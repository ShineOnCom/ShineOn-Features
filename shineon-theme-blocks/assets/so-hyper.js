var dr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Yo(Re) {
  return Re && Re.__esModule && Object.prototype.hasOwnProperty.call(Re, "default") ? Re.default : Re;
}
function ip(Re) {
  if (Object.prototype.hasOwnProperty.call(Re, "__esModule")) return Re;
  var be = Re.default;
  if (typeof be == "function") {
    var ae = function k() {
      return this instanceof k ? Reflect.construct(be, arguments, this.constructor) : be.apply(this, arguments);
    };
    ae.prototype = be.prototype;
  } else ae = {};
  return Object.defineProperty(ae, "__esModule", { value: !0 }), Object.keys(Re).forEach(function(k) {
    var Z = Object.getOwnPropertyDescriptor(Re, k);
    Object.defineProperty(ae, k, Z.get ? Z : {
      enumerable: !0,
      get: function() {
        return Re[k];
      }
    });
  }), ae;
}
var El = { exports: {} }, Es = {}, xl = { exports: {} }, Qt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ic;
function np() {
  if (ic) return Qt;
  ic = 1;
  var Re = Symbol.for("react.element"), be = Symbol.for("react.portal"), ae = Symbol.for("react.fragment"), k = Symbol.for("react.strict_mode"), Z = Symbol.for("react.profiler"), _ = Symbol.for("react.provider"), M = Symbol.for("react.context"), x = Symbol.for("react.forward_ref"), y = Symbol.for("react.suspense"), E = Symbol.for("react.memo"), c = Symbol.for("react.lazy"), u = Symbol.iterator;
  function l(we) {
    return we === null || typeof we != "object" ? null : (we = u && we[u] || we["@@iterator"], typeof we == "function" ? we : null);
  }
  var a = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, n = Object.assign, d = {};
  function g(we, ke, Me) {
    this.props = we, this.context = ke, this.refs = d, this.updater = Me || a;
  }
  g.prototype.isReactComponent = {}, g.prototype.setState = function(we, ke) {
    if (typeof we != "object" && typeof we != "function" && we != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, we, ke, "setState");
  }, g.prototype.forceUpdate = function(we) {
    this.updater.enqueueForceUpdate(this, we, "forceUpdate");
  };
  function h() {
  }
  h.prototype = g.prototype;
  function m(we, ke, Me) {
    this.props = we, this.context = ke, this.refs = d, this.updater = Me || a;
  }
  var s = m.prototype = new h();
  s.constructor = m, n(s, g.prototype), s.isPureReactComponent = !0;
  var b = Array.isArray, S = Object.prototype.hasOwnProperty, o = { current: null }, A = { key: !0, ref: !0, __self: !0, __source: !0 };
  function T(we, ke, Me) {
    var fe, xe = {}, Ee = null, Pe = null;
    if (ke != null) for (fe in ke.ref !== void 0 && (Pe = ke.ref), ke.key !== void 0 && (Ee = "" + ke.key), ke) S.call(ke, fe) && !A.hasOwnProperty(fe) && (xe[fe] = ke[fe]);
    var Ue = arguments.length - 2;
    if (Ue === 1) xe.children = Me;
    else if (1 < Ue) {
      for (var He = Array(Ue), We = 0; We < Ue; We++) He[We] = arguments[We + 2];
      xe.children = He;
    }
    if (we && we.defaultProps) for (fe in Ue = we.defaultProps, Ue) xe[fe] === void 0 && (xe[fe] = Ue[fe]);
    return { $$typeof: Re, type: we, key: Ee, ref: Pe, props: xe, _owner: o.current };
  }
  function I(we, ke) {
    return { $$typeof: Re, type: we.type, key: ke, ref: we.ref, props: we.props, _owner: we._owner };
  }
  function L(we) {
    return typeof we == "object" && we !== null && we.$$typeof === Re;
  }
  function z(we) {
    var ke = { "=": "=0", ":": "=2" };
    return "$" + we.replace(/[=:]/g, function(Me) {
      return ke[Me];
    });
  }
  var U = /\/+/g;
  function J(we, ke) {
    return typeof we == "object" && we !== null && we.key != null ? z("" + we.key) : ke.toString(36);
  }
  function F(we, ke, Me, fe, xe) {
    var Ee = typeof we;
    (Ee === "undefined" || Ee === "boolean") && (we = null);
    var Pe = !1;
    if (we === null) Pe = !0;
    else switch (Ee) {
      case "string":
      case "number":
        Pe = !0;
        break;
      case "object":
        switch (we.$$typeof) {
          case Re:
          case be:
            Pe = !0;
        }
    }
    if (Pe) return Pe = we, xe = xe(Pe), we = fe === "" ? "." + J(Pe, 0) : fe, b(xe) ? (Me = "", we != null && (Me = we.replace(U, "$&/") + "/"), F(xe, ke, Me, "", function(We) {
      return We;
    })) : xe != null && (L(xe) && (xe = I(xe, Me + (!xe.key || Pe && Pe.key === xe.key ? "" : ("" + xe.key).replace(U, "$&/") + "/") + we)), ke.push(xe)), 1;
    if (Pe = 0, fe = fe === "" ? "." : fe + ":", b(we)) for (var Ue = 0; Ue < we.length; Ue++) {
      Ee = we[Ue];
      var He = fe + J(Ee, Ue);
      Pe += F(Ee, ke, Me, He, xe);
    }
    else if (He = l(we), typeof He == "function") for (we = He.call(we), Ue = 0; !(Ee = we.next()).done; ) Ee = Ee.value, He = fe + J(Ee, Ue++), Pe += F(Ee, ke, Me, He, xe);
    else if (Ee === "object") throw ke = String(we), Error("Objects are not valid as a React child (found: " + (ke === "[object Object]" ? "object with keys {" + Object.keys(we).join(", ") + "}" : ke) + "). If you meant to render a collection of children, use an array instead.");
    return Pe;
  }
  function oe(we, ke, Me) {
    if (we == null) return we;
    var fe = [], xe = 0;
    return F(we, fe, "", "", function(Ee) {
      return ke.call(Me, Ee, xe++);
    }), fe;
  }
  function ee(we) {
    if (we._status === -1) {
      var ke = we._result;
      ke = ke(), ke.then(function(Me) {
        (we._status === 0 || we._status === -1) && (we._status = 1, we._result = Me);
      }, function(Me) {
        (we._status === 0 || we._status === -1) && (we._status = 2, we._result = Me);
      }), we._status === -1 && (we._status = 0, we._result = ke);
    }
    if (we._status === 1) return we._result.default;
    throw we._result;
  }
  var ie = { current: null }, W = { transition: null }, Q = { ReactCurrentDispatcher: ie, ReactCurrentBatchConfig: W, ReactCurrentOwner: o };
  function de() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return Qt.Children = { map: oe, forEach: function(we, ke, Me) {
    oe(we, function() {
      ke.apply(this, arguments);
    }, Me);
  }, count: function(we) {
    var ke = 0;
    return oe(we, function() {
      ke++;
    }), ke;
  }, toArray: function(we) {
    return oe(we, function(ke) {
      return ke;
    }) || [];
  }, only: function(we) {
    if (!L(we)) throw Error("React.Children.only expected to receive a single React element child.");
    return we;
  } }, Qt.Component = g, Qt.Fragment = ae, Qt.Profiler = Z, Qt.PureComponent = m, Qt.StrictMode = k, Qt.Suspense = y, Qt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Q, Qt.act = de, Qt.cloneElement = function(we, ke, Me) {
    if (we == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + we + ".");
    var fe = n({}, we.props), xe = we.key, Ee = we.ref, Pe = we._owner;
    if (ke != null) {
      if (ke.ref !== void 0 && (Ee = ke.ref, Pe = o.current), ke.key !== void 0 && (xe = "" + ke.key), we.type && we.type.defaultProps) var Ue = we.type.defaultProps;
      for (He in ke) S.call(ke, He) && !A.hasOwnProperty(He) && (fe[He] = ke[He] === void 0 && Ue !== void 0 ? Ue[He] : ke[He]);
    }
    var He = arguments.length - 2;
    if (He === 1) fe.children = Me;
    else if (1 < He) {
      Ue = Array(He);
      for (var We = 0; We < He; We++) Ue[We] = arguments[We + 2];
      fe.children = Ue;
    }
    return { $$typeof: Re, type: we.type, key: xe, ref: Ee, props: fe, _owner: Pe };
  }, Qt.createContext = function(we) {
    return we = { $$typeof: M, _currentValue: we, _currentValue2: we, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, we.Provider = { $$typeof: _, _context: we }, we.Consumer = we;
  }, Qt.createElement = T, Qt.createFactory = function(we) {
    var ke = T.bind(null, we);
    return ke.type = we, ke;
  }, Qt.createRef = function() {
    return { current: null };
  }, Qt.forwardRef = function(we) {
    return { $$typeof: x, render: we };
  }, Qt.isValidElement = L, Qt.lazy = function(we) {
    return { $$typeof: c, _payload: { _status: -1, _result: we }, _init: ee };
  }, Qt.memo = function(we, ke) {
    return { $$typeof: E, type: we, compare: ke === void 0 ? null : ke };
  }, Qt.startTransition = function(we) {
    var ke = W.transition;
    W.transition = {};
    try {
      we();
    } finally {
      W.transition = ke;
    }
  }, Qt.unstable_act = de, Qt.useCallback = function(we, ke) {
    return ie.current.useCallback(we, ke);
  }, Qt.useContext = function(we) {
    return ie.current.useContext(we);
  }, Qt.useDebugValue = function() {
  }, Qt.useDeferredValue = function(we) {
    return ie.current.useDeferredValue(we);
  }, Qt.useEffect = function(we, ke) {
    return ie.current.useEffect(we, ke);
  }, Qt.useId = function() {
    return ie.current.useId();
  }, Qt.useImperativeHandle = function(we, ke, Me) {
    return ie.current.useImperativeHandle(we, ke, Me);
  }, Qt.useInsertionEffect = function(we, ke) {
    return ie.current.useInsertionEffect(we, ke);
  }, Qt.useLayoutEffect = function(we, ke) {
    return ie.current.useLayoutEffect(we, ke);
  }, Qt.useMemo = function(we, ke) {
    return ie.current.useMemo(we, ke);
  }, Qt.useReducer = function(we, ke, Me) {
    return ie.current.useReducer(we, ke, Me);
  }, Qt.useRef = function(we) {
    return ie.current.useRef(we);
  }, Qt.useState = function(we) {
    return ie.current.useState(we);
  }, Qt.useSyncExternalStore = function(we, ke, Me) {
    return ie.current.useSyncExternalStore(we, ke, Me);
  }, Qt.useTransition = function() {
    return ie.current.useTransition();
  }, Qt.version = "18.3.1", Qt;
}
var nc;
function tf() {
  return nc || (nc = 1, xl.exports = np()), xl.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ac;
function ap() {
  if (ac) return Es;
  ac = 1;
  var Re = tf(), be = Symbol.for("react.element"), ae = Symbol.for("react.fragment"), k = Object.prototype.hasOwnProperty, Z = Re.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, _ = { key: !0, ref: !0, __self: !0, __source: !0 };
  function M(x, y, E) {
    var c, u = {}, l = null, a = null;
    E !== void 0 && (l = "" + E), y.key !== void 0 && (l = "" + y.key), y.ref !== void 0 && (a = y.ref);
    for (c in y) k.call(y, c) && !_.hasOwnProperty(c) && (u[c] = y[c]);
    if (x && x.defaultProps) for (c in y = x.defaultProps, y) u[c] === void 0 && (u[c] = y[c]);
    return { $$typeof: be, type: x, key: l, ref: a, props: u, _owner: Z.current };
  }
  return Es.Fragment = ae, Es.jsx = M, Es.jsxs = M, Es;
}
var sc;
function sp() {
  return sc || (sc = 1, El.exports = ap()), El.exports;
}
var pt = sp(), Kt = tf();
const ga = /* @__PURE__ */ Yo(Kt);
var Fo = {}, Cl = { exports: {} }, pi = {}, kl = { exports: {} }, Al = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oc;
function op() {
  return oc || (oc = 1, function(Re) {
    function be(W, Q) {
      var de = W.length;
      W.push(Q);
      e: for (; 0 < de; ) {
        var we = de - 1 >>> 1, ke = W[we];
        if (0 < Z(ke, Q)) W[we] = Q, W[de] = ke, de = we;
        else break e;
      }
    }
    function ae(W) {
      return W.length === 0 ? null : W[0];
    }
    function k(W) {
      if (W.length === 0) return null;
      var Q = W[0], de = W.pop();
      if (de !== Q) {
        W[0] = de;
        e: for (var we = 0, ke = W.length, Me = ke >>> 1; we < Me; ) {
          var fe = 2 * (we + 1) - 1, xe = W[fe], Ee = fe + 1, Pe = W[Ee];
          if (0 > Z(xe, de)) Ee < ke && 0 > Z(Pe, xe) ? (W[we] = Pe, W[Ee] = de, we = Ee) : (W[we] = xe, W[fe] = de, we = fe);
          else if (Ee < ke && 0 > Z(Pe, de)) W[we] = Pe, W[Ee] = de, we = Ee;
          else break e;
        }
      }
      return Q;
    }
    function Z(W, Q) {
      var de = W.sortIndex - Q.sortIndex;
      return de !== 0 ? de : W.id - Q.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var _ = performance;
      Re.unstable_now = function() {
        return _.now();
      };
    } else {
      var M = Date, x = M.now();
      Re.unstable_now = function() {
        return M.now() - x;
      };
    }
    var y = [], E = [], c = 1, u = null, l = 3, a = !1, n = !1, d = !1, g = typeof setTimeout == "function" ? setTimeout : null, h = typeof clearTimeout == "function" ? clearTimeout : null, m = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function s(W) {
      for (var Q = ae(E); Q !== null; ) {
        if (Q.callback === null) k(E);
        else if (Q.startTime <= W) k(E), Q.sortIndex = Q.expirationTime, be(y, Q);
        else break;
        Q = ae(E);
      }
    }
    function b(W) {
      if (d = !1, s(W), !n) if (ae(y) !== null) n = !0, ee(S);
      else {
        var Q = ae(E);
        Q !== null && ie(b, Q.startTime - W);
      }
    }
    function S(W, Q) {
      n = !1, d && (d = !1, h(T), T = -1), a = !0;
      var de = l;
      try {
        for (s(Q), u = ae(y); u !== null && (!(u.expirationTime > Q) || W && !z()); ) {
          var we = u.callback;
          if (typeof we == "function") {
            u.callback = null, l = u.priorityLevel;
            var ke = we(u.expirationTime <= Q);
            Q = Re.unstable_now(), typeof ke == "function" ? u.callback = ke : u === ae(y) && k(y), s(Q);
          } else k(y);
          u = ae(y);
        }
        if (u !== null) var Me = !0;
        else {
          var fe = ae(E);
          fe !== null && ie(b, fe.startTime - Q), Me = !1;
        }
        return Me;
      } finally {
        u = null, l = de, a = !1;
      }
    }
    var o = !1, A = null, T = -1, I = 5, L = -1;
    function z() {
      return !(Re.unstable_now() - L < I);
    }
    function U() {
      if (A !== null) {
        var W = Re.unstable_now();
        L = W;
        var Q = !0;
        try {
          Q = A(!0, W);
        } finally {
          Q ? J() : (o = !1, A = null);
        }
      } else o = !1;
    }
    var J;
    if (typeof m == "function") J = function() {
      m(U);
    };
    else if (typeof MessageChannel < "u") {
      var F = new MessageChannel(), oe = F.port2;
      F.port1.onmessage = U, J = function() {
        oe.postMessage(null);
      };
    } else J = function() {
      g(U, 0);
    };
    function ee(W) {
      A = W, o || (o = !0, J());
    }
    function ie(W, Q) {
      T = g(function() {
        W(Re.unstable_now());
      }, Q);
    }
    Re.unstable_IdlePriority = 5, Re.unstable_ImmediatePriority = 1, Re.unstable_LowPriority = 4, Re.unstable_NormalPriority = 3, Re.unstable_Profiling = null, Re.unstable_UserBlockingPriority = 2, Re.unstable_cancelCallback = function(W) {
      W.callback = null;
    }, Re.unstable_continueExecution = function() {
      n || a || (n = !0, ee(S));
    }, Re.unstable_forceFrameRate = function(W) {
      0 > W || 125 < W ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < W ? Math.floor(1e3 / W) : 5;
    }, Re.unstable_getCurrentPriorityLevel = function() {
      return l;
    }, Re.unstable_getFirstCallbackNode = function() {
      return ae(y);
    }, Re.unstable_next = function(W) {
      switch (l) {
        case 1:
        case 2:
        case 3:
          var Q = 3;
          break;
        default:
          Q = l;
      }
      var de = l;
      l = Q;
      try {
        return W();
      } finally {
        l = de;
      }
    }, Re.unstable_pauseExecution = function() {
    }, Re.unstable_requestPaint = function() {
    }, Re.unstable_runWithPriority = function(W, Q) {
      switch (W) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          W = 3;
      }
      var de = l;
      l = W;
      try {
        return Q();
      } finally {
        l = de;
      }
    }, Re.unstable_scheduleCallback = function(W, Q, de) {
      var we = Re.unstable_now();
      switch (typeof de == "object" && de !== null ? (de = de.delay, de = typeof de == "number" && 0 < de ? we + de : we) : de = we, W) {
        case 1:
          var ke = -1;
          break;
        case 2:
          ke = 250;
          break;
        case 5:
          ke = 1073741823;
          break;
        case 4:
          ke = 1e4;
          break;
        default:
          ke = 5e3;
      }
      return ke = de + ke, W = { id: c++, callback: Q, priorityLevel: W, startTime: de, expirationTime: ke, sortIndex: -1 }, de > we ? (W.sortIndex = de, be(E, W), ae(y) === null && W === ae(E) && (d ? (h(T), T = -1) : d = !0, ie(b, de - we))) : (W.sortIndex = ke, be(y, W), n || a || (n = !0, ee(S))), W;
    }, Re.unstable_shouldYield = z, Re.unstable_wrapCallback = function(W) {
      var Q = l;
      return function() {
        var de = l;
        l = Q;
        try {
          return W.apply(this, arguments);
        } finally {
          l = de;
        }
      };
    };
  }(Al)), Al;
}
var uc;
function up() {
  return uc || (uc = 1, kl.exports = op()), kl.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lc;
function lp() {
  if (lc) return pi;
  lc = 1;
  var Re = tf(), be = up();
  function ae(t) {
    for (var i = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, w = 1; w < arguments.length; w++) i += "&args[]=" + encodeURIComponent(arguments[w]);
    return "Minified React error #" + t + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var k = /* @__PURE__ */ new Set(), Z = {};
  function _(t, i) {
    M(t, i), M(t + "Capture", i);
  }
  function M(t, i) {
    for (Z[t] = i, t = 0; t < i.length; t++) k.add(i[t]);
  }
  var x = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), y = Object.prototype.hasOwnProperty, E = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, c = {}, u = {};
  function l(t) {
    return y.call(u, t) ? !0 : y.call(c, t) ? !1 : E.test(t) ? u[t] = !0 : (c[t] = !0, !1);
  }
  function a(t, i, w, N) {
    if (w !== null && w.type === 0) return !1;
    switch (typeof i) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return N ? !1 : w !== null ? !w.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
      default:
        return !1;
    }
  }
  function n(t, i, w, N) {
    if (i === null || typeof i > "u" || a(t, i, w, N)) return !0;
    if (N) return !1;
    if (w !== null) switch (w.type) {
      case 3:
        return !i;
      case 4:
        return i === !1;
      case 5:
        return isNaN(i);
      case 6:
        return isNaN(i) || 1 > i;
    }
    return !1;
  }
  function d(t, i, w, N, ne, ge, ze) {
    this.acceptsBooleans = i === 2 || i === 3 || i === 4, this.attributeName = N, this.attributeNamespace = ne, this.mustUseProperty = w, this.propertyName = t, this.type = i, this.sanitizeURL = ge, this.removeEmptyString = ze;
  }
  var g = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    g[t] = new d(t, 0, !1, t, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(t) {
    var i = t[0];
    g[i] = new d(i, 1, !1, t[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
    g[t] = new d(t, 2, !1, t.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
    g[t] = new d(t, 2, !1, t, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    g[t] = new d(t, 3, !1, t.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(t) {
    g[t] = new d(t, 3, !0, t, null, !1, !1);
  }), ["capture", "download"].forEach(function(t) {
    g[t] = new d(t, 4, !1, t, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(t) {
    g[t] = new d(t, 6, !1, t, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(t) {
    g[t] = new d(t, 5, !1, t.toLowerCase(), null, !1, !1);
  });
  var h = /[\-:]([a-z])/g;
  function m(t) {
    return t[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var i = t.replace(
      h,
      m
    );
    g[i] = new d(i, 1, !1, t, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var i = t.replace(h, m);
    g[i] = new d(i, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
    var i = t.replace(h, m);
    g[i] = new d(i, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(t) {
    g[t] = new d(t, 1, !1, t.toLowerCase(), null, !1, !1);
  }), g.xlinkHref = new d("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(t) {
    g[t] = new d(t, 1, !1, t.toLowerCase(), null, !0, !0);
  });
  function s(t, i, w, N) {
    var ne = g.hasOwnProperty(i) ? g[i] : null;
    (ne !== null ? ne.type !== 0 : N || !(2 < i.length) || i[0] !== "o" && i[0] !== "O" || i[1] !== "n" && i[1] !== "N") && (n(i, w, ne, N) && (w = null), N || ne === null ? l(i) && (w === null ? t.removeAttribute(i) : t.setAttribute(i, "" + w)) : ne.mustUseProperty ? t[ne.propertyName] = w === null ? ne.type === 3 ? !1 : "" : w : (i = ne.attributeName, N = ne.attributeNamespace, w === null ? t.removeAttribute(i) : (ne = ne.type, w = ne === 3 || ne === 4 && w === !0 ? "" : "" + w, N ? t.setAttributeNS(N, i, w) : t.setAttribute(i, w))));
  }
  var b = Re.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, S = Symbol.for("react.element"), o = Symbol.for("react.portal"), A = Symbol.for("react.fragment"), T = Symbol.for("react.strict_mode"), I = Symbol.for("react.profiler"), L = Symbol.for("react.provider"), z = Symbol.for("react.context"), U = Symbol.for("react.forward_ref"), J = Symbol.for("react.suspense"), F = Symbol.for("react.suspense_list"), oe = Symbol.for("react.memo"), ee = Symbol.for("react.lazy"), ie = Symbol.for("react.offscreen"), W = Symbol.iterator;
  function Q(t) {
    return t === null || typeof t != "object" ? null : (t = W && t[W] || t["@@iterator"], typeof t == "function" ? t : null);
  }
  var de = Object.assign, we;
  function ke(t) {
    if (we === void 0) try {
      throw Error();
    } catch (w) {
      var i = w.stack.trim().match(/\n( *(at )?)/);
      we = i && i[1] || "";
    }
    return `
` + we + t;
  }
  var Me = !1;
  function fe(t, i) {
    if (!t || Me) return "";
    Me = !0;
    var w = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (i) if (i = function() {
        throw Error();
      }, Object.defineProperty(i.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(i, []);
        } catch (ft) {
          var N = ft;
        }
        Reflect.construct(t, [], i);
      } else {
        try {
          i.call();
        } catch (ft) {
          N = ft;
        }
        t.call(i.prototype);
      }
      else {
        try {
          throw Error();
        } catch (ft) {
          N = ft;
        }
        t();
      }
    } catch (ft) {
      if (ft && N && typeof ft.stack == "string") {
        for (var ne = ft.stack.split(`
`), ge = N.stack.split(`
`), ze = ne.length - 1, Qe = ge.length - 1; 1 <= ze && 0 <= Qe && ne[ze] !== ge[Qe]; ) Qe--;
        for (; 1 <= ze && 0 <= Qe; ze--, Qe--) if (ne[ze] !== ge[Qe]) {
          if (ze !== 1 || Qe !== 1)
            do
              if (ze--, Qe--, 0 > Qe || ne[ze] !== ge[Qe]) {
                var rt = `
` + ne[ze].replace(" at new ", " at ");
                return t.displayName && rt.includes("<anonymous>") && (rt = rt.replace("<anonymous>", t.displayName)), rt;
              }
            while (1 <= ze && 0 <= Qe);
          break;
        }
      }
    } finally {
      Me = !1, Error.prepareStackTrace = w;
    }
    return (t = t ? t.displayName || t.name : "") ? ke(t) : "";
  }
  function xe(t) {
    switch (t.tag) {
      case 5:
        return ke(t.type);
      case 16:
        return ke("Lazy");
      case 13:
        return ke("Suspense");
      case 19:
        return ke("SuspenseList");
      case 0:
      case 2:
      case 15:
        return t = fe(t.type, !1), t;
      case 11:
        return t = fe(t.type.render, !1), t;
      case 1:
        return t = fe(t.type, !0), t;
      default:
        return "";
    }
  }
  function Ee(t) {
    if (t == null) return null;
    if (typeof t == "function") return t.displayName || t.name || null;
    if (typeof t == "string") return t;
    switch (t) {
      case A:
        return "Fragment";
      case o:
        return "Portal";
      case I:
        return "Profiler";
      case T:
        return "StrictMode";
      case J:
        return "Suspense";
      case F:
        return "SuspenseList";
    }
    if (typeof t == "object") switch (t.$$typeof) {
      case z:
        return (t.displayName || "Context") + ".Consumer";
      case L:
        return (t._context.displayName || "Context") + ".Provider";
      case U:
        var i = t.render;
        return t = t.displayName, t || (t = i.displayName || i.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
      case oe:
        return i = t.displayName || null, i !== null ? i : Ee(t.type) || "Memo";
      case ee:
        i = t._payload, t = t._init;
        try {
          return Ee(t(i));
        } catch {
        }
    }
    return null;
  }
  function Pe(t) {
    var i = t.type;
    switch (t.tag) {
      case 24:
        return "Cache";
      case 9:
        return (i.displayName || "Context") + ".Consumer";
      case 10:
        return (i._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return t = i.render, t = t.displayName || t.name || "", i.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return i;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Ee(i);
      case 8:
        return i === T ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof i == "function") return i.displayName || i.name || null;
        if (typeof i == "string") return i;
    }
    return null;
  }
  function Ue(t) {
    switch (typeof t) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return t;
      case "object":
        return t;
      default:
        return "";
    }
  }
  function He(t) {
    var i = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (i === "checkbox" || i === "radio");
  }
  function We(t) {
    var i = He(t) ? "checked" : "value", w = Object.getOwnPropertyDescriptor(t.constructor.prototype, i), N = "" + t[i];
    if (!t.hasOwnProperty(i) && typeof w < "u" && typeof w.get == "function" && typeof w.set == "function") {
      var ne = w.get, ge = w.set;
      return Object.defineProperty(t, i, { configurable: !0, get: function() {
        return ne.call(this);
      }, set: function(ze) {
        N = "" + ze, ge.call(this, ze);
      } }), Object.defineProperty(t, i, { enumerable: w.enumerable }), { getValue: function() {
        return N;
      }, setValue: function(ze) {
        N = "" + ze;
      }, stopTracking: function() {
        t._valueTracker = null, delete t[i];
      } };
    }
  }
  function Ze(t) {
    t._valueTracker || (t._valueTracker = We(t));
  }
  function $e(t) {
    if (!t) return !1;
    var i = t._valueTracker;
    if (!i) return !0;
    var w = i.getValue(), N = "";
    return t && (N = He(t) ? t.checked ? "true" : "false" : t.value), t = N, t !== w ? (i.setValue(t), !0) : !1;
  }
  function Ve(t) {
    if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null;
    try {
      return t.activeElement || t.body;
    } catch {
      return t.body;
    }
  }
  function Ge(t, i) {
    var w = i.checked;
    return de({}, i, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: w ?? t._wrapperState.initialChecked });
  }
  function Ie(t, i) {
    var w = i.defaultValue == null ? "" : i.defaultValue, N = i.checked != null ? i.checked : i.defaultChecked;
    w = Ue(i.value != null ? i.value : w), t._wrapperState = { initialChecked: N, initialValue: w, controlled: i.type === "checkbox" || i.type === "radio" ? i.checked != null : i.value != null };
  }
  function De(t, i) {
    i = i.checked, i != null && s(t, "checked", i, !1);
  }
  function Ne(t, i) {
    De(t, i);
    var w = Ue(i.value), N = i.type;
    if (w != null) N === "number" ? (w === 0 && t.value === "" || t.value != w) && (t.value = "" + w) : t.value !== "" + w && (t.value = "" + w);
    else if (N === "submit" || N === "reset") {
      t.removeAttribute("value");
      return;
    }
    i.hasOwnProperty("value") ? re(t, i.type, w) : i.hasOwnProperty("defaultValue") && re(t, i.type, Ue(i.defaultValue)), i.checked == null && i.defaultChecked != null && (t.defaultChecked = !!i.defaultChecked);
  }
  function _e(t, i, w) {
    if (i.hasOwnProperty("value") || i.hasOwnProperty("defaultValue")) {
      var N = i.type;
      if (!(N !== "submit" && N !== "reset" || i.value !== void 0 && i.value !== null)) return;
      i = "" + t._wrapperState.initialValue, w || i === t.value || (t.value = i), t.defaultValue = i;
    }
    w = t.name, w !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, w !== "" && (t.name = w);
  }
  function re(t, i, w) {
    (i !== "number" || Ve(t.ownerDocument) !== t) && (w == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + w && (t.defaultValue = "" + w));
  }
  var $ = Array.isArray;
  function Ce(t, i, w, N) {
    if (t = t.options, i) {
      i = {};
      for (var ne = 0; ne < w.length; ne++) i["$" + w[ne]] = !0;
      for (w = 0; w < t.length; w++) ne = i.hasOwnProperty("$" + t[w].value), t[w].selected !== ne && (t[w].selected = ne), ne && N && (t[w].defaultSelected = !0);
    } else {
      for (w = "" + Ue(w), i = null, ne = 0; ne < t.length; ne++) {
        if (t[ne].value === w) {
          t[ne].selected = !0, N && (t[ne].defaultSelected = !0);
          return;
        }
        i !== null || t[ne].disabled || (i = t[ne]);
      }
      i !== null && (i.selected = !0);
    }
  }
  function ve(t, i) {
    if (i.dangerouslySetInnerHTML != null) throw Error(ae(91));
    return de({}, i, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue });
  }
  function Y(t, i) {
    var w = i.value;
    if (w == null) {
      if (w = i.children, i = i.defaultValue, w != null) {
        if (i != null) throw Error(ae(92));
        if ($(w)) {
          if (1 < w.length) throw Error(ae(93));
          w = w[0];
        }
        i = w;
      }
      i == null && (i = ""), w = i;
    }
    t._wrapperState = { initialValue: Ue(w) };
  }
  function G(t, i) {
    var w = Ue(i.value), N = Ue(i.defaultValue);
    w != null && (w = "" + w, w !== t.value && (t.value = w), i.defaultValue == null && t.defaultValue !== w && (t.defaultValue = w)), N != null && (t.defaultValue = "" + N);
  }
  function Ae(t) {
    var i = t.textContent;
    i === t._wrapperState.initialValue && i !== "" && i !== null && (t.value = i);
  }
  function e(t) {
    switch (t) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function r(t, i) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? e(i) : t === "http://www.w3.org/2000/svg" && i === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t;
  }
  var f, C = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(i, w, N, ne) {
      MSApp.execUnsafeLocalFunction(function() {
        return t(i, w, N, ne);
      });
    } : t;
  }(function(t, i) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = i;
    else {
      for (f = f || document.createElement("div"), f.innerHTML = "<svg>" + i.valueOf().toString() + "</svg>", i = f.firstChild; t.firstChild; ) t.removeChild(t.firstChild);
      for (; i.firstChild; ) t.appendChild(i.firstChild);
    }
  });
  function R(t, i) {
    if (i) {
      var w = t.firstChild;
      if (w && w === t.lastChild && w.nodeType === 3) {
        w.nodeValue = i;
        return;
      }
    }
    t.textContent = i;
  }
  var B = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, j = ["Webkit", "ms", "Moz", "O"];
  Object.keys(B).forEach(function(t) {
    j.forEach(function(i) {
      i = i + t.charAt(0).toUpperCase() + t.substring(1), B[i] = B[t];
    });
  });
  function H(t, i, w) {
    return i == null || typeof i == "boolean" || i === "" ? "" : w || typeof i != "number" || i === 0 || B.hasOwnProperty(t) && B[t] ? ("" + i).trim() : i + "px";
  }
  function X(t, i) {
    t = t.style;
    for (var w in i) if (i.hasOwnProperty(w)) {
      var N = w.indexOf("--") === 0, ne = H(w, i[w], N);
      w === "float" && (w = "cssFloat"), N ? t.setProperty(w, ne) : t[w] = ne;
    }
  }
  var ue = de({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function pe(t, i) {
    if (i) {
      if (ue[t] && (i.children != null || i.dangerouslySetInnerHTML != null)) throw Error(ae(137, t));
      if (i.dangerouslySetInnerHTML != null) {
        if (i.children != null) throw Error(ae(60));
        if (typeof i.dangerouslySetInnerHTML != "object" || !("__html" in i.dangerouslySetInnerHTML)) throw Error(ae(61));
      }
      if (i.style != null && typeof i.style != "object") throw Error(ae(62));
    }
  }
  function P(t, i) {
    if (t.indexOf("-") === -1) return typeof i.is == "string";
    switch (t) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var q = null;
  function K(t) {
    return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t;
  }
  var ye = null, te = null, he = null;
  function D(t) {
    if (t = us(t)) {
      if (typeof ye != "function") throw Error(ae(280));
      var i = t.stateNode;
      i && (i = Js(i), ye(t.stateNode, t.type, i));
    }
  }
  function Se(t) {
    te ? he ? he.push(t) : he = [t] : te = t;
  }
  function le() {
    if (te) {
      var t = te, i = he;
      if (he = te = null, D(t), i) for (t = 0; t < i.length; t++) D(i[t]);
    }
  }
  function v(t, i) {
    return t(i);
  }
  function se() {
  }
  var me = !1;
  function O(t, i, w) {
    if (me) return t(i, w);
    me = !0;
    try {
      return v(t, i, w);
    } finally {
      me = !1, (te !== null || he !== null) && (se(), le());
    }
  }
  function ce(t, i) {
    var w = t.stateNode;
    if (w === null) return null;
    var N = Js(w);
    if (N === null) return null;
    w = N[i];
    e: switch (i) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (N = !N.disabled) || (t = t.type, N = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !N;
        break e;
      default:
        t = !1;
    }
    if (t) return null;
    if (w && typeof w != "function") throw Error(ae(231, i, typeof w));
    return w;
  }
  var Oe = !1;
  if (x) try {
    var Be = {};
    Object.defineProperty(Be, "passive", { get: function() {
      Oe = !0;
    } }), window.addEventListener("test", Be, Be), window.removeEventListener("test", Be, Be);
  } catch {
    Oe = !1;
  }
  function je(t, i, w, N, ne, ge, ze, Qe, rt) {
    var ft = Array.prototype.slice.call(arguments, 3);
    try {
      i.apply(w, ft);
    } catch (yt) {
      this.onError(yt);
    }
  }
  var Fe = !1, Ye = null, Ke = !1, et = null, Je = { onError: function(t) {
    Fe = !0, Ye = t;
  } };
  function nt(t, i, w, N, ne, ge, ze, Qe, rt) {
    Fe = !1, Ye = null, je.apply(Je, arguments);
  }
  function dt(t, i, w, N, ne, ge, ze, Qe, rt) {
    if (nt.apply(this, arguments), Fe) {
      if (Fe) {
        var ft = Ye;
        Fe = !1, Ye = null;
      } else throw Error(ae(198));
      Ke || (Ke = !0, et = ft);
    }
  }
  function vt(t) {
    var i = t, w = t;
    if (t.alternate) for (; i.return; ) i = i.return;
    else {
      t = i;
      do
        i = t, (i.flags & 4098) !== 0 && (w = i.return), t = i.return;
      while (t);
    }
    return i.tag === 3 ? w : null;
  }
  function bt(t) {
    if (t.tag === 13) {
      var i = t.memoizedState;
      if (i === null && (t = t.alternate, t !== null && (i = t.memoizedState)), i !== null) return i.dehydrated;
    }
    return null;
  }
  function At(t) {
    if (vt(t) !== t) throw Error(ae(188));
  }
  function ot(t) {
    var i = t.alternate;
    if (!i) {
      if (i = vt(t), i === null) throw Error(ae(188));
      return i !== t ? null : t;
    }
    for (var w = t, N = i; ; ) {
      var ne = w.return;
      if (ne === null) break;
      var ge = ne.alternate;
      if (ge === null) {
        if (N = ne.return, N !== null) {
          w = N;
          continue;
        }
        break;
      }
      if (ne.child === ge.child) {
        for (ge = ne.child; ge; ) {
          if (ge === w) return At(ne), t;
          if (ge === N) return At(ne), i;
          ge = ge.sibling;
        }
        throw Error(ae(188));
      }
      if (w.return !== N.return) w = ne, N = ge;
      else {
        for (var ze = !1, Qe = ne.child; Qe; ) {
          if (Qe === w) {
            ze = !0, w = ne, N = ge;
            break;
          }
          if (Qe === N) {
            ze = !0, N = ne, w = ge;
            break;
          }
          Qe = Qe.sibling;
        }
        if (!ze) {
          for (Qe = ge.child; Qe; ) {
            if (Qe === w) {
              ze = !0, w = ge, N = ne;
              break;
            }
            if (Qe === N) {
              ze = !0, N = ge, w = ne;
              break;
            }
            Qe = Qe.sibling;
          }
          if (!ze) throw Error(ae(189));
        }
      }
      if (w.alternate !== N) throw Error(ae(190));
    }
    if (w.tag !== 3) throw Error(ae(188));
    return w.stateNode.current === w ? t : i;
  }
  function ht(t) {
    return t = ot(t), t !== null ? gt(t) : null;
  }
  function gt(t) {
    if (t.tag === 5 || t.tag === 6) return t;
    for (t = t.child; t !== null; ) {
      var i = gt(t);
      if (i !== null) return i;
      t = t.sibling;
    }
    return null;
  }
  var Ct = be.unstable_scheduleCallback, xt = be.unstable_cancelCallback, Ot = be.unstable_shouldYield, Nt = be.unstable_requestPaint, Mt = be.unstable_now, Gt = be.unstable_getCurrentPriorityLevel, Bt = be.unstable_ImmediatePriority, or = be.unstable_UserBlockingPriority, ar = be.unstable_NormalPriority, ur = be.unstable_LowPriority, hr = be.unstable_IdlePriority, wt = null, $t = null;
  function lr(t) {
    if ($t && typeof $t.onCommitFiberRoot == "function") try {
      $t.onCommitFiberRoot(wt, t, void 0, (t.current.flags & 128) === 128);
    } catch {
    }
  }
  var tr = Math.clz32 ? Math.clz32 : ii, Xr = Math.log, gi = Math.LN2;
  function ii(t) {
    return t >>>= 0, t === 0 ? 32 : 31 - (Xr(t) / gi | 0) | 0;
  }
  var Br = 64, Er = 4194304;
  function kr(t) {
    switch (t & -t) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return t & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return t & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return t;
    }
  }
  function qr(t, i) {
    var w = t.pendingLanes;
    if (w === 0) return 0;
    var N = 0, ne = t.suspendedLanes, ge = t.pingedLanes, ze = w & 268435455;
    if (ze !== 0) {
      var Qe = ze & ~ne;
      Qe !== 0 ? N = kr(Qe) : (ge &= ze, ge !== 0 && (N = kr(ge)));
    } else ze = w & ~ne, ze !== 0 ? N = kr(ze) : ge !== 0 && (N = kr(ge));
    if (N === 0) return 0;
    if (i !== 0 && i !== N && (i & ne) === 0 && (ne = N & -N, ge = i & -i, ne >= ge || ne === 16 && (ge & 4194240) !== 0)) return i;
    if ((N & 4) !== 0 && (N |= w & 16), i = t.entangledLanes, i !== 0) for (t = t.entanglements, i &= N; 0 < i; ) w = 31 - tr(i), ne = 1 << w, N |= t[w], i &= ~ne;
    return N;
  }
  function yr(t, i) {
    switch (t) {
      case 1:
      case 2:
      case 4:
        return i + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Or(t, i) {
    for (var w = t.suspendedLanes, N = t.pingedLanes, ne = t.expirationTimes, ge = t.pendingLanes; 0 < ge; ) {
      var ze = 31 - tr(ge), Qe = 1 << ze, rt = ne[ze];
      rt === -1 ? ((Qe & w) === 0 || (Qe & N) !== 0) && (ne[ze] = yr(Qe, i)) : rt <= i && (t.expiredLanes |= Qe), ge &= ~Qe;
    }
  }
  function yn(t) {
    return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0;
  }
  function wn() {
    var t = Br;
    return Br <<= 1, (Br & 4194240) === 0 && (Br = 64), t;
  }
  function bn(t) {
    for (var i = [], w = 0; 31 > w; w++) i.push(t);
    return i;
  }
  function Yi(t, i, w) {
    t.pendingLanes |= i, i !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, i = 31 - tr(i), t[i] = w;
  }
  function ya(t, i) {
    var w = t.pendingLanes & ~i;
    t.pendingLanes = i, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= i, t.mutableReadLanes &= i, t.entangledLanes &= i, i = t.entanglements;
    var N = t.eventTimes;
    for (t = t.expirationTimes; 0 < w; ) {
      var ne = 31 - tr(w), ge = 1 << ne;
      i[ne] = 0, N[ne] = -1, t[ne] = -1, w &= ~ge;
    }
  }
  function Xi(t, i) {
    var w = t.entangledLanes |= i;
    for (t = t.entanglements; w; ) {
      var N = 31 - tr(w), ne = 1 << N;
      ne & i | t[N] & i && (t[N] |= i), w &= ~ne;
    }
  }
  var qt = 0;
  function qi(t) {
    return t &= -t, 1 < t ? 4 < t ? (t & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
  }
  var Qi, _i, ni, Vt, Qr, Kr = !1, zr = [], Fr = null, oi = null, ui = null, Di = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Map(), V = [], Te = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Le(t, i) {
    switch (t) {
      case "focusin":
      case "focusout":
        Fr = null;
        break;
      case "dragenter":
      case "dragleave":
        oi = null;
        break;
      case "mouseover":
      case "mouseout":
        ui = null;
        break;
      case "pointerover":
      case "pointerout":
        Di.delete(i.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        p.delete(i.pointerId);
    }
  }
  function Xe(t, i, w, N, ne, ge) {
    return t === null || t.nativeEvent !== ge ? (t = { blockedOn: i, domEventName: w, eventSystemFlags: N, nativeEvent: ge, targetContainers: [ne] }, i !== null && (i = us(i), i !== null && _i(i)), t) : (t.eventSystemFlags |= N, i = t.targetContainers, ne !== null && i.indexOf(ne) === -1 && i.push(ne), t);
  }
  function at(t, i, w, N, ne) {
    switch (i) {
      case "focusin":
        return Fr = Xe(Fr, t, i, w, N, ne), !0;
      case "dragenter":
        return oi = Xe(oi, t, i, w, N, ne), !0;
      case "mouseover":
        return ui = Xe(ui, t, i, w, N, ne), !0;
      case "pointerover":
        var ge = ne.pointerId;
        return Di.set(ge, Xe(Di.get(ge) || null, t, i, w, N, ne)), !0;
      case "gotpointercapture":
        return ge = ne.pointerId, p.set(ge, Xe(p.get(ge) || null, t, i, w, N, ne)), !0;
    }
    return !1;
  }
  function lt(t) {
    var i = ia(t.target);
    if (i !== null) {
      var w = vt(i);
      if (w !== null) {
        if (i = w.tag, i === 13) {
          if (i = bt(w), i !== null) {
            t.blockedOn = i, Qr(t.priority, function() {
              ni(w);
            });
            return;
          }
        } else if (i === 3 && w.stateNode.current.memoizedState.isDehydrated) {
          t.blockedOn = w.tag === 3 ? w.stateNode.containerInfo : null;
          return;
        }
      }
    }
    t.blockedOn = null;
  }
  function Et(t) {
    if (t.blockedOn !== null) return !1;
    for (var i = t.targetContainers; 0 < i.length; ) {
      var w = wa(t.domEventName, t.eventSystemFlags, i[0], t.nativeEvent);
      if (w === null) {
        w = t.nativeEvent;
        var N = new w.constructor(w.type, w);
        q = N, w.target.dispatchEvent(N), q = null;
      } else return i = us(w), i !== null && _i(i), t.blockedOn = w, !1;
      i.shift();
    }
    return !0;
  }
  function Tt(t, i, w) {
    Et(t) && w.delete(i);
  }
  function Yt() {
    Kr = !1, Fr !== null && Et(Fr) && (Fr = null), oi !== null && Et(oi) && (oi = null), ui !== null && Et(ui) && (ui = null), Di.forEach(Tt), p.forEach(Tt);
  }
  function zt(t, i) {
    t.blockedOn === i && (t.blockedOn = null, Kr || (Kr = !0, be.unstable_scheduleCallback(be.unstable_NormalPriority, Yt)));
  }
  function fr(t) {
    function i(ne) {
      return zt(ne, t);
    }
    if (0 < zr.length) {
      zt(zr[0], t);
      for (var w = 1; w < zr.length; w++) {
        var N = zr[w];
        N.blockedOn === t && (N.blockedOn = null);
      }
    }
    for (Fr !== null && zt(Fr, t), oi !== null && zt(oi, t), ui !== null && zt(ui, t), Di.forEach(i), p.forEach(i), w = 0; w < V.length; w++) N = V[w], N.blockedOn === t && (N.blockedOn = null);
    for (; 0 < V.length && (w = V[0], w.blockedOn === null); ) lt(w), w.blockedOn === null && V.shift();
  }
  var $r = b.ReactCurrentBatchConfig, Ci = !0;
  function Bi(t, i, w, N) {
    var ne = qt, ge = $r.transition;
    $r.transition = null;
    try {
      qt = 1, Ai(t, i, w, N);
    } finally {
      qt = ne, $r.transition = ge;
    }
  }
  function ki(t, i, w, N) {
    var ne = qt, ge = $r.transition;
    $r.transition = null;
    try {
      qt = 4, Ai(t, i, w, N);
    } finally {
      qt = ne, $r.transition = ge;
    }
  }
  function Ai(t, i, w, N) {
    if (Ci) {
      var ne = wa(t, i, w, N);
      if (ne === null) du(t, i, N, yi, w), Le(t, N);
      else if (at(ne, t, i, w, N)) N.stopPropagation();
      else if (Le(t, N), i & 4 && -1 < Te.indexOf(t)) {
        for (; ne !== null; ) {
          var ge = us(ne);
          if (ge !== null && Qi(ge), ge = wa(t, i, w, N), ge === null && du(t, i, N, yi, w), ge === ne) break;
          ne = ge;
        }
        ne !== null && N.stopPropagation();
      } else du(t, i, N, null, w);
    }
  }
  var yi = null;
  function wa(t, i, w, N) {
    if (yi = null, t = K(N), t = ia(t), t !== null) if (i = vt(t), i === null) t = null;
    else if (w = i.tag, w === 13) {
      if (t = bt(i), t !== null) return t;
      t = null;
    } else if (w === 3) {
      if (i.stateNode.current.memoizedState.isDehydrated) return i.tag === 3 ? i.stateNode.containerInfo : null;
      t = null;
    } else i !== t && (t = null);
    return yi = t, null;
  }
  function Yn(t) {
    switch (t) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Gt()) {
          case Bt:
            return 1;
          case or:
            return 4;
          case ar:
          case ur:
            return 16;
          case hr:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ki = null, Qa = null, Xn = null;
  function Ls() {
    if (Xn) return Xn;
    var t, i = Qa, w = i.length, N, ne = "value" in Ki ? Ki.value : Ki.textContent, ge = ne.length;
    for (t = 0; t < w && i[t] === ne[t]; t++) ;
    var ze = w - t;
    for (N = 1; N <= ze && i[w - N] === ne[ge - N]; N++) ;
    return Xn = ne.slice(t, 1 < N ? 1 - N : void 0);
  }
  function qn(t) {
    var i = t.keyCode;
    return "charCode" in t ? (t = t.charCode, t === 0 && i === 13 && (t = 13)) : t = i, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0;
  }
  function ba() {
    return !0;
  }
  function Qn() {
    return !1;
  }
  function Mr(t) {
    function i(w, N, ne, ge, ze) {
      this._reactName = w, this._targetInst = ne, this.type = N, this.nativeEvent = ge, this.target = ze, this.currentTarget = null;
      for (var Qe in t) t.hasOwnProperty(Qe) && (w = t[Qe], this[Qe] = w ? w(ge) : ge[Qe]);
      return this.isDefaultPrevented = (ge.defaultPrevented != null ? ge.defaultPrevented : ge.returnValue === !1) ? ba : Qn, this.isPropagationStopped = Qn, this;
    }
    return de(i.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var w = this.nativeEvent;
      w && (w.preventDefault ? w.preventDefault() : typeof w.returnValue != "unknown" && (w.returnValue = !1), this.isDefaultPrevented = ba);
    }, stopPropagation: function() {
      var w = this.nativeEvent;
      w && (w.stopPropagation ? w.stopPropagation() : typeof w.cancelBubble != "unknown" && (w.cancelBubble = !0), this.isPropagationStopped = ba);
    }, persist: function() {
    }, isPersistent: ba }), i;
  }
  var zi = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(t) {
    return t.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Sa = Mr(zi), wi = de({}, zi, { view: 0, detail: 0 }), Ns = Mr(wi), xr, Ka, un, Fi = de({}, wi, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Ja, button: 0, buttons: 0, relatedTarget: function(t) {
    return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget;
  }, movementX: function(t) {
    return "movementX" in t ? t.movementX : (t !== un && (un && t.type === "mousemove" ? (xr = t.screenX - un.screenX, Ka = t.screenY - un.screenY) : Ka = xr = 0, un = t), xr);
  }, movementY: function(t) {
    return "movementY" in t ? t.movementY : Ka;
  } }), Ds = Mr(Fi), Ko = de({}, Fi, { dataTransfer: 0 }), $o = Mr(Ko), Jo = de({}, wi, { relatedTarget: 0 }), $a = Mr(Jo), eu = de({}, zi, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), tu = Mr(eu), ru = de({}, zi, { clipboardData: function(t) {
    return "clipboardData" in t ? t.clipboardData : window.clipboardData;
  } }), iu = Mr(ru), ln = de({}, zi, { data: 0 }), Ar = Mr(ln), Bs = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Kn = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, nu = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function zs(t) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(t) : (t = nu[t]) ? !!i[t] : !1;
  }
  function Ja() {
    return zs;
  }
  var Ea = de({}, wi, { key: function(t) {
    if (t.key) {
      var i = Bs[t.key] || t.key;
      if (i !== "Unidentified") return i;
    }
    return t.type === "keypress" ? (t = qn(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? Kn[t.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Ja, charCode: function(t) {
    return t.type === "keypress" ? qn(t) : 0;
  }, keyCode: function(t) {
    return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
  }, which: function(t) {
    return t.type === "keypress" ? qn(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
  } }), Sn = Mr(Ea), Fs = de({}, Fi, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), es = Mr(Fs), er = de({}, wi, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Ja }), ts = Mr(er), Us = de({}, zi, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), js = Mr(Us), Lr = de({}, Fi, {
    deltaX: function(t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
    },
    deltaY: function(t) {
      return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), $i = Mr(Lr), Xt = [9, 13, 27, 32], $n = x && "CompositionEvent" in window, sr = null;
  x && "documentMode" in document && (sr = document.documentMode);
  var xa = x && "TextEvent" in window && !sr, Ji = x && (!$n || sr && 8 < sr && 11 >= sr), wr = " ", Ti = !1;
  function Jn(t, i) {
    switch (t) {
      case "keyup":
        return Xt.indexOf(i.keyCode) !== -1;
      case "keydown":
        return i.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Hs(t) {
    return t = t.detail, typeof t == "object" && "data" in t ? t.data : null;
  }
  var en = !1;
  function au(t, i) {
    switch (t) {
      case "compositionend":
        return Hs(i);
      case "keypress":
        return i.which !== 32 ? null : (Ti = !0, wr);
      case "textInput":
        return t = i.data, t === wr && Ti ? null : t;
      default:
        return null;
    }
  }
  function bi(t, i) {
    if (en) return t === "compositionend" || !$n && Jn(t, i) ? (t = Ls(), Xn = Qa = Ki = null, en = !1, t) : null;
    switch (t) {
      case "paste":
        return null;
      case "keypress":
        if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
          if (i.char && 1 < i.char.length) return i.char;
          if (i.which) return String.fromCharCode(i.which);
        }
        return null;
      case "compositionend":
        return Ji && i.locale !== "ko" ? null : i.data;
      default:
        return null;
    }
  }
  var ea = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function En(t) {
    var i = t && t.nodeName && t.nodeName.toLowerCase();
    return i === "input" ? !!ea[t.type] : i === "textarea";
  }
  function Ca(t, i, w, N) {
    Se(N), i = Qs(i, "onChange"), 0 < i.length && (w = new Sa("onChange", "change", null, w, N), t.push({ event: w, listeners: i }));
  }
  var xn = null, Cn = null;
  function Ur(t) {
    yf(t, 0);
  }
  function kn(t) {
    var i = Pa(t);
    if ($e(i)) return t;
  }
  function su(t, i) {
    if (t === "change") return i;
  }
  var Gs = !1;
  if (x) {
    var ta;
    if (x) {
      var ra = "oninput" in document;
      if (!ra) {
        var Vs = document.createElement("div");
        Vs.setAttribute("oninput", "return;"), ra = typeof Vs.oninput == "function";
      }
      ta = ra;
    } else ta = !1;
    Gs = ta && (!document.documentMode || 9 < document.documentMode);
  }
  function An() {
    xn && (xn.detachEvent("onpropertychange", ka), Cn = xn = null);
  }
  function ka(t) {
    if (t.propertyName === "value" && kn(Cn)) {
      var i = [];
      Ca(i, Cn, t, K(t)), O(Ur, i);
    }
  }
  function ou(t, i, w) {
    t === "focusin" ? (An(), xn = i, Cn = w, xn.attachEvent("onpropertychange", ka)) : t === "focusout" && An();
  }
  function uu(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown") return kn(Cn);
  }
  function Ws(t, i) {
    if (t === "click") return kn(i);
  }
  function rs(t, i) {
    if (t === "input" || t === "change") return kn(i);
  }
  function is(t, i) {
    return t === i && (t !== 0 || 1 / t === 1 / i) || t !== t && i !== i;
  }
  var Pr = typeof Object.is == "function" ? Object.is : is;
  function qe(t, i) {
    if (Pr(t, i)) return !0;
    if (typeof t != "object" || t === null || typeof i != "object" || i === null) return !1;
    var w = Object.keys(t), N = Object.keys(i);
    if (w.length !== N.length) return !1;
    for (N = 0; N < w.length; N++) {
      var ne = w[N];
      if (!y.call(i, ne) || !Pr(t[ne], i[ne])) return !1;
    }
    return !0;
  }
  function tt(t) {
    for (; t && t.firstChild; ) t = t.firstChild;
    return t;
  }
  function ct(t, i) {
    var w = tt(t);
    t = 0;
    for (var N; w; ) {
      if (w.nodeType === 3) {
        if (N = t + w.textContent.length, t <= i && N >= i) return { node: w, offset: i - t };
        t = N;
      }
      e: {
        for (; w; ) {
          if (w.nextSibling) {
            w = w.nextSibling;
            break e;
          }
          w = w.parentNode;
        }
        w = void 0;
      }
      w = tt(w);
    }
  }
  function mt(t, i) {
    return t && i ? t === i ? !0 : t && t.nodeType === 3 ? !1 : i && i.nodeType === 3 ? mt(t, i.parentNode) : "contains" in t ? t.contains(i) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(i) & 16) : !1 : !1;
  }
  function Ft() {
    for (var t = window, i = Ve(); i instanceof t.HTMLIFrameElement; ) {
      try {
        var w = typeof i.contentWindow.location.href == "string";
      } catch {
        w = !1;
      }
      if (w) t = i.contentWindow;
      else break;
      i = Ve(t.document);
    }
    return i;
  }
  function Ut(t) {
    var i = t && t.nodeName && t.nodeName.toLowerCase();
    return i && (i === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || i === "textarea" || t.contentEditable === "true");
  }
  function Wt(t) {
    var i = Ft(), w = t.focusedElem, N = t.selectionRange;
    if (i !== w && w && w.ownerDocument && mt(w.ownerDocument.documentElement, w)) {
      if (N !== null && Ut(w)) {
        if (i = N.start, t = N.end, t === void 0 && (t = i), "selectionStart" in w) w.selectionStart = i, w.selectionEnd = Math.min(t, w.value.length);
        else if (t = (i = w.ownerDocument || document) && i.defaultView || window, t.getSelection) {
          t = t.getSelection();
          var ne = w.textContent.length, ge = Math.min(N.start, ne);
          N = N.end === void 0 ? ge : Math.min(N.end, ne), !t.extend && ge > N && (ne = N, N = ge, ge = ne), ne = ct(w, ge);
          var ze = ct(
            w,
            N
          );
          ne && ze && (t.rangeCount !== 1 || t.anchorNode !== ne.node || t.anchorOffset !== ne.offset || t.focusNode !== ze.node || t.focusOffset !== ze.offset) && (i = i.createRange(), i.setStart(ne.node, ne.offset), t.removeAllRanges(), ge > N ? (t.addRange(i), t.extend(ze.node, ze.offset)) : (i.setEnd(ze.node, ze.offset), t.addRange(i)));
        }
      }
      for (i = [], t = w; t = t.parentNode; ) t.nodeType === 1 && i.push({ element: t, left: t.scrollLeft, top: t.scrollTop });
      for (typeof w.focus == "function" && w.focus(), w = 0; w < i.length; w++) t = i[w], t.element.scrollLeft = t.left, t.element.scrollTop = t.top;
    }
  }
  var rr = x && "documentMode" in document && 11 >= document.documentMode, jr = null, Ui = null, fn = null, Tn = !1;
  function Zs(t, i, w) {
    var N = w.window === w ? w.document : w.nodeType === 9 ? w : w.ownerDocument;
    Tn || jr == null || jr !== Ve(N) || (N = jr, "selectionStart" in N && Ut(N) ? N = { start: N.selectionStart, end: N.selectionEnd } : (N = (N.ownerDocument && N.ownerDocument.defaultView || window).getSelection(), N = { anchorNode: N.anchorNode, anchorOffset: N.anchorOffset, focusNode: N.focusNode, focusOffset: N.focusOffset }), fn && qe(fn, N) || (fn = N, N = Qs(Ui, "onSelect"), 0 < N.length && (i = new Sa("onSelect", "select", null, i, w), t.push({ event: i, listeners: N }), i.target = jr)));
  }
  function Ys(t, i) {
    var w = {};
    return w[t.toLowerCase()] = i.toLowerCase(), w["Webkit" + t] = "webkit" + i, w["Moz" + t] = "moz" + i, w;
  }
  var Aa = { animationend: Ys("Animation", "AnimationEnd"), animationiteration: Ys("Animation", "AnimationIteration"), animationstart: Ys("Animation", "AnimationStart"), transitionend: Ys("Transition", "TransitionEnd") }, lu = {}, hf = {};
  x && (hf = document.createElement("div").style, "AnimationEvent" in window || (delete Aa.animationend.animation, delete Aa.animationiteration.animation, delete Aa.animationstart.animation), "TransitionEvent" in window || delete Aa.transitionend.transition);
  function Xs(t) {
    if (lu[t]) return lu[t];
    if (!Aa[t]) return t;
    var i = Aa[t], w;
    for (w in i) if (i.hasOwnProperty(w) && w in hf) return lu[t] = i[w];
    return t;
  }
  var cf = Xs("animationend"), df = Xs("animationiteration"), pf = Xs("animationstart"), vf = Xs("transitionend"), mf = /* @__PURE__ */ new Map(), gf = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Mn(t, i) {
    mf.set(t, i), _(i, [t]);
  }
  for (var fu = 0; fu < gf.length; fu++) {
    var hu = gf[fu], cd = hu.toLowerCase(), dd = hu[0].toUpperCase() + hu.slice(1);
    Mn(cd, "on" + dd);
  }
  Mn(cf, "onAnimationEnd"), Mn(df, "onAnimationIteration"), Mn(pf, "onAnimationStart"), Mn("dblclick", "onDoubleClick"), Mn("focusin", "onFocus"), Mn("focusout", "onBlur"), Mn(vf, "onTransitionEnd"), M("onMouseEnter", ["mouseout", "mouseover"]), M("onMouseLeave", ["mouseout", "mouseover"]), M("onPointerEnter", ["pointerout", "pointerover"]), M("onPointerLeave", ["pointerout", "pointerover"]), _("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), _("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), _("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), _("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), _("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), _("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var ns = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), pd = new Set("cancel close invalid load scroll toggle".split(" ").concat(ns));
  function _f(t, i, w) {
    var N = t.type || "unknown-event";
    t.currentTarget = w, dt(N, i, void 0, t), t.currentTarget = null;
  }
  function yf(t, i) {
    i = (i & 4) !== 0;
    for (var w = 0; w < t.length; w++) {
      var N = t[w], ne = N.event;
      N = N.listeners;
      e: {
        var ge = void 0;
        if (i) for (var ze = N.length - 1; 0 <= ze; ze--) {
          var Qe = N[ze], rt = Qe.instance, ft = Qe.currentTarget;
          if (Qe = Qe.listener, rt !== ge && ne.isPropagationStopped()) break e;
          _f(ne, Qe, ft), ge = rt;
        }
        else for (ze = 0; ze < N.length; ze++) {
          if (Qe = N[ze], rt = Qe.instance, ft = Qe.currentTarget, Qe = Qe.listener, rt !== ge && ne.isPropagationStopped()) break e;
          _f(ne, Qe, ft), ge = rt;
        }
      }
    }
    if (Ke) throw t = et, Ke = !1, et = null, t;
  }
  function pr(t, i) {
    var w = i[yu];
    w === void 0 && (w = i[yu] = /* @__PURE__ */ new Set());
    var N = t + "__bubble";
    w.has(N) || (wf(i, t, 2, !1), w.add(N));
  }
  function cu(t, i, w) {
    var N = 0;
    i && (N |= 4), wf(w, t, N, i);
  }
  var qs = "_reactListening" + Math.random().toString(36).slice(2);
  function as(t) {
    if (!t[qs]) {
      t[qs] = !0, k.forEach(function(w) {
        w !== "selectionchange" && (pd.has(w) || cu(w, !1, t), cu(w, !0, t));
      });
      var i = t.nodeType === 9 ? t : t.ownerDocument;
      i === null || i[qs] || (i[qs] = !0, cu("selectionchange", !1, i));
    }
  }
  function wf(t, i, w, N) {
    switch (Yn(i)) {
      case 1:
        var ne = Bi;
        break;
      case 4:
        ne = ki;
        break;
      default:
        ne = Ai;
    }
    w = ne.bind(null, i, w, t), ne = void 0, !Oe || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (ne = !0), N ? ne !== void 0 ? t.addEventListener(i, w, { capture: !0, passive: ne }) : t.addEventListener(i, w, !0) : ne !== void 0 ? t.addEventListener(i, w, { passive: ne }) : t.addEventListener(i, w, !1);
  }
  function du(t, i, w, N, ne) {
    var ge = N;
    if ((i & 1) === 0 && (i & 2) === 0 && N !== null) e: for (; ; ) {
      if (N === null) return;
      var ze = N.tag;
      if (ze === 3 || ze === 4) {
        var Qe = N.stateNode.containerInfo;
        if (Qe === ne || Qe.nodeType === 8 && Qe.parentNode === ne) break;
        if (ze === 4) for (ze = N.return; ze !== null; ) {
          var rt = ze.tag;
          if ((rt === 3 || rt === 4) && (rt = ze.stateNode.containerInfo, rt === ne || rt.nodeType === 8 && rt.parentNode === ne)) return;
          ze = ze.return;
        }
        for (; Qe !== null; ) {
          if (ze = ia(Qe), ze === null) return;
          if (rt = ze.tag, rt === 5 || rt === 6) {
            N = ge = ze;
            continue e;
          }
          Qe = Qe.parentNode;
        }
      }
      N = N.return;
    }
    O(function() {
      var ft = ge, yt = K(w), St = [];
      e: {
        var _t = mf.get(t);
        if (_t !== void 0) {
          var Pt = Sa, Rt = t;
          switch (t) {
            case "keypress":
              if (qn(w) === 0) break e;
            case "keydown":
            case "keyup":
              Pt = Sn;
              break;
            case "focusin":
              Rt = "focus", Pt = $a;
              break;
            case "focusout":
              Rt = "blur", Pt = $a;
              break;
            case "beforeblur":
            case "afterblur":
              Pt = $a;
              break;
            case "click":
              if (w.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Pt = Ds;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Pt = $o;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Pt = ts;
              break;
            case cf:
            case df:
            case pf:
              Pt = tu;
              break;
            case vf:
              Pt = js;
              break;
            case "scroll":
              Pt = Ns;
              break;
            case "wheel":
              Pt = $i;
              break;
            case "copy":
            case "cut":
            case "paste":
              Pt = iu;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Pt = es;
          }
          var Lt = (i & 4) !== 0, Tr = !Lt && t === "scroll", st = Lt ? _t !== null ? _t + "Capture" : null : _t;
          Lt = [];
          for (var it = ft, ut; it !== null; ) {
            ut = it;
            var kt = ut.stateNode;
            if (ut.tag === 5 && kt !== null && (ut = kt, st !== null && (kt = ce(it, st), kt != null && Lt.push(ss(it, kt, ut)))), Tr) break;
            it = it.return;
          }
          0 < Lt.length && (_t = new Pt(_t, Rt, null, w, yt), St.push({ event: _t, listeners: Lt }));
        }
      }
      if ((i & 7) === 0) {
        e: {
          if (_t = t === "mouseover" || t === "pointerover", Pt = t === "mouseout" || t === "pointerout", _t && w !== q && (Rt = w.relatedTarget || w.fromElement) && (ia(Rt) || Rt[hn])) break e;
          if ((Pt || _t) && (_t = yt.window === yt ? yt : (_t = yt.ownerDocument) ? _t.defaultView || _t.parentWindow : window, Pt ? (Rt = w.relatedTarget || w.toElement, Pt = ft, Rt = Rt ? ia(Rt) : null, Rt !== null && (Tr = vt(Rt), Rt !== Tr || Rt.tag !== 5 && Rt.tag !== 6) && (Rt = null)) : (Pt = null, Rt = ft), Pt !== Rt)) {
            if (Lt = Ds, kt = "onMouseLeave", st = "onMouseEnter", it = "mouse", (t === "pointerout" || t === "pointerover") && (Lt = es, kt = "onPointerLeave", st = "onPointerEnter", it = "pointer"), Tr = Pt == null ? _t : Pa(Pt), ut = Rt == null ? _t : Pa(Rt), _t = new Lt(kt, it + "leave", Pt, w, yt), _t.target = Tr, _t.relatedTarget = ut, kt = null, ia(yt) === ft && (Lt = new Lt(st, it + "enter", Rt, w, yt), Lt.target = ut, Lt.relatedTarget = Tr, kt = Lt), Tr = kt, Pt && Rt) t: {
              for (Lt = Pt, st = Rt, it = 0, ut = Lt; ut; ut = Ta(ut)) it++;
              for (ut = 0, kt = st; kt; kt = Ta(kt)) ut++;
              for (; 0 < it - ut; ) Lt = Ta(Lt), it--;
              for (; 0 < ut - it; ) st = Ta(st), ut--;
              for (; it--; ) {
                if (Lt === st || st !== null && Lt === st.alternate) break t;
                Lt = Ta(Lt), st = Ta(st);
              }
              Lt = null;
            }
            else Lt = null;
            Pt !== null && bf(St, _t, Pt, Lt, !1), Rt !== null && Tr !== null && bf(St, Tr, Rt, Lt, !0);
          }
        }
        e: {
          if (_t = ft ? Pa(ft) : window, Pt = _t.nodeName && _t.nodeName.toLowerCase(), Pt === "select" || Pt === "input" && _t.type === "file") var Dt = su;
          else if (En(_t)) if (Gs) Dt = rs;
          else {
            Dt = uu;
            var jt = ou;
          }
          else (Pt = _t.nodeName) && Pt.toLowerCase() === "input" && (_t.type === "checkbox" || _t.type === "radio") && (Dt = Ws);
          if (Dt && (Dt = Dt(t, ft))) {
            Ca(St, Dt, w, yt);
            break e;
          }
          jt && jt(t, _t, ft), t === "focusout" && (jt = _t._wrapperState) && jt.controlled && _t.type === "number" && re(_t, "number", _t.value);
        }
        switch (jt = ft ? Pa(ft) : window, t) {
          case "focusin":
            (En(jt) || jt.contentEditable === "true") && (jr = jt, Ui = ft, fn = null);
            break;
          case "focusout":
            fn = Ui = jr = null;
            break;
          case "mousedown":
            Tn = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Tn = !1, Zs(St, w, yt);
            break;
          case "selectionchange":
            if (rr) break;
          case "keydown":
          case "keyup":
            Zs(St, w, yt);
        }
        var Ht;
        if ($n) e: {
          switch (t) {
            case "compositionstart":
              var Zt = "onCompositionStart";
              break e;
            case "compositionend":
              Zt = "onCompositionEnd";
              break e;
            case "compositionupdate":
              Zt = "onCompositionUpdate";
              break e;
          }
          Zt = void 0;
        }
        else en ? Jn(t, w) && (Zt = "onCompositionEnd") : t === "keydown" && w.keyCode === 229 && (Zt = "onCompositionStart");
        Zt && (Ji && w.locale !== "ko" && (en || Zt !== "onCompositionStart" ? Zt === "onCompositionEnd" && en && (Ht = Ls()) : (Ki = yt, Qa = "value" in Ki ? Ki.value : Ki.textContent, en = !0)), jt = Qs(ft, Zt), 0 < jt.length && (Zt = new Ar(Zt, t, null, w, yt), St.push({ event: Zt, listeners: jt }), Ht ? Zt.data = Ht : (Ht = Hs(w), Ht !== null && (Zt.data = Ht)))), (Ht = xa ? au(t, w) : bi(t, w)) && (ft = Qs(ft, "onBeforeInput"), 0 < ft.length && (yt = new Ar("onBeforeInput", "beforeinput", null, w, yt), St.push({ event: yt, listeners: ft }), yt.data = Ht));
      }
      yf(St, i);
    });
  }
  function ss(t, i, w) {
    return { instance: t, listener: i, currentTarget: w };
  }
  function Qs(t, i) {
    for (var w = i + "Capture", N = []; t !== null; ) {
      var ne = t, ge = ne.stateNode;
      ne.tag === 5 && ge !== null && (ne = ge, ge = ce(t, w), ge != null && N.unshift(ss(t, ge, ne)), ge = ce(t, i), ge != null && N.push(ss(t, ge, ne))), t = t.return;
    }
    return N;
  }
  function Ta(t) {
    if (t === null) return null;
    do
      t = t.return;
    while (t && t.tag !== 5);
    return t || null;
  }
  function bf(t, i, w, N, ne) {
    for (var ge = i._reactName, ze = []; w !== null && w !== N; ) {
      var Qe = w, rt = Qe.alternate, ft = Qe.stateNode;
      if (rt !== null && rt === N) break;
      Qe.tag === 5 && ft !== null && (Qe = ft, ne ? (rt = ce(w, ge), rt != null && ze.unshift(ss(w, rt, Qe))) : ne || (rt = ce(w, ge), rt != null && ze.push(ss(w, rt, Qe)))), w = w.return;
    }
    ze.length !== 0 && t.push({ event: i, listeners: ze });
  }
  var vd = /\r\n?/g, md = /\u0000|\uFFFD/g;
  function Sf(t) {
    return (typeof t == "string" ? t : "" + t).replace(vd, `
`).replace(md, "");
  }
  function Ks(t, i, w) {
    if (i = Sf(i), Sf(t) !== i && w) throw Error(ae(425));
  }
  function $s() {
  }
  var pu = null, vu = null;
  function mu(t, i) {
    return t === "textarea" || t === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null;
  }
  var gu = typeof setTimeout == "function" ? setTimeout : void 0, gd = typeof clearTimeout == "function" ? clearTimeout : void 0, Ef = typeof Promise == "function" ? Promise : void 0, _d = typeof queueMicrotask == "function" ? queueMicrotask : typeof Ef < "u" ? function(t) {
    return Ef.resolve(null).then(t).catch(yd);
  } : gu;
  function yd(t) {
    setTimeout(function() {
      throw t;
    });
  }
  function _u(t, i) {
    var w = i, N = 0;
    do {
      var ne = w.nextSibling;
      if (t.removeChild(w), ne && ne.nodeType === 8) if (w = ne.data, w === "/$") {
        if (N === 0) {
          t.removeChild(ne), fr(i);
          return;
        }
        N--;
      } else w !== "$" && w !== "$?" && w !== "$!" || N++;
      w = ne;
    } while (w);
    fr(i);
  }
  function Pn(t) {
    for (; t != null; t = t.nextSibling) {
      var i = t.nodeType;
      if (i === 1 || i === 3) break;
      if (i === 8) {
        if (i = t.data, i === "$" || i === "$!" || i === "$?") break;
        if (i === "/$") return null;
      }
    }
    return t;
  }
  function xf(t) {
    t = t.previousSibling;
    for (var i = 0; t; ) {
      if (t.nodeType === 8) {
        var w = t.data;
        if (w === "$" || w === "$!" || w === "$?") {
          if (i === 0) return t;
          i--;
        } else w === "/$" && i++;
      }
      t = t.previousSibling;
    }
    return null;
  }
  var Ma = Math.random().toString(36).slice(2), tn = "__reactFiber$" + Ma, os = "__reactProps$" + Ma, hn = "__reactContainer$" + Ma, yu = "__reactEvents$" + Ma, wd = "__reactListeners$" + Ma, bd = "__reactHandles$" + Ma;
  function ia(t) {
    var i = t[tn];
    if (i) return i;
    for (var w = t.parentNode; w; ) {
      if (i = w[hn] || w[tn]) {
        if (w = i.alternate, i.child !== null || w !== null && w.child !== null) for (t = xf(t); t !== null; ) {
          if (w = t[tn]) return w;
          t = xf(t);
        }
        return i;
      }
      t = w, w = t.parentNode;
    }
    return null;
  }
  function us(t) {
    return t = t[tn] || t[hn], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t;
  }
  function Pa(t) {
    if (t.tag === 5 || t.tag === 6) return t.stateNode;
    throw Error(ae(33));
  }
  function Js(t) {
    return t[os] || null;
  }
  var wu = [], Ia = -1;
  function In(t) {
    return { current: t };
  }
  function vr(t) {
    0 > Ia || (t.current = wu[Ia], wu[Ia] = null, Ia--);
  }
  function cr(t, i) {
    Ia++, wu[Ia] = t.current, t.current = i;
  }
  var Rn = {}, Jr = In(Rn), li = In(!1), na = Rn;
  function Ra(t, i) {
    var w = t.type.contextTypes;
    if (!w) return Rn;
    var N = t.stateNode;
    if (N && N.__reactInternalMemoizedUnmaskedChildContext === i) return N.__reactInternalMemoizedMaskedChildContext;
    var ne = {}, ge;
    for (ge in w) ne[ge] = i[ge];
    return N && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = ne), ne;
  }
  function fi(t) {
    return t = t.childContextTypes, t != null;
  }
  function eo() {
    vr(li), vr(Jr);
  }
  function Cf(t, i, w) {
    if (Jr.current !== Rn) throw Error(ae(168));
    cr(Jr, i), cr(li, w);
  }
  function kf(t, i, w) {
    var N = t.stateNode;
    if (i = i.childContextTypes, typeof N.getChildContext != "function") return w;
    N = N.getChildContext();
    for (var ne in N) if (!(ne in i)) throw Error(ae(108, Pe(t) || "Unknown", ne));
    return de({}, w, N);
  }
  function to(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Rn, na = Jr.current, cr(Jr, t), cr(li, li.current), !0;
  }
  function Af(t, i, w) {
    var N = t.stateNode;
    if (!N) throw Error(ae(169));
    w ? (t = kf(t, i, na), N.__reactInternalMemoizedMergedChildContext = t, vr(li), vr(Jr), cr(Jr, t)) : vr(li), cr(li, w);
  }
  var cn = null, ro = !1, bu = !1;
  function Tf(t) {
    cn === null ? cn = [t] : cn.push(t);
  }
  function Sd(t) {
    ro = !0, Tf(t);
  }
  function On() {
    if (!bu && cn !== null) {
      bu = !0;
      var t = 0, i = qt;
      try {
        var w = cn;
        for (qt = 1; t < w.length; t++) {
          var N = w[t];
          do
            N = N(!0);
          while (N !== null);
        }
        cn = null, ro = !1;
      } catch (ne) {
        throw cn !== null && (cn = cn.slice(t + 1)), Ct(Bt, On), ne;
      } finally {
        qt = i, bu = !1;
      }
    }
    return null;
  }
  var Oa = [], La = 0, io = null, no = 0, Mi = [], Pi = 0, aa = null, dn = 1, pn = "";
  function sa(t, i) {
    Oa[La++] = no, Oa[La++] = io, io = t, no = i;
  }
  function Mf(t, i, w) {
    Mi[Pi++] = dn, Mi[Pi++] = pn, Mi[Pi++] = aa, aa = t;
    var N = dn;
    t = pn;
    var ne = 32 - tr(N) - 1;
    N &= ~(1 << ne), w += 1;
    var ge = 32 - tr(i) + ne;
    if (30 < ge) {
      var ze = ne - ne % 5;
      ge = (N & (1 << ze) - 1).toString(32), N >>= ze, ne -= ze, dn = 1 << 32 - tr(i) + ne | w << ne | N, pn = ge + t;
    } else dn = 1 << ge | w << ne | N, pn = t;
  }
  function Su(t) {
    t.return !== null && (sa(t, 1), Mf(t, 1, 0));
  }
  function Eu(t) {
    for (; t === io; ) io = Oa[--La], Oa[La] = null, no = Oa[--La], Oa[La] = null;
    for (; t === aa; ) aa = Mi[--Pi], Mi[Pi] = null, pn = Mi[--Pi], Mi[Pi] = null, dn = Mi[--Pi], Mi[Pi] = null;
  }
  var Si = null, Ei = null, mr = !1, ji = null;
  function Pf(t, i) {
    var w = Li(5, null, null, 0);
    w.elementType = "DELETED", w.stateNode = i, w.return = t, i = t.deletions, i === null ? (t.deletions = [w], t.flags |= 16) : i.push(w);
  }
  function If(t, i) {
    switch (t.tag) {
      case 5:
        var w = t.type;
        return i = i.nodeType !== 1 || w.toLowerCase() !== i.nodeName.toLowerCase() ? null : i, i !== null ? (t.stateNode = i, Si = t, Ei = Pn(i.firstChild), !0) : !1;
      case 6:
        return i = t.pendingProps === "" || i.nodeType !== 3 ? null : i, i !== null ? (t.stateNode = i, Si = t, Ei = null, !0) : !1;
      case 13:
        return i = i.nodeType !== 8 ? null : i, i !== null ? (w = aa !== null ? { id: dn, overflow: pn } : null, t.memoizedState = { dehydrated: i, treeContext: w, retryLane: 1073741824 }, w = Li(18, null, null, 0), w.stateNode = i, w.return = t, t.child = w, Si = t, Ei = null, !0) : !1;
      default:
        return !1;
    }
  }
  function xu(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
  }
  function Cu(t) {
    if (mr) {
      var i = Ei;
      if (i) {
        var w = i;
        if (!If(t, i)) {
          if (xu(t)) throw Error(ae(418));
          i = Pn(w.nextSibling);
          var N = Si;
          i && If(t, i) ? Pf(N, w) : (t.flags = t.flags & -4097 | 2, mr = !1, Si = t);
        }
      } else {
        if (xu(t)) throw Error(ae(418));
        t.flags = t.flags & -4097 | 2, mr = !1, Si = t;
      }
    }
  }
  function Rf(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; ) t = t.return;
    Si = t;
  }
  function ao(t) {
    if (t !== Si) return !1;
    if (!mr) return Rf(t), mr = !0, !1;
    var i;
    if ((i = t.tag !== 3) && !(i = t.tag !== 5) && (i = t.type, i = i !== "head" && i !== "body" && !mu(t.type, t.memoizedProps)), i && (i = Ei)) {
      if (xu(t)) throw Of(), Error(ae(418));
      for (; i; ) Pf(t, i), i = Pn(i.nextSibling);
    }
    if (Rf(t), t.tag === 13) {
      if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(ae(317));
      e: {
        for (t = t.nextSibling, i = 0; t; ) {
          if (t.nodeType === 8) {
            var w = t.data;
            if (w === "/$") {
              if (i === 0) {
                Ei = Pn(t.nextSibling);
                break e;
              }
              i--;
            } else w !== "$" && w !== "$!" && w !== "$?" || i++;
          }
          t = t.nextSibling;
        }
        Ei = null;
      }
    } else Ei = Si ? Pn(t.stateNode.nextSibling) : null;
    return !0;
  }
  function Of() {
    for (var t = Ei; t; ) t = Pn(t.nextSibling);
  }
  function Na() {
    Ei = Si = null, mr = !1;
  }
  function ku(t) {
    ji === null ? ji = [t] : ji.push(t);
  }
  var Ed = b.ReactCurrentBatchConfig;
  function ls(t, i, w) {
    if (t = w.ref, t !== null && typeof t != "function" && typeof t != "object") {
      if (w._owner) {
        if (w = w._owner, w) {
          if (w.tag !== 1) throw Error(ae(309));
          var N = w.stateNode;
        }
        if (!N) throw Error(ae(147, t));
        var ne = N, ge = "" + t;
        return i !== null && i.ref !== null && typeof i.ref == "function" && i.ref._stringRef === ge ? i.ref : (i = function(ze) {
          var Qe = ne.refs;
          ze === null ? delete Qe[ge] : Qe[ge] = ze;
        }, i._stringRef = ge, i);
      }
      if (typeof t != "string") throw Error(ae(284));
      if (!w._owner) throw Error(ae(290, t));
    }
    return t;
  }
  function so(t, i) {
    throw t = Object.prototype.toString.call(i), Error(ae(31, t === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : t));
  }
  function Lf(t) {
    var i = t._init;
    return i(t._payload);
  }
  function Nf(t) {
    function i(st, it) {
      if (t) {
        var ut = st.deletions;
        ut === null ? (st.deletions = [it], st.flags |= 16) : ut.push(it);
      }
    }
    function w(st, it) {
      if (!t) return null;
      for (; it !== null; ) i(st, it), it = it.sibling;
      return null;
    }
    function N(st, it) {
      for (st = /* @__PURE__ */ new Map(); it !== null; ) it.key !== null ? st.set(it.key, it) : st.set(it.index, it), it = it.sibling;
      return st;
    }
    function ne(st, it) {
      return st = jn(st, it), st.index = 0, st.sibling = null, st;
    }
    function ge(st, it, ut) {
      return st.index = ut, t ? (ut = st.alternate, ut !== null ? (ut = ut.index, ut < it ? (st.flags |= 2, it) : ut) : (st.flags |= 2, it)) : (st.flags |= 1048576, it);
    }
    function ze(st) {
      return t && st.alternate === null && (st.flags |= 2), st;
    }
    function Qe(st, it, ut, kt) {
      return it === null || it.tag !== 6 ? (it = gl(ut, st.mode, kt), it.return = st, it) : (it = ne(it, ut), it.return = st, it);
    }
    function rt(st, it, ut, kt) {
      var Dt = ut.type;
      return Dt === A ? yt(st, it, ut.props.children, kt, ut.key) : it !== null && (it.elementType === Dt || typeof Dt == "object" && Dt !== null && Dt.$$typeof === ee && Lf(Dt) === it.type) ? (kt = ne(it, ut.props), kt.ref = ls(st, it, ut), kt.return = st, kt) : (kt = Io(ut.type, ut.key, ut.props, null, st.mode, kt), kt.ref = ls(st, it, ut), kt.return = st, kt);
    }
    function ft(st, it, ut, kt) {
      return it === null || it.tag !== 4 || it.stateNode.containerInfo !== ut.containerInfo || it.stateNode.implementation !== ut.implementation ? (it = _l(ut, st.mode, kt), it.return = st, it) : (it = ne(it, ut.children || []), it.return = st, it);
    }
    function yt(st, it, ut, kt, Dt) {
      return it === null || it.tag !== 7 ? (it = pa(ut, st.mode, kt, Dt), it.return = st, it) : (it = ne(it, ut), it.return = st, it);
    }
    function St(st, it, ut) {
      if (typeof it == "string" && it !== "" || typeof it == "number") return it = gl("" + it, st.mode, ut), it.return = st, it;
      if (typeof it == "object" && it !== null) {
        switch (it.$$typeof) {
          case S:
            return ut = Io(it.type, it.key, it.props, null, st.mode, ut), ut.ref = ls(st, null, it), ut.return = st, ut;
          case o:
            return it = _l(it, st.mode, ut), it.return = st, it;
          case ee:
            var kt = it._init;
            return St(st, kt(it._payload), ut);
        }
        if ($(it) || Q(it)) return it = pa(it, st.mode, ut, null), it.return = st, it;
        so(st, it);
      }
      return null;
    }
    function _t(st, it, ut, kt) {
      var Dt = it !== null ? it.key : null;
      if (typeof ut == "string" && ut !== "" || typeof ut == "number") return Dt !== null ? null : Qe(st, it, "" + ut, kt);
      if (typeof ut == "object" && ut !== null) {
        switch (ut.$$typeof) {
          case S:
            return ut.key === Dt ? rt(st, it, ut, kt) : null;
          case o:
            return ut.key === Dt ? ft(st, it, ut, kt) : null;
          case ee:
            return Dt = ut._init, _t(
              st,
              it,
              Dt(ut._payload),
              kt
            );
        }
        if ($(ut) || Q(ut)) return Dt !== null ? null : yt(st, it, ut, kt, null);
        so(st, ut);
      }
      return null;
    }
    function Pt(st, it, ut, kt, Dt) {
      if (typeof kt == "string" && kt !== "" || typeof kt == "number") return st = st.get(ut) || null, Qe(it, st, "" + kt, Dt);
      if (typeof kt == "object" && kt !== null) {
        switch (kt.$$typeof) {
          case S:
            return st = st.get(kt.key === null ? ut : kt.key) || null, rt(it, st, kt, Dt);
          case o:
            return st = st.get(kt.key === null ? ut : kt.key) || null, ft(it, st, kt, Dt);
          case ee:
            var jt = kt._init;
            return Pt(st, it, ut, jt(kt._payload), Dt);
        }
        if ($(kt) || Q(kt)) return st = st.get(ut) || null, yt(it, st, kt, Dt, null);
        so(it, kt);
      }
      return null;
    }
    function Rt(st, it, ut, kt) {
      for (var Dt = null, jt = null, Ht = it, Zt = it = 0, Vr = null; Ht !== null && Zt < ut.length; Zt++) {
        Ht.index > Zt ? (Vr = Ht, Ht = null) : Vr = Ht.sibling;
        var nr = _t(st, Ht, ut[Zt], kt);
        if (nr === null) {
          Ht === null && (Ht = Vr);
          break;
        }
        t && Ht && nr.alternate === null && i(st, Ht), it = ge(nr, it, Zt), jt === null ? Dt = nr : jt.sibling = nr, jt = nr, Ht = Vr;
      }
      if (Zt === ut.length) return w(st, Ht), mr && sa(st, Zt), Dt;
      if (Ht === null) {
        for (; Zt < ut.length; Zt++) Ht = St(st, ut[Zt], kt), Ht !== null && (it = ge(Ht, it, Zt), jt === null ? Dt = Ht : jt.sibling = Ht, jt = Ht);
        return mr && sa(st, Zt), Dt;
      }
      for (Ht = N(st, Ht); Zt < ut.length; Zt++) Vr = Pt(Ht, st, Zt, ut[Zt], kt), Vr !== null && (t && Vr.alternate !== null && Ht.delete(Vr.key === null ? Zt : Vr.key), it = ge(Vr, it, Zt), jt === null ? Dt = Vr : jt.sibling = Vr, jt = Vr);
      return t && Ht.forEach(function(Hn) {
        return i(st, Hn);
      }), mr && sa(st, Zt), Dt;
    }
    function Lt(st, it, ut, kt) {
      var Dt = Q(ut);
      if (typeof Dt != "function") throw Error(ae(150));
      if (ut = Dt.call(ut), ut == null) throw Error(ae(151));
      for (var jt = Dt = null, Ht = it, Zt = it = 0, Vr = null, nr = ut.next(); Ht !== null && !nr.done; Zt++, nr = ut.next()) {
        Ht.index > Zt ? (Vr = Ht, Ht = null) : Vr = Ht.sibling;
        var Hn = _t(st, Ht, nr.value, kt);
        if (Hn === null) {
          Ht === null && (Ht = Vr);
          break;
        }
        t && Ht && Hn.alternate === null && i(st, Ht), it = ge(Hn, it, Zt), jt === null ? Dt = Hn : jt.sibling = Hn, jt = Hn, Ht = Vr;
      }
      if (nr.done) return w(
        st,
        Ht
      ), mr && sa(st, Zt), Dt;
      if (Ht === null) {
        for (; !nr.done; Zt++, nr = ut.next()) nr = St(st, nr.value, kt), nr !== null && (it = ge(nr, it, Zt), jt === null ? Dt = nr : jt.sibling = nr, jt = nr);
        return mr && sa(st, Zt), Dt;
      }
      for (Ht = N(st, Ht); !nr.done; Zt++, nr = ut.next()) nr = Pt(Ht, st, Zt, nr.value, kt), nr !== null && (t && nr.alternate !== null && Ht.delete(nr.key === null ? Zt : nr.key), it = ge(nr, it, Zt), jt === null ? Dt = nr : jt.sibling = nr, jt = nr);
      return t && Ht.forEach(function(rp) {
        return i(st, rp);
      }), mr && sa(st, Zt), Dt;
    }
    function Tr(st, it, ut, kt) {
      if (typeof ut == "object" && ut !== null && ut.type === A && ut.key === null && (ut = ut.props.children), typeof ut == "object" && ut !== null) {
        switch (ut.$$typeof) {
          case S:
            e: {
              for (var Dt = ut.key, jt = it; jt !== null; ) {
                if (jt.key === Dt) {
                  if (Dt = ut.type, Dt === A) {
                    if (jt.tag === 7) {
                      w(st, jt.sibling), it = ne(jt, ut.props.children), it.return = st, st = it;
                      break e;
                    }
                  } else if (jt.elementType === Dt || typeof Dt == "object" && Dt !== null && Dt.$$typeof === ee && Lf(Dt) === jt.type) {
                    w(st, jt.sibling), it = ne(jt, ut.props), it.ref = ls(st, jt, ut), it.return = st, st = it;
                    break e;
                  }
                  w(st, jt);
                  break;
                } else i(st, jt);
                jt = jt.sibling;
              }
              ut.type === A ? (it = pa(ut.props.children, st.mode, kt, ut.key), it.return = st, st = it) : (kt = Io(ut.type, ut.key, ut.props, null, st.mode, kt), kt.ref = ls(st, it, ut), kt.return = st, st = kt);
            }
            return ze(st);
          case o:
            e: {
              for (jt = ut.key; it !== null; ) {
                if (it.key === jt) if (it.tag === 4 && it.stateNode.containerInfo === ut.containerInfo && it.stateNode.implementation === ut.implementation) {
                  w(st, it.sibling), it = ne(it, ut.children || []), it.return = st, st = it;
                  break e;
                } else {
                  w(st, it);
                  break;
                }
                else i(st, it);
                it = it.sibling;
              }
              it = _l(ut, st.mode, kt), it.return = st, st = it;
            }
            return ze(st);
          case ee:
            return jt = ut._init, Tr(st, it, jt(ut._payload), kt);
        }
        if ($(ut)) return Rt(st, it, ut, kt);
        if (Q(ut)) return Lt(st, it, ut, kt);
        so(st, ut);
      }
      return typeof ut == "string" && ut !== "" || typeof ut == "number" ? (ut = "" + ut, it !== null && it.tag === 6 ? (w(st, it.sibling), it = ne(it, ut), it.return = st, st = it) : (w(st, it), it = gl(ut, st.mode, kt), it.return = st, st = it), ze(st)) : w(st, it);
    }
    return Tr;
  }
  var Da = Nf(!0), Df = Nf(!1), oo = In(null), uo = null, Ba = null, Au = null;
  function Tu() {
    Au = Ba = uo = null;
  }
  function Mu(t) {
    var i = oo.current;
    vr(oo), t._currentValue = i;
  }
  function Pu(t, i, w) {
    for (; t !== null; ) {
      var N = t.alternate;
      if ((t.childLanes & i) !== i ? (t.childLanes |= i, N !== null && (N.childLanes |= i)) : N !== null && (N.childLanes & i) !== i && (N.childLanes |= i), t === w) break;
      t = t.return;
    }
  }
  function za(t, i) {
    uo = t, Au = Ba = null, t = t.dependencies, t !== null && t.firstContext !== null && ((t.lanes & i) !== 0 && (hi = !0), t.firstContext = null);
  }
  function Ii(t) {
    var i = t._currentValue;
    if (Au !== t) if (t = { context: t, memoizedValue: i, next: null }, Ba === null) {
      if (uo === null) throw Error(ae(308));
      Ba = t, uo.dependencies = { lanes: 0, firstContext: t };
    } else Ba = Ba.next = t;
    return i;
  }
  var oa = null;
  function Iu(t) {
    oa === null ? oa = [t] : oa.push(t);
  }
  function Bf(t, i, w, N) {
    var ne = i.interleaved;
    return ne === null ? (w.next = w, Iu(i)) : (w.next = ne.next, ne.next = w), i.interleaved = w, vn(t, N);
  }
  function vn(t, i) {
    t.lanes |= i;
    var w = t.alternate;
    for (w !== null && (w.lanes |= i), w = t, t = t.return; t !== null; ) t.childLanes |= i, w = t.alternate, w !== null && (w.childLanes |= i), w = t, t = t.return;
    return w.tag === 3 ? w.stateNode : null;
  }
  var Ln = !1;
  function Ru(t) {
    t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function zf(t, i) {
    t = t.updateQueue, i.updateQueue === t && (i.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects });
  }
  function mn(t, i) {
    return { eventTime: t, lane: i, tag: 0, payload: null, callback: null, next: null };
  }
  function Nn(t, i, w) {
    var N = t.updateQueue;
    if (N === null) return null;
    if (N = N.shared, (ir & 2) !== 0) {
      var ne = N.pending;
      return ne === null ? i.next = i : (i.next = ne.next, ne.next = i), N.pending = i, vn(t, w);
    }
    return ne = N.interleaved, ne === null ? (i.next = i, Iu(N)) : (i.next = ne.next, ne.next = i), N.interleaved = i, vn(t, w);
  }
  function lo(t, i, w) {
    if (i = i.updateQueue, i !== null && (i = i.shared, (w & 4194240) !== 0)) {
      var N = i.lanes;
      N &= t.pendingLanes, w |= N, i.lanes = w, Xi(t, w);
    }
  }
  function Ff(t, i) {
    var w = t.updateQueue, N = t.alternate;
    if (N !== null && (N = N.updateQueue, w === N)) {
      var ne = null, ge = null;
      if (w = w.firstBaseUpdate, w !== null) {
        do {
          var ze = { eventTime: w.eventTime, lane: w.lane, tag: w.tag, payload: w.payload, callback: w.callback, next: null };
          ge === null ? ne = ge = ze : ge = ge.next = ze, w = w.next;
        } while (w !== null);
        ge === null ? ne = ge = i : ge = ge.next = i;
      } else ne = ge = i;
      w = { baseState: N.baseState, firstBaseUpdate: ne, lastBaseUpdate: ge, shared: N.shared, effects: N.effects }, t.updateQueue = w;
      return;
    }
    t = w.lastBaseUpdate, t === null ? w.firstBaseUpdate = i : t.next = i, w.lastBaseUpdate = i;
  }
  function fo(t, i, w, N) {
    var ne = t.updateQueue;
    Ln = !1;
    var ge = ne.firstBaseUpdate, ze = ne.lastBaseUpdate, Qe = ne.shared.pending;
    if (Qe !== null) {
      ne.shared.pending = null;
      var rt = Qe, ft = rt.next;
      rt.next = null, ze === null ? ge = ft : ze.next = ft, ze = rt;
      var yt = t.alternate;
      yt !== null && (yt = yt.updateQueue, Qe = yt.lastBaseUpdate, Qe !== ze && (Qe === null ? yt.firstBaseUpdate = ft : Qe.next = ft, yt.lastBaseUpdate = rt));
    }
    if (ge !== null) {
      var St = ne.baseState;
      ze = 0, yt = ft = rt = null, Qe = ge;
      do {
        var _t = Qe.lane, Pt = Qe.eventTime;
        if ((N & _t) === _t) {
          yt !== null && (yt = yt.next = {
            eventTime: Pt,
            lane: 0,
            tag: Qe.tag,
            payload: Qe.payload,
            callback: Qe.callback,
            next: null
          });
          e: {
            var Rt = t, Lt = Qe;
            switch (_t = i, Pt = w, Lt.tag) {
              case 1:
                if (Rt = Lt.payload, typeof Rt == "function") {
                  St = Rt.call(Pt, St, _t);
                  break e;
                }
                St = Rt;
                break e;
              case 3:
                Rt.flags = Rt.flags & -65537 | 128;
              case 0:
                if (Rt = Lt.payload, _t = typeof Rt == "function" ? Rt.call(Pt, St, _t) : Rt, _t == null) break e;
                St = de({}, St, _t);
                break e;
              case 2:
                Ln = !0;
            }
          }
          Qe.callback !== null && Qe.lane !== 0 && (t.flags |= 64, _t = ne.effects, _t === null ? ne.effects = [Qe] : _t.push(Qe));
        } else Pt = { eventTime: Pt, lane: _t, tag: Qe.tag, payload: Qe.payload, callback: Qe.callback, next: null }, yt === null ? (ft = yt = Pt, rt = St) : yt = yt.next = Pt, ze |= _t;
        if (Qe = Qe.next, Qe === null) {
          if (Qe = ne.shared.pending, Qe === null) break;
          _t = Qe, Qe = _t.next, _t.next = null, ne.lastBaseUpdate = _t, ne.shared.pending = null;
        }
      } while (!0);
      if (yt === null && (rt = St), ne.baseState = rt, ne.firstBaseUpdate = ft, ne.lastBaseUpdate = yt, i = ne.shared.interleaved, i !== null) {
        ne = i;
        do
          ze |= ne.lane, ne = ne.next;
        while (ne !== i);
      } else ge === null && (ne.shared.lanes = 0);
      fa |= ze, t.lanes = ze, t.memoizedState = St;
    }
  }
  function Uf(t, i, w) {
    if (t = i.effects, i.effects = null, t !== null) for (i = 0; i < t.length; i++) {
      var N = t[i], ne = N.callback;
      if (ne !== null) {
        if (N.callback = null, N = w, typeof ne != "function") throw Error(ae(191, ne));
        ne.call(N);
      }
    }
  }
  var fs = {}, rn = In(fs), hs = In(fs), cs = In(fs);
  function ua(t) {
    if (t === fs) throw Error(ae(174));
    return t;
  }
  function Ou(t, i) {
    switch (cr(cs, i), cr(hs, t), cr(rn, fs), t = i.nodeType, t) {
      case 9:
      case 11:
        i = (i = i.documentElement) ? i.namespaceURI : r(null, "");
        break;
      default:
        t = t === 8 ? i.parentNode : i, i = t.namespaceURI || null, t = t.tagName, i = r(i, t);
    }
    vr(rn), cr(rn, i);
  }
  function Fa() {
    vr(rn), vr(hs), vr(cs);
  }
  function jf(t) {
    ua(cs.current);
    var i = ua(rn.current), w = r(i, t.type);
    i !== w && (cr(hs, t), cr(rn, w));
  }
  function Lu(t) {
    hs.current === t && (vr(rn), vr(hs));
  }
  var br = In(0);
  function ho(t) {
    for (var i = t; i !== null; ) {
      if (i.tag === 13) {
        var w = i.memoizedState;
        if (w !== null && (w = w.dehydrated, w === null || w.data === "$?" || w.data === "$!")) return i;
      } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
        if ((i.flags & 128) !== 0) return i;
      } else if (i.child !== null) {
        i.child.return = i, i = i.child;
        continue;
      }
      if (i === t) break;
      for (; i.sibling === null; ) {
        if (i.return === null || i.return === t) return null;
        i = i.return;
      }
      i.sibling.return = i.return, i = i.sibling;
    }
    return null;
  }
  var Nu = [];
  function Du() {
    for (var t = 0; t < Nu.length; t++) Nu[t]._workInProgressVersionPrimary = null;
    Nu.length = 0;
  }
  var co = b.ReactCurrentDispatcher, Bu = b.ReactCurrentBatchConfig, la = 0, Sr = null, Nr = null, Hr = null, po = !1, ds = !1, ps = 0, xd = 0;
  function ei() {
    throw Error(ae(321));
  }
  function zu(t, i) {
    if (i === null) return !1;
    for (var w = 0; w < i.length && w < t.length; w++) if (!Pr(t[w], i[w])) return !1;
    return !0;
  }
  function Fu(t, i, w, N, ne, ge) {
    if (la = ge, Sr = i, i.memoizedState = null, i.updateQueue = null, i.lanes = 0, co.current = t === null || t.memoizedState === null ? Td : Md, t = w(N, ne), ds) {
      ge = 0;
      do {
        if (ds = !1, ps = 0, 25 <= ge) throw Error(ae(301));
        ge += 1, Hr = Nr = null, i.updateQueue = null, co.current = Pd, t = w(N, ne);
      } while (ds);
    }
    if (co.current = go, i = Nr !== null && Nr.next !== null, la = 0, Hr = Nr = Sr = null, po = !1, i) throw Error(ae(300));
    return t;
  }
  function Uu() {
    var t = ps !== 0;
    return ps = 0, t;
  }
  function nn() {
    var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Hr === null ? Sr.memoizedState = Hr = t : Hr = Hr.next = t, Hr;
  }
  function Ri() {
    if (Nr === null) {
      var t = Sr.alternate;
      t = t !== null ? t.memoizedState : null;
    } else t = Nr.next;
    var i = Hr === null ? Sr.memoizedState : Hr.next;
    if (i !== null) Hr = i, Nr = t;
    else {
      if (t === null) throw Error(ae(310));
      Nr = t, t = { memoizedState: Nr.memoizedState, baseState: Nr.baseState, baseQueue: Nr.baseQueue, queue: Nr.queue, next: null }, Hr === null ? Sr.memoizedState = Hr = t : Hr = Hr.next = t;
    }
    return Hr;
  }
  function vs(t, i) {
    return typeof i == "function" ? i(t) : i;
  }
  function ju(t) {
    var i = Ri(), w = i.queue;
    if (w === null) throw Error(ae(311));
    w.lastRenderedReducer = t;
    var N = Nr, ne = N.baseQueue, ge = w.pending;
    if (ge !== null) {
      if (ne !== null) {
        var ze = ne.next;
        ne.next = ge.next, ge.next = ze;
      }
      N.baseQueue = ne = ge, w.pending = null;
    }
    if (ne !== null) {
      ge = ne.next, N = N.baseState;
      var Qe = ze = null, rt = null, ft = ge;
      do {
        var yt = ft.lane;
        if ((la & yt) === yt) rt !== null && (rt = rt.next = { lane: 0, action: ft.action, hasEagerState: ft.hasEagerState, eagerState: ft.eagerState, next: null }), N = ft.hasEagerState ? ft.eagerState : t(N, ft.action);
        else {
          var St = {
            lane: yt,
            action: ft.action,
            hasEagerState: ft.hasEagerState,
            eagerState: ft.eagerState,
            next: null
          };
          rt === null ? (Qe = rt = St, ze = N) : rt = rt.next = St, Sr.lanes |= yt, fa |= yt;
        }
        ft = ft.next;
      } while (ft !== null && ft !== ge);
      rt === null ? ze = N : rt.next = Qe, Pr(N, i.memoizedState) || (hi = !0), i.memoizedState = N, i.baseState = ze, i.baseQueue = rt, w.lastRenderedState = N;
    }
    if (t = w.interleaved, t !== null) {
      ne = t;
      do
        ge = ne.lane, Sr.lanes |= ge, fa |= ge, ne = ne.next;
      while (ne !== t);
    } else ne === null && (w.lanes = 0);
    return [i.memoizedState, w.dispatch];
  }
  function Hu(t) {
    var i = Ri(), w = i.queue;
    if (w === null) throw Error(ae(311));
    w.lastRenderedReducer = t;
    var N = w.dispatch, ne = w.pending, ge = i.memoizedState;
    if (ne !== null) {
      w.pending = null;
      var ze = ne = ne.next;
      do
        ge = t(ge, ze.action), ze = ze.next;
      while (ze !== ne);
      Pr(ge, i.memoizedState) || (hi = !0), i.memoizedState = ge, i.baseQueue === null && (i.baseState = ge), w.lastRenderedState = ge;
    }
    return [ge, N];
  }
  function Hf() {
  }
  function Gf(t, i) {
    var w = Sr, N = Ri(), ne = i(), ge = !Pr(N.memoizedState, ne);
    if (ge && (N.memoizedState = ne, hi = !0), N = N.queue, Gu(Zf.bind(null, w, N, t), [t]), N.getSnapshot !== i || ge || Hr !== null && Hr.memoizedState.tag & 1) {
      if (w.flags |= 2048, ms(9, Wf.bind(null, w, N, ne, i), void 0, null), Gr === null) throw Error(ae(349));
      (la & 30) !== 0 || Vf(w, i, ne);
    }
    return ne;
  }
  function Vf(t, i, w) {
    t.flags |= 16384, t = { getSnapshot: i, value: w }, i = Sr.updateQueue, i === null ? (i = { lastEffect: null, stores: null }, Sr.updateQueue = i, i.stores = [t]) : (w = i.stores, w === null ? i.stores = [t] : w.push(t));
  }
  function Wf(t, i, w, N) {
    i.value = w, i.getSnapshot = N, Yf(i) && Xf(t);
  }
  function Zf(t, i, w) {
    return w(function() {
      Yf(i) && Xf(t);
    });
  }
  function Yf(t) {
    var i = t.getSnapshot;
    t = t.value;
    try {
      var w = i();
      return !Pr(t, w);
    } catch {
      return !0;
    }
  }
  function Xf(t) {
    var i = vn(t, 1);
    i !== null && Wi(i, t, 1, -1);
  }
  function qf(t) {
    var i = nn();
    return typeof t == "function" && (t = t()), i.memoizedState = i.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: vs, lastRenderedState: t }, i.queue = t, t = t.dispatch = Ad.bind(null, Sr, t), [i.memoizedState, t];
  }
  function ms(t, i, w, N) {
    return t = { tag: t, create: i, destroy: w, deps: N, next: null }, i = Sr.updateQueue, i === null ? (i = { lastEffect: null, stores: null }, Sr.updateQueue = i, i.lastEffect = t.next = t) : (w = i.lastEffect, w === null ? i.lastEffect = t.next = t : (N = w.next, w.next = t, t.next = N, i.lastEffect = t)), t;
  }
  function Qf() {
    return Ri().memoizedState;
  }
  function vo(t, i, w, N) {
    var ne = nn();
    Sr.flags |= t, ne.memoizedState = ms(1 | i, w, void 0, N === void 0 ? null : N);
  }
  function mo(t, i, w, N) {
    var ne = Ri();
    N = N === void 0 ? null : N;
    var ge = void 0;
    if (Nr !== null) {
      var ze = Nr.memoizedState;
      if (ge = ze.destroy, N !== null && zu(N, ze.deps)) {
        ne.memoizedState = ms(i, w, ge, N);
        return;
      }
    }
    Sr.flags |= t, ne.memoizedState = ms(1 | i, w, ge, N);
  }
  function Kf(t, i) {
    return vo(8390656, 8, t, i);
  }
  function Gu(t, i) {
    return mo(2048, 8, t, i);
  }
  function $f(t, i) {
    return mo(4, 2, t, i);
  }
  function Jf(t, i) {
    return mo(4, 4, t, i);
  }
  function eh(t, i) {
    if (typeof i == "function") return t = t(), i(t), function() {
      i(null);
    };
    if (i != null) return t = t(), i.current = t, function() {
      i.current = null;
    };
  }
  function th(t, i, w) {
    return w = w != null ? w.concat([t]) : null, mo(4, 4, eh.bind(null, i, t), w);
  }
  function Vu() {
  }
  function rh(t, i) {
    var w = Ri();
    i = i === void 0 ? null : i;
    var N = w.memoizedState;
    return N !== null && i !== null && zu(i, N[1]) ? N[0] : (w.memoizedState = [t, i], t);
  }
  function ih(t, i) {
    var w = Ri();
    i = i === void 0 ? null : i;
    var N = w.memoizedState;
    return N !== null && i !== null && zu(i, N[1]) ? N[0] : (t = t(), w.memoizedState = [t, i], t);
  }
  function nh(t, i, w) {
    return (la & 21) === 0 ? (t.baseState && (t.baseState = !1, hi = !0), t.memoizedState = w) : (Pr(w, i) || (w = wn(), Sr.lanes |= w, fa |= w, t.baseState = !0), i);
  }
  function Cd(t, i) {
    var w = qt;
    qt = w !== 0 && 4 > w ? w : 4, t(!0);
    var N = Bu.transition;
    Bu.transition = {};
    try {
      t(!1), i();
    } finally {
      qt = w, Bu.transition = N;
    }
  }
  function ah() {
    return Ri().memoizedState;
  }
  function kd(t, i, w) {
    var N = Fn(t);
    if (w = { lane: N, action: w, hasEagerState: !1, eagerState: null, next: null }, sh(t)) oh(i, w);
    else if (w = Bf(t, i, w, N), w !== null) {
      var ne = si();
      Wi(w, t, N, ne), uh(w, i, N);
    }
  }
  function Ad(t, i, w) {
    var N = Fn(t), ne = { lane: N, action: w, hasEagerState: !1, eagerState: null, next: null };
    if (sh(t)) oh(i, ne);
    else {
      var ge = t.alternate;
      if (t.lanes === 0 && (ge === null || ge.lanes === 0) && (ge = i.lastRenderedReducer, ge !== null)) try {
        var ze = i.lastRenderedState, Qe = ge(ze, w);
        if (ne.hasEagerState = !0, ne.eagerState = Qe, Pr(Qe, ze)) {
          var rt = i.interleaved;
          rt === null ? (ne.next = ne, Iu(i)) : (ne.next = rt.next, rt.next = ne), i.interleaved = ne;
          return;
        }
      } catch {
      } finally {
      }
      w = Bf(t, i, ne, N), w !== null && (ne = si(), Wi(w, t, N, ne), uh(w, i, N));
    }
  }
  function sh(t) {
    var i = t.alternate;
    return t === Sr || i !== null && i === Sr;
  }
  function oh(t, i) {
    ds = po = !0;
    var w = t.pending;
    w === null ? i.next = i : (i.next = w.next, w.next = i), t.pending = i;
  }
  function uh(t, i, w) {
    if ((w & 4194240) !== 0) {
      var N = i.lanes;
      N &= t.pendingLanes, w |= N, i.lanes = w, Xi(t, w);
    }
  }
  var go = { readContext: Ii, useCallback: ei, useContext: ei, useEffect: ei, useImperativeHandle: ei, useInsertionEffect: ei, useLayoutEffect: ei, useMemo: ei, useReducer: ei, useRef: ei, useState: ei, useDebugValue: ei, useDeferredValue: ei, useTransition: ei, useMutableSource: ei, useSyncExternalStore: ei, useId: ei, unstable_isNewReconciler: !1 }, Td = { readContext: Ii, useCallback: function(t, i) {
    return nn().memoizedState = [t, i === void 0 ? null : i], t;
  }, useContext: Ii, useEffect: Kf, useImperativeHandle: function(t, i, w) {
    return w = w != null ? w.concat([t]) : null, vo(
      4194308,
      4,
      eh.bind(null, i, t),
      w
    );
  }, useLayoutEffect: function(t, i) {
    return vo(4194308, 4, t, i);
  }, useInsertionEffect: function(t, i) {
    return vo(4, 2, t, i);
  }, useMemo: function(t, i) {
    var w = nn();
    return i = i === void 0 ? null : i, t = t(), w.memoizedState = [t, i], t;
  }, useReducer: function(t, i, w) {
    var N = nn();
    return i = w !== void 0 ? w(i) : i, N.memoizedState = N.baseState = i, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: i }, N.queue = t, t = t.dispatch = kd.bind(null, Sr, t), [N.memoizedState, t];
  }, useRef: function(t) {
    var i = nn();
    return t = { current: t }, i.memoizedState = t;
  }, useState: qf, useDebugValue: Vu, useDeferredValue: function(t) {
    return nn().memoizedState = t;
  }, useTransition: function() {
    var t = qf(!1), i = t[0];
    return t = Cd.bind(null, t[1]), nn().memoizedState = t, [i, t];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(t, i, w) {
    var N = Sr, ne = nn();
    if (mr) {
      if (w === void 0) throw Error(ae(407));
      w = w();
    } else {
      if (w = i(), Gr === null) throw Error(ae(349));
      (la & 30) !== 0 || Vf(N, i, w);
    }
    ne.memoizedState = w;
    var ge = { value: w, getSnapshot: i };
    return ne.queue = ge, Kf(Zf.bind(
      null,
      N,
      ge,
      t
    ), [t]), N.flags |= 2048, ms(9, Wf.bind(null, N, ge, w, i), void 0, null), w;
  }, useId: function() {
    var t = nn(), i = Gr.identifierPrefix;
    if (mr) {
      var w = pn, N = dn;
      w = (N & ~(1 << 32 - tr(N) - 1)).toString(32) + w, i = ":" + i + "R" + w, w = ps++, 0 < w && (i += "H" + w.toString(32)), i += ":";
    } else w = xd++, i = ":" + i + "r" + w.toString(32) + ":";
    return t.memoizedState = i;
  }, unstable_isNewReconciler: !1 }, Md = {
    readContext: Ii,
    useCallback: rh,
    useContext: Ii,
    useEffect: Gu,
    useImperativeHandle: th,
    useInsertionEffect: $f,
    useLayoutEffect: Jf,
    useMemo: ih,
    useReducer: ju,
    useRef: Qf,
    useState: function() {
      return ju(vs);
    },
    useDebugValue: Vu,
    useDeferredValue: function(t) {
      var i = Ri();
      return nh(i, Nr.memoizedState, t);
    },
    useTransition: function() {
      var t = ju(vs)[0], i = Ri().memoizedState;
      return [t, i];
    },
    useMutableSource: Hf,
    useSyncExternalStore: Gf,
    useId: ah,
    unstable_isNewReconciler: !1
  }, Pd = { readContext: Ii, useCallback: rh, useContext: Ii, useEffect: Gu, useImperativeHandle: th, useInsertionEffect: $f, useLayoutEffect: Jf, useMemo: ih, useReducer: Hu, useRef: Qf, useState: function() {
    return Hu(vs);
  }, useDebugValue: Vu, useDeferredValue: function(t) {
    var i = Ri();
    return Nr === null ? i.memoizedState = t : nh(i, Nr.memoizedState, t);
  }, useTransition: function() {
    var t = Hu(vs)[0], i = Ri().memoizedState;
    return [t, i];
  }, useMutableSource: Hf, useSyncExternalStore: Gf, useId: ah, unstable_isNewReconciler: !1 };
  function Hi(t, i) {
    if (t && t.defaultProps) {
      i = de({}, i), t = t.defaultProps;
      for (var w in t) i[w] === void 0 && (i[w] = t[w]);
      return i;
    }
    return i;
  }
  function Wu(t, i, w, N) {
    i = t.memoizedState, w = w(N, i), w = w == null ? i : de({}, i, w), t.memoizedState = w, t.lanes === 0 && (t.updateQueue.baseState = w);
  }
  var _o = { isMounted: function(t) {
    return (t = t._reactInternals) ? vt(t) === t : !1;
  }, enqueueSetState: function(t, i, w) {
    t = t._reactInternals;
    var N = si(), ne = Fn(t), ge = mn(N, ne);
    ge.payload = i, w != null && (ge.callback = w), i = Nn(t, ge, ne), i !== null && (Wi(i, t, ne, N), lo(i, t, ne));
  }, enqueueReplaceState: function(t, i, w) {
    t = t._reactInternals;
    var N = si(), ne = Fn(t), ge = mn(N, ne);
    ge.tag = 1, ge.payload = i, w != null && (ge.callback = w), i = Nn(t, ge, ne), i !== null && (Wi(i, t, ne, N), lo(i, t, ne));
  }, enqueueForceUpdate: function(t, i) {
    t = t._reactInternals;
    var w = si(), N = Fn(t), ne = mn(w, N);
    ne.tag = 2, i != null && (ne.callback = i), i = Nn(t, ne, N), i !== null && (Wi(i, t, N, w), lo(i, t, N));
  } };
  function lh(t, i, w, N, ne, ge, ze) {
    return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(N, ge, ze) : i.prototype && i.prototype.isPureReactComponent ? !qe(w, N) || !qe(ne, ge) : !0;
  }
  function fh(t, i, w) {
    var N = !1, ne = Rn, ge = i.contextType;
    return typeof ge == "object" && ge !== null ? ge = Ii(ge) : (ne = fi(i) ? na : Jr.current, N = i.contextTypes, ge = (N = N != null) ? Ra(t, ne) : Rn), i = new i(w, ge), t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, i.updater = _o, t.stateNode = i, i._reactInternals = t, N && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = ne, t.__reactInternalMemoizedMaskedChildContext = ge), i;
  }
  function hh(t, i, w, N) {
    t = i.state, typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(w, N), typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(w, N), i.state !== t && _o.enqueueReplaceState(i, i.state, null);
  }
  function Zu(t, i, w, N) {
    var ne = t.stateNode;
    ne.props = w, ne.state = t.memoizedState, ne.refs = {}, Ru(t);
    var ge = i.contextType;
    typeof ge == "object" && ge !== null ? ne.context = Ii(ge) : (ge = fi(i) ? na : Jr.current, ne.context = Ra(t, ge)), ne.state = t.memoizedState, ge = i.getDerivedStateFromProps, typeof ge == "function" && (Wu(t, i, ge, w), ne.state = t.memoizedState), typeof i.getDerivedStateFromProps == "function" || typeof ne.getSnapshotBeforeUpdate == "function" || typeof ne.UNSAFE_componentWillMount != "function" && typeof ne.componentWillMount != "function" || (i = ne.state, typeof ne.componentWillMount == "function" && ne.componentWillMount(), typeof ne.UNSAFE_componentWillMount == "function" && ne.UNSAFE_componentWillMount(), i !== ne.state && _o.enqueueReplaceState(ne, ne.state, null), fo(t, w, ne, N), ne.state = t.memoizedState), typeof ne.componentDidMount == "function" && (t.flags |= 4194308);
  }
  function Ua(t, i) {
    try {
      var w = "", N = i;
      do
        w += xe(N), N = N.return;
      while (N);
      var ne = w;
    } catch (ge) {
      ne = `
Error generating stack: ` + ge.message + `
` + ge.stack;
    }
    return { value: t, source: i, stack: ne, digest: null };
  }
  function Yu(t, i, w) {
    return { value: t, source: null, stack: w ?? null, digest: i ?? null };
  }
  function Xu(t, i) {
    try {
      console.error(i.value);
    } catch (w) {
      setTimeout(function() {
        throw w;
      });
    }
  }
  var Id = typeof WeakMap == "function" ? WeakMap : Map;
  function ch(t, i, w) {
    w = mn(-1, w), w.tag = 3, w.payload = { element: null };
    var N = i.value;
    return w.callback = function() {
      Co || (Co = !0, ll = N), Xu(t, i);
    }, w;
  }
  function dh(t, i, w) {
    w = mn(-1, w), w.tag = 3;
    var N = t.type.getDerivedStateFromError;
    if (typeof N == "function") {
      var ne = i.value;
      w.payload = function() {
        return N(ne);
      }, w.callback = function() {
        Xu(t, i);
      };
    }
    var ge = t.stateNode;
    return ge !== null && typeof ge.componentDidCatch == "function" && (w.callback = function() {
      Xu(t, i), typeof N != "function" && (Bn === null ? Bn = /* @__PURE__ */ new Set([this]) : Bn.add(this));
      var ze = i.stack;
      this.componentDidCatch(i.value, { componentStack: ze !== null ? ze : "" });
    }), w;
  }
  function ph(t, i, w) {
    var N = t.pingCache;
    if (N === null) {
      N = t.pingCache = new Id();
      var ne = /* @__PURE__ */ new Set();
      N.set(i, ne);
    } else ne = N.get(i), ne === void 0 && (ne = /* @__PURE__ */ new Set(), N.set(i, ne));
    ne.has(w) || (ne.add(w), t = Wd.bind(null, t, i, w), i.then(t, t));
  }
  function vh(t) {
    do {
      var i;
      if ((i = t.tag === 13) && (i = t.memoizedState, i = i !== null ? i.dehydrated !== null : !0), i) return t;
      t = t.return;
    } while (t !== null);
    return null;
  }
  function mh(t, i, w, N, ne) {
    return (t.mode & 1) === 0 ? (t === i ? t.flags |= 65536 : (t.flags |= 128, w.flags |= 131072, w.flags &= -52805, w.tag === 1 && (w.alternate === null ? w.tag = 17 : (i = mn(-1, 1), i.tag = 2, Nn(w, i, 1))), w.lanes |= 1), t) : (t.flags |= 65536, t.lanes = ne, t);
  }
  var Rd = b.ReactCurrentOwner, hi = !1;
  function ai(t, i, w, N) {
    i.child = t === null ? Df(i, null, w, N) : Da(i, t.child, w, N);
  }
  function gh(t, i, w, N, ne) {
    w = w.render;
    var ge = i.ref;
    return za(i, ne), N = Fu(t, i, w, N, ge, ne), w = Uu(), t !== null && !hi ? (i.updateQueue = t.updateQueue, i.flags &= -2053, t.lanes &= ~ne, gn(t, i, ne)) : (mr && w && Su(i), i.flags |= 1, ai(t, i, N, ne), i.child);
  }
  function _h(t, i, w, N, ne) {
    if (t === null) {
      var ge = w.type;
      return typeof ge == "function" && !ml(ge) && ge.defaultProps === void 0 && w.compare === null && w.defaultProps === void 0 ? (i.tag = 15, i.type = ge, yh(t, i, ge, N, ne)) : (t = Io(w.type, null, N, i, i.mode, ne), t.ref = i.ref, t.return = i, i.child = t);
    }
    if (ge = t.child, (t.lanes & ne) === 0) {
      var ze = ge.memoizedProps;
      if (w = w.compare, w = w !== null ? w : qe, w(ze, N) && t.ref === i.ref) return gn(t, i, ne);
    }
    return i.flags |= 1, t = jn(ge, N), t.ref = i.ref, t.return = i, i.child = t;
  }
  function yh(t, i, w, N, ne) {
    if (t !== null) {
      var ge = t.memoizedProps;
      if (qe(ge, N) && t.ref === i.ref) if (hi = !1, i.pendingProps = N = ge, (t.lanes & ne) !== 0) (t.flags & 131072) !== 0 && (hi = !0);
      else return i.lanes = t.lanes, gn(t, i, ne);
    }
    return qu(t, i, w, N, ne);
  }
  function wh(t, i, w) {
    var N = i.pendingProps, ne = N.children, ge = t !== null ? t.memoizedState : null;
    if (N.mode === "hidden") if ((i.mode & 1) === 0) i.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, cr(Ha, xi), xi |= w;
    else {
      if ((w & 1073741824) === 0) return t = ge !== null ? ge.baseLanes | w : w, i.lanes = i.childLanes = 1073741824, i.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, i.updateQueue = null, cr(Ha, xi), xi |= t, null;
      i.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, N = ge !== null ? ge.baseLanes : w, cr(Ha, xi), xi |= N;
    }
    else ge !== null ? (N = ge.baseLanes | w, i.memoizedState = null) : N = w, cr(Ha, xi), xi |= N;
    return ai(t, i, ne, w), i.child;
  }
  function bh(t, i) {
    var w = i.ref;
    (t === null && w !== null || t !== null && t.ref !== w) && (i.flags |= 512, i.flags |= 2097152);
  }
  function qu(t, i, w, N, ne) {
    var ge = fi(w) ? na : Jr.current;
    return ge = Ra(i, ge), za(i, ne), w = Fu(t, i, w, N, ge, ne), N = Uu(), t !== null && !hi ? (i.updateQueue = t.updateQueue, i.flags &= -2053, t.lanes &= ~ne, gn(t, i, ne)) : (mr && N && Su(i), i.flags |= 1, ai(t, i, w, ne), i.child);
  }
  function Sh(t, i, w, N, ne) {
    if (fi(w)) {
      var ge = !0;
      to(i);
    } else ge = !1;
    if (za(i, ne), i.stateNode === null) wo(t, i), fh(i, w, N), Zu(i, w, N, ne), N = !0;
    else if (t === null) {
      var ze = i.stateNode, Qe = i.memoizedProps;
      ze.props = Qe;
      var rt = ze.context, ft = w.contextType;
      typeof ft == "object" && ft !== null ? ft = Ii(ft) : (ft = fi(w) ? na : Jr.current, ft = Ra(i, ft));
      var yt = w.getDerivedStateFromProps, St = typeof yt == "function" || typeof ze.getSnapshotBeforeUpdate == "function";
      St || typeof ze.UNSAFE_componentWillReceiveProps != "function" && typeof ze.componentWillReceiveProps != "function" || (Qe !== N || rt !== ft) && hh(i, ze, N, ft), Ln = !1;
      var _t = i.memoizedState;
      ze.state = _t, fo(i, N, ze, ne), rt = i.memoizedState, Qe !== N || _t !== rt || li.current || Ln ? (typeof yt == "function" && (Wu(i, w, yt, N), rt = i.memoizedState), (Qe = Ln || lh(i, w, Qe, N, _t, rt, ft)) ? (St || typeof ze.UNSAFE_componentWillMount != "function" && typeof ze.componentWillMount != "function" || (typeof ze.componentWillMount == "function" && ze.componentWillMount(), typeof ze.UNSAFE_componentWillMount == "function" && ze.UNSAFE_componentWillMount()), typeof ze.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof ze.componentDidMount == "function" && (i.flags |= 4194308), i.memoizedProps = N, i.memoizedState = rt), ze.props = N, ze.state = rt, ze.context = ft, N = Qe) : (typeof ze.componentDidMount == "function" && (i.flags |= 4194308), N = !1);
    } else {
      ze = i.stateNode, zf(t, i), Qe = i.memoizedProps, ft = i.type === i.elementType ? Qe : Hi(i.type, Qe), ze.props = ft, St = i.pendingProps, _t = ze.context, rt = w.contextType, typeof rt == "object" && rt !== null ? rt = Ii(rt) : (rt = fi(w) ? na : Jr.current, rt = Ra(i, rt));
      var Pt = w.getDerivedStateFromProps;
      (yt = typeof Pt == "function" || typeof ze.getSnapshotBeforeUpdate == "function") || typeof ze.UNSAFE_componentWillReceiveProps != "function" && typeof ze.componentWillReceiveProps != "function" || (Qe !== St || _t !== rt) && hh(i, ze, N, rt), Ln = !1, _t = i.memoizedState, ze.state = _t, fo(i, N, ze, ne);
      var Rt = i.memoizedState;
      Qe !== St || _t !== Rt || li.current || Ln ? (typeof Pt == "function" && (Wu(i, w, Pt, N), Rt = i.memoizedState), (ft = Ln || lh(i, w, ft, N, _t, Rt, rt) || !1) ? (yt || typeof ze.UNSAFE_componentWillUpdate != "function" && typeof ze.componentWillUpdate != "function" || (typeof ze.componentWillUpdate == "function" && ze.componentWillUpdate(N, Rt, rt), typeof ze.UNSAFE_componentWillUpdate == "function" && ze.UNSAFE_componentWillUpdate(N, Rt, rt)), typeof ze.componentDidUpdate == "function" && (i.flags |= 4), typeof ze.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof ze.componentDidUpdate != "function" || Qe === t.memoizedProps && _t === t.memoizedState || (i.flags |= 4), typeof ze.getSnapshotBeforeUpdate != "function" || Qe === t.memoizedProps && _t === t.memoizedState || (i.flags |= 1024), i.memoizedProps = N, i.memoizedState = Rt), ze.props = N, ze.state = Rt, ze.context = rt, N = ft) : (typeof ze.componentDidUpdate != "function" || Qe === t.memoizedProps && _t === t.memoizedState || (i.flags |= 4), typeof ze.getSnapshotBeforeUpdate != "function" || Qe === t.memoizedProps && _t === t.memoizedState || (i.flags |= 1024), N = !1);
    }
    return Qu(t, i, w, N, ge, ne);
  }
  function Qu(t, i, w, N, ne, ge) {
    bh(t, i);
    var ze = (i.flags & 128) !== 0;
    if (!N && !ze) return ne && Af(i, w, !1), gn(t, i, ge);
    N = i.stateNode, Rd.current = i;
    var Qe = ze && typeof w.getDerivedStateFromError != "function" ? null : N.render();
    return i.flags |= 1, t !== null && ze ? (i.child = Da(i, t.child, null, ge), i.child = Da(i, null, Qe, ge)) : ai(t, i, Qe, ge), i.memoizedState = N.state, ne && Af(i, w, !0), i.child;
  }
  function Eh(t) {
    var i = t.stateNode;
    i.pendingContext ? Cf(t, i.pendingContext, i.pendingContext !== i.context) : i.context && Cf(t, i.context, !1), Ou(t, i.containerInfo);
  }
  function xh(t, i, w, N, ne) {
    return Na(), ku(ne), i.flags |= 256, ai(t, i, w, N), i.child;
  }
  var Ku = { dehydrated: null, treeContext: null, retryLane: 0 };
  function $u(t) {
    return { baseLanes: t, cachePool: null, transitions: null };
  }
  function Ch(t, i, w) {
    var N = i.pendingProps, ne = br.current, ge = !1, ze = (i.flags & 128) !== 0, Qe;
    if ((Qe = ze) || (Qe = t !== null && t.memoizedState === null ? !1 : (ne & 2) !== 0), Qe ? (ge = !0, i.flags &= -129) : (t === null || t.memoizedState !== null) && (ne |= 1), cr(br, ne & 1), t === null)
      return Cu(i), t = i.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? ((i.mode & 1) === 0 ? i.lanes = 1 : t.data === "$!" ? i.lanes = 8 : i.lanes = 1073741824, null) : (ze = N.children, t = N.fallback, ge ? (N = i.mode, ge = i.child, ze = { mode: "hidden", children: ze }, (N & 1) === 0 && ge !== null ? (ge.childLanes = 0, ge.pendingProps = ze) : ge = Ro(ze, N, 0, null), t = pa(t, N, w, null), ge.return = i, t.return = i, ge.sibling = t, i.child = ge, i.child.memoizedState = $u(w), i.memoizedState = Ku, t) : Ju(i, ze));
    if (ne = t.memoizedState, ne !== null && (Qe = ne.dehydrated, Qe !== null)) return Od(t, i, ze, N, Qe, ne, w);
    if (ge) {
      ge = N.fallback, ze = i.mode, ne = t.child, Qe = ne.sibling;
      var rt = { mode: "hidden", children: N.children };
      return (ze & 1) === 0 && i.child !== ne ? (N = i.child, N.childLanes = 0, N.pendingProps = rt, i.deletions = null) : (N = jn(ne, rt), N.subtreeFlags = ne.subtreeFlags & 14680064), Qe !== null ? ge = jn(Qe, ge) : (ge = pa(ge, ze, w, null), ge.flags |= 2), ge.return = i, N.return = i, N.sibling = ge, i.child = N, N = ge, ge = i.child, ze = t.child.memoizedState, ze = ze === null ? $u(w) : { baseLanes: ze.baseLanes | w, cachePool: null, transitions: ze.transitions }, ge.memoizedState = ze, ge.childLanes = t.childLanes & ~w, i.memoizedState = Ku, N;
    }
    return ge = t.child, t = ge.sibling, N = jn(ge, { mode: "visible", children: N.children }), (i.mode & 1) === 0 && (N.lanes = w), N.return = i, N.sibling = null, t !== null && (w = i.deletions, w === null ? (i.deletions = [t], i.flags |= 16) : w.push(t)), i.child = N, i.memoizedState = null, N;
  }
  function Ju(t, i) {
    return i = Ro({ mode: "visible", children: i }, t.mode, 0, null), i.return = t, t.child = i;
  }
  function yo(t, i, w, N) {
    return N !== null && ku(N), Da(i, t.child, null, w), t = Ju(i, i.pendingProps.children), t.flags |= 2, i.memoizedState = null, t;
  }
  function Od(t, i, w, N, ne, ge, ze) {
    if (w)
      return i.flags & 256 ? (i.flags &= -257, N = Yu(Error(ae(422))), yo(t, i, ze, N)) : i.memoizedState !== null ? (i.child = t.child, i.flags |= 128, null) : (ge = N.fallback, ne = i.mode, N = Ro({ mode: "visible", children: N.children }, ne, 0, null), ge = pa(ge, ne, ze, null), ge.flags |= 2, N.return = i, ge.return = i, N.sibling = ge, i.child = N, (i.mode & 1) !== 0 && Da(i, t.child, null, ze), i.child.memoizedState = $u(ze), i.memoizedState = Ku, ge);
    if ((i.mode & 1) === 0) return yo(t, i, ze, null);
    if (ne.data === "$!") {
      if (N = ne.nextSibling && ne.nextSibling.dataset, N) var Qe = N.dgst;
      return N = Qe, ge = Error(ae(419)), N = Yu(ge, N, void 0), yo(t, i, ze, N);
    }
    if (Qe = (ze & t.childLanes) !== 0, hi || Qe) {
      if (N = Gr, N !== null) {
        switch (ze & -ze) {
          case 4:
            ne = 2;
            break;
          case 16:
            ne = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            ne = 32;
            break;
          case 536870912:
            ne = 268435456;
            break;
          default:
            ne = 0;
        }
        ne = (ne & (N.suspendedLanes | ze)) !== 0 ? 0 : ne, ne !== 0 && ne !== ge.retryLane && (ge.retryLane = ne, vn(t, ne), Wi(N, t, ne, -1));
      }
      return vl(), N = Yu(Error(ae(421))), yo(t, i, ze, N);
    }
    return ne.data === "$?" ? (i.flags |= 128, i.child = t.child, i = Zd.bind(null, t), ne._reactRetry = i, null) : (t = ge.treeContext, Ei = Pn(ne.nextSibling), Si = i, mr = !0, ji = null, t !== null && (Mi[Pi++] = dn, Mi[Pi++] = pn, Mi[Pi++] = aa, dn = t.id, pn = t.overflow, aa = i), i = Ju(i, N.children), i.flags |= 4096, i);
  }
  function kh(t, i, w) {
    t.lanes |= i;
    var N = t.alternate;
    N !== null && (N.lanes |= i), Pu(t.return, i, w);
  }
  function el(t, i, w, N, ne) {
    var ge = t.memoizedState;
    ge === null ? t.memoizedState = { isBackwards: i, rendering: null, renderingStartTime: 0, last: N, tail: w, tailMode: ne } : (ge.isBackwards = i, ge.rendering = null, ge.renderingStartTime = 0, ge.last = N, ge.tail = w, ge.tailMode = ne);
  }
  function Ah(t, i, w) {
    var N = i.pendingProps, ne = N.revealOrder, ge = N.tail;
    if (ai(t, i, N.children, w), N = br.current, (N & 2) !== 0) N = N & 1 | 2, i.flags |= 128;
    else {
      if (t !== null && (t.flags & 128) !== 0) e: for (t = i.child; t !== null; ) {
        if (t.tag === 13) t.memoizedState !== null && kh(t, w, i);
        else if (t.tag === 19) kh(t, w, i);
        else if (t.child !== null) {
          t.child.return = t, t = t.child;
          continue;
        }
        if (t === i) break e;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === i) break e;
          t = t.return;
        }
        t.sibling.return = t.return, t = t.sibling;
      }
      N &= 1;
    }
    if (cr(br, N), (i.mode & 1) === 0) i.memoizedState = null;
    else switch (ne) {
      case "forwards":
        for (w = i.child, ne = null; w !== null; ) t = w.alternate, t !== null && ho(t) === null && (ne = w), w = w.sibling;
        w = ne, w === null ? (ne = i.child, i.child = null) : (ne = w.sibling, w.sibling = null), el(i, !1, ne, w, ge);
        break;
      case "backwards":
        for (w = null, ne = i.child, i.child = null; ne !== null; ) {
          if (t = ne.alternate, t !== null && ho(t) === null) {
            i.child = ne;
            break;
          }
          t = ne.sibling, ne.sibling = w, w = ne, ne = t;
        }
        el(i, !0, w, null, ge);
        break;
      case "together":
        el(i, !1, null, null, void 0);
        break;
      default:
        i.memoizedState = null;
    }
    return i.child;
  }
  function wo(t, i) {
    (i.mode & 1) === 0 && t !== null && (t.alternate = null, i.alternate = null, i.flags |= 2);
  }
  function gn(t, i, w) {
    if (t !== null && (i.dependencies = t.dependencies), fa |= i.lanes, (w & i.childLanes) === 0) return null;
    if (t !== null && i.child !== t.child) throw Error(ae(153));
    if (i.child !== null) {
      for (t = i.child, w = jn(t, t.pendingProps), i.child = w, w.return = i; t.sibling !== null; ) t = t.sibling, w = w.sibling = jn(t, t.pendingProps), w.return = i;
      w.sibling = null;
    }
    return i.child;
  }
  function Ld(t, i, w) {
    switch (i.tag) {
      case 3:
        Eh(i), Na();
        break;
      case 5:
        jf(i);
        break;
      case 1:
        fi(i.type) && to(i);
        break;
      case 4:
        Ou(i, i.stateNode.containerInfo);
        break;
      case 10:
        var N = i.type._context, ne = i.memoizedProps.value;
        cr(oo, N._currentValue), N._currentValue = ne;
        break;
      case 13:
        if (N = i.memoizedState, N !== null)
          return N.dehydrated !== null ? (cr(br, br.current & 1), i.flags |= 128, null) : (w & i.child.childLanes) !== 0 ? Ch(t, i, w) : (cr(br, br.current & 1), t = gn(t, i, w), t !== null ? t.sibling : null);
        cr(br, br.current & 1);
        break;
      case 19:
        if (N = (w & i.childLanes) !== 0, (t.flags & 128) !== 0) {
          if (N) return Ah(t, i, w);
          i.flags |= 128;
        }
        if (ne = i.memoizedState, ne !== null && (ne.rendering = null, ne.tail = null, ne.lastEffect = null), cr(br, br.current), N) break;
        return null;
      case 22:
      case 23:
        return i.lanes = 0, wh(t, i, w);
    }
    return gn(t, i, w);
  }
  var Th, tl, Mh, Ph;
  Th = function(t, i) {
    for (var w = i.child; w !== null; ) {
      if (w.tag === 5 || w.tag === 6) t.appendChild(w.stateNode);
      else if (w.tag !== 4 && w.child !== null) {
        w.child.return = w, w = w.child;
        continue;
      }
      if (w === i) break;
      for (; w.sibling === null; ) {
        if (w.return === null || w.return === i) return;
        w = w.return;
      }
      w.sibling.return = w.return, w = w.sibling;
    }
  }, tl = function() {
  }, Mh = function(t, i, w, N) {
    var ne = t.memoizedProps;
    if (ne !== N) {
      t = i.stateNode, ua(rn.current);
      var ge = null;
      switch (w) {
        case "input":
          ne = Ge(t, ne), N = Ge(t, N), ge = [];
          break;
        case "select":
          ne = de({}, ne, { value: void 0 }), N = de({}, N, { value: void 0 }), ge = [];
          break;
        case "textarea":
          ne = ve(t, ne), N = ve(t, N), ge = [];
          break;
        default:
          typeof ne.onClick != "function" && typeof N.onClick == "function" && (t.onclick = $s);
      }
      pe(w, N);
      var ze;
      w = null;
      for (ft in ne) if (!N.hasOwnProperty(ft) && ne.hasOwnProperty(ft) && ne[ft] != null) if (ft === "style") {
        var Qe = ne[ft];
        for (ze in Qe) Qe.hasOwnProperty(ze) && (w || (w = {}), w[ze] = "");
      } else ft !== "dangerouslySetInnerHTML" && ft !== "children" && ft !== "suppressContentEditableWarning" && ft !== "suppressHydrationWarning" && ft !== "autoFocus" && (Z.hasOwnProperty(ft) ? ge || (ge = []) : (ge = ge || []).push(ft, null));
      for (ft in N) {
        var rt = N[ft];
        if (Qe = ne != null ? ne[ft] : void 0, N.hasOwnProperty(ft) && rt !== Qe && (rt != null || Qe != null)) if (ft === "style") if (Qe) {
          for (ze in Qe) !Qe.hasOwnProperty(ze) || rt && rt.hasOwnProperty(ze) || (w || (w = {}), w[ze] = "");
          for (ze in rt) rt.hasOwnProperty(ze) && Qe[ze] !== rt[ze] && (w || (w = {}), w[ze] = rt[ze]);
        } else w || (ge || (ge = []), ge.push(
          ft,
          w
        )), w = rt;
        else ft === "dangerouslySetInnerHTML" ? (rt = rt ? rt.__html : void 0, Qe = Qe ? Qe.__html : void 0, rt != null && Qe !== rt && (ge = ge || []).push(ft, rt)) : ft === "children" ? typeof rt != "string" && typeof rt != "number" || (ge = ge || []).push(ft, "" + rt) : ft !== "suppressContentEditableWarning" && ft !== "suppressHydrationWarning" && (Z.hasOwnProperty(ft) ? (rt != null && ft === "onScroll" && pr("scroll", t), ge || Qe === rt || (ge = [])) : (ge = ge || []).push(ft, rt));
      }
      w && (ge = ge || []).push("style", w);
      var ft = ge;
      (i.updateQueue = ft) && (i.flags |= 4);
    }
  }, Ph = function(t, i, w, N) {
    w !== N && (i.flags |= 4);
  };
  function gs(t, i) {
    if (!mr) switch (t.tailMode) {
      case "hidden":
        i = t.tail;
        for (var w = null; i !== null; ) i.alternate !== null && (w = i), i = i.sibling;
        w === null ? t.tail = null : w.sibling = null;
        break;
      case "collapsed":
        w = t.tail;
        for (var N = null; w !== null; ) w.alternate !== null && (N = w), w = w.sibling;
        N === null ? i || t.tail === null ? t.tail = null : t.tail.sibling = null : N.sibling = null;
    }
  }
  function ti(t) {
    var i = t.alternate !== null && t.alternate.child === t.child, w = 0, N = 0;
    if (i) for (var ne = t.child; ne !== null; ) w |= ne.lanes | ne.childLanes, N |= ne.subtreeFlags & 14680064, N |= ne.flags & 14680064, ne.return = t, ne = ne.sibling;
    else for (ne = t.child; ne !== null; ) w |= ne.lanes | ne.childLanes, N |= ne.subtreeFlags, N |= ne.flags, ne.return = t, ne = ne.sibling;
    return t.subtreeFlags |= N, t.childLanes = w, i;
  }
  function Nd(t, i, w) {
    var N = i.pendingProps;
    switch (Eu(i), i.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ti(i), null;
      case 1:
        return fi(i.type) && eo(), ti(i), null;
      case 3:
        return N = i.stateNode, Fa(), vr(li), vr(Jr), Du(), N.pendingContext && (N.context = N.pendingContext, N.pendingContext = null), (t === null || t.child === null) && (ao(i) ? i.flags |= 4 : t === null || t.memoizedState.isDehydrated && (i.flags & 256) === 0 || (i.flags |= 1024, ji !== null && (cl(ji), ji = null))), tl(t, i), ti(i), null;
      case 5:
        Lu(i);
        var ne = ua(cs.current);
        if (w = i.type, t !== null && i.stateNode != null) Mh(t, i, w, N, ne), t.ref !== i.ref && (i.flags |= 512, i.flags |= 2097152);
        else {
          if (!N) {
            if (i.stateNode === null) throw Error(ae(166));
            return ti(i), null;
          }
          if (t = ua(rn.current), ao(i)) {
            N = i.stateNode, w = i.type;
            var ge = i.memoizedProps;
            switch (N[tn] = i, N[os] = ge, t = (i.mode & 1) !== 0, w) {
              case "dialog":
                pr("cancel", N), pr("close", N);
                break;
              case "iframe":
              case "object":
              case "embed":
                pr("load", N);
                break;
              case "video":
              case "audio":
                for (ne = 0; ne < ns.length; ne++) pr(ns[ne], N);
                break;
              case "source":
                pr("error", N);
                break;
              case "img":
              case "image":
              case "link":
                pr(
                  "error",
                  N
                ), pr("load", N);
                break;
              case "details":
                pr("toggle", N);
                break;
              case "input":
                Ie(N, ge), pr("invalid", N);
                break;
              case "select":
                N._wrapperState = { wasMultiple: !!ge.multiple }, pr("invalid", N);
                break;
              case "textarea":
                Y(N, ge), pr("invalid", N);
            }
            pe(w, ge), ne = null;
            for (var ze in ge) if (ge.hasOwnProperty(ze)) {
              var Qe = ge[ze];
              ze === "children" ? typeof Qe == "string" ? N.textContent !== Qe && (ge.suppressHydrationWarning !== !0 && Ks(N.textContent, Qe, t), ne = ["children", Qe]) : typeof Qe == "number" && N.textContent !== "" + Qe && (ge.suppressHydrationWarning !== !0 && Ks(
                N.textContent,
                Qe,
                t
              ), ne = ["children", "" + Qe]) : Z.hasOwnProperty(ze) && Qe != null && ze === "onScroll" && pr("scroll", N);
            }
            switch (w) {
              case "input":
                Ze(N), _e(N, ge, !0);
                break;
              case "textarea":
                Ze(N), Ae(N);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof ge.onClick == "function" && (N.onclick = $s);
            }
            N = ne, i.updateQueue = N, N !== null && (i.flags |= 4);
          } else {
            ze = ne.nodeType === 9 ? ne : ne.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = e(w)), t === "http://www.w3.org/1999/xhtml" ? w === "script" ? (t = ze.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof N.is == "string" ? t = ze.createElement(w, { is: N.is }) : (t = ze.createElement(w), w === "select" && (ze = t, N.multiple ? ze.multiple = !0 : N.size && (ze.size = N.size))) : t = ze.createElementNS(t, w), t[tn] = i, t[os] = N, Th(t, i, !1, !1), i.stateNode = t;
            e: {
              switch (ze = P(w, N), w) {
                case "dialog":
                  pr("cancel", t), pr("close", t), ne = N;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  pr("load", t), ne = N;
                  break;
                case "video":
                case "audio":
                  for (ne = 0; ne < ns.length; ne++) pr(ns[ne], t);
                  ne = N;
                  break;
                case "source":
                  pr("error", t), ne = N;
                  break;
                case "img":
                case "image":
                case "link":
                  pr(
                    "error",
                    t
                  ), pr("load", t), ne = N;
                  break;
                case "details":
                  pr("toggle", t), ne = N;
                  break;
                case "input":
                  Ie(t, N), ne = Ge(t, N), pr("invalid", t);
                  break;
                case "option":
                  ne = N;
                  break;
                case "select":
                  t._wrapperState = { wasMultiple: !!N.multiple }, ne = de({}, N, { value: void 0 }), pr("invalid", t);
                  break;
                case "textarea":
                  Y(t, N), ne = ve(t, N), pr("invalid", t);
                  break;
                default:
                  ne = N;
              }
              pe(w, ne), Qe = ne;
              for (ge in Qe) if (Qe.hasOwnProperty(ge)) {
                var rt = Qe[ge];
                ge === "style" ? X(t, rt) : ge === "dangerouslySetInnerHTML" ? (rt = rt ? rt.__html : void 0, rt != null && C(t, rt)) : ge === "children" ? typeof rt == "string" ? (w !== "textarea" || rt !== "") && R(t, rt) : typeof rt == "number" && R(t, "" + rt) : ge !== "suppressContentEditableWarning" && ge !== "suppressHydrationWarning" && ge !== "autoFocus" && (Z.hasOwnProperty(ge) ? rt != null && ge === "onScroll" && pr("scroll", t) : rt != null && s(t, ge, rt, ze));
              }
              switch (w) {
                case "input":
                  Ze(t), _e(t, N, !1);
                  break;
                case "textarea":
                  Ze(t), Ae(t);
                  break;
                case "option":
                  N.value != null && t.setAttribute("value", "" + Ue(N.value));
                  break;
                case "select":
                  t.multiple = !!N.multiple, ge = N.value, ge != null ? Ce(t, !!N.multiple, ge, !1) : N.defaultValue != null && Ce(
                    t,
                    !!N.multiple,
                    N.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof ne.onClick == "function" && (t.onclick = $s);
              }
              switch (w) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  N = !!N.autoFocus;
                  break e;
                case "img":
                  N = !0;
                  break e;
                default:
                  N = !1;
              }
            }
            N && (i.flags |= 4);
          }
          i.ref !== null && (i.flags |= 512, i.flags |= 2097152);
        }
        return ti(i), null;
      case 6:
        if (t && i.stateNode != null) Ph(t, i, t.memoizedProps, N);
        else {
          if (typeof N != "string" && i.stateNode === null) throw Error(ae(166));
          if (w = ua(cs.current), ua(rn.current), ao(i)) {
            if (N = i.stateNode, w = i.memoizedProps, N[tn] = i, (ge = N.nodeValue !== w) && (t = Si, t !== null)) switch (t.tag) {
              case 3:
                Ks(N.nodeValue, w, (t.mode & 1) !== 0);
                break;
              case 5:
                t.memoizedProps.suppressHydrationWarning !== !0 && Ks(N.nodeValue, w, (t.mode & 1) !== 0);
            }
            ge && (i.flags |= 4);
          } else N = (w.nodeType === 9 ? w : w.ownerDocument).createTextNode(N), N[tn] = i, i.stateNode = N;
        }
        return ti(i), null;
      case 13:
        if (vr(br), N = i.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
          if (mr && Ei !== null && (i.mode & 1) !== 0 && (i.flags & 128) === 0) Of(), Na(), i.flags |= 98560, ge = !1;
          else if (ge = ao(i), N !== null && N.dehydrated !== null) {
            if (t === null) {
              if (!ge) throw Error(ae(318));
              if (ge = i.memoizedState, ge = ge !== null ? ge.dehydrated : null, !ge) throw Error(ae(317));
              ge[tn] = i;
            } else Na(), (i.flags & 128) === 0 && (i.memoizedState = null), i.flags |= 4;
            ti(i), ge = !1;
          } else ji !== null && (cl(ji), ji = null), ge = !0;
          if (!ge) return i.flags & 65536 ? i : null;
        }
        return (i.flags & 128) !== 0 ? (i.lanes = w, i) : (N = N !== null, N !== (t !== null && t.memoizedState !== null) && N && (i.child.flags |= 8192, (i.mode & 1) !== 0 && (t === null || (br.current & 1) !== 0 ? Dr === 0 && (Dr = 3) : vl())), i.updateQueue !== null && (i.flags |= 4), ti(i), null);
      case 4:
        return Fa(), tl(t, i), t === null && as(i.stateNode.containerInfo), ti(i), null;
      case 10:
        return Mu(i.type._context), ti(i), null;
      case 17:
        return fi(i.type) && eo(), ti(i), null;
      case 19:
        if (vr(br), ge = i.memoizedState, ge === null) return ti(i), null;
        if (N = (i.flags & 128) !== 0, ze = ge.rendering, ze === null) if (N) gs(ge, !1);
        else {
          if (Dr !== 0 || t !== null && (t.flags & 128) !== 0) for (t = i.child; t !== null; ) {
            if (ze = ho(t), ze !== null) {
              for (i.flags |= 128, gs(ge, !1), N = ze.updateQueue, N !== null && (i.updateQueue = N, i.flags |= 4), i.subtreeFlags = 0, N = w, w = i.child; w !== null; ) ge = w, t = N, ge.flags &= 14680066, ze = ge.alternate, ze === null ? (ge.childLanes = 0, ge.lanes = t, ge.child = null, ge.subtreeFlags = 0, ge.memoizedProps = null, ge.memoizedState = null, ge.updateQueue = null, ge.dependencies = null, ge.stateNode = null) : (ge.childLanes = ze.childLanes, ge.lanes = ze.lanes, ge.child = ze.child, ge.subtreeFlags = 0, ge.deletions = null, ge.memoizedProps = ze.memoizedProps, ge.memoizedState = ze.memoizedState, ge.updateQueue = ze.updateQueue, ge.type = ze.type, t = ze.dependencies, ge.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), w = w.sibling;
              return cr(br, br.current & 1 | 2), i.child;
            }
            t = t.sibling;
          }
          ge.tail !== null && Mt() > Ga && (i.flags |= 128, N = !0, gs(ge, !1), i.lanes = 4194304);
        }
        else {
          if (!N) if (t = ho(ze), t !== null) {
            if (i.flags |= 128, N = !0, w = t.updateQueue, w !== null && (i.updateQueue = w, i.flags |= 4), gs(ge, !0), ge.tail === null && ge.tailMode === "hidden" && !ze.alternate && !mr) return ti(i), null;
          } else 2 * Mt() - ge.renderingStartTime > Ga && w !== 1073741824 && (i.flags |= 128, N = !0, gs(ge, !1), i.lanes = 4194304);
          ge.isBackwards ? (ze.sibling = i.child, i.child = ze) : (w = ge.last, w !== null ? w.sibling = ze : i.child = ze, ge.last = ze);
        }
        return ge.tail !== null ? (i = ge.tail, ge.rendering = i, ge.tail = i.sibling, ge.renderingStartTime = Mt(), i.sibling = null, w = br.current, cr(br, N ? w & 1 | 2 : w & 1), i) : (ti(i), null);
      case 22:
      case 23:
        return pl(), N = i.memoizedState !== null, t !== null && t.memoizedState !== null !== N && (i.flags |= 8192), N && (i.mode & 1) !== 0 ? (xi & 1073741824) !== 0 && (ti(i), i.subtreeFlags & 6 && (i.flags |= 8192)) : ti(i), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(ae(156, i.tag));
  }
  function Dd(t, i) {
    switch (Eu(i), i.tag) {
      case 1:
        return fi(i.type) && eo(), t = i.flags, t & 65536 ? (i.flags = t & -65537 | 128, i) : null;
      case 3:
        return Fa(), vr(li), vr(Jr), Du(), t = i.flags, (t & 65536) !== 0 && (t & 128) === 0 ? (i.flags = t & -65537 | 128, i) : null;
      case 5:
        return Lu(i), null;
      case 13:
        if (vr(br), t = i.memoizedState, t !== null && t.dehydrated !== null) {
          if (i.alternate === null) throw Error(ae(340));
          Na();
        }
        return t = i.flags, t & 65536 ? (i.flags = t & -65537 | 128, i) : null;
      case 19:
        return vr(br), null;
      case 4:
        return Fa(), null;
      case 10:
        return Mu(i.type._context), null;
      case 22:
      case 23:
        return pl(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var bo = !1, ri = !1, Bd = typeof WeakSet == "function" ? WeakSet : Set, It = null;
  function ja(t, i) {
    var w = t.ref;
    if (w !== null) if (typeof w == "function") try {
      w(null);
    } catch (N) {
      Cr(t, i, N);
    }
    else w.current = null;
  }
  function rl(t, i, w) {
    try {
      w();
    } catch (N) {
      Cr(t, i, N);
    }
  }
  var Ih = !1;
  function zd(t, i) {
    if (pu = Ci, t = Ft(), Ut(t)) {
      if ("selectionStart" in t) var w = { start: t.selectionStart, end: t.selectionEnd };
      else e: {
        w = (w = t.ownerDocument) && w.defaultView || window;
        var N = w.getSelection && w.getSelection();
        if (N && N.rangeCount !== 0) {
          w = N.anchorNode;
          var ne = N.anchorOffset, ge = N.focusNode;
          N = N.focusOffset;
          try {
            w.nodeType, ge.nodeType;
          } catch {
            w = null;
            break e;
          }
          var ze = 0, Qe = -1, rt = -1, ft = 0, yt = 0, St = t, _t = null;
          t: for (; ; ) {
            for (var Pt; St !== w || ne !== 0 && St.nodeType !== 3 || (Qe = ze + ne), St !== ge || N !== 0 && St.nodeType !== 3 || (rt = ze + N), St.nodeType === 3 && (ze += St.nodeValue.length), (Pt = St.firstChild) !== null; )
              _t = St, St = Pt;
            for (; ; ) {
              if (St === t) break t;
              if (_t === w && ++ft === ne && (Qe = ze), _t === ge && ++yt === N && (rt = ze), (Pt = St.nextSibling) !== null) break;
              St = _t, _t = St.parentNode;
            }
            St = Pt;
          }
          w = Qe === -1 || rt === -1 ? null : { start: Qe, end: rt };
        } else w = null;
      }
      w = w || { start: 0, end: 0 };
    } else w = null;
    for (vu = { focusedElem: t, selectionRange: w }, Ci = !1, It = i; It !== null; ) if (i = It, t = i.child, (i.subtreeFlags & 1028) !== 0 && t !== null) t.return = i, It = t;
    else for (; It !== null; ) {
      i = It;
      try {
        var Rt = i.alternate;
        if ((i.flags & 1024) !== 0) switch (i.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (Rt !== null) {
              var Lt = Rt.memoizedProps, Tr = Rt.memoizedState, st = i.stateNode, it = st.getSnapshotBeforeUpdate(i.elementType === i.type ? Lt : Hi(i.type, Lt), Tr);
              st.__reactInternalSnapshotBeforeUpdate = it;
            }
            break;
          case 3:
            var ut = i.stateNode.containerInfo;
            ut.nodeType === 1 ? ut.textContent = "" : ut.nodeType === 9 && ut.documentElement && ut.removeChild(ut.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(ae(163));
        }
      } catch (kt) {
        Cr(i, i.return, kt);
      }
      if (t = i.sibling, t !== null) {
        t.return = i.return, It = t;
        break;
      }
      It = i.return;
    }
    return Rt = Ih, Ih = !1, Rt;
  }
  function _s(t, i, w) {
    var N = i.updateQueue;
    if (N = N !== null ? N.lastEffect : null, N !== null) {
      var ne = N = N.next;
      do {
        if ((ne.tag & t) === t) {
          var ge = ne.destroy;
          ne.destroy = void 0, ge !== void 0 && rl(i, w, ge);
        }
        ne = ne.next;
      } while (ne !== N);
    }
  }
  function So(t, i) {
    if (i = i.updateQueue, i = i !== null ? i.lastEffect : null, i !== null) {
      var w = i = i.next;
      do {
        if ((w.tag & t) === t) {
          var N = w.create;
          w.destroy = N();
        }
        w = w.next;
      } while (w !== i);
    }
  }
  function il(t) {
    var i = t.ref;
    if (i !== null) {
      var w = t.stateNode;
      switch (t.tag) {
        case 5:
          t = w;
          break;
        default:
          t = w;
      }
      typeof i == "function" ? i(t) : i.current = t;
    }
  }
  function Rh(t) {
    var i = t.alternate;
    i !== null && (t.alternate = null, Rh(i)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (i = t.stateNode, i !== null && (delete i[tn], delete i[os], delete i[yu], delete i[wd], delete i[bd])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null;
  }
  function Oh(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4;
  }
  function Lh(t) {
    e: for (; ; ) {
      for (; t.sibling === null; ) {
        if (t.return === null || Oh(t.return)) return null;
        t = t.return;
      }
      for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
        if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
        t.child.return = t, t = t.child;
      }
      if (!(t.flags & 2)) return t.stateNode;
    }
  }
  function nl(t, i, w) {
    var N = t.tag;
    if (N === 5 || N === 6) t = t.stateNode, i ? w.nodeType === 8 ? w.parentNode.insertBefore(t, i) : w.insertBefore(t, i) : (w.nodeType === 8 ? (i = w.parentNode, i.insertBefore(t, w)) : (i = w, i.appendChild(t)), w = w._reactRootContainer, w != null || i.onclick !== null || (i.onclick = $s));
    else if (N !== 4 && (t = t.child, t !== null)) for (nl(t, i, w), t = t.sibling; t !== null; ) nl(t, i, w), t = t.sibling;
  }
  function al(t, i, w) {
    var N = t.tag;
    if (N === 5 || N === 6) t = t.stateNode, i ? w.insertBefore(t, i) : w.appendChild(t);
    else if (N !== 4 && (t = t.child, t !== null)) for (al(t, i, w), t = t.sibling; t !== null; ) al(t, i, w), t = t.sibling;
  }
  var Zr = null, Gi = !1;
  function Dn(t, i, w) {
    for (w = w.child; w !== null; ) Nh(t, i, w), w = w.sibling;
  }
  function Nh(t, i, w) {
    if ($t && typeof $t.onCommitFiberUnmount == "function") try {
      $t.onCommitFiberUnmount(wt, w);
    } catch {
    }
    switch (w.tag) {
      case 5:
        ri || ja(w, i);
      case 6:
        var N = Zr, ne = Gi;
        Zr = null, Dn(t, i, w), Zr = N, Gi = ne, Zr !== null && (Gi ? (t = Zr, w = w.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(w) : t.removeChild(w)) : Zr.removeChild(w.stateNode));
        break;
      case 18:
        Zr !== null && (Gi ? (t = Zr, w = w.stateNode, t.nodeType === 8 ? _u(t.parentNode, w) : t.nodeType === 1 && _u(t, w), fr(t)) : _u(Zr, w.stateNode));
        break;
      case 4:
        N = Zr, ne = Gi, Zr = w.stateNode.containerInfo, Gi = !0, Dn(t, i, w), Zr = N, Gi = ne;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!ri && (N = w.updateQueue, N !== null && (N = N.lastEffect, N !== null))) {
          ne = N = N.next;
          do {
            var ge = ne, ze = ge.destroy;
            ge = ge.tag, ze !== void 0 && ((ge & 2) !== 0 || (ge & 4) !== 0) && rl(w, i, ze), ne = ne.next;
          } while (ne !== N);
        }
        Dn(t, i, w);
        break;
      case 1:
        if (!ri && (ja(w, i), N = w.stateNode, typeof N.componentWillUnmount == "function")) try {
          N.props = w.memoizedProps, N.state = w.memoizedState, N.componentWillUnmount();
        } catch (Qe) {
          Cr(w, i, Qe);
        }
        Dn(t, i, w);
        break;
      case 21:
        Dn(t, i, w);
        break;
      case 22:
        w.mode & 1 ? (ri = (N = ri) || w.memoizedState !== null, Dn(t, i, w), ri = N) : Dn(t, i, w);
        break;
      default:
        Dn(t, i, w);
    }
  }
  function Dh(t) {
    var i = t.updateQueue;
    if (i !== null) {
      t.updateQueue = null;
      var w = t.stateNode;
      w === null && (w = t.stateNode = new Bd()), i.forEach(function(N) {
        var ne = Yd.bind(null, t, N);
        w.has(N) || (w.add(N), N.then(ne, ne));
      });
    }
  }
  function Vi(t, i) {
    var w = i.deletions;
    if (w !== null) for (var N = 0; N < w.length; N++) {
      var ne = w[N];
      try {
        var ge = t, ze = i, Qe = ze;
        e: for (; Qe !== null; ) {
          switch (Qe.tag) {
            case 5:
              Zr = Qe.stateNode, Gi = !1;
              break e;
            case 3:
              Zr = Qe.stateNode.containerInfo, Gi = !0;
              break e;
            case 4:
              Zr = Qe.stateNode.containerInfo, Gi = !0;
              break e;
          }
          Qe = Qe.return;
        }
        if (Zr === null) throw Error(ae(160));
        Nh(ge, ze, ne), Zr = null, Gi = !1;
        var rt = ne.alternate;
        rt !== null && (rt.return = null), ne.return = null;
      } catch (ft) {
        Cr(ne, i, ft);
      }
    }
    if (i.subtreeFlags & 12854) for (i = i.child; i !== null; ) Bh(i, t), i = i.sibling;
  }
  function Bh(t, i) {
    var w = t.alternate, N = t.flags;
    switch (t.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Vi(i, t), an(t), N & 4) {
          try {
            _s(3, t, t.return), So(3, t);
          } catch (Lt) {
            Cr(t, t.return, Lt);
          }
          try {
            _s(5, t, t.return);
          } catch (Lt) {
            Cr(t, t.return, Lt);
          }
        }
        break;
      case 1:
        Vi(i, t), an(t), N & 512 && w !== null && ja(w, w.return);
        break;
      case 5:
        if (Vi(i, t), an(t), N & 512 && w !== null && ja(w, w.return), t.flags & 32) {
          var ne = t.stateNode;
          try {
            R(ne, "");
          } catch (Lt) {
            Cr(t, t.return, Lt);
          }
        }
        if (N & 4 && (ne = t.stateNode, ne != null)) {
          var ge = t.memoizedProps, ze = w !== null ? w.memoizedProps : ge, Qe = t.type, rt = t.updateQueue;
          if (t.updateQueue = null, rt !== null) try {
            Qe === "input" && ge.type === "radio" && ge.name != null && De(ne, ge), P(Qe, ze);
            var ft = P(Qe, ge);
            for (ze = 0; ze < rt.length; ze += 2) {
              var yt = rt[ze], St = rt[ze + 1];
              yt === "style" ? X(ne, St) : yt === "dangerouslySetInnerHTML" ? C(ne, St) : yt === "children" ? R(ne, St) : s(ne, yt, St, ft);
            }
            switch (Qe) {
              case "input":
                Ne(ne, ge);
                break;
              case "textarea":
                G(ne, ge);
                break;
              case "select":
                var _t = ne._wrapperState.wasMultiple;
                ne._wrapperState.wasMultiple = !!ge.multiple;
                var Pt = ge.value;
                Pt != null ? Ce(ne, !!ge.multiple, Pt, !1) : _t !== !!ge.multiple && (ge.defaultValue != null ? Ce(
                  ne,
                  !!ge.multiple,
                  ge.defaultValue,
                  !0
                ) : Ce(ne, !!ge.multiple, ge.multiple ? [] : "", !1));
            }
            ne[os] = ge;
          } catch (Lt) {
            Cr(t, t.return, Lt);
          }
        }
        break;
      case 6:
        if (Vi(i, t), an(t), N & 4) {
          if (t.stateNode === null) throw Error(ae(162));
          ne = t.stateNode, ge = t.memoizedProps;
          try {
            ne.nodeValue = ge;
          } catch (Lt) {
            Cr(t, t.return, Lt);
          }
        }
        break;
      case 3:
        if (Vi(i, t), an(t), N & 4 && w !== null && w.memoizedState.isDehydrated) try {
          fr(i.containerInfo);
        } catch (Lt) {
          Cr(t, t.return, Lt);
        }
        break;
      case 4:
        Vi(i, t), an(t);
        break;
      case 13:
        Vi(i, t), an(t), ne = t.child, ne.flags & 8192 && (ge = ne.memoizedState !== null, ne.stateNode.isHidden = ge, !ge || ne.alternate !== null && ne.alternate.memoizedState !== null || (ul = Mt())), N & 4 && Dh(t);
        break;
      case 22:
        if (yt = w !== null && w.memoizedState !== null, t.mode & 1 ? (ri = (ft = ri) || yt, Vi(i, t), ri = ft) : Vi(i, t), an(t), N & 8192) {
          if (ft = t.memoizedState !== null, (t.stateNode.isHidden = ft) && !yt && (t.mode & 1) !== 0) for (It = t, yt = t.child; yt !== null; ) {
            for (St = It = yt; It !== null; ) {
              switch (_t = It, Pt = _t.child, _t.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  _s(4, _t, _t.return);
                  break;
                case 1:
                  ja(_t, _t.return);
                  var Rt = _t.stateNode;
                  if (typeof Rt.componentWillUnmount == "function") {
                    N = _t, w = _t.return;
                    try {
                      i = N, Rt.props = i.memoizedProps, Rt.state = i.memoizedState, Rt.componentWillUnmount();
                    } catch (Lt) {
                      Cr(N, w, Lt);
                    }
                  }
                  break;
                case 5:
                  ja(_t, _t.return);
                  break;
                case 22:
                  if (_t.memoizedState !== null) {
                    Uh(St);
                    continue;
                  }
              }
              Pt !== null ? (Pt.return = _t, It = Pt) : Uh(St);
            }
            yt = yt.sibling;
          }
          e: for (yt = null, St = t; ; ) {
            if (St.tag === 5) {
              if (yt === null) {
                yt = St;
                try {
                  ne = St.stateNode, ft ? (ge = ne.style, typeof ge.setProperty == "function" ? ge.setProperty("display", "none", "important") : ge.display = "none") : (Qe = St.stateNode, rt = St.memoizedProps.style, ze = rt != null && rt.hasOwnProperty("display") ? rt.display : null, Qe.style.display = H("display", ze));
                } catch (Lt) {
                  Cr(t, t.return, Lt);
                }
              }
            } else if (St.tag === 6) {
              if (yt === null) try {
                St.stateNode.nodeValue = ft ? "" : St.memoizedProps;
              } catch (Lt) {
                Cr(t, t.return, Lt);
              }
            } else if ((St.tag !== 22 && St.tag !== 23 || St.memoizedState === null || St === t) && St.child !== null) {
              St.child.return = St, St = St.child;
              continue;
            }
            if (St === t) break e;
            for (; St.sibling === null; ) {
              if (St.return === null || St.return === t) break e;
              yt === St && (yt = null), St = St.return;
            }
            yt === St && (yt = null), St.sibling.return = St.return, St = St.sibling;
          }
        }
        break;
      case 19:
        Vi(i, t), an(t), N & 4 && Dh(t);
        break;
      case 21:
        break;
      default:
        Vi(
          i,
          t
        ), an(t);
    }
  }
  function an(t) {
    var i = t.flags;
    if (i & 2) {
      try {
        e: {
          for (var w = t.return; w !== null; ) {
            if (Oh(w)) {
              var N = w;
              break e;
            }
            w = w.return;
          }
          throw Error(ae(160));
        }
        switch (N.tag) {
          case 5:
            var ne = N.stateNode;
            N.flags & 32 && (R(ne, ""), N.flags &= -33);
            var ge = Lh(t);
            al(t, ge, ne);
            break;
          case 3:
          case 4:
            var ze = N.stateNode.containerInfo, Qe = Lh(t);
            nl(t, Qe, ze);
            break;
          default:
            throw Error(ae(161));
        }
      } catch (rt) {
        Cr(t, t.return, rt);
      }
      t.flags &= -3;
    }
    i & 4096 && (t.flags &= -4097);
  }
  function Fd(t, i, w) {
    It = t, zh(t);
  }
  function zh(t, i, w) {
    for (var N = (t.mode & 1) !== 0; It !== null; ) {
      var ne = It, ge = ne.child;
      if (ne.tag === 22 && N) {
        var ze = ne.memoizedState !== null || bo;
        if (!ze) {
          var Qe = ne.alternate, rt = Qe !== null && Qe.memoizedState !== null || ri;
          Qe = bo;
          var ft = ri;
          if (bo = ze, (ri = rt) && !ft) for (It = ne; It !== null; ) ze = It, rt = ze.child, ze.tag === 22 && ze.memoizedState !== null ? jh(ne) : rt !== null ? (rt.return = ze, It = rt) : jh(ne);
          for (; ge !== null; ) It = ge, zh(ge), ge = ge.sibling;
          It = ne, bo = Qe, ri = ft;
        }
        Fh(t);
      } else (ne.subtreeFlags & 8772) !== 0 && ge !== null ? (ge.return = ne, It = ge) : Fh(t);
    }
  }
  function Fh(t) {
    for (; It !== null; ) {
      var i = It;
      if ((i.flags & 8772) !== 0) {
        var w = i.alternate;
        try {
          if ((i.flags & 8772) !== 0) switch (i.tag) {
            case 0:
            case 11:
            case 15:
              ri || So(5, i);
              break;
            case 1:
              var N = i.stateNode;
              if (i.flags & 4 && !ri) if (w === null) N.componentDidMount();
              else {
                var ne = i.elementType === i.type ? w.memoizedProps : Hi(i.type, w.memoizedProps);
                N.componentDidUpdate(ne, w.memoizedState, N.__reactInternalSnapshotBeforeUpdate);
              }
              var ge = i.updateQueue;
              ge !== null && Uf(i, ge, N);
              break;
            case 3:
              var ze = i.updateQueue;
              if (ze !== null) {
                if (w = null, i.child !== null) switch (i.child.tag) {
                  case 5:
                    w = i.child.stateNode;
                    break;
                  case 1:
                    w = i.child.stateNode;
                }
                Uf(i, ze, w);
              }
              break;
            case 5:
              var Qe = i.stateNode;
              if (w === null && i.flags & 4) {
                w = Qe;
                var rt = i.memoizedProps;
                switch (i.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    rt.autoFocus && w.focus();
                    break;
                  case "img":
                    rt.src && (w.src = rt.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (i.memoizedState === null) {
                var ft = i.alternate;
                if (ft !== null) {
                  var yt = ft.memoizedState;
                  if (yt !== null) {
                    var St = yt.dehydrated;
                    St !== null && fr(St);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(ae(163));
          }
          ri || i.flags & 512 && il(i);
        } catch (_t) {
          Cr(i, i.return, _t);
        }
      }
      if (i === t) {
        It = null;
        break;
      }
      if (w = i.sibling, w !== null) {
        w.return = i.return, It = w;
        break;
      }
      It = i.return;
    }
  }
  function Uh(t) {
    for (; It !== null; ) {
      var i = It;
      if (i === t) {
        It = null;
        break;
      }
      var w = i.sibling;
      if (w !== null) {
        w.return = i.return, It = w;
        break;
      }
      It = i.return;
    }
  }
  function jh(t) {
    for (; It !== null; ) {
      var i = It;
      try {
        switch (i.tag) {
          case 0:
          case 11:
          case 15:
            var w = i.return;
            try {
              So(4, i);
            } catch (rt) {
              Cr(i, w, rt);
            }
            break;
          case 1:
            var N = i.stateNode;
            if (typeof N.componentDidMount == "function") {
              var ne = i.return;
              try {
                N.componentDidMount();
              } catch (rt) {
                Cr(i, ne, rt);
              }
            }
            var ge = i.return;
            try {
              il(i);
            } catch (rt) {
              Cr(i, ge, rt);
            }
            break;
          case 5:
            var ze = i.return;
            try {
              il(i);
            } catch (rt) {
              Cr(i, ze, rt);
            }
        }
      } catch (rt) {
        Cr(i, i.return, rt);
      }
      if (i === t) {
        It = null;
        break;
      }
      var Qe = i.sibling;
      if (Qe !== null) {
        Qe.return = i.return, It = Qe;
        break;
      }
      It = i.return;
    }
  }
  var Ud = Math.ceil, Eo = b.ReactCurrentDispatcher, sl = b.ReactCurrentOwner, Oi = b.ReactCurrentBatchConfig, ir = 0, Gr = null, Ir = null, Yr = 0, xi = 0, Ha = In(0), Dr = 0, ys = null, fa = 0, xo = 0, ol = 0, ws = null, ci = null, ul = 0, Ga = 1 / 0, _n = null, Co = !1, ll = null, Bn = null, ko = !1, zn = null, Ao = 0, bs = 0, fl = null, To = -1, Mo = 0;
  function si() {
    return (ir & 6) !== 0 ? Mt() : To !== -1 ? To : To = Mt();
  }
  function Fn(t) {
    return (t.mode & 1) === 0 ? 1 : (ir & 2) !== 0 && Yr !== 0 ? Yr & -Yr : Ed.transition !== null ? (Mo === 0 && (Mo = wn()), Mo) : (t = qt, t !== 0 || (t = window.event, t = t === void 0 ? 16 : Yn(t.type)), t);
  }
  function Wi(t, i, w, N) {
    if (50 < bs) throw bs = 0, fl = null, Error(ae(185));
    Yi(t, w, N), ((ir & 2) === 0 || t !== Gr) && (t === Gr && ((ir & 2) === 0 && (xo |= w), Dr === 4 && Un(t, Yr)), di(t, N), w === 1 && ir === 0 && (i.mode & 1) === 0 && (Ga = Mt() + 500, ro && On()));
  }
  function di(t, i) {
    var w = t.callbackNode;
    Or(t, i);
    var N = qr(t, t === Gr ? Yr : 0);
    if (N === 0) w !== null && xt(w), t.callbackNode = null, t.callbackPriority = 0;
    else if (i = N & -N, t.callbackPriority !== i) {
      if (w != null && xt(w), i === 1) t.tag === 0 ? Sd(Gh.bind(null, t)) : Tf(Gh.bind(null, t)), _d(function() {
        (ir & 6) === 0 && On();
      }), w = null;
      else {
        switch (qi(N)) {
          case 1:
            w = Bt;
            break;
          case 4:
            w = or;
            break;
          case 16:
            w = ar;
            break;
          case 536870912:
            w = hr;
            break;
          default:
            w = ar;
        }
        w = Kh(w, Hh.bind(null, t));
      }
      t.callbackPriority = i, t.callbackNode = w;
    }
  }
  function Hh(t, i) {
    if (To = -1, Mo = 0, (ir & 6) !== 0) throw Error(ae(327));
    var w = t.callbackNode;
    if (Va() && t.callbackNode !== w) return null;
    var N = qr(t, t === Gr ? Yr : 0);
    if (N === 0) return null;
    if ((N & 30) !== 0 || (N & t.expiredLanes) !== 0 || i) i = Po(t, N);
    else {
      i = N;
      var ne = ir;
      ir |= 2;
      var ge = Wh();
      (Gr !== t || Yr !== i) && (_n = null, Ga = Mt() + 500, ca(t, i));
      do
        try {
          Gd();
          break;
        } catch (Qe) {
          Vh(t, Qe);
        }
      while (!0);
      Tu(), Eo.current = ge, ir = ne, Ir !== null ? i = 0 : (Gr = null, Yr = 0, i = Dr);
    }
    if (i !== 0) {
      if (i === 2 && (ne = yn(t), ne !== 0 && (N = ne, i = hl(t, ne))), i === 1) throw w = ys, ca(t, 0), Un(t, N), di(t, Mt()), w;
      if (i === 6) Un(t, N);
      else {
        if (ne = t.current.alternate, (N & 30) === 0 && !jd(ne) && (i = Po(t, N), i === 2 && (ge = yn(t), ge !== 0 && (N = ge, i = hl(t, ge))), i === 1)) throw w = ys, ca(t, 0), Un(t, N), di(t, Mt()), w;
        switch (t.finishedWork = ne, t.finishedLanes = N, i) {
          case 0:
          case 1:
            throw Error(ae(345));
          case 2:
            da(t, ci, _n);
            break;
          case 3:
            if (Un(t, N), (N & 130023424) === N && (i = ul + 500 - Mt(), 10 < i)) {
              if (qr(t, 0) !== 0) break;
              if (ne = t.suspendedLanes, (ne & N) !== N) {
                si(), t.pingedLanes |= t.suspendedLanes & ne;
                break;
              }
              t.timeoutHandle = gu(da.bind(null, t, ci, _n), i);
              break;
            }
            da(t, ci, _n);
            break;
          case 4:
            if (Un(t, N), (N & 4194240) === N) break;
            for (i = t.eventTimes, ne = -1; 0 < N; ) {
              var ze = 31 - tr(N);
              ge = 1 << ze, ze = i[ze], ze > ne && (ne = ze), N &= ~ge;
            }
            if (N = ne, N = Mt() - N, N = (120 > N ? 120 : 480 > N ? 480 : 1080 > N ? 1080 : 1920 > N ? 1920 : 3e3 > N ? 3e3 : 4320 > N ? 4320 : 1960 * Ud(N / 1960)) - N, 10 < N) {
              t.timeoutHandle = gu(da.bind(null, t, ci, _n), N);
              break;
            }
            da(t, ci, _n);
            break;
          case 5:
            da(t, ci, _n);
            break;
          default:
            throw Error(ae(329));
        }
      }
    }
    return di(t, Mt()), t.callbackNode === w ? Hh.bind(null, t) : null;
  }
  function hl(t, i) {
    var w = ws;
    return t.current.memoizedState.isDehydrated && (ca(t, i).flags |= 256), t = Po(t, i), t !== 2 && (i = ci, ci = w, i !== null && cl(i)), t;
  }
  function cl(t) {
    ci === null ? ci = t : ci.push.apply(ci, t);
  }
  function jd(t) {
    for (var i = t; ; ) {
      if (i.flags & 16384) {
        var w = i.updateQueue;
        if (w !== null && (w = w.stores, w !== null)) for (var N = 0; N < w.length; N++) {
          var ne = w[N], ge = ne.getSnapshot;
          ne = ne.value;
          try {
            if (!Pr(ge(), ne)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (w = i.child, i.subtreeFlags & 16384 && w !== null) w.return = i, i = w;
      else {
        if (i === t) break;
        for (; i.sibling === null; ) {
          if (i.return === null || i.return === t) return !0;
          i = i.return;
        }
        i.sibling.return = i.return, i = i.sibling;
      }
    }
    return !0;
  }
  function Un(t, i) {
    for (i &= ~ol, i &= ~xo, t.suspendedLanes |= i, t.pingedLanes &= ~i, t = t.expirationTimes; 0 < i; ) {
      var w = 31 - tr(i), N = 1 << w;
      t[w] = -1, i &= ~N;
    }
  }
  function Gh(t) {
    if ((ir & 6) !== 0) throw Error(ae(327));
    Va();
    var i = qr(t, 0);
    if ((i & 1) === 0) return di(t, Mt()), null;
    var w = Po(t, i);
    if (t.tag !== 0 && w === 2) {
      var N = yn(t);
      N !== 0 && (i = N, w = hl(t, N));
    }
    if (w === 1) throw w = ys, ca(t, 0), Un(t, i), di(t, Mt()), w;
    if (w === 6) throw Error(ae(345));
    return t.finishedWork = t.current.alternate, t.finishedLanes = i, da(t, ci, _n), di(t, Mt()), null;
  }
  function dl(t, i) {
    var w = ir;
    ir |= 1;
    try {
      return t(i);
    } finally {
      ir = w, ir === 0 && (Ga = Mt() + 500, ro && On());
    }
  }
  function ha(t) {
    zn !== null && zn.tag === 0 && (ir & 6) === 0 && Va();
    var i = ir;
    ir |= 1;
    var w = Oi.transition, N = qt;
    try {
      if (Oi.transition = null, qt = 1, t) return t();
    } finally {
      qt = N, Oi.transition = w, ir = i, (ir & 6) === 0 && On();
    }
  }
  function pl() {
    xi = Ha.current, vr(Ha);
  }
  function ca(t, i) {
    t.finishedWork = null, t.finishedLanes = 0;
    var w = t.timeoutHandle;
    if (w !== -1 && (t.timeoutHandle = -1, gd(w)), Ir !== null) for (w = Ir.return; w !== null; ) {
      var N = w;
      switch (Eu(N), N.tag) {
        case 1:
          N = N.type.childContextTypes, N != null && eo();
          break;
        case 3:
          Fa(), vr(li), vr(Jr), Du();
          break;
        case 5:
          Lu(N);
          break;
        case 4:
          Fa();
          break;
        case 13:
          vr(br);
          break;
        case 19:
          vr(br);
          break;
        case 10:
          Mu(N.type._context);
          break;
        case 22:
        case 23:
          pl();
      }
      w = w.return;
    }
    if (Gr = t, Ir = t = jn(t.current, null), Yr = xi = i, Dr = 0, ys = null, ol = xo = fa = 0, ci = ws = null, oa !== null) {
      for (i = 0; i < oa.length; i++) if (w = oa[i], N = w.interleaved, N !== null) {
        w.interleaved = null;
        var ne = N.next, ge = w.pending;
        if (ge !== null) {
          var ze = ge.next;
          ge.next = ne, N.next = ze;
        }
        w.pending = N;
      }
      oa = null;
    }
    return t;
  }
  function Vh(t, i) {
    do {
      var w = Ir;
      try {
        if (Tu(), co.current = go, po) {
          for (var N = Sr.memoizedState; N !== null; ) {
            var ne = N.queue;
            ne !== null && (ne.pending = null), N = N.next;
          }
          po = !1;
        }
        if (la = 0, Hr = Nr = Sr = null, ds = !1, ps = 0, sl.current = null, w === null || w.return === null) {
          Dr = 1, ys = i, Ir = null;
          break;
        }
        e: {
          var ge = t, ze = w.return, Qe = w, rt = i;
          if (i = Yr, Qe.flags |= 32768, rt !== null && typeof rt == "object" && typeof rt.then == "function") {
            var ft = rt, yt = Qe, St = yt.tag;
            if ((yt.mode & 1) === 0 && (St === 0 || St === 11 || St === 15)) {
              var _t = yt.alternate;
              _t ? (yt.updateQueue = _t.updateQueue, yt.memoizedState = _t.memoizedState, yt.lanes = _t.lanes) : (yt.updateQueue = null, yt.memoizedState = null);
            }
            var Pt = vh(ze);
            if (Pt !== null) {
              Pt.flags &= -257, mh(Pt, ze, Qe, ge, i), Pt.mode & 1 && ph(ge, ft, i), i = Pt, rt = ft;
              var Rt = i.updateQueue;
              if (Rt === null) {
                var Lt = /* @__PURE__ */ new Set();
                Lt.add(rt), i.updateQueue = Lt;
              } else Rt.add(rt);
              break e;
            } else {
              if ((i & 1) === 0) {
                ph(ge, ft, i), vl();
                break e;
              }
              rt = Error(ae(426));
            }
          } else if (mr && Qe.mode & 1) {
            var Tr = vh(ze);
            if (Tr !== null) {
              (Tr.flags & 65536) === 0 && (Tr.flags |= 256), mh(Tr, ze, Qe, ge, i), ku(Ua(rt, Qe));
              break e;
            }
          }
          ge = rt = Ua(rt, Qe), Dr !== 4 && (Dr = 2), ws === null ? ws = [ge] : ws.push(ge), ge = ze;
          do {
            switch (ge.tag) {
              case 3:
                ge.flags |= 65536, i &= -i, ge.lanes |= i;
                var st = ch(ge, rt, i);
                Ff(ge, st);
                break e;
              case 1:
                Qe = rt;
                var it = ge.type, ut = ge.stateNode;
                if ((ge.flags & 128) === 0 && (typeof it.getDerivedStateFromError == "function" || ut !== null && typeof ut.componentDidCatch == "function" && (Bn === null || !Bn.has(ut)))) {
                  ge.flags |= 65536, i &= -i, ge.lanes |= i;
                  var kt = dh(ge, Qe, i);
                  Ff(ge, kt);
                  break e;
                }
            }
            ge = ge.return;
          } while (ge !== null);
        }
        Yh(w);
      } catch (Dt) {
        i = Dt, Ir === w && w !== null && (Ir = w = w.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Wh() {
    var t = Eo.current;
    return Eo.current = go, t === null ? go : t;
  }
  function vl() {
    (Dr === 0 || Dr === 3 || Dr === 2) && (Dr = 4), Gr === null || (fa & 268435455) === 0 && (xo & 268435455) === 0 || Un(Gr, Yr);
  }
  function Po(t, i) {
    var w = ir;
    ir |= 2;
    var N = Wh();
    (Gr !== t || Yr !== i) && (_n = null, ca(t, i));
    do
      try {
        Hd();
        break;
      } catch (ne) {
        Vh(t, ne);
      }
    while (!0);
    if (Tu(), ir = w, Eo.current = N, Ir !== null) throw Error(ae(261));
    return Gr = null, Yr = 0, Dr;
  }
  function Hd() {
    for (; Ir !== null; ) Zh(Ir);
  }
  function Gd() {
    for (; Ir !== null && !Ot(); ) Zh(Ir);
  }
  function Zh(t) {
    var i = Qh(t.alternate, t, xi);
    t.memoizedProps = t.pendingProps, i === null ? Yh(t) : Ir = i, sl.current = null;
  }
  function Yh(t) {
    var i = t;
    do {
      var w = i.alternate;
      if (t = i.return, (i.flags & 32768) === 0) {
        if (w = Nd(w, i, xi), w !== null) {
          Ir = w;
          return;
        }
      } else {
        if (w = Dd(w, i), w !== null) {
          w.flags &= 32767, Ir = w;
          return;
        }
        if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
        else {
          Dr = 6, Ir = null;
          return;
        }
      }
      if (i = i.sibling, i !== null) {
        Ir = i;
        return;
      }
      Ir = i = t;
    } while (i !== null);
    Dr === 0 && (Dr = 5);
  }
  function da(t, i, w) {
    var N = qt, ne = Oi.transition;
    try {
      Oi.transition = null, qt = 1, Vd(t, i, w, N);
    } finally {
      Oi.transition = ne, qt = N;
    }
    return null;
  }
  function Vd(t, i, w, N) {
    do
      Va();
    while (zn !== null);
    if ((ir & 6) !== 0) throw Error(ae(327));
    w = t.finishedWork;
    var ne = t.finishedLanes;
    if (w === null) return null;
    if (t.finishedWork = null, t.finishedLanes = 0, w === t.current) throw Error(ae(177));
    t.callbackNode = null, t.callbackPriority = 0;
    var ge = w.lanes | w.childLanes;
    if (ya(t, ge), t === Gr && (Ir = Gr = null, Yr = 0), (w.subtreeFlags & 2064) === 0 && (w.flags & 2064) === 0 || ko || (ko = !0, Kh(ar, function() {
      return Va(), null;
    })), ge = (w.flags & 15990) !== 0, (w.subtreeFlags & 15990) !== 0 || ge) {
      ge = Oi.transition, Oi.transition = null;
      var ze = qt;
      qt = 1;
      var Qe = ir;
      ir |= 4, sl.current = null, zd(t, w), Bh(w, t), Wt(vu), Ci = !!pu, vu = pu = null, t.current = w, Fd(w), Nt(), ir = Qe, qt = ze, Oi.transition = ge;
    } else t.current = w;
    if (ko && (ko = !1, zn = t, Ao = ne), ge = t.pendingLanes, ge === 0 && (Bn = null), lr(w.stateNode), di(t, Mt()), i !== null) for (N = t.onRecoverableError, w = 0; w < i.length; w++) ne = i[w], N(ne.value, { componentStack: ne.stack, digest: ne.digest });
    if (Co) throw Co = !1, t = ll, ll = null, t;
    return (Ao & 1) !== 0 && t.tag !== 0 && Va(), ge = t.pendingLanes, (ge & 1) !== 0 ? t === fl ? bs++ : (bs = 0, fl = t) : bs = 0, On(), null;
  }
  function Va() {
    if (zn !== null) {
      var t = qi(Ao), i = Oi.transition, w = qt;
      try {
        if (Oi.transition = null, qt = 16 > t ? 16 : t, zn === null) var N = !1;
        else {
          if (t = zn, zn = null, Ao = 0, (ir & 6) !== 0) throw Error(ae(331));
          var ne = ir;
          for (ir |= 4, It = t.current; It !== null; ) {
            var ge = It, ze = ge.child;
            if ((It.flags & 16) !== 0) {
              var Qe = ge.deletions;
              if (Qe !== null) {
                for (var rt = 0; rt < Qe.length; rt++) {
                  var ft = Qe[rt];
                  for (It = ft; It !== null; ) {
                    var yt = It;
                    switch (yt.tag) {
                      case 0:
                      case 11:
                      case 15:
                        _s(8, yt, ge);
                    }
                    var St = yt.child;
                    if (St !== null) St.return = yt, It = St;
                    else for (; It !== null; ) {
                      yt = It;
                      var _t = yt.sibling, Pt = yt.return;
                      if (Rh(yt), yt === ft) {
                        It = null;
                        break;
                      }
                      if (_t !== null) {
                        _t.return = Pt, It = _t;
                        break;
                      }
                      It = Pt;
                    }
                  }
                }
                var Rt = ge.alternate;
                if (Rt !== null) {
                  var Lt = Rt.child;
                  if (Lt !== null) {
                    Rt.child = null;
                    do {
                      var Tr = Lt.sibling;
                      Lt.sibling = null, Lt = Tr;
                    } while (Lt !== null);
                  }
                }
                It = ge;
              }
            }
            if ((ge.subtreeFlags & 2064) !== 0 && ze !== null) ze.return = ge, It = ze;
            else e: for (; It !== null; ) {
              if (ge = It, (ge.flags & 2048) !== 0) switch (ge.tag) {
                case 0:
                case 11:
                case 15:
                  _s(9, ge, ge.return);
              }
              var st = ge.sibling;
              if (st !== null) {
                st.return = ge.return, It = st;
                break e;
              }
              It = ge.return;
            }
          }
          var it = t.current;
          for (It = it; It !== null; ) {
            ze = It;
            var ut = ze.child;
            if ((ze.subtreeFlags & 2064) !== 0 && ut !== null) ut.return = ze, It = ut;
            else e: for (ze = it; It !== null; ) {
              if (Qe = It, (Qe.flags & 2048) !== 0) try {
                switch (Qe.tag) {
                  case 0:
                  case 11:
                  case 15:
                    So(9, Qe);
                }
              } catch (Dt) {
                Cr(Qe, Qe.return, Dt);
              }
              if (Qe === ze) {
                It = null;
                break e;
              }
              var kt = Qe.sibling;
              if (kt !== null) {
                kt.return = Qe.return, It = kt;
                break e;
              }
              It = Qe.return;
            }
          }
          if (ir = ne, On(), $t && typeof $t.onPostCommitFiberRoot == "function") try {
            $t.onPostCommitFiberRoot(wt, t);
          } catch {
          }
          N = !0;
        }
        return N;
      } finally {
        qt = w, Oi.transition = i;
      }
    }
    return !1;
  }
  function Xh(t, i, w) {
    i = Ua(w, i), i = ch(t, i, 1), t = Nn(t, i, 1), i = si(), t !== null && (Yi(t, 1, i), di(t, i));
  }
  function Cr(t, i, w) {
    if (t.tag === 3) Xh(t, t, w);
    else for (; i !== null; ) {
      if (i.tag === 3) {
        Xh(i, t, w);
        break;
      } else if (i.tag === 1) {
        var N = i.stateNode;
        if (typeof i.type.getDerivedStateFromError == "function" || typeof N.componentDidCatch == "function" && (Bn === null || !Bn.has(N))) {
          t = Ua(w, t), t = dh(i, t, 1), i = Nn(i, t, 1), t = si(), i !== null && (Yi(i, 1, t), di(i, t));
          break;
        }
      }
      i = i.return;
    }
  }
  function Wd(t, i, w) {
    var N = t.pingCache;
    N !== null && N.delete(i), i = si(), t.pingedLanes |= t.suspendedLanes & w, Gr === t && (Yr & w) === w && (Dr === 4 || Dr === 3 && (Yr & 130023424) === Yr && 500 > Mt() - ul ? ca(t, 0) : ol |= w), di(t, i);
  }
  function qh(t, i) {
    i === 0 && ((t.mode & 1) === 0 ? i = 1 : (i = Er, Er <<= 1, (Er & 130023424) === 0 && (Er = 4194304)));
    var w = si();
    t = vn(t, i), t !== null && (Yi(t, i, w), di(t, w));
  }
  function Zd(t) {
    var i = t.memoizedState, w = 0;
    i !== null && (w = i.retryLane), qh(t, w);
  }
  function Yd(t, i) {
    var w = 0;
    switch (t.tag) {
      case 13:
        var N = t.stateNode, ne = t.memoizedState;
        ne !== null && (w = ne.retryLane);
        break;
      case 19:
        N = t.stateNode;
        break;
      default:
        throw Error(ae(314));
    }
    N !== null && N.delete(i), qh(t, w);
  }
  var Qh;
  Qh = function(t, i, w) {
    if (t !== null) if (t.memoizedProps !== i.pendingProps || li.current) hi = !0;
    else {
      if ((t.lanes & w) === 0 && (i.flags & 128) === 0) return hi = !1, Ld(t, i, w);
      hi = (t.flags & 131072) !== 0;
    }
    else hi = !1, mr && (i.flags & 1048576) !== 0 && Mf(i, no, i.index);
    switch (i.lanes = 0, i.tag) {
      case 2:
        var N = i.type;
        wo(t, i), t = i.pendingProps;
        var ne = Ra(i, Jr.current);
        za(i, w), ne = Fu(null, i, N, t, ne, w);
        var ge = Uu();
        return i.flags |= 1, typeof ne == "object" && ne !== null && typeof ne.render == "function" && ne.$$typeof === void 0 ? (i.tag = 1, i.memoizedState = null, i.updateQueue = null, fi(N) ? (ge = !0, to(i)) : ge = !1, i.memoizedState = ne.state !== null && ne.state !== void 0 ? ne.state : null, Ru(i), ne.updater = _o, i.stateNode = ne, ne._reactInternals = i, Zu(i, N, t, w), i = Qu(null, i, N, !0, ge, w)) : (i.tag = 0, mr && ge && Su(i), ai(null, i, ne, w), i = i.child), i;
      case 16:
        N = i.elementType;
        e: {
          switch (wo(t, i), t = i.pendingProps, ne = N._init, N = ne(N._payload), i.type = N, ne = i.tag = qd(N), t = Hi(N, t), ne) {
            case 0:
              i = qu(null, i, N, t, w);
              break e;
            case 1:
              i = Sh(null, i, N, t, w);
              break e;
            case 11:
              i = gh(null, i, N, t, w);
              break e;
            case 14:
              i = _h(null, i, N, Hi(N.type, t), w);
              break e;
          }
          throw Error(ae(
            306,
            N,
            ""
          ));
        }
        return i;
      case 0:
        return N = i.type, ne = i.pendingProps, ne = i.elementType === N ? ne : Hi(N, ne), qu(t, i, N, ne, w);
      case 1:
        return N = i.type, ne = i.pendingProps, ne = i.elementType === N ? ne : Hi(N, ne), Sh(t, i, N, ne, w);
      case 3:
        e: {
          if (Eh(i), t === null) throw Error(ae(387));
          N = i.pendingProps, ge = i.memoizedState, ne = ge.element, zf(t, i), fo(i, N, null, w);
          var ze = i.memoizedState;
          if (N = ze.element, ge.isDehydrated) if (ge = { element: N, isDehydrated: !1, cache: ze.cache, pendingSuspenseBoundaries: ze.pendingSuspenseBoundaries, transitions: ze.transitions }, i.updateQueue.baseState = ge, i.memoizedState = ge, i.flags & 256) {
            ne = Ua(Error(ae(423)), i), i = xh(t, i, N, w, ne);
            break e;
          } else if (N !== ne) {
            ne = Ua(Error(ae(424)), i), i = xh(t, i, N, w, ne);
            break e;
          } else for (Ei = Pn(i.stateNode.containerInfo.firstChild), Si = i, mr = !0, ji = null, w = Df(i, null, N, w), i.child = w; w; ) w.flags = w.flags & -3 | 4096, w = w.sibling;
          else {
            if (Na(), N === ne) {
              i = gn(t, i, w);
              break e;
            }
            ai(t, i, N, w);
          }
          i = i.child;
        }
        return i;
      case 5:
        return jf(i), t === null && Cu(i), N = i.type, ne = i.pendingProps, ge = t !== null ? t.memoizedProps : null, ze = ne.children, mu(N, ne) ? ze = null : ge !== null && mu(N, ge) && (i.flags |= 32), bh(t, i), ai(t, i, ze, w), i.child;
      case 6:
        return t === null && Cu(i), null;
      case 13:
        return Ch(t, i, w);
      case 4:
        return Ou(i, i.stateNode.containerInfo), N = i.pendingProps, t === null ? i.child = Da(i, null, N, w) : ai(t, i, N, w), i.child;
      case 11:
        return N = i.type, ne = i.pendingProps, ne = i.elementType === N ? ne : Hi(N, ne), gh(t, i, N, ne, w);
      case 7:
        return ai(t, i, i.pendingProps, w), i.child;
      case 8:
        return ai(t, i, i.pendingProps.children, w), i.child;
      case 12:
        return ai(t, i, i.pendingProps.children, w), i.child;
      case 10:
        e: {
          if (N = i.type._context, ne = i.pendingProps, ge = i.memoizedProps, ze = ne.value, cr(oo, N._currentValue), N._currentValue = ze, ge !== null) if (Pr(ge.value, ze)) {
            if (ge.children === ne.children && !li.current) {
              i = gn(t, i, w);
              break e;
            }
          } else for (ge = i.child, ge !== null && (ge.return = i); ge !== null; ) {
            var Qe = ge.dependencies;
            if (Qe !== null) {
              ze = ge.child;
              for (var rt = Qe.firstContext; rt !== null; ) {
                if (rt.context === N) {
                  if (ge.tag === 1) {
                    rt = mn(-1, w & -w), rt.tag = 2;
                    var ft = ge.updateQueue;
                    if (ft !== null) {
                      ft = ft.shared;
                      var yt = ft.pending;
                      yt === null ? rt.next = rt : (rt.next = yt.next, yt.next = rt), ft.pending = rt;
                    }
                  }
                  ge.lanes |= w, rt = ge.alternate, rt !== null && (rt.lanes |= w), Pu(
                    ge.return,
                    w,
                    i
                  ), Qe.lanes |= w;
                  break;
                }
                rt = rt.next;
              }
            } else if (ge.tag === 10) ze = ge.type === i.type ? null : ge.child;
            else if (ge.tag === 18) {
              if (ze = ge.return, ze === null) throw Error(ae(341));
              ze.lanes |= w, Qe = ze.alternate, Qe !== null && (Qe.lanes |= w), Pu(ze, w, i), ze = ge.sibling;
            } else ze = ge.child;
            if (ze !== null) ze.return = ge;
            else for (ze = ge; ze !== null; ) {
              if (ze === i) {
                ze = null;
                break;
              }
              if (ge = ze.sibling, ge !== null) {
                ge.return = ze.return, ze = ge;
                break;
              }
              ze = ze.return;
            }
            ge = ze;
          }
          ai(t, i, ne.children, w), i = i.child;
        }
        return i;
      case 9:
        return ne = i.type, N = i.pendingProps.children, za(i, w), ne = Ii(ne), N = N(ne), i.flags |= 1, ai(t, i, N, w), i.child;
      case 14:
        return N = i.type, ne = Hi(N, i.pendingProps), ne = Hi(N.type, ne), _h(t, i, N, ne, w);
      case 15:
        return yh(t, i, i.type, i.pendingProps, w);
      case 17:
        return N = i.type, ne = i.pendingProps, ne = i.elementType === N ? ne : Hi(N, ne), wo(t, i), i.tag = 1, fi(N) ? (t = !0, to(i)) : t = !1, za(i, w), fh(i, N, ne), Zu(i, N, ne, w), Qu(null, i, N, !0, t, w);
      case 19:
        return Ah(t, i, w);
      case 22:
        return wh(t, i, w);
    }
    throw Error(ae(156, i.tag));
  };
  function Kh(t, i) {
    return Ct(t, i);
  }
  function Xd(t, i, w, N) {
    this.tag = t, this.key = w, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = i, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = N, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Li(t, i, w, N) {
    return new Xd(t, i, w, N);
  }
  function ml(t) {
    return t = t.prototype, !(!t || !t.isReactComponent);
  }
  function qd(t) {
    if (typeof t == "function") return ml(t) ? 1 : 0;
    if (t != null) {
      if (t = t.$$typeof, t === U) return 11;
      if (t === oe) return 14;
    }
    return 2;
  }
  function jn(t, i) {
    var w = t.alternate;
    return w === null ? (w = Li(t.tag, i, t.key, t.mode), w.elementType = t.elementType, w.type = t.type, w.stateNode = t.stateNode, w.alternate = t, t.alternate = w) : (w.pendingProps = i, w.type = t.type, w.flags = 0, w.subtreeFlags = 0, w.deletions = null), w.flags = t.flags & 14680064, w.childLanes = t.childLanes, w.lanes = t.lanes, w.child = t.child, w.memoizedProps = t.memoizedProps, w.memoizedState = t.memoizedState, w.updateQueue = t.updateQueue, i = t.dependencies, w.dependencies = i === null ? null : { lanes: i.lanes, firstContext: i.firstContext }, w.sibling = t.sibling, w.index = t.index, w.ref = t.ref, w;
  }
  function Io(t, i, w, N, ne, ge) {
    var ze = 2;
    if (N = t, typeof t == "function") ml(t) && (ze = 1);
    else if (typeof t == "string") ze = 5;
    else e: switch (t) {
      case A:
        return pa(w.children, ne, ge, i);
      case T:
        ze = 8, ne |= 8;
        break;
      case I:
        return t = Li(12, w, i, ne | 2), t.elementType = I, t.lanes = ge, t;
      case J:
        return t = Li(13, w, i, ne), t.elementType = J, t.lanes = ge, t;
      case F:
        return t = Li(19, w, i, ne), t.elementType = F, t.lanes = ge, t;
      case ie:
        return Ro(w, ne, ge, i);
      default:
        if (typeof t == "object" && t !== null) switch (t.$$typeof) {
          case L:
            ze = 10;
            break e;
          case z:
            ze = 9;
            break e;
          case U:
            ze = 11;
            break e;
          case oe:
            ze = 14;
            break e;
          case ee:
            ze = 16, N = null;
            break e;
        }
        throw Error(ae(130, t == null ? t : typeof t, ""));
    }
    return i = Li(ze, w, i, ne), i.elementType = t, i.type = N, i.lanes = ge, i;
  }
  function pa(t, i, w, N) {
    return t = Li(7, t, N, i), t.lanes = w, t;
  }
  function Ro(t, i, w, N) {
    return t = Li(22, t, N, i), t.elementType = ie, t.lanes = w, t.stateNode = { isHidden: !1 }, t;
  }
  function gl(t, i, w) {
    return t = Li(6, t, null, i), t.lanes = w, t;
  }
  function _l(t, i, w) {
    return i = Li(4, t.children !== null ? t.children : [], t.key, i), i.lanes = w, i.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, i;
  }
  function Qd(t, i, w, N, ne) {
    this.tag = i, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = bn(0), this.expirationTimes = bn(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = bn(0), this.identifierPrefix = N, this.onRecoverableError = ne, this.mutableSourceEagerHydrationData = null;
  }
  function yl(t, i, w, N, ne, ge, ze, Qe, rt) {
    return t = new Qd(t, i, w, Qe, rt), i === 1 ? (i = 1, ge === !0 && (i |= 8)) : i = 0, ge = Li(3, null, null, i), t.current = ge, ge.stateNode = t, ge.memoizedState = { element: N, isDehydrated: w, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Ru(ge), t;
  }
  function Kd(t, i, w) {
    var N = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: o, key: N == null ? null : "" + N, children: t, containerInfo: i, implementation: w };
  }
  function $h(t) {
    if (!t) return Rn;
    t = t._reactInternals;
    e: {
      if (vt(t) !== t || t.tag !== 1) throw Error(ae(170));
      var i = t;
      do {
        switch (i.tag) {
          case 3:
            i = i.stateNode.context;
            break e;
          case 1:
            if (fi(i.type)) {
              i = i.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        i = i.return;
      } while (i !== null);
      throw Error(ae(171));
    }
    if (t.tag === 1) {
      var w = t.type;
      if (fi(w)) return kf(t, w, i);
    }
    return i;
  }
  function Jh(t, i, w, N, ne, ge, ze, Qe, rt) {
    return t = yl(w, N, !0, t, ne, ge, ze, Qe, rt), t.context = $h(null), w = t.current, N = si(), ne = Fn(w), ge = mn(N, ne), ge.callback = i ?? null, Nn(w, ge, ne), t.current.lanes = ne, Yi(t, ne, N), di(t, N), t;
  }
  function Oo(t, i, w, N) {
    var ne = i.current, ge = si(), ze = Fn(ne);
    return w = $h(w), i.context === null ? i.context = w : i.pendingContext = w, i = mn(ge, ze), i.payload = { element: t }, N = N === void 0 ? null : N, N !== null && (i.callback = N), t = Nn(ne, i, ze), t !== null && (Wi(t, ne, ze, ge), lo(t, ne, ze)), ze;
  }
  function Lo(t) {
    if (t = t.current, !t.child) return null;
    switch (t.child.tag) {
      case 5:
        return t.child.stateNode;
      default:
        return t.child.stateNode;
    }
  }
  function ec(t, i) {
    if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
      var w = t.retryLane;
      t.retryLane = w !== 0 && w < i ? w : i;
    }
  }
  function wl(t, i) {
    ec(t, i), (t = t.alternate) && ec(t, i);
  }
  function $d() {
    return null;
  }
  var tc = typeof reportError == "function" ? reportError : function(t) {
    console.error(t);
  };
  function bl(t) {
    this._internalRoot = t;
  }
  No.prototype.render = bl.prototype.render = function(t) {
    var i = this._internalRoot;
    if (i === null) throw Error(ae(409));
    Oo(t, i, null, null);
  }, No.prototype.unmount = bl.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
      this._internalRoot = null;
      var i = t.containerInfo;
      ha(function() {
        Oo(null, t, null, null);
      }), i[hn] = null;
    }
  };
  function No(t) {
    this._internalRoot = t;
  }
  No.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
      var i = Vt();
      t = { blockedOn: null, target: t, priority: i };
      for (var w = 0; w < V.length && i !== 0 && i < V[w].priority; w++) ;
      V.splice(w, 0, t), w === 0 && lt(t);
    }
  };
  function Sl(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11);
  }
  function Do(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "));
  }
  function rc() {
  }
  function Jd(t, i, w, N, ne) {
    if (ne) {
      if (typeof N == "function") {
        var ge = N;
        N = function() {
          var ft = Lo(ze);
          ge.call(ft);
        };
      }
      var ze = Jh(i, N, t, 0, null, !1, !1, "", rc);
      return t._reactRootContainer = ze, t[hn] = ze.current, as(t.nodeType === 8 ? t.parentNode : t), ha(), ze;
    }
    for (; ne = t.lastChild; ) t.removeChild(ne);
    if (typeof N == "function") {
      var Qe = N;
      N = function() {
        var ft = Lo(rt);
        Qe.call(ft);
      };
    }
    var rt = yl(t, 0, !1, null, null, !1, !1, "", rc);
    return t._reactRootContainer = rt, t[hn] = rt.current, as(t.nodeType === 8 ? t.parentNode : t), ha(function() {
      Oo(i, rt, w, N);
    }), rt;
  }
  function Bo(t, i, w, N, ne) {
    var ge = w._reactRootContainer;
    if (ge) {
      var ze = ge;
      if (typeof ne == "function") {
        var Qe = ne;
        ne = function() {
          var rt = Lo(ze);
          Qe.call(rt);
        };
      }
      Oo(i, ze, t, ne);
    } else ze = Jd(w, i, t, ne, N);
    return Lo(ze);
  }
  Qi = function(t) {
    switch (t.tag) {
      case 3:
        var i = t.stateNode;
        if (i.current.memoizedState.isDehydrated) {
          var w = kr(i.pendingLanes);
          w !== 0 && (Xi(i, w | 1), di(i, Mt()), (ir & 6) === 0 && (Ga = Mt() + 500, On()));
        }
        break;
      case 13:
        ha(function() {
          var N = vn(t, 1);
          if (N !== null) {
            var ne = si();
            Wi(N, t, 1, ne);
          }
        }), wl(t, 1);
    }
  }, _i = function(t) {
    if (t.tag === 13) {
      var i = vn(t, 134217728);
      if (i !== null) {
        var w = si();
        Wi(i, t, 134217728, w);
      }
      wl(t, 134217728);
    }
  }, ni = function(t) {
    if (t.tag === 13) {
      var i = Fn(t), w = vn(t, i);
      if (w !== null) {
        var N = si();
        Wi(w, t, i, N);
      }
      wl(t, i);
    }
  }, Vt = function() {
    return qt;
  }, Qr = function(t, i) {
    var w = qt;
    try {
      return qt = t, i();
    } finally {
      qt = w;
    }
  }, ye = function(t, i, w) {
    switch (i) {
      case "input":
        if (Ne(t, w), i = w.name, w.type === "radio" && i != null) {
          for (w = t; w.parentNode; ) w = w.parentNode;
          for (w = w.querySelectorAll("input[name=" + JSON.stringify("" + i) + '][type="radio"]'), i = 0; i < w.length; i++) {
            var N = w[i];
            if (N !== t && N.form === t.form) {
              var ne = Js(N);
              if (!ne) throw Error(ae(90));
              $e(N), Ne(N, ne);
            }
          }
        }
        break;
      case "textarea":
        G(t, w);
        break;
      case "select":
        i = w.value, i != null && Ce(t, !!w.multiple, i, !1);
    }
  }, v = dl, se = ha;
  var ep = { usingClientEntryPoint: !1, Events: [us, Pa, Js, Se, le, dl] }, Ss = { findFiberByHostInstance: ia, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, tp = { bundleType: Ss.bundleType, version: Ss.version, rendererPackageName: Ss.rendererPackageName, rendererConfig: Ss.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: b.ReactCurrentDispatcher, findHostInstanceByFiber: function(t) {
    return t = ht(t), t === null ? null : t.stateNode;
  }, findFiberByHostInstance: Ss.findFiberByHostInstance || $d, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var zo = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!zo.isDisabled && zo.supportsFiber) try {
      wt = zo.inject(tp), $t = zo;
    } catch {
    }
  }
  return pi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ep, pi.createPortal = function(t, i) {
    var w = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Sl(i)) throw Error(ae(200));
    return Kd(t, i, null, w);
  }, pi.createRoot = function(t, i) {
    if (!Sl(t)) throw Error(ae(299));
    var w = !1, N = "", ne = tc;
    return i != null && (i.unstable_strictMode === !0 && (w = !0), i.identifierPrefix !== void 0 && (N = i.identifierPrefix), i.onRecoverableError !== void 0 && (ne = i.onRecoverableError)), i = yl(t, 1, !1, null, null, w, !1, N, ne), t[hn] = i.current, as(t.nodeType === 8 ? t.parentNode : t), new bl(i);
  }, pi.findDOMNode = function(t) {
    if (t == null) return null;
    if (t.nodeType === 1) return t;
    var i = t._reactInternals;
    if (i === void 0)
      throw typeof t.render == "function" ? Error(ae(188)) : (t = Object.keys(t).join(","), Error(ae(268, t)));
    return t = ht(i), t = t === null ? null : t.stateNode, t;
  }, pi.flushSync = function(t) {
    return ha(t);
  }, pi.hydrate = function(t, i, w) {
    if (!Do(i)) throw Error(ae(200));
    return Bo(null, t, i, !0, w);
  }, pi.hydrateRoot = function(t, i, w) {
    if (!Sl(t)) throw Error(ae(405));
    var N = w != null && w.hydratedSources || null, ne = !1, ge = "", ze = tc;
    if (w != null && (w.unstable_strictMode === !0 && (ne = !0), w.identifierPrefix !== void 0 && (ge = w.identifierPrefix), w.onRecoverableError !== void 0 && (ze = w.onRecoverableError)), i = Jh(i, null, t, 1, w ?? null, ne, !1, ge, ze), t[hn] = i.current, as(t), N) for (t = 0; t < N.length; t++) w = N[t], ne = w._getVersion, ne = ne(w._source), i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [w, ne] : i.mutableSourceEagerHydrationData.push(
      w,
      ne
    );
    return new No(i);
  }, pi.render = function(t, i, w) {
    if (!Do(i)) throw Error(ae(200));
    return Bo(null, t, i, !1, w);
  }, pi.unmountComponentAtNode = function(t) {
    if (!Do(t)) throw Error(ae(40));
    return t._reactRootContainer ? (ha(function() {
      Bo(null, null, t, !1, function() {
        t._reactRootContainer = null, t[hn] = null;
      });
    }), !0) : !1;
  }, pi.unstable_batchedUpdates = dl, pi.unstable_renderSubtreeIntoContainer = function(t, i, w, N) {
    if (!Do(w)) throw Error(ae(200));
    if (t == null || t._reactInternals === void 0) throw Error(ae(38));
    return Bo(t, i, w, !1, N);
  }, pi.version = "18.3.1-next-f1338f8080-20240426", pi;
}
var fc;
function fp() {
  if (fc) return Cl.exports;
  fc = 1;
  function Re() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Re);
      } catch (be) {
        console.error(be);
      }
  }
  return Re(), Cl.exports = lp(), Cl.exports;
}
var hc;
function hp() {
  if (hc) return Fo;
  hc = 1;
  var Re = fp();
  return Fo.createRoot = Re.createRoot, Fo.hydrateRoot = Re.hydrateRoot, Fo;
}
var cp = hp();
const dp = /* @__PURE__ */ Yo(cp), rf = () => {
  const Re = document.getElementById("product-info"), be = JSON.parse((Re == null ? void 0 : Re.textContent) || "{}");
  return window.shineon = window.shineon || {}, window.shineon.product_info = be, be;
}, nf = () => {
  const Re = rf();
  return pp(Re);
}, pp = (Re) => {
  var be;
  return !Re.shop_cf || !((be = Re.shop_pt_id_obj) != null && be.custom_fields) ? [] : Re.shop_pt_id_obj.custom_fields.map((ae) => ({
    ...Re.shop_cf[ae.key],
    id: ae
  }));
}, vp = ({ hasErrors: Re, setUserInteracted: be }) => (Kt.useEffect(() => {
  const ae = Array.from(document.querySelectorAll('form[action="/cart/add"]')).filter(
    (Z) => Z.querySelector('button[type="submit"]')
  );
  if (!ae.length) return;
  const k = () => {
    be(!0);
  };
  return ae.forEach((Z) => {
    Z.querySelectorAll(".so-validation-mask").forEach((M) => M.remove());
  }), Re ? ae.forEach((Z) => {
    const _ = Z.querySelector('button[type="submit"]');
    if (!_) return;
    const M = _.parentElement;
    if (!M) return;
    M.style.position = "relative";
    const x = document.createElement("div");
    x.className = "so-validation-mask", x.addEventListener("click", k), M.appendChild(x);
  }) : be(!1), () => {
    ae.forEach((Z) => {
      Z.querySelectorAll(".so-validation-mask").forEach((M) => {
        M.removeEventListener("click", k), M.remove();
      });
    });
  };
}, [Re]), null), mp = ({ uploads: Re, validationErrors: be, hasErrors: ae, setUserInteracted: k }) => (Kt.useEffect(() => {
  const Z = Array.from(document.querySelectorAll("form")).filter(
    (_) => _.querySelector('button[type="submit"]')
  );
  Z.length && Z.forEach((_) => {
    const M = _.querySelector('input[name="properties[Upload]"]');
    if (M && M.remove(), Re.Upload) {
      const x = document.createElement("input");
      x.type = "hidden", x.name = "properties[Upload]", x.value = Re.Upload, _.appendChild(x);
    }
  });
}, [Re.Upload]), /* @__PURE__ */ pt.jsx(
  vp,
  {
    validationErrors: be,
    hasErrors: ae,
    setUserInteracted: k
  }
)), af = rf();
let Tl = af.selected_variant;
const gp = {
  get variantInputs() {
    return document.querySelectorAll(af.variant_id_input);
  }
}, _p = () => {
  const Re = document.querySelectorAll('form[action="/cart/add"]');
  return Array.from(Re).map((be) => be.getAttribute("id"));
}, yp = () => (Tl || gp.variantInputs.forEach((Re) => {
  if (Re) {
    const be = parseInt(Re.value);
    Tl = af.product.variants.find((ae) => ae.id === be);
  }
}), Tl), wp = ({ product_cf: Re, required: be, formId: ae, onBeforeInput: k, onChange: Z }) => {
  const _ = (M, x) => ({
    type: "text",
    id: M.id.key,
    name: `properties[${M.name}]`,
    autoComplete: "off",
    placeholder: M.placeholder,
    form: x,
    pattern: M.pattern,
    required: be,
    className: `so-field__input ${M.class || ""}`,
    minLength: M.minlength > 0 ? M.minlength : void 0,
    maxLength: M.maxlength > 0 ? M.maxlength : 20,
    onBeforeInput: k,
    onChange: Z
  });
  return /* @__PURE__ */ pt.jsx("input", { ..._(Re, ae) });
}, bp = {
  first: ["t", "a", "f", "h", "b"],
  last: ["w", "e", "t", "i", "o", "s", "d", "f", "h", "k", "l", "z", "b"]
}, Sp = ({ previewConfig: Re, inputs: be, product_cf: ae, metalType: k }) => {
  var g, h, m;
  const Z = Re.chains || {}, _ = Re.fields[0].class, M = _.includes("graduation") ? !1 : ((g = Z.left) == null ? void 0 : g[k]) || ((h = Z.right) == null ? void 0 : h[k]) || ((m = Z.vertical) == null ? void 0 : m[k]), x = (s) => {
    var A, T, I, L;
    const b = (be[s.id.key] || s.name).replace(/\s+/g, ""), S = ((L = (I = (T = (A = Re.symbolAtEnd) == null ? void 0 : A[0]) == null ? void 0 : T.options) == null ? void 0 : I[0]) == null ? void 0 : L.code) || "";
    return (Re.flowerSymbol || "") + b + S;
  }, y = x(ae), E = y.length >= 2, c = (s, b) => {
    if (!b) return "";
    const S = b.toLowerCase();
    return bp[s].includes(S) ? `${s}-letter-${S}` : "";
  }, u = c("first", y[0]), l = c("last", y[y.length - 1]), a = (s) => {
    const b = Array.isArray(s) ? s : [s], S = `preview-items-${b.length}`;
    return /* @__PURE__ */ pt.jsx("div", { className: `preview-w ${_} ${S}`, children: b.map((o, A) => /* @__PURE__ */ pt.jsxs("div", { className: `preview-item preview-item-${A + 1}`, children: [
      /* @__PURE__ */ pt.jsx("span", { className: `preview ${_}`, children: x(o) }),
      /* @__PURE__ */ pt.jsx("span", { className: `preview colored-with-gradient ${_} preview-mask`, children: x(o) })
    ] }, o.id.key)) });
  }, n = (s) => {
    var A, T;
    const b = Re.isVertical ? "vertical" : s, o = (Array.isArray(Re.inputFields) ? Re.inputFields : [ae]).length;
    if (Re.isVertical && o > 1) {
      const I = Object.keys(Z.vertical.multiple).find((L) => parseInt(L) === o);
      if (I)
        return /* @__PURE__ */ pt.jsx(
          "img",
          {
            src: (A = Z.vertical.multiple[I]) == null ? void 0 : A[k],
            className: `chain-${s}`,
            alt: `${s.charAt(0).toUpperCase() + s.slice(1)} chain for ${o} items`,
            "data-metal": k,
            "data-items": o
          }
        );
    }
    return /* @__PURE__ */ pt.jsx(
      "img",
      {
        src: (T = Z[b]) == null ? void 0 : T[k],
        className: `chain-${s}`,
        alt: `${s.charAt(0).toUpperCase() + s.slice(1)} chain`,
        "data-metal": k
      }
    );
  }, d = (s = !1) => {
    const b = document.querySelector(".preview-vertical"), S = b == null ? void 0 : b.querySelector(".chain-vertical"), o = b == null ? void 0 : b.querySelector(".preview-w");
    if (!S || !o || !b) return;
    const A = S.offsetWidth + o.offsetWidth, T = 10, I = A + T;
    (!b.style.minHeight || s.type === "load") && (b.style.minHeight = `${I}px`), b.style.height = `${A + T}px`;
  };
  return Kt.useEffect(() => {
    d();
  }, [y]), Kt.useEffect(() => {
    const s = (b) => {
      d(b);
    };
    return window.addEventListener("load", s), () => {
      window.removeEventListener("load", s);
      const b = document.querySelector(".preview-vertical");
      b && (b.style.height = "");
    };
  }, []), /* @__PURE__ */ pt.jsx(
    "div",
    {
      className: `font-preview-w ${M ? "w-chains" : ""} ${Re.isVertical ? "vertical" : ""}`,
      "data-metal": k,
      children: /* @__PURE__ */ pt.jsx("div", { className: `position-wrap ${Re.isVertical ? "preview-vertical" : ""}`, children: M ? /* @__PURE__ */ pt.jsx(pt.Fragment, { children: Re.isVertical ? /* @__PURE__ */ pt.jsxs(pt.Fragment, { children: [
        /* @__PURE__ */ pt.jsx("span", { className: `font-preview-chain chain-vertical ${_}`, children: n("vertical") }),
        a(Re.inputFields || ae)
      ] }) : /* @__PURE__ */ pt.jsxs(pt.Fragment, { children: [
        /* @__PURE__ */ pt.jsx("span", { className: `font-preview-chain chain-left ${_} ${u}`, children: n("left") }),
        a(Re.inputFields || ae),
        /* @__PURE__ */ pt.jsx(
          "span",
          {
            className: `font-preview-chain chain-right ${_} ${l}`,
            style: { opacity: E ? 1 : 0 },
            children: n("right")
          }
        )
      ] }) }) : a(Re.inputFields || ae) })
    }
  );
}, Ep = (Re, be = !1) => Re ? be ? Re.charAt(0).toUpperCase() + Re.slice(1).toLowerCase() : Re : "", xp = ({
  currentVariant: Re,
  productInfo: be,
  productCustomFields: ae,
  formId: k,
  inputFields: Z,
  inputs: _,
  setInputs: M,
  validationErrors: x,
  showErrors: y
}) => {
  var b, S, o, A;
  const [E, c] = Kt.useState({}), [u, l] = Kt.useState({});
  Kt.useEffect(() => {
    const T = Z.slice(0, be.variant_metafields[Re.id].engravings || Z.length).map((z) => z.id.key), I = Object.entries(_).reduce((z, [U, J]) => (T.includes(U) && (z[U] = J), z), {});
    M(I);
    const L = Object.entries(I).reduce((z, [U, J]) => (z[U] = (J == null ? void 0 : J.length) || 0, z), {});
    c(L);
  }, [Re.id]);
  const a = ((b = be.variant_metafields[Re.id]) == null ? void 0 : b.metal) || "stainless", n = (T) => {
    const I = T.target.value, L = s.fields.length > 0, z = Ep(I, L);
    T.target.value = z, c((U) => ({
      ...U,
      [T.target.id]: z.length
    })), M((U) => ({
      ...U,
      [T.target.id]: z
    }));
  }, d = (T, I) => {
    const L = I.pattern;
    L && (new RegExp(L).test(T.data) ? l((U) => ({
      ...U,
      [I.id.key]: {
        show: !1,
        symbol: ""
      }
    })) : (T.preventDefault(), l((U) => ({
      ...U,
      [I.id.key]: {
        show: !0,
        symbol: T.data
      }
    }))));
  }, g = (S = ae.filter(
    (T) => {
      var I;
      return T.field_type === "custom" && ((I = T.class) == null ? void 0 : I.includes("so-flower-month"));
    }
  )[0]) == null ? void 0 : S.options, h = () => {
    const T = g == null ? void 0 : g.findIndex((I) => I === Re.option3);
    return T >= 0 ? "#f" + (T + 1 < 10 ? "0" + (T + 1) : T + 1) + "#" : !1;
  }, m = ae.filter(
    (T) => {
      var I;
      return T.field_type === "custom" && ((I = T.slug) == null ? void 0 : I.includes("font-family-preview"));
    }
  ), s = {
    fields: m,
    // TODO: Symbols might be not only at the end -> previewSymbolAtEnd?
    symbolAtEnd: ae.filter(
      (T) => {
        var I;
        return T.field_type === "custom" && ((I = T.class) == null ? void 0 : I.includes("symbol-at-the-end"));
      }
    ),
    flowerSymbol: h(),
    chains: be.additions.chains,
    isVertical: (A = (o = m[0]) == null ? void 0 : o.class) == null ? void 0 : A.includes("dangle"),
    inputFields: Z.slice(
      0,
      be.variant_metafields[Re.id].engravings || Z.length
    )
  };
  return /* @__PURE__ */ pt.jsxs(pt.Fragment, { children: [
    Z.slice(0, be.variant_metafields[Re.id].engravings || Z.length).map((T) => {
      var I, L;
      return /* @__PURE__ */ pt.jsxs(
        "div",
        {
          className: `so-field-wrapper ${y && x.inputs.includes(T.id.key) ? "error" : ""}`,
          children: [
            /* @__PURE__ */ pt.jsx("label", { className: "so-form__label", children: T.name }),
            /* @__PURE__ */ pt.jsx("div", { className: "so-field", children: /* @__PURE__ */ pt.jsxs("div", { className: "so-input-counter-w", children: [
              /* @__PURE__ */ pt.jsx(
                wp,
                {
                  product_cf: T,
                  formId: k,
                  required: T.required,
                  onChange: (z) => n(z),
                  onBeforeInput: (z) => d(z, T)
                }
              ),
              ((I = u[T.id.key]) == null ? void 0 : I.show) && /* @__PURE__ */ pt.jsxs("span", { className: "so-wrong-input-notification", children: [
                'Invalid character: "',
                u[T.id.key].symbol,
                '"'
              ] }),
              !((L = u[T.id.key]) != null && L.show) && /* @__PURE__ */ pt.jsxs(
                "span",
                {
                  className: `so-counter ${E[T.id.key] ? "so-input-filled" : ""}`,
                  children: [
                    E[T.id.key] || 0,
                    "/",
                    T.maxlength || 20
                  ]
                }
              )
            ] }) })
          ]
        },
        `input-field-${T.id.key}`
      );
    }),
    s.fields.length > 0 && /* @__PURE__ */ pt.jsx(
      Sp,
      {
        previewConfig: s,
        inputs: _,
        product_cf: Z[0],
        metalType: a
      }
    )
  ] });
};
/*!
 * Cropper.js v1.6.2
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2024-04-21T07:43:05.335Z
 */
function cc(Re, be) {
  var ae = Object.keys(Re);
  if (Object.getOwnPropertySymbols) {
    var k = Object.getOwnPropertySymbols(Re);
    be && (k = k.filter(function(Z) {
      return Object.getOwnPropertyDescriptor(Re, Z).enumerable;
    })), ae.push.apply(ae, k);
  }
  return ae;
}
function Zc(Re) {
  for (var be = 1; be < arguments.length; be++) {
    var ae = arguments[be] != null ? arguments[be] : {};
    be % 2 ? cc(Object(ae), !0).forEach(function(k) {
      Tp(Re, k, ae[k]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Re, Object.getOwnPropertyDescriptors(ae)) : cc(Object(ae)).forEach(function(k) {
      Object.defineProperty(Re, k, Object.getOwnPropertyDescriptor(ae, k));
    });
  }
  return Re;
}
function Cp(Re, be) {
  if (typeof Re != "object" || !Re) return Re;
  var ae = Re[Symbol.toPrimitive];
  if (ae !== void 0) {
    var k = ae.call(Re, be);
    if (typeof k != "object") return k;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(Re);
}
function Yc(Re) {
  var be = Cp(Re, "string");
  return typeof be == "symbol" ? be : be + "";
}
function Wl(Re) {
  "@babel/helpers - typeof";
  return Wl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(be) {
    return typeof be;
  } : function(be) {
    return be && typeof Symbol == "function" && be.constructor === Symbol && be !== Symbol.prototype ? "symbol" : typeof be;
  }, Wl(Re);
}
function kp(Re, be) {
  if (!(Re instanceof be))
    throw new TypeError("Cannot call a class as a function");
}
function dc(Re, be) {
  for (var ae = 0; ae < be.length; ae++) {
    var k = be[ae];
    k.enumerable = k.enumerable || !1, k.configurable = !0, "value" in k && (k.writable = !0), Object.defineProperty(Re, Yc(k.key), k);
  }
}
function Ap(Re, be, ae) {
  return be && dc(Re.prototype, be), ae && dc(Re, ae), Object.defineProperty(Re, "prototype", {
    writable: !1
  }), Re;
}
function Tp(Re, be, ae) {
  return be = Yc(be), be in Re ? Object.defineProperty(Re, be, {
    value: ae,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : Re[be] = ae, Re;
}
function Xc(Re) {
  return Mp(Re) || Pp(Re) || Ip(Re) || Rp();
}
function Mp(Re) {
  if (Array.isArray(Re)) return Zl(Re);
}
function Pp(Re) {
  if (typeof Symbol < "u" && Re[Symbol.iterator] != null || Re["@@iterator"] != null) return Array.from(Re);
}
function Ip(Re, be) {
  if (Re) {
    if (typeof Re == "string") return Zl(Re, be);
    var ae = Object.prototype.toString.call(Re).slice(8, -1);
    if (ae === "Object" && Re.constructor && (ae = Re.constructor.name), ae === "Map" || ae === "Set") return Array.from(Re);
    if (ae === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ae)) return Zl(Re, be);
  }
}
function Zl(Re, be) {
  (be == null || be > Re.length) && (be = Re.length);
  for (var ae = 0, k = new Array(be); ae < be; ae++) k[ae] = Re[ae];
  return k;
}
function Rp() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var Xo = typeof window < "u" && typeof window.document < "u", on = Xo ? window : {}, sf = Xo && on.document.documentElement ? "ontouchstart" in on.document.documentElement : !1, of = Xo ? "PointerEvent" in on : !1, gr = "cropper", uf = "all", qc = "crop", Qc = "move", Kc = "zoom", va = "e", ma = "w", Wa = "s", Gn = "n", xs = "ne", Cs = "nw", ks = "se", As = "sw", Yl = "".concat(gr, "-crop"), pc = "".concat(gr, "-disabled"), mi = "".concat(gr, "-hidden"), vc = "".concat(gr, "-hide"), Op = "".concat(gr, "-invisible"), Wo = "".concat(gr, "-modal"), Xl = "".concat(gr, "-move"), Rs = "".concat(gr, "Action"), Uo = "".concat(gr, "Preview"), lf = "crop", $c = "move", Jc = "none", ql = "crop", Ql = "cropend", Kl = "cropmove", $l = "cropstart", mc = "dblclick", Lp = sf ? "touchstart" : "mousedown", Np = sf ? "touchmove" : "mousemove", Dp = sf ? "touchend touchcancel" : "mouseup", gc = of ? "pointerdown" : Lp, _c = of ? "pointermove" : Np, yc = of ? "pointerup pointercancel" : Dp, wc = "ready", bc = "resize", Sc = "wheel", Jl = "zoom", Ec = "image/jpeg", Bp = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/, zp = /^data:/, Fp = /^data:image\/jpeg;base64,/, Up = /^img|canvas$/i, ed = 200, td = 100, xc = {
  // Define the view mode of the cropper
  viewMode: 0,
  // 0, 1, 2, 3
  // Define the dragging mode of the cropper
  dragMode: lf,
  // 'crop', 'move' or 'none'
  // Define the initial aspect ratio of the crop box
  initialAspectRatio: NaN,
  // Define the aspect ratio of the crop box
  aspectRatio: NaN,
  // An object with the previous cropping result data
  data: null,
  // A selector for adding extra containers to preview
  preview: "",
  // Re-render the cropper when resize the window
  responsive: !0,
  // Restore the cropped area after resize the window
  restore: !0,
  // Check if the current image is a cross-origin image
  checkCrossOrigin: !0,
  // Check the current image's Exif Orientation information
  checkOrientation: !0,
  // Show the black modal
  modal: !0,
  // Show the dashed lines for guiding
  guides: !0,
  // Show the center indicator for guiding
  center: !0,
  // Show the white modal to highlight the crop box
  highlight: !0,
  // Show the grid background
  background: !0,
  // Enable to crop the image automatically when initialize
  autoCrop: !0,
  // Define the percentage of automatic cropping area when initializes
  autoCropArea: 0.8,
  // Enable to move the image
  movable: !0,
  // Enable to rotate the image
  rotatable: !0,
  // Enable to scale the image
  scalable: !0,
  // Enable to zoom the image
  zoomable: !0,
  // Enable to zoom the image by dragging touch
  zoomOnTouch: !0,
  // Enable to zoom the image by wheeling mouse
  zoomOnWheel: !0,
  // Define zoom ratio when zoom the image by wheeling mouse
  wheelZoomRatio: 0.1,
  // Enable to move the crop box
  cropBoxMovable: !0,
  // Enable to resize the crop box
  cropBoxResizable: !0,
  // Toggle drag mode between "crop" and "move" when click twice on the cropper
  toggleDragModeOnDblclick: !0,
  // Size limitation
  minCanvasWidth: 0,
  minCanvasHeight: 0,
  minCropBoxWidth: 0,
  minCropBoxHeight: 0,
  minContainerWidth: ed,
  minContainerHeight: td,
  // Shortcuts of events
  ready: null,
  cropstart: null,
  cropmove: null,
  cropend: null,
  crop: null,
  zoom: null
}, jp = '<div class="cropper-container" touch-action="none"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-cropper-action="e"></span><span class="cropper-line line-n" data-cropper-action="n"></span><span class="cropper-line line-w" data-cropper-action="w"></span><span class="cropper-line line-s" data-cropper-action="s"></span><span class="cropper-point point-e" data-cropper-action="e"></span><span class="cropper-point point-n" data-cropper-action="n"></span><span class="cropper-point point-w" data-cropper-action="w"></span><span class="cropper-point point-s" data-cropper-action="s"></span><span class="cropper-point point-ne" data-cropper-action="ne"></span><span class="cropper-point point-nw" data-cropper-action="nw"></span><span class="cropper-point point-sw" data-cropper-action="sw"></span><span class="cropper-point point-se" data-cropper-action="se"></span></div></div>', Hp = Number.isNaN || on.isNaN;
function Jt(Re) {
  return typeof Re == "number" && !Hp(Re);
}
var Cc = function(be) {
  return be > 0 && be < 1 / 0;
};
function Ml(Re) {
  return typeof Re > "u";
}
function _a(Re) {
  return Wl(Re) === "object" && Re !== null;
}
var Gp = Object.prototype.hasOwnProperty;
function Za(Re) {
  if (!_a(Re))
    return !1;
  try {
    var be = Re.constructor, ae = be.prototype;
    return be && ae && Gp.call(ae, "isPrototypeOf");
  } catch {
    return !1;
  }
}
function vi(Re) {
  return typeof Re == "function";
}
var Vp = Array.prototype.slice;
function rd(Re) {
  return Array.from ? Array.from(Re) : Vp.call(Re);
}
function Rr(Re, be) {
  return Re && vi(be) && (Array.isArray(Re) || Jt(Re.length) ? rd(Re).forEach(function(ae, k) {
    be.call(Re, ae, k, Re);
  }) : _a(Re) && Object.keys(Re).forEach(function(ae) {
    be.call(Re, Re[ae], ae, Re);
  })), Re;
}
var _r = Object.assign || function(be) {
  for (var ae = arguments.length, k = new Array(ae > 1 ? ae - 1 : 0), Z = 1; Z < ae; Z++)
    k[Z - 1] = arguments[Z];
  return _a(be) && k.length > 0 && k.forEach(function(_) {
    _a(_) && Object.keys(_).forEach(function(M) {
      be[M] = _[M];
    });
  }), be;
}, Wp = /\.\d*(?:0|9){12}\d*$/;
function Xa(Re) {
  var be = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11;
  return Wp.test(Re) ? Math.round(Re * be) / be : Re;
}
var Zp = /^width|height|left|top|marginLeft|marginTop$/;
function Wn(Re, be) {
  var ae = Re.style;
  Rr(be, function(k, Z) {
    Zp.test(Z) && Jt(k) && (k = "".concat(k, "px")), ae[Z] = k;
  });
}
function Yp(Re, be) {
  return Re.classList ? Re.classList.contains(be) : Re.className.indexOf(be) > -1;
}
function Wr(Re, be) {
  if (be) {
    if (Jt(Re.length)) {
      Rr(Re, function(k) {
        Wr(k, be);
      });
      return;
    }
    if (Re.classList) {
      Re.classList.add(be);
      return;
    }
    var ae = Re.className.trim();
    ae ? ae.indexOf(be) < 0 && (Re.className = "".concat(ae, " ").concat(be)) : Re.className = be;
  }
}
function sn(Re, be) {
  if (be) {
    if (Jt(Re.length)) {
      Rr(Re, function(ae) {
        sn(ae, be);
      });
      return;
    }
    if (Re.classList) {
      Re.classList.remove(be);
      return;
    }
    Re.className.indexOf(be) >= 0 && (Re.className = Re.className.replace(be, ""));
  }
}
function Ya(Re, be, ae) {
  if (be) {
    if (Jt(Re.length)) {
      Rr(Re, function(k) {
        Ya(k, be, ae);
      });
      return;
    }
    ae ? Wr(Re, be) : sn(Re, be);
  }
}
var Xp = /([a-z\d])([A-Z])/g;
function ff(Re) {
  return Re.replace(Xp, "$1-$2").toLowerCase();
}
function ef(Re, be) {
  return _a(Re[be]) ? Re[be] : Re.dataset ? Re.dataset[be] : Re.getAttribute("data-".concat(ff(be)));
}
function Os(Re, be, ae) {
  _a(ae) ? Re[be] = ae : Re.dataset ? Re.dataset[be] = ae : Re.setAttribute("data-".concat(ff(be)), ae);
}
function qp(Re, be) {
  if (_a(Re[be]))
    try {
      delete Re[be];
    } catch {
      Re[be] = void 0;
    }
  else if (Re.dataset)
    try {
      delete Re.dataset[be];
    } catch {
      Re.dataset[be] = void 0;
    }
  else
    Re.removeAttribute("data-".concat(ff(be)));
}
var id = /\s\s*/, nd = function() {
  var Re = !1;
  if (Xo) {
    var be = !1, ae = function() {
    }, k = Object.defineProperty({}, "once", {
      get: function() {
        return Re = !0, be;
      },
      /**
       * This setter can fix a `TypeError` in strict mode
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
       * @param {boolean} value - The value to set
       */
      set: function(_) {
        be = _;
      }
    });
    on.addEventListener("test", ae, k), on.removeEventListener("test", ae, k);
  }
  return Re;
}();
function Zi(Re, be, ae) {
  var k = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, Z = ae;
  be.trim().split(id).forEach(function(_) {
    if (!nd) {
      var M = Re.listeners;
      M && M[_] && M[_][ae] && (Z = M[_][ae], delete M[_][ae], Object.keys(M[_]).length === 0 && delete M[_], Object.keys(M).length === 0 && delete Re.listeners);
    }
    Re.removeEventListener(_, Z, k);
  });
}
function Ni(Re, be, ae) {
  var k = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, Z = ae;
  be.trim().split(id).forEach(function(_) {
    if (k.once && !nd) {
      var M = Re.listeners, x = M === void 0 ? {} : M;
      Z = function() {
        delete x[_][ae], Re.removeEventListener(_, Z, k);
        for (var E = arguments.length, c = new Array(E), u = 0; u < E; u++)
          c[u] = arguments[u];
        ae.apply(Re, c);
      }, x[_] || (x[_] = {}), x[_][ae] && Re.removeEventListener(_, x[_][ae], k), x[_][ae] = Z, Re.listeners = x;
    }
    Re.addEventListener(_, Z, k);
  });
}
function qa(Re, be, ae) {
  var k;
  return vi(Event) && vi(CustomEvent) ? k = new CustomEvent(be, {
    detail: ae,
    bubbles: !0,
    cancelable: !0
  }) : (k = document.createEvent("CustomEvent"), k.initCustomEvent(be, !0, !0, ae)), Re.dispatchEvent(k);
}
function ad(Re) {
  var be = Re.getBoundingClientRect();
  return {
    left: be.left + (window.pageXOffset - document.documentElement.clientLeft),
    top: be.top + (window.pageYOffset - document.documentElement.clientTop)
  };
}
var Pl = on.location, Qp = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
function kc(Re) {
  var be = Re.match(Qp);
  return be !== null && (be[1] !== Pl.protocol || be[2] !== Pl.hostname || be[3] !== Pl.port);
}
function Ac(Re) {
  var be = "timestamp=".concat((/* @__PURE__ */ new Date()).getTime());
  return Re + (Re.indexOf("?") === -1 ? "?" : "&") + be;
}
function Is(Re) {
  var be = Re.rotate, ae = Re.scaleX, k = Re.scaleY, Z = Re.translateX, _ = Re.translateY, M = [];
  Jt(Z) && Z !== 0 && M.push("translateX(".concat(Z, "px)")), Jt(_) && _ !== 0 && M.push("translateY(".concat(_, "px)")), Jt(be) && be !== 0 && M.push("rotate(".concat(be, "deg)")), Jt(ae) && ae !== 1 && M.push("scaleX(".concat(ae, ")")), Jt(k) && k !== 1 && M.push("scaleY(".concat(k, ")"));
  var x = M.length ? M.join(" ") : "none";
  return {
    WebkitTransform: x,
    msTransform: x,
    transform: x
  };
}
function Kp(Re) {
  var be = Zc({}, Re), ae = 0;
  return Rr(Re, function(k, Z) {
    delete be[Z], Rr(be, function(_) {
      var M = Math.abs(k.startX - _.startX), x = Math.abs(k.startY - _.startY), y = Math.abs(k.endX - _.endX), E = Math.abs(k.endY - _.endY), c = Math.sqrt(M * M + x * x), u = Math.sqrt(y * y + E * E), l = (u - c) / c;
      Math.abs(l) > Math.abs(ae) && (ae = l);
    });
  }), ae;
}
function jo(Re, be) {
  var ae = Re.pageX, k = Re.pageY, Z = {
    endX: ae,
    endY: k
  };
  return be ? Z : Zc({
    startX: ae,
    startY: k
  }, Z);
}
function $p(Re) {
  var be = 0, ae = 0, k = 0;
  return Rr(Re, function(Z) {
    var _ = Z.startX, M = Z.startY;
    be += _, ae += M, k += 1;
  }), be /= k, ae /= k, {
    pageX: be,
    pageY: ae
  };
}
function Zn(Re) {
  var be = Re.aspectRatio, ae = Re.height, k = Re.width, Z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "contain", _ = Cc(k), M = Cc(ae);
  if (_ && M) {
    var x = ae * be;
    Z === "contain" && x > k || Z === "cover" && x < k ? ae = k / be : k = ae * be;
  } else _ ? ae = k / be : M && (k = ae * be);
  return {
    width: k,
    height: ae
  };
}
function Jp(Re) {
  var be = Re.width, ae = Re.height, k = Re.degree;
  if (k = Math.abs(k) % 180, k === 90)
    return {
      width: ae,
      height: be
    };
  var Z = k % 90 * Math.PI / 180, _ = Math.sin(Z), M = Math.cos(Z), x = be * M + ae * _, y = be * _ + ae * M;
  return k > 90 ? {
    width: y,
    height: x
  } : {
    width: x,
    height: y
  };
}
function e0(Re, be, ae, k) {
  var Z = be.aspectRatio, _ = be.naturalWidth, M = be.naturalHeight, x = be.rotate, y = x === void 0 ? 0 : x, E = be.scaleX, c = E === void 0 ? 1 : E, u = be.scaleY, l = u === void 0 ? 1 : u, a = ae.aspectRatio, n = ae.naturalWidth, d = ae.naturalHeight, g = k.fillColor, h = g === void 0 ? "transparent" : g, m = k.imageSmoothingEnabled, s = m === void 0 ? !0 : m, b = k.imageSmoothingQuality, S = b === void 0 ? "low" : b, o = k.maxWidth, A = o === void 0 ? 1 / 0 : o, T = k.maxHeight, I = T === void 0 ? 1 / 0 : T, L = k.minWidth, z = L === void 0 ? 0 : L, U = k.minHeight, J = U === void 0 ? 0 : U, F = document.createElement("canvas"), oe = F.getContext("2d"), ee = Zn({
    aspectRatio: a,
    width: A,
    height: I
  }), ie = Zn({
    aspectRatio: a,
    width: z,
    height: J
  }, "cover"), W = Math.min(ee.width, Math.max(ie.width, n)), Q = Math.min(ee.height, Math.max(ie.height, d)), de = Zn({
    aspectRatio: Z,
    width: A,
    height: I
  }), we = Zn({
    aspectRatio: Z,
    width: z,
    height: J
  }, "cover"), ke = Math.min(de.width, Math.max(we.width, _)), Me = Math.min(de.height, Math.max(we.height, M)), fe = [-ke / 2, -Me / 2, ke, Me];
  return F.width = Xa(W), F.height = Xa(Q), oe.fillStyle = h, oe.fillRect(0, 0, W, Q), oe.save(), oe.translate(W / 2, Q / 2), oe.rotate(y * Math.PI / 180), oe.scale(c, l), oe.imageSmoothingEnabled = s, oe.imageSmoothingQuality = S, oe.drawImage.apply(oe, [Re].concat(Xc(fe.map(function(xe) {
    return Math.floor(Xa(xe));
  })))), oe.restore(), F;
}
var sd = String.fromCharCode;
function t0(Re, be, ae) {
  var k = "";
  ae += be;
  for (var Z = be; Z < ae; Z += 1)
    k += sd(Re.getUint8(Z));
  return k;
}
var r0 = /^data:.*,/;
function i0(Re) {
  var be = Re.replace(r0, ""), ae = atob(be), k = new ArrayBuffer(ae.length), Z = new Uint8Array(k);
  return Rr(Z, function(_, M) {
    Z[M] = ae.charCodeAt(M);
  }), k;
}
function n0(Re, be) {
  for (var ae = [], k = 8192, Z = new Uint8Array(Re); Z.length > 0; )
    ae.push(sd.apply(null, rd(Z.subarray(0, k)))), Z = Z.subarray(k);
  return "data:".concat(be, ";base64,").concat(btoa(ae.join("")));
}
function a0(Re) {
  var be = new DataView(Re), ae;
  try {
    var k, Z, _;
    if (be.getUint8(0) === 255 && be.getUint8(1) === 216)
      for (var M = be.byteLength, x = 2; x + 1 < M; ) {
        if (be.getUint8(x) === 255 && be.getUint8(x + 1) === 225) {
          Z = x;
          break;
        }
        x += 1;
      }
    if (Z) {
      var y = Z + 4, E = Z + 10;
      if (t0(be, y, 4) === "Exif") {
        var c = be.getUint16(E);
        if (k = c === 18761, (k || c === 19789) && be.getUint16(E + 2, k) === 42) {
          var u = be.getUint32(E + 4, k);
          u >= 8 && (_ = E + u);
        }
      }
    }
    if (_) {
      var l = be.getUint16(_, k), a, n;
      for (n = 0; n < l; n += 1)
        if (a = _ + n * 12 + 2, be.getUint16(a, k) === 274) {
          a += 8, ae = be.getUint16(a, k), be.setUint16(a, 1, k);
          break;
        }
    }
  } catch {
    ae = 1;
  }
  return ae;
}
function s0(Re) {
  var be = 0, ae = 1, k = 1;
  switch (Re) {
    // Flip horizontal
    case 2:
      ae = -1;
      break;
    // Rotate left 180°
    case 3:
      be = -180;
      break;
    // Flip vertical
    case 4:
      k = -1;
      break;
    // Flip vertical and rotate right 90°
    case 5:
      be = 90, k = -1;
      break;
    // Rotate right 90°
    case 6:
      be = 90;
      break;
    // Flip horizontal and rotate right 90°
    case 7:
      be = 90, ae = -1;
      break;
    // Rotate left 90°
    case 8:
      be = -90;
      break;
  }
  return {
    rotate: be,
    scaleX: ae,
    scaleY: k
  };
}
var o0 = {
  render: function() {
    this.initContainer(), this.initCanvas(), this.initCropBox(), this.renderCanvas(), this.cropped && this.renderCropBox();
  },
  initContainer: function() {
    var be = this.element, ae = this.options, k = this.container, Z = this.cropper, _ = Number(ae.minContainerWidth), M = Number(ae.minContainerHeight);
    Wr(Z, mi), sn(be, mi);
    var x = {
      width: Math.max(k.offsetWidth, _ >= 0 ? _ : ed),
      height: Math.max(k.offsetHeight, M >= 0 ? M : td)
    };
    this.containerData = x, Wn(Z, {
      width: x.width,
      height: x.height
    }), Wr(be, mi), sn(Z, mi);
  },
  // Canvas (image wrapper)
  initCanvas: function() {
    var be = this.containerData, ae = this.imageData, k = this.options.viewMode, Z = Math.abs(ae.rotate) % 180 === 90, _ = Z ? ae.naturalHeight : ae.naturalWidth, M = Z ? ae.naturalWidth : ae.naturalHeight, x = _ / M, y = be.width, E = be.height;
    be.height * x > be.width ? k === 3 ? y = be.height * x : E = be.width / x : k === 3 ? E = be.width / x : y = be.height * x;
    var c = {
      aspectRatio: x,
      naturalWidth: _,
      naturalHeight: M,
      width: y,
      height: E
    };
    this.canvasData = c, this.limited = k === 1 || k === 2, this.limitCanvas(!0, !0), c.width = Math.min(Math.max(c.width, c.minWidth), c.maxWidth), c.height = Math.min(Math.max(c.height, c.minHeight), c.maxHeight), c.left = (be.width - c.width) / 2, c.top = (be.height - c.height) / 2, c.oldLeft = c.left, c.oldTop = c.top, this.initialCanvasData = _r({}, c);
  },
  limitCanvas: function(be, ae) {
    var k = this.options, Z = this.containerData, _ = this.canvasData, M = this.cropBoxData, x = k.viewMode, y = _.aspectRatio, E = this.cropped && M;
    if (be) {
      var c = Number(k.minCanvasWidth) || 0, u = Number(k.minCanvasHeight) || 0;
      x > 1 ? (c = Math.max(c, Z.width), u = Math.max(u, Z.height), x === 3 && (u * y > c ? c = u * y : u = c / y)) : x > 0 && (c ? c = Math.max(c, E ? M.width : 0) : u ? u = Math.max(u, E ? M.height : 0) : E && (c = M.width, u = M.height, u * y > c ? c = u * y : u = c / y));
      var l = Zn({
        aspectRatio: y,
        width: c,
        height: u
      });
      c = l.width, u = l.height, _.minWidth = c, _.minHeight = u, _.maxWidth = 1 / 0, _.maxHeight = 1 / 0;
    }
    if (ae)
      if (x > (E ? 0 : 1)) {
        var a = Z.width - _.width, n = Z.height - _.height;
        _.minLeft = Math.min(0, a), _.minTop = Math.min(0, n), _.maxLeft = Math.max(0, a), _.maxTop = Math.max(0, n), E && this.limited && (_.minLeft = Math.min(M.left, M.left + (M.width - _.width)), _.minTop = Math.min(M.top, M.top + (M.height - _.height)), _.maxLeft = M.left, _.maxTop = M.top, x === 2 && (_.width >= Z.width && (_.minLeft = Math.min(0, a), _.maxLeft = Math.max(0, a)), _.height >= Z.height && (_.minTop = Math.min(0, n), _.maxTop = Math.max(0, n))));
      } else
        _.minLeft = -_.width, _.minTop = -_.height, _.maxLeft = Z.width, _.maxTop = Z.height;
  },
  renderCanvas: function(be, ae) {
    var k = this.canvasData, Z = this.imageData;
    if (ae) {
      var _ = Jp({
        width: Z.naturalWidth * Math.abs(Z.scaleX || 1),
        height: Z.naturalHeight * Math.abs(Z.scaleY || 1),
        degree: Z.rotate || 0
      }), M = _.width, x = _.height, y = k.width * (M / k.naturalWidth), E = k.height * (x / k.naturalHeight);
      k.left -= (y - k.width) / 2, k.top -= (E - k.height) / 2, k.width = y, k.height = E, k.aspectRatio = M / x, k.naturalWidth = M, k.naturalHeight = x, this.limitCanvas(!0, !1);
    }
    (k.width > k.maxWidth || k.width < k.minWidth) && (k.left = k.oldLeft), (k.height > k.maxHeight || k.height < k.minHeight) && (k.top = k.oldTop), k.width = Math.min(Math.max(k.width, k.minWidth), k.maxWidth), k.height = Math.min(Math.max(k.height, k.minHeight), k.maxHeight), this.limitCanvas(!1, !0), k.left = Math.min(Math.max(k.left, k.minLeft), k.maxLeft), k.top = Math.min(Math.max(k.top, k.minTop), k.maxTop), k.oldLeft = k.left, k.oldTop = k.top, Wn(this.canvas, _r({
      width: k.width,
      height: k.height
    }, Is({
      translateX: k.left,
      translateY: k.top
    }))), this.renderImage(be), this.cropped && this.limited && this.limitCropBox(!0, !0);
  },
  renderImage: function(be) {
    var ae = this.canvasData, k = this.imageData, Z = k.naturalWidth * (ae.width / ae.naturalWidth), _ = k.naturalHeight * (ae.height / ae.naturalHeight);
    _r(k, {
      width: Z,
      height: _,
      left: (ae.width - Z) / 2,
      top: (ae.height - _) / 2
    }), Wn(this.image, _r({
      width: k.width,
      height: k.height
    }, Is(_r({
      translateX: k.left,
      translateY: k.top
    }, k)))), be && this.output();
  },
  initCropBox: function() {
    var be = this.options, ae = this.canvasData, k = be.aspectRatio || be.initialAspectRatio, Z = Number(be.autoCropArea) || 0.8, _ = {
      width: ae.width,
      height: ae.height
    };
    k && (ae.height * k > ae.width ? _.height = _.width / k : _.width = _.height * k), this.cropBoxData = _, this.limitCropBox(!0, !0), _.width = Math.min(Math.max(_.width, _.minWidth), _.maxWidth), _.height = Math.min(Math.max(_.height, _.minHeight), _.maxHeight), _.width = Math.max(_.minWidth, _.width * Z), _.height = Math.max(_.minHeight, _.height * Z), _.left = ae.left + (ae.width - _.width) / 2, _.top = ae.top + (ae.height - _.height) / 2, _.oldLeft = _.left, _.oldTop = _.top, this.initialCropBoxData = _r({}, _);
  },
  limitCropBox: function(be, ae) {
    var k = this.options, Z = this.containerData, _ = this.canvasData, M = this.cropBoxData, x = this.limited, y = k.aspectRatio;
    if (be) {
      var E = Number(k.minCropBoxWidth) || 0, c = Number(k.minCropBoxHeight) || 0, u = x ? Math.min(Z.width, _.width, _.width + _.left, Z.width - _.left) : Z.width, l = x ? Math.min(Z.height, _.height, _.height + _.top, Z.height - _.top) : Z.height;
      E = Math.min(E, Z.width), c = Math.min(c, Z.height), y && (E && c ? c * y > E ? c = E / y : E = c * y : E ? c = E / y : c && (E = c * y), l * y > u ? l = u / y : u = l * y), M.minWidth = Math.min(E, u), M.minHeight = Math.min(c, l), M.maxWidth = u, M.maxHeight = l;
    }
    ae && (x ? (M.minLeft = Math.max(0, _.left), M.minTop = Math.max(0, _.top), M.maxLeft = Math.min(Z.width, _.left + _.width) - M.width, M.maxTop = Math.min(Z.height, _.top + _.height) - M.height) : (M.minLeft = 0, M.minTop = 0, M.maxLeft = Z.width - M.width, M.maxTop = Z.height - M.height));
  },
  renderCropBox: function() {
    var be = this.options, ae = this.containerData, k = this.cropBoxData;
    (k.width > k.maxWidth || k.width < k.minWidth) && (k.left = k.oldLeft), (k.height > k.maxHeight || k.height < k.minHeight) && (k.top = k.oldTop), k.width = Math.min(Math.max(k.width, k.minWidth), k.maxWidth), k.height = Math.min(Math.max(k.height, k.minHeight), k.maxHeight), this.limitCropBox(!1, !0), k.left = Math.min(Math.max(k.left, k.minLeft), k.maxLeft), k.top = Math.min(Math.max(k.top, k.minTop), k.maxTop), k.oldLeft = k.left, k.oldTop = k.top, be.movable && be.cropBoxMovable && Os(this.face, Rs, k.width >= ae.width && k.height >= ae.height ? Qc : uf), Wn(this.cropBox, _r({
      width: k.width,
      height: k.height
    }, Is({
      translateX: k.left,
      translateY: k.top
    }))), this.cropped && this.limited && this.limitCanvas(!0, !0), this.disabled || this.output();
  },
  output: function() {
    this.preview(), qa(this.element, ql, this.getData());
  }
}, u0 = {
  initPreview: function() {
    var be = this.element, ae = this.crossOrigin, k = this.options.preview, Z = ae ? this.crossOriginUrl : this.url, _ = be.alt || "The image to preview", M = document.createElement("img");
    if (ae && (M.crossOrigin = ae), M.src = Z, M.alt = _, this.viewBox.appendChild(M), this.viewBoxImage = M, !!k) {
      var x = k;
      typeof k == "string" ? x = be.ownerDocument.querySelectorAll(k) : k.querySelector && (x = [k]), this.previews = x, Rr(x, function(y) {
        var E = document.createElement("img");
        Os(y, Uo, {
          width: y.offsetWidth,
          height: y.offsetHeight,
          html: y.innerHTML
        }), ae && (E.crossOrigin = ae), E.src = Z, E.alt = _, E.style.cssText = 'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"', y.innerHTML = "", y.appendChild(E);
      });
    }
  },
  resetPreview: function() {
    Rr(this.previews, function(be) {
      var ae = ef(be, Uo);
      Wn(be, {
        width: ae.width,
        height: ae.height
      }), be.innerHTML = ae.html, qp(be, Uo);
    });
  },
  preview: function() {
    var be = this.imageData, ae = this.canvasData, k = this.cropBoxData, Z = k.width, _ = k.height, M = be.width, x = be.height, y = k.left - ae.left - be.left, E = k.top - ae.top - be.top;
    !this.cropped || this.disabled || (Wn(this.viewBoxImage, _r({
      width: M,
      height: x
    }, Is(_r({
      translateX: -y,
      translateY: -E
    }, be)))), Rr(this.previews, function(c) {
      var u = ef(c, Uo), l = u.width, a = u.height, n = l, d = a, g = 1;
      Z && (g = l / Z, d = _ * g), _ && d > a && (g = a / _, n = Z * g, d = a), Wn(c, {
        width: n,
        height: d
      }), Wn(c.getElementsByTagName("img")[0], _r({
        width: M * g,
        height: x * g
      }, Is(_r({
        translateX: -y * g,
        translateY: -E * g
      }, be))));
    }));
  }
}, l0 = {
  bind: function() {
    var be = this.element, ae = this.options, k = this.cropper;
    vi(ae.cropstart) && Ni(be, $l, ae.cropstart), vi(ae.cropmove) && Ni(be, Kl, ae.cropmove), vi(ae.cropend) && Ni(be, Ql, ae.cropend), vi(ae.crop) && Ni(be, ql, ae.crop), vi(ae.zoom) && Ni(be, Jl, ae.zoom), Ni(k, gc, this.onCropStart = this.cropStart.bind(this)), ae.zoomable && ae.zoomOnWheel && Ni(k, Sc, this.onWheel = this.wheel.bind(this), {
      passive: !1,
      capture: !0
    }), ae.toggleDragModeOnDblclick && Ni(k, mc, this.onDblclick = this.dblclick.bind(this)), Ni(be.ownerDocument, _c, this.onCropMove = this.cropMove.bind(this)), Ni(be.ownerDocument, yc, this.onCropEnd = this.cropEnd.bind(this)), ae.responsive && Ni(window, bc, this.onResize = this.resize.bind(this));
  },
  unbind: function() {
    var be = this.element, ae = this.options, k = this.cropper;
    vi(ae.cropstart) && Zi(be, $l, ae.cropstart), vi(ae.cropmove) && Zi(be, Kl, ae.cropmove), vi(ae.cropend) && Zi(be, Ql, ae.cropend), vi(ae.crop) && Zi(be, ql, ae.crop), vi(ae.zoom) && Zi(be, Jl, ae.zoom), Zi(k, gc, this.onCropStart), ae.zoomable && ae.zoomOnWheel && Zi(k, Sc, this.onWheel, {
      passive: !1,
      capture: !0
    }), ae.toggleDragModeOnDblclick && Zi(k, mc, this.onDblclick), Zi(be.ownerDocument, _c, this.onCropMove), Zi(be.ownerDocument, yc, this.onCropEnd), ae.responsive && Zi(window, bc, this.onResize);
  }
}, f0 = {
  resize: function() {
    if (!this.disabled) {
      var be = this.options, ae = this.container, k = this.containerData, Z = ae.offsetWidth / k.width, _ = ae.offsetHeight / k.height, M = Math.abs(Z - 1) > Math.abs(_ - 1) ? Z : _;
      if (M !== 1) {
        var x, y;
        be.restore && (x = this.getCanvasData(), y = this.getCropBoxData()), this.render(), be.restore && (this.setCanvasData(Rr(x, function(E, c) {
          x[c] = E * M;
        })), this.setCropBoxData(Rr(y, function(E, c) {
          y[c] = E * M;
        })));
      }
    }
  },
  dblclick: function() {
    this.disabled || this.options.dragMode === Jc || this.setDragMode(Yp(this.dragBox, Yl) ? $c : lf);
  },
  wheel: function(be) {
    var ae = this, k = Number(this.options.wheelZoomRatio) || 0.1, Z = 1;
    this.disabled || (be.preventDefault(), !this.wheeling && (this.wheeling = !0, setTimeout(function() {
      ae.wheeling = !1;
    }, 50), be.deltaY ? Z = be.deltaY > 0 ? 1 : -1 : be.wheelDelta ? Z = -be.wheelDelta / 120 : be.detail && (Z = be.detail > 0 ? 1 : -1), this.zoom(-Z * k, be)));
  },
  cropStart: function(be) {
    var ae = be.buttons, k = be.button;
    if (!(this.disabled || (be.type === "mousedown" || be.type === "pointerdown" && be.pointerType === "mouse") && // No primary button (Usually the left button)
    (Jt(ae) && ae !== 1 || Jt(k) && k !== 0 || be.ctrlKey))) {
      var Z = this.options, _ = this.pointers, M;
      be.changedTouches ? Rr(be.changedTouches, function(x) {
        _[x.identifier] = jo(x);
      }) : _[be.pointerId || 0] = jo(be), Object.keys(_).length > 1 && Z.zoomable && Z.zoomOnTouch ? M = Kc : M = ef(be.target, Rs), Bp.test(M) && qa(this.element, $l, {
        originalEvent: be,
        action: M
      }) !== !1 && (be.preventDefault(), this.action = M, this.cropping = !1, M === qc && (this.cropping = !0, Wr(this.dragBox, Wo)));
    }
  },
  cropMove: function(be) {
    var ae = this.action;
    if (!(this.disabled || !ae)) {
      var k = this.pointers;
      be.preventDefault(), qa(this.element, Kl, {
        originalEvent: be,
        action: ae
      }) !== !1 && (be.changedTouches ? Rr(be.changedTouches, function(Z) {
        _r(k[Z.identifier] || {}, jo(Z, !0));
      }) : _r(k[be.pointerId || 0] || {}, jo(be, !0)), this.change(be));
    }
  },
  cropEnd: function(be) {
    if (!this.disabled) {
      var ae = this.action, k = this.pointers;
      be.changedTouches ? Rr(be.changedTouches, function(Z) {
        delete k[Z.identifier];
      }) : delete k[be.pointerId || 0], ae && (be.preventDefault(), Object.keys(k).length || (this.action = ""), this.cropping && (this.cropping = !1, Ya(this.dragBox, Wo, this.cropped && this.options.modal)), qa(this.element, Ql, {
        originalEvent: be,
        action: ae
      }));
    }
  }
}, h0 = {
  change: function(be) {
    var ae = this.options, k = this.canvasData, Z = this.containerData, _ = this.cropBoxData, M = this.pointers, x = this.action, y = ae.aspectRatio, E = _.left, c = _.top, u = _.width, l = _.height, a = E + u, n = c + l, d = 0, g = 0, h = Z.width, m = Z.height, s = !0, b;
    !y && be.shiftKey && (y = u && l ? u / l : 1), this.limited && (d = _.minLeft, g = _.minTop, h = d + Math.min(Z.width, k.width, k.left + k.width), m = g + Math.min(Z.height, k.height, k.top + k.height));
    var S = M[Object.keys(M)[0]], o = {
      x: S.endX - S.startX,
      y: S.endY - S.startY
    }, A = function(I) {
      switch (I) {
        case va:
          a + o.x > h && (o.x = h - a);
          break;
        case ma:
          E + o.x < d && (o.x = d - E);
          break;
        case Gn:
          c + o.y < g && (o.y = g - c);
          break;
        case Wa:
          n + o.y > m && (o.y = m - n);
          break;
      }
    };
    switch (x) {
      // Move crop box
      case uf:
        E += o.x, c += o.y;
        break;
      // Resize crop box
      case va:
        if (o.x >= 0 && (a >= h || y && (c <= g || n >= m))) {
          s = !1;
          break;
        }
        A(va), u += o.x, u < 0 && (x = ma, u = -u, E -= u), y && (l = u / y, c += (_.height - l) / 2);
        break;
      case Gn:
        if (o.y <= 0 && (c <= g || y && (E <= d || a >= h))) {
          s = !1;
          break;
        }
        A(Gn), l -= o.y, c += o.y, l < 0 && (x = Wa, l = -l, c -= l), y && (u = l * y, E += (_.width - u) / 2);
        break;
      case ma:
        if (o.x <= 0 && (E <= d || y && (c <= g || n >= m))) {
          s = !1;
          break;
        }
        A(ma), u -= o.x, E += o.x, u < 0 && (x = va, u = -u, E -= u), y && (l = u / y, c += (_.height - l) / 2);
        break;
      case Wa:
        if (o.y >= 0 && (n >= m || y && (E <= d || a >= h))) {
          s = !1;
          break;
        }
        A(Wa), l += o.y, l < 0 && (x = Gn, l = -l, c -= l), y && (u = l * y, E += (_.width - u) / 2);
        break;
      case xs:
        if (y) {
          if (o.y <= 0 && (c <= g || a >= h)) {
            s = !1;
            break;
          }
          A(Gn), l -= o.y, c += o.y, u = l * y;
        } else
          A(Gn), A(va), o.x >= 0 ? a < h ? u += o.x : o.y <= 0 && c <= g && (s = !1) : u += o.x, o.y <= 0 ? c > g && (l -= o.y, c += o.y) : (l -= o.y, c += o.y);
        u < 0 && l < 0 ? (x = As, l = -l, u = -u, c -= l, E -= u) : u < 0 ? (x = Cs, u = -u, E -= u) : l < 0 && (x = ks, l = -l, c -= l);
        break;
      case Cs:
        if (y) {
          if (o.y <= 0 && (c <= g || E <= d)) {
            s = !1;
            break;
          }
          A(Gn), l -= o.y, c += o.y, u = l * y, E += _.width - u;
        } else
          A(Gn), A(ma), o.x <= 0 ? E > d ? (u -= o.x, E += o.x) : o.y <= 0 && c <= g && (s = !1) : (u -= o.x, E += o.x), o.y <= 0 ? c > g && (l -= o.y, c += o.y) : (l -= o.y, c += o.y);
        u < 0 && l < 0 ? (x = ks, l = -l, u = -u, c -= l, E -= u) : u < 0 ? (x = xs, u = -u, E -= u) : l < 0 && (x = As, l = -l, c -= l);
        break;
      case As:
        if (y) {
          if (o.x <= 0 && (E <= d || n >= m)) {
            s = !1;
            break;
          }
          A(ma), u -= o.x, E += o.x, l = u / y;
        } else
          A(Wa), A(ma), o.x <= 0 ? E > d ? (u -= o.x, E += o.x) : o.y >= 0 && n >= m && (s = !1) : (u -= o.x, E += o.x), o.y >= 0 ? n < m && (l += o.y) : l += o.y;
        u < 0 && l < 0 ? (x = xs, l = -l, u = -u, c -= l, E -= u) : u < 0 ? (x = ks, u = -u, E -= u) : l < 0 && (x = Cs, l = -l, c -= l);
        break;
      case ks:
        if (y) {
          if (o.x >= 0 && (a >= h || n >= m)) {
            s = !1;
            break;
          }
          A(va), u += o.x, l = u / y;
        } else
          A(Wa), A(va), o.x >= 0 ? a < h ? u += o.x : o.y >= 0 && n >= m && (s = !1) : u += o.x, o.y >= 0 ? n < m && (l += o.y) : l += o.y;
        u < 0 && l < 0 ? (x = Cs, l = -l, u = -u, c -= l, E -= u) : u < 0 ? (x = As, u = -u, E -= u) : l < 0 && (x = xs, l = -l, c -= l);
        break;
      // Move canvas
      case Qc:
        this.move(o.x, o.y), s = !1;
        break;
      // Zoom canvas
      case Kc:
        this.zoom(Kp(M), be), s = !1;
        break;
      // Create crop box
      case qc:
        if (!o.x || !o.y) {
          s = !1;
          break;
        }
        b = ad(this.cropper), E = S.startX - b.left, c = S.startY - b.top, u = _.minWidth, l = _.minHeight, o.x > 0 ? x = o.y > 0 ? ks : xs : o.x < 0 && (E -= u, x = o.y > 0 ? As : Cs), o.y < 0 && (c -= l), this.cropped || (sn(this.cropBox, mi), this.cropped = !0, this.limited && this.limitCropBox(!0, !0));
        break;
    }
    s && (_.width = u, _.height = l, _.left = E, _.top = c, this.action = x, this.renderCropBox()), Rr(M, function(T) {
      T.startX = T.endX, T.startY = T.endY;
    });
  }
}, c0 = {
  // Show the crop box manually
  crop: function() {
    return this.ready && !this.cropped && !this.disabled && (this.cropped = !0, this.limitCropBox(!0, !0), this.options.modal && Wr(this.dragBox, Wo), sn(this.cropBox, mi), this.setCropBoxData(this.initialCropBoxData)), this;
  },
  // Reset the image and crop box to their initial states
  reset: function() {
    return this.ready && !this.disabled && (this.imageData = _r({}, this.initialImageData), this.canvasData = _r({}, this.initialCanvasData), this.cropBoxData = _r({}, this.initialCropBoxData), this.renderCanvas(), this.cropped && this.renderCropBox()), this;
  },
  // Clear the crop box
  clear: function() {
    return this.cropped && !this.disabled && (_r(this.cropBoxData, {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    }), this.cropped = !1, this.renderCropBox(), this.limitCanvas(!0, !0), this.renderCanvas(), sn(this.dragBox, Wo), Wr(this.cropBox, mi)), this;
  },
  /**
   * Replace the image's src and rebuild the cropper
   * @param {string} url - The new URL.
   * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
   * @returns {Cropper} this
   */
  replace: function(be) {
    var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return !this.disabled && be && (this.isImg && (this.element.src = be), ae ? (this.url = be, this.image.src = be, this.ready && (this.viewBoxImage.src = be, Rr(this.previews, function(k) {
      k.getElementsByTagName("img")[0].src = be;
    }))) : (this.isImg && (this.replaced = !0), this.options.data = null, this.uncreate(), this.load(be))), this;
  },
  // Enable (unfreeze) the cropper
  enable: function() {
    return this.ready && this.disabled && (this.disabled = !1, sn(this.cropper, pc)), this;
  },
  // Disable (freeze) the cropper
  disable: function() {
    return this.ready && !this.disabled && (this.disabled = !0, Wr(this.cropper, pc)), this;
  },
  /**
   * Destroy the cropper and remove the instance from the image
   * @returns {Cropper} this
   */
  destroy: function() {
    var be = this.element;
    return be[gr] ? (be[gr] = void 0, this.isImg && this.replaced && (be.src = this.originalUrl), this.uncreate(), this) : this;
  },
  /**
   * Move the canvas with relative offsets
   * @param {number} offsetX - The relative offset distance on the x-axis.
   * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
   * @returns {Cropper} this
   */
  move: function(be) {
    var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : be, k = this.canvasData, Z = k.left, _ = k.top;
    return this.moveTo(Ml(be) ? be : Z + Number(be), Ml(ae) ? ae : _ + Number(ae));
  },
  /**
   * Move the canvas to an absolute point
   * @param {number} x - The x-axis coordinate.
   * @param {number} [y=x] - The y-axis coordinate.
   * @returns {Cropper} this
   */
  moveTo: function(be) {
    var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : be, k = this.canvasData, Z = !1;
    return be = Number(be), ae = Number(ae), this.ready && !this.disabled && this.options.movable && (Jt(be) && (k.left = be, Z = !0), Jt(ae) && (k.top = ae, Z = !0), Z && this.renderCanvas(!0)), this;
  },
  /**
   * Zoom the canvas with a relative ratio
   * @param {number} ratio - The target ratio.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Cropper} this
   */
  zoom: function(be, ae) {
    var k = this.canvasData;
    return be = Number(be), be < 0 ? be = 1 / (1 - be) : be = 1 + be, this.zoomTo(k.width * be / k.naturalWidth, null, ae);
  },
  /**
   * Zoom the canvas to an absolute ratio
   * @param {number} ratio - The target ratio.
   * @param {Object} pivot - The zoom pivot point coordinate.
   * @param {Event} _originalEvent - The original event if any.
   * @returns {Cropper} this
   */
  zoomTo: function(be, ae, k) {
    var Z = this.options, _ = this.canvasData, M = _.width, x = _.height, y = _.naturalWidth, E = _.naturalHeight;
    if (be = Number(be), be >= 0 && this.ready && !this.disabled && Z.zoomable) {
      var c = y * be, u = E * be;
      if (qa(this.element, Jl, {
        ratio: be,
        oldRatio: M / y,
        originalEvent: k
      }) === !1)
        return this;
      if (k) {
        var l = this.pointers, a = ad(this.cropper), n = l && Object.keys(l).length ? $p(l) : {
          pageX: k.pageX,
          pageY: k.pageY
        };
        _.left -= (c - M) * ((n.pageX - a.left - _.left) / M), _.top -= (u - x) * ((n.pageY - a.top - _.top) / x);
      } else Za(ae) && Jt(ae.x) && Jt(ae.y) ? (_.left -= (c - M) * ((ae.x - _.left) / M), _.top -= (u - x) * ((ae.y - _.top) / x)) : (_.left -= (c - M) / 2, _.top -= (u - x) / 2);
      _.width = c, _.height = u, this.renderCanvas(!0);
    }
    return this;
  },
  /**
   * Rotate the canvas with a relative degree
   * @param {number} degree - The rotate degree.
   * @returns {Cropper} this
   */
  rotate: function(be) {
    return this.rotateTo((this.imageData.rotate || 0) + Number(be));
  },
  /**
   * Rotate the canvas to an absolute degree
   * @param {number} degree - The rotate degree.
   * @returns {Cropper} this
   */
  rotateTo: function(be) {
    return be = Number(be), Jt(be) && this.ready && !this.disabled && this.options.rotatable && (this.imageData.rotate = be % 360, this.renderCanvas(!0, !0)), this;
  },
  /**
   * Scale the image on the x-axis.
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @returns {Cropper} this
   */
  scaleX: function(be) {
    var ae = this.imageData.scaleY;
    return this.scale(be, Jt(ae) ? ae : 1);
  },
  /**
   * Scale the image on the y-axis.
   * @param {number} scaleY - The scale ratio on the y-axis.
   * @returns {Cropper} this
   */
  scaleY: function(be) {
    var ae = this.imageData.scaleX;
    return this.scale(Jt(ae) ? ae : 1, be);
  },
  /**
   * Scale the image
   * @param {number} scaleX - The scale ratio on the x-axis.
   * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
   * @returns {Cropper} this
   */
  scale: function(be) {
    var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : be, k = this.imageData, Z = !1;
    return be = Number(be), ae = Number(ae), this.ready && !this.disabled && this.options.scalable && (Jt(be) && (k.scaleX = be, Z = !0), Jt(ae) && (k.scaleY = ae, Z = !0), Z && this.renderCanvas(!0, !0)), this;
  },
  /**
   * Get the cropped area position and size data (base on the original image)
   * @param {boolean} [rounded=false] - Indicate if round the data values or not.
   * @returns {Object} The result cropped data.
   */
  getData: function() {
    var be = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, ae = this.options, k = this.imageData, Z = this.canvasData, _ = this.cropBoxData, M;
    if (this.ready && this.cropped) {
      M = {
        x: _.left - Z.left,
        y: _.top - Z.top,
        width: _.width,
        height: _.height
      };
      var x = k.width / k.naturalWidth;
      if (Rr(M, function(c, u) {
        M[u] = c / x;
      }), be) {
        var y = Math.round(M.y + M.height), E = Math.round(M.x + M.width);
        M.x = Math.round(M.x), M.y = Math.round(M.y), M.width = E - M.x, M.height = y - M.y;
      }
    } else
      M = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
    return ae.rotatable && (M.rotate = k.rotate || 0), ae.scalable && (M.scaleX = k.scaleX || 1, M.scaleY = k.scaleY || 1), M;
  },
  /**
   * Set the cropped area position and size with new data
   * @param {Object} data - The new data.
   * @returns {Cropper} this
   */
  setData: function(be) {
    var ae = this.options, k = this.imageData, Z = this.canvasData, _ = {};
    if (this.ready && !this.disabled && Za(be)) {
      var M = !1;
      ae.rotatable && Jt(be.rotate) && be.rotate !== k.rotate && (k.rotate = be.rotate, M = !0), ae.scalable && (Jt(be.scaleX) && be.scaleX !== k.scaleX && (k.scaleX = be.scaleX, M = !0), Jt(be.scaleY) && be.scaleY !== k.scaleY && (k.scaleY = be.scaleY, M = !0)), M && this.renderCanvas(!0, !0);
      var x = k.width / k.naturalWidth;
      Jt(be.x) && (_.left = be.x * x + Z.left), Jt(be.y) && (_.top = be.y * x + Z.top), Jt(be.width) && (_.width = be.width * x), Jt(be.height) && (_.height = be.height * x), this.setCropBoxData(_);
    }
    return this;
  },
  /**
   * Get the container size data.
   * @returns {Object} The result container data.
   */
  getContainerData: function() {
    return this.ready ? _r({}, this.containerData) : {};
  },
  /**
   * Get the image position and size data.
   * @returns {Object} The result image data.
   */
  getImageData: function() {
    return this.sized ? _r({}, this.imageData) : {};
  },
  /**
   * Get the canvas position and size data.
   * @returns {Object} The result canvas data.
   */
  getCanvasData: function() {
    var be = this.canvasData, ae = {};
    return this.ready && Rr(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function(k) {
      ae[k] = be[k];
    }), ae;
  },
  /**
   * Set the canvas position and size with new data.
   * @param {Object} data - The new canvas data.
   * @returns {Cropper} this
   */
  setCanvasData: function(be) {
    var ae = this.canvasData, k = ae.aspectRatio;
    return this.ready && !this.disabled && Za(be) && (Jt(be.left) && (ae.left = be.left), Jt(be.top) && (ae.top = be.top), Jt(be.width) ? (ae.width = be.width, ae.height = be.width / k) : Jt(be.height) && (ae.height = be.height, ae.width = be.height * k), this.renderCanvas(!0)), this;
  },
  /**
   * Get the crop box position and size data.
   * @returns {Object} The result crop box data.
   */
  getCropBoxData: function() {
    var be = this.cropBoxData, ae;
    return this.ready && this.cropped && (ae = {
      left: be.left,
      top: be.top,
      width: be.width,
      height: be.height
    }), ae || {};
  },
  /**
   * Set the crop box position and size with new data.
   * @param {Object} data - The new crop box data.
   * @returns {Cropper} this
   */
  setCropBoxData: function(be) {
    var ae = this.cropBoxData, k = this.options.aspectRatio, Z, _;
    return this.ready && this.cropped && !this.disabled && Za(be) && (Jt(be.left) && (ae.left = be.left), Jt(be.top) && (ae.top = be.top), Jt(be.width) && be.width !== ae.width && (Z = !0, ae.width = be.width), Jt(be.height) && be.height !== ae.height && (_ = !0, ae.height = be.height), k && (Z ? ae.height = ae.width / k : _ && (ae.width = ae.height * k)), this.renderCropBox()), this;
  },
  /**
   * Get a canvas drawn the cropped image.
   * @param {Object} [options={}] - The config options.
   * @returns {HTMLCanvasElement} - The result canvas.
   */
  getCroppedCanvas: function() {
    var be = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!this.ready || !window.HTMLCanvasElement)
      return null;
    var ae = this.canvasData, k = e0(this.image, this.imageData, ae, be);
    if (!this.cropped)
      return k;
    var Z = this.getData(be.rounded), _ = Z.x, M = Z.y, x = Z.width, y = Z.height, E = k.width / Math.floor(ae.naturalWidth);
    E !== 1 && (_ *= E, M *= E, x *= E, y *= E);
    var c = x / y, u = Zn({
      aspectRatio: c,
      width: be.maxWidth || 1 / 0,
      height: be.maxHeight || 1 / 0
    }), l = Zn({
      aspectRatio: c,
      width: be.minWidth || 0,
      height: be.minHeight || 0
    }, "cover"), a = Zn({
      aspectRatio: c,
      width: be.width || (E !== 1 ? k.width : x),
      height: be.height || (E !== 1 ? k.height : y)
    }), n = a.width, d = a.height;
    n = Math.min(u.width, Math.max(l.width, n)), d = Math.min(u.height, Math.max(l.height, d));
    var g = document.createElement("canvas"), h = g.getContext("2d");
    g.width = Xa(n), g.height = Xa(d), h.fillStyle = be.fillColor || "transparent", h.fillRect(0, 0, n, d);
    var m = be.imageSmoothingEnabled, s = m === void 0 ? !0 : m, b = be.imageSmoothingQuality;
    h.imageSmoothingEnabled = s, b && (h.imageSmoothingQuality = b);
    var S = k.width, o = k.height, A = _, T = M, I, L, z, U, J, F;
    A <= -x || A > S ? (A = 0, I = 0, z = 0, J = 0) : A <= 0 ? (z = -A, A = 0, I = Math.min(S, x + A), J = I) : A <= S && (z = 0, I = Math.min(x, S - A), J = I), I <= 0 || T <= -y || T > o ? (T = 0, L = 0, U = 0, F = 0) : T <= 0 ? (U = -T, T = 0, L = Math.min(o, y + T), F = L) : T <= o && (U = 0, L = Math.min(y, o - T), F = L);
    var oe = [A, T, I, L];
    if (J > 0 && F > 0) {
      var ee = n / x;
      oe.push(z * ee, U * ee, J * ee, F * ee);
    }
    return h.drawImage.apply(h, [k].concat(Xc(oe.map(function(ie) {
      return Math.floor(Xa(ie));
    })))), g;
  },
  /**
   * Change the aspect ratio of the crop box.
   * @param {number} aspectRatio - The new aspect ratio.
   * @returns {Cropper} this
   */
  setAspectRatio: function(be) {
    var ae = this.options;
    return !this.disabled && !Ml(be) && (ae.aspectRatio = Math.max(0, be) || NaN, this.ready && (this.initCropBox(), this.cropped && this.renderCropBox())), this;
  },
  /**
   * Change the drag mode.
   * @param {string} mode - The new drag mode.
   * @returns {Cropper} this
   */
  setDragMode: function(be) {
    var ae = this.options, k = this.dragBox, Z = this.face;
    if (this.ready && !this.disabled) {
      var _ = be === lf, M = ae.movable && be === $c;
      be = _ || M ? be : Jc, ae.dragMode = be, Os(k, Rs, be), Ya(k, Yl, _), Ya(k, Xl, M), ae.cropBoxMovable || (Os(Z, Rs, be), Ya(Z, Yl, _), Ya(Z, Xl, M));
    }
    return this;
  }
}, d0 = on.Cropper, od = /* @__PURE__ */ function() {
  function Re(be) {
    var ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (kp(this, Re), !be || !Up.test(be.tagName))
      throw new Error("The first argument is required and must be an <img> or <canvas> element.");
    this.element = be, this.options = _r({}, xc, Za(ae) && ae), this.cropped = !1, this.disabled = !1, this.pointers = {}, this.ready = !1, this.reloading = !1, this.replaced = !1, this.sized = !1, this.sizing = !1, this.init();
  }
  return Ap(Re, [{
    key: "init",
    value: function() {
      var ae = this.element, k = ae.tagName.toLowerCase(), Z;
      if (!ae[gr]) {
        if (ae[gr] = this, k === "img") {
          if (this.isImg = !0, Z = ae.getAttribute("src") || "", this.originalUrl = Z, !Z)
            return;
          Z = ae.src;
        } else k === "canvas" && window.HTMLCanvasElement && (Z = ae.toDataURL());
        this.load(Z);
      }
    }
  }, {
    key: "load",
    value: function(ae) {
      var k = this;
      if (ae) {
        this.url = ae, this.imageData = {};
        var Z = this.element, _ = this.options;
        if (!_.rotatable && !_.scalable && (_.checkOrientation = !1), !_.checkOrientation || !window.ArrayBuffer) {
          this.clone();
          return;
        }
        if (zp.test(ae)) {
          Fp.test(ae) ? this.read(i0(ae)) : this.clone();
          return;
        }
        var M = new XMLHttpRequest(), x = this.clone.bind(this);
        this.reloading = !0, this.xhr = M, M.onabort = x, M.onerror = x, M.ontimeout = x, M.onprogress = function() {
          M.getResponseHeader("content-type") !== Ec && M.abort();
        }, M.onload = function() {
          k.read(M.response);
        }, M.onloadend = function() {
          k.reloading = !1, k.xhr = null;
        }, _.checkCrossOrigin && kc(ae) && Z.crossOrigin && (ae = Ac(ae)), M.open("GET", ae, !0), M.responseType = "arraybuffer", M.withCredentials = Z.crossOrigin === "use-credentials", M.send();
      }
    }
  }, {
    key: "read",
    value: function(ae) {
      var k = this.options, Z = this.imageData, _ = a0(ae), M = 0, x = 1, y = 1;
      if (_ > 1) {
        this.url = n0(ae, Ec);
        var E = s0(_);
        M = E.rotate, x = E.scaleX, y = E.scaleY;
      }
      k.rotatable && (Z.rotate = M), k.scalable && (Z.scaleX = x, Z.scaleY = y), this.clone();
    }
  }, {
    key: "clone",
    value: function() {
      var ae = this.element, k = this.url, Z = ae.crossOrigin, _ = k;
      this.options.checkCrossOrigin && kc(k) && (Z || (Z = "anonymous"), _ = Ac(k)), this.crossOrigin = Z, this.crossOriginUrl = _;
      var M = document.createElement("img");
      Z && (M.crossOrigin = Z), M.src = _ || k, M.alt = ae.alt || "The image to crop", this.image = M, M.onload = this.start.bind(this), M.onerror = this.stop.bind(this), Wr(M, vc), ae.parentNode.insertBefore(M, ae.nextSibling);
    }
  }, {
    key: "start",
    value: function() {
      var ae = this, k = this.image;
      k.onload = null, k.onerror = null, this.sizing = !0;
      var Z = on.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(on.navigator.userAgent), _ = function(E, c) {
        _r(ae.imageData, {
          naturalWidth: E,
          naturalHeight: c,
          aspectRatio: E / c
        }), ae.initialImageData = _r({}, ae.imageData), ae.sizing = !1, ae.sized = !0, ae.build();
      };
      if (k.naturalWidth && !Z) {
        _(k.naturalWidth, k.naturalHeight);
        return;
      }
      var M = document.createElement("img"), x = document.body || document.documentElement;
      this.sizingImage = M, M.onload = function() {
        _(M.width, M.height), Z || x.removeChild(M);
      }, M.src = k.src, Z || (M.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;", x.appendChild(M));
    }
  }, {
    key: "stop",
    value: function() {
      var ae = this.image;
      ae.onload = null, ae.onerror = null, ae.parentNode.removeChild(ae), this.image = null;
    }
  }, {
    key: "build",
    value: function() {
      if (!(!this.sized || this.ready)) {
        var ae = this.element, k = this.options, Z = this.image, _ = ae.parentNode, M = document.createElement("div");
        M.innerHTML = jp;
        var x = M.querySelector(".".concat(gr, "-container")), y = x.querySelector(".".concat(gr, "-canvas")), E = x.querySelector(".".concat(gr, "-drag-box")), c = x.querySelector(".".concat(gr, "-crop-box")), u = c.querySelector(".".concat(gr, "-face"));
        this.container = _, this.cropper = x, this.canvas = y, this.dragBox = E, this.cropBox = c, this.viewBox = x.querySelector(".".concat(gr, "-view-box")), this.face = u, y.appendChild(Z), Wr(ae, mi), _.insertBefore(x, ae.nextSibling), sn(Z, vc), this.initPreview(), this.bind(), k.initialAspectRatio = Math.max(0, k.initialAspectRatio) || NaN, k.aspectRatio = Math.max(0, k.aspectRatio) || NaN, k.viewMode = Math.max(0, Math.min(3, Math.round(k.viewMode))) || 0, Wr(c, mi), k.guides || Wr(c.getElementsByClassName("".concat(gr, "-dashed")), mi), k.center || Wr(c.getElementsByClassName("".concat(gr, "-center")), mi), k.background && Wr(x, "".concat(gr, "-bg")), k.highlight || Wr(u, Op), k.cropBoxMovable && (Wr(u, Xl), Os(u, Rs, uf)), k.cropBoxResizable || (Wr(c.getElementsByClassName("".concat(gr, "-line")), mi), Wr(c.getElementsByClassName("".concat(gr, "-point")), mi)), this.render(), this.ready = !0, this.setDragMode(k.dragMode), k.autoCrop && this.crop(), this.setData(k.data), vi(k.ready) && Ni(ae, wc, k.ready, {
          once: !0
        }), qa(ae, wc);
      }
    }
  }, {
    key: "unbuild",
    value: function() {
      if (this.ready) {
        this.ready = !1, this.unbind(), this.resetPreview();
        var ae = this.cropper.parentNode;
        ae && ae.removeChild(this.cropper), sn(this.element, mi);
      }
    }
  }, {
    key: "uncreate",
    value: function() {
      this.ready ? (this.unbuild(), this.ready = !1, this.cropped = !1) : this.sizing ? (this.sizingImage.onload = null, this.sizing = !1, this.sized = !1) : this.reloading ? (this.xhr.onabort = null, this.xhr.abort()) : this.image && this.stop();
    }
    /**
     * Get the no conflict cropper class.
     * @returns {Cropper} The cropper class.
     */
  }], [{
    key: "noConflict",
    value: function() {
      return window.Cropper = d0, Re;
    }
    /**
     * Change the default options.
     * @param {Object} options - The new default options.
     */
  }, {
    key: "setDefaults",
    value: function(ae) {
      _r(xc, Za(ae) && ae);
    }
  }]);
}();
_r(od.prototype, o0, u0, l0, f0, h0, c0);
const p0 = Kt.forwardRef(
  ({ previewContent: Re, transformationArray: be, currentVariant: ae, transformationData: k, onFileProcessed: Z }, _) => {
    const M = Kt.useRef(null), x = {
      minResolution: 500,
      upload_wrapper: ".preview-upload"
    }, y = () => k.zone_width / k.zone_height, E = () => {
      if (!k) return;
      const u = document.querySelector(".transformation-mask"), l = document.querySelector(x.upload_wrapper);
      if (!u || !l) return;
      const a = u.offsetWidth / k.width, n = u.offsetHeight / k.height;
      l.style.left = `${k.zone_offset_x * a}px`, l.style.top = `${k.zone_offset_y * n}px`, l.style.width = `${k.zone_width * a}px`, l.style.height = `${k.zone_height * n}px`;
    };
    Kt.useEffect(() => {
      if (!k) return;
      const u = new ResizeObserver(() => {
        var a;
        E(), (a = _.current) != null && a.cropper && _.current.cropper.resize();
      }), l = document.querySelector(".preview-wrapper");
      return l && u.observe(l), () => {
        u.disconnect();
      };
    }, [k]);
    const c = Kt.useCallback(async () => {
      var u;
      if (!(!(Re != null && Re.file) || !((u = _.current) != null && u.cropper)))
        try {
          const l = _.current.cropper.getCroppedCanvas({
            imageSmoothingEnabled: !0,
            imageSmoothingQuality: "high",
            maxWidth: 4096,
            maxHeight: 4096,
            fillColor: "#fff"
          }), a = await new Promise((g) => l.toBlob(g, Re.file.type, 1)), n = new File([a], Re.file.name, {
            type: Re.file.type,
            lastModified: Date.now()
          }), d = new DataTransfer();
          d.items.add(n), Z == null || Z(d.files[0]);
        } catch (l) {
          console.error("Error processing file:", l);
        }
    }, [Re]);
    return Kt.useEffect(() => {
      if (M.current)
        return E(), _.current = {
          cropper: new od(M.current, {
            viewMode: 3,
            dragMode: "move",
            aspectRatio: y(),
            restore: !1,
            modal: !1,
            guides: !1,
            center: !1,
            highlight: !1,
            background: !1,
            autoCropArea: 1,
            wheelZoomRatio: 0.1,
            cropBoxMovable: !1,
            cropBoxResizable: !1,
            toggleDragModeOnDblclick: !1,
            minCropBoxWidth: x.minResolution,
            minCropBoxHeight: x.minResolution,
            minContainerWidth: document.querySelector(x.upload_wrapper).offsetWidth,
            minContainerHeight: document.querySelector(x.upload_wrapper).offsetHeight,
            checkOrientation: !1,
            checkCrossOrigin: !1,
            zoomOnWheel: !0,
            crop: () => {
              c();
            }
          })
        }, () => {
          var u;
          (u = _.current) != null && u.cropper && _.current.cropper.destroy();
        };
    }, [Re, ae, c]), /* @__PURE__ */ pt.jsx("div", { className: "preview-wrapper", children: /* @__PURE__ */ pt.jsxs("div", { className: `preview-container ${Re ? "has-upload" : ""}`, children: [
      /* @__PURE__ */ pt.jsx("div", { className: "preview-upload", children: Re && /* @__PURE__ */ pt.jsx(
        "img",
        {
          ref: M,
          src: Re.imageUrl,
          alt: "Uploaded preview",
          className: "preview-content uploaded-image"
        }
      ) }),
      be && be[1] && /* @__PURE__ */ pt.jsx(
        "img",
        {
          src: be[1],
          alt: "Background",
          className: "preview-content transformation-mask"
        }
      )
    ] }) });
  }
), v0 = ({ itemClass: Re }) => /* @__PURE__ */ pt.jsx("div", { className: Re, children: /* @__PURE__ */ pt.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ pt.jsx(
  "path",
  {
    d: "M12 5V19M5 12H19",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }
) }) }), m0 = ({ itemClass: Re }) => /* @__PURE__ */ pt.jsx("div", { className: Re, children: /* @__PURE__ */ pt.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ pt.jsx("path", { d: "M5 12H19", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }) }) }), g0 = ({ itemClass: Re }) => /* @__PURE__ */ pt.jsx("div", { className: Re, children: /* @__PURE__ */ pt.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", children: /* @__PURE__ */ pt.jsx("path", { d: "M12 8h27.711c6.739 0 12.157 5.548 11.997 12.286l-2.347 98.568C93.925 51.834 170.212 7.73 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.835 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l19.738-19.738c4.498-4.498 11.753-4.785 16.501-.552C160.213 433.246 205.895 452 256 452c108.322 0 196-87.662 196-196 0-108.322-87.662-196-196-196-79.545 0-147.941 47.282-178.675 115.302l126.389-3.009c6.737-.16 12.286 5.257 12.286 11.997V212c0 6.627-5.373 12-12 12H12c-6.627 0-12-5.373-12-12V20C0 13.373 5.373 8 12 8z" }) }) }), Ho = {
  Plus: v0,
  Minus: m0,
  Rotate: g0
}, _0 = 0.1, y0 = ({ isUploading: Re, previewContent: be, onFileSelect: ae, cropperRef: k }) => {
  const Z = () => Re ? "Uploading..." : be ? "Change Image" : "Upload Image", _ = () => {
    var E;
    (E = k.current) != null && E.cropper && k.current.cropper.rotate(-15);
  }, M = () => {
    var E;
    (E = k.current) != null && E.cropper && k.current.cropper.rotate(15);
  }, x = () => {
    var E;
    (E = k.current) != null && E.cropper && k.current.cropper.zoom(_0);
  }, y = () => {
    var E;
    (E = k.current) != null && E.cropper && k.current.cropper.zoom(-0.1);
  };
  return /* @__PURE__ */ pt.jsxs("div", { className: "upload-controls", children: [
    be && /* @__PURE__ */ pt.jsx("div", { className: "cropper-btn-section", children: /* @__PURE__ */ pt.jsxs("div", { className: "cropper-btn-group", children: [
      /* @__PURE__ */ pt.jsx("button", { className: "cropper-btn rounded", onClick: _, type: "button", children: /* @__PURE__ */ pt.jsx(Ho.Rotate, { itemClass: "leading-[0]" }) }),
      /* @__PURE__ */ pt.jsx("button", { className: "cropper-btn rotate-right rounded", onClick: M, type: "button", children: /* @__PURE__ */ pt.jsx(Ho.Rotate, { itemClass: "leading-[0]" }) }),
      /* @__PURE__ */ pt.jsx("button", { className: "cropper-btn rounded", onClick: x, type: "button", children: /* @__PURE__ */ pt.jsx(Ho.Plus, { itemClass: "leading-[0]" }) }),
      /* @__PURE__ */ pt.jsx("button", { className: "cropper-btn rounded", onClick: y, type: "button", children: /* @__PURE__ */ pt.jsx(Ho.Minus, { itemClass: "leading-[0]" }) })
    ] }) }),
    /* @__PURE__ */ pt.jsxs("div", { className: "upload-btn-wrapper", children: [
      /* @__PURE__ */ pt.jsx(
        "input",
        {
          type: "file",
          accept: "image/*",
          onChange: ae,
          className: "upload-input",
          style: { cursor: "pointer" }
        }
      ),
      /* @__PURE__ */ pt.jsx("div", { className: "upload-info-w", children: /* @__PURE__ */ pt.jsx("div", { className: "upload-info btn button p-3 so-btn so-btn-primary", children: /* @__PURE__ */ pt.jsx("span", { className: "upload-status", children: Z() }) }) })
    ] })
  ] });
}, Go = {
  en: {
    errors: {
      invalid_character: " isn't available"
    },
    buyer_upload: {
      confirmDesign: "Confirm Design",
      confirming: "Confirming...",
      confirmed: "Confirmed"
    }
  },
  fr: {
    errors: {
      invalid_character: " n'est pas disponible"
    }
  },
  es: {
    errors: {
      invalid_character: " no está disponible"
    }
  },
  de: {
    errors: {
      invalid_character: " ist nicht verfügbar"
    }
  },
  it: {
    errors: {
      invalid_character: " non è disponibile"
    }
  },
  pt: {
    errors: {
      invalid_character: " não está disponível"
    }
  },
  ua: {
    errors: {
      invalid_character: " недоступний"
    }
  },
  pl: {
    errors: {
      invalid_character: " jest niedostępny"
    }
  }
}, w0 = () => {
  var ae;
  const Re = ((ae = window.Shopify) == null ? void 0 : ae.locale) || "en", be = Go[Re] || Go.en;
  return new Proxy(be, {
    get: (k, Z) => typeof k[Z] == "object" && k[Z] !== null ? new Proxy(k[Z], {
      get: (_, M) => {
        var x;
        return _[M] || ((x = Go.en[Z]) == null ? void 0 : x[M]) || `[${Z}.${M}]`;
      }
    }) : k[Z] || Go.en[Z] || `[${Z}]`
  });
}, ud = ({ registeredFile: Re, currentVariant: be, setUploads: ae, showErrors: k, setUserInteracted: Z }) => {
  const [_, M] = Kt.useState(!1), [x, y] = Kt.useState(!1), { buyer_upload: E } = w0(), c = Kt.useCallback(async () => {
    var l;
    try {
      if (M(!0), !Re || !(be != null && be.id)) {
        console.error("Missing file or variant id", {
          file: Re,
          variantId: be == null ? void 0 : be.id
        });
        return;
      }
      const a = new FormData();
      a.append("id", be.id), a.append("quantity", "1"), a.append("properties[Upload]", Re);
      const n = await fetch("/cart/add.js", {
        method: "POST",
        headers: {
          Accept: "application/json",
          "X-Requested-With": "XMLHttpRequest",
          "X-SO-REQUEST": "file-upload"
        },
        body: a
      });
      if (!n.ok)
        throw new Error(`File upload failed: ${n.status}`);
      const g = (l = (await n.json()).properties) == null ? void 0 : l.Upload;
      if (!g)
        throw new Error("No file URL received");
      const s = (await (await fetch("/cart.js")).json()).items.find(
        (b) => {
          var S;
          return b.id === be.id && ((S = b.properties) == null ? void 0 : S.Upload) === g;
        }
      );
      s && await fetch("/cart/change.js", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        body: JSON.stringify({
          id: s.key,
          quantity: 0
        })
      }), g && (ae((b) => ({
        ...b,
        Upload: g
      })), y(!0), Z && Z(!1));
    } catch (a) {
      console.error("Failed to confirm design:", a);
    } finally {
      M(!1);
    }
  }, [Re, be == null ? void 0 : be.id]), u = () => x ? "so-btn-success" : _ ? "so-btn-primary" : k ? "so-btn-danger" : "so-btn-primary";
  return /* @__PURE__ */ pt.jsx("div", { className: "button-row", children: /* @__PURE__ */ pt.jsx("div", { className: "design-confirmation", children: /* @__PURE__ */ pt.jsx(
    "button",
    {
      className: `btn ${u()}`,
      onClick: c,
      disabled: _ || x,
      children: _ ? /* @__PURE__ */ pt.jsxs(pt.Fragment, { children: [
        /* @__PURE__ */ pt.jsx("svg", { className: "spinner", viewBox: "0 0 24 24", children: /* @__PURE__ */ pt.jsx("path", { d: "M12,4V2A10,10 0 0,0 2,12H4A8,8 0 0,1 12,4Z" }) }),
        E.confirming
      ] }) : x ? /* @__PURE__ */ pt.jsxs(pt.Fragment, { children: [
        /* @__PURE__ */ pt.jsx("span", { children: E.confirmed }),
        /* @__PURE__ */ pt.jsx("svg", { className: "checkmark", viewBox: "0 0 16 16", children: /* @__PURE__ */ pt.jsx("path", { d: "M3 8l3.5 3.5L13 5" }) })
      ] }) : /* @__PURE__ */ pt.jsx("span", { children: E.confirmDesign })
    }
  ) }) });
}, b0 = ({ message: Re, type: be = "error" }) => /* @__PURE__ */ pt.jsx("div", { className: `so-notification ${be}`, children: /* @__PURE__ */ pt.jsx("span", { children: Re }) }), S0 = ({ currentVariant: Re, productInfo: be, setUploads: ae, showErrors: k, setUserInteracted: Z }) => {
  const [_, M] = Kt.useState(null), [x, y] = Kt.useState(!1), [E, c] = Kt.useState(null), u = Kt.useRef(null), [l, a] = Kt.useState(null), n = (s, b = 3e3) => {
    c(s), setTimeout(() => c(null), b);
  }, d = (s) => {
    const b = s.target, S = b.files[0], o = () => {
      b.value = "";
    }, A = {
      "image/jpeg": 10,
      // 10MB
      "image/png": 10,
      "image/jpg": 10,
      "image/webp": 10,
      "image/bmp": 5
    };
    if (!S || !A.hasOwnProperty(S.type)) {
      n("Please upload a valid image file (JPEG, PNG, WebP, or BMP)."), o();
      return;
    }
    if (S.size / (1024 * 1024) > A[S.type]) {
      n(`File size must be less than ${A[S.type]}MB`), o();
      return;
    }
    const I = new Image(), L = URL.createObjectURL(S);
    I.onload = () => {
      if (URL.revokeObjectURL(L), I.width < 500 || I.height < 500) {
        n("Image dimensions must be at least 500x500px"), o();
        return;
      }
      y(!0);
      const z = new FileReader();
      z.onload = (U) => {
        M({
          imageUrl: U.target.result,
          type: "upload",
          file: S
        }), y(!1), Z(!1);
      }, z.readAsDataURL(S);
    }, I.onerror = () => {
      URL.revokeObjectURL(L), n("Error loading image. Please try another file."), o();
    }, I.src = L;
  }, g = (s) => {
    ae((b) => ({
      ...b,
      file: s,
      Upload: null
    })), a(s);
  }, m = (() => {
    var b, S, o, A;
    const s = be.variant_metafields[Re.id];
    if ((s == null ? void 0 : s.engravable) === 1) {
      const T = s.options[0], I = Object.keys(be.variant_metafields).find((L) => {
        var U;
        const z = be.variant_metafields[L];
        return z.engravable === 0 && ((U = z.options) == null ? void 0 : U.includes(T));
      });
      if (I) {
        const L = be.variant_metafields[I], z = ((S = (b = L == null ? void 0 : L.transformations_filenames_json) == null ? void 0 : b[0]) == null ? void 0 : S.split(",")) || [];
        return {
          array: z,
          data: L == null ? void 0 : L.transformations_json[z[0]]
        };
      }
    }
    if ((s == null ? void 0 : s.engravable) === 0) {
      const T = ((A = (o = s == null ? void 0 : s.transformations_filenames_json) == null ? void 0 : o[0]) == null ? void 0 : A.split(",")) || [];
      return {
        array: T,
        data: s == null ? void 0 : s.transformations_json[T[0]]
      };
    }
    return { array: [], data: null };
  })();
  return /* @__PURE__ */ pt.jsx("div", { className: "so-tw", children: /* @__PURE__ */ pt.jsxs(
    "div",
    {
      className: `uploading-container ${_ ? "has-upload" : "no-upload"} ${k ? "error" : ""}`,
      children: [
        E && /* @__PURE__ */ pt.jsx(b0, { message: E }),
        /* @__PURE__ */ pt.jsx(
          p0,
          {
            ref: u,
            previewContent: _,
            transformationArray: m.array,
            transformationData: m.data,
            onFileProcessed: g
          }
        ),
        /* @__PURE__ */ pt.jsxs("div", { className: `upload-overlay ${_ ? "" : "empty-state-overlay"}`, children: [
          /* @__PURE__ */ pt.jsx(
            y0,
            {
              isUploading: x,
              previewContent: _,
              onFileSelect: d,
              cropperRef: u
            }
          ),
          _ && /* @__PURE__ */ pt.jsx(
            ud,
            {
              currentVariant: Re,
              registeredFile: l,
              setUploads: ae,
              showErrors: k,
              setUserInteracted: Z
            },
            l ? l.lastModified : "no-file"
          )
        ] })
      ]
    }
  ) });
}, Zo = {
  heart: /* @__PURE__ */ pt.jsx("path", { d: "M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" }),
  pin: /* @__PURE__ */ pt.jsx("path", { d: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" }),
  stone: /* @__PURE__ */ pt.jsx("path", { d: "M12 2L2 8.5L12 15L22 8.5L12 2ZM12 17L2 10.5L12 22L22 10.5L12 17Z" })
}, Tc = ({ renderInMap: Re, onMarkerChange: be, selectedType: ae, metalType: k }) => {
  var y;
  const _ = nf().filter((E) => {
    var c;
    return E.field_type === "custom" && ((c = E.slug) == null ? void 0 : c.includes("capture-"));
  }), M = {
    heart: "#323232",
    pin: `var(--metal-border-${k})`,
    stone: "#000000"
  };
  if (Re)
    return ae !== "none" ? /* @__PURE__ */ pt.jsx("div", { className: "icon-marker", style: { color: M[ae] }, children: /* @__PURE__ */ pt.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "currentColor", children: Zo[ae] }) }) : null;
  const x = (y = _[0]) == null ? void 0 : y.options.marker;
  return /* @__PURE__ */ pt.jsxs("div", { className: "marker-selector", children: [
    /* @__PURE__ */ pt.jsx("label", { className: "marker-label", children: "Marker style:" }),
    /* @__PURE__ */ pt.jsx("div", { className: "marker-swatches", children: x.map((E) => /* @__PURE__ */ pt.jsxs("label", { className: "marker-swatch", children: [
      /* @__PURE__ */ pt.jsx(
        "input",
        {
          type: "radio",
          name: "marker-type",
          value: E.value,
          checked: ae === E.value,
          onChange: (c) => be(c.target.value)
        }
      ),
      /* @__PURE__ */ pt.jsxs("span", { children: [
        E.value !== "none" && /* @__PURE__ */ pt.jsx(
          "svg",
          {
            width: "16",
            height: "16",
            viewBox: "0 0 24 24",
            fill: "currentColor",
            style: { color: M[E.value] },
            children: Zo[E.value]
          }
        ),
        E.label
      ] })
    ] }, E.value)) })
  ] });
};
function Ms(Re) {
  throw new Error('Could not dynamically require "' + Re + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Il = { exports: {} }, Mc;
function ld() {
  return Mc || (Mc = 1, function(Re, be) {
    if ((typeof ae > "u" || !ae) && typeof self < "u") var ae = self;
    (function(k) {
      Re.exports = k();
    })(function() {
      return (/* @__PURE__ */ function() {
        function k(Z, _, M) {
          function x(c, u) {
            if (!_[c]) {
              if (!Z[c]) {
                var l = typeof Ms == "function" && Ms;
                if (!u && l) return l(c, !0);
                if (y) return y(c, !0);
                var a = new Error("Cannot find module '" + c + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var n = _[c] = { exports: {} };
              Z[c][0].call(n.exports, function(d) {
                var g = Z[c][1][d];
                return x(g || d);
              }, n, n.exports, k, Z, _, M);
            }
            return _[c].exports;
          }
          for (var y = typeof Ms == "function" && Ms, E = 0; E < M.length; E++) x(M[E]);
          return x;
        }
        return k;
      }())({ 1: [function(k, Z, _) {
        function M(x) {
          if (Array.isArray(x)) return x;
        }
        Z.exports = M;
      }, {}], 2: [function(k, Z, _) {
        function M(x) {
          if (Array.isArray(x)) {
            for (var y = 0, E = new Array(x.length); y < x.length; y++)
              E[y] = x[y];
            return E;
          }
        }
        Z.exports = M;
      }, {}], 3: [function(k, Z, _) {
        function M(x) {
          if (x === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return x;
        }
        Z.exports = M;
      }, {}], 4: [function(k, Z, _) {
        function M(x, y) {
          if (!(x instanceof y))
            throw new TypeError("Cannot call a class as a function");
        }
        Z.exports = M;
      }, {}], 5: [function(k, Z, _) {
        var M = k("./setPrototypeOf");
        function x() {
          if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
          if (typeof Proxy == "function") return !0;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), !0;
          } catch {
            return !1;
          }
        }
        function y(E, c, u) {
          return x() ? Z.exports = y = Reflect.construct : Z.exports = y = function(a, n, d) {
            var g = [null];
            g.push.apply(g, n);
            var h = Function.bind.apply(a, g), m = new h();
            return d && M(m, d.prototype), m;
          }, y.apply(null, arguments);
        }
        Z.exports = y;
      }, { "./setPrototypeOf": 18 }], 6: [function(k, Z, _) {
        function M(y, E) {
          for (var c = 0; c < E.length; c++) {
            var u = E[c];
            u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(y, u.key, u);
          }
        }
        function x(y, E, c) {
          return E && M(y.prototype, E), c && M(y, c), y;
        }
        Z.exports = x;
      }, {}], 7: [function(k, Z, _) {
        function M(x, y, E) {
          return y in x ? Object.defineProperty(x, y, {
            value: E,
            enumerable: !0,
            configurable: !0,
            writable: !0
          }) : x[y] = E, x;
        }
        Z.exports = M;
      }, {}], 8: [function(k, Z, _) {
        function M() {
          return Z.exports = M = Object.assign || function(x) {
            for (var y = 1; y < arguments.length; y++) {
              var E = arguments[y];
              for (var c in E)
                Object.prototype.hasOwnProperty.call(E, c) && (x[c] = E[c]);
            }
            return x;
          }, M.apply(this, arguments);
        }
        Z.exports = M;
      }, {}], 9: [function(k, Z, _) {
        function M(x) {
          return Z.exports = M = Object.setPrototypeOf ? Object.getPrototypeOf : function(E) {
            return E.__proto__ || Object.getPrototypeOf(E);
          }, M(x);
        }
        Z.exports = M;
      }, {}], 10: [function(k, Z, _) {
        var M = k("./setPrototypeOf");
        function x(y, E) {
          if (typeof E != "function" && E !== null)
            throw new TypeError("Super expression must either be null or a function");
          y.prototype = Object.create(E && E.prototype, {
            constructor: {
              value: y,
              writable: !0,
              configurable: !0
            }
          }), E && M(y, E);
        }
        Z.exports = x;
      }, { "./setPrototypeOf": 18 }], 11: [function(k, Z, _) {
        function M(x) {
          return x && x.__esModule ? x : {
            default: x
          };
        }
        Z.exports = M;
      }, {}], 12: [function(k, Z, _) {
        var M = k("../helpers/typeof");
        function x() {
          if (typeof WeakMap != "function") return null;
          var E = /* @__PURE__ */ new WeakMap();
          return x = function() {
            return E;
          }, E;
        }
        function y(E) {
          if (E && E.__esModule)
            return E;
          if (E === null || M(E) !== "object" && typeof E != "function")
            return {
              default: E
            };
          var c = x();
          if (c && c.has(E))
            return c.get(E);
          var u = {}, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var a in E)
            if (Object.prototype.hasOwnProperty.call(E, a)) {
              var n = l ? Object.getOwnPropertyDescriptor(E, a) : null;
              n && (n.get || n.set) ? Object.defineProperty(u, a, n) : u[a] = E[a];
            }
          return u.default = E, c && c.set(E, u), u;
        }
        Z.exports = y;
      }, { "../helpers/typeof": 21 }], 13: [function(k, Z, _) {
        function M(x) {
          if (Symbol.iterator in Object(x) || Object.prototype.toString.call(x) === "[object Arguments]") return Array.from(x);
        }
        Z.exports = M;
      }, {}], 14: [function(k, Z, _) {
        function M(x, y) {
          if (Symbol.iterator in Object(x) || Object.prototype.toString.call(x) === "[object Arguments]") {
            var E = [], c = !0, u = !1, l = void 0;
            try {
              for (var a = x[Symbol.iterator](), n; !(c = (n = a.next()).done) && (E.push(n.value), !(y && E.length === y)); c = !0)
                ;
            } catch (d) {
              u = !0, l = d;
            } finally {
              try {
                !c && a.return != null && a.return();
              } finally {
                if (u) throw l;
              }
            }
            return E;
          }
        }
        Z.exports = M;
      }, {}], 15: [function(k, Z, _) {
        function M() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
        Z.exports = M;
      }, {}], 16: [function(k, Z, _) {
        function M() {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }
        Z.exports = M;
      }, {}], 17: [function(k, Z, _) {
        var M = k("../helpers/typeof"), x = k("./assertThisInitialized");
        function y(E, c) {
          return c && (M(c) === "object" || typeof c == "function") ? c : x(E);
        }
        Z.exports = y;
      }, { "../helpers/typeof": 21, "./assertThisInitialized": 3 }], 18: [function(k, Z, _) {
        function M(x, y) {
          return Z.exports = M = Object.setPrototypeOf || function(c, u) {
            return c.__proto__ = u, c;
          }, M(x, y);
        }
        Z.exports = M;
      }, {}], 19: [function(k, Z, _) {
        var M = k("./arrayWithHoles"), x = k("./iterableToArrayLimit"), y = k("./nonIterableRest");
        function E(c, u) {
          return M(c) || x(c, u) || y();
        }
        Z.exports = E;
      }, { "./arrayWithHoles": 1, "./iterableToArrayLimit": 14, "./nonIterableRest": 15 }], 20: [function(k, Z, _) {
        var M = k("./arrayWithoutHoles"), x = k("./iterableToArray"), y = k("./nonIterableSpread");
        function E(c) {
          return M(c) || x(c) || y();
        }
        Z.exports = E;
      }, { "./arrayWithoutHoles": 2, "./iterableToArray": 13, "./nonIterableSpread": 16 }], 21: [function(k, Z, _) {
        function M(y) {
          return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? M = function(c) {
            return typeof c;
          } : M = function(c) {
            return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
          }, M(y);
        }
        function x(y) {
          return typeof Symbol == "function" && M(Symbol.iterator) === "symbol" ? Z.exports = x = function(c) {
            return M(c);
          } : Z.exports = x = function(c) {
            return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : M(c);
          }, x(y);
        }
        Z.exports = x;
      }, {}], 22: [function(k, Z, _) {
        Z.exports = k("regenerator-runtime");
      }, { "regenerator-runtime": 153 }], 23: [function(k, Z, _) {
        var M = k("./src/converter");
        function x(y, E) {
          var c = new M(y, E);
          return function(u) {
            return c.convert(u);
          };
        }
        x.BIN = "01", x.OCT = "01234567", x.DEC = "0123456789", x.HEX = "0123456789abcdef", Z.exports = x;
      }, { "./src/converter": 24 }], 24: [function(k, Z, _) {
        function M(x, y) {
          if (!x || !y || !x.length || !y.length)
            throw new Error("Bad alphabet");
          this.srcAlphabet = x, this.dstAlphabet = y;
        }
        M.prototype.convert = function(x) {
          var y, E, c, u = {}, l = this.srcAlphabet.length, a = this.dstAlphabet.length, n = x.length, d = typeof x == "string" ? "" : [];
          if (!this.isValid(x))
            throw new Error('Number "' + x + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
          if (this.srcAlphabet === this.dstAlphabet)
            return x;
          for (y = 0; y < n; y++)
            u[y] = this.srcAlphabet.indexOf(x[y]);
          do {
            for (E = 0, c = 0, y = 0; y < n; y++)
              E = E * l + u[y], E >= a ? (u[c++] = parseInt(E / a, 10), E = E % a) : c > 0 && (u[c++] = 0);
            n = c, d = this.dstAlphabet.slice(E, E + 1).concat(d);
          } while (c !== 0);
          return d;
        }, M.prototype.isValid = function(x) {
          for (var y = 0; y < x.length; ++y)
            if (this.srcAlphabet.indexOf(x[y]) === -1)
              return !1;
          return !0;
        }, Z.exports = M;
      }, {}], 25: [function(k, Z, _) {
        (function(M) {
          var x = k("object-assign");
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
           * @license  MIT
           */
          function y(ie, W) {
            if (ie === W)
              return 0;
            for (var Q = ie.length, de = W.length, we = 0, ke = Math.min(Q, de); we < ke; ++we)
              if (ie[we] !== W[we]) {
                Q = ie[we], de = W[we];
                break;
              }
            return Q < de ? -1 : de < Q ? 1 : 0;
          }
          function E(ie) {
            return M.Buffer && typeof M.Buffer.isBuffer == "function" ? M.Buffer.isBuffer(ie) : !!(ie != null && ie._isBuffer);
          }
          var c = k("util/"), u = Object.prototype.hasOwnProperty, l = Array.prototype.slice, a = function() {
            return (function() {
            }).name === "foo";
          }();
          function n(ie) {
            return Object.prototype.toString.call(ie);
          }
          function d(ie) {
            return E(ie) || typeof M.ArrayBuffer != "function" ? !1 : typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(ie) : ie ? !!(ie instanceof DataView || ie.buffer && ie.buffer instanceof ArrayBuffer) : !1;
          }
          var g = Z.exports = A, h = /\s*function\s+([^\(\s]*)\s*/;
          function m(ie) {
            if (c.isFunction(ie)) {
              if (a)
                return ie.name;
              var W = ie.toString(), Q = W.match(h);
              return Q && Q[1];
            }
          }
          g.AssertionError = function(W) {
            this.name = "AssertionError", this.actual = W.actual, this.expected = W.expected, this.operator = W.operator, W.message ? (this.message = W.message, this.generatedMessage = !1) : (this.message = S(this), this.generatedMessage = !0);
            var Q = W.stackStartFunction || o;
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, Q);
            else {
              var de = new Error();
              if (de.stack) {
                var we = de.stack, ke = m(Q), Me = we.indexOf(`
` + ke);
                if (Me >= 0) {
                  var fe = we.indexOf(`
`, Me + 1);
                  we = we.substring(fe + 1);
                }
                this.stack = we;
              }
            }
          }, c.inherits(g.AssertionError, Error);
          function s(ie, W) {
            return typeof ie == "string" ? ie.length < W ? ie : ie.slice(0, W) : ie;
          }
          function b(ie) {
            if (a || !c.isFunction(ie))
              return c.inspect(ie);
            var W = m(ie), Q = W ? ": " + W : "";
            return "[Function" + Q + "]";
          }
          function S(ie) {
            return s(b(ie.actual), 128) + " " + ie.operator + " " + s(b(ie.expected), 128);
          }
          function o(ie, W, Q, de, we) {
            throw new g.AssertionError({
              message: Q,
              actual: ie,
              expected: W,
              operator: de,
              stackStartFunction: we
            });
          }
          g.fail = o;
          function A(ie, W) {
            ie || o(ie, !0, W, "==", g.ok);
          }
          g.ok = A, g.equal = function(W, Q, de) {
            W != Q && o(W, Q, de, "==", g.equal);
          }, g.notEqual = function(W, Q, de) {
            W == Q && o(W, Q, de, "!=", g.notEqual);
          }, g.deepEqual = function(W, Q, de) {
            T(W, Q, !1) || o(W, Q, de, "deepEqual", g.deepEqual);
          }, g.deepStrictEqual = function(W, Q, de) {
            T(W, Q, !0) || o(W, Q, de, "deepStrictEqual", g.deepStrictEqual);
          };
          function T(ie, W, Q, de) {
            if (ie === W)
              return !0;
            if (E(ie) && E(W))
              return y(ie, W) === 0;
            if (c.isDate(ie) && c.isDate(W))
              return ie.getTime() === W.getTime();
            if (c.isRegExp(ie) && c.isRegExp(W))
              return ie.source === W.source && ie.global === W.global && ie.multiline === W.multiline && ie.lastIndex === W.lastIndex && ie.ignoreCase === W.ignoreCase;
            if ((ie === null || typeof ie != "object") && (W === null || typeof W != "object"))
              return Q ? ie === W : ie == W;
            if (d(ie) && d(W) && n(ie) === n(W) && !(ie instanceof Float32Array || ie instanceof Float64Array))
              return y(
                new Uint8Array(ie.buffer),
                new Uint8Array(W.buffer)
              ) === 0;
            if (E(ie) !== E(W))
              return !1;
            de = de || { actual: [], expected: [] };
            var we = de.actual.indexOf(ie);
            return we !== -1 && we === de.expected.indexOf(W) ? !0 : (de.actual.push(ie), de.expected.push(W), L(ie, W, Q, de));
          }
          function I(ie) {
            return Object.prototype.toString.call(ie) == "[object Arguments]";
          }
          function L(ie, W, Q, de) {
            if (ie == null || W === null || W === void 0)
              return !1;
            if (c.isPrimitive(ie) || c.isPrimitive(W))
              return ie === W;
            if (Q && Object.getPrototypeOf(ie) !== Object.getPrototypeOf(W))
              return !1;
            var we = I(ie), ke = I(W);
            if (we && !ke || !we && ke)
              return !1;
            if (we)
              return ie = l.call(ie), W = l.call(W), T(ie, W, Q);
            var Me = ee(ie), fe = ee(W), xe, Ee;
            if (Me.length !== fe.length)
              return !1;
            for (Me.sort(), fe.sort(), Ee = Me.length - 1; Ee >= 0; Ee--)
              if (Me[Ee] !== fe[Ee])
                return !1;
            for (Ee = Me.length - 1; Ee >= 0; Ee--)
              if (xe = Me[Ee], !T(ie[xe], W[xe], Q, de))
                return !1;
            return !0;
          }
          g.notDeepEqual = function(W, Q, de) {
            T(W, Q, !1) && o(W, Q, de, "notDeepEqual", g.notDeepEqual);
          }, g.notDeepStrictEqual = z;
          function z(ie, W, Q) {
            T(ie, W, !0) && o(ie, W, Q, "notDeepStrictEqual", z);
          }
          g.strictEqual = function(W, Q, de) {
            W !== Q && o(W, Q, de, "===", g.strictEqual);
          }, g.notStrictEqual = function(W, Q, de) {
            W === Q && o(W, Q, de, "!==", g.notStrictEqual);
          };
          function U(ie, W) {
            if (!ie || !W)
              return !1;
            if (Object.prototype.toString.call(W) == "[object RegExp]")
              return W.test(ie);
            try {
              if (ie instanceof W)
                return !0;
            } catch {
            }
            return Error.isPrototypeOf(W) ? !1 : W.call({}, ie) === !0;
          }
          function J(ie) {
            var W;
            try {
              ie();
            } catch (Q) {
              W = Q;
            }
            return W;
          }
          function F(ie, W, Q, de) {
            var we;
            if (typeof W != "function")
              throw new TypeError('"block" argument must be a function');
            typeof Q == "string" && (de = Q, Q = null), we = J(W), de = (Q && Q.name ? " (" + Q.name + ")." : ".") + (de ? " " + de : "."), ie && !we && o(we, Q, "Missing expected exception" + de);
            var ke = typeof de == "string", Me = !ie && c.isError(we), fe = !ie && we && !Q;
            if ((Me && ke && U(we, Q) || fe) && o(we, Q, "Got unwanted exception" + de), ie && we && Q && !U(we, Q) || !ie && we)
              throw we;
          }
          g.throws = function(ie, W, Q) {
            F(!0, ie, W, Q);
          }, g.doesNotThrow = function(ie, W, Q) {
            F(!1, ie, W, Q);
          }, g.ifError = function(ie) {
            if (ie) throw ie;
          };
          function oe(ie, W) {
            ie || o(ie, !0, W, "==", oe);
          }
          g.strict = x(oe, g, {
            equal: g.strictEqual,
            deepEqual: g.deepStrictEqual,
            notEqual: g.notStrictEqual,
            notDeepEqual: g.notDeepStrictEqual
          }), g.strict.strict = g.strict;
          var ee = Object.keys || function(ie) {
            var W = [];
            for (var Q in ie)
              u.call(ie, Q) && W.push(Q);
            return W;
          };
        }).call(this, typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {});
      }, { "object-assign": 84, "util/": 28 }], 26: [function(k, Z, _) {
        typeof Object.create == "function" ? Z.exports = function(x, y) {
          x.super_ = y, x.prototype = Object.create(y.prototype, {
            constructor: {
              value: x,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : Z.exports = function(x, y) {
          x.super_ = y;
          var E = function() {
          };
          E.prototype = y.prototype, x.prototype = new E(), x.prototype.constructor = x;
        };
      }, {}], 27: [function(k, Z, _) {
        Z.exports = function(x) {
          return x && typeof x == "object" && typeof x.copy == "function" && typeof x.fill == "function" && typeof x.readUInt8 == "function";
        };
      }, {}], 28: [function(k, Z, _) {
        (function(M, x) {
          var y = /%[sdj%]/g;
          _.format = function(fe) {
            if (!L(fe)) {
              for (var xe = [], Ee = 0; Ee < arguments.length; Ee++)
                xe.push(u(arguments[Ee]));
              return xe.join(" ");
            }
            for (var Ee = 1, Pe = arguments, Ue = Pe.length, He = String(fe).replace(y, function(Ze) {
              if (Ze === "%%") return "%";
              if (Ee >= Ue) return Ze;
              switch (Ze) {
                case "%s":
                  return String(Pe[Ee++]);
                case "%d":
                  return Number(Pe[Ee++]);
                case "%j":
                  try {
                    return JSON.stringify(Pe[Ee++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return Ze;
              }
            }), We = Pe[Ee]; Ee < Ue; We = Pe[++Ee])
              A(We) || !F(We) ? He += " " + We : He += " " + u(We);
            return He;
          }, _.deprecate = function(fe, xe) {
            if (U(x.process))
              return function() {
                return _.deprecate(fe, xe).apply(this, arguments);
              };
            if (M.noDeprecation === !0)
              return fe;
            var Ee = !1;
            function Pe() {
              if (!Ee) {
                if (M.throwDeprecation)
                  throw new Error(xe);
                M.traceDeprecation ? console.trace(xe) : console.error(xe), Ee = !0;
              }
              return fe.apply(this, arguments);
            }
            return Pe;
          };
          var E = {}, c;
          _.debuglog = function(fe) {
            if (U(c) && (c = M.env.NODE_DEBUG || ""), fe = fe.toUpperCase(), !E[fe])
              if (new RegExp("\\b" + fe + "\\b", "i").test(c)) {
                var xe = M.pid;
                E[fe] = function() {
                  var Ee = _.format.apply(_, arguments);
                  console.error("%s %d: %s", fe, xe, Ee);
                };
              } else
                E[fe] = function() {
                };
            return E[fe];
          };
          function u(fe, xe) {
            var Ee = {
              seen: [],
              stylize: a
            };
            return arguments.length >= 3 && (Ee.depth = arguments[2]), arguments.length >= 4 && (Ee.colors = arguments[3]), o(xe) ? Ee.showHidden = xe : xe && _._extend(Ee, xe), U(Ee.showHidden) && (Ee.showHidden = !1), U(Ee.depth) && (Ee.depth = 2), U(Ee.colors) && (Ee.colors = !1), U(Ee.customInspect) && (Ee.customInspect = !0), Ee.colors && (Ee.stylize = l), d(Ee, fe, Ee.depth);
          }
          _.inspect = u, u.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, u.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function l(fe, xe) {
            var Ee = u.styles[xe];
            return Ee ? "\x1B[" + u.colors[Ee][0] + "m" + fe + "\x1B[" + u.colors[Ee][1] + "m" : fe;
          }
          function a(fe, xe) {
            return fe;
          }
          function n(fe) {
            var xe = {};
            return fe.forEach(function(Ee, Pe) {
              xe[Ee] = !0;
            }), xe;
          }
          function d(fe, xe, Ee) {
            if (fe.customInspect && xe && ie(xe.inspect) && // Filter out the util module, it's inspect function is special
            xe.inspect !== _.inspect && // Also filter out any prototype objects using the circular check.
            !(xe.constructor && xe.constructor.prototype === xe)) {
              var Pe = xe.inspect(Ee, fe);
              return L(Pe) || (Pe = d(fe, Pe, Ee)), Pe;
            }
            var Ue = g(fe, xe);
            if (Ue)
              return Ue;
            var He = Object.keys(xe), We = n(He);
            if (fe.showHidden && (He = Object.getOwnPropertyNames(xe)), ee(xe) && (He.indexOf("message") >= 0 || He.indexOf("description") >= 0))
              return h(xe);
            if (He.length === 0) {
              if (ie(xe)) {
                var Ze = xe.name ? ": " + xe.name : "";
                return fe.stylize("[Function" + Ze + "]", "special");
              }
              if (J(xe))
                return fe.stylize(RegExp.prototype.toString.call(xe), "regexp");
              if (oe(xe))
                return fe.stylize(Date.prototype.toString.call(xe), "date");
              if (ee(xe))
                return h(xe);
            }
            var $e = "", Ve = !1, Ge = ["{", "}"];
            if (S(xe) && (Ve = !0, Ge = ["[", "]"]), ie(xe)) {
              var Ie = xe.name ? ": " + xe.name : "";
              $e = " [Function" + Ie + "]";
            }
            if (J(xe) && ($e = " " + RegExp.prototype.toString.call(xe)), oe(xe) && ($e = " " + Date.prototype.toUTCString.call(xe)), ee(xe) && ($e = " " + h(xe)), He.length === 0 && (!Ve || xe.length == 0))
              return Ge[0] + $e + Ge[1];
            if (Ee < 0)
              return J(xe) ? fe.stylize(RegExp.prototype.toString.call(xe), "regexp") : fe.stylize("[Object]", "special");
            fe.seen.push(xe);
            var De;
            return Ve ? De = m(fe, xe, Ee, We, He) : De = He.map(function(Ne) {
              return s(fe, xe, Ee, We, Ne, Ve);
            }), fe.seen.pop(), b(De, $e, Ge);
          }
          function g(fe, xe) {
            if (U(xe))
              return fe.stylize("undefined", "undefined");
            if (L(xe)) {
              var Ee = "'" + JSON.stringify(xe).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return fe.stylize(Ee, "string");
            }
            if (I(xe))
              return fe.stylize("" + xe, "number");
            if (o(xe))
              return fe.stylize("" + xe, "boolean");
            if (A(xe))
              return fe.stylize("null", "null");
          }
          function h(fe) {
            return "[" + Error.prototype.toString.call(fe) + "]";
          }
          function m(fe, xe, Ee, Pe, Ue) {
            for (var He = [], We = 0, Ze = xe.length; We < Ze; ++We)
              Me(xe, String(We)) ? He.push(s(
                fe,
                xe,
                Ee,
                Pe,
                String(We),
                !0
              )) : He.push("");
            return Ue.forEach(function($e) {
              $e.match(/^\d+$/) || He.push(s(
                fe,
                xe,
                Ee,
                Pe,
                $e,
                !0
              ));
            }), He;
          }
          function s(fe, xe, Ee, Pe, Ue, He) {
            var We, Ze, $e;
            if ($e = Object.getOwnPropertyDescriptor(xe, Ue) || { value: xe[Ue] }, $e.get ? $e.set ? Ze = fe.stylize("[Getter/Setter]", "special") : Ze = fe.stylize("[Getter]", "special") : $e.set && (Ze = fe.stylize("[Setter]", "special")), Me(Pe, Ue) || (We = "[" + Ue + "]"), Ze || (fe.seen.indexOf($e.value) < 0 ? (A(Ee) ? Ze = d(fe, $e.value, null) : Ze = d(fe, $e.value, Ee - 1), Ze.indexOf(`
`) > -1 && (He ? Ze = Ze.split(`
`).map(function(Ve) {
              return "  " + Ve;
            }).join(`
`).substr(2) : Ze = `
` + Ze.split(`
`).map(function(Ve) {
              return "   " + Ve;
            }).join(`
`))) : Ze = fe.stylize("[Circular]", "special")), U(We)) {
              if (He && Ue.match(/^\d+$/))
                return Ze;
              We = JSON.stringify("" + Ue), We.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (We = We.substr(1, We.length - 2), We = fe.stylize(We, "name")) : (We = We.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), We = fe.stylize(We, "string"));
            }
            return We + ": " + Ze;
          }
          function b(fe, xe, Ee) {
            var Pe = fe.reduce(function(Ue, He) {
              return He.indexOf(`
`) >= 0, Ue + He.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return Pe > 60 ? Ee[0] + (xe === "" ? "" : xe + `
 `) + " " + fe.join(`,
  `) + " " + Ee[1] : Ee[0] + xe + " " + fe.join(", ") + " " + Ee[1];
          }
          function S(fe) {
            return Array.isArray(fe);
          }
          _.isArray = S;
          function o(fe) {
            return typeof fe == "boolean";
          }
          _.isBoolean = o;
          function A(fe) {
            return fe === null;
          }
          _.isNull = A;
          function T(fe) {
            return fe == null;
          }
          _.isNullOrUndefined = T;
          function I(fe) {
            return typeof fe == "number";
          }
          _.isNumber = I;
          function L(fe) {
            return typeof fe == "string";
          }
          _.isString = L;
          function z(fe) {
            return typeof fe == "symbol";
          }
          _.isSymbol = z;
          function U(fe) {
            return fe === void 0;
          }
          _.isUndefined = U;
          function J(fe) {
            return F(fe) && Q(fe) === "[object RegExp]";
          }
          _.isRegExp = J;
          function F(fe) {
            return typeof fe == "object" && fe !== null;
          }
          _.isObject = F;
          function oe(fe) {
            return F(fe) && Q(fe) === "[object Date]";
          }
          _.isDate = oe;
          function ee(fe) {
            return F(fe) && (Q(fe) === "[object Error]" || fe instanceof Error);
          }
          _.isError = ee;
          function ie(fe) {
            return typeof fe == "function";
          }
          _.isFunction = ie;
          function W(fe) {
            return fe === null || typeof fe == "boolean" || typeof fe == "number" || typeof fe == "string" || typeof fe == "symbol" || // ES6 symbol
            typeof fe > "u";
          }
          _.isPrimitive = W, _.isBuffer = k("./support/isBuffer");
          function Q(fe) {
            return Object.prototype.toString.call(fe);
          }
          function de(fe) {
            return fe < 10 ? "0" + fe.toString(10) : fe.toString(10);
          }
          var we = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function ke() {
            var fe = /* @__PURE__ */ new Date(), xe = [
              de(fe.getHours()),
              de(fe.getMinutes()),
              de(fe.getSeconds())
            ].join(":");
            return [fe.getDate(), we[fe.getMonth()], xe].join(" ");
          }
          _.log = function() {
            console.log("%s - %s", ke(), _.format.apply(_, arguments));
          }, _.inherits = k("inherits"), _._extend = function(fe, xe) {
            if (!xe || !F(xe)) return fe;
            for (var Ee = Object.keys(xe), Pe = Ee.length; Pe--; )
              fe[Ee[Pe]] = xe[Ee[Pe]];
            return fe;
          };
          function Me(fe, xe) {
            return Object.prototype.hasOwnProperty.call(fe, xe);
          }
        }).call(this, k("_process"), typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {});
      }, { "./support/isBuffer": 27, _process: 133, inherits: 26 }], 29: [function(k, Z, _) {
        _.byteLength = a, _.toByteArray = d, _.fromByteArray = m;
        for (var M = [], x = [], y = typeof Uint8Array < "u" ? Uint8Array : Array, E = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", c = 0, u = E.length; c < u; ++c)
          M[c] = E[c], x[E.charCodeAt(c)] = c;
        x[45] = 62, x[95] = 63;
        function l(s) {
          var b = s.length;
          if (b % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var S = s.indexOf("=");
          S === -1 && (S = b);
          var o = S === b ? 0 : 4 - S % 4;
          return [S, o];
        }
        function a(s) {
          var b = l(s), S = b[0], o = b[1];
          return (S + o) * 3 / 4 - o;
        }
        function n(s, b, S) {
          return (b + S) * 3 / 4 - S;
        }
        function d(s) {
          var b, S = l(s), o = S[0], A = S[1], T = new y(n(s, o, A)), I = 0, L = A > 0 ? o - 4 : o, z;
          for (z = 0; z < L; z += 4)
            b = x[s.charCodeAt(z)] << 18 | x[s.charCodeAt(z + 1)] << 12 | x[s.charCodeAt(z + 2)] << 6 | x[s.charCodeAt(z + 3)], T[I++] = b >> 16 & 255, T[I++] = b >> 8 & 255, T[I++] = b & 255;
          return A === 2 && (b = x[s.charCodeAt(z)] << 2 | x[s.charCodeAt(z + 1)] >> 4, T[I++] = b & 255), A === 1 && (b = x[s.charCodeAt(z)] << 10 | x[s.charCodeAt(z + 1)] << 4 | x[s.charCodeAt(z + 2)] >> 2, T[I++] = b >> 8 & 255, T[I++] = b & 255), T;
        }
        function g(s) {
          return M[s >> 18 & 63] + M[s >> 12 & 63] + M[s >> 6 & 63] + M[s & 63];
        }
        function h(s, b, S) {
          for (var o, A = [], T = b; T < S; T += 3)
            o = (s[T] << 16 & 16711680) + (s[T + 1] << 8 & 65280) + (s[T + 2] & 255), A.push(g(o));
          return A.join("");
        }
        function m(s) {
          for (var b, S = s.length, o = S % 3, A = [], T = 16383, I = 0, L = S - o; I < L; I += T)
            A.push(h(
              s,
              I,
              I + T > L ? L : I + T
            ));
          return o === 1 ? (b = s[S - 1], A.push(
            M[b >> 2] + M[b << 4 & 63] + "=="
          )) : o === 2 && (b = (s[S - 2] << 8) + s[S - 1], A.push(
            M[b >> 10] + M[b >> 4 & 63] + M[b << 2 & 63] + "="
          )), A.join("");
        }
      }, {}], 30: [function(k, Z, _) {
        var M = k("./lib/encoder"), x = k("./lib/decoder");
        Z.exports = {
          encode: M,
          decode: x
        };
      }, { "./lib/decoder": 31, "./lib/encoder": 32 }], 31: [function(k, Z, _) {
        (function(M) {
          function x(y, E) {
            if (this.pos = 0, this.buffer = y, this.is_with_alpha = !!E, this.bottom_up = !0, this.flag = this.buffer.toString("utf-8", 0, this.pos += 2), this.flag != "BM") throw new Error("Invalid BMP File");
            this.parseHeader(), this.parseRGBA();
          }
          x.prototype.parseHeader = function() {
            if (this.fileSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.reserved = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.offset = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.headerSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.width = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.height = this.buffer.readInt32LE(this.pos), this.pos += 4, this.planes = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.bitPP = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.compress = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.rawSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.hr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.vr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.colors = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.importantColors = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
              var y = this.colors === 0 ? 1 << this.bitPP : this.colors;
              this.palette = new Array(y);
              for (var E = 0; E < y; E++) {
                var c = this.buffer.readUInt8(this.pos++), u = this.buffer.readUInt8(this.pos++), l = this.buffer.readUInt8(this.pos++), a = this.buffer.readUInt8(this.pos++);
                this.palette[E] = {
                  red: l,
                  green: u,
                  blue: c,
                  quad: a
                };
              }
            }
            this.height < 0 && (this.height *= -1, this.bottom_up = !1);
          }, x.prototype.parseRGBA = function() {
            var y = "bit" + this.bitPP, E = this.width * this.height * 4;
            this.data = new M(E), this[y]();
          }, x.prototype.bit1 = function() {
            for (var y = Math.ceil(this.width / 8), E = y % 4, c = this.height >= 0 ? this.height - 1 : -this.height, c = this.height - 1; c >= 0; c--) {
              for (var u = this.bottom_up ? c : this.height - 1 - c, l = 0; l < y; l++)
                for (var a = this.buffer.readUInt8(this.pos++), n = u * this.width * 4 + l * 8 * 4, d = 0; d < 8 && l * 8 + d < this.width; d++) {
                  var g = this.palette[a >> 7 - d & 1];
                  this.data[n + d * 4] = 0, this.data[n + d * 4 + 1] = g.blue, this.data[n + d * 4 + 2] = g.green, this.data[n + d * 4 + 3] = g.red;
                }
              E != 0 && (this.pos += 4 - E);
            }
          }, x.prototype.bit4 = function() {
            if (this.compress == 2) {
              let A = function(T) {
                var I = this.palette[T];
                this.data[y] = 0, this.data[y + 1] = I.blue, this.data[y + 2] = I.green, this.data[y + 3] = I.red, y += 4;
              };
              this.data.fill(255);
              for (var y = 0, E = this.bottom_up ? this.height - 1 : 0, c = !1; y < this.data.length; ) {
                var u = this.buffer.readUInt8(this.pos++), l = this.buffer.readUInt8(this.pos++);
                if (u == 0)
                  if (l == 0) {
                    this.bottom_up ? E-- : E++, y = E * this.width * 4, c = !1;
                    continue;
                  } else {
                    if (l == 1)
                      break;
                    if (l == 2) {
                      var a = this.buffer.readUInt8(this.pos++), n = this.buffer.readUInt8(this.pos++);
                      this.bottom_up ? E -= n : E += n, y += n * this.width * 4 + a * 4;
                    } else {
                      for (var d = this.buffer.readUInt8(this.pos++), g = 0; g < l; g++)
                        c ? A.call(this, d & 15) : A.call(this, (d & 240) >> 4), g & 1 && g + 1 < l && (d = this.buffer.readUInt8(this.pos++)), c = !c;
                      (l + 1 >> 1 & 1) == 1 && this.pos++;
                    }
                  }
                else
                  for (var g = 0; g < u; g++)
                    c ? A.call(this, l & 15) : A.call(this, (l & 240) >> 4), c = !c;
              }
            } else
              for (var h = Math.ceil(this.width / 2), m = h % 4, n = this.height - 1; n >= 0; n--) {
                for (var s = this.bottom_up ? n : this.height - 1 - n, a = 0; a < h; a++) {
                  var l = this.buffer.readUInt8(this.pos++), y = s * this.width * 4 + a * 2 * 4, b = l >> 4, S = l & 15, o = this.palette[b];
                  if (this.data[y] = 0, this.data[y + 1] = o.blue, this.data[y + 2] = o.green, this.data[y + 3] = o.red, a * 2 + 1 >= this.width) break;
                  o = this.palette[S], this.data[y + 4] = 0, this.data[y + 4 + 1] = o.blue, this.data[y + 4 + 2] = o.green, this.data[y + 4 + 3] = o.red;
                }
                m != 0 && (this.pos += 4 - m);
              }
          }, x.prototype.bit8 = function() {
            if (this.compress == 1) {
              let s = function(b) {
                var S = this.palette[b];
                this.data[y] = 0, this.data[y + 1] = S.blue, this.data[y + 2] = S.green, this.data[y + 3] = S.red, y += 4;
              };
              this.data.fill(255);
              for (var y = 0, E = this.bottom_up ? this.height - 1 : 0; y < this.data.length; ) {
                var c = this.buffer.readUInt8(this.pos++), u = this.buffer.readUInt8(this.pos++);
                if (c == 0)
                  if (u == 0) {
                    this.bottom_up ? E-- : E++, y = E * this.width * 4;
                    continue;
                  } else {
                    if (u == 1)
                      break;
                    if (u == 2) {
                      var l = this.buffer.readUInt8(this.pos++), a = this.buffer.readUInt8(this.pos++);
                      this.bottom_up ? E -= a : E += a, y += a * this.width * 4 + l * 4;
                    } else {
                      for (var n = 0; n < u; n++) {
                        var d = this.buffer.readUInt8(this.pos++);
                        s.call(this, d);
                      }
                      u & !0 && this.pos++;
                    }
                  }
                else
                  for (var n = 0; n < c; n++)
                    s.call(this, u);
              }
            } else
              for (var g = this.width % 4, a = this.height - 1; a >= 0; a--) {
                for (var h = this.bottom_up ? a : this.height - 1 - a, l = 0; l < this.width; l++) {
                  var u = this.buffer.readUInt8(this.pos++), y = h * this.width * 4 + l * 4;
                  if (u < this.palette.length) {
                    var m = this.palette[u];
                    this.data[y] = 0, this.data[y + 1] = m.blue, this.data[y + 2] = m.green, this.data[y + 3] = m.red;
                  } else
                    this.data[y] = 0, this.data[y + 1] = 255, this.data[y + 2] = 255, this.data[y + 3] = 255;
                }
                g != 0 && (this.pos += 4 - g);
              }
          }, x.prototype.bit15 = function() {
            for (var y = this.width % 3, E = parseInt("11111", 2), c = E, u = this.height - 1; u >= 0; u--) {
              for (var l = this.bottom_up ? u : this.height - 1 - u, a = 0; a < this.width; a++) {
                var n = this.buffer.readUInt16LE(this.pos);
                this.pos += 2;
                var d = (n & c) / c * 255 | 0, g = (n >> 5 & c) / c * 255 | 0, h = (n >> 10 & c) / c * 255 | 0, m = n >> 15 ? 255 : 0, s = l * this.width * 4 + a * 4;
                this.data[s] = m, this.data[s + 1] = d, this.data[s + 2] = g, this.data[s + 3] = h;
              }
              this.pos += y;
            }
          }, x.prototype.bit16 = function() {
            var y = this.width % 2 * 2;
            this.maskRed = 31744, this.maskGreen = 992, this.maskBlue = 31, this.mask0 = 0, this.compress == 3 && (this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4);
            for (var E = [0, 0, 0], c = 0; c < 16; c++)
              this.maskRed >> c & 1 && E[0]++, this.maskGreen >> c & 1 && E[1]++, this.maskBlue >> c & 1 && E[2]++;
            E[1] += E[0], E[2] += E[1], E[0] = 8 - E[0], E[1] -= 8, E[2] -= 8;
            for (var u = this.height - 1; u >= 0; u--) {
              for (var l = this.bottom_up ? u : this.height - 1 - u, a = 0; a < this.width; a++) {
                var n = this.buffer.readUInt16LE(this.pos);
                this.pos += 2;
                var d = (n & this.maskBlue) << E[0], g = (n & this.maskGreen) >> E[1], h = (n & this.maskRed) >> E[2], m = l * this.width * 4 + a * 4;
                this.data[m] = 0, this.data[m + 1] = d, this.data[m + 2] = g, this.data[m + 3] = h;
              }
              this.pos += y;
            }
          }, x.prototype.bit24 = function() {
            for (var y = this.height - 1; y >= 0; y--) {
              for (var E = this.bottom_up ? y : this.height - 1 - y, c = 0; c < this.width; c++) {
                var u = this.buffer.readUInt8(this.pos++), l = this.buffer.readUInt8(this.pos++), a = this.buffer.readUInt8(this.pos++), n = E * this.width * 4 + c * 4;
                this.data[n] = 0, this.data[n + 1] = u, this.data[n + 2] = l, this.data[n + 3] = a;
              }
              this.pos += this.width % 4;
            }
          }, x.prototype.bit32 = function() {
            if (this.compress == 3) {
              this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4;
              for (var y = this.height - 1; y >= 0; y--)
                for (var E = this.bottom_up ? y : this.height - 1 - y, c = 0; c < this.width; c++) {
                  var u = this.buffer.readUInt8(this.pos++), l = this.buffer.readUInt8(this.pos++), a = this.buffer.readUInt8(this.pos++), n = this.buffer.readUInt8(this.pos++), d = E * this.width * 4 + c * 4;
                  this.data[d] = u, this.data[d + 1] = l, this.data[d + 2] = a, this.data[d + 3] = n;
                }
            } else
              for (var y = this.height - 1; y >= 0; y--)
                for (var E = this.bottom_up ? y : this.height - 1 - y, c = 0; c < this.width; c++) {
                  var l = this.buffer.readUInt8(this.pos++), a = this.buffer.readUInt8(this.pos++), n = this.buffer.readUInt8(this.pos++), u = this.buffer.readUInt8(this.pos++), d = E * this.width * 4 + c * 4;
                  this.data[d] = u, this.data[d + 1] = l, this.data[d + 2] = a, this.data[d + 3] = n;
                }
          }, x.prototype.getData = function() {
            return this.data;
          }, Z.exports = function(y) {
            var E = new x(y);
            return E;
          };
        }).call(this, k("buffer").Buffer);
      }, { buffer: 48 }], 32: [function(k, Z, _) {
        (function(M) {
          function x(y) {
            this.buffer = y.data, this.width = y.width, this.height = y.height, this.extraBytes = this.width % 4, this.rgbSize = this.height * (3 * this.width + this.extraBytes), this.headerInfoSize = 40, this.data = [], this.flag = "BM", this.reserved = 0, this.offset = 54, this.fileSize = this.rgbSize + this.offset, this.planes = 1, this.bitPP = 24, this.compress = 0, this.hr = 0, this.vr = 0, this.colors = 0, this.importantColors = 0;
          }
          x.prototype.encode = function() {
            var y = new M(this.offset + this.rgbSize);
            this.pos = 0, y.write(this.flag, this.pos, 2), this.pos += 2, y.writeUInt32LE(this.fileSize, this.pos), this.pos += 4, y.writeUInt32LE(this.reserved, this.pos), this.pos += 4, y.writeUInt32LE(this.offset, this.pos), this.pos += 4, y.writeUInt32LE(this.headerInfoSize, this.pos), this.pos += 4, y.writeUInt32LE(this.width, this.pos), this.pos += 4, y.writeInt32LE(-this.height, this.pos), this.pos += 4, y.writeUInt16LE(this.planes, this.pos), this.pos += 2, y.writeUInt16LE(this.bitPP, this.pos), this.pos += 2, y.writeUInt32LE(this.compress, this.pos), this.pos += 4, y.writeUInt32LE(this.rgbSize, this.pos), this.pos += 4, y.writeUInt32LE(this.hr, this.pos), this.pos += 4, y.writeUInt32LE(this.vr, this.pos), this.pos += 4, y.writeUInt32LE(this.colors, this.pos), this.pos += 4, y.writeUInt32LE(this.importantColors, this.pos), this.pos += 4;
            for (var E = 0, c = 3 * this.width + this.extraBytes, u = 0; u < this.height; u++) {
              for (var l = 0; l < this.width; l++) {
                var a = this.pos + u * c + l * 3;
                E++, y[a] = this.buffer[E++], y[a + 1] = this.buffer[E++], y[a + 2] = this.buffer[E++];
              }
              if (this.extraBytes > 0) {
                var n = this.pos + u * c + this.width * 3;
                y.fill(0, n, n + this.extraBytes);
              }
            }
            return y;
          }, Z.exports = function(y, E) {
            var c = new x(y), u = c.encode();
            return {
              data: u,
              width: y.width,
              height: y.height
            };
          };
        }).call(this, k("buffer").Buffer);
      }, { buffer: 48 }], 33: [function(k, Z, _) {
      }, {}], 34: [function(k, Z, _) {
        (function(M, x) {
          var y = k("assert"), E = k("pako/lib/zlib/zstream"), c = k("pako/lib/zlib/deflate.js"), u = k("pako/lib/zlib/inflate.js"), l = k("pako/lib/zlib/constants");
          for (var a in l)
            _[a] = l[a];
          _.NONE = 0, _.DEFLATE = 1, _.INFLATE = 2, _.GZIP = 3, _.GUNZIP = 4, _.DEFLATERAW = 5, _.INFLATERAW = 6, _.UNZIP = 7;
          var n = 31, d = 139;
          function g(h) {
            if (typeof h != "number" || h < _.DEFLATE || h > _.UNZIP)
              throw new TypeError("Bad argument");
            this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = h, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
          }
          g.prototype.close = function() {
            if (this.write_in_progress) {
              this.pending_close = !0;
              return;
            }
            this.pending_close = !1, y(this.init_done, "close before init"), y(this.mode <= _.UNZIP), this.mode === _.DEFLATE || this.mode === _.GZIP || this.mode === _.DEFLATERAW ? c.deflateEnd(this.strm) : (this.mode === _.INFLATE || this.mode === _.GUNZIP || this.mode === _.INFLATERAW || this.mode === _.UNZIP) && u.inflateEnd(this.strm), this.mode = _.NONE, this.dictionary = null;
          }, g.prototype.write = function(h, m, s, b, S, o, A) {
            return this._write(!0, h, m, s, b, S, o, A);
          }, g.prototype.writeSync = function(h, m, s, b, S, o, A) {
            return this._write(!1, h, m, s, b, S, o, A);
          }, g.prototype._write = function(h, m, s, b, S, o, A, T) {
            if (y.equal(arguments.length, 8), y(this.init_done, "write before init"), y(this.mode !== _.NONE, "already finalized"), y.equal(!1, this.write_in_progress, "write already in progress"), y.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, y.equal(!1, m === void 0, "must provide flush value"), this.write_in_progress = !0, m !== _.Z_NO_FLUSH && m !== _.Z_PARTIAL_FLUSH && m !== _.Z_SYNC_FLUSH && m !== _.Z_FULL_FLUSH && m !== _.Z_FINISH && m !== _.Z_BLOCK)
              throw new Error("Invalid flush value");
            if (s == null && (s = x.alloc(0), S = 0, b = 0), this.strm.avail_in = S, this.strm.input = s, this.strm.next_in = b, this.strm.avail_out = T, this.strm.output = o, this.strm.next_out = A, this.flush = m, !h)
              return this._process(), this._checkError() ? this._afterSync() : void 0;
            var I = this;
            return M.nextTick(function() {
              I._process(), I._after();
            }), this;
          }, g.prototype._afterSync = function() {
            var h = this.strm.avail_out, m = this.strm.avail_in;
            return this.write_in_progress = !1, [m, h];
          }, g.prototype._process = function() {
            var h = null;
            switch (this.mode) {
              case _.DEFLATE:
              case _.GZIP:
              case _.DEFLATERAW:
                this.err = c.deflate(this.strm, this.flush);
                break;
              case _.UNZIP:
                switch (this.strm.avail_in > 0 && (h = this.strm.next_in), this.gzip_id_bytes_read) {
                  case 0:
                    if (h === null)
                      break;
                    if (this.strm.input[h] === n) {
                      if (this.gzip_id_bytes_read = 1, h++, this.strm.avail_in === 1)
                        break;
                    } else {
                      this.mode = _.INFLATE;
                      break;
                    }
                  // fallthrough
                  case 1:
                    if (h === null)
                      break;
                    this.strm.input[h] === d ? (this.gzip_id_bytes_read = 2, this.mode = _.GUNZIP) : this.mode = _.INFLATE;
                    break;
                  default:
                    throw new Error("invalid number of gzip magic number bytes read");
                }
              // fallthrough
              case _.INFLATE:
              case _.GUNZIP:
              case _.INFLATERAW:
                for (this.err = u.inflate(
                  this.strm,
                  this.flush
                  // If data was encoded with dictionary
                ), this.err === _.Z_NEED_DICT && this.dictionary && (this.err = u.inflateSetDictionary(this.strm, this.dictionary), this.err === _.Z_OK ? this.err = u.inflate(this.strm, this.flush) : this.err === _.Z_DATA_ERROR && (this.err = _.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === _.GUNZIP && this.err === _.Z_STREAM_END && this.strm.next_in[0] !== 0; )
                  this.reset(), this.err = u.inflate(this.strm, this.flush);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
          }, g.prototype._checkError = function() {
            switch (this.err) {
              case _.Z_OK:
              case _.Z_BUF_ERROR:
                if (this.strm.avail_out !== 0 && this.flush === _.Z_FINISH)
                  return this._error("unexpected end of file"), !1;
                break;
              case _.Z_STREAM_END:
                break;
              case _.Z_NEED_DICT:
                return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
              default:
                return this._error("Zlib error"), !1;
            }
            return !0;
          }, g.prototype._after = function() {
            if (this._checkError()) {
              var h = this.strm.avail_out, m = this.strm.avail_in;
              this.write_in_progress = !1, this.callback(m, h), this.pending_close && this.close();
            }
          }, g.prototype._error = function(h) {
            this.strm.msg && (h = this.strm.msg), this.onerror(
              h,
              this.err
              // no hope of rescue.
            ), this.write_in_progress = !1, this.pending_close && this.close();
          }, g.prototype.init = function(h, m, s, b, S) {
            y(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), y(h >= 8 && h <= 15, "invalid windowBits"), y(m >= -1 && m <= 9, "invalid compression level"), y(s >= 1 && s <= 9, "invalid memlevel"), y(b === _.Z_FILTERED || b === _.Z_HUFFMAN_ONLY || b === _.Z_RLE || b === _.Z_FIXED || b === _.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(m, h, s, b, S), this._setDictionary();
          }, g.prototype.params = function() {
            throw new Error("deflateParams Not supported");
          }, g.prototype.reset = function() {
            this._reset(), this._setDictionary();
          }, g.prototype._init = function(h, m, s, b, S) {
            switch (this.level = h, this.windowBits = m, this.memLevel = s, this.strategy = b, this.flush = _.Z_NO_FLUSH, this.err = _.Z_OK, (this.mode === _.GZIP || this.mode === _.GUNZIP) && (this.windowBits += 16), this.mode === _.UNZIP && (this.windowBits += 32), (this.mode === _.DEFLATERAW || this.mode === _.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new E(), this.mode) {
              case _.DEFLATE:
              case _.GZIP:
              case _.DEFLATERAW:
                this.err = c.deflateInit2(this.strm, this.level, _.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                break;
              case _.INFLATE:
              case _.GUNZIP:
              case _.INFLATERAW:
              case _.UNZIP:
                this.err = u.inflateInit2(this.strm, this.windowBits);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
            this.err !== _.Z_OK && this._error("Init error"), this.dictionary = S, this.write_in_progress = !1, this.init_done = !0;
          }, g.prototype._setDictionary = function() {
            if (this.dictionary != null) {
              switch (this.err = _.Z_OK, this.mode) {
                case _.DEFLATE:
                case _.DEFLATERAW:
                  this.err = c.deflateSetDictionary(this.strm, this.dictionary);
                  break;
              }
              this.err !== _.Z_OK && this._error("Failed to set dictionary");
            }
          }, g.prototype._reset = function() {
            switch (this.err = _.Z_OK, this.mode) {
              case _.DEFLATE:
              case _.DEFLATERAW:
              case _.GZIP:
                this.err = c.deflateReset(this.strm);
                break;
              case _.INFLATE:
              case _.INFLATERAW:
              case _.GUNZIP:
                this.err = u.inflateReset(this.strm);
                break;
            }
            this.err !== _.Z_OK && this._error("Failed to reset stream");
          }, _.Zlib = g;
        }).call(this, k("_process"), k("buffer").Buffer);
      }, { _process: 133, assert: 25, buffer: 48, "pako/lib/zlib/constants": 38, "pako/lib/zlib/deflate.js": 40, "pako/lib/zlib/inflate.js": 42, "pako/lib/zlib/zstream": 46 }], 35: [function(k, Z, _) {
        (function(M) {
          var x = k("buffer").Buffer, y = k("stream").Transform, E = k("./binding"), c = k("util"), u = k("assert").ok, l = k("buffer").kMaxLength, a = "Cannot create final Buffer. It would be larger than 0x" + l.toString(16) + " bytes";
          E.Z_MIN_WINDOWBITS = 8, E.Z_MAX_WINDOWBITS = 15, E.Z_DEFAULT_WINDOWBITS = 15, E.Z_MIN_CHUNK = 64, E.Z_MAX_CHUNK = 1 / 0, E.Z_DEFAULT_CHUNK = 16 * 1024, E.Z_MIN_MEMLEVEL = 1, E.Z_MAX_MEMLEVEL = 9, E.Z_DEFAULT_MEMLEVEL = 8, E.Z_MIN_LEVEL = -1, E.Z_MAX_LEVEL = 9, E.Z_DEFAULT_LEVEL = E.Z_DEFAULT_COMPRESSION;
          for (var n = Object.keys(E), d = 0; d < n.length; d++) {
            var g = n[d];
            g.match(/^Z/) && Object.defineProperty(_, g, {
              enumerable: !0,
              value: E[g],
              writable: !1
            });
          }
          for (var h = {
            Z_OK: E.Z_OK,
            Z_STREAM_END: E.Z_STREAM_END,
            Z_NEED_DICT: E.Z_NEED_DICT,
            Z_ERRNO: E.Z_ERRNO,
            Z_STREAM_ERROR: E.Z_STREAM_ERROR,
            Z_DATA_ERROR: E.Z_DATA_ERROR,
            Z_MEM_ERROR: E.Z_MEM_ERROR,
            Z_BUF_ERROR: E.Z_BUF_ERROR,
            Z_VERSION_ERROR: E.Z_VERSION_ERROR
          }, m = Object.keys(h), s = 0; s < m.length; s++) {
            var b = m[s];
            h[h[b]] = b;
          }
          Object.defineProperty(_, "codes", {
            enumerable: !0,
            value: Object.freeze(h),
            writable: !1
          }), _.Deflate = A, _.Inflate = T, _.Gzip = I, _.Gunzip = L, _.DeflateRaw = z, _.InflateRaw = U, _.Unzip = J, _.createDeflate = function(W) {
            return new A(W);
          }, _.createInflate = function(W) {
            return new T(W);
          }, _.createDeflateRaw = function(W) {
            return new z(W);
          }, _.createInflateRaw = function(W) {
            return new U(W);
          }, _.createGzip = function(W) {
            return new I(W);
          }, _.createGunzip = function(W) {
            return new L(W);
          }, _.createUnzip = function(W) {
            return new J(W);
          }, _.deflate = function(W, Q, de) {
            return typeof Q == "function" && (de = Q, Q = {}), S(new A(Q), W, de);
          }, _.deflateSync = function(W, Q) {
            return o(new A(Q), W);
          }, _.gzip = function(W, Q, de) {
            return typeof Q == "function" && (de = Q, Q = {}), S(new I(Q), W, de);
          }, _.gzipSync = function(W, Q) {
            return o(new I(Q), W);
          }, _.deflateRaw = function(W, Q, de) {
            return typeof Q == "function" && (de = Q, Q = {}), S(new z(Q), W, de);
          }, _.deflateRawSync = function(W, Q) {
            return o(new z(Q), W);
          }, _.unzip = function(W, Q, de) {
            return typeof Q == "function" && (de = Q, Q = {}), S(new J(Q), W, de);
          }, _.unzipSync = function(W, Q) {
            return o(new J(Q), W);
          }, _.inflate = function(W, Q, de) {
            return typeof Q == "function" && (de = Q, Q = {}), S(new T(Q), W, de);
          }, _.inflateSync = function(W, Q) {
            return o(new T(Q), W);
          }, _.gunzip = function(W, Q, de) {
            return typeof Q == "function" && (de = Q, Q = {}), S(new L(Q), W, de);
          }, _.gunzipSync = function(W, Q) {
            return o(new L(Q), W);
          }, _.inflateRaw = function(W, Q, de) {
            return typeof Q == "function" && (de = Q, Q = {}), S(new U(Q), W, de);
          }, _.inflateRawSync = function(W, Q) {
            return o(new U(Q), W);
          };
          function S(W, Q, de) {
            var we = [], ke = 0;
            W.on("error", fe), W.on("end", xe), W.end(Q), Me();
            function Me() {
              for (var Ee; (Ee = W.read()) !== null; )
                we.push(Ee), ke += Ee.length;
              W.once("readable", Me);
            }
            function fe(Ee) {
              W.removeListener("end", xe), W.removeListener("readable", Me), de(Ee);
            }
            function xe() {
              var Ee, Pe = null;
              ke >= l ? Pe = new RangeError(a) : Ee = x.concat(we, ke), we = [], W.close(), de(Pe, Ee);
            }
          }
          function o(W, Q) {
            if (typeof Q == "string" && (Q = x.from(Q)), !x.isBuffer(Q)) throw new TypeError("Not a string or buffer");
            var de = W._finishFlushFlag;
            return W._processChunk(Q, de);
          }
          function A(W) {
            if (!(this instanceof A)) return new A(W);
            oe.call(this, W, E.DEFLATE);
          }
          function T(W) {
            if (!(this instanceof T)) return new T(W);
            oe.call(this, W, E.INFLATE);
          }
          function I(W) {
            if (!(this instanceof I)) return new I(W);
            oe.call(this, W, E.GZIP);
          }
          function L(W) {
            if (!(this instanceof L)) return new L(W);
            oe.call(this, W, E.GUNZIP);
          }
          function z(W) {
            if (!(this instanceof z)) return new z(W);
            oe.call(this, W, E.DEFLATERAW);
          }
          function U(W) {
            if (!(this instanceof U)) return new U(W);
            oe.call(this, W, E.INFLATERAW);
          }
          function J(W) {
            if (!(this instanceof J)) return new J(W);
            oe.call(this, W, E.UNZIP);
          }
          function F(W) {
            return W === E.Z_NO_FLUSH || W === E.Z_PARTIAL_FLUSH || W === E.Z_SYNC_FLUSH || W === E.Z_FULL_FLUSH || W === E.Z_FINISH || W === E.Z_BLOCK;
          }
          function oe(W, Q) {
            var de = this;
            if (this._opts = W = W || {}, this._chunkSize = W.chunkSize || _.Z_DEFAULT_CHUNK, y.call(this, W), W.flush && !F(W.flush))
              throw new Error("Invalid flush flag: " + W.flush);
            if (W.finishFlush && !F(W.finishFlush))
              throw new Error("Invalid flush flag: " + W.finishFlush);
            if (this._flushFlag = W.flush || E.Z_NO_FLUSH, this._finishFlushFlag = typeof W.finishFlush < "u" ? W.finishFlush : E.Z_FINISH, W.chunkSize && (W.chunkSize < _.Z_MIN_CHUNK || W.chunkSize > _.Z_MAX_CHUNK))
              throw new Error("Invalid chunk size: " + W.chunkSize);
            if (W.windowBits && (W.windowBits < _.Z_MIN_WINDOWBITS || W.windowBits > _.Z_MAX_WINDOWBITS))
              throw new Error("Invalid windowBits: " + W.windowBits);
            if (W.level && (W.level < _.Z_MIN_LEVEL || W.level > _.Z_MAX_LEVEL))
              throw new Error("Invalid compression level: " + W.level);
            if (W.memLevel && (W.memLevel < _.Z_MIN_MEMLEVEL || W.memLevel > _.Z_MAX_MEMLEVEL))
              throw new Error("Invalid memLevel: " + W.memLevel);
            if (W.strategy && W.strategy != _.Z_FILTERED && W.strategy != _.Z_HUFFMAN_ONLY && W.strategy != _.Z_RLE && W.strategy != _.Z_FIXED && W.strategy != _.Z_DEFAULT_STRATEGY)
              throw new Error("Invalid strategy: " + W.strategy);
            if (W.dictionary && !x.isBuffer(W.dictionary))
              throw new Error("Invalid dictionary: it should be a Buffer instance");
            this._handle = new E.Zlib(Q);
            var we = this;
            this._hadError = !1, this._handle.onerror = function(fe, xe) {
              ee(we), we._hadError = !0;
              var Ee = new Error(fe);
              Ee.errno = xe, Ee.code = _.codes[xe], we.emit("error", Ee);
            };
            var ke = _.Z_DEFAULT_COMPRESSION;
            typeof W.level == "number" && (ke = W.level);
            var Me = _.Z_DEFAULT_STRATEGY;
            typeof W.strategy == "number" && (Me = W.strategy), this._handle.init(W.windowBits || _.Z_DEFAULT_WINDOWBITS, ke, W.memLevel || _.Z_DEFAULT_MEMLEVEL, Me, W.dictionary), this._buffer = x.allocUnsafe(this._chunkSize), this._offset = 0, this._level = ke, this._strategy = Me, this.once("end", this.close), Object.defineProperty(this, "_closed", {
              get: function() {
                return !de._handle;
              },
              configurable: !0,
              enumerable: !0
            });
          }
          c.inherits(oe, y), oe.prototype.params = function(W, Q, de) {
            if (W < _.Z_MIN_LEVEL || W > _.Z_MAX_LEVEL)
              throw new RangeError("Invalid compression level: " + W);
            if (Q != _.Z_FILTERED && Q != _.Z_HUFFMAN_ONLY && Q != _.Z_RLE && Q != _.Z_FIXED && Q != _.Z_DEFAULT_STRATEGY)
              throw new TypeError("Invalid strategy: " + Q);
            if (this._level !== W || this._strategy !== Q) {
              var we = this;
              this.flush(E.Z_SYNC_FLUSH, function() {
                u(we._handle, "zlib binding closed"), we._handle.params(W, Q), we._hadError || (we._level = W, we._strategy = Q, de && de());
              });
            } else
              M.nextTick(de);
          }, oe.prototype.reset = function() {
            return u(this._handle, "zlib binding closed"), this._handle.reset();
          }, oe.prototype._flush = function(W) {
            this._transform(x.alloc(0), "", W);
          }, oe.prototype.flush = function(W, Q) {
            var de = this, we = this._writableState;
            (typeof W == "function" || W === void 0 && !Q) && (Q = W, W = E.Z_FULL_FLUSH), we.ended ? Q && M.nextTick(Q) : we.ending ? Q && this.once("end", Q) : we.needDrain ? Q && this.once("drain", function() {
              return de.flush(W, Q);
            }) : (this._flushFlag = W, this.write(x.alloc(0), "", Q));
          }, oe.prototype.close = function(W) {
            ee(this, W), M.nextTick(ie, this);
          };
          function ee(W, Q) {
            Q && M.nextTick(Q), W._handle && (W._handle.close(), W._handle = null);
          }
          function ie(W) {
            W.emit("close");
          }
          oe.prototype._transform = function(W, Q, de) {
            var we, ke = this._writableState, Me = ke.ending || ke.ended, fe = Me && (!W || ke.length === W.length);
            if (W !== null && !x.isBuffer(W)) return de(new Error("invalid input"));
            if (!this._handle) return de(new Error("zlib binding closed"));
            fe ? we = this._finishFlushFlag : (we = this._flushFlag, W.length >= ke.length && (this._flushFlag = this._opts.flush || E.Z_NO_FLUSH)), this._processChunk(W, we, de);
          }, oe.prototype._processChunk = function(W, Q, de) {
            var we = W && W.length, ke = this._chunkSize - this._offset, Me = 0, fe = this, xe = typeof de == "function";
            if (!xe) {
              var Ee = [], Pe = 0, Ue;
              this.on("error", function(Ve) {
                Ue = Ve;
              }), u(this._handle, "zlib binding closed");
              do
                var He = this._handle.writeSync(
                  Q,
                  W,
                  // in
                  Me,
                  // in_off
                  we,
                  // in_len
                  this._buffer,
                  // out
                  this._offset,
                  //out_off
                  ke
                );
              while (!this._hadError && $e(He[0], He[1]));
              if (this._hadError)
                throw Ue;
              if (Pe >= l)
                throw ee(this), new RangeError(a);
              var We = x.concat(Ee, Pe);
              return ee(this), We;
            }
            u(this._handle, "zlib binding closed");
            var Ze = this._handle.write(
              Q,
              W,
              // in
              Me,
              // in_off
              we,
              // in_len
              this._buffer,
              // out
              this._offset,
              //out_off
              ke
            );
            Ze.buffer = W, Ze.callback = $e;
            function $e(Ve, Ge) {
              if (this && (this.buffer = null, this.callback = null), !fe._hadError) {
                var Ie = ke - Ge;
                if (u(Ie >= 0, "have should not go down"), Ie > 0) {
                  var De = fe._buffer.slice(fe._offset, fe._offset + Ie);
                  fe._offset += Ie, xe ? fe.push(De) : (Ee.push(De), Pe += De.length);
                }
                if ((Ge === 0 || fe._offset >= fe._chunkSize) && (ke = fe._chunkSize, fe._offset = 0, fe._buffer = x.allocUnsafe(fe._chunkSize)), Ge === 0) {
                  if (Me += we - Ve, we = Ve, !xe) return !0;
                  var Ne = fe._handle.write(Q, W, Me, we, fe._buffer, fe._offset, fe._chunkSize);
                  Ne.callback = $e, Ne.buffer = W;
                  return;
                }
                if (!xe) return !1;
                de();
              }
            }
          }, c.inherits(A, oe), c.inherits(T, oe), c.inherits(I, oe), c.inherits(L, oe), c.inherits(z, oe), c.inherits(U, oe), c.inherits(J, oe);
        }).call(this, k("_process"));
      }, { "./binding": 34, _process: 133, assert: 25, buffer: 48, stream: 155, util: 186 }], 36: [function(k, Z, _) {
        var M = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        function x(c, u) {
          return Object.prototype.hasOwnProperty.call(c, u);
        }
        _.assign = function(c) {
          for (var u = Array.prototype.slice.call(arguments, 1); u.length; ) {
            var l = u.shift();
            if (l) {
              if (typeof l != "object")
                throw new TypeError(l + "must be non-object");
              for (var a in l)
                x(l, a) && (c[a] = l[a]);
            }
          }
          return c;
        }, _.shrinkBuf = function(c, u) {
          return c.length === u ? c : c.subarray ? c.subarray(0, u) : (c.length = u, c);
        };
        var y = {
          arraySet: function(c, u, l, a, n) {
            if (u.subarray && c.subarray) {
              c.set(u.subarray(l, l + a), n);
              return;
            }
            for (var d = 0; d < a; d++)
              c[n + d] = u[l + d];
          },
          // Join array of chunks to single array.
          flattenChunks: function(c) {
            var u, l, a, n, d, g;
            for (a = 0, u = 0, l = c.length; u < l; u++)
              a += c[u].length;
            for (g = new Uint8Array(a), n = 0, u = 0, l = c.length; u < l; u++)
              d = c[u], g.set(d, n), n += d.length;
            return g;
          }
        }, E = {
          arraySet: function(c, u, l, a, n) {
            for (var d = 0; d < a; d++)
              c[n + d] = u[l + d];
          },
          // Join array of chunks to single array.
          flattenChunks: function(c) {
            return [].concat.apply([], c);
          }
        };
        _.setTyped = function(c) {
          c ? (_.Buf8 = Uint8Array, _.Buf16 = Uint16Array, _.Buf32 = Int32Array, _.assign(_, y)) : (_.Buf8 = Array, _.Buf16 = Array, _.Buf32 = Array, _.assign(_, E));
        }, _.setTyped(M);
      }, {}], 37: [function(k, Z, _) {
        function M(x, y, E, c) {
          for (var u = x & 65535 | 0, l = x >>> 16 & 65535 | 0, a = 0; E !== 0; ) {
            a = E > 2e3 ? 2e3 : E, E -= a;
            do
              u = u + y[c++] | 0, l = l + u | 0;
            while (--a);
            u %= 65521, l %= 65521;
          }
          return u | l << 16 | 0;
        }
        Z.exports = M;
      }, {}], 38: [function(k, Z, _) {
        Z.exports = {
          /* Allowed flush values; see deflate() and inflate() below for details */
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          /* Return codes for the compression/decompression functions. Negative values
          * are errors, positive values are used for special but normal events.
          */
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          //Z_MEM_ERROR:     -4,
          Z_BUF_ERROR: -5,
          //Z_VERSION_ERROR: -6,
          /* compression levels */
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          /* Possible values of the data_type field (though see inflate()) */
          Z_BINARY: 0,
          Z_TEXT: 1,
          //Z_ASCII:                1, // = Z_TEXT (deprecated)
          Z_UNKNOWN: 2,
          /* The deflate compression method */
          Z_DEFLATED: 8
          //Z_NULL:                 null // Use -1 or null inline, depending on var type
        };
      }, {}], 39: [function(k, Z, _) {
        function M() {
          for (var E, c = [], u = 0; u < 256; u++) {
            E = u;
            for (var l = 0; l < 8; l++)
              E = E & 1 ? 3988292384 ^ E >>> 1 : E >>> 1;
            c[u] = E;
          }
          return c;
        }
        var x = M();
        function y(E, c, u, l) {
          var a = x, n = l + u;
          E ^= -1;
          for (var d = l; d < n; d++)
            E = E >>> 8 ^ a[(E ^ c[d]) & 255];
          return E ^ -1;
        }
        Z.exports = y;
      }, {}], 40: [function(k, Z, _) {
        var M = k("../utils/common"), x = k("./trees"), y = k("./adler32"), E = k("./crc32"), c = k("./messages"), u = 0, l = 1, a = 3, n = 4, d = 5, g = 0, h = 1, m = -2, s = -3, b = -5, S = -1, o = 1, A = 2, T = 3, I = 4, L = 0, z = 2, U = 8, J = 9, F = 15, oe = 8, ee = 29, ie = 256, W = ie + 1 + ee, Q = 30, de = 19, we = 2 * W + 1, ke = 15, Me = 3, fe = 258, xe = fe + Me + 1, Ee = 32, Pe = 42, Ue = 69, He = 73, We = 91, Ze = 103, $e = 113, Ve = 666, Ge = 1, Ie = 2, De = 3, Ne = 4, _e = 3;
        function re(v, se) {
          return v.msg = c[se], se;
        }
        function $(v) {
          return (v << 1) - (v > 4 ? 9 : 0);
        }
        function Ce(v) {
          for (var se = v.length; --se >= 0; )
            v[se] = 0;
        }
        function ve(v) {
          var se = v.state, me = se.pending;
          me > v.avail_out && (me = v.avail_out), me !== 0 && (M.arraySet(v.output, se.pending_buf, se.pending_out, me, v.next_out), v.next_out += me, se.pending_out += me, v.total_out += me, v.avail_out -= me, se.pending -= me, se.pending === 0 && (se.pending_out = 0));
        }
        function Y(v, se) {
          x._tr_flush_block(v, v.block_start >= 0 ? v.block_start : -1, v.strstart - v.block_start, se), v.block_start = v.strstart, ve(v.strm);
        }
        function G(v, se) {
          v.pending_buf[v.pending++] = se;
        }
        function Ae(v, se) {
          v.pending_buf[v.pending++] = se >>> 8 & 255, v.pending_buf[v.pending++] = se & 255;
        }
        function e(v, se, me, O) {
          var ce = v.avail_in;
          return ce > O && (ce = O), ce === 0 ? 0 : (v.avail_in -= ce, M.arraySet(se, v.input, v.next_in, ce, me), v.state.wrap === 1 ? v.adler = y(v.adler, se, ce, me) : v.state.wrap === 2 && (v.adler = E(v.adler, se, ce, me)), v.next_in += ce, v.total_in += ce, ce);
        }
        function r(v, se) {
          var me = v.max_chain_length, O = v.strstart, ce, Oe, Be = v.prev_length, je = v.nice_match, Fe = v.strstart > v.w_size - xe ? v.strstart - (v.w_size - xe) : 0, Ye = v.window, Ke = v.w_mask, et = v.prev, Je = v.strstart + fe, nt = Ye[O + Be - 1], dt = Ye[O + Be];
          v.prev_length >= v.good_match && (me >>= 2), je > v.lookahead && (je = v.lookahead);
          do
            if (ce = se, !(Ye[ce + Be] !== dt || Ye[ce + Be - 1] !== nt || Ye[ce] !== Ye[O] || Ye[++ce] !== Ye[O + 1])) {
              O += 2, ce++;
              do
                ;
              while (Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && O < Je);
              if (Oe = fe - (Je - O), O = Je - fe, Oe > Be) {
                if (v.match_start = se, Be = Oe, Oe >= je)
                  break;
                nt = Ye[O + Be - 1], dt = Ye[O + Be];
              }
            }
          while ((se = et[se & Ke]) > Fe && --me !== 0);
          return Be <= v.lookahead ? Be : v.lookahead;
        }
        function f(v) {
          var se = v.w_size, me, O, ce, Oe, Be;
          do {
            if (Oe = v.window_size - v.lookahead - v.strstart, v.strstart >= se + (se - xe)) {
              M.arraySet(v.window, v.window, se, se, 0), v.match_start -= se, v.strstart -= se, v.block_start -= se, O = v.hash_size, me = O;
              do
                ce = v.head[--me], v.head[me] = ce >= se ? ce - se : 0;
              while (--O);
              O = se, me = O;
              do
                ce = v.prev[--me], v.prev[me] = ce >= se ? ce - se : 0;
              while (--O);
              Oe += se;
            }
            if (v.strm.avail_in === 0)
              break;
            if (O = e(v.strm, v.window, v.strstart + v.lookahead, Oe), v.lookahead += O, v.lookahead + v.insert >= Me)
              for (Be = v.strstart - v.insert, v.ins_h = v.window[Be], v.ins_h = (v.ins_h << v.hash_shift ^ v.window[Be + 1]) & v.hash_mask; v.insert && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[Be + Me - 1]) & v.hash_mask, v.prev[Be & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = Be, Be++, v.insert--, !(v.lookahead + v.insert < Me)); )
                ;
          } while (v.lookahead < xe && v.strm.avail_in !== 0);
        }
        function C(v, se) {
          var me = 65535;
          for (me > v.pending_buf_size - 5 && (me = v.pending_buf_size - 5); ; ) {
            if (v.lookahead <= 1) {
              if (f(v), v.lookahead === 0 && se === u)
                return Ge;
              if (v.lookahead === 0)
                break;
            }
            v.strstart += v.lookahead, v.lookahead = 0;
            var O = v.block_start + me;
            if ((v.strstart === 0 || v.strstart >= O) && (v.lookahead = v.strstart - O, v.strstart = O, Y(v, !1), v.strm.avail_out === 0) || v.strstart - v.block_start >= v.w_size - xe && (Y(v, !1), v.strm.avail_out === 0))
              return Ge;
          }
          return v.insert = 0, se === n ? (Y(v, !0), v.strm.avail_out === 0 ? De : Ne) : (v.strstart > v.block_start && (Y(v, !1), v.strm.avail_out === 0), Ge);
        }
        function R(v, se) {
          for (var me, O; ; ) {
            if (v.lookahead < xe) {
              if (f(v), v.lookahead < xe && se === u)
                return Ge;
              if (v.lookahead === 0)
                break;
            }
            if (me = 0, v.lookahead >= Me && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + Me - 1]) & v.hash_mask, me = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart), me !== 0 && v.strstart - me <= v.w_size - xe && (v.match_length = r(v, me)), v.match_length >= Me)
              if (O = x._tr_tally(v, v.strstart - v.match_start, v.match_length - Me), v.lookahead -= v.match_length, v.match_length <= v.max_lazy_match && v.lookahead >= Me) {
                v.match_length--;
                do
                  v.strstart++, v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + Me - 1]) & v.hash_mask, me = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart;
                while (--v.match_length !== 0);
                v.strstart++;
              } else
                v.strstart += v.match_length, v.match_length = 0, v.ins_h = v.window[v.strstart], v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + 1]) & v.hash_mask;
            else
              O = x._tr_tally(v, 0, v.window[v.strstart]), v.lookahead--, v.strstart++;
            if (O && (Y(v, !1), v.strm.avail_out === 0))
              return Ge;
          }
          return v.insert = v.strstart < Me - 1 ? v.strstart : Me - 1, se === n ? (Y(v, !0), v.strm.avail_out === 0 ? De : Ne) : v.last_lit && (Y(v, !1), v.strm.avail_out === 0) ? Ge : Ie;
        }
        function B(v, se) {
          for (var me, O, ce; ; ) {
            if (v.lookahead < xe) {
              if (f(v), v.lookahead < xe && se === u)
                return Ge;
              if (v.lookahead === 0)
                break;
            }
            if (me = 0, v.lookahead >= Me && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + Me - 1]) & v.hash_mask, me = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart), v.prev_length = v.match_length, v.prev_match = v.match_start, v.match_length = Me - 1, me !== 0 && v.prev_length < v.max_lazy_match && v.strstart - me <= v.w_size - xe && (v.match_length = r(v, me), v.match_length <= 5 && (v.strategy === o || v.match_length === Me && v.strstart - v.match_start > 4096) && (v.match_length = Me - 1)), v.prev_length >= Me && v.match_length <= v.prev_length) {
              ce = v.strstart + v.lookahead - Me, O = x._tr_tally(v, v.strstart - 1 - v.prev_match, v.prev_length - Me), v.lookahead -= v.prev_length - 1, v.prev_length -= 2;
              do
                ++v.strstart <= ce && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + Me - 1]) & v.hash_mask, me = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart);
              while (--v.prev_length !== 0);
              if (v.match_available = 0, v.match_length = Me - 1, v.strstart++, O && (Y(v, !1), v.strm.avail_out === 0))
                return Ge;
            } else if (v.match_available) {
              if (O = x._tr_tally(v, 0, v.window[v.strstart - 1]), O && Y(v, !1), v.strstart++, v.lookahead--, v.strm.avail_out === 0)
                return Ge;
            } else
              v.match_available = 1, v.strstart++, v.lookahead--;
          }
          return v.match_available && (O = x._tr_tally(v, 0, v.window[v.strstart - 1]), v.match_available = 0), v.insert = v.strstart < Me - 1 ? v.strstart : Me - 1, se === n ? (Y(v, !0), v.strm.avail_out === 0 ? De : Ne) : v.last_lit && (Y(v, !1), v.strm.avail_out === 0) ? Ge : Ie;
        }
        function j(v, se) {
          for (var me, O, ce, Oe, Be = v.window; ; ) {
            if (v.lookahead <= fe) {
              if (f(v), v.lookahead <= fe && se === u)
                return Ge;
              if (v.lookahead === 0)
                break;
            }
            if (v.match_length = 0, v.lookahead >= Me && v.strstart > 0 && (ce = v.strstart - 1, O = Be[ce], O === Be[++ce] && O === Be[++ce] && O === Be[++ce])) {
              Oe = v.strstart + fe;
              do
                ;
              while (O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && ce < Oe);
              v.match_length = fe - (Oe - ce), v.match_length > v.lookahead && (v.match_length = v.lookahead);
            }
            if (v.match_length >= Me ? (me = x._tr_tally(v, 1, v.match_length - Me), v.lookahead -= v.match_length, v.strstart += v.match_length, v.match_length = 0) : (me = x._tr_tally(v, 0, v.window[v.strstart]), v.lookahead--, v.strstart++), me && (Y(v, !1), v.strm.avail_out === 0))
              return Ge;
          }
          return v.insert = 0, se === n ? (Y(v, !0), v.strm.avail_out === 0 ? De : Ne) : v.last_lit && (Y(v, !1), v.strm.avail_out === 0) ? Ge : Ie;
        }
        function H(v, se) {
          for (var me; ; ) {
            if (v.lookahead === 0 && (f(v), v.lookahead === 0)) {
              if (se === u)
                return Ge;
              break;
            }
            if (v.match_length = 0, me = x._tr_tally(v, 0, v.window[v.strstart]), v.lookahead--, v.strstart++, me && (Y(v, !1), v.strm.avail_out === 0))
              return Ge;
          }
          return v.insert = 0, se === n ? (Y(v, !0), v.strm.avail_out === 0 ? De : Ne) : v.last_lit && (Y(v, !1), v.strm.avail_out === 0) ? Ge : Ie;
        }
        function X(v, se, me, O, ce) {
          this.good_length = v, this.max_lazy = se, this.nice_length = me, this.max_chain = O, this.func = ce;
        }
        var ue;
        ue = [
          /*      good lazy nice chain */
          new X(0, 0, 0, 0, C),
          /* 0 store only */
          new X(4, 4, 8, 4, R),
          /* 1 max speed, no lazy matches */
          new X(4, 5, 16, 8, R),
          /* 2 */
          new X(4, 6, 32, 32, R),
          /* 3 */
          new X(4, 4, 16, 16, B),
          /* 4 lazy matches */
          new X(8, 16, 32, 32, B),
          /* 5 */
          new X(8, 16, 128, 128, B),
          /* 6 */
          new X(8, 32, 128, 256, B),
          /* 7 */
          new X(32, 128, 258, 1024, B),
          /* 8 */
          new X(32, 258, 258, 4096, B)
          /* 9 max compression */
        ];
        function pe(v) {
          v.window_size = 2 * v.w_size, Ce(v.head), v.max_lazy_match = ue[v.level].max_lazy, v.good_match = ue[v.level].good_length, v.nice_match = ue[v.level].nice_length, v.max_chain_length = ue[v.level].max_chain, v.strstart = 0, v.block_start = 0, v.lookahead = 0, v.insert = 0, v.match_length = v.prev_length = Me - 1, v.match_available = 0, v.ins_h = 0;
        }
        function P() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = U, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new M.Buf16(we * 2), this.dyn_dtree = new M.Buf16((2 * Q + 1) * 2), this.bl_tree = new M.Buf16((2 * de + 1) * 2), Ce(this.dyn_ltree), Ce(this.dyn_dtree), Ce(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new M.Buf16(ke + 1), this.heap = new M.Buf16(2 * W + 1), Ce(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new M.Buf16(2 * W + 1), Ce(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function q(v) {
          var se;
          return !v || !v.state ? re(v, m) : (v.total_in = v.total_out = 0, v.data_type = z, se = v.state, se.pending = 0, se.pending_out = 0, se.wrap < 0 && (se.wrap = -se.wrap), se.status = se.wrap ? Pe : $e, v.adler = se.wrap === 2 ? 0 : 1, se.last_flush = u, x._tr_init(se), g);
        }
        function K(v) {
          var se = q(v);
          return se === g && pe(v.state), se;
        }
        function ye(v, se) {
          return !v || !v.state || v.state.wrap !== 2 ? m : (v.state.gzhead = se, g);
        }
        function te(v, se, me, O, ce, Oe) {
          if (!v)
            return m;
          var Be = 1;
          if (se === S && (se = 6), O < 0 ? (Be = 0, O = -O) : O > 15 && (Be = 2, O -= 16), ce < 1 || ce > J || me !== U || O < 8 || O > 15 || se < 0 || se > 9 || Oe < 0 || Oe > I)
            return re(v, m);
          O === 8 && (O = 9);
          var je = new P();
          return v.state = je, je.strm = v, je.wrap = Be, je.gzhead = null, je.w_bits = O, je.w_size = 1 << je.w_bits, je.w_mask = je.w_size - 1, je.hash_bits = ce + 7, je.hash_size = 1 << je.hash_bits, je.hash_mask = je.hash_size - 1, je.hash_shift = ~~((je.hash_bits + Me - 1) / Me), je.window = new M.Buf8(je.w_size * 2), je.head = new M.Buf16(je.hash_size), je.prev = new M.Buf16(je.w_size), je.lit_bufsize = 1 << ce + 6, je.pending_buf_size = je.lit_bufsize * 4, je.pending_buf = new M.Buf8(je.pending_buf_size), je.d_buf = 1 * je.lit_bufsize, je.l_buf = 3 * je.lit_bufsize, je.level = se, je.strategy = Oe, je.method = me, K(v);
        }
        function he(v, se) {
          return te(v, se, U, F, oe, L);
        }
        function D(v, se) {
          var me, O, ce, Oe;
          if (!v || !v.state || se > d || se < 0)
            return v ? re(v, m) : m;
          if (O = v.state, !v.output || !v.input && v.avail_in !== 0 || O.status === Ve && se !== n)
            return re(v, v.avail_out === 0 ? b : m);
          if (O.strm = v, me = O.last_flush, O.last_flush = se, O.status === Pe)
            if (O.wrap === 2)
              v.adler = 0, G(O, 31), G(O, 139), G(O, 8), O.gzhead ? (G(
                O,
                (O.gzhead.text ? 1 : 0) + (O.gzhead.hcrc ? 2 : 0) + (O.gzhead.extra ? 4 : 0) + (O.gzhead.name ? 8 : 0) + (O.gzhead.comment ? 16 : 0)
              ), G(O, O.gzhead.time & 255), G(O, O.gzhead.time >> 8 & 255), G(O, O.gzhead.time >> 16 & 255), G(O, O.gzhead.time >> 24 & 255), G(O, O.level === 9 ? 2 : O.strategy >= A || O.level < 2 ? 4 : 0), G(O, O.gzhead.os & 255), O.gzhead.extra && O.gzhead.extra.length && (G(O, O.gzhead.extra.length & 255), G(O, O.gzhead.extra.length >> 8 & 255)), O.gzhead.hcrc && (v.adler = E(v.adler, O.pending_buf, O.pending, 0)), O.gzindex = 0, O.status = Ue) : (G(O, 0), G(O, 0), G(O, 0), G(O, 0), G(O, 0), G(O, O.level === 9 ? 2 : O.strategy >= A || O.level < 2 ? 4 : 0), G(O, _e), O.status = $e);
            else {
              var Be = U + (O.w_bits - 8 << 4) << 8, je = -1;
              O.strategy >= A || O.level < 2 ? je = 0 : O.level < 6 ? je = 1 : O.level === 6 ? je = 2 : je = 3, Be |= je << 6, O.strstart !== 0 && (Be |= Ee), Be += 31 - Be % 31, O.status = $e, Ae(O, Be), O.strstart !== 0 && (Ae(O, v.adler >>> 16), Ae(O, v.adler & 65535)), v.adler = 1;
            }
          if (O.status === Ue)
            if (O.gzhead.extra) {
              for (ce = O.pending; O.gzindex < (O.gzhead.extra.length & 65535) && !(O.pending === O.pending_buf_size && (O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), ve(v), ce = O.pending, O.pending === O.pending_buf_size)); )
                G(O, O.gzhead.extra[O.gzindex] & 255), O.gzindex++;
              O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), O.gzindex === O.gzhead.extra.length && (O.gzindex = 0, O.status = He);
            } else
              O.status = He;
          if (O.status === He)
            if (O.gzhead.name) {
              ce = O.pending;
              do {
                if (O.pending === O.pending_buf_size && (O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), ve(v), ce = O.pending, O.pending === O.pending_buf_size)) {
                  Oe = 1;
                  break;
                }
                O.gzindex < O.gzhead.name.length ? Oe = O.gzhead.name.charCodeAt(O.gzindex++) & 255 : Oe = 0, G(O, Oe);
              } while (Oe !== 0);
              O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), Oe === 0 && (O.gzindex = 0, O.status = We);
            } else
              O.status = We;
          if (O.status === We)
            if (O.gzhead.comment) {
              ce = O.pending;
              do {
                if (O.pending === O.pending_buf_size && (O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), ve(v), ce = O.pending, O.pending === O.pending_buf_size)) {
                  Oe = 1;
                  break;
                }
                O.gzindex < O.gzhead.comment.length ? Oe = O.gzhead.comment.charCodeAt(O.gzindex++) & 255 : Oe = 0, G(O, Oe);
              } while (Oe !== 0);
              O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), Oe === 0 && (O.status = Ze);
            } else
              O.status = Ze;
          if (O.status === Ze && (O.gzhead.hcrc ? (O.pending + 2 > O.pending_buf_size && ve(v), O.pending + 2 <= O.pending_buf_size && (G(O, v.adler & 255), G(O, v.adler >> 8 & 255), v.adler = 0, O.status = $e)) : O.status = $e), O.pending !== 0) {
            if (ve(v), v.avail_out === 0)
              return O.last_flush = -1, g;
          } else if (v.avail_in === 0 && $(se) <= $(me) && se !== n)
            return re(v, b);
          if (O.status === Ve && v.avail_in !== 0)
            return re(v, b);
          if (v.avail_in !== 0 || O.lookahead !== 0 || se !== u && O.status !== Ve) {
            var Fe = O.strategy === A ? H(O, se) : O.strategy === T ? j(O, se) : ue[O.level].func(O, se);
            if ((Fe === De || Fe === Ne) && (O.status = Ve), Fe === Ge || Fe === De)
              return v.avail_out === 0 && (O.last_flush = -1), g;
            if (Fe === Ie && (se === l ? x._tr_align(O) : se !== d && (x._tr_stored_block(O, 0, 0, !1), se === a && (Ce(O.head), O.lookahead === 0 && (O.strstart = 0, O.block_start = 0, O.insert = 0))), ve(v), v.avail_out === 0))
              return O.last_flush = -1, g;
          }
          return se !== n ? g : O.wrap <= 0 ? h : (O.wrap === 2 ? (G(O, v.adler & 255), G(O, v.adler >> 8 & 255), G(O, v.adler >> 16 & 255), G(O, v.adler >> 24 & 255), G(O, v.total_in & 255), G(O, v.total_in >> 8 & 255), G(O, v.total_in >> 16 & 255), G(O, v.total_in >> 24 & 255)) : (Ae(O, v.adler >>> 16), Ae(O, v.adler & 65535)), ve(v), O.wrap > 0 && (O.wrap = -O.wrap), O.pending !== 0 ? g : h);
        }
        function Se(v) {
          var se;
          return !v || !v.state ? m : (se = v.state.status, se !== Pe && se !== Ue && se !== He && se !== We && se !== Ze && se !== $e && se !== Ve ? re(v, m) : (v.state = null, se === $e ? re(v, s) : g));
        }
        function le(v, se) {
          var me = se.length, O, ce, Oe, Be, je, Fe, Ye, Ke;
          if (!v || !v.state || (O = v.state, Be = O.wrap, Be === 2 || Be === 1 && O.status !== Pe || O.lookahead))
            return m;
          for (Be === 1 && (v.adler = y(v.adler, se, me, 0)), O.wrap = 0, me >= O.w_size && (Be === 0 && (Ce(O.head), O.strstart = 0, O.block_start = 0, O.insert = 0), Ke = new M.Buf8(O.w_size), M.arraySet(Ke, se, me - O.w_size, O.w_size, 0), se = Ke, me = O.w_size), je = v.avail_in, Fe = v.next_in, Ye = v.input, v.avail_in = me, v.next_in = 0, v.input = se, f(O); O.lookahead >= Me; ) {
            ce = O.strstart, Oe = O.lookahead - (Me - 1);
            do
              O.ins_h = (O.ins_h << O.hash_shift ^ O.window[ce + Me - 1]) & O.hash_mask, O.prev[ce & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = ce, ce++;
            while (--Oe);
            O.strstart = ce, O.lookahead = Me - 1, f(O);
          }
          return O.strstart += O.lookahead, O.block_start = O.strstart, O.insert = O.lookahead, O.lookahead = 0, O.match_length = O.prev_length = Me - 1, O.match_available = 0, v.next_in = Fe, v.input = Ye, v.avail_in = je, O.wrap = Be, g;
        }
        _.deflateInit = he, _.deflateInit2 = te, _.deflateReset = K, _.deflateResetKeep = q, _.deflateSetHeader = ye, _.deflate = D, _.deflateEnd = Se, _.deflateSetDictionary = le, _.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 36, "./adler32": 37, "./crc32": 39, "./messages": 44, "./trees": 45 }], 41: [function(k, Z, _) {
        var M = 30, x = 12;
        Z.exports = function(E, c) {
          var u, l, a, n, d, g, h, m, s, b, S, o, A, T, I, L, z, U, J, F, oe, ee, ie, W, Q;
          u = E.state, l = E.next_in, W = E.input, a = l + (E.avail_in - 5), n = E.next_out, Q = E.output, d = n - (c - E.avail_out), g = n + (E.avail_out - 257), h = u.dmax, m = u.wsize, s = u.whave, b = u.wnext, S = u.window, o = u.hold, A = u.bits, T = u.lencode, I = u.distcode, L = (1 << u.lenbits) - 1, z = (1 << u.distbits) - 1;
          e:
            do {
              A < 15 && (o += W[l++] << A, A += 8, o += W[l++] << A, A += 8), U = T[o & L];
              t:
                for (; ; ) {
                  if (J = U >>> 24, o >>>= J, A -= J, J = U >>> 16 & 255, J === 0)
                    Q[n++] = U & 65535;
                  else if (J & 16) {
                    F = U & 65535, J &= 15, J && (A < J && (o += W[l++] << A, A += 8), F += o & (1 << J) - 1, o >>>= J, A -= J), A < 15 && (o += W[l++] << A, A += 8, o += W[l++] << A, A += 8), U = I[o & z];
                    r:
                      for (; ; ) {
                        if (J = U >>> 24, o >>>= J, A -= J, J = U >>> 16 & 255, J & 16) {
                          if (oe = U & 65535, J &= 15, A < J && (o += W[l++] << A, A += 8, A < J && (o += W[l++] << A, A += 8)), oe += o & (1 << J) - 1, oe > h) {
                            E.msg = "invalid distance too far back", u.mode = M;
                            break e;
                          }
                          if (o >>>= J, A -= J, J = n - d, oe > J) {
                            if (J = oe - J, J > s && u.sane) {
                              E.msg = "invalid distance too far back", u.mode = M;
                              break e;
                            }
                            if (ee = 0, ie = S, b === 0) {
                              if (ee += m - J, J < F) {
                                F -= J;
                                do
                                  Q[n++] = S[ee++];
                                while (--J);
                                ee = n - oe, ie = Q;
                              }
                            } else if (b < J) {
                              if (ee += m + b - J, J -= b, J < F) {
                                F -= J;
                                do
                                  Q[n++] = S[ee++];
                                while (--J);
                                if (ee = 0, b < F) {
                                  J = b, F -= J;
                                  do
                                    Q[n++] = S[ee++];
                                  while (--J);
                                  ee = n - oe, ie = Q;
                                }
                              }
                            } else if (ee += b - J, J < F) {
                              F -= J;
                              do
                                Q[n++] = S[ee++];
                              while (--J);
                              ee = n - oe, ie = Q;
                            }
                            for (; F > 2; )
                              Q[n++] = ie[ee++], Q[n++] = ie[ee++], Q[n++] = ie[ee++], F -= 3;
                            F && (Q[n++] = ie[ee++], F > 1 && (Q[n++] = ie[ee++]));
                          } else {
                            ee = n - oe;
                            do
                              Q[n++] = Q[ee++], Q[n++] = Q[ee++], Q[n++] = Q[ee++], F -= 3;
                            while (F > 2);
                            F && (Q[n++] = Q[ee++], F > 1 && (Q[n++] = Q[ee++]));
                          }
                        } else if ((J & 64) === 0) {
                          U = I[(U & 65535) + (o & (1 << J) - 1)];
                          continue r;
                        } else {
                          E.msg = "invalid distance code", u.mode = M;
                          break e;
                        }
                        break;
                      }
                  } else if ((J & 64) === 0) {
                    U = T[(U & 65535) + (o & (1 << J) - 1)];
                    continue t;
                  } else if (J & 32) {
                    u.mode = x;
                    break e;
                  } else {
                    E.msg = "invalid literal/length code", u.mode = M;
                    break e;
                  }
                  break;
                }
            } while (l < a && n < g);
          F = A >> 3, l -= F, A -= F << 3, o &= (1 << A) - 1, E.next_in = l, E.next_out = n, E.avail_in = l < a ? 5 + (a - l) : 5 - (l - a), E.avail_out = n < g ? 257 + (g - n) : 257 - (n - g), u.hold = o, u.bits = A;
        };
      }, {}], 42: [function(k, Z, _) {
        var M = k("../utils/common"), x = k("./adler32"), y = k("./crc32"), E = k("./inffast"), c = k("./inftrees"), u = 0, l = 1, a = 2, n = 4, d = 5, g = 6, h = 0, m = 1, s = 2, b = -2, S = -3, o = -4, A = -5, T = 8, I = 1, L = 2, z = 3, U = 4, J = 5, F = 6, oe = 7, ee = 8, ie = 9, W = 10, Q = 11, de = 12, we = 13, ke = 14, Me = 15, fe = 16, xe = 17, Ee = 18, Pe = 19, Ue = 20, He = 21, We = 22, Ze = 23, $e = 24, Ve = 25, Ge = 26, Ie = 27, De = 28, Ne = 29, _e = 30, re = 31, $ = 32, Ce = 852, ve = 592, Y = 15, G = Y;
        function Ae(te) {
          return (te >>> 24 & 255) + (te >>> 8 & 65280) + ((te & 65280) << 8) + ((te & 255) << 24);
        }
        function e() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new M.Buf16(320), this.work = new M.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function r(te) {
          var he;
          return !te || !te.state ? b : (he = te.state, te.total_in = te.total_out = he.total = 0, te.msg = "", he.wrap && (te.adler = he.wrap & 1), he.mode = I, he.last = 0, he.havedict = 0, he.dmax = 32768, he.head = null, he.hold = 0, he.bits = 0, he.lencode = he.lendyn = new M.Buf32(Ce), he.distcode = he.distdyn = new M.Buf32(ve), he.sane = 1, he.back = -1, h);
        }
        function f(te) {
          var he;
          return !te || !te.state ? b : (he = te.state, he.wsize = 0, he.whave = 0, he.wnext = 0, r(te));
        }
        function C(te, he) {
          var D, Se;
          return !te || !te.state || (Se = te.state, he < 0 ? (D = 0, he = -he) : (D = (he >> 4) + 1, he < 48 && (he &= 15)), he && (he < 8 || he > 15)) ? b : (Se.window !== null && Se.wbits !== he && (Se.window = null), Se.wrap = D, Se.wbits = he, f(te));
        }
        function R(te, he) {
          var D, Se;
          return te ? (Se = new e(), te.state = Se, Se.window = null, D = C(te, he), D !== h && (te.state = null), D) : b;
        }
        function B(te) {
          return R(te, G);
        }
        var j = !0, H, X;
        function ue(te) {
          if (j) {
            var he;
            for (H = new M.Buf32(512), X = new M.Buf32(32), he = 0; he < 144; )
              te.lens[he++] = 8;
            for (; he < 256; )
              te.lens[he++] = 9;
            for (; he < 280; )
              te.lens[he++] = 7;
            for (; he < 288; )
              te.lens[he++] = 8;
            for (c(l, te.lens, 0, 288, H, 0, te.work, { bits: 9 }), he = 0; he < 32; )
              te.lens[he++] = 5;
            c(a, te.lens, 0, 32, X, 0, te.work, { bits: 5 }), j = !1;
          }
          te.lencode = H, te.lenbits = 9, te.distcode = X, te.distbits = 5;
        }
        function pe(te, he, D, Se) {
          var le, v = te.state;
          return v.window === null && (v.wsize = 1 << v.wbits, v.wnext = 0, v.whave = 0, v.window = new M.Buf8(v.wsize)), Se >= v.wsize ? (M.arraySet(v.window, he, D - v.wsize, v.wsize, 0), v.wnext = 0, v.whave = v.wsize) : (le = v.wsize - v.wnext, le > Se && (le = Se), M.arraySet(v.window, he, D - Se, le, v.wnext), Se -= le, Se ? (M.arraySet(v.window, he, D - Se, Se, 0), v.wnext = Se, v.whave = v.wsize) : (v.wnext += le, v.wnext === v.wsize && (v.wnext = 0), v.whave < v.wsize && (v.whave += le))), 0;
        }
        function P(te, he) {
          var D, Se, le, v, se, me, O, ce, Oe, Be, je, Fe, Ye, Ke, et = 0, Je, nt, dt, vt, bt, At, ot, ht, gt = new M.Buf8(4), Ct, xt, Ot = (
            /* permutation of code lengths */
            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
          );
          if (!te || !te.state || !te.output || !te.input && te.avail_in !== 0)
            return b;
          D = te.state, D.mode === de && (D.mode = we), se = te.next_out, le = te.output, O = te.avail_out, v = te.next_in, Se = te.input, me = te.avail_in, ce = D.hold, Oe = D.bits, Be = me, je = O, ht = h;
          e:
            for (; ; )
              switch (D.mode) {
                case I:
                  if (D.wrap === 0) {
                    D.mode = we;
                    break;
                  }
                  for (; Oe < 16; ) {
                    if (me === 0)
                      break e;
                    me--, ce += Se[v++] << Oe, Oe += 8;
                  }
                  if (D.wrap & 2 && ce === 35615) {
                    D.check = 0, gt[0] = ce & 255, gt[1] = ce >>> 8 & 255, D.check = y(D.check, gt, 2, 0), ce = 0, Oe = 0, D.mode = L;
                    break;
                  }
                  if (D.flags = 0, D.head && (D.head.done = !1), !(D.wrap & 1) || /* check if zlib header allowed */
                  (((ce & 255) << 8) + (ce >> 8)) % 31) {
                    te.msg = "incorrect header check", D.mode = _e;
                    break;
                  }
                  if ((ce & 15) !== T) {
                    te.msg = "unknown compression method", D.mode = _e;
                    break;
                  }
                  if (ce >>>= 4, Oe -= 4, ot = (ce & 15) + 8, D.wbits === 0)
                    D.wbits = ot;
                  else if (ot > D.wbits) {
                    te.msg = "invalid window size", D.mode = _e;
                    break;
                  }
                  D.dmax = 1 << ot, te.adler = D.check = 1, D.mode = ce & 512 ? W : de, ce = 0, Oe = 0;
                  break;
                case L:
                  for (; Oe < 16; ) {
                    if (me === 0)
                      break e;
                    me--, ce += Se[v++] << Oe, Oe += 8;
                  }
                  if (D.flags = ce, (D.flags & 255) !== T) {
                    te.msg = "unknown compression method", D.mode = _e;
                    break;
                  }
                  if (D.flags & 57344) {
                    te.msg = "unknown header flags set", D.mode = _e;
                    break;
                  }
                  D.head && (D.head.text = ce >> 8 & 1), D.flags & 512 && (gt[0] = ce & 255, gt[1] = ce >>> 8 & 255, D.check = y(D.check, gt, 2, 0)), ce = 0, Oe = 0, D.mode = z;
                /* falls through */
                case z:
                  for (; Oe < 32; ) {
                    if (me === 0)
                      break e;
                    me--, ce += Se[v++] << Oe, Oe += 8;
                  }
                  D.head && (D.head.time = ce), D.flags & 512 && (gt[0] = ce & 255, gt[1] = ce >>> 8 & 255, gt[2] = ce >>> 16 & 255, gt[3] = ce >>> 24 & 255, D.check = y(D.check, gt, 4, 0)), ce = 0, Oe = 0, D.mode = U;
                /* falls through */
                case U:
                  for (; Oe < 16; ) {
                    if (me === 0)
                      break e;
                    me--, ce += Se[v++] << Oe, Oe += 8;
                  }
                  D.head && (D.head.xflags = ce & 255, D.head.os = ce >> 8), D.flags & 512 && (gt[0] = ce & 255, gt[1] = ce >>> 8 & 255, D.check = y(D.check, gt, 2, 0)), ce = 0, Oe = 0, D.mode = J;
                /* falls through */
                case J:
                  if (D.flags & 1024) {
                    for (; Oe < 16; ) {
                      if (me === 0)
                        break e;
                      me--, ce += Se[v++] << Oe, Oe += 8;
                    }
                    D.length = ce, D.head && (D.head.extra_len = ce), D.flags & 512 && (gt[0] = ce & 255, gt[1] = ce >>> 8 & 255, D.check = y(D.check, gt, 2, 0)), ce = 0, Oe = 0;
                  } else D.head && (D.head.extra = null);
                  D.mode = F;
                /* falls through */
                case F:
                  if (D.flags & 1024 && (Fe = D.length, Fe > me && (Fe = me), Fe && (D.head && (ot = D.head.extra_len - D.length, D.head.extra || (D.head.extra = new Array(D.head.extra_len)), M.arraySet(
                    D.head.extra,
                    Se,
                    v,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    Fe,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    ot
                  )), D.flags & 512 && (D.check = y(D.check, Se, Fe, v)), me -= Fe, v += Fe, D.length -= Fe), D.length))
                    break e;
                  D.length = 0, D.mode = oe;
                /* falls through */
                case oe:
                  if (D.flags & 2048) {
                    if (me === 0)
                      break e;
                    Fe = 0;
                    do
                      ot = Se[v + Fe++], D.head && ot && D.length < 65536 && (D.head.name += String.fromCharCode(ot));
                    while (ot && Fe < me);
                    if (D.flags & 512 && (D.check = y(D.check, Se, Fe, v)), me -= Fe, v += Fe, ot)
                      break e;
                  } else D.head && (D.head.name = null);
                  D.length = 0, D.mode = ee;
                /* falls through */
                case ee:
                  if (D.flags & 4096) {
                    if (me === 0)
                      break e;
                    Fe = 0;
                    do
                      ot = Se[v + Fe++], D.head && ot && D.length < 65536 && (D.head.comment += String.fromCharCode(ot));
                    while (ot && Fe < me);
                    if (D.flags & 512 && (D.check = y(D.check, Se, Fe, v)), me -= Fe, v += Fe, ot)
                      break e;
                  } else D.head && (D.head.comment = null);
                  D.mode = ie;
                /* falls through */
                case ie:
                  if (D.flags & 512) {
                    for (; Oe < 16; ) {
                      if (me === 0)
                        break e;
                      me--, ce += Se[v++] << Oe, Oe += 8;
                    }
                    if (ce !== (D.check & 65535)) {
                      te.msg = "header crc mismatch", D.mode = _e;
                      break;
                    }
                    ce = 0, Oe = 0;
                  }
                  D.head && (D.head.hcrc = D.flags >> 9 & 1, D.head.done = !0), te.adler = D.check = 0, D.mode = de;
                  break;
                case W:
                  for (; Oe < 32; ) {
                    if (me === 0)
                      break e;
                    me--, ce += Se[v++] << Oe, Oe += 8;
                  }
                  te.adler = D.check = Ae(ce), ce = 0, Oe = 0, D.mode = Q;
                /* falls through */
                case Q:
                  if (D.havedict === 0)
                    return te.next_out = se, te.avail_out = O, te.next_in = v, te.avail_in = me, D.hold = ce, D.bits = Oe, s;
                  te.adler = D.check = 1, D.mode = de;
                /* falls through */
                case de:
                  if (he === d || he === g)
                    break e;
                /* falls through */
                case we:
                  if (D.last) {
                    ce >>>= Oe & 7, Oe -= Oe & 7, D.mode = Ie;
                    break;
                  }
                  for (; Oe < 3; ) {
                    if (me === 0)
                      break e;
                    me--, ce += Se[v++] << Oe, Oe += 8;
                  }
                  switch (D.last = ce & 1, ce >>>= 1, Oe -= 1, ce & 3) {
                    case 0:
                      D.mode = ke;
                      break;
                    case 1:
                      if (ue(D), D.mode = Ue, he === g) {
                        ce >>>= 2, Oe -= 2;
                        break e;
                      }
                      break;
                    case 2:
                      D.mode = xe;
                      break;
                    case 3:
                      te.msg = "invalid block type", D.mode = _e;
                  }
                  ce >>>= 2, Oe -= 2;
                  break;
                case ke:
                  for (ce >>>= Oe & 7, Oe -= Oe & 7; Oe < 32; ) {
                    if (me === 0)
                      break e;
                    me--, ce += Se[v++] << Oe, Oe += 8;
                  }
                  if ((ce & 65535) !== (ce >>> 16 ^ 65535)) {
                    te.msg = "invalid stored block lengths", D.mode = _e;
                    break;
                  }
                  if (D.length = ce & 65535, ce = 0, Oe = 0, D.mode = Me, he === g)
                    break e;
                /* falls through */
                case Me:
                  D.mode = fe;
                /* falls through */
                case fe:
                  if (Fe = D.length, Fe) {
                    if (Fe > me && (Fe = me), Fe > O && (Fe = O), Fe === 0)
                      break e;
                    M.arraySet(le, Se, v, Fe, se), me -= Fe, v += Fe, O -= Fe, se += Fe, D.length -= Fe;
                    break;
                  }
                  D.mode = de;
                  break;
                case xe:
                  for (; Oe < 14; ) {
                    if (me === 0)
                      break e;
                    me--, ce += Se[v++] << Oe, Oe += 8;
                  }
                  if (D.nlen = (ce & 31) + 257, ce >>>= 5, Oe -= 5, D.ndist = (ce & 31) + 1, ce >>>= 5, Oe -= 5, D.ncode = (ce & 15) + 4, ce >>>= 4, Oe -= 4, D.nlen > 286 || D.ndist > 30) {
                    te.msg = "too many length or distance symbols", D.mode = _e;
                    break;
                  }
                  D.have = 0, D.mode = Ee;
                /* falls through */
                case Ee:
                  for (; D.have < D.ncode; ) {
                    for (; Oe < 3; ) {
                      if (me === 0)
                        break e;
                      me--, ce += Se[v++] << Oe, Oe += 8;
                    }
                    D.lens[Ot[D.have++]] = ce & 7, ce >>>= 3, Oe -= 3;
                  }
                  for (; D.have < 19; )
                    D.lens[Ot[D.have++]] = 0;
                  if (D.lencode = D.lendyn, D.lenbits = 7, Ct = { bits: D.lenbits }, ht = c(u, D.lens, 0, 19, D.lencode, 0, D.work, Ct), D.lenbits = Ct.bits, ht) {
                    te.msg = "invalid code lengths set", D.mode = _e;
                    break;
                  }
                  D.have = 0, D.mode = Pe;
                /* falls through */
                case Pe:
                  for (; D.have < D.nlen + D.ndist; ) {
                    for (; et = D.lencode[ce & (1 << D.lenbits) - 1], Je = et >>> 24, nt = et >>> 16 & 255, dt = et & 65535, !(Je <= Oe); ) {
                      if (me === 0)
                        break e;
                      me--, ce += Se[v++] << Oe, Oe += 8;
                    }
                    if (dt < 16)
                      ce >>>= Je, Oe -= Je, D.lens[D.have++] = dt;
                    else {
                      if (dt === 16) {
                        for (xt = Je + 2; Oe < xt; ) {
                          if (me === 0)
                            break e;
                          me--, ce += Se[v++] << Oe, Oe += 8;
                        }
                        if (ce >>>= Je, Oe -= Je, D.have === 0) {
                          te.msg = "invalid bit length repeat", D.mode = _e;
                          break;
                        }
                        ot = D.lens[D.have - 1], Fe = 3 + (ce & 3), ce >>>= 2, Oe -= 2;
                      } else if (dt === 17) {
                        for (xt = Je + 3; Oe < xt; ) {
                          if (me === 0)
                            break e;
                          me--, ce += Se[v++] << Oe, Oe += 8;
                        }
                        ce >>>= Je, Oe -= Je, ot = 0, Fe = 3 + (ce & 7), ce >>>= 3, Oe -= 3;
                      } else {
                        for (xt = Je + 7; Oe < xt; ) {
                          if (me === 0)
                            break e;
                          me--, ce += Se[v++] << Oe, Oe += 8;
                        }
                        ce >>>= Je, Oe -= Je, ot = 0, Fe = 11 + (ce & 127), ce >>>= 7, Oe -= 7;
                      }
                      if (D.have + Fe > D.nlen + D.ndist) {
                        te.msg = "invalid bit length repeat", D.mode = _e;
                        break;
                      }
                      for (; Fe--; )
                        D.lens[D.have++] = ot;
                    }
                  }
                  if (D.mode === _e)
                    break;
                  if (D.lens[256] === 0) {
                    te.msg = "invalid code -- missing end-of-block", D.mode = _e;
                    break;
                  }
                  if (D.lenbits = 9, Ct = { bits: D.lenbits }, ht = c(l, D.lens, 0, D.nlen, D.lencode, 0, D.work, Ct), D.lenbits = Ct.bits, ht) {
                    te.msg = "invalid literal/lengths set", D.mode = _e;
                    break;
                  }
                  if (D.distbits = 6, D.distcode = D.distdyn, Ct = { bits: D.distbits }, ht = c(a, D.lens, D.nlen, D.ndist, D.distcode, 0, D.work, Ct), D.distbits = Ct.bits, ht) {
                    te.msg = "invalid distances set", D.mode = _e;
                    break;
                  }
                  if (D.mode = Ue, he === g)
                    break e;
                /* falls through */
                case Ue:
                  D.mode = He;
                /* falls through */
                case He:
                  if (me >= 6 && O >= 258) {
                    te.next_out = se, te.avail_out = O, te.next_in = v, te.avail_in = me, D.hold = ce, D.bits = Oe, E(te, je), se = te.next_out, le = te.output, O = te.avail_out, v = te.next_in, Se = te.input, me = te.avail_in, ce = D.hold, Oe = D.bits, D.mode === de && (D.back = -1);
                    break;
                  }
                  for (D.back = 0; et = D.lencode[ce & (1 << D.lenbits) - 1], Je = et >>> 24, nt = et >>> 16 & 255, dt = et & 65535, !(Je <= Oe); ) {
                    if (me === 0)
                      break e;
                    me--, ce += Se[v++] << Oe, Oe += 8;
                  }
                  if (nt && (nt & 240) === 0) {
                    for (vt = Je, bt = nt, At = dt; et = D.lencode[At + ((ce & (1 << vt + bt) - 1) >> vt)], Je = et >>> 24, nt = et >>> 16 & 255, dt = et & 65535, !(vt + Je <= Oe); ) {
                      if (me === 0)
                        break e;
                      me--, ce += Se[v++] << Oe, Oe += 8;
                    }
                    ce >>>= vt, Oe -= vt, D.back += vt;
                  }
                  if (ce >>>= Je, Oe -= Je, D.back += Je, D.length = dt, nt === 0) {
                    D.mode = Ge;
                    break;
                  }
                  if (nt & 32) {
                    D.back = -1, D.mode = de;
                    break;
                  }
                  if (nt & 64) {
                    te.msg = "invalid literal/length code", D.mode = _e;
                    break;
                  }
                  D.extra = nt & 15, D.mode = We;
                /* falls through */
                case We:
                  if (D.extra) {
                    for (xt = D.extra; Oe < xt; ) {
                      if (me === 0)
                        break e;
                      me--, ce += Se[v++] << Oe, Oe += 8;
                    }
                    D.length += ce & (1 << D.extra) - 1, ce >>>= D.extra, Oe -= D.extra, D.back += D.extra;
                  }
                  D.was = D.length, D.mode = Ze;
                /* falls through */
                case Ze:
                  for (; et = D.distcode[ce & (1 << D.distbits) - 1], Je = et >>> 24, nt = et >>> 16 & 255, dt = et & 65535, !(Je <= Oe); ) {
                    if (me === 0)
                      break e;
                    me--, ce += Se[v++] << Oe, Oe += 8;
                  }
                  if ((nt & 240) === 0) {
                    for (vt = Je, bt = nt, At = dt; et = D.distcode[At + ((ce & (1 << vt + bt) - 1) >> vt)], Je = et >>> 24, nt = et >>> 16 & 255, dt = et & 65535, !(vt + Je <= Oe); ) {
                      if (me === 0)
                        break e;
                      me--, ce += Se[v++] << Oe, Oe += 8;
                    }
                    ce >>>= vt, Oe -= vt, D.back += vt;
                  }
                  if (ce >>>= Je, Oe -= Je, D.back += Je, nt & 64) {
                    te.msg = "invalid distance code", D.mode = _e;
                    break;
                  }
                  D.offset = dt, D.extra = nt & 15, D.mode = $e;
                /* falls through */
                case $e:
                  if (D.extra) {
                    for (xt = D.extra; Oe < xt; ) {
                      if (me === 0)
                        break e;
                      me--, ce += Se[v++] << Oe, Oe += 8;
                    }
                    D.offset += ce & (1 << D.extra) - 1, ce >>>= D.extra, Oe -= D.extra, D.back += D.extra;
                  }
                  if (D.offset > D.dmax) {
                    te.msg = "invalid distance too far back", D.mode = _e;
                    break;
                  }
                  D.mode = Ve;
                /* falls through */
                case Ve:
                  if (O === 0)
                    break e;
                  if (Fe = je - O, D.offset > Fe) {
                    if (Fe = D.offset - Fe, Fe > D.whave && D.sane) {
                      te.msg = "invalid distance too far back", D.mode = _e;
                      break;
                    }
                    Fe > D.wnext ? (Fe -= D.wnext, Ye = D.wsize - Fe) : Ye = D.wnext - Fe, Fe > D.length && (Fe = D.length), Ke = D.window;
                  } else
                    Ke = le, Ye = se - D.offset, Fe = D.length;
                  Fe > O && (Fe = O), O -= Fe, D.length -= Fe;
                  do
                    le[se++] = Ke[Ye++];
                  while (--Fe);
                  D.length === 0 && (D.mode = He);
                  break;
                case Ge:
                  if (O === 0)
                    break e;
                  le[se++] = D.length, O--, D.mode = He;
                  break;
                case Ie:
                  if (D.wrap) {
                    for (; Oe < 32; ) {
                      if (me === 0)
                        break e;
                      me--, ce |= Se[v++] << Oe, Oe += 8;
                    }
                    if (je -= O, te.total_out += je, D.total += je, je && (te.adler = D.check = /*UPDATE(state.check, put - _out, _out);*/
                    D.flags ? y(D.check, le, je, se - je) : x(D.check, le, je, se - je)), je = O, (D.flags ? ce : Ae(ce)) !== D.check) {
                      te.msg = "incorrect data check", D.mode = _e;
                      break;
                    }
                    ce = 0, Oe = 0;
                  }
                  D.mode = De;
                /* falls through */
                case De:
                  if (D.wrap && D.flags) {
                    for (; Oe < 32; ) {
                      if (me === 0)
                        break e;
                      me--, ce += Se[v++] << Oe, Oe += 8;
                    }
                    if (ce !== (D.total & 4294967295)) {
                      te.msg = "incorrect length check", D.mode = _e;
                      break;
                    }
                    ce = 0, Oe = 0;
                  }
                  D.mode = Ne;
                /* falls through */
                case Ne:
                  ht = m;
                  break e;
                case _e:
                  ht = S;
                  break e;
                case re:
                  return o;
                case $:
                /* falls through */
                default:
                  return b;
              }
          return te.next_out = se, te.avail_out = O, te.next_in = v, te.avail_in = me, D.hold = ce, D.bits = Oe, (D.wsize || je !== te.avail_out && D.mode < _e && (D.mode < Ie || he !== n)) && pe(te, te.output, te.next_out, je - te.avail_out), Be -= te.avail_in, je -= te.avail_out, te.total_in += Be, te.total_out += je, D.total += je, D.wrap && je && (te.adler = D.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          D.flags ? y(D.check, le, je, te.next_out - je) : x(D.check, le, je, te.next_out - je)), te.data_type = D.bits + (D.last ? 64 : 0) + (D.mode === de ? 128 : 0) + (D.mode === Ue || D.mode === Me ? 256 : 0), (Be === 0 && je === 0 || he === n) && ht === h && (ht = A), ht;
        }
        function q(te) {
          if (!te || !te.state)
            return b;
          var he = te.state;
          return he.window && (he.window = null), te.state = null, h;
        }
        function K(te, he) {
          var D;
          return !te || !te.state || (D = te.state, (D.wrap & 2) === 0) ? b : (D.head = he, he.done = !1, h);
        }
        function ye(te, he) {
          var D = he.length, Se, le, v;
          return !te || !te.state || (Se = te.state, Se.wrap !== 0 && Se.mode !== Q) ? b : Se.mode === Q && (le = 1, le = x(le, he, D, 0), le !== Se.check) ? S : (v = pe(te, he, D, D), v ? (Se.mode = re, o) : (Se.havedict = 1, h));
        }
        _.inflateReset = f, _.inflateReset2 = C, _.inflateResetKeep = r, _.inflateInit = B, _.inflateInit2 = R, _.inflate = P, _.inflateEnd = q, _.inflateGetHeader = K, _.inflateSetDictionary = ye, _.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 36, "./adler32": 37, "./crc32": 39, "./inffast": 41, "./inftrees": 43 }], 43: [function(k, Z, _) {
        var M = k("../utils/common"), x = 15, y = 852, E = 592, c = 0, u = 1, l = 2, a = [
          /* Length codes 257..285 base */
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ], n = [
          /* Length codes 257..285 extra */
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ], d = [
          /* Distance codes 0..29 base */
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ], g = [
          /* Distance codes 0..29 extra */
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ];
        Z.exports = function(m, s, b, S, o, A, T, I) {
          var L = I.bits, z = 0, U = 0, J = 0, F = 0, oe = 0, ee = 0, ie = 0, W = 0, Q = 0, de = 0, we, ke, Me, fe, xe, Ee = null, Pe = 0, Ue, He = new M.Buf16(x + 1), We = new M.Buf16(x + 1), Ze = null, $e = 0, Ve, Ge, Ie;
          for (z = 0; z <= x; z++)
            He[z] = 0;
          for (U = 0; U < S; U++)
            He[s[b + U]]++;
          for (oe = L, F = x; F >= 1 && He[F] === 0; F--)
            ;
          if (oe > F && (oe = F), F === 0)
            return o[A++] = 1 << 24 | 64 << 16 | 0, o[A++] = 1 << 24 | 64 << 16 | 0, I.bits = 1, 0;
          for (J = 1; J < F && He[J] === 0; J++)
            ;
          for (oe < J && (oe = J), W = 1, z = 1; z <= x; z++)
            if (W <<= 1, W -= He[z], W < 0)
              return -1;
          if (W > 0 && (m === c || F !== 1))
            return -1;
          for (We[1] = 0, z = 1; z < x; z++)
            We[z + 1] = We[z] + He[z];
          for (U = 0; U < S; U++)
            s[b + U] !== 0 && (T[We[s[b + U]]++] = U);
          if (m === c ? (Ee = Ze = T, Ue = 19) : m === u ? (Ee = a, Pe -= 257, Ze = n, $e -= 257, Ue = 256) : (Ee = d, Ze = g, Ue = -1), de = 0, U = 0, z = J, xe = A, ee = oe, ie = 0, Me = -1, Q = 1 << oe, fe = Q - 1, m === u && Q > y || m === l && Q > E)
            return 1;
          for (; ; ) {
            Ve = z - ie, T[U] < Ue ? (Ge = 0, Ie = T[U]) : T[U] > Ue ? (Ge = Ze[$e + T[U]], Ie = Ee[Pe + T[U]]) : (Ge = 96, Ie = 0), we = 1 << z - ie, ke = 1 << ee, J = ke;
            do
              ke -= we, o[xe + (de >> ie) + ke] = Ve << 24 | Ge << 16 | Ie | 0;
            while (ke !== 0);
            for (we = 1 << z - 1; de & we; )
              we >>= 1;
            if (we !== 0 ? (de &= we - 1, de += we) : de = 0, U++, --He[z] === 0) {
              if (z === F)
                break;
              z = s[b + T[U]];
            }
            if (z > oe && (de & fe) !== Me) {
              for (ie === 0 && (ie = oe), xe += J, ee = z - ie, W = 1 << ee; ee + ie < F && (W -= He[ee + ie], !(W <= 0)); )
                ee++, W <<= 1;
              if (Q += 1 << ee, m === u && Q > y || m === l && Q > E)
                return 1;
              Me = de & fe, o[Me] = oe << 24 | ee << 16 | xe - A | 0;
            }
          }
          return de !== 0 && (o[xe + de] = z - ie << 24 | 64 << 16 | 0), I.bits = oe, 0;
        };
      }, { "../utils/common": 36 }], 44: [function(k, Z, _) {
        Z.exports = {
          2: "need dictionary",
          /* Z_NEED_DICT       2  */
          1: "stream end",
          /* Z_STREAM_END      1  */
          0: "",
          /* Z_OK              0  */
          "-1": "file error",
          /* Z_ERRNO         (-1) */
          "-2": "stream error",
          /* Z_STREAM_ERROR  (-2) */
          "-3": "data error",
          /* Z_DATA_ERROR    (-3) */
          "-4": "insufficient memory",
          /* Z_MEM_ERROR     (-4) */
          "-5": "buffer error",
          /* Z_BUF_ERROR     (-5) */
          "-6": "incompatible version"
          /* Z_VERSION_ERROR (-6) */
        };
      }, {}], 45: [function(k, Z, _) {
        var M = k("../utils/common"), x = 4, y = 0, E = 1, c = 2;
        function u(P) {
          for (var q = P.length; --q >= 0; )
            P[q] = 0;
        }
        var l = 0, a = 1, n = 2, d = 3, g = 258, h = 29, m = 256, s = m + 1 + h, b = 30, S = 19, o = 2 * s + 1, A = 15, T = 16, I = 7, L = 256, z = 16, U = 17, J = 18, F = (
          /* extra bits for each length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
        ), oe = (
          /* extra bits for each distance code */
          [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
        ), ee = (
          /* extra bits for each bit length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
        ), ie = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], W = 512, Q = new Array((s + 2) * 2);
        u(Q);
        var de = new Array(b * 2);
        u(de);
        var we = new Array(W);
        u(we);
        var ke = new Array(g - d + 1);
        u(ke);
        var Me = new Array(h);
        u(Me);
        var fe = new Array(b);
        u(fe);
        function xe(P, q, K, ye, te) {
          this.static_tree = P, this.extra_bits = q, this.extra_base = K, this.elems = ye, this.max_length = te, this.has_stree = P && P.length;
        }
        var Ee, Pe, Ue;
        function He(P, q) {
          this.dyn_tree = P, this.max_code = 0, this.stat_desc = q;
        }
        function We(P) {
          return P < 256 ? we[P] : we[256 + (P >>> 7)];
        }
        function Ze(P, q) {
          P.pending_buf[P.pending++] = q & 255, P.pending_buf[P.pending++] = q >>> 8 & 255;
        }
        function $e(P, q, K) {
          P.bi_valid > T - K ? (P.bi_buf |= q << P.bi_valid & 65535, Ze(P, P.bi_buf), P.bi_buf = q >> T - P.bi_valid, P.bi_valid += K - T) : (P.bi_buf |= q << P.bi_valid & 65535, P.bi_valid += K);
        }
        function Ve(P, q, K) {
          $e(
            P,
            K[q * 2],
            K[q * 2 + 1]
            /*.Len*/
          );
        }
        function Ge(P, q) {
          var K = 0;
          do
            K |= P & 1, P >>>= 1, K <<= 1;
          while (--q > 0);
          return K >>> 1;
        }
        function Ie(P) {
          P.bi_valid === 16 ? (Ze(P, P.bi_buf), P.bi_buf = 0, P.bi_valid = 0) : P.bi_valid >= 8 && (P.pending_buf[P.pending++] = P.bi_buf & 255, P.bi_buf >>= 8, P.bi_valid -= 8);
        }
        function De(P, q) {
          var K = q.dyn_tree, ye = q.max_code, te = q.stat_desc.static_tree, he = q.stat_desc.has_stree, D = q.stat_desc.extra_bits, Se = q.stat_desc.extra_base, le = q.stat_desc.max_length, v, se, me, O, ce, Oe, Be = 0;
          for (O = 0; O <= A; O++)
            P.bl_count[O] = 0;
          for (K[P.heap[P.heap_max] * 2 + 1] = 0, v = P.heap_max + 1; v < o; v++)
            se = P.heap[v], O = K[K[se * 2 + 1] * 2 + 1] + 1, O > le && (O = le, Be++), K[se * 2 + 1] = O, !(se > ye) && (P.bl_count[O]++, ce = 0, se >= Se && (ce = D[se - Se]), Oe = K[se * 2], P.opt_len += Oe * (O + ce), he && (P.static_len += Oe * (te[se * 2 + 1] + ce)));
          if (Be !== 0) {
            do {
              for (O = le - 1; P.bl_count[O] === 0; )
                O--;
              P.bl_count[O]--, P.bl_count[O + 1] += 2, P.bl_count[le]--, Be -= 2;
            } while (Be > 0);
            for (O = le; O !== 0; O--)
              for (se = P.bl_count[O]; se !== 0; )
                me = P.heap[--v], !(me > ye) && (K[me * 2 + 1] !== O && (P.opt_len += (O - K[me * 2 + 1]) * K[me * 2], K[me * 2 + 1] = O), se--);
          }
        }
        function Ne(P, q, K) {
          var ye = new Array(A + 1), te = 0, he, D;
          for (he = 1; he <= A; he++)
            ye[he] = te = te + K[he - 1] << 1;
          for (D = 0; D <= q; D++) {
            var Se = P[D * 2 + 1];
            Se !== 0 && (P[D * 2] = Ge(ye[Se]++, Se));
          }
        }
        function _e() {
          var P, q, K, ye, te, he = new Array(A + 1);
          for (K = 0, ye = 0; ye < h - 1; ye++)
            for (Me[ye] = K, P = 0; P < 1 << F[ye]; P++)
              ke[K++] = ye;
          for (ke[K - 1] = ye, te = 0, ye = 0; ye < 16; ye++)
            for (fe[ye] = te, P = 0; P < 1 << oe[ye]; P++)
              we[te++] = ye;
          for (te >>= 7; ye < b; ye++)
            for (fe[ye] = te << 7, P = 0; P < 1 << oe[ye] - 7; P++)
              we[256 + te++] = ye;
          for (q = 0; q <= A; q++)
            he[q] = 0;
          for (P = 0; P <= 143; )
            Q[P * 2 + 1] = 8, P++, he[8]++;
          for (; P <= 255; )
            Q[P * 2 + 1] = 9, P++, he[9]++;
          for (; P <= 279; )
            Q[P * 2 + 1] = 7, P++, he[7]++;
          for (; P <= 287; )
            Q[P * 2 + 1] = 8, P++, he[8]++;
          for (Ne(Q, s + 1, he), P = 0; P < b; P++)
            de[P * 2 + 1] = 5, de[P * 2] = Ge(P, 5);
          Ee = new xe(Q, F, m + 1, s, A), Pe = new xe(de, oe, 0, b, A), Ue = new xe(new Array(0), ee, 0, S, I);
        }
        function re(P) {
          var q;
          for (q = 0; q < s; q++)
            P.dyn_ltree[q * 2] = 0;
          for (q = 0; q < b; q++)
            P.dyn_dtree[q * 2] = 0;
          for (q = 0; q < S; q++)
            P.bl_tree[q * 2] = 0;
          P.dyn_ltree[L * 2] = 1, P.opt_len = P.static_len = 0, P.last_lit = P.matches = 0;
        }
        function $(P) {
          P.bi_valid > 8 ? Ze(P, P.bi_buf) : P.bi_valid > 0 && (P.pending_buf[P.pending++] = P.bi_buf), P.bi_buf = 0, P.bi_valid = 0;
        }
        function Ce(P, q, K, ye) {
          $(P), Ze(P, K), Ze(P, ~K), M.arraySet(P.pending_buf, P.window, q, K, P.pending), P.pending += K;
        }
        function ve(P, q, K, ye) {
          var te = q * 2, he = K * 2;
          return P[te] < P[he] || P[te] === P[he] && ye[q] <= ye[K];
        }
        function Y(P, q, K) {
          for (var ye = P.heap[K], te = K << 1; te <= P.heap_len && (te < P.heap_len && ve(q, P.heap[te + 1], P.heap[te], P.depth) && te++, !ve(q, ye, P.heap[te], P.depth)); )
            P.heap[K] = P.heap[te], K = te, te <<= 1;
          P.heap[K] = ye;
        }
        function G(P, q, K) {
          var ye, te, he = 0, D, Se;
          if (P.last_lit !== 0)
            do
              ye = P.pending_buf[P.d_buf + he * 2] << 8 | P.pending_buf[P.d_buf + he * 2 + 1], te = P.pending_buf[P.l_buf + he], he++, ye === 0 ? Ve(P, te, q) : (D = ke[te], Ve(P, D + m + 1, q), Se = F[D], Se !== 0 && (te -= Me[D], $e(P, te, Se)), ye--, D = We(ye), Ve(P, D, K), Se = oe[D], Se !== 0 && (ye -= fe[D], $e(P, ye, Se)));
            while (he < P.last_lit);
          Ve(P, L, q);
        }
        function Ae(P, q) {
          var K = q.dyn_tree, ye = q.stat_desc.static_tree, te = q.stat_desc.has_stree, he = q.stat_desc.elems, D, Se, le = -1, v;
          for (P.heap_len = 0, P.heap_max = o, D = 0; D < he; D++)
            K[D * 2] !== 0 ? (P.heap[++P.heap_len] = le = D, P.depth[D] = 0) : K[D * 2 + 1] = 0;
          for (; P.heap_len < 2; )
            v = P.heap[++P.heap_len] = le < 2 ? ++le : 0, K[v * 2] = 1, P.depth[v] = 0, P.opt_len--, te && (P.static_len -= ye[v * 2 + 1]);
          for (q.max_code = le, D = P.heap_len >> 1; D >= 1; D--)
            Y(P, K, D);
          v = he;
          do
            D = P.heap[
              1
              /*SMALLEST*/
            ], P.heap[
              1
              /*SMALLEST*/
            ] = P.heap[P.heap_len--], Y(
              P,
              K,
              1
              /*SMALLEST*/
            ), Se = P.heap[
              1
              /*SMALLEST*/
            ], P.heap[--P.heap_max] = D, P.heap[--P.heap_max] = Se, K[v * 2] = K[D * 2] + K[Se * 2], P.depth[v] = (P.depth[D] >= P.depth[Se] ? P.depth[D] : P.depth[Se]) + 1, K[D * 2 + 1] = K[Se * 2 + 1] = v, P.heap[
              1
              /*SMALLEST*/
            ] = v++, Y(
              P,
              K,
              1
              /*SMALLEST*/
            );
          while (P.heap_len >= 2);
          P.heap[--P.heap_max] = P.heap[
            1
            /*SMALLEST*/
          ], De(P, q), Ne(K, le, P.bl_count);
        }
        function e(P, q, K) {
          var ye, te = -1, he, D = q[0 * 2 + 1], Se = 0, le = 7, v = 4;
          for (D === 0 && (le = 138, v = 3), q[(K + 1) * 2 + 1] = 65535, ye = 0; ye <= K; ye++)
            he = D, D = q[(ye + 1) * 2 + 1], !(++Se < le && he === D) && (Se < v ? P.bl_tree[he * 2] += Se : he !== 0 ? (he !== te && P.bl_tree[he * 2]++, P.bl_tree[z * 2]++) : Se <= 10 ? P.bl_tree[U * 2]++ : P.bl_tree[J * 2]++, Se = 0, te = he, D === 0 ? (le = 138, v = 3) : he === D ? (le = 6, v = 3) : (le = 7, v = 4));
        }
        function r(P, q, K) {
          var ye, te = -1, he, D = q[0 * 2 + 1], Se = 0, le = 7, v = 4;
          for (D === 0 && (le = 138, v = 3), ye = 0; ye <= K; ye++)
            if (he = D, D = q[(ye + 1) * 2 + 1], !(++Se < le && he === D)) {
              if (Se < v)
                do
                  Ve(P, he, P.bl_tree);
                while (--Se !== 0);
              else he !== 0 ? (he !== te && (Ve(P, he, P.bl_tree), Se--), Ve(P, z, P.bl_tree), $e(P, Se - 3, 2)) : Se <= 10 ? (Ve(P, U, P.bl_tree), $e(P, Se - 3, 3)) : (Ve(P, J, P.bl_tree), $e(P, Se - 11, 7));
              Se = 0, te = he, D === 0 ? (le = 138, v = 3) : he === D ? (le = 6, v = 3) : (le = 7, v = 4);
            }
        }
        function f(P) {
          var q;
          for (e(P, P.dyn_ltree, P.l_desc.max_code), e(P, P.dyn_dtree, P.d_desc.max_code), Ae(P, P.bl_desc), q = S - 1; q >= 3 && P.bl_tree[ie[q] * 2 + 1] === 0; q--)
            ;
          return P.opt_len += 3 * (q + 1) + 5 + 5 + 4, q;
        }
        function C(P, q, K, ye) {
          var te;
          for ($e(P, q - 257, 5), $e(P, K - 1, 5), $e(P, ye - 4, 4), te = 0; te < ye; te++)
            $e(P, P.bl_tree[ie[te] * 2 + 1], 3);
          r(P, P.dyn_ltree, q - 1), r(P, P.dyn_dtree, K - 1);
        }
        function R(P) {
          var q = 4093624447, K;
          for (K = 0; K <= 31; K++, q >>>= 1)
            if (q & 1 && P.dyn_ltree[K * 2] !== 0)
              return y;
          if (P.dyn_ltree[9 * 2] !== 0 || P.dyn_ltree[10 * 2] !== 0 || P.dyn_ltree[13 * 2] !== 0)
            return E;
          for (K = 32; K < m; K++)
            if (P.dyn_ltree[K * 2] !== 0)
              return E;
          return y;
        }
        var B = !1;
        function j(P) {
          B || (_e(), B = !0), P.l_desc = new He(P.dyn_ltree, Ee), P.d_desc = new He(P.dyn_dtree, Pe), P.bl_desc = new He(P.bl_tree, Ue), P.bi_buf = 0, P.bi_valid = 0, re(P);
        }
        function H(P, q, K, ye) {
          $e(P, (l << 1) + (ye ? 1 : 0), 3), Ce(P, q, K);
        }
        function X(P) {
          $e(P, a << 1, 3), Ve(P, L, Q), Ie(P);
        }
        function ue(P, q, K, ye) {
          var te, he, D = 0;
          P.level > 0 ? (P.strm.data_type === c && (P.strm.data_type = R(P)), Ae(P, P.l_desc), Ae(P, P.d_desc), D = f(P), te = P.opt_len + 3 + 7 >>> 3, he = P.static_len + 3 + 7 >>> 3, he <= te && (te = he)) : te = he = K + 5, K + 4 <= te && q !== -1 ? H(P, q, K, ye) : P.strategy === x || he === te ? ($e(P, (a << 1) + (ye ? 1 : 0), 3), G(P, Q, de)) : ($e(P, (n << 1) + (ye ? 1 : 0), 3), C(P, P.l_desc.max_code + 1, P.d_desc.max_code + 1, D + 1), G(P, P.dyn_ltree, P.dyn_dtree)), re(P), ye && $(P);
        }
        function pe(P, q, K) {
          return P.pending_buf[P.d_buf + P.last_lit * 2] = q >>> 8 & 255, P.pending_buf[P.d_buf + P.last_lit * 2 + 1] = q & 255, P.pending_buf[P.l_buf + P.last_lit] = K & 255, P.last_lit++, q === 0 ? P.dyn_ltree[K * 2]++ : (P.matches++, q--, P.dyn_ltree[(ke[K] + m + 1) * 2]++, P.dyn_dtree[We(q) * 2]++), P.last_lit === P.lit_bufsize - 1;
        }
        _._tr_init = j, _._tr_stored_block = H, _._tr_flush_block = ue, _._tr_tally = pe, _._tr_align = X;
      }, { "../utils/common": 36 }], 46: [function(k, Z, _) {
        function M() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        }
        Z.exports = M;
      }, {}], 47: [function(k, Z, _) {
        arguments[4][33][0].apply(_, arguments);
      }, { dup: 33 }], 48: [function(k, Z, _) {
        (function(a) {
          var x = k("base64-js"), y = k("ieee754"), E = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
          _.Buffer = a, _.SlowBuffer = A, _.INSPECT_MAX_BYTES = 50;
          var c = 2147483647;
          _.kMaxLength = c, a.TYPED_ARRAY_SUPPORT = u(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          );
          function u() {
            try {
              var ve = new Uint8Array(1), Y = { foo: function() {
                return 42;
              } };
              return Object.setPrototypeOf(Y, Uint8Array.prototype), Object.setPrototypeOf(ve, Y), ve.foo() === 42;
            } catch {
              return !1;
            }
          }
          Object.defineProperty(a.prototype, "parent", {
            enumerable: !0,
            get: function() {
              if (a.isBuffer(this))
                return this.buffer;
            }
          }), Object.defineProperty(a.prototype, "offset", {
            enumerable: !0,
            get: function() {
              if (a.isBuffer(this))
                return this.byteOffset;
            }
          });
          function l(ve) {
            if (ve > c)
              throw new RangeError('The value "' + ve + '" is invalid for option "size"');
            var Y = new Uint8Array(ve);
            return Object.setPrototypeOf(Y, a.prototype), Y;
          }
          function a(ve, Y, G) {
            if (typeof ve == "number") {
              if (typeof Y == "string")
                throw new TypeError(
                  'The "string" argument must be of type string. Received type number'
                );
              return h(ve);
            }
            return n(ve, Y, G);
          }
          typeof Symbol < "u" && Symbol.species != null && a[Symbol.species] === a && Object.defineProperty(a, Symbol.species, {
            value: null,
            configurable: !0,
            enumerable: !1,
            writable: !1
          }), a.poolSize = 8192;
          function n(ve, Y, G) {
            if (typeof ve == "string")
              return m(ve, Y);
            if (ArrayBuffer.isView(ve))
              return s(ve);
            if (ve == null)
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ve
              );
            if (re(ve, ArrayBuffer) || ve && re(ve.buffer, ArrayBuffer))
              return b(ve, Y, G);
            if (typeof ve == "number")
              throw new TypeError(
                'The "value" argument must not be of type number. Received type number'
              );
            var Ae = ve.valueOf && ve.valueOf();
            if (Ae != null && Ae !== ve)
              return a.from(Ae, Y, G);
            var e = S(ve);
            if (e) return e;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ve[Symbol.toPrimitive] == "function")
              return a.from(
                ve[Symbol.toPrimitive]("string"),
                Y,
                G
              );
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ve
            );
          }
          a.from = function(ve, Y, G) {
            return n(ve, Y, G);
          }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
          function d(ve) {
            if (typeof ve != "number")
              throw new TypeError('"size" argument must be of type number');
            if (ve < 0)
              throw new RangeError('The value "' + ve + '" is invalid for option "size"');
          }
          function g(ve, Y, G) {
            return d(ve), ve <= 0 ? l(ve) : Y !== void 0 ? typeof G == "string" ? l(ve).fill(Y, G) : l(ve).fill(Y) : l(ve);
          }
          a.alloc = function(ve, Y, G) {
            return g(ve, Y, G);
          };
          function h(ve) {
            return d(ve), l(ve < 0 ? 0 : o(ve) | 0);
          }
          a.allocUnsafe = function(ve) {
            return h(ve);
          }, a.allocUnsafeSlow = function(ve) {
            return h(ve);
          };
          function m(ve, Y) {
            if ((typeof Y != "string" || Y === "") && (Y = "utf8"), !a.isEncoding(Y))
              throw new TypeError("Unknown encoding: " + Y);
            var G = T(ve, Y) | 0, Ae = l(G), e = Ae.write(ve, Y);
            return e !== G && (Ae = Ae.slice(0, e)), Ae;
          }
          function s(ve) {
            for (var Y = ve.length < 0 ? 0 : o(ve.length) | 0, G = l(Y), Ae = 0; Ae < Y; Ae += 1)
              G[Ae] = ve[Ae] & 255;
            return G;
          }
          function b(ve, Y, G) {
            if (Y < 0 || ve.byteLength < Y)
              throw new RangeError('"offset" is outside of buffer bounds');
            if (ve.byteLength < Y + (G || 0))
              throw new RangeError('"length" is outside of buffer bounds');
            var Ae;
            return Y === void 0 && G === void 0 ? Ae = new Uint8Array(ve) : G === void 0 ? Ae = new Uint8Array(ve, Y) : Ae = new Uint8Array(ve, Y, G), Object.setPrototypeOf(Ae, a.prototype), Ae;
          }
          function S(ve) {
            if (a.isBuffer(ve)) {
              var Y = o(ve.length) | 0, G = l(Y);
              return G.length === 0 || ve.copy(G, 0, 0, Y), G;
            }
            if (ve.length !== void 0)
              return typeof ve.length != "number" || $(ve.length) ? l(0) : s(ve);
            if (ve.type === "Buffer" && Array.isArray(ve.data))
              return s(ve.data);
          }
          function o(ve) {
            if (ve >= c)
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + c.toString(16) + " bytes");
            return ve | 0;
          }
          function A(ve) {
            return +ve != ve && (ve = 0), a.alloc(+ve);
          }
          a.isBuffer = function(Y) {
            return Y != null && Y._isBuffer === !0 && Y !== a.prototype;
          }, a.compare = function(Y, G) {
            if (re(Y, Uint8Array) && (Y = a.from(Y, Y.offset, Y.byteLength)), re(G, Uint8Array) && (G = a.from(G, G.offset, G.byteLength)), !a.isBuffer(Y) || !a.isBuffer(G))
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
              );
            if (Y === G) return 0;
            for (var Ae = Y.length, e = G.length, r = 0, f = Math.min(Ae, e); r < f; ++r)
              if (Y[r] !== G[r]) {
                Ae = Y[r], e = G[r];
                break;
              }
            return Ae < e ? -1 : e < Ae ? 1 : 0;
          }, a.isEncoding = function(Y) {
            switch (String(Y).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, a.concat = function(Y, G) {
            if (!Array.isArray(Y))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (Y.length === 0)
              return a.alloc(0);
            var Ae;
            if (G === void 0)
              for (G = 0, Ae = 0; Ae < Y.length; ++Ae)
                G += Y[Ae].length;
            var e = a.allocUnsafe(G), r = 0;
            for (Ae = 0; Ae < Y.length; ++Ae) {
              var f = Y[Ae];
              if (re(f, Uint8Array) && (f = a.from(f)), !a.isBuffer(f))
                throw new TypeError('"list" argument must be an Array of Buffers');
              f.copy(e, r), r += f.length;
            }
            return e;
          };
          function T(ve, Y) {
            if (a.isBuffer(ve))
              return ve.length;
            if (ArrayBuffer.isView(ve) || re(ve, ArrayBuffer))
              return ve.byteLength;
            if (typeof ve != "string")
              throw new TypeError(
                'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ve
              );
            var G = ve.length, Ae = arguments.length > 2 && arguments[2] === !0;
            if (!Ae && G === 0) return 0;
            for (var e = !1; ; )
              switch (Y) {
                case "ascii":
                case "latin1":
                case "binary":
                  return G;
                case "utf8":
                case "utf-8":
                  return Ge(ve).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return G * 2;
                case "hex":
                  return G >>> 1;
                case "base64":
                  return Ne(ve).length;
                default:
                  if (e)
                    return Ae ? -1 : Ge(ve).length;
                  Y = ("" + Y).toLowerCase(), e = !0;
              }
          }
          a.byteLength = T;
          function I(ve, Y, G) {
            var Ae = !1;
            if ((Y === void 0 || Y < 0) && (Y = 0), Y > this.length || ((G === void 0 || G > this.length) && (G = this.length), G <= 0) || (G >>>= 0, Y >>>= 0, G <= Y))
              return "";
            for (ve || (ve = "utf8"); ; )
              switch (ve) {
                case "hex":
                  return xe(this, Y, G);
                case "utf8":
                case "utf-8":
                  return de(this, Y, G);
                case "ascii":
                  return Me(this, Y, G);
                case "latin1":
                case "binary":
                  return fe(this, Y, G);
                case "base64":
                  return Q(this, Y, G);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return Ee(this, Y, G);
                default:
                  if (Ae) throw new TypeError("Unknown encoding: " + ve);
                  ve = (ve + "").toLowerCase(), Ae = !0;
              }
          }
          a.prototype._isBuffer = !0;
          function L(ve, Y, G) {
            var Ae = ve[Y];
            ve[Y] = ve[G], ve[G] = Ae;
          }
          a.prototype.swap16 = function() {
            var Y = this.length;
            if (Y % 2 !== 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var G = 0; G < Y; G += 2)
              L(this, G, G + 1);
            return this;
          }, a.prototype.swap32 = function() {
            var Y = this.length;
            if (Y % 4 !== 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var G = 0; G < Y; G += 4)
              L(this, G, G + 3), L(this, G + 1, G + 2);
            return this;
          }, a.prototype.swap64 = function() {
            var Y = this.length;
            if (Y % 8 !== 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var G = 0; G < Y; G += 8)
              L(this, G, G + 7), L(this, G + 1, G + 6), L(this, G + 2, G + 5), L(this, G + 3, G + 4);
            return this;
          }, a.prototype.toString = function() {
            var Y = this.length;
            return Y === 0 ? "" : arguments.length === 0 ? de(this, 0, Y) : I.apply(this, arguments);
          }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(Y) {
            if (!a.isBuffer(Y)) throw new TypeError("Argument must be a Buffer");
            return this === Y ? !0 : a.compare(this, Y) === 0;
          }, a.prototype.inspect = function() {
            var Y = "", G = _.INSPECT_MAX_BYTES;
            return Y = this.toString("hex", 0, G).replace(/(.{2})/g, "$1 ").trim(), this.length > G && (Y += " ... "), "<Buffer " + Y + ">";
          }, E && (a.prototype[E] = a.prototype.inspect), a.prototype.compare = function(Y, G, Ae, e, r) {
            if (re(Y, Uint8Array) && (Y = a.from(Y, Y.offset, Y.byteLength)), !a.isBuffer(Y))
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Y
              );
            if (G === void 0 && (G = 0), Ae === void 0 && (Ae = Y ? Y.length : 0), e === void 0 && (e = 0), r === void 0 && (r = this.length), G < 0 || Ae > Y.length || e < 0 || r > this.length)
              throw new RangeError("out of range index");
            if (e >= r && G >= Ae)
              return 0;
            if (e >= r)
              return -1;
            if (G >= Ae)
              return 1;
            if (G >>>= 0, Ae >>>= 0, e >>>= 0, r >>>= 0, this === Y) return 0;
            for (var f = r - e, C = Ae - G, R = Math.min(f, C), B = this.slice(e, r), j = Y.slice(G, Ae), H = 0; H < R; ++H)
              if (B[H] !== j[H]) {
                f = B[H], C = j[H];
                break;
              }
            return f < C ? -1 : C < f ? 1 : 0;
          };
          function z(ve, Y, G, Ae, e) {
            if (ve.length === 0) return -1;
            if (typeof G == "string" ? (Ae = G, G = 0) : G > 2147483647 ? G = 2147483647 : G < -2147483648 && (G = -2147483648), G = +G, $(G) && (G = e ? 0 : ve.length - 1), G < 0 && (G = ve.length + G), G >= ve.length) {
              if (e) return -1;
              G = ve.length - 1;
            } else if (G < 0)
              if (e) G = 0;
              else return -1;
            if (typeof Y == "string" && (Y = a.from(Y, Ae)), a.isBuffer(Y))
              return Y.length === 0 ? -1 : U(ve, Y, G, Ae, e);
            if (typeof Y == "number")
              return Y = Y & 255, typeof Uint8Array.prototype.indexOf == "function" ? e ? Uint8Array.prototype.indexOf.call(ve, Y, G) : Uint8Array.prototype.lastIndexOf.call(ve, Y, G) : U(ve, [Y], G, Ae, e);
            throw new TypeError("val must be string, number or Buffer");
          }
          function U(ve, Y, G, Ae, e) {
            var r = 1, f = ve.length, C = Y.length;
            if (Ae !== void 0 && (Ae = String(Ae).toLowerCase(), Ae === "ucs2" || Ae === "ucs-2" || Ae === "utf16le" || Ae === "utf-16le")) {
              if (ve.length < 2 || Y.length < 2)
                return -1;
              r = 2, f /= 2, C /= 2, G /= 2;
            }
            function R(ue, pe) {
              return r === 1 ? ue[pe] : ue.readUInt16BE(pe * r);
            }
            var B;
            if (e) {
              var j = -1;
              for (B = G; B < f; B++)
                if (R(ve, B) === R(Y, j === -1 ? 0 : B - j)) {
                  if (j === -1 && (j = B), B - j + 1 === C) return j * r;
                } else
                  j !== -1 && (B -= B - j), j = -1;
            } else
              for (G + C > f && (G = f - C), B = G; B >= 0; B--) {
                for (var H = !0, X = 0; X < C; X++)
                  if (R(ve, B + X) !== R(Y, X)) {
                    H = !1;
                    break;
                  }
                if (H) return B;
              }
            return -1;
          }
          a.prototype.includes = function(Y, G, Ae) {
            return this.indexOf(Y, G, Ae) !== -1;
          }, a.prototype.indexOf = function(Y, G, Ae) {
            return z(this, Y, G, Ae, !0);
          }, a.prototype.lastIndexOf = function(Y, G, Ae) {
            return z(this, Y, G, Ae, !1);
          };
          function J(ve, Y, G, Ae) {
            G = Number(G) || 0;
            var e = ve.length - G;
            Ae ? (Ae = Number(Ae), Ae > e && (Ae = e)) : Ae = e;
            var r = Y.length;
            Ae > r / 2 && (Ae = r / 2);
            for (var f = 0; f < Ae; ++f) {
              var C = parseInt(Y.substr(f * 2, 2), 16);
              if ($(C)) return f;
              ve[G + f] = C;
            }
            return f;
          }
          function F(ve, Y, G, Ae) {
            return _e(Ge(Y, ve.length - G), ve, G, Ae);
          }
          function oe(ve, Y, G, Ae) {
            return _e(Ie(Y), ve, G, Ae);
          }
          function ee(ve, Y, G, Ae) {
            return oe(ve, Y, G, Ae);
          }
          function ie(ve, Y, G, Ae) {
            return _e(Ne(Y), ve, G, Ae);
          }
          function W(ve, Y, G, Ae) {
            return _e(De(Y, ve.length - G), ve, G, Ae);
          }
          a.prototype.write = function(Y, G, Ae, e) {
            if (G === void 0)
              e = "utf8", Ae = this.length, G = 0;
            else if (Ae === void 0 && typeof G == "string")
              e = G, Ae = this.length, G = 0;
            else if (isFinite(G))
              G = G >>> 0, isFinite(Ae) ? (Ae = Ae >>> 0, e === void 0 && (e = "utf8")) : (e = Ae, Ae = void 0);
            else
              throw new Error(
                "Buffer.write(string, encoding, offset[, length]) is no longer supported"
              );
            var r = this.length - G;
            if ((Ae === void 0 || Ae > r) && (Ae = r), Y.length > 0 && (Ae < 0 || G < 0) || G > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            e || (e = "utf8");
            for (var f = !1; ; )
              switch (e) {
                case "hex":
                  return J(this, Y, G, Ae);
                case "utf8":
                case "utf-8":
                  return F(this, Y, G, Ae);
                case "ascii":
                  return oe(this, Y, G, Ae);
                case "latin1":
                case "binary":
                  return ee(this, Y, G, Ae);
                case "base64":
                  return ie(this, Y, G, Ae);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return W(this, Y, G, Ae);
                default:
                  if (f) throw new TypeError("Unknown encoding: " + e);
                  e = ("" + e).toLowerCase(), f = !0;
              }
          }, a.prototype.toJSON = function() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function Q(ve, Y, G) {
            return Y === 0 && G === ve.length ? x.fromByteArray(ve) : x.fromByteArray(ve.slice(Y, G));
          }
          function de(ve, Y, G) {
            G = Math.min(ve.length, G);
            for (var Ae = [], e = Y; e < G; ) {
              var r = ve[e], f = null, C = r > 239 ? 4 : r > 223 ? 3 : r > 191 ? 2 : 1;
              if (e + C <= G) {
                var R, B, j, H;
                switch (C) {
                  case 1:
                    r < 128 && (f = r);
                    break;
                  case 2:
                    R = ve[e + 1], (R & 192) === 128 && (H = (r & 31) << 6 | R & 63, H > 127 && (f = H));
                    break;
                  case 3:
                    R = ve[e + 1], B = ve[e + 2], (R & 192) === 128 && (B & 192) === 128 && (H = (r & 15) << 12 | (R & 63) << 6 | B & 63, H > 2047 && (H < 55296 || H > 57343) && (f = H));
                    break;
                  case 4:
                    R = ve[e + 1], B = ve[e + 2], j = ve[e + 3], (R & 192) === 128 && (B & 192) === 128 && (j & 192) === 128 && (H = (r & 15) << 18 | (R & 63) << 12 | (B & 63) << 6 | j & 63, H > 65535 && H < 1114112 && (f = H));
                }
              }
              f === null ? (f = 65533, C = 1) : f > 65535 && (f -= 65536, Ae.push(f >>> 10 & 1023 | 55296), f = 56320 | f & 1023), Ae.push(f), e += C;
            }
            return ke(Ae);
          }
          var we = 4096;
          function ke(ve) {
            var Y = ve.length;
            if (Y <= we)
              return String.fromCharCode.apply(String, ve);
            for (var G = "", Ae = 0; Ae < Y; )
              G += String.fromCharCode.apply(
                String,
                ve.slice(Ae, Ae += we)
              );
            return G;
          }
          function Me(ve, Y, G) {
            var Ae = "";
            G = Math.min(ve.length, G);
            for (var e = Y; e < G; ++e)
              Ae += String.fromCharCode(ve[e] & 127);
            return Ae;
          }
          function fe(ve, Y, G) {
            var Ae = "";
            G = Math.min(ve.length, G);
            for (var e = Y; e < G; ++e)
              Ae += String.fromCharCode(ve[e]);
            return Ae;
          }
          function xe(ve, Y, G) {
            var Ae = ve.length;
            (!Y || Y < 0) && (Y = 0), (!G || G < 0 || G > Ae) && (G = Ae);
            for (var e = "", r = Y; r < G; ++r)
              e += Ce[ve[r]];
            return e;
          }
          function Ee(ve, Y, G) {
            for (var Ae = ve.slice(Y, G), e = "", r = 0; r < Ae.length; r += 2)
              e += String.fromCharCode(Ae[r] + Ae[r + 1] * 256);
            return e;
          }
          a.prototype.slice = function(Y, G) {
            var Ae = this.length;
            Y = ~~Y, G = G === void 0 ? Ae : ~~G, Y < 0 ? (Y += Ae, Y < 0 && (Y = 0)) : Y > Ae && (Y = Ae), G < 0 ? (G += Ae, G < 0 && (G = 0)) : G > Ae && (G = Ae), G < Y && (G = Y);
            var e = this.subarray(Y, G);
            return Object.setPrototypeOf(e, a.prototype), e;
          };
          function Pe(ve, Y, G) {
            if (ve % 1 !== 0 || ve < 0) throw new RangeError("offset is not uint");
            if (ve + Y > G) throw new RangeError("Trying to access beyond buffer length");
          }
          a.prototype.readUIntLE = function(Y, G, Ae) {
            Y = Y >>> 0, G = G >>> 0, Ae || Pe(Y, G, this.length);
            for (var e = this[Y], r = 1, f = 0; ++f < G && (r *= 256); )
              e += this[Y + f] * r;
            return e;
          }, a.prototype.readUIntBE = function(Y, G, Ae) {
            Y = Y >>> 0, G = G >>> 0, Ae || Pe(Y, G, this.length);
            for (var e = this[Y + --G], r = 1; G > 0 && (r *= 256); )
              e += this[Y + --G] * r;
            return e;
          }, a.prototype.readUInt8 = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 1, this.length), this[Y];
          }, a.prototype.readUInt16LE = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 2, this.length), this[Y] | this[Y + 1] << 8;
          }, a.prototype.readUInt16BE = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 2, this.length), this[Y] << 8 | this[Y + 1];
          }, a.prototype.readUInt32LE = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 4, this.length), (this[Y] | this[Y + 1] << 8 | this[Y + 2] << 16) + this[Y + 3] * 16777216;
          }, a.prototype.readUInt32BE = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 4, this.length), this[Y] * 16777216 + (this[Y + 1] << 16 | this[Y + 2] << 8 | this[Y + 3]);
          }, a.prototype.readIntLE = function(Y, G, Ae) {
            Y = Y >>> 0, G = G >>> 0, Ae || Pe(Y, G, this.length);
            for (var e = this[Y], r = 1, f = 0; ++f < G && (r *= 256); )
              e += this[Y + f] * r;
            return r *= 128, e >= r && (e -= Math.pow(2, 8 * G)), e;
          }, a.prototype.readIntBE = function(Y, G, Ae) {
            Y = Y >>> 0, G = G >>> 0, Ae || Pe(Y, G, this.length);
            for (var e = G, r = 1, f = this[Y + --e]; e > 0 && (r *= 256); )
              f += this[Y + --e] * r;
            return r *= 128, f >= r && (f -= Math.pow(2, 8 * G)), f;
          }, a.prototype.readInt8 = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 1, this.length), this[Y] & 128 ? (255 - this[Y] + 1) * -1 : this[Y];
          }, a.prototype.readInt16LE = function(Y, G) {
            Y = Y >>> 0, G || Pe(Y, 2, this.length);
            var Ae = this[Y] | this[Y + 1] << 8;
            return Ae & 32768 ? Ae | 4294901760 : Ae;
          }, a.prototype.readInt16BE = function(Y, G) {
            Y = Y >>> 0, G || Pe(Y, 2, this.length);
            var Ae = this[Y + 1] | this[Y] << 8;
            return Ae & 32768 ? Ae | 4294901760 : Ae;
          }, a.prototype.readInt32LE = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 4, this.length), this[Y] | this[Y + 1] << 8 | this[Y + 2] << 16 | this[Y + 3] << 24;
          }, a.prototype.readInt32BE = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 4, this.length), this[Y] << 24 | this[Y + 1] << 16 | this[Y + 2] << 8 | this[Y + 3];
          }, a.prototype.readFloatLE = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 4, this.length), y.read(this, Y, !0, 23, 4);
          }, a.prototype.readFloatBE = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 4, this.length), y.read(this, Y, !1, 23, 4);
          }, a.prototype.readDoubleLE = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 8, this.length), y.read(this, Y, !0, 52, 8);
          }, a.prototype.readDoubleBE = function(Y, G) {
            return Y = Y >>> 0, G || Pe(Y, 8, this.length), y.read(this, Y, !1, 52, 8);
          };
          function Ue(ve, Y, G, Ae, e, r) {
            if (!a.isBuffer(ve)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (Y > e || Y < r) throw new RangeError('"value" argument is out of bounds');
            if (G + Ae > ve.length) throw new RangeError("Index out of range");
          }
          a.prototype.writeUIntLE = function(Y, G, Ae, e) {
            if (Y = +Y, G = G >>> 0, Ae = Ae >>> 0, !e) {
              var r = Math.pow(2, 8 * Ae) - 1;
              Ue(this, Y, G, Ae, r, 0);
            }
            var f = 1, C = 0;
            for (this[G] = Y & 255; ++C < Ae && (f *= 256); )
              this[G + C] = Y / f & 255;
            return G + Ae;
          }, a.prototype.writeUIntBE = function(Y, G, Ae, e) {
            if (Y = +Y, G = G >>> 0, Ae = Ae >>> 0, !e) {
              var r = Math.pow(2, 8 * Ae) - 1;
              Ue(this, Y, G, Ae, r, 0);
            }
            var f = Ae - 1, C = 1;
            for (this[G + f] = Y & 255; --f >= 0 && (C *= 256); )
              this[G + f] = Y / C & 255;
            return G + Ae;
          }, a.prototype.writeUInt8 = function(Y, G, Ae) {
            return Y = +Y, G = G >>> 0, Ae || Ue(this, Y, G, 1, 255, 0), this[G] = Y & 255, G + 1;
          }, a.prototype.writeUInt16LE = function(Y, G, Ae) {
            return Y = +Y, G = G >>> 0, Ae || Ue(this, Y, G, 2, 65535, 0), this[G] = Y & 255, this[G + 1] = Y >>> 8, G + 2;
          }, a.prototype.writeUInt16BE = function(Y, G, Ae) {
            return Y = +Y, G = G >>> 0, Ae || Ue(this, Y, G, 2, 65535, 0), this[G] = Y >>> 8, this[G + 1] = Y & 255, G + 2;
          }, a.prototype.writeUInt32LE = function(Y, G, Ae) {
            return Y = +Y, G = G >>> 0, Ae || Ue(this, Y, G, 4, 4294967295, 0), this[G + 3] = Y >>> 24, this[G + 2] = Y >>> 16, this[G + 1] = Y >>> 8, this[G] = Y & 255, G + 4;
          }, a.prototype.writeUInt32BE = function(Y, G, Ae) {
            return Y = +Y, G = G >>> 0, Ae || Ue(this, Y, G, 4, 4294967295, 0), this[G] = Y >>> 24, this[G + 1] = Y >>> 16, this[G + 2] = Y >>> 8, this[G + 3] = Y & 255, G + 4;
          }, a.prototype.writeIntLE = function(Y, G, Ae, e) {
            if (Y = +Y, G = G >>> 0, !e) {
              var r = Math.pow(2, 8 * Ae - 1);
              Ue(this, Y, G, Ae, r - 1, -r);
            }
            var f = 0, C = 1, R = 0;
            for (this[G] = Y & 255; ++f < Ae && (C *= 256); )
              Y < 0 && R === 0 && this[G + f - 1] !== 0 && (R = 1), this[G + f] = (Y / C >> 0) - R & 255;
            return G + Ae;
          }, a.prototype.writeIntBE = function(Y, G, Ae, e) {
            if (Y = +Y, G = G >>> 0, !e) {
              var r = Math.pow(2, 8 * Ae - 1);
              Ue(this, Y, G, Ae, r - 1, -r);
            }
            var f = Ae - 1, C = 1, R = 0;
            for (this[G + f] = Y & 255; --f >= 0 && (C *= 256); )
              Y < 0 && R === 0 && this[G + f + 1] !== 0 && (R = 1), this[G + f] = (Y / C >> 0) - R & 255;
            return G + Ae;
          }, a.prototype.writeInt8 = function(Y, G, Ae) {
            return Y = +Y, G = G >>> 0, Ae || Ue(this, Y, G, 1, 127, -128), Y < 0 && (Y = 255 + Y + 1), this[G] = Y & 255, G + 1;
          }, a.prototype.writeInt16LE = function(Y, G, Ae) {
            return Y = +Y, G = G >>> 0, Ae || Ue(this, Y, G, 2, 32767, -32768), this[G] = Y & 255, this[G + 1] = Y >>> 8, G + 2;
          }, a.prototype.writeInt16BE = function(Y, G, Ae) {
            return Y = +Y, G = G >>> 0, Ae || Ue(this, Y, G, 2, 32767, -32768), this[G] = Y >>> 8, this[G + 1] = Y & 255, G + 2;
          }, a.prototype.writeInt32LE = function(Y, G, Ae) {
            return Y = +Y, G = G >>> 0, Ae || Ue(this, Y, G, 4, 2147483647, -2147483648), this[G] = Y & 255, this[G + 1] = Y >>> 8, this[G + 2] = Y >>> 16, this[G + 3] = Y >>> 24, G + 4;
          }, a.prototype.writeInt32BE = function(Y, G, Ae) {
            return Y = +Y, G = G >>> 0, Ae || Ue(this, Y, G, 4, 2147483647, -2147483648), Y < 0 && (Y = 4294967295 + Y + 1), this[G] = Y >>> 24, this[G + 1] = Y >>> 16, this[G + 2] = Y >>> 8, this[G + 3] = Y & 255, G + 4;
          };
          function He(ve, Y, G, Ae, e, r) {
            if (G + Ae > ve.length) throw new RangeError("Index out of range");
            if (G < 0) throw new RangeError("Index out of range");
          }
          function We(ve, Y, G, Ae, e) {
            return Y = +Y, G = G >>> 0, e || He(ve, Y, G, 4), y.write(ve, Y, G, Ae, 23, 4), G + 4;
          }
          a.prototype.writeFloatLE = function(Y, G, Ae) {
            return We(this, Y, G, !0, Ae);
          }, a.prototype.writeFloatBE = function(Y, G, Ae) {
            return We(this, Y, G, !1, Ae);
          };
          function Ze(ve, Y, G, Ae, e) {
            return Y = +Y, G = G >>> 0, e || He(ve, Y, G, 8), y.write(ve, Y, G, Ae, 52, 8), G + 8;
          }
          a.prototype.writeDoubleLE = function(Y, G, Ae) {
            return Ze(this, Y, G, !0, Ae);
          }, a.prototype.writeDoubleBE = function(Y, G, Ae) {
            return Ze(this, Y, G, !1, Ae);
          }, a.prototype.copy = function(Y, G, Ae, e) {
            if (!a.isBuffer(Y)) throw new TypeError("argument should be a Buffer");
            if (Ae || (Ae = 0), !e && e !== 0 && (e = this.length), G >= Y.length && (G = Y.length), G || (G = 0), e > 0 && e < Ae && (e = Ae), e === Ae || Y.length === 0 || this.length === 0) return 0;
            if (G < 0)
              throw new RangeError("targetStart out of bounds");
            if (Ae < 0 || Ae >= this.length) throw new RangeError("Index out of range");
            if (e < 0) throw new RangeError("sourceEnd out of bounds");
            e > this.length && (e = this.length), Y.length - G < e - Ae && (e = Y.length - G + Ae);
            var r = e - Ae;
            if (this === Y && typeof Uint8Array.prototype.copyWithin == "function")
              this.copyWithin(G, Ae, e);
            else if (this === Y && Ae < G && G < e)
              for (var f = r - 1; f >= 0; --f)
                Y[f + G] = this[f + Ae];
            else
              Uint8Array.prototype.set.call(
                Y,
                this.subarray(Ae, e),
                G
              );
            return r;
          }, a.prototype.fill = function(Y, G, Ae, e) {
            if (typeof Y == "string") {
              if (typeof G == "string" ? (e = G, G = 0, Ae = this.length) : typeof Ae == "string" && (e = Ae, Ae = this.length), e !== void 0 && typeof e != "string")
                throw new TypeError("encoding must be a string");
              if (typeof e == "string" && !a.isEncoding(e))
                throw new TypeError("Unknown encoding: " + e);
              if (Y.length === 1) {
                var r = Y.charCodeAt(0);
                (e === "utf8" && r < 128 || e === "latin1") && (Y = r);
              }
            } else typeof Y == "number" ? Y = Y & 255 : typeof Y == "boolean" && (Y = Number(Y));
            if (G < 0 || this.length < G || this.length < Ae)
              throw new RangeError("Out of range index");
            if (Ae <= G)
              return this;
            G = G >>> 0, Ae = Ae === void 0 ? this.length : Ae >>> 0, Y || (Y = 0);
            var f;
            if (typeof Y == "number")
              for (f = G; f < Ae; ++f)
                this[f] = Y;
            else {
              var C = a.isBuffer(Y) ? Y : a.from(Y, e), R = C.length;
              if (R === 0)
                throw new TypeError('The value "' + Y + '" is invalid for argument "value"');
              for (f = 0; f < Ae - G; ++f)
                this[f + G] = C[f % R];
            }
            return this;
          };
          var $e = /[^+/0-9A-Za-z-_]/g;
          function Ve(ve) {
            if (ve = ve.split("=")[0], ve = ve.trim().replace($e, ""), ve.length < 2) return "";
            for (; ve.length % 4 !== 0; )
              ve = ve + "=";
            return ve;
          }
          function Ge(ve, Y) {
            Y = Y || 1 / 0;
            for (var G, Ae = ve.length, e = null, r = [], f = 0; f < Ae; ++f) {
              if (G = ve.charCodeAt(f), G > 55295 && G < 57344) {
                if (!e) {
                  if (G > 56319) {
                    (Y -= 3) > -1 && r.push(239, 191, 189);
                    continue;
                  } else if (f + 1 === Ae) {
                    (Y -= 3) > -1 && r.push(239, 191, 189);
                    continue;
                  }
                  e = G;
                  continue;
                }
                if (G < 56320) {
                  (Y -= 3) > -1 && r.push(239, 191, 189), e = G;
                  continue;
                }
                G = (e - 55296 << 10 | G - 56320) + 65536;
              } else e && (Y -= 3) > -1 && r.push(239, 191, 189);
              if (e = null, G < 128) {
                if ((Y -= 1) < 0) break;
                r.push(G);
              } else if (G < 2048) {
                if ((Y -= 2) < 0) break;
                r.push(
                  G >> 6 | 192,
                  G & 63 | 128
                );
              } else if (G < 65536) {
                if ((Y -= 3) < 0) break;
                r.push(
                  G >> 12 | 224,
                  G >> 6 & 63 | 128,
                  G & 63 | 128
                );
              } else if (G < 1114112) {
                if ((Y -= 4) < 0) break;
                r.push(
                  G >> 18 | 240,
                  G >> 12 & 63 | 128,
                  G >> 6 & 63 | 128,
                  G & 63 | 128
                );
              } else
                throw new Error("Invalid code point");
            }
            return r;
          }
          function Ie(ve) {
            for (var Y = [], G = 0; G < ve.length; ++G)
              Y.push(ve.charCodeAt(G) & 255);
            return Y;
          }
          function De(ve, Y) {
            for (var G, Ae, e, r = [], f = 0; f < ve.length && !((Y -= 2) < 0); ++f)
              G = ve.charCodeAt(f), Ae = G >> 8, e = G % 256, r.push(e), r.push(Ae);
            return r;
          }
          function Ne(ve) {
            return x.toByteArray(Ve(ve));
          }
          function _e(ve, Y, G, Ae) {
            for (var e = 0; e < Ae && !(e + G >= Y.length || e >= ve.length); ++e)
              Y[e + G] = ve[e];
            return e;
          }
          function re(ve, Y) {
            return ve instanceof Y || ve != null && ve.constructor != null && ve.constructor.name != null && ve.constructor.name === Y.name;
          }
          function $(ve) {
            return ve !== ve;
          }
          var Ce = function() {
            for (var ve = "0123456789abcdef", Y = new Array(256), G = 0; G < 16; ++G)
              for (var Ae = G * 16, e = 0; e < 16; ++e)
                Y[Ae + e] = ve[G] + ve[e];
            return Y;
          }();
        }).call(this, k("buffer").Buffer);
      }, { "base64-js": 29, buffer: 48, ieee754: 73 }], 49: [function(k, Z, _) {
        var M = k("buffer").Buffer;
        Z.exports = function(x, y) {
          if (M.isBuffer(x) && M.isBuffer(y)) {
            if (typeof x.equals == "function") return x.equals(y);
            if (x.length !== y.length) return !1;
            for (var E = 0; E < x.length; E++)
              if (x[E] !== y[E]) return !1;
            return !0;
          }
        };
      }, { buffer: 48 }], 50: [function(k, Z, _) {
        Z.exports = {
          100: "Continue",
          101: "Switching Protocols",
          102: "Processing",
          200: "OK",
          201: "Created",
          202: "Accepted",
          203: "Non-Authoritative Information",
          204: "No Content",
          205: "Reset Content",
          206: "Partial Content",
          207: "Multi-Status",
          208: "Already Reported",
          226: "IM Used",
          300: "Multiple Choices",
          301: "Moved Permanently",
          302: "Found",
          303: "See Other",
          304: "Not Modified",
          305: "Use Proxy",
          307: "Temporary Redirect",
          308: "Permanent Redirect",
          400: "Bad Request",
          401: "Unauthorized",
          402: "Payment Required",
          403: "Forbidden",
          404: "Not Found",
          405: "Method Not Allowed",
          406: "Not Acceptable",
          407: "Proxy Authentication Required",
          408: "Request Timeout",
          409: "Conflict",
          410: "Gone",
          411: "Length Required",
          412: "Precondition Failed",
          413: "Payload Too Large",
          414: "URI Too Long",
          415: "Unsupported Media Type",
          416: "Range Not Satisfiable",
          417: "Expectation Failed",
          418: "I'm a teapot",
          421: "Misdirected Request",
          422: "Unprocessable Entity",
          423: "Locked",
          424: "Failed Dependency",
          425: "Unordered Collection",
          426: "Upgrade Required",
          428: "Precondition Required",
          429: "Too Many Requests",
          431: "Request Header Fields Too Large",
          451: "Unavailable For Legal Reasons",
          500: "Internal Server Error",
          501: "Not Implemented",
          502: "Bad Gateway",
          503: "Service Unavailable",
          504: "Gateway Timeout",
          505: "HTTP Version Not Supported",
          506: "Variant Also Negotiates",
          507: "Insufficient Storage",
          508: "Loop Detected",
          509: "Bandwidth Limit Exceeded",
          510: "Not Extended",
          511: "Network Authentication Required"
        };
      }, {}], 51: [function(k, Z, _) {
        (function(M) {
          function x(o) {
            return Array.isArray ? Array.isArray(o) : S(o) === "[object Array]";
          }
          _.isArray = x;
          function y(o) {
            return typeof o == "boolean";
          }
          _.isBoolean = y;
          function E(o) {
            return o === null;
          }
          _.isNull = E;
          function c(o) {
            return o == null;
          }
          _.isNullOrUndefined = c;
          function u(o) {
            return typeof o == "number";
          }
          _.isNumber = u;
          function l(o) {
            return typeof o == "string";
          }
          _.isString = l;
          function a(o) {
            return typeof o == "symbol";
          }
          _.isSymbol = a;
          function n(o) {
            return o === void 0;
          }
          _.isUndefined = n;
          function d(o) {
            return S(o) === "[object RegExp]";
          }
          _.isRegExp = d;
          function g(o) {
            return typeof o == "object" && o !== null;
          }
          _.isObject = g;
          function h(o) {
            return S(o) === "[object Date]";
          }
          _.isDate = h;
          function m(o) {
            return S(o) === "[object Error]" || o instanceof Error;
          }
          _.isError = m;
          function s(o) {
            return typeof o == "function";
          }
          _.isFunction = s;
          function b(o) {
            return o === null || typeof o == "boolean" || typeof o == "number" || typeof o == "string" || typeof o == "symbol" || // ES6 symbol
            typeof o > "u";
          }
          _.isPrimitive = b, _.isBuffer = M.isBuffer;
          function S(o) {
            return Object.prototype.toString.call(o);
          }
        }).call(this, { isBuffer: k("../../is-buffer/index.js") });
      }, { "../../is-buffer/index.js": 76 }], 52: [function(k, Z, _) {
        var M = Object.create || z, x = Object.keys || U, y = Function.prototype.bind || J;
        function E() {
          (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) && (this._events = M(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }
        Z.exports = E, E.EventEmitter = E, E.prototype._events = void 0, E.prototype._maxListeners = void 0;
        var c = 10, u;
        try {
          var l = {};
          Object.defineProperty && Object.defineProperty(l, "x", { value: 0 }), u = l.x === 0;
        } catch {
          u = !1;
        }
        u ? Object.defineProperty(E, "defaultMaxListeners", {
          enumerable: !0,
          get: function() {
            return c;
          },
          set: function(F) {
            if (typeof F != "number" || F < 0 || F !== F)
              throw new TypeError('"defaultMaxListeners" must be a positive number');
            c = F;
          }
        }) : E.defaultMaxListeners = c, E.prototype.setMaxListeners = function(oe) {
          if (typeof oe != "number" || oe < 0 || isNaN(oe))
            throw new TypeError('"n" argument must be a positive number');
          return this._maxListeners = oe, this;
        };
        function a(F) {
          return F._maxListeners === void 0 ? E.defaultMaxListeners : F._maxListeners;
        }
        E.prototype.getMaxListeners = function() {
          return a(this);
        };
        function n(F, oe, ee) {
          if (oe)
            F.call(ee);
          else
            for (var ie = F.length, W = I(F, ie), Q = 0; Q < ie; ++Q)
              W[Q].call(ee);
        }
        function d(F, oe, ee, ie) {
          if (oe)
            F.call(ee, ie);
          else
            for (var W = F.length, Q = I(F, W), de = 0; de < W; ++de)
              Q[de].call(ee, ie);
        }
        function g(F, oe, ee, ie, W) {
          if (oe)
            F.call(ee, ie, W);
          else
            for (var Q = F.length, de = I(F, Q), we = 0; we < Q; ++we)
              de[we].call(ee, ie, W);
        }
        function h(F, oe, ee, ie, W, Q) {
          if (oe)
            F.call(ee, ie, W, Q);
          else
            for (var de = F.length, we = I(F, de), ke = 0; ke < de; ++ke)
              we[ke].call(ee, ie, W, Q);
        }
        function m(F, oe, ee, ie) {
          if (oe)
            F.apply(ee, ie);
          else
            for (var W = F.length, Q = I(F, W), de = 0; de < W; ++de)
              Q[de].apply(ee, ie);
        }
        E.prototype.emit = function(oe) {
          var ee, ie, W, Q, de, we, ke = oe === "error";
          if (we = this._events, we)
            ke = ke && we.error == null;
          else if (!ke)
            return !1;
          if (ke) {
            if (arguments.length > 1 && (ee = arguments[1]), ee instanceof Error)
              throw ee;
            var Me = new Error('Unhandled "error" event. (' + ee + ")");
            throw Me.context = ee, Me;
          }
          if (ie = we[oe], !ie)
            return !1;
          var fe = typeof ie == "function";
          switch (W = arguments.length, W) {
            // fast cases
            case 1:
              n(ie, fe, this);
              break;
            case 2:
              d(ie, fe, this, arguments[1]);
              break;
            case 3:
              g(ie, fe, this, arguments[1], arguments[2]);
              break;
            case 4:
              h(ie, fe, this, arguments[1], arguments[2], arguments[3]);
              break;
            // slower
            default:
              for (Q = new Array(W - 1), de = 1; de < W; de++)
                Q[de - 1] = arguments[de];
              m(ie, fe, this, Q);
          }
          return !0;
        };
        function s(F, oe, ee, ie) {
          var W, Q, de;
          if (typeof ee != "function")
            throw new TypeError('"listener" argument must be a function');
          if (Q = F._events, Q ? (Q.newListener && (F.emit(
            "newListener",
            oe,
            ee.listener ? ee.listener : ee
          ), Q = F._events), de = Q[oe]) : (Q = F._events = M(null), F._eventsCount = 0), !de)
            de = Q[oe] = ee, ++F._eventsCount;
          else if (typeof de == "function" ? de = Q[oe] = ie ? [ee, de] : [de, ee] : ie ? de.unshift(ee) : de.push(ee), !de.warned && (W = a(F), W && W > 0 && de.length > W)) {
            de.warned = !0;
            var we = new Error("Possible EventEmitter memory leak detected. " + de.length + ' "' + String(oe) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
            we.name = "MaxListenersExceededWarning", we.emitter = F, we.type = oe, we.count = de.length, typeof console == "object" && console.warn && console.warn("%s: %s", we.name, we.message);
          }
          return F;
        }
        E.prototype.addListener = function(oe, ee) {
          return s(this, oe, ee, !1);
        }, E.prototype.on = E.prototype.addListener, E.prototype.prependListener = function(oe, ee) {
          return s(this, oe, ee, !0);
        };
        function b() {
          if (!this.fired)
            switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length) {
              case 0:
                return this.listener.call(this.target);
              case 1:
                return this.listener.call(this.target, arguments[0]);
              case 2:
                return this.listener.call(this.target, arguments[0], arguments[1]);
              case 3:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1],
                  arguments[2]
                );
              default:
                for (var F = new Array(arguments.length), oe = 0; oe < F.length; ++oe)
                  F[oe] = arguments[oe];
                this.listener.apply(this.target, F);
            }
        }
        function S(F, oe, ee) {
          var ie = { fired: !1, wrapFn: void 0, target: F, type: oe, listener: ee }, W = y.call(b, ie);
          return W.listener = ee, ie.wrapFn = W, W;
        }
        E.prototype.once = function(oe, ee) {
          if (typeof ee != "function")
            throw new TypeError('"listener" argument must be a function');
          return this.on(oe, S(this, oe, ee)), this;
        }, E.prototype.prependOnceListener = function(oe, ee) {
          if (typeof ee != "function")
            throw new TypeError('"listener" argument must be a function');
          return this.prependListener(oe, S(this, oe, ee)), this;
        }, E.prototype.removeListener = function(oe, ee) {
          var ie, W, Q, de, we;
          if (typeof ee != "function")
            throw new TypeError('"listener" argument must be a function');
          if (W = this._events, !W)
            return this;
          if (ie = W[oe], !ie)
            return this;
          if (ie === ee || ie.listener === ee)
            --this._eventsCount === 0 ? this._events = M(null) : (delete W[oe], W.removeListener && this.emit("removeListener", oe, ie.listener || ee));
          else if (typeof ie != "function") {
            for (Q = -1, de = ie.length - 1; de >= 0; de--)
              if (ie[de] === ee || ie[de].listener === ee) {
                we = ie[de].listener, Q = de;
                break;
              }
            if (Q < 0)
              return this;
            Q === 0 ? ie.shift() : T(ie, Q), ie.length === 1 && (W[oe] = ie[0]), W.removeListener && this.emit("removeListener", oe, we || ee);
          }
          return this;
        }, E.prototype.removeAllListeners = function(oe) {
          var ee, ie, W;
          if (ie = this._events, !ie)
            return this;
          if (!ie.removeListener)
            return arguments.length === 0 ? (this._events = M(null), this._eventsCount = 0) : ie[oe] && (--this._eventsCount === 0 ? this._events = M(null) : delete ie[oe]), this;
          if (arguments.length === 0) {
            var Q = x(ie), de;
            for (W = 0; W < Q.length; ++W)
              de = Q[W], de !== "removeListener" && this.removeAllListeners(de);
            return this.removeAllListeners("removeListener"), this._events = M(null), this._eventsCount = 0, this;
          }
          if (ee = ie[oe], typeof ee == "function")
            this.removeListener(oe, ee);
          else if (ee)
            for (W = ee.length - 1; W >= 0; W--)
              this.removeListener(oe, ee[W]);
          return this;
        };
        function o(F, oe, ee) {
          var ie = F._events;
          if (!ie)
            return [];
          var W = ie[oe];
          return W ? typeof W == "function" ? ee ? [W.listener || W] : [W] : ee ? L(W) : I(W, W.length) : [];
        }
        E.prototype.listeners = function(oe) {
          return o(this, oe, !0);
        }, E.prototype.rawListeners = function(oe) {
          return o(this, oe, !1);
        }, E.listenerCount = function(F, oe) {
          return typeof F.listenerCount == "function" ? F.listenerCount(oe) : A.call(F, oe);
        }, E.prototype.listenerCount = A;
        function A(F) {
          var oe = this._events;
          if (oe) {
            var ee = oe[F];
            if (typeof ee == "function")
              return 1;
            if (ee)
              return ee.length;
          }
          return 0;
        }
        E.prototype.eventNames = function() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };
        function T(F, oe) {
          for (var ee = oe, ie = ee + 1, W = F.length; ie < W; ee += 1, ie += 1)
            F[ee] = F[ie];
          F.pop();
        }
        function I(F, oe) {
          for (var ee = new Array(oe), ie = 0; ie < oe; ++ie)
            ee[ie] = F[ie];
          return ee;
        }
        function L(F) {
          for (var oe = new Array(F.length), ee = 0; ee < oe.length; ++ee)
            oe[ee] = F[ee].listener || F[ee];
          return oe;
        }
        function z(F) {
          var oe = function() {
          };
          return oe.prototype = F, new oe();
        }
        function U(F) {
          for (var oe in F) Object.prototype.hasOwnProperty.call(F, oe);
          return oe;
        }
        function J(F) {
          var oe = this;
          return function() {
            return oe.apply(F, arguments);
          };
        }
      }, {}], 53: [function(k, Z, _) {
        var M = k("./lib/parser");
        function x() {
          return (0, eval)("this");
        }
        Z.exports = {
          create: function(y, E) {
            if (E = E || x(), y instanceof E.ArrayBuffer) {
              var c = k("./lib/dom-bufferstream");
              return new M(new c(y, 0, y.byteLength, !0, E));
            } else {
              var u = k("./lib/bufferstream");
              return new M(new u(y, 0, y.length, !0));
            }
          }
        };
      }, { "./lib/bufferstream": 54, "./lib/dom-bufferstream": 56, "./lib/parser": 60 }], 54: [function(k, Z, _) {
        function M(x, y, E, c) {
          this.buffer = x, this.offset = y || 0, E = typeof E == "number" ? E : x.length, this.endPosition = this.offset + E, this.setBigEndian(c);
        }
        M.prototype = {
          setBigEndian: function(x) {
            this.bigEndian = !!x;
          },
          nextUInt8: function() {
            var x = this.buffer.readUInt8(this.offset);
            return this.offset += 1, x;
          },
          nextInt8: function() {
            var x = this.buffer.readInt8(this.offset);
            return this.offset += 1, x;
          },
          nextUInt16: function() {
            var x = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
            return this.offset += 2, x;
          },
          nextUInt32: function() {
            var x = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
            return this.offset += 4, x;
          },
          nextInt16: function() {
            var x = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
            return this.offset += 2, x;
          },
          nextInt32: function() {
            var x = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
            return this.offset += 4, x;
          },
          nextFloat: function() {
            var x = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
            return this.offset += 4, x;
          },
          nextDouble: function() {
            var x = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
            return this.offset += 8, x;
          },
          nextBuffer: function(x) {
            var y = this.buffer.slice(this.offset, this.offset + x);
            return this.offset += x, y;
          },
          remainingLength: function() {
            return this.endPosition - this.offset;
          },
          nextString: function(x) {
            var y = this.buffer.toString("utf8", this.offset, this.offset + x);
            return this.offset += x, y;
          },
          mark: function() {
            var x = this;
            return {
              openWithOffset: function(y) {
                return y = (y || 0) + this.offset, new M(x.buffer, y, x.endPosition - y, x.bigEndian);
              },
              offset: this.offset
            };
          },
          offsetFrom: function(x) {
            return this.offset - x.offset;
          },
          skip: function(x) {
            this.offset += x;
          },
          branch: function(x, y) {
            return y = typeof y == "number" ? y : this.endPosition - (this.offset + x), new M(this.buffer, this.offset + x, y, this.bigEndian);
          }
        }, Z.exports = M;
      }, {}], 55: [function(k, Z, _) {
        function M(a) {
          return parseInt(a, 10);
        }
        var x = 3600, y = 60;
        function E(a, n) {
          a = a.map(M), n = n.map(M);
          var d = a[0], g = a[1] - 1, h = a[2], m = n[0], s = n[1], b = n[2], S = Date.UTC(d, g, h, m, s, b, 0), o = S / 1e3;
          return o;
        }
        function c(a) {
          var n = a.substr(0, 10).split("-"), d = a.substr(11, 8).split(":"), g = a.substr(19, 6), h = g.split(":").map(M), m = h[0] * x + h[1] * y, s = E(n, d);
          if (s -= m, typeof s == "number" && !isNaN(s))
            return s;
        }
        function u(a) {
          var n = a.split(" "), d = n[0].split(":"), g = n[1].split(":"), h = E(d, g);
          if (typeof h == "number" && !isNaN(h))
            return h;
        }
        function l(a) {
          var n = a.length === 19 && a.charAt(4) === ":", d = a.length === 25 && a.charAt(10) === "T";
          if (d)
            return c(a);
          if (n)
            return u(a);
        }
        Z.exports = {
          parseDateWithSpecFormat: u,
          parseDateWithTimezoneFormat: c,
          parseExifDate: l
        };
      }, {}], 56: [function(k, Z, _) {
        function M(x, y, E, c, u, l) {
          this.global = u, y = y || 0, E = E || x.byteLength - y, this.arrayBuffer = x.slice(y, y + E), this.view = new u.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength), this.setBigEndian(c), this.offset = 0, this.parentOffset = (l || 0) + y;
        }
        M.prototype = {
          setBigEndian: function(x) {
            this.littleEndian = !x;
          },
          nextUInt8: function() {
            var x = this.view.getUint8(this.offset);
            return this.offset += 1, x;
          },
          nextInt8: function() {
            var x = this.view.getInt8(this.offset);
            return this.offset += 1, x;
          },
          nextUInt16: function() {
            var x = this.view.getUint16(this.offset, this.littleEndian);
            return this.offset += 2, x;
          },
          nextUInt32: function() {
            var x = this.view.getUint32(this.offset, this.littleEndian);
            return this.offset += 4, x;
          },
          nextInt16: function() {
            var x = this.view.getInt16(this.offset, this.littleEndian);
            return this.offset += 2, x;
          },
          nextInt32: function() {
            var x = this.view.getInt32(this.offset, this.littleEndian);
            return this.offset += 4, x;
          },
          nextFloat: function() {
            var x = this.view.getFloat32(this.offset, this.littleEndian);
            return this.offset += 4, x;
          },
          nextDouble: function() {
            var x = this.view.getFloat64(this.offset, this.littleEndian);
            return this.offset += 8, x;
          },
          nextBuffer: function(x) {
            var y = this.arrayBuffer.slice(this.offset, this.offset + x);
            return this.offset += x, y;
          },
          remainingLength: function() {
            return this.arrayBuffer.byteLength - this.offset;
          },
          nextString: function(x) {
            var y = this.arrayBuffer.slice(this.offset, this.offset + x);
            return y = String.fromCharCode.apply(null, new this.global.Uint8Array(y)), this.offset += x, y;
          },
          mark: function() {
            var x = this;
            return {
              openWithOffset: function(y) {
                return y = (y || 0) + this.offset, new M(x.arrayBuffer, y, x.arrayBuffer.byteLength - y, !x.littleEndian, x.global, x.parentOffset);
              },
              offset: this.offset,
              getParentOffset: function() {
                return x.parentOffset;
              }
            };
          },
          offsetFrom: function(x) {
            return this.parentOffset + this.offset - (x.offset + x.getParentOffset());
          },
          skip: function(x) {
            this.offset += x;
          },
          branch: function(x, y) {
            return y = typeof y == "number" ? y : this.arrayBuffer.byteLength - (this.offset + x), new M(this.arrayBuffer, this.offset + x, y, !this.littleEndian, this.global, this.parentOffset);
          }
        }, Z.exports = M;
      }, {}], 57: [function(k, Z, _) {
        Z.exports = {
          exif: {
            1: "InteropIndex",
            2: "InteropVersion",
            11: "ProcessingSoftware",
            254: "SubfileType",
            255: "OldSubfileType",
            256: "ImageWidth",
            257: "ImageHeight",
            258: "BitsPerSample",
            259: "Compression",
            262: "PhotometricInterpretation",
            263: "Thresholding",
            264: "CellWidth",
            265: "CellLength",
            266: "FillOrder",
            269: "DocumentName",
            270: "ImageDescription",
            271: "Make",
            272: "Model",
            273: "StripOffsets",
            274: "Orientation",
            277: "SamplesPerPixel",
            278: "RowsPerStrip",
            279: "StripByteCounts",
            280: "MinSampleValue",
            281: "MaxSampleValue",
            282: "XResolution",
            283: "YResolution",
            284: "PlanarConfiguration",
            285: "PageName",
            286: "XPosition",
            287: "YPosition",
            288: "FreeOffsets",
            289: "FreeByteCounts",
            290: "GrayResponseUnit",
            291: "GrayResponseCurve",
            292: "T4Options",
            293: "T6Options",
            296: "ResolutionUnit",
            297: "PageNumber",
            300: "ColorResponseUnit",
            301: "TransferFunction",
            305: "Software",
            306: "ModifyDate",
            315: "Artist",
            316: "HostComputer",
            317: "Predictor",
            318: "WhitePoint",
            319: "PrimaryChromaticities",
            320: "ColorMap",
            321: "HalftoneHints",
            322: "TileWidth",
            323: "TileLength",
            324: "TileOffsets",
            325: "TileByteCounts",
            326: "BadFaxLines",
            327: "CleanFaxData",
            328: "ConsecutiveBadFaxLines",
            330: "SubIFD",
            332: "InkSet",
            333: "InkNames",
            334: "NumberofInks",
            336: "DotRange",
            337: "TargetPrinter",
            338: "ExtraSamples",
            339: "SampleFormat",
            340: "SMinSampleValue",
            341: "SMaxSampleValue",
            342: "TransferRange",
            343: "ClipPath",
            344: "XClipPathUnits",
            345: "YClipPathUnits",
            346: "Indexed",
            347: "JPEGTables",
            351: "OPIProxy",
            400: "GlobalParametersIFD",
            401: "ProfileType",
            402: "FaxProfile",
            403: "CodingMethods",
            404: "VersionYear",
            405: "ModeNumber",
            433: "Decode",
            434: "DefaultImageColor",
            435: "T82Options",
            437: "JPEGTables",
            512: "JPEGProc",
            513: "ThumbnailOffset",
            514: "ThumbnailLength",
            515: "JPEGRestartInterval",
            517: "JPEGLosslessPredictors",
            518: "JPEGPointTransforms",
            519: "JPEGQTables",
            520: "JPEGDCTables",
            521: "JPEGACTables",
            529: "YCbCrCoefficients",
            530: "YCbCrSubSampling",
            531: "YCbCrPositioning",
            532: "ReferenceBlackWhite",
            559: "StripRowCounts",
            700: "ApplicationNotes",
            999: "USPTOMiscellaneous",
            4096: "RelatedImageFileFormat",
            4097: "RelatedImageWidth",
            4098: "RelatedImageHeight",
            18246: "Rating",
            18247: "XP_DIP_XML",
            18248: "StitchInfo",
            18249: "RatingPercent",
            32781: "ImageID",
            32931: "WangTag1",
            32932: "WangAnnotation",
            32933: "WangTag3",
            32934: "WangTag4",
            32995: "Matteing",
            32996: "DataType",
            32997: "ImageDepth",
            32998: "TileDepth",
            33405: "Model2",
            33421: "CFARepeatPatternDim",
            33422: "CFAPattern2",
            33423: "BatteryLevel",
            33424: "KodakIFD",
            33432: "Copyright",
            33434: "ExposureTime",
            33437: "FNumber",
            33445: "MDFileTag",
            33446: "MDScalePixel",
            33447: "MDColorTable",
            33448: "MDLabName",
            33449: "MDSampleInfo",
            33450: "MDPrepDate",
            33451: "MDPrepTime",
            33452: "MDFileUnits",
            33550: "PixelScale",
            33589: "AdventScale",
            33590: "AdventRevision",
            33628: "UIC1Tag",
            33629: "UIC2Tag",
            33630: "UIC3Tag",
            33631: "UIC4Tag",
            33723: "IPTC-NAA",
            33918: "IntergraphPacketData",
            33919: "IntergraphFlagRegisters",
            33920: "IntergraphMatrix",
            33921: "INGRReserved",
            33922: "ModelTiePoint",
            34016: "Site",
            34017: "ColorSequence",
            34018: "IT8Header",
            34019: "RasterPadding",
            34020: "BitsPerRunLength",
            34021: "BitsPerExtendedRunLength",
            34022: "ColorTable",
            34023: "ImageColorIndicator",
            34024: "BackgroundColorIndicator",
            34025: "ImageColorValue",
            34026: "BackgroundColorValue",
            34027: "PixelIntensityRange",
            34028: "TransparencyIndicator",
            34029: "ColorCharacterization",
            34030: "HCUsage",
            34031: "TrapIndicator",
            34032: "CMYKEquivalent",
            34118: "SEMInfo",
            34152: "AFCP_IPTC",
            34232: "PixelMagicJBIGOptions",
            34264: "ModelTransform",
            34306: "WB_GRGBLevels",
            34310: "LeafData",
            34377: "PhotoshopSettings",
            34665: "ExifOffset",
            34675: "ICC_Profile",
            34687: "TIFF_FXExtensions",
            34688: "MultiProfiles",
            34689: "SharedData",
            34690: "T88Options",
            34732: "ImageLayer",
            34735: "GeoTiffDirectory",
            34736: "GeoTiffDoubleParams",
            34737: "GeoTiffAsciiParams",
            34850: "ExposureProgram",
            34852: "SpectralSensitivity",
            34853: "GPSInfo",
            34855: "ISO",
            34856: "Opto-ElectricConvFactor",
            34857: "Interlace",
            34858: "TimeZoneOffset",
            34859: "SelfTimerMode",
            34864: "SensitivityType",
            34865: "StandardOutputSensitivity",
            34866: "RecommendedExposureIndex",
            34867: "ISOSpeed",
            34868: "ISOSpeedLatitudeyyy",
            34869: "ISOSpeedLatitudezzz",
            34908: "FaxRecvParams",
            34909: "FaxSubAddress",
            34910: "FaxRecvTime",
            34954: "LeafSubIFD",
            36864: "ExifVersion",
            36867: "DateTimeOriginal",
            36868: "CreateDate",
            37121: "ComponentsConfiguration",
            37122: "CompressedBitsPerPixel",
            37377: "ShutterSpeedValue",
            37378: "ApertureValue",
            37379: "BrightnessValue",
            37380: "ExposureCompensation",
            37381: "MaxApertureValue",
            37382: "SubjectDistance",
            37383: "MeteringMode",
            37384: "LightSource",
            37385: "Flash",
            37386: "FocalLength",
            37387: "FlashEnergy",
            37388: "SpatialFrequencyResponse",
            37389: "Noise",
            37390: "FocalPlaneXResolution",
            37391: "FocalPlaneYResolution",
            37392: "FocalPlaneResolutionUnit",
            37393: "ImageNumber",
            37394: "SecurityClassification",
            37395: "ImageHistory",
            37396: "SubjectArea",
            37397: "ExposureIndex",
            37398: "TIFF-EPStandardID",
            37399: "SensingMethod",
            37434: "CIP3DataFile",
            37435: "CIP3Sheet",
            37436: "CIP3Side",
            37439: "StoNits",
            37500: "MakerNote",
            37510: "UserComment",
            37520: "SubSecTime",
            37521: "SubSecTimeOriginal",
            37522: "SubSecTimeDigitized",
            37679: "MSDocumentText",
            37680: "MSPropertySetStorage",
            37681: "MSDocumentTextPosition",
            37724: "ImageSourceData",
            40091: "XPTitle",
            40092: "XPComment",
            40093: "XPAuthor",
            40094: "XPKeywords",
            40095: "XPSubject",
            40960: "FlashpixVersion",
            40961: "ColorSpace",
            40962: "ExifImageWidth",
            40963: "ExifImageHeight",
            40964: "RelatedSoundFile",
            40965: "InteropOffset",
            41483: "FlashEnergy",
            41484: "SpatialFrequencyResponse",
            41485: "Noise",
            41486: "FocalPlaneXResolution",
            41487: "FocalPlaneYResolution",
            41488: "FocalPlaneResolutionUnit",
            41489: "ImageNumber",
            41490: "SecurityClassification",
            41491: "ImageHistory",
            41492: "SubjectLocation",
            41493: "ExposureIndex",
            41494: "TIFF-EPStandardID",
            41495: "SensingMethod",
            41728: "FileSource",
            41729: "SceneType",
            41730: "CFAPattern",
            41985: "CustomRendered",
            41986: "ExposureMode",
            41987: "WhiteBalance",
            41988: "DigitalZoomRatio",
            41989: "FocalLengthIn35mmFormat",
            41990: "SceneCaptureType",
            41991: "GainControl",
            41992: "Contrast",
            41993: "Saturation",
            41994: "Sharpness",
            41995: "DeviceSettingDescription",
            41996: "SubjectDistanceRange",
            42016: "ImageUniqueID",
            42032: "OwnerName",
            42033: "SerialNumber",
            42034: "LensInfo",
            42035: "LensMake",
            42036: "LensModel",
            42037: "LensSerialNumber",
            42112: "GDALMetadata",
            42113: "GDALNoData",
            42240: "Gamma",
            44992: "ExpandSoftware",
            44993: "ExpandLens",
            44994: "ExpandFilm",
            44995: "ExpandFilterLens",
            44996: "ExpandScanner",
            44997: "ExpandFlashLamp",
            48129: "PixelFormat",
            48130: "Transformation",
            48131: "Uncompressed",
            48132: "ImageType",
            48256: "ImageWidth",
            48257: "ImageHeight",
            48258: "WidthResolution",
            48259: "HeightResolution",
            48320: "ImageOffset",
            48321: "ImageByteCount",
            48322: "AlphaOffset",
            48323: "AlphaByteCount",
            48324: "ImageDataDiscard",
            48325: "AlphaDataDiscard",
            50215: "OceScanjobDesc",
            50216: "OceApplicationSelector",
            50217: "OceIDNumber",
            50218: "OceImageLogic",
            50255: "Annotations",
            50341: "PrintIM",
            50560: "USPTOOriginalContentType",
            50706: "DNGVersion",
            50707: "DNGBackwardVersion",
            50708: "UniqueCameraModel",
            50709: "LocalizedCameraModel",
            50710: "CFAPlaneColor",
            50711: "CFALayout",
            50712: "LinearizationTable",
            50713: "BlackLevelRepeatDim",
            50714: "BlackLevel",
            50715: "BlackLevelDeltaH",
            50716: "BlackLevelDeltaV",
            50717: "WhiteLevel",
            50718: "DefaultScale",
            50719: "DefaultCropOrigin",
            50720: "DefaultCropSize",
            50721: "ColorMatrix1",
            50722: "ColorMatrix2",
            50723: "CameraCalibration1",
            50724: "CameraCalibration2",
            50725: "ReductionMatrix1",
            50726: "ReductionMatrix2",
            50727: "AnalogBalance",
            50728: "AsShotNeutral",
            50729: "AsShotWhiteXY",
            50730: "BaselineExposure",
            50731: "BaselineNoise",
            50732: "BaselineSharpness",
            50733: "BayerGreenSplit",
            50734: "LinearResponseLimit",
            50735: "CameraSerialNumber",
            50736: "DNGLensInfo",
            50737: "ChromaBlurRadius",
            50738: "AntiAliasStrength",
            50739: "ShadowScale",
            50740: "DNGPrivateData",
            50741: "MakerNoteSafety",
            50752: "RawImageSegmentation",
            50778: "CalibrationIlluminant1",
            50779: "CalibrationIlluminant2",
            50780: "BestQualityScale",
            50781: "RawDataUniqueID",
            50784: "AliasLayerMetadata",
            50827: "OriginalRawFileName",
            50828: "OriginalRawFileData",
            50829: "ActiveArea",
            50830: "MaskedAreas",
            50831: "AsShotICCProfile",
            50832: "AsShotPreProfileMatrix",
            50833: "CurrentICCProfile",
            50834: "CurrentPreProfileMatrix",
            50879: "ColorimetricReference",
            50898: "PanasonicTitle",
            50899: "PanasonicTitle2",
            50931: "CameraCalibrationSig",
            50932: "ProfileCalibrationSig",
            50933: "ProfileIFD",
            50934: "AsShotProfileName",
            50935: "NoiseReductionApplied",
            50936: "ProfileName",
            50937: "ProfileHueSatMapDims",
            50938: "ProfileHueSatMapData1",
            50939: "ProfileHueSatMapData2",
            50940: "ProfileToneCurve",
            50941: "ProfileEmbedPolicy",
            50942: "ProfileCopyright",
            50964: "ForwardMatrix1",
            50965: "ForwardMatrix2",
            50966: "PreviewApplicationName",
            50967: "PreviewApplicationVersion",
            50968: "PreviewSettingsName",
            50969: "PreviewSettingsDigest",
            50970: "PreviewColorSpace",
            50971: "PreviewDateTime",
            50972: "RawImageDigest",
            50973: "OriginalRawFileDigest",
            50974: "SubTileBlockSize",
            50975: "RowInterleaveFactor",
            50981: "ProfileLookTableDims",
            50982: "ProfileLookTableData",
            51008: "OpcodeList1",
            51009: "OpcodeList2",
            51022: "OpcodeList3",
            51041: "NoiseProfile",
            51043: "TimeCodes",
            51044: "FrameRate",
            51058: "TStop",
            51081: "ReelName",
            51089: "OriginalDefaultFinalSize",
            51090: "OriginalBestQualitySize",
            51091: "OriginalDefaultCropSize",
            51105: "CameraLabel",
            51107: "ProfileHueSatMapEncoding",
            51108: "ProfileLookTableEncoding",
            51109: "BaselineExposureOffset",
            51110: "DefaultBlackRender",
            51111: "NewRawImageDigest",
            51112: "RawToPreviewGain",
            51125: "DefaultUserCrop",
            59932: "Padding",
            59933: "OffsetSchema",
            65e3: "OwnerName",
            65001: "SerialNumber",
            65002: "Lens",
            65024: "KDC_IFD",
            65100: "RawFile",
            65101: "Converter",
            65102: "WhiteBalance",
            65105: "Exposure",
            65106: "Shadows",
            65107: "Brightness",
            65108: "Contrast",
            65109: "Saturation",
            65110: "Sharpness",
            65111: "Smoothness",
            65112: "MoireFilter"
          },
          gps: {
            0: "GPSVersionID",
            1: "GPSLatitudeRef",
            2: "GPSLatitude",
            3: "GPSLongitudeRef",
            4: "GPSLongitude",
            5: "GPSAltitudeRef",
            6: "GPSAltitude",
            7: "GPSTimeStamp",
            8: "GPSSatellites",
            9: "GPSStatus",
            10: "GPSMeasureMode",
            11: "GPSDOP",
            12: "GPSSpeedRef",
            13: "GPSSpeed",
            14: "GPSTrackRef",
            15: "GPSTrack",
            16: "GPSImgDirectionRef",
            17: "GPSImgDirection",
            18: "GPSMapDatum",
            19: "GPSDestLatitudeRef",
            20: "GPSDestLatitude",
            21: "GPSDestLongitudeRef",
            22: "GPSDestLongitude",
            23: "GPSDestBearingRef",
            24: "GPSDestBearing",
            25: "GPSDestDistanceRef",
            26: "GPSDestDistance",
            27: "GPSProcessingMethod",
            28: "GPSAreaInformation",
            29: "GPSDateStamp",
            30: "GPSDifferential",
            31: "GPSHPositioningError"
          }
        };
      }, {}], 58: [function(k, Z, _) {
        function M(u, l) {
          switch (u) {
            case 1:
              return l.nextUInt8();
            case 3:
              return l.nextUInt16();
            case 4:
              return l.nextUInt32();
            case 5:
              return [l.nextUInt32(), l.nextUInt32()];
            case 6:
              return l.nextInt8();
            case 8:
              return l.nextUInt16();
            case 9:
              return l.nextUInt32();
            case 10:
              return [l.nextInt32(), l.nextInt32()];
            case 11:
              return l.nextFloat();
            case 12:
              return l.nextDouble();
            default:
              throw new Error("Invalid format while decoding: " + u);
          }
        }
        function x(u) {
          switch (u) {
            case 1:
            case 2:
            case 6:
            case 7:
              return 1;
            case 3:
            case 8:
              return 2;
            case 4:
            case 9:
            case 11:
              return 4;
            case 5:
            case 10:
            case 12:
              return 8;
            default:
              return 0;
          }
        }
        function y(u, l) {
          var a = l.nextUInt16(), n = l.nextUInt16(), d = x(n), g = l.nextUInt32(), h = d * g, m, s;
          if (h > 4 && (l = u.openWithOffset(l.nextUInt32())), n === 2) {
            m = l.nextString(g);
            var b = m.indexOf("\0");
            b !== -1 && (m = m.substr(0, b));
          } else if (n === 7)
            m = l.nextBuffer(g);
          else if (n !== 0)
            for (m = [], s = 0; s < g; ++s)
              m.push(M(n, l));
          return h < 4 && l.skip(4 - h), [a, m, n];
        }
        function E(u, l, a) {
          var n = l.nextUInt16(), d, g;
          for (g = 0; g < n; ++g)
            d = y(u, l), a(d[0], d[1], d[2]);
        }
        function c(u) {
          var l = u.nextString(6);
          if (l !== "Exif\0\0")
            throw new Error("Invalid EXIF header");
          var a = u.mark(), n = u.nextUInt16();
          if (n === 18761)
            u.setBigEndian(!1);
          else if (n === 19789)
            u.setBigEndian(!0);
          else
            throw new Error("Invalid TIFF header");
          if (u.nextUInt16() !== 42)
            throw new Error("Invalid TIFF data");
          return a;
        }
        Z.exports = {
          IFD0: 1,
          IFD1: 2,
          GPSIFD: 3,
          SubIFD: 4,
          InteropIFD: 5,
          parseTags: function(u, l) {
            var a;
            try {
              a = c(u);
            } catch {
              return !1;
            }
            var n, d, g, h = a.openWithOffset(u.nextUInt32()), m = this.IFD0;
            E(a, h, function(I, L, z) {
              switch (I) {
                case 34853:
                  d = L[0];
                  break;
                case 34665:
                  n = L[0];
                  break;
                default:
                  l(m, I, L, z);
                  break;
              }
            });
            var s = h.nextUInt32();
            if (s !== 0) {
              var b = a.openWithOffset(s);
              E(a, b, l.bind(null, this.IFD1));
            }
            if (d) {
              var S = a.openWithOffset(d);
              E(a, S, l.bind(null, this.GPSIFD));
            }
            if (n) {
              var o = a.openWithOffset(n), A = this.InteropIFD;
              E(a, o, function(I, L, z) {
                I === 40965 ? g = L[0] : l(A, I, L, z);
              });
            }
            if (g) {
              var T = a.openWithOffset(g);
              E(a, T, l.bind(null, this.InteropIFD));
            }
            return !0;
          }
        };
      }, {}], 59: [function(k, Z, _) {
        Z.exports = {
          parseSections: function(M, x) {
            var y, E;
            for (M.setBigEndian(!0); M.remainingLength() > 0 && E !== 218; ) {
              if (M.nextUInt8() !== 255)
                throw new Error("Invalid JPEG section offset");
              E = M.nextUInt8(), E >= 208 && E <= 217 || E === 218 ? y = 0 : y = M.nextUInt16() - 2, x(E, M.branch(0, y)), M.skip(y);
            }
          },
          //stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator
          getSizeFromSOFSection: function(M) {
            return M.skip(1), {
              height: M.nextUInt16(),
              width: M.nextUInt16()
            };
          },
          getSectionName: function(M) {
            var x, y;
            switch (M) {
              case 216:
                x = "SOI";
                break;
              case 196:
                x = "DHT";
                break;
              case 219:
                x = "DQT";
                break;
              case 221:
                x = "DRI";
                break;
              case 218:
                x = "SOS";
                break;
              case 254:
                x = "COM";
                break;
              case 217:
                x = "EOI";
                break;
              default:
                M >= 224 && M <= 239 ? (x = "APP", y = M - 224) : M >= 192 && M <= 207 && M !== 196 && M !== 200 && M !== 204 ? (x = "SOF", y = M - 192) : M >= 208 && M <= 215 && (x = "RST", y = M - 208);
                break;
            }
            var E = {
              name: x
            };
            return typeof y == "number" && (E.index = y), E;
          }
        };
      }, {}], 60: [function(k, Z, _) {
        var M = k("./jpeg"), x = k("./exif"), y = k("./simplify");
        function E(u, l, a, n, d, g, h) {
          this.startMarker = u, this.tags = l, this.imageSize = a, this.thumbnailOffset = n, this.thumbnailLength = d, this.thumbnailType = g, this.app1Offset = h;
        }
        E.prototype = {
          hasThumbnail: function(u) {
            return !this.thumbnailOffset || !this.thumbnailLength ? !1 : typeof u != "string" ? !0 : u.toLowerCase().trim() === "image/jpeg" ? this.thumbnailType === 6 : u.toLowerCase().trim() === "image/tiff" ? this.thumbnailType === 1 : !1;
          },
          getThumbnailOffset: function() {
            return this.app1Offset + 6 + this.thumbnailOffset;
          },
          getThumbnailLength: function() {
            return this.thumbnailLength;
          },
          getThumbnailBuffer: function() {
            return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
          },
          _getThumbnailStream: function() {
            return this.startMarker.openWithOffset(this.getThumbnailOffset());
          },
          getImageSize: function() {
            return this.imageSize;
          },
          getThumbnailSize: function() {
            var u = this._getThumbnailStream(), l;
            return M.parseSections(u, function(a, n) {
              M.getSectionName(a).name === "SOF" && (l = M.getSizeFromSOFSection(n));
            }), l;
          }
        };
        function c(u) {
          this.stream = u, this.flags = {
            readBinaryTags: !1,
            resolveTagNames: !0,
            simplifyValues: !0,
            imageSize: !0,
            hidePointers: !0,
            returnTags: !0
          };
        }
        c.prototype = {
          enableBinaryFields: function(u) {
            return this.flags.readBinaryTags = !!u, this;
          },
          enablePointers: function(u) {
            return this.flags.hidePointers = !u, this;
          },
          enableTagNames: function(u) {
            return this.flags.resolveTagNames = !!u, this;
          },
          enableImageSize: function(u) {
            return this.flags.imageSize = !!u, this;
          },
          enableReturnTags: function(u) {
            return this.flags.returnTags = !!u, this;
          },
          enableSimpleValues: function(u) {
            return this.flags.simplifyValues = !!u, this;
          },
          parse: function() {
            var u = this.stream.mark(), l = u.openWithOffset(0), a = this.flags, n, d, g, h, m, s, b, S, o;
            return a.resolveTagNames && (b = k("./exif-tags")), a.resolveTagNames ? (n = {}, S = function(A) {
              return n[A.name];
            }, o = function(A, T) {
              n[A.name] = T;
            }) : (n = [], S = function(A) {
              var T;
              for (T = 0; T < n.length; ++T)
                if (n[T].type === A.type && n[T].section === A.section)
                  return n.value;
            }, o = function(A, T) {
              var I;
              for (I = 0; I < n.length; ++I)
                if (n[I].type === A.type && n[I].section === A.section) {
                  n.value = T;
                  return;
                }
            }), M.parseSections(l, function(A, T) {
              var I, L = T.offsetFrom(u);
              A === 225 ? (I = x.parseTags(T, function(z, U, J, F) {
                if (!(!a.readBinaryTags && F === 7)) {
                  if (U === 513) {
                    if (g = J[0], a.hidePointers)
                      return;
                  } else if (U === 514) {
                    if (h = J[0], a.hidePointers)
                      return;
                  } else if (U === 259 && (m = J[0], a.hidePointers))
                    return;
                  if (a.returnTags)
                    if (a.simplifyValues && (J = y.simplifyValue(J, F)), a.resolveTagNames) {
                      var oe = z === x.GPSIFD ? b.gps : b.exif, ee = oe[U];
                      ee || (ee = b.exif[U]), n.hasOwnProperty(ee) || (n[ee] = J);
                    } else
                      n.push({
                        section: z,
                        type: U,
                        value: J
                      });
                }
              }), I && (s = L)) : a.imageSize && M.getSectionName(A).name === "SOF" && (d = M.getSizeFromSOFSection(T));
            }), a.simplifyValues && (y.castDegreeValues(S, o), y.castDateValues(S, o)), new E(u, n, d, g, h, m, s);
          }
        }, Z.exports = c;
      }, { "./exif": 58, "./exif-tags": 57, "./jpeg": 59, "./simplify": 61 }], 61: [function(k, Z, _) {
        var M = k("./exif"), x = k("./date"), y = [
          {
            section: M.GPSIFD,
            type: 2,
            name: "GPSLatitude",
            refType: 1,
            refName: "GPSLatitudeRef",
            posVal: "N"
          },
          {
            section: M.GPSIFD,
            type: 4,
            name: "GPSLongitude",
            refType: 3,
            refName: "GPSLongitudeRef",
            posVal: "E"
          }
        ], E = [
          {
            section: M.SubIFD,
            type: 306,
            name: "ModifyDate"
          },
          {
            section: M.SubIFD,
            type: 36867,
            name: "DateTimeOriginal"
          },
          {
            section: M.SubIFD,
            type: 36868,
            name: "CreateDate"
          },
          {
            section: M.SubIFD,
            type: 306,
            name: "ModifyDate"
          }
        ];
        Z.exports = {
          castDegreeValues: function(c, u) {
            y.forEach(function(l) {
              var a = c(l);
              if (a) {
                var n = c({ section: l.section, type: l.refType, name: l.refName }), d = n === l.posVal ? 1 : -1, g = (a[0] + a[1] / 60 + a[2] / 3600) * d;
                u(l, g);
              }
            });
          },
          castDateValues: function(c, u) {
            E.forEach(function(l) {
              var a = c(l);
              if (a) {
                var n = x.parseExifDate(a);
                typeof n < "u" && u(l, n);
              }
            });
          },
          simplifyValue: function(c, u) {
            return Array.isArray(c) && (c = c.map(function(l) {
              return u === 10 || u === 5 ? l[0] / l[1] : l;
            }), c.length === 1 && (c = c[0])), c;
          }
        };
      }, { "./date": 55, "./exif": 58 }], 62: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireDefault"), x = M(k("@babel/runtime/helpers/toConsumableArray")), y = function(a) {
          return (0, x.default)(a).map(function(n) {
            return n.charCodeAt(0);
          });
        }, E = y("META-INF/mozilla.rsa"), c = y("[Content_Types].xml"), u = y("_rels/.rels");
        Z.exports = function(l) {
          var a = l instanceof Uint8Array ? l : new Uint8Array(l);
          if (!(a && a.length > 1))
            return null;
          var n = function(z, U) {
            U = Object.assign({
              offset: 0
            }, U);
            for (var J = 0; J < z.length; J++)
              if (U.mask) {
                if (z[J] !== (U.mask[J] & a[J + U.offset]))
                  return !1;
              } else if (z[J] !== a[J + U.offset])
                return !1;
            return !0;
          }, d = function(z, U) {
            return n(y(z), U);
          };
          if (n([255, 216, 255]))
            return {
              ext: "jpg",
              mime: "image/jpeg"
            };
          if (n([137, 80, 78, 71, 13, 10, 26, 10]))
            return {
              ext: "png",
              mime: "image/png"
            };
          if (n([71, 73, 70]))
            return {
              ext: "gif",
              mime: "image/gif"
            };
          if (n([87, 69, 66, 80], {
            offset: 8
          }))
            return {
              ext: "webp",
              mime: "image/webp"
            };
          if (n([70, 76, 73, 70]))
            return {
              ext: "flif",
              mime: "image/flif"
            };
          if ((n([73, 73, 42, 0]) || n([77, 77, 0, 42])) && n([67, 82], {
            offset: 8
          }))
            return {
              ext: "cr2",
              mime: "image/x-canon-cr2"
            };
          if (n([73, 73, 42, 0]) || n([77, 77, 0, 42]))
            return {
              ext: "tif",
              mime: "image/tiff"
            };
          if (n([66, 77]))
            return {
              ext: "bmp",
              mime: "image/bmp"
            };
          if (n([73, 73, 188]))
            return {
              ext: "jxr",
              mime: "image/vnd.ms-photo"
            };
          if (n([56, 66, 80, 83]))
            return {
              ext: "psd",
              mime: "image/vnd.adobe.photoshop"
            };
          if (n([80, 75, 3, 4])) {
            if (n([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], {
              offset: 30
            }))
              return {
                ext: "epub",
                mime: "application/epub+zip"
              };
            if (n(E, {
              offset: 30
            }))
              return {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
            if (d("mimetypeapplication/vnd.oasis.opendocument.text", {
              offset: 30
            }))
              return {
                ext: "odt",
                mime: "application/vnd.oasis.opendocument.text"
              };
            if (d("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", {
              offset: 30
            }))
              return {
                ext: "ods",
                mime: "application/vnd.oasis.opendocument.spreadsheet"
              };
            if (d("mimetypeapplication/vnd.oasis.opendocument.presentation", {
              offset: 30
            }))
              return {
                ext: "odp",
                mime: "application/vnd.oasis.opendocument.presentation"
              };
            var g = function(z) {
              var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              return z.findIndex(function(J, F, oe) {
                return F >= U && oe[F] === 80 && oe[F + 1] === 75 && oe[F + 2] === 3 && oe[F + 3] === 4;
              });
            }, h = 0, m = !1, s = null;
            do {
              var b = h + 30;
              if (m || (m = n(c, {
                offset: b
              }) || n(u, {
                offset: b
              })), s || (d("word/", {
                offset: b
              }) ? s = {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
              } : d("ppt/", {
                offset: b
              }) ? s = {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
              } : d("xl/", {
                offset: b
              }) && (s = {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              })), m && s)
                return s;
              h = g(a, b);
            } while (h >= 0);
            if (s)
              return s;
          }
          if (n([80, 75]) && (a[2] === 3 || a[2] === 5 || a[2] === 7) && (a[3] === 4 || a[3] === 6 || a[3] === 8))
            return {
              ext: "zip",
              mime: "application/zip"
            };
          if (n([117, 115, 116, 97, 114], {
            offset: 257
          }))
            return {
              ext: "tar",
              mime: "application/x-tar"
            };
          if (n([82, 97, 114, 33, 26, 7]) && (a[6] === 0 || a[6] === 1))
            return {
              ext: "rar",
              mime: "application/x-rar-compressed"
            };
          if (n([31, 139, 8]))
            return {
              ext: "gz",
              mime: "application/gzip"
            };
          if (n([66, 90, 104]))
            return {
              ext: "bz2",
              mime: "application/x-bzip2"
            };
          if (n([55, 122, 188, 175, 39, 28]))
            return {
              ext: "7z",
              mime: "application/x-7z-compressed"
            };
          if (n([120, 1]))
            return {
              ext: "dmg",
              mime: "application/x-apple-diskimage"
            };
          if (n([51, 103, 112, 53]) || // 3gp5
          n([0, 0, 0]) && n([102, 116, 121, 112], {
            offset: 4
          }) && (n([109, 112, 52, 49], {
            offset: 8
          }) || // MP41
          n([109, 112, 52, 50], {
            offset: 8
          }) || // MP42
          n([105, 115, 111, 109], {
            offset: 8
          }) || // ISOM
          n([105, 115, 111, 50], {
            offset: 8
          }) || // ISO2
          n([109, 109, 112, 52], {
            offset: 8
          }) || // MMP4
          n([77, 52, 86], {
            offset: 8
          }) || // M4V
          n([100, 97, 115, 104], {
            offset: 8
          })))
            return {
              ext: "mp4",
              mime: "video/mp4"
            };
          if (n([77, 84, 104, 100]))
            return {
              ext: "mid",
              mime: "audio/midi"
            };
          if (n([26, 69, 223, 163])) {
            var S = a.subarray(4, 4100), o = S.findIndex(function(L, z, U) {
              return U[z] === 66 && U[z + 1] === 130;
            });
            if (o !== -1) {
              var A = o + 3, T = function(z) {
                return (0, x.default)(z).every(function(U, J) {
                  return S[A + J] === U.charCodeAt(0);
                });
              };
              if (T("matroska"))
                return {
                  ext: "mkv",
                  mime: "video/x-matroska"
                };
              if (T("webm"))
                return {
                  ext: "webm",
                  mime: "video/webm"
                };
            }
          }
          if (n([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || n([102, 114, 101, 101], {
            offset: 4
          }) || n([102, 116, 121, 112, 113, 116, 32, 32], {
            offset: 4
          }) || n([109, 100, 97, 116], {
            offset: 4
          }) || // MJPEG
          n([119, 105, 100, 101], {
            offset: 4
          }))
            return {
              ext: "mov",
              mime: "video/quicktime"
            };
          if (n([82, 73, 70, 70])) {
            if (n([65, 86, 73], {
              offset: 8
            }))
              return {
                ext: "avi",
                mime: "video/vnd.avi"
              };
            if (n([87, 65, 86, 69], {
              offset: 8
            }))
              return {
                ext: "wav",
                mime: "audio/vnd.wave"
              };
            if (n([81, 76, 67, 77], {
              offset: 8
            }))
              return {
                ext: "qcp",
                mime: "audio/qcelp"
              };
          }
          if (n([48, 38, 178, 117, 142, 102, 207, 17, 166, 217]))
            return {
              ext: "wmv",
              mime: "video/x-ms-wmv"
            };
          if (n([0, 0, 1, 186]) || n([0, 0, 1, 179]))
            return {
              ext: "mpg",
              mime: "video/mpeg"
            };
          if (n([102, 116, 121, 112, 51, 103], {
            offset: 4
          }))
            return {
              ext: "3gp",
              mime: "video/3gpp"
            };
          for (var I = 0; I < 2 && I < a.length - 16; I++) {
            if (n([73, 68, 51], {
              offset: I
            }) || // ID3 header
            n([255, 226], {
              offset: I,
              mask: [255, 226]
            }))
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            if (n([255, 228], {
              offset: I,
              mask: [255, 228]
            }))
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            if (n([255, 248], {
              offset: I,
              mask: [255, 252]
            }))
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            if (n([255, 240], {
              offset: I,
              mask: [255, 252]
            }))
              return {
                ext: "mp4",
                mime: "audio/mpeg"
              };
          }
          if (n([102, 116, 121, 112, 77, 52, 65], {
            offset: 4
          }) || n([77, 52, 65, 32]))
            return {
              // MPEG-4 layer 3 (audio)
              ext: "m4a",
              mime: "audio/mp4"
              // RFC 4337
            };
          if (n([79, 112, 117, 115, 72, 101, 97, 100], {
            offset: 28
          }))
            return {
              ext: "opus",
              mime: "audio/opus"
            };
          if (n([79, 103, 103, 83]))
            return n([128, 116, 104, 101, 111, 114, 97], {
              offset: 28
            }) ? {
              ext: "ogv",
              mime: "video/ogg"
            } : n([1, 118, 105, 100, 101, 111, 0], {
              offset: 28
            }) ? {
              ext: "ogm",
              mime: "video/ogg"
            } : n([127, 70, 76, 65, 67], {
              offset: 28
            }) ? {
              ext: "oga",
              mime: "audio/ogg"
            } : n([83, 112, 101, 101, 120, 32, 32], {
              offset: 28
            }) ? {
              ext: "spx",
              mime: "audio/ogg"
            } : n([1, 118, 111, 114, 98, 105, 115], {
              offset: 28
            }) ? {
              ext: "ogg",
              mime: "audio/ogg"
            } : {
              ext: "ogx",
              mime: "application/ogg"
            };
          if (n([102, 76, 97, 67]))
            return {
              ext: "flac",
              mime: "audio/x-flac"
            };
          if (n([77, 65, 67, 32]))
            return {
              ext: "ape",
              mime: "audio/ape"
            };
          if (n([119, 118, 112, 107]))
            return {
              ext: "wv",
              mime: "audio/wavpack"
            };
          if (n([35, 33, 65, 77, 82, 10]))
            return {
              ext: "amr",
              mime: "audio/amr"
            };
          if (n([37, 80, 68, 70]))
            return {
              ext: "pdf",
              mime: "application/pdf"
            };
          if (n([77, 90]))
            return {
              ext: "exe",
              mime: "application/x-msdownload"
            };
          if ((a[0] === 67 || a[0] === 70) && n([87, 83], {
            offset: 1
          }))
            return {
              ext: "swf",
              mime: "application/x-shockwave-flash"
            };
          if (n([123, 92, 114, 116, 102]))
            return {
              ext: "rtf",
              mime: "application/rtf"
            };
          if (n([0, 97, 115, 109]))
            return {
              ext: "wasm",
              mime: "application/wasm"
            };
          if (n([119, 79, 70, 70]) && (n([0, 1, 0, 0], {
            offset: 4
          }) || n([79, 84, 84, 79], {
            offset: 4
          })))
            return {
              ext: "woff",
              mime: "font/woff"
            };
          if (n([119, 79, 70, 50]) && (n([0, 1, 0, 0], {
            offset: 4
          }) || n([79, 84, 84, 79], {
            offset: 4
          })))
            return {
              ext: "woff2",
              mime: "font/woff2"
            };
          if (n([76, 80], {
            offset: 34
          }) && (n([0, 0, 1], {
            offset: 8
          }) || n([1, 0, 2], {
            offset: 8
          }) || n([2, 0, 2], {
            offset: 8
          })))
            return {
              ext: "eot",
              mime: "application/vnd.ms-fontobject"
            };
          if (n([0, 1, 0, 0, 0]))
            return {
              ext: "ttf",
              mime: "font/ttf"
            };
          if (n([79, 84, 84, 79, 0]))
            return {
              ext: "otf",
              mime: "font/otf"
            };
          if (n([0, 0, 1, 0]))
            return {
              ext: "ico",
              mime: "image/x-icon"
            };
          if (n([0, 0, 2, 0]))
            return {
              ext: "cur",
              mime: "image/x-icon"
            };
          if (n([70, 76, 86, 1]))
            return {
              ext: "flv",
              mime: "video/x-flv"
            };
          if (n([37, 33]))
            return {
              ext: "ps",
              mime: "application/postscript"
            };
          if (n([253, 55, 122, 88, 90, 0]))
            return {
              ext: "xz",
              mime: "application/x-xz"
            };
          if (n([83, 81, 76, 105]))
            return {
              ext: "sqlite",
              mime: "application/x-sqlite3"
            };
          if (n([78, 69, 83, 26]))
            return {
              ext: "nes",
              mime: "application/x-nintendo-nes-rom"
            };
          if (n([67, 114, 50, 52]))
            return {
              ext: "crx",
              mime: "application/x-google-chrome-extension"
            };
          if (n([77, 83, 67, 70]) || n([73, 83, 99, 40]))
            return {
              ext: "cab",
              mime: "application/vnd.ms-cab-compressed"
            };
          if (n([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121]))
            return {
              ext: "deb",
              mime: "application/x-deb"
            };
          if (n([33, 60, 97, 114, 99, 104, 62]))
            return {
              ext: "ar",
              mime: "application/x-unix-archive"
            };
          if (n([237, 171, 238, 219]))
            return {
              ext: "rpm",
              mime: "application/x-rpm"
            };
          if (n([31, 160]) || n([31, 157]))
            return {
              ext: "Z",
              mime: "application/x-compress"
            };
          if (n([76, 90, 73, 80]))
            return {
              ext: "lz",
              mime: "application/x-lzip"
            };
          if (n([208, 207, 17, 224, 161, 177, 26, 225]))
            return {
              ext: "msi",
              mime: "application/x-msi"
            };
          if (n([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
            return {
              ext: "mxf",
              mime: "application/mxf"
            };
          if (n([71], {
            offset: 4
          }) && (n([71], {
            offset: 192
          }) || n([71], {
            offset: 196
          })))
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          if (n([66, 76, 69, 78, 68, 69, 82]))
            return {
              ext: "blend",
              mime: "application/x-blender"
            };
          if (n([66, 80, 71, 251]))
            return {
              ext: "bpg",
              mime: "image/bpg"
            };
          if (n([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
            if (n([106, 112, 50, 32], {
              offset: 20
            }))
              return {
                ext: "jp2",
                mime: "image/jp2"
              };
            if (n([106, 112, 120, 32], {
              offset: 20
            }))
              return {
                ext: "jpx",
                mime: "image/jpx"
              };
            if (n([106, 112, 109, 32], {
              offset: 20
            }))
              return {
                ext: "jpm",
                mime: "image/jpm"
              };
            if (n([109, 106, 112, 50], {
              offset: 20
            }))
              return {
                ext: "mj2",
                mime: "image/mj2"
              };
          }
          if (n([70, 79, 82, 77, 0]))
            return {
              ext: "aif",
              mime: "audio/aiff"
            };
          if (d("<?xml "))
            return {
              ext: "xml",
              mime: "application/xml"
            };
          if (n([66, 79, 79, 75, 77, 79, 66, 73], {
            offset: 60
          }))
            return {
              ext: "mobi",
              mime: "application/x-mobipocket-ebook"
            };
          if (n([102, 116, 121, 112], {
            offset: 4
          })) {
            if (n([109, 105, 102, 49], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heif"
              };
            if (n([109, 115, 102, 49], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heif-sequence"
              };
            if (n([104, 101, 105, 99], {
              offset: 8
            }) || n([104, 101, 105, 120], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heic"
              };
            if (n([104, 101, 118, 99], {
              offset: 8
            }) || n([104, 101, 118, 120], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heic-sequence"
              };
          }
          return n([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]) ? {
            ext: "ktx",
            mime: "image/ktx"
          } : null;
        };
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20 }], 63: [function(k, Z, _) {
        var M = k("is-callable"), x = Object.prototype.toString, y = Object.prototype.hasOwnProperty, E = function(n, d, g) {
          for (var h = 0, m = n.length; h < m; h++)
            y.call(n, h) && (g == null ? d(n[h], h, n) : d.call(g, n[h], h, n));
        }, c = function(n, d, g) {
          for (var h = 0, m = n.length; h < m; h++)
            g == null ? d(n.charAt(h), h, n) : d.call(g, n.charAt(h), h, n);
        }, u = function(n, d, g) {
          for (var h in n)
            y.call(n, h) && (g == null ? d(n[h], h, n) : d.call(g, n[h], h, n));
        }, l = function(n, d, g) {
          if (!M(d))
            throw new TypeError("iterator must be a function");
          var h;
          arguments.length >= 3 && (h = g), x.call(n) === "[object Array]" ? E(n, d, h) : typeof n == "string" ? c(n, d, h) : u(n, d, h);
        };
        Z.exports = l;
      }, { "is-callable": 77 }], 64: [function(k, Z, _) {
        function M(c, u, l, d) {
          var n = 0, d = d === void 0 ? {} : d, g = d.loop === void 0 ? null : d.loop, h = d.palette === void 0 ? null : d.palette;
          if (u <= 0 || l <= 0 || u > 65535 || l > 65535)
            throw new Error("Width/Height invalid.");
          function m(L) {
            var z = L.length;
            if (z < 2 || z > 256 || z & z - 1)
              throw new Error(
                "Invalid code/color length, must be power of 2 and 2 .. 256."
              );
            return z;
          }
          c[n++] = 71, c[n++] = 73, c[n++] = 70, c[n++] = 56, c[n++] = 57, c[n++] = 97;
          var s = 0, b = 0;
          if (h !== null) {
            for (var S = m(h); S >>= 1; ) ++s;
            if (S = 1 << s, --s, d.background !== void 0) {
              if (b = d.background, b >= S)
                throw new Error("Background index out of range.");
              if (b === 0)
                throw new Error("Background index explicitly passed as 0.");
            }
          }
          if (c[n++] = u & 255, c[n++] = u >> 8 & 255, c[n++] = l & 255, c[n++] = l >> 8 & 255, c[n++] = (h !== null ? 128 : 0) | // Global Color Table Flag.
          s, c[n++] = b, c[n++] = 0, h !== null)
            for (var o = 0, A = h.length; o < A; ++o) {
              var T = h[o];
              c[n++] = T >> 16 & 255, c[n++] = T >> 8 & 255, c[n++] = T & 255;
            }
          if (g !== null) {
            if (g < 0 || g > 65535)
              throw new Error("Loop count invalid.");
            c[n++] = 33, c[n++] = 255, c[n++] = 11, c[n++] = 78, c[n++] = 69, c[n++] = 84, c[n++] = 83, c[n++] = 67, c[n++] = 65, c[n++] = 80, c[n++] = 69, c[n++] = 50, c[n++] = 46, c[n++] = 48, c[n++] = 3, c[n++] = 1, c[n++] = g & 255, c[n++] = g >> 8 & 255, c[n++] = 0;
          }
          var I = !1;
          this.addFrame = function(L, z, U, J, F, oe) {
            if (I === !0 && (--n, I = !1), oe = oe === void 0 ? {} : oe, L < 0 || z < 0 || L > 65535 || z > 65535)
              throw new Error("x/y invalid.");
            if (U <= 0 || J <= 0 || U > 65535 || J > 65535)
              throw new Error("Width/Height invalid.");
            if (F.length < U * J)
              throw new Error("Not enough pixels for the frame size.");
            var ee = !0, ie = oe.palette;
            if (ie == null && (ee = !1, ie = h), ie == null)
              throw new Error("Must supply either a local or global palette.");
            for (var W = m(ie), Q = 0; W >>= 1; ) ++Q;
            W = 1 << Q;
            var de = oe.delay === void 0 ? 0 : oe.delay, we = oe.disposal === void 0 ? 0 : oe.disposal;
            if (we < 0 || we > 3)
              throw new Error("Disposal out of range.");
            var ke = !1, Me = 0;
            if (oe.transparent !== void 0 && oe.transparent !== null && (ke = !0, Me = oe.transparent, Me < 0 || Me >= W))
              throw new Error("Transparent color index.");
            if ((we !== 0 || ke || de !== 0) && (c[n++] = 33, c[n++] = 249, c[n++] = 4, c[n++] = we << 2 | (ke === !0 ? 1 : 0), c[n++] = de & 255, c[n++] = de >> 8 & 255, c[n++] = Me, c[n++] = 0), c[n++] = 44, c[n++] = L & 255, c[n++] = L >> 8 & 255, c[n++] = z & 255, c[n++] = z >> 8 & 255, c[n++] = U & 255, c[n++] = U >> 8 & 255, c[n++] = J & 255, c[n++] = J >> 8 & 255, c[n++] = ee === !0 ? 128 | Q - 1 : 0, ee === !0)
              for (var fe = 0, xe = ie.length; fe < xe; ++fe) {
                var Ee = ie[fe];
                c[n++] = Ee >> 16 & 255, c[n++] = Ee >> 8 & 255, c[n++] = Ee & 255;
              }
            return n = x(
              c,
              n,
              Q < 2 ? 2 : Q,
              F
            ), n;
          }, this.end = function() {
            return I === !1 && (c[n++] = 59, I = !0), n;
          }, this.getOutputBuffer = function() {
            return c;
          }, this.setOutputBuffer = function(L) {
            c = L;
          }, this.getOutputBufferPosition = function() {
            return n;
          }, this.setOutputBufferPosition = function(L) {
            n = L;
          };
        }
        function x(c, u, l, a) {
          c[u++] = l;
          var n = u++, d = 1 << l, g = d - 1, h = d + 1, m = h + 1, s = l + 1, b = 0, S = 0;
          function o(oe) {
            for (; b >= oe; )
              c[u++] = S & 255, S >>= 8, b -= 8, u === n + 256 && (c[n] = 255, n = u++);
          }
          function A(oe) {
            S |= oe << b, b += s, o(8);
          }
          var T = a[0] & g, I = {};
          A(d);
          for (var L = 1, z = a.length; L < z; ++L) {
            var U = a[L] & g, J = T << 8 | U, F = I[J];
            if (F === void 0) {
              for (S |= T << b, b += s; b >= 8; )
                c[u++] = S & 255, S >>= 8, b -= 8, u === n + 256 && (c[n] = 255, n = u++);
              m === 4096 ? (A(d), m = h + 1, s = l + 1, I = {}) : (m >= 1 << s && ++s, I[J] = m++), T = U;
            } else
              T = F;
          }
          return A(T), A(h), o(1), n + 1 === u ? c[n] = 0 : (c[n] = u - n - 1, c[u++] = 0), u;
        }
        function y(c) {
          var u = 0;
          if (c[u++] !== 71 || c[u++] !== 73 || c[u++] !== 70 || c[u++] !== 56 || (c[u++] + 1 & 253) !== 56 || c[u++] !== 97)
            throw new Error("Invalid GIF 87a/89a header.");
          var l = c[u++] | c[u++] << 8, a = c[u++] | c[u++] << 8, n = c[u++], d = n >> 7, g = n & 7, h = 1 << g + 1;
          c[u++], c[u++];
          var m = null, s = null;
          d && (m = u, s = h, u += h * 3);
          var b = !0, S = [], o = 0, A = null, T = 0, I = null;
          for (this.width = l, this.height = a; b && u < c.length; )
            switch (c[u++]) {
              case 33:
                switch (c[u++]) {
                  case 255:
                    if (c[u] !== 11 || // 21 FF already read, check block size.
                    // NETSCAPE2.0
                    c[u + 1] == 78 && c[u + 2] == 69 && c[u + 3] == 84 && c[u + 4] == 83 && c[u + 5] == 67 && c[u + 6] == 65 && c[u + 7] == 80 && c[u + 8] == 69 && c[u + 9] == 50 && c[u + 10] == 46 && c[u + 11] == 48 && // Sub-block
                    c[u + 12] == 3 && c[u + 13] == 1 && c[u + 16] == 0)
                      u += 14, I = c[u++] | c[u++] << 8, u++;
                    else
                      for (u += 12; ; ) {
                        var L = c[u++];
                        if (!(L >= 0)) throw Error("Invalid block size");
                        if (L === 0) break;
                        u += L;
                      }
                    break;
                  case 249:
                    if (c[u++] !== 4 || c[u + 4] !== 0)
                      throw new Error("Invalid graphics extension block.");
                    var z = c[u++];
                    o = c[u++] | c[u++] << 8, A = c[u++], (z & 1) === 0 && (A = null), T = z >> 2 & 7, u++;
                    break;
                  case 254:
                    for (; ; ) {
                      var L = c[u++];
                      if (!(L >= 0)) throw Error("Invalid block size");
                      if (L === 0) break;
                      u += L;
                    }
                    break;
                  default:
                    throw new Error(
                      "Unknown graphic control label: 0x" + c[u - 1].toString(16)
                    );
                }
                break;
              case 44:
                var U = c[u++] | c[u++] << 8, J = c[u++] | c[u++] << 8, F = c[u++] | c[u++] << 8, oe = c[u++] | c[u++] << 8, ee = c[u++], ie = ee >> 7, W = ee >> 6 & 1, Q = ee & 7, de = 1 << Q + 1, we = m, ke = s, Me = !1;
                if (ie) {
                  var Me = !0;
                  we = u, ke = de, u += de * 3;
                }
                var fe = u;
                for (u++; ; ) {
                  var L = c[u++];
                  if (!(L >= 0)) throw Error("Invalid block size");
                  if (L === 0) break;
                  u += L;
                }
                S.push({
                  x: U,
                  y: J,
                  width: F,
                  height: oe,
                  has_local_palette: Me,
                  palette_offset: we,
                  palette_size: ke,
                  data_offset: fe,
                  data_length: u - fe,
                  transparent_index: A,
                  interlaced: !!W,
                  delay: o,
                  disposal: T
                });
                break;
              case 59:
                b = !1;
                break;
              default:
                throw new Error("Unknown gif block: 0x" + c[u - 1].toString(16));
            }
          this.numFrames = function() {
            return S.length;
          }, this.loopCount = function() {
            return I;
          }, this.frameInfo = function(xe) {
            if (xe < 0 || xe >= S.length)
              throw new Error("Frame index out of range.");
            return S[xe];
          }, this.decodeAndBlitFrameBGRA = function(xe, Ee) {
            var Pe = this.frameInfo(xe), Ue = Pe.width * Pe.height, He = new Uint8Array(Ue);
            E(
              c,
              Pe.data_offset,
              He,
              Ue
            );
            var We = Pe.palette_offset, Ze = Pe.transparent_index;
            Ze === null && (Ze = 256);
            var $e = Pe.width, Ve = l - $e, Ge = $e, Ie = (Pe.y * l + Pe.x) * 4, De = ((Pe.y + Pe.height) * l + Pe.x) * 4, Ne = Ie, _e = Ve * 4;
            Pe.interlaced === !0 && (_e += l * 4 * 7);
            for (var re = 8, $ = 0, Ce = He.length; $ < Ce; ++$) {
              var ve = He[$];
              if (Ge === 0 && (Ne += _e, Ge = $e, Ne >= De && (_e = Ve * 4 + l * 4 * (re - 1), Ne = Ie + ($e + Ve) * (re << 1), re >>= 1)), ve === Ze)
                Ne += 4;
              else {
                var Y = c[We + ve * 3], G = c[We + ve * 3 + 1], Ae = c[We + ve * 3 + 2];
                Ee[Ne++] = Ae, Ee[Ne++] = G, Ee[Ne++] = Y, Ee[Ne++] = 255;
              }
              --Ge;
            }
          }, this.decodeAndBlitFrameRGBA = function(xe, Ee) {
            var Pe = this.frameInfo(xe), Ue = Pe.width * Pe.height, He = new Uint8Array(Ue);
            E(
              c,
              Pe.data_offset,
              He,
              Ue
            );
            var We = Pe.palette_offset, Ze = Pe.transparent_index;
            Ze === null && (Ze = 256);
            var $e = Pe.width, Ve = l - $e, Ge = $e, Ie = (Pe.y * l + Pe.x) * 4, De = ((Pe.y + Pe.height) * l + Pe.x) * 4, Ne = Ie, _e = Ve * 4;
            Pe.interlaced === !0 && (_e += l * 4 * 7);
            for (var re = 8, $ = 0, Ce = He.length; $ < Ce; ++$) {
              var ve = He[$];
              if (Ge === 0 && (Ne += _e, Ge = $e, Ne >= De && (_e = Ve * 4 + l * 4 * (re - 1), Ne = Ie + ($e + Ve) * (re << 1), re >>= 1)), ve === Ze)
                Ne += 4;
              else {
                var Y = c[We + ve * 3], G = c[We + ve * 3 + 1], Ae = c[We + ve * 3 + 2];
                Ee[Ne++] = Y, Ee[Ne++] = G, Ee[Ne++] = Ae, Ee[Ne++] = 255;
              }
              --Ge;
            }
          };
        }
        function E(c, u, l, a) {
          for (var n = c[u++], d = 1 << n, g = d + 1, h = g + 1, m = n + 1, s = (1 << m) - 1, b = 0, S = 0, o = 0, A = c[u++], T = new Int32Array(4096), I = null; ; ) {
            for (; b < 16 && A !== 0; )
              S |= c[u++] << b, b += 8, A === 1 ? A = c[u++] : --A;
            if (b < m)
              break;
            var L = S & s;
            if (S >>= m, b -= m, L === d) {
              h = g + 1, m = n + 1, s = (1 << m) - 1, I = null;
              continue;
            } else if (L === g)
              break;
            for (var z = L < h ? L : I, U = 0, J = z; J > d; )
              J = T[J] >> 8, ++U;
            var F = J, oe = o + U + (z !== L ? 1 : 0);
            if (oe > a) {
              console.log("Warning, gif stream longer than expected.");
              return;
            }
            l[o++] = F, o += U;
            var ee = o;
            for (z !== L && (l[o++] = F), J = z; U--; )
              J = T[J], l[--ee] = J & 255, J >>= 8;
            I !== null && h < 4096 && (T[h++] = I << 8 | F, h >= s + 1 && m < 12 && (++m, s = s << 1 | 1)), I = L;
          }
          return o !== a && console.log("Warning, gif stream shorter than expected."), l;
        }
        try {
          _.GifWriter = M, _.GifReader = y;
        } catch {
        }
      }, {}], 65: [function(k, Z, _) {
        (function(M) {
          class x {
            /**
             * BitmapImage is a class that hold an RGBA (red, green, blue, alpha) representation of an image. It's shape is borrowed from the Jimp package to make it easy to transfer GIF image frames into Jimp and Jimp images into GIF image frames. Each instance has a `bitmap` property having the following properties:
             * 
             * Property | Description
             * --- | ---
             * bitmap.width | width of image in pixels
             * bitmap.height | height of image in pixels
             * bitmap.data | a Buffer whose every four bytes represents a pixel, each sequential byte of a pixel corresponding to the red, green, blue, and alpha values of the pixel
             *
             * Its constructor supports the following signatures:
             *
             * * new BitmapImage(bitmap: { width: number, height: number, data: Buffer })
             * * new BitmapImage(bitmapImage: BitmapImage)
             * * new BitmapImage(width: number, height: number, buffer: Buffer)
             * * new BitmapImage(width: number, height: number, backgroundRGBA?: number)
             * 
             * When a `BitmapImage` is provided, the constructed `BitmapImage` is a deep clone of the provided one, so that each image's pixel data can subsequently be modified without affecting each other.
             *
             * `backgroundRGBA` is an optional parameter representing a pixel as a single number. In hex, the number is as follows: 0xRRGGBBAA, where RR is the red byte, GG the green byte, BB, the blue byte, and AA the alpha value. An AA of 0x00 is considered transparent, and all non-zero AA values are treated as opaque.
             */
            constructor(...E) {
              if (E.length === 0)
                throw new Error("constructor requires parameters");
              const c = E[0];
              if (c !== null && typeof c == "object")
                if (c instanceof x) {
                  const u = c.bitmap;
                  this.bitmap = {
                    width: u.width,
                    height: u.height,
                    data: new M(u.width * u.height * 4)
                  }, u.data.copy(this.bitmap.data);
                } else if (c.width && c.height && c.data)
                  this.bitmap = c;
                else
                  throw new Error("unrecognized constructor parameters");
              else if (typeof c == "number" && typeof E[1] == "number") {
                const u = c, l = E[1], a = E[2];
                this.bitmap = { width: u, height: l }, M.isBuffer(a) ? this.bitmap.data = a : (this.bitmap.data = new M(u * l * 4), typeof a == "number" && this.fillRGBA(a));
              } else
                throw new Error("unrecognized constructor parameters");
            }
            /**
             * Copy a square portion of this image into another image. 
             * 
             * @param {BitmapImage} toImage Image into which to copy the square
             * @param {number} toX x-coord in toImage of upper-left corner of receiving square
             * @param {number} toY y-coord in toImage of upper-left corner of receiving square
             * @param {number} fromX x-coord in this image of upper-left corner of source square
             * @param {number} fromY y-coord in this image of upper-left corner of source square
             * @return {BitmapImage} The present image to allow for chaining.
             */
            blit(E, c, u, l, a, n, d) {
              if (l + n > this.bitmap.width)
                throw new Error("copy exceeds width of source bitmap");
              if (c + n > E.bitmap.width)
                throw new Error("copy exceeds width of target bitmap");
              if (a + d > this.bitmap.height)
                throw new Error("copy exceeds height of source bitmap");
              if (u + d > E.bitmap.height)
                throw new Erro("copy exceeds height of target bitmap");
              const g = this.bitmap.data, h = E.bitmap.data, m = this.bitmap.width * 4, s = E.bitmap.width * 4, b = n * 4;
              let S = a * m + l * 4, o = u * s + c * 4;
              for (; --d >= 0; )
                g.copy(h, o, S, S + b), S += m, o += s;
              return this;
            }
            /**
             * Fills the image with a single color.
             * 
             * @param {number} rgba Color with which to fill image, expressed as a singlenumber in the form 0xRRGGBBAA, where AA is 0x00 for transparent and any other value for opaque.
             * @return {BitmapImage} The present image to allow for chaining.
             */
            fillRGBA(E) {
              const c = this.bitmap.data, u = this.bitmap.height * 4;
              let l = 0;
              for (; l < u; )
                c.writeUInt32BE(E, l), l += 4;
              for (; l < c.length; )
                c.copy(c, l, 0, u), l += u;
              return this;
            }
            /**
             * Gets the RGBA number of the pixel at the given coordinate in the form 0xRRGGBBAA, where AA is the alpha value, with alpha 0x00 encoding to transparency in GIFs.
             * 
             * @param {number} x x-coord of pixel
             * @param {number} y y-coord of pixel
             * @return {number} RGBA of pixel in 0xRRGGBBAA form
             */
            getRGBA(E, c) {
              const u = (c * this.bitmap.width + E) * 4;
              return this.bitmap.data.readUInt32BE(u);
            }
            /**
             * Gets a set of all RGBA colors found within the image.
             * 
             * @return {Set} Set of all RGBA colors that the image contains.
             */
            getRGBASet() {
              const E = /* @__PURE__ */ new Set(), c = this.bitmap.data;
              for (let u = 0; u < c.length; u += 4)
                E.add(c.readUInt32BE(u, !0));
              return E;
            }
            /**
             * Converts the image to greyscale using inferred Adobe metrics.
             * 
             * @return {BitmapImage} The present image to allow for chaining.
             */
            greyscale() {
              const E = this.bitmap.data;
              return this.scan(0, 0, this.bitmap.width, this.bitmap.height, (c, u, l) => {
                const a = Math.round(
                  0.299 * E[l] + 0.587 * E[l + 1] + 0.114 * E[l + 2]
                );
                E[l] = a, E[l + 1] = a, E[l + 2] = a;
              }), this;
            }
            /**
             * Reframes the image as if placing a frame around the original image and replacing the original image with the newly framed image. When the new frame is strictly within the boundaries of the original image, this method crops the image. When any of the new boundaries exceed those of the original image, the `fillRGBA` must be provided to indicate the color with which to fill the extra space added to the image.
             * 
             * @param {number} xOffset The x-coord offset of the upper-left pixel of the desired image relative to the present image.
             * @param {number} yOffset The y-coord offset of the upper-left pixel of the desired image relative to the present image.
             * @param {number} width The width of the new image after reframing
             * @param {number} height The height of the new image after reframing
             * @param {number} fillRGBA The color with which to fill space added to the image as a result of the reframing, in 0xRRGGBBAA format, where AA is 0x00 to indicate transparent and a non-zero value to indicate opaque. This parameter is only required when the reframing exceeds the original boundaries (i.e. does not simply perform a crop).
             * @return {BitmapImage} The present image to allow for chaining.
             */
            reframe(E, c, u, l, a) {
              const n = E < 0 ? 0 : E, d = c < 0 ? 0 : c, g = u + n > this.bitmap.width ? this.bitmap.width - n : u, h = l + d > this.bitmap.height ? this.bitmap.height - d : l, m = E < 0 ? -E : 0, s = c < 0 ? -c : 0;
              let b;
              if (a === void 0) {
                if (n !== E || d != c || g !== u || h !== l)
                  throw new GifError("fillRGBA required for this reframing");
                b = new x(u, l);
              } else
                b = new x(u, l, a);
              return this.blit(b, m, s, n, d, g, h), this.bitmap = b.bitmap, this;
            }
            /**
             * Scales the image size up by an integer factor. Each pixel of the original image becomes a square of the same color in the new image having a size of `factor` x `factor` pixels.
             * 
             * @param {number} factor The factor by which to scale up the image. Must be an integer >= 1.
             * @return {BitmapImage} The present image to allow for chaining.
             */
            scale(E) {
              if (E === 1)
                return;
              if (!Number.isInteger(E) || E < 1)
                throw new Error("the scale must be an integer >= 1");
              const c = this.bitmap.width, u = this.bitmap.height, l = c * E * 4, a = this.bitmap.data, n = new M(u * l * E);
              let d = 0, g, h = 0;
              for (let m = 0; m < u; ++m) {
                g = h;
                for (let s = 0; s < c; ++s) {
                  const b = a.readUInt32BE(d, !0);
                  for (let S = 0; S < E; ++S)
                    n.writeUInt32BE(b, h), h += 4;
                  d += 4;
                }
                for (let s = 1; s < E; ++s)
                  n.copy(n, h, g, h), h += l, g += l;
              }
              return this.bitmap = {
                width: c * E,
                height: u * E,
                data: n
              }, this;
            }
            /**
             * Scans all coordinates of the image, handing each in turn to the provided handler function.
             *
             * @param {function} scanHandler A function(x: number, y: number, bi: number) to be called for each pixel of the image with that pixel's x-coord, y-coord, and index into the `data` buffer. The function accesses the pixel at this coordinate by accessing the `this.data` at index `bi`.
             * @see scanAllIndexes
             */
            scanAllCoords(E) {
              const c = this.bitmap.width, u = this.bitmap.data.length;
              let l = 0, a = 0;
              for (let n = 0; n < u; n += 4)
                E(l, a, n), ++l === c && (l = 0, ++a);
            }
            /**
             * Scans all pixels of the image, handing the index of each in turn to the provided handler function. Runs a bit faster than `scanAllCoords()`, should the handler not need pixel coordinates.
             *
             * @param {function} scanHandler A function(bi: number) to be called for each pixel of the image with that pixel's index into the `data` buffer. The pixels is found at index 'bi' within `this.data`.
             * @see scanAllCoords
             */
            scanAllIndexes(E) {
              const c = this.bitmap.data.length;
              for (let u = 0; u < c; u += 4)
                E(u);
            }
          }
          Z.exports = x;
        }).call(this, k("buffer").Buffer);
      }, { buffer: 48 }], 66: [function(k, Z, _) {
        class M {
          // width - width of GIF in pixels
          // height - height of GIF in pixels
          // loops - 0 = unending; (n > 0) = iterate n times
          // usesTransparency - whether any frames have transparent pixels
          // colorScope - scope of color tables in GIF
          // frames - array of frames
          // buffer - GIF-formatted data
          /**
           * Gif is a class representing an encoded GIF. It is intended to be a read-only representation of a byte-encoded GIF. Only encoders and decoders should be creating instances of this class.
           * 
           * Property | Description
           * --- | ---
           * width | width of the GIF at its widest
           * height | height of the GIF at its highest
           * loops | the number of times the GIF should loop before stopping; 0 => loop indefinately
           * usesTransparency | boolean indicating whether at least one frame contains at least one transparent pixel
           * colorScope | the scope of the color tables as encoded within the GIF; either Gif.GlobalColorsOnly (== 1) or Gif.LocalColorsOnly (== 2).
           * frames | a array of GifFrame instances, one for each frame of the GIF
           * buffer | a Buffer holding the encoding's byte data
           * 
           * Its constructor should only ever be called by the GIF encoder or decoder.
           *
           * @param {Buffer} buffer A Buffer containing the encoded bytes
           * @param {GifFrame[]} frames Array of frames found in the encoding
           * @param {object} spec Properties of the encoding as listed above
           */
          constructor(E, c, u) {
            this.width = u.width, this.height = u.height, this.loops = u.loops, this.usesTransparency = u.usesTransparency, this.colorScope = u.colorScope, this.frames = c, this.buffer = E;
          }
        }
        M.GlobalColorsPreferred = 0, M.GlobalColorsOnly = 1, M.LocalColorsOnly = 2;
        class x extends Error {
          /**
           * GifError is a class representing a GIF-related error
           * 
           * @param {string|Error} messageOrError
           */
          constructor(E) {
            super(E), E instanceof Error && (this.stack = "Gif" + E.stack);
          }
        }
        _.Gif = M, _.GifError = x;
      }, {}], 67: [function(k, Z, _) {
        (function(M, x) {
          const y = k("omggif"), { Gif: E, GifError: c } = k("./gif");
          let u;
          M.nextTick(() => {
            u = k("./gifutil");
          });
          const { GifFrame: l } = k("./gifframe"), a = 200, n = 100;
          class d {
            // _transparentRGBA - RGB given to transparent pixels (alpha=0) on decode; defaults to null indicating 0x000000, which is fastest
            /**
             * GifCodec is a class that both encodes and decodes GIFs. It implements both the `encode()` method expected of an encoder and the `decode()` method expected of a decoder, and it wraps the `omggif` GIF encoder/decoder package. GifCodec serves as this library's default encoder and decoder, but it's possible to wrap other GIF encoders and decoders for use by `gifwrap` as well. GifCodec will not encode GIFs with interlacing.
             * 
             * Instances of this class are stateless and can be shared across multiple encodings and decodings.
             * 
             * Its constructor takes one option argument:
             * 
             * @param {object} options Optionally takes an objection whose only possible property is `transparentRGB`. Images are internally represented in RGBA format, where A is the alpha value of a pixel. When `transparentRGB` is provided, this RGB value (excluding alpha) is assigned to transparent pixels, which are also given alpha value 0x00. (All opaque pixels are given alpha value 0xFF). The RGB color of transparent pixels shouldn't matter for most applications. Defaults to 0x000000.
             */
            constructor(L = {}) {
              this._transparentRGB = null, typeof L.transparentRGB == "number" && L.transparentRGB !== 0 && (this._transparentRGBA = L.transparentRGB * 256), this._testInitialBufferSize = 0;
            }
            /**
             * Decodes a GIF from a Buffer to yield an instance of Gif. Transparent pixels of the GIF are given alpha values of 0x00, and opaque pixels are given alpha values of 0xFF. The RGB values of transparent pixels default to 0x000000 but can be overridden by the constructor's `transparentRGB` option.
             * 
             * @param {Buffer} buffer Bytes of an encoded GIF to decode.
             * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
             * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
             */
            decodeGif(L) {
              try {
                let z;
                try {
                  z = new y.GifReader(L);
                } catch (oe) {
                  throw new c(oe);
                }
                const U = z.numFrames(), J = [], F = {
                  width: z.width,
                  height: z.height,
                  loops: z.loopCount()
                };
                F.usesTransparency = !1;
                for (let oe = 0; oe < U; ++oe) {
                  const ee = this._decodeFrame(z, oe, F.usesTransparency);
                  J.push(ee.frame), ee.usesTransparency && (F.usesTransparency = !0);
                }
                return Promise.resolve(new E(L, J, F));
              } catch (z) {
                return Promise.reject(z);
              }
            }
            /**
             * Encodes a GIF from provided frames. Each pixel having an alpha value of 0x00 renders as transparent within the encoding, while all pixels of non-zero alpha value render as opaque.
             * 
             * @param {GifFrame[]} frames Array of frames to encode
             * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely, and `colorScope` defaults to Gif.GlobalColorsPreferred.
             * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
             * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
             */
            encodeGif(L, z = {}) {
              try {
                if (L === null || L.length === 0)
                  throw new c("there are no frames");
                const U = u.getMaxDimensions(L);
                return z = Object.assign({}, z), z.width = U.maxWidth, z.height = U.maxHeight, z.loops = z.loops || 0, z.colorScope = z.colorScope || E.GlobalColorsPreferred, Promise.resolve(this._encodeGif(L, z));
              } catch (U) {
                return Promise.reject(U);
              }
            }
            _decodeFrame(L, z, U) {
              let J, F;
              try {
                if (J = L.frameInfo(z), F = new x(L.width * L.height * 4), L.decodeAndBlitFrameRGBA(z, F), J.width !== L.width || J.height !== L.height) {
                  if (J.y && (F = F.slice(J.y * L.width * 4)), L.width > J.width)
                    for (let ie = 0; ie < J.height; ++ie)
                      F.copy(
                        F,
                        ie * J.width * 4,
                        (J.x + ie * L.width) * 4,
                        (J.x + ie * L.width) * 4 + J.width * 4
                      );
                  F = F.slice(0, J.width * J.height * 4);
                }
              } catch (ie) {
                throw new c(ie);
              }
              let oe = !1;
              if (this._transparentRGBA === null) {
                if (!U)
                  for (let ie = 3; ie < F.length; ie += 4)
                    F[ie] === 0 && (oe = !0, ie = F.length);
              } else
                for (let ie = 3; ie < F.length; ie += 4)
                  F[ie] === 0 && (F.writeUInt32BE(this._transparentRGBA, ie - 3), oe = !0);
              return { frame: new l(J.width, J.height, F, {
                xOffset: J.x,
                yOffset: J.y,
                disposalMethod: J.disposal,
                interlaced: J.interlaced,
                delayCentisecs: J.delay
              }), usesTransparency: oe };
            }
            _encodeGif(L, z) {
              let U;
              if (z.colorScope === E.LocalColorsOnly)
                U = u.getColorInfo(L, 0);
              else if (U = u.getColorInfo(L, 256), !U.colors) {
                if (z.colorScope === E.GlobalColorsOnly)
                  throw new c(
                    "Too many color indexes for global color table"
                  );
                z.colorScope = E.LocalColorsOnly;
              }
              z.usesTransparency = U.usesTransparency;
              const J = U.palettes;
              return z.colorScope === E.LocalColorsOnly ? s(L, z, 2e3, J) : m(L, z, 2e3, U);
            }
            _getSizeEstimateGlobal(L, z) {
              if (this._testInitialBufferSize > 0)
                return this._testInitialBufferSize;
              let U = a + 3 * 256;
              const J = A(L);
              return z.forEach((F) => {
                U += S(F, J);
              }), U;
            }
            _getSizeEstimateLocal(L, z) {
              if (this._testInitialBufferSize > 0)
                return this._testInitialBufferSize;
              let U = a;
              for (let J = 0; J < z.length; ++J) {
                const F = L[J], oe = A(F);
                U += S(z[J], oe);
              }
              return U;
            }
          }
          _.GifCodec = d;
          function g(I, L) {
            const z = I.indexOf(L);
            return z === -1 ? null : z;
          }
          function h(I, L) {
            for (var z = 0, U = I.length - 1, J; z <= U; )
              if (J = Math.floor((z + U) / 2), I[J] > L)
                U = J - 1;
              else if (I[J] < L)
                z = J + 1;
              else
                return J;
            return null;
          }
          function m(I, L, z, U) {
            const J = {
              colors: U.colors.slice(),
              usesTransparency: U.usesTransparency
            };
            b(J);
            const F = {
              palette: J.colors,
              loop: L.loops
            };
            let oe = new x(z), ee;
            try {
              ee = new y.GifWriter(
                oe,
                L.width,
                L.height,
                F
              );
            } catch (ie) {
              throw new c(ie);
            }
            for (let ie = 0; ie < I.length; ++ie)
              oe = T(ee, ie, I[ie], U, !1);
            return new E(oe.slice(0, ee.end()), I, L);
          }
          function s(I, L, z, U) {
            const J = {
              loop: L.loops
            };
            let F = new x(z), oe;
            try {
              oe = new y.GifWriter(
                F,
                L.width,
                L.height,
                J
              );
            } catch (ee) {
              throw new c(ee);
            }
            for (let ee = 0; ee < I.length; ++ee)
              F = T(oe, ee, I[ee], U[ee], !0);
            return new E(F.slice(0, oe.end()), I, L);
          }
          function b(I) {
            const L = I.colors;
            I.usesTransparency && L.push(0);
            const z = L.length;
            let U = 2;
            for (; z > U; )
              U <<= 1;
            L.length = U, L.fill(0, z);
          }
          function S(I, L) {
            let z = I.bitmap.width * I.bitmap.height;
            return z = Math.ceil(z * L / 8), z += Math.ceil(z / 255), n + z + 3 * 256;
          }
          function o(I, L, z) {
            const U = z.colors, J = U.length <= 8 ? (
              // guess at the break-even
              g
            ) : h, F = L.bitmap.data, oe = new x(F.length / 4);
            let ee = U.length, ie = 0, W = 0;
            for (; ie < F.length; ) {
              if (F[ie + 3] !== 0) {
                const Q = F.readUInt32BE(ie, !0) >> 8 & 16777215;
                oe[W] = J(U, Q);
              } else
                oe[W] = ee;
              ie += 4, ++W;
            }
            if (z.usesTransparency) {
              if (ee === 256)
                throw new c(`Frame ${I} already has 256 colorsand so can't use transparency`);
            } else
              ee = null;
            return { buffer: oe, transparentIndex: ee };
          }
          function A(I) {
            let L = I.indexCount, z = 0;
            for (--L; L; )
              ++z, L >>= 1;
            return z > 0 ? z : 1;
          }
          function T(I, L, z, U, J) {
            if (z.interlaced)
              throw new c("writing interlaced GIFs is not supported");
            const F = o(L, z, U), oe = {
              delay: z.delayCentisecs,
              disposal: z.disposalMethod,
              transparent: F.transparentIndex
            };
            J && (b(U), oe.palette = U.colors);
            try {
              let ee = I.getOutputBuffer(), ie = I.getOutputBufferPosition(), W, Q = !0;
              for (; Q; )
                if (W = I.addFrame(
                  z.xOffset,
                  z.yOffset,
                  z.bitmap.width,
                  z.bitmap.height,
                  F.buffer,
                  oe
                ), Q = !1, W >= ee.length - 1) {
                  const de = new x(ee.length * 1.5);
                  ee.copy(de), I.setOutputBuffer(de), I.setOutputBufferPosition(ie), ee = de, Q = !0;
                }
              return ee;
            } catch (ee) {
              throw new c(ee);
            }
          }
        }).call(this, k("_process"), k("buffer").Buffer);
      }, { "./gif": 66, "./gifframe": 68, "./gifutil": 69, _process: 133, buffer: 48, omggif: 64 }], 68: [function(k, Z, _) {
        const M = k("./bitmapimage"), { GifError: x } = k("./gif");
        class y extends M {
          // xOffset - x offset of bitmap on GIF (defaults to 0)
          // yOffset - y offset of bitmap on GIF (defaults to 0)
          // disposalMethod - pixel disposal method when handling partial images
          // delayCentisecs - duration of frame in hundredths of a second
          // interlaced - whether the image is interlaced (defaults to false)
          /**
           * GifFrame is a class representing an image frame of a GIF. GIFs contain one or more instances of GifFrame.
           * 
           * Property | Description
           * --- | ---
           * xOffset | x-coord of position within GIF at which to render the image (defaults to 0)
           * yOffset | y-coord of position within GIF at which to render the image (defaults to 0)
           * disposalMethod | GIF disposal method; only relevant when the frames aren't all the same size (defaults to 2, disposing to background color)
           * delayCentisecs | duration of the frame in hundreths of a second
           * interlaced | boolean indicating whether the frame renders interlaced
           * 
           * Its constructor supports the following signatures:
           * 
           * * new GifFrame(bitmap: {width: number, height: number, data: Buffer}, options?)
           * * new GifFrame(bitmapImage: BitmapImage, options?)
           * * new GifFrame(width: number, height: number, buffer: Buffer, options?)
           * * new GifFrame(width: number, height: number, backgroundRGBA?: number, options?)
           * * new GifFrame(frame: GifFrame)
           * 
           * See the base class BitmapImage for a discussion of all parameters but `options` and `frame`. `options` is an optional argument providing initial values for the above-listed GifFrame properties. Each property within option is itself optional.
           * 
           * Provide a `frame` to the constructor to create a clone of the provided frame. The new frame includes a copy of the provided frame's pixel data so that each can subsequently be modified without affecting each other.
           */
          constructor(...c) {
            if (super(...c), c[0] instanceof y) {
              const u = c[0];
              this.xOffset = u.xOffset, this.yOffset = u.yOffset, this.disposalMethod = u.disposalMethod, this.delayCentisecs = u.delayCentisecs, this.interlaced = u.interlaced;
            } else {
              const u = c[c.length - 1];
              let l = {};
              typeof u == "object" && !(u instanceof M) && (l = u), this.xOffset = l.xOffset || 0, this.yOffset = l.yOffset || 0, this.disposalMethod = l.disposalMethod !== void 0 ? l.disposalMethod : y.DisposeToBackgroundColor, this.delayCentisecs = l.delayCentisecs || 8, this.interlaced = l.interlaced || !1;
            }
          }
          /**
           * Get a summary of the colors found within the frame. The return value is an object of the following form:
           * 
           * Property | Description
           * --- | ---
           * colors | An array of all the opaque colors found within the frame. Each color is given as an RGB number of the form 0xRRGGBB. The array is sorted by increasing number. Will be an empty array when the image is completely transparent.
           * usesTransparency | boolean indicating whether there are any transparent pixels within the frame. A pixel is considered transparent if its alpha value is 0x00.
           * indexCount | The number of color indexes required to represent this palette of colors. It is equal to the number of opaque colors plus one if the image includes transparency.
           * 
           * @return {object} An object representing a color palette as described above.
           */
          getPalette() {
            const c = /* @__PURE__ */ new Set(), u = this.bitmap.data;
            let l = 0, a = !1;
            for (; l < u.length; ) {
              if (u[l + 3] === 0)
                a = !0;
              else {
                const h = u.readUInt32BE(l, !0) >> 8 & 16777215;
                c.add(h);
              }
              l += 4;
            }
            const n = new Array(c.size), d = c.values();
            for (l = 0; l < n.length; ++l)
              n[l] = d.next().value;
            n.sort((h, m) => h - m);
            let g = n.length;
            return a && ++g, { colors: n, usesTransparency: a, indexCount: g };
          }
        }
        y.DisposeToAnything = 0, y.DisposeNothing = 1, y.DisposeToBackgroundColor = 2, y.DisposeToPrevious = 3, _.GifFrame = y;
      }, { "./bitmapimage": 65, "./gif": 66 }], 69: [function(k, Z, _) {
        (function(M) {
          const x = k("fs"), y = k("image-q"), E = k("./bitmapimage"), { GifFrame: c } = k("./gifframe"), { GifError: u } = k("./gif"), { GifCodec: l } = k("./gifcodec"), a = [".jpg", ".jpeg", ".png", ".bmp"], n = new l();
          _.cloneFrames = function(m) {
            let s = [];
            return m.forEach((b) => {
              s.push(new c(b));
            }), s;
          }, _.getColorInfo = function(m, s) {
            let b = !1;
            const S = [];
            for (let L = 0; L < m.length; ++L) {
              let z = m[L].getPalette();
              if (z.usesTransparency && (b = !0), z.indexCount > 256)
                throw new u(`Frame ${L} uses more than 256 color indexes`);
              S.push(z);
            }
            if (s === 0)
              return { usesTransparency: b, palettes: S };
            const o = /* @__PURE__ */ new Set();
            S.forEach((L) => {
              L.colors.forEach((z) => {
                o.add(z);
              });
            });
            let A = o.size;
            if (b && ++A, s && A > s)
              return { usesTransparency: b, palettes: S };
            const T = new Array(o.size), I = o.values();
            for (let L = 0; L < T.length; ++L)
              T[L] = I.next().value;
            return T.sort((L, z) => L - z), { colors: T, indexCount: A, usesTransparency: b, palettes: S };
          }, _.copyAsJimp = function(m, s) {
            return _.shareAsJimp(m, new E(s));
          }, _.getMaxDimensions = function(m) {
            let s = 0, b = 0;
            return m.forEach((S) => {
              const o = S.xOffset + S.bitmap.width;
              o > s && (s = o);
              const A = S.yOffset + S.bitmap.height;
              A > b && (b = A);
            }), { maxWidth: s, maxHeight: b };
          }, _.quantizeDekker = function(m, s, b) {
            s = s || 256, d(m, "NeuQuantFloat", s, 0, b);
          }, _.quantizeSorokin = function(m, s, b, S) {
            s = s || 256, b = b || "min-pop";
            let o;
            switch (b) {
              case "min-pop":
                o = 2;
                break;
              case "top-pop":
                o = 1;
                break;
              default:
                throw new Error(`Invalid quantizeSorokin histogram '${b}'`);
            }
            d(m, "RGBQuant", s, o, S);
          }, _.quantizeWu = function(m, s, b, S) {
            if (s = s || 256, b = b || 5, b < 1 || b > 8)
              throw new Error("Invalid quantization quality");
            d(m, "WuQuant", s, b, S);
          }, _.read = function(m, s) {
            return s = s || n, M.isBuffer(m) ? s.decodeGif(m) : g(m).then((b) => s.decodeGif(b));
          }, _.shareAsJimp = function(m, s) {
            const b = new m(
              s.bitmap.width,
              s.bitmap.height,
              0
            );
            return b.bitmap.data = s.bitmap.data, b;
          }, _.write = function(m, s, b, S) {
            S = S || n;
            const o = m.match(/\.[a-zA-Z]+$/);
            if (o !== null && a.includes(o[0].toLowerCase()))
              throw new Error(`GIF '${m}' has an unexpected suffix`);
            return S.encodeGif(s, b).then((A) => h(m, A.buffer).then(() => A));
          };
          function d(m, s, b, S, o) {
            const A = Array.isArray(m) ? m : [m], T = [
              "FloydSteinberg",
              "FalseFloydSteinberg",
              "Stucki",
              "Atkinson",
              "Jarvis",
              "Burkes",
              "Sierra",
              "TwoSierra",
              "SierraLite"
            ];
            if (o) {
              if (T.indexOf(o.ditherAlgorithm) < 0)
                throw new Error(`Invalid ditherAlgorithm '${o.ditherAlgorithm}'`);
              o.serpentine === void 0 && (o.serpentine = !0), o.minimumColorDistanceToDither === void 0 && (o.minimumColorDistanceToDither = 0), o.calculateErrorLikeGIMP === void 0 && (o.calculateErrorLikeGIMP = !1);
            }
            const I = new y.distance.Euclidean(), L = new y.palette[s](I, b, S);
            let z;
            o ? z = new y.image.ErrorDiffusionArray(
              I,
              y.image.ErrorDiffusionArrayKernel[o.ditherAlgorithm],
              o.serpentine,
              o.minimumColorDistanceToDither,
              o.calculateErrorLikeGIMP
            ) : z = new y.image.NearestColor(I);
            const U = [];
            A.forEach((F) => {
              const oe = F.bitmap.data, ee = new ArrayBuffer(oe.length), ie = new Uint32Array(ee);
              for (let Q = 0, de = 0; Q < oe.length; Q += 4, ++de)
                ie[de] = oe.readUInt32LE(Q, !0);
              const W = y.utils.PointContainer.fromUint32Array(
                ie,
                F.bitmap.width,
                F.bitmap.height
              );
              L.sample(W), U.push(W);
            });
            const J = L.quantize();
            for (let F = 0; F < A.length; ++F) {
              const oe = A[F].bitmap.data, ie = z.quantize(U[F], J).toUint32Array();
              for (let W = 0, Q = 0; W < oe.length; W += 4, ++Q)
                oe.writeUInt32LE(ie[Q], W);
            }
          }
          function g(m) {
            return new Promise((s, b) => {
              x.readFile(m, (S, o) => S ? b(S) : s(o));
            });
          }
          function h(m, s) {
            return new Promise((b, S) => {
              x.writeFile(m, s, (o) => o ? S(o) : b());
            });
          }
        }).call(this, { isBuffer: k("../../is-buffer/index.js") });
      }, { "../../is-buffer/index.js": 76, "./bitmapimage": 65, "./gif": 66, "./gifcodec": 67, "./gifframe": 68, fs: 47, "image-q": 74 }], 70: [function(k, Z, _) {
        const M = k("./bitmapimage"), { Gif: x, GifError: y } = k("./gif"), { GifCodec: E } = k("./gifcodec"), { GifFrame: c } = k("./gifframe"), u = k("./gifutil");
        Z.exports = {
          BitmapImage: M,
          Gif: x,
          GifCodec: E,
          GifFrame: c,
          GifUtil: u,
          GifError: y
        };
      }, { "./bitmapimage": 65, "./gif": 66, "./gifcodec": 67, "./gifframe": 68, "./gifutil": 69 }], 71: [function(k, Z, _) {
        (function(M) {
          var x;
          typeof ae < "u" ? x = ae : typeof M < "u" ? x = M : typeof self < "u" ? x = self : x = {}, Z.exports = x;
        }).call(this, typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {});
      }, {}], 72: [function(k, Z, _) {
        var M = k("http"), x = k("url"), y = Z.exports;
        for (var E in M)
          M.hasOwnProperty(E) && (y[E] = M[E]);
        y.request = function(u, l) {
          return u = c(u), M.request.call(this, u, l);
        }, y.get = function(u, l) {
          return u = c(u), M.get.call(this, u, l);
        };
        function c(u) {
          if (typeof u == "string" && (u = x.parse(u)), u.protocol || (u.protocol = "https:"), u.protocol !== "https:")
            throw new Error('Protocol "' + u.protocol + '" not supported. Expected "https:"');
          return u;
        }
      }, { http: 156, url: 180 }], 73: [function(k, Z, _) {
        _.read = function(M, x, y, E, c) {
          var u, l, a = c * 8 - E - 1, n = (1 << a) - 1, d = n >> 1, g = -7, h = y ? c - 1 : 0, m = y ? -1 : 1, s = M[x + h];
          for (h += m, u = s & (1 << -g) - 1, s >>= -g, g += a; g > 0; u = u * 256 + M[x + h], h += m, g -= 8)
            ;
          for (l = u & (1 << -g) - 1, u >>= -g, g += E; g > 0; l = l * 256 + M[x + h], h += m, g -= 8)
            ;
          if (u === 0)
            u = 1 - d;
          else {
            if (u === n)
              return l ? NaN : (s ? -1 : 1) * (1 / 0);
            l = l + Math.pow(2, E), u = u - d;
          }
          return (s ? -1 : 1) * l * Math.pow(2, u - E);
        }, _.write = function(M, x, y, E, c, u) {
          var l, a, n, d = u * 8 - c - 1, g = (1 << d) - 1, h = g >> 1, m = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, s = E ? 0 : u - 1, b = E ? 1 : -1, S = x < 0 || x === 0 && 1 / x < 0 ? 1 : 0;
          for (x = Math.abs(x), isNaN(x) || x === 1 / 0 ? (a = isNaN(x) ? 1 : 0, l = g) : (l = Math.floor(Math.log(x) / Math.LN2), x * (n = Math.pow(2, -l)) < 1 && (l--, n *= 2), l + h >= 1 ? x += m / n : x += m * Math.pow(2, 1 - h), x * n >= 2 && (l++, n /= 2), l + h >= g ? (a = 0, l = g) : l + h >= 1 ? (a = (x * n - 1) * Math.pow(2, c), l = l + h) : (a = x * Math.pow(2, h - 1) * Math.pow(2, c), l = 0)); c >= 8; M[y + s] = a & 255, s += b, a /= 256, c -= 8)
            ;
          for (l = l << c | a, d += c; d > 0; M[y + s] = l & 255, s += b, l /= 256, d -= 8)
            ;
          M[y + s - b] |= S * 128;
        };
      }, {}], 74: [function(k, Z, _) {
        (function(x, y) {
          typeof _ == "object" && typeof Z == "object" ? Z.exports = y() : typeof _ == "object" ? _.iq = y() : x.iq = y();
        })(this, function() {
          return (
            /******/
            function(M) {
              var x = {};
              function y(E) {
                if (x[E])
                  return x[E].exports;
                var c = x[E] = {
                  /******/
                  exports: {},
                  /******/
                  id: E,
                  /******/
                  loaded: !1
                  /******/
                };
                return M[E].call(c.exports, c, c.exports, y), c.loaded = !0, c.exports;
              }
              return y.m = M, y.c = x, y.p = "", y(0);
            }([
              /* 0 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var E = y(1);
                x.constants = E;
                var c = y(3);
                x.conversion = c;
                var u = y(12);
                x.distance = u;
                var l = y(20);
                x.palette = l;
                var a = y(30);
                x.image = a;
                var n = y(35);
                x.quality = n;
                var d = y(37);
                x.utils = d;
              },
              /* 1 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * constants.ts - part of Image Quantization Library
                 */
                var E = y(2);
                x.bt709 = E;
              },
              /* 2 */
              /***/
              function(M, x) {
                var y;
                (function(u) {
                  u[u.RED = 0.2126] = "RED", u[u.GREEN = 0.7152] = "GREEN", u[u.BLUE = 0.0722] = "BLUE", u[u.WHITE = 1] = "WHITE";
                })(y || (y = {})), x.Y = y;
                var E;
                (function(u) {
                  u[u.RED = 0.64] = "RED", u[u.GREEN = 0.3] = "GREEN", u[u.BLUE = 0.15] = "BLUE", u[u.WHITE = 0.3127] = "WHITE";
                })(E || (E = {})), x.x = E;
                var c;
                (function(u) {
                  u[u.RED = 0.33] = "RED", u[u.GREEN = 0.6] = "GREEN", u[u.BLUE = 0.06] = "BLUE", u[u.WHITE = 0.329] = "WHITE";
                })(c || (c = {})), x.y = c;
              },
              /* 3 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var E = y(4);
                x.rgb2xyz = E.rgb2xyz;
                var c = y(5);
                x.rgb2hsl = c.rgb2hsl;
                var u = y(7);
                x.rgb2lab = u.rgb2lab;
                var l = y(9);
                x.lab2xyz = l.lab2xyz;
                var a = y(10);
                x.lab2rgb = a.lab2rgb;
                var n = y(8);
                x.xyz2lab = n.xyz2lab;
                var d = y(11);
                x.xyz2rgb = d.xyz2rgb;
              },
              /* 4 */
              /***/
              function(M, x) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgb2xyz.ts - part of Image Quantization Library
                 */
                function y(c) {
                  return c > 0.04045 ? Math.pow((c + 0.055) / 1.055, 2.4) : c / 12.92;
                }
                function E(c, u, l) {
                  return c = y(c / 255), u = y(u / 255), l = y(l / 255), {
                    x: c * 0.4124 + u * 0.3576 + l * 0.1805,
                    y: c * 0.2126 + u * 0.7152 + l * 0.0722,
                    z: c * 0.0193 + u * 0.1192 + l * 0.9505
                  };
                }
                x.rgb2xyz = E;
              },
              /* 5 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgb2hsl.ts - part of Image Quantization Library
                 */
                var E = y(6);
                function c(u, l, a) {
                  var n = E.min3(u, l, a), d = E.max3(u, l, a), g = d - n, h = (n + d) / 510, m = 0;
                  h > 0 && h < 1 && (m = g / (h < 0.5 ? d + n : 510 - d - n));
                  var s = 0;
                  return g > 0 && (d === u ? s = (l - a) / g : d === l ? s = 2 + (a - u) / g : s = 4 + (u - l) / g, s *= 60, s < 0 && (s += 360)), { h: s, s: m, l: h };
                }
                x.rgb2hsl = c;
              },
              /* 6 */
              /***/
              function(M, x) {
                function y(d) {
                  return d * (Math.PI / 180);
                }
                x.degrees2radians = y;
                function E(d, g, h) {
                  var m = d;
                  return m < g && (m = g), m < h && (m = h), m;
                }
                x.max3 = E;
                function c(d, g, h) {
                  var m = d;
                  return m > g && (m = g), m > h && (m = h), m;
                }
                x.min3 = c;
                function u(d, g, h) {
                  return d > h && (d = h), d < g && (d = g), d | 0;
                }
                x.intInRange = u;
                function l(d) {
                  return d = Math.round(d), d > 255 ? d = 255 : d < 0 && (d = 0), d;
                }
                x.inRange0to255Rounded = l;
                function a(d) {
                  return d > 255 ? d = 255 : d < 0 && (d = 0), d;
                }
                x.inRange0to255 = a;
                function n(d, g) {
                  var h = typeof d[0], m;
                  if (h === "number" || h === "string") {
                    for (var s = /* @__PURE__ */ Object.create(null), b = 0, S = d.length; b < S; b++) {
                      var o = d[b];
                      s[o] || s[o] === 0 || (s[o] = b);
                    }
                    m = d.sort(function(T, I) {
                      return g(T, I) || s[T] - s[I];
                    });
                  } else {
                    var A = d.slice(0);
                    m = d.sort(function(T, I) {
                      return g(T, I) || A.indexOf(T) - A.indexOf(I);
                    });
                  }
                  return m;
                }
                x.stableSort = n;
              },
              /* 7 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgb2lab.ts - part of Image Quantization Library
                 */
                var E = y(4), c = y(8);
                function u(l, a, n) {
                  var d = E.rgb2xyz(l, a, n);
                  return c.xyz2lab(d.x, d.y, d.z);
                }
                x.rgb2lab = u;
              },
              /* 8 */
              /***/
              function(M, x) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * xyz2lab.ts - part of Image Quantization Library
                 */
                var y = 0.95047, E = 1, c = 1.08883;
                function u(a) {
                  return a > 8856e-6 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116;
                }
                function l(a, n, d) {
                  if (a = u(a / y), n = u(n / E), d = u(d / c), 116 * n - 16 < 0)
                    throw new Error("xxx");
                  return {
                    L: Math.max(0, 116 * n - 16),
                    a: 500 * (a - n),
                    b: 200 * (n - d)
                  };
                }
                x.xyz2lab = l;
              },
              /* 9 */
              /***/
              function(M, x) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * lab2xyz.ts - part of Image Quantization Library
                 */
                var y = 0.95047, E = 1, c = 1.08883;
                function u(a) {
                  return a > 0.206893034 ? Math.pow(a, 3) : (a - 16 / 116) / 7.787;
                }
                function l(a, n, d) {
                  var g = (a + 16) / 116, h = n / 500 + g, m = g - d / 200;
                  return {
                    x: y * u(h),
                    y: E * u(g),
                    z: c * u(m)
                  };
                }
                x.lab2xyz = l;
              },
              /* 10 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * lab2rgb.ts - part of Image Quantization Library
                 */
                var E = y(9), c = y(11);
                function u(l, a, n) {
                  var d = E.lab2xyz(l, a, n);
                  return c.xyz2rgb(d.x, d.y, d.z);
                }
                x.lab2rgb = u;
              },
              /* 11 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * xyz2rgb.ts - part of Image Quantization Library
                 */
                var E = y(6);
                function c(l) {
                  return l > 31308e-7 ? 1.055 * Math.pow(l, 1 / 2.4) - 0.055 : 12.92 * l;
                }
                function u(l, a, n) {
                  var d = c(l * 3.2406 + a * -1.5372 + n * -0.4986), g = c(l * -0.9689 + a * 1.8758 + n * 0.0415), h = c(l * 0.0557 + a * -0.204 + n * 1.057);
                  return {
                    r: E.inRange0to255Rounded(d * 255),
                    g: E.inRange0to255Rounded(g * 255),
                    b: E.inRange0to255Rounded(h * 255)
                  };
                }
                x.xyz2rgb = u;
              },
              /* 12 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var E = y(13);
                x.AbstractDistanceCalculator = E.AbstractDistanceCalculator;
                var c = y(14);
                x.CIE94Textiles = c.CIE94Textiles, x.CIE94GraphicArts = c.CIE94GraphicArts;
                var u = y(15);
                x.CIEDE2000 = u.CIEDE2000;
                var l = y(16);
                x.CMETRIC = l.CMETRIC;
                var a = y(17);
                x.AbstractEuclidean = a.AbstractEuclidean, x.Euclidean = a.Euclidean, x.EuclideanRgbQuantWOAlpha = a.EuclideanRgbQuantWOAlpha, x.EuclideanRgbQuantWithAlpha = a.EuclideanRgbQuantWithAlpha;
                var n = y(18);
                x.AbstractManhattan = n.AbstractManhattan, x.Manhattan = n.Manhattan, x.ManhattanSRGB = n.ManhattanSRGB, x.ManhattanNommyde = n.ManhattanNommyde;
                var d = y(19);
                x.PNGQUANT = d.PNGQUANT;
              },
              /* 13 */
              /***/
              function(M, x) {
                var y = function() {
                  function E() {
                    this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
                  }
                  return E.prototype.setWhitePoint = function(c, u, l, a) {
                    this._whitePoint = {
                      r: c > 0 ? 255 / c : 0,
                      g: u > 0 ? 255 / u : 0,
                      b: l > 0 ? 255 / l : 0,
                      a: a > 0 ? 255 / a : 0
                    }, this._maxDistance = this.calculateRaw(c, u, l, a, 0, 0, 0, 0);
                  }, E.prototype.calculateNormalized = function(c, u) {
                    return this.calculateRaw(c.r, c.g, c.b, c.a, u.r, u.g, u.b, u.a) / this._maxDistance;
                  }, E.prototype._setDefaults = function() {
                  }, E;
                }();
                x.AbstractDistanceCalculator = y;
              },
              /* 14 */
              /***/
              function(M, x, y) {
                var E = this && this.__extends || function(g, h) {
                  for (var m in h) h.hasOwnProperty(m) && (g[m] = h[m]);
                  function s() {
                    this.constructor = g;
                  }
                  g.prototype = h === null ? Object.create(h) : (s.prototype = h.prototype, new s());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * cie94.ts - part of Image Quantization Library
                 */
                var c = y(13), u = y(7), l = y(6), a = function(g) {
                  E(h, g);
                  function h() {
                    g.apply(this, arguments);
                  }
                  return h.prototype.calculateRaw = function(m, s, b, S, o, A, T, I) {
                    var L = u.rgb2lab(l.inRange0to255(m * this._whitePoint.r), l.inRange0to255(s * this._whitePoint.g), l.inRange0to255(b * this._whitePoint.b)), z = u.rgb2lab(l.inRange0to255(o * this._whitePoint.r), l.inRange0to255(A * this._whitePoint.g), l.inRange0to255(T * this._whitePoint.b)), U = L.L - z.L, J = L.a - z.a, F = L.b - z.b, oe = Math.sqrt(L.a * L.a + L.b * L.b), ee = Math.sqrt(z.a * z.a + z.b * z.b), ie = oe - ee, W = J * J + F * F - ie * ie;
                    W = W < 0 ? 0 : Math.sqrt(W);
                    var Q = (I - S) * this._whitePoint.a * this._kA;
                    return Math.sqrt(Math.pow(U / this._Kl, 2) + Math.pow(ie / (1 + this._K1 * oe), 2) + Math.pow(W / (1 + this._K2 * oe), 2) + Math.pow(Q, 2));
                  }, h;
                }(c.AbstractDistanceCalculator);
                x.AbstractCIE94 = a;
                var n = function(g) {
                  E(h, g);
                  function h() {
                    g.apply(this, arguments);
                  }
                  return h.prototype._setDefaults = function() {
                    this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 0.25 * 50 / 255;
                  }, h;
                }(a);
                x.CIE94Textiles = n;
                var d = function(g) {
                  E(h, g);
                  function h() {
                    g.apply(this, arguments);
                  }
                  return h.prototype._setDefaults = function() {
                    this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 0.25 * 100 / 255;
                  }, h;
                }(a);
                x.CIE94GraphicArts = d;
              },
              /* 15 */
              /***/
              function(M, x, y) {
                var E = this && this.__extends || function(n, d) {
                  for (var g in d) d.hasOwnProperty(g) && (n[g] = d[g]);
                  function h() {
                    this.constructor = n;
                  }
                  n.prototype = d === null ? Object.create(d) : (h.prototype = d.prototype, new h());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * ciede2000.ts - part of Image Quantization Library
                 */
                var c = y(13), u = y(7), l = y(6), a = function(n) {
                  E(d, n);
                  function d() {
                    n.apply(this, arguments);
                  }
                  return d.prototype.calculateRaw = function(g, h, m, s, b, S, o, A) {
                    var T = u.rgb2lab(l.inRange0to255(g * this._whitePoint.r), l.inRange0to255(h * this._whitePoint.g), l.inRange0to255(m * this._whitePoint.b)), I = u.rgb2lab(l.inRange0to255(b * this._whitePoint.r), l.inRange0to255(S * this._whitePoint.g), l.inRange0to255(o * this._whitePoint.b)), L = (A - s) * this._whitePoint.a * d._kA, z = this.calculateRawInLab(T, I);
                    return Math.sqrt(z + L * L);
                  }, d.prototype.calculateRawInLab = function(g, h) {
                    var m = g.L, s = g.a, b = g.b, S = h.L, o = h.a, A = h.b, T = Math.sqrt(s * s + b * b), I = Math.sqrt(o * o + A * A), L = Math.pow((T + I) / 2, 7), z = 0.5 * (1 - Math.sqrt(L / (L + d._pow25to7))), U = (1 + z) * s, J = (1 + z) * o, F = Math.sqrt(U * U + b * b), oe = Math.sqrt(J * J + A * A), ee = F * oe, ie = d._calculatehp(b, U), W = d._calculatehp(A, J), Q = Math.abs(ie - W), de = S - m, we = oe - F, ke = d._calculate_dHp(ee, Q, W, ie), Me = d._calculate_ahp(ee, Q, ie, W), fe = d._calculateT(Me), xe = (F + oe) / 2, Ee = Math.pow((m + S) / 2 - 50, 2), Pe = 1 + 0.015 * Ee / Math.sqrt(20 + Ee), Ue = 1 + 0.045 * xe, He = 1 + 0.015 * fe * xe, We = d._calculateRT(Me, xe), Ze = de / Pe, $e = we / Ue, Ve = ke / He;
                    return Math.pow(Ze, 2) + Math.pow($e, 2) + Math.pow(Ve, 2) + We * $e * Ve;
                  }, d._calculatehp = function(g, h) {
                    var m = Math.atan2(g, h);
                    return m >= 0 ? m : m + d._deg360InRad;
                  }, d._calculateRT = function(g, h) {
                    var m = Math.pow(h, 7), s = 2 * Math.sqrt(m / (m + d._pow25to7)), b = d._deg30InRad * Math.exp(-Math.pow((g - d._deg275InRad) / d._deg25InRad, 2));
                    return -Math.sin(2 * b) * s;
                  }, d._calculateT = function(g) {
                    return 1 - 0.17 * Math.cos(g - d._deg30InRad) + 0.24 * Math.cos(g * 2) + 0.32 * Math.cos(g * 3 + d._deg6InRad) - 0.2 * Math.cos(g * 4 - d._deg63InRad);
                  }, d._calculate_ahp = function(g, h, m, s) {
                    var b = m + s;
                    return g == 0 ? b : h <= d._deg180InRad ? b / 2 : b < d._deg360InRad ? (b + d._deg360InRad) / 2 : (b - d._deg360InRad) / 2;
                  }, d._calculate_dHp = function(g, h, m, s) {
                    var b;
                    return g == 0 ? b = 0 : h <= d._deg180InRad ? b = m - s : m <= s ? b = m - s + d._deg360InRad : b = m - s - d._deg360InRad, 2 * Math.sqrt(g) * Math.sin(b / 2);
                  }, d._kA = 0.25 * 100 / 255, d._pow25to7 = Math.pow(25, 7), d._deg360InRad = l.degrees2radians(360), d._deg180InRad = l.degrees2radians(180), d._deg30InRad = l.degrees2radians(30), d._deg6InRad = l.degrees2radians(6), d._deg63InRad = l.degrees2radians(63), d._deg275InRad = l.degrees2radians(275), d._deg25InRad = l.degrees2radians(25), d;
                }(c.AbstractDistanceCalculator);
                x.CIEDE2000 = a;
              },
              /* 16 */
              /***/
              function(M, x, y) {
                var E = this && this.__extends || function(l, a) {
                  for (var n in a) a.hasOwnProperty(n) && (l[n] = a[n]);
                  function d() {
                    this.constructor = l;
                  }
                  l.prototype = a === null ? Object.create(a) : (d.prototype = a.prototype, new d());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * cmetric.ts - part of Image Quantization Library
                 */
                var c = y(13), u = function(l) {
                  E(a, l);
                  function a() {
                    l.apply(this, arguments);
                  }
                  return a.prototype.calculateRaw = function(n, d, g, h, m, s, b, S) {
                    var o = (n + m) / 2 * this._whitePoint.r, A = (n - m) * this._whitePoint.r, T = (d - s) * this._whitePoint.g, I = (g - b) * this._whitePoint.b, L = ((512 + o) * A * A >> 8) + 4 * T * T + ((767 - o) * I * I >> 8), z = (S - h) * this._whitePoint.a;
                    return Math.sqrt(L + z * z);
                  }, a;
                }(c.AbstractDistanceCalculator);
                x.CMETRIC = u;
              },
              /* 17 */
              /***/
              function(M, x, y) {
                var E = this && this.__extends || function(g, h) {
                  for (var m in h) h.hasOwnProperty(m) && (g[m] = h[m]);
                  function s() {
                    this.constructor = g;
                  }
                  g.prototype = h === null ? Object.create(h) : (s.prototype = h.prototype, new s());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * euclidean.ts - part of Image Quantization Library
                 */
                var c = y(13), u = y(2), l = function(g) {
                  E(h, g);
                  function h() {
                    g.apply(this, arguments);
                  }
                  return h.prototype.calculateRaw = function(m, s, b, S, o, A, T, I) {
                    var L = o - m, z = A - s, U = T - b, J = I - S;
                    return Math.sqrt(this._kR * L * L + this._kG * z * z + this._kB * U * U + this._kA * J * J);
                  }, h;
                }(c.AbstractDistanceCalculator);
                x.AbstractEuclidean = l;
                var a = function(g) {
                  E(h, g);
                  function h() {
                    g.apply(this, arguments);
                  }
                  return h.prototype._setDefaults = function() {
                    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
                  }, h;
                }(l);
                x.Euclidean = a;
                var n = function(g) {
                  E(h, g);
                  function h() {
                    g.apply(this, arguments);
                  }
                  return h.prototype._setDefaults = function() {
                    this._kR = u.Y.RED, this._kG = u.Y.GREEN, this._kB = u.Y.BLUE, this._kA = 1;
                  }, h;
                }(l);
                x.EuclideanRgbQuantWithAlpha = n;
                var d = function(g) {
                  E(h, g);
                  function h() {
                    g.apply(this, arguments);
                  }
                  return h.prototype._setDefaults = function() {
                    this._kR = u.Y.RED, this._kG = u.Y.GREEN, this._kB = u.Y.BLUE, this._kA = 0;
                  }, h;
                }(l);
                x.EuclideanRgbQuantWOAlpha = d;
              },
              /* 18 */
              /***/
              function(M, x, y) {
                var E = this && this.__extends || function(g, h) {
                  for (var m in h) h.hasOwnProperty(m) && (g[m] = h[m]);
                  function s() {
                    this.constructor = g;
                  }
                  g.prototype = h === null ? Object.create(h) : (s.prototype = h.prototype, new s());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * manhattanNeuQuant.ts - part of Image Quantization Library
                 */
                var c = y(13), u = y(2), l = function(g) {
                  E(h, g);
                  function h() {
                    g.apply(this, arguments);
                  }
                  return h.prototype.calculateRaw = function(m, s, b, S, o, A, T, I) {
                    var L = o - m, z = A - s, U = T - b, J = I - S;
                    return L < 0 && (L = 0 - L), z < 0 && (z = 0 - z), U < 0 && (U = 0 - U), J < 0 && (J = 0 - J), this._kR * L + this._kG * z + this._kB * U + this._kA * J;
                  }, h;
                }(c.AbstractDistanceCalculator);
                x.AbstractManhattan = l;
                var a = function(g) {
                  E(h, g);
                  function h() {
                    g.apply(this, arguments);
                  }
                  return h.prototype._setDefaults = function() {
                    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
                  }, h;
                }(l);
                x.Manhattan = a;
                var n = function(g) {
                  E(h, g);
                  function h() {
                    g.apply(this, arguments);
                  }
                  return h.prototype._setDefaults = function() {
                    this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
                  }, h;
                }(l);
                x.ManhattanNommyde = n;
                var d = function(g) {
                  E(h, g);
                  function h() {
                    g.apply(this, arguments);
                  }
                  return h.prototype._setDefaults = function() {
                    this._kR = u.Y.RED, this._kG = u.Y.GREEN, this._kB = u.Y.BLUE, this._kA = 1;
                  }, h;
                }(l);
                x.ManhattanSRGB = d;
              },
              /* 19 */
              /***/
              function(M, x, y) {
                var E = this && this.__extends || function(l, a) {
                  for (var n in a) a.hasOwnProperty(n) && (l[n] = a[n]);
                  function d() {
                    this.constructor = l;
                  }
                  l.prototype = a === null ? Object.create(a) : (d.prototype = a.prototype, new d());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * pngQuant.ts - part of Image Quantization Library
                 */
                var c = y(13), u = function(l) {
                  E(a, l);
                  function a() {
                    l.apply(this, arguments);
                  }
                  return a.prototype.calculateRaw = function(n, d, g, h, m, s, b, S) {
                    var o = (S - h) * this._whitePoint.a;
                    return this._colordifference_ch(n * this._whitePoint.r, m * this._whitePoint.r, o) + this._colordifference_ch(d * this._whitePoint.g, s * this._whitePoint.g, o) + this._colordifference_ch(g * this._whitePoint.b, b * this._whitePoint.b, o);
                  }, a.prototype._colordifference_ch = function(n, d, g) {
                    var h = n - d, m = h + g;
                    return h * h + m * m;
                  }, a;
                }(c.AbstractDistanceCalculator);
                x.PNGQUANT = u;
              },
              /* 20 */
              /***/
              function(M, x, y) {
                var E = y(21);
                x.NeuQuant = E.NeuQuant;
                var c = y(25);
                x.NeuQuantFloat = c.NeuQuantFloat;
                var u = y(26);
                x.RGBQuant = u.RGBQuant;
                var l = y(27);
                x.ColorHistogram = l.ColorHistogram;
                var a = y(29);
                x.WuQuant = a.WuQuant, x.WuColorCube = a.WuColorCube;
              },
              /* 21 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * neuquant.ts - part of Image Quantization Library
                 */
                var E = y(22), c = y(24), u = 3, l = function() {
                  function n(d) {
                    this.r = this.g = this.b = this.a = d;
                  }
                  return n.prototype.toPoint = function() {
                    return c.Point.createByRGBA(this.r >> u, this.g >> u, this.b >> u, this.a >> u);
                  }, n.prototype.subtract = function(d, g, h, m) {
                    this.r -= d | 0, this.g -= g | 0, this.b -= h | 0, this.a -= m | 0;
                  }, n;
                }(), a = function() {
                  function n(d, g) {
                    g === void 0 && (g = 256), this._distance = d, this._pointArray = [], this._sampleFactor = 1, this._networkSize = g, this._distance.setWhitePoint(255 << u, 255 << u, 255 << u, 255 << u);
                  }
                  return n.prototype.sample = function(d) {
                    this._pointArray = this._pointArray.concat(d.getPointArray());
                  }, n.prototype.quantize = function() {
                    return this._init(), this._learn(), this._buildPalette();
                  }, n.prototype._init = function() {
                    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
                    for (var d = 0; d < this._networkSize; d++)
                      this._network[d] = new l((d << u + 8) / this._networkSize | 0), this._freq[d] = n._initialBias / this._networkSize | 0, this._bias[d] = 0;
                  }, n.prototype._learn = function() {
                    var d = this._sampleFactor, g = this._pointArray.length;
                    g < n._minpicturebytes && (d = 1);
                    var h = 30 + (d - 1) / 3 | 0, m = g / d | 0, s = m / n._nCycles | 0, b = n._initAlpha, S = (this._networkSize >> 3) * n._radiusBias, o = S >> n._radiusBiasShift;
                    o <= 1 && (o = 0);
                    for (var A = 0; A < o; A++)
                      this._radPower[A] = b * ((o * o - A * A) * n._radBias / (o * o)) >>> 0;
                    var T;
                    g < n._minpicturebytes ? T = 1 : g % n._prime1 != 0 ? T = n._prime1 : g % n._prime2 != 0 ? T = n._prime2 : g % n._prime3 != 0 ? T = n._prime3 : T = n._prime4;
                    for (var A = 0, I = 0; A < m; ) {
                      var L = this._pointArray[I], z = L.b << u, U = L.g << u, J = L.r << u, F = L.a << u, oe = this._contest(z, U, J, F);
                      if (this._alterSingle(b, oe, z, U, J, F), o !== 0 && this._alterNeighbour(o, oe, z, U, J, F), I += T, I >= g && (I -= g), A++, s === 0 && (s = 1), A % s === 0) {
                        b -= b / h | 0, S -= S / n._radiusDecrease | 0, o = S >> n._radiusBiasShift, o <= 1 && (o = 0);
                        for (var ee = 0; ee < o; ee++)
                          this._radPower[ee] = b * ((o * o - ee * ee) * n._radBias / (o * o)) >>> 0;
                      }
                    }
                  }, n.prototype._buildPalette = function() {
                    var d = new E.Palette();
                    return this._network.forEach(function(g) {
                      d.add(g.toPoint());
                    }), d.sort(), d;
                  }, n.prototype._alterNeighbour = function(d, g, h, m, s, b) {
                    var S = g - d;
                    S < -1 && (S = -1);
                    var o = g + d;
                    o > this._networkSize && (o = this._networkSize);
                    for (var A = g + 1, T = g - 1, I = 1; A < o || T > S; ) {
                      var L = this._radPower[I++] / n._alphaRadBias;
                      if (A < o) {
                        var z = this._network[A++];
                        z.subtract(L * (z.r - s), L * (z.g - m), L * (z.b - h), L * (z.a - b));
                      }
                      if (T > S) {
                        var z = this._network[T--];
                        z.subtract(L * (z.r - s), L * (z.g - m), L * (z.b - h), L * (z.a - b));
                      }
                    }
                  }, n.prototype._alterSingle = function(d, g, h, m, s, b) {
                    d /= n._initAlpha;
                    var S = this._network[g];
                    S.subtract(d * (S.r - s), d * (S.g - m), d * (S.b - h), d * (S.a - b));
                  }, n.prototype._contest = function(d, g, h, m) {
                    for (var s = 1020 << u, b = 2147483647, S = b, o = -1, A = o, T = 0; T < this._networkSize; T++) {
                      var I = this._network[T], L = this._distance.calculateNormalized(I, { r: h, g, b: d, a: m }) * s | 0;
                      L < b && (b = L, o = T);
                      var z = L - (this._bias[T] >> n._initialBiasShift - u);
                      z < S && (S = z, A = T);
                      var U = this._freq[T] >> n._betaShift;
                      this._freq[T] -= U, this._bias[T] += U << n._gammaShift;
                    }
                    return this._freq[o] += n._beta, this._bias[o] -= n._betaGamma, A;
                  }, n._prime1 = 499, n._prime2 = 491, n._prime3 = 487, n._prime4 = 503, n._minpicturebytes = n._prime4, n._nCycles = 100, n._initialBiasShift = 16, n._initialBias = 1 << n._initialBiasShift, n._gammaShift = 10, n._betaShift = 10, n._beta = n._initialBias >> n._betaShift, n._betaGamma = n._initialBias << n._gammaShift - n._betaShift, n._radiusBiasShift = 6, n._radiusBias = 1 << n._radiusBiasShift, n._radiusDecrease = 30, n._alphaBiasShift = 10, n._initAlpha = 1 << n._alphaBiasShift, n._radBiasShift = 8, n._radBias = 1 << n._radBiasShift, n._alphaRadBiasShift = n._alphaBiasShift + n._radBiasShift, n._alphaRadBias = 1 << n._alphaRadBiasShift, n;
                }();
                x.NeuQuant = a;
              },
              /* 22 */
              /***/
              function(M, x, y) {
                var E = y(23), c = y(5), u = 10;
                function l(n, d) {
                  for (var g = 360, h = g / d, m = h / 2, s = 1, b = h - m; s < d; s++, b += h)
                    if (n >= b && n < b + h)
                      return s;
                  return 0;
                }
                x.hueGroup = l;
                var a = function() {
                  function n() {
                    this._pointArray = [], this._i32idx = {}, this._pointContainer = new E.PointContainer(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
                  }
                  return n.prototype.add = function(d) {
                    this._pointArray.push(d), this._pointContainer.setWidth(this._pointArray.length);
                  }, n.prototype.has = function(d) {
                    for (var g = this._pointArray.length - 1; g >= 0; g--)
                      if (d.uint32 === this._pointArray[g].uint32)
                        return !0;
                    return !1;
                  }, n.prototype.getNearestColor = function(d, g) {
                    return this._pointArray[this.getNearestIndex(d, g) | 0];
                  }, n.prototype.getPointContainer = function() {
                    return this._pointContainer;
                  }, n.prototype._nearestPointFromCache = function(d) {
                    return typeof this._i32idx[d] == "number" ? this._i32idx[d] : -1;
                  }, n.prototype.getNearestIndex = function(d, g) {
                    var h = this._nearestPointFromCache("" + g.uint32);
                    if (h >= 0)
                      return h;
                    var m = Number.MAX_VALUE;
                    h = 0;
                    for (var s = 0, b = this._pointArray.length; s < b; s++) {
                      var S = this._pointArray[s], o = d.calculateRaw(g.r, g.g, g.b, g.a, S.r, S.g, S.b, S.a);
                      o < m && (m = o, h = s);
                    }
                    return this._i32idx[g.uint32] = h, h;
                  }, n.prototype.sort = function() {
                    this._i32idx = {}, this._pointArray.sort(function(d, g) {
                      var h = c.rgb2hsl(d.r, d.g, d.b), m = c.rgb2hsl(g.r, g.g, g.b), s = d.r === d.g && d.g === d.b ? 0 : 1 + l(h.h, u), b = g.r === g.g && g.g === g.b ? 0 : 1 + l(m.h, u), S = b - s;
                      if (S)
                        return -S;
                      var o = d.getLuminosity(!0), A = g.getLuminosity(!0);
                      if (A - o !== 0)
                        return A - o;
                      var T = (m.s * 100 | 0) - (h.s * 100 | 0);
                      return T ? -T : 0;
                    });
                  }, n;
                }();
                x.Palette = a;
              },
              /* 23 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * pointContainer.ts - part of Image Quantization Library
                 */
                var E = y(24), c = function() {
                  function u() {
                    this._width = 0, this._height = 0, this._pointArray = [];
                  }
                  return u.prototype.getWidth = function() {
                    return this._width;
                  }, u.prototype.getHeight = function() {
                    return this._height;
                  }, u.prototype.setWidth = function(l) {
                    this._width = l;
                  }, u.prototype.setHeight = function(l) {
                    this._height = l;
                  }, u.prototype.getPointArray = function() {
                    return this._pointArray;
                  }, u.prototype.clone = function() {
                    var l = new u();
                    l._width = this._width, l._height = this._height;
                    for (var a = 0, n = this._pointArray.length; a < n; a++)
                      l._pointArray[a] = E.Point.createByUint32(this._pointArray[a].uint32 | 0);
                    return l;
                  }, u.prototype.toUint32Array = function() {
                    for (var l = this._pointArray.length, a = new Uint32Array(l), n = 0; n < l; n++)
                      a[n] = this._pointArray[n].uint32;
                    return a;
                  }, u.prototype.toUint8Array = function() {
                    return new Uint8Array(this.toUint32Array().buffer);
                  }, u.fromHTMLImageElement = function(l) {
                    var a = l.naturalWidth, n = l.naturalHeight, d = document.createElement("canvas");
                    d.width = a, d.height = n;
                    var g = d.getContext("2d");
                    return g.drawImage(l, 0, 0, a, n, 0, 0, a, n), u.fromHTMLCanvasElement(d);
                  }, u.fromHTMLCanvasElement = function(l) {
                    var a = l.width, n = l.height, d = l.getContext("2d"), g = d.getImageData(0, 0, a, n);
                    return u.fromImageData(g);
                  }, u.fromNodeCanvas = function(l) {
                    return u.fromHTMLCanvasElement(l);
                  }, u.fromImageData = function(l) {
                    var a = l.width, n = l.height;
                    return u.fromCanvasPixelArray(l.data, a, n);
                  }, u.fromArray = function(l, a, n) {
                    var d = new Uint8Array(l);
                    return u.fromUint8Array(d, a, n);
                  }, u.fromCanvasPixelArray = function(l, a, n) {
                    return u.fromArray(l, a, n);
                  }, u.fromUint8Array = function(l, a, n) {
                    return u.fromUint32Array(new Uint32Array(l.buffer), a, n);
                  }, u.fromUint32Array = function(l, a, n) {
                    var d = new u();
                    d._width = a, d._height = n;
                    for (var g = 0, h = l.length; g < h; g++)
                      d._pointArray[g] = E.Point.createByUint32(l[g] | 0);
                    return d;
                  }, u;
                }();
                x.PointContainer = c;
              },
              /* 24 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * point.ts - part of Image Quantization Library
                 */
                var E = y(2), c = function() {
                  function u() {
                    this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
                  }
                  return u.createByQuadruplet = function(l) {
                    var a = new u();
                    return a.r = l[0] | 0, a.g = l[1] | 0, a.b = l[2] | 0, a.a = l[3] | 0, a._loadUINT32(), a._loadQuadruplet(), a;
                  }, u.createByRGBA = function(l, a, n, d) {
                    var g = new u();
                    return g.r = l | 0, g.g = a | 0, g.b = n | 0, g.a = d | 0, g._loadUINT32(), g._loadQuadruplet(), g;
                  }, u.createByUint32 = function(l) {
                    var a = new u();
                    return a.uint32 = l >>> 0, a._loadRGBA(), a._loadQuadruplet(), a;
                  }, u.prototype.from = function(l) {
                    this.r = l.r, this.g = l.g, this.b = l.b, this.a = l.a, this.uint32 = l.uint32, this.rgba[0] = l.r, this.rgba[1] = l.g, this.rgba[2] = l.b, this.rgba[3] = l.a;
                  }, u.prototype.getLuminosity = function(l) {
                    var a = this.r, n = this.g, d = this.b;
                    return l && (a = Math.min(255, 255 - this.a + this.a * a / 255), n = Math.min(255, 255 - this.a + this.a * n / 255), d = Math.min(255, 255 - this.a + this.a * d / 255)), a * E.Y.RED + n * E.Y.GREEN + d * E.Y.BLUE;
                  }, u.prototype._loadUINT32 = function() {
                    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
                  }, u.prototype._loadRGBA = function() {
                    this.r = this.uint32 & 255, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
                  }, u.prototype._loadQuadruplet = function() {
                    this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
                  }, u;
                }();
                x.Point = c;
              },
              /* 25 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * neuquant.ts - part of Image Quantization Library
                 */
                var E = y(22), c = y(24), u = 3, l = function() {
                  function n(d) {
                    this.r = this.g = this.b = this.a = d;
                  }
                  return n.prototype.toPoint = function() {
                    return c.Point.createByRGBA(this.r >> u, this.g >> u, this.b >> u, this.a >> u);
                  }, n.prototype.subtract = function(d, g, h, m) {
                    this.r -= d, this.g -= g, this.b -= h, this.a -= m;
                  }, n;
                }(), a = function() {
                  function n(d, g) {
                    g === void 0 && (g = 256), this._distance = d, this._pointArray = [], this._sampleFactor = 1, this._networkSize = g, this._distance.setWhitePoint(255 << u, 255 << u, 255 << u, 255 << u);
                  }
                  return n.prototype.sample = function(d) {
                    this._pointArray = this._pointArray.concat(d.getPointArray());
                  }, n.prototype.quantize = function() {
                    return this._init(), this._learn(), this._buildPalette();
                  }, n.prototype._init = function() {
                    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
                    for (var d = 0; d < this._networkSize; d++)
                      this._network[d] = new l((d << u + 8) / this._networkSize), this._freq[d] = n._initialBias / this._networkSize, this._bias[d] = 0;
                  }, n.prototype._learn = function() {
                    var d = this._sampleFactor, g = this._pointArray.length;
                    g < n._minpicturebytes && (d = 1);
                    var h = 30 + (d - 1) / 3, m = g / d, s = m / n._nCycles | 0, b = n._initAlpha, S = (this._networkSize >> 3) * n._radiusBias, o = S >> n._radiusBiasShift;
                    o <= 1 && (o = 0);
                    for (var A = 0; A < o; A++)
                      this._radPower[A] = b * ((o * o - A * A) * n._radBias / (o * o));
                    var T;
                    g < n._minpicturebytes ? T = 1 : g % n._prime1 != 0 ? T = n._prime1 : g % n._prime2 != 0 ? T = n._prime2 : g % n._prime3 != 0 ? T = n._prime3 : T = n._prime4;
                    for (var A = 0, I = 0; A < m; ) {
                      var L = this._pointArray[I], z = L.b << u, U = L.g << u, J = L.r << u, F = L.a << u, oe = this._contest(z, U, J, F);
                      if (this._alterSingle(b, oe, z, U, J, F), o != 0 && this._alterNeighbour(o, oe, z, U, J, F), I += T, I >= g && (I -= g), A++, s == 0 && (s = 1), A % s == 0) {
                        b -= b / h, S -= S / n._radiusDecrease, o = S >> n._radiusBiasShift, o <= 1 && (o = 0);
                        for (var ee = 0; ee < o; ee++)
                          this._radPower[ee] = b * ((o * o - ee * ee) * n._radBias / (o * o));
                      }
                    }
                  }, n.prototype._buildPalette = function() {
                    var d = new E.Palette();
                    return this._network.forEach(function(g) {
                      d.add(g.toPoint());
                    }), d.sort(), d;
                  }, n.prototype._alterNeighbour = function(d, g, h, m, s, b) {
                    var S = g - d;
                    S < -1 && (S = -1);
                    var o = g + d;
                    o > this._networkSize && (o = this._networkSize);
                    for (var A = g + 1, T = g - 1, I = 1; A < o || T > S; ) {
                      var L = this._radPower[I++] / n._alphaRadBias;
                      if (A < o) {
                        var z = this._network[A++];
                        z.subtract(L * (z.r - s), L * (z.g - m), L * (z.b - h), L * (z.a - b));
                      }
                      if (T > S) {
                        var z = this._network[T--];
                        z.subtract(L * (z.r - s), L * (z.g - m), L * (z.b - h), L * (z.a - b));
                      }
                    }
                  }, n.prototype._alterSingle = function(d, g, h, m, s, b) {
                    d /= n._initAlpha;
                    var S = this._network[g];
                    S.subtract(d * (S.r - s), d * (S.g - m), d * (S.b - h), d * (S.a - b));
                  }, n.prototype._contest = function(d, g, h, m) {
                    for (var s = 1020 << u, b = 2147483647, S = b, o = -1, A = o, T = 0; T < this._networkSize; T++) {
                      var I = this._network[T], L = this._distance.calculateNormalized(I, { r: h, g, b: d, a: m }) * s;
                      L < b && (b = L, o = T);
                      var z = L - (this._bias[T] >> n._initialBiasShift - u);
                      z < S && (S = z, A = T);
                      var U = this._freq[T] >> n._betaShift;
                      this._freq[T] -= U, this._bias[T] += U << n._gammaShift;
                    }
                    return this._freq[o] += n._beta, this._bias[o] -= n._betaGamma, A;
                  }, n._prime1 = 499, n._prime2 = 491, n._prime3 = 487, n._prime4 = 503, n._minpicturebytes = n._prime4, n._nCycles = 100, n._initialBiasShift = 16, n._initialBias = 1 << n._initialBiasShift, n._gammaShift = 10, n._betaShift = 10, n._beta = n._initialBias >> n._betaShift, n._betaGamma = n._initialBias << n._gammaShift - n._betaShift, n._radiusBiasShift = 6, n._radiusBias = 1 << n._radiusBiasShift, n._radiusDecrease = 30, n._alphaBiasShift = 10, n._initAlpha = 1 << n._alphaBiasShift, n._radBiasShift = 8, n._radBias = 1 << n._radBiasShift, n._alphaRadBiasShift = n._alphaBiasShift + n._radBiasShift, n._alphaRadBias = 1 << n._alphaRadBiasShift, n;
                }();
                x.NeuQuantFloat = a;
              },
              /* 26 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgbquant.ts - part of Image Quantization Library
                 */
                var E = y(22), c = y(24), u = y(27), l = y(6), a = /* @__PURE__ */ function() {
                  function d(g, h, m) {
                    this.index = g, this.color = h, this.distance = m;
                  }
                  return d;
                }(), n = function() {
                  function d(g, h, m) {
                    h === void 0 && (h = 256), m === void 0 && (m = 2), this._distance = g, this._colors = h, this._histogram = new u.ColorHistogram(m, h), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
                  }
                  return d.prototype.sample = function(g) {
                    this._histogram.sample(g);
                  }, d.prototype.quantize = function() {
                    var g = this._histogram.getImportanceSortedColorsIDXI32();
                    if (g.length === 0)
                      throw new Error("No colors in image");
                    var h = this._buildPalette(g);
                    return h.sort(), h;
                  }, d.prototype._buildPalette = function(g) {
                    for (var h = new E.Palette(), m = h.getPointContainer().getPointArray(), s = new Array(g.length), b = 0; b < g.length; b++)
                      m.push(c.Point.createByUint32(g[b])), s[b] = 1;
                    for (var S = m.length, o = [], A = S, T = this._initialDistance; A > this._colors; ) {
                      o.length = 0;
                      for (var b = 0; b < S; b++)
                        if (s[b] !== 0) {
                          for (var I = m[b], L = b + 1; L < S; L++)
                            if (s[L] !== 0) {
                              var z = m[L], U = this._distance.calculateNormalized(I, z);
                              U < T && (o.push(new a(L, z, U)), s[L] = 0, A--);
                            }
                        }
                      T += A > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
                    }
                    if (A < this._colors) {
                      l.stableSort(o, function(ie, W) {
                        return W.distance - ie.distance;
                      });
                      for (var J = 0; A < this._colors && J < o.length; ) {
                        var F = o[J];
                        s[F.index] = 1, A++, J++;
                      }
                    }
                    for (var oe = m.length, ee = oe - 1; ee >= 0; ee--)
                      s[ee] === 0 && (ee !== oe - 1 && (m[ee] = m[oe - 1]), --oe);
                    return m.length = oe, h;
                  }, d;
                }();
                x.RGBQuant = n;
              },
              /* 27 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * colorHistogram.ts - part of Image Quantization Library
                 */
                var E = y(28), c = y(6), u = function() {
                  function l(a, n) {
                    this._method = a, this._minHueCols = n << 2, this._initColors = n << 2, this._hueStats = new E.HueStatistics(l._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
                  }
                  return l.prototype.sample = function(a) {
                    switch (this._method) {
                      case 1:
                        this._colorStats1D(a);
                        break;
                      case 2:
                        this._colorStats2D(a);
                        break;
                    }
                  }, l.prototype.getImportanceSortedColorsIDXI32 = function() {
                    var a = this, n = c.stableSort(Object.keys(this._histogram), function(S, o) {
                      return a._histogram[o] - a._histogram[S];
                    });
                    if (n.length === 0)
                      return [];
                    var d;
                    switch (this._method) {
                      case 1:
                        var g = Math.min(n.length, this._initColors), h = n[g - 1], m = this._histogram[h];
                        d = n.slice(0, g);
                        for (var s = g, b = n.length; s < b && this._histogram[n[s]] == m; )
                          d.push(n[s++]);
                        this._hueStats.injectIntoArray(d);
                        break;
                      case 2:
                        d = n;
                        break;
                      default:
                        throw new Error("Incorrect method");
                    }
                    return d.map(function(S) {
                      return +S;
                    });
                  }, l.prototype._colorStats1D = function(a) {
                    for (var n = this._histogram, d = a.getPointArray(), g = d.length, h = 0; h < g; h++) {
                      var m = d[h].uint32;
                      this._hueStats.check(m), m in n ? n[m]++ : n[m] = 1;
                    }
                  }, l.prototype._colorStats2D = function(a) {
                    var n = this, d = a.getWidth(), g = a.getHeight(), h = a.getPointArray(), m = l._boxSize[0], s = l._boxSize[1], b = m * s, S = this._makeBoxes(d, g, m, s), o = this._histogram;
                    S.forEach(function(A) {
                      var T = Math.round(A.w * A.h / b) * l._boxPixels;
                      T < 2 && (T = 2);
                      var I = {};
                      n._iterateBox(A, d, function(L) {
                        var z = h[L].uint32;
                        n._hueStats.check(z), z in o ? o[z]++ : z in I ? ++I[z] >= T && (o[z] = I[z]) : I[z] = 1;
                      });
                    }), this._hueStats.injectIntoDictionary(o);
                  }, l.prototype._iterateBox = function(a, n, d) {
                    var g = a, h = g.y * n + g.x, m = (g.y + g.h - 1) * n + (g.x + g.w - 1), s = n - g.w + 1, b = 0, S = h;
                    do
                      d.call(this, S), S += ++b % g.w == 0 ? s : 1;
                    while (S <= m);
                  }, l.prototype._makeBoxes = function(a, n, d, g) {
                    for (var h = a % d, m = n % g, s = a - h, b = n - m, S = [], o = 0; o < n; o += g)
                      for (var A = 0; A < a; A += d)
                        S.push({ x: A, y: o, w: A == s ? h : d, h: o == b ? m : g });
                    return S;
                  }, l._boxSize = [64, 64], l._boxPixels = 2, l._hueGroups = 10, l;
                }();
                x.ColorHistogram = u;
              },
              /* 28 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * hueStatistics.ts - part of Image Quantization Library
                 */
                var E = y(5), c = y(22), u = /* @__PURE__ */ function() {
                  function a() {
                    this.num = 0, this.cols = [];
                  }
                  return a;
                }(), l = function() {
                  function a(n, d) {
                    this._numGroups = n, this._minCols = d, this._stats = [];
                    for (var g = 0; g <= n; g++)
                      this._stats[g] = new u();
                    this._groupsFull = 0;
                  }
                  return a.prototype.check = function(n) {
                    this._groupsFull == this._numGroups + 1 && (this.check = function() {
                    });
                    var d = n & 255, g = n >>> 8 & 255, h = n >>> 16 & 255, m = d == g && g == h ? 0 : 1 + c.hueGroup(E.rgb2hsl(d, g, h).h, this._numGroups), s = this._stats[m], b = this._minCols;
                    s.num++, !(s.num > b) && (s.num == b && this._groupsFull++, s.num <= b && this._stats[m].cols.push(n));
                  }, a.prototype.injectIntoDictionary = function(n) {
                    for (var d = 0; d <= this._numGroups; d++)
                      this._stats[d].num <= this._minCols && this._stats[d].cols.forEach(function(g) {
                        n[g] ? n[g]++ : n[g] = 1;
                      });
                  }, a.prototype.injectIntoArray = function(n) {
                    for (var d = 0; d <= this._numGroups; d++)
                      this._stats[d].num <= this._minCols && this._stats[d].cols.forEach(function(g) {
                        n.indexOf(g) == -1 && n.push(g);
                      });
                  }, a;
                }();
                x.HueStatistics = l;
              },
              /* 29 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * wuQuant.ts - part of Image Quantization Library
                 */
                var E = y(22), c = y(24);
                function u(m) {
                  for (var s = [], b = 0; b < m; b++)
                    s[b] = 0;
                  return s;
                }
                function l(m, s, b, S) {
                  for (var o = new Array(m), A = 0; A < m; A++) {
                    o[A] = new Array(s);
                    for (var T = 0; T < s; T++) {
                      o[A][T] = new Array(b);
                      for (var I = 0; I < b; I++) {
                        o[A][T][I] = new Array(S);
                        for (var L = 0; L < S; L++)
                          o[A][T][I][L] = 0;
                      }
                    }
                  }
                  return o;
                }
                function a(m, s, b) {
                  for (var S = new Array(m), o = 0; o < m; o++) {
                    S[o] = new Array(s);
                    for (var A = 0; A < s; A++) {
                      S[o][A] = new Array(b);
                      for (var T = 0; T < b; T++)
                        S[o][A][T] = 0;
                    }
                  }
                  return S;
                }
                function n(m, s, b, S, o) {
                  for (var A = 0; A < s; A++) {
                    m[A] = [];
                    for (var T = 0; T < b; T++) {
                      m[A][T] = [];
                      for (var I = 0; I < S; I++)
                        m[A][T][I] = o;
                    }
                  }
                }
                function d(m, s, b) {
                  for (var S = 0; S < s; S++)
                    m[S] = b;
                }
                var g = /* @__PURE__ */ function() {
                  function m() {
                  }
                  return m;
                }();
                x.WuColorCube = g;
                var h = function() {
                  function m(s, b, S) {
                    b === void 0 && (b = 256), S === void 0 && (S = 5), this._distance = s, this._setQuality(S), this._initialize(b);
                  }
                  return m.prototype.sample = function(s) {
                    for (var b = s.getPointArray(), S = 0, o = b.length; S < o; S++)
                      this._addColor(b[S]);
                    this._pixels = this._pixels.concat(b);
                  }, m.prototype.quantize = function() {
                    this._preparePalette();
                    for (var s = new E.Palette(), b = 0; b < this._colors; b++)
                      if (this._sums[b] > 0) {
                        var S = this._sums[b], o = this._reds[b] / S, A = this._greens[b] / S, T = this._blues[b] / S, I = this._alphas[b] / S, L = c.Point.createByRGBA(o | 0, A | 0, T | 0, I | 0);
                        s.add(L);
                      }
                    return s.sort(), s;
                  }, m.prototype._preparePalette = function() {
                    this._calculateMoments();
                    for (var s = 0, b = u(this._colors), S = 1; S < this._colors; ++S) {
                      this._cut(this._cubes[s], this._cubes[S]) ? (b[s] = this._cubes[s].volume > 1 ? this._calculateVariance(this._cubes[s]) : 0, b[S] = this._cubes[S].volume > 1 ? this._calculateVariance(this._cubes[S]) : 0) : (b[s] = 0, S--), s = 0;
                      for (var o = b[0], A = 1; A <= S; ++A)
                        b[A] > o && (o = b[A], s = A);
                      if (o <= 0) {
                        this._colors = S + 1;
                        break;
                      }
                    }
                    for (var T = [], I = [], L = [], z = [], U = 0; U < this._colors; ++U) {
                      var J = m._volume(this._cubes[U], this._weights);
                      J > 0 ? (T[U] = m._volume(this._cubes[U], this._momentsRed) / J | 0, I[U] = m._volume(this._cubes[U], this._momentsGreen) / J | 0, L[U] = m._volume(this._cubes[U], this._momentsBlue) / J | 0, z[U] = m._volume(this._cubes[U], this._momentsAlpha) / J | 0) : (T[U] = 0, I[U] = 0, L[U] = 0, z[U] = 0);
                    }
                    this._reds = u(this._colors + 1), this._greens = u(this._colors + 1), this._blues = u(this._colors + 1), this._alphas = u(this._colors + 1), this._sums = u(this._colors + 1);
                    for (var A = 0, F = this._pixels.length; A < F; A++) {
                      for (var oe = this._pixels[A], ee = -1, ie = ee, W = Number.MAX_VALUE, Q = 0; Q < this._colors; Q++) {
                        var de = T[Q], we = I[Q], ke = L[Q], Me = z[Q], fe = this._distance.calculateRaw(de, we, ke, Me, oe.r, oe.g, oe.b, oe.a);
                        fe < W && (W = fe, ie = Q);
                      }
                      this._reds[ie] += oe.r, this._greens[ie] += oe.g, this._blues[ie] += oe.b, this._alphas[ie] += oe.a, this._sums[ie]++;
                    }
                  }, m.prototype._addColor = function(s) {
                    var b = 8 - this._significantBitsPerChannel, S = (s.r >> b) + 1, o = (s.g >> b) + 1, A = (s.b >> b) + 1, T = (s.a >> b) + 1;
                    this._weights[T][S][o][A]++, this._momentsRed[T][S][o][A] += s.r, this._momentsGreen[T][S][o][A] += s.g, this._momentsBlue[T][S][o][A] += s.b, this._momentsAlpha[T][S][o][A] += s.a, this._moments[T][S][o][A] += this._table[s.r] + this._table[s.g] + this._table[s.b] + this._table[s.a];
                  }, m.prototype._calculateMoments = function() {
                    for (var s = [], b = [], S = [], o = [], A = [], T = [], I = a(this._sideSize, this._sideSize, this._sideSize), L = a(this._sideSize, this._sideSize, this._sideSize), z = a(this._sideSize, this._sideSize, this._sideSize), U = a(this._sideSize, this._sideSize, this._sideSize), J = a(this._sideSize, this._sideSize, this._sideSize), F = a(this._sideSize, this._sideSize, this._sideSize), oe = 1; oe <= this._alphaMaxSideIndex; ++oe) {
                      n(I, this._sideSize, this._sideSize, this._sideSize, 0), n(L, this._sideSize, this._sideSize, this._sideSize, 0), n(z, this._sideSize, this._sideSize, this._sideSize, 0), n(U, this._sideSize, this._sideSize, this._sideSize, 0), n(J, this._sideSize, this._sideSize, this._sideSize, 0), n(F, this._sideSize, this._sideSize, this._sideSize, 0);
                      for (var ee = 1; ee <= this._maxSideIndex; ++ee) {
                        d(s, this._sideSize, 0), d(b, this._sideSize, 0), d(S, this._sideSize, 0), d(o, this._sideSize, 0), d(A, this._sideSize, 0), d(T, this._sideSize, 0);
                        for (var ie = 1; ie <= this._maxSideIndex; ++ie)
                          for (var W = 0, Q = 0, de = 0, we = 0, ke = 0, Me = 0, fe = 1; fe <= this._maxSideIndex; ++fe)
                            W += this._weights[oe][ee][ie][fe], Q += this._momentsRed[oe][ee][ie][fe], de += this._momentsGreen[oe][ee][ie][fe], we += this._momentsBlue[oe][ee][ie][fe], ke += this._momentsAlpha[oe][ee][ie][fe], Me += this._moments[oe][ee][ie][fe], s[fe] += W, b[fe] += Q, S[fe] += de, o[fe] += we, A[fe] += ke, T[fe] += Me, I[ee][ie][fe] = I[ee - 1][ie][fe] + s[fe], L[ee][ie][fe] = L[ee - 1][ie][fe] + b[fe], z[ee][ie][fe] = z[ee - 1][ie][fe] + S[fe], U[ee][ie][fe] = U[ee - 1][ie][fe] + o[fe], J[ee][ie][fe] = J[ee - 1][ie][fe] + A[fe], F[ee][ie][fe] = F[ee - 1][ie][fe] + T[fe], this._weights[oe][ee][ie][fe] = this._weights[oe - 1][ee][ie][fe] + I[ee][ie][fe], this._momentsRed[oe][ee][ie][fe] = this._momentsRed[oe - 1][ee][ie][fe] + L[ee][ie][fe], this._momentsGreen[oe][ee][ie][fe] = this._momentsGreen[oe - 1][ee][ie][fe] + z[ee][ie][fe], this._momentsBlue[oe][ee][ie][fe] = this._momentsBlue[oe - 1][ee][ie][fe] + U[ee][ie][fe], this._momentsAlpha[oe][ee][ie][fe] = this._momentsAlpha[oe - 1][ee][ie][fe] + J[ee][ie][fe], this._moments[oe][ee][ie][fe] = this._moments[oe - 1][ee][ie][fe] + F[ee][ie][fe];
                      }
                    }
                  }, m._volumeFloat = function(s, b) {
                    return b[s.alphaMaximum][s.redMaximum][s.greenMaximum][s.blueMaximum] - b[s.alphaMaximum][s.redMaximum][s.greenMinimum][s.blueMaximum] - b[s.alphaMaximum][s.redMinimum][s.greenMaximum][s.blueMaximum] + b[s.alphaMaximum][s.redMinimum][s.greenMinimum][s.blueMaximum] - b[s.alphaMinimum][s.redMaximum][s.greenMaximum][s.blueMaximum] + b[s.alphaMinimum][s.redMaximum][s.greenMinimum][s.blueMaximum] + b[s.alphaMinimum][s.redMinimum][s.greenMaximum][s.blueMaximum] - b[s.alphaMinimum][s.redMinimum][s.greenMinimum][s.blueMaximum] - (b[s.alphaMaximum][s.redMaximum][s.greenMaximum][s.blueMinimum] - b[s.alphaMinimum][s.redMaximum][s.greenMaximum][s.blueMinimum] - b[s.alphaMaximum][s.redMaximum][s.greenMinimum][s.blueMinimum] + b[s.alphaMinimum][s.redMaximum][s.greenMinimum][s.blueMinimum] - b[s.alphaMaximum][s.redMinimum][s.greenMaximum][s.blueMinimum] + b[s.alphaMinimum][s.redMinimum][s.greenMaximum][s.blueMinimum] + b[s.alphaMaximum][s.redMinimum][s.greenMinimum][s.blueMinimum] - b[s.alphaMinimum][s.redMinimum][s.greenMinimum][s.blueMinimum]);
                  }, m._volume = function(s, b) {
                    return m._volumeFloat(s, b) | 0;
                  }, m._top = function(s, b, S, o) {
                    var A;
                    switch (b) {
                      case m.alpha:
                        A = o[S][s.redMaximum][s.greenMaximum][s.blueMaximum] - o[S][s.redMaximum][s.greenMinimum][s.blueMaximum] - o[S][s.redMinimum][s.greenMaximum][s.blueMaximum] + o[S][s.redMinimum][s.greenMinimum][s.blueMaximum] - (o[S][s.redMaximum][s.greenMaximum][s.blueMinimum] - o[S][s.redMaximum][s.greenMinimum][s.blueMinimum] - o[S][s.redMinimum][s.greenMaximum][s.blueMinimum] + o[S][s.redMinimum][s.greenMinimum][s.blueMinimum]);
                        break;
                      case m.red:
                        A = o[s.alphaMaximum][S][s.greenMaximum][s.blueMaximum] - o[s.alphaMaximum][S][s.greenMinimum][s.blueMaximum] - o[s.alphaMinimum][S][s.greenMaximum][s.blueMaximum] + o[s.alphaMinimum][S][s.greenMinimum][s.blueMaximum] - (o[s.alphaMaximum][S][s.greenMaximum][s.blueMinimum] - o[s.alphaMaximum][S][s.greenMinimum][s.blueMinimum] - o[s.alphaMinimum][S][s.greenMaximum][s.blueMinimum] + o[s.alphaMinimum][S][s.greenMinimum][s.blueMinimum]);
                        break;
                      case m.green:
                        A = o[s.alphaMaximum][s.redMaximum][S][s.blueMaximum] - o[s.alphaMaximum][s.redMinimum][S][s.blueMaximum] - o[s.alphaMinimum][s.redMaximum][S][s.blueMaximum] + o[s.alphaMinimum][s.redMinimum][S][s.blueMaximum] - (o[s.alphaMaximum][s.redMaximum][S][s.blueMinimum] - o[s.alphaMaximum][s.redMinimum][S][s.blueMinimum] - o[s.alphaMinimum][s.redMaximum][S][s.blueMinimum] + o[s.alphaMinimum][s.redMinimum][S][s.blueMinimum]);
                        break;
                      case m.blue:
                        A = o[s.alphaMaximum][s.redMaximum][s.greenMaximum][S] - o[s.alphaMaximum][s.redMaximum][s.greenMinimum][S] - o[s.alphaMaximum][s.redMinimum][s.greenMaximum][S] + o[s.alphaMaximum][s.redMinimum][s.greenMinimum][S] - (o[s.alphaMinimum][s.redMaximum][s.greenMaximum][S] - o[s.alphaMinimum][s.redMaximum][s.greenMinimum][S] - o[s.alphaMinimum][s.redMinimum][s.greenMaximum][S] + o[s.alphaMinimum][s.redMinimum][s.greenMinimum][S]);
                        break;
                      default:
                        throw new Error("impossible");
                    }
                    return A | 0;
                  }, m._bottom = function(s, b, S) {
                    switch (b) {
                      case m.alpha:
                        return -S[s.alphaMinimum][s.redMaximum][s.greenMaximum][s.blueMaximum] + S[s.alphaMinimum][s.redMaximum][s.greenMinimum][s.blueMaximum] + S[s.alphaMinimum][s.redMinimum][s.greenMaximum][s.blueMaximum] - S[s.alphaMinimum][s.redMinimum][s.greenMinimum][s.blueMaximum] - (-S[s.alphaMinimum][s.redMaximum][s.greenMaximum][s.blueMinimum] + S[s.alphaMinimum][s.redMaximum][s.greenMinimum][s.blueMinimum] + S[s.alphaMinimum][s.redMinimum][s.greenMaximum][s.blueMinimum] - S[s.alphaMinimum][s.redMinimum][s.greenMinimum][s.blueMinimum]);
                      case m.red:
                        return -S[s.alphaMaximum][s.redMinimum][s.greenMaximum][s.blueMaximum] + S[s.alphaMaximum][s.redMinimum][s.greenMinimum][s.blueMaximum] + S[s.alphaMinimum][s.redMinimum][s.greenMaximum][s.blueMaximum] - S[s.alphaMinimum][s.redMinimum][s.greenMinimum][s.blueMaximum] - (-S[s.alphaMaximum][s.redMinimum][s.greenMaximum][s.blueMinimum] + S[s.alphaMaximum][s.redMinimum][s.greenMinimum][s.blueMinimum] + S[s.alphaMinimum][s.redMinimum][s.greenMaximum][s.blueMinimum] - S[s.alphaMinimum][s.redMinimum][s.greenMinimum][s.blueMinimum]);
                      case m.green:
                        return -S[s.alphaMaximum][s.redMaximum][s.greenMinimum][s.blueMaximum] + S[s.alphaMaximum][s.redMinimum][s.greenMinimum][s.blueMaximum] + S[s.alphaMinimum][s.redMaximum][s.greenMinimum][s.blueMaximum] - S[s.alphaMinimum][s.redMinimum][s.greenMinimum][s.blueMaximum] - (-S[s.alphaMaximum][s.redMaximum][s.greenMinimum][s.blueMinimum] + S[s.alphaMaximum][s.redMinimum][s.greenMinimum][s.blueMinimum] + S[s.alphaMinimum][s.redMaximum][s.greenMinimum][s.blueMinimum] - S[s.alphaMinimum][s.redMinimum][s.greenMinimum][s.blueMinimum]);
                      case m.blue:
                        return -S[s.alphaMaximum][s.redMaximum][s.greenMaximum][s.blueMinimum] + S[s.alphaMaximum][s.redMaximum][s.greenMinimum][s.blueMinimum] + S[s.alphaMaximum][s.redMinimum][s.greenMaximum][s.blueMinimum] - S[s.alphaMaximum][s.redMinimum][s.greenMinimum][s.blueMinimum] - (-S[s.alphaMinimum][s.redMaximum][s.greenMaximum][s.blueMinimum] + S[s.alphaMinimum][s.redMaximum][s.greenMinimum][s.blueMinimum] + S[s.alphaMinimum][s.redMinimum][s.greenMaximum][s.blueMinimum] - S[s.alphaMinimum][s.redMinimum][s.greenMinimum][s.blueMinimum]);
                      default:
                        return 0;
                    }
                  }, m.prototype._calculateVariance = function(s) {
                    var b = m._volume(s, this._momentsRed), S = m._volume(s, this._momentsGreen), o = m._volume(s, this._momentsBlue), A = m._volume(s, this._momentsAlpha), T = m._volumeFloat(s, this._moments), I = m._volume(s, this._weights), L = b * b + S * S + o * o + A * A;
                    return T - L / I;
                  }, m.prototype._maximize = function(s, b, S, o, A, T, I, L, z) {
                    for (var U = m._bottom(s, b, this._momentsRed) | 0, J = m._bottom(s, b, this._momentsGreen) | 0, F = m._bottom(s, b, this._momentsBlue) | 0, oe = m._bottom(s, b, this._momentsAlpha) | 0, ee = m._bottom(s, b, this._weights) | 0, ie = 0, W = -1, Q = S; Q < o; ++Q) {
                      var de = U + m._top(s, b, Q, this._momentsRed), we = J + m._top(s, b, Q, this._momentsGreen), ke = F + m._top(s, b, Q, this._momentsBlue), Me = oe + m._top(s, b, Q, this._momentsAlpha), fe = ee + m._top(s, b, Q, this._weights);
                      if (fe != 0) {
                        var xe = de * de + we * we + ke * ke + Me * Me, Ee = xe / fe;
                        de = A - de, we = T - we, ke = I - ke, Me = L - Me, fe = z - fe, fe != 0 && (xe = de * de + we * we + ke * ke + Me * Me, Ee += xe / fe, Ee > ie && (ie = Ee, W = Q));
                      }
                    }
                    return { max: ie, position: W };
                  }, m.prototype._cut = function(s, b) {
                    var S, o = m._volume(s, this._momentsRed), A = m._volume(s, this._momentsGreen), T = m._volume(s, this._momentsBlue), I = m._volume(s, this._momentsAlpha), L = m._volume(s, this._weights), z = this._maximize(s, m.red, s.redMinimum + 1, s.redMaximum, o, A, T, I, L), U = this._maximize(s, m.green, s.greenMinimum + 1, s.greenMaximum, o, A, T, I, L), J = this._maximize(s, m.blue, s.blueMinimum + 1, s.blueMaximum, o, A, T, I, L), F = this._maximize(s, m.alpha, s.alphaMinimum + 1, s.alphaMaximum, o, A, T, I, L);
                    if (F.max >= z.max && F.max >= U.max && F.max >= J.max) {
                      if (S = m.alpha, F.position < 0)
                        return !1;
                    } else
                      z.max >= F.max && z.max >= U.max && z.max >= J.max ? S = m.red : U.max >= F.max && U.max >= z.max && U.max >= J.max ? S = m.green : S = m.blue;
                    switch (b.redMaximum = s.redMaximum, b.greenMaximum = s.greenMaximum, b.blueMaximum = s.blueMaximum, b.alphaMaximum = s.alphaMaximum, S) {
                      case m.red:
                        b.redMinimum = s.redMaximum = z.position, b.greenMinimum = s.greenMinimum, b.blueMinimum = s.blueMinimum, b.alphaMinimum = s.alphaMinimum;
                        break;
                      case m.green:
                        b.greenMinimum = s.greenMaximum = U.position, b.redMinimum = s.redMinimum, b.blueMinimum = s.blueMinimum, b.alphaMinimum = s.alphaMinimum;
                        break;
                      case m.blue:
                        b.blueMinimum = s.blueMaximum = J.position, b.redMinimum = s.redMinimum, b.greenMinimum = s.greenMinimum, b.alphaMinimum = s.alphaMinimum;
                        break;
                      case m.alpha:
                        b.alphaMinimum = s.alphaMaximum = F.position, b.blueMinimum = s.blueMinimum, b.redMinimum = s.redMinimum, b.greenMinimum = s.greenMinimum;
                        break;
                    }
                    return s.volume = (s.redMaximum - s.redMinimum) * (s.greenMaximum - s.greenMinimum) * (s.blueMaximum - s.blueMinimum) * (s.alphaMaximum - s.alphaMinimum), b.volume = (b.redMaximum - b.redMinimum) * (b.greenMaximum - b.greenMinimum) * (b.blueMaximum - b.blueMinimum) * (b.alphaMaximum - b.alphaMinimum), !0;
                  }, m.prototype._initialize = function(s) {
                    this._colors = s, this._cubes = [];
                    for (var b = 0; b < s; b++)
                      this._cubes[b] = new g();
                    this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = l(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = l(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = l(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = l(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = l(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = l(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
                    for (var S = 0; S < 256; ++S)
                      this._table[S] = S * S;
                    this._pixels = [];
                  }, m.prototype._setQuality = function(s) {
                    s === void 0 && (s = 5), this._significantBitsPerChannel = s, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
                  }, m.alpha = 3, m.red = 2, m.green = 1, m.blue = 0, m;
                }();
                x.WuQuant = h;
              },
              /* 30 */
              /***/
              function(M, x, y) {
                var E = y(31);
                x.NearestColor = E.NearestColor;
                var c = y(32);
                x.ErrorDiffusionArray = c.ErrorDiffusionArray, x.ErrorDiffusionArrayKernel = c.ErrorDiffusionArrayKernel;
                var u = y(33);
                x.ErrorDiffusionRiemersma = u.ErrorDiffusionRiemersma;
              },
              /* 31 */
              /***/
              function(M, x) {
                var y = function() {
                  function E(c) {
                    this._distance = c;
                  }
                  return E.prototype.quantize = function(c, u) {
                    for (var l = c.getPointArray(), a = c.getWidth(), n = c.getHeight(), d = 0; d < n; d++)
                      for (var g = 0, h = d * a; g < a; g++, h++) {
                        var m = l[h];
                        m.from(u.getNearestColor(this._distance, m));
                      }
                    return c;
                  }, E;
                }();
                x.NearestColor = y;
              },
              /* 32 */
              /***/
              function(M, x, y) {
                var E = y(24), c = y(6);
                (function(a) {
                  a[a.FloydSteinberg = 0] = "FloydSteinberg", a[a.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", a[a.Stucki = 2] = "Stucki", a[a.Atkinson = 3] = "Atkinson", a[a.Jarvis = 4] = "Jarvis", a[a.Burkes = 5] = "Burkes", a[a.Sierra = 6] = "Sierra", a[a.TwoSierra = 7] = "TwoSierra", a[a.SierraLite = 8] = "SierraLite";
                })(x.ErrorDiffusionArrayKernel || (x.ErrorDiffusionArrayKernel = {}));
                var u = x.ErrorDiffusionArrayKernel, l = function() {
                  function a(n, d, g, h, m) {
                    g === void 0 && (g = !0), h === void 0 && (h = 0), m === void 0 && (m = !1), this._setKernel(d), this._distance = n, this._minColorDistance = h, this._serpentine = g, this._calculateErrorLikeGIMP = m;
                  }
                  return a.prototype.quantize = function(n, d) {
                    for (var g = n.getPointArray(), h = new E.Point(), m = n.getWidth(), s = n.getHeight(), b = [], S = 1, o = 1, A = 0; A < this._kernel.length; A++) {
                      var T = this._kernel[A][2] + 1;
                      o < T && (o = T);
                    }
                    for (var A = 0; A < o; A++)
                      this._fillErrorLine(b[A] = [], m);
                    for (var I = 0; I < s; I++) {
                      this._serpentine && (S = S * -1);
                      var L = I * m, z = S == 1 ? 0 : m - 1, U = S == 1 ? m : -1;
                      this._fillErrorLine(b[0], m), b.push(b.shift());
                      for (var J = b[0], F = z, oe = L + z; F !== U; F += S, oe += S) {
                        var ee = g[oe], ie = J[F];
                        h.from(ee);
                        var W = E.Point.createByRGBA(c.inRange0to255Rounded(ee.r + ie[0]), c.inRange0to255Rounded(ee.g + ie[1]), c.inRange0to255Rounded(ee.b + ie[2]), c.inRange0to255Rounded(ee.a + ie[3])), Q = d.getNearestColor(this._distance, W);
                        if (ee.from(Q), this._minColorDistance) {
                          var de = this._distance.calculateNormalized(ee, Q);
                          if (de < this._minColorDistance)
                            continue;
                        }
                        var we = void 0, ke = void 0, Me = void 0, fe = void 0;
                        this._calculateErrorLikeGIMP ? (we = W.r - Q.r, ke = W.g - Q.g, Me = W.b - Q.b, fe = W.a - Q.a) : (we = h.r - Q.r, ke = h.g - Q.g, Me = h.b - Q.b, fe = h.a - Q.a);
                        for (var xe = S == 1 ? 0 : this._kernel.length - 1, Ee = S == 1 ? this._kernel.length : -1, A = xe; A !== Ee; A += S) {
                          var Pe = this._kernel[A][1] * S, Ue = this._kernel[A][2];
                          if (Pe + F >= 0 && Pe + F < m && Ue + I >= 0 && Ue + I < s) {
                            var He = this._kernel[A][0], We = b[Ue][Pe + F];
                            We[0] = We[0] + we * He, We[1] = We[1] + ke * He, We[2] = We[2] + Me * He, We[3] = We[3] + fe * He;
                          }
                        }
                      }
                    }
                    return n;
                  }, a.prototype._fillErrorLine = function(n, d) {
                    n.length > d && (n.length = d);
                    for (var g = n.length, h = 0; h < g; h++) {
                      var m = n[h];
                      m[0] = m[1] = m[2] = m[3] = 0;
                    }
                    for (var h = g; h < d; h++)
                      n[h] = [0, 0, 0, 0];
                  }, a.prototype._setKernel = function(n) {
                    switch (n) {
                      case u.FloydSteinberg:
                        this._kernel = [
                          [7 / 16, 1, 0],
                          [3 / 16, -1, 1],
                          [5 / 16, 0, 1],
                          [1 / 16, 1, 1]
                        ];
                        break;
                      case u.FalseFloydSteinberg:
                        this._kernel = [
                          [3 / 8, 1, 0],
                          [3 / 8, 0, 1],
                          [2 / 8, 1, 1]
                        ];
                        break;
                      case u.Stucki:
                        this._kernel = [
                          [8 / 42, 1, 0],
                          [4 / 42, 2, 0],
                          [2 / 42, -2, 1],
                          [4 / 42, -1, 1],
                          [8 / 42, 0, 1],
                          [4 / 42, 1, 1],
                          [2 / 42, 2, 1],
                          [1 / 42, -2, 2],
                          [2 / 42, -1, 2],
                          [4 / 42, 0, 2],
                          [2 / 42, 1, 2],
                          [1 / 42, 2, 2]
                        ];
                        break;
                      case u.Atkinson:
                        this._kernel = [
                          [1 / 8, 1, 0],
                          [1 / 8, 2, 0],
                          [1 / 8, -1, 1],
                          [1 / 8, 0, 1],
                          [1 / 8, 1, 1],
                          [1 / 8, 0, 2]
                        ];
                        break;
                      case u.Jarvis:
                        this._kernel = [
                          [7 / 48, 1, 0],
                          [5 / 48, 2, 0],
                          [3 / 48, -2, 1],
                          [5 / 48, -1, 1],
                          [7 / 48, 0, 1],
                          [5 / 48, 1, 1],
                          [3 / 48, 2, 1],
                          [1 / 48, -2, 2],
                          [3 / 48, -1, 2],
                          [5 / 48, 0, 2],
                          [3 / 48, 1, 2],
                          [1 / 48, 2, 2]
                        ];
                        break;
                      case u.Burkes:
                        this._kernel = [
                          [8 / 32, 1, 0],
                          [4 / 32, 2, 0],
                          [2 / 32, -2, 1],
                          [4 / 32, -1, 1],
                          [8 / 32, 0, 1],
                          [4 / 32, 1, 1],
                          [2 / 32, 2, 1]
                        ];
                        break;
                      case u.Sierra:
                        this._kernel = [
                          [5 / 32, 1, 0],
                          [3 / 32, 2, 0],
                          [2 / 32, -2, 1],
                          [4 / 32, -1, 1],
                          [5 / 32, 0, 1],
                          [4 / 32, 1, 1],
                          [2 / 32, 2, 1],
                          [2 / 32, -1, 2],
                          [3 / 32, 0, 2],
                          [2 / 32, 1, 2]
                        ];
                        break;
                      case u.TwoSierra:
                        this._kernel = [
                          [4 / 16, 1, 0],
                          [3 / 16, 2, 0],
                          [1 / 16, -2, 1],
                          [2 / 16, -1, 1],
                          [3 / 16, 0, 1],
                          [2 / 16, 1, 1],
                          [1 / 16, 2, 1]
                        ];
                        break;
                      case u.SierraLite:
                        this._kernel = [
                          [2 / 4, 1, 0],
                          [1 / 4, -1, 1],
                          [1 / 4, 0, 1]
                        ];
                        break;
                      default:
                        throw new Error("ErrorDiffusionArray: unknown kernel = " + n);
                    }
                  }, a;
                }();
                x.ErrorDiffusionArray = l;
              },
              /* 33 */
              /***/
              function(M, x, y) {
                var E = y(34), c = y(24), u = y(6), l = function() {
                  function a(n, d, g) {
                    d === void 0 && (d = 16), g === void 0 && (g = 1), this._distance = n, this._errorPropagation = g, this._errorQueueSize = d, this._max = this._errorQueueSize, this._createWeights();
                  }
                  return a.prototype.quantize = function(n, d) {
                    for (var g = this, h = new E.HilbertCurveBase(), m = n.getPointArray(), s = n.getWidth(), b = n.getHeight(), S = [], o = 0, A = 0; A < this._errorQueueSize; A++)
                      S[A] = { r: 0, g: 0, b: 0, a: 0 };
                    return h.walk(s, b, function(T, I) {
                      for (var L = m[T + I * s], z = L.r, U = L.g, J = L.b, F = L.a, oe = 0; oe < g._errorQueueSize; oe++) {
                        var ee = g._weights[oe], ie = S[(oe + o) % g._errorQueueSize];
                        z += ie.r * ee, U += ie.g * ee, J += ie.b * ee, F += ie.a * ee;
                      }
                      var W = c.Point.createByRGBA(u.inRange0to255Rounded(z), u.inRange0to255Rounded(U), u.inRange0to255Rounded(J), u.inRange0to255Rounded(F)), Q = d.getNearestColor(g._distance, W);
                      o = (o + 1) % g._errorQueueSize;
                      var de = (o + g._errorQueueSize - 1) % g._errorQueueSize;
                      S[de].r = L.r - Q.r, S[de].g = L.g - Q.g, S[de].b = L.b - Q.b, S[de].a = L.a - Q.a, L.from(Q);
                    }), n;
                  }, a.prototype._createWeights = function() {
                    this._weights = [];
                    for (var n = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1)), d = 0, g = 1; d < this._errorQueueSize; d++)
                      this._weights[d] = (g + 0.5 | 0) / this._max * this._errorPropagation, g *= n;
                  }, a;
                }();
                x.ErrorDiffusionRiemersma = l;
              },
              /* 34 */
              /***/
              function(M, x) {
                var y;
                (function(c) {
                  c[c.NONE = 0] = "NONE", c[c.UP = 1] = "UP", c[c.LEFT = 2] = "LEFT", c[c.RIGHT = 3] = "RIGHT", c[c.DOWN = 4] = "DOWN";
                })(y || (y = {}));
                var E = function() {
                  function c() {
                  }
                  return c.prototype.walk = function(u, l, a) {
                    this._x = 0, this._y = 0, this._d = 0, this._width = u, this._height = l, this._callback = a;
                    var n = Math.max(u, l);
                    this._level = Math.log(n) / Math.log(2) + 1 | 0, this._walkHilbert(y.UP), this._visit(y.NONE);
                  }, c.prototype._walkHilbert = function(u) {
                    if (!(this._level < 1)) {
                      switch (this._level--, u) {
                        case y.LEFT:
                          this._walkHilbert(y.UP), this._visit(y.RIGHT), this._walkHilbert(y.LEFT), this._visit(y.DOWN), this._walkHilbert(y.LEFT), this._visit(y.LEFT), this._walkHilbert(y.DOWN);
                          break;
                        case y.RIGHT:
                          this._walkHilbert(y.DOWN), this._visit(y.LEFT), this._walkHilbert(y.RIGHT), this._visit(y.UP), this._walkHilbert(y.RIGHT), this._visit(y.RIGHT), this._walkHilbert(y.UP);
                          break;
                        case y.UP:
                          this._walkHilbert(y.LEFT), this._visit(y.DOWN), this._walkHilbert(y.UP), this._visit(y.RIGHT), this._walkHilbert(y.UP), this._visit(y.UP), this._walkHilbert(y.RIGHT);
                          break;
                        case y.DOWN:
                          this._walkHilbert(y.RIGHT), this._visit(y.UP), this._walkHilbert(y.DOWN), this._visit(y.LEFT), this._walkHilbert(y.DOWN), this._visit(y.DOWN), this._walkHilbert(y.LEFT);
                          break;
                      }
                      this._level++;
                    }
                  }, c.prototype._visit = function(u) {
                    switch (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height && (this._callback(this._x, this._y, this._d), this._d++), u) {
                      case y.LEFT:
                        this._x--;
                        break;
                      case y.RIGHT:
                        this._x++;
                        break;
                      case y.UP:
                        this._y--;
                        break;
                      case y.DOWN:
                        this._y++;
                        break;
                    }
                  }, c;
                }();
                x.HilbertCurveBase = E;
              },
              /* 35 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var E = y(36);
                x.SSIM = E.SSIM;
              },
              /* 36 */
              /***/
              function(M, x, y) {
                var E = y(2), c = 0.01, u = 0.03, l = function() {
                  function a() {
                  }
                  return a.prototype.compare = function(n, d) {
                    if (n.getHeight() !== d.getHeight() || n.getWidth() !== d.getWidth())
                      throw new Error("Images have different sizes!");
                    var g = 8, h = (1 << g) - 1, m = Math.pow(c * h, 2), s = Math.pow(u * h, 2), b = 0, S = 0;
                    return this._iterate(n, d, function(o, A, T, I) {
                      for (var L = 0, z = 0, U = 0, J = 0; J < o.length; J++)
                        z += Math.pow(o[J] - T, 2), U += Math.pow(A[J] - I, 2), L += (o[J] - T) * (A[J] - I);
                      var F = o.length - 1;
                      z /= F, U /= F, L /= F;
                      var oe = (2 * T * I + m) * (2 * L + s), ee = (Math.pow(T, 2) + Math.pow(I, 2) + m) * (z + U + s), ie = oe / ee;
                      S += ie, b++;
                    }), S / b;
                  }, a.prototype._iterate = function(n, d, g) {
                    for (var h = 8, m = n.getWidth(), s = n.getHeight(), b = 0; b < s; b += h)
                      for (var S = 0; S < m; S += h) {
                        var o = Math.min(h, m - S), A = Math.min(h, s - b), T = this._calculateLumaValuesForWindow(n, S, b, o, A), I = this._calculateLumaValuesForWindow(d, S, b, o, A), L = this._calculateAverageLuma(T), z = this._calculateAverageLuma(I);
                        g(T, I, L, z);
                      }
                  }, a.prototype._calculateLumaValuesForWindow = function(n, d, g, h, m) {
                    for (var s = n.getPointArray(), b = [], S = 0, o = g; o < g + m; o++)
                      for (var A = o * n.getWidth(), T = d; T < d + h; T++) {
                        var I = s[A + T];
                        b[S] = I.r * E.Y.RED + I.g * E.Y.GREEN + I.b * E.Y.BLUE, S++;
                      }
                    return b;
                  }, a.prototype._calculateAverageLuma = function(n) {
                    for (var d = 0, g = 0; g < n.length; g++)
                      d += n[g];
                    return d / n.length;
                  }, a;
                }();
                x.SSIM = l;
              },
              /* 37 */
              /***/
              function(M, x, y) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var E = y(6);
                x.arithmetic = E;
                var c = y(28);
                x.HueStatistics = c.HueStatistics;
                var u = y(22);
                x.Palette = u.Palette;
                var l = y(24);
                x.Point = l.Point;
                var a = y(23);
                x.PointContainer = a.PointContainer;
              }
              /******/
            ])
          );
        });
      }, {}], 75: [function(k, Z, _) {
        typeof Object.create == "function" ? Z.exports = function(x, y) {
          y && (x.super_ = y, x.prototype = Object.create(y.prototype, {
            constructor: {
              value: x,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          }));
        } : Z.exports = function(x, y) {
          if (y) {
            x.super_ = y;
            var E = function() {
            };
            E.prototype = y.prototype, x.prototype = new E(), x.prototype.constructor = x;
          }
        };
      }, {}], 76: [function(k, Z, _) {
        /*!
         * Determine if an object is a Buffer
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */
        Z.exports = function(y) {
          return y != null && (M(y) || x(y) || !!y._isBuffer);
        };
        function M(y) {
          return !!y.constructor && typeof y.constructor.isBuffer == "function" && y.constructor.isBuffer(y);
        }
        function x(y) {
          return typeof y.readFloatLE == "function" && typeof y.slice == "function" && M(y.slice(0, 0));
        }
      }, {}], 77: [function(k, Z, _) {
        var M = Function.prototype.toString, x = /^\s*class\b/, y = function(d) {
          try {
            var g = M.call(d);
            return x.test(g);
          } catch {
            return !1;
          }
        }, E = function(d) {
          try {
            return y(d) ? !1 : (M.call(d), !0);
          } catch {
            return !1;
          }
        }, c = Object.prototype.toString, u = "[object Function]", l = "[object GeneratorFunction]", a = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
        Z.exports = function(d) {
          if (!d || typeof d != "function" && typeof d != "object")
            return !1;
          if (typeof d == "function" && !d.prototype)
            return !0;
          if (a)
            return E(d);
          if (y(d))
            return !1;
          var g = c.call(d);
          return g === u || g === l;
        };
      }, {}], 78: [function(k, Z, _) {
        Z.exports = x;
        var M = Object.prototype.toString;
        function x(y) {
          var E = M.call(y);
          return E === "[object Function]" || typeof y == "function" && E !== "[object RegExp]" || typeof ae < "u" && // IE8 and below
          (y === ae.setTimeout || y === ae.alert || y === ae.confirm || y === ae.prompt);
        }
      }, {}], 79: [function(k, Z, _) {
        var M = {}.toString;
        Z.exports = Array.isArray || function(x) {
          return M.call(x) == "[object Array]";
        };
      }, {}], 80: [function(k, Z, _) {
        var M = k("./lib/encoder"), x = k("./lib/decoder");
        Z.exports = {
          encode: M,
          decode: x
        };
      }, { "./lib/decoder": 81, "./lib/encoder": 82 }], 81: [function(k, Z, _) {
        (function(M) {
          var x = function() {
            var c = new Int32Array([
              0,
              1,
              8,
              16,
              9,
              2,
              3,
              10,
              17,
              24,
              32,
              25,
              18,
              11,
              4,
              5,
              12,
              19,
              26,
              33,
              40,
              48,
              41,
              34,
              27,
              20,
              13,
              6,
              7,
              14,
              21,
              28,
              35,
              42,
              49,
              56,
              57,
              50,
              43,
              36,
              29,
              22,
              15,
              23,
              30,
              37,
              44,
              51,
              58,
              59,
              52,
              45,
              38,
              31,
              39,
              46,
              53,
              60,
              61,
              54,
              47,
              55,
              62,
              63
            ]), u = 4017, l = 799, a = 3406, n = 2276, d = 1567, g = 3784, h = 5793, m = 2896;
            function s() {
            }
            function b(z, U) {
              for (var J = 0, F = [], oe, ee, ie = 16; ie > 0 && !z[ie - 1]; )
                ie--;
              F.push({ children: [], index: 0 });
              var W = F[0], Q;
              for (oe = 0; oe < ie; oe++) {
                for (ee = 0; ee < z[oe]; ee++) {
                  for (W = F.pop(), W.children[W.index] = U[J]; W.index > 0; ) {
                    if (F.length === 0)
                      throw new Error("Could not recreate Huffman Table");
                    W = F.pop();
                  }
                  for (W.index++, F.push(W); F.length <= oe; )
                    F.push(Q = { children: [], index: 0 }), W.children[W.index] = Q.children, W = Q;
                  J++;
                }
                oe + 1 < ie && (F.push(Q = { children: [], index: 0 }), W.children[W.index] = Q.children, W = Q);
              }
              return F[0].children;
            }
            function S(z, U, J, F, oe, ee, ie, W, Q, de) {
              J.precision, J.samplesPerLine, J.scanLines;
              var we = J.mcusPerLine, ke = J.progressive;
              J.maxH, J.maxV;
              var Me = U, fe = 0, xe = 0;
              function Ee() {
                if (xe > 0)
                  return xe--, fe >> xe & 1;
                if (fe = z[U++], fe == 255) {
                  var j = z[U++];
                  if (j)
                    throw new Error("unexpected marker: " + (fe << 8 | j).toString(16));
                }
                return xe = 7, fe >>> 7;
              }
              function Pe(j) {
                for (var H = j, X; (X = Ee()) !== null; ) {
                  if (H = H[X], typeof H == "number")
                    return H;
                  if (typeof H != "object")
                    throw new Error("invalid huffman sequence");
                }
                return null;
              }
              function Ue(j) {
                for (var H = 0; j > 0; ) {
                  var X = Ee();
                  if (X === null) return;
                  H = H << 1 | X, j--;
                }
                return H;
              }
              function He(j) {
                var H = Ue(j);
                return H >= 1 << j - 1 ? H : H + (-1 << j) + 1;
              }
              function We(j, H) {
                var X = Pe(j.huffmanTableDC), ue = X === 0 ? 0 : He(X);
                H[0] = j.pred += ue;
                for (var pe = 1; pe < 64; ) {
                  var P = Pe(j.huffmanTableAC), q = P & 15, K = P >> 4;
                  if (q === 0) {
                    if (K < 15)
                      break;
                    pe += 16;
                    continue;
                  }
                  pe += K;
                  var ye = c[pe];
                  H[ye] = He(q), pe++;
                }
              }
              function Ze(j, H) {
                var X = Pe(j.huffmanTableDC), ue = X === 0 ? 0 : He(X) << Q;
                H[0] = j.pred += ue;
              }
              function $e(j, H) {
                H[0] |= Ee() << Q;
              }
              var Ve = 0;
              function Ge(j, H) {
                if (Ve > 0) {
                  Ve--;
                  return;
                }
                for (var X = ee, ue = ie; X <= ue; ) {
                  var pe = Pe(j.huffmanTableAC), P = pe & 15, q = pe >> 4;
                  if (P === 0) {
                    if (q < 15) {
                      Ve = Ue(q) + (1 << q) - 1;
                      break;
                    }
                    X += 16;
                    continue;
                  }
                  X += q;
                  var K = c[X];
                  H[K] = He(P) * (1 << Q), X++;
                }
              }
              var Ie = 0, De;
              function Ne(j, H) {
                for (var X = ee, ue = ie, pe = 0; X <= ue; ) {
                  var P = c[X], q = H[P] < 0 ? -1 : 1;
                  switch (Ie) {
                    case 0:
                      var K = Pe(j.huffmanTableAC), ye = K & 15, pe = K >> 4;
                      if (ye === 0)
                        pe < 15 ? (Ve = Ue(pe) + (1 << pe), Ie = 4) : (pe = 16, Ie = 1);
                      else {
                        if (ye !== 1)
                          throw new Error("invalid ACn encoding");
                        De = He(ye), Ie = pe ? 2 : 3;
                      }
                      continue;
                    case 1:
                    // skipping r zero items
                    case 2:
                      H[P] ? H[P] += (Ee() << Q) * q : (pe--, pe === 0 && (Ie = Ie == 2 ? 3 : 0));
                      break;
                    case 3:
                      H[P] ? H[P] += (Ee() << Q) * q : (H[P] = De << Q, Ie = 0);
                      break;
                    case 4:
                      H[P] && (H[P] += (Ee() << Q) * q);
                      break;
                  }
                  X++;
                }
                Ie === 4 && (Ve--, Ve === 0 && (Ie = 0));
              }
              function _e(j, H, X, ue, pe) {
                var P = X / we | 0, q = X % we, K = P * j.v + ue, ye = q * j.h + pe;
                j.blocks[K] === void 0 && de.tolerantDecoding || H(j, j.blocks[K][ye]);
              }
              function re(j, H, X) {
                var ue = X / j.blocksPerLine | 0, pe = X % j.blocksPerLine;
                j.blocks[ue] === void 0 && de.tolerantDecoding || H(j, j.blocks[ue][pe]);
              }
              var $ = F.length, Ce, ve, Y, G, Ae, e;
              ke ? ee === 0 ? e = W === 0 ? Ze : $e : e = W === 0 ? Ge : Ne : e = We;
              var r = 0, f, C;
              $ == 1 ? C = F[0].blocksPerLine * F[0].blocksPerColumn : C = we * J.mcusPerColumn, oe || (oe = C);
              for (var R, B; r < C; ) {
                for (ve = 0; ve < $; ve++)
                  F[ve].pred = 0;
                if (Ve = 0, $ == 1)
                  for (Ce = F[0], Ae = 0; Ae < oe; Ae++)
                    re(Ce, e, r), r++;
                else
                  for (Ae = 0; Ae < oe; Ae++) {
                    for (ve = 0; ve < $; ve++)
                      for (Ce = F[ve], R = Ce.h, B = Ce.v, Y = 0; Y < B; Y++)
                        for (G = 0; G < R; G++)
                          _e(Ce, e, r, Y, G);
                    if (r++, r === C) break;
                  }
                if (r === C)
                  do {
                    if (z[U] === 255 && z[U + 1] !== 0)
                      break;
                    U += 1;
                  } while (U < z.length - 2);
                if (xe = 0, f = z[U] << 8 | z[U + 1], f < 65280)
                  throw new Error("marker was not found");
                if (f >= 65488 && f <= 65495)
                  U += 2;
                else
                  break;
              }
              return U - Me;
            }
            function o(z, U) {
              var J = [], F = U.blocksPerLine, oe = U.blocksPerColumn, ee = F << 3, ie = new Int32Array(64), W = new Uint8Array(64);
              function Q(Ue, He, We) {
                var Ze = U.quantizationTable, $e, Ve, Ge, Ie, De, Ne, _e, re, $, Ce = We, ve;
                for (ve = 0; ve < 64; ve++)
                  Ce[ve] = Ue[ve] * Ze[ve];
                for (ve = 0; ve < 8; ++ve) {
                  var Y = 8 * ve;
                  if (Ce[1 + Y] == 0 && Ce[2 + Y] == 0 && Ce[3 + Y] == 0 && Ce[4 + Y] == 0 && Ce[5 + Y] == 0 && Ce[6 + Y] == 0 && Ce[7 + Y] == 0) {
                    $ = h * Ce[0 + Y] + 512 >> 10, Ce[0 + Y] = $, Ce[1 + Y] = $, Ce[2 + Y] = $, Ce[3 + Y] = $, Ce[4 + Y] = $, Ce[5 + Y] = $, Ce[6 + Y] = $, Ce[7 + Y] = $;
                    continue;
                  }
                  $e = h * Ce[0 + Y] + 128 >> 8, Ve = h * Ce[4 + Y] + 128 >> 8, Ge = Ce[2 + Y], Ie = Ce[6 + Y], De = m * (Ce[1 + Y] - Ce[7 + Y]) + 128 >> 8, re = m * (Ce[1 + Y] + Ce[7 + Y]) + 128 >> 8, Ne = Ce[3 + Y] << 4, _e = Ce[5 + Y] << 4, $ = $e - Ve + 1 >> 1, $e = $e + Ve + 1 >> 1, Ve = $, $ = Ge * g + Ie * d + 128 >> 8, Ge = Ge * d - Ie * g + 128 >> 8, Ie = $, $ = De - _e + 1 >> 1, De = De + _e + 1 >> 1, _e = $, $ = re + Ne + 1 >> 1, Ne = re - Ne + 1 >> 1, re = $, $ = $e - Ie + 1 >> 1, $e = $e + Ie + 1 >> 1, Ie = $, $ = Ve - Ge + 1 >> 1, Ve = Ve + Ge + 1 >> 1, Ge = $, $ = De * n + re * a + 2048 >> 12, De = De * a - re * n + 2048 >> 12, re = $, $ = Ne * l + _e * u + 2048 >> 12, Ne = Ne * u - _e * l + 2048 >> 12, _e = $, Ce[0 + Y] = $e + re, Ce[7 + Y] = $e - re, Ce[1 + Y] = Ve + _e, Ce[6 + Y] = Ve - _e, Ce[2 + Y] = Ge + Ne, Ce[5 + Y] = Ge - Ne, Ce[3 + Y] = Ie + De, Ce[4 + Y] = Ie - De;
                }
                for (ve = 0; ve < 8; ++ve) {
                  var G = ve;
                  if (Ce[8 + G] == 0 && Ce[16 + G] == 0 && Ce[24 + G] == 0 && Ce[32 + G] == 0 && Ce[40 + G] == 0 && Ce[48 + G] == 0 && Ce[56 + G] == 0) {
                    $ = h * We[ve + 0] + 8192 >> 14, Ce[0 + G] = $, Ce[8 + G] = $, Ce[16 + G] = $, Ce[24 + G] = $, Ce[32 + G] = $, Ce[40 + G] = $, Ce[48 + G] = $, Ce[56 + G] = $;
                    continue;
                  }
                  $e = h * Ce[0 + G] + 2048 >> 12, Ve = h * Ce[32 + G] + 2048 >> 12, Ge = Ce[16 + G], Ie = Ce[48 + G], De = m * (Ce[8 + G] - Ce[56 + G]) + 2048 >> 12, re = m * (Ce[8 + G] + Ce[56 + G]) + 2048 >> 12, Ne = Ce[24 + G], _e = Ce[40 + G], $ = $e - Ve + 1 >> 1, $e = $e + Ve + 1 >> 1, Ve = $, $ = Ge * g + Ie * d + 2048 >> 12, Ge = Ge * d - Ie * g + 2048 >> 12, Ie = $, $ = De - _e + 1 >> 1, De = De + _e + 1 >> 1, _e = $, $ = re + Ne + 1 >> 1, Ne = re - Ne + 1 >> 1, re = $, $ = $e - Ie + 1 >> 1, $e = $e + Ie + 1 >> 1, Ie = $, $ = Ve - Ge + 1 >> 1, Ve = Ve + Ge + 1 >> 1, Ge = $, $ = De * n + re * a + 2048 >> 12, De = De * a - re * n + 2048 >> 12, re = $, $ = Ne * l + _e * u + 2048 >> 12, Ne = Ne * u - _e * l + 2048 >> 12, _e = $, Ce[0 + G] = $e + re, Ce[56 + G] = $e - re, Ce[8 + G] = Ve + _e, Ce[48 + G] = Ve - _e, Ce[16 + G] = Ge + Ne, Ce[40 + G] = Ge - Ne, Ce[24 + G] = Ie + De, Ce[32 + G] = Ie - De;
                }
                for (ve = 0; ve < 64; ++ve) {
                  var Ae = 128 + (Ce[ve] + 8 >> 4);
                  He[ve] = Ae < 0 ? 0 : Ae > 255 ? 255 : Ae;
                }
              }
              L(ee * oe * 8);
              for (var de, we, ke = 0; ke < oe; ke++) {
                var Me = ke << 3;
                for (de = 0; de < 8; de++)
                  J.push(new Uint8Array(ee));
                for (var fe = 0; fe < F; fe++) {
                  Q(U.blocks[ke][fe], W, ie);
                  var xe = 0, Ee = fe << 3;
                  for (we = 0; we < 8; we++) {
                    var Pe = J[Me + we];
                    for (de = 0; de < 8; de++)
                      Pe[Ee + de] = W[xe++];
                  }
                }
              }
              return J;
            }
            function A(z) {
              return z < 0 ? 0 : z > 255 ? 255 : z;
            }
            s.prototype = {
              load: function(U) {
                var J = new XMLHttpRequest();
                J.open("GET", U, !0), J.responseType = "arraybuffer", J.onload = (function() {
                  var F = new Uint8Array(J.response || J.mozResponseArrayBuffer);
                  this.parse(F), this.onload && this.onload();
                }).bind(this), J.send(null);
              },
              parse: function(U) {
                var J = this.opts.maxResolutionInMP * 1e3 * 1e3, F = 0;
                U.length;
                function oe() {
                  var pe = U[F] << 8 | U[F + 1];
                  return F += 2, pe;
                }
                function ee() {
                  var pe = oe(), P = U.subarray(F, F + pe - 2);
                  return F += P.length, P;
                }
                function ie(pe) {
                  var P = 0, q = 0, K, ye;
                  for (ye in pe.components)
                    pe.components.hasOwnProperty(ye) && (K = pe.components[ye], P < K.h && (P = K.h), q < K.v && (q = K.v));
                  var te = Math.ceil(pe.samplesPerLine / 8 / P), he = Math.ceil(pe.scanLines / 8 / q);
                  for (ye in pe.components)
                    if (pe.components.hasOwnProperty(ye)) {
                      K = pe.components[ye];
                      var D = Math.ceil(Math.ceil(pe.samplesPerLine / 8) * K.h / P), Se = Math.ceil(Math.ceil(pe.scanLines / 8) * K.v / q), le = te * K.h, v = he * K.v, se = v * le, me = [];
                      L(se * 256);
                      for (var O = 0; O < v; O++) {
                        for (var ce = [], Oe = 0; Oe < le; Oe++)
                          ce.push(new Int32Array(64));
                        me.push(ce);
                      }
                      K.blocksPerLine = D, K.blocksPerColumn = Se, K.blocks = me;
                    }
                  pe.maxH = P, pe.maxV = q, pe.mcusPerLine = te, pe.mcusPerColumn = he;
                }
                var W = null, Q = null, de, we, ke = [], Me = [], fe = [], xe = [], Ee = oe();
                if (Ee != 65496)
                  throw new Error("SOI not found");
                for (Ee = oe(); Ee != 65497; ) {
                  var Pe, Ue;
                  switch (Ee) {
                    case 65280:
                      break;
                    case 65504:
                    // APP0 (Application Specific)
                    case 65505:
                    // APP1
                    case 65506:
                    // APP2
                    case 65507:
                    // APP3
                    case 65508:
                    // APP4
                    case 65509:
                    // APP5
                    case 65510:
                    // APP6
                    case 65511:
                    // APP7
                    case 65512:
                    // APP8
                    case 65513:
                    // APP9
                    case 65514:
                    // APP10
                    case 65515:
                    // APP11
                    case 65516:
                    // APP12
                    case 65517:
                    // APP13
                    case 65518:
                    // APP14
                    case 65519:
                    // APP15
                    case 65534:
                      var He = ee();
                      Ee === 65504 && He[0] === 74 && He[1] === 70 && He[2] === 73 && He[3] === 70 && He[4] === 0 && (W = {
                        version: { major: He[5], minor: He[6] },
                        densityUnits: He[7],
                        xDensity: He[8] << 8 | He[9],
                        yDensity: He[10] << 8 | He[11],
                        thumbWidth: He[12],
                        thumbHeight: He[13],
                        thumbData: He.subarray(14, 14 + 3 * He[12] * He[13])
                      }), Ee === 65505 && He[0] === 69 && He[1] === 120 && He[2] === 105 && He[3] === 102 && He[4] === 0 && (this.exifBuffer = He.subarray(5, He.length)), Ee === 65518 && He[0] === 65 && He[1] === 100 && He[2] === 111 && He[3] === 98 && He[4] === 101 && He[5] === 0 && (Q = {
                        version: He[6],
                        flags0: He[7] << 8 | He[8],
                        flags1: He[9] << 8 | He[10],
                        transformCode: He[11]
                      });
                      break;
                    case 65499:
                      for (var We = oe(), Ze = We + F - 2; F < Ze; ) {
                        var $e = U[F++];
                        L(256);
                        var Ve = new Int32Array(64);
                        if ($e >> 4 === 0)
                          for (Ue = 0; Ue < 64; Ue++) {
                            var Ge = c[Ue];
                            Ve[Ge] = U[F++];
                          }
                        else if ($e >> 4 === 1)
                          for (Ue = 0; Ue < 64; Ue++) {
                            var Ge = c[Ue];
                            Ve[Ge] = oe();
                          }
                        else
                          throw new Error("DQT: invalid table spec");
                        ke[$e & 15] = Ve;
                      }
                      break;
                    case 65472:
                    // SOF0 (Start of Frame, Baseline DCT)
                    case 65473:
                    // SOF1 (Start of Frame, Extended DCT)
                    case 65474:
                      oe(), de = {}, de.extended = Ee === 65473, de.progressive = Ee === 65474, de.precision = U[F++], de.scanLines = oe(), de.samplesPerLine = oe(), de.components = {}, de.componentsOrder = [];
                      var Ie = de.scanLines * de.samplesPerLine;
                      if (Ie > J) {
                        var De = Math.ceil((Ie - J) / 1e6);
                        throw new Error(`maxResolutionInMP limit exceeded by ${De}MP`);
                      }
                      var Ne = U[F++], _e;
                      for (Pe = 0; Pe < Ne; Pe++) {
                        _e = U[F];
                        var re = U[F + 1] >> 4, $ = U[F + 1] & 15, Ce = U[F + 2];
                        de.componentsOrder.push(_e), de.components[_e] = {
                          h: re,
                          v: $,
                          quantizationIdx: Ce
                        }, F += 3;
                      }
                      ie(de), Me.push(de);
                      break;
                    case 65476:
                      var ve = oe();
                      for (Pe = 2; Pe < ve; ) {
                        var Y = U[F++], G = new Uint8Array(16), Ae = 0;
                        for (Ue = 0; Ue < 16; Ue++, F++)
                          Ae += G[Ue] = U[F];
                        L(16 + Ae);
                        var e = new Uint8Array(Ae);
                        for (Ue = 0; Ue < Ae; Ue++, F++)
                          e[Ue] = U[F];
                        Pe += 17 + Ae, (Y >> 4 === 0 ? xe : fe)[Y & 15] = b(G, e);
                      }
                      break;
                    case 65501:
                      oe(), we = oe();
                      break;
                    case 65498:
                      oe();
                      var r = U[F++], f = [], C;
                      for (Pe = 0; Pe < r; Pe++) {
                        C = de.components[U[F++]];
                        var R = U[F++];
                        C.huffmanTableDC = xe[R >> 4], C.huffmanTableAC = fe[R & 15], f.push(C);
                      }
                      var B = U[F++], j = U[F++], H = U[F++], X = S(
                        U,
                        F,
                        de,
                        f,
                        we,
                        B,
                        j,
                        H >> 4,
                        H & 15,
                        this.opts
                      );
                      F += X;
                      break;
                    case 65535:
                      U[F] !== 255 && F--;
                      break;
                    default:
                      if (U[F - 3] == 255 && U[F - 2] >= 192 && U[F - 2] <= 254) {
                        F -= 3;
                        break;
                      }
                      throw new Error("unknown JPEG marker " + Ee.toString(16));
                  }
                  Ee = oe();
                }
                if (Me.length != 1)
                  throw new Error("only single frame JPEGs supported");
                for (var Pe = 0; Pe < Me.length; Pe++) {
                  var ue = Me[Pe].components;
                  for (var Ue in ue)
                    ue[Ue].quantizationTable = ke[ue[Ue].quantizationIdx], delete ue[Ue].quantizationIdx;
                }
                this.width = de.samplesPerLine, this.height = de.scanLines, this.jfif = W, this.adobe = Q, this.components = [];
                for (var Pe = 0; Pe < de.componentsOrder.length; Pe++) {
                  var C = de.components[de.componentsOrder[Pe]];
                  this.components.push({
                    lines: o(de, C),
                    scaleX: C.h / de.maxH,
                    scaleY: C.v / de.maxV
                  });
                }
              },
              getData: function(U, J) {
                var F = this.width / U, oe = this.height / J, ee, ie, W, Q, de, we, ke, Me, fe, xe, Ee = 0, Pe, Ue, He, We, Ze, $e, Ve, Ge, Ie, De, Ne, _e = U * J * this.components.length;
                L(_e);
                var re = new Uint8Array(_e);
                switch (this.components.length) {
                  case 1:
                    for (ee = this.components[0], xe = 0; xe < J; xe++)
                      for (de = ee.lines[0 | xe * ee.scaleY * oe], fe = 0; fe < U; fe++)
                        Pe = de[0 | fe * ee.scaleX * F], re[Ee++] = Pe;
                    break;
                  case 2:
                    for (ee = this.components[0], ie = this.components[1], xe = 0; xe < J; xe++)
                      for (de = ee.lines[0 | xe * ee.scaleY * oe], we = ie.lines[0 | xe * ie.scaleY * oe], fe = 0; fe < U; fe++)
                        Pe = de[0 | fe * ee.scaleX * F], re[Ee++] = Pe, Pe = we[0 | fe * ie.scaleX * F], re[Ee++] = Pe;
                    break;
                  case 3:
                    for (Ne = !0, this.adobe && this.adobe.transformCode ? Ne = !0 : typeof this.opts.colorTransform < "u" && (Ne = !!this.opts.colorTransform), ee = this.components[0], ie = this.components[1], W = this.components[2], xe = 0; xe < J; xe++)
                      for (de = ee.lines[0 | xe * ee.scaleY * oe], we = ie.lines[0 | xe * ie.scaleY * oe], ke = W.lines[0 | xe * W.scaleY * oe], fe = 0; fe < U; fe++)
                        Ne ? (Pe = de[0 | fe * ee.scaleX * F], Ue = we[0 | fe * ie.scaleX * F], He = ke[0 | fe * W.scaleX * F], Ge = A(Pe + 1.402 * (He - 128)), Ie = A(Pe - 0.3441363 * (Ue - 128) - 0.71413636 * (He - 128)), De = A(Pe + 1.772 * (Ue - 128))) : (Ge = de[0 | fe * ee.scaleX * F], Ie = we[0 | fe * ie.scaleX * F], De = ke[0 | fe * W.scaleX * F]), re[Ee++] = Ge, re[Ee++] = Ie, re[Ee++] = De;
                    break;
                  case 4:
                    if (!this.adobe)
                      throw new Error("Unsupported color mode (4 components)");
                    for (Ne = !1, this.adobe && this.adobe.transformCode ? Ne = !0 : typeof this.opts.colorTransform < "u" && (Ne = !!this.opts.colorTransform), ee = this.components[0], ie = this.components[1], W = this.components[2], Q = this.components[3], xe = 0; xe < J; xe++)
                      for (de = ee.lines[0 | xe * ee.scaleY * oe], we = ie.lines[0 | xe * ie.scaleY * oe], ke = W.lines[0 | xe * W.scaleY * oe], Me = Q.lines[0 | xe * Q.scaleY * oe], fe = 0; fe < U; fe++)
                        Ne ? (Pe = de[0 | fe * ee.scaleX * F], Ue = we[0 | fe * ie.scaleX * F], He = ke[0 | fe * W.scaleX * F], We = Me[0 | fe * Q.scaleX * F], Ze = 255 - A(Pe + 1.402 * (He - 128)), $e = 255 - A(Pe - 0.3441363 * (Ue - 128) - 0.71413636 * (He - 128)), Ve = 255 - A(Pe + 1.772 * (Ue - 128))) : (Ze = de[0 | fe * ee.scaleX * F], $e = we[0 | fe * ie.scaleX * F], Ve = ke[0 | fe * W.scaleX * F], We = Me[0 | fe * Q.scaleX * F]), re[Ee++] = 255 - Ze, re[Ee++] = 255 - $e, re[Ee++] = 255 - Ve, re[Ee++] = 255 - We;
                    break;
                  default:
                    throw new Error("Unsupported color mode");
                }
                return re;
              },
              copyToImageData: function(U, J) {
                var F = U.width, oe = U.height, ee = U.data, ie = this.getData(F, oe), W = 0, Q = 0, de, we, ke, Me, fe, xe, Ee, Pe, Ue;
                switch (this.components.length) {
                  case 1:
                    for (we = 0; we < oe; we++)
                      for (de = 0; de < F; de++)
                        ke = ie[W++], ee[Q++] = ke, ee[Q++] = ke, ee[Q++] = ke, J && (ee[Q++] = 255);
                    break;
                  case 3:
                    for (we = 0; we < oe; we++)
                      for (de = 0; de < F; de++)
                        Ee = ie[W++], Pe = ie[W++], Ue = ie[W++], ee[Q++] = Ee, ee[Q++] = Pe, ee[Q++] = Ue, J && (ee[Q++] = 255);
                    break;
                  case 4:
                    for (we = 0; we < oe; we++)
                      for (de = 0; de < F; de++)
                        fe = ie[W++], xe = ie[W++], ke = ie[W++], Me = ie[W++], Ee = 255 - A(fe * (1 - Me / 255) + Me), Pe = 255 - A(xe * (1 - Me / 255) + Me), Ue = 255 - A(ke * (1 - Me / 255) + Me), ee[Q++] = Ee, ee[Q++] = Pe, ee[Q++] = Ue, J && (ee[Q++] = 255);
                    break;
                  default:
                    throw new Error("Unsupported color mode");
                }
              }
            };
            var T = 0, I = 0;
            function L(z = 0) {
              var U = T + z;
              if (U > I) {
                var J = Math.ceil((U - I) / 1024 / 1024);
                throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${J}MB`);
              }
              T = U;
            }
            return s.resetMaxMemoryUsage = function(z) {
              T = 0, I = z;
            }, s.getBytesAllocated = function() {
              return T;
            }, s.requestMemoryAllocation = L, s;
          }();
          typeof Z < "u" ? Z.exports = y : typeof ae < "u" && (ae["jpeg-js"] = ae["jpeg-js"] || {}, ae["jpeg-js"].decode = y);
          function y(E, c = {}) {
            var u = {
              // "undefined" means "Choose whether to transform colors based on the image’s color model."
              colorTransform: void 0,
              useTArray: !1,
              formatAsRGBA: !0,
              tolerantDecoding: !0,
              maxResolutionInMP: 100,
              // Don't decode more than 100 megapixels
              maxMemoryUsageInMB: 512
              // Don't decode if memory footprint is more than 512MB
            }, l = { ...u, ...c }, a = new Uint8Array(E), n = new x();
            n.opts = l, x.resetMaxMemoryUsage(l.maxMemoryUsageInMB * 1024 * 1024), n.parse(a);
            var d = l.formatAsRGBA ? 4 : 3, g = n.width * n.height * d;
            try {
              x.requestMemoryAllocation(g);
              var h = {
                width: n.width,
                height: n.height,
                exifBuffer: n.exifBuffer,
                data: l.useTArray ? new Uint8Array(g) : new M(g)
              };
            } catch (m) {
              throw m instanceof RangeError ? new Error("Could not allocate enough memory for the image. Required: " + g) : m;
            }
            return n.copyToImageData(h, l.formatAsRGBA), h;
          }
        }).call(this, k("buffer").Buffer);
      }, { buffer: 48 }], 82: [function(k, Z, _) {
        (function(M) {
          function x(E) {
            var c = Math.floor, u = new Array(64), l = new Array(64), a = new Array(64), n = new Array(64), d, g, h, m, s = new Array(65535), b = new Array(65535), S = new Array(64), o = new Array(64), A = [], T = 0, I = 7, L = new Array(64), z = new Array(64), U = new Array(64), J = new Array(256), F = new Array(2048), oe, ee = [
              0,
              1,
              5,
              6,
              14,
              15,
              27,
              28,
              2,
              4,
              7,
              13,
              16,
              26,
              29,
              42,
              3,
              8,
              12,
              17,
              25,
              30,
              41,
              43,
              9,
              11,
              18,
              24,
              31,
              40,
              44,
              53,
              10,
              19,
              23,
              32,
              39,
              45,
              52,
              54,
              20,
              22,
              33,
              38,
              46,
              51,
              55,
              60,
              21,
              34,
              37,
              47,
              50,
              56,
              59,
              61,
              35,
              36,
              48,
              49,
              57,
              58,
              62,
              63
            ], ie = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], W = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Q = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], de = [
              1,
              2,
              3,
              0,
              4,
              17,
              5,
              18,
              33,
              49,
              65,
              6,
              19,
              81,
              97,
              7,
              34,
              113,
              20,
              50,
              129,
              145,
              161,
              8,
              35,
              66,
              177,
              193,
              21,
              82,
              209,
              240,
              36,
              51,
              98,
              114,
              130,
              9,
              10,
              22,
              23,
              24,
              25,
              26,
              37,
              38,
              39,
              40,
              41,
              42,
              52,
              53,
              54,
              55,
              56,
              57,
              58,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              90,
              99,
              100,
              101,
              102,
              103,
              104,
              105,
              106,
              115,
              116,
              117,
              118,
              119,
              120,
              121,
              122,
              131,
              132,
              133,
              134,
              135,
              136,
              137,
              138,
              146,
              147,
              148,
              149,
              150,
              151,
              152,
              153,
              154,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              178,
              179,
              180,
              181,
              182,
              183,
              184,
              185,
              186,
              194,
              195,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              210,
              211,
              212,
              213,
              214,
              215,
              216,
              217,
              218,
              225,
              226,
              227,
              228,
              229,
              230,
              231,
              232,
              233,
              234,
              241,
              242,
              243,
              244,
              245,
              246,
              247,
              248,
              249,
              250
            ], we = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], ke = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Me = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], fe = [
              0,
              1,
              2,
              3,
              17,
              4,
              5,
              33,
              49,
              6,
              18,
              65,
              81,
              7,
              97,
              113,
              19,
              34,
              50,
              129,
              8,
              20,
              66,
              145,
              161,
              177,
              193,
              9,
              35,
              51,
              82,
              240,
              21,
              98,
              114,
              209,
              10,
              22,
              36,
              52,
              225,
              37,
              241,
              23,
              24,
              25,
              26,
              38,
              39,
              40,
              41,
              42,
              53,
              54,
              55,
              56,
              57,
              58,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              90,
              99,
              100,
              101,
              102,
              103,
              104,
              105,
              106,
              115,
              116,
              117,
              118,
              119,
              120,
              121,
              122,
              130,
              131,
              132,
              133,
              134,
              135,
              136,
              137,
              138,
              146,
              147,
              148,
              149,
              150,
              151,
              152,
              153,
              154,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              178,
              179,
              180,
              181,
              182,
              183,
              184,
              185,
              186,
              194,
              195,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              210,
              211,
              212,
              213,
              214,
              215,
              216,
              217,
              218,
              226,
              227,
              228,
              229,
              230,
              231,
              232,
              233,
              234,
              242,
              243,
              244,
              245,
              246,
              247,
              248,
              249,
              250
            ];
            function xe(G) {
              for (var Ae = [
                16,
                11,
                10,
                16,
                24,
                40,
                51,
                61,
                12,
                12,
                14,
                19,
                26,
                58,
                60,
                55,
                14,
                13,
                16,
                24,
                40,
                57,
                69,
                56,
                14,
                17,
                22,
                29,
                51,
                87,
                80,
                62,
                18,
                22,
                37,
                56,
                68,
                109,
                103,
                77,
                24,
                35,
                55,
                64,
                81,
                104,
                113,
                92,
                49,
                64,
                78,
                87,
                103,
                121,
                120,
                101,
                72,
                92,
                95,
                98,
                112,
                100,
                103,
                99
              ], e = 0; e < 64; e++) {
                var r = c((Ae[e] * G + 50) / 100);
                r < 1 ? r = 1 : r > 255 && (r = 255), u[ee[e]] = r;
              }
              for (var f = [
                17,
                18,
                24,
                47,
                99,
                99,
                99,
                99,
                18,
                21,
                26,
                66,
                99,
                99,
                99,
                99,
                24,
                26,
                56,
                99,
                99,
                99,
                99,
                99,
                47,
                66,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99
              ], C = 0; C < 64; C++) {
                var R = c((f[C] * G + 50) / 100);
                R < 1 ? R = 1 : R > 255 && (R = 255), l[ee[C]] = R;
              }
              for (var B = [
                1,
                1.387039845,
                1.306562965,
                1.175875602,
                1,
                0.785694958,
                0.5411961,
                0.275899379
              ], j = 0, H = 0; H < 8; H++)
                for (var X = 0; X < 8; X++)
                  a[j] = 1 / (u[ee[j]] * B[H] * B[X] * 8), n[j] = 1 / (l[ee[j]] * B[H] * B[X] * 8), j++;
            }
            function Ee(G, Ae) {
              for (var e = 0, r = 0, f = new Array(), C = 1; C <= 16; C++) {
                for (var R = 1; R <= G[C]; R++)
                  f[Ae[r]] = [], f[Ae[r]][0] = e, f[Ae[r]][1] = C, r++, e++;
                e *= 2;
              }
              return f;
            }
            function Pe() {
              d = Ee(ie, W), g = Ee(we, ke), h = Ee(Q, de), m = Ee(Me, fe);
            }
            function Ue() {
              for (var G = 1, Ae = 2, e = 1; e <= 15; e++) {
                for (var r = G; r < Ae; r++)
                  b[32767 + r] = e, s[32767 + r] = [], s[32767 + r][1] = e, s[32767 + r][0] = r;
                for (var f = -(Ae - 1); f <= -G; f++)
                  b[32767 + f] = e, s[32767 + f] = [], s[32767 + f][1] = e, s[32767 + f][0] = Ae - 1 + f;
                G <<= 1, Ae <<= 1;
              }
            }
            function He() {
              for (var G = 0; G < 256; G++)
                F[G] = 19595 * G, F[G + 256 >> 0] = 38470 * G, F[G + 512 >> 0] = 7471 * G + 32768, F[G + 768 >> 0] = -11059 * G, F[G + 1024 >> 0] = -21709 * G, F[G + 1280 >> 0] = 32768 * G + 8421375, F[G + 1536 >> 0] = -27439 * G, F[G + 1792 >> 0] = -5329 * G;
            }
            function We(G) {
              for (var Ae = G[0], e = G[1] - 1; e >= 0; )
                Ae & 1 << e && (T |= 1 << I), e--, I--, I < 0 && (T == 255 ? (Ze(255), Ze(0)) : Ze(T), I = 7, T = 0);
            }
            function Ze(G) {
              A.push(G);
            }
            function $e(G) {
              Ze(G >> 8 & 255), Ze(G & 255);
            }
            function Ve(G, Ae) {
              var e, r, f, C, R, B, j, H, X = 0, ue, pe = 8, P = 64;
              for (ue = 0; ue < pe; ++ue) {
                e = G[X], r = G[X + 1], f = G[X + 2], C = G[X + 3], R = G[X + 4], B = G[X + 5], j = G[X + 6], H = G[X + 7];
                var q = e + H, K = e - H, ye = r + j, te = r - j, he = f + B, D = f - B, Se = C + R, le = C - R, v = q + Se, se = q - Se, me = ye + he, O = ye - he;
                G[X] = v + me, G[X + 4] = v - me;
                var ce = (O + se) * 0.707106781;
                G[X + 2] = se + ce, G[X + 6] = se - ce, v = le + D, me = D + te, O = te + K;
                var Oe = (v - O) * 0.382683433, Be = 0.5411961 * v + Oe, je = 1.306562965 * O + Oe, Fe = me * 0.707106781, Ye = K + Fe, Ke = K - Fe;
                G[X + 5] = Ke + Be, G[X + 3] = Ke - Be, G[X + 1] = Ye + je, G[X + 7] = Ye - je, X += 8;
              }
              for (X = 0, ue = 0; ue < pe; ++ue) {
                e = G[X], r = G[X + 8], f = G[X + 16], C = G[X + 24], R = G[X + 32], B = G[X + 40], j = G[X + 48], H = G[X + 56];
                var et = e + H, Je = e - H, nt = r + j, dt = r - j, vt = f + B, bt = f - B, At = C + R, ot = C - R, ht = et + At, gt = et - At, Ct = nt + vt, xt = nt - vt;
                G[X] = ht + Ct, G[X + 32] = ht - Ct;
                var Ot = (xt + gt) * 0.707106781;
                G[X + 16] = gt + Ot, G[X + 48] = gt - Ot, ht = ot + bt, Ct = bt + dt, xt = dt + Je;
                var Nt = (ht - xt) * 0.382683433, Mt = 0.5411961 * ht + Nt, Gt = 1.306562965 * xt + Nt, Bt = Ct * 0.707106781, or = Je + Bt, ar = Je - Bt;
                G[X + 40] = ar + Mt, G[X + 24] = ar - Mt, G[X + 8] = or + Gt, G[X + 56] = or - Gt, X++;
              }
              var ur;
              for (ue = 0; ue < P; ++ue)
                ur = G[ue] * Ae[ue], S[ue] = ur > 0 ? ur + 0.5 | 0 : ur - 0.5 | 0;
              return S;
            }
            function Ge() {
              $e(65504), $e(16), Ze(74), Ze(70), Ze(73), Ze(70), Ze(0), Ze(1), Ze(1), Ze(0), $e(1), $e(1), Ze(0), Ze(0);
            }
            function Ie(G) {
              if (G) {
                $e(65505), G[0] === 69 && G[1] === 120 && G[2] === 105 && G[3] === 102 ? $e(G.length + 2) : ($e(G.length + 5 + 2), Ze(69), Ze(120), Ze(105), Ze(102), Ze(0));
                for (var Ae = 0; Ae < G.length; Ae++)
                  Ze(G[Ae]);
              }
            }
            function De(G, Ae) {
              $e(65472), $e(17), Ze(8), $e(Ae), $e(G), Ze(3), Ze(1), Ze(17), Ze(0), Ze(2), Ze(17), Ze(1), Ze(3), Ze(17), Ze(1);
            }
            function Ne() {
              $e(65499), $e(132), Ze(0);
              for (var G = 0; G < 64; G++)
                Ze(u[G]);
              Ze(1);
              for (var Ae = 0; Ae < 64; Ae++)
                Ze(l[Ae]);
            }
            function _e() {
              $e(65476), $e(418), Ze(0);
              for (var G = 0; G < 16; G++)
                Ze(ie[G + 1]);
              for (var Ae = 0; Ae <= 11; Ae++)
                Ze(W[Ae]);
              Ze(16);
              for (var e = 0; e < 16; e++)
                Ze(Q[e + 1]);
              for (var r = 0; r <= 161; r++)
                Ze(de[r]);
              Ze(1);
              for (var f = 0; f < 16; f++)
                Ze(we[f + 1]);
              for (var C = 0; C <= 11; C++)
                Ze(ke[C]);
              Ze(17);
              for (var R = 0; R < 16; R++)
                Ze(Me[R + 1]);
              for (var B = 0; B <= 161; B++)
                Ze(fe[B]);
            }
            function re() {
              $e(65498), $e(12), Ze(3), Ze(1), Ze(0), Ze(2), Ze(17), Ze(3), Ze(17), Ze(0), Ze(63), Ze(0);
            }
            function $(G, Ae, e, r, f) {
              for (var C = f[0], R = f[240], B, j = 16, H = 63, X = 64, ue = Ve(G, Ae), pe = 0; pe < X; ++pe)
                o[ee[pe]] = ue[pe];
              var P = o[0] - e;
              e = o[0], P == 0 ? We(r[0]) : (B = 32767 + P, We(r[b[B]]), We(s[B]));
              for (var q = 63; q > 0 && o[q] == 0; q--)
                ;
              if (q == 0)
                return We(C), e;
              for (var K = 1, ye; K <= q; ) {
                for (var te = K; o[K] == 0 && K <= q; ++K)
                  ;
                var he = K - te;
                if (he >= j) {
                  ye = he >> 4;
                  for (var D = 1; D <= ye; ++D)
                    We(R);
                  he = he & 15;
                }
                B = 32767 + o[K], We(f[(he << 4) + b[B]]), We(s[B]), K++;
              }
              return q != H && We(C), e;
            }
            function Ce() {
              for (var G = String.fromCharCode, Ae = 0; Ae < 256; Ae++)
                J[Ae] = G(Ae);
            }
            this.encode = function(G, Ae) {
              (/* @__PURE__ */ new Date()).getTime(), Ae && ve(Ae), A = new Array(), T = 0, I = 7, $e(65496), Ge(), Ie(G.exifBuffer), Ne(), De(G.width, G.height), _e(), re();
              var e = 0, r = 0, f = 0;
              T = 0, I = 7, this.encode.displayName = "_encode_";
              for (var C = G.data, R = G.width, B = G.height, j = R * 4, H, X = 0, ue, pe, P, q, K, ye, te, he; X < B; ) {
                for (H = 0; H < j; ) {
                  for (q = j * X + H, K = q, ye = -1, te = 0, he = 0; he < 64; he++)
                    te = he >> 3, ye = (he & 7) * 4, K = q + te * j + ye, X + te >= B && (K -= j * (X + 1 + te - B)), H + ye >= j && (K -= H + ye - j + 4), ue = C[K++], pe = C[K++], P = C[K++], L[he] = (F[ue] + F[pe + 256 >> 0] + F[P + 512 >> 0] >> 16) - 128, z[he] = (F[ue + 768 >> 0] + F[pe + 1024 >> 0] + F[P + 1280 >> 0] >> 16) - 128, U[he] = (F[ue + 1280 >> 0] + F[pe + 1536 >> 0] + F[P + 1792 >> 0] >> 16) - 128;
                  e = $(L, a, e, d, h), r = $(z, n, r, g, m), f = $(U, n, f, g, m), H += 32;
                }
                X += 8;
              }
              if (I >= 0) {
                var D = [];
                D[1] = I + 1, D[0] = (1 << I + 1) - 1, We(D);
              }
              return $e(65497), typeof Z > "u" ? new Uint8Array(A) : new M(A);
            };
            function ve(G) {
              if (G <= 0 && (G = 1), G > 100 && (G = 100), oe != G) {
                var Ae = 0;
                G < 50 ? Ae = Math.floor(5e3 / G) : Ae = Math.floor(200 - G * 2), xe(Ae), oe = G;
              }
            }
            function Y() {
              var G = (/* @__PURE__ */ new Date()).getTime();
              E || (E = 50), Ce(), Pe(), Ue(), He(), ve(E), (/* @__PURE__ */ new Date()).getTime() - G;
            }
            Y();
          }
          typeof Z < "u" ? Z.exports = y : typeof ae < "u" && (ae["jpeg-js"] = ae["jpeg-js"] || {}, ae["jpeg-js"].encode = y);
          function y(E, c) {
            typeof c > "u" && (c = 50);
            var u = new x(c), l = u.encode(E, c);
            return {
              data: l,
              width: E.width,
              height: E.height
            };
          }
        }).call(this, k("buffer").Buffer);
      }, { buffer: 48 }], 83: [function(k, Z, _) {
        (function(M) {
          var x = k("path"), y = k("fs"), E = parseInt("0777", 8);
          Z.exports = c.mkdirp = c.mkdirP = c;
          function c(u, l, a, n) {
            typeof l == "function" ? (a = l, l = {}) : (!l || typeof l != "object") && (l = { mode: l });
            var d = l.mode, g = l.fs || y;
            d === void 0 && (d = E & ~M.umask()), n || (n = null);
            var h = a || function() {
            };
            u = x.resolve(u), g.mkdir(u, d, function(m) {
              if (!m)
                return n = n || u, h(null, n);
              switch (m.code) {
                case "ENOENT":
                  c(x.dirname(u), l, function(s, b) {
                    s ? h(s, b) : c(u, l, h, b);
                  });
                  break;
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                  g.stat(u, function(s, b) {
                    s || !b.isDirectory() ? h(m, n) : h(null, n);
                  });
                  break;
              }
            });
          }
          c.sync = function u(l, a, n) {
            (!a || typeof a != "object") && (a = { mode: a });
            var d = a.mode, g = a.fs || y;
            d === void 0 && (d = E & ~M.umask()), n || (n = null), l = x.resolve(l);
            try {
              g.mkdirSync(l, d), n = n || l;
            } catch (m) {
              switch (m.code) {
                case "ENOENT":
                  n = u(x.dirname(l), a, n), u(l, a, n);
                  break;
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                  var h;
                  try {
                    h = g.statSync(l);
                  } catch {
                    throw m;
                  }
                  if (!h.isDirectory()) throw m;
                  break;
              }
            }
            return n;
          };
        }).call(this, k("_process"));
      }, { _process: 133, fs: 47, path: 107 }], 84: [function(k, Z, _) {
        var M = Object.getOwnPropertySymbols, x = Object.prototype.hasOwnProperty, y = Object.prototype.propertyIsEnumerable;
        function E(u) {
          if (u == null)
            throw new TypeError("Object.assign cannot be called with null or undefined");
          return Object(u);
        }
        function c() {
          try {
            if (!Object.assign)
              return !1;
            var u = new String("abc");
            if (u[5] = "de", Object.getOwnPropertyNames(u)[0] === "5")
              return !1;
            for (var l = {}, a = 0; a < 10; a++)
              l["_" + String.fromCharCode(a)] = a;
            var n = Object.getOwnPropertyNames(l).map(function(g) {
              return l[g];
            });
            if (n.join("") !== "0123456789")
              return !1;
            var d = {};
            return "abcdefghijklmnopqrst".split("").forEach(function(g) {
              d[g] = g;
            }), Object.keys(Object.assign({}, d)).join("") === "abcdefghijklmnopqrst";
          } catch {
            return !1;
          }
        }
        Z.exports = c() ? Object.assign : function(u, l) {
          for (var a, n = E(u), d, g = 1; g < arguments.length; g++) {
            a = Object(arguments[g]);
            for (var h in a)
              x.call(a, h) && (n[h] = a[h]);
            if (M) {
              d = M(a);
              for (var m = 0; m < d.length; m++)
                y.call(a, d[m]) && (n[d[m]] = a[d[m]]);
            }
          }
          return n;
        };
      }, {}], 85: [function(k, Z, _) {
        arguments[4][64][0].apply(_, arguments);
      }, { dup: 64 }], 86: [function(k, Z, _) {
        var M = k("./lib/utils/common").assign, x = k("./lib/deflate"), y = k("./lib/inflate"), E = k("./lib/zlib/constants"), c = {};
        M(c, x, y, E), Z.exports = c;
      }, { "./lib/deflate": 87, "./lib/inflate": 88, "./lib/utils/common": 89, "./lib/zlib/constants": 92 }], 87: [function(k, Z, _) {
        var M = k("./zlib/deflate"), x = k("./utils/common"), y = k("./utils/strings"), E = k("./zlib/messages"), c = k("./zlib/zstream"), u = Object.prototype.toString, l = 0, a = 4, n = 0, d = 1, g = 2, h = -1, m = 0, s = 8;
        function b(T) {
          if (!(this instanceof b)) return new b(T);
          this.options = x.assign({
            level: h,
            method: s,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: m,
            to: ""
          }, T || {});
          var I = this.options;
          I.raw && I.windowBits > 0 ? I.windowBits = -I.windowBits : I.gzip && I.windowBits > 0 && I.windowBits < 16 && (I.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
          var L = M.deflateInit2(
            this.strm,
            I.level,
            I.method,
            I.windowBits,
            I.memLevel,
            I.strategy
          );
          if (L !== n)
            throw new Error(E[L]);
          if (I.header && M.deflateSetHeader(this.strm, I.header), I.dictionary) {
            var z;
            if (typeof I.dictionary == "string" ? z = y.string2buf(I.dictionary) : u.call(I.dictionary) === "[object ArrayBuffer]" ? z = new Uint8Array(I.dictionary) : z = I.dictionary, L = M.deflateSetDictionary(this.strm, z), L !== n)
              throw new Error(E[L]);
            this._dict_set = !0;
          }
        }
        b.prototype.push = function(T, I) {
          var L = this.strm, z = this.options.chunkSize, U, J;
          if (this.ended)
            return !1;
          J = I === ~~I ? I : I === !0 ? a : l, typeof T == "string" ? L.input = y.string2buf(T) : u.call(T) === "[object ArrayBuffer]" ? L.input = new Uint8Array(T) : L.input = T, L.next_in = 0, L.avail_in = L.input.length;
          do {
            if (L.avail_out === 0 && (L.output = new x.Buf8(z), L.next_out = 0, L.avail_out = z), U = M.deflate(L, J), U !== d && U !== n)
              return this.onEnd(U), this.ended = !0, !1;
            (L.avail_out === 0 || L.avail_in === 0 && (J === a || J === g)) && (this.options.to === "string" ? this.onData(y.buf2binstring(x.shrinkBuf(L.output, L.next_out))) : this.onData(x.shrinkBuf(L.output, L.next_out)));
          } while ((L.avail_in > 0 || L.avail_out === 0) && U !== d);
          return J === a ? (U = M.deflateEnd(this.strm), this.onEnd(U), this.ended = !0, U === n) : (J === g && (this.onEnd(n), L.avail_out = 0), !0);
        }, b.prototype.onData = function(T) {
          this.chunks.push(T);
        }, b.prototype.onEnd = function(T) {
          T === n && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = x.flattenChunks(this.chunks)), this.chunks = [], this.err = T, this.msg = this.strm.msg;
        };
        function S(T, I) {
          var L = new b(I);
          if (L.push(T, !0), L.err)
            throw L.msg || E[L.err];
          return L.result;
        }
        function o(T, I) {
          return I = I || {}, I.raw = !0, S(T, I);
        }
        function A(T, I) {
          return I = I || {}, I.gzip = !0, S(T, I);
        }
        _.Deflate = b, _.deflate = S, _.deflateRaw = o, _.gzip = A;
      }, { "./utils/common": 89, "./utils/strings": 90, "./zlib/deflate": 94, "./zlib/messages": 99, "./zlib/zstream": 101 }], 88: [function(k, Z, _) {
        var M = k("./zlib/inflate"), x = k("./utils/common"), y = k("./utils/strings"), E = k("./zlib/constants"), c = k("./zlib/messages"), u = k("./zlib/zstream"), l = k("./zlib/gzheader"), a = Object.prototype.toString;
        function n(h) {
          if (!(this instanceof n)) return new n(h);
          this.options = x.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, h || {});
          var m = this.options;
          m.raw && m.windowBits >= 0 && m.windowBits < 16 && (m.windowBits = -m.windowBits, m.windowBits === 0 && (m.windowBits = -15)), m.windowBits >= 0 && m.windowBits < 16 && !(h && h.windowBits) && (m.windowBits += 32), m.windowBits > 15 && m.windowBits < 48 && (m.windowBits & 15) === 0 && (m.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
          var s = M.inflateInit2(
            this.strm,
            m.windowBits
          );
          if (s !== E.Z_OK)
            throw new Error(c[s]);
          this.header = new l(), M.inflateGetHeader(this.strm, this.header);
        }
        n.prototype.push = function(h, m) {
          var s = this.strm, b = this.options.chunkSize, S = this.options.dictionary, o, A, T, I, L, z, U = !1;
          if (this.ended)
            return !1;
          A = m === ~~m ? m : m === !0 ? E.Z_FINISH : E.Z_NO_FLUSH, typeof h == "string" ? s.input = y.binstring2buf(h) : a.call(h) === "[object ArrayBuffer]" ? s.input = new Uint8Array(h) : s.input = h, s.next_in = 0, s.avail_in = s.input.length;
          do {
            if (s.avail_out === 0 && (s.output = new x.Buf8(b), s.next_out = 0, s.avail_out = b), o = M.inflate(s, E.Z_NO_FLUSH), o === E.Z_NEED_DICT && S && (typeof S == "string" ? z = y.string2buf(S) : a.call(S) === "[object ArrayBuffer]" ? z = new Uint8Array(S) : z = S, o = M.inflateSetDictionary(this.strm, z)), o === E.Z_BUF_ERROR && U === !0 && (o = E.Z_OK, U = !1), o !== E.Z_STREAM_END && o !== E.Z_OK)
              return this.onEnd(o), this.ended = !0, !1;
            s.next_out && (s.avail_out === 0 || o === E.Z_STREAM_END || s.avail_in === 0 && (A === E.Z_FINISH || A === E.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (T = y.utf8border(s.output, s.next_out), I = s.next_out - T, L = y.buf2string(s.output, T), s.next_out = I, s.avail_out = b - I, I && x.arraySet(s.output, s.output, T, I, 0), this.onData(L)) : this.onData(x.shrinkBuf(s.output, s.next_out))), s.avail_in === 0 && s.avail_out === 0 && (U = !0);
          } while ((s.avail_in > 0 || s.avail_out === 0) && o !== E.Z_STREAM_END);
          return o === E.Z_STREAM_END && (A = E.Z_FINISH), A === E.Z_FINISH ? (o = M.inflateEnd(this.strm), this.onEnd(o), this.ended = !0, o === E.Z_OK) : (A === E.Z_SYNC_FLUSH && (this.onEnd(E.Z_OK), s.avail_out = 0), !0);
        }, n.prototype.onData = function(h) {
          this.chunks.push(h);
        }, n.prototype.onEnd = function(h) {
          h === E.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = x.flattenChunks(this.chunks)), this.chunks = [], this.err = h, this.msg = this.strm.msg;
        };
        function d(h, m) {
          var s = new n(m);
          if (s.push(h, !0), s.err)
            throw s.msg || c[s.err];
          return s.result;
        }
        function g(h, m) {
          return m = m || {}, m.raw = !0, d(h, m);
        }
        _.Inflate = n, _.inflate = d, _.inflateRaw = g, _.ungzip = d;
      }, { "./utils/common": 89, "./utils/strings": 90, "./zlib/constants": 92, "./zlib/gzheader": 95, "./zlib/inflate": 97, "./zlib/messages": 99, "./zlib/zstream": 101 }], 89: [function(k, Z, _) {
        arguments[4][36][0].apply(_, arguments);
      }, { dup: 36 }], 90: [function(k, Z, _) {
        var M = k("./common"), x = !0, y = !0;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch {
          x = !1;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          y = !1;
        }
        for (var E = new M.Buf8(256), c = 0; c < 256; c++)
          E[c] = c >= 252 ? 6 : c >= 248 ? 5 : c >= 240 ? 4 : c >= 224 ? 3 : c >= 192 ? 2 : 1;
        E[254] = E[254] = 1, _.string2buf = function(l) {
          var a, n, d, g, h, m = l.length, s = 0;
          for (g = 0; g < m; g++)
            n = l.charCodeAt(g), (n & 64512) === 55296 && g + 1 < m && (d = l.charCodeAt(g + 1), (d & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (d - 56320), g++)), s += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
          for (a = new M.Buf8(s), h = 0, g = 0; h < s; g++)
            n = l.charCodeAt(g), (n & 64512) === 55296 && g + 1 < m && (d = l.charCodeAt(g + 1), (d & 64512) === 56320 && (n = 65536 + (n - 55296 << 10) + (d - 56320), g++)), n < 128 ? a[h++] = n : n < 2048 ? (a[h++] = 192 | n >>> 6, a[h++] = 128 | n & 63) : n < 65536 ? (a[h++] = 224 | n >>> 12, a[h++] = 128 | n >>> 6 & 63, a[h++] = 128 | n & 63) : (a[h++] = 240 | n >>> 18, a[h++] = 128 | n >>> 12 & 63, a[h++] = 128 | n >>> 6 & 63, a[h++] = 128 | n & 63);
          return a;
        };
        function u(l, a) {
          if (a < 65537 && (l.subarray && y || !l.subarray && x))
            return String.fromCharCode.apply(null, M.shrinkBuf(l, a));
          for (var n = "", d = 0; d < a; d++)
            n += String.fromCharCode(l[d]);
          return n;
        }
        _.buf2binstring = function(l) {
          return u(l, l.length);
        }, _.binstring2buf = function(l) {
          for (var a = new M.Buf8(l.length), n = 0, d = a.length; n < d; n++)
            a[n] = l.charCodeAt(n);
          return a;
        }, _.buf2string = function(l, a) {
          var n, d, g, h, m = a || l.length, s = new Array(m * 2);
          for (d = 0, n = 0; n < m; ) {
            if (g = l[n++], g < 128) {
              s[d++] = g;
              continue;
            }
            if (h = E[g], h > 4) {
              s[d++] = 65533, n += h - 1;
              continue;
            }
            for (g &= h === 2 ? 31 : h === 3 ? 15 : 7; h > 1 && n < m; )
              g = g << 6 | l[n++] & 63, h--;
            if (h > 1) {
              s[d++] = 65533;
              continue;
            }
            g < 65536 ? s[d++] = g : (g -= 65536, s[d++] = 55296 | g >> 10 & 1023, s[d++] = 56320 | g & 1023);
          }
          return u(s, d);
        }, _.utf8border = function(l, a) {
          var n;
          for (a = a || l.length, a > l.length && (a = l.length), n = a - 1; n >= 0 && (l[n] & 192) === 128; )
            n--;
          return n < 0 || n === 0 ? a : n + E[l[n]] > a ? n : a;
        };
      }, { "./common": 89 }], 91: [function(k, Z, _) {
        arguments[4][37][0].apply(_, arguments);
      }, { dup: 37 }], 92: [function(k, Z, _) {
        arguments[4][38][0].apply(_, arguments);
      }, { dup: 38 }], 93: [function(k, Z, _) {
        arguments[4][39][0].apply(_, arguments);
      }, { dup: 39 }], 94: [function(k, Z, _) {
        var M = k("../utils/common"), x = k("./trees"), y = k("./adler32"), E = k("./crc32"), c = k("./messages"), u = 0, l = 1, a = 3, n = 4, d = 5, g = 0, h = 1, m = -2, s = -3, b = -5, S = -1, o = 1, A = 2, T = 3, I = 4, L = 0, z = 2, U = 8, J = 9, F = 15, oe = 8, ee = 29, ie = 256, W = ie + 1 + ee, Q = 30, de = 19, we = 2 * W + 1, ke = 15, Me = 3, fe = 258, xe = fe + Me + 1, Ee = 32, Pe = 42, Ue = 69, He = 73, We = 91, Ze = 103, $e = 113, Ve = 666, Ge = 1, Ie = 2, De = 3, Ne = 4, _e = 3;
        function re(v, se) {
          return v.msg = c[se], se;
        }
        function $(v) {
          return (v << 1) - (v > 4 ? 9 : 0);
        }
        function Ce(v) {
          for (var se = v.length; --se >= 0; )
            v[se] = 0;
        }
        function ve(v) {
          var se = v.state, me = se.pending;
          me > v.avail_out && (me = v.avail_out), me !== 0 && (M.arraySet(v.output, se.pending_buf, se.pending_out, me, v.next_out), v.next_out += me, se.pending_out += me, v.total_out += me, v.avail_out -= me, se.pending -= me, se.pending === 0 && (se.pending_out = 0));
        }
        function Y(v, se) {
          x._tr_flush_block(v, v.block_start >= 0 ? v.block_start : -1, v.strstart - v.block_start, se), v.block_start = v.strstart, ve(v.strm);
        }
        function G(v, se) {
          v.pending_buf[v.pending++] = se;
        }
        function Ae(v, se) {
          v.pending_buf[v.pending++] = se >>> 8 & 255, v.pending_buf[v.pending++] = se & 255;
        }
        function e(v, se, me, O) {
          var ce = v.avail_in;
          return ce > O && (ce = O), ce === 0 ? 0 : (v.avail_in -= ce, M.arraySet(se, v.input, v.next_in, ce, me), v.state.wrap === 1 ? v.adler = y(v.adler, se, ce, me) : v.state.wrap === 2 && (v.adler = E(v.adler, se, ce, me)), v.next_in += ce, v.total_in += ce, ce);
        }
        function r(v, se) {
          var me = v.max_chain_length, O = v.strstart, ce, Oe, Be = v.prev_length, je = v.nice_match, Fe = v.strstart > v.w_size - xe ? v.strstart - (v.w_size - xe) : 0, Ye = v.window, Ke = v.w_mask, et = v.prev, Je = v.strstart + fe, nt = Ye[O + Be - 1], dt = Ye[O + Be];
          v.prev_length >= v.good_match && (me >>= 2), je > v.lookahead && (je = v.lookahead);
          do
            if (ce = se, !(Ye[ce + Be] !== dt || Ye[ce + Be - 1] !== nt || Ye[ce] !== Ye[O] || Ye[++ce] !== Ye[O + 1])) {
              O += 2, ce++;
              do
                ;
              while (Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && Ye[++O] === Ye[++ce] && O < Je);
              if (Oe = fe - (Je - O), O = Je - fe, Oe > Be) {
                if (v.match_start = se, Be = Oe, Oe >= je)
                  break;
                nt = Ye[O + Be - 1], dt = Ye[O + Be];
              }
            }
          while ((se = et[se & Ke]) > Fe && --me !== 0);
          return Be <= v.lookahead ? Be : v.lookahead;
        }
        function f(v) {
          var se = v.w_size, me, O, ce, Oe, Be;
          do {
            if (Oe = v.window_size - v.lookahead - v.strstart, v.strstart >= se + (se - xe)) {
              M.arraySet(v.window, v.window, se, se, 0), v.match_start -= se, v.strstart -= se, v.block_start -= se, O = v.hash_size, me = O;
              do
                ce = v.head[--me], v.head[me] = ce >= se ? ce - se : 0;
              while (--O);
              O = se, me = O;
              do
                ce = v.prev[--me], v.prev[me] = ce >= se ? ce - se : 0;
              while (--O);
              Oe += se;
            }
            if (v.strm.avail_in === 0)
              break;
            if (O = e(v.strm, v.window, v.strstart + v.lookahead, Oe), v.lookahead += O, v.lookahead + v.insert >= Me)
              for (Be = v.strstart - v.insert, v.ins_h = v.window[Be], v.ins_h = (v.ins_h << v.hash_shift ^ v.window[Be + 1]) & v.hash_mask; v.insert && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[Be + Me - 1]) & v.hash_mask, v.prev[Be & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = Be, Be++, v.insert--, !(v.lookahead + v.insert < Me)); )
                ;
          } while (v.lookahead < xe && v.strm.avail_in !== 0);
        }
        function C(v, se) {
          var me = 65535;
          for (me > v.pending_buf_size - 5 && (me = v.pending_buf_size - 5); ; ) {
            if (v.lookahead <= 1) {
              if (f(v), v.lookahead === 0 && se === u)
                return Ge;
              if (v.lookahead === 0)
                break;
            }
            v.strstart += v.lookahead, v.lookahead = 0;
            var O = v.block_start + me;
            if ((v.strstart === 0 || v.strstart >= O) && (v.lookahead = v.strstart - O, v.strstart = O, Y(v, !1), v.strm.avail_out === 0) || v.strstart - v.block_start >= v.w_size - xe && (Y(v, !1), v.strm.avail_out === 0))
              return Ge;
          }
          return v.insert = 0, se === n ? (Y(v, !0), v.strm.avail_out === 0 ? De : Ne) : (v.strstart > v.block_start && (Y(v, !1), v.strm.avail_out === 0), Ge);
        }
        function R(v, se) {
          for (var me, O; ; ) {
            if (v.lookahead < xe) {
              if (f(v), v.lookahead < xe && se === u)
                return Ge;
              if (v.lookahead === 0)
                break;
            }
            if (me = 0, v.lookahead >= Me && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + Me - 1]) & v.hash_mask, me = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart), me !== 0 && v.strstart - me <= v.w_size - xe && (v.match_length = r(v, me)), v.match_length >= Me)
              if (O = x._tr_tally(v, v.strstart - v.match_start, v.match_length - Me), v.lookahead -= v.match_length, v.match_length <= v.max_lazy_match && v.lookahead >= Me) {
                v.match_length--;
                do
                  v.strstart++, v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + Me - 1]) & v.hash_mask, me = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart;
                while (--v.match_length !== 0);
                v.strstart++;
              } else
                v.strstart += v.match_length, v.match_length = 0, v.ins_h = v.window[v.strstart], v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + 1]) & v.hash_mask;
            else
              O = x._tr_tally(v, 0, v.window[v.strstart]), v.lookahead--, v.strstart++;
            if (O && (Y(v, !1), v.strm.avail_out === 0))
              return Ge;
          }
          return v.insert = v.strstart < Me - 1 ? v.strstart : Me - 1, se === n ? (Y(v, !0), v.strm.avail_out === 0 ? De : Ne) : v.last_lit && (Y(v, !1), v.strm.avail_out === 0) ? Ge : Ie;
        }
        function B(v, se) {
          for (var me, O, ce; ; ) {
            if (v.lookahead < xe) {
              if (f(v), v.lookahead < xe && se === u)
                return Ge;
              if (v.lookahead === 0)
                break;
            }
            if (me = 0, v.lookahead >= Me && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + Me - 1]) & v.hash_mask, me = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart), v.prev_length = v.match_length, v.prev_match = v.match_start, v.match_length = Me - 1, me !== 0 && v.prev_length < v.max_lazy_match && v.strstart - me <= v.w_size - xe && (v.match_length = r(v, me), v.match_length <= 5 && (v.strategy === o || v.match_length === Me && v.strstart - v.match_start > 4096) && (v.match_length = Me - 1)), v.prev_length >= Me && v.match_length <= v.prev_length) {
              ce = v.strstart + v.lookahead - Me, O = x._tr_tally(v, v.strstart - 1 - v.prev_match, v.prev_length - Me), v.lookahead -= v.prev_length - 1, v.prev_length -= 2;
              do
                ++v.strstart <= ce && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + Me - 1]) & v.hash_mask, me = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart);
              while (--v.prev_length !== 0);
              if (v.match_available = 0, v.match_length = Me - 1, v.strstart++, O && (Y(v, !1), v.strm.avail_out === 0))
                return Ge;
            } else if (v.match_available) {
              if (O = x._tr_tally(v, 0, v.window[v.strstart - 1]), O && Y(v, !1), v.strstart++, v.lookahead--, v.strm.avail_out === 0)
                return Ge;
            } else
              v.match_available = 1, v.strstart++, v.lookahead--;
          }
          return v.match_available && (O = x._tr_tally(v, 0, v.window[v.strstart - 1]), v.match_available = 0), v.insert = v.strstart < Me - 1 ? v.strstart : Me - 1, se === n ? (Y(v, !0), v.strm.avail_out === 0 ? De : Ne) : v.last_lit && (Y(v, !1), v.strm.avail_out === 0) ? Ge : Ie;
        }
        function j(v, se) {
          for (var me, O, ce, Oe, Be = v.window; ; ) {
            if (v.lookahead <= fe) {
              if (f(v), v.lookahead <= fe && se === u)
                return Ge;
              if (v.lookahead === 0)
                break;
            }
            if (v.match_length = 0, v.lookahead >= Me && v.strstart > 0 && (ce = v.strstart - 1, O = Be[ce], O === Be[++ce] && O === Be[++ce] && O === Be[++ce])) {
              Oe = v.strstart + fe;
              do
                ;
              while (O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && O === Be[++ce] && ce < Oe);
              v.match_length = fe - (Oe - ce), v.match_length > v.lookahead && (v.match_length = v.lookahead);
            }
            if (v.match_length >= Me ? (me = x._tr_tally(v, 1, v.match_length - Me), v.lookahead -= v.match_length, v.strstart += v.match_length, v.match_length = 0) : (me = x._tr_tally(v, 0, v.window[v.strstart]), v.lookahead--, v.strstart++), me && (Y(v, !1), v.strm.avail_out === 0))
              return Ge;
          }
          return v.insert = 0, se === n ? (Y(v, !0), v.strm.avail_out === 0 ? De : Ne) : v.last_lit && (Y(v, !1), v.strm.avail_out === 0) ? Ge : Ie;
        }
        function H(v, se) {
          for (var me; ; ) {
            if (v.lookahead === 0 && (f(v), v.lookahead === 0)) {
              if (se === u)
                return Ge;
              break;
            }
            if (v.match_length = 0, me = x._tr_tally(v, 0, v.window[v.strstart]), v.lookahead--, v.strstart++, me && (Y(v, !1), v.strm.avail_out === 0))
              return Ge;
          }
          return v.insert = 0, se === n ? (Y(v, !0), v.strm.avail_out === 0 ? De : Ne) : v.last_lit && (Y(v, !1), v.strm.avail_out === 0) ? Ge : Ie;
        }
        function X(v, se, me, O, ce) {
          this.good_length = v, this.max_lazy = se, this.nice_length = me, this.max_chain = O, this.func = ce;
        }
        var ue;
        ue = [
          /*      good lazy nice chain */
          new X(0, 0, 0, 0, C),
          /* 0 store only */
          new X(4, 4, 8, 4, R),
          /* 1 max speed, no lazy matches */
          new X(4, 5, 16, 8, R),
          /* 2 */
          new X(4, 6, 32, 32, R),
          /* 3 */
          new X(4, 4, 16, 16, B),
          /* 4 lazy matches */
          new X(8, 16, 32, 32, B),
          /* 5 */
          new X(8, 16, 128, 128, B),
          /* 6 */
          new X(8, 32, 128, 256, B),
          /* 7 */
          new X(32, 128, 258, 1024, B),
          /* 8 */
          new X(32, 258, 258, 4096, B)
          /* 9 max compression */
        ];
        function pe(v) {
          v.window_size = 2 * v.w_size, Ce(v.head), v.max_lazy_match = ue[v.level].max_lazy, v.good_match = ue[v.level].good_length, v.nice_match = ue[v.level].nice_length, v.max_chain_length = ue[v.level].max_chain, v.strstart = 0, v.block_start = 0, v.lookahead = 0, v.insert = 0, v.match_length = v.prev_length = Me - 1, v.match_available = 0, v.ins_h = 0;
        }
        function P() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = U, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new M.Buf16(we * 2), this.dyn_dtree = new M.Buf16((2 * Q + 1) * 2), this.bl_tree = new M.Buf16((2 * de + 1) * 2), Ce(this.dyn_ltree), Ce(this.dyn_dtree), Ce(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new M.Buf16(ke + 1), this.heap = new M.Buf16(2 * W + 1), Ce(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new M.Buf16(2 * W + 1), Ce(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function q(v) {
          var se;
          return !v || !v.state ? re(v, m) : (v.total_in = v.total_out = 0, v.data_type = z, se = v.state, se.pending = 0, se.pending_out = 0, se.wrap < 0 && (se.wrap = -se.wrap), se.status = se.wrap ? Pe : $e, v.adler = se.wrap === 2 ? 0 : 1, se.last_flush = u, x._tr_init(se), g);
        }
        function K(v) {
          var se = q(v);
          return se === g && pe(v.state), se;
        }
        function ye(v, se) {
          return !v || !v.state || v.state.wrap !== 2 ? m : (v.state.gzhead = se, g);
        }
        function te(v, se, me, O, ce, Oe) {
          if (!v)
            return m;
          var Be = 1;
          if (se === S && (se = 6), O < 0 ? (Be = 0, O = -O) : O > 15 && (Be = 2, O -= 16), ce < 1 || ce > J || me !== U || O < 8 || O > 15 || se < 0 || se > 9 || Oe < 0 || Oe > I)
            return re(v, m);
          O === 8 && (O = 9);
          var je = new P();
          return v.state = je, je.strm = v, je.wrap = Be, je.gzhead = null, je.w_bits = O, je.w_size = 1 << je.w_bits, je.w_mask = je.w_size - 1, je.hash_bits = ce + 7, je.hash_size = 1 << je.hash_bits, je.hash_mask = je.hash_size - 1, je.hash_shift = ~~((je.hash_bits + Me - 1) / Me), je.window = new M.Buf8(je.w_size * 2), je.head = new M.Buf16(je.hash_size), je.prev = new M.Buf16(je.w_size), je.lit_bufsize = 1 << ce + 6, je.pending_buf_size = je.lit_bufsize * 4, je.pending_buf = new M.Buf8(je.pending_buf_size), je.d_buf = 1 * je.lit_bufsize, je.l_buf = 3 * je.lit_bufsize, je.level = se, je.strategy = Oe, je.method = me, K(v);
        }
        function he(v, se) {
          return te(v, se, U, F, oe, L);
        }
        function D(v, se) {
          var me, O, ce, Oe;
          if (!v || !v.state || se > d || se < 0)
            return v ? re(v, m) : m;
          if (O = v.state, !v.output || !v.input && v.avail_in !== 0 || O.status === Ve && se !== n)
            return re(v, v.avail_out === 0 ? b : m);
          if (O.strm = v, me = O.last_flush, O.last_flush = se, O.status === Pe)
            if (O.wrap === 2)
              v.adler = 0, G(O, 31), G(O, 139), G(O, 8), O.gzhead ? (G(
                O,
                (O.gzhead.text ? 1 : 0) + (O.gzhead.hcrc ? 2 : 0) + (O.gzhead.extra ? 4 : 0) + (O.gzhead.name ? 8 : 0) + (O.gzhead.comment ? 16 : 0)
              ), G(O, O.gzhead.time & 255), G(O, O.gzhead.time >> 8 & 255), G(O, O.gzhead.time >> 16 & 255), G(O, O.gzhead.time >> 24 & 255), G(O, O.level === 9 ? 2 : O.strategy >= A || O.level < 2 ? 4 : 0), G(O, O.gzhead.os & 255), O.gzhead.extra && O.gzhead.extra.length && (G(O, O.gzhead.extra.length & 255), G(O, O.gzhead.extra.length >> 8 & 255)), O.gzhead.hcrc && (v.adler = E(v.adler, O.pending_buf, O.pending, 0)), O.gzindex = 0, O.status = Ue) : (G(O, 0), G(O, 0), G(O, 0), G(O, 0), G(O, 0), G(O, O.level === 9 ? 2 : O.strategy >= A || O.level < 2 ? 4 : 0), G(O, _e), O.status = $e);
            else {
              var Be = U + (O.w_bits - 8 << 4) << 8, je = -1;
              O.strategy >= A || O.level < 2 ? je = 0 : O.level < 6 ? je = 1 : O.level === 6 ? je = 2 : je = 3, Be |= je << 6, O.strstart !== 0 && (Be |= Ee), Be += 31 - Be % 31, O.status = $e, Ae(O, Be), O.strstart !== 0 && (Ae(O, v.adler >>> 16), Ae(O, v.adler & 65535)), v.adler = 1;
            }
          if (O.status === Ue)
            if (O.gzhead.extra) {
              for (ce = O.pending; O.gzindex < (O.gzhead.extra.length & 65535) && !(O.pending === O.pending_buf_size && (O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), ve(v), ce = O.pending, O.pending === O.pending_buf_size)); )
                G(O, O.gzhead.extra[O.gzindex] & 255), O.gzindex++;
              O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), O.gzindex === O.gzhead.extra.length && (O.gzindex = 0, O.status = He);
            } else
              O.status = He;
          if (O.status === He)
            if (O.gzhead.name) {
              ce = O.pending;
              do {
                if (O.pending === O.pending_buf_size && (O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), ve(v), ce = O.pending, O.pending === O.pending_buf_size)) {
                  Oe = 1;
                  break;
                }
                O.gzindex < O.gzhead.name.length ? Oe = O.gzhead.name.charCodeAt(O.gzindex++) & 255 : Oe = 0, G(O, Oe);
              } while (Oe !== 0);
              O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), Oe === 0 && (O.gzindex = 0, O.status = We);
            } else
              O.status = We;
          if (O.status === We)
            if (O.gzhead.comment) {
              ce = O.pending;
              do {
                if (O.pending === O.pending_buf_size && (O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), ve(v), ce = O.pending, O.pending === O.pending_buf_size)) {
                  Oe = 1;
                  break;
                }
                O.gzindex < O.gzhead.comment.length ? Oe = O.gzhead.comment.charCodeAt(O.gzindex++) & 255 : Oe = 0, G(O, Oe);
              } while (Oe !== 0);
              O.gzhead.hcrc && O.pending > ce && (v.adler = E(v.adler, O.pending_buf, O.pending - ce, ce)), Oe === 0 && (O.status = Ze);
            } else
              O.status = Ze;
          if (O.status === Ze && (O.gzhead.hcrc ? (O.pending + 2 > O.pending_buf_size && ve(v), O.pending + 2 <= O.pending_buf_size && (G(O, v.adler & 255), G(O, v.adler >> 8 & 255), v.adler = 0, O.status = $e)) : O.status = $e), O.pending !== 0) {
            if (ve(v), v.avail_out === 0)
              return O.last_flush = -1, g;
          } else if (v.avail_in === 0 && $(se) <= $(me) && se !== n)
            return re(v, b);
          if (O.status === Ve && v.avail_in !== 0)
            return re(v, b);
          if (v.avail_in !== 0 || O.lookahead !== 0 || se !== u && O.status !== Ve) {
            var Fe = O.strategy === A ? H(O, se) : O.strategy === T ? j(O, se) : ue[O.level].func(O, se);
            if ((Fe === De || Fe === Ne) && (O.status = Ve), Fe === Ge || Fe === De)
              return v.avail_out === 0 && (O.last_flush = -1), g;
            if (Fe === Ie && (se === l ? x._tr_align(O) : se !== d && (x._tr_stored_block(O, 0, 0, !1), se === a && (Ce(O.head), O.lookahead === 0 && (O.strstart = 0, O.block_start = 0, O.insert = 0))), ve(v), v.avail_out === 0))
              return O.last_flush = -1, g;
          }
          return se !== n ? g : O.wrap <= 0 ? h : (O.wrap === 2 ? (G(O, v.adler & 255), G(O, v.adler >> 8 & 255), G(O, v.adler >> 16 & 255), G(O, v.adler >> 24 & 255), G(O, v.total_in & 255), G(O, v.total_in >> 8 & 255), G(O, v.total_in >> 16 & 255), G(O, v.total_in >> 24 & 255)) : (Ae(O, v.adler >>> 16), Ae(O, v.adler & 65535)), ve(v), O.wrap > 0 && (O.wrap = -O.wrap), O.pending !== 0 ? g : h);
        }
        function Se(v) {
          var se;
          return !v || !v.state ? m : (se = v.state.status, se !== Pe && se !== Ue && se !== He && se !== We && se !== Ze && se !== $e && se !== Ve ? re(v, m) : (v.state = null, se === $e ? re(v, s) : g));
        }
        function le(v, se) {
          var me = se.length, O, ce, Oe, Be, je, Fe, Ye, Ke;
          if (!v || !v.state || (O = v.state, Be = O.wrap, Be === 2 || Be === 1 && O.status !== Pe || O.lookahead))
            return m;
          for (Be === 1 && (v.adler = y(v.adler, se, me, 0)), O.wrap = 0, me >= O.w_size && (Be === 0 && (Ce(O.head), O.strstart = 0, O.block_start = 0, O.insert = 0), Ke = new M.Buf8(O.w_size), M.arraySet(Ke, se, me - O.w_size, O.w_size, 0), se = Ke, me = O.w_size), je = v.avail_in, Fe = v.next_in, Ye = v.input, v.avail_in = me, v.next_in = 0, v.input = se, f(O); O.lookahead >= Me; ) {
            ce = O.strstart, Oe = O.lookahead - (Me - 1);
            do
              O.ins_h = (O.ins_h << O.hash_shift ^ O.window[ce + Me - 1]) & O.hash_mask, O.prev[ce & O.w_mask] = O.head[O.ins_h], O.head[O.ins_h] = ce, ce++;
            while (--Oe);
            O.strstart = ce, O.lookahead = Me - 1, f(O);
          }
          return O.strstart += O.lookahead, O.block_start = O.strstart, O.insert = O.lookahead, O.lookahead = 0, O.match_length = O.prev_length = Me - 1, O.match_available = 0, v.next_in = Fe, v.input = Ye, v.avail_in = je, O.wrap = Be, g;
        }
        _.deflateInit = he, _.deflateInit2 = te, _.deflateReset = K, _.deflateResetKeep = q, _.deflateSetHeader = ye, _.deflate = D, _.deflateEnd = Se, _.deflateSetDictionary = le, _.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 89, "./adler32": 91, "./crc32": 93, "./messages": 99, "./trees": 100 }], 95: [function(k, Z, _) {
        function M() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
        }
        Z.exports = M;
      }, {}], 96: [function(k, Z, _) {
        arguments[4][41][0].apply(_, arguments);
      }, { dup: 41 }], 97: [function(k, Z, _) {
        arguments[4][42][0].apply(_, arguments);
      }, { "../utils/common": 89, "./adler32": 91, "./crc32": 93, "./inffast": 96, "./inftrees": 98, dup: 42 }], 98: [function(k, Z, _) {
        arguments[4][43][0].apply(_, arguments);
      }, { "../utils/common": 89, dup: 43 }], 99: [function(k, Z, _) {
        arguments[4][44][0].apply(_, arguments);
      }, { dup: 44 }], 100: [function(k, Z, _) {
        var M = k("../utils/common"), x = 4, y = 0, E = 1, c = 2;
        function u(P) {
          for (var q = P.length; --q >= 0; )
            P[q] = 0;
        }
        var l = 0, a = 1, n = 2, d = 3, g = 258, h = 29, m = 256, s = m + 1 + h, b = 30, S = 19, o = 2 * s + 1, A = 15, T = 16, I = 7, L = 256, z = 16, U = 17, J = 18, F = (
          /* extra bits for each length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
        ), oe = (
          /* extra bits for each distance code */
          [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
        ), ee = (
          /* extra bits for each bit length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
        ), ie = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], W = 512, Q = new Array((s + 2) * 2);
        u(Q);
        var de = new Array(b * 2);
        u(de);
        var we = new Array(W);
        u(we);
        var ke = new Array(g - d + 1);
        u(ke);
        var Me = new Array(h);
        u(Me);
        var fe = new Array(b);
        u(fe);
        function xe(P, q, K, ye, te) {
          this.static_tree = P, this.extra_bits = q, this.extra_base = K, this.elems = ye, this.max_length = te, this.has_stree = P && P.length;
        }
        var Ee, Pe, Ue;
        function He(P, q) {
          this.dyn_tree = P, this.max_code = 0, this.stat_desc = q;
        }
        function We(P) {
          return P < 256 ? we[P] : we[256 + (P >>> 7)];
        }
        function Ze(P, q) {
          P.pending_buf[P.pending++] = q & 255, P.pending_buf[P.pending++] = q >>> 8 & 255;
        }
        function $e(P, q, K) {
          P.bi_valid > T - K ? (P.bi_buf |= q << P.bi_valid & 65535, Ze(P, P.bi_buf), P.bi_buf = q >> T - P.bi_valid, P.bi_valid += K - T) : (P.bi_buf |= q << P.bi_valid & 65535, P.bi_valid += K);
        }
        function Ve(P, q, K) {
          $e(
            P,
            K[q * 2],
            K[q * 2 + 1]
            /*.Len*/
          );
        }
        function Ge(P, q) {
          var K = 0;
          do
            K |= P & 1, P >>>= 1, K <<= 1;
          while (--q > 0);
          return K >>> 1;
        }
        function Ie(P) {
          P.bi_valid === 16 ? (Ze(P, P.bi_buf), P.bi_buf = 0, P.bi_valid = 0) : P.bi_valid >= 8 && (P.pending_buf[P.pending++] = P.bi_buf & 255, P.bi_buf >>= 8, P.bi_valid -= 8);
        }
        function De(P, q) {
          var K = q.dyn_tree, ye = q.max_code, te = q.stat_desc.static_tree, he = q.stat_desc.has_stree, D = q.stat_desc.extra_bits, Se = q.stat_desc.extra_base, le = q.stat_desc.max_length, v, se, me, O, ce, Oe, Be = 0;
          for (O = 0; O <= A; O++)
            P.bl_count[O] = 0;
          for (K[P.heap[P.heap_max] * 2 + 1] = 0, v = P.heap_max + 1; v < o; v++)
            se = P.heap[v], O = K[K[se * 2 + 1] * 2 + 1] + 1, O > le && (O = le, Be++), K[se * 2 + 1] = O, !(se > ye) && (P.bl_count[O]++, ce = 0, se >= Se && (ce = D[se - Se]), Oe = K[se * 2], P.opt_len += Oe * (O + ce), he && (P.static_len += Oe * (te[se * 2 + 1] + ce)));
          if (Be !== 0) {
            do {
              for (O = le - 1; P.bl_count[O] === 0; )
                O--;
              P.bl_count[O]--, P.bl_count[O + 1] += 2, P.bl_count[le]--, Be -= 2;
            } while (Be > 0);
            for (O = le; O !== 0; O--)
              for (se = P.bl_count[O]; se !== 0; )
                me = P.heap[--v], !(me > ye) && (K[me * 2 + 1] !== O && (P.opt_len += (O - K[me * 2 + 1]) * K[me * 2], K[me * 2 + 1] = O), se--);
          }
        }
        function Ne(P, q, K) {
          var ye = new Array(A + 1), te = 0, he, D;
          for (he = 1; he <= A; he++)
            ye[he] = te = te + K[he - 1] << 1;
          for (D = 0; D <= q; D++) {
            var Se = P[D * 2 + 1];
            Se !== 0 && (P[D * 2] = Ge(ye[Se]++, Se));
          }
        }
        function _e() {
          var P, q, K, ye, te, he = new Array(A + 1);
          for (K = 0, ye = 0; ye < h - 1; ye++)
            for (Me[ye] = K, P = 0; P < 1 << F[ye]; P++)
              ke[K++] = ye;
          for (ke[K - 1] = ye, te = 0, ye = 0; ye < 16; ye++)
            for (fe[ye] = te, P = 0; P < 1 << oe[ye]; P++)
              we[te++] = ye;
          for (te >>= 7; ye < b; ye++)
            for (fe[ye] = te << 7, P = 0; P < 1 << oe[ye] - 7; P++)
              we[256 + te++] = ye;
          for (q = 0; q <= A; q++)
            he[q] = 0;
          for (P = 0; P <= 143; )
            Q[P * 2 + 1] = 8, P++, he[8]++;
          for (; P <= 255; )
            Q[P * 2 + 1] = 9, P++, he[9]++;
          for (; P <= 279; )
            Q[P * 2 + 1] = 7, P++, he[7]++;
          for (; P <= 287; )
            Q[P * 2 + 1] = 8, P++, he[8]++;
          for (Ne(Q, s + 1, he), P = 0; P < b; P++)
            de[P * 2 + 1] = 5, de[P * 2] = Ge(P, 5);
          Ee = new xe(Q, F, m + 1, s, A), Pe = new xe(de, oe, 0, b, A), Ue = new xe(new Array(0), ee, 0, S, I);
        }
        function re(P) {
          var q;
          for (q = 0; q < s; q++)
            P.dyn_ltree[q * 2] = 0;
          for (q = 0; q < b; q++)
            P.dyn_dtree[q * 2] = 0;
          for (q = 0; q < S; q++)
            P.bl_tree[q * 2] = 0;
          P.dyn_ltree[L * 2] = 1, P.opt_len = P.static_len = 0, P.last_lit = P.matches = 0;
        }
        function $(P) {
          P.bi_valid > 8 ? Ze(P, P.bi_buf) : P.bi_valid > 0 && (P.pending_buf[P.pending++] = P.bi_buf), P.bi_buf = 0, P.bi_valid = 0;
        }
        function Ce(P, q, K, ye) {
          $(P), Ze(P, K), Ze(P, ~K), M.arraySet(P.pending_buf, P.window, q, K, P.pending), P.pending += K;
        }
        function ve(P, q, K, ye) {
          var te = q * 2, he = K * 2;
          return P[te] < P[he] || P[te] === P[he] && ye[q] <= ye[K];
        }
        function Y(P, q, K) {
          for (var ye = P.heap[K], te = K << 1; te <= P.heap_len && (te < P.heap_len && ve(q, P.heap[te + 1], P.heap[te], P.depth) && te++, !ve(q, ye, P.heap[te], P.depth)); )
            P.heap[K] = P.heap[te], K = te, te <<= 1;
          P.heap[K] = ye;
        }
        function G(P, q, K) {
          var ye, te, he = 0, D, Se;
          if (P.last_lit !== 0)
            do
              ye = P.pending_buf[P.d_buf + he * 2] << 8 | P.pending_buf[P.d_buf + he * 2 + 1], te = P.pending_buf[P.l_buf + he], he++, ye === 0 ? Ve(P, te, q) : (D = ke[te], Ve(P, D + m + 1, q), Se = F[D], Se !== 0 && (te -= Me[D], $e(P, te, Se)), ye--, D = We(ye), Ve(P, D, K), Se = oe[D], Se !== 0 && (ye -= fe[D], $e(P, ye, Se)));
            while (he < P.last_lit);
          Ve(P, L, q);
        }
        function Ae(P, q) {
          var K = q.dyn_tree, ye = q.stat_desc.static_tree, te = q.stat_desc.has_stree, he = q.stat_desc.elems, D, Se, le = -1, v;
          for (P.heap_len = 0, P.heap_max = o, D = 0; D < he; D++)
            K[D * 2] !== 0 ? (P.heap[++P.heap_len] = le = D, P.depth[D] = 0) : K[D * 2 + 1] = 0;
          for (; P.heap_len < 2; )
            v = P.heap[++P.heap_len] = le < 2 ? ++le : 0, K[v * 2] = 1, P.depth[v] = 0, P.opt_len--, te && (P.static_len -= ye[v * 2 + 1]);
          for (q.max_code = le, D = P.heap_len >> 1; D >= 1; D--)
            Y(P, K, D);
          v = he;
          do
            D = P.heap[
              1
              /*SMALLEST*/
            ], P.heap[
              1
              /*SMALLEST*/
            ] = P.heap[P.heap_len--], Y(
              P,
              K,
              1
              /*SMALLEST*/
            ), Se = P.heap[
              1
              /*SMALLEST*/
            ], P.heap[--P.heap_max] = D, P.heap[--P.heap_max] = Se, K[v * 2] = K[D * 2] + K[Se * 2], P.depth[v] = (P.depth[D] >= P.depth[Se] ? P.depth[D] : P.depth[Se]) + 1, K[D * 2 + 1] = K[Se * 2 + 1] = v, P.heap[
              1
              /*SMALLEST*/
            ] = v++, Y(
              P,
              K,
              1
              /*SMALLEST*/
            );
          while (P.heap_len >= 2);
          P.heap[--P.heap_max] = P.heap[
            1
            /*SMALLEST*/
          ], De(P, q), Ne(K, le, P.bl_count);
        }
        function e(P, q, K) {
          var ye, te = -1, he, D = q[0 * 2 + 1], Se = 0, le = 7, v = 4;
          for (D === 0 && (le = 138, v = 3), q[(K + 1) * 2 + 1] = 65535, ye = 0; ye <= K; ye++)
            he = D, D = q[(ye + 1) * 2 + 1], !(++Se < le && he === D) && (Se < v ? P.bl_tree[he * 2] += Se : he !== 0 ? (he !== te && P.bl_tree[he * 2]++, P.bl_tree[z * 2]++) : Se <= 10 ? P.bl_tree[U * 2]++ : P.bl_tree[J * 2]++, Se = 0, te = he, D === 0 ? (le = 138, v = 3) : he === D ? (le = 6, v = 3) : (le = 7, v = 4));
        }
        function r(P, q, K) {
          var ye, te = -1, he, D = q[0 * 2 + 1], Se = 0, le = 7, v = 4;
          for (D === 0 && (le = 138, v = 3), ye = 0; ye <= K; ye++)
            if (he = D, D = q[(ye + 1) * 2 + 1], !(++Se < le && he === D)) {
              if (Se < v)
                do
                  Ve(P, he, P.bl_tree);
                while (--Se !== 0);
              else he !== 0 ? (he !== te && (Ve(P, he, P.bl_tree), Se--), Ve(P, z, P.bl_tree), $e(P, Se - 3, 2)) : Se <= 10 ? (Ve(P, U, P.bl_tree), $e(P, Se - 3, 3)) : (Ve(P, J, P.bl_tree), $e(P, Se - 11, 7));
              Se = 0, te = he, D === 0 ? (le = 138, v = 3) : he === D ? (le = 6, v = 3) : (le = 7, v = 4);
            }
        }
        function f(P) {
          var q;
          for (e(P, P.dyn_ltree, P.l_desc.max_code), e(P, P.dyn_dtree, P.d_desc.max_code), Ae(P, P.bl_desc), q = S - 1; q >= 3 && P.bl_tree[ie[q] * 2 + 1] === 0; q--)
            ;
          return P.opt_len += 3 * (q + 1) + 5 + 5 + 4, q;
        }
        function C(P, q, K, ye) {
          var te;
          for ($e(P, q - 257, 5), $e(P, K - 1, 5), $e(P, ye - 4, 4), te = 0; te < ye; te++)
            $e(P, P.bl_tree[ie[te] * 2 + 1], 3);
          r(P, P.dyn_ltree, q - 1), r(P, P.dyn_dtree, K - 1);
        }
        function R(P) {
          var q = 4093624447, K;
          for (K = 0; K <= 31; K++, q >>>= 1)
            if (q & 1 && P.dyn_ltree[K * 2] !== 0)
              return y;
          if (P.dyn_ltree[9 * 2] !== 0 || P.dyn_ltree[10 * 2] !== 0 || P.dyn_ltree[13 * 2] !== 0)
            return E;
          for (K = 32; K < m; K++)
            if (P.dyn_ltree[K * 2] !== 0)
              return E;
          return y;
        }
        var B = !1;
        function j(P) {
          B || (_e(), B = !0), P.l_desc = new He(P.dyn_ltree, Ee), P.d_desc = new He(P.dyn_dtree, Pe), P.bl_desc = new He(P.bl_tree, Ue), P.bi_buf = 0, P.bi_valid = 0, re(P);
        }
        function H(P, q, K, ye) {
          $e(P, (l << 1) + (ye ? 1 : 0), 3), Ce(P, q, K);
        }
        function X(P) {
          $e(P, a << 1, 3), Ve(P, L, Q), Ie(P);
        }
        function ue(P, q, K, ye) {
          var te, he, D = 0;
          P.level > 0 ? (P.strm.data_type === c && (P.strm.data_type = R(P)), Ae(P, P.l_desc), Ae(P, P.d_desc), D = f(P), te = P.opt_len + 3 + 7 >>> 3, he = P.static_len + 3 + 7 >>> 3, he <= te && (te = he)) : te = he = K + 5, K + 4 <= te && q !== -1 ? H(P, q, K, ye) : P.strategy === x || he === te ? ($e(P, (a << 1) + (ye ? 1 : 0), 3), G(P, Q, de)) : ($e(P, (n << 1) + (ye ? 1 : 0), 3), C(P, P.l_desc.max_code + 1, P.d_desc.max_code + 1, D + 1), G(P, P.dyn_ltree, P.dyn_dtree)), re(P), ye && $(P);
        }
        function pe(P, q, K) {
          return P.pending_buf[P.d_buf + P.last_lit * 2] = q >>> 8 & 255, P.pending_buf[P.d_buf + P.last_lit * 2 + 1] = q & 255, P.pending_buf[P.l_buf + P.last_lit] = K & 255, P.last_lit++, q === 0 ? P.dyn_ltree[K * 2]++ : (P.matches++, q--, P.dyn_ltree[(ke[K] + m + 1) * 2]++, P.dyn_dtree[We(q) * 2]++), P.last_lit === P.lit_bufsize - 1;
        }
        _._tr_init = j, _._tr_stored_block = H, _._tr_flush_block = ue, _._tr_tally = pe, _._tr_align = X;
      }, { "../utils/common": 89 }], 101: [function(k, Z, _) {
        arguments[4][46][0].apply(_, arguments);
      }, { dup: 46 }], 102: [function(k, Z, _) {
        Z.exports = function(c) {
          if (!c)
            throw new Error("no data provided");
          c = c.toString().trim();
          var u = {
            pages: [],
            chars: [],
            kernings: []
          }, l = c.split(/\r\n?|\n/g);
          if (l.length === 0)
            throw new Error("no data in BMFont file");
          for (var a = 0; a < l.length; a++) {
            var n = M(l[a], a);
            if (n)
              if (n.key === "page") {
                if (typeof n.data.id != "number")
                  throw new Error("malformed file at line " + a + " -- needs page id=N");
                if (typeof n.data.file != "string")
                  throw new Error("malformed file at line " + a + ' -- needs page file="path"');
                u.pages[n.data.id] = n.data.file;
              } else n.key === "chars" || n.key === "kernings" || (n.key === "char" ? u.chars.push(n.data) : n.key === "kerning" ? u.kernings.push(n.data) : u[n.key] = n.data);
          }
          return u;
        };
        function M(E, c) {
          if (E = E.replace(/\t+/g, " ").trim(), !E)
            return null;
          var u = E.indexOf(" ");
          if (u === -1)
            throw new Error("no named row at line " + c);
          var l = E.substring(0, u);
          E = E.substring(u + 1), E = E.replace(/letter=[\'\"]\S+[\'\"]/gi, ""), E = E.split("="), E = E.map(function(h) {
            return h.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
          });
          for (var a = [], n = 0; n < E.length; n++) {
            var d = E[n];
            n === 0 ? a.push({
              key: d[0],
              data: ""
            }) : n === E.length - 1 ? a[a.length - 1].data = x(d[0]) : (a[a.length - 1].data = x(d[0]), a.push({
              key: d[1],
              data: ""
            }));
          }
          var g = {
            key: l,
            data: {}
          };
          return a.forEach(function(h) {
            g.data[h.key] = h.data;
          }), g;
        }
        function x(E) {
          return !E || E.length === 0 ? "" : E.indexOf('"') === 0 || E.indexOf("'") === 0 ? E.substring(1, E.length - 1) : E.indexOf(",") !== -1 ? y(E) : parseInt(E, 10);
        }
        function y(E) {
          return E.split(",").map(function(c) {
            return parseInt(c, 10);
          });
        }
      }, {}], 103: [function(k, Z, _) {
        var M = [66, 77, 70];
        Z.exports = function(g) {
          if (g.length < 6)
            throw new Error("invalid buffer length for BMFont");
          var h = M.every(function(o, A) {
            return g.readUInt8(A) === o;
          });
          if (!h)
            throw new Error("BMFont missing BMF byte header");
          var m = 3, s = g.readUInt8(m++);
          if (s > 3)
            throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
          for (var b = { kernings: [], chars: [] }, S = 0; S < 5; S++)
            m += x(b, g, m);
          return b;
        };
        function x(d, g, h) {
          if (h > g.length - 1)
            return 0;
          var m = g.readUInt8(h++), s = g.readInt32LE(h);
          switch (h += 4, m) {
            case 1:
              d.info = y(g, h);
              break;
            case 2:
              d.common = E(g, h);
              break;
            case 3:
              d.pages = c(g, h, s);
              break;
            case 4:
              d.chars = u(g, h, s);
              break;
            case 5:
              d.kernings = l(g, h, s);
              break;
          }
          return 5 + s;
        }
        function y(d, g) {
          var h = {};
          h.size = d.readInt16LE(g);
          var m = d.readUInt8(g + 2);
          return h.smooth = m >> 7 & 1, h.unicode = m >> 6 & 1, h.italic = m >> 5 & 1, h.bold = m >> 4 & 1, m >> 3 & 1 && (h.fixedHeight = 1), h.charset = d.readUInt8(g + 3) || "", h.stretchH = d.readUInt16LE(g + 4), h.aa = d.readUInt8(g + 6), h.padding = [
            d.readInt8(g + 7),
            d.readInt8(g + 8),
            d.readInt8(g + 9),
            d.readInt8(g + 10)
          ], h.spacing = [
            d.readInt8(g + 11),
            d.readInt8(g + 12)
          ], h.outline = d.readUInt8(g + 13), h.face = n(d, g + 14), h;
        }
        function E(d, g) {
          var h = {};
          return h.lineHeight = d.readUInt16LE(g), h.base = d.readUInt16LE(g + 2), h.scaleW = d.readUInt16LE(g + 4), h.scaleH = d.readUInt16LE(g + 6), h.pages = d.readUInt16LE(g + 8), d.readUInt8(g + 10), h.packed = 0, h.alphaChnl = d.readUInt8(g + 11), h.redChnl = d.readUInt8(g + 12), h.greenChnl = d.readUInt8(g + 13), h.blueChnl = d.readUInt8(g + 14), h;
        }
        function c(d, g, h) {
          for (var m = [], s = a(d, g), b = s.length + 1, S = h / b, o = 0; o < S; o++)
            m[o] = d.slice(g, g + s.length).toString("utf8"), g += b;
          return m;
        }
        function u(d, g, h) {
          for (var m = [], s = h / 20, b = 0; b < s; b++) {
            var S = {}, o = b * 20;
            S.id = d.readUInt32LE(g + 0 + o), S.x = d.readUInt16LE(g + 4 + o), S.y = d.readUInt16LE(g + 6 + o), S.width = d.readUInt16LE(g + 8 + o), S.height = d.readUInt16LE(g + 10 + o), S.xoffset = d.readInt16LE(g + 12 + o), S.yoffset = d.readInt16LE(g + 14 + o), S.xadvance = d.readInt16LE(g + 16 + o), S.page = d.readUInt8(g + 18 + o), S.chnl = d.readUInt8(g + 19 + o), m[b] = S;
          }
          return m;
        }
        function l(d, g, h) {
          for (var m = [], s = h / 10, b = 0; b < s; b++) {
            var S = {}, o = b * 10;
            S.first = d.readUInt32LE(g + 0 + o), S.second = d.readUInt32LE(g + 4 + o), S.amount = d.readInt16LE(g + 8 + o), m[b] = S;
          }
          return m;
        }
        function a(d, g) {
          for (var h = g; h < d.length && d[h] !== 0; h++)
            ;
          return d.slice(g, h);
        }
        function n(d, g) {
          return a(d, g).toString("utf8");
        }
      }, {}], 104: [function(k, Z, _) {
        var M = k("./parse-attribs"), x = k("xml-parse-from-string"), y = {
          scaleh: "scaleH",
          scalew: "scaleW",
          stretchh: "stretchH",
          lineheight: "lineHeight",
          alphachnl: "alphaChnl",
          redchnl: "redChnl",
          greenchnl: "greenChnl",
          bluechnl: "blueChnl"
        };
        Z.exports = function(a) {
          a = a.toString();
          var n = x(a), d = {
            pages: [],
            chars: [],
            kernings: []
          };
          ["info", "common"].forEach(function(o) {
            var A = n.getElementsByTagName(o)[0];
            A && (d[o] = M(E(A)));
          });
          var g = n.getElementsByTagName("pages")[0];
          if (!g)
            throw new Error("malformed file -- no <pages> element");
          for (var h = g.getElementsByTagName("page"), m = 0; m < h.length; m++) {
            var s = h[m], b = parseInt(s.getAttribute("id"), 10), S = s.getAttribute("file");
            if (isNaN(b))
              throw new Error('malformed file -- page "id" attribute is NaN');
            if (!S)
              throw new Error('malformed file -- needs page "file" attribute');
            d.pages[parseInt(b, 10)] = S;
          }
          return ["chars", "kernings"].forEach(function(o) {
            var A = n.getElementsByTagName(o)[0];
            if (A)
              for (var T = o.substring(0, o.length - 1), I = A.getElementsByTagName(T), L = 0; L < I.length; L++) {
                var z = I[L];
                d[o].push(M(E(z)));
              }
          }), d;
        };
        function E(l) {
          var a = c(l);
          return a.reduce(function(n, d) {
            var g = u(d.nodeName);
            return n[g] = d.nodeValue, n;
          }, {});
        }
        function c(l) {
          for (var a = [], n = 0; n < l.attributes.length; n++)
            a.push(l.attributes[n]);
          return a;
        }
        function u(l) {
          return y[l.toLowerCase()] || l;
        }
      }, { "./parse-attribs": 105, "xml-parse-from-string": 188 }], 105: [function(k, Z, _) {
        var M = "chasrset";
        Z.exports = function(E) {
          M in E && (E.charset = E[M], delete E[M]);
          for (var c in E)
            c === "face" || c === "charset" || (c === "padding" || c === "spacing" ? E[c] = x(E[c]) : E[c] = parseInt(E[c], 10));
          return E;
        };
        function x(y) {
          return y.split(",").map(function(E) {
            return parseInt(E, 10);
          });
        }
      }, {}], 106: [function(k, Z, _) {
        var M = k("trim"), x = k("for-each"), y = function(E) {
          return Object.prototype.toString.call(E) === "[object Array]";
        };
        Z.exports = function(E) {
          if (!E)
            return {};
          var c = {};
          return x(
            M(E).split(`
`),
            function(u) {
              var l = u.indexOf(":"), a = M(u.slice(0, l)).toLowerCase(), n = M(u.slice(l + 1));
              typeof c[a] > "u" ? c[a] = n : y(c[a]) ? c[a].push(n) : c[a] = [c[a], n];
            }
          ), c;
        };
      }, { "for-each": 63, trim: 179 }], 107: [function(k, Z, _) {
        (function(M) {
          function x(u, l) {
            for (var a = 0, n = u.length - 1; n >= 0; n--) {
              var d = u[n];
              d === "." ? u.splice(n, 1) : d === ".." ? (u.splice(n, 1), a++) : a && (u.splice(n, 1), a--);
            }
            if (l)
              for (; a--; a)
                u.unshift("..");
            return u;
          }
          _.resolve = function() {
            for (var u = "", l = !1, a = arguments.length - 1; a >= -1 && !l; a--) {
              var n = a >= 0 ? arguments[a] : M.cwd();
              if (typeof n != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              if (!n)
                continue;
              u = n + "/" + u, l = n.charAt(0) === "/";
            }
            return u = x(E(u.split("/"), function(d) {
              return !!d;
            }), !l).join("/"), (l ? "/" : "") + u || ".";
          }, _.normalize = function(u) {
            var l = _.isAbsolute(u), a = c(u, -1) === "/";
            return u = x(E(u.split("/"), function(n) {
              return !!n;
            }), !l).join("/"), !u && !l && (u = "."), u && a && (u += "/"), (l ? "/" : "") + u;
          }, _.isAbsolute = function(u) {
            return u.charAt(0) === "/";
          }, _.join = function() {
            var u = Array.prototype.slice.call(arguments, 0);
            return _.normalize(E(u, function(l, a) {
              if (typeof l != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return l;
            }).join("/"));
          }, _.relative = function(u, l) {
            u = _.resolve(u).substr(1), l = _.resolve(l).substr(1);
            function a(b) {
              for (var S = 0; S < b.length && b[S] === ""; S++)
                ;
              for (var o = b.length - 1; o >= 0 && b[o] === ""; o--)
                ;
              return S > o ? [] : b.slice(S, o - S + 1);
            }
            for (var n = a(u.split("/")), d = a(l.split("/")), g = Math.min(n.length, d.length), h = g, m = 0; m < g; m++)
              if (n[m] !== d[m]) {
                h = m;
                break;
              }
            for (var s = [], m = h; m < n.length; m++)
              s.push("..");
            return s = s.concat(d.slice(h)), s.join("/");
          }, _.sep = "/", _.delimiter = ":", _.dirname = function(u) {
            if (typeof u != "string" && (u = u + ""), u.length === 0) return ".";
            for (var l = u.charCodeAt(0), a = l === 47, n = -1, d = !0, g = u.length - 1; g >= 1; --g)
              if (l = u.charCodeAt(g), l === 47) {
                if (!d) {
                  n = g;
                  break;
                }
              } else
                d = !1;
            return n === -1 ? a ? "/" : "." : a && n === 1 ? "/" : u.slice(0, n);
          };
          function y(u) {
            typeof u != "string" && (u = u + "");
            var l = 0, a = -1, n = !0, d;
            for (d = u.length - 1; d >= 0; --d)
              if (u.charCodeAt(d) === 47) {
                if (!n) {
                  l = d + 1;
                  break;
                }
              } else a === -1 && (n = !1, a = d + 1);
            return a === -1 ? "" : u.slice(l, a);
          }
          _.basename = function(u, l) {
            var a = y(u);
            return l && a.substr(-1 * l.length) === l && (a = a.substr(0, a.length - l.length)), a;
          }, _.extname = function(u) {
            typeof u != "string" && (u = u + "");
            for (var l = -1, a = 0, n = -1, d = !0, g = 0, h = u.length - 1; h >= 0; --h) {
              var m = u.charCodeAt(h);
              if (m === 47) {
                if (!d) {
                  a = h + 1;
                  break;
                }
                continue;
              }
              n === -1 && (d = !1, n = h + 1), m === 46 ? l === -1 ? l = h : g !== 1 && (g = 1) : l !== -1 && (g = -1);
            }
            return l === -1 || n === -1 || // We saw a non-dot character immediately before the dot
            g === 0 || // The (right-most) trimmed path component is exactly '..'
            g === 1 && l === n - 1 && l === a + 1 ? "" : u.slice(l, n);
          };
          function E(u, l) {
            if (u.filter) return u.filter(l);
            for (var a = [], n = 0; n < u.length; n++)
              l(u[n], n, u) && a.push(u[n]);
            return a;
          }
          var c = "ab".substr(-1) === "b" ? function(u, l, a) {
            return u.substr(l, a);
          } : function(u, l, a) {
            return l < 0 && (l = u.length + l), u.substr(l, a);
          };
        }).call(this, k("_process"));
      }, { _process: 133 }], 108: [function(k, Z, _) {
        (function(M) {
          var x = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, y = k("http"), E = k("https"), c = k("url"), u = k("querystring"), l = k("zlib"), a = k("util"), n = function(g, h) {
            if (typeof g != "string" && !g.hasOwnProperty("url"))
              throw new Error("Missing url option from options for request method.");
            var m = (typeof g > "u" ? "undefined" : x(g)) === "object" ? c.parse(g.url) : c.parse(g), s = { hostname: m.hostname, port: m.port || (m.protocol.toLowerCase() === "http:" ? 80 : 443), path: m.path, method: "GET", headers: {}, auth: m.auth || null, parse: "none", stream: !1 };
            if ((typeof g > "u" ? "undefined" : x(g)) === "object" && (s = Object.assign(s, g)), s.port = Number(s.port), s.hasOwnProperty("timeout") && delete s.timeout, s.compressed === !0 && (s.headers["accept-encoding"] = "gzip, deflate"), g.hasOwnProperty("form")) {
              if (x(g.form) !== "object")
                throw new Error("phin 'form' option must be of type Object if present.");
              var b = u.stringify(g.form);
              s.headers["Content-Type"] = "application/x-www-form-urlencoded", s.headers["Content-Length"] = M.byteLength(b), g.data = b;
            }
            var S = void 0, o = function(L) {
              var z = L;
              s.compressed === !0 && (L.headers["content-encoding"] === "gzip" ? z = L.pipe(l.createGunzip()) : L.headers["content-encoding"] === "deflate" && (z = L.pipe(l.createInflate()))), s.stream === !0 ? (L.stream = z, h(null, L)) : (L.body = new M([]), z.on("data", function(U) {
                L.body = M.concat([L.body, U]);
              }), z.on("end", function() {
                if (h) {
                  if (s.parse === "json")
                    try {
                      L.body = JSON.parse(L.body.toString());
                    } catch {
                      h("Invalid JSON received.", L);
                      return;
                    }
                  h(null, L);
                }
              }));
            };
            switch (m.protocol.toLowerCase()) {
              case "http:":
                S = y.request(s, o);
                break;
              case "https:":
                S = E.request(s, o);
                break;
              default:
                h && h(new Error("Invalid / unknown URL protocol. Expected HTTP or HTTPS."), null);
                return;
            }
            if (typeof g.timeout == "number" && S.setTimeout(g.timeout, function() {
              S.abort(), h(new Error("Timeout has been reached."), null), h = null;
            }), S.on("error", function(I) {
              h && h(I, null);
            }), g.hasOwnProperty("data")) {
              var A = g.data;
              if (!(g.data instanceof M) && x(g.data) === "object") {
                var T = s.headers["content-type"] || s.headers["Content-Type"];
                if (T === "application/x-www-form-urlencoded")
                  A = u.stringify(g.data);
                else
                  try {
                    A = JSON.stringify(g.data);
                  } catch {
                    h(new Error("Couldn't stringify object. (Likely due to a circular reference.)"), null);
                  }
              }
              S.write(A);
            }
            S.end();
          };
          n.promisified = function(d, g) {
            return new Promise(function(h, m) {
              n(d, function(s, b) {
                s ? m(s) : h(b);
              });
            });
          }, a.promisify && (n[a.promisify.custom] = n.promisified), Z.exports = n;
        }).call(this, k("buffer").Buffer);
      }, { buffer: 48, http: 156, https: 72, querystring: 137, url: 180, util: 186, zlib: 35 }], 109: [function(k, Z, _) {
        Z.exports = M;
        function M(d, g, h, m, s, b) {
          b || (b = {});
          for (var S = b.threshold === void 0 ? 0.1 : b.threshold, o = 35215 * S * S, A = 0, T = 0; T < s; T++)
            for (var I = 0; I < m; I++) {
              var L = (T * m + I) * 4, z = y(d, g, L, L);
              if (z > o)
                !b.includeAA && (x(d, I, T, m, s, g) || x(g, I, T, m, s, d)) ? h && a(h, L, 255, 255, 0) : (h && a(h, L, 255, 0, 0), A++);
              else if (h) {
                var U = l(n(d, L), 0.1);
                a(h, L, U, U, U);
              }
            }
          return A;
        }
        function x(d, g, h, m, s, b) {
          for (var S = Math.max(g - 1, 0), o = Math.max(h - 1, 0), A = Math.min(g + 1, m - 1), T = Math.min(h + 1, s - 1), I = (h * m + g) * 4, L = 0, z = 0, U = 0, J = 0, F = 0, oe, ee, ie, W, Q = S; Q <= A; Q++)
            for (var de = o; de <= T; de++)
              if (!(Q === g && de === h)) {
                var we = y(d, d, I, (de * m + Q) * 4, !0);
                if (we === 0 ? L++ : we < 0 ? U++ : we > 0 && z++, L > 2) return !1;
                b && (we < J && (J = we, oe = Q, ee = de), we > F && (F = we, ie = Q, W = de));
              }
          return b ? U === 0 || z === 0 ? !1 : !x(d, oe, ee, m, s) && !x(b, oe, ee, m, s) || !x(d, ie, W, m, s) && !x(b, ie, W, m, s) : !0;
        }
        function y(d, g, h, m, s) {
          var b = d[h + 3] / 255, S = g[m + 3] / 255, o = l(d[h + 0], b), A = l(d[h + 1], b), T = l(d[h + 2], b), I = l(g[m + 0], S), L = l(g[m + 1], S), z = l(g[m + 2], S), U = E(o, A, T) - E(I, L, z);
          if (s) return U;
          var J = c(o, A, T) - c(I, L, z), F = u(o, A, T) - u(I, L, z);
          return 0.5053 * U * U + 0.299 * J * J + 0.1957 * F * F;
        }
        function E(d, g, h) {
          return d * 0.29889531 + g * 0.58662247 + h * 0.11448223;
        }
        function c(d, g, h) {
          return d * 0.59597799 - g * 0.2741761 - h * 0.32180189;
        }
        function u(d, g, h) {
          return d * 0.21147017 - g * 0.52261711 + h * 0.31114694;
        }
        function l(d, g) {
          return 255 + (d - 255) * g;
        }
        function a(d, g, h, m, s) {
          d[g + 0] = h, d[g + 1] = m, d[g + 2] = s, d[g + 3] = 255;
        }
        function n(d, g) {
          var h = d[g + 3] / 255, m = l(d[g + 0], h), s = l(d[g + 1], h), b = l(d[g + 2], h);
          return E(m, s, b);
        }
      }, {}], 110: [function(k, Z, _) {
        (function(M) {
          var x = k("./interlace"), y = {
            1: {
              // L
              0: 0,
              1: 0,
              2: 0,
              3: 255
            },
            2: {
              // LA
              0: 0,
              1: 0,
              2: 0,
              3: 1
            },
            3: {
              // RGB
              0: 0,
              1: 1,
              2: 2,
              3: 255
            },
            4: {
              // RGBA
              0: 0,
              1: 1,
              2: 2,
              3: 3
            }
          };
          function E(l, a) {
            var n = [], d = 0;
            function g() {
              if (d === l.length)
                throw new Error("Ran out of data");
              var h = l[d];
              d++;
              var m, s, b, S, o, A, T, I;
              switch (a) {
                default:
                  throw new Error("unrecognised depth");
                case 16:
                  T = l[d], d++, n.push((h << 8) + T);
                  break;
                case 4:
                  T = h & 15, I = h >> 4, n.push(I, T);
                  break;
                case 2:
                  o = h & 3, A = h >> 2 & 3, T = h >> 4 & 3, I = h >> 6 & 3, n.push(I, T, A, o);
                  break;
                case 1:
                  m = h & 1, s = h >> 1 & 1, b = h >> 2 & 1, S = h >> 3 & 1, o = h >> 4 & 1, A = h >> 5 & 1, T = h >> 6 & 1, I = h >> 7 & 1, n.push(I, T, A, o, S, b, s, m);
                  break;
              }
            }
            return {
              get: function(h) {
                for (; n.length < h; )
                  g();
                var m = n.slice(0, h);
                return n = n.slice(h), m;
              },
              resetAfterLine: function() {
                n.length = 0;
              },
              end: function() {
                if (d !== l.length)
                  throw new Error("extra data found");
              }
            };
          }
          function c(l, a, n, d, g, h) {
            for (var m = l.width, s = l.height, b = l.index, S = 0; S < s; S++)
              for (var o = 0; o < m; o++) {
                for (var A = n(o, S, b), T = 0; T < 4; T++) {
                  var I = y[d][T];
                  if (I === 255)
                    a[A + T] = 255;
                  else {
                    var L = I + h;
                    if (L === g.length)
                      throw new Error("Ran out of data");
                    a[A + T] = g[L];
                  }
                }
                h += d;
              }
            return h;
          }
          function u(l, a, n, d, g, h) {
            for (var m = l.width, s = l.height, b = l.index, S = 0; S < s; S++) {
              for (var o = 0; o < m; o++)
                for (var A = g.get(d), T = n(o, S, b), I = 0; I < 4; I++) {
                  var L = y[d][I];
                  a[T + I] = L !== 255 ? A[L] : h;
                }
              g.resetAfterLine();
            }
          }
          _.dataToBitMap = function(l, a) {
            var n = a.width, d = a.height, g = a.depth, h = a.bpp, m = a.interlace;
            if (g !== 8)
              var s = E(l, g);
            var b;
            g <= 8 ? b = new M(n * d * 4) : b = new Uint16Array(n * d * 4);
            var S = Math.pow(2, g) - 1, o = 0, A, T;
            if (m)
              A = x.getImagePasses(n, d), T = x.getInterlaceIterator(n, d);
            else {
              var I = 0;
              T = function() {
                var z = I;
                return I += 4, z;
              }, A = [{ width: n, height: d }];
            }
            for (var L = 0; L < A.length; L++)
              g === 8 ? o = c(A[L], b, T, h, l, o) : u(A[L], b, T, h, s, S);
            if (g === 8) {
              if (o !== l.length)
                throw new Error("extra data found");
            } else
              s.end();
            return b;
          };
        }).call(this, k("buffer").Buffer);
      }, { "./interlace": 120, buffer: 48 }], 111: [function(k, Z, _) {
        (function(M) {
          var x = k("./constants");
          Z.exports = function(y, E, c, u) {
            var l = [x.COLORTYPE_COLOR_ALPHA, x.COLORTYPE_ALPHA].indexOf(u.colorType) !== -1;
            if (u.colorType === u.inputColorType) {
              var a = function() {
                var z = new ArrayBuffer(2);
                return new DataView(z).setInt16(
                  0,
                  256,
                  !0
                  /* littleEndian */
                ), new Int16Array(z)[0] !== 256;
              }();
              if (u.bitDepth === 8 || u.bitDepth === 16 && a)
                return y;
            }
            var n = u.bitDepth !== 16 ? y : new Uint16Array(y.buffer), d = 255, g = x.COLORTYPE_TO_BPP_MAP[u.inputColorType];
            g == 4 && !u.inputHasAlpha && (g = 3);
            var h = x.COLORTYPE_TO_BPP_MAP[u.colorType];
            u.bitDepth === 16 && (d = 65535, h *= 2);
            var m = new M(E * c * h), s = 0, b = 0, S = u.bgColor || {};
            S.red === void 0 && (S.red = d), S.green === void 0 && (S.green = d), S.blue === void 0 && (S.blue = d);
            function o(z, U) {
              var J, F, oe, ee = d;
              switch (u.inputColorType) {
                case x.COLORTYPE_COLOR_ALPHA:
                  ee = z[U + 3], J = z[U], F = z[U + 1], oe = z[U + 2];
                  break;
                case x.COLORTYPE_COLOR:
                  J = z[U], F = z[U + 1], oe = z[U + 2];
                  break;
                case x.COLORTYPE_ALPHA:
                  ee = z[U + 1], J = z[U], F = J, oe = J;
                  break;
                case x.COLORTYPE_GRAYSCALE:
                  J = z[U], F = J, oe = J;
                  break;
                default:
                  throw new Error("input color type:" + u.inputColorType + " is not supported at present");
              }
              return u.inputHasAlpha && (l || (ee /= d, J = Math.min(Math.max(Math.round((1 - ee) * S.red + ee * J), 0), d), F = Math.min(Math.max(Math.round((1 - ee) * S.green + ee * F), 0), d), oe = Math.min(Math.max(Math.round((1 - ee) * S.blue + ee * oe), 0), d))), { red: J, green: F, blue: oe, alpha: ee };
            }
            for (var A = 0; A < c; A++)
              for (var T = 0; T < E; T++) {
                var I = o(n, s);
                switch (u.colorType) {
                  case x.COLORTYPE_COLOR_ALPHA:
                  case x.COLORTYPE_COLOR:
                    u.bitDepth === 8 ? (m[b] = I.red, m[b + 1] = I.green, m[b + 2] = I.blue, l && (m[b + 3] = I.alpha)) : (m.writeUInt16BE(I.red, b), m.writeUInt16BE(I.green, b + 2), m.writeUInt16BE(I.blue, b + 4), l && m.writeUInt16BE(I.alpha, b + 6));
                    break;
                  case x.COLORTYPE_ALPHA:
                  case x.COLORTYPE_GRAYSCALE:
                    var L = (I.red + I.green + I.blue) / 3;
                    u.bitDepth === 8 ? (m[b] = L, l && (m[b + 1] = I.alpha)) : (m.writeUInt16BE(L, b), l && m.writeUInt16BE(I.alpha, b + 2));
                    break;
                }
                s += g, b += h;
              }
            return m;
          };
        }).call(this, k("buffer").Buffer);
      }, { "./constants": 113, buffer: 48 }], 112: [function(k, Z, _) {
        (function(M, x) {
          var y = k("util"), E = k("stream"), c = Z.exports = function() {
            E.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = !1, this._encoding = "utf8", this.writable = !0;
          };
          y.inherits(c, E), c.prototype.read = function(u, l) {
            this._reads.push({
              length: Math.abs(u),
              // if length < 0 then at most this length
              allowLess: u < 0,
              func: l
            }), M.nextTick((function() {
              this._process(), this._paused && this._reads.length > 0 && (this._paused = !1, this.emit("drain"));
            }).bind(this));
          }, c.prototype.write = function(u, l) {
            if (!this.writable)
              return this.emit("error", new Error("Stream not writable")), !1;
            var a;
            return x.isBuffer(u) ? a = u : a = new x(u, l || this._encoding), this._buffers.push(a), this._buffered += a.length, this._process(), this._reads && this._reads.length === 0 && (this._paused = !0), this.writable && !this._paused;
          }, c.prototype.end = function(u, l) {
            u && this.write(u, l), this.writable = !1, this._buffers && (this._buffers.length === 0 ? this._end() : (this._buffers.push(null), this._process()));
          }, c.prototype.destroySoon = c.prototype.end, c.prototype._end = function() {
            this._reads.length > 0 && this.emit(
              "error",
              new Error("There are some read requests waiting on finished stream")
            ), this.destroy();
          }, c.prototype.destroy = function() {
            this._buffers && (this.writable = !1, this._reads = null, this._buffers = null, this.emit("close"));
          }, c.prototype._processReadAllowingLess = function(u) {
            this._reads.shift();
            var l = this._buffers[0];
            l.length > u.length ? (this._buffered -= u.length, this._buffers[0] = l.slice(u.length), u.func.call(this, l.slice(0, u.length))) : (this._buffered -= l.length, this._buffers.shift(), u.func.call(this, l));
          }, c.prototype._processRead = function(u) {
            this._reads.shift();
            for (var l = 0, a = 0, n = new x(u.length); l < u.length; ) {
              var d = this._buffers[a++], g = Math.min(d.length, u.length - l);
              d.copy(n, l, 0, g), l += g, g !== d.length && (this._buffers[--a] = d.slice(g));
            }
            a > 0 && this._buffers.splice(0, a), this._buffered -= u.length, u.func.call(this, n);
          }, c.prototype._process = function() {
            try {
              for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
                var u = this._reads[0];
                if (u.allowLess)
                  this._processReadAllowingLess(u);
                else if (this._buffered >= u.length)
                  this._processRead(u);
                else
                  break;
              }
              this._buffers && this._buffers.length > 0 && this._buffers[0] === null && this._end();
            } catch (l) {
              this.emit("error", l);
            }
          };
        }).call(this, k("_process"), k("buffer").Buffer);
      }, { _process: 133, buffer: 48, stream: 155, util: 186 }], 113: [function(k, Z, _) {
        Z.exports = {
          PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
          TYPE_IHDR: 1229472850,
          TYPE_IEND: 1229278788,
          TYPE_IDAT: 1229209940,
          TYPE_PLTE: 1347179589,
          TYPE_tRNS: 1951551059,
          // eslint-disable-line camelcase
          TYPE_gAMA: 1732332865,
          // eslint-disable-line camelcase
          // color-type bits
          COLORTYPE_GRAYSCALE: 0,
          COLORTYPE_PALETTE: 1,
          COLORTYPE_COLOR: 2,
          COLORTYPE_ALPHA: 4,
          // e.g. grayscale and alpha
          // color-type combinations
          COLORTYPE_PALETTE_COLOR: 3,
          COLORTYPE_COLOR_ALPHA: 6,
          COLORTYPE_TO_BPP_MAP: {
            0: 1,
            2: 3,
            3: 1,
            4: 2,
            6: 4
          },
          GAMMA_DIVISION: 1e5
        };
      }, {}], 114: [function(k, Z, _) {
        var M = [];
        (function() {
          for (var y = 0; y < 256; y++) {
            for (var E = y, c = 0; c < 8; c++)
              E & 1 ? E = 3988292384 ^ E >>> 1 : E = E >>> 1;
            M[y] = E;
          }
        })();
        var x = Z.exports = function() {
          this._crc = -1;
        };
        x.prototype.write = function(y) {
          for (var E = 0; E < y.length; E++)
            this._crc = M[(this._crc ^ y[E]) & 255] ^ this._crc >>> 8;
          return !0;
        }, x.prototype.crc32 = function() {
          return this._crc ^ -1;
        }, x.crc32 = function(y) {
          for (var E = -1, c = 0; c < y.length; c++)
            E = M[(E ^ y[c]) & 255] ^ E >>> 8;
          return E ^ -1;
        };
      }, {}], 115: [function(k, Z, _) {
        (function(M) {
          var x = k("./paeth-predictor");
          function y(b, S, o, A, T) {
            for (var I = 0; I < o; I++)
              A[T + I] = b[S + I];
          }
          function E(b, S, o) {
            for (var A = 0, T = S + o, I = S; I < T; I++)
              A += Math.abs(b[I]);
            return A;
          }
          function c(b, S, o, A, T, I) {
            for (var L = 0; L < o; L++) {
              var z = L >= I ? b[S + L - I] : 0, U = b[S + L] - z;
              A[T + L] = U;
            }
          }
          function u(b, S, o, A) {
            for (var T = 0, I = 0; I < o; I++) {
              var L = I >= A ? b[S + I - A] : 0, z = b[S + I] - L;
              T += Math.abs(z);
            }
            return T;
          }
          function l(b, S, o, A, T) {
            for (var I = 0; I < o; I++) {
              var L = S > 0 ? b[S + I - o] : 0, z = b[S + I] - L;
              A[T + I] = z;
            }
          }
          function a(b, S, o) {
            for (var A = 0, T = S + o, I = S; I < T; I++) {
              var L = S > 0 ? b[I - o] : 0, z = b[I] - L;
              A += Math.abs(z);
            }
            return A;
          }
          function n(b, S, o, A, T, I) {
            for (var L = 0; L < o; L++) {
              var z = L >= I ? b[S + L - I] : 0, U = S > 0 ? b[S + L - o] : 0, J = b[S + L] - (z + U >> 1);
              A[T + L] = J;
            }
          }
          function d(b, S, o, A) {
            for (var T = 0, I = 0; I < o; I++) {
              var L = I >= A ? b[S + I - A] : 0, z = S > 0 ? b[S + I - o] : 0, U = b[S + I] - (L + z >> 1);
              T += Math.abs(U);
            }
            return T;
          }
          function g(b, S, o, A, T, I) {
            for (var L = 0; L < o; L++) {
              var z = L >= I ? b[S + L - I] : 0, U = S > 0 ? b[S + L - o] : 0, J = S > 0 && L >= I ? b[S + L - (o + I)] : 0, F = b[S + L] - x(z, U, J);
              A[T + L] = F;
            }
          }
          function h(b, S, o, A) {
            for (var T = 0, I = 0; I < o; I++) {
              var L = I >= A ? b[S + I - A] : 0, z = S > 0 ? b[S + I - o] : 0, U = S > 0 && I >= A ? b[S + I - (o + A)] : 0, J = b[S + I] - x(L, z, U);
              T += Math.abs(J);
            }
            return T;
          }
          var m = {
            0: y,
            1: c,
            2: l,
            3: n,
            4: g
          }, s = {
            0: E,
            1: u,
            2: a,
            3: d,
            4: h
          };
          Z.exports = function(b, S, o, A, T) {
            var I;
            if (!("filterType" in A) || A.filterType === -1)
              I = [0, 1, 2, 3, 4];
            else if (typeof A.filterType == "number")
              I = [A.filterType];
            else
              throw new Error("unrecognised filter types");
            A.bitDepth === 16 && (T *= 2);
            for (var L = S * T, z = 0, U = 0, J = new M((L + 1) * o), F = I[0], oe = 0; oe < o; oe++) {
              if (I.length > 1)
                for (var ee = 1 / 0, ie = 0; ie < I.length; ie++) {
                  var W = s[I[ie]](b, U, L, T);
                  W < ee && (F = I[ie], ee = W);
                }
              J[z] = F, z++, m[F](b, U, L, J, z, T), z += L, U += L;
            }
            return J;
          };
        }).call(this, k("buffer").Buffer);
      }, { "./paeth-predictor": 124, buffer: 48 }], 116: [function(k, Z, _) {
        (function(M) {
          var x = k("util"), y = k("./chunkstream"), E = k("./filter-parse"), c = Z.exports = function(u) {
            y.call(this);
            var l = [], a = this;
            this._filter = new E(u, {
              read: this.read.bind(this),
              write: function(n) {
                l.push(n);
              },
              complete: function() {
                a.emit("complete", M.concat(l));
              }
            }), this._filter.start();
          };
          x.inherits(c, y);
        }).call(this, k("buffer").Buffer);
      }, { "./chunkstream": 112, "./filter-parse": 118, buffer: 48, util: 186 }], 117: [function(k, Z, _) {
        (function(M) {
          var x = k("./sync-reader"), y = k("./filter-parse");
          _.process = function(E, c) {
            var u = [], l = new x(E), a = new y(c, {
              read: l.read.bind(l),
              write: function(n) {
                u.push(n);
              },
              complete: function() {
              }
            });
            return a.start(), l.process(), M.concat(u);
          };
        }).call(this, k("buffer").Buffer);
      }, { "./filter-parse": 118, "./sync-reader": 131, buffer: 48 }], 118: [function(k, Z, _) {
        (function(M) {
          var x = k("./interlace"), y = k("./paeth-predictor");
          function E(u, l, a) {
            var n = u * l;
            return a !== 8 && (n = Math.ceil(n / (8 / a))), n;
          }
          var c = Z.exports = function(u, l) {
            var a = u.width, n = u.height, d = u.interlace, g = u.bpp, h = u.depth;
            if (this.read = l.read, this.write = l.write, this.complete = l.complete, this._imageIndex = 0, this._images = [], d)
              for (var m = x.getImagePasses(a, n), s = 0; s < m.length; s++)
                this._images.push({
                  byteWidth: E(m[s].width, g, h),
                  height: m[s].height,
                  lineIndex: 0
                });
            else
              this._images.push({
                byteWidth: E(a, g, h),
                height: n,
                lineIndex: 0
              });
            h === 8 ? this._xComparison = g : h === 16 ? this._xComparison = g * 2 : this._xComparison = 1;
          };
          c.prototype.start = function() {
            this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
          }, c.prototype._unFilterType1 = function(u, l, a) {
            for (var n = this._xComparison, d = n - 1, g = 0; g < a; g++) {
              var h = u[1 + g], m = g > d ? l[g - n] : 0;
              l[g] = h + m;
            }
          }, c.prototype._unFilterType2 = function(u, l, a) {
            for (var n = this._lastLine, d = 0; d < a; d++) {
              var g = u[1 + d], h = n ? n[d] : 0;
              l[d] = g + h;
            }
          }, c.prototype._unFilterType3 = function(u, l, a) {
            for (var n = this._xComparison, d = n - 1, g = this._lastLine, h = 0; h < a; h++) {
              var m = u[1 + h], s = g ? g[h] : 0, b = h > d ? l[h - n] : 0, S = Math.floor((b + s) / 2);
              l[h] = m + S;
            }
          }, c.prototype._unFilterType4 = function(u, l, a) {
            for (var n = this._xComparison, d = n - 1, g = this._lastLine, h = 0; h < a; h++) {
              var m = u[1 + h], s = g ? g[h] : 0, b = h > d ? l[h - n] : 0, S = h > d && g ? g[h - n] : 0, o = y(b, s, S);
              l[h] = m + o;
            }
          }, c.prototype._reverseFilterLine = function(u) {
            var l = u[0], a, n = this._images[this._imageIndex], d = n.byteWidth;
            if (l === 0)
              a = u.slice(1, d + 1);
            else
              switch (a = new M(d), l) {
                case 1:
                  this._unFilterType1(u, a, d);
                  break;
                case 2:
                  this._unFilterType2(u, a, d);
                  break;
                case 3:
                  this._unFilterType3(u, a, d);
                  break;
                case 4:
                  this._unFilterType4(u, a, d);
                  break;
                default:
                  throw new Error("Unrecognised filter type - " + l);
              }
            this.write(a), n.lineIndex++, n.lineIndex >= n.height ? (this._lastLine = null, this._imageIndex++, n = this._images[this._imageIndex]) : this._lastLine = a, n ? this.read(n.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
          };
        }).call(this, k("buffer").Buffer);
      }, { "./interlace": 120, "./paeth-predictor": 124, buffer: 48 }], 119: [function(k, Z, _) {
        (function(M) {
          function x(c, u, l, a, n) {
            for (var d = 0, g = 0; g < a; g++)
              for (var h = 0; h < l; h++) {
                var m = n[c[d]];
                if (!m)
                  throw new Error("index " + c[d] + " not in palette");
                for (var s = 0; s < 4; s++)
                  u[d + s] = m[s];
                d += 4;
              }
          }
          function y(c, u, l, a, n) {
            for (var d = 0, g = 0; g < a; g++)
              for (var h = 0; h < l; h++) {
                var m = !1;
                if (n.length === 1 ? n[0] === c[d] && (m = !0) : n[0] === c[d] && n[1] === c[d + 1] && n[2] === c[d + 2] && (m = !0), m)
                  for (var s = 0; s < 4; s++)
                    u[d + s] = 0;
                d += 4;
              }
          }
          function E(c, u, l, a, n) {
            for (var d = 255, g = Math.pow(2, n) - 1, h = 0, m = 0; m < a; m++)
              for (var s = 0; s < l; s++) {
                for (var b = 0; b < 4; b++)
                  u[h + b] = Math.floor(c[h + b] * d / g + 0.5);
                h += 4;
              }
          }
          Z.exports = function(c, u) {
            var l = u.depth, a = u.width, n = u.height, d = u.colorType, g = u.transColor, h = u.palette, m = c;
            return d === 3 ? x(c, m, a, n, h) : (g && y(c, m, a, n, g), l !== 8 && (l === 16 && (m = new M(a * n * 4)), E(c, m, a, n, l))), m;
          };
        }).call(this, k("buffer").Buffer);
      }, { buffer: 48 }], 120: [function(k, Z, _) {
        var M = [
          {
            // pass 1 - 1px
            x: [0],
            y: [0]
          },
          {
            // pass 2 - 1px
            x: [4],
            y: [0]
          },
          {
            // pass 3 - 2px
            x: [0, 4],
            y: [4]
          },
          {
            // pass 4 - 4px
            x: [2, 6],
            y: [0, 4]
          },
          {
            // pass 5 - 8px
            x: [0, 2, 4, 6],
            y: [2, 6]
          },
          {
            // pass 6 - 16px
            x: [1, 3, 5, 7],
            y: [0, 2, 4, 6]
          },
          {
            // pass 7 - 32px
            x: [0, 1, 2, 3, 4, 5, 6, 7],
            y: [1, 3, 5, 7]
          }
        ];
        _.getImagePasses = function(x, y) {
          for (var E = [], c = x % 8, u = y % 8, l = (x - c) / 8, a = (y - u) / 8, n = 0; n < M.length; n++) {
            for (var d = M[n], g = l * d.x.length, h = a * d.y.length, m = 0; m < d.x.length && d.x[m] < c; m++)
              g++;
            for (m = 0; m < d.y.length && d.y[m] < u; m++)
              h++;
            g > 0 && h > 0 && E.push({ width: g, height: h, index: n });
          }
          return E;
        }, _.getInterlaceIterator = function(x) {
          return function(y, E, c) {
            var u = y % M[c].x.length, l = (y - u) / M[c].x.length * 8 + M[c].x[u], a = E % M[c].y.length, n = (E - a) / M[c].y.length * 8 + M[c].y[a];
            return l * 4 + n * x * 4;
          };
        };
      }, {}], 121: [function(k, Z, _) {
        (function(M) {
          var x = k("util"), y = k("stream"), E = k("./constants"), c = k("./packer"), u = Z.exports = function(l) {
            y.call(this);
            var a = l || {};
            this._packer = new c(a), this._deflate = this._packer.createDeflate(), this.readable = !0;
          };
          x.inherits(u, y), u.prototype.pack = function(l, a, n, d) {
            this.emit("data", new M(E.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(a, n)), d && this.emit("data", this._packer.packGAMA(d));
            var g = this._packer.filterData(l, a, n);
            this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", (function(h) {
              this.emit("data", this._packer.packIDAT(h));
            }).bind(this)), this._deflate.on("end", (function() {
              this.emit("data", this._packer.packIEND()), this.emit("end");
            }).bind(this)), this._deflate.end(g);
          };
        }).call(this, k("buffer").Buffer);
      }, { "./constants": 113, "./packer": 123, buffer: 48, stream: 155, util: 186 }], 122: [function(k, Z, _) {
        (function(M) {
          var x = !0, y = k("zlib");
          y.deflateSync || (x = !1);
          var E = k("./constants"), c = k("./packer");
          Z.exports = function(u, l) {
            if (!x)
              throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            var a = l || {}, n = new c(a), d = [];
            d.push(new M(E.PNG_SIGNATURE)), d.push(n.packIHDR(u.width, u.height)), u.gamma && d.push(n.packGAMA(u.gamma));
            var g = n.filterData(u.data, u.width, u.height), h = y.deflateSync(g, n.getDeflateOptions());
            if (g = null, !h || !h.length)
              throw new Error("bad png - invalid compressed data response");
            return d.push(n.packIDAT(h)), d.push(n.packIEND()), M.concat(d);
          };
        }).call(this, k("buffer").Buffer);
      }, { "./constants": 113, "./packer": 123, buffer: 48, zlib: 35 }], 123: [function(k, Z, _) {
        (function(M) {
          var x = k("./constants"), y = k("./crc"), E = k("./bitpacker"), c = k("./filter-pack"), u = k("zlib"), l = Z.exports = function(a) {
            if (this._options = a, a.deflateChunkSize = a.deflateChunkSize || 32 * 1024, a.deflateLevel = a.deflateLevel != null ? a.deflateLevel : 9, a.deflateStrategy = a.deflateStrategy != null ? a.deflateStrategy : 3, a.inputHasAlpha = a.inputHasAlpha != null ? a.inputHasAlpha : !0, a.deflateFactory = a.deflateFactory || u.createDeflate, a.bitDepth = a.bitDepth || 8, a.colorType = typeof a.colorType == "number" ? a.colorType : x.COLORTYPE_COLOR_ALPHA, a.inputColorType = typeof a.inputColorType == "number" ? a.inputColorType : x.COLORTYPE_COLOR_ALPHA, [
              x.COLORTYPE_GRAYSCALE,
              x.COLORTYPE_COLOR,
              x.COLORTYPE_COLOR_ALPHA,
              x.COLORTYPE_ALPHA
            ].indexOf(a.colorType) === -1)
              throw new Error("option color type:" + a.colorType + " is not supported at present");
            if ([
              x.COLORTYPE_GRAYSCALE,
              x.COLORTYPE_COLOR,
              x.COLORTYPE_COLOR_ALPHA,
              x.COLORTYPE_ALPHA
            ].indexOf(a.inputColorType) === -1)
              throw new Error("option input color type:" + a.inputColorType + " is not supported at present");
            if (a.bitDepth !== 8 && a.bitDepth !== 16)
              throw new Error("option bit depth:" + a.bitDepth + " is not supported at present");
          };
          l.prototype.getDeflateOptions = function() {
            return {
              chunkSize: this._options.deflateChunkSize,
              level: this._options.deflateLevel,
              strategy: this._options.deflateStrategy
            };
          }, l.prototype.createDeflate = function() {
            return this._options.deflateFactory(this.getDeflateOptions());
          }, l.prototype.filterData = function(a, n, d) {
            var g = E(a, n, d, this._options), h = x.COLORTYPE_TO_BPP_MAP[this._options.colorType], m = c(g, n, d, this._options, h);
            return m;
          }, l.prototype._packChunk = function(a, n) {
            var d = n ? n.length : 0, g = new M(d + 12);
            return g.writeUInt32BE(d, 0), g.writeUInt32BE(a, 4), n && n.copy(g, 8), g.writeInt32BE(y.crc32(g.slice(4, g.length - 4)), g.length - 4), g;
          }, l.prototype.packGAMA = function(a) {
            var n = new M(4);
            return n.writeUInt32BE(Math.floor(a * x.GAMMA_DIVISION), 0), this._packChunk(x.TYPE_gAMA, n);
          }, l.prototype.packIHDR = function(a, n) {
            var d = new M(13);
            return d.writeUInt32BE(a, 0), d.writeUInt32BE(n, 4), d[8] = this._options.bitDepth, d[9] = this._options.colorType, d[10] = 0, d[11] = 0, d[12] = 0, this._packChunk(x.TYPE_IHDR, d);
          }, l.prototype.packIDAT = function(a) {
            return this._packChunk(x.TYPE_IDAT, a);
          }, l.prototype.packIEND = function() {
            return this._packChunk(x.TYPE_IEND, null);
          };
        }).call(this, k("buffer").Buffer);
      }, { "./bitpacker": 111, "./constants": 113, "./crc": 114, "./filter-pack": 115, buffer: 48, zlib: 35 }], 124: [function(k, Z, _) {
        Z.exports = function(x, y, E) {
          var c = x + y - E, u = Math.abs(c - x), l = Math.abs(c - y), a = Math.abs(c - E);
          return u <= l && u <= a ? x : l <= a ? y : E;
        };
      }, {}], 125: [function(k, Z, _) {
        var M = k("util"), x = k("zlib"), y = k("./chunkstream"), E = k("./filter-parse-async"), c = k("./parser"), u = k("./bitmapper"), l = k("./format-normaliser"), a = Z.exports = function(n) {
          y.call(this), this._parser = new c(n, {
            read: this.read.bind(this),
            error: this._handleError.bind(this),
            metadata: this._handleMetaData.bind(this),
            gamma: this.emit.bind(this, "gamma"),
            palette: this._handlePalette.bind(this),
            transColor: this._handleTransColor.bind(this),
            finished: this._finished.bind(this),
            inflateData: this._inflateData.bind(this)
          }), this._options = n, this.writable = !0, this._parser.start();
        };
        M.inherits(a, y), a.prototype._handleError = function(n) {
          this.emit("error", n), this.writable = !1, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
          })), this.errord = !0;
        }, a.prototype._inflateData = function(n) {
          if (!this._inflate)
            if (this._bitmapInfo.interlace)
              this._inflate = x.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
            else {
              var d = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1, g = d * this._bitmapInfo.height, h = Math.max(g, x.Z_MIN_CHUNK);
              this._inflate = x.createInflate({ chunkSize: h });
              var m = g, s = this.emit.bind(this, "error");
              this._inflate.on("error", function(S) {
                m && s(S);
              }), this._filter.on("complete", this._complete.bind(this));
              var b = this._filter.write.bind(this._filter);
              this._inflate.on("data", function(S) {
                m && (S.length > m && (S = S.slice(0, m)), m -= S.length, b(S));
              }), this._inflate.on("end", this._filter.end.bind(this._filter));
            }
          this._inflate.write(n);
        }, a.prototype._handleMetaData = function(n) {
          this.emit("metadata", n), this._bitmapInfo = Object.create(n), this._filter = new E(this._bitmapInfo);
        }, a.prototype._handleTransColor = function(n) {
          this._bitmapInfo.transColor = n;
        }, a.prototype._handlePalette = function(n) {
          this._bitmapInfo.palette = n;
        }, a.prototype._finished = function() {
          this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"), this.destroySoon());
        }, a.prototype._complete = function(n) {
          if (!this.errord) {
            try {
              var d = u.dataToBitMap(n, this._bitmapInfo), g = l(d, this._bitmapInfo);
              d = null;
            } catch (h) {
              this._handleError(h);
              return;
            }
            this.emit("parsed", g);
          }
        };
      }, { "./bitmapper": 110, "./chunkstream": 112, "./filter-parse-async": 116, "./format-normaliser": 119, "./parser": 127, util: 186, zlib: 35 }], 126: [function(k, Z, _) {
        (function(M) {
          var x = !0, y = k("zlib"), E = k("./sync-inflate");
          y.deflateSync || (x = !1);
          var c = k("./sync-reader"), u = k("./filter-parse-sync"), l = k("./parser"), a = k("./bitmapper"), n = k("./format-normaliser");
          Z.exports = function(d, g) {
            if (!x)
              throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            var h;
            function m(de) {
              h = de;
            }
            var s;
            function b(de) {
              s = de;
            }
            function S(de) {
              s.transColor = de;
            }
            function o(de) {
              s.palette = de;
            }
            var A;
            function T(de) {
              A = de;
            }
            var I = [];
            function L(de) {
              I.push(de);
            }
            var z = new c(d), U = new l(g, {
              read: z.read.bind(z),
              error: m,
              metadata: b,
              gamma: T,
              palette: o,
              transColor: S,
              inflateData: L
            });
            if (U.start(), z.process(), h)
              throw h;
            var J = M.concat(I);
            I.length = 0;
            var F;
            if (s.interlace)
              F = y.inflateSync(J);
            else {
              var oe = (s.width * s.bpp * s.depth + 7 >> 3) + 1, ee = oe * s.height;
              F = E(J, { chunkSize: ee, maxLength: ee });
            }
            if (J = null, !F || !F.length)
              throw new Error("bad png - invalid inflate data response");
            var ie = u.process(F, s);
            J = null;
            var W = a.dataToBitMap(ie, s);
            ie = null;
            var Q = n(W, s);
            return s.data = Q, s.gamma = A || 0, s;
          };
        }).call(this, k("buffer").Buffer);
      }, { "./bitmapper": 110, "./filter-parse-sync": 117, "./format-normaliser": 119, "./parser": 127, "./sync-inflate": 130, "./sync-reader": 131, buffer: 48, zlib: 35 }], 127: [function(k, Z, _) {
        (function(M) {
          var x = k("./constants"), y = k("./crc"), E = Z.exports = function(c, u) {
            this._options = c, c.checkCRC = c.checkCRC !== !1, this._hasIHDR = !1, this._hasIEND = !1, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[x.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[x.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[x.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[x.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[x.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[x.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = u.read, this.error = u.error, this.metadata = u.metadata, this.gamma = u.gamma, this.transColor = u.transColor, this.palette = u.palette, this.parsed = u.parsed, this.inflateData = u.inflateData, this.finished = u.finished;
          };
          E.prototype.start = function() {
            this.read(
              x.PNG_SIGNATURE.length,
              this._parseSignature.bind(this)
            );
          }, E.prototype._parseSignature = function(c) {
            for (var u = x.PNG_SIGNATURE, l = 0; l < u.length; l++)
              if (c[l] !== u[l]) {
                this.error(new Error("Invalid file signature"));
                return;
              }
            this.read(8, this._parseChunkBegin.bind(this));
          }, E.prototype._parseChunkBegin = function(c) {
            for (var u = c.readUInt32BE(0), l = c.readUInt32BE(4), a = "", n = 4; n < 8; n++)
              a += String.fromCharCode(c[n]);
            var d = !!(c[4] & 32);
            if (!this._hasIHDR && l !== x.TYPE_IHDR) {
              this.error(new Error("Expected IHDR on beggining"));
              return;
            }
            if (this._crc = new y(), this._crc.write(new M(a)), this._chunks[l])
              return this._chunks[l](u);
            if (!d) {
              this.error(new Error("Unsupported critical chunk type " + a));
              return;
            }
            this.read(u + 4, this._skipChunk.bind(this));
          }, E.prototype._skipChunk = function() {
            this.read(8, this._parseChunkBegin.bind(this));
          }, E.prototype._handleChunkEnd = function() {
            this.read(4, this._parseChunkEnd.bind(this));
          }, E.prototype._parseChunkEnd = function(c) {
            var u = c.readInt32BE(0), l = this._crc.crc32();
            if (this._options.checkCRC && l !== u) {
              this.error(new Error("Crc error - " + u + " - " + l));
              return;
            }
            this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
          }, E.prototype._handleIHDR = function(c) {
            this.read(c, this._parseIHDR.bind(this));
          }, E.prototype._parseIHDR = function(c) {
            this._crc.write(c);
            var u = c.readUInt32BE(0), l = c.readUInt32BE(4), a = c[8], n = c[9], d = c[10], g = c[11], h = c[12];
            if (a !== 8 && a !== 4 && a !== 2 && a !== 1 && a !== 16) {
              this.error(new Error("Unsupported bit depth " + a));
              return;
            }
            if (!(n in x.COLORTYPE_TO_BPP_MAP)) {
              this.error(new Error("Unsupported color type"));
              return;
            }
            if (d !== 0) {
              this.error(new Error("Unsupported compression method"));
              return;
            }
            if (g !== 0) {
              this.error(new Error("Unsupported filter method"));
              return;
            }
            if (h !== 0 && h !== 1) {
              this.error(new Error("Unsupported interlace method"));
              return;
            }
            this._colorType = n;
            var m = x.COLORTYPE_TO_BPP_MAP[this._colorType];
            this._hasIHDR = !0, this.metadata({
              width: u,
              height: l,
              depth: a,
              interlace: !!h,
              palette: !!(n & x.COLORTYPE_PALETTE),
              color: !!(n & x.COLORTYPE_COLOR),
              alpha: !!(n & x.COLORTYPE_ALPHA),
              bpp: m,
              colorType: n
            }), this._handleChunkEnd();
          }, E.prototype._handlePLTE = function(c) {
            this.read(c, this._parsePLTE.bind(this));
          }, E.prototype._parsePLTE = function(c) {
            this._crc.write(c);
            for (var u = Math.floor(c.length / 3), l = 0; l < u; l++)
              this._palette.push([
                c[l * 3],
                c[l * 3 + 1],
                c[l * 3 + 2],
                255
              ]);
            this.palette(this._palette), this._handleChunkEnd();
          }, E.prototype._handleTRNS = function(c) {
            this.read(c, this._parseTRNS.bind(this));
          }, E.prototype._parseTRNS = function(c) {
            if (this._crc.write(c), this._colorType === x.COLORTYPE_PALETTE_COLOR) {
              if (this._palette.length === 0) {
                this.error(new Error("Transparency chunk must be after palette"));
                return;
              }
              if (c.length > this._palette.length) {
                this.error(new Error("More transparent colors than palette size"));
                return;
              }
              for (var u = 0; u < c.length; u++)
                this._palette[u][3] = c[u];
              this.palette(this._palette);
            }
            this._colorType === x.COLORTYPE_GRAYSCALE && this.transColor([c.readUInt16BE(0)]), this._colorType === x.COLORTYPE_COLOR && this.transColor([c.readUInt16BE(0), c.readUInt16BE(2), c.readUInt16BE(4)]), this._handleChunkEnd();
          }, E.prototype._handleGAMA = function(c) {
            this.read(c, this._parseGAMA.bind(this));
          }, E.prototype._parseGAMA = function(c) {
            this._crc.write(c), this.gamma(c.readUInt32BE(0) / x.GAMMA_DIVISION), this._handleChunkEnd();
          }, E.prototype._handleIDAT = function(c) {
            this.read(-c, this._parseIDAT.bind(this, c));
          }, E.prototype._parseIDAT = function(c, u) {
            if (this._crc.write(u), this._colorType === x.COLORTYPE_PALETTE_COLOR && this._palette.length === 0)
              throw new Error("Expected palette not found");
            this.inflateData(u);
            var l = c - u.length;
            l > 0 ? this._handleIDAT(l) : this._handleChunkEnd();
          }, E.prototype._handleIEND = function(c) {
            this.read(c, this._parseIEND.bind(this));
          }, E.prototype._parseIEND = function(c) {
            this._crc.write(c), this._hasIEND = !0, this._handleChunkEnd(), this.finished && this.finished();
          };
        }).call(this, k("buffer").Buffer);
      }, { "./constants": 113, "./crc": 114, buffer: 48 }], 128: [function(k, Z, _) {
        var M = k("./parser-sync"), x = k("./packer-sync");
        _.read = function(y, E) {
          return M(y, E || {});
        }, _.write = function(y, E) {
          return x(y, E);
        };
      }, { "./packer-sync": 122, "./parser-sync": 126 }], 129: [function(k, Z, _) {
        (function(M, x) {
          var y = k("util"), E = k("stream"), c = k("./parser-async"), u = k("./packer-async"), l = k("./png-sync"), a = _.PNG = function(n) {
            E.call(this), n = n || {}, this.width = n.width | 0, this.height = n.height | 0, this.data = this.width > 0 && this.height > 0 ? new x(4 * this.width * this.height) : null, n.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = !0, this._parser = new c(n), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", (function(d) {
              this.data = d, this.emit("parsed", d);
            }).bind(this)), this._packer = new u(n), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
          };
          y.inherits(a, E), a.sync = l, a.prototype.pack = function() {
            return !this.data || !this.data.length ? (this.emit("error", "No data provided"), this) : (M.nextTick((function() {
              this._packer.pack(this.data, this.width, this.height, this.gamma);
            }).bind(this)), this);
          }, a.prototype.parse = function(n, d) {
            if (d) {
              var g, h;
              g = (function(m) {
                this.removeListener("error", h), this.data = m, d(null, this);
              }).bind(this), h = (function(m) {
                this.removeListener("parsed", g), d(m, null);
              }).bind(this), this.once("parsed", g), this.once("error", h);
            }
            return this.end(n), this;
          }, a.prototype.write = function(n) {
            return this._parser.write(n), !0;
          }, a.prototype.end = function(n) {
            this._parser.end(n);
          }, a.prototype._metadata = function(n) {
            this.width = n.width, this.height = n.height, this.emit("metadata", n);
          }, a.prototype._gamma = function(n) {
            this.gamma = n;
          }, a.prototype._handleClose = function() {
            !this._parser.writable && !this._packer.readable && this.emit("close");
          }, a.bitblt = function(n, d, g, h, m, s, b, S) {
            if (g |= 0, h |= 0, m |= 0, s |= 0, b |= 0, S |= 0, g > n.width || h > n.height || g + m > n.width || h + s > n.height)
              throw new Error("bitblt reading outside image");
            if (b > d.width || S > d.height || b + m > d.width || S + s > d.height)
              throw new Error("bitblt writing outside image");
            for (var o = 0; o < s; o++)
              n.data.copy(
                d.data,
                (S + o) * d.width + b << 2,
                (h + o) * n.width + g << 2,
                (h + o) * n.width + g + m << 2
              );
          }, a.prototype.bitblt = function(n, d, g, h, m, s, b) {
            return a.bitblt(this, n, d, g, h, m, s, b), this;
          }, a.adjustGamma = function(n) {
            if (n.gamma) {
              for (var d = 0; d < n.height; d++)
                for (var g = 0; g < n.width; g++)
                  for (var h = n.width * d + g << 2, m = 0; m < 3; m++) {
                    var s = n.data[h + m] / 255;
                    s = Math.pow(s, 1 / 2.2 / n.gamma), n.data[h + m] = Math.round(s * 255);
                  }
              n.gamma = 0;
            }
          }, a.prototype.adjustGamma = function() {
            a.adjustGamma(this);
          };
        }).call(this, k("_process"), k("buffer").Buffer);
      }, { "./packer-async": 121, "./parser-async": 125, "./png-sync": 128, _process: 133, buffer: 48, stream: 155, util: 186 }], 130: [function(k, Z, _) {
        (function(M, x) {
          var y = k("assert").ok, E = k("zlib"), c = k("util"), u = k("buffer").kMaxLength;
          function l(h) {
            if (!(this instanceof l))
              return new l(h);
            h && h.chunkSize < E.Z_MIN_CHUNK && (h.chunkSize = E.Z_MIN_CHUNK), E.Inflate.call(this, h), this._offset = this._offset === void 0 ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, h && h.maxLength != null && (this._maxLength = h.maxLength);
          }
          function a(h) {
            return new l(h);
          }
          function n(h, m) {
            h._handle && (h._handle.close(), h._handle = null);
          }
          l.prototype._processChunk = function(h, m, s) {
            if (typeof s == "function")
              return E.Inflate._processChunk.call(this, h, m, s);
            var b = this, S = h && h.length, o = this._chunkSize - this._offset, A = this._maxLength, T = 0, I = [], L = 0, z;
            this.on("error", function(oe) {
              z = oe;
            });
            function U(oe, ee) {
              if (!b._hadError) {
                var ie = o - ee;
                if (y(ie >= 0, "have should not go down"), ie > 0) {
                  var W = b._buffer.slice(b._offset, b._offset + ie);
                  if (b._offset += ie, W.length > A && (W = W.slice(0, A)), I.push(W), L += W.length, A -= W.length, A === 0)
                    return !1;
                }
                return (ee === 0 || b._offset >= b._chunkSize) && (o = b._chunkSize, b._offset = 0, b._buffer = x.allocUnsafe(b._chunkSize)), ee === 0 ? (T += S - oe, S = oe, !0) : !1;
              }
            }
            y(this._handle, "zlib binding closed");
            do {
              var J = this._handle.writeSync(
                m,
                h,
                // in
                T,
                // in_off
                S,
                // in_len
                this._buffer,
                // out
                this._offset,
                //out_off
                o
              );
              J = J || this._writeState;
            } while (!this._hadError && U(J[0], J[1]));
            if (this._hadError)
              throw z;
            if (L >= u)
              throw n(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + u.toString(16) + " bytes");
            var F = x.concat(I, L);
            return n(this), F;
          }, c.inherits(l, E.Inflate);
          function d(h, m) {
            if (typeof m == "string" && (m = x.from(m)), !(m instanceof x))
              throw new TypeError("Not a string or buffer");
            var s = h._finishFlushFlag;
            return s == null && (s = E.Z_FINISH), h._processChunk(m, s);
          }
          function g(h, m) {
            return d(new l(m), h);
          }
          Z.exports = _ = g, _.Inflate = l, _.createInflate = a, _.inflateSync = g;
        }).call(this, k("_process"), k("buffer").Buffer);
      }, { _process: 133, assert: 25, buffer: 48, util: 186, zlib: 35 }], 131: [function(k, Z, _) {
        var M = Z.exports = function(x) {
          this._buffer = x, this._reads = [];
        };
        M.prototype.read = function(x, y) {
          this._reads.push({
            length: Math.abs(x),
            // if length < 0 then at most this length
            allowLess: x < 0,
            func: y
          });
        }, M.prototype.process = function() {
          for (; this._reads.length > 0 && this._buffer.length; ) {
            var x = this._reads[0];
            if (this._buffer.length && (this._buffer.length >= x.length || x.allowLess)) {
              this._reads.shift();
              var y = this._buffer;
              this._buffer = y.slice(x.length), x.func.call(this, y.slice(0, x.length));
            } else
              break;
          }
          if (this._reads.length > 0)
            return new Error("There are some read requests waitng on finished stream");
          if (this._buffer.length > 0)
            return new Error("unrecognised content at end of stream");
        };
      }, {}], 132: [function(k, Z, _) {
        (function(M) {
          typeof M > "u" || !M.version || M.version.indexOf("v0.") === 0 || M.version.indexOf("v1.") === 0 && M.version.indexOf("v1.8.") !== 0 ? Z.exports = { nextTick: x } : Z.exports = M;
          function x(y, E, c, u) {
            if (typeof y != "function")
              throw new TypeError('"callback" argument must be a function');
            var l = arguments.length, a, n;
            switch (l) {
              case 0:
              case 1:
                return M.nextTick(y);
              case 2:
                return M.nextTick(function() {
                  y.call(null, E);
                });
              case 3:
                return M.nextTick(function() {
                  y.call(null, E, c);
                });
              case 4:
                return M.nextTick(function() {
                  y.call(null, E, c, u);
                });
              default:
                for (a = new Array(l - 1), n = 0; n < a.length; )
                  a[n++] = arguments[n];
                return M.nextTick(function() {
                  y.apply(null, a);
                });
            }
          }
        }).call(this, k("_process"));
      }, { _process: 133 }], 133: [function(k, Z, _) {
        var M = Z.exports = {}, x, y;
        function E() {
          throw new Error("setTimeout has not been defined");
        }
        function c() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? x = setTimeout : x = E;
          } catch {
            x = E;
          }
          try {
            typeof clearTimeout == "function" ? y = clearTimeout : y = c;
          } catch {
            y = c;
          }
        })();
        function u(S) {
          if (x === setTimeout)
            return setTimeout(S, 0);
          if ((x === E || !x) && setTimeout)
            return x = setTimeout, setTimeout(S, 0);
          try {
            return x(S, 0);
          } catch {
            try {
              return x.call(null, S, 0);
            } catch {
              return x.call(this, S, 0);
            }
          }
        }
        function l(S) {
          if (y === clearTimeout)
            return clearTimeout(S);
          if ((y === c || !y) && clearTimeout)
            return y = clearTimeout, clearTimeout(S);
          try {
            return y(S);
          } catch {
            try {
              return y.call(null, S);
            } catch {
              return y.call(this, S);
            }
          }
        }
        var a = [], n = !1, d, g = -1;
        function h() {
          !n || !d || (n = !1, d.length ? a = d.concat(a) : g = -1, a.length && m());
        }
        function m() {
          if (!n) {
            var S = u(h);
            n = !0;
            for (var o = a.length; o; ) {
              for (d = a, a = []; ++g < o; )
                d && d[g].run();
              g = -1, o = a.length;
            }
            d = null, n = !1, l(S);
          }
        }
        M.nextTick = function(S) {
          var o = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var A = 1; A < arguments.length; A++)
              o[A - 1] = arguments[A];
          a.push(new s(S, o)), a.length === 1 && !n && u(m);
        };
        function s(S, o) {
          this.fun = S, this.array = o;
        }
        s.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, M.title = "browser", M.browser = !0, M.env = {}, M.argv = [], M.version = "", M.versions = {};
        function b() {
        }
        M.on = b, M.addListener = b, M.once = b, M.off = b, M.removeListener = b, M.removeAllListeners = b, M.emit = b, M.prependListener = b, M.prependOnceListener = b, M.listeners = function(S) {
          return [];
        }, M.binding = function(S) {
          throw new Error("process.binding is not supported");
        }, M.cwd = function() {
          return "/";
        }, M.chdir = function(S) {
          throw new Error("process.chdir is not supported");
        }, M.umask = function() {
          return 0;
        };
      }, {}], 134: [function(k, Z, _) {
        (function(M) {
          (function(x) {
            var y = typeof _ == "object" && _ && !_.nodeType && _, E = typeof Z == "object" && Z && !Z.nodeType && Z, c = typeof M == "object" && M;
            (c.global === c || c.window === c || c.self === c) && (x = c);
            var u, l = 2147483647, a = 36, n = 1, d = 26, g = 38, h = 700, m = 72, s = 128, b = "-", S = /^xn--/, o = /[^\x20-\x7E]/, A = /[\x2E\u3002\uFF0E\uFF61]/g, T = {
              overflow: "Overflow: input needs wider integers to process",
              "not-basic": "Illegal input >= 0x80 (not a basic code point)",
              "invalid-input": "Invalid input"
            }, I = a - n, L = Math.floor, z = String.fromCharCode, U;
            function J(xe) {
              throw new RangeError(T[xe]);
            }
            function F(xe, Ee) {
              for (var Pe = xe.length, Ue = []; Pe--; )
                Ue[Pe] = Ee(xe[Pe]);
              return Ue;
            }
            function oe(xe, Ee) {
              var Pe = xe.split("@"), Ue = "";
              Pe.length > 1 && (Ue = Pe[0] + "@", xe = Pe[1]), xe = xe.replace(A, ".");
              var He = xe.split("."), We = F(He, Ee).join(".");
              return Ue + We;
            }
            function ee(xe) {
              for (var Ee = [], Pe = 0, Ue = xe.length, He, We; Pe < Ue; )
                He = xe.charCodeAt(Pe++), He >= 55296 && He <= 56319 && Pe < Ue ? (We = xe.charCodeAt(Pe++), (We & 64512) == 56320 ? Ee.push(((He & 1023) << 10) + (We & 1023) + 65536) : (Ee.push(He), Pe--)) : Ee.push(He);
              return Ee;
            }
            function ie(xe) {
              return F(xe, function(Ee) {
                var Pe = "";
                return Ee > 65535 && (Ee -= 65536, Pe += z(Ee >>> 10 & 1023 | 55296), Ee = 56320 | Ee & 1023), Pe += z(Ee), Pe;
              }).join("");
            }
            function W(xe) {
              return xe - 48 < 10 ? xe - 22 : xe - 65 < 26 ? xe - 65 : xe - 97 < 26 ? xe - 97 : a;
            }
            function Q(xe, Ee) {
              return xe + 22 + 75 * (xe < 26) - ((Ee != 0) << 5);
            }
            function de(xe, Ee, Pe) {
              var Ue = 0;
              for (xe = Pe ? L(xe / h) : xe >> 1, xe += L(xe / Ee); xe > I * d >> 1; Ue += a)
                xe = L(xe / I);
              return L(Ue + (I + 1) * xe / (xe + g));
            }
            function we(xe) {
              var Ee = [], Pe = xe.length, Ue, He = 0, We = s, Ze = m, $e, Ve, Ge, Ie, De, Ne, _e, re, $;
              for ($e = xe.lastIndexOf(b), $e < 0 && ($e = 0), Ve = 0; Ve < $e; ++Ve)
                xe.charCodeAt(Ve) >= 128 && J("not-basic"), Ee.push(xe.charCodeAt(Ve));
              for (Ge = $e > 0 ? $e + 1 : 0; Ge < Pe; ) {
                for (Ie = He, De = 1, Ne = a; Ge >= Pe && J("invalid-input"), _e = W(xe.charCodeAt(Ge++)), (_e >= a || _e > L((l - He) / De)) && J("overflow"), He += _e * De, re = Ne <= Ze ? n : Ne >= Ze + d ? d : Ne - Ze, !(_e < re); Ne += a)
                  $ = a - re, De > L(l / $) && J("overflow"), De *= $;
                Ue = Ee.length + 1, Ze = de(He - Ie, Ue, Ie == 0), L(He / Ue) > l - We && J("overflow"), We += L(He / Ue), He %= Ue, Ee.splice(He++, 0, We);
              }
              return ie(Ee);
            }
            function ke(xe) {
              var Ee, Pe, Ue, He, We, Ze, $e, Ve, Ge, Ie, De, Ne = [], _e, re, $, Ce;
              for (xe = ee(xe), _e = xe.length, Ee = s, Pe = 0, We = m, Ze = 0; Ze < _e; ++Ze)
                De = xe[Ze], De < 128 && Ne.push(z(De));
              for (Ue = He = Ne.length, He && Ne.push(b); Ue < _e; ) {
                for ($e = l, Ze = 0; Ze < _e; ++Ze)
                  De = xe[Ze], De >= Ee && De < $e && ($e = De);
                for (re = Ue + 1, $e - Ee > L((l - Pe) / re) && J("overflow"), Pe += ($e - Ee) * re, Ee = $e, Ze = 0; Ze < _e; ++Ze)
                  if (De = xe[Ze], De < Ee && ++Pe > l && J("overflow"), De == Ee) {
                    for (Ve = Pe, Ge = a; Ie = Ge <= We ? n : Ge >= We + d ? d : Ge - We, !(Ve < Ie); Ge += a)
                      Ce = Ve - Ie, $ = a - Ie, Ne.push(
                        z(Q(Ie + Ce % $, 0))
                      ), Ve = L(Ce / $);
                    Ne.push(z(Q(Ve, 0))), We = de(Pe, re, Ue == He), Pe = 0, ++Ue;
                  }
                ++Pe, ++Ee;
              }
              return Ne.join("");
            }
            function Me(xe) {
              return oe(xe, function(Ee) {
                return S.test(Ee) ? we(Ee.slice(4).toLowerCase()) : Ee;
              });
            }
            function fe(xe) {
              return oe(xe, function(Ee) {
                return o.test(Ee) ? "xn--" + ke(Ee) : Ee;
              });
            }
            if (u = {
              /**
               * A string representing the current Punycode.js version number.
               * @memberOf punycode
               * @type String
               */
              version: "1.4.1",
              /**
               * An object of methods to convert from JavaScript's internal character
               * representation (UCS-2) to Unicode code points, and back.
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode
               * @type Object
               */
              ucs2: {
                decode: ee,
                encode: ie
              },
              decode: we,
              encode: ke,
              toASCII: fe,
              toUnicode: Me
            }, y && E)
              if (Z.exports == y)
                E.exports = u;
              else
                for (U in u)
                  u.hasOwnProperty(U) && (y[U] = u[U]);
            else
              x.punycode = u;
          })(this);
        }).call(this, typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {});
      }, {}], 135: [function(k, Z, _) {
        function M(y, E) {
          return Object.prototype.hasOwnProperty.call(y, E);
        }
        Z.exports = function(y, E, c, u) {
          E = E || "&", c = c || "=";
          var l = {};
          if (typeof y != "string" || y.length === 0)
            return l;
          var a = /\+/g;
          y = y.split(E);
          var n = 1e3;
          u && typeof u.maxKeys == "number" && (n = u.maxKeys);
          var d = y.length;
          n > 0 && d > n && (d = n);
          for (var g = 0; g < d; ++g) {
            var h = y[g].replace(a, "%20"), m = h.indexOf(c), s, b, S, o;
            m >= 0 ? (s = h.substr(0, m), b = h.substr(m + 1)) : (s = h, b = ""), S = decodeURIComponent(s), o = decodeURIComponent(b), M(l, S) ? x(l[S]) ? l[S].push(o) : l[S] = [l[S], o] : l[S] = o;
          }
          return l;
        };
        var x = Array.isArray || function(y) {
          return Object.prototype.toString.call(y) === "[object Array]";
        };
      }, {}], 136: [function(k, Z, _) {
        var M = function(c) {
          switch (typeof c) {
            case "string":
              return c;
            case "boolean":
              return c ? "true" : "false";
            case "number":
              return isFinite(c) ? c : "";
            default:
              return "";
          }
        };
        Z.exports = function(c, u, l, a) {
          return u = u || "&", l = l || "=", c === null && (c = void 0), typeof c == "object" ? y(E(c), function(n) {
            var d = encodeURIComponent(M(n)) + l;
            return x(c[n]) ? y(c[n], function(g) {
              return d + encodeURIComponent(M(g));
            }).join(u) : d + encodeURIComponent(M(c[n]));
          }).join(u) : a ? encodeURIComponent(M(a)) + l + encodeURIComponent(M(c)) : "";
        };
        var x = Array.isArray || function(c) {
          return Object.prototype.toString.call(c) === "[object Array]";
        };
        function y(c, u) {
          if (c.map) return c.map(u);
          for (var l = [], a = 0; a < c.length; a++)
            l.push(u(c[a], a));
          return l;
        }
        var E = Object.keys || function(c) {
          var u = [];
          for (var l in c)
            Object.prototype.hasOwnProperty.call(c, l) && u.push(l);
          return u;
        };
      }, {}], 137: [function(k, Z, _) {
        _.decode = _.parse = k("./decode"), _.encode = _.stringify = k("./encode");
      }, { "./decode": 135, "./encode": 136 }], 138: [function(k, Z, _) {
        Z.exports = k("./lib/_stream_duplex.js");
      }, { "./lib/_stream_duplex.js": 139 }], 139: [function(k, Z, _) {
        var M = k("process-nextick-args"), x = Object.keys || function(h) {
          var m = [];
          for (var s in h)
            m.push(s);
          return m;
        };
        Z.exports = n;
        var y = k("core-util-is");
        y.inherits = k("inherits");
        var E = k("./_stream_readable"), c = k("./_stream_writable");
        y.inherits(n, E);
        for (var u = x(c.prototype), l = 0; l < u.length; l++) {
          var a = u[l];
          n.prototype[a] || (n.prototype[a] = c.prototype[a]);
        }
        function n(h) {
          if (!(this instanceof n)) return new n(h);
          E.call(this, h), c.call(this, h), h && h.readable === !1 && (this.readable = !1), h && h.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, h && h.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", d);
        }
        Object.defineProperty(n.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: !1,
          get: function() {
            return this._writableState.highWaterMark;
          }
        });
        function d() {
          this.allowHalfOpen || this._writableState.ended || M.nextTick(g, this);
        }
        function g(h) {
          h.end();
        }
        Object.defineProperty(n.prototype, "destroyed", {
          get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
          },
          set: function(h) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = h, this._writableState.destroyed = h);
          }
        }), n.prototype._destroy = function(h, m) {
          this.push(null), this.end(), M.nextTick(m, h);
        };
      }, { "./_stream_readable": 141, "./_stream_writable": 143, "core-util-is": 51, inherits: 75, "process-nextick-args": 132 }], 140: [function(k, Z, _) {
        Z.exports = y;
        var M = k("./_stream_transform"), x = k("core-util-is");
        x.inherits = k("inherits"), x.inherits(y, M);
        function y(E) {
          if (!(this instanceof y)) return new y(E);
          M.call(this, E);
        }
        y.prototype._transform = function(E, c, u) {
          u(null, E);
        };
      }, { "./_stream_transform": 142, "core-util-is": 51, inherits: 75 }], 141: [function(k, Z, _) {
        (function(M, x) {
          var y = k("process-nextick-args");
          Z.exports = L;
          var E = k("isarray"), c;
          L.ReadableState = I, k("events").EventEmitter;
          var u = function(Ie, De) {
            return Ie.listeners(De).length;
          }, l = k("./internal/streams/stream"), a = k("safe-buffer").Buffer, n = x.Uint8Array || function() {
          };
          function d(Ie) {
            return a.from(Ie);
          }
          function g(Ie) {
            return a.isBuffer(Ie) || Ie instanceof n;
          }
          var h = k("core-util-is");
          h.inherits = k("inherits");
          var m = k("util"), s = void 0;
          m && m.debuglog ? s = m.debuglog("stream") : s = function() {
          };
          var b = k("./internal/streams/BufferList"), S = k("./internal/streams/destroy"), o;
          h.inherits(L, l);
          var A = ["error", "close", "destroy", "pause", "resume"];
          function T(Ie, De, Ne) {
            if (typeof Ie.prependListener == "function") return Ie.prependListener(De, Ne);
            !Ie._events || !Ie._events[De] ? Ie.on(De, Ne) : E(Ie._events[De]) ? Ie._events[De].unshift(Ne) : Ie._events[De] = [Ne, Ie._events[De]];
          }
          function I(Ie, De) {
            c = c || k("./_stream_duplex"), Ie = Ie || {};
            var Ne = De instanceof c;
            this.objectMode = !!Ie.objectMode, Ne && (this.objectMode = this.objectMode || !!Ie.readableObjectMode);
            var _e = Ie.highWaterMark, re = Ie.readableHighWaterMark, $ = this.objectMode ? 16 : 16 * 1024;
            _e || _e === 0 ? this.highWaterMark = _e : Ne && (re || re === 0) ? this.highWaterMark = re : this.highWaterMark = $, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new b(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Ie.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Ie.encoding && (o || (o = k("string_decoder/").StringDecoder), this.decoder = new o(Ie.encoding), this.encoding = Ie.encoding);
          }
          function L(Ie) {
            if (c = c || k("./_stream_duplex"), !(this instanceof L)) return new L(Ie);
            this._readableState = new I(Ie, this), this.readable = !0, Ie && (typeof Ie.read == "function" && (this._read = Ie.read), typeof Ie.destroy == "function" && (this._destroy = Ie.destroy)), l.call(this);
          }
          Object.defineProperty(L.prototype, "destroyed", {
            get: function() {
              return this._readableState === void 0 ? !1 : this._readableState.destroyed;
            },
            set: function(Ie) {
              this._readableState && (this._readableState.destroyed = Ie);
            }
          }), L.prototype.destroy = S.destroy, L.prototype._undestroy = S.undestroy, L.prototype._destroy = function(Ie, De) {
            this.push(null), De(Ie);
          }, L.prototype.push = function(Ie, De) {
            var Ne = this._readableState, _e;
            return Ne.objectMode ? _e = !0 : typeof Ie == "string" && (De = De || Ne.defaultEncoding, De !== Ne.encoding && (Ie = a.from(Ie, De), De = ""), _e = !0), z(this, Ie, De, !1, _e);
          }, L.prototype.unshift = function(Ie) {
            return z(this, Ie, null, !0, !1);
          };
          function z(Ie, De, Ne, _e, re) {
            var $ = Ie._readableState;
            if (De === null)
              $.reading = !1, W(Ie, $);
            else {
              var Ce;
              re || (Ce = J($, De)), Ce ? Ie.emit("error", Ce) : $.objectMode || De && De.length > 0 ? (typeof De != "string" && !$.objectMode && Object.getPrototypeOf(De) !== a.prototype && (De = d(De)), _e ? $.endEmitted ? Ie.emit("error", new Error("stream.unshift() after end event")) : U(Ie, $, De, !0) : $.ended ? Ie.emit("error", new Error("stream.push() after EOF")) : ($.reading = !1, $.decoder && !Ne ? (De = $.decoder.write(De), $.objectMode || De.length !== 0 ? U(Ie, $, De, !1) : we(Ie, $)) : U(Ie, $, De, !1))) : _e || ($.reading = !1);
            }
            return F($);
          }
          function U(Ie, De, Ne, _e) {
            De.flowing && De.length === 0 && !De.sync ? (Ie.emit("data", Ne), Ie.read(0)) : (De.length += De.objectMode ? 1 : Ne.length, _e ? De.buffer.unshift(Ne) : De.buffer.push(Ne), De.needReadable && Q(Ie)), we(Ie, De);
          }
          function J(Ie, De) {
            var Ne;
            return !g(De) && typeof De != "string" && De !== void 0 && !Ie.objectMode && (Ne = new TypeError("Invalid non-string/buffer chunk")), Ne;
          }
          function F(Ie) {
            return !Ie.ended && (Ie.needReadable || Ie.length < Ie.highWaterMark || Ie.length === 0);
          }
          L.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, L.prototype.setEncoding = function(Ie) {
            return o || (o = k("string_decoder/").StringDecoder), this._readableState.decoder = new o(Ie), this._readableState.encoding = Ie, this;
          };
          var oe = 8388608;
          function ee(Ie) {
            return Ie >= oe ? Ie = oe : (Ie--, Ie |= Ie >>> 1, Ie |= Ie >>> 2, Ie |= Ie >>> 4, Ie |= Ie >>> 8, Ie |= Ie >>> 16, Ie++), Ie;
          }
          function ie(Ie, De) {
            return Ie <= 0 || De.length === 0 && De.ended ? 0 : De.objectMode ? 1 : Ie !== Ie ? De.flowing && De.length ? De.buffer.head.data.length : De.length : (Ie > De.highWaterMark && (De.highWaterMark = ee(Ie)), Ie <= De.length ? Ie : De.ended ? De.length : (De.needReadable = !0, 0));
          }
          L.prototype.read = function(Ie) {
            s("read", Ie), Ie = parseInt(Ie, 10);
            var De = this._readableState, Ne = Ie;
            if (Ie !== 0 && (De.emittedReadable = !1), Ie === 0 && De.needReadable && (De.length >= De.highWaterMark || De.ended))
              return s("read: emitReadable", De.length, De.ended), De.length === 0 && De.ended ? $e(this) : Q(this), null;
            if (Ie = ie(Ie, De), Ie === 0 && De.ended)
              return De.length === 0 && $e(this), null;
            var _e = De.needReadable;
            s("need readable", _e), (De.length === 0 || De.length - Ie < De.highWaterMark) && (_e = !0, s("length less than watermark", _e)), De.ended || De.reading ? (_e = !1, s("reading or ended", _e)) : _e && (s("do read"), De.reading = !0, De.sync = !0, De.length === 0 && (De.needReadable = !0), this._read(De.highWaterMark), De.sync = !1, De.reading || (Ie = ie(Ne, De)));
            var re;
            return Ie > 0 ? re = Ue(Ie, De) : re = null, re === null ? (De.needReadable = !0, Ie = 0) : De.length -= Ie, De.length === 0 && (De.ended || (De.needReadable = !0), Ne !== Ie && De.ended && $e(this)), re !== null && this.emit("data", re), re;
          };
          function W(Ie, De) {
            if (!De.ended) {
              if (De.decoder) {
                var Ne = De.decoder.end();
                Ne && Ne.length && (De.buffer.push(Ne), De.length += De.objectMode ? 1 : Ne.length);
              }
              De.ended = !0, Q(Ie);
            }
          }
          function Q(Ie) {
            var De = Ie._readableState;
            De.needReadable = !1, De.emittedReadable || (s("emitReadable", De.flowing), De.emittedReadable = !0, De.sync ? y.nextTick(de, Ie) : de(Ie));
          }
          function de(Ie) {
            s("emit readable"), Ie.emit("readable"), Pe(Ie);
          }
          function we(Ie, De) {
            De.readingMore || (De.readingMore = !0, y.nextTick(ke, Ie, De));
          }
          function ke(Ie, De) {
            for (var Ne = De.length; !De.reading && !De.flowing && !De.ended && De.length < De.highWaterMark && (s("maybeReadMore read 0"), Ie.read(0), Ne !== De.length); )
              Ne = De.length;
            De.readingMore = !1;
          }
          L.prototype._read = function(Ie) {
            this.emit("error", new Error("_read() is not implemented"));
          }, L.prototype.pipe = function(Ie, De) {
            var Ne = this, _e = this._readableState;
            switch (_e.pipesCount) {
              case 0:
                _e.pipes = Ie;
                break;
              case 1:
                _e.pipes = [_e.pipes, Ie];
                break;
              default:
                _e.pipes.push(Ie);
                break;
            }
            _e.pipesCount += 1, s("pipe count=%d opts=%j", _e.pipesCount, De);
            var re = (!De || De.end !== !1) && Ie !== M.stdout && Ie !== M.stderr, $ = re ? ve : B;
            _e.endEmitted ? y.nextTick($) : Ne.once("end", $), Ie.on("unpipe", Ce);
            function Ce(j, H) {
              s("onunpipe"), j === Ne && H && H.hasUnpiped === !1 && (H.hasUnpiped = !0, Ae());
            }
            function ve() {
              s("onend"), Ie.end();
            }
            var Y = Me(Ne);
            Ie.on("drain", Y);
            var G = !1;
            function Ae() {
              s("cleanup"), Ie.removeListener("close", C), Ie.removeListener("finish", R), Ie.removeListener("drain", Y), Ie.removeListener("error", f), Ie.removeListener("unpipe", Ce), Ne.removeListener("end", ve), Ne.removeListener("end", B), Ne.removeListener("data", r), G = !0, _e.awaitDrain && (!Ie._writableState || Ie._writableState.needDrain) && Y();
            }
            var e = !1;
            Ne.on("data", r);
            function r(j) {
              s("ondata"), e = !1;
              var H = Ie.write(j);
              H === !1 && !e && ((_e.pipesCount === 1 && _e.pipes === Ie || _e.pipesCount > 1 && Ge(_e.pipes, Ie) !== -1) && !G && (s("false write response, pause", Ne._readableState.awaitDrain), Ne._readableState.awaitDrain++, e = !0), Ne.pause());
            }
            function f(j) {
              s("onerror", j), B(), Ie.removeListener("error", f), u(Ie, "error") === 0 && Ie.emit("error", j);
            }
            T(Ie, "error", f);
            function C() {
              Ie.removeListener("finish", R), B();
            }
            Ie.once("close", C);
            function R() {
              s("onfinish"), Ie.removeListener("close", C), B();
            }
            Ie.once("finish", R);
            function B() {
              s("unpipe"), Ne.unpipe(Ie);
            }
            return Ie.emit("pipe", Ne), _e.flowing || (s("pipe resume"), Ne.resume()), Ie;
          };
          function Me(Ie) {
            return function() {
              var De = Ie._readableState;
              s("pipeOnDrain", De.awaitDrain), De.awaitDrain && De.awaitDrain--, De.awaitDrain === 0 && u(Ie, "data") && (De.flowing = !0, Pe(Ie));
            };
          }
          L.prototype.unpipe = function(Ie) {
            var De = this._readableState, Ne = { hasUnpiped: !1 };
            if (De.pipesCount === 0) return this;
            if (De.pipesCount === 1)
              return Ie && Ie !== De.pipes ? this : (Ie || (Ie = De.pipes), De.pipes = null, De.pipesCount = 0, De.flowing = !1, Ie && Ie.emit("unpipe", this, Ne), this);
            if (!Ie) {
              var _e = De.pipes, re = De.pipesCount;
              De.pipes = null, De.pipesCount = 0, De.flowing = !1;
              for (var $ = 0; $ < re; $++)
                _e[$].emit("unpipe", this, Ne);
              return this;
            }
            var Ce = Ge(De.pipes, Ie);
            return Ce === -1 ? this : (De.pipes.splice(Ce, 1), De.pipesCount -= 1, De.pipesCount === 1 && (De.pipes = De.pipes[0]), Ie.emit("unpipe", this, Ne), this);
          }, L.prototype.on = function(Ie, De) {
            var Ne = l.prototype.on.call(this, Ie, De);
            if (Ie === "data")
              this._readableState.flowing !== !1 && this.resume();
            else if (Ie === "readable") {
              var _e = this._readableState;
              !_e.endEmitted && !_e.readableListening && (_e.readableListening = _e.needReadable = !0, _e.emittedReadable = !1, _e.reading ? _e.length && Q(this) : y.nextTick(fe, this));
            }
            return Ne;
          }, L.prototype.addListener = L.prototype.on;
          function fe(Ie) {
            s("readable nexttick read 0"), Ie.read(0);
          }
          L.prototype.resume = function() {
            var Ie = this._readableState;
            return Ie.flowing || (s("resume"), Ie.flowing = !0, xe(this, Ie)), this;
          };
          function xe(Ie, De) {
            De.resumeScheduled || (De.resumeScheduled = !0, y.nextTick(Ee, Ie, De));
          }
          function Ee(Ie, De) {
            De.reading || (s("resume read 0"), Ie.read(0)), De.resumeScheduled = !1, De.awaitDrain = 0, Ie.emit("resume"), Pe(Ie), De.flowing && !De.reading && Ie.read(0);
          }
          L.prototype.pause = function() {
            return s("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (s("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
          };
          function Pe(Ie) {
            var De = Ie._readableState;
            for (s("flow", De.flowing); De.flowing && Ie.read() !== null; )
              ;
          }
          L.prototype.wrap = function(Ie) {
            var De = this, Ne = this._readableState, _e = !1;
            Ie.on("end", function() {
              if (s("wrapped end"), Ne.decoder && !Ne.ended) {
                var Ce = Ne.decoder.end();
                Ce && Ce.length && De.push(Ce);
              }
              De.push(null);
            }), Ie.on("data", function(Ce) {
              if (s("wrapped data"), Ne.decoder && (Ce = Ne.decoder.write(Ce)), !(Ne.objectMode && Ce == null) && !(!Ne.objectMode && (!Ce || !Ce.length))) {
                var ve = De.push(Ce);
                ve || (_e = !0, Ie.pause());
              }
            });
            for (var re in Ie)
              this[re] === void 0 && typeof Ie[re] == "function" && (this[re] = /* @__PURE__ */ function(Ce) {
                return function() {
                  return Ie[Ce].apply(Ie, arguments);
                };
              }(re));
            for (var $ = 0; $ < A.length; $++)
              Ie.on(A[$], this.emit.bind(this, A[$]));
            return this._read = function(Ce) {
              s("wrapped _read", Ce), _e && (_e = !1, Ie.resume());
            }, this;
          }, Object.defineProperty(L.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.highWaterMark;
            }
          }), L._fromList = Ue;
          function Ue(Ie, De) {
            if (De.length === 0) return null;
            var Ne;
            return De.objectMode ? Ne = De.buffer.shift() : !Ie || Ie >= De.length ? (De.decoder ? Ne = De.buffer.join("") : De.buffer.length === 1 ? Ne = De.buffer.head.data : Ne = De.buffer.concat(De.length), De.buffer.clear()) : Ne = He(Ie, De.buffer, De.decoder), Ne;
          }
          function He(Ie, De, Ne) {
            var _e;
            return Ie < De.head.data.length ? (_e = De.head.data.slice(0, Ie), De.head.data = De.head.data.slice(Ie)) : Ie === De.head.data.length ? _e = De.shift() : _e = Ne ? We(Ie, De) : Ze(Ie, De), _e;
          }
          function We(Ie, De) {
            var Ne = De.head, _e = 1, re = Ne.data;
            for (Ie -= re.length; Ne = Ne.next; ) {
              var $ = Ne.data, Ce = Ie > $.length ? $.length : Ie;
              if (Ce === $.length ? re += $ : re += $.slice(0, Ie), Ie -= Ce, Ie === 0) {
                Ce === $.length ? (++_e, Ne.next ? De.head = Ne.next : De.head = De.tail = null) : (De.head = Ne, Ne.data = $.slice(Ce));
                break;
              }
              ++_e;
            }
            return De.length -= _e, re;
          }
          function Ze(Ie, De) {
            var Ne = a.allocUnsafe(Ie), _e = De.head, re = 1;
            for (_e.data.copy(Ne), Ie -= _e.data.length; _e = _e.next; ) {
              var $ = _e.data, Ce = Ie > $.length ? $.length : Ie;
              if ($.copy(Ne, Ne.length - Ie, 0, Ce), Ie -= Ce, Ie === 0) {
                Ce === $.length ? (++re, _e.next ? De.head = _e.next : De.head = De.tail = null) : (De.head = _e, _e.data = $.slice(Ce));
                break;
              }
              ++re;
            }
            return De.length -= re, Ne;
          }
          function $e(Ie) {
            var De = Ie._readableState;
            if (De.length > 0) throw new Error('"endReadable()" called on non-empty stream');
            De.endEmitted || (De.ended = !0, y.nextTick(Ve, De, Ie));
          }
          function Ve(Ie, De) {
            !Ie.endEmitted && Ie.length === 0 && (Ie.endEmitted = !0, De.readable = !1, De.emit("end"));
          }
          function Ge(Ie, De) {
            for (var Ne = 0, _e = Ie.length; Ne < _e; Ne++)
              if (Ie[Ne] === De) return Ne;
            return -1;
          }
        }).call(this, k("_process"), typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {});
      }, { "./_stream_duplex": 139, "./internal/streams/BufferList": 144, "./internal/streams/destroy": 145, "./internal/streams/stream": 146, _process: 133, "core-util-is": 51, events: 52, inherits: 75, isarray: 79, "process-nextick-args": 132, "safe-buffer": 147, "string_decoder/": 148, util: 33 }], 142: [function(k, Z, _) {
        Z.exports = E;
        var M = k("./_stream_duplex"), x = k("core-util-is");
        x.inherits = k("inherits"), x.inherits(E, M);
        function y(l, a) {
          var n = this._transformState;
          n.transforming = !1;
          var d = n.writecb;
          if (!d)
            return this.emit("error", new Error("write callback called multiple times"));
          n.writechunk = null, n.writecb = null, a != null && this.push(a), d(l);
          var g = this._readableState;
          g.reading = !1, (g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark);
        }
        function E(l) {
          if (!(this instanceof E)) return new E(l);
          M.call(this, l), this._transformState = {
            afterTransform: y.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }, this._readableState.needReadable = !0, this._readableState.sync = !1, l && (typeof l.transform == "function" && (this._transform = l.transform), typeof l.flush == "function" && (this._flush = l.flush)), this.on("prefinish", c);
        }
        function c() {
          var l = this;
          typeof this._flush == "function" ? this._flush(function(a, n) {
            u(l, a, n);
          }) : u(this, null, null);
        }
        E.prototype.push = function(l, a) {
          return this._transformState.needTransform = !1, M.prototype.push.call(this, l, a);
        }, E.prototype._transform = function(l, a, n) {
          throw new Error("_transform() is not implemented");
        }, E.prototype._write = function(l, a, n) {
          var d = this._transformState;
          if (d.writecb = n, d.writechunk = l, d.writeencoding = a, !d.transforming) {
            var g = this._readableState;
            (d.needTransform || g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark);
          }
        }, E.prototype._read = function(l) {
          var a = this._transformState;
          a.writechunk !== null && a.writecb && !a.transforming ? (a.transforming = !0, this._transform(a.writechunk, a.writeencoding, a.afterTransform)) : a.needTransform = !0;
        }, E.prototype._destroy = function(l, a) {
          var n = this;
          M.prototype._destroy.call(this, l, function(d) {
            a(d), n.emit("close");
          });
        };
        function u(l, a, n) {
          if (a) return l.emit("error", a);
          if (n != null && l.push(n), l._writableState.length) throw new Error("Calling transform done when ws.length != 0");
          if (l._transformState.transforming) throw new Error("Calling transform done when still transforming");
          return l.push(null);
        }
      }, { "./_stream_duplex": 139, "core-util-is": 51, inherits: 75 }], 143: [function(k, Z, _) {
        (function(M, x, y) {
          var E = k("process-nextick-args");
          Z.exports = T;
          function c(Ee) {
            var Pe = this;
            this.next = null, this.entry = null, this.finish = function() {
              xe(Pe, Ee);
            };
          }
          var u = !M.browser && ["v0.10", "v0.9."].indexOf(M.version.slice(0, 5)) > -1 ? y : E.nextTick, l;
          T.WritableState = o;
          var a = k("core-util-is");
          a.inherits = k("inherits");
          var n = {
            deprecate: k("util-deprecate")
          }, d = k("./internal/streams/stream"), g = k("safe-buffer").Buffer, h = x.Uint8Array || function() {
          };
          function m(Ee) {
            return g.from(Ee);
          }
          function s(Ee) {
            return g.isBuffer(Ee) || Ee instanceof h;
          }
          var b = k("./internal/streams/destroy");
          a.inherits(T, d);
          function S() {
          }
          function o(Ee, Pe) {
            l = l || k("./_stream_duplex"), Ee = Ee || {};
            var Ue = Pe instanceof l;
            this.objectMode = !!Ee.objectMode, Ue && (this.objectMode = this.objectMode || !!Ee.writableObjectMode);
            var He = Ee.highWaterMark, We = Ee.writableHighWaterMark, Ze = this.objectMode ? 16 : 16 * 1024;
            He || He === 0 ? this.highWaterMark = He : Ue && (We || We === 0) ? this.highWaterMark = We : this.highWaterMark = Ze, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var $e = Ee.decodeStrings === !1;
            this.decodeStrings = !$e, this.defaultEncoding = Ee.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ve) {
              ee(Pe, Ve);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new c(this);
          }
          o.prototype.getBuffer = function() {
            for (var Pe = this.bufferedRequest, Ue = []; Pe; )
              Ue.push(Pe), Pe = Pe.next;
            return Ue;
          }, function() {
            try {
              Object.defineProperty(o.prototype, "buffer", {
                get: n.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch {
            }
          }();
          var A;
          typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (A = Function.prototype[Symbol.hasInstance], Object.defineProperty(T, Symbol.hasInstance, {
            value: function(Ee) {
              return A.call(this, Ee) ? !0 : this !== T ? !1 : Ee && Ee._writableState instanceof o;
            }
          })) : A = function(Ee) {
            return Ee instanceof this;
          };
          function T(Ee) {
            if (l = l || k("./_stream_duplex"), !A.call(T, this) && !(this instanceof l))
              return new T(Ee);
            this._writableState = new o(Ee, this), this.writable = !0, Ee && (typeof Ee.write == "function" && (this._write = Ee.write), typeof Ee.writev == "function" && (this._writev = Ee.writev), typeof Ee.destroy == "function" && (this._destroy = Ee.destroy), typeof Ee.final == "function" && (this._final = Ee.final)), d.call(this);
          }
          T.prototype.pipe = function() {
            this.emit("error", new Error("Cannot pipe, not readable"));
          };
          function I(Ee, Pe) {
            var Ue = new Error("write after end");
            Ee.emit("error", Ue), E.nextTick(Pe, Ue);
          }
          function L(Ee, Pe, Ue, He) {
            var We = !0, Ze = !1;
            return Ue === null ? Ze = new TypeError("May not write null values to stream") : typeof Ue != "string" && Ue !== void 0 && !Pe.objectMode && (Ze = new TypeError("Invalid non-string/buffer chunk")), Ze && (Ee.emit("error", Ze), E.nextTick(He, Ze), We = !1), We;
          }
          T.prototype.write = function(Ee, Pe, Ue) {
            var He = this._writableState, We = !1, Ze = !He.objectMode && s(Ee);
            return Ze && !g.isBuffer(Ee) && (Ee = m(Ee)), typeof Pe == "function" && (Ue = Pe, Pe = null), Ze ? Pe = "buffer" : Pe || (Pe = He.defaultEncoding), typeof Ue != "function" && (Ue = S), He.ended ? I(this, Ue) : (Ze || L(this, He, Ee, Ue)) && (He.pendingcb++, We = U(this, He, Ze, Ee, Pe, Ue)), We;
          }, T.prototype.cork = function() {
            var Ee = this._writableState;
            Ee.corked++;
          }, T.prototype.uncork = function() {
            var Ee = this._writableState;
            Ee.corked && (Ee.corked--, !Ee.writing && !Ee.corked && !Ee.finished && !Ee.bufferProcessing && Ee.bufferedRequest && Q(this, Ee));
          }, T.prototype.setDefaultEncoding = function(Pe) {
            if (typeof Pe == "string" && (Pe = Pe.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Pe + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + Pe);
            return this._writableState.defaultEncoding = Pe, this;
          };
          function z(Ee, Pe, Ue) {
            return !Ee.objectMode && Ee.decodeStrings !== !1 && typeof Pe == "string" && (Pe = g.from(Pe, Ue)), Pe;
          }
          Object.defineProperty(T.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.highWaterMark;
            }
          });
          function U(Ee, Pe, Ue, He, We, Ze) {
            if (!Ue) {
              var $e = z(Pe, He, We);
              He !== $e && (Ue = !0, We = "buffer", He = $e);
            }
            var Ve = Pe.objectMode ? 1 : He.length;
            Pe.length += Ve;
            var Ge = Pe.length < Pe.highWaterMark;
            if (Ge || (Pe.needDrain = !0), Pe.writing || Pe.corked) {
              var Ie = Pe.lastBufferedRequest;
              Pe.lastBufferedRequest = {
                chunk: He,
                encoding: We,
                isBuf: Ue,
                callback: Ze,
                next: null
              }, Ie ? Ie.next = Pe.lastBufferedRequest : Pe.bufferedRequest = Pe.lastBufferedRequest, Pe.bufferedRequestCount += 1;
            } else
              J(Ee, Pe, !1, Ve, He, We, Ze);
            return Ge;
          }
          function J(Ee, Pe, Ue, He, We, Ze, $e) {
            Pe.writelen = He, Pe.writecb = $e, Pe.writing = !0, Pe.sync = !0, Ue ? Ee._writev(We, Pe.onwrite) : Ee._write(We, Ze, Pe.onwrite), Pe.sync = !1;
          }
          function F(Ee, Pe, Ue, He, We) {
            --Pe.pendingcb, Ue ? (E.nextTick(We, He), E.nextTick(Me, Ee, Pe), Ee._writableState.errorEmitted = !0, Ee.emit("error", He)) : (We(He), Ee._writableState.errorEmitted = !0, Ee.emit("error", He), Me(Ee, Pe));
          }
          function oe(Ee) {
            Ee.writing = !1, Ee.writecb = null, Ee.length -= Ee.writelen, Ee.writelen = 0;
          }
          function ee(Ee, Pe) {
            var Ue = Ee._writableState, He = Ue.sync, We = Ue.writecb;
            if (oe(Ue), Pe) F(Ee, Ue, He, Pe, We);
            else {
              var Ze = de(Ue);
              !Ze && !Ue.corked && !Ue.bufferProcessing && Ue.bufferedRequest && Q(Ee, Ue), He ? u(ie, Ee, Ue, Ze, We) : ie(Ee, Ue, Ze, We);
            }
          }
          function ie(Ee, Pe, Ue, He) {
            Ue || W(Ee, Pe), Pe.pendingcb--, He(), Me(Ee, Pe);
          }
          function W(Ee, Pe) {
            Pe.length === 0 && Pe.needDrain && (Pe.needDrain = !1, Ee.emit("drain"));
          }
          function Q(Ee, Pe) {
            Pe.bufferProcessing = !0;
            var Ue = Pe.bufferedRequest;
            if (Ee._writev && Ue && Ue.next) {
              var He = Pe.bufferedRequestCount, We = new Array(He), Ze = Pe.corkedRequestsFree;
              Ze.entry = Ue;
              for (var $e = 0, Ve = !0; Ue; )
                We[$e] = Ue, Ue.isBuf || (Ve = !1), Ue = Ue.next, $e += 1;
              We.allBuffers = Ve, J(Ee, Pe, !0, Pe.length, We, "", Ze.finish), Pe.pendingcb++, Pe.lastBufferedRequest = null, Ze.next ? (Pe.corkedRequestsFree = Ze.next, Ze.next = null) : Pe.corkedRequestsFree = new c(Pe), Pe.bufferedRequestCount = 0;
            } else {
              for (; Ue; ) {
                var Ge = Ue.chunk, Ie = Ue.encoding, De = Ue.callback, Ne = Pe.objectMode ? 1 : Ge.length;
                if (J(Ee, Pe, !1, Ne, Ge, Ie, De), Ue = Ue.next, Pe.bufferedRequestCount--, Pe.writing)
                  break;
              }
              Ue === null && (Pe.lastBufferedRequest = null);
            }
            Pe.bufferedRequest = Ue, Pe.bufferProcessing = !1;
          }
          T.prototype._write = function(Ee, Pe, Ue) {
            Ue(new Error("_write() is not implemented"));
          }, T.prototype._writev = null, T.prototype.end = function(Ee, Pe, Ue) {
            var He = this._writableState;
            typeof Ee == "function" ? (Ue = Ee, Ee = null, Pe = null) : typeof Pe == "function" && (Ue = Pe, Pe = null), Ee != null && this.write(Ee, Pe), He.corked && (He.corked = 1, this.uncork()), !He.ending && !He.finished && fe(this, He, Ue);
          };
          function de(Ee) {
            return Ee.ending && Ee.length === 0 && Ee.bufferedRequest === null && !Ee.finished && !Ee.writing;
          }
          function we(Ee, Pe) {
            Ee._final(function(Ue) {
              Pe.pendingcb--, Ue && Ee.emit("error", Ue), Pe.prefinished = !0, Ee.emit("prefinish"), Me(Ee, Pe);
            });
          }
          function ke(Ee, Pe) {
            !Pe.prefinished && !Pe.finalCalled && (typeof Ee._final == "function" ? (Pe.pendingcb++, Pe.finalCalled = !0, E.nextTick(we, Ee, Pe)) : (Pe.prefinished = !0, Ee.emit("prefinish")));
          }
          function Me(Ee, Pe) {
            var Ue = de(Pe);
            return Ue && (ke(Ee, Pe), Pe.pendingcb === 0 && (Pe.finished = !0, Ee.emit("finish"))), Ue;
          }
          function fe(Ee, Pe, Ue) {
            Pe.ending = !0, Me(Ee, Pe), Ue && (Pe.finished ? E.nextTick(Ue) : Ee.once("finish", Ue)), Pe.ended = !0, Ee.writable = !1;
          }
          function xe(Ee, Pe, Ue) {
            var He = Ee.entry;
            for (Ee.entry = null; He; ) {
              var We = He.callback;
              Pe.pendingcb--, We(Ue), He = He.next;
            }
            Pe.corkedRequestsFree ? Pe.corkedRequestsFree.next = Ee : Pe.corkedRequestsFree = Ee;
          }
          Object.defineProperty(T.prototype, "destroyed", {
            get: function() {
              return this._writableState === void 0 ? !1 : this._writableState.destroyed;
            },
            set: function(Ee) {
              this._writableState && (this._writableState.destroyed = Ee);
            }
          }), T.prototype.destroy = b.destroy, T.prototype._undestroy = b.undestroy, T.prototype._destroy = function(Ee, Pe) {
            this.end(), Pe(Ee);
          };
        }).call(this, k("_process"), typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {}, k("timers").setImmediate);
      }, { "./_stream_duplex": 139, "./internal/streams/destroy": 145, "./internal/streams/stream": 146, _process: 133, "core-util-is": 51, inherits: 75, "process-nextick-args": 132, "safe-buffer": 147, timers: 176, "util-deprecate": 183 }], 144: [function(k, Z, _) {
        function M(c, u) {
          if (!(c instanceof u))
            throw new TypeError("Cannot call a class as a function");
        }
        var x = k("safe-buffer").Buffer, y = k("util");
        function E(c, u, l) {
          c.copy(u, l);
        }
        Z.exports = function() {
          function c() {
            M(this, c), this.head = null, this.tail = null, this.length = 0;
          }
          return c.prototype.push = function(l) {
            var a = { data: l, next: null };
            this.length > 0 ? this.tail.next = a : this.head = a, this.tail = a, ++this.length;
          }, c.prototype.unshift = function(l) {
            var a = { data: l, next: this.head };
            this.length === 0 && (this.tail = a), this.head = a, ++this.length;
          }, c.prototype.shift = function() {
            if (this.length !== 0) {
              var l = this.head.data;
              return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, l;
            }
          }, c.prototype.clear = function() {
            this.head = this.tail = null, this.length = 0;
          }, c.prototype.join = function(l) {
            if (this.length === 0) return "";
            for (var a = this.head, n = "" + a.data; a = a.next; )
              n += l + a.data;
            return n;
          }, c.prototype.concat = function(l) {
            if (this.length === 0) return x.alloc(0);
            if (this.length === 1) return this.head.data;
            for (var a = x.allocUnsafe(l >>> 0), n = this.head, d = 0; n; )
              E(n.data, a, d), d += n.data.length, n = n.next;
            return a;
          }, c;
        }(), y && y.inspect && y.inspect.custom && (Z.exports.prototype[y.inspect.custom] = function() {
          var c = y.inspect({ length: this.length });
          return this.constructor.name + " " + c;
        });
      }, { "safe-buffer": 147, util: 33 }], 145: [function(k, Z, _) {
        var M = k("process-nextick-args");
        function x(c, u) {
          var l = this, a = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed;
          return a || n ? (u ? u(c) : c && (!this._writableState || !this._writableState.errorEmitted) && M.nextTick(E, this, c), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(c || null, function(d) {
            !u && d ? (M.nextTick(E, l, d), l._writableState && (l._writableState.errorEmitted = !0)) : u && u(d);
          }), this);
        }
        function y() {
          this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
        }
        function E(c, u) {
          c.emit("error", u);
        }
        Z.exports = {
          destroy: x,
          undestroy: y
        };
      }, { "process-nextick-args": 132 }], 146: [function(k, Z, _) {
        Z.exports = k("events").EventEmitter;
      }, { events: 52 }], 147: [function(k, Z, _) {
        var M = k("buffer"), x = M.Buffer;
        function y(c, u) {
          for (var l in c)
            u[l] = c[l];
        }
        x.from && x.alloc && x.allocUnsafe && x.allocUnsafeSlow ? Z.exports = M : (y(M, _), _.Buffer = E);
        function E(c, u, l) {
          return x(c, u, l);
        }
        y(x, E), E.from = function(c, u, l) {
          if (typeof c == "number")
            throw new TypeError("Argument must not be a number");
          return x(c, u, l);
        }, E.alloc = function(c, u, l) {
          if (typeof c != "number")
            throw new TypeError("Argument must be a number");
          var a = x(c);
          return u !== void 0 ? typeof l == "string" ? a.fill(u, l) : a.fill(u) : a.fill(0), a;
        }, E.allocUnsafe = function(c) {
          if (typeof c != "number")
            throw new TypeError("Argument must be a number");
          return x(c);
        }, E.allocUnsafeSlow = function(c) {
          if (typeof c != "number")
            throw new TypeError("Argument must be a number");
          return M.SlowBuffer(c);
        };
      }, { buffer: 48 }], 148: [function(k, Z, _) {
        var M = k("safe-buffer").Buffer, x = M.isEncoding || function(A) {
          switch (A = "" + A, A && A.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return !0;
            default:
              return !1;
          }
        };
        function y(A) {
          if (!A) return "utf8";
          for (var T; ; )
            switch (A) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return A;
              default:
                if (T) return;
                A = ("" + A).toLowerCase(), T = !0;
            }
        }
        function E(A) {
          var T = y(A);
          if (typeof T != "string" && (M.isEncoding === x || !x(A))) throw new Error("Unknown encoding: " + A);
          return T || A;
        }
        _.StringDecoder = c;
        function c(A) {
          this.encoding = E(A);
          var T;
          switch (this.encoding) {
            case "utf16le":
              this.text = h, this.end = m, T = 4;
              break;
            case "utf8":
              this.fillLast = n, T = 4;
              break;
            case "base64":
              this.text = s, this.end = b, T = 3;
              break;
            default:
              this.write = S, this.end = o;
              return;
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = M.allocUnsafe(T);
        }
        c.prototype.write = function(A) {
          if (A.length === 0) return "";
          var T, I;
          if (this.lastNeed) {
            if (T = this.fillLast(A), T === void 0) return "";
            I = this.lastNeed, this.lastNeed = 0;
          } else
            I = 0;
          return I < A.length ? T ? T + this.text(A, I) : this.text(A, I) : T || "";
        }, c.prototype.end = g, c.prototype.text = d, c.prototype.fillLast = function(A) {
          if (this.lastNeed <= A.length)
            return A.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          A.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, A.length), this.lastNeed -= A.length;
        };
        function u(A) {
          return A <= 127 ? 0 : A >> 5 === 6 ? 2 : A >> 4 === 14 ? 3 : A >> 3 === 30 ? 4 : A >> 6 === 2 ? -1 : -2;
        }
        function l(A, T, I) {
          var L = T.length - 1;
          if (L < I) return 0;
          var z = u(T[L]);
          return z >= 0 ? (z > 0 && (A.lastNeed = z - 1), z) : --L < I || z === -2 ? 0 : (z = u(T[L]), z >= 0 ? (z > 0 && (A.lastNeed = z - 2), z) : --L < I || z === -2 ? 0 : (z = u(T[L]), z >= 0 ? (z > 0 && (z === 2 ? z = 0 : A.lastNeed = z - 3), z) : 0));
        }
        function a(A, T, I) {
          if ((T[0] & 192) !== 128)
            return A.lastNeed = 0, "�";
          if (A.lastNeed > 1 && T.length > 1) {
            if ((T[1] & 192) !== 128)
              return A.lastNeed = 1, "�";
            if (A.lastNeed > 2 && T.length > 2 && (T[2] & 192) !== 128)
              return A.lastNeed = 2, "�";
          }
        }
        function n(A) {
          var T = this.lastTotal - this.lastNeed, I = a(this, A);
          if (I !== void 0) return I;
          if (this.lastNeed <= A.length)
            return A.copy(this.lastChar, T, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          A.copy(this.lastChar, T, 0, A.length), this.lastNeed -= A.length;
        }
        function d(A, T) {
          var I = l(this, A, T);
          if (!this.lastNeed) return A.toString("utf8", T);
          this.lastTotal = I;
          var L = A.length - (I - this.lastNeed);
          return A.copy(this.lastChar, 0, L), A.toString("utf8", T, L);
        }
        function g(A) {
          var T = A && A.length ? this.write(A) : "";
          return this.lastNeed ? T + "�" : T;
        }
        function h(A, T) {
          if ((A.length - T) % 2 === 0) {
            var I = A.toString("utf16le", T);
            if (I) {
              var L = I.charCodeAt(I.length - 1);
              if (L >= 55296 && L <= 56319)
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = A[A.length - 2], this.lastChar[1] = A[A.length - 1], I.slice(0, -1);
            }
            return I;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = A[A.length - 1], A.toString("utf16le", T, A.length - 1);
        }
        function m(A) {
          var T = A && A.length ? this.write(A) : "";
          if (this.lastNeed) {
            var I = this.lastTotal - this.lastNeed;
            return T + this.lastChar.toString("utf16le", 0, I);
          }
          return T;
        }
        function s(A, T) {
          var I = (A.length - T) % 3;
          return I === 0 ? A.toString("base64", T) : (this.lastNeed = 3 - I, this.lastTotal = 3, I === 1 ? this.lastChar[0] = A[A.length - 1] : (this.lastChar[0] = A[A.length - 2], this.lastChar[1] = A[A.length - 1]), A.toString("base64", T, A.length - I));
        }
        function b(A) {
          var T = A && A.length ? this.write(A) : "";
          return this.lastNeed ? T + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : T;
        }
        function S(A) {
          return A.toString(this.encoding);
        }
        function o(A) {
          return A && A.length ? this.write(A) : "";
        }
      }, { "safe-buffer": 147 }], 149: [function(k, Z, _) {
        Z.exports = k("./readable").PassThrough;
      }, { "./readable": 150 }], 150: [function(k, Z, _) {
        _ = Z.exports = k("./lib/_stream_readable.js"), _.Stream = _, _.Readable = _, _.Writable = k("./lib/_stream_writable.js"), _.Duplex = k("./lib/_stream_duplex.js"), _.Transform = k("./lib/_stream_transform.js"), _.PassThrough = k("./lib/_stream_passthrough.js");
      }, { "./lib/_stream_duplex.js": 139, "./lib/_stream_passthrough.js": 140, "./lib/_stream_readable.js": 141, "./lib/_stream_transform.js": 142, "./lib/_stream_writable.js": 143 }], 151: [function(k, Z, _) {
        Z.exports = k("./readable").Transform;
      }, { "./readable": 150 }], 152: [function(k, Z, _) {
        Z.exports = k("./lib/_stream_writable.js");
      }, { "./lib/_stream_writable.js": 143 }], 153: [function(k, Z, _) {
        var M = function(x) {
          var y = Object.prototype, E = y.hasOwnProperty, c, u = typeof Symbol == "function" ? Symbol : {}, l = u.iterator || "@@iterator", a = u.asyncIterator || "@@asyncIterator", n = u.toStringTag || "@@toStringTag";
          function d(ke, Me, fe, xe) {
            var Ee = Me && Me.prototype instanceof o ? Me : o, Pe = Object.create(Ee.prototype), Ue = new Q(xe || []);
            return Pe._invoke = oe(ke, fe, Ue), Pe;
          }
          x.wrap = d;
          function g(ke, Me, fe) {
            try {
              return { type: "normal", arg: ke.call(Me, fe) };
            } catch (xe) {
              return { type: "throw", arg: xe };
            }
          }
          var h = "suspendedStart", m = "suspendedYield", s = "executing", b = "completed", S = {};
          function o() {
          }
          function A() {
          }
          function T() {
          }
          var I = {};
          I[l] = function() {
            return this;
          };
          var L = Object.getPrototypeOf, z = L && L(L(de([])));
          z && z !== y && E.call(z, l) && (I = z);
          var U = T.prototype = o.prototype = Object.create(I);
          A.prototype = U.constructor = T, T.constructor = A, T[n] = A.displayName = "GeneratorFunction";
          function J(ke) {
            ["next", "throw", "return"].forEach(function(Me) {
              ke[Me] = function(fe) {
                return this._invoke(Me, fe);
              };
            });
          }
          x.isGeneratorFunction = function(ke) {
            var Me = typeof ke == "function" && ke.constructor;
            return Me ? Me === A || // For the native GeneratorFunction constructor, the best we can
            // do is to check its .name property.
            (Me.displayName || Me.name) === "GeneratorFunction" : !1;
          }, x.mark = function(ke) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(ke, T) : (ke.__proto__ = T, n in ke || (ke[n] = "GeneratorFunction")), ke.prototype = Object.create(U), ke;
          }, x.awrap = function(ke) {
            return { __await: ke };
          };
          function F(ke) {
            function Me(Ee, Pe, Ue, He) {
              var We = g(ke[Ee], ke, Pe);
              if (We.type === "throw")
                He(We.arg);
              else {
                var Ze = We.arg, $e = Ze.value;
                return $e && typeof $e == "object" && E.call($e, "__await") ? Promise.resolve($e.__await).then(function(Ve) {
                  Me("next", Ve, Ue, He);
                }, function(Ve) {
                  Me("throw", Ve, Ue, He);
                }) : Promise.resolve($e).then(function(Ve) {
                  Ze.value = Ve, Ue(Ze);
                }, function(Ve) {
                  return Me("throw", Ve, Ue, He);
                });
              }
            }
            var fe;
            function xe(Ee, Pe) {
              function Ue() {
                return new Promise(function(He, We) {
                  Me(Ee, Pe, He, We);
                });
              }
              return fe = // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              fe ? fe.then(
                Ue,
                // Avoid propagating failures to Promises returned by later
                // invocations of the iterator.
                Ue
              ) : Ue();
            }
            this._invoke = xe;
          }
          J(F.prototype), F.prototype[a] = function() {
            return this;
          }, x.AsyncIterator = F, x.async = function(ke, Me, fe, xe) {
            var Ee = new F(
              d(ke, Me, fe, xe)
            );
            return x.isGeneratorFunction(Me) ? Ee : Ee.next().then(function(Pe) {
              return Pe.done ? Pe.value : Ee.next();
            });
          };
          function oe(ke, Me, fe) {
            var xe = h;
            return function(Pe, Ue) {
              if (xe === s)
                throw new Error("Generator is already running");
              if (xe === b) {
                if (Pe === "throw")
                  throw Ue;
                return we();
              }
              for (fe.method = Pe, fe.arg = Ue; ; ) {
                var He = fe.delegate;
                if (He) {
                  var We = ee(He, fe);
                  if (We) {
                    if (We === S) continue;
                    return We;
                  }
                }
                if (fe.method === "next")
                  fe.sent = fe._sent = fe.arg;
                else if (fe.method === "throw") {
                  if (xe === h)
                    throw xe = b, fe.arg;
                  fe.dispatchException(fe.arg);
                } else fe.method === "return" && fe.abrupt("return", fe.arg);
                xe = s;
                var Ze = g(ke, Me, fe);
                if (Ze.type === "normal") {
                  if (xe = fe.done ? b : m, Ze.arg === S)
                    continue;
                  return {
                    value: Ze.arg,
                    done: fe.done
                  };
                } else Ze.type === "throw" && (xe = b, fe.method = "throw", fe.arg = Ze.arg);
              }
            };
          }
          function ee(ke, Me) {
            var fe = ke.iterator[Me.method];
            if (fe === c) {
              if (Me.delegate = null, Me.method === "throw") {
                if (ke.iterator.return && (Me.method = "return", Me.arg = c, ee(ke, Me), Me.method === "throw"))
                  return S;
                Me.method = "throw", Me.arg = new TypeError(
                  "The iterator does not provide a 'throw' method"
                );
              }
              return S;
            }
            var xe = g(fe, ke.iterator, Me.arg);
            if (xe.type === "throw")
              return Me.method = "throw", Me.arg = xe.arg, Me.delegate = null, S;
            var Ee = xe.arg;
            if (!Ee)
              return Me.method = "throw", Me.arg = new TypeError("iterator result is not an object"), Me.delegate = null, S;
            if (Ee.done)
              Me[ke.resultName] = Ee.value, Me.next = ke.nextLoc, Me.method !== "return" && (Me.method = "next", Me.arg = c);
            else
              return Ee;
            return Me.delegate = null, S;
          }
          J(U), U[n] = "Generator", U[l] = function() {
            return this;
          }, U.toString = function() {
            return "[object Generator]";
          };
          function ie(ke) {
            var Me = { tryLoc: ke[0] };
            1 in ke && (Me.catchLoc = ke[1]), 2 in ke && (Me.finallyLoc = ke[2], Me.afterLoc = ke[3]), this.tryEntries.push(Me);
          }
          function W(ke) {
            var Me = ke.completion || {};
            Me.type = "normal", delete Me.arg, ke.completion = Me;
          }
          function Q(ke) {
            this.tryEntries = [{ tryLoc: "root" }], ke.forEach(ie, this), this.reset(!0);
          }
          x.keys = function(ke) {
            var Me = [];
            for (var fe in ke)
              Me.push(fe);
            return Me.reverse(), function xe() {
              for (; Me.length; ) {
                var Ee = Me.pop();
                if (Ee in ke)
                  return xe.value = Ee, xe.done = !1, xe;
              }
              return xe.done = !0, xe;
            };
          };
          function de(ke) {
            if (ke) {
              var Me = ke[l];
              if (Me)
                return Me.call(ke);
              if (typeof ke.next == "function")
                return ke;
              if (!isNaN(ke.length)) {
                var fe = -1, xe = function Ee() {
                  for (; ++fe < ke.length; )
                    if (E.call(ke, fe))
                      return Ee.value = ke[fe], Ee.done = !1, Ee;
                  return Ee.value = c, Ee.done = !0, Ee;
                };
                return xe.next = xe;
              }
            }
            return { next: we };
          }
          x.values = de;
          function we() {
            return { value: c, done: !0 };
          }
          return Q.prototype = {
            constructor: Q,
            reset: function(ke) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = c, this.done = !1, this.delegate = null, this.method = "next", this.arg = c, this.tryEntries.forEach(W), !ke)
                for (var Me in this)
                  Me.charAt(0) === "t" && E.call(this, Me) && !isNaN(+Me.slice(1)) && (this[Me] = c);
            },
            stop: function() {
              this.done = !0;
              var ke = this.tryEntries[0], Me = ke.completion;
              if (Me.type === "throw")
                throw Me.arg;
              return this.rval;
            },
            dispatchException: function(ke) {
              if (this.done)
                throw ke;
              var Me = this;
              function fe(We, Ze) {
                return Pe.type = "throw", Pe.arg = ke, Me.next = We, Ze && (Me.method = "next", Me.arg = c), !!Ze;
              }
              for (var xe = this.tryEntries.length - 1; xe >= 0; --xe) {
                var Ee = this.tryEntries[xe], Pe = Ee.completion;
                if (Ee.tryLoc === "root")
                  return fe("end");
                if (Ee.tryLoc <= this.prev) {
                  var Ue = E.call(Ee, "catchLoc"), He = E.call(Ee, "finallyLoc");
                  if (Ue && He) {
                    if (this.prev < Ee.catchLoc)
                      return fe(Ee.catchLoc, !0);
                    if (this.prev < Ee.finallyLoc)
                      return fe(Ee.finallyLoc);
                  } else if (Ue) {
                    if (this.prev < Ee.catchLoc)
                      return fe(Ee.catchLoc, !0);
                  } else if (He) {
                    if (this.prev < Ee.finallyLoc)
                      return fe(Ee.finallyLoc);
                  } else
                    throw new Error("try statement without catch or finally");
                }
              }
            },
            abrupt: function(ke, Me) {
              for (var fe = this.tryEntries.length - 1; fe >= 0; --fe) {
                var xe = this.tryEntries[fe];
                if (xe.tryLoc <= this.prev && E.call(xe, "finallyLoc") && this.prev < xe.finallyLoc) {
                  var Ee = xe;
                  break;
                }
              }
              Ee && (ke === "break" || ke === "continue") && Ee.tryLoc <= Me && Me <= Ee.finallyLoc && (Ee = null);
              var Pe = Ee ? Ee.completion : {};
              return Pe.type = ke, Pe.arg = Me, Ee ? (this.method = "next", this.next = Ee.finallyLoc, S) : this.complete(Pe);
            },
            complete: function(ke, Me) {
              if (ke.type === "throw")
                throw ke.arg;
              return ke.type === "break" || ke.type === "continue" ? this.next = ke.arg : ke.type === "return" ? (this.rval = this.arg = ke.arg, this.method = "return", this.next = "end") : ke.type === "normal" && Me && (this.next = Me), S;
            },
            finish: function(ke) {
              for (var Me = this.tryEntries.length - 1; Me >= 0; --Me) {
                var fe = this.tryEntries[Me];
                if (fe.finallyLoc === ke)
                  return this.complete(fe.completion, fe.afterLoc), W(fe), S;
              }
            },
            catch: function(ke) {
              for (var Me = this.tryEntries.length - 1; Me >= 0; --Me) {
                var fe = this.tryEntries[Me];
                if (fe.tryLoc === ke) {
                  var xe = fe.completion;
                  if (xe.type === "throw") {
                    var Ee = xe.arg;
                    W(fe);
                  }
                  return Ee;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function(ke, Me, fe) {
              return this.delegate = {
                iterator: de(ke),
                resultName: Me,
                nextLoc: fe
              }, this.method === "next" && (this.arg = c), S;
            }
          }, x;
        }(
          // If this script is executing as a CommonJS module, use module.exports
          // as the regeneratorRuntime namespace. Otherwise create a new empty
          // object. Either way, the resulting object will be used to initialize
          // the regeneratorRuntime variable at the top of this file.
          typeof Z == "object" ? Z.exports : {}
        );
        try {
          regeneratorRuntime = M;
        } catch {
          Function("r", "regeneratorRuntime = r")(M);
        }
      }, {}], 154: [function(k, Z, _) {
        var M = k("buffer"), x = M.Buffer;
        function y(c, u) {
          for (var l in c)
            u[l] = c[l];
        }
        x.from && x.alloc && x.allocUnsafe && x.allocUnsafeSlow ? Z.exports = M : (y(M, _), _.Buffer = E);
        function E(c, u, l) {
          return x(c, u, l);
        }
        E.prototype = Object.create(x.prototype), y(x, E), E.from = function(c, u, l) {
          if (typeof c == "number")
            throw new TypeError("Argument must not be a number");
          return x(c, u, l);
        }, E.alloc = function(c, u, l) {
          if (typeof c != "number")
            throw new TypeError("Argument must be a number");
          var a = x(c);
          return u !== void 0 ? typeof l == "string" ? a.fill(u, l) : a.fill(u) : a.fill(0), a;
        }, E.allocUnsafe = function(c) {
          if (typeof c != "number")
            throw new TypeError("Argument must be a number");
          return x(c);
        }, E.allocUnsafeSlow = function(c) {
          if (typeof c != "number")
            throw new TypeError("Argument must be a number");
          return M.SlowBuffer(c);
        };
      }, { buffer: 48 }], 155: [function(k, Z, _) {
        Z.exports = y;
        var M = k("events").EventEmitter, x = k("inherits");
        x(y, M), y.Readable = k("readable-stream/readable.js"), y.Writable = k("readable-stream/writable.js"), y.Duplex = k("readable-stream/duplex.js"), y.Transform = k("readable-stream/transform.js"), y.PassThrough = k("readable-stream/passthrough.js"), y.Stream = y;
        function y() {
          M.call(this);
        }
        y.prototype.pipe = function(E, c) {
          var u = this;
          function l(s) {
            E.writable && E.write(s) === !1 && u.pause && u.pause();
          }
          u.on("data", l);
          function a() {
            u.readable && u.resume && u.resume();
          }
          E.on("drain", a), !E._isStdio && (!c || c.end !== !1) && (u.on("end", d), u.on("close", g));
          var n = !1;
          function d() {
            n || (n = !0, E.end());
          }
          function g() {
            n || (n = !0, typeof E.destroy == "function" && E.destroy());
          }
          function h(s) {
            if (m(), M.listenerCount(this, "error") === 0)
              throw s;
          }
          u.on("error", h), E.on("error", h);
          function m() {
            u.removeListener("data", l), E.removeListener("drain", a), u.removeListener("end", d), u.removeListener("close", g), u.removeListener("error", h), E.removeListener("error", h), u.removeListener("end", m), u.removeListener("close", m), E.removeListener("close", m);
          }
          return u.on("end", m), u.on("close", m), E.on("close", m), E.emit("pipe", u), E;
        };
      }, { events: 52, inherits: 75, "readable-stream/duplex.js": 138, "readable-stream/passthrough.js": 149, "readable-stream/readable.js": 150, "readable-stream/transform.js": 151, "readable-stream/writable.js": 152 }], 156: [function(k, Z, _) {
        (function(M) {
          var x = k("./lib/request"), y = k("./lib/response"), E = k("xtend"), c = k("builtin-status-codes"), u = k("url"), l = _;
          l.request = function(a, n) {
            typeof a == "string" ? a = u.parse(a) : a = E(a);
            var d = M.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", g = a.protocol || d, h = a.hostname || a.host, m = a.port, s = a.path || "/";
            h && h.indexOf(":") !== -1 && (h = "[" + h + "]"), a.url = (h ? g + "//" + h : "") + (m ? ":" + m : "") + s, a.method = (a.method || "GET").toUpperCase(), a.headers = a.headers || {};
            var b = new x(a);
            return n && b.on("response", n), b;
          }, l.get = function(n, d) {
            var g = l.request(n, d);
            return g.end(), g;
          }, l.ClientRequest = x, l.IncomingMessage = y.IncomingMessage, l.Agent = function() {
          }, l.Agent.defaultMaxSockets = 4, l.globalAgent = new l.Agent(), l.STATUS_CODES = c, l.METHODS = [
            "CHECKOUT",
            "CONNECT",
            "COPY",
            "DELETE",
            "GET",
            "HEAD",
            "LOCK",
            "M-SEARCH",
            "MERGE",
            "MKACTIVITY",
            "MKCOL",
            "MOVE",
            "NOTIFY",
            "OPTIONS",
            "PATCH",
            "POST",
            "PROPFIND",
            "PROPPATCH",
            "PURGE",
            "PUT",
            "REPORT",
            "SEARCH",
            "SUBSCRIBE",
            "TRACE",
            "UNLOCK",
            "UNSUBSCRIBE"
          ];
        }).call(this, typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {});
      }, { "./lib/request": 158, "./lib/response": 159, "builtin-status-codes": 50, url: 180, xtend: 189 }], 157: [function(k, Z, _) {
        (function(M) {
          _.fetch = c(M.fetch) && c(M.ReadableStream), _.writableStream = c(M.WritableStream), _.abortController = c(M.AbortController);
          var x;
          function y() {
            if (x !== void 0) return x;
            if (M.XMLHttpRequest) {
              x = new M.XMLHttpRequest();
              try {
                x.open("GET", M.XDomainRequest ? "/" : "https://example.com");
              } catch {
                x = null;
              }
            } else
              x = null;
            return x;
          }
          function E(u) {
            var l = y();
            if (!l) return !1;
            try {
              return l.responseType = u, l.responseType === u;
            } catch {
            }
            return !1;
          }
          _.arraybuffer = _.fetch || E("arraybuffer"), _.msstream = !_.fetch && E("ms-stream"), _.mozchunkedarraybuffer = !_.fetch && E("moz-chunked-arraybuffer"), _.overrideMimeType = _.fetch || (y() ? c(y().overrideMimeType) : !1);
          function c(u) {
            return typeof u == "function";
          }
          x = null;
        }).call(this, typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {});
      }, {}], 158: [function(k, Z, _) {
        (function(M, x, y) {
          var E = k("./capability"), c = k("inherits"), u = k("./response"), l = k("readable-stream"), a = u.IncomingMessage, n = u.readyStates;
          function d(s, b) {
            return E.fetch && b ? "fetch" : E.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : E.msstream ? "ms-stream" : E.arraybuffer && s ? "arraybuffer" : "text";
          }
          var g = Z.exports = function(s) {
            var b = this;
            l.Writable.call(b), b._opts = s, b._body = [], b._headers = {}, s.auth && b.setHeader("Authorization", "Basic " + y.from(s.auth).toString("base64")), Object.keys(s.headers).forEach(function(A) {
              b.setHeader(A, s.headers[A]);
            });
            var S, o = !0;
            if (s.mode === "disable-fetch" || "requestTimeout" in s && !E.abortController)
              o = !1, S = !0;
            else if (s.mode === "prefer-streaming")
              S = !1;
            else if (s.mode === "allow-wrong-content-type")
              S = !E.overrideMimeType;
            else if (!s.mode || s.mode === "default" || s.mode === "prefer-fast")
              S = !0;
            else
              throw new Error("Invalid value for opts.mode");
            b._mode = d(S, o), b._fetchTimer = null, b.on("finish", function() {
              b._onFinish();
            });
          };
          c(g, l.Writable), g.prototype.setHeader = function(s, b) {
            var S = this, o = s.toLowerCase();
            m.indexOf(o) === -1 && (S._headers[o] = {
              name: s,
              value: b
            });
          }, g.prototype.getHeader = function(s) {
            var b = this._headers[s.toLowerCase()];
            return b ? b.value : null;
          }, g.prototype.removeHeader = function(s) {
            var b = this;
            delete b._headers[s.toLowerCase()];
          }, g.prototype._onFinish = function() {
            var s = this;
            if (!s._destroyed) {
              var b = s._opts, S = s._headers, o = null;
              b.method !== "GET" && b.method !== "HEAD" && (o = new Blob(s._body, {
                type: (S["content-type"] || {}).value || ""
              }));
              var A = [];
              if (Object.keys(S).forEach(function(z) {
                var U = S[z].name, J = S[z].value;
                Array.isArray(J) ? J.forEach(function(F) {
                  A.push([U, F]);
                }) : A.push([U, J]);
              }), s._mode === "fetch") {
                var T = null;
                if (E.abortController) {
                  var I = new AbortController();
                  T = I.signal, s._fetchAbortController = I, "requestTimeout" in b && b.requestTimeout !== 0 && (s._fetchTimer = x.setTimeout(function() {
                    s.emit("requestTimeout"), s._fetchAbortController && s._fetchAbortController.abort();
                  }, b.requestTimeout));
                }
                x.fetch(s._opts.url, {
                  method: s._opts.method,
                  headers: A,
                  body: o || void 0,
                  mode: "cors",
                  credentials: b.withCredentials ? "include" : "same-origin",
                  signal: T
                }).then(function(z) {
                  s._fetchResponse = z, s._connect();
                }, function(z) {
                  x.clearTimeout(s._fetchTimer), s._destroyed || s.emit("error", z);
                });
              } else {
                var L = s._xhr = new x.XMLHttpRequest();
                try {
                  L.open(s._opts.method, s._opts.url, !0);
                } catch (z) {
                  M.nextTick(function() {
                    s.emit("error", z);
                  });
                  return;
                }
                "responseType" in L && (L.responseType = s._mode), "withCredentials" in L && (L.withCredentials = !!b.withCredentials), s._mode === "text" && "overrideMimeType" in L && L.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in b && (L.timeout = b.requestTimeout, L.ontimeout = function() {
                  s.emit("requestTimeout");
                }), A.forEach(function(z) {
                  L.setRequestHeader(z[0], z[1]);
                }), s._response = null, L.onreadystatechange = function() {
                  switch (L.readyState) {
                    case n.LOADING:
                    case n.DONE:
                      s._onXHRProgress();
                      break;
                  }
                }, s._mode === "moz-chunked-arraybuffer" && (L.onprogress = function() {
                  s._onXHRProgress();
                }), L.onerror = function() {
                  s._destroyed || s.emit("error", new Error("XHR error"));
                };
                try {
                  L.send(o);
                } catch (z) {
                  M.nextTick(function() {
                    s.emit("error", z);
                  });
                  return;
                }
              }
            }
          };
          function h(s) {
            try {
              var b = s.status;
              return b !== null && b !== 0;
            } catch {
              return !1;
            }
          }
          g.prototype._onXHRProgress = function() {
            var s = this;
            !h(s._xhr) || s._destroyed || (s._response || s._connect(), s._response._onXHRProgress());
          }, g.prototype._connect = function() {
            var s = this;
            s._destroyed || (s._response = new a(s._xhr, s._fetchResponse, s._mode, s._fetchTimer), s._response.on("error", function(b) {
              s.emit("error", b);
            }), s.emit("response", s._response));
          }, g.prototype._write = function(s, b, S) {
            var o = this;
            o._body.push(s), S();
          }, g.prototype.abort = g.prototype.destroy = function() {
            var s = this;
            s._destroyed = !0, x.clearTimeout(s._fetchTimer), s._response && (s._response._destroyed = !0), s._xhr ? s._xhr.abort() : s._fetchAbortController && s._fetchAbortController.abort();
          }, g.prototype.end = function(s, b, S) {
            var o = this;
            typeof s == "function" && (S = s, s = void 0), l.Writable.prototype.end.call(o, s, b, S);
          }, g.prototype.flushHeaders = function() {
          }, g.prototype.setTimeout = function() {
          }, g.prototype.setNoDelay = function() {
          }, g.prototype.setSocketKeepAlive = function() {
          };
          var m = [
            "accept-charset",
            "accept-encoding",
            "access-control-request-headers",
            "access-control-request-method",
            "connection",
            "content-length",
            "cookie",
            "cookie2",
            "date",
            "dnt",
            "expect",
            "host",
            "keep-alive",
            "origin",
            "referer",
            "te",
            "trailer",
            "transfer-encoding",
            "upgrade",
            "via"
          ];
        }).call(this, k("_process"), typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {}, k("buffer").Buffer);
      }, { "./capability": 157, "./response": 159, _process: 133, buffer: 48, inherits: 75, "readable-stream": 174 }], 159: [function(k, Z, _) {
        (function(M, x, y) {
          var E = k("./capability"), c = k("inherits"), u = k("readable-stream"), l = _.readyStates = {
            UNSENT: 0,
            OPENED: 1,
            HEADERS_RECEIVED: 2,
            LOADING: 3,
            DONE: 4
          }, a = _.IncomingMessage = function(n, d, g, h) {
            var m = this;
            if (u.Readable.call(m), m._mode = g, m.headers = {}, m.rawHeaders = [], m.trailers = {}, m.rawTrailers = [], m.on("end", function() {
              M.nextTick(function() {
                m.emit("close");
              });
            }), g === "fetch") {
              let T = function() {
                b.read().then(function(I) {
                  if (!m._destroyed) {
                    if (I.done) {
                      x.clearTimeout(h), m.push(null);
                      return;
                    }
                    m.push(y.from(I.value)), T();
                  }
                }).catch(function(I) {
                  x.clearTimeout(h), m._destroyed || m.emit("error", I);
                });
              };
              if (m._fetchResponse = d, m.url = d.url, m.statusCode = d.status, m.statusMessage = d.statusText, d.headers.forEach(function(I, L) {
                m.headers[L.toLowerCase()] = I, m.rawHeaders.push(L, I);
              }), E.writableStream) {
                var s = new WritableStream({
                  write: function(I) {
                    return new Promise(function(L, z) {
                      m._destroyed ? z() : m.push(y.from(I)) ? L() : m._resumeFetch = L;
                    });
                  },
                  close: function() {
                    x.clearTimeout(h), m._destroyed || m.push(null);
                  },
                  abort: function(I) {
                    m._destroyed || m.emit("error", I);
                  }
                });
                try {
                  d.body.pipeTo(s).catch(function(I) {
                    x.clearTimeout(h), m._destroyed || m.emit("error", I);
                  });
                  return;
                } catch {
                }
              }
              var b = d.body.getReader();
              T();
            } else {
              m._xhr = n, m._pos = 0, m.url = n.responseURL, m.statusCode = n.status, m.statusMessage = n.statusText;
              var S = n.getAllResponseHeaders().split(/\r?\n/);
              if (S.forEach(function(T) {
                var I = T.match(/^([^:]+):\s*(.*)/);
                if (I) {
                  var L = I[1].toLowerCase();
                  L === "set-cookie" ? (m.headers[L] === void 0 && (m.headers[L] = []), m.headers[L].push(I[2])) : m.headers[L] !== void 0 ? m.headers[L] += ", " + I[2] : m.headers[L] = I[2], m.rawHeaders.push(I[1], I[2]);
                }
              }), m._charset = "x-user-defined", !E.overrideMimeType) {
                var o = m.rawHeaders["mime-type"];
                if (o) {
                  var A = o.match(/;\s*charset=([^;])(;|$)/);
                  A && (m._charset = A[1].toLowerCase());
                }
                m._charset || (m._charset = "utf-8");
              }
            }
          };
          c(a, u.Readable), a.prototype._read = function() {
            var n = this, d = n._resumeFetch;
            d && (n._resumeFetch = null, d());
          }, a.prototype._onXHRProgress = function() {
            var n = this, d = n._xhr, g = null;
            switch (n._mode) {
              case "text":
                if (g = d.responseText, g.length > n._pos) {
                  var h = g.substr(n._pos);
                  if (n._charset === "x-user-defined") {
                    for (var m = y.alloc(h.length), s = 0; s < h.length; s++)
                      m[s] = h.charCodeAt(s) & 255;
                    n.push(m);
                  } else
                    n.push(h, n._charset);
                  n._pos = g.length;
                }
                break;
              case "arraybuffer":
                if (d.readyState !== l.DONE || !d.response)
                  break;
                g = d.response, n.push(y.from(new Uint8Array(g)));
                break;
              case "moz-chunked-arraybuffer":
                if (g = d.response, d.readyState !== l.LOADING || !g)
                  break;
                n.push(y.from(new Uint8Array(g)));
                break;
              case "ms-stream":
                if (g = d.response, d.readyState !== l.LOADING)
                  break;
                var b = new x.MSStreamReader();
                b.onprogress = function() {
                  b.result.byteLength > n._pos && (n.push(y.from(new Uint8Array(b.result.slice(n._pos)))), n._pos = b.result.byteLength);
                }, b.onload = function() {
                  n.push(null);
                }, b.readAsArrayBuffer(g);
                break;
            }
            n._xhr.readyState === l.DONE && n._mode !== "ms-stream" && n.push(null);
          };
        }).call(this, k("_process"), typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {}, k("buffer").Buffer);
      }, { "./capability": 157, _process: 133, buffer: 48, inherits: 75, "readable-stream": 174 }], 160: [function(k, Z, _) {
        function M(a, n) {
          a.prototype = Object.create(n.prototype), a.prototype.constructor = a, a.__proto__ = n;
        }
        var x = {};
        function y(a, n, d) {
          d || (d = Error);
          function g(m, s, b) {
            return typeof n == "string" ? n : n(m, s, b);
          }
          var h = /* @__PURE__ */ function(m) {
            M(s, m);
            function s(b, S, o) {
              return m.call(this, g(b, S, o)) || this;
            }
            return s;
          }(d);
          h.prototype.name = d.name, h.prototype.code = a, x[a] = h;
        }
        function E(a, n) {
          if (Array.isArray(a)) {
            var d = a.length;
            return a = a.map(function(g) {
              return String(g);
            }), d > 2 ? "one of ".concat(n, " ").concat(a.slice(0, d - 1).join(", "), ", or ") + a[d - 1] : d === 2 ? "one of ".concat(n, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(n, " ").concat(a[0]);
          } else
            return "of ".concat(n, " ").concat(String(a));
        }
        function c(a, n, d) {
          return a.substr(0, n.length) === n;
        }
        function u(a, n, d) {
          return (d === void 0 || d > a.length) && (d = a.length), a.substring(d - n.length, d) === n;
        }
        function l(a, n, d) {
          return typeof d != "number" && (d = 0), d + n.length > a.length ? !1 : a.indexOf(n, d) !== -1;
        }
        y("ERR_INVALID_OPT_VALUE", function(a, n) {
          return 'The value "' + n + '" is invalid for option "' + a + '"';
        }, TypeError), y("ERR_INVALID_ARG_TYPE", function(a, n, d) {
          var g;
          typeof n == "string" && c(n, "not ") ? (g = "must not be", n = n.replace(/^not /, "")) : g = "must be";
          var h;
          if (u(a, " argument"))
            h = "The ".concat(a, " ").concat(g, " ").concat(E(n, "type"));
          else {
            var m = l(a, ".") ? "property" : "argument";
            h = 'The "'.concat(a, '" ').concat(m, " ").concat(g, " ").concat(E(n, "type"));
          }
          return h += ". Received type ".concat(typeof d), h;
        }, TypeError), y("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), y("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
          return "The " + a + " method is not implemented";
        }), y("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), y("ERR_STREAM_DESTROYED", function(a) {
          return "Cannot call " + a + " after a stream was destroyed";
        }), y("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), y("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), y("ERR_STREAM_WRITE_AFTER_END", "write after end"), y("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), y("ERR_UNKNOWN_ENCODING", function(a) {
          return "Unknown encoding: " + a;
        }, TypeError), y("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Z.exports.codes = x;
      }, {}], 161: [function(k, Z, _) {
        (function(M) {
          var x = /* @__PURE__ */ new Set();
          function y(c) {
            if (!x.has(c)) {
              var u = c + " is an experimental feature. This feature could change at any time";
              x.add(c), M.emitWarning(u, "ExperimentalWarning");
            }
          }
          function E() {
          }
          Z.exports.emitExperimentalWarning = M.emitWarning ? y : E;
        }).call(this, k("_process"));
      }, { _process: 133 }], 162: [function(k, Z, _) {
        (function(M) {
          var x = Object.keys || function(g) {
            var h = [];
            for (var m in g)
              h.push(m);
            return h;
          };
          Z.exports = a;
          var y = k("./_stream_readable"), E = k("./_stream_writable");
          k("inherits")(a, y);
          for (var c = x(E.prototype), u = 0; u < c.length; u++) {
            var l = c[u];
            a.prototype[l] || (a.prototype[l] = E.prototype[l]);
          }
          function a(g) {
            if (!(this instanceof a)) return new a(g);
            y.call(this, g), E.call(this, g), this.allowHalfOpen = !0, g && (g.readable === !1 && (this.readable = !1), g.writable === !1 && (this.writable = !1), g.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", n)));
          }
          Object.defineProperty(a.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.highWaterMark;
            }
          }), Object.defineProperty(a.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState && this._writableState.getBuffer();
            }
          }), Object.defineProperty(a.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.length;
            }
          });
          function n() {
            this._writableState.ended || M.nextTick(d, this);
          }
          function d(g) {
            g.end();
          }
          Object.defineProperty(a.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function(h) {
              this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = h, this._writableState.destroyed = h);
            }
          });
        }).call(this, k("_process"));
      }, { "./_stream_readable": 164, "./_stream_writable": 166, _process: 133, inherits: 75 }], 163: [function(k, Z, _) {
        Z.exports = x;
        var M = k("./_stream_transform");
        k("inherits")(x, M);
        function x(y) {
          if (!(this instanceof x)) return new x(y);
          M.call(this, y);
        }
        x.prototype._transform = function(y, E, c) {
          c(null, y);
        };
      }, { "./_stream_transform": 165, inherits: 75 }], 164: [function(k, Z, _) {
        (function(M, x) {
          Z.exports = ie;
          var y;
          ie.ReadableState = ee, k("events").EventEmitter;
          var E = function($, Ce) {
            return $.listeners(Ce).length;
          }, c = k("./internal/streams/stream"), u = k("buffer").Buffer, l = x.Uint8Array || function() {
          };
          function a(re) {
            return u.from(re);
          }
          function n(re) {
            return u.isBuffer(re) || re instanceof l;
          }
          var d = k("util"), g;
          d && d.debuglog ? g = d.debuglog("stream") : g = function() {
          };
          var h = k("./internal/streams/buffer_list"), m = k("./internal/streams/destroy"), s = k("./internal/streams/state"), b = s.getHighWaterMark, S = k("../errors").codes, o = S.ERR_INVALID_ARG_TYPE, A = S.ERR_STREAM_PUSH_AFTER_EOF, T = S.ERR_METHOD_NOT_IMPLEMENTED, I = S.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, L = k("../experimentalWarning"), z = L.emitExperimentalWarning, U, J;
          k("inherits")(ie, c);
          var F = ["error", "close", "destroy", "pause", "resume"];
          function oe(re, $, Ce) {
            if (typeof re.prependListener == "function") return re.prependListener($, Ce);
            !re._events || !re._events[$] ? re.on($, Ce) : Array.isArray(re._events[$]) ? re._events[$].unshift(Ce) : re._events[$] = [Ce, re._events[$]];
          }
          function ee(re, $, Ce) {
            y = y || k("./_stream_duplex"), re = re || {}, typeof Ce != "boolean" && (Ce = $ instanceof y), this.objectMode = !!re.objectMode, Ce && (this.objectMode = this.objectMode || !!re.readableObjectMode), this.highWaterMark = b(this, re, "readableHighWaterMark", Ce), this.buffer = new h(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = re.emitClose !== !1, this.destroyed = !1, this.defaultEncoding = re.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, re.encoding && (U || (U = k("string_decoder/").StringDecoder), this.decoder = new U(re.encoding), this.encoding = re.encoding);
          }
          function ie(re) {
            if (y = y || k("./_stream_duplex"), !(this instanceof ie)) return new ie(re);
            var $ = this instanceof y;
            this._readableState = new ee(re, this, $), this.readable = !0, re && (typeof re.read == "function" && (this._read = re.read), typeof re.destroy == "function" && (this._destroy = re.destroy)), c.call(this);
          }
          Object.defineProperty(ie.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState === void 0 ? !1 : this._readableState.destroyed;
            },
            set: function($) {
              this._readableState && (this._readableState.destroyed = $);
            }
          }), ie.prototype.destroy = m.destroy, ie.prototype._undestroy = m.undestroy, ie.prototype._destroy = function(re, $) {
            $(re);
          }, ie.prototype.push = function(re, $) {
            var Ce = this._readableState, ve;
            return Ce.objectMode ? ve = !0 : typeof re == "string" && ($ = $ || Ce.defaultEncoding, $ !== Ce.encoding && (re = u.from(re, $), $ = ""), ve = !0), W(this, re, $, !1, ve);
          }, ie.prototype.unshift = function(re) {
            return W(this, re, null, !0, !1);
          };
          function W(re, $, Ce, ve, Y) {
            g("readableAddChunk", $);
            var G = re._readableState;
            if ($ === null)
              G.reading = !1, fe(re, G);
            else {
              var Ae;
              if (Y || (Ae = de(G, $)), Ae)
                re.emit("error", Ae);
              else if (G.objectMode || $ && $.length > 0)
                if (typeof $ != "string" && !G.objectMode && Object.getPrototypeOf($) !== u.prototype && ($ = a($)), ve)
                  G.endEmitted ? re.emit("error", new I()) : Q(re, G, $, !0);
                else if (G.ended)
                  re.emit("error", new A());
                else {
                  if (G.destroyed)
                    return !1;
                  G.reading = !1, G.decoder && !Ce ? ($ = G.decoder.write($), G.objectMode || $.length !== 0 ? Q(re, G, $, !1) : Pe(re, G)) : Q(re, G, $, !1);
                }
              else ve || (G.reading = !1, Pe(re, G));
            }
            return !G.ended && (G.length < G.highWaterMark || G.length === 0);
          }
          function Q(re, $, Ce, ve) {
            $.flowing && $.length === 0 && !$.sync ? ($.awaitDrain = 0, re.emit("data", Ce)) : ($.length += $.objectMode ? 1 : Ce.length, ve ? $.buffer.unshift(Ce) : $.buffer.push(Ce), $.needReadable && xe(re)), Pe(re, $);
          }
          function de(re, $) {
            var Ce;
            return !n($) && typeof $ != "string" && $ !== void 0 && !re.objectMode && (Ce = new o("chunk", ["string", "Buffer", "Uint8Array"], $)), Ce;
          }
          ie.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, ie.prototype.setEncoding = function(re) {
            return U || (U = k("string_decoder/").StringDecoder), this._readableState.decoder = new U(re), this._readableState.encoding = this._readableState.decoder.encoding, this;
          };
          var we = 8388608;
          function ke(re) {
            return re >= we ? re = we : (re--, re |= re >>> 1, re |= re >>> 2, re |= re >>> 4, re |= re >>> 8, re |= re >>> 16, re++), re;
          }
          function Me(re, $) {
            return re <= 0 || $.length === 0 && $.ended ? 0 : $.objectMode ? 1 : re !== re ? $.flowing && $.length ? $.buffer.head.data.length : $.length : (re > $.highWaterMark && ($.highWaterMark = ke(re)), re <= $.length ? re : $.ended ? $.length : ($.needReadable = !0, 0));
          }
          ie.prototype.read = function(re) {
            g("read", re), re = parseInt(re, 10);
            var $ = this._readableState, Ce = re;
            if (re !== 0 && ($.emittedReadable = !1), re === 0 && $.needReadable && (($.highWaterMark !== 0 ? $.length >= $.highWaterMark : $.length > 0) || $.ended))
              return g("read: emitReadable", $.length, $.ended), $.length === 0 && $.ended ? De(this) : xe(this), null;
            if (re = Me(re, $), re === 0 && $.ended)
              return $.length === 0 && De(this), null;
            var ve = $.needReadable;
            g("need readable", ve), ($.length === 0 || $.length - re < $.highWaterMark) && (ve = !0, g("length less than watermark", ve)), $.ended || $.reading ? (ve = !1, g("reading or ended", ve)) : ve && (g("do read"), $.reading = !0, $.sync = !0, $.length === 0 && ($.needReadable = !0), this._read($.highWaterMark), $.sync = !1, $.reading || (re = Me(Ce, $)));
            var Y;
            return re > 0 ? Y = Ie(re, $) : Y = null, Y === null ? ($.needReadable = !0, re = 0) : ($.length -= re, $.awaitDrain = 0), $.length === 0 && ($.ended || ($.needReadable = !0), Ce !== re && $.ended && De(this)), Y !== null && this.emit("data", Y), Y;
          };
          function fe(re, $) {
            if (!$.ended) {
              if ($.decoder) {
                var Ce = $.decoder.end();
                Ce && Ce.length && ($.buffer.push(Ce), $.length += $.objectMode ? 1 : Ce.length);
              }
              $.ended = !0, $.sync ? xe(re) : ($.needReadable = !1, $.emittedReadable || ($.emittedReadable = !0, Ee(re)));
            }
          }
          function xe(re) {
            var $ = re._readableState;
            $.needReadable = !1, $.emittedReadable || (g("emitReadable", $.flowing), $.emittedReadable = !0, M.nextTick(Ee, re));
          }
          function Ee(re) {
            var $ = re._readableState;
            g("emitReadable_", $.destroyed, $.length, $.ended), !$.destroyed && ($.length || $.ended) && re.emit("readable"), $.needReadable = !$.flowing && !$.ended && $.length <= $.highWaterMark, Ge(re);
          }
          function Pe(re, $) {
            $.readingMore || ($.readingMore = !0, M.nextTick(Ue, re, $));
          }
          function Ue(re, $) {
            for (; !$.reading && !$.ended && ($.length < $.highWaterMark || $.flowing && $.length === 0); ) {
              var Ce = $.length;
              if (g("maybeReadMore read 0"), re.read(0), Ce === $.length)
                break;
            }
            $.readingMore = !1;
          }
          ie.prototype._read = function(re) {
            this.emit("error", new T("_read()"));
          }, ie.prototype.pipe = function(re, $) {
            var Ce = this, ve = this._readableState;
            switch (ve.pipesCount) {
              case 0:
                ve.pipes = re;
                break;
              case 1:
                ve.pipes = [ve.pipes, re];
                break;
              default:
                ve.pipes.push(re);
                break;
            }
            ve.pipesCount += 1, g("pipe count=%d opts=%j", ve.pipesCount, $);
            var Y = (!$ || $.end !== !1) && re !== M.stdout && re !== M.stderr, G = Y ? e : X;
            ve.endEmitted ? M.nextTick(G) : Ce.once("end", G), re.on("unpipe", Ae);
            function Ae(ue, pe) {
              g("onunpipe"), ue === Ce && pe && pe.hasUnpiped === !1 && (pe.hasUnpiped = !0, C());
            }
            function e() {
              g("onend"), re.end();
            }
            var r = He(Ce);
            re.on("drain", r);
            var f = !1;
            function C() {
              g("cleanup"), re.removeListener("close", j), re.removeListener("finish", H), re.removeListener("drain", r), re.removeListener("error", B), re.removeListener("unpipe", Ae), Ce.removeListener("end", e), Ce.removeListener("end", X), Ce.removeListener("data", R), f = !0, ve.awaitDrain && (!re._writableState || re._writableState.needDrain) && r();
            }
            Ce.on("data", R);
            function R(ue) {
              g("ondata");
              var pe = re.write(ue);
              g("dest.write", pe), pe === !1 && ((ve.pipesCount === 1 && ve.pipes === re || ve.pipesCount > 1 && _e(ve.pipes, re) !== -1) && !f && (g("false write response, pause", ve.awaitDrain), ve.awaitDrain++), Ce.pause());
            }
            function B(ue) {
              g("onerror", ue), X(), re.removeListener("error", B), E(re, "error") === 0 && re.emit("error", ue);
            }
            oe(re, "error", B);
            function j() {
              re.removeListener("finish", H), X();
            }
            re.once("close", j);
            function H() {
              g("onfinish"), re.removeListener("close", j), X();
            }
            re.once("finish", H);
            function X() {
              g("unpipe"), Ce.unpipe(re);
            }
            return re.emit("pipe", Ce), ve.flowing || (g("pipe resume"), Ce.resume()), re;
          };
          function He(re) {
            return function() {
              var Ce = re._readableState;
              g("pipeOnDrain", Ce.awaitDrain), Ce.awaitDrain && Ce.awaitDrain--, Ce.awaitDrain === 0 && E(re, "data") && (Ce.flowing = !0, Ge(re));
            };
          }
          ie.prototype.unpipe = function(re) {
            var $ = this._readableState, Ce = {
              hasUnpiped: !1
            };
            if ($.pipesCount === 0) return this;
            if ($.pipesCount === 1)
              return re && re !== $.pipes ? this : (re || (re = $.pipes), $.pipes = null, $.pipesCount = 0, $.flowing = !1, re && re.emit("unpipe", this, Ce), this);
            if (!re) {
              var ve = $.pipes, Y = $.pipesCount;
              $.pipes = null, $.pipesCount = 0, $.flowing = !1;
              for (var G = 0; G < Y; G++)
                ve[G].emit("unpipe", this, {
                  hasUnpiped: !1
                });
              return this;
            }
            var Ae = _e($.pipes, re);
            return Ae === -1 ? this : ($.pipes.splice(Ae, 1), $.pipesCount -= 1, $.pipesCount === 1 && ($.pipes = $.pipes[0]), re.emit("unpipe", this, Ce), this);
          }, ie.prototype.on = function(re, $) {
            var Ce = c.prototype.on.call(this, re, $), ve = this._readableState;
            return re === "data" ? (ve.readableListening = this.listenerCount("readable") > 0, ve.flowing !== !1 && this.resume()) : re === "readable" && !ve.endEmitted && !ve.readableListening && (ve.readableListening = ve.needReadable = !0, ve.flowing = !1, ve.emittedReadable = !1, g("on readable", ve.length, ve.reading), ve.length ? xe(this) : ve.reading || M.nextTick(Ze, this)), Ce;
          }, ie.prototype.addListener = ie.prototype.on, ie.prototype.removeListener = function(re, $) {
            var Ce = c.prototype.removeListener.call(this, re, $);
            return re === "readable" && M.nextTick(We, this), Ce;
          }, ie.prototype.removeAllListeners = function(re) {
            var $ = c.prototype.removeAllListeners.apply(this, arguments);
            return (re === "readable" || re === void 0) && M.nextTick(We, this), $;
          };
          function We(re) {
            var $ = re._readableState;
            $.readableListening = re.listenerCount("readable") > 0, $.resumeScheduled && !$.paused ? $.flowing = !0 : re.listenerCount("data") > 0 && re.resume();
          }
          function Ze(re) {
            g("readable nexttick read 0"), re.read(0);
          }
          ie.prototype.resume = function() {
            var re = this._readableState;
            return re.flowing || (g("resume"), re.flowing = !re.readableListening, $e(this, re)), re.paused = !1, this;
          };
          function $e(re, $) {
            $.resumeScheduled || ($.resumeScheduled = !0, M.nextTick(Ve, re, $));
          }
          function Ve(re, $) {
            g("resume", $.reading), $.reading || re.read(0), $.resumeScheduled = !1, re.emit("resume"), Ge(re), $.flowing && !$.reading && re.read(0);
          }
          ie.prototype.pause = function() {
            return g("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (g("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
          };
          function Ge(re) {
            var $ = re._readableState;
            for (g("flow", $.flowing); $.flowing && re.read() !== null; )
              ;
          }
          ie.prototype.wrap = function(re) {
            var $ = this, Ce = this._readableState, ve = !1;
            re.on("end", function() {
              if (g("wrapped end"), Ce.decoder && !Ce.ended) {
                var Ae = Ce.decoder.end();
                Ae && Ae.length && $.push(Ae);
              }
              $.push(null);
            }), re.on("data", function(Ae) {
              if (g("wrapped data"), Ce.decoder && (Ae = Ce.decoder.write(Ae)), !(Ce.objectMode && Ae == null) && !(!Ce.objectMode && (!Ae || !Ae.length))) {
                var e = $.push(Ae);
                e || (ve = !0, re.pause());
              }
            });
            for (var Y in re)
              this[Y] === void 0 && typeof re[Y] == "function" && (this[Y] = /* @__PURE__ */ function(e) {
                return function() {
                  return re[e].apply(re, arguments);
                };
              }(Y));
            for (var G = 0; G < F.length; G++)
              re.on(F[G], this.emit.bind(this, F[G]));
            return this._read = function(Ae) {
              g("wrapped _read", Ae), ve && (ve = !1, re.resume());
            }, this;
          }, typeof Symbol == "function" && (ie.prototype[Symbol.asyncIterator] = function() {
            return z("Readable[Symbol.asyncIterator]"), J === void 0 && (J = k("./internal/streams/async_iterator")), J(this);
          }), Object.defineProperty(ie.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.highWaterMark;
            }
          }), Object.defineProperty(ie.prototype, "readableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState && this._readableState.buffer;
            }
          }), Object.defineProperty(ie.prototype, "readableFlowing", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.flowing;
            },
            set: function($) {
              this._readableState && (this._readableState.flowing = $);
            }
          }), ie._fromList = Ie, Object.defineProperty(ie.prototype, "readableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.length;
            }
          });
          function Ie(re, $) {
            if ($.length === 0) return null;
            var Ce;
            return $.objectMode ? Ce = $.buffer.shift() : !re || re >= $.length ? ($.decoder ? Ce = $.buffer.join("") : $.buffer.length === 1 ? Ce = $.buffer.first() : Ce = $.buffer.concat($.length), $.buffer.clear()) : Ce = $.buffer.consume(re, $.decoder), Ce;
          }
          function De(re) {
            var $ = re._readableState;
            g("endReadable", $.endEmitted), $.endEmitted || ($.ended = !0, M.nextTick(Ne, $, re));
          }
          function Ne(re, $) {
            g("endReadableNT", re.endEmitted, re.length), !re.endEmitted && re.length === 0 && (re.endEmitted = !0, $.readable = !1, $.emit("end"));
          }
          function _e(re, $) {
            for (var Ce = 0, ve = re.length; Ce < ve; Ce++)
              if (re[Ce] === $) return Ce;
            return -1;
          }
        }).call(this, k("_process"), typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {});
      }, { "../errors": 160, "../experimentalWarning": 161, "./_stream_duplex": 162, "./internal/streams/async_iterator": 167, "./internal/streams/buffer_list": 168, "./internal/streams/destroy": 169, "./internal/streams/state": 172, "./internal/streams/stream": 173, _process: 133, buffer: 48, events: 52, inherits: 75, "string_decoder/": 175, util: 33 }], 165: [function(k, Z, _) {
        Z.exports = a;
        var M = k("../errors").codes, x = M.ERR_METHOD_NOT_IMPLEMENTED, y = M.ERR_MULTIPLE_CALLBACK, E = M.ERR_TRANSFORM_ALREADY_TRANSFORMING, c = M.ERR_TRANSFORM_WITH_LENGTH_0, u = k("./_stream_duplex");
        k("inherits")(a, u);
        function l(g, h) {
          var m = this._transformState;
          m.transforming = !1;
          var s = m.writecb;
          if (s === null)
            return this.emit("error", new y());
          m.writechunk = null, m.writecb = null, h != null && this.push(h), s(g);
          var b = this._readableState;
          b.reading = !1, (b.needReadable || b.length < b.highWaterMark) && this._read(b.highWaterMark);
        }
        function a(g) {
          if (!(this instanceof a)) return new a(g);
          u.call(this, g), this._transformState = {
            afterTransform: l.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }, this._readableState.needReadable = !0, this._readableState.sync = !1, g && (typeof g.transform == "function" && (this._transform = g.transform), typeof g.flush == "function" && (this._flush = g.flush)), this.on("prefinish", n);
        }
        function n() {
          var g = this;
          typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(h, m) {
            d(g, h, m);
          }) : d(this, null, null);
        }
        a.prototype.push = function(g, h) {
          return this._transformState.needTransform = !1, u.prototype.push.call(this, g, h);
        }, a.prototype._transform = function(g, h, m) {
          m(new x("_transform()"));
        }, a.prototype._write = function(g, h, m) {
          var s = this._transformState;
          if (s.writecb = m, s.writechunk = g, s.writeencoding = h, !s.transforming) {
            var b = this._readableState;
            (s.needTransform || b.needReadable || b.length < b.highWaterMark) && this._read(b.highWaterMark);
          }
        }, a.prototype._read = function(g) {
          var h = this._transformState;
          h.writechunk !== null && !h.transforming ? (h.transforming = !0, this._transform(h.writechunk, h.writeencoding, h.afterTransform)) : h.needTransform = !0;
        }, a.prototype._destroy = function(g, h) {
          u.prototype._destroy.call(this, g, function(m) {
            h(m);
          });
        };
        function d(g, h, m) {
          if (h) return g.emit("error", h);
          if (m != null && g.push(m), g._writableState.length) throw new c();
          if (g._transformState.transforming) throw new E();
          return g.push(null);
        }
      }, { "../errors": 160, "./_stream_duplex": 162, inherits: 75 }], 166: [function(k, Z, _) {
        (function(M, x) {
          Z.exports = oe;
          function y(Ve) {
            var Ge = this;
            this.next = null, this.entry = null, this.finish = function() {
              $e(Ge, Ve);
            };
          }
          var E;
          oe.WritableState = J;
          var c = {
            deprecate: k("util-deprecate")
          }, u = k("./internal/streams/stream"), l = k("buffer").Buffer, a = x.Uint8Array || function() {
          };
          function n(Ve) {
            return l.from(Ve);
          }
          function d(Ve) {
            return l.isBuffer(Ve) || Ve instanceof a;
          }
          var g = k("./internal/streams/destroy"), h = k("./internal/streams/state"), m = h.getHighWaterMark, s = k("../errors").codes, b = s.ERR_INVALID_ARG_TYPE, S = s.ERR_METHOD_NOT_IMPLEMENTED, o = s.ERR_MULTIPLE_CALLBACK, A = s.ERR_STREAM_CANNOT_PIPE, T = s.ERR_STREAM_DESTROYED, I = s.ERR_STREAM_NULL_VALUES, L = s.ERR_STREAM_WRITE_AFTER_END, z = s.ERR_UNKNOWN_ENCODING;
          k("inherits")(oe, u);
          function U() {
          }
          function J(Ve, Ge, Ie) {
            E = E || k("./_stream_duplex"), Ve = Ve || {}, typeof Ie != "boolean" && (Ie = Ge instanceof E), this.objectMode = !!Ve.objectMode, Ie && (this.objectMode = this.objectMode || !!Ve.writableObjectMode), this.highWaterMark = m(this, Ve, "writableHighWaterMark", Ie), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var De = Ve.decodeStrings === !1;
            this.decodeStrings = !De, this.defaultEncoding = Ve.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ne) {
              Me(Ge, Ne);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Ve.emitClose !== !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new y(this);
          }
          J.prototype.getBuffer = function() {
            for (var Ge = this.bufferedRequest, Ie = []; Ge; )
              Ie.push(Ge), Ge = Ge.next;
            return Ie;
          }, function() {
            try {
              Object.defineProperty(J.prototype, "buffer", {
                get: c.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch {
            }
          }();
          var F;
          typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (F = Function.prototype[Symbol.hasInstance], Object.defineProperty(oe, Symbol.hasInstance, {
            value: function(Ge) {
              return F.call(this, Ge) ? !0 : this !== oe ? !1 : Ge && Ge._writableState instanceof J;
            }
          })) : F = function(Ge) {
            return Ge instanceof this;
          };
          function oe(Ve) {
            E = E || k("./_stream_duplex");
            var Ge = this instanceof E;
            if (!Ge && !F.call(oe, this)) return new oe(Ve);
            this._writableState = new J(Ve, this, Ge), this.writable = !0, Ve && (typeof Ve.write == "function" && (this._write = Ve.write), typeof Ve.writev == "function" && (this._writev = Ve.writev), typeof Ve.destroy == "function" && (this._destroy = Ve.destroy), typeof Ve.final == "function" && (this._final = Ve.final)), u.call(this);
          }
          oe.prototype.pipe = function() {
            this.emit("error", new A());
          };
          function ee(Ve, Ge) {
            var Ie = new L();
            Ve.emit("error", Ie), M.nextTick(Ge, Ie);
          }
          function ie(Ve, Ge, Ie, De) {
            var Ne;
            return Ie === null ? Ne = new I() : typeof Ie != "string" && !Ge.objectMode && (Ne = new b("chunk", ["string", "Buffer"], Ie)), Ne ? (Ve.emit("error", Ne), M.nextTick(De, Ne), !1) : !0;
          }
          oe.prototype.write = function(Ve, Ge, Ie) {
            var De = this._writableState, Ne = !1, _e = !De.objectMode && d(Ve);
            return _e && !l.isBuffer(Ve) && (Ve = n(Ve)), typeof Ge == "function" && (Ie = Ge, Ge = null), _e ? Ge = "buffer" : Ge || (Ge = De.defaultEncoding), typeof Ie != "function" && (Ie = U), De.ending ? ee(this, Ie) : (_e || ie(this, De, Ve, Ie)) && (De.pendingcb++, Ne = Q(this, De, _e, Ve, Ge, Ie)), Ne;
          }, oe.prototype.cork = function() {
            this._writableState.corked++;
          }, oe.prototype.uncork = function() {
            var Ve = this._writableState;
            Ve.corked && (Ve.corked--, !Ve.writing && !Ve.corked && !Ve.bufferProcessing && Ve.bufferedRequest && Ee(this, Ve));
          }, oe.prototype.setDefaultEncoding = function(Ge) {
            if (typeof Ge == "string" && (Ge = Ge.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Ge + "").toLowerCase()) > -1)) throw new z(Ge);
            return this._writableState.defaultEncoding = Ge, this;
          }, Object.defineProperty(oe.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          function W(Ve, Ge, Ie) {
            return !Ve.objectMode && Ve.decodeStrings !== !1 && typeof Ge == "string" && (Ge = l.from(Ge, Ie)), Ge;
          }
          Object.defineProperty(oe.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.highWaterMark;
            }
          });
          function Q(Ve, Ge, Ie, De, Ne, _e) {
            if (!Ie) {
              var re = W(Ge, De, Ne);
              De !== re && (Ie = !0, Ne = "buffer", De = re);
            }
            var $ = Ge.objectMode ? 1 : De.length;
            Ge.length += $;
            var Ce = Ge.length < Ge.highWaterMark;
            if (Ce || (Ge.needDrain = !0), Ge.writing || Ge.corked) {
              var ve = Ge.lastBufferedRequest;
              Ge.lastBufferedRequest = {
                chunk: De,
                encoding: Ne,
                isBuf: Ie,
                callback: _e,
                next: null
              }, ve ? ve.next = Ge.lastBufferedRequest : Ge.bufferedRequest = Ge.lastBufferedRequest, Ge.bufferedRequestCount += 1;
            } else
              de(Ve, Ge, !1, $, De, Ne, _e);
            return Ce;
          }
          function de(Ve, Ge, Ie, De, Ne, _e, re) {
            Ge.writelen = De, Ge.writecb = re, Ge.writing = !0, Ge.sync = !0, Ge.destroyed ? Ge.onwrite(new T("write")) : Ie ? Ve._writev(Ne, Ge.onwrite) : Ve._write(Ne, _e, Ge.onwrite), Ge.sync = !1;
          }
          function we(Ve, Ge, Ie, De, Ne) {
            --Ge.pendingcb, Ie ? (M.nextTick(Ne, De), M.nextTick(We, Ve, Ge), Ve._writableState.errorEmitted = !0, Ve.emit("error", De)) : (Ne(De), Ve._writableState.errorEmitted = !0, Ve.emit("error", De), We(Ve, Ge));
          }
          function ke(Ve) {
            Ve.writing = !1, Ve.writecb = null, Ve.length -= Ve.writelen, Ve.writelen = 0;
          }
          function Me(Ve, Ge) {
            var Ie = Ve._writableState, De = Ie.sync, Ne = Ie.writecb;
            if (typeof Ne != "function") throw new o();
            if (ke(Ie), Ge) we(Ve, Ie, De, Ge, Ne);
            else {
              var _e = Pe(Ie) || Ve.destroyed;
              !_e && !Ie.corked && !Ie.bufferProcessing && Ie.bufferedRequest && Ee(Ve, Ie), De ? M.nextTick(fe, Ve, Ie, _e, Ne) : fe(Ve, Ie, _e, Ne);
            }
          }
          function fe(Ve, Ge, Ie, De) {
            Ie || xe(Ve, Ge), Ge.pendingcb--, De(), We(Ve, Ge);
          }
          function xe(Ve, Ge) {
            Ge.length === 0 && Ge.needDrain && (Ge.needDrain = !1, Ve.emit("drain"));
          }
          function Ee(Ve, Ge) {
            Ge.bufferProcessing = !0;
            var Ie = Ge.bufferedRequest;
            if (Ve._writev && Ie && Ie.next) {
              var De = Ge.bufferedRequestCount, Ne = new Array(De), _e = Ge.corkedRequestsFree;
              _e.entry = Ie;
              for (var re = 0, $ = !0; Ie; )
                Ne[re] = Ie, Ie.isBuf || ($ = !1), Ie = Ie.next, re += 1;
              Ne.allBuffers = $, de(Ve, Ge, !0, Ge.length, Ne, "", _e.finish), Ge.pendingcb++, Ge.lastBufferedRequest = null, _e.next ? (Ge.corkedRequestsFree = _e.next, _e.next = null) : Ge.corkedRequestsFree = new y(Ge), Ge.bufferedRequestCount = 0;
            } else {
              for (; Ie; ) {
                var Ce = Ie.chunk, ve = Ie.encoding, Y = Ie.callback, G = Ge.objectMode ? 1 : Ce.length;
                if (de(Ve, Ge, !1, G, Ce, ve, Y), Ie = Ie.next, Ge.bufferedRequestCount--, Ge.writing)
                  break;
              }
              Ie === null && (Ge.lastBufferedRequest = null);
            }
            Ge.bufferedRequest = Ie, Ge.bufferProcessing = !1;
          }
          oe.prototype._write = function(Ve, Ge, Ie) {
            Ie(new S("_write()"));
          }, oe.prototype._writev = null, oe.prototype.end = function(Ve, Ge, Ie) {
            var De = this._writableState;
            return typeof Ve == "function" ? (Ie = Ve, Ve = null, Ge = null) : typeof Ge == "function" && (Ie = Ge, Ge = null), Ve != null && this.write(Ve, Ge), De.corked && (De.corked = 1, this.uncork()), De.ending || Ze(this, De, Ie), this;
          }, Object.defineProperty(oe.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.length;
            }
          });
          function Pe(Ve) {
            return Ve.ending && Ve.length === 0 && Ve.bufferedRequest === null && !Ve.finished && !Ve.writing;
          }
          function Ue(Ve, Ge) {
            Ve._final(function(Ie) {
              Ge.pendingcb--, Ie && Ve.emit("error", Ie), Ge.prefinished = !0, Ve.emit("prefinish"), We(Ve, Ge);
            });
          }
          function He(Ve, Ge) {
            !Ge.prefinished && !Ge.finalCalled && (typeof Ve._final == "function" && !Ge.destroyed ? (Ge.pendingcb++, Ge.finalCalled = !0, M.nextTick(Ue, Ve, Ge)) : (Ge.prefinished = !0, Ve.emit("prefinish")));
          }
          function We(Ve, Ge) {
            var Ie = Pe(Ge);
            return Ie && (He(Ve, Ge), Ge.pendingcb === 0 && (Ge.finished = !0, Ve.emit("finish"))), Ie;
          }
          function Ze(Ve, Ge, Ie) {
            Ge.ending = !0, We(Ve, Ge), Ie && (Ge.finished ? M.nextTick(Ie) : Ve.once("finish", Ie)), Ge.ended = !0, Ve.writable = !1;
          }
          function $e(Ve, Ge, Ie) {
            var De = Ve.entry;
            for (Ve.entry = null; De; ) {
              var Ne = De.callback;
              Ge.pendingcb--, Ne(Ie), De = De.next;
            }
            Ge.corkedRequestsFree.next = Ve;
          }
          Object.defineProperty(oe.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState === void 0 ? !1 : this._writableState.destroyed;
            },
            set: function(Ge) {
              this._writableState && (this._writableState.destroyed = Ge);
            }
          }), oe.prototype.destroy = g.destroy, oe.prototype._undestroy = g.undestroy, oe.prototype._destroy = function(Ve, Ge) {
            Ge(Ve);
          };
        }).call(this, k("_process"), typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {});
      }, { "../errors": 160, "./_stream_duplex": 162, "./internal/streams/destroy": 169, "./internal/streams/state": 172, "./internal/streams/stream": 173, _process: 133, buffer: 48, inherits: 75, "util-deprecate": 183 }], 167: [function(k, Z, _) {
        (function(M) {
          var x;
          function y(T, I, L) {
            return I in T ? Object.defineProperty(T, I, { value: L, enumerable: !0, configurable: !0, writable: !0 }) : T[I] = L, T;
          }
          var E = k("./end-of-stream"), c = Symbol("lastResolve"), u = Symbol("lastReject"), l = Symbol("error"), a = Symbol("ended"), n = Symbol("lastPromise"), d = Symbol("handlePromise"), g = Symbol("stream");
          function h(T, I) {
            return {
              value: T,
              done: I
            };
          }
          function m(T) {
            var I = T[c];
            if (I !== null) {
              var L = T[g].read();
              L !== null && (T[n] = null, T[c] = null, T[u] = null, I(h(L, !1)));
            }
          }
          function s(T) {
            M.nextTick(m, T);
          }
          function b(T, I) {
            return function(L, z) {
              T.then(function() {
                if (I[a]) {
                  L(h(void 0, !0));
                  return;
                }
                I[d](L, z);
              }, z);
            };
          }
          var S = Object.getPrototypeOf(function() {
          }), o = Object.setPrototypeOf((x = {
            get stream() {
              return this[g];
            },
            next: function() {
              var I = this, L = this[l];
              if (L !== null)
                return Promise.reject(L);
              if (this[a])
                return Promise.resolve(h(void 0, !0));
              if (this[g].destroyed)
                return new Promise(function(F, oe) {
                  M.nextTick(function() {
                    I[l] ? oe(I[l]) : F(h(void 0, !0));
                  });
                });
              var z = this[n], U;
              if (z)
                U = new Promise(b(z, this));
              else {
                var J = this[g].read();
                if (J !== null)
                  return Promise.resolve(h(J, !1));
                U = new Promise(this[d]);
              }
              return this[n] = U, U;
            }
          }, y(x, Symbol.asyncIterator, function() {
            return this;
          }), y(x, "return", function() {
            var I = this;
            return new Promise(function(L, z) {
              I[g].destroy(null, function(U) {
                if (U) {
                  z(U);
                  return;
                }
                L(h(void 0, !0));
              });
            });
          }), x), S), A = function(I) {
            var L, z = Object.create(o, (L = {}, y(L, g, {
              value: I,
              writable: !0
            }), y(L, c, {
              value: null,
              writable: !0
            }), y(L, u, {
              value: null,
              writable: !0
            }), y(L, l, {
              value: null,
              writable: !0
            }), y(L, a, {
              value: I._readableState.endEmitted,
              writable: !0
            }), y(L, d, {
              value: function(J, F) {
                var oe = z[g].read();
                oe ? (z[n] = null, z[c] = null, z[u] = null, J(h(oe, !1))) : (z[c] = J, z[u] = F);
              },
              writable: !0
            }), L));
            return z[n] = null, E(I, function(U) {
              if (U && U.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var J = z[u];
                J !== null && (z[n] = null, z[c] = null, z[u] = null, J(U)), z[l] = U;
                return;
              }
              var F = z[c];
              F !== null && (z[n] = null, z[c] = null, z[u] = null, F(h(void 0, !0))), z[a] = !0;
            }), I.on("readable", s.bind(null, z)), z;
          };
          Z.exports = A;
        }).call(this, k("_process"));
      }, { "./end-of-stream": 170, _process: 133 }], 168: [function(k, Z, _) {
        function M(n) {
          for (var d = 1; d < arguments.length; d++) {
            var g = arguments[d] != null ? arguments[d] : {}, h = Object.keys(g);
            typeof Object.getOwnPropertySymbols == "function" && (h = h.concat(Object.getOwnPropertySymbols(g).filter(function(m) {
              return Object.getOwnPropertyDescriptor(g, m).enumerable;
            }))), h.forEach(function(m) {
              x(n, m, g[m]);
            });
          }
          return n;
        }
        function x(n, d, g) {
          return d in n ? Object.defineProperty(n, d, { value: g, enumerable: !0, configurable: !0, writable: !0 }) : n[d] = g, n;
        }
        var y = k("buffer"), E = y.Buffer, c = k("util"), u = c.inspect, l = u && u.custom || "inspect";
        function a(n, d, g) {
          E.prototype.copy.call(n, d, g);
        }
        Z.exports = /* @__PURE__ */ function() {
          function n() {
            this.head = null, this.tail = null, this.length = 0;
          }
          var d = n.prototype;
          return d.push = function(h) {
            var m = {
              data: h,
              next: null
            };
            this.length > 0 ? this.tail.next = m : this.head = m, this.tail = m, ++this.length;
          }, d.unshift = function(h) {
            var m = {
              data: h,
              next: this.head
            };
            this.length === 0 && (this.tail = m), this.head = m, ++this.length;
          }, d.shift = function() {
            if (this.length !== 0) {
              var h = this.head.data;
              return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, h;
            }
          }, d.clear = function() {
            this.head = this.tail = null, this.length = 0;
          }, d.join = function(h) {
            if (this.length === 0) return "";
            for (var m = this.head, s = "" + m.data; m = m.next; )
              s += h + m.data;
            return s;
          }, d.concat = function(h) {
            if (this.length === 0) return E.alloc(0);
            for (var m = E.allocUnsafe(h >>> 0), s = this.head, b = 0; s; )
              a(s.data, m, b), b += s.data.length, s = s.next;
            return m;
          }, d.consume = function(h, m) {
            var s;
            return h < this.head.data.length ? (s = this.head.data.slice(0, h), this.head.data = this.head.data.slice(h)) : h === this.head.data.length ? s = this.shift() : s = m ? this._getString(h) : this._getBuffer(h), s;
          }, d.first = function() {
            return this.head.data;
          }, d._getString = function(h) {
            var m = this.head, s = 1, b = m.data;
            for (h -= b.length; m = m.next; ) {
              var S = m.data, o = h > S.length ? S.length : h;
              if (o === S.length ? b += S : b += S.slice(0, h), h -= o, h === 0) {
                o === S.length ? (++s, m.next ? this.head = m.next : this.head = this.tail = null) : (this.head = m, m.data = S.slice(o));
                break;
              }
              ++s;
            }
            return this.length -= s, b;
          }, d._getBuffer = function(h) {
            var m = E.allocUnsafe(h), s = this.head, b = 1;
            for (s.data.copy(m), h -= s.data.length; s = s.next; ) {
              var S = s.data, o = h > S.length ? S.length : h;
              if (S.copy(m, m.length - h, 0, o), h -= o, h === 0) {
                o === S.length ? (++b, s.next ? this.head = s.next : this.head = this.tail = null) : (this.head = s, s.data = S.slice(o));
                break;
              }
              ++b;
            }
            return this.length -= b, m;
          }, d[l] = function(g, h) {
            return u(this, M({}, h, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: !1
            }));
          }, n;
        }();
      }, { buffer: 48, util: 33 }], 169: [function(k, Z, _) {
        (function(M) {
          function x(l, a) {
            var n = this, d = this._readableState && this._readableState.destroyed, g = this._writableState && this._writableState.destroyed;
            return d || g ? (a ? a(l) : l && (!this._writableState || !this._writableState.errorEmitted) && M.nextTick(u, this, l), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(l || null, function(h) {
              !a && h ? (M.nextTick(y, n, h), n._writableState && (n._writableState.errorEmitted = !0)) : a ? (M.nextTick(E, n), a(h)) : M.nextTick(E, n);
            }), this);
          }
          function y(l, a) {
            u(l, a), E(l);
          }
          function E(l) {
            l._writableState && !l._writableState.emitClose || l._readableState && !l._readableState.emitClose || l.emit("close");
          }
          function c() {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
          }
          function u(l, a) {
            l.emit("error", a);
          }
          Z.exports = {
            destroy: x,
            undestroy: c
          };
        }).call(this, k("_process"));
      }, { _process: 133 }], 170: [function(k, Z, _) {
        var M = k("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function x(u) {
          var l = !1;
          return function() {
            if (!l) {
              l = !0;
              for (var a = arguments.length, n = new Array(a), d = 0; d < a; d++)
                n[d] = arguments[d];
              u.apply(this, n);
            }
          };
        }
        function y() {
        }
        function E(u) {
          return u.setHeader && typeof u.abort == "function";
        }
        function c(u, l, a) {
          if (typeof l == "function") return c(u, null, l);
          l || (l = {}), a = x(a || y);
          var n = l.readable || l.readable !== !1 && u.readable, d = l.writable || l.writable !== !1 && u.writable, g = function() {
            u.writable || m();
          }, h = u._writableState && u._writableState.finished, m = function() {
            d = !1, h = !0, n || a.call(u);
          }, s = u._readableState && u._readableState.endEmitted, b = function() {
            n = !1, s = !0, d || a.call(u);
          }, S = function(I) {
            a.call(u, I);
          }, o = function() {
            var I;
            if (n && !s)
              return (!u._readableState || !u._readableState.ended) && (I = new M()), a.call(u, I);
            if (d && !h)
              return (!u._writableState || !u._writableState.ended) && (I = new M()), a.call(u, I);
          }, A = function() {
            u.req.on("finish", m);
          };
          return E(u) ? (u.on("complete", m), u.on("abort", o), u.req ? A() : u.on("request", A)) : d && !u._writableState && (u.on("end", g), u.on("close", g)), u.on("end", b), u.on("finish", m), l.error !== !1 && u.on("error", S), u.on("close", o), function() {
            u.removeListener("complete", m), u.removeListener("abort", o), u.removeListener("request", A), u.req && u.req.removeListener("finish", m), u.removeListener("end", g), u.removeListener("close", g), u.removeListener("finish", m), u.removeListener("end", b), u.removeListener("error", S), u.removeListener("close", o);
          };
        }
        Z.exports = c;
      }, { "../../../errors": 160 }], 171: [function(k, Z, _) {
        var M;
        function x(m) {
          var s = !1;
          return function() {
            s || (s = !0, m.apply(void 0, arguments));
          };
        }
        var y = k("../../../errors").codes, E = y.ERR_MISSING_ARGS, c = y.ERR_STREAM_DESTROYED;
        function u(m) {
          if (m) throw m;
        }
        function l(m) {
          return m.setHeader && typeof m.abort == "function";
        }
        function a(m, s, b, S) {
          S = x(S);
          var o = !1;
          m.on("close", function() {
            o = !0;
          }), M === void 0 && (M = k("./end-of-stream")), M(m, {
            readable: s,
            writable: b
          }, function(T) {
            if (T) return S(T);
            o = !0, S();
          });
          var A = !1;
          return function(T) {
            if (!o && !A) {
              if (A = !0, l(m)) return m.abort();
              if (typeof m.destroy == "function") return m.destroy();
              S(T || new c("pipe"));
            }
          };
        }
        function n(m) {
          m();
        }
        function d(m, s) {
          return m.pipe(s);
        }
        function g(m) {
          return !m.length || typeof m[m.length - 1] != "function" ? u : m.pop();
        }
        function h() {
          for (var m = arguments.length, s = new Array(m), b = 0; b < m; b++)
            s[b] = arguments[b];
          var S = g(s);
          if (Array.isArray(s[0]) && (s = s[0]), s.length < 2)
            throw new E("streams");
          var o, A = s.map(function(T, I) {
            var L = I < s.length - 1, z = I > 0;
            return a(T, L, z, function(U) {
              o || (o = U), U && A.forEach(n), !L && (A.forEach(n), S(o));
            });
          });
          return s.reduce(d);
        }
        Z.exports = h;
      }, { "../../../errors": 160, "./end-of-stream": 170 }], 172: [function(k, Z, _) {
        var M = k("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        function x(E, c, u) {
          return E.highWaterMark != null ? E.highWaterMark : c ? E[u] : null;
        }
        function y(E, c, u, l) {
          var a = x(c, l, u);
          if (a != null) {
            if (!(isFinite(a) && Math.floor(a) === a) || a < 0) {
              var n = l ? u : "highWaterMark";
              throw new M(n, a);
            }
            return Math.floor(a);
          }
          return E.objectMode ? 16 : 16 * 1024;
        }
        Z.exports = {
          getHighWaterMark: y
        };
      }, { "../../../errors": 160 }], 173: [function(k, Z, _) {
        arguments[4][146][0].apply(_, arguments);
      }, { dup: 146, events: 52 }], 174: [function(k, Z, _) {
        _ = Z.exports = k("./lib/_stream_readable.js"), _.Stream = _, _.Readable = _, _.Writable = k("./lib/_stream_writable.js"), _.Duplex = k("./lib/_stream_duplex.js"), _.Transform = k("./lib/_stream_transform.js"), _.PassThrough = k("./lib/_stream_passthrough.js"), _.finished = k("./lib/internal/streams/end-of-stream.js"), _.pipeline = k("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 162, "./lib/_stream_passthrough.js": 163, "./lib/_stream_readable.js": 164, "./lib/_stream_transform.js": 165, "./lib/_stream_writable.js": 166, "./lib/internal/streams/end-of-stream.js": 170, "./lib/internal/streams/pipeline.js": 171 }], 175: [function(k, Z, _) {
        arguments[4][148][0].apply(_, arguments);
      }, { dup: 148, "safe-buffer": 154 }], 176: [function(k, Z, _) {
        (function(M, x) {
          var y = k("process/browser.js").nextTick, E = Function.prototype.apply, c = Array.prototype.slice, u = {}, l = 0;
          _.setTimeout = function() {
            return new a(E.call(setTimeout, ae, arguments), clearTimeout);
          }, _.setInterval = function() {
            return new a(E.call(setInterval, ae, arguments), clearInterval);
          }, _.clearTimeout = _.clearInterval = function(n) {
            n.close();
          };
          function a(n, d) {
            this._id = n, this._clearFn = d;
          }
          a.prototype.unref = a.prototype.ref = function() {
          }, a.prototype.close = function() {
            this._clearFn.call(ae, this._id);
          }, _.enroll = function(n, d) {
            clearTimeout(n._idleTimeoutId), n._idleTimeout = d;
          }, _.unenroll = function(n) {
            clearTimeout(n._idleTimeoutId), n._idleTimeout = -1;
          }, _._unrefActive = _.active = function(n) {
            clearTimeout(n._idleTimeoutId);
            var d = n._idleTimeout;
            d >= 0 && (n._idleTimeoutId = setTimeout(function() {
              n._onTimeout && n._onTimeout();
            }, d));
          }, _.setImmediate = typeof M == "function" ? M : function(n) {
            var d = l++, g = arguments.length < 2 ? !1 : c.call(arguments, 1);
            return u[d] = !0, y(function() {
              u[d] && (g ? n.apply(null, g) : n.call(null), _.clearImmediate(d));
            }), d;
          }, _.clearImmediate = typeof x == "function" ? x : function(n) {
            delete u[n];
          };
        }).call(this, k("timers").setImmediate, k("timers").clearImmediate);
      }, { "process/browser.js": 133, timers: 176 }], 177: [function(k, Z, _) {
        (function(M) {
          Object.defineProperty(_, "__esModule", {
            value: !0
          });
          var x = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(W) {
            return typeof W;
          } : function(W) {
            return W && typeof Symbol == "function" && W.constructor === Symbol && W !== Symbol.prototype ? "symbol" : typeof W;
          };
          _.clone = l, _.addLast = d, _.addFirst = g, _.removeLast = h, _.removeFirst = m, _.insert = s, _.removeAt = b, _.replaceAt = S, _.getIn = o, _.set = A, _.setIn = I, _.update = L, _.updateIn = z, _.merge = U, _.mergeDeep = J, _.mergeIn = F, _.omit = oe, _.addDefaults = ee;
          /*!
           * Timm
           *
           * Immutability helpers with fast reads and acceptable writes.
           *
           * @copyright Guillermo Grau Panea 2016
           * @license MIT
           */
          var y = "INVALID_ARGS";
          function E(W) {
            throw new Error(W);
          }
          function c(W) {
            var Q = Object.keys(W);
            return Object.getOwnPropertySymbols ? Q.concat(Object.getOwnPropertySymbols(W)) : Q;
          }
          var u = {}.hasOwnProperty;
          function l(W) {
            if (Array.isArray(W)) return W.slice();
            for (var Q = c(W), de = {}, we = 0; we < Q.length; we++) {
              var ke = Q[we];
              de[ke] = W[ke];
            }
            return de;
          }
          function a(W, Q, de) {
            var we = de;
            we == null && E(M.env.NODE_ENV !== "production" ? "At least one object should be provided to merge()" : y);
            for (var ke = !1, Me = arguments.length, fe = Array(Me > 3 ? Me - 3 : 0), xe = 3; xe < Me; xe++)
              fe[xe - 3] = arguments[xe];
            for (var Ee = 0; Ee < fe.length; Ee++) {
              var Pe = fe[Ee];
              if (Pe != null) {
                var Ue = c(Pe);
                if (Ue.length)
                  for (var He = 0; He <= Ue.length; He++) {
                    var We = Ue[He];
                    if (!(W && we[We] !== void 0)) {
                      var Ze = Pe[We];
                      Q && n(we[We]) && n(Ze) && (Ze = a(W, Q, we[We], Ze)), !(Ze === void 0 || Ze === we[We]) && (ke || (ke = !0, we = l(we)), we[We] = Ze);
                    }
                  }
              }
            }
            return we;
          }
          function n(W) {
            var Q = typeof W > "u" ? "undefined" : x(W);
            return W != null && Q === "object";
          }
          function d(W, Q) {
            return Array.isArray(Q) ? W.concat(Q) : W.concat([Q]);
          }
          function g(W, Q) {
            return Array.isArray(Q) ? Q.concat(W) : [Q].concat(W);
          }
          function h(W) {
            return W.length ? W.slice(0, W.length - 1) : W;
          }
          function m(W) {
            return W.length ? W.slice(1) : W;
          }
          function s(W, Q, de) {
            return W.slice(0, Q).concat(Array.isArray(de) ? de : [de]).concat(W.slice(Q));
          }
          function b(W, Q) {
            return Q >= W.length || Q < 0 ? W : W.slice(0, Q).concat(W.slice(Q + 1));
          }
          function S(W, Q, de) {
            if (W[Q] === de) return W;
            for (var we = W.length, ke = Array(we), Me = 0; Me < we; Me++)
              ke[Me] = W[Me];
            return ke[Q] = de, ke;
          }
          function o(W, Q) {
            if (!Array.isArray(Q) && E(M.env.NODE_ENV !== "production" ? "A path array should be provided when calling getIn()" : y), W != null) {
              for (var de = W, we = 0; we < Q.length; we++) {
                var ke = Q[we];
                if (de = de != null ? de[ke] : void 0, de === void 0) return de;
              }
              return de;
            }
          }
          function A(W, Q, de) {
            var we = typeof Q == "number" ? [] : {}, ke = W ?? we;
            if (ke[Q] === de) return ke;
            var Me = l(ke);
            return Me[Q] = de, Me;
          }
          function T(W, Q, de, we) {
            var ke = void 0, Me = Q[we];
            if (we === Q.length - 1)
              ke = de;
            else {
              var fe = n(W) && n(W[Me]) ? W[Me] : typeof Q[we + 1] == "number" ? [] : {};
              ke = T(fe, Q, de, we + 1);
            }
            return A(W, Me, ke);
          }
          function I(W, Q, de) {
            return Q.length ? T(W, Q, de, 0) : de;
          }
          function L(W, Q, de) {
            var we = W == null ? void 0 : W[Q], ke = de(we);
            return A(W, Q, ke);
          }
          function z(W, Q, de) {
            var we = o(W, Q), ke = de(we);
            return I(W, Q, ke);
          }
          function U(W, Q, de, we, ke, Me) {
            for (var fe = arguments.length, xe = Array(fe > 6 ? fe - 6 : 0), Ee = 6; Ee < fe; Ee++)
              xe[Ee - 6] = arguments[Ee];
            return xe.length ? a.call.apply(a, [null, !1, !1, W, Q, de, we, ke, Me].concat(xe)) : a(!1, !1, W, Q, de, we, ke, Me);
          }
          function J(W, Q, de, we, ke, Me) {
            for (var fe = arguments.length, xe = Array(fe > 6 ? fe - 6 : 0), Ee = 6; Ee < fe; Ee++)
              xe[Ee - 6] = arguments[Ee];
            return xe.length ? a.call.apply(a, [null, !1, !0, W, Q, de, we, ke, Me].concat(xe)) : a(!1, !0, W, Q, de, we, ke, Me);
          }
          function F(W, Q, de, we, ke, Me, fe) {
            var xe = o(W, Q);
            xe == null && (xe = {});
            for (var Ee = void 0, Pe = arguments.length, Ue = Array(Pe > 7 ? Pe - 7 : 0), He = 7; He < Pe; He++)
              Ue[He - 7] = arguments[He];
            return Ue.length ? Ee = a.call.apply(a, [null, !1, !1, xe, de, we, ke, Me, fe].concat(Ue)) : Ee = a(!1, !1, xe, de, we, ke, Me, fe), I(W, Q, Ee);
          }
          function oe(W, Q) {
            for (var de = Array.isArray(Q) ? Q : [Q], we = !1, ke = 0; ke < de.length; ke++)
              if (u.call(W, de[ke])) {
                we = !0;
                break;
              }
            if (!we) return W;
            for (var Me = {}, fe = c(W), xe = 0; xe < fe.length; xe++) {
              var Ee = fe[xe];
              de.indexOf(Ee) >= 0 || (Me[Ee] = W[Ee]);
            }
            return Me;
          }
          function ee(W, Q, de, we, ke, Me) {
            for (var fe = arguments.length, xe = Array(fe > 6 ? fe - 6 : 0), Ee = 6; Ee < fe; Ee++)
              xe[Ee - 6] = arguments[Ee];
            return xe.length ? a.call.apply(a, [null, !0, !1, W, Q, de, we, ke, Me].concat(xe)) : a(!0, !1, W, Q, de, we, ke, Me);
          }
          var ie = {
            clone: l,
            addLast: d,
            addFirst: g,
            removeLast: h,
            removeFirst: m,
            insert: s,
            removeAt: b,
            replaceAt: S,
            getIn: o,
            // eslint-disable-next-line object-shorthand
            set: A,
            // so that flow doesn't complain
            setIn: I,
            update: L,
            updateIn: z,
            merge: U,
            mergeDeep: J,
            mergeIn: F,
            omit: oe,
            addDefaults: ee
          };
          _.default = ie;
        }).call(this, k("_process"));
      }, { _process: 133 }], 178: [function(k, Z, _) {
        (function(M) {
          var x = /^\s+/, y = /\s+$/, E = 0, c = M.round, u = M.min, l = M.max, a = M.random;
          function n(_e, re) {
            if (_e = _e || "", re = re || {}, _e instanceof n)
              return _e;
            if (!(this instanceof n))
              return new n(_e, re);
            var $ = d(_e);
            this._originalInput = _e, this._r = $.r, this._g = $.g, this._b = $.b, this._a = $.a, this._roundA = c(100 * this._a) / 100, this._format = re.format || $.format, this._gradientType = re.gradientType, this._r < 1 && (this._r = c(this._r)), this._g < 1 && (this._g = c(this._g)), this._b < 1 && (this._b = c(this._b)), this._ok = $.ok, this._tc_id = E++;
          }
          n.prototype = {
            isDark: function() {
              return this.getBrightness() < 128;
            },
            isLight: function() {
              return !this.isDark();
            },
            isValid: function() {
              return this._ok;
            },
            getOriginalInput: function() {
              return this._originalInput;
            },
            getFormat: function() {
              return this._format;
            },
            getAlpha: function() {
              return this._a;
            },
            getBrightness: function() {
              var _e = this.toRgb();
              return (_e.r * 299 + _e.g * 587 + _e.b * 114) / 1e3;
            },
            getLuminance: function() {
              var _e = this.toRgb(), re, $, Ce, ve, Y, G;
              return re = _e.r / 255, $ = _e.g / 255, Ce = _e.b / 255, re <= 0.03928 ? ve = re / 12.92 : ve = M.pow((re + 0.055) / 1.055, 2.4), $ <= 0.03928 ? Y = $ / 12.92 : Y = M.pow(($ + 0.055) / 1.055, 2.4), Ce <= 0.03928 ? G = Ce / 12.92 : G = M.pow((Ce + 0.055) / 1.055, 2.4), 0.2126 * ve + 0.7152 * Y + 0.0722 * G;
            },
            setAlpha: function(_e) {
              return this._a = fe(_e), this._roundA = c(100 * this._a) / 100, this;
            },
            toHsv: function() {
              var _e = s(this._r, this._g, this._b);
              return { h: _e.h * 360, s: _e.s, v: _e.v, a: this._a };
            },
            toHsvString: function() {
              var _e = s(this._r, this._g, this._b), re = c(_e.h * 360), $ = c(_e.s * 100), Ce = c(_e.v * 100);
              return this._a == 1 ? "hsv(" + re + ", " + $ + "%, " + Ce + "%)" : "hsva(" + re + ", " + $ + "%, " + Ce + "%, " + this._roundA + ")";
            },
            toHsl: function() {
              var _e = h(this._r, this._g, this._b);
              return { h: _e.h * 360, s: _e.s, l: _e.l, a: this._a };
            },
            toHslString: function() {
              var _e = h(this._r, this._g, this._b), re = c(_e.h * 360), $ = c(_e.s * 100), Ce = c(_e.l * 100);
              return this._a == 1 ? "hsl(" + re + ", " + $ + "%, " + Ce + "%)" : "hsla(" + re + ", " + $ + "%, " + Ce + "%, " + this._roundA + ")";
            },
            toHex: function(_e) {
              return S(this._r, this._g, this._b, _e);
            },
            toHexString: function(_e) {
              return "#" + this.toHex(_e);
            },
            toHex8: function(_e) {
              return o(this._r, this._g, this._b, this._a, _e);
            },
            toHex8String: function(_e) {
              return "#" + this.toHex8(_e);
            },
            toRgb: function() {
              return { r: c(this._r), g: c(this._g), b: c(this._b), a: this._a };
            },
            toRgbString: function() {
              return this._a == 1 ? "rgb(" + c(this._r) + ", " + c(this._g) + ", " + c(this._b) + ")" : "rgba(" + c(this._r) + ", " + c(this._g) + ", " + c(this._b) + ", " + this._roundA + ")";
            },
            toPercentageRgb: function() {
              return { r: c(xe(this._r, 255) * 100) + "%", g: c(xe(this._g, 255) * 100) + "%", b: c(xe(this._b, 255) * 100) + "%", a: this._a };
            },
            toPercentageRgbString: function() {
              return this._a == 1 ? "rgb(" + c(xe(this._r, 255) * 100) + "%, " + c(xe(this._g, 255) * 100) + "%, " + c(xe(this._b, 255) * 100) + "%)" : "rgba(" + c(xe(this._r, 255) * 100) + "%, " + c(xe(this._g, 255) * 100) + "%, " + c(xe(this._b, 255) * 100) + "%, " + this._roundA + ")";
            },
            toName: function() {
              return this._a === 0 ? "transparent" : this._a < 1 ? !1 : ke[S(this._r, this._g, this._b, !0)] || !1;
            },
            toFilter: function(_e) {
              var re = "#" + A(this._r, this._g, this._b, this._a), $ = re, Ce = this._gradientType ? "GradientType = 1, " : "";
              if (_e) {
                var ve = n(_e);
                $ = "#" + A(ve._r, ve._g, ve._b, ve._a);
              }
              return "progid:DXImageTransform.Microsoft.gradient(" + Ce + "startColorstr=" + re + ",endColorstr=" + $ + ")";
            },
            toString: function(_e) {
              var re = !!_e;
              _e = _e || this._format;
              var $ = !1, Ce = this._a < 1 && this._a >= 0, ve = !re && Ce && (_e === "hex" || _e === "hex6" || _e === "hex3" || _e === "hex4" || _e === "hex8" || _e === "name");
              return ve ? _e === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (_e === "rgb" && ($ = this.toRgbString()), _e === "prgb" && ($ = this.toPercentageRgbString()), (_e === "hex" || _e === "hex6") && ($ = this.toHexString()), _e === "hex3" && ($ = this.toHexString(!0)), _e === "hex4" && ($ = this.toHex8String(!0)), _e === "hex8" && ($ = this.toHex8String()), _e === "name" && ($ = this.toName()), _e === "hsl" && ($ = this.toHslString()), _e === "hsv" && ($ = this.toHsvString()), $ || this.toHexString());
            },
            clone: function() {
              return n(this.toString());
            },
            _applyModification: function(_e, re) {
              var $ = _e.apply(null, [this].concat([].slice.call(re)));
              return this._r = $._r, this._g = $._g, this._b = $._b, this.setAlpha($._a), this;
            },
            lighten: function() {
              return this._applyModification(z, arguments);
            },
            brighten: function() {
              return this._applyModification(U, arguments);
            },
            darken: function() {
              return this._applyModification(J, arguments);
            },
            desaturate: function() {
              return this._applyModification(T, arguments);
            },
            saturate: function() {
              return this._applyModification(I, arguments);
            },
            greyscale: function() {
              return this._applyModification(L, arguments);
            },
            spin: function() {
              return this._applyModification(F, arguments);
            },
            _applyCombination: function(_e, re) {
              return _e.apply(null, [this].concat([].slice.call(re)));
            },
            analogous: function() {
              return this._applyCombination(Q, arguments);
            },
            complement: function() {
              return this._applyCombination(oe, arguments);
            },
            monochromatic: function() {
              return this._applyCombination(de, arguments);
            },
            splitcomplement: function() {
              return this._applyCombination(W, arguments);
            },
            triad: function() {
              return this._applyCombination(ee, arguments);
            },
            tetrad: function() {
              return this._applyCombination(ie, arguments);
            }
          }, n.fromRatio = function(_e, re) {
            if (typeof _e == "object") {
              var $ = {};
              for (var Ce in _e)
                _e.hasOwnProperty(Ce) && (Ce === "a" ? $[Ce] = _e[Ce] : $[Ce] = Ze(_e[Ce]));
              _e = $;
            }
            return n(_e, re);
          };
          function d(_e) {
            var re = { r: 0, g: 0, b: 0 }, $ = 1, Ce = null, ve = null, Y = null, G = !1, Ae = !1;
            return typeof _e == "string" && (_e = De(_e)), typeof _e == "object" && (Ie(_e.r) && Ie(_e.g) && Ie(_e.b) ? (re = g(_e.r, _e.g, _e.b), G = !0, Ae = String(_e.r).substr(-1) === "%" ? "prgb" : "rgb") : Ie(_e.h) && Ie(_e.s) && Ie(_e.v) ? (Ce = Ze(_e.s), ve = Ze(_e.v), re = b(_e.h, Ce, ve), G = !0, Ae = "hsv") : Ie(_e.h) && Ie(_e.s) && Ie(_e.l) && (Ce = Ze(_e.s), Y = Ze(_e.l), re = m(_e.h, Ce, Y), G = !0, Ae = "hsl"), _e.hasOwnProperty("a") && ($ = _e.a)), $ = fe($), {
              ok: G,
              format: _e.format || Ae,
              r: u(255, l(re.r, 0)),
              g: u(255, l(re.g, 0)),
              b: u(255, l(re.b, 0)),
              a: $
            };
          }
          function g(_e, re, $) {
            return {
              r: xe(_e, 255) * 255,
              g: xe(re, 255) * 255,
              b: xe($, 255) * 255
            };
          }
          function h(_e, re, $) {
            _e = xe(_e, 255), re = xe(re, 255), $ = xe($, 255);
            var Ce = l(_e, re, $), ve = u(_e, re, $), Y, G, Ae = (Ce + ve) / 2;
            if (Ce == ve)
              Y = G = 0;
            else {
              var e = Ce - ve;
              switch (G = Ae > 0.5 ? e / (2 - Ce - ve) : e / (Ce + ve), Ce) {
                case _e:
                  Y = (re - $) / e + (re < $ ? 6 : 0);
                  break;
                case re:
                  Y = ($ - _e) / e + 2;
                  break;
                case $:
                  Y = (_e - re) / e + 4;
                  break;
              }
              Y /= 6;
            }
            return { h: Y, s: G, l: Ae };
          }
          function m(_e, re, $) {
            var Ce, ve, Y;
            _e = xe(_e, 360), re = xe(re, 100), $ = xe($, 100);
            function G(r, f, C) {
              return C < 0 && (C += 1), C > 1 && (C -= 1), C < 1 / 6 ? r + (f - r) * 6 * C : C < 1 / 2 ? f : C < 2 / 3 ? r + (f - r) * (2 / 3 - C) * 6 : r;
            }
            if (re === 0)
              Ce = ve = Y = $;
            else {
              var Ae = $ < 0.5 ? $ * (1 + re) : $ + re - $ * re, e = 2 * $ - Ae;
              Ce = G(e, Ae, _e + 1 / 3), ve = G(e, Ae, _e), Y = G(e, Ae, _e - 1 / 3);
            }
            return { r: Ce * 255, g: ve * 255, b: Y * 255 };
          }
          function s(_e, re, $) {
            _e = xe(_e, 255), re = xe(re, 255), $ = xe($, 255);
            var Ce = l(_e, re, $), ve = u(_e, re, $), Y, G, Ae = Ce, e = Ce - ve;
            if (G = Ce === 0 ? 0 : e / Ce, Ce == ve)
              Y = 0;
            else {
              switch (Ce) {
                case _e:
                  Y = (re - $) / e + (re < $ ? 6 : 0);
                  break;
                case re:
                  Y = ($ - _e) / e + 2;
                  break;
                case $:
                  Y = (_e - re) / e + 4;
                  break;
              }
              Y /= 6;
            }
            return { h: Y, s: G, v: Ae };
          }
          function b(_e, re, $) {
            _e = xe(_e, 360) * 6, re = xe(re, 100), $ = xe($, 100);
            var Ce = M.floor(_e), ve = _e - Ce, Y = $ * (1 - re), G = $ * (1 - ve * re), Ae = $ * (1 - (1 - ve) * re), e = Ce % 6, r = [$, G, Y, Y, Ae, $][e], f = [Ae, $, $, G, Y, Y][e], C = [Y, Y, Ae, $, $, G][e];
            return { r: r * 255, g: f * 255, b: C * 255 };
          }
          function S(_e, re, $, Ce) {
            var ve = [
              We(c(_e).toString(16)),
              We(c(re).toString(16)),
              We(c($).toString(16))
            ];
            return Ce && ve[0].charAt(0) == ve[0].charAt(1) && ve[1].charAt(0) == ve[1].charAt(1) && ve[2].charAt(0) == ve[2].charAt(1) ? ve[0].charAt(0) + ve[1].charAt(0) + ve[2].charAt(0) : ve.join("");
          }
          function o(_e, re, $, Ce, ve) {
            var Y = [
              We(c(_e).toString(16)),
              We(c(re).toString(16)),
              We(c($).toString(16)),
              We($e(Ce))
            ];
            return ve && Y[0].charAt(0) == Y[0].charAt(1) && Y[1].charAt(0) == Y[1].charAt(1) && Y[2].charAt(0) == Y[2].charAt(1) && Y[3].charAt(0) == Y[3].charAt(1) ? Y[0].charAt(0) + Y[1].charAt(0) + Y[2].charAt(0) + Y[3].charAt(0) : Y.join("");
          }
          function A(_e, re, $, Ce) {
            var ve = [
              We($e(Ce)),
              We(c(_e).toString(16)),
              We(c(re).toString(16)),
              We(c($).toString(16))
            ];
            return ve.join("");
          }
          n.equals = function(_e, re) {
            return !_e || !re ? !1 : n(_e).toRgbString() == n(re).toRgbString();
          }, n.random = function() {
            return n.fromRatio({
              r: a(),
              g: a(),
              b: a()
            });
          };
          function T(_e, re) {
            re = re === 0 ? 0 : re || 10;
            var $ = n(_e).toHsl();
            return $.s -= re / 100, $.s = Ee($.s), n($);
          }
          function I(_e, re) {
            re = re === 0 ? 0 : re || 10;
            var $ = n(_e).toHsl();
            return $.s += re / 100, $.s = Ee($.s), n($);
          }
          function L(_e) {
            return n(_e).desaturate(100);
          }
          function z(_e, re) {
            re = re === 0 ? 0 : re || 10;
            var $ = n(_e).toHsl();
            return $.l += re / 100, $.l = Ee($.l), n($);
          }
          function U(_e, re) {
            re = re === 0 ? 0 : re || 10;
            var $ = n(_e).toRgb();
            return $.r = l(0, u(255, $.r - c(255 * -(re / 100)))), $.g = l(0, u(255, $.g - c(255 * -(re / 100)))), $.b = l(0, u(255, $.b - c(255 * -(re / 100)))), n($);
          }
          function J(_e, re) {
            re = re === 0 ? 0 : re || 10;
            var $ = n(_e).toHsl();
            return $.l -= re / 100, $.l = Ee($.l), n($);
          }
          function F(_e, re) {
            var $ = n(_e).toHsl(), Ce = ($.h + re) % 360;
            return $.h = Ce < 0 ? 360 + Ce : Ce, n($);
          }
          function oe(_e) {
            var re = n(_e).toHsl();
            return re.h = (re.h + 180) % 360, n(re);
          }
          function ee(_e) {
            var re = n(_e).toHsl(), $ = re.h;
            return [
              n(_e),
              n({ h: ($ + 120) % 360, s: re.s, l: re.l }),
              n({ h: ($ + 240) % 360, s: re.s, l: re.l })
            ];
          }
          function ie(_e) {
            var re = n(_e).toHsl(), $ = re.h;
            return [
              n(_e),
              n({ h: ($ + 90) % 360, s: re.s, l: re.l }),
              n({ h: ($ + 180) % 360, s: re.s, l: re.l }),
              n({ h: ($ + 270) % 360, s: re.s, l: re.l })
            ];
          }
          function W(_e) {
            var re = n(_e).toHsl(), $ = re.h;
            return [
              n(_e),
              n({ h: ($ + 72) % 360, s: re.s, l: re.l }),
              n({ h: ($ + 216) % 360, s: re.s, l: re.l })
            ];
          }
          function Q(_e, re, $) {
            re = re || 6, $ = $ || 30;
            var Ce = n(_e).toHsl(), ve = 360 / $, Y = [n(_e)];
            for (Ce.h = (Ce.h - (ve * re >> 1) + 720) % 360; --re; )
              Ce.h = (Ce.h + ve) % 360, Y.push(n(Ce));
            return Y;
          }
          function de(_e, re) {
            re = re || 6;
            for (var $ = n(_e).toHsv(), Ce = $.h, ve = $.s, Y = $.v, G = [], Ae = 1 / re; re--; )
              G.push(n({ h: Ce, s: ve, v: Y })), Y = (Y + Ae) % 1;
            return G;
          }
          n.mix = function(_e, re, $) {
            $ = $ === 0 ? 0 : $ || 50;
            var Ce = n(_e).toRgb(), ve = n(re).toRgb(), Y = $ / 100, G = {
              r: (ve.r - Ce.r) * Y + Ce.r,
              g: (ve.g - Ce.g) * Y + Ce.g,
              b: (ve.b - Ce.b) * Y + Ce.b,
              a: (ve.a - Ce.a) * Y + Ce.a
            };
            return n(G);
          }, n.readability = function(_e, re) {
            var $ = n(_e), Ce = n(re);
            return (M.max($.getLuminance(), Ce.getLuminance()) + 0.05) / (M.min($.getLuminance(), Ce.getLuminance()) + 0.05);
          }, n.isReadable = function(_e, re, $) {
            var Ce = n.readability(_e, re), ve, Y;
            switch (Y = !1, ve = Ne($), ve.level + ve.size) {
              case "AAsmall":
              case "AAAlarge":
                Y = Ce >= 4.5;
                break;
              case "AAlarge":
                Y = Ce >= 3;
                break;
              case "AAAsmall":
                Y = Ce >= 7;
                break;
            }
            return Y;
          }, n.mostReadable = function(_e, re, $) {
            var Ce = null, ve = 0, Y, G, Ae, e;
            $ = $ || {}, G = $.includeFallbackColors, Ae = $.level, e = $.size;
            for (var r = 0; r < re.length; r++)
              Y = n.readability(_e, re[r]), Y > ve && (ve = Y, Ce = n(re[r]));
            return n.isReadable(_e, Ce, { level: Ae, size: e }) || !G ? Ce : ($.includeFallbackColors = !1, n.mostReadable(_e, ["#fff", "#000"], $));
          };
          var we = n.names = {
            aliceblue: "f0f8ff",
            antiquewhite: "faebd7",
            aqua: "0ff",
            aquamarine: "7fffd4",
            azure: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "000",
            blanchedalmond: "ffebcd",
            blue: "00f",
            blueviolet: "8a2be2",
            brown: "a52a2a",
            burlywood: "deb887",
            burntsienna: "ea7e5d",
            cadetblue: "5f9ea0",
            chartreuse: "7fff00",
            chocolate: "d2691e",
            coral: "ff7f50",
            cornflowerblue: "6495ed",
            cornsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "0ff",
            darkblue: "00008b",
            darkcyan: "008b8b",
            darkgoldenrod: "b8860b",
            darkgray: "a9a9a9",
            darkgreen: "006400",
            darkgrey: "a9a9a9",
            darkkhaki: "bdb76b",
            darkmagenta: "8b008b",
            darkolivegreen: "556b2f",
            darkorange: "ff8c00",
            darkorchid: "9932cc",
            darkred: "8b0000",
            darksalmon: "e9967a",
            darkseagreen: "8fbc8f",
            darkslateblue: "483d8b",
            darkslategray: "2f4f4f",
            darkslategrey: "2f4f4f",
            darkturquoise: "00ced1",
            darkviolet: "9400d3",
            deeppink: "ff1493",
            deepskyblue: "00bfff",
            dimgray: "696969",
            dimgrey: "696969",
            dodgerblue: "1e90ff",
            firebrick: "b22222",
            floralwhite: "fffaf0",
            forestgreen: "228b22",
            fuchsia: "f0f",
            gainsboro: "dcdcdc",
            ghostwhite: "f8f8ff",
            gold: "ffd700",
            goldenrod: "daa520",
            gray: "808080",
            green: "008000",
            greenyellow: "adff2f",
            grey: "808080",
            honeydew: "f0fff0",
            hotpink: "ff69b4",
            indianred: "cd5c5c",
            indigo: "4b0082",
            ivory: "fffff0",
            khaki: "f0e68c",
            lavender: "e6e6fa",
            lavenderblush: "fff0f5",
            lawngreen: "7cfc00",
            lemonchiffon: "fffacd",
            lightblue: "add8e6",
            lightcoral: "f08080",
            lightcyan: "e0ffff",
            lightgoldenrodyellow: "fafad2",
            lightgray: "d3d3d3",
            lightgreen: "90ee90",
            lightgrey: "d3d3d3",
            lightpink: "ffb6c1",
            lightsalmon: "ffa07a",
            lightseagreen: "20b2aa",
            lightskyblue: "87cefa",
            lightslategray: "789",
            lightslategrey: "789",
            lightsteelblue: "b0c4de",
            lightyellow: "ffffe0",
            lime: "0f0",
            limegreen: "32cd32",
            linen: "faf0e6",
            magenta: "f0f",
            maroon: "800000",
            mediumaquamarine: "66cdaa",
            mediumblue: "0000cd",
            mediumorchid: "ba55d3",
            mediumpurple: "9370db",
            mediumseagreen: "3cb371",
            mediumslateblue: "7b68ee",
            mediumspringgreen: "00fa9a",
            mediumturquoise: "48d1cc",
            mediumvioletred: "c71585",
            midnightblue: "191970",
            mintcream: "f5fffa",
            mistyrose: "ffe4e1",
            moccasin: "ffe4b5",
            navajowhite: "ffdead",
            navy: "000080",
            oldlace: "fdf5e6",
            olive: "808000",
            olivedrab: "6b8e23",
            orange: "ffa500",
            orangered: "ff4500",
            orchid: "da70d6",
            palegoldenrod: "eee8aa",
            palegreen: "98fb98",
            paleturquoise: "afeeee",
            palevioletred: "db7093",
            papayawhip: "ffefd5",
            peachpuff: "ffdab9",
            peru: "cd853f",
            pink: "ffc0cb",
            plum: "dda0dd",
            powderblue: "b0e0e6",
            purple: "800080",
            rebeccapurple: "663399",
            red: "f00",
            rosybrown: "bc8f8f",
            royalblue: "4169e1",
            saddlebrown: "8b4513",
            salmon: "fa8072",
            sandybrown: "f4a460",
            seagreen: "2e8b57",
            seashell: "fff5ee",
            sienna: "a0522d",
            silver: "c0c0c0",
            skyblue: "87ceeb",
            slateblue: "6a5acd",
            slategray: "708090",
            slategrey: "708090",
            snow: "fffafa",
            springgreen: "00ff7f",
            steelblue: "4682b4",
            tan: "d2b48c",
            teal: "008080",
            thistle: "d8bfd8",
            tomato: "ff6347",
            turquoise: "40e0d0",
            violet: "ee82ee",
            wheat: "f5deb3",
            white: "fff",
            whitesmoke: "f5f5f5",
            yellow: "ff0",
            yellowgreen: "9acd32"
          }, ke = n.hexNames = Me(we);
          function Me(_e) {
            var re = {};
            for (var $ in _e)
              _e.hasOwnProperty($) && (re[_e[$]] = $);
            return re;
          }
          function fe(_e) {
            return _e = parseFloat(_e), (isNaN(_e) || _e < 0 || _e > 1) && (_e = 1), _e;
          }
          function xe(_e, re) {
            Ue(_e) && (_e = "100%");
            var $ = He(_e);
            return _e = u(re, l(0, parseFloat(_e))), $ && (_e = parseInt(_e * re, 10) / 100), M.abs(_e - re) < 1e-6 ? 1 : _e % re / parseFloat(re);
          }
          function Ee(_e) {
            return u(1, l(0, _e));
          }
          function Pe(_e) {
            return parseInt(_e, 16);
          }
          function Ue(_e) {
            return typeof _e == "string" && _e.indexOf(".") != -1 && parseFloat(_e) === 1;
          }
          function He(_e) {
            return typeof _e == "string" && _e.indexOf("%") != -1;
          }
          function We(_e) {
            return _e.length == 1 ? "0" + _e : "" + _e;
          }
          function Ze(_e) {
            return _e <= 1 && (_e = _e * 100 + "%"), _e;
          }
          function $e(_e) {
            return M.round(parseFloat(_e) * 255).toString(16);
          }
          function Ve(_e) {
            return Pe(_e) / 255;
          }
          var Ge = function() {
            var _e = "[-\\+]?\\d+%?", re = "[-\\+]?\\d*\\.\\d+%?", $ = "(?:" + re + ")|(?:" + _e + ")", Ce = "[\\s|\\(]+(" + $ + ")[,|\\s]+(" + $ + ")[,|\\s]+(" + $ + ")\\s*\\)?", ve = "[\\s|\\(]+(" + $ + ")[,|\\s]+(" + $ + ")[,|\\s]+(" + $ + ")[,|\\s]+(" + $ + ")\\s*\\)?";
            return {
              CSS_UNIT: new RegExp($),
              rgb: new RegExp("rgb" + Ce),
              rgba: new RegExp("rgba" + ve),
              hsl: new RegExp("hsl" + Ce),
              hsla: new RegExp("hsla" + ve),
              hsv: new RegExp("hsv" + Ce),
              hsva: new RegExp("hsva" + ve),
              hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
              hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
            };
          }();
          function Ie(_e) {
            return !!Ge.CSS_UNIT.exec(_e);
          }
          function De(_e) {
            _e = _e.replace(x, "").replace(y, "").toLowerCase();
            var re = !1;
            if (we[_e])
              _e = we[_e], re = !0;
            else if (_e == "transparent")
              return { r: 0, g: 0, b: 0, a: 0, format: "name" };
            var $;
            return ($ = Ge.rgb.exec(_e)) ? { r: $[1], g: $[2], b: $[3] } : ($ = Ge.rgba.exec(_e)) ? { r: $[1], g: $[2], b: $[3], a: $[4] } : ($ = Ge.hsl.exec(_e)) ? { h: $[1], s: $[2], l: $[3] } : ($ = Ge.hsla.exec(_e)) ? { h: $[1], s: $[2], l: $[3], a: $[4] } : ($ = Ge.hsv.exec(_e)) ? { h: $[1], s: $[2], v: $[3] } : ($ = Ge.hsva.exec(_e)) ? { h: $[1], s: $[2], v: $[3], a: $[4] } : ($ = Ge.hex8.exec(_e)) ? {
              r: Pe($[1]),
              g: Pe($[2]),
              b: Pe($[3]),
              a: Ve($[4]),
              format: re ? "name" : "hex8"
            } : ($ = Ge.hex6.exec(_e)) ? {
              r: Pe($[1]),
              g: Pe($[2]),
              b: Pe($[3]),
              format: re ? "name" : "hex"
            } : ($ = Ge.hex4.exec(_e)) ? {
              r: Pe($[1] + "" + $[1]),
              g: Pe($[2] + "" + $[2]),
              b: Pe($[3] + "" + $[3]),
              a: Ve($[4] + "" + $[4]),
              format: re ? "name" : "hex8"
            } : ($ = Ge.hex3.exec(_e)) ? {
              r: Pe($[1] + "" + $[1]),
              g: Pe($[2] + "" + $[2]),
              b: Pe($[3] + "" + $[3]),
              format: re ? "name" : "hex"
            } : !1;
          }
          function Ne(_e) {
            var re, $;
            return _e = _e || { level: "AA", size: "small" }, re = (_e.level || "AA").toUpperCase(), $ = (_e.size || "small").toLowerCase(), re !== "AA" && re !== "AAA" && (re = "AA"), $ !== "small" && $ !== "large" && ($ = "small"), { level: re, size: $ };
          }
          typeof Z < "u" && Z.exports ? Z.exports = n : ae.tinycolor = n;
        })(Math);
      }, {}], 179: [function(k, Z, _) {
        _ = Z.exports = M;
        function M(x) {
          return x.replace(/^\s*|\s*$/g, "");
        }
        _.left = function(x) {
          return x.replace(/^\s*/, "");
        }, _.right = function(x) {
          return x.replace(/\s*$/, "");
        };
      }, {}], 180: [function(k, Z, _) {
        var M = k("punycode"), x = k("./util");
        _.parse = T, _.resolve = L, _.resolveObject = z, _.format = I, _.Url = y;
        function y() {
          this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
        }
        var E = /^([a-z0-9.+-]+:)/i, c = /:[0-9]*$/, u = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, l = ["<", ">", '"', "`", " ", "\r", `
`, "	"], a = ["{", "}", "|", "\\", "^", "`"].concat(l), n = ["'"].concat(a), d = ["%", "/", "?", ";", "#"].concat(n), g = ["/", "?", "#"], h = 255, m = /^[+a-z0-9A-Z_-]{0,63}$/, s = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, b = {
          javascript: !0,
          "javascript:": !0
        }, S = {
          javascript: !0,
          "javascript:": !0
        }, o = {
          http: !0,
          https: !0,
          ftp: !0,
          gopher: !0,
          file: !0,
          "http:": !0,
          "https:": !0,
          "ftp:": !0,
          "gopher:": !0,
          "file:": !0
        }, A = k("querystring");
        function T(U, J, F) {
          if (U && x.isObject(U) && U instanceof y) return U;
          var oe = new y();
          return oe.parse(U, J, F), oe;
        }
        y.prototype.parse = function(U, J, F) {
          if (!x.isString(U))
            throw new TypeError("Parameter 'url' must be a string, not " + typeof U);
          var oe = U.indexOf("?"), ee = oe !== -1 && oe < U.indexOf("#") ? "?" : "#", ie = U.split(ee), W = /\\/g;
          ie[0] = ie[0].replace(W, "/"), U = ie.join(ee);
          var Q = U;
          if (Q = Q.trim(), !F && U.split("#").length === 1) {
            var de = u.exec(Q);
            if (de)
              return this.path = Q, this.href = Q, this.pathname = de[1], de[2] ? (this.search = de[2], J ? this.query = A.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : J && (this.search = "", this.query = {}), this;
          }
          var we = E.exec(Q);
          if (we) {
            we = we[0];
            var ke = we.toLowerCase();
            this.protocol = ke, Q = Q.substr(we.length);
          }
          if (F || we || Q.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var Me = Q.substr(0, 2) === "//";
            Me && !(we && S[we]) && (Q = Q.substr(2), this.slashes = !0);
          }
          if (!S[we] && (Me || we && !o[we])) {
            for (var fe = -1, xe = 0; xe < g.length; xe++) {
              var Ee = Q.indexOf(g[xe]);
              Ee !== -1 && (fe === -1 || Ee < fe) && (fe = Ee);
            }
            var Pe, Ue;
            fe === -1 ? Ue = Q.lastIndexOf("@") : Ue = Q.lastIndexOf("@", fe), Ue !== -1 && (Pe = Q.slice(0, Ue), Q = Q.slice(Ue + 1), this.auth = decodeURIComponent(Pe)), fe = -1;
            for (var xe = 0; xe < d.length; xe++) {
              var Ee = Q.indexOf(d[xe]);
              Ee !== -1 && (fe === -1 || Ee < fe) && (fe = Ee);
            }
            fe === -1 && (fe = Q.length), this.host = Q.slice(0, fe), Q = Q.slice(fe), this.parseHost(), this.hostname = this.hostname || "";
            var He = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!He)
              for (var We = this.hostname.split(/\./), xe = 0, Ze = We.length; xe < Ze; xe++) {
                var $e = We[xe];
                if ($e && !$e.match(m)) {
                  for (var Ve = "", Ge = 0, Ie = $e.length; Ge < Ie; Ge++)
                    $e.charCodeAt(Ge) > 127 ? Ve += "x" : Ve += $e[Ge];
                  if (!Ve.match(m)) {
                    var De = We.slice(0, xe), Ne = We.slice(xe + 1), _e = $e.match(s);
                    _e && (De.push(_e[1]), Ne.unshift(_e[2])), Ne.length && (Q = "/" + Ne.join(".") + Q), this.hostname = De.join(".");
                    break;
                  }
                }
              }
            this.hostname.length > h ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), He || (this.hostname = M.toASCII(this.hostname));
            var re = this.port ? ":" + this.port : "", $ = this.hostname || "";
            this.host = $ + re, this.href += this.host, He && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), Q[0] !== "/" && (Q = "/" + Q));
          }
          if (!b[ke])
            for (var xe = 0, Ze = n.length; xe < Ze; xe++) {
              var Ce = n[xe];
              if (Q.indexOf(Ce) !== -1) {
                var ve = encodeURIComponent(Ce);
                ve === Ce && (ve = escape(Ce)), Q = Q.split(Ce).join(ve);
              }
            }
          var Y = Q.indexOf("#");
          Y !== -1 && (this.hash = Q.substr(Y), Q = Q.slice(0, Y));
          var G = Q.indexOf("?");
          if (G !== -1 ? (this.search = Q.substr(G), this.query = Q.substr(G + 1), J && (this.query = A.parse(this.query)), Q = Q.slice(0, G)) : J && (this.search = "", this.query = {}), Q && (this.pathname = Q), o[ke] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            var re = this.pathname || "", Ae = this.search || "";
            this.path = re + Ae;
          }
          return this.href = this.format(), this;
        };
        function I(U) {
          return x.isString(U) && (U = T(U)), U instanceof y ? U.format() : y.prototype.format.call(U);
        }
        y.prototype.format = function() {
          var U = this.auth || "";
          U && (U = encodeURIComponent(U), U = U.replace(/%3A/i, ":"), U += "@");
          var J = this.protocol || "", F = this.pathname || "", oe = this.hash || "", ee = !1, ie = "";
          this.host ? ee = U + this.host : this.hostname && (ee = U + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (ee += ":" + this.port)), this.query && x.isObject(this.query) && Object.keys(this.query).length && (ie = A.stringify(this.query));
          var W = this.search || ie && "?" + ie || "";
          return J && J.substr(-1) !== ":" && (J += ":"), this.slashes || (!J || o[J]) && ee !== !1 ? (ee = "//" + (ee || ""), F && F.charAt(0) !== "/" && (F = "/" + F)) : ee || (ee = ""), oe && oe.charAt(0) !== "#" && (oe = "#" + oe), W && W.charAt(0) !== "?" && (W = "?" + W), F = F.replace(/[?#]/g, function(Q) {
            return encodeURIComponent(Q);
          }), W = W.replace("#", "%23"), J + ee + F + W + oe;
        };
        function L(U, J) {
          return T(U, !1, !0).resolve(J);
        }
        y.prototype.resolve = function(U) {
          return this.resolveObject(T(U, !1, !0)).format();
        };
        function z(U, J) {
          return U ? T(U, !1, !0).resolveObject(J) : J;
        }
        y.prototype.resolveObject = function(U) {
          if (x.isString(U)) {
            var J = new y();
            J.parse(U, !1, !0), U = J;
          }
          for (var F = new y(), oe = Object.keys(this), ee = 0; ee < oe.length; ee++) {
            var ie = oe[ee];
            F[ie] = this[ie];
          }
          if (F.hash = U.hash, U.href === "")
            return F.href = F.format(), F;
          if (U.slashes && !U.protocol) {
            for (var W = Object.keys(U), Q = 0; Q < W.length; Q++) {
              var de = W[Q];
              de !== "protocol" && (F[de] = U[de]);
            }
            return o[F.protocol] && F.hostname && !F.pathname && (F.path = F.pathname = "/"), F.href = F.format(), F;
          }
          if (U.protocol && U.protocol !== F.protocol) {
            if (!o[U.protocol]) {
              for (var we = Object.keys(U), ke = 0; ke < we.length; ke++) {
                var Me = we[ke];
                F[Me] = U[Me];
              }
              return F.href = F.format(), F;
            }
            if (F.protocol = U.protocol, !U.host && !S[U.protocol]) {
              for (var Ze = (U.pathname || "").split("/"); Ze.length && !(U.host = Ze.shift()); ) ;
              U.host || (U.host = ""), U.hostname || (U.hostname = ""), Ze[0] !== "" && Ze.unshift(""), Ze.length < 2 && Ze.unshift(""), F.pathname = Ze.join("/");
            } else
              F.pathname = U.pathname;
            if (F.search = U.search, F.query = U.query, F.host = U.host || "", F.auth = U.auth, F.hostname = U.hostname || U.host, F.port = U.port, F.pathname || F.search) {
              var fe = F.pathname || "", xe = F.search || "";
              F.path = fe + xe;
            }
            return F.slashes = F.slashes || U.slashes, F.href = F.format(), F;
          }
          var Ee = F.pathname && F.pathname.charAt(0) === "/", Pe = U.host || U.pathname && U.pathname.charAt(0) === "/", Ue = Pe || Ee || F.host && U.pathname, He = Ue, We = F.pathname && F.pathname.split("/") || [], Ze = U.pathname && U.pathname.split("/") || [], $e = F.protocol && !o[F.protocol];
          if ($e && (F.hostname = "", F.port = null, F.host && (We[0] === "" ? We[0] = F.host : We.unshift(F.host)), F.host = "", U.protocol && (U.hostname = null, U.port = null, U.host && (Ze[0] === "" ? Ze[0] = U.host : Ze.unshift(U.host)), U.host = null), Ue = Ue && (Ze[0] === "" || We[0] === "")), Pe)
            F.host = U.host || U.host === "" ? U.host : F.host, F.hostname = U.hostname || U.hostname === "" ? U.hostname : F.hostname, F.search = U.search, F.query = U.query, We = Ze;
          else if (Ze.length)
            We || (We = []), We.pop(), We = We.concat(Ze), F.search = U.search, F.query = U.query;
          else if (!x.isNullOrUndefined(U.search)) {
            if ($e) {
              F.hostname = F.host = We.shift();
              var Ve = F.host && F.host.indexOf("@") > 0 ? F.host.split("@") : !1;
              Ve && (F.auth = Ve.shift(), F.host = F.hostname = Ve.shift());
            }
            return F.search = U.search, F.query = U.query, (!x.isNull(F.pathname) || !x.isNull(F.search)) && (F.path = (F.pathname ? F.pathname : "") + (F.search ? F.search : "")), F.href = F.format(), F;
          }
          if (!We.length)
            return F.pathname = null, F.search ? F.path = "/" + F.search : F.path = null, F.href = F.format(), F;
          for (var Ge = We.slice(-1)[0], Ie = (F.host || U.host || We.length > 1) && (Ge === "." || Ge === "..") || Ge === "", De = 0, Ne = We.length; Ne >= 0; Ne--)
            Ge = We[Ne], Ge === "." ? We.splice(Ne, 1) : Ge === ".." ? (We.splice(Ne, 1), De++) : De && (We.splice(Ne, 1), De--);
          if (!Ue && !He)
            for (; De--; De)
              We.unshift("..");
          Ue && We[0] !== "" && (!We[0] || We[0].charAt(0) !== "/") && We.unshift(""), Ie && We.join("/").substr(-1) !== "/" && We.push("");
          var _e = We[0] === "" || We[0] && We[0].charAt(0) === "/";
          if ($e) {
            F.hostname = F.host = _e ? "" : We.length ? We.shift() : "";
            var Ve = F.host && F.host.indexOf("@") > 0 ? F.host.split("@") : !1;
            Ve && (F.auth = Ve.shift(), F.host = F.hostname = Ve.shift());
          }
          return Ue = Ue || F.host && We.length, Ue && !_e && We.unshift(""), We.length ? F.pathname = We.join("/") : (F.pathname = null, F.path = null), (!x.isNull(F.pathname) || !x.isNull(F.search)) && (F.path = (F.pathname ? F.pathname : "") + (F.search ? F.search : "")), F.auth = U.auth || F.auth, F.slashes = F.slashes || U.slashes, F.href = F.format(), F;
        }, y.prototype.parseHost = function() {
          var U = this.host, J = c.exec(U);
          J && (J = J[0], J !== ":" && (this.port = J.substr(1)), U = U.substr(0, U.length - J.length)), U && (this.hostname = U);
        };
      }, { "./util": 181, punycode: 134, querystring: 137 }], 181: [function(k, Z, _) {
        Z.exports = {
          isString: function(M) {
            return typeof M == "string";
          },
          isObject: function(M) {
            return typeof M == "object" && M !== null;
          },
          isNull: function(M) {
            return M === null;
          },
          isNullOrUndefined: function(M) {
            return M == null;
          }
        };
      }, {}], 182: [function(k, Z, _) {
        (function(M) {
          (function() {
            var x = {};
            typeof Z == "object" ? Z.exports = x : self.UTIF = x;
            var y;
            typeof k == "function" ? y = k("pako") : y = self.pako;
            function E() {
              (typeof M > "u" || M.env.NODE_ENV == "development") && console.log.apply(console, arguments);
            }
            (function(c, u) {
              (function() {
                var l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
                  return typeof d;
                } : function(d) {
                  return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
                }, a = function() {
                  function d(g) {
                    this.message = "JPEG error: " + g;
                  }
                  return d.prototype = Error(), d.prototype.name = "JpegError", d.constructor = d;
                }(), n = function() {
                  function d(g, h) {
                    this.message = g, this.g = h;
                  }
                  return d.prototype = Error(), d.prototype.name = "DNLMarkerError", d.constructor = d;
                }();
                (function() {
                  function d() {
                    this.M = null, this.B = -1;
                  }
                  function g(S, o) {
                    for (var A = 0, T = [], I, L, z = 16; 0 < z && !S[z - 1]; ) z--;
                    T.push({ children: [], index: 0 });
                    var U = T[0], J;
                    for (I = 0; I < z; I++) {
                      for (L = 0; L < S[I]; L++) {
                        for (U = T.pop(), U.children[U.index] = o[A]; 0 < U.index; ) U = T.pop();
                        for (U.index++, T.push(U); T.length <= I; ) T.push(J = { children: [], index: 0 }), U.children[U.index] = J.children, U = J;
                        A++;
                      }
                      I + 1 < z && (T.push(J = { children: [], index: 0 }), U.children[U.index] = J.children, U = J);
                    }
                    return T[0].children;
                  }
                  function h(S, o, A, T, I, L, z, U, J) {
                    function F() {
                      if (0 < Pe) return Pe--, Ee >> Pe & 1;
                      if (Ee = S[o++], Ee === 255) {
                        var Y = S[o++];
                        if (Y) {
                          if (Y === 220 && Me) {
                            o += 2;
                            var G = S[o++] << 8 | S[o++];
                            if (0 < G && G !== A.g) throw new n("Found DNL marker (0xFFDC) while parsing scan data", G);
                          }
                          throw new a("unexpected marker " + (Ee << 8 | Y).toString(16));
                        }
                      }
                      return Pe = 7, Ee >>> 7;
                    }
                    function oe(Y) {
                      for (; ; ) {
                        if (Y = Y[F()], typeof Y == "number") return Y;
                        if ((typeof Y > "u" ? "undefined" : l(Y)) !== "object") throw new a("invalid huffman sequence");
                      }
                    }
                    function ee(Y) {
                      for (var G = 0; 0 < Y; ) G = G << 1 | F(), Y--;
                      return G;
                    }
                    function ie(Y) {
                      if (Y === 1) return F() === 1 ? 1 : -1;
                      var G = ee(Y);
                      return G >= 1 << Y - 1 ? G : G + (-1 << Y) + 1;
                    }
                    function W(Y, G) {
                      var Ae = oe(Y.D);
                      for (Ae = Ae === 0 ? 0 : ie(Ae), Y.a[G] = Y.m += Ae, Ae = 1; 64 > Ae; ) {
                        var e = oe(Y.o), r = e & 15;
                        if (e >>= 4, r === 0) {
                          if (15 > e) break;
                          Ae += 16;
                        } else Ae += e, Y.a[G + b[Ae]] = ie(r), Ae++;
                      }
                    }
                    function Q(Y, G) {
                      var Ae = oe(Y.D);
                      Ae = Ae === 0 ? 0 : ie(Ae) << J, Y.a[G] = Y.m += Ae;
                    }
                    function de(Y, G) {
                      Y.a[G] |= F() << J;
                    }
                    function we(Y, G) {
                      if (0 < Ue) Ue--;
                      else for (var Ae = L; Ae <= z; ) {
                        var e = oe(Y.o), r = e & 15;
                        if (e >>= 4, r === 0) {
                          if (15 > e) {
                            Ue = ee(e) + (1 << e) - 1;
                            break;
                          }
                          Ae += 16;
                        } else Ae += e, Y.a[G + b[Ae]] = ie(r) * (1 << J), Ae++;
                      }
                    }
                    function ke(Y, G) {
                      for (var Ae = L, e = 0, r; Ae <= z; ) {
                        r = G + b[Ae];
                        var f = 0 > Y.a[r] ? -1 : 1;
                        switch (He) {
                          case 0:
                            if (e = oe(Y.o), r = e & 15, e >>= 4, r === 0) 15 > e ? (Ue = ee(e) + (1 << e), He = 4) : (e = 16, He = 1);
                            else {
                              if (r !== 1) throw new a("invalid ACn encoding");
                              We = ie(r), He = e ? 2 : 3;
                            }
                            continue;
                          case 1:
                          case 2:
                            Y.a[r] ? Y.a[r] += f * (F() << J) : (e--, e === 0 && (He = He === 2 ? 3 : 0));
                            break;
                          case 3:
                            Y.a[r] ? Y.a[r] += f * (F() << J) : (Y.a[r] = We << J, He = 0);
                            break;
                          case 4:
                            Y.a[r] && (Y.a[r] += f * (F() << J));
                        }
                        Ae++;
                      }
                      He === 4 && (Ue--, Ue === 0 && (He = 0));
                    }
                    for (var Me = 9 < arguments.length && arguments[9] !== void 0 ? arguments[9] : !1, fe = A.P, xe = o, Ee = 0, Pe = 0, Ue = 0, He = 0, We, Ze = T.length, $e, Ve, Ge, Ie, De = A.S ? L === 0 ? U === 0 ? Q : de : U === 0 ? we : ke : W, Ne = 0, _e = Ze === 1 ? T[0].c * T[0].l : fe * A.O, re, $; Ne < _e; ) {
                      var Ce = I ? Math.min(_e - Ne, I) : _e;
                      for ($e = 0; $e < Ze; $e++) T[$e].m = 0;
                      if (Ue = 0, Ze === 1) {
                        var ve = T[0];
                        for (Ie = 0; Ie < Ce; Ie++) De(ve, 64 * ((ve.c + 1) * (Ne / ve.c | 0) + Ne % ve.c)), Ne++;
                      } else for (Ie = 0; Ie < Ce; Ie++) {
                        for ($e = 0; $e < Ze; $e++) for (ve = T[$e], re = ve.h, $ = ve.j, Ve = 0; Ve < $; Ve++) for (Ge = 0; Ge < re; Ge++) De(ve, 64 * ((ve.c + 1) * ((Ne / fe | 0) * ve.j + Ve) + (Ne % fe * ve.h + Ge)));
                        Ne++;
                      }
                      if (Pe = 0, (ve = s(S, o)) && ve.f && ((0, _util.warn)("decodeScan - unexpected MCU data, current marker is: " + ve.f), o = ve.offset), ve = ve && ve.F, !ve || 65280 >= ve) throw new a("marker was not found");
                      if (65488 <= ve && 65495 >= ve) o += 2;
                      else break;
                    }
                    return (ve = s(S, o)) && ve.f && ((0, _util.warn)("decodeScan - unexpected Scan data, current marker is: " + ve.f), o = ve.offset), o - xe;
                  }
                  function m(S, o) {
                    for (var A = o.c, T = o.l, I = new Int16Array(64), L = 0; L < T; L++) for (var z = 0; z < A; z++) {
                      var U = 64 * ((o.c + 1) * L + z), J = I, F = o.G, oe = o.a;
                      if (!F) throw new a("missing required Quantization Table.");
                      for (var ee = 0; 64 > ee; ee += 8) {
                        var ie = oe[U + ee], W = oe[U + ee + 1], Q = oe[U + ee + 2], de = oe[U + ee + 3], we = oe[U + ee + 4], ke = oe[U + ee + 5], Me = oe[U + ee + 6], fe = oe[U + ee + 7];
                        if (ie *= F[ee], (W | Q | de | we | ke | Me | fe) === 0) ie = 5793 * ie + 512 >> 10, J[ee] = ie, J[ee + 1] = ie, J[ee + 2] = ie, J[ee + 3] = ie, J[ee + 4] = ie, J[ee + 5] = ie, J[ee + 6] = ie, J[ee + 7] = ie;
                        else {
                          W *= F[ee + 1], Q *= F[ee + 2], de *= F[ee + 3], we *= F[ee + 4], ke *= F[ee + 5], Me *= F[ee + 6], fe *= F[ee + 7];
                          var xe = 5793 * ie + 128 >> 8, Ee = 5793 * we + 128 >> 8, Pe = Q, Ue = Me;
                          we = 2896 * (W - fe) + 128 >> 8, fe = 2896 * (W + fe) + 128 >> 8, de <<= 4, ke <<= 4, xe = xe + Ee + 1 >> 1, Ee = xe - Ee, ie = 3784 * Pe + 1567 * Ue + 128 >> 8, Pe = 1567 * Pe - 3784 * Ue + 128 >> 8, Ue = ie, we = we + ke + 1 >> 1, ke = we - ke, fe = fe + de + 1 >> 1, de = fe - de, xe = xe + Ue + 1 >> 1, Ue = xe - Ue, Ee = Ee + Pe + 1 >> 1, Pe = Ee - Pe, ie = 2276 * we + 3406 * fe + 2048 >> 12, we = 3406 * we - 2276 * fe + 2048 >> 12, fe = ie, ie = 799 * de + 4017 * ke + 2048 >> 12, de = 4017 * de - 799 * ke + 2048 >> 12, ke = ie, J[ee] = xe + fe, J[ee + 7] = xe - fe, J[ee + 1] = Ee + ke, J[ee + 6] = Ee - ke, J[ee + 2] = Pe + de, J[ee + 5] = Pe - de, J[ee + 3] = Ue + we, J[ee + 4] = Ue - we;
                        }
                      }
                      for (F = 0; 8 > F; ++F) ie = J[F], W = J[F + 8], Q = J[F + 16], de = J[F + 24], we = J[F + 32], ke = J[F + 40], Me = J[F + 48], fe = J[F + 56], (W | Q | de | we | ke | Me | fe) === 0 ? (ie = 5793 * ie + 8192 >> 14, ie = -2040 > ie ? 0 : 2024 <= ie ? 255 : ie + 2056 >> 4, oe[U + F] = ie, oe[U + F + 8] = ie, oe[U + F + 16] = ie, oe[U + F + 24] = ie, oe[U + F + 32] = ie, oe[U + F + 40] = ie, oe[U + F + 48] = ie, oe[U + F + 56] = ie) : (xe = 5793 * ie + 2048 >> 12, Ee = 5793 * we + 2048 >> 12, Pe = Q, Ue = Me, we = 2896 * (W - fe) + 2048 >> 12, fe = 2896 * (W + fe) + 2048 >> 12, xe = (xe + Ee + 1 >> 1) + 4112, Ee = xe - Ee, ie = 3784 * Pe + 1567 * Ue + 2048 >> 12, Pe = 1567 * Pe - 3784 * Ue + 2048 >> 12, Ue = ie, we = we + ke + 1 >> 1, ke = we - ke, fe = fe + de + 1 >> 1, de = fe - de, xe = xe + Ue + 1 >> 1, Ue = xe - Ue, Ee = Ee + Pe + 1 >> 1, Pe = Ee - Pe, ie = 2276 * we + 3406 * fe + 2048 >> 12, we = 3406 * we - 2276 * fe + 2048 >> 12, fe = ie, ie = 799 * de + 4017 * ke + 2048 >> 12, de = 4017 * de - 799 * ke + 2048 >> 12, ke = ie, ie = xe + fe, fe = xe - fe, W = Ee + ke, Me = Ee - ke, Q = Pe + de, ke = Pe - de, de = Ue + we, we = Ue - we, ie = 16 > ie ? 0 : 4080 <= ie ? 255 : ie >> 4, W = 16 > W ? 0 : 4080 <= W ? 255 : W >> 4, Q = 16 > Q ? 0 : 4080 <= Q ? 255 : Q >> 4, de = 16 > de ? 0 : 4080 <= de ? 255 : de >> 4, we = 16 > we ? 0 : 4080 <= we ? 255 : we >> 4, ke = 16 > ke ? 0 : 4080 <= ke ? 255 : ke >> 4, Me = 16 > Me ? 0 : 4080 <= Me ? 255 : Me >> 4, fe = 16 > fe ? 0 : 4080 <= fe ? 255 : fe >> 4, oe[U + F] = ie, oe[U + F + 8] = W, oe[U + F + 16] = Q, oe[U + F + 24] = de, oe[U + F + 32] = we, oe[U + F + 40] = ke, oe[U + F + 48] = Me, oe[U + F + 56] = fe);
                    }
                    return o.a;
                  }
                  function s(S, o) {
                    var A = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : o, T = S.length - 1;
                    if (A = A < o ? A : o, o >= T) return null;
                    var I = S[o] << 8 | S[o + 1];
                    if (65472 <= I && 65534 >= I) return { f: null, F: I, offset: o };
                    for (var L = S[A] << 8 | S[A + 1]; !(65472 <= L && 65534 >= L); ) {
                      if (++A >= T) return null;
                      L = S[A] << 8 | S[A + 1];
                    }
                    return { f: I.toString(16), F: L, offset: A };
                  }
                  var b = new Uint8Array([
                    0,
                    1,
                    8,
                    16,
                    9,
                    2,
                    3,
                    10,
                    17,
                    24,
                    32,
                    25,
                    18,
                    11,
                    4,
                    5,
                    12,
                    19,
                    26,
                    33,
                    40,
                    48,
                    41,
                    34,
                    27,
                    20,
                    13,
                    6,
                    7,
                    14,
                    21,
                    28,
                    35,
                    42,
                    49,
                    56,
                    57,
                    50,
                    43,
                    36,
                    29,
                    22,
                    15,
                    23,
                    30,
                    37,
                    44,
                    51,
                    58,
                    59,
                    52,
                    45,
                    38,
                    31,
                    39,
                    46,
                    53,
                    60,
                    61,
                    54,
                    47,
                    55,
                    62,
                    63
                  ]);
                  d.prototype = { parse: function(S) {
                    function o() {
                      var Pe = S[z] << 8 | S[z + 1];
                      return z += 2, Pe;
                    }
                    function A() {
                      var Pe = o();
                      Pe = z + Pe - 2;
                      var Ue = s(S, Pe, z);
                      return Ue && Ue.f && ((0, _util.warn)("readDataBlock - incorrect length, current marker is: " + Ue.f), Pe = Ue.offset), Pe = S.subarray(z, Pe), z += Pe.length, Pe;
                    }
                    function T(Pe) {
                      for (var Ue = Math.ceil(Pe.v / 8 / Pe.s), He = Math.ceil(Pe.g / 8 / Pe.u), We = 0; We < Pe.b.length; We++) {
                        xe = Pe.b[We];
                        var Ze = Math.ceil(Math.ceil(Pe.v / 8) * xe.h / Pe.s), $e = Math.ceil(Math.ceil(Pe.g / 8) * xe.j / Pe.u);
                        xe.a = new Int16Array(64 * He * xe.j * (Ue * xe.h + 1)), xe.c = Ze, xe.l = $e;
                      }
                      Pe.P = Ue, Pe.O = He;
                    }
                    var I = (1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}).N, L = I === void 0 ? null : I, z = 0, U = null, J = 0;
                    I = [];
                    var F = [], oe = [], ee = o();
                    if (ee !== 65496) throw new a("SOI not found");
                    for (ee = o(); ee !== 65497; ) {
                      switch (ee) {
                        case 65504:
                        case 65505:
                        case 65506:
                        case 65507:
                        case 65508:
                        case 65509:
                        case 65510:
                        case 65511:
                        case 65512:
                        case 65513:
                        case 65514:
                        case 65515:
                        case 65516:
                        case 65517:
                        case 65518:
                        case 65519:
                        case 65534:
                          var ie = A();
                          ee === 65518 && ie[0] === 65 && ie[1] === 100 && ie[2] === 111 && ie[3] === 98 && ie[4] === 101 && (U = { version: ie[5] << 8 | ie[6], Y: ie[7] << 8 | ie[8], Z: ie[9] << 8 | ie[10], W: ie[11] });
                          break;
                        case 65499:
                          ee = o() + z - 2;
                          for (var W; z < ee; ) {
                            var Q = S[z++], de = new Uint16Array(64);
                            if (Q >> 4 === 0) for (ie = 0; 64 > ie; ie++) W = b[ie], de[W] = S[z++];
                            else if (Q >> 4 === 1) for (ie = 0; 64 > ie; ie++) W = b[ie], de[W] = o();
                            else throw new a("DQT - invalid table spec");
                            I[Q & 15] = de;
                          }
                          break;
                        case 65472:
                        case 65473:
                        case 65474:
                          if (we) throw new a("Only single frame JPEGs supported");
                          o();
                          var we = {};
                          for (we.X = ee === 65473, we.S = ee === 65474, we.precision = S[z++], ee = o(), we.g = L || ee, we.v = o(), we.b = [], we.C = {}, ie = S[z++], ee = de = Q = 0; ee < ie; ee++) {
                            W = S[z];
                            var ke = S[z + 1] >> 4, Me = S[z + 1] & 15;
                            Q < ke && (Q = ke), de < Me && (de = Me), ke = we.b.push({ h: ke, j: Me, T: S[z + 2], G: null }), we.C[W] = ke - 1, z += 3;
                          }
                          we.s = Q, we.u = de, T(we);
                          break;
                        case 65476:
                          for (W = o(), ee = 2; ee < W; ) {
                            for (Q = S[z++], de = new Uint8Array(16), ie = ke = 0; 16 > ie; ie++, z++) ke += de[ie] = S[z];
                            for (Me = new Uint8Array(ke), ie = 0; ie < ke; ie++, z++) Me[ie] = S[z];
                            ee += 17 + ke, (Q >> 4 === 0 ? oe : F)[Q & 15] = g(de, Me);
                          }
                          break;
                        case 65501:
                          o();
                          var fe = o();
                          break;
                        case 65498:
                          for (ie = ++J === 1 && !L, o(), Q = S[z++], W = [], ee = 0; ee < Q; ee++) {
                            de = we.C[S[z++]];
                            var xe = we.b[de];
                            de = S[z++], xe.D = oe[de >> 4], xe.o = F[de & 15], W.push(xe);
                          }
                          ee = S[z++], Q = S[z++], de = S[z++];
                          try {
                            var Ee = h(S, z, we, W, fe, ee, Q, de >> 4, de & 15, ie);
                            z += Ee;
                          } catch (Pe) {
                            if (Pe instanceof n) return (0, _util.warn)('Attempting to re-parse JPEG image using "scanLines" parameter found in DNL marker (0xFFDC) segment.'), this.parse(S, { N: Pe.g });
                            throw Pe;
                          }
                          break;
                        case 65500:
                          z += 4;
                          break;
                        case 65535:
                          S[z] !== 255 && z--;
                          break;
                        default:
                          if (S[z - 3] === 255 && 192 <= S[z - 2] && 254 >= S[z - 2]) z -= 3;
                          else if ((ie = s(S, z - 2)) && ie.f) (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + ie.f), z = ie.offset;
                          else throw new a("unknown marker " + ee.toString(16));
                      }
                      ee = o();
                    }
                    for (this.width = we.v, this.height = we.g, this.A = U, this.b = [], ee = 0; ee < we.b.length; ee++)
                      xe = we.b[ee], (fe = I[xe.T]) && (xe.G = fe), this.b.push({ R: m(we, xe), U: xe.h / we.s, V: xe.j / we.u, c: xe.c, l: xe.l });
                    this.i = this.b.length;
                  }, L: function(S, o) {
                    var A = this.width / S, T = this.height / o, I, L, z = this.b.length, U = S * o * z, J = new Uint8ClampedArray(U), F = new Uint32Array(S);
                    for (L = 0; L < z; L++) {
                      var oe = this.b[L], ee = oe.U * A, ie = oe.V * T, W = L, Q = oe.R, de = oe.c + 1 << 3;
                      for (I = 0; I < S; I++) oe = 0 | I * ee, F[I] = (oe & 4294967288) << 3 | oe & 7;
                      for (ee = 0; ee < o; ee++) for (oe = 0 | ee * ie, oe = de * (oe & 4294967288) | (oe & 7) << 3, I = 0; I < S; I++) J[W] = Q[oe + F[I]], W += z;
                    }
                    if (T = this.M) for (L = 0; L < U; ) for (A = oe = 0; oe < z; oe++, L++, A += 2) J[L] = (J[L] * T[A] >> 8) + T[A + 1];
                    return J;
                  }, w: function() {
                    return this.A ? !!this.A.W : this.i === 3 ? this.B !== 0 : this.B === 1;
                  }, I: function(S) {
                    for (var o, A, T, I = 0, L = S.length; I < L; I += 3) o = S[I], A = S[I + 1], T = S[I + 2], S[I] = o - 179.456 + 1.402 * T, S[I + 1] = o + 135.459 - 0.344 * A - 0.714 * T, S[I + 2] = o - 226.816 + 1.772 * A;
                    return S;
                  }, K: function(S) {
                    for (var o, A, T, I, L = 0, z = 0, U = S.length; z < U; z += 4) o = S[z], A = S[z + 1], T = S[z + 2], I = S[z + 3], S[L++] = -122.67195406894 + A * (-660635669420364e-19 * A + 437130475926232e-18 * T - 54080610064599e-18 * o + 48449797120281e-17 * I - 0.154362151871126) + T * (-957964378445773e-18 * T + 817076911346625e-18 * o - 0.00477271405408747 * I + 1.53380253221734) + o * (961250184130688e-18 * o - 0.00266257332283933 * I + 0.48357088451265) + I * (-336197177618394e-18 * I + 0.484791561490776), S[L++] = 107.268039397724 + A * (219927104525741e-19 * A - 640992018297945e-18 * T + 659397001245577e-18 * o + 426105652938837e-18 * I - 0.176491792462875) + T * (-778269941513683e-18 * T + 0.00130872261408275 * o + 770482631801132e-18 * I - 0.151051492775562) + o * (0.00126935368114843 * o - 0.00265090189010898 * I + 0.25802910206845) + I * (-318913117588328e-18 * I - 0.213742400323665), S[L++] = -20.810012546947 + A * (-570115196973677e-18 * A - 263409051004589e-19 * T + 0.0020741088115012 * o - 0.00288260236853442 * I + 0.814272968359295) + T * (-153496057440975e-19 * T - 132689043961446e-18 * o + 560833691242812e-18 * I - 0.195152027534049) + o * (0.00174418132927582 * o - 0.00255243321439347 * I + 0.116935020465145) + I * (-343531996510555e-18 * I + 0.24165260232407);
                    return S.subarray(
                      0,
                      L
                    );
                  }, J: function(S) {
                    for (var o, A, T, I = 0, L = S.length; I < L; I += 4) o = S[I], A = S[I + 1], T = S[I + 2], S[I] = 434.456 - o - 1.402 * T, S[I + 1] = 119.541 - o + 0.344 * A + 0.714 * T, S[I + 2] = 481.816 - o - 1.772 * A;
                    return S;
                  }, H: function(S) {
                    for (var o, A, T, I, L = 0, z = 1 / 255, U = 0, J = S.length; U < J; U += 4) o = S[U] * z, A = S[U + 1] * z, T = S[U + 2] * z, I = S[U + 3] * z, S[L++] = 255 + o * (-4.387332384609988 * o + 54.48615194189176 * A + 18.82290502165302 * T + 212.25662451639585 * I - 285.2331026137004) + A * (1.7149763477362134 * A - 5.6096736904047315 * T - 17.873870861415444 * I - 5.497006427196366) + T * (-2.5217340131683033 * T - 21.248923337353073 * I + 17.5119270841813) - I * (21.86122147463605 * I + 189.48180835922747), S[L++] = 255 + o * (8.841041422036149 * o + 60.118027045597366 * A + 6.871425592049007 * T + 31.159100130055922 * I - 79.2970844816548) + A * (-15.310361306967817 * A + 17.575251261109482 * T + 131.35250912493976 * I - 190.9453302588951) + T * (4.444339102852739 * T + 9.8632861493405 * I - 24.86741582555878) - I * (20.737325471181034 * I + 187.80453709719578), S[L++] = 255 + o * (0.8842522430003296 * o + 8.078677503112928 * A + 30.89978309703729 * T - 0.23883238689178934 * I - 14.183576799673286) + A * (10.49593273432072 * A + 63.02378494754052 * T + 50.606957656360734 * I - 112.23884253719248) + T * (0.03296041114873217 * T + 115.60384449646641 * I - 193.58209356861505) - I * (22.33816807309886 * I + 180.12613974708367);
                    return S.subarray(0, L);
                  }, getData: function(S, o, A) {
                    if (4 < this.i) throw new a("Unsupported color mode");
                    if (S = this.L(S, o), this.i === 1 && A) {
                      A = S.length, o = new Uint8ClampedArray(3 * A);
                      for (var T = 0, I = 0; I < A; I++) {
                        var L = S[I];
                        o[T++] = L, o[T++] = L, o[T++] = L;
                      }
                      return o;
                    }
                    if (this.i === 3 && this.w()) return this.I(S);
                    if (this.i === 4) {
                      if (this.w()) return A ? this.K(S) : this.J(S);
                      if (A) return this.H(S);
                    }
                    return S;
                  } }, c.JpegDecoder = d;
                })();
              })(), c.encodeImage = function(l, a, n, d) {
                var g = {
                  t256: [a],
                  t257: [n],
                  t258: [8, 8, 8, 8],
                  t259: [1],
                  t262: [2],
                  t273: [1e3],
                  // strips offset
                  t277: [4],
                  t278: [n],
                  /* rows per strip */
                  t279: [a * n * 4],
                  // strip byte counts
                  t282: [1],
                  t283: [1],
                  t284: [1],
                  t286: [0],
                  t287: [0],
                  t296: [1],
                  t305: ["Photopea (UTIF.js)"],
                  t338: [1]
                };
                if (d) for (var h in d) g[h] = d[h];
                for (var m = new Uint8Array(c.encode([g])), s = new Uint8Array(l), b = new Uint8Array(1e3 + a * n * 4), h = 0; h < m.length; h++) b[h] = m[h];
                for (var h = 0; h < s.length; h++) b[1e3 + h] = s[h];
                return b.buffer;
              }, c.encode = function(l) {
                var a = new Uint8Array(2e4), n = 4, d = c._binBE;
                a[0] = 77, a[1] = 77, a[3] = 42;
                var g = 8;
                d.writeUint(a, n, g), n += 4;
                for (var h = 0; h < l.length; h++) {
                  var m = c._writeIFD(d, a, g, l[h]);
                  g = m[1], h < l.length - 1 && d.writeUint(a, m[0], g);
                }
                return a.slice(0, g).buffer;
              }, c.decode = function(l) {
                c.decode._decodeG3.allow2D = null;
                var a = new Uint8Array(l), n = 0, d = c._binBE.readASCII(a, n, 2);
                n += 2;
                var g = d == "II" ? c._binLE : c._binBE;
                g.readUshort(a, n), n += 2;
                var h = g.readUint(a, n);
                n += 4;
                for (var m = []; ; ) {
                  var s = c._readIFD(g, a, h, m);
                  if (h = g.readUint(a, s), h == 0) break;
                }
                return m;
              }, c.decodeImages = function(l, a) {
                for (var n = new Uint8Array(l), d = c._binBE.readASCII(n, 0, 2), g = 0; g < a.length; g++) {
                  var h = a[g];
                  if (h.t256 != null) {
                    h.isLE = d == "II", h.width = h.t256[0], h.height = h.t257[0];
                    var m = h.t259 ? h.t259[0] : 1, s = h.t266 ? h.t266[0] : 1;
                    h.t284 && h.t284[0] == 2 && E("PlanarConfiguration 2 should not be used!");
                    var b = (h.t258 ? Math.min(32, h.t258[0]) : 1) * (h.t277 ? h.t277[0] : 1), S = Math.ceil(h.width * b / 8) * 8, o = h.t273;
                    o == null && (o = h.t324);
                    var A = h.t279;
                    m == 1 && o.length == 1 && (A = [h.height * (S >>> 3)]), A == null && (A = h.t325);
                    var T = new Uint8Array(h.height * (S >>> 3)), I = 0;
                    if (h.t322 != null) {
                      for (var L = h.t322[0], z = h.t323[0], U = Math.floor((h.width + L - 1) / L), J = Math.floor((h.height + z - 1) / z), F = new Uint8Array(Math.ceil(L * z * b / 8) | 0), oe = 0; oe < J; oe++)
                        for (var ee = 0; ee < U; ee++) {
                          for (var ie = oe * U + ee, W = 0; W < F.length; W++) F[W] = 0;
                          c.decode._decompress(h, n, o[ie], A[ie], m, F, 0, s), m == 6 ? T = F : c._copyTile(F, Math.ceil(L * b / 8) | 0, z, T, Math.ceil(h.width * b / 8) | 0, h.height, Math.ceil(ee * L * b / 8) | 0, oe * z);
                        }
                      I = T.length * 8;
                    } else {
                      var Q = h.t278 ? h.t278[0] : h.height;
                      Q = Math.min(Q, h.height);
                      for (var ie = 0; ie < o.length; ie++)
                        c.decode._decompress(h, n, o[ie], A[ie], m, T, Math.ceil(I / 8) | 0, s), I += S * Q;
                      I = Math.min(I, T.length * 8);
                    }
                    h.data = new Uint8Array(T.buffer, 0, Math.ceil(I / 8) | 0);
                  }
                }
              }, c.decode._decompress = function(l, a, n, d, g, h, m, s) {
                if (g == 1) for (var b = 0; b < d; b++) h[m + b] = a[n + b];
                else if (g == 3) c.decode._decodeG3(a, n, d, h, m, l.width, s);
                else if (g == 4) c.decode._decodeG4(a, n, d, h, m, l.width, s);
                else if (g == 5) c.decode._decodeLZW(a, n, h, m);
                else if (g == 6) c.decode._decodeOldJPEG(l, a, n, d, h, m);
                else if (g == 7) c.decode._decodeNewJPEG(l, a, n, d, h, m);
                else if (g == 8)
                  for (var S = new Uint8Array(a.buffer, n, d), o = u.inflate(S), A = 0; A < o.length; A++) h[m + A] = o[A];
                else g == 32773 ? c.decode._decodePackBits(a, n, d, h, m) : g == 32809 ? c.decode._decodeThunder(a, n, d, h, m) : E("Unknown compression", g);
                if (l.t317 && l.t317[0] == 2)
                  for (var T = l.t277 ? l.t277[0] : 1, I = l.t278 ? l.t278[0] : l.height, L = l.width * T, z = 0; z < I; z++) {
                    var U = m + z * L;
                    if (T == 3) for (var b = 3; b < L; b += 3)
                      h[U + b] = h[U + b] + h[U + b - 3] & 255, h[U + b + 1] = h[U + b + 1] + h[U + b - 2] & 255, h[U + b + 2] = h[U + b + 2] + h[U + b - 1] & 255;
                    else for (var b = T; b < L; b++) h[U + b] = h[U + b] + h[U + b - T] & 255;
                  }
              }, c.decode._decodeNikon = function(l, a, s, d, g) {
                var h, m, s;
                E(l.slice(a, a + 100)), h = l[a], a++, m = l[a], a++, E(h.toString(16), m.toString(16), s);
              }, c.decode._decodeNewJPEG = function(l, a, n, d, g, h) {
                var m = l.t347, s = m ? m.length : 0, b = new Uint8Array(s + d);
                if (m) {
                  for (var S = 216, o = 217, A = 0, T = 0; T < s - 1 && !(m[T] == 255 && m[T + 1] == o); T++)
                    b[A++] = m[T];
                  var I = a[n], L = a[n + 1];
                  (I != 255 || L != S) && (b[A++] = I, b[A++] = L);
                  for (var T = 2; T < d; T++) b[A++] = a[n + T];
                } else for (var T = 0; T < d; T++) b[T] = a[n + T];
                if (l.t262 == 32803) {
                  var z = l.t258[0], U = new LosslessJpegDecoder(), J = U.decode(b), F = J.length;
                  if (z == 16) for (var T = 0; T < F; T++)
                    g[h++] = J[T] & 255, g[h++] = J[T] >>> 8;
                  else if (z == 12) for (var T = 0; T < F; T += 2)
                    g[h++] = J[T] >>> 4, g[h++] = (J[T] << 4 | J[T + 1] >>> 8) & 255, g[h++] = J[T + 1] & 255;
                  else throw new Error("unsupported bit depth " + z);
                } else {
                  var oe = new c.JpegDecoder();
                  oe.parse(b);
                  for (var ee = oe.getData(oe.width, oe.height), T = 0; T < ee.length; T++) g[h + T] = ee[T];
                }
                l.t262[0] == 6 && (l.t262[0] = 2);
              }, c.decode._decodeOldJPEGInit = function(l, a, n, d) {
                var g = 216, h = 219, m = 196, s = 221, b = 192, S = 218, o = 0, A = 0, T, I, L = !1, z, U, J, F = l.t513, oe = F ? F[0] : 0, ee = l.t514, ie = ee ? ee[0] : 0, W = l.t324 || l.t273 || F, Q = l.t530, de = 0, we = 0, ke = l.t277 ? l.t277[0] : 1, Me = l.t515;
                if (W && (A = W[0], L = W.length > 1), !L) {
                  if (a[n] == 255 && a[n + 1] == g) return { jpegOffset: n };
                  if (F != null && (a[n + oe] == 255 && a[n + oe + 1] == g ? o = n + oe : E("JPEGInterchangeFormat does not point to SOI"), ee == null ? E("JPEGInterchangeFormatLength field is missing") : (oe >= A || oe + ie <= A) && E("JPEGInterchangeFormatLength field value is invalid"), o != null))
                    return { jpegOffset: o };
                }
                if (Q != null && (de = Q[0], we = Q[1]), F != null && ee != null)
                  if (ie >= 2 && oe + ie <= A) {
                    for (a[n + oe + ie - 2] == 255 && a[n + oe + ie - 1] == g ? T = new Uint8Array(ie - 2) : T = new Uint8Array(ie), z = 0; z < T.length; z++) T[z] = a[n + oe + z];
                    E("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
                  } else E("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
                if (T == null) {
                  var fe = 0, xe = [];
                  xe[fe++] = 255, xe[fe++] = g;
                  var Ee = l.t519;
                  if (Ee == null) throw new Error("JPEGQTables tag is missing");
                  for (z = 0; z < Ee.length; z++)
                    for (xe[fe++] = 255, xe[fe++] = h, xe[fe++] = 0, xe[fe++] = 67, xe[fe++] = z, U = 0; U < 64; U++) xe[fe++] = a[n + Ee[z] + U];
                  for (J = 0; J < 2; J++) {
                    var Pe = l[J == 0 ? "t520" : "t521"];
                    if (Pe == null) throw new Error((J == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
                    for (z = 0; z < Pe.length; z++) {
                      xe[fe++] = 255, xe[fe++] = m;
                      var Ue = 19;
                      for (U = 0; U < 16; U++) Ue += a[n + Pe[z] + U];
                      for (xe[fe++] = Ue >>> 8, xe[fe++] = Ue & 255, xe[fe++] = z | J << 4, U = 0; U < 16; U++) xe[fe++] = a[n + Pe[z] + U];
                      for (U = 0; U < Ue; U++) xe[fe++] = a[n + Pe[z] + 16 + U];
                    }
                  }
                  if (xe[fe++] = 255, xe[fe++] = b, xe[fe++] = 0, xe[fe++] = 8 + 3 * ke, xe[fe++] = 8, xe[fe++] = l.height >>> 8 & 255, xe[fe++] = l.height & 255, xe[fe++] = l.width >>> 8 & 255, xe[fe++] = l.width & 255, xe[fe++] = ke, ke == 1)
                    xe[fe++] = 1, xe[fe++] = 17, xe[fe++] = 0;
                  else for (z = 0; z < 3; z++)
                    xe[fe++] = z + 1, xe[fe++] = z != 0 ? 17 : (de & 15) << 4 | we & 15, xe[fe++] = z;
                  Me != null && Me[0] != 0 && (xe[fe++] = 255, xe[fe++] = s, xe[fe++] = 0, xe[fe++] = 4, xe[fe++] = Me[0] >>> 8 & 255, xe[fe++] = Me[0] & 255), T = new Uint8Array(xe);
                }
                var He = -1;
                for (z = 0; z < T.length - 1; ) {
                  if (T[z] == 255 && T[z + 1] == b) {
                    He = z;
                    break;
                  }
                  z++;
                }
                if (He == -1) {
                  var We = new Uint8Array(T.length + 10 + 3 * ke);
                  We.set(T);
                  var Ze = T.length;
                  if (He = T.length, T = We, T[Ze++] = 255, T[Ze++] = b, T[Ze++] = 0, T[Ze++] = 8 + 3 * ke, T[Ze++] = 8, T[Ze++] = l.height >>> 8 & 255, T[Ze++] = l.height & 255, T[Ze++] = l.width >>> 8 & 255, T[Ze++] = l.width & 255, T[Ze++] = ke, ke == 1)
                    T[Ze++] = 1, T[Ze++] = 17, T[Ze++] = 0;
                  else for (z = 0; z < 3; z++)
                    T[Ze++] = z + 1, T[Ze++] = z != 0 ? 17 : (de & 15) << 4 | we & 15, T[Ze++] = z;
                }
                if (a[A] == 255 && a[A + 1] == S) {
                  var $e = a[A + 2] << 8 | a[A + 3];
                  for (I = new Uint8Array($e + 2), I[0] = a[A], I[1] = a[A + 1], I[2] = a[A + 2], I[3] = a[A + 3], z = 0; z < $e - 2; z++) I[z + 4] = a[A + z + 4];
                } else {
                  I = new Uint8Array(8 + 2 * ke);
                  var Ve = 0;
                  if (I[Ve++] = 255, I[Ve++] = S, I[Ve++] = 0, I[Ve++] = 6 + 2 * ke, I[Ve++] = ke, ke == 1)
                    I[Ve++] = 1, I[Ve++] = 0;
                  else for (z = 0; z < 3; z++)
                    I[Ve++] = z + 1, I[Ve++] = z << 4 | z;
                  I[Ve++] = 0, I[Ve++] = 63, I[Ve++] = 0;
                }
                return { jpegOffset: n, tables: T, sosMarker: I, sofPosition: He };
              }, c.decode._decodeOldJPEG = function(l, a, n, d, g, h) {
                var m, s, b, S, o = c.decode._decodeOldJPEGInit(l, a, n, d);
                if (o.jpegOffset != null)
                  for (s = n + d - o.jpegOffset, S = new Uint8Array(s), m = 0; m < s; m++) S[m] = a[o.jpegOffset + m];
                else {
                  for (b = o.tables.length, S = new Uint8Array(b + o.sosMarker.length + d + 2), S.set(o.tables), S[o.sofPosition + 5] = l.height >>> 8 & 255, S[o.sofPosition + 6] = l.height & 255, S[o.sofPosition + 7] = l.width >>> 8 & 255, S[o.sofPosition + 8] = l.width & 255, (a[n] != 255 || a[n + 1] != SOS) && (S.set(o.sosMarker, bufoff), bufoff += sosMarker.length), m = 0; m < d; m++) S[bufoff++] = a[n + m];
                  S[bufoff++] = 255, S[bufoff++] = EOI;
                }
                var A = new c.JpegDecoder();
                A.parse(S);
                for (var T = A.getData(A.width, A.height), m = 0; m < T.length; m++) g[h + m] = T[m];
                l.t262[0] == 6 && (l.t262[0] = 2);
              }, c.decode._decodePackBits = function(l, a, n, d, g) {
                for (var h = new Int8Array(l.buffer), m = new Int8Array(d.buffer), s = a + n; a < s; ) {
                  var b = h[a];
                  if (a++, b >= 0 && b < 128) for (var S = 0; S < b + 1; S++)
                    m[g] = h[a], g++, a++;
                  if (b >= -127 && b < 0) {
                    for (var S = 0; S < -b + 1; S++)
                      m[g] = h[a], g++;
                    a++;
                  }
                }
              }, c.decode._decodeThunder = function(l, a, n, d, g) {
                for (var h = [0, 1, 0, -1], m = [0, 1, 2, 3, 0, -3, -2, -1], s = a + n, b = g * 2, S = 0; a < s; ) {
                  var o = l[a], A = o >>> 6, T = o & 63;
                  if (a++, A == 3 && (S = T & 15, d[b >>> 1] |= S << 4 * (1 - b & 1), b++), A == 0) for (var I = 0; I < T; I++)
                    d[b >>> 1] |= S << 4 * (1 - b & 1), b++;
                  if (A == 2) for (var I = 0; I < 2; I++) {
                    var L = T >>> 3 * (1 - I) & 7;
                    L != 4 && (S += m[L], d[b >>> 1] |= S << 4 * (1 - b & 1), b++);
                  }
                  if (A == 1) for (var I = 0; I < 3; I++) {
                    var L = T >>> 2 * (2 - I) & 3;
                    L != 2 && (S += h[L], d[b >>> 1] |= S << 4 * (1 - b & 1), b++);
                  }
                }
              }, c.decode._dmap = { 1: 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 }, c.decode._lens = function() {
                var l = function(b, S, o, A) {
                  for (var T = 0; T < S.length; T++) b[S[T]] = o + T * A;
                }, a = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", n = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", d = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", g = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", h = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
                a = a.split(","), n = n.split(","), d = d.split(","), g = g.split(","), h = h.split(",");
                var m = {}, s = {};
                return l(m, a, 0, 1), l(m, d, 64, 64), l(m, h, 1792, 64), l(s, n, 0, 1), l(s, g, 64, 64), l(s, h, 1792, 64), [m, s];
              }(), c.decode._decodeG4 = function(l, a, n, d, g, h, m) {
                for (var s = c.decode, b = a << 3, S = 0, o = "", A = [], T = [], I = 0; I < h; I++) T.push(0);
                T = s._makeDiff(T);
                for (var L = 0, z = 0, U = 0, J = 0, F = 0, oe = 0, ee = "", ie = 0, W = Math.ceil(h / 8) * 8; b >>> 3 < a + n; ) {
                  U = s._findDiff(T, L + (L == 0 ? 0 : 1), 1 - F), J = s._findDiff(T, U, F);
                  var Q = 0;
                  if (m == 1 && (Q = l[b >>> 3] >>> 7 - (b & 7) & 1), m == 2 && (Q = l[b >>> 3] >>> (b & 7) & 1), b++, o += Q, ee == "H") {
                    if (s._lens[F][o] != null) {
                      var de = s._lens[F][o];
                      o = "", S += de, de < 64 && (s._addNtimes(A, S, F), L += S, F = 1 - F, S = 0, ie--, ie == 0 && (ee = ""));
                    }
                  } else
                    o == "0001" && (o = "", s._addNtimes(A, J - L, F), L = J), o == "001" && (o = "", ee = "H", ie = 2), s._dmap[o] != null && (z = U + s._dmap[o], s._addNtimes(A, z - L, F), L = z, o = "", F = 1 - F);
                  A.length == h && ee == "" && (s._writeBits(A, d, g * 8 + oe * W), F = 0, oe++, L = 0, T = s._makeDiff(A), A = []);
                }
              }, c.decode._findDiff = function(l, a, n) {
                for (var d = 0; d < l.length; d += 2) if (l[d] >= a && l[d + 1] == n) return l[d];
              }, c.decode._makeDiff = function(l) {
                var a = [];
                l[0] == 1 && a.push(0, 1);
                for (var n = 1; n < l.length; n++) l[n - 1] != l[n] && a.push(n, l[n]);
                return a.push(l.length, 0, l.length, 1), a;
              }, c.decode._decodeG3 = function(l, a, n, d, g, h, m) {
                for (var s = c.decode, b = a << 3, S = 0, o = "", A = [], T = [], I = 0; I < h; I++) A.push(0);
                for (var L = 0, z = 0, U = 0, J = 0, F = 0, oe = -1, ee = "", ie = 0, W = !1, Q = Math.ceil(h / 8) * 8; b >>> 3 < a + n; ) {
                  U = s._findDiff(T, L + (L == 0 ? 0 : 1), 1 - F), J = s._findDiff(T, U, F);
                  var de = 0;
                  if (m == 1 && (de = l[b >>> 3] >>> 7 - (b & 7) & 1), m == 2 && (de = l[b >>> 3] >>> (b & 7) & 1), b++, o += de, W) {
                    if (s._lens[F][o] != null) {
                      var we = s._lens[F][o];
                      o = "", S += we, we < 64 && (s._addNtimes(A, S, F), F = 1 - F, S = 0);
                    }
                  } else if (ee == "H") {
                    if (s._lens[F][o] != null) {
                      var we = s._lens[F][o];
                      o = "", S += we, we < 64 && (s._addNtimes(A, S, F), L += S, F = 1 - F, S = 0, ie--, ie == 0 && (ee = ""));
                    }
                  } else
                    o == "0001" && (o = "", s._addNtimes(A, J - L, F), L = J), o == "001" && (o = "", ee = "H", ie = 2), s._dmap[o] != null && (z = U + s._dmap[o], s._addNtimes(A, z - L, F), L = z, o = "", F = 1 - F);
                  o.endsWith("000000000001") && (oe >= 0 && s._writeBits(A, d, g * 8 + oe * Q), m == 1 && (W = (l[b >>> 3] >>> 7 - (b & 7) & 1) == 1), m == 2 && (W = (l[b >>> 3] >>> (b & 7) & 1) == 1), b++, s._decodeG3.allow2D == null && (s._decodeG3.allow2D = W), s._decodeG3.allow2D || (W = !0, b--), o = "", F = 0, oe++, L = 0, T = s._makeDiff(A), A = []);
                }
                A.length == h && s._writeBits(A, d, g * 8 + oe * Q);
              }, c.decode._addNtimes = function(l, a, n) {
                for (var d = 0; d < a; d++) l.push(n);
              }, c.decode._writeBits = function(l, a, n) {
                for (var d = 0; d < l.length; d++) a[n + d >>> 3] |= l[d] << 7 - (n + d & 7);
              }, c.decode._decodeLZW = function(l, a, n, d) {
                if (c.decode._lzwTab == null) {
                  for (var g = new Uint32Array(65535), h = new Uint16Array(65535), o = new Uint8Array(2e6), m = 0; m < 256; m++)
                    o[m << 2] = m, g[m] = m << 2, h[m] = 1;
                  c.decode._lzwTab = [g, h, o];
                }
                for (var s = c.decode._copyData, b = c.decode._lzwTab[0], S = c.decode._lzwTab[1], o = c.decode._lzwTab[2], A = 258, T = 1032, I = 9, L = a << 3, z = 256, U = 257, J = 0, F = 0, oe = 0; J = l[L >>> 3] << 16 | l[L + 8 >>> 3] << 8 | l[L + 16 >>> 3], F = J >> 24 - (L & 7) - I & (1 << I) - 1, L += I, F != U; ) {
                  if (F == z) {
                    if (I = 9, A = 258, T = 1032, J = l[L >>> 3] << 16 | l[L + 8 >>> 3] << 8 | l[L + 16 >>> 3], F = J >> 24 - (L & 7) - I & (1 << I) - 1, L += I, F == U) break;
                    n[d] = F, d++;
                  } else if (F < A) {
                    var ee = b[F], ie = S[F];
                    if (s(o, ee, n, d, ie), d += ie, oe >= A)
                      b[A] = T, o[b[A]] = ee[0], S[A] = 1, T = T + 1 + 3 & -4, A++;
                    else {
                      b[A] = T;
                      var W = b[oe], Q = S[oe];
                      s(o, W, o, T, Q), o[T + Q] = o[ee], Q++, S[A] = Q, A++, T = T + Q + 3 & -4;
                    }
                    A + 1 == 1 << I && I++;
                  } else {
                    if (oe >= A)
                      b[A] = T, S[A] = 0, A++;
                    else {
                      b[A] = T;
                      var W = b[oe], Q = S[oe];
                      s(o, W, o, T, Q), o[T + Q] = o[T], Q++, S[A] = Q, A++, s(o, T, n, d, Q), d += Q, T = T + Q + 3 & -4;
                    }
                    A + 1 == 1 << I && I++;
                  }
                  oe = F;
                }
              }, c.decode._copyData = function(l, a, n, d, g) {
                for (var h = 0; h < g; h += 4)
                  n[d + h] = l[a + h], n[d + h + 1] = l[a + h + 1], n[d + h + 2] = l[a + h + 2], n[d + h + 3] = l[a + h + 3];
              }, c.tags = {
                254: "NewSubfileType",
                255: "SubfileType",
                256: "ImageWidth",
                257: "ImageLength",
                258: "BitsPerSample",
                259: "Compression",
                262: "PhotometricInterpretation",
                266: "FillOrder",
                269: "DocumentName",
                270: "ImageDescription",
                271: "Make",
                272: "Model",
                273: "StripOffset",
                274: "Orientation",
                277: "SamplesPerPixel",
                278: "RowsPerStrip",
                279: "StripByteCounts",
                280: "MinSampleValue",
                281: "MaxSampleValue",
                282: "XResolution",
                283: "YResolution",
                284: "PlanarConfiguration",
                285: "PageName",
                286: "XPosition",
                287: "YPosition",
                292: "T4Options",
                296: "ResolutionUnit",
                297: "PageNumber",
                305: "Software",
                306: "DateTime",
                315: "Artist",
                316: "HostComputer",
                317: "Predictor",
                318: "WhitePoint",
                319: "PrimaryChromaticities",
                320: "ColorMap",
                321: "HalftoneHints",
                322: "TileWidth",
                323: "TileLength",
                324: "TileOffset",
                325: "TileByteCounts",
                330: "SubIFDs",
                336: "DotRange",
                338: "ExtraSample",
                339: "SampleFormat",
                347: "JPEGTables",
                512: "JPEGProc",
                513: "JPEGInterchangeFormat",
                514: "JPEGInterchangeFormatLength",
                519: "JPEGQTables",
                520: "JPEGDCTables",
                521: "JPEGACTables",
                529: "YCbCrCoefficients",
                530: "YCbCrSubSampling",
                531: "YCbCrPositioning",
                532: "ReferenceBlackWhite",
                700: "XMP",
                33421: "CFARepeatPatternDim",
                33422: "CFAPattern",
                33432: "Copyright",
                33434: "ExposureTime",
                33437: "FNumber",
                33723: "IPTC/NAA",
                34377: "Photoshop",
                34665: "ExifIFD",
                34675: "ICC Profile",
                34850: "ExposureProgram",
                34853: "GPSInfo",
                34855: "ISOSpeedRatings",
                34858: "TimeZoneOffset",
                34859: "SelfTimeMode",
                36867: "DateTimeOriginal",
                36868: "DateTimeDigitized",
                37377: "ShutterSpeedValue",
                37378: "ApertureValue",
                37380: "ExposureBiasValue",
                37383: "MeteringMode",
                37385: "Flash",
                37386: "FocalLength",
                37390: "FocalPlaneXResolution",
                37391: "FocalPlaneYResolution",
                37392: "FocalPlaneResolutionUnit",
                37393: "ImageNumber",
                37398: "TIFF/EPStandardID",
                37399: "SensingMethod",
                37500: "MakerNote",
                37510: "UserComment",
                37724: "ImageSourceData",
                40092: "XPComment",
                40094: "XPKeywords",
                40961: "ColorSpace",
                40962: "PixelXDimension",
                40963: "PixelXDimension",
                41486: "FocalPlaneXResolution",
                41487: "FocalPlaneYResolution",
                41488: "FocalPlaneResolutionUnit",
                41985: "CustomRendered",
                41986: "ExposureMode",
                41987: "WhiteBalance",
                41990: "SceneCaptureType",
                50706: "DNGVersion",
                50707: "DNGBackwardVersion",
                50708: "UniqueCameraModel",
                50709: "LocalizedCameraModel",
                50710: "CFAPlaneColor",
                50711: "CFALayout",
                50712: "LinearizationTable",
                50713: "BlackLevelRepeatDim",
                50714: "BlackLevel",
                50716: "BlackLevelDeltaV",
                50717: "WhiteLevel",
                50718: "DefaultScale",
                50719: "DefaultCropOrigin",
                50720: "DefaultCropSize",
                50733: "BayerGreenSplit",
                50738: "AntiAliasStrength",
                50721: "ColorMatrix1",
                50722: "ColorMatrix2",
                50723: "CameraCalibration1",
                50724: "CameraCalibration2",
                50727: "AnalogBalance",
                50728: "AsShotNeutral",
                50730: "BaselineExposure",
                50731: "BaselineNoise",
                50732: "BaselineSharpness",
                50734: "LinearResponseLimit",
                50735: "CameraSerialNumber",
                50736: "LensInfo",
                50739: "ShadowScale",
                50740: "DNGPrivateData",
                50741: "MakerNoteSafety",
                50778: "CalibrationIlluminant1",
                50779: "CalibrationIlluminant2",
                50780: "BestQualityScale",
                50781: "RawDataUniqueID",
                50827: "OriginalRawFileName",
                50829: "ActiveArea",
                50830: "MaskedAreas",
                50931: "CameraCalibrationSignature",
                50932: "ProfileCalibrationSignature",
                50935: "NoiseReductionApplied",
                50936: "ProfileName",
                50937: "ProfileHueSatMapDims",
                50938: "ProfileHueSatMapData1",
                50939: "ProfileHueSatMapData2",
                50940: "ProfileToneCurve",
                50941: "ProfileEmbedPolicy",
                50942: "ProfileCopyright",
                50964: "ForwardMatrix1",
                50965: "ForwardMatrix2",
                50966: "PreviewApplicationName",
                50967: "PreviewApplicationVersion",
                50969: "PreviewSettingsDigest",
                50970: "PreviewColorSpace",
                50971: "PreviewDateTime",
                50972: "RawImageDigest",
                51008: "OpcodeList1",
                51009: "OpcodeList2",
                51022: "OpcodeList3",
                51041: "NoiseProfile",
                51089: "OriginalDefaultFinalSize",
                51090: "OriginalBestQualityFinalSize",
                51091: "OriginalDefaultCropSize",
                51125: "DefaultUserCrop"
              }, c.ttypes = { 256: 3, 257: 3, 258: 3, 259: 3, 262: 3, 273: 4, 274: 3, 277: 3, 278: 4, 279: 4, 282: 5, 283: 5, 284: 3, 286: 5, 287: 5, 296: 3, 305: 2, 306: 2, 338: 3, 513: 4, 514: 4, 34665: 4 }, c._readIFD = function(l, a, n, d) {
                var g = l.readUshort(a, n);
                n += 2;
                var h = {};
                d.push(h);
                for (var m = 0; m < g; m++) {
                  var s = l.readUshort(a, n);
                  n += 2;
                  var b = l.readUshort(a, n);
                  n += 2;
                  var S = l.readUint(a, n);
                  n += 4;
                  var o = l.readUint(a, n);
                  n += 4;
                  var A = [];
                  if (h["t" + s] = A, b == 1 || b == 7)
                    for (var T = 0; T < S; T++) A.push(a[(S < 5 ? n - 4 : o) + T]);
                  if (b == 2 && A.push(l.readASCII(a, S < 5 ? n - 4 : o, S - 1)), b == 3)
                    for (var T = 0; T < S; T++) A.push(l.readUshort(a, (S < 3 ? n - 4 : o) + 2 * T));
                  if (b == 4)
                    for (var T = 0; T < S; T++) A.push(l.readUint(a, (S < 2 ? n - 4 : o) + 4 * T));
                  if (b == 5)
                    for (var T = 0; T < S; T++) A.push(l.readUint(a, o + T * 8) / l.readUint(a, o + T * 8 + 4));
                  if (b == 8)
                    for (var T = 0; T < S; T++) A.push(l.readShort(a, (S < 3 ? n - 4 : o) + 2 * T));
                  if (b == 9)
                    for (var T = 0; T < S; T++) A.push(l.readInt(a, (S < 2 ? n - 4 : o) + 4 * T));
                  if (b == 10)
                    for (var T = 0; T < S; T++) A.push(l.readInt(a, o + T * 8) / l.readInt(a, o + T * 8 + 4));
                  if (b == 11)
                    for (var T = 0; T < S; T++) A.push(l.readFloat(a, o + T * 4));
                  if (b == 12)
                    for (var T = 0; T < S; T++) A.push(l.readDouble(a, o + T * 8));
                  if (S != 0 && A.length == 0 && E("unknown TIFF tag type: ", b, "num:", S), s == 330) for (var T = 0; T < S; T++) c._readIFD(l, a, A[T], d);
                }
                return n;
              }, c._writeIFD = function(l, a, n, d) {
                var g = Object.keys(d);
                l.writeUshort(a, n, g.length), n += 2;
                for (var h = n + g.length * 12 + 4, m = 0; m < g.length; m++) {
                  var s = g[m], b = parseInt(s.slice(1)), S = c.ttypes[b];
                  if (S == null) throw new Error("unknown type of tag: " + b);
                  var o = d[s];
                  S == 2 && (o = o[0] + "\0");
                  var A = o.length;
                  l.writeUshort(a, n, b), n += 2, l.writeUshort(a, n, S), n += 2, l.writeUint(a, n, A), n += 4;
                  var T = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][S] * A, I = n;
                  if (T > 4 && (l.writeUint(a, n, h), I = h), S == 2 && l.writeASCII(a, I, o), S == 3)
                    for (var L = 0; L < A; L++) l.writeUshort(a, I + 2 * L, o[L]);
                  if (S == 4)
                    for (var L = 0; L < A; L++) l.writeUint(a, I + 4 * L, o[L]);
                  if (S == 5)
                    for (var L = 0; L < A; L++)
                      l.writeUint(a, I + 8 * L, Math.round(o[L] * 1e4)), l.writeUint(a, I + 8 * L + 4, 1e4);
                  if (S == 12)
                    for (var L = 0; L < A; L++) l.writeDouble(a, I + 8 * L, o[L]);
                  T > 4 && (T += T & 1, h += T), n += 4;
                }
                return [n, h];
              }, c.toRGBA8 = function(l) {
                var a = l.width, n = l.height, d = a * n, g = d * 4, h = l.data, m = new Uint8Array(d * 4), s = l.t262[0], b = l.t258 ? Math.min(32, l.t258[0]) : 1, S = l.isLE ? 1 : 0;
                if (s == 0)
                  for (var o = Math.ceil(b * a / 8), A = 0; A < n; A++) {
                    var T = A * o, I = A * a;
                    if (b == 1) for (var L = 0; L < a; L++) {
                      var z = I + L << 2, U = h[T + (L >> 3)] >> 7 - (L & 7) & 1;
                      m[z] = m[z + 1] = m[z + 2] = (1 - U) * 255, m[z + 3] = 255;
                    }
                    if (b == 4) for (var L = 0; L < a; L++) {
                      var z = I + L << 2, U = h[T + (L >> 1)] >> 4 - 4 * (L & 1) & 15;
                      m[z] = m[z + 1] = m[z + 2] = (15 - U) * 17, m[z + 3] = 255;
                    }
                    if (b == 8) for (var L = 0; L < a; L++) {
                      var z = I + L << 2, U = h[T + L];
                      m[z] = m[z + 1] = m[z + 2] = 255 - U, m[z + 3] = 255;
                    }
                  }
                else if (s == 1)
                  for (var o = Math.ceil(b * a / 8), A = 0; A < n; A++) {
                    var T = A * o, I = A * a;
                    if (b == 1) for (var L = 0; L < a; L++) {
                      var z = I + L << 2, U = h[T + (L >> 3)] >> 7 - (L & 7) & 1;
                      m[z] = m[z + 1] = m[z + 2] = U * 255, m[z + 3] = 255;
                    }
                    if (b == 2) for (var L = 0; L < a; L++) {
                      var z = I + L << 2, U = h[T + (L >> 2)] >> 6 - 2 * (L & 3) & 3;
                      m[z] = m[z + 1] = m[z + 2] = U * 85, m[z + 3] = 255;
                    }
                    if (b == 8) for (var L = 0; L < a; L++) {
                      var z = I + L << 2, U = h[T + L];
                      m[z] = m[z + 1] = m[z + 2] = U, m[z + 3] = 255;
                    }
                    if (b == 16) for (var L = 0; L < a; L++) {
                      var z = I + L << 2, U = h[T + (2 * L + S)];
                      m[z] = m[z + 1] = m[z + 2] = Math.min(255, U), m[z + 3] = 255;
                    }
                  }
                else if (s == 2)
                  if (b == 8)
                    if (l.t338)
                      if (l.t338[0] > 0) for (var L = 0; L < g; L++) m[L] = h[L];
                      else for (var L = 0; L < g; L += 4)
                        m[L] = h[L], m[L + 1] = h[L + 1], m[L + 2] = h[L + 2], m[L + 3] = 255;
                    else {
                      var J = l.t258 ? l.t258.length : 3;
                      if (J == 4) for (var L = 0; L < g; L++) m[L] = h[L];
                      if (J == 3) for (var L = 0; L < d; L++) {
                        var z = L << 2, F = L * 3;
                        m[z] = h[F], m[z + 1] = h[F + 1], m[z + 2] = h[F + 2], m[z + 3] = 255;
                      }
                    }
                  else
                    for (var L = 0; L < d; L++) {
                      var z = L << 2, F = L * 6;
                      m[z] = h[F], m[z + 1] = h[F + 2], m[z + 2] = h[F + 4], m[z + 3] = 255;
                    }
                else if (s == 3)
                  for (var oe = l.t320, L = 0; L < d; L++) {
                    var z = L << 2, ee = h[L];
                    m[z] = oe[ee] >> 8, m[z + 1] = oe[256 + ee] >> 8, m[z + 2] = oe[512 + ee] >> 8, m[z + 3] = 255;
                  }
                else if (s == 5)
                  for (var J = l.t258 ? l.t258.length : 4, ie = J > 4 ? 1 : 0, L = 0; L < d; L++) {
                    var z = L << 2, W = L * J, Q = 255 - h[W], de = 255 - h[W + 1], we = 255 - h[W + 2], ke = (255 - h[W + 3]) * (1 / 255);
                    m[z] = ~~(Q * ke + 0.5), m[z + 1] = ~~(de * ke + 0.5), m[z + 2] = ~~(we * ke + 0.5), m[z + 3] = 255 * (1 - ie) + h[W + 4] * ie;
                  }
                else E("Unknown Photometric interpretation: " + s);
                return m;
              }, c.replaceIMG = function() {
                for (var l = document.getElementsByTagName("img"), a = 0; a < l.length; a++) {
                  var n = l[a], d = n.getAttribute("src");
                  if (d != null) {
                    var g = d.split(".").pop().toLowerCase();
                    if (!(g != "tif" && g != "tiff")) {
                      var h = new XMLHttpRequest();
                      c._xhrs.push(h), c._imgs.push(n), h.open("GET", d), h.responseType = "arraybuffer", h.onload = c._imgLoaded, h.send();
                    }
                  }
                }
              }, c._xhrs = [], c._imgs = [], c._imgLoaded = function(l) {
                var a = l.target.response, n = c.decode(a), d = n[0];
                c.decodeImages(a, n);
                var g = c.toRGBA8(d), h = d.width, m = d.height, s = c._xhrs.indexOf(l.target), b = c._imgs[s];
                c._xhrs.splice(s, 1), c._imgs.splice(s, 1);
                var S = document.createElement("canvas");
                S.width = h, S.height = m;
                for (var o = S.getContext("2d"), A = o.createImageData(h, m), T = 0; T < g.length; T++) A.data[T] = g[T];
                o.putImageData(A, 0, 0);
                for (var I = ["style", "class", "id"], T = 0; T < I.length; T++) S.setAttribute(I[T], b.getAttribute(I[T]));
                b.parentNode.replaceChild(S, b);
              }, c._binBE = {
                nextZero: function(l, a) {
                  for (; l[a] != 0; ) a++;
                  return a;
                },
                readUshort: function(l, a) {
                  return l[a] << 8 | l[a + 1];
                },
                readShort: function(l, a) {
                  var n = c._binBE.ui8;
                  return n[0] = l[a + 1], n[1] = l[a + 0], c._binBE.i16[0];
                },
                readInt: function(l, a) {
                  var n = c._binBE.ui8;
                  return n[0] = l[a + 3], n[1] = l[a + 2], n[2] = l[a + 1], n[3] = l[a + 0], c._binBE.i32[0];
                },
                readUint: function(l, a) {
                  var n = c._binBE.ui8;
                  return n[0] = l[a + 3], n[1] = l[a + 2], n[2] = l[a + 1], n[3] = l[a + 0], c._binBE.ui32[0];
                },
                readASCII: function(l, a, n) {
                  for (var d = "", g = 0; g < n; g++) d += String.fromCharCode(l[a + g]);
                  return d;
                },
                readFloat: function(l, a) {
                  for (var n = c._binBE.ui8, d = 0; d < 4; d++) n[d] = l[a + 3 - d];
                  return c._binBE.fl32[0];
                },
                readDouble: function(l, a) {
                  for (var n = c._binBE.ui8, d = 0; d < 8; d++) n[d] = l[a + 7 - d];
                  return c._binBE.fl64[0];
                },
                writeUshort: function(l, a, n) {
                  l[a] = n >> 8 & 255, l[a + 1] = n & 255;
                },
                writeUint: function(l, a, n) {
                  l[a] = n >> 24 & 255, l[a + 1] = n >> 16 & 255, l[a + 2] = n >> 8 & 255, l[a + 3] = n >> 0 & 255;
                },
                writeASCII: function(l, a, n) {
                  for (var d = 0; d < n.length; d++) l[a + d] = n.charCodeAt(d);
                },
                writeDouble: function(l, a, n) {
                  c._binBE.fl64[0] = n;
                  for (var d = 0; d < 8; d++) l[a + d] = c._binBE.ui8[7 - d];
                }
              }, c._binBE.ui8 = new Uint8Array(8), c._binBE.i16 = new Int16Array(c._binBE.ui8.buffer), c._binBE.i32 = new Int32Array(c._binBE.ui8.buffer), c._binBE.ui32 = new Uint32Array(c._binBE.ui8.buffer), c._binBE.fl32 = new Float32Array(c._binBE.ui8.buffer), c._binBE.fl64 = new Float64Array(c._binBE.ui8.buffer), c._binLE = {
                nextZero: c._binBE.nextZero,
                readUshort: function(l, a) {
                  return l[a + 1] << 8 | l[a];
                },
                readShort: function(l, a) {
                  var n = c._binBE.ui8;
                  return n[0] = l[a + 0], n[1] = l[a + 1], c._binBE.i16[0];
                },
                readInt: function(l, a) {
                  var n = c._binBE.ui8;
                  return n[0] = l[a + 0], n[1] = l[a + 1], n[2] = l[a + 2], n[3] = l[a + 3], c._binBE.i32[0];
                },
                readUint: function(l, a) {
                  var n = c._binBE.ui8;
                  return n[0] = l[a + 0], n[1] = l[a + 1], n[2] = l[a + 2], n[3] = l[a + 3], c._binBE.ui32[0];
                },
                readASCII: c._binBE.readASCII,
                readFloat: function(l, a) {
                  for (var n = c._binBE.ui8, d = 0; d < 4; d++) n[d] = l[a + d];
                  return c._binBE.fl32[0];
                },
                readDouble: function(l, a) {
                  for (var n = c._binBE.ui8, d = 0; d < 8; d++) n[d] = l[a + d];
                  return c._binBE.fl64[0];
                }
              }, c._copyTile = function(l, a, n, d, g, h, m, s) {
                for (var b = Math.min(a, g - m), S = Math.min(n, h - s), o = 0; o < S; o++)
                  for (var A = (s + o) * g + m, T = o * a, I = 0; I < b; I++) d[A + I] = l[T + I];
              };
            })(x, y);
          })();
        }).call(this, k("_process"));
      }, { _process: 133, pako: 86 }], 183: [function(k, Z, _) {
        (function(M) {
          Z.exports = x;
          function x(E, c) {
            if (y("noDeprecation"))
              return E;
            var u = !1;
            function l() {
              if (!u) {
                if (y("throwDeprecation"))
                  throw new Error(c);
                y("traceDeprecation") ? console.trace(c) : console.warn(c), u = !0;
              }
              return E.apply(this, arguments);
            }
            return l;
          }
          function y(E) {
            try {
              if (!M.localStorage) return !1;
            } catch {
              return !1;
            }
            var c = M.localStorage[E];
            return c == null ? !1 : String(c).toLowerCase() === "true";
          }
        }).call(this, typeof dr < "u" ? dr : typeof self < "u" ? self : typeof ae < "u" ? ae : {});
      }, {}], 184: [function(k, Z, _) {
        arguments[4][26][0].apply(_, arguments);
      }, { dup: 26 }], 185: [function(k, Z, _) {
        arguments[4][27][0].apply(_, arguments);
      }, { dup: 27 }], 186: [function(k, Z, _) {
        arguments[4][28][0].apply(_, arguments);
      }, { "./support/isBuffer": 185, _process: 133, dup: 28, inherits: 184 }], 187: [function(k, Z, _) {
        var M = k("global/window"), x = k("is-function"), y = k("parse-headers"), E = k("xtend");
        Z.exports = a, Z.exports.default = a, a.XMLHttpRequest = M.XMLHttpRequest || g, a.XDomainRequest = "withCredentials" in new a.XMLHttpRequest() ? a.XMLHttpRequest : M.XDomainRequest, c(["get", "put", "post", "patch", "head", "delete"], function(h) {
          a[h === "delete" ? "del" : h] = function(m, s, b) {
            return s = l(m, s, b), s.method = h.toUpperCase(), n(s);
          };
        });
        function c(h, m) {
          for (var s = 0; s < h.length; s++)
            m(h[s]);
        }
        function u(h) {
          for (var m in h)
            if (h.hasOwnProperty(m)) return !1;
          return !0;
        }
        function l(h, m, s) {
          var b = h;
          return x(m) ? (s = m, typeof h == "string" && (b = { uri: h })) : b = E(m, { uri: h }), b.callback = s, b;
        }
        function a(h, m, s) {
          return m = l(h, m, s), n(m);
        }
        function n(h) {
          if (typeof h.callback > "u")
            throw new Error("callback argument missing");
          var m = !1, s = function(de, we, ke) {
            m || (m = !0, h.callback(de, we, ke));
          };
          function b() {
            T.readyState === 4 && setTimeout(A, 0);
          }
          function S() {
            var Q = void 0;
            if (T.response ? Q = T.response : Q = T.responseText || d(T), ee)
              try {
                Q = JSON.parse(Q);
              } catch {
              }
            return Q;
          }
          function o(Q) {
            return clearTimeout(ie), Q instanceof Error || (Q = new Error("" + (Q || "Unknown XMLHttpRequest Error"))), Q.statusCode = 0, s(Q, W);
          }
          function A() {
            if (!L) {
              var Q;
              clearTimeout(ie), h.useXDR && T.status === void 0 ? Q = 200 : Q = T.status === 1223 ? 204 : T.status;
              var de = W, we = null;
              return Q !== 0 ? (de = {
                body: S(),
                statusCode: Q,
                method: U,
                headers: {},
                url: z,
                rawRequest: T
              }, T.getAllResponseHeaders && (de.headers = y(T.getAllResponseHeaders()))) : we = new Error("Internal XMLHttpRequest Error"), s(we, de, de.body);
            }
          }
          var T = h.xhr || null;
          T || (h.cors || h.useXDR ? T = new a.XDomainRequest() : T = new a.XMLHttpRequest());
          var I, L, z = T.url = h.uri || h.url, U = T.method = h.method || "GET", J = h.body || h.data, F = T.headers = h.headers || {}, oe = !!h.sync, ee = !1, ie, W = {
            body: void 0,
            headers: {},
            statusCode: 0,
            method: U,
            url: z,
            rawRequest: T
          };
          if ("json" in h && h.json !== !1 && (ee = !0, F.accept || F.Accept || (F.Accept = "application/json"), U !== "GET" && U !== "HEAD" && (F["content-type"] || F["Content-Type"] || (F["Content-Type"] = "application/json"), J = JSON.stringify(h.json === !0 ? J : h.json))), T.onreadystatechange = b, T.onload = A, T.onerror = o, T.onprogress = function() {
          }, T.onabort = function() {
            L = !0;
          }, T.ontimeout = o, T.open(U, z, !oe, h.username, h.password), oe || (T.withCredentials = !!h.withCredentials), !oe && h.timeout > 0 && (ie = setTimeout(function() {
            if (!L) {
              L = !0, T.abort("timeout");
              var Q = new Error("XMLHttpRequest timeout");
              Q.code = "ETIMEDOUT", o(Q);
            }
          }, h.timeout)), T.setRequestHeader)
            for (I in F)
              F.hasOwnProperty(I) && T.setRequestHeader(I, F[I]);
          else if (h.headers && !u(h.headers))
            throw new Error("Headers cannot be set on an XDomainRequest object");
          return "responseType" in h && (T.responseType = h.responseType), "beforeSend" in h && typeof h.beforeSend == "function" && h.beforeSend(T), T.send(J || null), T;
        }
        function d(h) {
          try {
            if (h.responseType === "document")
              return h.responseXML;
            var m = h.responseXML && h.responseXML.documentElement.nodeName === "parsererror";
            if (h.responseType === "" && !m)
              return h.responseXML;
          } catch {
          }
          return null;
        }
        function g() {
        }
      }, { "global/window": 71, "is-function": 78, "parse-headers": 106, xtend: 189 }], 188: [function(k, Z, _) {
        Z.exports = function() {
          return typeof self.DOMParser < "u" ? function(x) {
            var y = new self.DOMParser();
            return y.parseFromString(x, "application/xml");
          } : typeof self.ActiveXObject < "u" && new self.ActiveXObject("Microsoft.XMLDOM") ? function(x) {
            var y = new self.ActiveXObject("Microsoft.XMLDOM");
            return y.async = "false", y.loadXML(x), y;
          } : function(x) {
            var y = document.createElement("div");
            return y.innerHTML = x, y;
          };
        }();
      }, {}], 189: [function(k, Z, _) {
        Z.exports = x;
        var M = Object.prototype.hasOwnProperty;
        function x() {
          for (var y = {}, E = 0; E < arguments.length; E++) {
            var c = arguments[E];
            for (var u in c)
              M.call(c, u) && (y[u] = c[u]);
          }
          return y;
        }
      }, {}], 190: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.srcOver = M, _.dstOver = x, _.multiply = y, _.add = E, _.screen = c, _.overlay = u, _.darken = l, _.lighten = a, _.hardLight = n, _.difference = d, _.exclusion = g;
        function M(h, m) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          h.a *= s;
          var b = m.a + h.a - m.a * h.a, S = (h.r * h.a + m.r * m.a * (1 - h.a)) / b, o = (h.g * h.a + m.g * m.a * (1 - h.a)) / b, A = (h.b * h.a + m.b * m.a * (1 - h.a)) / b;
          return {
            r: S,
            g: o,
            b: A,
            a: b
          };
        }
        function x(h, m) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          h.a *= s;
          var b = m.a + h.a - m.a * h.a, S = (m.r * m.a + h.r * h.a * (1 - m.a)) / b, o = (m.g * m.a + h.g * h.a * (1 - m.a)) / b, A = (m.b * m.a + h.b * h.a * (1 - m.a)) / b;
          return {
            r: S,
            g: o,
            b: A,
            a: b
          };
        }
        function y(h, m) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          h.a *= s;
          var b = m.a + h.a - m.a * h.a, S = h.r * h.a, o = h.g * h.a, A = h.b * h.a, T = m.r * m.a, I = m.g * m.a, L = m.b * m.a, z = (S * T + S * (1 - m.a) + T * (1 - h.a)) / b, U = (o * I + o * (1 - m.a) + I * (1 - h.a)) / b, J = (A * L + A * (1 - m.a) + L * (1 - h.a)) / b;
          return {
            r: z,
            g: U,
            b: J,
            a: b
          };
        }
        function E(h, m) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          h.a *= s;
          var b = m.a + h.a - m.a * h.a, S = h.r * h.a, o = h.g * h.a, A = h.b * h.a, T = m.r * m.a, I = m.g * m.a, L = m.b * m.a, z = (S + T) / b, U = (o + I) / b, J = (A + L) / b;
          return {
            r: z,
            g: U,
            b: J,
            a: b
          };
        }
        function c(h, m) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          h.a *= s;
          var b = m.a + h.a - m.a * h.a, S = h.r * h.a, o = h.g * h.a, A = h.b * h.a, T = m.r * m.a, I = m.g * m.a, L = m.b * m.a, z = (S * m.a + T * h.a - S * T + S * (1 - m.a) + T * (1 - h.a)) / b, U = (o * m.a + I * h.a - o * I + o * (1 - m.a) + I * (1 - h.a)) / b, J = (A * m.a + L * h.a - A * L + A * (1 - m.a) + L * (1 - h.a)) / b;
          return {
            r: z,
            g: U,
            b: J,
            a: b
          };
        }
        function u(h, m) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          h.a *= s;
          var b = m.a + h.a - m.a * h.a, S = h.r * h.a, o = h.g * h.a, A = h.b * h.a, T = m.r * m.a, I = m.g * m.a, L = m.b * m.a, z = (2 * T <= m.a ? 2 * S * T + S * (1 - m.a) + T * (1 - h.a) : S * (1 + m.a) + T * (1 + h.a) - 2 * T * S - m.a * h.a) / b, U = (2 * I <= m.a ? 2 * o * I + o * (1 - m.a) + I * (1 - h.a) : o * (1 + m.a) + I * (1 + h.a) - 2 * I * o - m.a * h.a) / b, J = (2 * L <= m.a ? 2 * A * L + A * (1 - m.a) + L * (1 - h.a) : A * (1 + m.a) + L * (1 + h.a) - 2 * L * A - m.a * h.a) / b;
          return {
            r: z,
            g: U,
            b: J,
            a: b
          };
        }
        function l(h, m) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          h.a *= s;
          var b = m.a + h.a - m.a * h.a, S = h.r * h.a, o = h.g * h.a, A = h.b * h.a, T = m.r * m.a, I = m.g * m.a, L = m.b * m.a, z = (Math.min(S * m.a, T * h.a) + S * (1 - m.a) + T * (1 - h.a)) / b, U = (Math.min(o * m.a, I * h.a) + o * (1 - m.a) + I * (1 - h.a)) / b, J = (Math.min(A * m.a, L * h.a) + A * (1 - m.a) + L * (1 - h.a)) / b;
          return {
            r: z,
            g: U,
            b: J,
            a: b
          };
        }
        function a(h, m) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          h.a *= s;
          var b = m.a + h.a - m.a * h.a, S = h.r * h.a, o = h.g * h.a, A = h.b * h.a, T = m.r * m.a, I = m.g * m.a, L = m.b * m.a, z = (Math.max(S * m.a, T * h.a) + S * (1 - m.a) + T * (1 - h.a)) / b, U = (Math.max(o * m.a, I * h.a) + o * (1 - m.a) + I * (1 - h.a)) / b, J = (Math.max(A * m.a, L * h.a) + A * (1 - m.a) + L * (1 - h.a)) / b;
          return {
            r: z,
            g: U,
            b: J,
            a: b
          };
        }
        function n(h, m) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          h.a *= s;
          var b = m.a + h.a - m.a * h.a, S = h.r * h.a, o = h.g * h.a, A = h.b * h.a, T = m.r * m.a, I = m.g * m.a, L = m.b * m.a, z = (2 * S <= h.a ? 2 * S * T + S * (1 - m.a) + T * (1 - h.a) : S * (1 + m.a) + T * (1 + h.a) - 2 * T * S - m.a * h.a) / b, U = (2 * o <= h.a ? 2 * o * I + o * (1 - m.a) + I * (1 - h.a) : o * (1 + m.a) + I * (1 + h.a) - 2 * I * o - m.a * h.a) / b, J = (2 * A <= h.a ? 2 * A * L + A * (1 - m.a) + L * (1 - h.a) : A * (1 + m.a) + L * (1 + h.a) - 2 * L * A - m.a * h.a) / b;
          return {
            r: z,
            g: U,
            b: J,
            a: b
          };
        }
        function d(h, m) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          h.a *= s;
          var b = m.a + h.a - m.a * h.a, S = h.r * h.a, o = h.g * h.a, A = h.b * h.a, T = m.r * m.a, I = m.g * m.a, L = m.b * m.a, z = (S + T - 2 * Math.min(S * m.a, T * h.a)) / b, U = (o + I - 2 * Math.min(o * m.a, I * h.a)) / b, J = (A + L - 2 * Math.min(A * m.a, L * h.a)) / b;
          return {
            r: z,
            g: U,
            b: J,
            a: b
          };
        }
        function g(h, m) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          h.a *= s;
          var b = m.a + h.a - m.a * h.a, S = h.r * h.a, o = h.g * h.a, A = h.b * h.a, T = m.r * m.a, I = m.g * m.a, L = m.b * m.a, z = (S * m.a + T * h.a - 2 * S * T + S * (1 - m.a) + T * (1 - h.a)) / b, U = (o * m.a + I * h.a - 2 * o * I + o * (1 - m.a) + I * (1 - h.a)) / b, J = (A * m.a + L * h.a - 2 * A * L + A * (1 - m.a) + L * (1 - h.a)) / b;
          return {
            r: z,
            g: U,
            b: J,
            a: b
          };
        }
      }, {}], 191: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireWildcard");
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = c;
        var x = k("@jimp/utils"), y = M(k("../constants")), E = M(k("./composite-modes"));
        function c(u, l, a) {
          var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, d = arguments.length > 4 ? arguments[4] : void 0;
          if (typeof n == "function" && (d = n, n = {}), !(u instanceof this.constructor))
            return x.throwError.call(this, "The source must be a Jimp image", d);
          if (typeof l != "number" || typeof a != "number")
            return x.throwError.call(this, "x and y must be numbers", d);
          var g = n, h = g.mode, m = g.opacitySource, s = g.opacityDest;
          h || (h = y.BLEND_SOURCE_OVER), (typeof m != "number" || m < 0 || m > 1) && (m = 1), (typeof s != "number" || s < 0 || s > 1) && (s = 1);
          var b = E[h];
          l = Math.round(l), a = Math.round(a);
          var S = this;
          return s !== 1 && S.opacity(s), u.scanQuiet(0, 0, u.bitmap.width, u.bitmap.height, function(o, A, T) {
            var I = S.getPixelIndex(l + o, a + A, y.EDGE_CROP), L = b({
              r: this.bitmap.data[T + 0] / 255,
              g: this.bitmap.data[T + 1] / 255,
              b: this.bitmap.data[T + 2] / 255,
              a: this.bitmap.data[T + 3] / 255
            }, {
              r: S.bitmap.data[I + 0] / 255,
              g: S.bitmap.data[I + 1] / 255,
              b: S.bitmap.data[I + 2] / 255,
              a: S.bitmap.data[I + 3] / 255
            }, m);
            S.bitmap.data[I + 0] = this.constructor.limit255(L.r * 255), S.bitmap.data[I + 1] = this.constructor.limit255(L.g * 255), S.bitmap.data[I + 2] = this.constructor.limit255(L.b * 255), S.bitmap.data[I + 3] = this.constructor.limit255(L.a * 255);
          }), (0, x.isNodePattern)(d) && d.call(this, null, this), this;
        }
        Z.exports = _.default;
      }, { "../constants": 192, "./composite-modes": 190, "@babel/runtime/helpers/interopRequireWildcard": 12, "@jimp/utils": 235 }], 192: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.EDGE_CROP = _.EDGE_WRAP = _.EDGE_EXTEND = _.BLEND_EXCLUSION = _.BLEND_DIFFERENCE = _.BLEND_HARDLIGHT = _.BLEND_LIGHTEN = _.BLEND_DARKEN = _.BLEND_OVERLAY = _.BLEND_SCREEN = _.BLEND_ADD = _.BLEND_MULTIPLY = _.BLEND_DESTINATION_OVER = _.BLEND_SOURCE_OVER = _.VERTICAL_ALIGN_BOTTOM = _.VERTICAL_ALIGN_MIDDLE = _.VERTICAL_ALIGN_TOP = _.HORIZONTAL_ALIGN_RIGHT = _.HORIZONTAL_ALIGN_CENTER = _.HORIZONTAL_ALIGN_LEFT = _.AUTO = void 0;
        var M = -1;
        _.AUTO = M;
        var x = 1;
        _.HORIZONTAL_ALIGN_LEFT = x;
        var y = 2;
        _.HORIZONTAL_ALIGN_CENTER = y;
        var E = 4;
        _.HORIZONTAL_ALIGN_RIGHT = E;
        var c = 8;
        _.VERTICAL_ALIGN_TOP = c;
        var u = 16;
        _.VERTICAL_ALIGN_MIDDLE = u;
        var l = 32;
        _.VERTICAL_ALIGN_BOTTOM = l;
        var a = "srcOver";
        _.BLEND_SOURCE_OVER = a;
        var n = "dstOver";
        _.BLEND_DESTINATION_OVER = n;
        var d = "multiply";
        _.BLEND_MULTIPLY = d;
        var g = "add";
        _.BLEND_ADD = g;
        var h = "screen";
        _.BLEND_SCREEN = h;
        var m = "overlay";
        _.BLEND_OVERLAY = m;
        var s = "darken";
        _.BLEND_DARKEN = s;
        var b = "lighten";
        _.BLEND_LIGHTEN = b;
        var S = "hardLight";
        _.BLEND_HARDLIGHT = S;
        var o = "difference";
        _.BLEND_DIFFERENCE = o;
        var A = "exclusion";
        _.BLEND_EXCLUSION = A;
        var T = 1;
        _.EDGE_EXTEND = T;
        var I = 2;
        _.EDGE_WRAP = I;
        var L = 3;
        _.EDGE_CROP = L;
      }, {}], 193: [function(k, Z, _) {
        (function(M) {
          var x = k("@babel/runtime/helpers/interopRequireWildcard"), y = k("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(_, "__esModule", {
            value: !0
          }), _.addConstants = Ze, _.addJimpMethods = $e, _.jimpEvMethod = Ve, _.jimpEvChange = Ge, Object.defineProperty(_, "addType", {
            enumerable: !0,
            get: function() {
              return oe.addType;
            }
          }), _.default = void 0;
          for (var E = y(k("@babel/runtime/helpers/construct")), c = y(k("@babel/runtime/helpers/slicedToArray")), u = y(k("@babel/runtime/helpers/classCallCheck")), l = y(k("@babel/runtime/helpers/createClass")), a = y(k("@babel/runtime/helpers/possibleConstructorReturn")), n = y(k("@babel/runtime/helpers/getPrototypeOf")), d = y(k("@babel/runtime/helpers/assertThisInitialized")), g = y(k("@babel/runtime/helpers/inherits")), h = y(k("@babel/runtime/helpers/defineProperty")), m = y(k("@babel/runtime/helpers/typeof")), s = y(k("fs")), b = y(k("path")), S = y(k("events")), o = k("@jimp/utils"), A = y(k("any-base")), T = y(k("mkdirp")), I = y(k("pixelmatch")), L = y(k("tinycolor2")), z = y(k("./modules/phash")), U = y(k("./request")), J = y(k("./composite")), F = y(k("./utils/promisify")), oe = x(k("./utils/mime")), ee = k("./utils/image-bitmap"), ie = x(k("./constants")), W = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", Q = [NaN, NaN], de = 2; de < 65; de++) {
            var we = (0, A.default)(A.default.BIN, W.slice(0, de))(new Array(65).join("1"));
            Q.push(we.length);
          }
          function ke() {
          }
          function Me(Ne) {
            return Object.prototype.toString.call(Ne).toLowerCase().indexOf("arraybuffer") > -1;
          }
          function fe(Ne) {
            for (var _e = M.alloc(Ne.byteLength), re = new Uint8Array(Ne), $ = 0; $ < _e.length; ++$)
              _e[$] = re[$];
            return _e;
          }
          function xe(Ne, _e) {
            (0, U.default)(Ne, function(re, $, Ce) {
              if (re)
                return _e(re);
              if ("headers" in $ && "location" in $.headers)
                return Ne.url = $.headers.location, xe(Ne, _e);
              if ((0, m.default)(Ce) === "object" && M.isBuffer(Ce))
                return _e(null, Ce);
              var ve = "Could not load Buffer from <" + Ne.url + "> (HTTP: " + $.statusCode + ")";
              return new Error(ve);
            });
          }
          function Ee(Ne, _e) {
            s.default && typeof s.default.readFile == "function" && !Ne.match(/^(http|ftp)s?:\/\/./) ? s.default.readFile(Ne, _e) : xe({
              url: Ne
            }, _e);
          }
          function Pe(Ne) {
            return Ne && (0, m.default)(Ne) === "object" && typeof Ne.width == "number" && typeof Ne.height == "number" && (M.isBuffer(Ne.data) || Ne.data instanceof Uint8Array || typeof Uint8ClampedArray == "function" && Ne.data instanceof Uint8ClampedArray) && (Ne.data.length === Ne.width * Ne.height * 4 || Ne.data.length === Ne.width * Ne.height * 3);
          }
          function Ue(Ne) {
            if (Ne.length % 3 !== 0)
              throw new Error("Buffer length is incorrect");
            for (var _e = M.allocUnsafe(Ne.length / 3 * 4), re = 0, $ = 0; $ < Ne.length; $++)
              _e[re] = Ne[$], ($ + 1) % 3 === 0 && (_e[++re] = 255), re++;
            return _e;
          }
          var He = {
            data: null,
            width: null,
            height: null
          }, We = /* @__PURE__ */ function(Ne) {
            (0, g.default)(_e, Ne);
            function _e() {
              for (var re, $ = arguments.length, Ce = new Array($), ve = 0; ve < $; ve++)
                Ce[ve] = arguments[ve];
              (0, u.default)(this, _e), re = (0, a.default)(this, (0, n.default)(_e).call(this)), (0, h.default)((0, d.default)(re), "bitmap", He), (0, h.default)((0, d.default)(re), "_background", 0), (0, h.default)((0, d.default)(re), "_originalMime", _e.MIME_PNG), (0, h.default)((0, d.default)(re), "_exif", null), (0, h.default)((0, d.default)(re), "_rgba", !0), (0, h.default)((0, d.default)(re), "writeAsync", function(pe) {
                return (0, F.default)(re.write, (0, d.default)(re), pe);
              }), (0, h.default)((0, d.default)(re), "getBase64Async", function(pe) {
                return (0, F.default)(re.getBase64, (0, d.default)(re), pe);
              }), (0, h.default)((0, d.default)(re), "getBuffer", ee.getBuffer), (0, h.default)((0, d.default)(re), "getBufferAsync", ee.getBufferAsync), (0, h.default)((0, d.default)(re), "getPixelColour", re.getPixelColor), (0, h.default)((0, d.default)(re), "setPixelColour", re.setPixelColor);
              var Y = (0, d.default)(re), G = ke;
              Me(Ce[0]) && (Ce[0] = fe(Ce[0]));
              function Ae() {
                for (var pe = arguments.length, P = new Array(pe), q = 0; q < pe; q++)
                  P[q] = arguments[q];
                var K = P[0], ye = K || {};
                ye.methodName = "constructor", setTimeout(function() {
                  var te;
                  K && G === ke ? Y.emitError("constructor", K) : K || Y.emitMulti("constructor", "initialized"), (te = G).call.apply(te, [Y].concat(P));
                }, 1);
              }
              if (typeof Ce[0] == "number" && typeof Ce[1] == "number" || parseInt(Ce[0], 10) && parseInt(Ce[1], 10)) {
                var e = parseInt(Ce[0], 10), r = parseInt(Ce[1], 10);
                if (G = Ce[2], typeof Ce[2] == "number" && (re._background = Ce[2], G = Ce[3]), typeof Ce[2] == "string" && (re._background = _e.cssColorToHex(Ce[2]), G = Ce[3]), typeof G > "u" && (G = ke), typeof G != "function")
                  return (0, a.default)(re, o.throwError.call((0, d.default)(re), "cb must be a function", Ae));
                re.bitmap = {
                  data: M.alloc(e * r * 4),
                  width: e,
                  height: r
                };
                for (var f = 0; f < re.bitmap.data.length; f += 4)
                  re.bitmap.data.writeUInt32BE(re._background, f);
                Ae(null, (0, d.default)(re));
              } else if ((0, m.default)(Ce[0]) === "object" && Ce[0].url) {
                if (G = Ce[1] || ke, typeof G != "function")
                  return (0, a.default)(re, o.throwError.call((0, d.default)(re), "cb must be a function", Ae));
                xe(Ce[0], function(pe, P) {
                  if (pe)
                    return o.throwError.call((0, d.default)(re), pe, Ae);
                  re.parseBitmap(P, Ce[0].url, Ae);
                });
              } else if (Ce[0] instanceof _e) {
                var C = Ce[0];
                if (G = Ce[1], typeof G > "u" && (G = ke), typeof G != "function")
                  return (0, a.default)(re, o.throwError.call((0, d.default)(re), "cb must be a function", Ae));
                re.bitmap = {
                  data: M.from(C.bitmap.data),
                  width: C.bitmap.width,
                  height: C.bitmap.height
                }, re._quality = C._quality, re._deflateLevel = C._deflateLevel, re._deflateStrategy = C._deflateStrategy, re._filterType = C._filterType, re._rgba = C._rgba, re._background = C._background, re._originalMime = C._originalMime, Ae(null, (0, d.default)(re));
              } else if (Pe(Ce[0])) {
                var R = Ce[0];
                G = Ce[1] || ke;
                var B = R.width * R.height * 4 === R.data.length, j = B ? M.from(R.data) : Ue(R.data);
                re.bitmap = {
                  data: j,
                  width: R.width,
                  height: R.height
                }, Ae(null, (0, d.default)(re));
              } else if (typeof Ce[0] == "string") {
                var H = Ce[0];
                if (G = Ce[1], typeof G > "u" && (G = ke), typeof G != "function")
                  return (0, a.default)(re, o.throwError.call((0, d.default)(re), "cb must be a function", Ae));
                Ee(H, function(pe, P) {
                  if (pe)
                    return o.throwError.call((0, d.default)(re), pe, Ae);
                  re.parseBitmap(P, H, Ae);
                });
              } else if ((0, m.default)(Ce[0]) === "object" && M.isBuffer(Ce[0])) {
                var X = Ce[0];
                if (G = Ce[1], typeof G != "function")
                  return (0, a.default)(re, o.throwError.call((0, d.default)(re), "cb must be a function", Ae));
                re.parseBitmap(X, null, Ae);
              } else {
                G = Ce[Ce.length - 1], typeof G != "function" && (G = Ce[Ce.length - 2], typeof G != "function" && (G = ke));
                var ue = _e.__extraConstructors.find(function(pe) {
                  return pe.test.apply(pe, Ce);
                });
                if (ue)
                  new Promise(function(pe, P) {
                    var q;
                    return (q = ue.run).call.apply(q, [(0, d.default)(re), pe, P].concat(Ce));
                  }).then(function() {
                    return Ae(null, (0, d.default)(re));
                  }).catch(Ae);
                else
                  return (0, a.default)(re, o.throwError.call((0, d.default)(re), "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", Ae));
              }
              return re;
            }
            return (0, l.default)(_e, [{
              key: "parseBitmap",
              value: function($, Ce, ve) {
                ee.parseBitmap.call(this, $, null, ve);
              }
              /**
               * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)
               * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "rgba",
              value: function($, Ce) {
                return typeof $ != "boolean" ? o.throwError.call(this, "bool must be a boolean, true for RGBA or false for RGB", Ce) : (this._rgba = $, (0, o.isNodePattern)(Ce) && Ce.call(this, null, this), this);
              }
              /**
               * Emit for multiple listeners
               * @param {string} methodName name of the method to emit an error for
               * @param {string} eventName name of the eventName to emit an error for
               * @param {object} data to emit
               */
            }, {
              key: "emitMulti",
              value: function($, Ce) {
                var ve = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                ve = Object.assign(ve, {
                  methodName: $,
                  eventName: Ce
                }), this.emit("any", ve), $ && this.emit($, ve), this.emit(Ce, ve);
              }
            }, {
              key: "emitError",
              value: function($, Ce) {
                this.emitMulti($, "error", Ce);
              }
              /**
               * Get the current height of the image
               * @return {number} height of the image
               */
            }, {
              key: "getHeight",
              value: function() {
                return this.bitmap.height;
              }
              /**
               * Get the current width of the image
               * @return {number} width of the image
               */
            }, {
              key: "getWidth",
              value: function() {
                return this.bitmap.width;
              }
              /**
               * Nicely format Jimp object when sent to the console e.g. console.log(image)
               * @returns {string} pretty printed
               */
            }, {
              key: "inspect",
              value: function() {
                return "<Jimp " + (this.bitmap === He ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
              }
              /**
               * Nicely format Jimp object when converted to a string
               * @returns {string} pretty printed
               */
            }, {
              key: "toString",
              value: function() {
                return "[object Jimp]";
              }
              /**
               * Returns the original MIME of the image (default: "image/png")
               * @returns {string} the MIME
               */
            }, {
              key: "getMIME",
              value: function() {
                var $ = this._originalMime || _e.MIME_PNG;
                return $;
              }
              /**
               * Returns the appropriate file extension for the original MIME of the image (default: "png")
               * @returns {string} the file extension
               */
            }, {
              key: "getExtension",
              value: function() {
                var $ = this.getMIME();
                return oe.getExtension($);
              }
              /**
               * Writes the image to a file
               * @param {string} path a path to the destination file
               * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "write",
              value: function($, Ce) {
                var ve = this;
                if (!s.default || !s.default.createWriteStream)
                  throw new Error("Cant access the filesystem. You can use the getBase64 method.");
                if (typeof $ != "string")
                  return o.throwError.call(this, "path must be a string", Ce);
                if (typeof Ce > "u" && (Ce = ke), typeof Ce != "function")
                  return o.throwError.call(this, "cb must be a function", Ce);
                var Y = oe.getType($) || this.getMIME(), G = b.default.parse($);
                return G.dir && T.default.sync(G.dir), this.getBuffer(Y, function(Ae, e) {
                  if (Ae)
                    return o.throwError.call(ve, Ae, Ce);
                  var r = s.default.createWriteStream($);
                  r.on("open", function() {
                    r.write(e), r.end();
                  }).on("error", function(f) {
                    return o.throwError.call(ve, f, Ce);
                  }), r.on("finish", function() {
                    Ce.call(ve, null, ve);
                  });
                }), this;
              }
            }, {
              key: "getBase64",
              /**
               * Converts the image to a base 64 string
               * @param {string} mime the mime type of the image data to be created
               * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
               * @returns {Jimp} this for chaining of methods
               */
              value: function($, Ce) {
                return $ === _e.AUTO && ($ = this.getMIME()), typeof $ != "string" ? o.throwError.call(this, "mime must be a string", Ce) : typeof Ce != "function" ? o.throwError.call(this, "cb must be a function", Ce) : (this.getBuffer($, function(ve, Y) {
                  if (ve)
                    return o.throwError.call(this, ve, Ce);
                  var G = "data:" + $ + ";base64," + Y.toString("base64");
                  Ce.call(this, null, G);
                }), this);
              }
            }, {
              key: "hash",
              /**
               * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.
               * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {string} a string representing the hash
               */
              value: function($, Ce) {
                if ($ = $ || 64, typeof $ == "function" && (Ce = $, $ = 64), typeof $ != "number")
                  return o.throwError.call(this, "base must be a number", Ce);
                if ($ < 2 || $ > 64)
                  return o.throwError.call(this, "base must be a number between 2 and 64", Ce);
                var ve = this.pHash();
                for (ve = (0, A.default)(A.default.BIN, W.slice(0, $))(ve); ve.length < Q[$]; )
                  ve = "0" + ve;
                return (0, o.isNodePattern)(Ce) && Ce.call(this, null, ve), ve;
              }
              /**
               * Calculates the perceptual hash
               * @returns {number} the perceptual hash
               */
            }, {
              key: "pHash",
              value: function() {
                var $ = new z.default();
                return $.getHash(this);
              }
              /**
               * Calculates the hamming distance of the current image and a hash based on their perceptual hash
               * @param {hash} compareHash hash to compare to
               * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
               */
            }, {
              key: "distanceFromHash",
              value: function($) {
                var Ce = new z.default(), ve = Ce.getHash(this);
                return Ce.distance(ve, $);
              }
              /**
               * Converts the image to a buffer
               * @param {string} mime the mime type of the image buffer to be created
               * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "getPixelIndex",
              /**
               * Returns the offset of a pixel in the bitmap buffer
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
               * @param {number} cb (optional) a callback for when complete
               * @returns {number} the index of the pixel or -1 if not found
               */
              value: function($, Ce, ve, Y) {
                var G, Ae;
                if (typeof ve == "function" && typeof Y > "u" && (Y = ve, ve = null), ve || (ve = _e.EDGE_EXTEND), typeof $ != "number" || typeof Ce != "number")
                  return o.throwError.call(this, "x and y must be numbers", Y);
                $ = Math.round($), Ce = Math.round(Ce), G = $, Ae = Ce, ve === _e.EDGE_EXTEND && ($ < 0 && (G = 0), $ >= this.bitmap.width && (G = this.bitmap.width - 1), Ce < 0 && (Ae = 0), Ce >= this.bitmap.height && (Ae = this.bitmap.height - 1)), ve === _e.EDGE_WRAP && ($ < 0 && (G = this.bitmap.width + $), $ >= this.bitmap.width && (G = $ % this.bitmap.width), Ce < 0 && (G = this.bitmap.height + Ce), Ce >= this.bitmap.height && (Ae = Ce % this.bitmap.height));
                var e = this.bitmap.width * Ae + G << 2;
                return (G < 0 || G >= this.bitmap.width) && (e = -1), (Ae < 0 || Ae >= this.bitmap.height) && (e = -1), (0, o.isNodePattern)(Y) && Y.call(this, null, e), e;
              }
              /**
               * Returns the hex colour value of a pixel
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {number} the color of the pixel
               */
            }, {
              key: "getPixelColor",
              value: function($, Ce, ve) {
                if (typeof $ != "number" || typeof Ce != "number") return o.throwError.call(this, "x and y must be numbers", ve);
                $ = Math.round($), Ce = Math.round(Ce);
                var Y = this.getPixelIndex($, Ce), G = this.bitmap.data.readUInt32BE(Y);
                return (0, o.isNodePattern)(ve) && ve.call(this, null, G), G;
              }
            }, {
              key: "setPixelColor",
              /**
               * Returns the hex colour value of a pixel
               * @param {number} hex color to set
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {number} the index of the pixel or -1 if not found
               */
              value: function($, Ce, ve, Y) {
                if (typeof $ != "number" || typeof Ce != "number" || typeof ve != "number") return o.throwError.call(this, "hex, x and y must be numbers", Y);
                Ce = Math.round(Ce), ve = Math.round(ve);
                var G = this.getPixelIndex(Ce, ve);
                return this.bitmap.data.writeUInt32BE($, G), (0, o.isNodePattern)(Y) && Y.call(this, null, this), this;
              }
            }, {
              key: "hasAlpha",
              /**
               * Determine if the image contains opaque pixels.
               * @return {boolean} hasAlpha whether the image contains opaque pixels
               */
              value: function() {
                for (var $ = 0; $ < this.bitmap.height; $++)
                  for (var Ce = 0; Ce < this.bitmap.width; Ce++) {
                    var ve = this.bitmap.width * $ + Ce << 2, Y = this.bitmap.data[ve + 3];
                    if (Y !== 255)
                      return !0;
                  }
                return !1;
              }
              /**
               * Iterate scan through a region of the bitmap
               * @param {number} x the x coordinate to begin the scan at
               * @param {number} y the y coordinate to begin the scan at
               * @param w the width of the scan region
               * @param h the height of the scan region
               * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}
               */
            }, {
              key: "scanIterator",
              value: function($, Ce, ve, Y) {
                return typeof $ != "number" || typeof Ce != "number" ? o.throwError.call(this, "x and y must be numbers") : typeof ve != "number" || typeof Y != "number" ? o.throwError.call(this, "w and h must be numbers") : (0, o.scanIterator)(this, $, Ce, ve, Y);
              }
            }]), _e;
          }(S.default);
          function Ze(Ne) {
            var _e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : We;
            Object.entries(Ne).forEach(function(re) {
              var $ = (0, c.default)(re, 2), Ce = $[0], ve = $[1];
              _e[Ce] = ve;
            });
          }
          function $e(Ne) {
            var _e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : We;
            Object.entries(Ne).forEach(function(re) {
              var $ = (0, c.default)(re, 2), Ce = $[0], ve = $[1];
              _e.prototype[Ce] = ve;
            });
          }
          Ze(ie), $e({
            composite: J.default
          }), We.__extraConstructors = [], We.appendConstructorOption = function(Ne, _e, re) {
            We.__extraConstructors.push({
              name: Ne,
              test: _e,
              run: re
            });
          }, We.read = function() {
            for (var Ne = arguments.length, _e = new Array(Ne), re = 0; re < Ne; re++)
              _e[re] = arguments[re];
            return new Promise(function($, Ce) {
              (0, E.default)(We, _e.concat([function(ve, Y) {
                ve ? Ce(ve) : $(Y);
              }]));
            });
          }, We.create = We.read, We.rgbaToInt = function(Ne, _e, re, $, Ce) {
            if (typeof Ne != "number" || typeof _e != "number" || typeof re != "number" || typeof $ != "number")
              return o.throwError.call(this, "r, g, b and a must be numbers", Ce);
            if (Ne < 0 || Ne > 255)
              return o.throwError.call(this, "r must be between 0 and 255", Ce);
            if ((_e < 0 || _e > 255) && o.throwError.call(this, "g must be between 0 and 255", Ce), re < 0 || re > 255)
              return o.throwError.call(this, "b must be between 0 and 255", Ce);
            if ($ < 0 || $ > 255)
              return o.throwError.call(this, "a must be between 0 and 255", Ce);
            Ne = Math.round(Ne), re = Math.round(re), _e = Math.round(_e), $ = Math.round($);
            var ve = Ne * Math.pow(256, 3) + _e * Math.pow(256, 2) + re * Math.pow(256, 1) + $ * Math.pow(256, 0);
            return (0, o.isNodePattern)(Ce) && Ce.call(this, null, ve), ve;
          }, We.intToRGBA = function(Ne, _e) {
            if (typeof Ne != "number")
              return o.throwError.call(this, "i must be a number", _e);
            var re = {};
            return re.r = Math.floor(Ne / Math.pow(256, 3)), re.g = Math.floor((Ne - re.r * Math.pow(256, 3)) / Math.pow(256, 2)), re.b = Math.floor((Ne - re.r * Math.pow(256, 3) - re.g * Math.pow(256, 2)) / Math.pow(256, 1)), re.a = Math.floor((Ne - re.r * Math.pow(256, 3) - re.g * Math.pow(256, 2) - re.b * Math.pow(256, 1)) / Math.pow(256, 0)), (0, o.isNodePattern)(_e) && _e.call(this, null, re), re;
          }, We.cssColorToHex = function(Ne) {
            return Ne = Ne || 0, typeof Ne == "number" ? Number(Ne) : parseInt((0, L.default)(Ne).toHex8(), 16);
          }, We.limit255 = function(Ne) {
            return Ne = Math.max(Ne, 0), Ne = Math.min(Ne, 255), Ne;
          }, We.diff = function(Ne, _e) {
            var re = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.1;
            if (!(Ne instanceof We) || !(_e instanceof We)) return o.throwError.call(this, "img1 and img2 must be an Jimp images");
            var $ = Ne.bitmap, Ce = _e.bitmap;
            if (($.width !== Ce.width || $.height !== Ce.height) && ($.width * $.height > Ce.width * Ce.height ? Ne = Ne.cloneQuiet().resize(Ce.width, Ce.height) : _e = _e.cloneQuiet().resize($.width, $.height)), typeof re != "number" || re < 0 || re > 1)
              return o.throwError.call(this, "threshold must be a number between 0 and 1");
            var ve = new We($.width, $.height, 4294967295), Y = (0, I.default)($.data, Ce.data, ve.bitmap.data, ve.bitmap.width, ve.bitmap.height, {
              threshold: re
            });
            return {
              percent: Y / (ve.bitmap.width * ve.bitmap.height),
              image: ve
            };
          }, We.distance = function(Ne, _e) {
            var re = new z.default(), $ = re.getHash(Ne), Ce = re.getHash(_e);
            return re.distance($, Ce);
          }, We.compareHashes = function(Ne, _e) {
            var re = new z.default();
            return re.distance(Ne, _e);
          }, We.colorDiff = function(Ne, _e) {
            var re = function(Y) {
              return Math.pow(Y, 2);
            }, $ = Math.max, Ce = 255 * 255 * 3;
            return Ne.a !== 0 && !Ne.a && (Ne.a = 255), _e.a !== 0 && !_e.a && (_e.a = 255), ($(re(Ne.r - _e.r), re(Ne.r - _e.r - Ne.a + _e.a)) + $(re(Ne.g - _e.g), re(Ne.g - _e.g - Ne.a + _e.a)) + $(re(Ne.b - _e.b), re(Ne.b - _e.b - Ne.a + _e.a))) / Ce;
          };
          function Ve(Ne, _e, re) {
            var $ = "before-" + _e, Ce = _e.replace(/e$/, "") + "ed";
            We.prototype[Ne] = function() {
              for (var ve, Y = arguments.length, G = new Array(Y), Ae = 0; Ae < Y; Ae++)
                G[Ae] = arguments[Ae];
              var e = G[re.length - 1], r = this;
              typeof e == "function" ? (ve = function() {
                for (var R = arguments.length, B = new Array(R), j = 0; j < R; j++)
                  B[j] = arguments[j];
                var H = B[0], X = B[1];
                H ? r.emitError(Ne, H) : r.emitMulti(Ne, Ce, (0, h.default)({}, Ne, X)), e.apply(this, B);
              }, G[G.length - 1] = ve) : ve = !1, this.emitMulti(Ne, $);
              var f;
              try {
                f = re.apply(this, G), ve || this.emitMulti(Ne, Ce, (0, h.default)({}, Ne, f));
              } catch (C) {
                C.methodName = Ne, this.emitError(Ne, C);
              }
              return f;
            }, We.prototype[Ne + "Quiet"] = re;
          }
          Ve("clone", "clone", function(Ne) {
            var _e = new We(this);
            return (0, o.isNodePattern)(Ne) && Ne.call(_e, null, _e), _e;
          });
          function Ge(Ne, _e) {
            Ve(Ne, "change", _e);
          }
          Ge("background", function(Ne, _e) {
            return typeof Ne != "number" ? o.throwError.call(this, "hex must be a hexadecimal rgba value", _e) : (this._background = Ne, (0, o.isNodePattern)(_e) && _e.call(this, null, this), this);
          }), Ge("scan", function(Ne, _e, re, $, Ce, ve) {
            if (typeof Ne != "number" || typeof _e != "number")
              return o.throwError.call(this, "x and y must be numbers", ve);
            if (typeof re != "number" || typeof $ != "number")
              return o.throwError.call(this, "w and h must be numbers", ve);
            if (typeof Ce != "function")
              return o.throwError.call(this, "f must be a function", ve);
            var Y = (0, o.scan)(this, Ne, _e, re, $, Ce);
            return (0, o.isNodePattern)(ve) && ve.call(this, null, Y), Y;
          });
          {
            var Ie;
            typeof ae < "u" && (typeof ae > "u" ? "undefined" : (0, m.default)(ae)) === "object" && (Ie = ae), typeof self < "u" && (typeof self > "u" ? "undefined" : (0, m.default)(self)) === "object" && (Ie = self), Ie.Jimp = We, Ie.Buffer = M;
          }
          var De = We;
          _.default = De;
        }).call(this, k("buffer").Buffer);
      }, { "./composite": 191, "./constants": 192, "./modules/phash": 194, "./request": 195, "./utils/image-bitmap": 196, "./utils/mime": 197, "./utils/promisify": 198, "@babel/runtime/helpers/assertThisInitialized": 3, "@babel/runtime/helpers/classCallCheck": 4, "@babel/runtime/helpers/construct": 5, "@babel/runtime/helpers/createClass": 6, "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/getPrototypeOf": 9, "@babel/runtime/helpers/inherits": 10, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/possibleConstructorReturn": 17, "@babel/runtime/helpers/slicedToArray": 19, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, "any-base": 23, buffer: 48, events: 52, fs: 47, mkdirp: 83, path: 107, pixelmatch: 109, tinycolor2: 178 }], 194: [function(k, Z, _) {
        function M(u, l) {
          this.size = this.size || u, this.smallerSize = this.smallerSize || l, E(this.size);
        }
        M.prototype.size = 32, M.prototype.smallerSize = 8, M.prototype.distance = function(u, l) {
          for (var a = 0, n = 0; n < u.length; n++)
            u[n] !== l[n] && a++;
          return a / u.length;
        }, M.prototype.getHash = function(u) {
          u = u.clone().resize(this.size, this.size), u.grayscale();
          for (var l = [], a = 0; a < u.bitmap.width; a++) {
            l[a] = [];
            for (var n = 0; n < u.bitmap.height; n++)
              l[a][n] = x(u.getPixelColor(a, n)).b;
          }
          for (var d = c(l, this.size), g = 0, h = 0; h < this.smallerSize; h++)
            for (var m = 0; m < this.smallerSize; m++)
              g += d[h][m];
          for (var s = g / (this.smallerSize * this.smallerSize), b = "", S = 0; S < this.smallerSize; S++)
            for (var o = 0; o < this.smallerSize; o++)
              b += d[S][o] > s ? "1" : "0";
          return b;
        };
        function x(u) {
          var l = {};
          return l.r = Math.floor(u / Math.pow(256, 3)), l.g = Math.floor((u - l.r * Math.pow(256, 3)) / Math.pow(256, 2)), l.b = Math.floor((u - l.r * Math.pow(256, 3) - l.g * Math.pow(256, 2)) / Math.pow(256, 1)), l.a = Math.floor((u - l.r * Math.pow(256, 3) - l.g * Math.pow(256, 2) - l.b * Math.pow(256, 1)) / Math.pow(256, 0)), l;
        }
        var y = [];
        function E(u) {
          for (var l = 1; l < u; l++)
            y[l] = 1;
          y[0] = 1 / Math.sqrt(2);
        }
        function c(u, l) {
          for (var a = l, n = [], d = 0; d < a; d++) {
            n[d] = [];
            for (var g = 0; g < a; g++) {
              for (var h = 0, m = 0; m < a; m++)
                for (var s = 0; s < a; s++)
                  h += Math.cos((2 * m + 1) / (2 * a) * d * Math.PI) * Math.cos((2 * s + 1) / (2 * a) * g * Math.PI) * u[m][s];
              h *= y[d] * y[g] / 4, n[d][g] = h;
            }
          }
          return n;
        }
        Z.exports = M;
      }, {}], 195: [function(k, Z, _) {
        (function(M, x) {
          var y = k("@babel/runtime/helpers/interopRequireDefault");
          y(k("@babel/runtime/helpers/defineProperty")), y(k("@babel/runtime/helpers/extends")), M.browser, Z.exports = function(E, c) {
            var u = new XMLHttpRequest();
            u.open("GET", E.url, !0), u.responseType = "arraybuffer", u.addEventListener("load", function() {
              if (u.status < 400)
                try {
                  var l = x.from(this.response);
                  c(null, u, l);
                } catch (a) {
                  return c(new Error("Response is not a buffer for url " + E.url + ". Error: " + a.message));
                }
              else
                c(new Error("HTTP Status " + u.status + " for url " + E.url));
            }), u.addEventListener("error", function(l) {
              c(l);
            }), u.send();
          };
        }).call(this, k("_process"), k("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/extends": 8, "@babel/runtime/helpers/interopRequireDefault": 11, _process: 133, buffer: 48, phin: 108 }], 196: [function(k, Z, _) {
        (function(M) {
          var x = k("@babel/runtime/helpers/interopRequireWildcard"), y = k("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(_, "__esModule", {
            value: !0
          }), _.parseBitmap = S, _.getBuffer = A, _.getBufferAsync = T;
          var E = y(k("@babel/runtime/helpers/slicedToArray")), c = y(k("file-type")), u = y(k("exif-parser")), l = k("@jimp/utils"), a = x(k("../constants")), n = x(k("./mime")), d = y(k("./promisify"));
          function g(I, L) {
            var z = (0, c.default)(I);
            return z ? z.mime : L ? n.getType(L) : null;
          }
          function h(I) {
            return I._exif && I._exif.tags && I._exif.tags.Orientation || 1;
          }
          function m(I) {
            var L = I.getWidth(), z = I.getHeight();
            switch (h(I)) {
              case 1:
                return null;
              case 2:
                return function(U, J) {
                  return [L - U - 1, J];
                };
              case 3:
                return function(U, J) {
                  return [L - U - 1, z - J - 1];
                };
              case 4:
                return function(U, J) {
                  return [U, z - J - 1];
                };
              case 5:
                return function(U, J) {
                  return [J, U];
                };
              case 6:
                return function(U, J) {
                  return [J, z - U - 1];
                };
              case 7:
                return function(U, J) {
                  return [L - J - 1, z - U - 1];
                };
              case 8:
                return function(U, J) {
                  return [L - J - 1, U];
                };
              default:
                return null;
            }
          }
          function s(I, L, z, U) {
            for (var J = I.bitmap.data, F = I.bitmap.width, oe = M.alloc(J.length), ee = 0; ee < L; ee++)
              for (var ie = 0; ie < z; ie++) {
                var W = U(ee, ie), Q = (0, E.default)(W, 2), de = Q[0], we = Q[1], ke = L * ie + ee << 2, Me = F * we + de << 2, fe = J.readUInt32BE(Me);
                oe.writeUInt32BE(fe, ke);
              }
            I.bitmap.data = oe, I.bitmap.width = L, I.bitmap.height = z;
          }
          function b(I) {
            if (!(h(I) < 2)) {
              var L = m(I), z = h(I) > 4, U = z ? I.bitmap.height : I.bitmap.width, J = z ? I.bitmap.width : I.bitmap.height;
              s(I, U, J, L);
            }
          }
          function S(I, L, z) {
            var U = g(I, L);
            if (typeof U != "string")
              return z(new Error("Could not find MIME for Buffer <" + L + ">"));
            this._originalMime = U.toLowerCase();
            try {
              var J = this.getMIME();
              if (this.constructor.decoders[J])
                this.bitmap = this.constructor.decoders[J](I);
              else
                return l.throwError.call(this, "Unsupported MIME type: " + J, z);
            } catch (F) {
              return z.call(this, F, this);
            }
            try {
              this._exif = u.default.create(I).parse(), b(this);
            } catch {
            }
            return z.call(this, null, this), this;
          }
          function o(I, L) {
            return new I(L.bitmap.width, L.bitmap.height, L._background).composite(L, 0, 0).bitmap;
          }
          function A(I, L) {
            if (I === a.AUTO && (I = this.getMIME()), typeof I != "string")
              return l.throwError.call(this, "mime must be a string", L);
            if (typeof L != "function")
              return l.throwError.call(this, "cb must be a function", L);
            if (I = I.toLowerCase(), this._rgba && this.constructor.hasAlpha[I] ? this.bitmap.data = M.from(this.bitmap.data) : this.bitmap.data = o(this.constructor, this).data, this.constructor.encoders[I]) {
              var z = this.constructor.encoders[I](this);
              L.call(this, null, z);
            } else
              L.call(this, "Unsupported MIME type: " + I);
            return this;
          }
          function T(I) {
            return (0, d.default)(A, this, I);
          }
        }).call(this, k("buffer").Buffer);
      }, { "../constants": 192, "./mime": 197, "./promisify": 198, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/slicedToArray": 19, "@jimp/utils": 235, buffer: 48, "exif-parser": 53, "file-type": 62 }], 197: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.getExtension = _.getType = _.addType = void 0;
        var M = {}, x = function(l) {
          return Object.entries(M).find(function(a) {
            return a[1].includes(l);
          }) || [];
        }, y = function(l, a) {
          M[l] = a;
        };
        _.addType = y;
        var E = function(l) {
          var a = l.split("/").slice(-1), n = a[a.length - 1].split(".").pop(), d = x(n);
          return d[0];
        };
        _.getType = E;
        var c = function(l) {
          return (M[l.toLowerCase()] || [])[0];
        };
        _.getExtension = c;
      }, {}], 198: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = function(E, c) {
          for (var u = arguments.length, l = new Array(u > 2 ? u - 2 : 0), a = 2; a < u; a++)
            l[a - 2] = arguments[a];
          return new Promise(function(n, d) {
            l.push(function(g, h) {
              g && d(g), n(h);
            }), E.bind(c).apply(void 0, l);
          });
        }, x = M;
        _.default = x, Z.exports = _.default;
      }, {}], 199: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireWildcard"), x = k("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = n;
        var y = x(k("@babel/runtime/helpers/toConsumableArray")), E = x(k("@babel/runtime/helpers/defineProperty")), c = x(k("@babel/runtime/helpers/slicedToArray")), u = M(k("@jimp/core"));
        function l(d, g) {
          var h = Object.keys(d);
          if (Object.getOwnPropertySymbols) {
            var m = Object.getOwnPropertySymbols(d);
            g && (m = m.filter(function(s) {
              return Object.getOwnPropertyDescriptor(d, s).enumerable;
            })), h.push.apply(h, m);
          }
          return h;
        }
        function a(d) {
          for (var g = 1; g < arguments.length; g++) {
            var h = arguments[g] != null ? arguments[g] : {};
            g % 2 ? l(h, !0).forEach(function(m) {
              (0, E.default)(d, m, h[m]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(d, Object.getOwnPropertyDescriptors(h)) : l(h).forEach(function(m) {
              Object.defineProperty(d, m, Object.getOwnPropertyDescriptor(h, m));
            });
          }
          return d;
        }
        function n(d) {
          var g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : u.default, h = {
            hasAlpha: {},
            encoders: {},
            decoders: {},
            class: {},
            constants: {}
          };
          function m(S) {
            Object.entries(S).forEach(function(o) {
              var A = (0, c.default)(o, 2), T = A[0], I = A[1];
              h[T] = a({}, h[T], {}, I);
            });
          }
          function s(S) {
            var o = S();
            Array.isArray(o.mime) ? u.addType.apply(void 0, (0, y.default)(o.mime)) : Object.entries(o.mime).forEach(function(A) {
              return u.addType.apply(void 0, (0, y.default)(A));
            }), delete o.mime, m(o);
          }
          function b(S) {
            var o = S(u.jimpEvChange) || {};
            !o.class && !o.constants ? m({
              class: o
            }) : m(o);
          }
          return d.types && (d.types.forEach(s), g.decoders = a({}, g.decoders, {}, h.decoders), g.encoders = a({}, g.encoders, {}, h.encoders), g.hasAlpha = a({}, g.hasAlpha, {}, h.hasAlpha)), d.plugins && d.plugins.forEach(b), (0, u.addJimpMethods)(h.class, g), (0, u.addConstants)(h.constants, g), u.default;
        }
        Z.exports = _.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/slicedToArray": 19, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/core": 193 }], 200: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var x = M(k("@jimp/custom")), y = M(k("@jimp/types")), E = M(k("@jimp/plugins")), c = (0, x.default)({
          types: [y.default],
          plugins: [E.default]
        });
        _.default = c, Z.exports = _.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/custom": 199, "@jimp/plugins": 228, "@jimp/types": 234 }], 201: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var x = M(k("@babel/runtime/helpers/typeof")), y = k("@jimp/utils"), E = function() {
          return {
            /**
             * Blits a source image on to this image
             * @param {Jimp} src the source Jimp instance
             * @param {number} x the x position to blit the image
             * @param {number} y the y position to blit the image
             * @param {number} srcx (optional) the x position from which to crop the source image
             * @param {number} srcy (optional) the y position from which to crop the source image
             * @param {number} srcw (optional) the width to which to crop the source image
             * @param {number} srch (optional) the height to which to crop the source image
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            blit: function(l, a, n, d, g, h, m, s) {
              if (!(l instanceof this.constructor))
                return y.throwError.call(this, "The source must be a Jimp image", s);
              if (typeof a != "number" || typeof n != "number")
                return y.throwError.call(this, "x and y must be numbers", s);
              if (typeof d == "function")
                s = d, d = 0, g = 0, h = l.bitmap.width, m = l.bitmap.height;
              else if ((0, x.default)(d) === (0, x.default)(g) && (0, x.default)(g) === (0, x.default)(h) && (0, x.default)(h) === (0, x.default)(m))
                d = d || 0, g = g || 0, h = h || l.bitmap.width, m = m || l.bitmap.height;
              else
                return y.throwError.call(this, "srcx, srcy, srcw, srch must be numbers", s);
              a = Math.round(a), n = Math.round(n), d = Math.round(d), g = Math.round(g), h = Math.round(h), m = Math.round(m);
              var b = this.bitmap.width, S = this.bitmap.height, o = this;
              return l.scanQuiet(d, g, h, m, function(A, T, I) {
                var L = a + A - d, z = n + T - g;
                if (L >= 0 && z >= 0 && b - L > 0 && S - z > 0) {
                  var U = o.getPixelIndex(L, z), J = {
                    r: this.bitmap.data[I],
                    g: this.bitmap.data[I + 1],
                    b: this.bitmap.data[I + 2],
                    a: this.bitmap.data[I + 3]
                  }, F = {
                    r: o.bitmap.data[U],
                    g: o.bitmap.data[U + 1],
                    b: o.bitmap.data[U + 2],
                    a: o.bitmap.data[U + 3]
                  };
                  o.bitmap.data[U] = (J.a * (J.r - F.r) - F.r + 255 >> 8) + F.r, o.bitmap.data[U + 1] = (J.a * (J.g - F.g) - F.g + 255 >> 8) + F.g, o.bitmap.data[U + 2] = (J.a * (J.b - F.b) - F.b + 255 >> 8) + F.b, o.bitmap.data[U + 3] = this.constructor.limit255(F.a + J.a);
                }
              }), (0, y.isNodePattern)(s) && s.call(this, null, this), this;
            }
          };
        };
        _.default = E, Z.exports = _.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235 }], 202: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.shgTable = _.mulTable = void 0;
        var M = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
        _.mulTable = M;
        var x = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
        _.shgTable = x;
      }, {}], 203: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils"), x = k("./blur-tables"), y = function() {
          return {
            /**
             * A fast blur algorithm that produces similar effect to a Gaussian blur - but MUCH quicker
             * @param {number} r the pixel radius of the blur
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            blur: function(u, l) {
              if (typeof u != "number") return M.throwError.call(this, "r must be a number", l);
              if (u < 1) return M.throwError.call(this, "r must be greater than 0", l);
              for (var a, n, d, g, h, m, s, b, S, o, A, T, I, L, z = this.bitmap.width - 1, U = this.bitmap.height - 1, J = u + 1, F = x.mulTable[u], oe = x.shgTable[u], ee = [], ie = [], W = [], Q = [], de = [], we = [], ke = 2; ke-- > 0; ) {
                for (T = 0, I = 0, m = 0; m < this.bitmap.height; m++) {
                  for (a = this.bitmap.data[I] * J, n = this.bitmap.data[I + 1] * J, d = this.bitmap.data[I + 2] * J, g = this.bitmap.data[I + 3] * J, s = 1; s <= u; s++)
                    b = I + ((s > z ? z : s) << 2), a += this.bitmap.data[b++], n += this.bitmap.data[b++], d += this.bitmap.data[b++], g += this.bitmap.data[b];
                  for (h = 0; h < this.bitmap.width; h++)
                    ee[T] = a, ie[T] = n, W[T] = d, Q[T] = g, m === 0 && (de[h] = ((b = h + J) < z ? b : z) << 2, we[h] = (b = h - u) > 0 ? b << 2 : 0), S = I + de[h], o = I + we[h], a += this.bitmap.data[S++] - this.bitmap.data[o++], n += this.bitmap.data[S++] - this.bitmap.data[o++], d += this.bitmap.data[S++] - this.bitmap.data[o++], g += this.bitmap.data[S] - this.bitmap.data[o], T++;
                  I += this.bitmap.width << 2;
                }
                for (h = 0; h < this.bitmap.width; h++) {
                  for (A = h, a = ee[A] * J, n = ie[A] * J, d = W[A] * J, g = Q[A] * J, s = 1; s <= u; s++)
                    A += s > U ? 0 : this.bitmap.width, a += ee[A], n += ie[A], d += W[A], g += Q[A];
                  for (T = h << 2, m = 0; m < this.bitmap.height; m++)
                    L = g * F >>> oe, this.bitmap.data[T + 3] = L, L > 255 && (this.bitmap.data[T + 3] = 255), L > 0 ? (L = 255 / L, this.bitmap.data[T] = (a * F >>> oe) * L, this.bitmap.data[T + 1] = (n * F >>> oe) * L, this.bitmap.data[T + 2] = (d * F >>> oe) * L) : (this.bitmap.data[T + 2] = 0, this.bitmap.data[T + 1] = 0, this.bitmap.data[T] = 0), h === 0 && (de[m] = ((b = m + J) < U ? b : U) * this.bitmap.width, we[m] = (b = m - u) > 0 ? b * this.bitmap.width : 0), S = h + de[m], o = h + we[m], a += ee[S] - ee[o], n += ie[S] - ie[o], d += W[S] - W[o], g += Q[S] - Q[o], T += this.bitmap.width << 2;
                }
              }
              return (0, M.isNodePattern)(l) && l.call(this, null, this), this;
            }
          };
        };
        _.default = y, Z.exports = _.default;
      }, { "./blur-tables": 202, "@jimp/utils": 235 }], 204: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils"), x = function() {
          return {
            circle: function() {
              var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = arguments.length > 1 ? arguments[1] : void 0;
              typeof c == "function" && (u = c, c = {});
              var l = c.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2, a = {
                x: typeof c.x == "number" ? c.x : this.bitmap.width / 2,
                y: typeof c.y == "number" ? c.y : this.bitmap.height / 2
              };
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(n, d, g) {
                var h = Math.sqrt(Math.pow(n - a.x, 2) + Math.pow(d - a.y, 2));
                l - h <= 0 ? this.bitmap.data[g + 3] = 0 : l - h < 1 && (this.bitmap.data[g + 3] = 255 * (l - h));
              }), (0, M.isNodePattern)(u) && u.call(this, null, this), this;
            }
          };
        };
        _.default = x, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 205: [function(k, Z, _) {
        (function(M) {
          var x = k("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(_, "__esModule", {
            value: !0
          }), _.default = void 0;
          var y = x(k("@babel/runtime/helpers/toConsumableArray")), E = x(k("tinycolor2")), c = k("@jimp/utils");
          function u(h, m, s, b) {
            for (var S = [0, 0, 0], o = (m.length - 1) / 2, A = 0; A < m.length; A += 1)
              for (var T = 0; T < m[A].length; T += 1) {
                var I = h.getPixelIndex(s + A - o, b + T - o);
                S[0] += h.bitmap.data[I] * m[A][T], S[1] += h.bitmap.data[I + 1] * m[A][T], S[2] += h.bitmap.data[I + 2] * m[A][T];
              }
            return S;
          }
          var l = function(m) {
            return typeof m < "u" && m !== null;
          };
          function a(h) {
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(m, s, b) {
              var S = parseInt(0.2126 * this.bitmap.data[b] + 0.7152 * this.bitmap.data[b + 1] + 0.0722 * this.bitmap.data[b + 2], 10);
              this.bitmap.data[b] = S, this.bitmap.data[b + 1] = S, this.bitmap.data[b + 2] = S;
            }), (0, c.isNodePattern)(h) && h.call(this, null, this), this;
          }
          function n(h, m) {
            var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50;
            return {
              r: (m.r - h.r) * (s / 100) + h.r,
              g: (m.g - h.g) * (s / 100) + h.g,
              b: (m.b - h.b) * (s / 100) + h.b
            };
          }
          function d(h, m) {
            var s = this;
            return !h || !Array.isArray(h) ? c.throwError.call(this, "actions must be an array", m) : (h = h.map(function(b) {
              return (b.apply === "xor" || b.apply === "mix") && (b.params[0] = (0, E.default)(b.params[0]).toRgb()), b;
            }), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(b, S, o) {
              var A = {
                r: s.bitmap.data[o],
                g: s.bitmap.data[o + 1],
                b: s.bitmap.data[o + 2]
              }, T = function(L, z) {
                return s.constructor.limit255(A[L] + z);
              };
              h.forEach(function(I) {
                if (I.apply === "mix")
                  A = n(A, I.params[0], I.params[1]);
                else if (I.apply === "tint")
                  A = n(A, {
                    r: 255,
                    g: 255,
                    b: 255
                  }, I.params[0]);
                else if (I.apply === "shade")
                  A = n(A, {
                    r: 0,
                    g: 0,
                    b: 0
                  }, I.params[0]);
                else if (I.apply === "xor")
                  A = {
                    r: A.r ^ I.params[0].r,
                    g: A.g ^ I.params[0].g,
                    b: A.b ^ I.params[0].b
                  };
                else if (I.apply === "red")
                  A.r = T("r", I.params[0]);
                else if (I.apply === "green")
                  A.g = T("g", I.params[0]);
                else if (I.apply === "blue")
                  A.b = T("b", I.params[0]);
                else {
                  var L;
                  if (I.apply === "hue" && (I.apply = "spin"), A = (0, E.default)(A), !A[I.apply])
                    return c.throwError.call(s, "action " + I.apply + " not supported", m);
                  A = (L = A)[I.apply].apply(L, (0, y.default)(I.params)).toRgb();
                }
              }), s.bitmap.data[o] = A.r, s.bitmap.data[o + 1] = A.g, s.bitmap.data[o + 2] = A.b;
            }), (0, c.isNodePattern)(m) && m.call(this, null, this), this);
          }
          var g = function() {
            return {
              /**
               * Adjusts the brightness of the image
               * @param {number} val the amount to adjust the brightness, a number between -1 and +1
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              brightness: function(s, b) {
                return typeof s != "number" ? c.throwError.call(this, "val must be numbers", b) : s < -1 || s > 1 ? c.throwError.call(this, "val must be a number between -1 and +1", b) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(S, o, A) {
                  s < 0 ? (this.bitmap.data[A] = this.bitmap.data[A] * (1 + s), this.bitmap.data[A + 1] = this.bitmap.data[A + 1] * (1 + s), this.bitmap.data[A + 2] = this.bitmap.data[A + 2] * (1 + s)) : (this.bitmap.data[A] = this.bitmap.data[A] + (255 - this.bitmap.data[A]) * s, this.bitmap.data[A + 1] = this.bitmap.data[A + 1] + (255 - this.bitmap.data[A + 1]) * s, this.bitmap.data[A + 2] = this.bitmap.data[A + 2] + (255 - this.bitmap.data[A + 2]) * s);
                }), (0, c.isNodePattern)(b) && b.call(this, null, this), this);
              },
              /**
               * Adjusts the contrast of the image
               * @param {number} val the amount to adjust the contrast, a number between -1 and +1
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              contrast: function(s, b) {
                if (typeof s != "number")
                  return c.throwError.call(this, "val must be numbers", b);
                if (s < -1 || s > 1)
                  return c.throwError.call(this, "val must be a number between -1 and +1", b);
                var S = (s + 1) / (1 - s);
                function o(A) {
                  return A = Math.floor(S * (A - 127) + 127), A < 0 ? 0 : A > 255 ? 255 : A;
                }
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(A, T, I) {
                  this.bitmap.data[I] = o(this.bitmap.data[I]), this.bitmap.data[I + 1] = o(this.bitmap.data[I + 1]), this.bitmap.data[I + 2] = o(this.bitmap.data[I + 2]);
                }), (0, c.isNodePattern)(b) && b.call(this, null, this), this;
              },
              /**
               * Apply a posterize effect
               * @param {number} n the amount to adjust the contrast, minimum threshold is two
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              posterize: function(s, b) {
                return typeof s != "number" ? c.throwError.call(this, "n must be numbers", b) : (s < 2 && (s = 2), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(S, o, A) {
                  this.bitmap.data[A] = Math.floor(this.bitmap.data[A] / 255 * (s - 1)) / (s - 1) * 255, this.bitmap.data[A + 1] = Math.floor(this.bitmap.data[A + 1] / 255 * (s - 1)) / (s - 1) * 255, this.bitmap.data[A + 2] = Math.floor(this.bitmap.data[A + 2] / 255 * (s - 1)) / (s - 1) * 255;
                }), (0, c.isNodePattern)(b) && b.call(this, null, this), this);
              },
              /**
               * Removes colour from the image using ITU Rec 709 luminance values
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              greyscale: a,
              // Alias of greyscale for our American friends
              grayscale: a,
              /**
               * Multiplies the opacity of each pixel by a factor between 0 and 1
               * @param {number} f A number, the factor by which to multiply the opacity of each pixel
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              opacity: function(s, b) {
                return typeof s != "number" ? c.throwError.call(this, "f must be a number", b) : s < 0 || s > 1 ? c.throwError.call(this, "f must be a number from 0 to 1", b) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(S, o, A) {
                  var T = this.bitmap.data[A + 3] * s;
                  this.bitmap.data[A + 3] = T;
                }), (0, c.isNodePattern)(b) && b.call(this, null, this), this);
              },
              /**
               * Applies a sepia tone to the image
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              sepia: function(s) {
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(b, S, o) {
                  var A = this.bitmap.data[o], T = this.bitmap.data[o + 1], I = this.bitmap.data[o + 2];
                  A = A * 0.393 + T * 0.769 + I * 0.189, T = A * 0.349 + T * 0.686 + I * 0.168, I = A * 0.272 + T * 0.534 + I * 0.131, this.bitmap.data[o] = A < 255 ? A : 255, this.bitmap.data[o + 1] = T < 255 ? T : 255, this.bitmap.data[o + 2] = I < 255 ? I : 255;
                }), (0, c.isNodePattern)(s) && s.call(this, null, this), this;
              },
              /**
               * Fades each pixel by a factor between 0 and 1
               * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              fade: function(s, b) {
                return typeof s != "number" ? c.throwError.call(this, "f must be a number", b) : s < 0 || s > 1 ? c.throwError.call(this, "f must be a number from 0 to 1", b) : (this.opacity(1 - s), (0, c.isNodePattern)(b) && b.call(this, null, this), this);
              },
              /**
               * Adds each element of the image to its local neighbors, weighted by the kernel
               * @param {array} kernel a matrix to weight the neighbors sum
               * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              convolution: function(s, b, S) {
                typeof b == "function" && typeof S > "u" && (S = b, b = null), b || (b = this.constructor.EDGE_EXTEND);
                var o = M.from(this.bitmap.data), A = s.length, T = s[0].length, I = Math.floor(A / 2), L = Math.floor(T / 2), z = -I, U = -L, J, F, oe, ee, ie, W, Q, de, we, ke;
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(Me, fe, xe) {
                  ee = 0, oe = 0, F = 0;
                  for (var Ee = z; Ee <= I; Ee++)
                    for (var Pe = U; Pe <= L; Pe++)
                      de = Me + Pe, we = fe + Ee, J = s[Ee + I][Pe + L], ke = this.getPixelIndex(de, we, b), ke === -1 ? (Q = 0, W = 0, ie = 0) : (ie = this.bitmap.data[ke + 0], W = this.bitmap.data[ke + 1], Q = this.bitmap.data[ke + 2]), F += J * ie, oe += J * W, ee += J * Q;
                  F < 0 && (F = 0), oe < 0 && (oe = 0), ee < 0 && (ee = 0), F > 255 && (F = 255), oe > 255 && (oe = 255), ee > 255 && (ee = 255), o[xe + 0] = F, o[xe + 1] = oe, o[xe + 2] = ee;
                }), this.bitmap.data = o, (0, c.isNodePattern)(S) && S.call(this, null, this), this;
              },
              /**
               * Set the alpha channel on every pixel to fully opaque
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              opaque: function(s) {
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(b, S, o) {
                  this.bitmap.data[o + 3] = 255;
                }), (0, c.isNodePattern)(s) && s.call(this, null, this), this;
              },
              /**
               * Pixelates the image or a region
               * @param {number} size the size of the pixels
               * @param {number} x (optional) the x position of the region to pixelate
               * @param {number} y (optional) the y position of the region to pixelate
               * @param {number} w (optional) the width of the region to pixelate
               * @param {number} h (optional) the height of the region to pixelate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              pixelate: function(s, b, S, o, A, T) {
                if (typeof b == "function")
                  T = b, A = null, o = null, S = null, b = null;
                else {
                  if (typeof s != "number")
                    return c.throwError.call(this, "size must be a number", T);
                  if (l(b) && typeof b != "number")
                    return c.throwError.call(this, "x must be a number", T);
                  if (l(S) && typeof S != "number")
                    return c.throwError.call(this, "y must be a number", T);
                  if (l(o) && typeof o != "number")
                    return c.throwError.call(this, "w must be a number", T);
                  if (l(A) && typeof A != "number")
                    return c.throwError.call(this, "h must be a number", T);
                }
                var I = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];
                b = b || 0, S = S || 0, o = l(o) ? o : this.bitmap.width - b, A = l(A) ? A : this.bitmap.height - S;
                var L = this.cloneQuiet();
                return this.scanQuiet(b, S, o, A, function(z, U, J) {
                  z = s * Math.floor(z / s), U = s * Math.floor(U / s);
                  var F = u(L, I, z, U);
                  this.bitmap.data[J] = F[0], this.bitmap.data[J + 1] = F[1], this.bitmap.data[J + 2] = F[2];
                }), (0, c.isNodePattern)(T) && T.call(this, null, this), this;
              },
              /**
               * Applies a convolution kernel to the image or a region
               * @param {array} kernel the convolution kernel
               * @param {number} x (optional) the x position of the region to apply convolution to
               * @param {number} y (optional) the y position of the region to apply convolution to
               * @param {number} w (optional) the width of the region to apply convolution to
               * @param {number} h (optional) the height of the region to apply convolution to
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              convolute: function(s, b, S, o, A, T) {
                if (!Array.isArray(s)) return c.throwError.call(this, "the kernel must be an array", T);
                if (typeof b == "function")
                  T = b, b = null, S = null, o = null, A = null;
                else {
                  if (l(b) && typeof b != "number")
                    return c.throwError.call(this, "x must be a number", T);
                  if (l(S) && typeof S != "number")
                    return c.throwError.call(this, "y must be a number", T);
                  if (l(o) && typeof o != "number")
                    return c.throwError.call(this, "w must be a number", T);
                  if (l(A) && typeof A != "number")
                    return c.throwError.call(this, "h must be a number", T);
                }
                var I = (s.length - 1) / 2;
                b = l(b) ? b : I, S = l(S) ? S : I, o = l(o) ? o : this.bitmap.width - b, A = l(A) ? A : this.bitmap.height - S;
                var L = this.cloneQuiet();
                return this.scanQuiet(b, S, o, A, function(z, U, J) {
                  var F = u(L, s, z, U);
                  this.bitmap.data[J] = this.constructor.limit255(F[0]), this.bitmap.data[J + 1] = this.constructor.limit255(F[1]), this.bitmap.data[J + 2] = this.constructor.limit255(F[2]);
                }), (0, c.isNodePattern)(T) && T.call(this, null, this), this;
              },
              /**
               * Apply multiple color modification rules
               * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              color: d,
              colour: d
            };
          };
          _.default = g, Z.exports = _.default;
        }).call(this, k("buffer").Buffer);
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/utils": 235, buffer: 48, tinycolor2: 178 }], 206: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils"), x = function() {
          return {
            contain: function(c, u, l, a, n) {
              if (typeof c != "number" || typeof u != "number")
                return M.throwError.call(this, "w and h must be numbers", n);
              typeof l == "string" && (typeof a == "function" && typeof n > "u" && (n = a), a = l, l = null), typeof l == "function" && (typeof n > "u" && (n = l), a = null, l = null), typeof a == "function" && typeof n > "u" && (n = a, a = null), l = l || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
              var d = l & 7, g = l >> 3;
              if (!(d !== 0 && !(d & d - 1) || g !== 0 && !(g & g - 1)))
                return M.throwError.call(this, "only use one flag per alignment direction", n);
              var h = d >> 1, m = g >> 1, s = c / u > this.bitmap.width / this.bitmap.height ? u / this.bitmap.height : c / this.bitmap.width, b = this.cloneQuiet().scale(s, a);
              return this.resize(c, u, a), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(S, o, A) {
                this.bitmap.data.writeUInt32BE(this._background, A);
              }), this.blit(b, (this.bitmap.width - b.bitmap.width) / 2 * h, (this.bitmap.height - b.bitmap.height) / 2 * m), (0, M.isNodePattern)(n) && n.call(this, null, this), this;
            }
          };
        };
        _.default = x, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 207: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils"), x = function() {
          return {
            cover: function(c, u, l, a, n) {
              if (typeof c != "number" || typeof u != "number")
                return M.throwError.call(this, "w and h must be numbers", n);
              l && typeof l == "function" && typeof n > "u" ? (n = l, l = null, a = null) : typeof a == "function" && typeof n > "u" && (n = a, a = null), l = l || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
              var d = l & 7, g = l >> 3;
              if (!(d !== 0 && !(d & d - 1) || g !== 0 && !(g & g - 1))) return M.throwError.call(this, "only use one flag per alignment direction", n);
              var h = d >> 1, m = g >> 1, s = c / u > this.bitmap.width / this.bitmap.height ? c / this.bitmap.width : u / this.bitmap.height;
              return this.scale(s, a), this.crop((this.bitmap.width - c) / 2 * h, (this.bitmap.height - u) / 2 * m, c, u), (0, M.isNodePattern)(n) && n.call(this, null, this), this;
            }
          };
        };
        _.default = x, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 208: [function(k, Z, _) {
        (function(M) {
          var x = k("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(_, "__esModule", {
            value: !0
          }), _.default = c;
          var y = x(k("@babel/runtime/helpers/typeof")), E = k("@jimp/utils");
          function c(u) {
            return u("crop", function(l, a, n, d, g) {
              if (typeof l != "number" || typeof a != "number") return E.throwError.call(this, "x and y must be numbers", g);
              if (typeof n != "number" || typeof d != "number") return E.throwError.call(this, "w and h must be numbers", g);
              if (l = Math.round(l), a = Math.round(a), n = Math.round(n), d = Math.round(d), l === 0 && n === this.bitmap.width) {
                var h = n * a + l << 2, m = h + d * n << 2;
                this.bitmap.data = this.bitmap.data.slice(h, m);
              } else {
                var s = M.allocUnsafe(n * d * 4), b = 0;
                this.scanQuiet(l, a, n, d, function(S, o, A) {
                  var T = this.bitmap.data.readUInt32BE(A, !0);
                  s.writeUInt32BE(T, b, !0), b += 4;
                }), this.bitmap.data = s;
              }
              return this.bitmap.width = n, this.bitmap.height = d, (0, E.isNodePattern)(g) && g.call(this, null, this), this;
            }), {
              class: {
                /**
                 * Autocrop same color borders from this image
                 * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)
                 * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)
                 * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)
                 * @returns {Jimp} this for chaining of methods
                 */
                autocrop: function() {
                  for (var a = this.bitmap.width, n = this.bitmap.height, d = 1, g, h = 0, m = 2e-4, s = !0, b = !1, S = arguments.length, o = new Array(S), A = 0; A < S; A++)
                    o[A] = arguments[A];
                  for (var T = 0, I = o.length; T < I; T++)
                    if (typeof o[T] == "number" && (m = o[T]), typeof o[T] == "boolean" && (s = o[T]), typeof o[T] == "function" && (g = o[T]), (0, y.default)(o[T]) === "object") {
                      var L = o[T];
                      typeof L.tolerance < "u" && (m = L.tolerance), typeof L.cropOnlyFrames < "u" && (s = L.cropOnlyFrames), typeof L.cropSymmetric < "u" && (b = L.cropSymmetric), typeof L.leaveBorder < "u" && (h = L.leaveBorder);
                    }
                  var z = this.getPixelColor(0, 0), U = this.constructor.intToRGBA(z), J = 0, F = 0, oe = 0, ee = 0;
                  z = this.getPixelColor(0, 0);
                  e: for (var ie = 0; ie < n - d; ie++) {
                    for (var W = 0; W < a; W++) {
                      var Q = this.getPixelColor(W, ie), de = this.constructor.intToRGBA(Q);
                      if (this.constructor.colorDiff(U, de) > m)
                        break e;
                    }
                    J++;
                  }
                  z = this.getPixelColor(a, 0);
                  e: for (var we = 0; we < a - d; we++) {
                    for (var ke = 0 + J; ke < n; ke++) {
                      var Me = this.getPixelColor(we, ke), fe = this.constructor.intToRGBA(Me);
                      if (this.constructor.colorDiff(U, fe) > m)
                        break e;
                    }
                    F++;
                  }
                  z = this.getPixelColor(0, n);
                  e: for (var xe = n - 1; xe >= J + d; xe--) {
                    for (var Ee = a - F - 1; Ee >= 0; Ee--) {
                      var Pe = this.getPixelColor(Ee, xe), Ue = this.constructor.intToRGBA(Pe);
                      if (this.constructor.colorDiff(U, Ue) > m)
                        break e;
                    }
                    oe++;
                  }
                  z = this.getPixelColor(a, n);
                  e: for (var He = a - 1; He >= 0 + F + d; He--) {
                    for (var We = n - 1; We >= 0 + J; We--) {
                      var Ze = this.getPixelColor(He, We), $e = this.constructor.intToRGBA(Ze);
                      if (this.constructor.colorDiff(U, $e) > m)
                        break e;
                    }
                    ee++;
                  }
                  var Ve = !1;
                  if (ee -= h, F -= h, J -= h, oe -= h, b) {
                    var Ge = Math.min(F, ee), Ie = Math.min(J, oe);
                    ee = Ge, F = Ge, J = Ie, oe = Ie;
                  }
                  ee = ee >= 0 ? ee : 0, F = F >= 0 ? F : 0, J = J >= 0 ? J : 0, oe = oe >= 0 ? oe : 0;
                  var De = a - (ee + F), Ne = n - (oe + J);
                  return s ? Ve = F !== 0 && J !== 0 && ee !== 0 && oe !== 0 : Ve = F !== 0 || J !== 0 || ee !== 0 || oe !== 0, Ve && this.crop(F, J, De, Ne), (0, E.isNodePattern)(g) && g.call(this, null, this), this;
                }
              }
            };
          }
          Z.exports = _.default;
        }).call(this, k("buffer").Buffer);
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, buffer: 48 }], 209: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var x = M(k("@babel/runtime/helpers/typeof")), y = k("@jimp/utils"), E = function() {
          return {
            displace: function(l, a, n) {
              if ((0, x.default)(l) !== "object" || l.constructor !== this.constructor)
                return y.throwError.call(this, "The source must be a Jimp image", n);
              if (typeof a != "number")
                return y.throwError.call(this, "factor must be a number", n);
              var d = this.cloneQuiet();
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(g, h, m) {
                var s = l.bitmap.data[m] / 256 * a;
                s = Math.round(s);
                var b = this.getPixelIndex(g + s, h);
                this.bitmap.data[b] = d.bitmap.data[m], this.bitmap.data[b + 1] = d.bitmap.data[m + 1], this.bitmap.data[b + 2] = d.bitmap.data[m + 2];
              }), (0, y.isNodePattern)(n) && n.call(this, null, this), this;
            }
          };
        };
        _.default = E, Z.exports = _.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235 }], 210: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils");
        function x(E) {
          var c = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
          return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(u, l, a) {
            var n = ((l & 3) << 2) + u % 4, d = c[n];
            this.bitmap.data[a] = Math.min(this.bitmap.data[a] + d, 255), this.bitmap.data[a + 1] = Math.min(this.bitmap.data[a + 1] + d, 255), this.bitmap.data[a + 2] = Math.min(this.bitmap.data[a + 2] + d, 255);
          }), (0, M.isNodePattern)(E) && E.call(this, null, this), this;
        }
        var y = function() {
          return {
            dither565: x,
            dither16: x
          };
        };
        _.default = y, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 211: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils"), x = function() {
          return {
            fisheye: function() {
              var c = this, u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
                r: 2.5
              }, l = arguments.length > 1 ? arguments[1] : void 0;
              typeof u == "function" && (l = u, u = {
                r: 2.5
              });
              var a = this.cloneQuiet(), n = a.bitmap, d = n.width, g = n.height;
              return a.scanQuiet(0, 0, d, g, function(h, m) {
                var s = h / d, b = m / g, S = Math.sqrt(Math.pow(s - 0.5, 2) + Math.pow(b - 0.5, 2)), o = 2 * Math.pow(S, u.r), A = (s - 0.5) / S, T = (b - 0.5) / S, I = Math.round((o * A + 0.5) * d), L = Math.round((o * T + 0.5) * g), z = a.getPixelColor(I, L);
                c.setPixelColor(z, h, m);
              }), this.setPixelColor(a.getPixelColor(d / 2, g / 2), d / 2, g / 2), (0, M.isNodePattern)(l) && l.call(this, null, this), this;
            }
          };
        };
        _.default = x, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 212: [function(k, Z, _) {
        (function(M) {
          Object.defineProperty(_, "__esModule", {
            value: !0
          }), _.default = void 0;
          var x = k("@jimp/utils");
          function y(c, u, l) {
            if (typeof c != "boolean" || typeof u != "boolean") return x.throwError.call(this, "horizontal and vertical must be Booleans", l);
            var a = M.alloc(this.bitmap.data.length);
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(n, d, g) {
              var h = c ? this.bitmap.width - 1 - n : n, m = u ? this.bitmap.height - 1 - d : d, s = this.bitmap.width * m + h << 2, b = this.bitmap.data.readUInt32BE(g);
              a.writeUInt32BE(b, s);
            }), this.bitmap.data = M.from(a), (0, x.isNodePattern)(l) && l.call(this, null, this), this;
          }
          var E = function() {
            return {
              flip: y,
              mirror: y
            };
          };
          _.default = E, Z.exports = _.default;
        }).call(this, k("buffer").Buffer);
      }, { "@jimp/utils": 235, buffer: 48 }], 213: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils"), x = function() {
          return {
            gaussian: function(c, u) {
              if (typeof c != "number")
                return M.throwError.call(this, "r must be a number", u);
              if (c < 1)
                return M.throwError.call(this, "r must be greater than 0", u);
              for (var l = Math.ceil(c * 2.57), a = l * 2 + 1, n = c * c * 2, d = n * Math.PI, g = [], h = 0; h < a; h++) {
                g[h] = [];
                for (var m = 0; m < a; m++) {
                  var s = Math.pow(m - l, 2) + Math.pow(h - l, 2);
                  g[h][m] = Math.exp(-s / n) / d;
                }
              }
              for (var b = 0; b < this.bitmap.height; b++)
                for (var S = 0; S < this.bitmap.width; S++)
                  for (var o = 0, A = 0, T = 0, I = 0, L = 0, z = 0; z < a; z++) {
                    for (var U = 0; U < a; U++) {
                      var J = Math.min(this.bitmap.width - 1, Math.max(0, U + S - l)), F = Math.min(this.bitmap.height - 1, Math.max(0, z + b - l)), oe = g[z][U], ee = F * this.bitmap.width + J << 2;
                      o += this.bitmap.data[ee] * oe, A += this.bitmap.data[ee + 1] * oe, T += this.bitmap.data[ee + 2] * oe, I += this.bitmap.data[ee + 3] * oe, L += oe;
                    }
                    var ie = b * this.bitmap.width + S << 2;
                    this.bitmap.data[ie] = Math.round(o / L), this.bitmap.data[ie + 1] = Math.round(A / L), this.bitmap.data[ie + 2] = Math.round(T / L), this.bitmap.data[ie + 3] = Math.round(I / L);
                  }
              return (0, M.isNodePattern)(u) && u.call(this, null, this), this;
            }
          };
        };
        _.default = x, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 214: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils"), x = function() {
          return {
            invert: function(c) {
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(u, l, a) {
                this.bitmap.data[a] = 255 - this.bitmap.data[a], this.bitmap.data[a + 1] = 255 - this.bitmap.data[a + 1], this.bitmap.data[a + 2] = 255 - this.bitmap.data[a + 2];
              }), (0, M.isNodePattern)(c) && c.call(this, null, this), this;
            }
          };
        };
        _.default = x, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 215: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils"), x = function() {
          return {
            mask: function(c) {
              var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, a = arguments.length > 3 ? arguments[3] : void 0;
              if (!(c instanceof this.constructor))
                return M.throwError.call(this, "The source must be a Jimp image", a);
              if (typeof u != "number" || typeof l != "number")
                return M.throwError.call(this, "x and y must be numbers", a);
              u = Math.round(u), l = Math.round(l);
              var n = this.bitmap.width, d = this.bitmap.height, g = this;
              return c.scanQuiet(0, 0, c.bitmap.width, c.bitmap.height, function(h, m, s) {
                var b = u + h, S = l + m;
                if (b >= 0 && S >= 0 && b < n && S < d) {
                  var o = g.getPixelIndex(b, S), A = this.bitmap.data, T = (A[s + 0] + A[s + 1] + A[s + 2]) / 3;
                  g.bitmap.data[o + 3] *= T / 255;
                }
              }), (0, M.isNodePattern)(a) && a.call(this, null, this), this;
            }
          };
        };
        _.default = x, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 216: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils");
        function x() {
          var u = {
            r: new Array(256).fill(0),
            g: new Array(256).fill(0),
            b: new Array(256).fill(0)
          };
          return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(l, a, n) {
            u.r[this.bitmap.data[n + 0]]++, u.g[this.bitmap.data[n + 1]]++, u.b[this.bitmap.data[n + 2]]++;
          }), u;
        }
        var y = function(l, a, n) {
          return (l - a) * 255 / (n - a);
        }, E = function(l) {
          return [l.findIndex(function(a) {
            return a > 0;
          }), 255 - l.slice().reverse().findIndex(function(a) {
            return a > 0;
          })];
        }, c = function() {
          return {
            normalize: function(a) {
              var n = x.call(this), d = {
                r: E(n.r),
                g: E(n.g),
                b: E(n.b)
              };
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(g, h, m) {
                var s = this.bitmap.data[m + 0], b = this.bitmap.data[m + 1], S = this.bitmap.data[m + 2];
                this.bitmap.data[m + 0] = y(s, d.r[0], d.r[1]), this.bitmap.data[m + 1] = y(b, d.g[0], d.g[1]), this.bitmap.data[m + 2] = y(S, d.b[0], d.b[1]);
              }), (0, M.isNodePattern)(a) && a.call(this, null, this), this;
            }
          };
        };
        _.default = c, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 217: [function(k, Z, _) {
        (function(M) {
          var x = k("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(_, "__esModule", {
            value: !0
          }), _.default = void 0;
          var y = x(k("@babel/runtime/helpers/typeof")), E = x(k("@babel/runtime/helpers/toConsumableArray")), c = x(k("path")), u = x(k("load-bmfont")), l = k("@jimp/utils"), a = k("./measure-text");
          function n(S, o, A, T, I) {
            return I === S.HORIZONTAL_ALIGN_LEFT ? 0 : I === S.HORIZONTAL_ALIGN_CENTER ? (T - (0, a.measureText)(o, A)) / 2 : T - (0, a.measureText)(o, A);
          }
          function d(S, o, A, T, I) {
            if (I.width > 0 && I.height > 0) {
              var L = o.pages[I.page];
              S.blit(L, A + I.xoffset, T + I.yoffset, I.x, I.y, I.width, I.height);
            }
            return S;
          }
          function g(S, o, A, T, I) {
            for (var L = 0; L < T.length; L++) {
              var z = void 0;
              S.chars[T[L]] ? z = T[L] : /\s/.test(T[L]) ? z = "" : z = "?";
              var U = S.chars[z] || {}, J = S.kernings[z];
              d(this, S, o, A, U || {});
              var F = J && J[T[L + 1]] ? J[T[L + 1]] : 0;
              o += F + (U.xadvance || I);
            }
          }
          function h(S, o, A) {
            var T = o.split(" "), I = [], L = [], z = 0;
            return T.forEach(function(U) {
              var J = [].concat((0, E.default)(L), [U]).join(" "), F = (0, a.measureText)(S, J);
              F <= A ? (F > z && (z = F), L.push(U)) : (I.push(L), L = [U]);
            }), I.push(L), {
              lines: I,
              longestLine: z
            };
          }
          function m(S, o, A) {
            var T = A.map(function(I) {
              return S.read(o + "/" + I);
            });
            return Promise.all(T);
          }
          var s = "browser/lib/", b = function() {
            return {
              constants: {
                measureText: a.measureText,
                measureTextHeight: a.measureTextHeight,
                FONT_SANS_8_BLACK: c.default.join(s, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"),
                FONT_SANS_10_BLACK: c.default.join(s, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"),
                FONT_SANS_12_BLACK: c.default.join(s, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"),
                FONT_SANS_14_BLACK: c.default.join(s, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"),
                FONT_SANS_16_BLACK: c.default.join(s, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"),
                FONT_SANS_32_BLACK: c.default.join(s, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"),
                FONT_SANS_64_BLACK: c.default.join(s, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"),
                FONT_SANS_128_BLACK: c.default.join(s, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"),
                FONT_SANS_8_WHITE: c.default.join(s, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"),
                FONT_SANS_16_WHITE: c.default.join(s, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"),
                FONT_SANS_32_WHITE: c.default.join(s, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"),
                FONT_SANS_64_WHITE: c.default.join(s, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"),
                FONT_SANS_128_WHITE: c.default.join(s, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"),
                /**
                 * Loads a bitmap font from a file
                 * @param {string} file the file path of a .fnt file
                 * @param {function(Error, Jimp)} cb (optional) a function to call when the font is loaded
                 * @returns {Promise} a promise
                 */
                loadFont: function(A, T) {
                  var I = this;
                  return typeof A != "string" ? l.throwError.call(this, "file must be a string", T) : new Promise(function(L, z) {
                    T = T || function(U, J) {
                      U ? z(U) : L(J);
                    }, (0, u.default)(A, function(U, J) {
                      var F = {}, oe = {};
                      if (U)
                        return l.throwError.call(I, U, T);
                      for (var ee = 0; ee < J.chars.length; ee++)
                        F[String.fromCharCode(J.chars[ee].id)] = J.chars[ee];
                      for (var ie = 0; ie < J.kernings.length; ie++) {
                        var W = String.fromCharCode(J.kernings[ie].first);
                        oe[W] = oe[W] || {}, oe[W][String.fromCharCode(J.kernings[ie].second)] = J.kernings[ie].amount;
                      }
                      m(I, c.default.dirname(A), J.pages).then(function(Q) {
                        T(null, {
                          chars: F,
                          kernings: oe,
                          pages: Q,
                          common: J.common,
                          info: J.info
                        });
                      });
                    });
                  });
                }
              },
              class: {
                /**
                 * Draws a text on a image on a given boundary
                 * @param {Jimp} font a bitmap font loaded from `Jimp.loadFont` command
                 * @param {number} x the x position to start drawing the text
                 * @param {number} y the y position to start drawing the text
                 * @param {any} text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)
                 * @param {number} maxWidth (optional) the boundary width to draw in
                 * @param {number} maxHeight (optional) the boundary height to draw in
                 * @param {function(Error, Jimp)} cb (optional) a function to call when the text is written
                 * @returns {Jimp} this for chaining of methods
                 */
                print: function(A, T, I, L, z, U, J) {
                  var F = this;
                  if (typeof z == "function" && typeof J > "u" && (J = z, z = 1 / 0), typeof z > "u" && (z = 1 / 0), typeof U == "function" && typeof J > "u" && (J = U, U = 1 / 0), typeof U > "u" && (U = 1 / 0), (0, y.default)(A) !== "object")
                    return l.throwError.call(this, "font must be a Jimp loadFont", J);
                  if (typeof T != "number" || typeof I != "number" || typeof z != "number")
                    return l.throwError.call(this, "x, y and maxWidth must be numbers", J);
                  if (typeof z != "number")
                    return l.throwError.call(this, "maxWidth must be a number", J);
                  if (typeof U != "number")
                    return l.throwError.call(this, "maxHeight must be a number", J);
                  var oe, ee;
                  if ((0, y.default)(L) === "object" && L.text !== null && L.text !== void 0) {
                    oe = L.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT, ee = L.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;
                    var ie = L;
                    L = ie.text;
                  } else
                    oe = this.constructor.HORIZONTAL_ALIGN_LEFT, ee = this.constructor.VERTICAL_ALIGN_TOP, L = L.toString();
                  U !== 1 / 0 && ee === this.constructor.VERTICAL_ALIGN_BOTTOM ? I += U - (0, a.measureTextHeight)(A, L, z) : U !== 1 / 0 && ee === this.constructor.VERTICAL_ALIGN_MIDDLE && (I += U / 2 - (0, a.measureTextHeight)(A, L, z) / 2);
                  var W = Object.entries(A.chars)[0][1].xadvance, Q = h(A, L, z), de = Q.lines, we = Q.longestLine;
                  return de.forEach(function(ke) {
                    var Me = ke.join(" "), fe = n(F.constructor, A, Me, z, oe);
                    g.call(F, A, T + fe, I, Me, W), I += A.common.lineHeight;
                  }), (0, l.isNodePattern)(J) && J.call(this, null, this, {
                    x: T + we,
                    y: I
                  }), this;
                }
              }
            };
          };
          _.default = b, Z.exports = _.default;
        }).call(this, "/../../node_modules/@jimp/plugin-print/dist");
      }, { "./measure-text": 218, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, "load-bmfont": 219, path: 107 }], 218: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.measureText = M, _.measureTextHeight = x;
        function M(y, E) {
          for (var c = 0, u = 0; u < E.length; u++)
            if (y.chars[E[u]]) {
              var l = y.kernings[E[u]] && y.kernings[E[u]][E[u + 1]] ? y.kernings[E[u]][E[u + 1]] : 0;
              c += (y.chars[E[u]].xadvance || 0) + l;
            }
          return c;
        }
        function x(y, E, c) {
          for (var u = E.split(" "), l = "", a = y.common.lineHeight, n = 0; n < u.length; n++) {
            var d = l + u[n] + " ", g = M(y, d);
            g > c && n > 0 ? (a += y.common.lineHeight, l = u[n] + " ") : l = d;
          }
          return a;
        }
      }, {}], 219: [function(k, Z, _) {
        (function(M) {
          var x = k("xhr"), y = function() {
          }, E = k("parse-bmfont-ascii"), c = k("parse-bmfont-xml"), u = k("parse-bmfont-binary"), l = k("./lib/is-binary"), a = k("xtend"), n = function() {
            return self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
          }();
          Z.exports = function(h, m) {
            m = typeof m == "function" ? m : y, typeof h == "string" ? h = { uri: h } : h || (h = {});
            var s = h.binary;
            s && (h = g(h)), x(h, function(b, S, o) {
              if (b)
                return m(b);
              if (!/^2/.test(S.statusCode))
                return m(new Error("http status code: " + S.statusCode));
              if (!o)
                return m(new Error("no body result"));
              var A = !1;
              if (d(o)) {
                var T = new Uint8Array(o);
                o = new M(T, "binary");
              }
              l(o) && (A = !0, typeof o == "string" && (o = new M(o, "binary"))), A || (M.isBuffer(o) && (o = o.toString(h.encoding)), o = o.trim());
              var I;
              try {
                var L = S.headers["content-type"];
                A ? I = u(o) : /json/.test(L) || o.charAt(0) === "{" ? I = JSON.parse(o) : /xml/.test(L) || o.charAt(0) === "<" ? I = c(o) : I = E(o);
              } catch (z) {
                m(new Error("error parsing font " + z.message)), m = y;
              }
              m(null, I);
            });
          };
          function d(h) {
            var m = Object.prototype.toString;
            return m.call(h) === "[object ArrayBuffer]";
          }
          function g(h) {
            if (n)
              return a(h, { responseType: "arraybuffer" });
            if (typeof self.XMLHttpRequest > "u")
              throw new Error("your browser does not support XHR loading");
            var m = new self.XMLHttpRequest();
            return m.overrideMimeType("text/plain; charset=x-user-defined"), a({
              xhr: m
            }, h);
          }
        }).call(this, k("buffer").Buffer);
      }, { "./lib/is-binary": 220, buffer: 48, "parse-bmfont-ascii": 102, "parse-bmfont-binary": 103, "parse-bmfont-xml": 104, xhr: 187, xtend: 189 }], 220: [function(k, Z, _) {
        (function(M) {
          var x = k("buffer-equal"), y = new M([66, 77, 70, 3]);
          Z.exports = function(E) {
            return typeof E == "string" ? E.substring(0, 3) === "BMF" : E.length > 4 && x(E.slice(0, 4), y);
          };
        }).call(this, k("buffer").Buffer);
      }, { buffer: 48, "buffer-equal": 49 }], 221: [function(k, Z, _) {
        (function(M) {
          var x = k("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(_, "__esModule", {
            value: !0
          }), _.default = void 0;
          var y = k("@jimp/utils"), E = x(k("./modules/resize")), c = x(k("./modules/resize2")), u = function() {
            return {
              constants: {
                RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor",
                RESIZE_BILINEAR: "bilinearInterpolation",
                RESIZE_BICUBIC: "bicubicInterpolation",
                RESIZE_HERMITE: "hermiteInterpolation",
                RESIZE_BEZIER: "bezierInterpolation"
              },
              class: {
                /**
                 * Resizes the image to a set width and height using a 2-pass bilinear algorithm
                 * @param {number} w the width to resize the image to (or Jimp.AUTO)
                 * @param {number} h the height to resize the image to (or Jimp.AUTO)
                 * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
                 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
                 * @returns {Jimp} this for chaining of methods
                 */
                resize: function(n, d, g, h) {
                  if (typeof n != "number" || typeof d != "number")
                    return y.throwError.call(this, "w and h must be numbers", h);
                  if (typeof g == "function" && typeof h > "u" && (h = g, g = null), n === this.constructor.AUTO && d === this.constructor.AUTO)
                    return y.throwError.call(this, "w and h cannot both be set to auto", h);
                  if (n === this.constructor.AUTO && (n = this.bitmap.width * (d / this.bitmap.height)), d === this.constructor.AUTO && (d = this.bitmap.height * (n / this.bitmap.width)), n < 0 || d < 0)
                    return y.throwError.call(this, "w and h must be positive numbers", h);
                  if (n = Math.round(n), d = Math.round(d), typeof c.default[g] == "function") {
                    var m = {
                      data: M.alloc(n * d * 4),
                      width: n,
                      height: d
                    };
                    c.default[g](this.bitmap, m), this.bitmap = m;
                  } else {
                    var s = this, b = new E.default(this.bitmap.width, this.bitmap.height, n, d, !0, !0, function(S) {
                      s.bitmap.data = M.from(S), s.bitmap.width = n, s.bitmap.height = d;
                    });
                    b.resize(this.bitmap.data);
                  }
                  return (0, y.isNodePattern)(h) && h.call(this, null, this), this;
                }
              }
            };
          };
          _.default = u, Z.exports = _.default;
        }).call(this, k("buffer").Buffer);
      }, { "./modules/resize": 222, "./modules/resize2": 223, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, buffer: 48 }], 222: [function(k, Z, _) {
        function M(x, y, E, c, u, l, a) {
          this.widthOriginal = Math.abs(Math.floor(x) || 0), this.heightOriginal = Math.abs(Math.floor(y) || 0), this.targetWidth = Math.abs(Math.floor(E) || 0), this.targetHeight = Math.abs(Math.floor(c) || 0), this.colorChannels = u ? 4 : 3, this.interpolationPass = !!l, this.resizeCallback = typeof a == "function" ? a : function() {
          }, this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels, this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels, this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels, this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal, this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight, this.initialize();
        }
        M.prototype.initialize = function() {
          if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0)
            this.configurePasses();
          else
            throw new Error("Invalid settings specified for the resizer.");
        }, M.prototype.configurePasses = function() {
          this.widthOriginal === this.targetWidth ? this.resizeWidth = this.bypassResizer : (this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth, this.ratioWeightWidthPass < 1 && this.interpolationPass ? (this.initializeFirstPassBuffers(!0), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB) : (this.initializeFirstPassBuffers(!1), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB)), this.heightOriginal === this.targetHeight ? this.resizeHeight = this.bypassResizer : (this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight, this.ratioWeightHeightPass < 1 && this.interpolationPass ? (this.initializeSecondPassBuffers(!0), this.resizeHeight = this.resizeHeightInterpolated) : (this.initializeSecondPassBuffers(!1), this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB));
        }, M.prototype._resizeWidthInterpolatedRGBChannels = function(x, y) {
          var E = y ? 4 : 3, c = this.ratioWeightWidthPass, u = this.widthBuffer, l = 0, a = 0, n = 0, d = 0, g = 0, h;
          for (h = 0; l < 1 / 3; h += E, l += c)
            for (a = h, n = 0; a < this.widthPassResultSize; n += this.originalWidthMultipliedByChannels, a += this.targetWidthMultipliedByChannels)
              u[a] = x[n], u[a + 1] = x[n + 1], u[a + 2] = x[n + 2], y && (u[a + 3] = x[n + 3]);
          l -= 1 / 3;
          var m;
          for (m = this.widthOriginal - 1; l < m; h += E, l += c)
            for (g = l % 1, d = 1 - g, a = h, n = Math.floor(l) * E; a < this.widthPassResultSize; n += this.originalWidthMultipliedByChannels, a += this.targetWidthMultipliedByChannels)
              u[a + 0] = x[n + 0] * d + x[n + E + 0] * g, u[a + 1] = x[n + 1] * d + x[n + E + 1] * g, u[a + 2] = x[n + 2] * d + x[n + E + 2] * g, y && (u[a + 3] = x[n + 3] * d + x[n + E + 3] * g);
          for (m = this.originalWidthMultipliedByChannels - E; h < this.targetWidthMultipliedByChannels; h += E)
            for (a = h, n = m; a < this.widthPassResultSize; n += this.originalWidthMultipliedByChannels, a += this.targetWidthMultipliedByChannels)
              u[a] = x[n], u[a + 1] = x[n + 1], u[a + 2] = x[n + 2], y && (u[a + 3] = x[n + 3]);
          return u;
        }, M.prototype._resizeWidthRGBChannels = function(x, y) {
          var E = y ? 4 : 3, c = this.ratioWeightWidthPass, u = 1 / c, l = this.originalWidthMultipliedByChannels - E + 1, a = this.targetWidthMultipliedByChannels - E + 1, n = this.outputWidthWorkBench, d = this.widthBuffer, g = this.outputWidthWorkBenchOpaquePixelsCount, h = 0, m = 0, s = 0, b = 0, S = 0, o = 0, A = 0, T = 1, I = 0, L = 0, z = 0, U = 0;
          do {
            for (S = 0; S < this.originalHeightMultipliedByChannels; )
              n[S++] = 0, n[S++] = 0, n[S++] = 0, y && (n[S++] = 0, g[S / E - 1] = 0);
            h = c;
            do {
              for (m = 1 + s - b, T = Math.min(h, m), S = 0, o = s; S < this.originalHeightMultipliedByChannels; o += l)
                I = x[o], L = x[++o], z = x[++o], U = y ? x[++o] : 255, n[S++] += (U ? I : 0) * T, n[S++] += (U ? L : 0) * T, n[S++] += (U ? z : 0) * T, y && (n[S++] += U * T, g[S / E - 1] += U ? T : 0);
              if (h >= m)
                s += E, b = s, h -= m;
              else {
                b += h;
                break;
              }
            } while (h > 0 && s < this.originalWidthMultipliedByChannels);
            for (S = 0, o = A; S < this.originalHeightMultipliedByChannels; o += a)
              h = y ? g[S / E] : 1, T = y ? h ? 1 / h : 0 : u, d[o] = n[S++] * T, d[++o] = n[S++] * T, d[++o] = n[S++] * T, y && (d[++o] = n[S++] * u);
            A += E;
          } while (A < this.targetWidthMultipliedByChannels);
          return d;
        }, M.prototype._resizeHeightRGBChannels = function(x, y) {
          var E = this.ratioWeightHeightPass, c = 1 / E, u = this.outputHeightWorkBench, l = this.heightBuffer, a = this.outputHeightWorkBenchOpaquePixelsCount, n = 0, d = 0, g = 0, h = 0, m = 0, s = 0, b = 0, S = 1, o = 0, A = 0, T = 0, I = 0;
          do {
            for (m = 0; m < this.targetWidthMultipliedByChannels; )
              u[m++] = 0, u[m++] = 0, u[m++] = 0, y && (u[m++] = 0, a[m / 4 - 1] = 0);
            n = E;
            do {
              for (d = 1 + g - h, S = Math.min(n, d), b = g, m = 0; m < this.targetWidthMultipliedByChannels; )
                o = x[b++], A = x[b++], T = x[b++], I = y ? x[b++] : 255, u[m++] += (I ? o : 0) * S, u[m++] += (I ? A : 0) * S, u[m++] += (I ? T : 0) * S, y && (u[m++] += I * S, a[m / 4 - 1] += I ? S : 0);
              if (n >= d)
                g = b, h = g, n -= d;
              else {
                h += n;
                break;
              }
            } while (n > 0 && g < this.widthPassResultSize);
            for (m = 0; m < this.targetWidthMultipliedByChannels; )
              n = y ? a[m / 4] : 1, S = y ? n ? 1 / n : 0 : c, l[s++] = Math.round(u[m++] * S), l[s++] = Math.round(u[m++] * S), l[s++] = Math.round(u[m++] * S), y && (l[s++] = Math.round(u[m++] * c));
          } while (s < this.finalResultSize);
          return l;
        }, M.prototype.resizeWidthInterpolatedRGB = function(x) {
          return this._resizeWidthInterpolatedRGBChannels(x, !1);
        }, M.prototype.resizeWidthInterpolatedRGBA = function(x) {
          return this._resizeWidthInterpolatedRGBChannels(x, !0);
        }, M.prototype.resizeWidthRGB = function(x) {
          return this._resizeWidthRGBChannels(x, !1);
        }, M.prototype.resizeWidthRGBA = function(x) {
          return this._resizeWidthRGBChannels(x, !0);
        }, M.prototype.resizeHeightInterpolated = function(x) {
          for (var y = this.ratioWeightHeightPass, E = this.heightBuffer, c = 0, u = 0, l = 0, a = 0, n = 0, d = 0, g = 0, h; c < 1 / 3; c += y)
            for (l = 0; l < this.targetWidthMultipliedByChannels; )
              E[u++] = Math.round(x[l++]);
          for (c -= 1 / 3, h = this.heightOriginal - 1; c < h; c += y)
            for (g = c % 1, d = 1 - g, a = Math.floor(c) * this.targetWidthMultipliedByChannels, n = a + this.targetWidthMultipliedByChannels, l = 0; l < this.targetWidthMultipliedByChannels; ++l)
              E[u++] = Math.round(x[a++] * d + x[n++] * g);
          for (; u < this.finalResultSize; )
            for (l = 0, a = h * this.targetWidthMultipliedByChannels; l < this.targetWidthMultipliedByChannels; ++l)
              E[u++] = Math.round(x[a++]);
          return E;
        }, M.prototype.resizeHeightRGB = function(x) {
          return this._resizeHeightRGBChannels(x, !1);
        }, M.prototype.resizeHeightRGBA = function(x) {
          return this._resizeHeightRGBChannels(x, !0);
        }, M.prototype.resize = function(x) {
          this.resizeCallback(this.resizeHeight(this.resizeWidth(x)));
        }, M.prototype.bypassResizer = function(x) {
          return x;
        }, M.prototype.initializeFirstPassBuffers = function(x) {
          this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize), x || (this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels), this.colorChannels > 3 && (this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal)));
        }, M.prototype.initializeSecondPassBuffers = function(x) {
          this.heightBuffer = this.generateUint8Buffer(this.finalResultSize), x || (this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels), this.colorChannels > 3 && (this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth)));
        }, M.prototype.generateFloatBuffer = function(x) {
          try {
            return new Float32Array(x);
          } catch {
            return [];
          }
        }, M.prototype.generateFloat64Buffer = function(x) {
          try {
            return new Float64Array(x);
          } catch {
            return [];
          }
        }, M.prototype.generateUint8Buffer = function(x) {
          try {
            return new Uint8Array(x);
          } catch {
            return [];
          }
        }, Z.exports = M;
      }, {}], 223: [function(k, Z, _) {
        (function(M) {
          Z.exports = {
            nearestNeighbor: function(y, E) {
              for (var c = y.width, u = y.height, l = E.width, a = E.height, n = y.data, d = E.data, g = 0; g < a; g++)
                for (var h = 0; h < l; h++) {
                  var m = (g * l + h) * 4, s = Math.floor(g * u / a), b = Math.floor(h * c / l), S = (s * c + b) * 4;
                  d[m++] = n[S++], d[m++] = n[S++], d[m++] = n[S++], d[m++] = n[S++];
                }
            },
            bilinearInterpolation: function(y, E) {
              for (var c = y.width, u = y.height, l = E.width, a = E.height, n = y.data, d = E.data, g = function(U, J, F, oe, ee) {
                return J === oe ? F : Math.round((U - J) * ee + (oe - U) * F);
              }, h = function(U, J, F, oe, ee, ie, W, Q) {
                var de = (W * c + oe) * 4 + J, we = (W * c + ee) * 4 + J, ke = g(F, oe, n[de], ee, n[we]);
                if (Q === W)
                  d[U + J] = ke;
                else {
                  de = (Q * c + oe) * 4 + J, we = (Q * c + ee) * 4 + J;
                  var Me = g(F, oe, n[de], ee, n[we]);
                  d[U + J] = g(ie, W, ke, Q, Me);
                }
              }, m = 0; m < a; m++)
                for (var s = 0; s < l; s++) {
                  var b = (m * l + s) * 4, S = s * c / l, o = Math.floor(S), A = Math.min(Math.ceil(S), c - 1), T = m * u / a, I = Math.floor(T), L = Math.min(Math.ceil(T), u - 1);
                  h(b, 0, S, o, A, T, I, L), h(b, 1, S, o, A, T, I, L), h(b, 2, S, o, A, T, I, L), h(b, 3, S, o, A, T, I, L);
                }
            },
            _interpolate2D: function(y, E, c, u) {
              for (var l = y.data, a = E.data, n = y.width, d = y.height, g = E.width, h = E.height, m = Math.max(1, Math.floor(n / g)), s = g * m, b = Math.max(1, Math.floor(d / h)), S = h * b, o = M.alloc(s * d * 4), A = 0; A < d; A++)
                for (var T = 0; T < s; T++)
                  for (var I = T * (n - 1) / s, L = Math.floor(I), z = I - L, U = (A * n + L) * 4, J = (A * s + T) * 4, F = 0; F < 4; F++) {
                    var oe = U + F, ee = L > 0 ? l[oe - 4] : 2 * l[oe] - l[oe + 4], ie = l[oe], W = l[oe + 4], Q = L < n - 2 ? l[oe + 8] : 2 * l[oe + 4] - l[oe];
                    o[J + F] = u(ee, ie, W, Q, z);
                  }
              for (var de = M.alloc(s * S * 4), we = 0; we < S; we++)
                for (var ke = 0; ke < s; ke++)
                  for (var Me = we * (d - 1) / S, fe = Math.floor(Me), xe = Me - fe, Ee = (fe * s + ke) * 4, Pe = (we * s + ke) * 4, Ue = 0; Ue < 4; Ue++) {
                    var He = Ee + Ue, We = fe > 0 ? o[He - s * 4] : 2 * o[He] - o[He + s * 4], Ze = o[He], $e = o[He + s * 4], Ve = fe < d - 2 ? o[He + s * 8] : 2 * o[He + s * 4] - o[He];
                    de[Pe + Ue] = u(We, Ze, $e, Ve, xe);
                  }
              var Ge = m * b;
              if (Ge > 1)
                for (var Ie = 0; Ie < h; Ie++)
                  for (var De = 0; De < g; De++) {
                    for (var Ne = 0, _e = 0, re = 0, $ = 0, Ce = 0, ve = 0; ve < b; ve++)
                      for (var Y = Ie * b + ve, G = 0; G < m; G++) {
                        var Ae = De * m + G, e = (Y * s + Ae) * 4, r = de[e + 3];
                        r && (Ne += de[e], _e += de[e + 1], re += de[e + 2], Ce++), $ += r;
                      }
                    var f = (Ie * g + De) * 4;
                    a[f] = Ce ? Math.round(Ne / Ce) : 0, a[f + 1] = Ce ? Math.round(_e / Ce) : 0, a[f + 2] = Ce ? Math.round(re / Ce) : 0, a[f + 3] = Math.round($ / Ge);
                  }
              else
                E.data = de;
            },
            bicubicInterpolation: function(y, E, c) {
              var u = function(a, n, d, g, h) {
                var m = g - d - a + n, s = a - n - m, b = d - a, S = n;
                return Math.max(0, Math.min(255, m * (h * h * h) + s * (h * h) + b * h + S));
              };
              return this._interpolate2D(y, E, c, u);
            },
            hermiteInterpolation: function(y, E, c) {
              var u = function(a, n, d, g, h) {
                var m = n, s = 0.5 * (d - a), b = a - 2.5 * n + 2 * d - 0.5 * g, S = 0.5 * (g - a) + 1.5 * (n - d);
                return Math.max(0, Math.min(255, Math.round(((S * h + b) * h + s) * h + m)));
              };
              return this._interpolate2D(y, E, c, u);
            },
            bezierInterpolation: function(y, E, c) {
              var u = function(a, n, d, g, h) {
                var m = n + (d - a) / 4, s = d - (g - n) / 4, b = 1 - h, S = n * b * b * b, o = 3 * m * b * b * h, A = 3 * s * b * h * h, T = d * h * h * h;
                return Math.max(0, Math.min(255, Math.round(S + o + A + T)));
              };
              return this._interpolate2D(y, E, c, u);
            }
          };
        }).call(this, k("buffer").Buffer);
      }, { buffer: 48 }], 224: [function(k, Z, _) {
        (function(M) {
          Object.defineProperty(_, "__esModule", {
            value: !0
          }), _.default = void 0;
          var x = k("@jimp/utils");
          function y(c, u) {
            c %= 360;
            var l = c * Math.PI / 180, a = Math.cos(l), n = Math.sin(l), d = this.bitmap.width, g = this.bitmap.height;
            if (u === !0 || typeof u == "string") {
              d = Math.ceil(Math.abs(this.bitmap.width * a) + Math.abs(this.bitmap.height * n)) + 1, g = Math.ceil(Math.abs(this.bitmap.width * n) + Math.abs(this.bitmap.height * a)) + 1, d % 2 !== 0 && d++, g % 2 !== 0 && g++;
              var h = this.cloneQuiet();
              this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(W, Q, de) {
                this.bitmap.data.writeUInt32BE(this._background, de);
              });
              var m = Math.max(d, g, this.bitmap.width, this.bitmap.height);
              this.resize(m, m, u), this.blit(h, this.bitmap.width / 2 - h.bitmap.width / 2, this.bitmap.height / 2 - h.bitmap.height / 2);
            }
            var s = this.bitmap.width, b = this.bitmap.height, S = M.alloc(this.bitmap.data.length);
            function o(W, Q) {
              return function(de, we) {
                return {
                  x: de + W,
                  y: we + Q
                };
              };
            }
            for (var A = o(-(s / 2), -(b / 2)), T = o(s / 2 + 0.5, b / 2 + 0.5), I = 1; I <= b; I++)
              for (var L = 1; L <= s; L++) {
                var z = A(L, I), U = T(a * z.x - n * z.y, a * z.y + n * z.x), J = s * (I - 1) + L - 1 << 2;
                if (U.x >= 0 && U.x < s && U.y >= 0 && U.y < b) {
                  var F = (s * (U.y | 0) + U.x | 0) << 2, oe = this.bitmap.data.readUInt32BE(F);
                  S.writeUInt32BE(oe, J);
                } else
                  S.writeUInt32BE(this._background, J);
              }
            if (this.bitmap.data = S, u === !0 || typeof u == "string") {
              var ee = s / 2 - d / 2, ie = b / 2 - g / 2;
              this.crop(ee, ie, d, g);
            }
          }
          var E = function() {
            return {
              /**
               * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.
               * @param {number} deg the number of degrees to rotate the image by
               * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              rotate: function(l, a, n) {
                return (typeof a > "u" || a === null) && (a = !0), typeof a == "function" && typeof n > "u" && (n = a, a = !0), typeof l != "number" ? x.throwError.call(this, "deg must be a number", n) : typeof a != "boolean" && typeof a != "string" ? x.throwError.call(this, "mode must be a boolean or a string", n) : (y.call(this, l, a, n), (0, x.isNodePattern)(n) && n.call(this, null, this), this);
              }
            };
          };
          _.default = E, Z.exports = _.default;
        }).call(this, k("buffer").Buffer);
      }, { "@jimp/utils": 235, buffer: 48 }], 225: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils"), x = function() {
          return {
            /**
             * Uniformly scales the image by a factor.
             * @param {number} f the factor to scale the image by
             * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            scale: function(c, u, l) {
              if (typeof c != "number")
                return M.throwError.call(this, "f must be a number", l);
              if (c < 0)
                return M.throwError.call(this, "f must be a positive number", l);
              typeof u == "function" && typeof l > "u" && (l = u, u = null);
              var a = this.bitmap.width * c, n = this.bitmap.height * c;
              return this.resize(a, n, u), (0, M.isNodePattern)(l) && l.call(this, null, this), this;
            },
            /**
             * Scale the image to the largest size that fits inside the rectangle that has the given width and height.
             * @param {number} w the width to resize the image to
             * @param {number} h the height to resize the image to
             * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            scaleToFit: function(c, u, l, a) {
              if (typeof c != "number" || typeof u != "number")
                return M.throwError.call(this, "w and h must be numbers", a);
              typeof l == "function" && typeof a > "u" && (a = l, l = null);
              var n = c / u > this.bitmap.width / this.bitmap.height ? u / this.bitmap.height : c / this.bitmap.width;
              return this.scale(n, l), (0, M.isNodePattern)(a) && a.call(this, null, this), this;
            }
          };
        };
        _.default = x, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 226: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils"), x = function() {
          return {
            shadow: function() {
              var c = this, u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, l = arguments.length > 1 ? arguments[1] : void 0;
              typeof u == "function" && (l = u, u = {});
              var a = u, n = a.opacity, d = n === void 0 ? 0.7 : n, g = a.size, h = g === void 0 ? 1.1 : g, m = a.x, s = m === void 0 ? -25 : m, b = a.y, S = b === void 0 ? 25 : b, o = a.blur, A = o === void 0 ? 5 : o, T = this.clone(), I = this.clone();
              return I.scan(0, 0, I.bitmap.width, I.bitmap.height, function(L, z, U) {
                I.bitmap.data[U] = 0, I.bitmap.data[U + 1] = 0, I.bitmap.data[U + 2] = 0, I.bitmap.data[U + 3] = I.constructor.limit255(I.bitmap.data[U + 3] * d), c.bitmap.data[U] = 0, c.bitmap.data[U + 1] = 0, c.bitmap.data[U + 2] = 0, c.bitmap.data[U + 3] = 0;
              }), I.resize(I.bitmap.width * h, I.bitmap.height * h).blur(A), this.composite(I, s, S), this.composite(T, 0, 0), (0, M.isNodePattern)(l) && l.call(this, null, this), this;
            }
          };
        };
        _.default = x, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 227: [function(k, Z, _) {
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var M = k("@jimp/utils"), x = function() {
          return {
            threshold: function(c, u) {
              var l = this, a = c.max, n = c.replace, d = n === void 0 ? 255 : n, g = c.autoGreyscale, h = g === void 0 ? !0 : g;
              return typeof a != "number" ? M.throwError.call(this, "max must be a number", u) : typeof d != "number" ? M.throwError.call(this, "replace must be a number", u) : typeof h != "boolean" ? M.throwError.call(this, "autoGreyscale must be a boolean", u) : (a = this.constructor.limit255(a), d = this.constructor.limit255(d), h && this.greyscale(), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(m, s, b) {
                var S = l.bitmap.data[b] < a ? l.bitmap.data[b] : d;
                l.bitmap.data[b] = S, l.bitmap.data[b + 1] = S, l.bitmap.data[b + 2] = S;
              }), (0, M.isNodePattern)(u) && u.call(this, null, this), this);
            }
          };
        };
        _.default = x, Z.exports = _.default;
      }, { "@jimp/utils": 235 }], 228: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var x = M(k("@babel/runtime/helpers/toConsumableArray")), y = k("timm"), E = M(k("@jimp/plugin-blit")), c = M(k("@jimp/plugin-blur")), u = M(k("@jimp/plugin-circle")), l = M(k("@jimp/plugin-color")), a = M(k("@jimp/plugin-contain")), n = M(k("@jimp/plugin-cover")), d = M(k("@jimp/plugin-crop")), g = M(k("@jimp/plugin-displace")), h = M(k("@jimp/plugin-dither")), m = M(k("@jimp/plugin-fisheye")), s = M(k("@jimp/plugin-flip")), b = M(k("@jimp/plugin-gaussian")), S = M(k("@jimp/plugin-invert")), o = M(k("@jimp/plugin-mask")), A = M(k("@jimp/plugin-normalize")), T = M(k("@jimp/plugin-print")), I = M(k("@jimp/plugin-resize")), L = M(k("@jimp/plugin-rotate")), z = M(k("@jimp/plugin-scale")), U = M(k("@jimp/plugin-shadow")), J = M(k("@jimp/plugin-threshold")), F = [E.default, c.default, u.default, l.default, a.default, n.default, d.default, g.default, h.default, m.default, s.default, b.default, S.default, o.default, A.default, T.default, I.default, L.default, z.default, U.default, J.default], oe = function(ie) {
          var W = F.map(function(Q) {
            var de = Q(ie) || {};
            return !de.class && !de.constants && (de = {
              class: de
            }), de;
          });
          return y.mergeDeep.apply(void 0, (0, x.default)(W));
        };
        _.default = oe, Z.exports = _.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/plugin-blit": 201, "@jimp/plugin-blur": 203, "@jimp/plugin-circle": 204, "@jimp/plugin-color": 205, "@jimp/plugin-contain": 206, "@jimp/plugin-cover": 207, "@jimp/plugin-crop": 208, "@jimp/plugin-displace": 209, "@jimp/plugin-dither": 210, "@jimp/plugin-fisheye": 211, "@jimp/plugin-flip": 212, "@jimp/plugin-gaussian": 213, "@jimp/plugin-invert": 214, "@jimp/plugin-mask": 215, "@jimp/plugin-normalize": 216, "@jimp/plugin-print": 217, "@jimp/plugin-resize": 221, "@jimp/plugin-rotate": 224, "@jimp/plugin-scale": 225, "@jimp/plugin-shadow": 226, "@jimp/plugin-threshold": 227, timm: 177 }], 229: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var x = M(k("@babel/runtime/helpers/defineProperty")), y = M(k("bmp-js")), E = k("@jimp/utils"), c = "image/bmp", u = "image/x-ms-bmp";
        function l(h) {
          return (0, E.scan)(h, 0, 0, h.bitmap.width, h.bitmap.height, function(m, s, b) {
            var S = this.bitmap.data[b + 0], o = this.bitmap.data[b + 1], A = this.bitmap.data[b + 2], T = this.bitmap.data[b + 3];
            this.bitmap.data[b + 0] = T, this.bitmap.data[b + 1] = A, this.bitmap.data[b + 2] = o, this.bitmap.data[b + 3] = S;
          }).bitmap;
        }
        function a(h) {
          return (0, E.scan)({
            bitmap: h
          }, 0, 0, h.width, h.height, function(m, s, b) {
            var S = this.bitmap.data[b + 0], o = this.bitmap.data[b + 1], A = this.bitmap.data[b + 2], T = this.bitmap.data[b + 3];
            this.bitmap.data[b + 0] = T, this.bitmap.data[b + 1] = A, this.bitmap.data[b + 2] = o, this.bitmap.data[b + 3] = h.is_with_alpha ? S : 255;
          }).bitmap;
        }
        var n = function(m) {
          return a(y.default.decode(m));
        }, d = function(m) {
          return y.default.encode(l(m)).data;
        }, g = function() {
          var m, s;
          return {
            mime: (0, x.default)({}, c, ["bmp"]),
            constants: {
              MIME_BMP: c,
              MIME_X_MS_BMP: u
            },
            decoders: (m = {}, (0, x.default)(m, c, n), (0, x.default)(m, u, n), m),
            encoders: (s = {}, (0, x.default)(s, c, d), (0, x.default)(s, u, d), s)
          };
        };
        _.default = g, Z.exports = _.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, "bmp-js": 30 }], 230: [function(k, Z, _) {
        (function(M) {
          var x = k("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(_, "__esModule", {
            value: !0
          }), _.default = void 0;
          var y = x(k("@babel/runtime/helpers/defineProperty")), E = x(k("omggif")), c = k("gifwrap"), u = "image/gif", l = function() {
            return {
              mime: (0, y.default)({}, u, ["gif"]),
              constants: {
                MIME_GIF: u
              },
              decoders: (0, y.default)({}, u, function(n) {
                var d = new E.default.GifReader(n), g = M.alloc(d.width * d.height * 4);
                return d.decodeAndBlitFrameRGBA(0, g), {
                  data: g,
                  width: d.width,
                  height: d.height
                };
              }),
              encoders: (0, y.default)({}, u, function(n) {
                var d = new c.BitmapImage(n.bitmap);
                c.GifUtil.quantizeDekker(d, 256);
                var g = new c.GifFrame(d), h = new c.GifCodec();
                return h.encodeGif([g], {}).then(function(m) {
                  return m.buffer;
                });
              })
            };
          };
          _.default = l, Z.exports = _.default;
        }).call(this, k("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, buffer: 48, gifwrap: 70, omggif: 85 }], 231: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var x = M(k("@babel/runtime/helpers/defineProperty")), y = M(k("jpeg-js")), E = k("@jimp/utils"), c = "image/jpeg", u = function() {
          return {
            mime: (0, x.default)({}, c, ["jpeg", "jpg", "jpe"]),
            constants: {
              MIME_JPEG: c
            },
            decoders: (0, x.default)({}, c, y.default.decode),
            encoders: (0, x.default)({}, c, function(a) {
              return y.default.encode(a.bitmap, a._quality).data;
            }),
            class: {
              // The quality to be used when saving JPEG images
              _quality: 100,
              /**
               * Sets the quality of the image when saving as JPEG format (default is 100)
               * @param {number} n The quality to use 0-100
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              quality: function(n, d) {
                return typeof n != "number" ? E.throwError.call(this, "n must be a number", d) : n < 0 || n > 100 ? E.throwError.call(this, "n must be a number 0 - 100", d) : (this._quality = Math.round(n), (0, E.isNodePattern)(d) && d.call(this, null, this), this);
              }
            }
          };
        };
        _.default = u, Z.exports = _.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, "jpeg-js": 80 }], 232: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var x = M(k("@babel/runtime/helpers/defineProperty")), y = k("pngjs"), E = k("@jimp/utils"), c = "image/png", u = -1, l = 0, a = 1, n = 2, d = 3, g = 4, h = function() {
          return {
            mime: (0, x.default)({}, c, ["png"]),
            constants: {
              MIME_PNG: c,
              PNG_FILTER_AUTO: u,
              PNG_FILTER_NONE: l,
              PNG_FILTER_SUB: a,
              PNG_FILTER_UP: n,
              PNG_FILTER_AVERAGE: d,
              PNG_FILTER_PATH: g
            },
            hasAlpha: (0, x.default)({}, c, !0),
            decoders: (0, x.default)({}, c, y.PNG.sync.read),
            encoders: (0, x.default)({}, c, function(s) {
              var b = new y.PNG({
                width: s.bitmap.width,
                height: s.bitmap.height
              });
              return b.data = s.bitmap.data, y.PNG.sync.write(b, {
                width: s.bitmap.width,
                height: s.bitmap.height,
                deflateLevel: s._deflateLevel,
                deflateStrategy: s._deflateStrategy,
                filterType: s._filterType,
                colorType: typeof s._colorType == "number" ? s._colorType : s._rgba ? 6 : 2,
                inputHasAlpha: s._rgba
              });
            }),
            class: {
              _deflateLevel: 9,
              _deflateStrategy: 3,
              _filterType: u,
              _colorType: null,
              /**
               * Sets the deflate level used when saving as PNG format (default is 9)
               * @param {number} l Deflate level to use 0-9. 0 is no compression. 9 (default) is maximum compression.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              deflateLevel: function(b, S) {
                return typeof b != "number" ? E.throwError.call(this, "l must be a number", S) : b < 0 || b > 9 ? E.throwError.call(this, "l must be a number 0 - 9", S) : (this._deflateLevel = Math.round(b), (0, E.isNodePattern)(S) && S.call(this, null, this), this);
              },
              /**
               * Sets the deflate strategy used when saving as PNG format (default is 3)
               * @param {number} s Deflate strategy to use 0-3.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              deflateStrategy: function(b, S) {
                return typeof b != "number" ? E.throwError.call(this, "s must be a number", S) : b < 0 || b > 3 ? E.throwError.call(this, "s must be a number 0 - 3", S) : (this._deflateStrategy = Math.round(b), (0, E.isNodePattern)(S) && S.call(this, null, this), this);
              },
              /**
               * Sets the filter type used when saving as PNG format (default is automatic filters)
               * @param {number} f The quality to use -1-4.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              filterType: function(b, S) {
                return typeof b != "number" ? E.throwError.call(this, "n must be a number", S) : b < -1 || b > 4 ? E.throwError.call(this, "n must be -1 (auto) or a number 0 - 4", S) : (this._filterType = Math.round(b), (0, E.isNodePattern)(S) && S.call(this, null, this), this);
              },
              /**
               * Sets the color type used when saving as PNG format
               * @param {number} s color type to use 0, 2, 4, 6.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              colorType: function(b, S) {
                return typeof b != "number" ? E.throwError.call(this, "s must be a number", S) : b !== 0 && b !== 2 && b !== 4 && b !== 6 ? E.throwError.call(this, "s must be a number 0, 2, 4, 6.", S) : (this._colorType = Math.round(b), (0, E.isNodePattern)(S) && S.call(this, null, this), this);
              }
            }
          };
        };
        _.default = h, Z.exports = _.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, pngjs: 129 }], 233: [function(k, Z, _) {
        (function(M) {
          var x = k("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(_, "__esModule", {
            value: !0
          }), _.default = void 0;
          var y = x(k("@babel/runtime/helpers/defineProperty")), E = x(k("utif")), c = "image/tiff", u = function() {
            return {
              mime: (0, y.default)({}, c, ["tiff", "tif"]),
              constants: {
                MIME_TIFF: c
              },
              decoders: (0, y.default)({}, c, function(a) {
                var n = E.default.decode(a), d = n[0];
                E.default.decodeImages(a, n);
                var g = E.default.toRGBA8(d);
                return {
                  data: M.from(g),
                  width: d.t256[0],
                  height: d.t257[0]
                };
              }),
              encoders: (0, y.default)({}, c, function(a) {
                var n = E.default.encodeImage(a.bitmap.data, a.bitmap.width, a.bitmap.height);
                return M.from(n);
              })
            };
          };
          _.default = u, Z.exports = _.default;
        }).call(this, k("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, buffer: 48, utif: 182 }], 234: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.default = void 0;
        var x = k("timm"), y = M(k("@jimp/jpeg")), E = M(k("@jimp/png")), c = M(k("@jimp/bmp")), u = M(k("@jimp/tiff")), l = M(k("@jimp/gif")), a = function() {
          return (0, x.mergeDeep)((0, y.default)(), (0, E.default)(), (0, c.default)(), (0, u.default)(), (0, l.default)());
        };
        _.default = a, Z.exports = _.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/bmp": 229, "@jimp/gif": 230, "@jimp/jpeg": 231, "@jimp/png": 232, "@jimp/tiff": 233, timm: 177 }], 235: [function(k, Z, _) {
        var M = k("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(_, "__esModule", {
          value: !0
        }), _.isNodePattern = E, _.throwError = c, _.scan = u, _.scanIterator = l;
        var x = M(k("@babel/runtime/regenerator")), y = /* @__PURE__ */ x.default.mark(l);
        function E(a) {
          if (typeof a > "u")
            return !1;
          if (typeof a != "function")
            throw new TypeError("Callback must be a function");
          return !0;
        }
        function c(a, n) {
          if (typeof a == "string" && (a = new Error(a)), typeof n == "function")
            return n.call(this, a);
          throw a;
        }
        function u(a, n, d, g, h, m) {
          n = Math.round(n), d = Math.round(d), g = Math.round(g), h = Math.round(h);
          for (var s = d; s < d + h; s++)
            for (var b = n; b < n + g; b++) {
              var S = a.bitmap.width * s + b << 2;
              m.call(a, b, s, S);
            }
          return a;
        }
        function l(a, n, d, g, h) {
          var m, s, b;
          return x.default.wrap(function(o) {
            for (; ; )
              switch (o.prev = o.next) {
                case 0:
                  n = Math.round(n), d = Math.round(d), g = Math.round(g), h = Math.round(h), m = d;
                case 5:
                  if (!(m < d + h)) {
                    o.next = 17;
                    break;
                  }
                  s = n;
                case 7:
                  if (!(s < n + g)) {
                    o.next = 14;
                    break;
                  }
                  return b = a.bitmap.width * m + s << 2, o.next = 11, {
                    x: s,
                    y: m,
                    idx: b,
                    image: a
                  };
                case 11:
                  s++, o.next = 7;
                  break;
                case 14:
                  m++, o.next = 5;
                  break;
                case 17:
                case "end":
                  return o.stop();
              }
          }, y);
        }
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/regenerator": 22 }] }, {}, [200])(200);
    });
  }(Il)), Il.exports;
}
var Rl, Pc;
function qo() {
  if (Pc) return Rl;
  Pc = 1;
  function Re(be, ae) {
    this.x = be || 0, this.y = ae || 0;
  }
  return Re.prototype = {
    copy: function() {
      return new Re(this.x, this.y);
    }
  }, Rl = Re, Rl;
}
var Ol, Ic;
function Qo() {
  if (Ic) return Ol;
  Ic = 1;
  var Re = qo(), be = {};
  function ae(m) {
    return be[m] || (be[m] = new RegExp(" " + m + '="((?:\\\\(?=")"|[^"])+)"', "i")), be[m];
  }
  function k(m, s, b) {
    var S = " " + s + '="' + b + '"';
    return m.indexOf(" " + s + '="') === -1 ? m = m.replace(/<[a-z]+/i, function(o) {
      return o + S;
    }) : m = m.replace(ae(s), S), m;
  }
  function Z(m) {
    return m.toFixed(3).replace(".000", "");
  }
  function _(m, s) {
    return m >= s ? m % s : m >= 0 ? m : s - 1 - (-1 - m) % s;
  }
  function M(m, s) {
    return m.x * s.y - m.y * s.x;
  }
  function x(m, s, b) {
    return m <= b ? m <= s && s < b : m <= s || s < b;
  }
  function y(m) {
    return m > 0 ? 1 : m < 0 ? -1 : 0;
  }
  function E(m, s) {
    var b = new Array(3), S, o, A;
    for (b[0] = s.x, b[1] = s.y, b[2] = 1, A = 0, S = 0; S < 3; S++)
      for (o = 0; o < 3; o++)
        A += b[S] * m.at(S, o) * b[o];
    return A;
  }
  function c(m, s, b) {
    var S = new Re();
    return S.x = s.x + m * (b.x - s.x), S.y = s.y + m * (b.y - s.y), S;
  }
  function u(m, s) {
    var b = new Re();
    return b.y = y(s.x - m.x), b.x = -y(s.y - m.y), b;
  }
  function l(m, s) {
    var b = u(m, s);
    return b.y * (s.x - m.x) - b.x * (s.y - m.y);
  }
  function a(m, s, b) {
    var S, o, A, T;
    return S = s.x - m.x, o = s.y - m.y, A = b.x - m.x, T = b.y - m.y, S * T - A * o;
  }
  function n(m, s, b, S) {
    var o, A, T, I;
    return o = s.x - m.x, A = s.y - m.y, T = S.x - b.x, I = S.y - b.y, o * I - T * A;
  }
  function d(m, s, b) {
    var S, o, A, T;
    return S = s.x - m.x, o = s.y - m.y, A = b.x - m.x, T = b.y - m.y, S * A + o * T;
  }
  function g(m, s, b, S) {
    var o, A, T, I;
    return o = s.x - m.x, A = s.y - m.y, T = S.x - b.x, I = S.y - b.y, o * T + A * I;
  }
  function h(m, s) {
    return Math.sqrt((m.x - s.x) * (m.x - s.x) + (m.y - s.y) * (m.y - s.y));
  }
  return Ol = {
    luminance: function(m, s, b) {
      return Math.round(0.2126 * m + 0.7153 * s + 0.0721 * b);
    },
    between: function(m, s, b) {
      return m >= s && m <= b;
    },
    clamp: function(m, s, b) {
      return Math.min(b, Math.max(s, m));
    },
    isNumber: function(m) {
      return typeof m == "number";
    },
    setHtmlAttr: k,
    /**
     * Generates path instructions for given curve
     *
     * @param {Curve} curve
     * @param {Number} [scale]
     * @returns {string}
     */
    renderCurve: function(m, s) {
      s = s || { x: 1, y: 1 };
      var b = m.c[(m.n - 1) * 3 + 2], S = [
        "M " + Z(b.x * s.x) + " " + Z(b.y * s.y)
      ];
      return m.tag.forEach(function(o, A) {
        var T = A * 3, I = m.c[T], L = m.c[T + 1], z = m.c[T + 2];
        o === "CURVE" ? S.push(
          "C " + Z(I.x * s.x) + " " + Z(I.y * s.y) + ", " + Z(L.x * s.x) + " " + Z(L.y * s.y) + ", " + Z(z.x * s.x) + " " + Z(z.y * s.y)
        ) : o === "CORNER" && S.push(
          "L " + Z(L.x * s.x) + " " + Z(L.y * s.y) + " " + Z(z.x * s.x) + " " + Z(z.y * s.y)
        );
      }), S.join(" ");
    },
    bezier: function(s, b, S, o, A) {
      var T = 1 - s, I = new Re();
      return I.x = T * T * T * b.x + 3 * (T * T * s) * S.x + 3 * (s * s * T) * o.x + s * s * s * A.x, I.y = T * T * T * b.y + 3 * (T * T * s) * S.y + 3 * (s * s * T) * o.y + s * s * s * A.y, I;
    },
    tangent: function(s, b, S, o, A, T) {
      var I, L, z, U, J, F, oe, ee, ie, W;
      return I = n(s, b, A, T), L = n(b, S, A, T), z = n(S, o, A, T), U = I - 2 * L + z, J = -2 * I + 2 * L, F = I, oe = J * J - 4 * U * F, U === 0 || oe < 0 ? -1 : (ee = Math.sqrt(oe), ie = (-J + ee) / (2 * U), W = (-J - ee) / (2 * U), ie >= 0 && ie <= 1 ? ie : W >= 0 && W <= 1 ? W : -1);
    },
    mod: _,
    xprod: M,
    cyclic: x,
    sign: y,
    quadform: E,
    interval: c,
    dorth_infty: u,
    ddenom: l,
    dpara: a,
    cprod: n,
    iprod: d,
    iprod1: g,
    ddist: h
  }, Ol;
}
var Ll, Rc;
function Oc() {
  if (Rc) return Ll;
  Rc = 1;
  var Re = Qo(), be = null;
  try {
    be = ld();
  } catch {
  }
  var ae = fd(), k = 256, Z = k - 1;
  function _(y, E) {
    return k * y + E;
  }
  function M(y, E) {
    if (y = typeof y == "number" ? Re.clamp(Math.round(y), 0, Z) : 0, E = typeof E == "number" ? Re.clamp(Math.round(E), 0, Z) : Z, y > E)
      throw new Error('Invalid range "' + y + "..." + E + '"');
    return [y, E];
  }
  function x(y, E) {
    if (this.data = null, this.pixels = 0, this._sortedIndexes = null, this._cachedStats = {}, this._lookupTableH = null, typeof y == "number")
      this._createArray(y);
    else if (y instanceof ae)
      this._collectValuesBitmap(y);
    else if (be && y instanceof be)
      this._collectValuesJimp(y, E);
    else
      throw new Error("Unsupported image source");
  }
  return x.MODE_LUMINANCE = "luminance", x.MODE_R = "r", x.MODE_G = "g", x.MODE_B = "b", x.prototype = {
    /**
     * Initializes data array for an image of given pixel size
     * @param imageSize
     * @returns {Uint8Array|Uint16Array|Uint32Array}
     * @private
     */
    _createArray: function(y) {
      var E = y <= Math.pow(2, 8) ? Uint8Array : y <= Math.pow(2, 16) ? Uint16Array : Uint32Array;
      return this.pixels = y, this.data = new E(k);
    },
    /**
     * Aggregates color data from {@link Jimp} instance
     * @param {Jimp} source
     * @param mode
     * @private
     */
    _collectValuesJimp: function(y, E) {
      var c = y.bitmap.data, u = this._createArray(y.bitmap.width * y.bitmap.height);
      y.scan(0, 0, y.bitmap.width, y.bitmap.height, function(l, a, n) {
        var d = E === x.MODE_R ? c[n] : E === x.MODE_G ? c[n + 1] : E === x.MODE_B ? c[n + 2] : Re.luminance(c[n], c[n + 1], c[n + 2]);
        u[d]++;
      });
    },
    /**
     * Aggregates color data from {@link Bitmap} instance
     * @param {Bitmap} source
     * @private
     */
    _collectValuesBitmap: function(y) {
      for (var E = this._createArray(y.size), c = y.data.length, u, l = 0; l < c; l++)
        u = y.data[l], E[u]++;
    },
    /**
     * Returns array of color indexes in ascending order
     * @param refresh
     * @returns {*}
     * @private
     */
    _getSortedIndexes: function(y) {
      if (!y && this._sortedIndexes)
        return this._sortedIndexes;
      var E = this.data, c = new Array(k), u = 0;
      for (u; u < k; u++)
        c[u] = u;
      return c.sort(function(l, a) {
        return E[l] > E[a] ? 1 : E[l] < E[a] ? -1 : 0;
      }), this._sortedIndexes = c, c;
    },
    /**
     * Builds lookup table H from lookup tables P and S.
     * see {@link http://www.iis.sinica.edu.tw/page/jise/2001/200109_01.pdf|this paper} for more details
     *
     * @returns {Float64Array}
     * @private
     */
    _thresholdingBuildLookupTable: function() {
      var y = new Float64Array(k * k), E = new Float64Array(k * k), c = new Float64Array(k * k), u = this.pixels, l, a, n, d;
      for (l = 1; l < k; ++l)
        n = _(l, l), d = this.data[l] / u, y[n] = d, E[n] = l * d;
      for (l = 1; l < k - 1; ++l)
        d = this.data[l + 1] / u, n = _(1, l), y[n + 1] = y[n] + d, E[n + 1] = E[n] + (l + 1) * d;
      for (l = 2; l < k; l++)
        for (a = l + 1; a < k; a++)
          y[_(l, a)] = y[_(1, a)] - y[_(1, l - 1)], E[_(l, a)] = E[_(1, a)] - E[_(1, l - 1)];
      for (l = 1; l < k; ++l)
        for (a = l + 1; a < k; a++)
          n = _(l, a), c[n] = y[n] !== 0 ? E[n] * E[n] / y[n] : 0;
      return this._lookupTableH = c;
    },
    /**
     * Implements Algorithm For Multilevel Thresholding
     * Receives desired number of color stops, returns array of said size. Could be limited to a range levelMin..levelMax
     *
     * Regardless of levelMin and levelMax values it still relies on between class variances for the entire histogram
     *
     * @param amount - how many thresholds should be calculated
     * @param [levelMin=0] - histogram segment start
     * @param [levelMax=255] - histogram segment end
     * @returns {number[]}
    */
    multilevelThresholding: function(y, E, c) {
      if (E = M(E, c), c = E[1], E = E[0], y = Math.min(c - E - 2, ~~y), y < 1)
        return [];
      this._lookupTableH || this._thresholdingBuildLookupTable();
      var u = this._lookupTableH, l = null, a = 0;
      y > 4 && console.log("[Warning]: Threshold computation for more than 5 levels may take a long time");
      function n(d, g, h, m) {
        d = (d || 0) + 1, g = g || 0, h = h || new Array(y), m = m || 0;
        for (var s = m + 1, b, S = d; S < c - y + m; S++)
          b = g + u[_(d, S)], h[s - 1] = S, s + 1 < y + 1 ? n(S, b, h, s) : (b += u[_(S + 1, c)], a < b && (a = b, l = h.slice()));
      }
      return n(E || 0), l || [];
    },
    /**
     * Automatically finds threshold value using Algorithm For Multilevel Thresholding
     *
     * @param {number} [levelMin]
     * @param {number} [levelMax]
     * @returns {null|number}
     */
    autoThreshold: function(y, E) {
      var c = this.multilevelThresholding(1, y, E);
      return c.length ? c[0] : null;
    },
    /**
     * Returns dominant color in given range. Returns -1 if not a single color from the range present on the image
     *
     * @param [levelMin=0]
     * @param [levelMax=255]
     * @param [tolerance=1]
     * @returns {number}
     */
    getDominantColor: function(y, E, c) {
      y = M(y, E), E = y[1], y = y[0], c = c || 1;
      var u = this.data, l = -1, a = -1, n, d, g;
      if (y === E)
        return u[y] ? y : -1;
      for (n = y; n <= E; n++) {
        for (g = 0, d = ~~(c / -2); d < c; d++)
          g += Re.between(n + d, 0, Z) ? u[n + d] : 0;
        var h = g > a, m = a === g && (l < 0 || u[n] > u[l]);
        (h || m) && (l = n, a = g);
      }
      return a <= 0 ? -1 : l;
    },
    /**
     * Returns stats for histogram or its segment.
     *
     * Returned object contains median, mean and standard deviation for pixel values;
     * peak, mean and median number of pixels per level and few other values
     *
     * If no pixels colors from specified range present on the image - most values will be NaN
     *
     * @param {Number} [levelMin=0] - histogram segment start
     * @param {Number} [levelMax=255] - histogram segment end
     * @param {Boolean} [refresh=false] - if cached result can be returned
     * @returns {{levels: {mean: (number|*), median: *, stdDev: number, unique: number}, pixelsPerLevel: {mean: (number|*), median: (number|*), peak: number}, pixels: number}}
     */
    getStats: function(y, E, c) {
      if (y = M(y, E), E = y[1], y = y[0], !c && this._cachedStats[y + "-" + E])
        return this._cachedStats[y + "-" + E];
      var u = this.data, l = this._getSortedIndexes(), a = 0, n = null, d, g, h, m, s = 0, b = 0, S = 0, o, A, T, I = 0, L = 0;
      for (o = y; o <= E; o++)
        a += u[o], S += u[o] * o, I += u[o] === 0 ? 0 : 1, L < u[o] && (L = u[o]);
      for (d = S / a, h = a / (E - y), m = a / I, g = Math.floor(a / 2), o = 0; o < k; o++)
        T = l[o], A = u[T], !(T < y || T > E) && (b += A, s += Math.pow(T - d, 2) * A, n === null && b >= g && (n = T));
      return this._cachedStats[y + "-" + E] = {
        // various pixel counts for levels (0..255)
        levels: {
          mean: d,
          median: n,
          stdDev: Math.sqrt(s / a),
          unique: I
        },
        // what's visually represented as bars
        pixelsPerLevel: {
          mean: h,
          median: m,
          peak: L
        },
        pixels: a
      };
    }
  }, Ll = x, Ll;
}
var Nl, Lc;
function fd() {
  if (Lc) return Nl;
  Lc = 1;
  var Re = qo(), be = Qo();
  function ae(k, Z) {
    this._histogram = null, this.width = k, this.height = Z, this.size = k * Z, this.arrayBuffer = new ArrayBuffer(this.size), this.data = new Uint8Array(this.arrayBuffer);
  }
  return Nl = ae, Oc(), ae.prototype = {
    /**
     * Returns pixel value
     *
     * @param {Number|Point} x - index, point or x
     * @param {Number} [y]
     */
    getValueAt: function(k, Z) {
      var _ = typeof k == "number" && typeof Z != "number" ? k : this.pointToIndex(k, Z);
      return this.data[_];
    },
    /**
     * Converts {@link Point} to index value
     *
     * @param {Number} index
     * @returns {Point}
     */
    indexToPoint: function(k) {
      var Z = new Re();
      return be.between(k, 0, this.size) ? (Z.y = Math.floor(k / this.width), Z.x = k - Z.y * this.width) : (Z.x = -1, Z.y = -1), Z;
    },
    /**
     * Calculates index for point or coordinate pair
     *
     * @param {Number|Point} pointOrX
     * @param {Number} [y]
     * @returns {Number}
     */
    pointToIndex: function(k, Z) {
      var _ = k, M = Z;
      return k instanceof Re && (_ = k.x, M = k.y), !be.between(_, 0, this.width) || !be.between(M, 0, this.height) ? -1 : this.width * M + _;
    },
    /**
     * Makes a copy of current bitmap
     *
     * @param {Function} [iterator] optional callback, used for processing pixel value. Accepted arguments: value, index
     * @returns {Bitmap}
     */
    copy: function(k) {
      var Z = new ae(this.width, this.height), _ = typeof k == "function", M;
      for (M = 0; M < this.size; M++)
        Z.data[M] = _ ? k(this.data[M], M) : this.data[M];
      return Z;
    },
    histogram: function() {
      var k = Oc();
      return this._histogram ? this._histogram : (this._histogram = new k(this), this._histogram);
    }
  }, Nl;
}
var Dl, Nc;
function E0() {
  if (Nc) return Dl;
  Nc = 1;
  function Re(be) {
    this.n = be, this.tag = new Array(be), this.c = new Array(be * 3), this.alphaCurve = 0, this.vertex = new Array(be), this.alpha = new Array(be), this.alpha0 = new Array(be), this.beta = new Array(be);
  }
  return Dl = Re, Dl;
}
var Bl, Dc;
function x0() {
  if (Dc) return Bl;
  Dc = 1;
  function Re() {
    this.area = 0, this.len = 0, this.curve = {}, this.pt = [], this.minX = 1e5, this.minY = 1e5, this.maxX = -1, this.maxY = -1;
  }
  return Bl = Re, Bl;
}
var zl, Bc;
function C0() {
  if (Bc) return zl;
  Bc = 1;
  function Re() {
    this.data = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  return Re.prototype.at = function(be, ae) {
    return this.data[be * 3 + ae];
  }, zl = Re, zl;
}
var Fl, zc;
function k0() {
  if (zc) return Fl;
  zc = 1;
  function Re(be, ae, k, Z, _) {
    this.x = be, this.y = ae, this.xy = k, this.x2 = Z, this.y2 = _;
  }
  return Fl = Re, Fl;
}
var Ul, Fc;
function A0() {
  if (Fc) return Ul;
  Fc = 1;
  var Re = qo();
  function be() {
    this.pen = 0, this.c = [new Re(), new Re()], this.t = 0, this.s = 0, this.alpha = 0;
  }
  return Ul = be, Ul;
}
var jl, Uc;
function hd() {
  if (Uc) return jl;
  Uc = 1;
  var Re = ld(), be = fd(), ae = E0(), k = qo(), Z = x0(), _ = C0(), M = k0(), x = A0(), y = Qo();
  function E(u) {
    this._luminanceData = null, this._pathlist = [], this._imageLoadingIdentifier = null, this._imageLoaded = !1, this._processed = !1, this._params = {
      turnPolicy: E.TURNPOLICY_MINORITY,
      turdSize: 2,
      alphaMax: 1,
      optCurve: !0,
      optTolerance: 0.2,
      threshold: E.THRESHOLD_AUTO,
      blackOnWhite: !0,
      color: E.COLOR_AUTO,
      background: E.COLOR_TRANSPARENT,
      width: null,
      height: null
    }, u && this.setParameters(u);
  }
  E.COLOR_AUTO = "auto", E.COLOR_TRANSPARENT = "transparent", E.THRESHOLD_AUTO = -1, E.TURNPOLICY_BLACK = "black", E.TURNPOLICY_WHITE = "white", E.TURNPOLICY_LEFT = "left", E.TURNPOLICY_RIGHT = "right", E.TURNPOLICY_MINORITY = "minority", E.TURNPOLICY_MAJORITY = "majority";
  var c = [
    E.TURNPOLICY_BLACK,
    E.TURNPOLICY_WHITE,
    E.TURNPOLICY_LEFT,
    E.TURNPOLICY_RIGHT,
    E.TURNPOLICY_MINORITY,
    E.TURNPOLICY_MAJORITY
  ];
  return E.prototype = {
    /**
     * Creating a new {@link Path} for every group of black pixels.
     * @private
     */
    _bmToPathlist: function() {
      var u = this, l = this._params.threshold, a = this._params.blackOnWhite, n, d = new k(0, 0), g;
      l === E.THRESHOLD_AUTO && (l = this._luminanceData.histogram().autoThreshold() || 128), n = this._luminanceData.copy(function(S) {
        var o = a ? S > l : S < l;
        return o ? 0 : 1;
      });
      function h(S) {
        for (var o = n.pointToIndex(S); o < n.size && n.data[o] !== 1; )
          o++;
        return o < n.size && n.indexToPoint(o);
      }
      function m(S, o) {
        var A, T, I;
        for (A = 2; A < 5; A++) {
          for (I = 0, T = -A + 1; T <= A - 1; T++)
            I += n.getValueAt(S + T, o + A - 1) ? 1 : -1, I += n.getValueAt(S + A - 1, o + T - 1) ? 1 : -1, I += n.getValueAt(S + T - 1, o - A) ? 1 : -1, I += n.getValueAt(S - A, o + T) ? 1 : -1;
          if (I > 0)
            return 1;
          if (I < 0)
            return 0;
        }
        return 0;
      }
      function s(S) {
        var o = new Z(), A = S.x, T = S.y, I = 0, L = 1, z;
        for (o.sign = n.getValueAt(S.x, S.y) ? "+" : "-"; o.pt.push(new k(A, T)), A > o.maxX && (o.maxX = A), A < o.minX && (o.minX = A), T > o.maxY && (o.maxY = T), T < o.minY && (o.minY = T), o.len++, A += I, T += L, o.area -= A * L, !(A === S.x && T === S.y); ) {
          var U = n.getValueAt(A + (I + L - 1) / 2, T + (L - I - 1) / 2), J = n.getValueAt(A + (I - L - 1) / 2, T + (L + I - 1) / 2);
          J && !U ? u._params.turnPolicy === "right" || u._params.turnPolicy === "black" && o.sign === "+" || u._params.turnPolicy === "white" && o.sign === "-" || u._params.turnPolicy === "majority" && m(A, T) || u._params.turnPolicy === "minority" && !m(A, T) ? (z = I, I = -L, L = z) : (z = I, I = L, L = -z) : J ? (z = I, I = -L, L = z) : U || (z = I, I = L, L = -z);
        }
        return o;
      }
      function b(S) {
        var o = S.pt[0].y, A = S.len, T, I, L, z, U, J, F;
        for (U = 1; U < A; U++)
          if (T = S.pt[U].x, I = S.pt[U].y, I !== o) {
            for (z = o < I ? o : I, L = S.maxX, J = T; J < L; J++)
              F = n.pointToIndex(J, z), n.data[F] = n.data[F] ? 0 : 1;
            o = I;
          }
      }
      for (this._pathlist = []; d = h(d); )
        g = s(d), b(g), g.area > u._params.turdSize && this._pathlist.push(g);
    },
    /**
     * Processes path list created by _bmToPathlist method creating and optimizing {@link Curve}'s
     * @private
     */
    _processPath: function() {
      var u = this;
      function l(S) {
        var o, A, T;
        S.x0 = S.pt[0].x, S.y0 = S.pt[0].y, S.sums = [];
        var I = S.sums;
        for (I.push(new M(0, 0, 0, 0, 0)), o = 0; o < S.len; o++)
          A = S.pt[o].x - S.x0, T = S.pt[o].y - S.y0, I.push(new M(
            I[o].x + A,
            I[o].y + T,
            I[o].xy + A * T,
            I[o].x2 + A * A,
            I[o].y2 + T * T
          ));
      }
      function a(S) {
        var o = S.len, A = S.pt, T, I = new Array(o), L = new Array(o), z = new Array(4);
        S.lon = new Array(o);
        var U = [new k(), new k()], J = new k(), F = new k(), oe = new k(), ee, ie, W, Q, de, we, ke, Me, fe = 0;
        for (ie = o - 1; ie >= 0; ie--)
          A[ie].x != A[fe].x && A[ie].y != A[fe].y && (fe = ie + 1), L[ie] = fe;
        for (ie = o - 1; ie >= 0; ie--) {
          for (z[0] = z[1] = z[2] = z[3] = 0, T = (3 + 3 * (A[y.mod(ie + 1, o)].x - A[ie].x) + (A[y.mod(ie + 1, o)].y - A[ie].y)) / 2, z[T]++, U[0].x = 0, U[0].y = 0, U[1].x = 0, U[1].y = 0, fe = L[ie], Q = ie; ; ) {
            if (ee = 0, T = (3 + 3 * y.sign(A[fe].x - A[Q].x) + y.sign(A[fe].y - A[Q].y)) / 2, z[T]++, z[0] && z[1] && z[2] && z[3]) {
              I[ie] = Q, ee = 1;
              break;
            }
            if (J.x = A[fe].x - A[ie].x, J.y = A[fe].y - A[ie].y, y.xprod(U[0], J) < 0 || y.xprod(U[1], J) > 0 || (Math.abs(J.x) <= 1 && Math.abs(J.y) <= 1 || (F.x = J.x + (J.y >= 0 && (J.y > 0 || J.x < 0) ? 1 : -1), F.y = J.y + (J.x <= 0 && (J.x < 0 || J.y < 0) ? 1 : -1), y.xprod(U[0], F) >= 0 && (U[0].x = F.x, U[0].y = F.y), F.x = J.x + (J.y <= 0 && (J.y < 0 || J.x < 0) ? 1 : -1), F.y = J.y + (J.x >= 0 && (J.x > 0 || J.y < 0) ? 1 : -1), y.xprod(U[1], F) <= 0 && (U[1].x = F.x, U[1].y = F.y)), Q = fe, fe = L[Q], !y.cyclic(fe, ie, Q)))
              break;
          }
          ee === 0 && (oe.x = y.sign(A[fe].x - A[Q].x), oe.y = y.sign(A[fe].y - A[Q].y), J.x = A[Q].x - A[ie].x, J.y = A[Q].y - A[ie].y, de = y.xprod(U[0], J), we = y.xprod(U[0], oe), ke = y.xprod(U[1], J), Me = y.xprod(U[1], oe), W = 1e7, we < 0 && (W = Math.floor(de / -we)), Me > 0 && (W = Math.min(W, Math.floor(-ke / Me))), I[ie] = y.mod(Q + W, o));
        }
        for (W = I[o - 1], S.lon[o - 1] = W, ie = o - 2; ie >= 0; ie--)
          y.cyclic(ie + 1, I[ie], W) && (W = I[ie]), S.lon[ie] = W;
        for (ie = o - 1; y.cyclic(y.mod(ie + 1, o), W, S.lon[ie]); ie--)
          S.lon[ie] = W;
      }
      function n(S) {
        function o(we, ke, Me) {
          var fe = we.len, xe = we.pt, Ee = we.sums, Pe, Ue, He, We, Ze, $e, Ve, Ge, Ie, De, Ne, _e, re, $, Ce = 0;
          return Me >= fe && (Me -= fe, Ce = 1), Ce === 0 ? (Pe = Ee[Me + 1].x - Ee[ke].x, Ue = Ee[Me + 1].y - Ee[ke].y, We = Ee[Me + 1].x2 - Ee[ke].x2, He = Ee[Me + 1].xy - Ee[ke].xy, Ze = Ee[Me + 1].y2 - Ee[ke].y2, $e = Me + 1 - ke) : (Pe = Ee[Me + 1].x - Ee[ke].x + Ee[fe].x, Ue = Ee[Me + 1].y - Ee[ke].y + Ee[fe].y, We = Ee[Me + 1].x2 - Ee[ke].x2 + Ee[fe].x2, He = Ee[Me + 1].xy - Ee[ke].xy + Ee[fe].xy, Ze = Ee[Me + 1].y2 - Ee[ke].y2 + Ee[fe].y2, $e = Me + 1 - ke + fe), Ne = (xe[ke].x + xe[Me].x) / 2 - xe[0].x, _e = (xe[ke].y + xe[Me].y) / 2 - xe[0].y, $ = xe[Me].x - xe[ke].x, re = -(xe[Me].y - xe[ke].y), Ve = (We - 2 * Pe * Ne) / $e + Ne * Ne, Ge = (He - Pe * _e - Ue * Ne) / $e + Ne * _e, Ie = (Ze - 2 * Ue * _e) / $e + _e * _e, De = re * re * Ve + 2 * re * $ * Ge + $ * $ * Ie, Math.sqrt(De);
        }
        var A, T, I, L, z = S.len, U = new Array(z + 1), J = new Array(z + 1), F = new Array(z), oe = new Array(z + 1), ee = new Array(z + 1), ie = new Array(z + 1), W, Q, de;
        for (A = 0; A < z; A++)
          de = y.mod(S.lon[y.mod(A - 1, z)] - 1, z), de == A && (de = y.mod(A + 1, z)), de < A ? F[A] = z : F[A] = de;
        for (T = 1, A = 0; A < z; A++)
          for (; T <= F[A]; )
            oe[T] = A, T++;
        for (A = 0, T = 0; A < z; T++)
          ee[T] = A, A = F[A];
        for (ee[T] = z, I = T, A = z, T = I; T > 0; T--)
          ie[T] = A, A = oe[A];
        for (ie[0] = 0, U[0] = 0, T = 1; T <= I; T++)
          for (A = ie[T]; A <= ee[T]; A++) {
            for (Q = -1, L = ee[T - 1]; L >= oe[A]; L--)
              W = o(S, L, A) + U[L], (Q < 0 || W < Q) && (J[A] = L, Q = W);
            U[A] = Q;
          }
        for (S.m = I, S.po = new Array(I), A = z, T = I - 1; A > 0; T--)
          A = J[A], S.po[T] = A;
      }
      function d(S) {
        function o(Ve, Ge, Ie, De, Ne) {
          for (var _e = Ve.len, re = Ve.sums, $, Ce, ve, Y, G, Ae, e, r, f, C, R, B = 0; Ie >= _e; )
            Ie -= _e, B += 1;
          for (; Ge >= _e; )
            Ge -= _e, B -= 1;
          for (; Ie < 0; )
            Ie += _e, B -= 1;
          for (; Ge < 0; )
            Ge += _e, B += 1;
          $ = re[Ie + 1].x - re[Ge].x + B * re[_e].x, Ce = re[Ie + 1].y - re[Ge].y + B * re[_e].y, ve = re[Ie + 1].x2 - re[Ge].x2 + B * re[_e].x2, Y = re[Ie + 1].xy - re[Ge].xy + B * re[_e].xy, G = re[Ie + 1].y2 - re[Ge].y2 + B * re[_e].y2, Ae = Ie + 1 - Ge + B * _e, De.x = $ / Ae, De.y = Ce / Ae, e = (ve - $ * $ / Ae) / Ae, r = (Y - $ * Ce / Ae) / Ae, f = (G - Ce * Ce / Ae) / Ae, C = (e + f + Math.sqrt((e - f) * (e - f) + 4 * r * r)) / 2, e -= C, f -= C, Math.abs(e) >= Math.abs(f) ? (R = Math.sqrt(e * e + r * r), R !== 0 && (Ne.x = -r / R, Ne.y = e / R)) : (R = Math.sqrt(f * f + r * r), R !== 0 && (Ne.x = -f / R, Ne.y = r / R)), R === 0 && (Ne.x = Ne.y = 0);
        }
        var A = S.m, T = S.po, I = S.len, L = S.pt, z = S.x0, U = S.y0, J = new Array(A), F = new Array(A), oe = new Array(A), ee = new Array(3), ie, W, Q, de, we, ke = new k();
        for (S.curve = new ae(A), W = 0; W < A; W++)
          Q = T[y.mod(W + 1, A)], Q = y.mod(Q - T[W], I) + T[W], J[W] = new k(), F[W] = new k(), o(S, T[W], Q, J[W], F[W]);
        for (W = 0; W < A; W++)
          if (oe[W] = new _(), ie = F[W].x * F[W].x + F[W].y * F[W].y, ie === 0)
            for (Q = 0; Q < 3; Q++)
              for (de = 0; de < 3; de++)
                oe[W].data[Q * 3 + de] = 0;
          else
            for (ee[0] = F[W].y, ee[1] = -F[W].x, ee[2] = -ee[1] * J[W].y - ee[0] * J[W].x, we = 0; we < 3; we++)
              for (de = 0; de < 3; de++)
                oe[W].data[we * 3 + de] = ee[we] * ee[de] / ie;
        var Me, fe, xe, Ee, Pe, Ue, He, We, Ze, $e;
        for (W = 0; W < A; W++) {
          for (Me = new _(), fe = new k(), ke.x = L[T[W]].x - z, ke.y = L[T[W]].y - U, Q = y.mod(W - 1, A), we = 0; we < 3; we++)
            for (de = 0; de < 3; de++)
              Me.data[we * 3 + de] = oe[Q].at(we, de) + oe[W].at(we, de);
          for (; ; ) {
            if (Pe = Me.at(0, 0) * Me.at(1, 1) - Me.at(0, 1) * Me.at(1, 0), Pe !== 0) {
              fe.x = (-Me.at(0, 2) * Me.at(1, 1) + Me.at(1, 2) * Me.at(0, 1)) / Pe, fe.y = (Me.at(0, 2) * Me.at(1, 0) - Me.at(1, 2) * Me.at(0, 0)) / Pe;
              break;
            }
            for (Me.at(0, 0) > Me.at(1, 1) ? (ee[0] = -Me.at(0, 1), ee[1] = Me.at(0, 0)) : Me.at(1, 1) ? (ee[0] = -Me.at(1, 1), ee[1] = Me.at(1, 0)) : (ee[0] = 1, ee[1] = 0), ie = ee[0] * ee[0] + ee[1] * ee[1], ee[2] = -ee[1] * ke.y - ee[0] * ke.x, we = 0; we < 3; we++)
              for (de = 0; de < 3; de++)
                Me.data[we * 3 + de] += ee[we] * ee[de] / ie;
          }
          if (xe = Math.abs(fe.x - ke.x), Ee = Math.abs(fe.y - ke.y), xe <= 0.5 && Ee <= 0.5) {
            S.curve.vertex[W] = new k(fe.x + z, fe.y + U);
            continue;
          }
          if (Ue = y.quadform(Me, ke), We = ke.x, Ze = ke.y, Me.at(0, 0) !== 0)
            for ($e = 0; $e < 2; $e++)
              fe.y = ke.y - 0.5 + $e, fe.x = -(Me.at(0, 1) * fe.y + Me.at(0, 2)) / Me.at(0, 0), xe = Math.abs(fe.x - ke.x), He = y.quadform(Me, fe), xe <= 0.5 && He < Ue && (Ue = He, We = fe.x, Ze = fe.y);
          if (Me.at(1, 1) !== 0)
            for ($e = 0; $e < 2; $e++)
              fe.x = ke.x - 0.5 + $e, fe.y = -(Me.at(1, 0) * fe.x + Me.at(1, 2)) / Me.at(1, 1), Ee = Math.abs(fe.y - ke.y), He = y.quadform(Me, fe), Ee <= 0.5 && He < Ue && (Ue = He, We = fe.x, Ze = fe.y);
          for (we = 0; we < 2; we++)
            for (de = 0; de < 2; de++)
              fe.x = ke.x - 0.5 + we, fe.y = ke.y - 0.5 + de, He = y.quadform(Me, fe), He < Ue && (Ue = He, We = fe.x, Ze = fe.y);
          S.curve.vertex[W] = new k(We + z, Ze + U);
        }
      }
      function g(S) {
        var o = S.curve, A = o.n, T = o.vertex, I, L, z;
        for (I = 0, L = A - 1; I < L; I++, L--)
          z = T[I], T[I] = T[L], T[L] = z;
      }
      function h(S) {
        var o = S.curve.n, A = S.curve, T, I, L, z, U, J, F, oe, ee;
        for (T = 0; T < o; T++)
          I = y.mod(T + 1, o), L = y.mod(T + 2, o), ee = y.interval(1 / 2, A.vertex[L], A.vertex[I]), U = y.ddenom(A.vertex[T], A.vertex[L]), U !== 0 ? (z = y.dpara(A.vertex[T], A.vertex[I], A.vertex[L]) / U, z = Math.abs(z), J = z > 1 ? 1 - 1 / z : 0, J = J / 0.75) : J = 4 / 3, A.alpha0[I] = J, J >= u._params.alphaMax ? (A.tag[I] = "CORNER", A.c[3 * I + 1] = A.vertex[I], A.c[3 * I + 2] = ee) : (J < 0.55 ? J = 0.55 : J > 1 && (J = 1), F = y.interval(0.5 + 0.5 * J, A.vertex[T], A.vertex[I]), oe = y.interval(0.5 + 0.5 * J, A.vertex[L], A.vertex[I]), A.tag[I] = "CURVE", A.c[3 * I + 0] = F, A.c[3 * I + 1] = oe, A.c[3 * I + 2] = ee), A.alpha[I] = J, A.beta[I] = 0.5;
        A.alphaCurve = 1;
      }
      function m(S) {
        function o(Ue, He, We, Ze, $e, Ve, Ge) {
          var Ie = Ue.curve.n, De = Ue.curve, Ne = De.vertex, _e, re, $, Ce, ve, Y, G, Ae, e, r, f, C, R, B, j, H, X, ue, pe, P, q, K, ye;
          if (He == We || (_e = He, ve = y.mod(He + 1, Ie), re = y.mod(_e + 1, Ie), Ce = Ve[re], Ce === 0))
            return 1;
          for (Ae = y.ddist(Ne[He], Ne[ve]), _e = re; _e != We; _e = re)
            if (re = y.mod(_e + 1, Ie), $ = y.mod(_e + 2, Ie), Ve[re] != Ce || y.sign(y.cprod(Ne[He], Ne[ve], Ne[re], Ne[$])) != Ce || y.iprod1(Ne[He], Ne[ve], Ne[re], Ne[$]) < Ae * y.ddist(Ne[re], Ne[$]) * -0.999847695156)
              return 1;
          if (f = De.c[y.mod(He, Ie) * 3 + 2].copy(), C = Ne[y.mod(He + 1, Ie)].copy(), R = Ne[y.mod(We, Ie)].copy(), B = De.c[y.mod(We, Ie) * 3 + 2].copy(), Y = Ge[We] - Ge[He], Y -= y.dpara(Ne[0], De.c[He * 3 + 2], De.c[We * 3 + 2]) / 2, He >= We && (Y += Ge[Ie]), ue = y.dpara(f, C, R), pe = y.dpara(f, C, B), P = y.dpara(f, R, B), q = ue + P - pe, pe == ue || (ye = P / (P - q), K = pe / (pe - ue), H = pe * ye / 2, H === 0))
            return 1;
          for (X = Y / H, G = 2 - Math.sqrt(4 - X / 0.3), Ze.c[0] = y.interval(ye * G, f, C), Ze.c[1] = y.interval(K * G, B, R), Ze.alpha = G, Ze.t = ye, Ze.s = K, C = Ze.c[0].copy(), R = Ze.c[1].copy(), Ze.pen = 0, _e = y.mod(He + 1, Ie); _e != We; _e = re) {
            if (re = y.mod(_e + 1, Ie), ye = y.tangent(f, C, R, B, Ne[_e], Ne[re]), ye < -0.5 || (j = y.bezier(ye, f, C, R, B), Ae = y.ddist(Ne[_e], Ne[re]), Ae === 0) || (e = y.dpara(Ne[_e], Ne[re], j) / Ae, Math.abs(e) > $e) || y.iprod(Ne[_e], Ne[re], j) < 0 || y.iprod(Ne[re], Ne[_e], j) < 0)
              return 1;
            Ze.pen += e * e;
          }
          for (_e = He; _e != We; _e = re) {
            if (re = y.mod(_e + 1, Ie), ye = y.tangent(f, C, R, B, De.c[_e * 3 + 2], De.c[re * 3 + 2]), ye < -0.5 || (j = y.bezier(ye, f, C, R, B), Ae = y.ddist(De.c[_e * 3 + 2], De.c[re * 3 + 2]), Ae === 0) || (e = y.dpara(De.c[_e * 3 + 2], De.c[re * 3 + 2], j) / Ae, r = y.dpara(De.c[_e * 3 + 2], De.c[re * 3 + 2], Ne[re]) / Ae, r *= 0.75 * De.alpha[re], r < 0 && (e = -e, r = -r), e < r - $e))
              return 1;
            e < r && (Ze.pen += (e - r) * (e - r));
          }
          return 0;
        }
        var A = S.curve, T = A.n, I = A.vertex, L = new Array(T + 1), z = new Array(T + 1), U = new Array(T + 1), J = new Array(T + 1), F, oe, ee, ie, W = new x(), Q, de, we, ke, Me, fe, xe, Ee = new Array(T), Pe = new Array(T + 1);
        for (oe = 0; oe < T; oe++)
          A.tag[oe] == "CURVE" ? Ee[oe] = y.sign(y.dpara(I[y.mod(oe - 1, T)], I[oe], I[y.mod(oe + 1, T)])) : Ee[oe] = 0;
        for (we = 0, Pe[0] = 0, Q = A.vertex[0], oe = 0; oe < T; oe++)
          de = y.mod(oe + 1, T), A.tag[de] == "CURVE" && (ke = A.alpha[de], we += 0.3 * ke * (4 - ke) * y.dpara(A.c[oe * 3 + 2], I[de], A.c[de * 3 + 2]) / 2, we += y.dpara(Q, A.c[oe * 3 + 2], A.c[de * 3 + 2]) / 2), Pe[oe + 1] = we;
        for (L[0] = -1, z[0] = 0, U[0] = 0, ee = 1; ee <= T; ee++)
          for (L[ee] = ee - 1, z[ee] = z[ee - 1], U[ee] = U[ee - 1] + 1, oe = ee - 2; oe >= 0 && (ie = o(
            S,
            oe,
            y.mod(ee, T),
            W,
            u._params.optTolerance,
            Ee,
            Pe
          ), !ie); oe--)
            (U[ee] > U[oe] + 1 || U[ee] == U[oe] + 1 && z[ee] > z[oe] + W.pen) && (L[ee] = oe, z[ee] = z[oe] + W.pen, U[ee] = U[oe] + 1, J[ee] = W, W = new x());
        for (F = U[T], Me = new ae(F), fe = new Array(F), xe = new Array(F), ee = T, oe = F - 1; oe >= 0; oe--)
          L[ee] == ee - 1 ? (Me.tag[oe] = A.tag[y.mod(ee, T)], Me.c[oe * 3 + 0] = A.c[y.mod(ee, T) * 3 + 0], Me.c[oe * 3 + 1] = A.c[y.mod(ee, T) * 3 + 1], Me.c[oe * 3 + 2] = A.c[y.mod(ee, T) * 3 + 2], Me.vertex[oe] = A.vertex[y.mod(ee, T)], Me.alpha[oe] = A.alpha[y.mod(ee, T)], Me.alpha0[oe] = A.alpha0[y.mod(ee, T)], Me.beta[oe] = A.beta[y.mod(ee, T)], fe[oe] = xe[oe] = 1) : (Me.tag[oe] = "CURVE", Me.c[oe * 3 + 0] = J[ee].c[0], Me.c[oe * 3 + 1] = J[ee].c[1], Me.c[oe * 3 + 2] = A.c[y.mod(ee, T) * 3 + 2], Me.vertex[oe] = y.interval(
            J[ee].s,
            A.c[y.mod(ee, T) * 3 + 2],
            I[y.mod(ee, T)]
          ), Me.alpha[oe] = J[ee].alpha, Me.alpha0[oe] = J[ee].alpha, fe[oe] = J[ee].s, xe[oe] = J[ee].t), ee = L[ee];
        for (oe = 0; oe < F; oe++)
          de = y.mod(oe + 1, F), Me.beta[oe] = fe[oe] / (fe[oe] + xe[de]);
        Me.alphaCurve = 1, S.curve = Me;
      }
      for (var s = 0; s < this._pathlist.length; s++) {
        var b = this._pathlist[s];
        l(b), a(b), n(b), d(b), b.sign === "-" && g(b), h(b), u._params.optCurve && m(b);
      }
    },
    /**
     * Validates some of parameters
     * @param params
     * @private
     */
    _validateParameters: function(u) {
      if (u && u.turnPolicy && c.indexOf(u.turnPolicy) === -1) {
        var l = "'" + c.join("', '") + "'";
        throw new Error("Bad turnPolicy value. Allowed values are: " + l);
      }
      if (u && u.threshold != null && u.threshold !== E.THRESHOLD_AUTO && (typeof u.threshold != "number" || !y.between(u.threshold, 0, 255)))
        throw new Error("Bad threshold value. Expected to be an integer in range 0..255");
      if (u && u.optCurve != null && typeof u.optCurve != "boolean")
        throw new Error("'optCurve' must be Boolean");
    },
    _processLoadedImage: function(u) {
      var l = new be(u.bitmap.width, u.bitmap.height), a = u.bitmap.data;
      u.scan(0, 0, u.bitmap.width, u.bitmap.height, function(n, d, g) {
        var h = a[g + 3] / 255, m = 255 + (a[g + 0] - 255) * h, s = 255 + (a[g + 1] - 255) * h, b = 255 + (a[g + 2] - 255) * h;
        l.data[g / 4] = y.luminance(m, s, b);
      }), this._luminanceData = l, this._imageLoaded = !0;
    },
    /**
     * Reads given image. Uses {@link Jimp} under the hood, so target can be whatever Jimp can take
     *
     * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or BMP
     * @param {Function} callback
     */
    loadImage: function(u, l) {
      var a = this, n = {};
      this._imageLoadingIdentifier = n, this._imageLoaded = !1, u instanceof Re ? (this._imageLoadingIdentifier = null, this._imageLoaded = !0, a._processLoadedImage(u), l.call(a, null)) : Re.read(u, function(d, g) {
        var h = a._imageLoadingIdentifier !== n;
        if (h) {
          var m = d || new Error("Another image was loaded instead");
          return l.call(a, m);
        }
        a._imageLoadingIdentifier = null, a._processLoadedImage(g), l.call(a, null);
      });
    },
    /**
     * Sets algorithm parameters
     * @param {Potrace~Options} newParams
     */
    setParameters: function(u) {
      var l, a;
      this._validateParameters(u);
      for (l in this._params)
        this._params.hasOwnProperty(l) && u.hasOwnProperty(l) && (a = this._params[l], this._params[l] = u[l], a !== this._params[l] && ["color", "background"].indexOf(l) === -1 && (this._processed = !1));
    },
    /**
     * Generates just <path> tag without rest of the SVG file
     *
     * @param {String} [fillColor] - overrides color from parameters
     * @returns {String}
     */
    getPathTag: function(u, l) {
      if (u = arguments.length === 0 ? this._params.color : u, u === E.COLOR_AUTO && (u = this._params.blackOnWhite ? "black" : "white"), !this._imageLoaded)
        throw new Error("Image should be loaded first");
      this._processed || (this._bmToPathlist(), this._processPath(), this._processed = !0);
      var a = '<path d="';
      return a += this._pathlist.map(function(n) {
        return y.renderCurve(n.curve, l);
      }).join(" "), a += '" stroke="none" fill="' + u + '" fill-rule="evenodd"/>', a;
    },
    /**
     * Returns <symbol> tag. Always has viewBox specified and comes with no fill color,
     * so it could be changed with <use> tag
     *
     * @param id
     * @returns {string}
     */
    getSymbol: function(u) {
      return '<symbol viewBox="0 0 ' + this._luminanceData.width + " " + this._luminanceData.height + '" id="' + u + '">' + this.getPathTag("") + "</symbol>";
    },
    /**
     * Generates SVG image
     * @returns {String}
     */
    getSVG: function() {
      var u = this._params.width || this._luminanceData.width, l = this._params.height || this._luminanceData.height, a = {
        x: this._params.width ? this._params.width / this._luminanceData.width : 1,
        y: this._params.height ? this._params.height / this._luminanceData.height : 1
      };
      return '<svg xmlns="http://www.w3.org/2000/svg" width="' + u + '" height="' + l + '" viewBox="0 0 ' + u + " " + l + `" version="1.1">
` + (this._params.background !== E.COLOR_TRANSPARENT ? '	<rect x="0" y="0" width="100%" height="100%" fill="' + this._params.background + `" />
` : "") + "	" + this.getPathTag(this._params.color, a) + `
</svg>`;
    }
  }, jl = E, jl;
}
var Hl, jc;
function T0() {
  if (jc) return Hl;
  jc = 1;
  var Re = hd(), be = Qo();
  function ae(Z) {
    this._potrace = new Re(), this._calculatedThreshold = null, this._params = {
      threshold: Re.THRESHOLD_AUTO,
      blackOnWhite: !0,
      steps: ae.STEPS_AUTO,
      background: Re.COLOR_TRANSPARENT,
      fillStrategy: ae.FILL_DOMINANT,
      rangeDistribution: ae.RANGES_AUTO
    }, Z && this.setParameters(Z);
  }
  for (var k in Re)
    Object.prototype.hasOwnProperty.call(Re, k) && k === k.toUpperCase() && (ae[k] = Re[k]);
  return ae.STEPS_AUTO = -1, ae.FILL_SPREAD = "spread", ae.FILL_DOMINANT = "dominant", ae.FILL_MEDIAN = "median", ae.FILL_MEAN = "mean", ae.RANGES_AUTO = "auto", ae.RANGES_EQUAL = "equal", ae.prototype = {
    /**
     * Fine tuning to color ranges.
     *
     * If last range (featuring most saturated color) is larger than 10% of color space (25 units)
     * then we want to add another color stop, that hopefully will include darkest pixels, improving presence of
     * shadows and line art
     *
     * @param ranges
     * @private
     */
    _addExtraColorStop: function(Z) {
      var _ = this._params.blackOnWhite, M = Z[Z.length - 1], x = _ ? 0 : M.value, y = _ ? M.value : 255;
      if (y - x > 25 && M.colorIntensity !== 1) {
        var E = this._getImageHistogram(), c = E.getStats(x, y).levels, u = c.mean + c.stdDev <= 25 ? c.mean + c.stdDev : c.mean - c.stdDev <= 25 ? c.mean - c.stdDev : 25, l = _ ? E.getStats(0, u) : E.getStats(u, 255), a = l.levels.mean;
        Z.push({
          value: Math.abs((_ ? 0 : 255) - u),
          colorIntensity: isNaN(a) ? 0 : (_ ? 255 - a : a) / 255
        });
      }
      return Z;
    },
    /**
     * Calculates color intensity for each element of numeric array
     * 
     * @param {number[]} colorStops
     * @returns {{ levels: number, colorIntensity: number }[]}
     * @private
     */
    _calcColorIntensity: function(Z) {
      var _ = this._params.blackOnWhite, M = this._params.fillStrategy, x = M !== ae.FILL_SPREAD ? this._getImageHistogram() : null, y = Math.abs(this._paramThreshold() - (_ ? 0 : 255));
      return Z.map(function(E, c) {
        var u = c + 1 === Z.length ? _ ? -1 : 256 : Z[c + 1], l = Math.round(_ ? u + 1 : E), a = Math.round(_ ? E : u - 1), n = c / (Z.length - 1), d = a - l, g = x.getStats(l, a), h = -1;
        if (g.pixels === 0)
          return {
            value: E,
            colorIntensity: 0
          };
        switch (M) {
          case ae.FILL_SPREAD:
            h = (_ ? l : a) + (_ ? 1 : -1) * d * Math.max(0.5, y / 255) * n;
            break;
          case ae.FILL_DOMINANT:
            h = x.getDominantColor(l, a, be.clamp(d, 1, 5));
            break;
          case ae.FILL_MEAN:
            h = g.levels.mean;
            break;
          case ae.FILL_MEDIAN:
            h = g.levels.median;
            break;
        }
        return c !== 0 && (h = _ ? be.clamp(h, l, a - Math.round(d * 0.1)) : be.clamp(h, l + Math.round(d * 0.1), a)), {
          value: E,
          colorIntensity: h === -1 ? 0 : (_ ? 255 - h : h) / 255
        };
      });
    },
    /**
     * @returns {Histogram}
     * @private
     */
    _getImageHistogram: function() {
      return this._potrace._luminanceData.histogram();
    },
    /**
     * Processes threshold, steps and rangeDistribution parameters and returns normalized array of color stops
     * @returns {*}
     * @private
     */
    _getRanges: function() {
      var Z = this._paramSteps();
      if (!Array.isArray(Z))
        return this._params.rangeDistribution === ae.RANGES_AUTO ? this._getRangesAuto() : this._getRangesEquallyDistributed();
      var _ = [], M = this._paramThreshold(), x = this._params.blackOnWhite;
      return Z.forEach(function(y) {
        _.indexOf(y) === -1 && be.between(y, 0, 255) && _.push(y);
      }), _.length || _.push(M), _ = _.sort(function(y, E) {
        return y < E === x ? 1 : -1;
      }), x && _[0] < M ? _.unshift(M) : !x && _[_.length - 1] < M && _.push(M), this._calcColorIntensity(_);
    },
    /**
     * Calculates given (or lower) number of thresholds using automatic thresholding algorithm
     * @returns {*}
     * @private
     */
    _getRangesAuto: function() {
      var Z = this._getImageHistogram(), _ = this._paramSteps(!0), M;
      if (this._params.threshold === Re.THRESHOLD_AUTO)
        M = Z.multilevelThresholding(_);
      else {
        var x = this._paramThreshold();
        M = this._params.blackOnWhite ? Z.multilevelThresholding(_ - 1, 0, x) : Z.multilevelThresholding(_ - 1, x, 255), this._params.blackOnWhite ? M.push(x) : M.unshift(x);
      }
      return this._params.blackOnWhite && (M = M.reverse()), this._calcColorIntensity(M);
    },
    /**
     * Calculates color stops and color representing each segment, returning them
     * from least to most intense color (black or white, depending on blackOnWhite parameter)
     *
     * @private
     */
    _getRangesEquallyDistributed: function() {
      for (var Z = this._params.blackOnWhite, _ = Z ? this._paramThreshold() : 255 - this._paramThreshold(), M = this._paramSteps(), x = _ / M, y = [], E = M - 1, c; E >= 0; )
        c = Math.min(_, (E + 1) * x), c = Z ? c : 255 - c, E--, y.push(c);
      return this._calcColorIntensity(y);
    },
    /**
     * Returns valid steps value
     * @param {Boolean} [count=false]
     * @returns {number|number[]}
     * @private
     */
    _paramSteps: function(Z) {
      var _ = this._params.steps;
      if (Array.isArray(_))
        return Z ? _.length : _;
      if (_ === ae.STEPS_AUTO && this._params.threshold === Re.THRESHOLD_AUTO)
        return 4;
      var M = this._params.blackOnWhite, x = M ? this._paramThreshold() : 255 - this._paramThreshold();
      return _ === ae.STEPS_AUTO ? x > 200 ? 4 : 3 : Math.min(x, Math.max(2, _));
    },
    /**
     * Returns valid threshold value
     * @returns {number}
     * @private
     */
    _paramThreshold: function() {
      if (this._calculatedThreshold !== null)
        return this._calculatedThreshold;
      if (this._params.threshold !== Re.THRESHOLD_AUTO)
        return this._calculatedThreshold = this._params.threshold, this._calculatedThreshold;
      var Z = this._getImageHistogram().multilevelThresholding(2);
      return this._calculatedThreshold = this._params.blackOnWhite ? Z[1] : Z[0], this._calculatedThreshold = this._calculatedThreshold || 128, this._calculatedThreshold;
    },
    /**
     * Running potrace on the image multiple times with different thresholds and returns an array
     * of path tags
     *
     * @param {Boolean} [noFillColor]
     * @returns {string[]}
     * @private
     */
    _pathTags: function(Z) {
      var _ = this._getRanges(), M = this._potrace, x = this._params.blackOnWhite;
      _.length >= 10 && (_ = this._addExtraColorStop(_)), M.setParameters({ blackOnWhite: x });
      var y = 0;
      return _.map(function(E) {
        var c = E.colorIntensity;
        if (c === 0)
          return "";
        var u = !y || c === 1 ? c : (y - c) / (y - 1);
        u = be.clamp(parseFloat(u.toFixed(3)), 0, 1), y = y + (1 - y) * u, M.setParameters({ threshold: E.value });
        var l = Z ? M.getPathTag("") : M.getPathTag();
        l = be.setHtmlAttr(l, "fill-opacity", u.toFixed(3));
        var a = u === 0 || l.indexOf(' d=""') !== -1;
        return a ? "" : l;
      });
    },
    /**
     * Loads image.
     *
     * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or BMP
     * @param {Function} callback
     */
    loadImage: function(Z, _) {
      var M = this;
      this._potrace.loadImage(Z, function(x) {
        M._calculatedThreshold = null, _.call(M, x);
      });
    },
    /**
     * Sets parameters. Accepts same object as {Potrace}
     *
     * @param {Posterizer~Options} params
     */
    setParameters: function(Z) {
      if (Z) {
        if (this._potrace.setParameters(Z), Z.steps && !Array.isArray(Z.steps) && (!be.isNumber(Z.steps) || !be.between(Z.steps, 1, 255)))
          throw new Error("Bad 'steps' value");
        for (var _ in this._params)
          this._params.hasOwnProperty(_) && Z.hasOwnProperty(_) && (this._params[_] = Z[_]);
        this._calculatedThreshold = null;
      }
    },
    /**
     * Returns image as <symbol> tag. Always has viewBox specified
     *
     * @param {string} id
     */
    getSymbol: function(Z) {
      var _ = this._potrace._luminanceData.width, M = this._potrace._luminanceData.height, x = this._pathTags(!0);
      return '<symbol viewBox="0 0 ' + _ + " " + M + '" id="' + Z + '">' + x.join("") + "</symbol>";
    },
    /**
     * Generates SVG image
     * @returns {String}
     */
    getSVG: function() {
      var Z = this._potrace._luminanceData.width, _ = this._potrace._luminanceData.height, M = this._pathTags(!1), x = '<svg xmlns="http://www.w3.org/2000/svg" width="' + Z + '" height="' + _ + '" viewBox="0 0 ' + Z + " " + _ + `" version="1.1">
	` + (this._params.background !== Re.COLOR_TRANSPARENT ? '<rect x="0" y="0" width="100%" height="100%" fill="' + this._params.background + `" />
	` : "") + M.join(`
	`) + `
</svg>`;
      return x.replace(/\n(?:\t*\n)+(\t*)/g, `
$1`);
    }
  }, Hl = ae, Hl;
}
var Gl, Hc;
function M0() {
  if (Hc) return Gl;
  Hc = 1;
  var Re = hd(), be = T0();
  function ae(Z, _, M) {
    arguments.length === 2 && (M = _, _ = {});
    var x = new Re(_);
    x.loadImage(Z, function(y) {
      if (y)
        return M(y);
      M(null, x.getSVG(), x);
    });
  }
  function k(Z, _, M) {
    arguments.length === 2 && (M = _, _ = {});
    var x = new be(_);
    x.loadImage(Z, function(y) {
      if (y)
        return M(y);
      M(null, x.getSVG(), x);
    });
  }
  return Gl = {
    trace: ae,
    posterize: k,
    Potrace: Re,
    Posterizer: be
  }, Gl;
}
var P0 = M0();
const Vl = /* @__PURE__ */ Yo(P0);
var Vo = { exports: {} };
const I0 = {}, R0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: I0
}, Symbol.toStringTag, { value: "Module" })), Gc = /* @__PURE__ */ ip(R0);
var Ps = { exports: {} }, O0 = Ps.exports, Vc;
function L0() {
  return Vc || (Vc = 1, function(Re, be) {
    (function(ae, k) {
      k(be);
    })(O0, function(ae) {
      var k = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], Z = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], _ = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", M = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", x = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      }, y = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", E = {
        5: y,
        "5module": y + " export import",
        6: y + " const class extends export import super"
      }, c = /^in(stanceof)?$/, u = new RegExp("[" + M + "]"), l = new RegExp("[" + M + _ + "]");
      function a(p, V) {
        for (var Te = 65536, Le = 0; Le < V.length; Le += 2) {
          if (Te += V[Le], Te > p)
            return !1;
          if (Te += V[Le + 1], Te >= p)
            return !0;
        }
        return !1;
      }
      function n(p, V) {
        return p < 65 ? p === 36 : p < 91 ? !0 : p < 97 ? p === 95 : p < 123 ? !0 : p <= 65535 ? p >= 170 && u.test(String.fromCharCode(p)) : V === !1 ? !1 : a(p, Z);
      }
      function d(p, V) {
        return p < 48 ? p === 36 : p < 58 ? !0 : p < 65 ? !1 : p < 91 ? !0 : p < 97 ? p === 95 : p < 123 ? !0 : p <= 65535 ? p >= 170 && l.test(String.fromCharCode(p)) : V === !1 ? !1 : a(p, Z) || a(p, k);
      }
      var g = function(V, Te) {
        Te === void 0 && (Te = {}), this.label = V, this.keyword = Te.keyword, this.beforeExpr = !!Te.beforeExpr, this.startsExpr = !!Te.startsExpr, this.isLoop = !!Te.isLoop, this.isAssign = !!Te.isAssign, this.prefix = !!Te.prefix, this.postfix = !!Te.postfix, this.binop = Te.binop || null, this.updateContext = null;
      };
      function h(p, V) {
        return new g(p, { beforeExpr: !0, binop: V });
      }
      var m = { beforeExpr: !0 }, s = { startsExpr: !0 }, b = {};
      function S(p, V) {
        return V === void 0 && (V = {}), V.keyword = p, b[p] = new g(p, V);
      }
      var o = {
        num: new g("num", s),
        regexp: new g("regexp", s),
        string: new g("string", s),
        name: new g("name", s),
        privateId: new g("privateId", s),
        eof: new g("eof"),
        // Punctuation token types.
        bracketL: new g("[", { beforeExpr: !0, startsExpr: !0 }),
        bracketR: new g("]"),
        braceL: new g("{", { beforeExpr: !0, startsExpr: !0 }),
        braceR: new g("}"),
        parenL: new g("(", { beforeExpr: !0, startsExpr: !0 }),
        parenR: new g(")"),
        comma: new g(",", m),
        semi: new g(";", m),
        colon: new g(":", m),
        dot: new g("."),
        question: new g("?", m),
        questionDot: new g("?."),
        arrow: new g("=>", m),
        template: new g("template"),
        invalidTemplate: new g("invalidTemplate"),
        ellipsis: new g("...", m),
        backQuote: new g("`", s),
        dollarBraceL: new g("${", { beforeExpr: !0, startsExpr: !0 }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new g("=", { beforeExpr: !0, isAssign: !0 }),
        assign: new g("_=", { beforeExpr: !0, isAssign: !0 }),
        incDec: new g("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
        prefix: new g("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        logicalOR: h("||", 1),
        logicalAND: h("&&", 2),
        bitwiseOR: h("|", 3),
        bitwiseXOR: h("^", 4),
        bitwiseAND: h("&", 5),
        equality: h("==/!=/===/!==", 6),
        relational: h("</>/<=/>=", 7),
        bitShift: h("<</>>/>>>", 8),
        plusMin: new g("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
        modulo: h("%", 10),
        star: h("*", 10),
        slash: h("/", 10),
        starstar: new g("**", { beforeExpr: !0 }),
        coalesce: h("??", 1),
        // Keyword token types.
        _break: S("break"),
        _case: S("case", m),
        _catch: S("catch"),
        _continue: S("continue"),
        _debugger: S("debugger"),
        _default: S("default", m),
        _do: S("do", { isLoop: !0, beforeExpr: !0 }),
        _else: S("else", m),
        _finally: S("finally"),
        _for: S("for", { isLoop: !0 }),
        _function: S("function", s),
        _if: S("if"),
        _return: S("return", m),
        _switch: S("switch"),
        _throw: S("throw", m),
        _try: S("try"),
        _var: S("var"),
        _const: S("const"),
        _while: S("while", { isLoop: !0 }),
        _with: S("with"),
        _new: S("new", { beforeExpr: !0, startsExpr: !0 }),
        _this: S("this", s),
        _super: S("super", s),
        _class: S("class", s),
        _extends: S("extends", m),
        _export: S("export"),
        _import: S("import", s),
        _null: S("null", s),
        _true: S("true", s),
        _false: S("false", s),
        _in: S("in", { beforeExpr: !0, binop: 7 }),
        _instanceof: S("instanceof", { beforeExpr: !0, binop: 7 }),
        _typeof: S("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _void: S("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _delete: S("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
      }, A = /\r\n?|\n|\u2028|\u2029/, T = new RegExp(A.source, "g");
      function I(p) {
        return p === 10 || p === 13 || p === 8232 || p === 8233;
      }
      function L(p, V, Te) {
        Te === void 0 && (Te = p.length);
        for (var Le = V; Le < Te; Le++) {
          var Xe = p.charCodeAt(Le);
          if (I(Xe))
            return Le < Te - 1 && Xe === 13 && p.charCodeAt(Le + 1) === 10 ? Le + 2 : Le + 1;
        }
        return -1;
      }
      var z = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, U = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, J = Object.prototype, F = J.hasOwnProperty, oe = J.toString, ee = Object.hasOwn || function(p, V) {
        return F.call(p, V);
      }, ie = Array.isArray || function(p) {
        return oe.call(p) === "[object Array]";
      }, W = /* @__PURE__ */ Object.create(null);
      function Q(p) {
        return W[p] || (W[p] = new RegExp("^(?:" + p.replace(/ /g, "|") + ")$"));
      }
      function de(p) {
        return p <= 65535 ? String.fromCharCode(p) : (p -= 65536, String.fromCharCode((p >> 10) + 55296, (p & 1023) + 56320));
      }
      var we = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, ke = function(V, Te) {
        this.line = V, this.column = Te;
      };
      ke.prototype.offset = function(V) {
        return new ke(this.line, this.column + V);
      };
      var Me = function(V, Te, Le) {
        this.start = Te, this.end = Le, V.sourceFile !== null && (this.source = V.sourceFile);
      };
      function fe(p, V) {
        for (var Te = 1, Le = 0; ; ) {
          var Xe = L(p, Le, V);
          if (Xe < 0)
            return new ke(Te, V - Le);
          ++Te, Le = Xe;
        }
      }
      var xe = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: !1,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: !1,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: !1,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: !0,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: !1,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: !1,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: !1
      }, Ee = !1;
      function Pe(p) {
        var V = {};
        for (var Te in xe)
          V[Te] = p && ee(p, Te) ? p[Te] : xe[Te];
        if (V.ecmaVersion === "latest" ? V.ecmaVersion = 1e8 : V.ecmaVersion == null ? (!Ee && typeof console == "object" && console.warn && (Ee = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), V.ecmaVersion = 11) : V.ecmaVersion >= 2015 && (V.ecmaVersion -= 2009), V.allowReserved == null && (V.allowReserved = V.ecmaVersion < 5), (!p || p.allowHashBang == null) && (V.allowHashBang = V.ecmaVersion >= 14), ie(V.onToken)) {
          var Le = V.onToken;
          V.onToken = function(Xe) {
            return Le.push(Xe);
          };
        }
        return ie(V.onComment) && (V.onComment = Ue(V, V.onComment)), V;
      }
      function Ue(p, V) {
        return function(Te, Le, Xe, at, lt, Et) {
          var Tt = {
            type: Te ? "Block" : "Line",
            value: Le,
            start: Xe,
            end: at
          };
          p.locations && (Tt.loc = new Me(this, lt, Et)), p.ranges && (Tt.range = [Xe, at]), V.push(Tt);
        };
      }
      var He = 1, We = 2, Ze = 4, $e = 8, Ve = 16, Ge = 32, Ie = 64, De = 128, Ne = 256, _e = 512, re = He | We | Ne;
      function $(p, V) {
        return We | (p ? Ze : 0) | (V ? $e : 0);
      }
      var Ce = 0, ve = 1, Y = 2, G = 3, Ae = 4, e = 5, r = function(V, Te, Le) {
        this.options = V = Pe(V), this.sourceFile = V.sourceFile, this.keywords = Q(E[V.ecmaVersion >= 6 ? 6 : V.sourceType === "module" ? "5module" : 5]);
        var Xe = "";
        V.allowReserved !== !0 && (Xe = x[V.ecmaVersion >= 6 ? 6 : V.ecmaVersion === 5 ? 5 : 3], V.sourceType === "module" && (Xe += " await")), this.reservedWords = Q(Xe);
        var at = (Xe ? Xe + " " : "") + x.strict;
        this.reservedWordsStrict = Q(at), this.reservedWordsStrictBind = Q(at + " " + x.strictBind), this.input = String(Te), this.containsEsc = !1, Le ? (this.pos = Le, this.lineStart = this.input.lastIndexOf(`
`, Le - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(A).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = o.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = V.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && V.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(He), this.regexpState = null, this.privateNameStack = [];
      }, f = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
      r.prototype.parse = function() {
        var V = this.options.program || this.startNode();
        return this.nextToken(), this.parseTopLevel(V);
      }, f.inFunction.get = function() {
        return (this.currentVarScope().flags & We) > 0;
      }, f.inGenerator.get = function() {
        return (this.currentVarScope().flags & $e) > 0;
      }, f.inAsync.get = function() {
        return (this.currentVarScope().flags & Ze) > 0;
      }, f.canAwait.get = function() {
        for (var p = this.scopeStack.length - 1; p >= 0; p--) {
          var V = this.scopeStack[p], Te = V.flags;
          if (Te & (Ne | _e))
            return !1;
          if (Te & We)
            return (Te & Ze) > 0;
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      }, f.allowSuper.get = function() {
        var p = this.currentThisScope(), V = p.flags;
        return (V & Ie) > 0 || this.options.allowSuperOutsideMethod;
      }, f.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & De) > 0;
      }, f.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }, f.allowNewDotTarget.get = function() {
        for (var p = this.scopeStack.length - 1; p >= 0; p--) {
          var V = this.scopeStack[p], Te = V.flags;
          if (Te & (Ne | _e) || Te & We && !(Te & Ve))
            return !0;
        }
        return !1;
      }, f.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & Ne) > 0;
      }, r.extend = function() {
        for (var V = [], Te = arguments.length; Te--; ) V[Te] = arguments[Te];
        for (var Le = this, Xe = 0; Xe < V.length; Xe++)
          Le = V[Xe](Le);
        return Le;
      }, r.parse = function(V, Te) {
        return new this(Te, V).parse();
      }, r.parseExpressionAt = function(V, Te, Le) {
        var Xe = new this(Le, V, Te);
        return Xe.nextToken(), Xe.parseExpression();
      }, r.tokenizer = function(V, Te) {
        return new this(Te, V);
      }, Object.defineProperties(r.prototype, f);
      var C = r.prototype, R = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
      C.strictDirective = function(p) {
        if (this.options.ecmaVersion < 5)
          return !1;
        for (; ; ) {
          U.lastIndex = p, p += U.exec(this.input)[0].length;
          var V = R.exec(this.input.slice(p));
          if (!V)
            return !1;
          if ((V[1] || V[2]) === "use strict") {
            U.lastIndex = p + V[0].length;
            var Te = U.exec(this.input), Le = Te.index + Te[0].length, Xe = this.input.charAt(Le);
            return Xe === ";" || Xe === "}" || A.test(Te[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(Xe) || Xe === "!" && this.input.charAt(Le + 1) === "=");
          }
          p += V[0].length, U.lastIndex = p, p += U.exec(this.input)[0].length, this.input[p] === ";" && p++;
        }
      }, C.eat = function(p) {
        return this.type === p ? (this.next(), !0) : !1;
      }, C.isContextual = function(p) {
        return this.type === o.name && this.value === p && !this.containsEsc;
      }, C.eatContextual = function(p) {
        return this.isContextual(p) ? (this.next(), !0) : !1;
      }, C.expectContextual = function(p) {
        this.eatContextual(p) || this.unexpected();
      }, C.canInsertSemicolon = function() {
        return this.type === o.eof || this.type === o.braceR || A.test(this.input.slice(this.lastTokEnd, this.start));
      }, C.insertSemicolon = function() {
        if (this.canInsertSemicolon())
          return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
      }, C.semicolon = function() {
        !this.eat(o.semi) && !this.insertSemicolon() && this.unexpected();
      }, C.afterTrailingComma = function(p, V) {
        if (this.type === p)
          return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), V || this.next(), !0;
      }, C.expect = function(p) {
        this.eat(p) || this.unexpected();
      }, C.unexpected = function(p) {
        this.raise(p ?? this.start, "Unexpected token");
      };
      var B = function() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      C.checkPatternErrors = function(p, V) {
        if (p) {
          p.trailingComma > -1 && this.raiseRecoverable(p.trailingComma, "Comma is not permitted after the rest element");
          var Te = V ? p.parenthesizedAssign : p.parenthesizedBind;
          Te > -1 && this.raiseRecoverable(Te, V ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      }, C.checkExpressionErrors = function(p, V) {
        if (!p)
          return !1;
        var Te = p.shorthandAssign, Le = p.doubleProto;
        if (!V)
          return Te >= 0 || Le >= 0;
        Te >= 0 && this.raise(Te, "Shorthand property assignments are valid only in destructuring patterns"), Le >= 0 && this.raiseRecoverable(Le, "Redefinition of __proto__ property");
      }, C.checkYieldAwaitInDefaultParams = function() {
        this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
      }, C.isSimpleAssignTarget = function(p) {
        return p.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(p.expression) : p.type === "Identifier" || p.type === "MemberExpression";
      };
      var j = r.prototype;
      j.parseTopLevel = function(p) {
        var V = /* @__PURE__ */ Object.create(null);
        for (p.body || (p.body = []); this.type !== o.eof; ) {
          var Te = this.parseStatement(null, !0, V);
          p.body.push(Te);
        }
        if (this.inModule)
          for (var Le = 0, Xe = Object.keys(this.undefinedExports); Le < Xe.length; Le += 1) {
            var at = Xe[Le];
            this.raiseRecoverable(this.undefinedExports[at].start, "Export '" + at + "' is not defined");
          }
        return this.adaptDirectivePrologue(p.body), this.next(), p.sourceType = this.options.sourceType, this.finishNode(p, "Program");
      };
      var H = { kind: "loop" }, X = { kind: "switch" };
      j.isLet = function(p) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
          return !1;
        U.lastIndex = this.pos;
        var V = U.exec(this.input), Te = this.pos + V[0].length, Le = this.input.charCodeAt(Te);
        if (Le === 91 || Le === 92)
          return !0;
        if (p)
          return !1;
        if (Le === 123 || Le > 55295 && Le < 56320)
          return !0;
        if (n(Le, !0)) {
          for (var Xe = Te + 1; d(Le = this.input.charCodeAt(Xe), !0); )
            ++Xe;
          if (Le === 92 || Le > 55295 && Le < 56320)
            return !0;
          var at = this.input.slice(Te, Xe);
          if (!c.test(at))
            return !0;
        }
        return !1;
      }, j.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
          return !1;
        U.lastIndex = this.pos;
        var p = U.exec(this.input), V = this.pos + p[0].length, Te;
        return !A.test(this.input.slice(this.pos, V)) && this.input.slice(V, V + 8) === "function" && (V + 8 === this.input.length || !(d(Te = this.input.charCodeAt(V + 8)) || Te > 55295 && Te < 56320));
      }, j.parseStatement = function(p, V, Te) {
        var Le = this.type, Xe = this.startNode(), at;
        switch (this.isLet(p) && (Le = o._var, at = "let"), Le) {
          case o._break:
          case o._continue:
            return this.parseBreakContinueStatement(Xe, Le.keyword);
          case o._debugger:
            return this.parseDebuggerStatement(Xe);
          case o._do:
            return this.parseDoStatement(Xe);
          case o._for:
            return this.parseForStatement(Xe);
          case o._function:
            return p && (this.strict || p !== "if" && p !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(Xe, !1, !p);
          case o._class:
            return p && this.unexpected(), this.parseClass(Xe, !0);
          case o._if:
            return this.parseIfStatement(Xe);
          case o._return:
            return this.parseReturnStatement(Xe);
          case o._switch:
            return this.parseSwitchStatement(Xe);
          case o._throw:
            return this.parseThrowStatement(Xe);
          case o._try:
            return this.parseTryStatement(Xe);
          case o._const:
          case o._var:
            return at = at || this.value, p && at !== "var" && this.unexpected(), this.parseVarStatement(Xe, at);
          case o._while:
            return this.parseWhileStatement(Xe);
          case o._with:
            return this.parseWithStatement(Xe);
          case o.braceL:
            return this.parseBlock(!0, Xe);
          case o.semi:
            return this.parseEmptyStatement(Xe);
          case o._export:
          case o._import:
            if (this.options.ecmaVersion > 10 && Le === o._import) {
              U.lastIndex = this.pos;
              var lt = U.exec(this.input), Et = this.pos + lt[0].length, Tt = this.input.charCodeAt(Et);
              if (Tt === 40 || Tt === 46)
                return this.parseExpressionStatement(Xe, this.parseExpression());
            }
            return this.options.allowImportExportEverywhere || (V || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), Le === o._import ? this.parseImport(Xe) : this.parseExport(Xe, Te);
          // If the statement does not start with a statement keyword or a
          // brace, it's an ExpressionStatement or LabeledStatement. We
          // simply start parsing an expression, and afterwards, if the
          // next token is a colon and the expression was a simple
          // Identifier node, we switch to interpreting it as a label.
          default:
            if (this.isAsyncFunction())
              return p && this.unexpected(), this.next(), this.parseFunctionStatement(Xe, !0, !p);
            var Yt = this.value, zt = this.parseExpression();
            return Le === o.name && zt.type === "Identifier" && this.eat(o.colon) ? this.parseLabeledStatement(Xe, Yt, zt, p) : this.parseExpressionStatement(Xe, zt);
        }
      }, j.parseBreakContinueStatement = function(p, V) {
        var Te = V === "break";
        this.next(), this.eat(o.semi) || this.insertSemicolon() ? p.label = null : this.type !== o.name ? this.unexpected() : (p.label = this.parseIdent(), this.semicolon());
        for (var Le = 0; Le < this.labels.length; ++Le) {
          var Xe = this.labels[Le];
          if ((p.label == null || Xe.name === p.label.name) && (Xe.kind != null && (Te || Xe.kind === "loop") || p.label && Te))
            break;
        }
        return Le === this.labels.length && this.raise(p.start, "Unsyntactic " + V), this.finishNode(p, Te ? "BreakStatement" : "ContinueStatement");
      }, j.parseDebuggerStatement = function(p) {
        return this.next(), this.semicolon(), this.finishNode(p, "DebuggerStatement");
      }, j.parseDoStatement = function(p) {
        return this.next(), this.labels.push(H), p.body = this.parseStatement("do"), this.labels.pop(), this.expect(o._while), p.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(o.semi) : this.semicolon(), this.finishNode(p, "DoWhileStatement");
      }, j.parseForStatement = function(p) {
        this.next();
        var V = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        if (this.labels.push(H), this.enterScope(0), this.expect(o.parenL), this.type === o.semi)
          return V > -1 && this.unexpected(V), this.parseFor(p, null);
        var Te = this.isLet();
        if (this.type === o._var || this.type === o._const || Te) {
          var Le = this.startNode(), Xe = Te ? "let" : this.value;
          return this.next(), this.parseVar(Le, !0, Xe), this.finishNode(Le, "VariableDeclaration"), (this.type === o._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && Le.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === o._in ? V > -1 && this.unexpected(V) : p.await = V > -1), this.parseForIn(p, Le)) : (V > -1 && this.unexpected(V), this.parseFor(p, Le));
        }
        var at = this.isContextual("let"), lt = !1, Et = this.containsEsc, Tt = new B(), Yt = this.start, zt = V > -1 ? this.parseExprSubscripts(Tt, "await") : this.parseExpression(!0, Tt);
        return this.type === o._in || (lt = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (V > -1 ? (this.type === o._in && this.unexpected(V), p.await = !0) : lt && this.options.ecmaVersion >= 8 && (zt.start === Yt && !Et && zt.type === "Identifier" && zt.name === "async" ? this.unexpected() : this.options.ecmaVersion >= 9 && (p.await = !1)), at && lt && this.raise(zt.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(zt, !1, Tt), this.checkLValPattern(zt), this.parseForIn(p, zt)) : (this.checkExpressionErrors(Tt, !0), V > -1 && this.unexpected(V), this.parseFor(p, zt));
      }, j.parseFunctionStatement = function(p, V, Te) {
        return this.next(), this.parseFunction(p, pe | (Te ? 0 : P), !1, V);
      }, j.parseIfStatement = function(p) {
        return this.next(), p.test = this.parseParenExpression(), p.consequent = this.parseStatement("if"), p.alternate = this.eat(o._else) ? this.parseStatement("if") : null, this.finishNode(p, "IfStatement");
      }, j.parseReturnStatement = function(p) {
        return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(o.semi) || this.insertSemicolon() ? p.argument = null : (p.argument = this.parseExpression(), this.semicolon()), this.finishNode(p, "ReturnStatement");
      }, j.parseSwitchStatement = function(p) {
        this.next(), p.discriminant = this.parseParenExpression(), p.cases = [], this.expect(o.braceL), this.labels.push(X), this.enterScope(0);
        for (var V, Te = !1; this.type !== o.braceR; )
          if (this.type === o._case || this.type === o._default) {
            var Le = this.type === o._case;
            V && this.finishNode(V, "SwitchCase"), p.cases.push(V = this.startNode()), V.consequent = [], this.next(), Le ? V.test = this.parseExpression() : (Te && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), Te = !0, V.test = null), this.expect(o.colon);
          } else
            V || this.unexpected(), V.consequent.push(this.parseStatement(null));
        return this.exitScope(), V && this.finishNode(V, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(p, "SwitchStatement");
      }, j.parseThrowStatement = function(p) {
        return this.next(), A.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), p.argument = this.parseExpression(), this.semicolon(), this.finishNode(p, "ThrowStatement");
      };
      var ue = [];
      j.parseCatchClauseParam = function() {
        var p = this.parseBindingAtom(), V = p.type === "Identifier";
        return this.enterScope(V ? Ge : 0), this.checkLValPattern(p, V ? Ae : Y), this.expect(o.parenR), p;
      }, j.parseTryStatement = function(p) {
        if (this.next(), p.block = this.parseBlock(), p.handler = null, this.type === o._catch) {
          var V = this.startNode();
          this.next(), this.eat(o.parenL) ? V.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), V.param = null, this.enterScope(0)), V.body = this.parseBlock(!1), this.exitScope(), p.handler = this.finishNode(V, "CatchClause");
        }
        return p.finalizer = this.eat(o._finally) ? this.parseBlock() : null, !p.handler && !p.finalizer && this.raise(p.start, "Missing catch or finally clause"), this.finishNode(p, "TryStatement");
      }, j.parseVarStatement = function(p, V, Te) {
        return this.next(), this.parseVar(p, !1, V, Te), this.semicolon(), this.finishNode(p, "VariableDeclaration");
      }, j.parseWhileStatement = function(p) {
        return this.next(), p.test = this.parseParenExpression(), this.labels.push(H), p.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(p, "WhileStatement");
      }, j.parseWithStatement = function(p) {
        return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), p.object = this.parseParenExpression(), p.body = this.parseStatement("with"), this.finishNode(p, "WithStatement");
      }, j.parseEmptyStatement = function(p) {
        return this.next(), this.finishNode(p, "EmptyStatement");
      }, j.parseLabeledStatement = function(p, V, Te, Le) {
        for (var Xe = 0, at = this.labels; Xe < at.length; Xe += 1) {
          var lt = at[Xe];
          lt.name === V && this.raise(Te.start, "Label '" + V + "' is already declared");
        }
        for (var Et = this.type.isLoop ? "loop" : this.type === o._switch ? "switch" : null, Tt = this.labels.length - 1; Tt >= 0; Tt--) {
          var Yt = this.labels[Tt];
          if (Yt.statementStart === p.start)
            Yt.statementStart = this.start, Yt.kind = Et;
          else
            break;
        }
        return this.labels.push({ name: V, kind: Et, statementStart: this.start }), p.body = this.parseStatement(Le ? Le.indexOf("label") === -1 ? Le + "label" : Le : "label"), this.labels.pop(), p.label = Te, this.finishNode(p, "LabeledStatement");
      }, j.parseExpressionStatement = function(p, V) {
        return p.expression = V, this.semicolon(), this.finishNode(p, "ExpressionStatement");
      }, j.parseBlock = function(p, V, Te) {
        for (p === void 0 && (p = !0), V === void 0 && (V = this.startNode()), V.body = [], this.expect(o.braceL), p && this.enterScope(0); this.type !== o.braceR; ) {
          var Le = this.parseStatement(null);
          V.body.push(Le);
        }
        return Te && (this.strict = !1), this.next(), p && this.exitScope(), this.finishNode(V, "BlockStatement");
      }, j.parseFor = function(p, V) {
        return p.init = V, this.expect(o.semi), p.test = this.type === o.semi ? null : this.parseExpression(), this.expect(o.semi), p.update = this.type === o.parenR ? null : this.parseExpression(), this.expect(o.parenR), p.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(p, "ForStatement");
      }, j.parseForIn = function(p, V) {
        var Te = this.type === o._in;
        return this.next(), V.type === "VariableDeclaration" && V.declarations[0].init != null && (!Te || this.options.ecmaVersion < 8 || this.strict || V.kind !== "var" || V.declarations[0].id.type !== "Identifier") && this.raise(
          V.start,
          (Te ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
        ), p.left = V, p.right = Te ? this.parseExpression() : this.parseMaybeAssign(), this.expect(o.parenR), p.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(p, Te ? "ForInStatement" : "ForOfStatement");
      }, j.parseVar = function(p, V, Te, Le) {
        for (p.declarations = [], p.kind = Te; ; ) {
          var Xe = this.startNode();
          if (this.parseVarId(Xe, Te), this.eat(o.eq) ? Xe.init = this.parseMaybeAssign(V) : !Le && Te === "const" && !(this.type === o._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !Le && Xe.id.type !== "Identifier" && !(V && (this.type === o._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : Xe.init = null, p.declarations.push(this.finishNode(Xe, "VariableDeclarator")), !this.eat(o.comma))
            break;
        }
        return p;
      }, j.parseVarId = function(p, V) {
        p.id = this.parseBindingAtom(), this.checkLValPattern(p.id, V === "var" ? ve : Y, !1);
      };
      var pe = 1, P = 2, q = 4;
      j.parseFunction = function(p, V, Te, Le, Xe) {
        this.initFunction(p), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !Le) && (this.type === o.star && V & P && this.unexpected(), p.generator = this.eat(o.star)), this.options.ecmaVersion >= 8 && (p.async = !!Le), V & pe && (p.id = V & q && this.type !== o.name ? null : this.parseIdent(), p.id && !(V & P) && this.checkLValSimple(p.id, this.strict || p.generator || p.async ? this.treatFunctionsAsVar ? ve : Y : G));
        var at = this.yieldPos, lt = this.awaitPos, Et = this.awaitIdentPos;
        return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope($(p.async, p.generator)), V & pe || (p.id = this.type === o.name ? this.parseIdent() : null), this.parseFunctionParams(p), this.parseFunctionBody(p, Te, !1, Xe), this.yieldPos = at, this.awaitPos = lt, this.awaitIdentPos = Et, this.finishNode(p, V & pe ? "FunctionDeclaration" : "FunctionExpression");
      }, j.parseFunctionParams = function(p) {
        this.expect(o.parenL), p.params = this.parseBindingList(o.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
      }, j.parseClass = function(p, V) {
        this.next();
        var Te = this.strict;
        this.strict = !0, this.parseClassId(p, V), this.parseClassSuper(p);
        var Le = this.enterClassBody(), Xe = this.startNode(), at = !1;
        for (Xe.body = [], this.expect(o.braceL); this.type !== o.braceR; ) {
          var lt = this.parseClassElement(p.superClass !== null);
          lt && (Xe.body.push(lt), lt.type === "MethodDefinition" && lt.kind === "constructor" ? (at && this.raiseRecoverable(lt.start, "Duplicate constructor in the same class"), at = !0) : lt.key && lt.key.type === "PrivateIdentifier" && K(Le, lt) && this.raiseRecoverable(lt.key.start, "Identifier '#" + lt.key.name + "' has already been declared"));
        }
        return this.strict = Te, this.next(), p.body = this.finishNode(Xe, "ClassBody"), this.exitClassBody(), this.finishNode(p, V ? "ClassDeclaration" : "ClassExpression");
      }, j.parseClassElement = function(p) {
        if (this.eat(o.semi))
          return null;
        var V = this.options.ecmaVersion, Te = this.startNode(), Le = "", Xe = !1, at = !1, lt = "method", Et = !1;
        if (this.eatContextual("static")) {
          if (V >= 13 && this.eat(o.braceL))
            return this.parseClassStaticBlock(Te), Te;
          this.isClassElementNameStart() || this.type === o.star ? Et = !0 : Le = "static";
        }
        if (Te.static = Et, !Le && V >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === o.star) && !this.canInsertSemicolon() ? at = !0 : Le = "async"), !Le && (V >= 9 || !at) && this.eat(o.star) && (Xe = !0), !Le && !at && !Xe) {
          var Tt = this.value;
          (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? lt = Tt : Le = Tt);
        }
        if (Le ? (Te.computed = !1, Te.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), Te.key.name = Le, this.finishNode(Te.key, "Identifier")) : this.parseClassElementName(Te), V < 13 || this.type === o.parenL || lt !== "method" || Xe || at) {
          var Yt = !Te.static && ye(Te, "constructor"), zt = Yt && p;
          Yt && lt !== "method" && this.raise(Te.key.start, "Constructor can't have get/set modifier"), Te.kind = Yt ? "constructor" : lt, this.parseClassMethod(Te, Xe, at, zt);
        } else
          this.parseClassField(Te);
        return Te;
      }, j.isClassElementNameStart = function() {
        return this.type === o.name || this.type === o.privateId || this.type === o.num || this.type === o.string || this.type === o.bracketL || this.type.keyword;
      }, j.parseClassElementName = function(p) {
        this.type === o.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), p.computed = !1, p.key = this.parsePrivateIdent()) : this.parsePropertyName(p);
      }, j.parseClassMethod = function(p, V, Te, Le) {
        var Xe = p.key;
        p.kind === "constructor" ? (V && this.raise(Xe.start, "Constructor can't be a generator"), Te && this.raise(Xe.start, "Constructor can't be an async method")) : p.static && ye(p, "prototype") && this.raise(Xe.start, "Classes may not have a static property named prototype");
        var at = p.value = this.parseMethod(V, Te, Le);
        return p.kind === "get" && at.params.length !== 0 && this.raiseRecoverable(at.start, "getter should have no params"), p.kind === "set" && at.params.length !== 1 && this.raiseRecoverable(at.start, "setter should have exactly one param"), p.kind === "set" && at.params[0].type === "RestElement" && this.raiseRecoverable(at.params[0].start, "Setter cannot use rest params"), this.finishNode(p, "MethodDefinition");
      }, j.parseClassField = function(p) {
        return ye(p, "constructor") ? this.raise(p.key.start, "Classes can't have a field named 'constructor'") : p.static && ye(p, "prototype") && this.raise(p.key.start, "Classes can't have a static field named 'prototype'"), this.eat(o.eq) ? (this.enterScope(_e | Ie), p.value = this.parseMaybeAssign(), this.exitScope()) : p.value = null, this.semicolon(), this.finishNode(p, "PropertyDefinition");
      }, j.parseClassStaticBlock = function(p) {
        p.body = [];
        var V = this.labels;
        for (this.labels = [], this.enterScope(Ne | Ie); this.type !== o.braceR; ) {
          var Te = this.parseStatement(null);
          p.body.push(Te);
        }
        return this.next(), this.exitScope(), this.labels = V, this.finishNode(p, "StaticBlock");
      }, j.parseClassId = function(p, V) {
        this.type === o.name ? (p.id = this.parseIdent(), V && this.checkLValSimple(p.id, Y, !1)) : (V === !0 && this.unexpected(), p.id = null);
      }, j.parseClassSuper = function(p) {
        p.superClass = this.eat(o._extends) ? this.parseExprSubscripts(null, !1) : null;
      }, j.enterClassBody = function() {
        var p = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        return this.privateNameStack.push(p), p.declared;
      }, j.exitClassBody = function() {
        var p = this.privateNameStack.pop(), V = p.declared, Te = p.used;
        if (this.options.checkPrivateFields)
          for (var Le = this.privateNameStack.length, Xe = Le === 0 ? null : this.privateNameStack[Le - 1], at = 0; at < Te.length; ++at) {
            var lt = Te[at];
            ee(V, lt.name) || (Xe ? Xe.used.push(lt) : this.raiseRecoverable(lt.start, "Private field '#" + lt.name + "' must be declared in an enclosing class"));
          }
      };
      function K(p, V) {
        var Te = V.key.name, Le = p[Te], Xe = "true";
        return V.type === "MethodDefinition" && (V.kind === "get" || V.kind === "set") && (Xe = (V.static ? "s" : "i") + V.kind), Le === "iget" && Xe === "iset" || Le === "iset" && Xe === "iget" || Le === "sget" && Xe === "sset" || Le === "sset" && Xe === "sget" ? (p[Te] = "true", !1) : Le ? !0 : (p[Te] = Xe, !1);
      }
      function ye(p, V) {
        var Te = p.computed, Le = p.key;
        return !Te && (Le.type === "Identifier" && Le.name === V || Le.type === "Literal" && Le.value === V);
      }
      j.parseExportAllDeclaration = function(p, V) {
        return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (p.exported = this.parseModuleExportName(), this.checkExport(V, p.exported, this.lastTokStart)) : p.exported = null), this.expectContextual("from"), this.type !== o.string && this.unexpected(), p.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (p.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(p, "ExportAllDeclaration");
      }, j.parseExport = function(p, V) {
        if (this.next(), this.eat(o.star))
          return this.parseExportAllDeclaration(p, V);
        if (this.eat(o._default))
          return this.checkExport(V, "default", this.lastTokStart), p.declaration = this.parseExportDefaultDeclaration(), this.finishNode(p, "ExportDefaultDeclaration");
        if (this.shouldParseExportStatement())
          p.declaration = this.parseExportDeclaration(p), p.declaration.type === "VariableDeclaration" ? this.checkVariableExport(V, p.declaration.declarations) : this.checkExport(V, p.declaration.id, p.declaration.id.start), p.specifiers = [], p.source = null, this.options.ecmaVersion >= 16 && (p.attributes = []);
        else {
          if (p.declaration = null, p.specifiers = this.parseExportSpecifiers(V), this.eatContextual("from"))
            this.type !== o.string && this.unexpected(), p.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (p.attributes = this.parseWithClause());
          else {
            for (var Te = 0, Le = p.specifiers; Te < Le.length; Te += 1) {
              var Xe = Le[Te];
              this.checkUnreserved(Xe.local), this.checkLocalExport(Xe.local), Xe.local.type === "Literal" && this.raise(Xe.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
            p.source = null, this.options.ecmaVersion >= 16 && (p.attributes = []);
          }
          this.semicolon();
        }
        return this.finishNode(p, "ExportNamedDeclaration");
      }, j.parseExportDeclaration = function(p) {
        return this.parseStatement(null);
      }, j.parseExportDefaultDeclaration = function() {
        var p;
        if (this.type === o._function || (p = this.isAsyncFunction())) {
          var V = this.startNode();
          return this.next(), p && this.next(), this.parseFunction(V, pe | q, !1, p);
        } else if (this.type === o._class) {
          var Te = this.startNode();
          return this.parseClass(Te, "nullableID");
        } else {
          var Le = this.parseMaybeAssign();
          return this.semicolon(), Le;
        }
      }, j.checkExport = function(p, V, Te) {
        p && (typeof V != "string" && (V = V.type === "Identifier" ? V.name : V.value), ee(p, V) && this.raiseRecoverable(Te, "Duplicate export '" + V + "'"), p[V] = !0);
      }, j.checkPatternExport = function(p, V) {
        var Te = V.type;
        if (Te === "Identifier")
          this.checkExport(p, V, V.start);
        else if (Te === "ObjectPattern")
          for (var Le = 0, Xe = V.properties; Le < Xe.length; Le += 1) {
            var at = Xe[Le];
            this.checkPatternExport(p, at);
          }
        else if (Te === "ArrayPattern")
          for (var lt = 0, Et = V.elements; lt < Et.length; lt += 1) {
            var Tt = Et[lt];
            Tt && this.checkPatternExport(p, Tt);
          }
        else Te === "Property" ? this.checkPatternExport(p, V.value) : Te === "AssignmentPattern" ? this.checkPatternExport(p, V.left) : Te === "RestElement" && this.checkPatternExport(p, V.argument);
      }, j.checkVariableExport = function(p, V) {
        if (p)
          for (var Te = 0, Le = V; Te < Le.length; Te += 1) {
            var Xe = Le[Te];
            this.checkPatternExport(p, Xe.id);
          }
      }, j.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      }, j.parseExportSpecifier = function(p) {
        var V = this.startNode();
        return V.local = this.parseModuleExportName(), V.exported = this.eatContextual("as") ? this.parseModuleExportName() : V.local, this.checkExport(
          p,
          V.exported,
          V.exported.start
        ), this.finishNode(V, "ExportSpecifier");
      }, j.parseExportSpecifiers = function(p) {
        var V = [], Te = !0;
        for (this.expect(o.braceL); !this.eat(o.braceR); ) {
          if (Te)
            Te = !1;
          else if (this.expect(o.comma), this.afterTrailingComma(o.braceR))
            break;
          V.push(this.parseExportSpecifier(p));
        }
        return V;
      }, j.parseImport = function(p) {
        return this.next(), this.type === o.string ? (p.specifiers = ue, p.source = this.parseExprAtom()) : (p.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), p.source = this.type === o.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (p.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(p, "ImportDeclaration");
      }, j.parseImportSpecifier = function() {
        var p = this.startNode();
        return p.imported = this.parseModuleExportName(), this.eatContextual("as") ? p.local = this.parseIdent() : (this.checkUnreserved(p.imported), p.local = p.imported), this.checkLValSimple(p.local, Y), this.finishNode(p, "ImportSpecifier");
      }, j.parseImportDefaultSpecifier = function() {
        var p = this.startNode();
        return p.local = this.parseIdent(), this.checkLValSimple(p.local, Y), this.finishNode(p, "ImportDefaultSpecifier");
      }, j.parseImportNamespaceSpecifier = function() {
        var p = this.startNode();
        return this.next(), this.expectContextual("as"), p.local = this.parseIdent(), this.checkLValSimple(p.local, Y), this.finishNode(p, "ImportNamespaceSpecifier");
      }, j.parseImportSpecifiers = function() {
        var p = [], V = !0;
        if (this.type === o.name && (p.push(this.parseImportDefaultSpecifier()), !this.eat(o.comma)))
          return p;
        if (this.type === o.star)
          return p.push(this.parseImportNamespaceSpecifier()), p;
        for (this.expect(o.braceL); !this.eat(o.braceR); ) {
          if (V)
            V = !1;
          else if (this.expect(o.comma), this.afterTrailingComma(o.braceR))
            break;
          p.push(this.parseImportSpecifier());
        }
        return p;
      }, j.parseWithClause = function() {
        var p = [];
        if (!this.eat(o._with))
          return p;
        this.expect(o.braceL);
        for (var V = {}, Te = !0; !this.eat(o.braceR); ) {
          if (Te)
            Te = !1;
          else if (this.expect(o.comma), this.afterTrailingComma(o.braceR))
            break;
          var Le = this.parseImportAttribute(), Xe = Le.key.type === "Identifier" ? Le.key.name : Le.key.value;
          ee(V, Xe) && this.raiseRecoverable(Le.key.start, "Duplicate attribute key '" + Xe + "'"), V[Xe] = !0, p.push(Le);
        }
        return p;
      }, j.parseImportAttribute = function() {
        var p = this.startNode();
        return p.key = this.type === o.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(o.colon), this.type !== o.string && this.unexpected(), p.value = this.parseExprAtom(), this.finishNode(p, "ImportAttribute");
      }, j.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === o.string) {
          var p = this.parseLiteral(this.value);
          return we.test(p.value) && this.raise(p.start, "An export name cannot include a lone surrogate."), p;
        }
        return this.parseIdent(!0);
      }, j.adaptDirectivePrologue = function(p) {
        for (var V = 0; V < p.length && this.isDirectiveCandidate(p[V]); ++V)
          p[V].directive = p[V].expression.raw.slice(1, -1);
      }, j.isDirectiveCandidate = function(p) {
        return this.options.ecmaVersion >= 5 && p.type === "ExpressionStatement" && p.expression.type === "Literal" && typeof p.expression.value == "string" && // Reject parenthesized strings.
        (this.input[p.start] === '"' || this.input[p.start] === "'");
      };
      var te = r.prototype;
      te.toAssignable = function(p, V, Te) {
        if (this.options.ecmaVersion >= 6 && p)
          switch (p.type) {
            case "Identifier":
              this.inAsync && p.name === "await" && this.raise(p.start, "Cannot use 'await' as identifier inside an async function");
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              p.type = "ObjectPattern", Te && this.checkPatternErrors(Te, !0);
              for (var Le = 0, Xe = p.properties; Le < Xe.length; Le += 1) {
                var at = Xe[Le];
                this.toAssignable(at, V), at.type === "RestElement" && (at.argument.type === "ArrayPattern" || at.argument.type === "ObjectPattern") && this.raise(at.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              p.kind !== "init" && this.raise(p.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(p.value, V);
              break;
            case "ArrayExpression":
              p.type = "ArrayPattern", Te && this.checkPatternErrors(Te, !0), this.toAssignableList(p.elements, V);
              break;
            case "SpreadElement":
              p.type = "RestElement", this.toAssignable(p.argument, V), p.argument.type === "AssignmentPattern" && this.raise(p.argument.start, "Rest elements cannot have a default value");
              break;
            case "AssignmentExpression":
              p.operator !== "=" && this.raise(p.left.end, "Only '=' operator can be used for specifying default value."), p.type = "AssignmentPattern", delete p.operator, this.toAssignable(p.left, V);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(p.expression, V, Te);
              break;
            case "ChainExpression":
              this.raiseRecoverable(p.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!V)
                break;
            default:
              this.raise(p.start, "Assigning to rvalue");
          }
        else Te && this.checkPatternErrors(Te, !0);
        return p;
      }, te.toAssignableList = function(p, V) {
        for (var Te = p.length, Le = 0; Le < Te; Le++) {
          var Xe = p[Le];
          Xe && this.toAssignable(Xe, V);
        }
        if (Te) {
          var at = p[Te - 1];
          this.options.ecmaVersion === 6 && V && at && at.type === "RestElement" && at.argument.type !== "Identifier" && this.unexpected(at.argument.start);
        }
        return p;
      }, te.parseSpread = function(p) {
        var V = this.startNode();
        return this.next(), V.argument = this.parseMaybeAssign(!1, p), this.finishNode(V, "SpreadElement");
      }, te.parseRestBinding = function() {
        var p = this.startNode();
        return this.next(), this.options.ecmaVersion === 6 && this.type !== o.name && this.unexpected(), p.argument = this.parseBindingAtom(), this.finishNode(p, "RestElement");
      }, te.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6)
          switch (this.type) {
            case o.bracketL:
              var p = this.startNode();
              return this.next(), p.elements = this.parseBindingList(o.bracketR, !0, !0), this.finishNode(p, "ArrayPattern");
            case o.braceL:
              return this.parseObj(!0);
          }
        return this.parseIdent();
      }, te.parseBindingList = function(p, V, Te, Le) {
        for (var Xe = [], at = !0; !this.eat(p); )
          if (at ? at = !1 : this.expect(o.comma), V && this.type === o.comma)
            Xe.push(null);
          else {
            if (Te && this.afterTrailingComma(p))
              break;
            if (this.type === o.ellipsis) {
              var lt = this.parseRestBinding();
              this.parseBindingListItem(lt), Xe.push(lt), this.type === o.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(p);
              break;
            } else
              Xe.push(this.parseAssignableListItem(Le));
          }
        return Xe;
      }, te.parseAssignableListItem = function(p) {
        var V = this.parseMaybeDefault(this.start, this.startLoc);
        return this.parseBindingListItem(V), V;
      }, te.parseBindingListItem = function(p) {
        return p;
      }, te.parseMaybeDefault = function(p, V, Te) {
        if (Te = Te || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(o.eq))
          return Te;
        var Le = this.startNodeAt(p, V);
        return Le.left = Te, Le.right = this.parseMaybeAssign(), this.finishNode(Le, "AssignmentPattern");
      }, te.checkLValSimple = function(p, V, Te) {
        V === void 0 && (V = Ce);
        var Le = V !== Ce;
        switch (p.type) {
          case "Identifier":
            this.strict && this.reservedWordsStrictBind.test(p.name) && this.raiseRecoverable(p.start, (Le ? "Binding " : "Assigning to ") + p.name + " in strict mode"), Le && (V === Y && p.name === "let" && this.raiseRecoverable(p.start, "let is disallowed as a lexically bound name"), Te && (ee(Te, p.name) && this.raiseRecoverable(p.start, "Argument name clash"), Te[p.name] = !0), V !== e && this.declareName(p.name, V, p.start));
            break;
          case "ChainExpression":
            this.raiseRecoverable(p.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            Le && this.raiseRecoverable(p.start, "Binding member expression");
            break;
          case "ParenthesizedExpression":
            return Le && this.raiseRecoverable(p.start, "Binding parenthesized expression"), this.checkLValSimple(p.expression, V, Te);
          default:
            this.raise(p.start, (Le ? "Binding" : "Assigning to") + " rvalue");
        }
      }, te.checkLValPattern = function(p, V, Te) {
        switch (V === void 0 && (V = Ce), p.type) {
          case "ObjectPattern":
            for (var Le = 0, Xe = p.properties; Le < Xe.length; Le += 1) {
              var at = Xe[Le];
              this.checkLValInnerPattern(at, V, Te);
            }
            break;
          case "ArrayPattern":
            for (var lt = 0, Et = p.elements; lt < Et.length; lt += 1) {
              var Tt = Et[lt];
              Tt && this.checkLValInnerPattern(Tt, V, Te);
            }
            break;
          default:
            this.checkLValSimple(p, V, Te);
        }
      }, te.checkLValInnerPattern = function(p, V, Te) {
        switch (V === void 0 && (V = Ce), p.type) {
          case "Property":
            this.checkLValInnerPattern(p.value, V, Te);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(p.left, V, Te);
            break;
          case "RestElement":
            this.checkLValPattern(p.argument, V, Te);
            break;
          default:
            this.checkLValPattern(p, V, Te);
        }
      };
      var he = function(V, Te, Le, Xe, at) {
        this.token = V, this.isExpr = !!Te, this.preserveSpace = !!Le, this.override = Xe, this.generator = !!at;
      }, D = {
        b_stat: new he("{", !1),
        b_expr: new he("{", !0),
        b_tmpl: new he("${", !1),
        p_stat: new he("(", !1),
        p_expr: new he("(", !0),
        q_tmpl: new he("`", !0, !0, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new he("function", !1),
        f_expr: new he("function", !0),
        f_expr_gen: new he("function", !0, !1, null, !0),
        f_gen: new he("function", !1, !1, null, !0)
      }, Se = r.prototype;
      Se.initialContext = function() {
        return [D.b_stat];
      }, Se.curContext = function() {
        return this.context[this.context.length - 1];
      }, Se.braceIsBlock = function(p) {
        var V = this.curContext();
        return V === D.f_expr || V === D.f_stat ? !0 : p === o.colon && (V === D.b_stat || V === D.b_expr) ? !V.isExpr : p === o._return || p === o.name && this.exprAllowed ? A.test(this.input.slice(this.lastTokEnd, this.start)) : p === o._else || p === o.semi || p === o.eof || p === o.parenR || p === o.arrow ? !0 : p === o.braceL ? V === D.b_stat : p === o._var || p === o._const || p === o.name ? !1 : !this.exprAllowed;
      }, Se.inGeneratorContext = function() {
        for (var p = this.context.length - 1; p >= 1; p--) {
          var V = this.context[p];
          if (V.token === "function")
            return V.generator;
        }
        return !1;
      }, Se.updateContext = function(p) {
        var V, Te = this.type;
        Te.keyword && p === o.dot ? this.exprAllowed = !1 : (V = Te.updateContext) ? V.call(this, p) : this.exprAllowed = Te.beforeExpr;
      }, Se.overrideContext = function(p) {
        this.curContext() !== p && (this.context[this.context.length - 1] = p);
      }, o.parenR.updateContext = o.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = !0;
          return;
        }
        var p = this.context.pop();
        p === D.b_stat && this.curContext().token === "function" && (p = this.context.pop()), this.exprAllowed = !p.isExpr;
      }, o.braceL.updateContext = function(p) {
        this.context.push(this.braceIsBlock(p) ? D.b_stat : D.b_expr), this.exprAllowed = !0;
      }, o.dollarBraceL.updateContext = function() {
        this.context.push(D.b_tmpl), this.exprAllowed = !0;
      }, o.parenL.updateContext = function(p) {
        var V = p === o._if || p === o._for || p === o._with || p === o._while;
        this.context.push(V ? D.p_stat : D.p_expr), this.exprAllowed = !0;
      }, o.incDec.updateContext = function() {
      }, o._function.updateContext = o._class.updateContext = function(p) {
        p.beforeExpr && p !== o._else && !(p === o.semi && this.curContext() !== D.p_stat) && !(p === o._return && A.test(this.input.slice(this.lastTokEnd, this.start))) && !((p === o.colon || p === o.braceL) && this.curContext() === D.b_stat) ? this.context.push(D.f_expr) : this.context.push(D.f_stat), this.exprAllowed = !1;
      }, o.colon.updateContext = function() {
        this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
      }, o.backQuote.updateContext = function() {
        this.curContext() === D.q_tmpl ? this.context.pop() : this.context.push(D.q_tmpl), this.exprAllowed = !1;
      }, o.star.updateContext = function(p) {
        if (p === o._function) {
          var V = this.context.length - 1;
          this.context[V] === D.f_expr ? this.context[V] = D.f_expr_gen : this.context[V] = D.f_gen;
        }
        this.exprAllowed = !0;
      }, o.name.updateContext = function(p) {
        var V = !1;
        this.options.ecmaVersion >= 6 && p !== o.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (V = !0), this.exprAllowed = V;
      };
      var le = r.prototype;
      le.checkPropClash = function(p, V, Te) {
        if (!(this.options.ecmaVersion >= 9 && p.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (p.computed || p.method || p.shorthand))) {
          var Le = p.key, Xe;
          switch (Le.type) {
            case "Identifier":
              Xe = Le.name;
              break;
            case "Literal":
              Xe = String(Le.value);
              break;
            default:
              return;
          }
          var at = p.kind;
          if (this.options.ecmaVersion >= 6) {
            Xe === "__proto__" && at === "init" && (V.proto && (Te ? Te.doubleProto < 0 && (Te.doubleProto = Le.start) : this.raiseRecoverable(Le.start, "Redefinition of __proto__ property")), V.proto = !0);
            return;
          }
          Xe = "$" + Xe;
          var lt = V[Xe];
          if (lt) {
            var Et;
            at === "init" ? Et = this.strict && lt.init || lt.get || lt.set : Et = lt.init || lt[at], Et && this.raiseRecoverable(Le.start, "Redefinition of property");
          } else
            lt = V[Xe] = {
              init: !1,
              get: !1,
              set: !1
            };
          lt[at] = !0;
        }
      }, le.parseExpression = function(p, V) {
        var Te = this.start, Le = this.startLoc, Xe = this.parseMaybeAssign(p, V);
        if (this.type === o.comma) {
          var at = this.startNodeAt(Te, Le);
          for (at.expressions = [Xe]; this.eat(o.comma); )
            at.expressions.push(this.parseMaybeAssign(p, V));
          return this.finishNode(at, "SequenceExpression");
        }
        return Xe;
      }, le.parseMaybeAssign = function(p, V, Te) {
        if (this.isContextual("yield")) {
          if (this.inGenerator)
            return this.parseYield(p);
          this.exprAllowed = !1;
        }
        var Le = !1, Xe = -1, at = -1, lt = -1;
        V ? (Xe = V.parenthesizedAssign, at = V.trailingComma, lt = V.doubleProto, V.parenthesizedAssign = V.trailingComma = -1) : (V = new B(), Le = !0);
        var Et = this.start, Tt = this.startLoc;
        (this.type === o.parenL || this.type === o.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = p === "await");
        var Yt = this.parseMaybeConditional(p, V);
        if (Te && (Yt = Te.call(this, Yt, Et, Tt)), this.type.isAssign) {
          var zt = this.startNodeAt(Et, Tt);
          return zt.operator = this.value, this.type === o.eq && (Yt = this.toAssignable(Yt, !1, V)), Le || (V.parenthesizedAssign = V.trailingComma = V.doubleProto = -1), V.shorthandAssign >= Yt.start && (V.shorthandAssign = -1), this.type === o.eq ? this.checkLValPattern(Yt) : this.checkLValSimple(Yt), zt.left = Yt, this.next(), zt.right = this.parseMaybeAssign(p), lt > -1 && (V.doubleProto = lt), this.finishNode(zt, "AssignmentExpression");
        } else
          Le && this.checkExpressionErrors(V, !0);
        return Xe > -1 && (V.parenthesizedAssign = Xe), at > -1 && (V.trailingComma = at), Yt;
      }, le.parseMaybeConditional = function(p, V) {
        var Te = this.start, Le = this.startLoc, Xe = this.parseExprOps(p, V);
        if (this.checkExpressionErrors(V))
          return Xe;
        if (this.eat(o.question)) {
          var at = this.startNodeAt(Te, Le);
          return at.test = Xe, at.consequent = this.parseMaybeAssign(), this.expect(o.colon), at.alternate = this.parseMaybeAssign(p), this.finishNode(at, "ConditionalExpression");
        }
        return Xe;
      }, le.parseExprOps = function(p, V) {
        var Te = this.start, Le = this.startLoc, Xe = this.parseMaybeUnary(V, !1, !1, p);
        return this.checkExpressionErrors(V) || Xe.start === Te && Xe.type === "ArrowFunctionExpression" ? Xe : this.parseExprOp(Xe, Te, Le, -1, p);
      }, le.parseExprOp = function(p, V, Te, Le, Xe) {
        var at = this.type.binop;
        if (at != null && (!Xe || this.type !== o._in) && at > Le) {
          var lt = this.type === o.logicalOR || this.type === o.logicalAND, Et = this.type === o.coalesce;
          Et && (at = o.logicalAND.binop);
          var Tt = this.value;
          this.next();
          var Yt = this.start, zt = this.startLoc, fr = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, Xe), Yt, zt, at, Xe), $r = this.buildBinary(V, Te, p, fr, Tt, lt || Et);
          return (lt && this.type === o.coalesce || Et && (this.type === o.logicalOR || this.type === o.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp($r, V, Te, Le, Xe);
        }
        return p;
      }, le.buildBinary = function(p, V, Te, Le, Xe, at) {
        Le.type === "PrivateIdentifier" && this.raise(Le.start, "Private identifier can only be left side of binary expression");
        var lt = this.startNodeAt(p, V);
        return lt.left = Te, lt.operator = Xe, lt.right = Le, this.finishNode(lt, at ? "LogicalExpression" : "BinaryExpression");
      }, le.parseMaybeUnary = function(p, V, Te, Le) {
        var Xe = this.start, at = this.startLoc, lt;
        if (this.isContextual("await") && this.canAwait)
          lt = this.parseAwait(Le), V = !0;
        else if (this.type.prefix) {
          var Et = this.startNode(), Tt = this.type === o.incDec;
          Et.operator = this.value, Et.prefix = !0, this.next(), Et.argument = this.parseMaybeUnary(null, !0, Tt, Le), this.checkExpressionErrors(p, !0), Tt ? this.checkLValSimple(Et.argument) : this.strict && Et.operator === "delete" && v(Et.argument) ? this.raiseRecoverable(Et.start, "Deleting local variable in strict mode") : Et.operator === "delete" && se(Et.argument) ? this.raiseRecoverable(Et.start, "Private fields can not be deleted") : V = !0, lt = this.finishNode(Et, Tt ? "UpdateExpression" : "UnaryExpression");
        } else if (!V && this.type === o.privateId)
          (Le || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), lt = this.parsePrivateIdent(), this.type !== o._in && this.unexpected();
        else {
          if (lt = this.parseExprSubscripts(p, Le), this.checkExpressionErrors(p))
            return lt;
          for (; this.type.postfix && !this.canInsertSemicolon(); ) {
            var Yt = this.startNodeAt(Xe, at);
            Yt.operator = this.value, Yt.prefix = !1, Yt.argument = lt, this.checkLValSimple(lt), this.next(), lt = this.finishNode(Yt, "UpdateExpression");
          }
        }
        if (!Te && this.eat(o.starstar))
          if (V)
            this.unexpected(this.lastTokStart);
          else
            return this.buildBinary(Xe, at, lt, this.parseMaybeUnary(null, !1, !1, Le), "**", !1);
        else
          return lt;
      };
      function v(p) {
        return p.type === "Identifier" || p.type === "ParenthesizedExpression" && v(p.expression);
      }
      function se(p) {
        return p.type === "MemberExpression" && p.property.type === "PrivateIdentifier" || p.type === "ChainExpression" && se(p.expression) || p.type === "ParenthesizedExpression" && se(p.expression);
      }
      le.parseExprSubscripts = function(p, V) {
        var Te = this.start, Le = this.startLoc, Xe = this.parseExprAtom(p, V);
        if (Xe.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
          return Xe;
        var at = this.parseSubscripts(Xe, Te, Le, !1, V);
        return p && at.type === "MemberExpression" && (p.parenthesizedAssign >= at.start && (p.parenthesizedAssign = -1), p.parenthesizedBind >= at.start && (p.parenthesizedBind = -1), p.trailingComma >= at.start && (p.trailingComma = -1)), at;
      }, le.parseSubscripts = function(p, V, Te, Le, Xe) {
        for (var at = this.options.ecmaVersion >= 8 && p.type === "Identifier" && p.name === "async" && this.lastTokEnd === p.end && !this.canInsertSemicolon() && p.end - p.start === 5 && this.potentialArrowAt === p.start, lt = !1; ; ) {
          var Et = this.parseSubscript(p, V, Te, Le, at, lt, Xe);
          if (Et.optional && (lt = !0), Et === p || Et.type === "ArrowFunctionExpression") {
            if (lt) {
              var Tt = this.startNodeAt(V, Te);
              Tt.expression = Et, Et = this.finishNode(Tt, "ChainExpression");
            }
            return Et;
          }
          p = Et;
        }
      }, le.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(o.arrow);
      }, le.parseSubscriptAsyncArrow = function(p, V, Te, Le) {
        return this.parseArrowExpression(this.startNodeAt(p, V), Te, !0, Le);
      }, le.parseSubscript = function(p, V, Te, Le, Xe, at, lt) {
        var Et = this.options.ecmaVersion >= 11, Tt = Et && this.eat(o.questionDot);
        Le && Tt && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        var Yt = this.eat(o.bracketL);
        if (Yt || Tt && this.type !== o.parenL && this.type !== o.backQuote || this.eat(o.dot)) {
          var zt = this.startNodeAt(V, Te);
          zt.object = p, Yt ? (zt.property = this.parseExpression(), this.expect(o.bracketR)) : this.type === o.privateId && p.type !== "Super" ? zt.property = this.parsePrivateIdent() : zt.property = this.parseIdent(this.options.allowReserved !== "never"), zt.computed = !!Yt, Et && (zt.optional = Tt), p = this.finishNode(zt, "MemberExpression");
        } else if (!Le && this.eat(o.parenL)) {
          var fr = new B(), $r = this.yieldPos, Ci = this.awaitPos, Bi = this.awaitIdentPos;
          this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
          var ki = this.parseExprList(o.parenR, this.options.ecmaVersion >= 8, !1, fr);
          if (Xe && !Tt && this.shouldParseAsyncArrow())
            return this.checkPatternErrors(fr, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = $r, this.awaitPos = Ci, this.awaitIdentPos = Bi, this.parseSubscriptAsyncArrow(V, Te, ki, lt);
          this.checkExpressionErrors(fr, !0), this.yieldPos = $r || this.yieldPos, this.awaitPos = Ci || this.awaitPos, this.awaitIdentPos = Bi || this.awaitIdentPos;
          var Ai = this.startNodeAt(V, Te);
          Ai.callee = p, Ai.arguments = ki, Et && (Ai.optional = Tt), p = this.finishNode(Ai, "CallExpression");
        } else if (this.type === o.backQuote) {
          (Tt || at) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          var yi = this.startNodeAt(V, Te);
          yi.tag = p, yi.quasi = this.parseTemplate({ isTagged: !0 }), p = this.finishNode(yi, "TaggedTemplateExpression");
        }
        return p;
      }, le.parseExprAtom = function(p, V, Te) {
        this.type === o.slash && this.readRegexp();
        var Le, Xe = this.potentialArrowAt === this.start;
        switch (this.type) {
          case o._super:
            return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), Le = this.startNode(), this.next(), this.type === o.parenL && !this.allowDirectSuper && this.raise(Le.start, "super() call outside constructor of a subclass"), this.type !== o.dot && this.type !== o.bracketL && this.type !== o.parenL && this.unexpected(), this.finishNode(Le, "Super");
          case o._this:
            return Le = this.startNode(), this.next(), this.finishNode(Le, "ThisExpression");
          case o.name:
            var at = this.start, lt = this.startLoc, Et = this.containsEsc, Tt = this.parseIdent(!1);
            if (this.options.ecmaVersion >= 8 && !Et && Tt.name === "async" && !this.canInsertSemicolon() && this.eat(o._function))
              return this.overrideContext(D.f_expr), this.parseFunction(this.startNodeAt(at, lt), 0, !1, !0, V);
            if (Xe && !this.canInsertSemicolon()) {
              if (this.eat(o.arrow))
                return this.parseArrowExpression(this.startNodeAt(at, lt), [Tt], !1, V);
              if (this.options.ecmaVersion >= 8 && Tt.name === "async" && this.type === o.name && !Et && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
                return Tt = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(o.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(at, lt), [Tt], !0, V);
            }
            return Tt;
          case o.regexp:
            var Yt = this.value;
            return Le = this.parseLiteral(Yt.value), Le.regex = { pattern: Yt.pattern, flags: Yt.flags }, Le;
          case o.num:
          case o.string:
            return this.parseLiteral(this.value);
          case o._null:
          case o._true:
          case o._false:
            return Le = this.startNode(), Le.value = this.type === o._null ? null : this.type === o._true, Le.raw = this.type.keyword, this.next(), this.finishNode(Le, "Literal");
          case o.parenL:
            var zt = this.start, fr = this.parseParenAndDistinguishExpression(Xe, V);
            return p && (p.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(fr) && (p.parenthesizedAssign = zt), p.parenthesizedBind < 0 && (p.parenthesizedBind = zt)), fr;
          case o.bracketL:
            return Le = this.startNode(), this.next(), Le.elements = this.parseExprList(o.bracketR, !0, !0, p), this.finishNode(Le, "ArrayExpression");
          case o.braceL:
            return this.overrideContext(D.b_expr), this.parseObj(!1, p);
          case o._function:
            return Le = this.startNode(), this.next(), this.parseFunction(Le, 0);
          case o._class:
            return this.parseClass(this.startNode(), !1);
          case o._new:
            return this.parseNew();
          case o.backQuote:
            return this.parseTemplate();
          case o._import:
            return this.options.ecmaVersion >= 11 ? this.parseExprImport(Te) : this.unexpected();
          default:
            return this.parseExprAtomDefault();
        }
      }, le.parseExprAtomDefault = function() {
        this.unexpected();
      }, le.parseExprImport = function(p) {
        var V = this.startNode();
        if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === o.parenL && !p)
          return this.parseDynamicImport(V);
        if (this.type === o.dot) {
          var Te = this.startNodeAt(V.start, V.loc && V.loc.start);
          return Te.name = "import", V.meta = this.finishNode(Te, "Identifier"), this.parseImportMeta(V);
        } else
          this.unexpected();
      }, le.parseDynamicImport = function(p) {
        if (this.next(), p.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16)
          this.eat(o.parenR) ? p.options = null : (this.expect(o.comma), this.afterTrailingComma(o.parenR) ? p.options = null : (p.options = this.parseMaybeAssign(), this.eat(o.parenR) || (this.expect(o.comma), this.afterTrailingComma(o.parenR) || this.unexpected())));
        else if (!this.eat(o.parenR)) {
          var V = this.start;
          this.eat(o.comma) && this.eat(o.parenR) ? this.raiseRecoverable(V, "Trailing comma is not allowed in import()") : this.unexpected(V);
        }
        return this.finishNode(p, "ImportExpression");
      }, le.parseImportMeta = function(p) {
        this.next();
        var V = this.containsEsc;
        return p.property = this.parseIdent(!0), p.property.name !== "meta" && this.raiseRecoverable(p.property.start, "The only valid meta property for import is 'import.meta'"), V && this.raiseRecoverable(p.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(p.start, "Cannot use 'import.meta' outside a module"), this.finishNode(p, "MetaProperty");
      }, le.parseLiteral = function(p) {
        var V = this.startNode();
        return V.value = p, V.raw = this.input.slice(this.start, this.end), V.raw.charCodeAt(V.raw.length - 1) === 110 && (V.bigint = V.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(V, "Literal");
      }, le.parseParenExpression = function() {
        this.expect(o.parenL);
        var p = this.parseExpression();
        return this.expect(o.parenR), p;
      }, le.shouldParseArrow = function(p) {
        return !this.canInsertSemicolon();
      }, le.parseParenAndDistinguishExpression = function(p, V) {
        var Te = this.start, Le = this.startLoc, Xe, at = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var lt = this.start, Et = this.startLoc, Tt = [], Yt = !0, zt = !1, fr = new B(), $r = this.yieldPos, Ci = this.awaitPos, Bi;
          for (this.yieldPos = 0, this.awaitPos = 0; this.type !== o.parenR; )
            if (Yt ? Yt = !1 : this.expect(o.comma), at && this.afterTrailingComma(o.parenR, !0)) {
              zt = !0;
              break;
            } else if (this.type === o.ellipsis) {
              Bi = this.start, Tt.push(this.parseParenItem(this.parseRestBinding())), this.type === o.comma && this.raiseRecoverable(
                this.start,
                "Comma is not permitted after the rest element"
              );
              break;
            } else
              Tt.push(this.parseMaybeAssign(!1, fr, this.parseParenItem));
          var ki = this.lastTokEnd, Ai = this.lastTokEndLoc;
          if (this.expect(o.parenR), p && this.shouldParseArrow(Tt) && this.eat(o.arrow))
            return this.checkPatternErrors(fr, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = $r, this.awaitPos = Ci, this.parseParenArrowList(Te, Le, Tt, V);
          (!Tt.length || zt) && this.unexpected(this.lastTokStart), Bi && this.unexpected(Bi), this.checkExpressionErrors(fr, !0), this.yieldPos = $r || this.yieldPos, this.awaitPos = Ci || this.awaitPos, Tt.length > 1 ? (Xe = this.startNodeAt(lt, Et), Xe.expressions = Tt, this.finishNodeAt(Xe, "SequenceExpression", ki, Ai)) : Xe = Tt[0];
        } else
          Xe = this.parseParenExpression();
        if (this.options.preserveParens) {
          var yi = this.startNodeAt(Te, Le);
          return yi.expression = Xe, this.finishNode(yi, "ParenthesizedExpression");
        } else
          return Xe;
      }, le.parseParenItem = function(p) {
        return p;
      }, le.parseParenArrowList = function(p, V, Te, Le) {
        return this.parseArrowExpression(this.startNodeAt(p, V), Te, !1, Le);
      };
      var me = [];
      le.parseNew = function() {
        this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        var p = this.startNode();
        if (this.next(), this.options.ecmaVersion >= 6 && this.type === o.dot) {
          var V = this.startNodeAt(p.start, p.loc && p.loc.start);
          V.name = "new", p.meta = this.finishNode(V, "Identifier"), this.next();
          var Te = this.containsEsc;
          return p.property = this.parseIdent(!0), p.property.name !== "target" && this.raiseRecoverable(p.property.start, "The only valid meta property for new is 'new.target'"), Te && this.raiseRecoverable(p.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(p.start, "'new.target' can only be used in functions and class static block"), this.finishNode(p, "MetaProperty");
        }
        var Le = this.start, Xe = this.startLoc;
        return p.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), Le, Xe, !0, !1), this.eat(o.parenL) ? p.arguments = this.parseExprList(o.parenR, this.options.ecmaVersion >= 8, !1) : p.arguments = me, this.finishNode(p, "NewExpression");
      }, le.parseTemplateElement = function(p) {
        var V = p.isTagged, Te = this.startNode();
        return this.type === o.invalidTemplate ? (V || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), Te.value = {
          raw: this.value.replace(/\r\n?/g, `
`),
          cooked: null
        }) : Te.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
          cooked: this.value
        }, this.next(), Te.tail = this.type === o.backQuote, this.finishNode(Te, "TemplateElement");
      }, le.parseTemplate = function(p) {
        p === void 0 && (p = {});
        var V = p.isTagged;
        V === void 0 && (V = !1);
        var Te = this.startNode();
        this.next(), Te.expressions = [];
        var Le = this.parseTemplateElement({ isTagged: V });
        for (Te.quasis = [Le]; !Le.tail; )
          this.type === o.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(o.dollarBraceL), Te.expressions.push(this.parseExpression()), this.expect(o.braceR), Te.quasis.push(Le = this.parseTemplateElement({ isTagged: V }));
        return this.next(), this.finishNode(Te, "TemplateLiteral");
      }, le.isAsyncProp = function(p) {
        return !p.computed && p.key.type === "Identifier" && p.key.name === "async" && (this.type === o.name || this.type === o.num || this.type === o.string || this.type === o.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === o.star) && !A.test(this.input.slice(this.lastTokEnd, this.start));
      }, le.parseObj = function(p, V) {
        var Te = this.startNode(), Le = !0, Xe = {};
        for (Te.properties = [], this.next(); !this.eat(o.braceR); ) {
          if (Le)
            Le = !1;
          else if (this.expect(o.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(o.braceR))
            break;
          var at = this.parseProperty(p, V);
          p || this.checkPropClash(at, Xe, V), Te.properties.push(at);
        }
        return this.finishNode(Te, p ? "ObjectPattern" : "ObjectExpression");
      }, le.parseProperty = function(p, V) {
        var Te = this.startNode(), Le, Xe, at, lt;
        if (this.options.ecmaVersion >= 9 && this.eat(o.ellipsis))
          return p ? (Te.argument = this.parseIdent(!1), this.type === o.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(Te, "RestElement")) : (Te.argument = this.parseMaybeAssign(!1, V), this.type === o.comma && V && V.trailingComma < 0 && (V.trailingComma = this.start), this.finishNode(Te, "SpreadElement"));
        this.options.ecmaVersion >= 6 && (Te.method = !1, Te.shorthand = !1, (p || V) && (at = this.start, lt = this.startLoc), p || (Le = this.eat(o.star)));
        var Et = this.containsEsc;
        return this.parsePropertyName(Te), !p && !Et && this.options.ecmaVersion >= 8 && !Le && this.isAsyncProp(Te) ? (Xe = !0, Le = this.options.ecmaVersion >= 9 && this.eat(o.star), this.parsePropertyName(Te)) : Xe = !1, this.parsePropertyValue(Te, p, Le, Xe, at, lt, V, Et), this.finishNode(Te, "Property");
      }, le.parseGetterSetter = function(p) {
        var V = p.key.name;
        this.parsePropertyName(p), p.value = this.parseMethod(!1), p.kind = V;
        var Te = p.kind === "get" ? 0 : 1;
        if (p.value.params.length !== Te) {
          var Le = p.value.start;
          p.kind === "get" ? this.raiseRecoverable(Le, "getter should have no params") : this.raiseRecoverable(Le, "setter should have exactly one param");
        } else
          p.kind === "set" && p.value.params[0].type === "RestElement" && this.raiseRecoverable(p.value.params[0].start, "Setter cannot use rest params");
      }, le.parsePropertyValue = function(p, V, Te, Le, Xe, at, lt, Et) {
        (Te || Le) && this.type === o.colon && this.unexpected(), this.eat(o.colon) ? (p.value = V ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, lt), p.kind = "init") : this.options.ecmaVersion >= 6 && this.type === o.parenL ? (V && this.unexpected(), p.method = !0, p.value = this.parseMethod(Te, Le), p.kind = "init") : !V && !Et && this.options.ecmaVersion >= 5 && !p.computed && p.key.type === "Identifier" && (p.key.name === "get" || p.key.name === "set") && this.type !== o.comma && this.type !== o.braceR && this.type !== o.eq ? ((Te || Le) && this.unexpected(), this.parseGetterSetter(p)) : this.options.ecmaVersion >= 6 && !p.computed && p.key.type === "Identifier" ? ((Te || Le) && this.unexpected(), this.checkUnreserved(p.key), p.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = Xe), V ? p.value = this.parseMaybeDefault(Xe, at, this.copyNode(p.key)) : this.type === o.eq && lt ? (lt.shorthandAssign < 0 && (lt.shorthandAssign = this.start), p.value = this.parseMaybeDefault(Xe, at, this.copyNode(p.key))) : p.value = this.copyNode(p.key), p.kind = "init", p.shorthand = !0) : this.unexpected();
      }, le.parsePropertyName = function(p) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(o.bracketL))
            return p.computed = !0, p.key = this.parseMaybeAssign(), this.expect(o.bracketR), p.key;
          p.computed = !1;
        }
        return p.key = this.type === o.num || this.type === o.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      }, le.initFunction = function(p) {
        p.id = null, this.options.ecmaVersion >= 6 && (p.generator = p.expression = !1), this.options.ecmaVersion >= 8 && (p.async = !1);
      }, le.parseMethod = function(p, V, Te) {
        var Le = this.startNode(), Xe = this.yieldPos, at = this.awaitPos, lt = this.awaitIdentPos;
        return this.initFunction(Le), this.options.ecmaVersion >= 6 && (Le.generator = p), this.options.ecmaVersion >= 8 && (Le.async = !!V), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope($(V, Le.generator) | Ie | (Te ? De : 0)), this.expect(o.parenL), Le.params = this.parseBindingList(o.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(Le, !1, !0, !1), this.yieldPos = Xe, this.awaitPos = at, this.awaitIdentPos = lt, this.finishNode(Le, "FunctionExpression");
      }, le.parseArrowExpression = function(p, V, Te, Le) {
        var Xe = this.yieldPos, at = this.awaitPos, lt = this.awaitIdentPos;
        return this.enterScope($(Te, !1) | Ve), this.initFunction(p), this.options.ecmaVersion >= 8 && (p.async = !!Te), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, p.params = this.toAssignableList(V, !0), this.parseFunctionBody(p, !0, !1, Le), this.yieldPos = Xe, this.awaitPos = at, this.awaitIdentPos = lt, this.finishNode(p, "ArrowFunctionExpression");
      }, le.parseFunctionBody = function(p, V, Te, Le) {
        var Xe = V && this.type !== o.braceL, at = this.strict, lt = !1;
        if (Xe)
          p.body = this.parseMaybeAssign(Le), p.expression = !0, this.checkParams(p, !1);
        else {
          var Et = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(p.params);
          (!at || Et) && (lt = this.strictDirective(this.end), lt && Et && this.raiseRecoverable(p.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
          var Tt = this.labels;
          this.labels = [], lt && (this.strict = !0), this.checkParams(p, !at && !lt && !V && !Te && this.isSimpleParamList(p.params)), this.strict && p.id && this.checkLValSimple(p.id, e), p.body = this.parseBlock(!1, void 0, lt && !at), p.expression = !1, this.adaptDirectivePrologue(p.body.body), this.labels = Tt;
        }
        this.exitScope();
      }, le.isSimpleParamList = function(p) {
        for (var V = 0, Te = p; V < Te.length; V += 1) {
          var Le = Te[V];
          if (Le.type !== "Identifier")
            return !1;
        }
        return !0;
      }, le.checkParams = function(p, V) {
        for (var Te = /* @__PURE__ */ Object.create(null), Le = 0, Xe = p.params; Le < Xe.length; Le += 1) {
          var at = Xe[Le];
          this.checkLValInnerPattern(at, ve, V ? null : Te);
        }
      }, le.parseExprList = function(p, V, Te, Le) {
        for (var Xe = [], at = !0; !this.eat(p); ) {
          if (at)
            at = !1;
          else if (this.expect(o.comma), V && this.afterTrailingComma(p))
            break;
          var lt = void 0;
          Te && this.type === o.comma ? lt = null : this.type === o.ellipsis ? (lt = this.parseSpread(Le), Le && this.type === o.comma && Le.trailingComma < 0 && (Le.trailingComma = this.start)) : lt = this.parseMaybeAssign(!1, Le), Xe.push(lt);
        }
        return Xe;
      }, le.checkUnreserved = function(p) {
        var V = p.start, Te = p.end, Le = p.name;
        if (this.inGenerator && Le === "yield" && this.raiseRecoverable(V, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && Le === "await" && this.raiseRecoverable(V, "Cannot use 'await' as identifier inside an async function"), !(this.currentThisScope().flags & re) && Le === "arguments" && this.raiseRecoverable(V, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (Le === "arguments" || Le === "await") && this.raise(V, "Cannot use " + Le + " in class static initialization block"), this.keywords.test(Le) && this.raise(V, "Unexpected keyword '" + Le + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(V, Te).indexOf("\\") !== -1)) {
          var Xe = this.strict ? this.reservedWordsStrict : this.reservedWords;
          Xe.test(Le) && (!this.inAsync && Le === "await" && this.raiseRecoverable(V, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(V, "The keyword '" + Le + "' is reserved"));
        }
      }, le.parseIdent = function(p) {
        var V = this.parseIdentNode();
        return this.next(!!p), this.finishNode(V, "Identifier"), p || (this.checkUnreserved(V), V.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = V.start)), V;
      }, le.parseIdentNode = function() {
        var p = this.startNode();
        return this.type === o.name ? p.name = this.value : this.type.keyword ? (p.name = this.type.keyword, (p.name === "class" || p.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = o.name) : this.unexpected(), p;
      }, le.parsePrivateIdent = function() {
        var p = this.startNode();
        return this.type === o.privateId ? p.name = this.value : this.unexpected(), this.next(), this.finishNode(p, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(p.start, "Private field '#" + p.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(p)), p;
      }, le.parseYield = function(p) {
        this.yieldPos || (this.yieldPos = this.start);
        var V = this.startNode();
        return this.next(), this.type === o.semi || this.canInsertSemicolon() || this.type !== o.star && !this.type.startsExpr ? (V.delegate = !1, V.argument = null) : (V.delegate = this.eat(o.star), V.argument = this.parseMaybeAssign(p)), this.finishNode(V, "YieldExpression");
      }, le.parseAwait = function(p) {
        this.awaitPos || (this.awaitPos = this.start);
        var V = this.startNode();
        return this.next(), V.argument = this.parseMaybeUnary(null, !0, !1, p), this.finishNode(V, "AwaitExpression");
      };
      var O = r.prototype;
      O.raise = function(p, V) {
        var Te = fe(this.input, p);
        V += " (" + Te.line + ":" + Te.column + ")", this.sourceFile && (V += " in " + this.sourceFile);
        var Le = new SyntaxError(V);
        throw Le.pos = p, Le.loc = Te, Le.raisedAt = this.pos, Le;
      }, O.raiseRecoverable = O.raise, O.curPosition = function() {
        if (this.options.locations)
          return new ke(this.curLine, this.pos - this.lineStart);
      };
      var ce = r.prototype, Oe = function(V) {
        this.flags = V, this.var = [], this.lexical = [], this.functions = [];
      };
      ce.enterScope = function(p) {
        this.scopeStack.push(new Oe(p));
      }, ce.exitScope = function() {
        this.scopeStack.pop();
      }, ce.treatFunctionsAsVarInScope = function(p) {
        return p.flags & We || !this.inModule && p.flags & He;
      }, ce.declareName = function(p, V, Te) {
        var Le = !1;
        if (V === Y) {
          var Xe = this.currentScope();
          Le = Xe.lexical.indexOf(p) > -1 || Xe.functions.indexOf(p) > -1 || Xe.var.indexOf(p) > -1, Xe.lexical.push(p), this.inModule && Xe.flags & He && delete this.undefinedExports[p];
        } else if (V === Ae) {
          var at = this.currentScope();
          at.lexical.push(p);
        } else if (V === G) {
          var lt = this.currentScope();
          this.treatFunctionsAsVar ? Le = lt.lexical.indexOf(p) > -1 : Le = lt.lexical.indexOf(p) > -1 || lt.var.indexOf(p) > -1, lt.functions.push(p);
        } else
          for (var Et = this.scopeStack.length - 1; Et >= 0; --Et) {
            var Tt = this.scopeStack[Et];
            if (Tt.lexical.indexOf(p) > -1 && !(Tt.flags & Ge && Tt.lexical[0] === p) || !this.treatFunctionsAsVarInScope(Tt) && Tt.functions.indexOf(p) > -1) {
              Le = !0;
              break;
            }
            if (Tt.var.push(p), this.inModule && Tt.flags & He && delete this.undefinedExports[p], Tt.flags & re)
              break;
          }
        Le && this.raiseRecoverable(Te, "Identifier '" + p + "' has already been declared");
      }, ce.checkLocalExport = function(p) {
        this.scopeStack[0].lexical.indexOf(p.name) === -1 && this.scopeStack[0].var.indexOf(p.name) === -1 && (this.undefinedExports[p.name] = p);
      }, ce.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      }, ce.currentVarScope = function() {
        for (var p = this.scopeStack.length - 1; ; p--) {
          var V = this.scopeStack[p];
          if (V.flags & (re | _e | Ne))
            return V;
        }
      }, ce.currentThisScope = function() {
        for (var p = this.scopeStack.length - 1; ; p--) {
          var V = this.scopeStack[p];
          if (V.flags & (re | _e | Ne) && !(V.flags & Ve))
            return V;
        }
      };
      var Be = function(V, Te, Le) {
        this.type = "", this.start = Te, this.end = 0, V.options.locations && (this.loc = new Me(V, Le)), V.options.directSourceFile && (this.sourceFile = V.options.directSourceFile), V.options.ranges && (this.range = [Te, 0]);
      }, je = r.prototype;
      je.startNode = function() {
        return new Be(this, this.start, this.startLoc);
      }, je.startNodeAt = function(p, V) {
        return new Be(this, p, V);
      };
      function Fe(p, V, Te, Le) {
        return p.type = V, p.end = Te, this.options.locations && (p.loc.end = Le), this.options.ranges && (p.range[1] = Te), p;
      }
      je.finishNode = function(p, V) {
        return Fe.call(this, p, V, this.lastTokEnd, this.lastTokEndLoc);
      }, je.finishNodeAt = function(p, V, Te, Le) {
        return Fe.call(this, p, V, Te, Le);
      }, je.copyNode = function(p) {
        var V = new Be(this, p.start, this.startLoc);
        for (var Te in p)
          V[Te] = p[Te];
        return V;
      };
      var Ye = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz", Ke = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", et = Ke + " Extended_Pictographic", Je = et, nt = Je + " EBase EComp EMod EPres ExtPict", dt = nt, vt = dt, bt = {
        9: Ke,
        10: et,
        11: Je,
        12: nt,
        13: dt,
        14: vt
      }, At = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", ot = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: At
      }, ht = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", gt = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", Ct = gt + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", xt = Ct + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Ot = xt + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", Nt = Ot + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", Mt = Nt + " " + Ye, Gt = {
        9: gt,
        10: Ct,
        11: xt,
        12: Ot,
        13: Nt,
        14: Mt
      }, Bt = {};
      function or(p) {
        var V = Bt[p] = {
          binary: Q(bt[p] + " " + ht),
          binaryOfStrings: Q(ot[p]),
          nonBinary: {
            General_Category: Q(ht),
            Script: Q(Gt[p])
          }
        };
        V.nonBinary.Script_Extensions = V.nonBinary.Script, V.nonBinary.gc = V.nonBinary.General_Category, V.nonBinary.sc = V.nonBinary.Script, V.nonBinary.scx = V.nonBinary.Script_Extensions;
      }
      for (var ar = 0, ur = [9, 10, 11, 12, 13, 14]; ar < ur.length; ar += 1) {
        var hr = ur[ar];
        or(hr);
      }
      var wt = r.prototype, $t = function(V, Te) {
        this.parent = V, this.base = Te || this;
      };
      $t.prototype.separatedFrom = function(V) {
        for (var Te = this; Te; Te = Te.parent)
          for (var Le = V; Le; Le = Le.parent)
            if (Te.base === Le.base && Te !== Le)
              return !0;
        return !1;
      }, $t.prototype.sibling = function() {
        return new $t(this.parent, this.base);
      };
      var lr = function(V) {
        this.parser = V, this.validFlags = "gim" + (V.options.ecmaVersion >= 6 ? "uy" : "") + (V.options.ecmaVersion >= 9 ? "s" : "") + (V.options.ecmaVersion >= 13 ? "d" : "") + (V.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = Bt[V.options.ecmaVersion >= 14 ? 14 : V.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
      };
      lr.prototype.reset = function(V, Te, Le) {
        var Xe = Le.indexOf("v") !== -1, at = Le.indexOf("u") !== -1;
        this.start = V | 0, this.source = Te + "", this.flags = Le, Xe && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = at && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = at && this.parser.options.ecmaVersion >= 9);
      }, lr.prototype.raise = function(V) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + V);
      }, lr.prototype.at = function(V, Te) {
        Te === void 0 && (Te = !1);
        var Le = this.source, Xe = Le.length;
        if (V >= Xe)
          return -1;
        var at = Le.charCodeAt(V);
        if (!(Te || this.switchU) || at <= 55295 || at >= 57344 || V + 1 >= Xe)
          return at;
        var lt = Le.charCodeAt(V + 1);
        return lt >= 56320 && lt <= 57343 ? (at << 10) + lt - 56613888 : at;
      }, lr.prototype.nextIndex = function(V, Te) {
        Te === void 0 && (Te = !1);
        var Le = this.source, Xe = Le.length;
        if (V >= Xe)
          return Xe;
        var at = Le.charCodeAt(V), lt;
        return !(Te || this.switchU) || at <= 55295 || at >= 57344 || V + 1 >= Xe || (lt = Le.charCodeAt(V + 1)) < 56320 || lt > 57343 ? V + 1 : V + 2;
      }, lr.prototype.current = function(V) {
        return V === void 0 && (V = !1), this.at(this.pos, V);
      }, lr.prototype.lookahead = function(V) {
        return V === void 0 && (V = !1), this.at(this.nextIndex(this.pos, V), V);
      }, lr.prototype.advance = function(V) {
        V === void 0 && (V = !1), this.pos = this.nextIndex(this.pos, V);
      }, lr.prototype.eat = function(V, Te) {
        return Te === void 0 && (Te = !1), this.current(Te) === V ? (this.advance(Te), !0) : !1;
      }, lr.prototype.eatChars = function(V, Te) {
        Te === void 0 && (Te = !1);
        for (var Le = this.pos, Xe = 0, at = V; Xe < at.length; Xe += 1) {
          var lt = at[Xe], Et = this.at(Le, Te);
          if (Et === -1 || Et !== lt)
            return !1;
          Le = this.nextIndex(Le, Te);
        }
        return this.pos = Le, !0;
      }, wt.validateRegExpFlags = function(p) {
        for (var V = p.validFlags, Te = p.flags, Le = !1, Xe = !1, at = 0; at < Te.length; at++) {
          var lt = Te.charAt(at);
          V.indexOf(lt) === -1 && this.raise(p.start, "Invalid regular expression flag"), Te.indexOf(lt, at + 1) > -1 && this.raise(p.start, "Duplicate regular expression flag"), lt === "u" && (Le = !0), lt === "v" && (Xe = !0);
        }
        this.options.ecmaVersion >= 15 && Le && Xe && this.raise(p.start, "Invalid regular expression flag");
      };
      function tr(p) {
        for (var V in p)
          return !0;
        return !1;
      }
      wt.validateRegExpPattern = function(p) {
        this.regexp_pattern(p), !p.switchN && this.options.ecmaVersion >= 9 && tr(p.groupNames) && (p.switchN = !0, this.regexp_pattern(p));
      }, wt.regexp_pattern = function(p) {
        p.pos = 0, p.lastIntValue = 0, p.lastStringValue = "", p.lastAssertionIsQuantifiable = !1, p.numCapturingParens = 0, p.maxBackReference = 0, p.groupNames = /* @__PURE__ */ Object.create(null), p.backReferenceNames.length = 0, p.branchID = null, this.regexp_disjunction(p), p.pos !== p.source.length && (p.eat(
          41
          /* ) */
        ) && p.raise("Unmatched ')'"), (p.eat(
          93
          /* ] */
        ) || p.eat(
          125
          /* } */
        )) && p.raise("Lone quantifier brackets")), p.maxBackReference > p.numCapturingParens && p.raise("Invalid escape");
        for (var V = 0, Te = p.backReferenceNames; V < Te.length; V += 1) {
          var Le = Te[V];
          p.groupNames[Le] || p.raise("Invalid named capture referenced");
        }
      }, wt.regexp_disjunction = function(p) {
        var V = this.options.ecmaVersion >= 16;
        for (V && (p.branchID = new $t(p.branchID, null)), this.regexp_alternative(p); p.eat(
          124
          /* | */
        ); )
          V && (p.branchID = p.branchID.sibling()), this.regexp_alternative(p);
        V && (p.branchID = p.branchID.parent), this.regexp_eatQuantifier(p, !0) && p.raise("Nothing to repeat"), p.eat(
          123
          /* { */
        ) && p.raise("Lone quantifier brackets");
      }, wt.regexp_alternative = function(p) {
        for (; p.pos < p.source.length && this.regexp_eatTerm(p); )
          ;
      }, wt.regexp_eatTerm = function(p) {
        return this.regexp_eatAssertion(p) ? (p.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(p) && p.switchU && p.raise("Invalid quantifier"), !0) : (p.switchU ? this.regexp_eatAtom(p) : this.regexp_eatExtendedAtom(p)) ? (this.regexp_eatQuantifier(p), !0) : !1;
      }, wt.regexp_eatAssertion = function(p) {
        var V = p.pos;
        if (p.lastAssertionIsQuantifiable = !1, p.eat(
          94
          /* ^ */
        ) || p.eat(
          36
          /* $ */
        ))
          return !0;
        if (p.eat(
          92
          /* \ */
        )) {
          if (p.eat(
            66
            /* B */
          ) || p.eat(
            98
            /* b */
          ))
            return !0;
          p.pos = V;
        }
        if (p.eat(
          40
          /* ( */
        ) && p.eat(
          63
          /* ? */
        )) {
          var Te = !1;
          if (this.options.ecmaVersion >= 9 && (Te = p.eat(
            60
            /* < */
          )), p.eat(
            61
            /* = */
          ) || p.eat(
            33
            /* ! */
          ))
            return this.regexp_disjunction(p), p.eat(
              41
              /* ) */
            ) || p.raise("Unterminated group"), p.lastAssertionIsQuantifiable = !Te, !0;
        }
        return p.pos = V, !1;
      }, wt.regexp_eatQuantifier = function(p, V) {
        return V === void 0 && (V = !1), this.regexp_eatQuantifierPrefix(p, V) ? (p.eat(
          63
          /* ? */
        ), !0) : !1;
      }, wt.regexp_eatQuantifierPrefix = function(p, V) {
        return p.eat(
          42
          /* * */
        ) || p.eat(
          43
          /* + */
        ) || p.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(p, V);
      }, wt.regexp_eatBracedQuantifier = function(p, V) {
        var Te = p.pos;
        if (p.eat(
          123
          /* { */
        )) {
          var Le = 0, Xe = -1;
          if (this.regexp_eatDecimalDigits(p) && (Le = p.lastIntValue, p.eat(
            44
            /* , */
          ) && this.regexp_eatDecimalDigits(p) && (Xe = p.lastIntValue), p.eat(
            125
            /* } */
          )))
            return Xe !== -1 && Xe < Le && !V && p.raise("numbers out of order in {} quantifier"), !0;
          p.switchU && !V && p.raise("Incomplete quantifier"), p.pos = Te;
        }
        return !1;
      }, wt.regexp_eatAtom = function(p) {
        return this.regexp_eatPatternCharacters(p) || p.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(p) || this.regexp_eatCharacterClass(p) || this.regexp_eatUncapturingGroup(p) || this.regexp_eatCapturingGroup(p);
      }, wt.regexp_eatReverseSolidusAtomEscape = function(p) {
        var V = p.pos;
        if (p.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(p))
            return !0;
          p.pos = V;
        }
        return !1;
      }, wt.regexp_eatUncapturingGroup = function(p) {
        var V = p.pos;
        if (p.eat(
          40
          /* ( */
        )) {
          if (p.eat(
            63
            /* ? */
          )) {
            if (this.options.ecmaVersion >= 16) {
              var Te = this.regexp_eatModifiers(p), Le = p.eat(
                45
                /* - */
              );
              if (Te || Le) {
                for (var Xe = 0; Xe < Te.length; Xe++) {
                  var at = Te.charAt(Xe);
                  Te.indexOf(at, Xe + 1) > -1 && p.raise("Duplicate regular expression modifiers");
                }
                if (Le) {
                  var lt = this.regexp_eatModifiers(p);
                  !Te && !lt && p.current() === 58 && p.raise("Invalid regular expression modifiers");
                  for (var Et = 0; Et < lt.length; Et++) {
                    var Tt = lt.charAt(Et);
                    (lt.indexOf(Tt, Et + 1) > -1 || Te.indexOf(Tt) > -1) && p.raise("Duplicate regular expression modifiers");
                  }
                }
              }
            }
            if (p.eat(
              58
              /* : */
            )) {
              if (this.regexp_disjunction(p), p.eat(
                41
                /* ) */
              ))
                return !0;
              p.raise("Unterminated group");
            }
          }
          p.pos = V;
        }
        return !1;
      }, wt.regexp_eatCapturingGroup = function(p) {
        if (p.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(p) : p.current() === 63 && p.raise("Invalid group"), this.regexp_disjunction(p), p.eat(
            41
            /* ) */
          ))
            return p.numCapturingParens += 1, !0;
          p.raise("Unterminated group");
        }
        return !1;
      }, wt.regexp_eatModifiers = function(p) {
        for (var V = "", Te = 0; (Te = p.current()) !== -1 && Xr(Te); )
          V += de(Te), p.advance();
        return V;
      };
      function Xr(p) {
        return p === 105 || p === 109 || p === 115;
      }
      wt.regexp_eatExtendedAtom = function(p) {
        return p.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(p) || this.regexp_eatCharacterClass(p) || this.regexp_eatUncapturingGroup(p) || this.regexp_eatCapturingGroup(p) || this.regexp_eatInvalidBracedQuantifier(p) || this.regexp_eatExtendedPatternCharacter(p);
      }, wt.regexp_eatInvalidBracedQuantifier = function(p) {
        return this.regexp_eatBracedQuantifier(p, !0) && p.raise("Nothing to repeat"), !1;
      }, wt.regexp_eatSyntaxCharacter = function(p) {
        var V = p.current();
        return gi(V) ? (p.lastIntValue = V, p.advance(), !0) : !1;
      };
      function gi(p) {
        return p === 36 || p >= 40 && p <= 43 || p === 46 || p === 63 || p >= 91 && p <= 94 || p >= 123 && p <= 125;
      }
      wt.regexp_eatPatternCharacters = function(p) {
        for (var V = p.pos, Te = 0; (Te = p.current()) !== -1 && !gi(Te); )
          p.advance();
        return p.pos !== V;
      }, wt.regexp_eatExtendedPatternCharacter = function(p) {
        var V = p.current();
        return V !== -1 && V !== 36 && !(V >= 40 && V <= 43) && V !== 46 && V !== 63 && V !== 91 && V !== 94 && V !== 124 ? (p.advance(), !0) : !1;
      }, wt.regexp_groupSpecifier = function(p) {
        if (p.eat(
          63
          /* ? */
        )) {
          this.regexp_eatGroupName(p) || p.raise("Invalid group");
          var V = this.options.ecmaVersion >= 16, Te = p.groupNames[p.lastStringValue];
          if (Te)
            if (V)
              for (var Le = 0, Xe = Te; Le < Xe.length; Le += 1) {
                var at = Xe[Le];
                at.separatedFrom(p.branchID) || p.raise("Duplicate capture group name");
              }
            else
              p.raise("Duplicate capture group name");
          V ? (Te || (p.groupNames[p.lastStringValue] = [])).push(p.branchID) : p.groupNames[p.lastStringValue] = !0;
        }
      }, wt.regexp_eatGroupName = function(p) {
        if (p.lastStringValue = "", p.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(p) && p.eat(
            62
            /* > */
          ))
            return !0;
          p.raise("Invalid capture group name");
        }
        return !1;
      }, wt.regexp_eatRegExpIdentifierName = function(p) {
        if (p.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(p)) {
          for (p.lastStringValue += de(p.lastIntValue); this.regexp_eatRegExpIdentifierPart(p); )
            p.lastStringValue += de(p.lastIntValue);
          return !0;
        }
        return !1;
      }, wt.regexp_eatRegExpIdentifierStart = function(p) {
        var V = p.pos, Te = this.options.ecmaVersion >= 11, Le = p.current(Te);
        return p.advance(Te), Le === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(p, Te) && (Le = p.lastIntValue), ii(Le) ? (p.lastIntValue = Le, !0) : (p.pos = V, !1);
      };
      function ii(p) {
        return n(p, !0) || p === 36 || p === 95;
      }
      wt.regexp_eatRegExpIdentifierPart = function(p) {
        var V = p.pos, Te = this.options.ecmaVersion >= 11, Le = p.current(Te);
        return p.advance(Te), Le === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(p, Te) && (Le = p.lastIntValue), Br(Le) ? (p.lastIntValue = Le, !0) : (p.pos = V, !1);
      };
      function Br(p) {
        return d(p, !0) || p === 36 || p === 95 || p === 8204 || p === 8205;
      }
      wt.regexp_eatAtomEscape = function(p) {
        return this.regexp_eatBackReference(p) || this.regexp_eatCharacterClassEscape(p) || this.regexp_eatCharacterEscape(p) || p.switchN && this.regexp_eatKGroupName(p) ? !0 : (p.switchU && (p.current() === 99 && p.raise("Invalid unicode escape"), p.raise("Invalid escape")), !1);
      }, wt.regexp_eatBackReference = function(p) {
        var V = p.pos;
        if (this.regexp_eatDecimalEscape(p)) {
          var Te = p.lastIntValue;
          if (p.switchU)
            return Te > p.maxBackReference && (p.maxBackReference = Te), !0;
          if (Te <= p.numCapturingParens)
            return !0;
          p.pos = V;
        }
        return !1;
      }, wt.regexp_eatKGroupName = function(p) {
        if (p.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(p))
            return p.backReferenceNames.push(p.lastStringValue), !0;
          p.raise("Invalid named reference");
        }
        return !1;
      }, wt.regexp_eatCharacterEscape = function(p) {
        return this.regexp_eatControlEscape(p) || this.regexp_eatCControlLetter(p) || this.regexp_eatZero(p) || this.regexp_eatHexEscapeSequence(p) || this.regexp_eatRegExpUnicodeEscapeSequence(p, !1) || !p.switchU && this.regexp_eatLegacyOctalEscapeSequence(p) || this.regexp_eatIdentityEscape(p);
      }, wt.regexp_eatCControlLetter = function(p) {
        var V = p.pos;
        if (p.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(p))
            return !0;
          p.pos = V;
        }
        return !1;
      }, wt.regexp_eatZero = function(p) {
        return p.current() === 48 && !qt(p.lookahead()) ? (p.lastIntValue = 0, p.advance(), !0) : !1;
      }, wt.regexp_eatControlEscape = function(p) {
        var V = p.current();
        return V === 116 ? (p.lastIntValue = 9, p.advance(), !0) : V === 110 ? (p.lastIntValue = 10, p.advance(), !0) : V === 118 ? (p.lastIntValue = 11, p.advance(), !0) : V === 102 ? (p.lastIntValue = 12, p.advance(), !0) : V === 114 ? (p.lastIntValue = 13, p.advance(), !0) : !1;
      }, wt.regexp_eatControlLetter = function(p) {
        var V = p.current();
        return Er(V) ? (p.lastIntValue = V % 32, p.advance(), !0) : !1;
      };
      function Er(p) {
        return p >= 65 && p <= 90 || p >= 97 && p <= 122;
      }
      wt.regexp_eatRegExpUnicodeEscapeSequence = function(p, V) {
        V === void 0 && (V = !1);
        var Te = p.pos, Le = V || p.switchU;
        if (p.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(p, 4)) {
            var Xe = p.lastIntValue;
            if (Le && Xe >= 55296 && Xe <= 56319) {
              var at = p.pos;
              if (p.eat(
                92
                /* \ */
              ) && p.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(p, 4)) {
                var lt = p.lastIntValue;
                if (lt >= 56320 && lt <= 57343)
                  return p.lastIntValue = (Xe - 55296) * 1024 + (lt - 56320) + 65536, !0;
              }
              p.pos = at, p.lastIntValue = Xe;
            }
            return !0;
          }
          if (Le && p.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(p) && p.eat(
            125
            /* } */
          ) && kr(p.lastIntValue))
            return !0;
          Le && p.raise("Invalid unicode escape"), p.pos = Te;
        }
        return !1;
      };
      function kr(p) {
        return p >= 0 && p <= 1114111;
      }
      wt.regexp_eatIdentityEscape = function(p) {
        if (p.switchU)
          return this.regexp_eatSyntaxCharacter(p) ? !0 : p.eat(
            47
            /* / */
          ) ? (p.lastIntValue = 47, !0) : !1;
        var V = p.current();
        return V !== 99 && (!p.switchN || V !== 107) ? (p.lastIntValue = V, p.advance(), !0) : !1;
      }, wt.regexp_eatDecimalEscape = function(p) {
        p.lastIntValue = 0;
        var V = p.current();
        if (V >= 49 && V <= 57) {
          do
            p.lastIntValue = 10 * p.lastIntValue + (V - 48), p.advance();
          while ((V = p.current()) >= 48 && V <= 57);
          return !0;
        }
        return !1;
      };
      var qr = 0, yr = 1, Or = 2;
      wt.regexp_eatCharacterClassEscape = function(p) {
        var V = p.current();
        if (yn(V))
          return p.lastIntValue = -1, p.advance(), yr;
        var Te = !1;
        if (p.switchU && this.options.ecmaVersion >= 9 && ((Te = V === 80) || V === 112)) {
          p.lastIntValue = -1, p.advance();
          var Le;
          if (p.eat(
            123
            /* { */
          ) && (Le = this.regexp_eatUnicodePropertyValueExpression(p)) && p.eat(
            125
            /* } */
          ))
            return Te && Le === Or && p.raise("Invalid property name"), Le;
          p.raise("Invalid property name");
        }
        return qr;
      };
      function yn(p) {
        return p === 100 || p === 68 || p === 115 || p === 83 || p === 119 || p === 87;
      }
      wt.regexp_eatUnicodePropertyValueExpression = function(p) {
        var V = p.pos;
        if (this.regexp_eatUnicodePropertyName(p) && p.eat(
          61
          /* = */
        )) {
          var Te = p.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(p)) {
            var Le = p.lastStringValue;
            return this.regexp_validateUnicodePropertyNameAndValue(p, Te, Le), yr;
          }
        }
        if (p.pos = V, this.regexp_eatLoneUnicodePropertyNameOrValue(p)) {
          var Xe = p.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(p, Xe);
        }
        return qr;
      }, wt.regexp_validateUnicodePropertyNameAndValue = function(p, V, Te) {
        ee(p.unicodeProperties.nonBinary, V) || p.raise("Invalid property name"), p.unicodeProperties.nonBinary[V].test(Te) || p.raise("Invalid property value");
      }, wt.regexp_validateUnicodePropertyNameOrValue = function(p, V) {
        if (p.unicodeProperties.binary.test(V))
          return yr;
        if (p.switchV && p.unicodeProperties.binaryOfStrings.test(V))
          return Or;
        p.raise("Invalid property name");
      }, wt.regexp_eatUnicodePropertyName = function(p) {
        var V = 0;
        for (p.lastStringValue = ""; wn(V = p.current()); )
          p.lastStringValue += de(V), p.advance();
        return p.lastStringValue !== "";
      };
      function wn(p) {
        return Er(p) || p === 95;
      }
      wt.regexp_eatUnicodePropertyValue = function(p) {
        var V = 0;
        for (p.lastStringValue = ""; bn(V = p.current()); )
          p.lastStringValue += de(V), p.advance();
        return p.lastStringValue !== "";
      };
      function bn(p) {
        return wn(p) || qt(p);
      }
      wt.regexp_eatLoneUnicodePropertyNameOrValue = function(p) {
        return this.regexp_eatUnicodePropertyValue(p);
      }, wt.regexp_eatCharacterClass = function(p) {
        if (p.eat(
          91
          /* [ */
        )) {
          var V = p.eat(
            94
            /* ^ */
          ), Te = this.regexp_classContents(p);
          return p.eat(
            93
            /* ] */
          ) || p.raise("Unterminated character class"), V && Te === Or && p.raise("Negated character class may contain strings"), !0;
        }
        return !1;
      }, wt.regexp_classContents = function(p) {
        return p.current() === 93 ? yr : p.switchV ? this.regexp_classSetExpression(p) : (this.regexp_nonEmptyClassRanges(p), yr);
      }, wt.regexp_nonEmptyClassRanges = function(p) {
        for (; this.regexp_eatClassAtom(p); ) {
          var V = p.lastIntValue;
          if (p.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(p)) {
            var Te = p.lastIntValue;
            p.switchU && (V === -1 || Te === -1) && p.raise("Invalid character class"), V !== -1 && Te !== -1 && V > Te && p.raise("Range out of order in character class");
          }
        }
      }, wt.regexp_eatClassAtom = function(p) {
        var V = p.pos;
        if (p.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(p))
            return !0;
          if (p.switchU) {
            var Te = p.current();
            (Te === 99 || _i(Te)) && p.raise("Invalid class escape"), p.raise("Invalid escape");
          }
          p.pos = V;
        }
        var Le = p.current();
        return Le !== 93 ? (p.lastIntValue = Le, p.advance(), !0) : !1;
      }, wt.regexp_eatClassEscape = function(p) {
        var V = p.pos;
        if (p.eat(
          98
          /* b */
        ))
          return p.lastIntValue = 8, !0;
        if (p.switchU && p.eat(
          45
          /* - */
        ))
          return p.lastIntValue = 45, !0;
        if (!p.switchU && p.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(p))
            return !0;
          p.pos = V;
        }
        return this.regexp_eatCharacterClassEscape(p) || this.regexp_eatCharacterEscape(p);
      }, wt.regexp_classSetExpression = function(p) {
        var V = yr, Te;
        if (!this.regexp_eatClassSetRange(p)) if (Te = this.regexp_eatClassSetOperand(p)) {
          Te === Or && (V = Or);
          for (var Le = p.pos; p.eatChars(
            [38, 38]
            /* && */
          ); ) {
            if (p.current() !== 38 && (Te = this.regexp_eatClassSetOperand(p))) {
              Te !== Or && (V = yr);
              continue;
            }
            p.raise("Invalid character in character class");
          }
          if (Le !== p.pos)
            return V;
          for (; p.eatChars(
            [45, 45]
            /* -- */
          ); )
            this.regexp_eatClassSetOperand(p) || p.raise("Invalid character in character class");
          if (Le !== p.pos)
            return V;
        } else
          p.raise("Invalid character in character class");
        for (; ; )
          if (!this.regexp_eatClassSetRange(p)) {
            if (Te = this.regexp_eatClassSetOperand(p), !Te)
              return V;
            Te === Or && (V = Or);
          }
      }, wt.regexp_eatClassSetRange = function(p) {
        var V = p.pos;
        if (this.regexp_eatClassSetCharacter(p)) {
          var Te = p.lastIntValue;
          if (p.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(p)) {
            var Le = p.lastIntValue;
            return Te !== -1 && Le !== -1 && Te > Le && p.raise("Range out of order in character class"), !0;
          }
          p.pos = V;
        }
        return !1;
      }, wt.regexp_eatClassSetOperand = function(p) {
        return this.regexp_eatClassSetCharacter(p) ? yr : this.regexp_eatClassStringDisjunction(p) || this.regexp_eatNestedClass(p);
      }, wt.regexp_eatNestedClass = function(p) {
        var V = p.pos;
        if (p.eat(
          91
          /* [ */
        )) {
          var Te = p.eat(
            94
            /* ^ */
          ), Le = this.regexp_classContents(p);
          if (p.eat(
            93
            /* ] */
          ))
            return Te && Le === Or && p.raise("Negated character class may contain strings"), Le;
          p.pos = V;
        }
        if (p.eat(
          92
          /* \ */
        )) {
          var Xe = this.regexp_eatCharacterClassEscape(p);
          if (Xe)
            return Xe;
          p.pos = V;
        }
        return null;
      }, wt.regexp_eatClassStringDisjunction = function(p) {
        var V = p.pos;
        if (p.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (p.eat(
            123
            /* { */
          )) {
            var Te = this.regexp_classStringDisjunctionContents(p);
            if (p.eat(
              125
              /* } */
            ))
              return Te;
          } else
            p.raise("Invalid escape");
          p.pos = V;
        }
        return null;
      }, wt.regexp_classStringDisjunctionContents = function(p) {
        for (var V = this.regexp_classString(p); p.eat(
          124
          /* | */
        ); )
          this.regexp_classString(p) === Or && (V = Or);
        return V;
      }, wt.regexp_classString = function(p) {
        for (var V = 0; this.regexp_eatClassSetCharacter(p); )
          V++;
        return V === 1 ? yr : Or;
      }, wt.regexp_eatClassSetCharacter = function(p) {
        var V = p.pos;
        if (p.eat(
          92
          /* \ */
        ))
          return this.regexp_eatCharacterEscape(p) || this.regexp_eatClassSetReservedPunctuator(p) ? !0 : p.eat(
            98
            /* b */
          ) ? (p.lastIntValue = 8, !0) : (p.pos = V, !1);
        var Te = p.current();
        return Te < 0 || Te === p.lookahead() && Yi(Te) || ya(Te) ? !1 : (p.advance(), p.lastIntValue = Te, !0);
      };
      function Yi(p) {
        return p === 33 || p >= 35 && p <= 38 || p >= 42 && p <= 44 || p === 46 || p >= 58 && p <= 64 || p === 94 || p === 96 || p === 126;
      }
      function ya(p) {
        return p === 40 || p === 41 || p === 45 || p === 47 || p >= 91 && p <= 93 || p >= 123 && p <= 125;
      }
      wt.regexp_eatClassSetReservedPunctuator = function(p) {
        var V = p.current();
        return Xi(V) ? (p.lastIntValue = V, p.advance(), !0) : !1;
      };
      function Xi(p) {
        return p === 33 || p === 35 || p === 37 || p === 38 || p === 44 || p === 45 || p >= 58 && p <= 62 || p === 64 || p === 96 || p === 126;
      }
      wt.regexp_eatClassControlLetter = function(p) {
        var V = p.current();
        return qt(V) || V === 95 ? (p.lastIntValue = V % 32, p.advance(), !0) : !1;
      }, wt.regexp_eatHexEscapeSequence = function(p) {
        var V = p.pos;
        if (p.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(p, 2))
            return !0;
          p.switchU && p.raise("Invalid escape"), p.pos = V;
        }
        return !1;
      }, wt.regexp_eatDecimalDigits = function(p) {
        var V = p.pos, Te = 0;
        for (p.lastIntValue = 0; qt(Te = p.current()); )
          p.lastIntValue = 10 * p.lastIntValue + (Te - 48), p.advance();
        return p.pos !== V;
      };
      function qt(p) {
        return p >= 48 && p <= 57;
      }
      wt.regexp_eatHexDigits = function(p) {
        var V = p.pos, Te = 0;
        for (p.lastIntValue = 0; qi(Te = p.current()); )
          p.lastIntValue = 16 * p.lastIntValue + Qi(Te), p.advance();
        return p.pos !== V;
      };
      function qi(p) {
        return p >= 48 && p <= 57 || p >= 65 && p <= 70 || p >= 97 && p <= 102;
      }
      function Qi(p) {
        return p >= 65 && p <= 70 ? 10 + (p - 65) : p >= 97 && p <= 102 ? 10 + (p - 97) : p - 48;
      }
      wt.regexp_eatLegacyOctalEscapeSequence = function(p) {
        if (this.regexp_eatOctalDigit(p)) {
          var V = p.lastIntValue;
          if (this.regexp_eatOctalDigit(p)) {
            var Te = p.lastIntValue;
            V <= 3 && this.regexp_eatOctalDigit(p) ? p.lastIntValue = V * 64 + Te * 8 + p.lastIntValue : p.lastIntValue = V * 8 + Te;
          } else
            p.lastIntValue = V;
          return !0;
        }
        return !1;
      }, wt.regexp_eatOctalDigit = function(p) {
        var V = p.current();
        return _i(V) ? (p.lastIntValue = V - 48, p.advance(), !0) : (p.lastIntValue = 0, !1);
      };
      function _i(p) {
        return p >= 48 && p <= 55;
      }
      wt.regexp_eatFixedHexDigits = function(p, V) {
        var Te = p.pos;
        p.lastIntValue = 0;
        for (var Le = 0; Le < V; ++Le) {
          var Xe = p.current();
          if (!qi(Xe))
            return p.pos = Te, !1;
          p.lastIntValue = 16 * p.lastIntValue + Qi(Xe), p.advance();
        }
        return !0;
      };
      var ni = function(V) {
        this.type = V.type, this.value = V.value, this.start = V.start, this.end = V.end, V.options.locations && (this.loc = new Me(V, V.startLoc, V.endLoc)), V.options.ranges && (this.range = [V.start, V.end]);
      }, Vt = r.prototype;
      Vt.next = function(p) {
        !p && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new ni(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
      }, Vt.getToken = function() {
        return this.next(), new ni(this);
      }, typeof Symbol < "u" && (Vt[Symbol.iterator] = function() {
        var p = this;
        return {
          next: function() {
            var V = p.getToken();
            return {
              done: V.type === o.eof,
              value: V
            };
          }
        };
      }), Vt.nextToken = function() {
        var p = this.curContext();
        if ((!p || !p.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
          return this.finishToken(o.eof);
        if (p.override)
          return p.override(this);
        this.readToken(this.fullCharCodeAtPos());
      }, Vt.readToken = function(p) {
        return n(p, this.options.ecmaVersion >= 6) || p === 92 ? this.readWord() : this.getTokenFromCode(p);
      }, Vt.fullCharCodeAtPos = function() {
        var p = this.input.charCodeAt(this.pos);
        if (p <= 55295 || p >= 56320)
          return p;
        var V = this.input.charCodeAt(this.pos + 1);
        return V <= 56319 || V >= 57344 ? p : (p << 10) + V - 56613888;
      }, Vt.skipBlockComment = function() {
        var p = this.options.onComment && this.curPosition(), V = this.pos, Te = this.input.indexOf("*/", this.pos += 2);
        if (Te === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = Te + 2, this.options.locations)
          for (var Le = void 0, Xe = V; (Le = L(this.input, Xe, this.pos)) > -1; )
            ++this.curLine, Xe = this.lineStart = Le;
        this.options.onComment && this.options.onComment(
          !0,
          this.input.slice(V + 2, Te),
          V,
          this.pos,
          p,
          this.curPosition()
        );
      }, Vt.skipLineComment = function(p) {
        for (var V = this.pos, Te = this.options.onComment && this.curPosition(), Le = this.input.charCodeAt(this.pos += p); this.pos < this.input.length && !I(Le); )
          Le = this.input.charCodeAt(++this.pos);
        this.options.onComment && this.options.onComment(
          !1,
          this.input.slice(V + p, this.pos),
          V,
          this.pos,
          Te,
          this.curPosition()
        );
      }, Vt.skipSpace = function() {
        e: for (; this.pos < this.input.length; ) {
          var p = this.input.charCodeAt(this.pos);
          switch (p) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break e;
              }
              break;
            default:
              if (p > 8 && p < 14 || p >= 5760 && z.test(String.fromCharCode(p)))
                ++this.pos;
              else
                break e;
          }
        }
      }, Vt.finishToken = function(p, V) {
        this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
        var Te = this.type;
        this.type = p, this.value = V, this.updateContext(Te);
      }, Vt.readToken_dot = function() {
        var p = this.input.charCodeAt(this.pos + 1);
        if (p >= 48 && p <= 57)
          return this.readNumber(!0);
        var V = this.input.charCodeAt(this.pos + 2);
        return this.options.ecmaVersion >= 6 && p === 46 && V === 46 ? (this.pos += 3, this.finishToken(o.ellipsis)) : (++this.pos, this.finishToken(o.dot));
      }, Vt.readToken_slash = function() {
        var p = this.input.charCodeAt(this.pos + 1);
        return this.exprAllowed ? (++this.pos, this.readRegexp()) : p === 61 ? this.finishOp(o.assign, 2) : this.finishOp(o.slash, 1);
      }, Vt.readToken_mult_modulo_exp = function(p) {
        var V = this.input.charCodeAt(this.pos + 1), Te = 1, Le = p === 42 ? o.star : o.modulo;
        return this.options.ecmaVersion >= 7 && p === 42 && V === 42 && (++Te, Le = o.starstar, V = this.input.charCodeAt(this.pos + 2)), V === 61 ? this.finishOp(o.assign, Te + 1) : this.finishOp(Le, Te);
      }, Vt.readToken_pipe_amp = function(p) {
        var V = this.input.charCodeAt(this.pos + 1);
        if (V === p) {
          if (this.options.ecmaVersion >= 12) {
            var Te = this.input.charCodeAt(this.pos + 2);
            if (Te === 61)
              return this.finishOp(o.assign, 3);
          }
          return this.finishOp(p === 124 ? o.logicalOR : o.logicalAND, 2);
        }
        return V === 61 ? this.finishOp(o.assign, 2) : this.finishOp(p === 124 ? o.bitwiseOR : o.bitwiseAND, 1);
      }, Vt.readToken_caret = function() {
        var p = this.input.charCodeAt(this.pos + 1);
        return p === 61 ? this.finishOp(o.assign, 2) : this.finishOp(o.bitwiseXOR, 1);
      }, Vt.readToken_plus_min = function(p) {
        var V = this.input.charCodeAt(this.pos + 1);
        return V === p ? V === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || A.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(o.incDec, 2) : V === 61 ? this.finishOp(o.assign, 2) : this.finishOp(o.plusMin, 1);
      }, Vt.readToken_lt_gt = function(p) {
        var V = this.input.charCodeAt(this.pos + 1), Te = 1;
        return V === p ? (Te = p === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + Te) === 61 ? this.finishOp(o.assign, Te + 1) : this.finishOp(o.bitShift, Te)) : V === 33 && p === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (V === 61 && (Te = 2), this.finishOp(o.relational, Te));
      }, Vt.readToken_eq_excl = function(p) {
        var V = this.input.charCodeAt(this.pos + 1);
        return V === 61 ? this.finishOp(o.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : p === 61 && V === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(o.arrow)) : this.finishOp(p === 61 ? o.eq : o.prefix, 1);
      }, Vt.readToken_question = function() {
        var p = this.options.ecmaVersion;
        if (p >= 11) {
          var V = this.input.charCodeAt(this.pos + 1);
          if (V === 46) {
            var Te = this.input.charCodeAt(this.pos + 2);
            if (Te < 48 || Te > 57)
              return this.finishOp(o.questionDot, 2);
          }
          if (V === 63) {
            if (p >= 12) {
              var Le = this.input.charCodeAt(this.pos + 2);
              if (Le === 61)
                return this.finishOp(o.assign, 3);
            }
            return this.finishOp(o.coalesce, 2);
          }
        }
        return this.finishOp(o.question, 1);
      }, Vt.readToken_numberSign = function() {
        var p = this.options.ecmaVersion, V = 35;
        if (p >= 13 && (++this.pos, V = this.fullCharCodeAtPos(), n(V, !0) || V === 92))
          return this.finishToken(o.privateId, this.readWord1());
        this.raise(this.pos, "Unexpected character '" + de(V) + "'");
      }, Vt.getTokenFromCode = function(p) {
        switch (p) {
          // The interpretation of a dot depends on whether it is followed
          // by a digit or another two dots.
          case 46:
            return this.readToken_dot();
          // Punctuation tokens.
          case 40:
            return ++this.pos, this.finishToken(o.parenL);
          case 41:
            return ++this.pos, this.finishToken(o.parenR);
          case 59:
            return ++this.pos, this.finishToken(o.semi);
          case 44:
            return ++this.pos, this.finishToken(o.comma);
          case 91:
            return ++this.pos, this.finishToken(o.bracketL);
          case 93:
            return ++this.pos, this.finishToken(o.bracketR);
          case 123:
            return ++this.pos, this.finishToken(o.braceL);
          case 125:
            return ++this.pos, this.finishToken(o.braceR);
          case 58:
            return ++this.pos, this.finishToken(o.colon);
          case 96:
            if (this.options.ecmaVersion < 6)
              break;
            return ++this.pos, this.finishToken(o.backQuote);
          case 48:
            var V = this.input.charCodeAt(this.pos + 1);
            if (V === 120 || V === 88)
              return this.readRadixNumber(16);
            if (this.options.ecmaVersion >= 6) {
              if (V === 111 || V === 79)
                return this.readRadixNumber(8);
              if (V === 98 || V === 66)
                return this.readRadixNumber(2);
            }
          // Anything else beginning with a digit is an integer, octal
          // number, or float.
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(!1);
          // Quotes produce strings.
          case 34:
          case 39:
            return this.readString(p);
          // Operators are parsed inline in tiny state machines. '=' (61) is
          // often referred to. `finishOp` simply skips the amount of
          // characters it is given as second argument, and returns a token
          // of the type given by its first argument.
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(p);
          case 124:
          case 38:
            return this.readToken_pipe_amp(p);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(p);
          case 60:
          case 62:
            return this.readToken_lt_gt(p);
          case 61:
          case 33:
            return this.readToken_eq_excl(p);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(o.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + de(p) + "'");
      }, Vt.finishOp = function(p, V) {
        var Te = this.input.slice(this.pos, this.pos + V);
        return this.pos += V, this.finishToken(p, Te);
      }, Vt.readRegexp = function() {
        for (var p, V, Te = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(Te, "Unterminated regular expression");
          var Le = this.input.charAt(this.pos);
          if (A.test(Le) && this.raise(Te, "Unterminated regular expression"), p)
            p = !1;
          else {
            if (Le === "[")
              V = !0;
            else if (Le === "]" && V)
              V = !1;
            else if (Le === "/" && !V)
              break;
            p = Le === "\\";
          }
          ++this.pos;
        }
        var Xe = this.input.slice(Te, this.pos);
        ++this.pos;
        var at = this.pos, lt = this.readWord1();
        this.containsEsc && this.unexpected(at);
        var Et = this.regexpState || (this.regexpState = new lr(this));
        Et.reset(Te, Xe, lt), this.validateRegExpFlags(Et), this.validateRegExpPattern(Et);
        var Tt = null;
        try {
          Tt = new RegExp(Xe, lt);
        } catch {
        }
        return this.finishToken(o.regexp, { pattern: Xe, flags: lt, value: Tt });
      }, Vt.readInt = function(p, V, Te) {
        for (var Le = this.options.ecmaVersion >= 12 && V === void 0, Xe = Te && this.input.charCodeAt(this.pos) === 48, at = this.pos, lt = 0, Et = 0, Tt = 0, Yt = V ?? 1 / 0; Tt < Yt; ++Tt, ++this.pos) {
          var zt = this.input.charCodeAt(this.pos), fr = void 0;
          if (Le && zt === 95) {
            Xe && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), Et === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), Tt === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), Et = zt;
            continue;
          }
          if (zt >= 97 ? fr = zt - 97 + 10 : zt >= 65 ? fr = zt - 65 + 10 : zt >= 48 && zt <= 57 ? fr = zt - 48 : fr = 1 / 0, fr >= p)
            break;
          Et = zt, lt = lt * p + fr;
        }
        return Le && Et === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === at || V != null && this.pos - at !== V ? null : lt;
      };
      function Qr(p, V) {
        return V ? parseInt(p, 8) : parseFloat(p.replace(/_/g, ""));
      }
      function Kr(p) {
        return typeof BigInt != "function" ? null : BigInt(p.replace(/_/g, ""));
      }
      Vt.readRadixNumber = function(p) {
        var V = this.pos;
        this.pos += 2;
        var Te = this.readInt(p);
        return Te == null && this.raise(this.start + 2, "Expected number in radix " + p), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (Te = Kr(this.input.slice(V, this.pos)), ++this.pos) : n(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(o.num, Te);
      }, Vt.readNumber = function(p) {
        var V = this.pos;
        !p && this.readInt(10, void 0, !0) === null && this.raise(V, "Invalid number");
        var Te = this.pos - V >= 2 && this.input.charCodeAt(V) === 48;
        Te && this.strict && this.raise(V, "Invalid number");
        var Le = this.input.charCodeAt(this.pos);
        if (!Te && !p && this.options.ecmaVersion >= 11 && Le === 110) {
          var Xe = Kr(this.input.slice(V, this.pos));
          return ++this.pos, n(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(o.num, Xe);
        }
        Te && /[89]/.test(this.input.slice(V, this.pos)) && (Te = !1), Le === 46 && !Te && (++this.pos, this.readInt(10), Le = this.input.charCodeAt(this.pos)), (Le === 69 || Le === 101) && !Te && (Le = this.input.charCodeAt(++this.pos), (Le === 43 || Le === 45) && ++this.pos, this.readInt(10) === null && this.raise(V, "Invalid number")), n(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
        var at = Qr(this.input.slice(V, this.pos), Te);
        return this.finishToken(o.num, at);
      }, Vt.readCodePoint = function() {
        var p = this.input.charCodeAt(this.pos), V;
        if (p === 123) {
          this.options.ecmaVersion < 6 && this.unexpected();
          var Te = ++this.pos;
          V = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, V > 1114111 && this.invalidStringToken(Te, "Code point out of bounds");
        } else
          V = this.readHexChar(4);
        return V;
      }, Vt.readString = function(p) {
        for (var V = "", Te = ++this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
          var Le = this.input.charCodeAt(this.pos);
          if (Le === p)
            break;
          Le === 92 ? (V += this.input.slice(Te, this.pos), V += this.readEscapedChar(!1), Te = this.pos) : Le === 8232 || Le === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (I(Le) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
        }
        return V += this.input.slice(Te, this.pos++), this.finishToken(o.string, V);
      };
      var zr = {};
      Vt.tryReadTemplateToken = function() {
        this.inTemplateElement = !0;
        try {
          this.readTmplToken();
        } catch (p) {
          if (p === zr)
            this.readInvalidTemplateToken();
          else
            throw p;
        }
        this.inTemplateElement = !1;
      }, Vt.invalidStringToken = function(p, V) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9)
          throw zr;
        this.raise(p, V);
      }, Vt.readTmplToken = function() {
        for (var p = "", V = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
          var Te = this.input.charCodeAt(this.pos);
          if (Te === 96 || Te === 36 && this.input.charCodeAt(this.pos + 1) === 123)
            return this.pos === this.start && (this.type === o.template || this.type === o.invalidTemplate) ? Te === 36 ? (this.pos += 2, this.finishToken(o.dollarBraceL)) : (++this.pos, this.finishToken(o.backQuote)) : (p += this.input.slice(V, this.pos), this.finishToken(o.template, p));
          if (Te === 92)
            p += this.input.slice(V, this.pos), p += this.readEscapedChar(!0), V = this.pos;
          else if (I(Te)) {
            switch (p += this.input.slice(V, this.pos), ++this.pos, Te) {
              case 13:
                this.input.charCodeAt(this.pos) === 10 && ++this.pos;
              case 10:
                p += `
`;
                break;
              default:
                p += String.fromCharCode(Te);
                break;
            }
            this.options.locations && (++this.curLine, this.lineStart = this.pos), V = this.pos;
          } else
            ++this.pos;
        }
      }, Vt.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++)
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{")
                break;
            // fall through
            case "`":
              return this.finishToken(o.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              this.input[this.pos + 1] === `
` && ++this.pos;
            // fall through
            case `
`:
            case "\u2028":
            case "\u2029":
              ++this.curLine, this.lineStart = this.pos + 1;
              break;
          }
        this.raise(this.start, "Unterminated template");
      }, Vt.readEscapedChar = function(p) {
        var V = this.input.charCodeAt(++this.pos);
        switch (++this.pos, V) {
          case 110:
            return `
`;
          // 'n' -> '\n'
          case 114:
            return "\r";
          // 'r' -> '\r'
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          // 'x'
          case 117:
            return de(this.readCodePoint());
          // 'u'
          case 116:
            return "	";
          // 't' -> '\t'
          case 98:
            return "\b";
          // 'b' -> '\b'
          case 118:
            return "\v";
          // 'v' -> '\u000b'
          case 102:
            return "\f";
          // 'f' -> '\f'
          case 13:
            this.input.charCodeAt(this.pos) === 10 && ++this.pos;
          // '\r\n'
          case 10:
            return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
          case 56:
          case 57:
            if (this.strict && this.invalidStringToken(
              this.pos - 1,
              "Invalid escape sequence"
            ), p) {
              var Te = this.pos - 1;
              this.invalidStringToken(
                Te,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (V >= 48 && V <= 55) {
              var Le = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], Xe = parseInt(Le, 8);
              return Xe > 255 && (Le = Le.slice(0, -1), Xe = parseInt(Le, 8)), this.pos += Le.length - 1, V = this.input.charCodeAt(this.pos), (Le !== "0" || V === 56 || V === 57) && (this.strict || p) && this.invalidStringToken(
                this.pos - 1 - Le.length,
                p ? "Octal literal in template string" : "Octal literal in strict mode"
              ), String.fromCharCode(Xe);
            }
            return I(V) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(V);
        }
      }, Vt.readHexChar = function(p) {
        var V = this.pos, Te = this.readInt(16, p);
        return Te === null && this.invalidStringToken(V, "Bad character escape sequence"), Te;
      }, Vt.readWord1 = function() {
        this.containsEsc = !1;
        for (var p = "", V = !0, Te = this.pos, Le = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
          var Xe = this.fullCharCodeAtPos();
          if (d(Xe, Le))
            this.pos += Xe <= 65535 ? 1 : 2;
          else if (Xe === 92) {
            this.containsEsc = !0, p += this.input.slice(Te, this.pos);
            var at = this.pos;
            this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
            var lt = this.readCodePoint();
            (V ? n : d)(lt, Le) || this.invalidStringToken(at, "Invalid Unicode escape"), p += de(lt), Te = this.pos;
          } else
            break;
          V = !1;
        }
        return p + this.input.slice(Te, this.pos);
      }, Vt.readWord = function() {
        var p = this.readWord1(), V = o.name;
        return this.keywords.test(p) && (V = b[p]), this.finishToken(V, p);
      };
      var Fr = "8.14.1";
      r.acorn = {
        Parser: r,
        version: Fr,
        defaultOptions: xe,
        Position: ke,
        SourceLocation: Me,
        getLineInfo: fe,
        Node: Be,
        TokenType: g,
        tokTypes: o,
        keywordTypes: b,
        TokContext: he,
        tokContexts: D,
        isIdentifierChar: d,
        isIdentifierStart: n,
        Token: ni,
        isNewLine: I,
        lineBreak: A,
        lineBreakG: T,
        nonASCIIwhitespace: z
      };
      function oi(p, V) {
        return r.parse(p, V);
      }
      function ui(p, V, Te) {
        return r.parseExpressionAt(p, V, Te);
      }
      function Di(p, V) {
        return r.tokenizer(p, V);
      }
      ae.Node = Be, ae.Parser = r, ae.Position = ke, ae.SourceLocation = Me, ae.TokContext = he, ae.Token = ni, ae.TokenType = g, ae.defaultOptions = xe, ae.getLineInfo = fe, ae.isIdentifierChar = d, ae.isIdentifierStart = n, ae.isNewLine = I, ae.keywordTypes = b, ae.lineBreak = A, ae.lineBreakG = T, ae.nonASCIIwhitespace = z, ae.parse = oi, ae.parseExpressionAt = ui, ae.tokContexts = D, ae.tokTypes = o, ae.tokenizer = Di, ae.version = Fr;
    });
  }(Ps, Ps.exports)), Ps.exports;
}
/*!
 * Paper.js v0.12.18 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2020, Jürg Lehni & Jonathan Puckey
 * http://juerglehni.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Wed Jul 17 14:57:24 2024 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2020 Jürg Lehni
 * http://juerglehni.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */
var N0 = Vo.exports, Wc;
function D0() {
  return Wc || (Wc = 1, function(Re) {
    (function(be, ae) {
      be = be || Gc;
      var k = be.window, Z = be.document, _ = new function() {
        var e = /^(statics|enumerable|beans|preserve)$/, r = [], f = r.slice, C = Object.create, R = Object.getOwnPropertyDescriptor, B = Object.defineProperty, j = r.forEach || function(q, K) {
          for (var ye = 0, te = this.length; ye < te; ye++)
            q.call(K, this[ye], ye, this);
        }, H = function(q, K) {
          for (var ye in this)
            this.hasOwnProperty(ye) && q.call(K, this[ye], ye, this);
        }, X = Object.assign || function(q) {
          for (var K = 1, ye = arguments.length; K < ye; K++) {
            var te = arguments[K];
            for (var he in te)
              te.hasOwnProperty(he) && (q[he] = te[he]);
          }
          return q;
        }, ue = function(q, K, ye) {
          if (q) {
            var te = R(q, "length");
            (te && typeof te.value == "number" ? j : H).call(q, K, ye = ye || q);
          }
          return ye;
        };
        function pe(q, K, ye, te, he) {
          var D = {};
          function Se(O, ce) {
            ce = ce || (ce = R(K, O)) && (ce.get ? ce : ce.value), typeof ce == "string" && ce[0] === "#" && (ce = q[ce.substring(1)] || ce);
            var Oe = typeof ce == "function", Be = ce, je = he || Oe && !ce.base ? ce && ce.get ? O in q : q[O] : null, Fe;
            (!he || !je) && (Oe && je && (ce.base = je), Oe && te !== !1 && (Fe = O.match(/^([gs]et|is)(([A-Z])(.*))$/)) && (D[Fe[3].toLowerCase() + Fe[4]] = Fe[2]), (!Be || Oe || !Be.get || typeof Be.get != "function" || !P.isPlainObject(Be)) && (Be = { value: Be, writable: !0 }), (R(q, O) || { configurable: !0 }).configurable && (Be.configurable = !0, Be.enumerable = ye ?? !Fe), B(q, O, Be));
          }
          if (K) {
            for (var le in K)
              K.hasOwnProperty(le) && !e.test(le) && Se(le);
            for (var le in D) {
              var v = D[le], se = q["set" + v], me = q["get" + v] || se && q["is" + v];
              me && (te === !0 || me.length === 0) && Se(le, { get: me, set: se });
            }
          }
          return q;
        }
        function P() {
          for (var q = 0, K = arguments.length; q < K; q++) {
            var ye = arguments[q];
            ye && X(this, ye);
          }
          return this;
        }
        return pe(P, {
          inject: function(q) {
            if (q) {
              var K = q.statics === !0 ? q : q.statics, ye = q.beans, te = q.preserve;
              K !== q && pe(this.prototype, q, q.enumerable, ye, te), pe(this, K, null, ye, te);
            }
            for (var he = 1, D = arguments.length; he < D; he++)
              this.inject(arguments[he]);
            return this;
          },
          extend: function() {
            for (var q = this, K, ye, te = 0, he, D = arguments.length; te < D && !(K && ye); te++)
              he = arguments[te], K = K || he.initialize, ye = ye || he.prototype;
            return K = K || function() {
              q.apply(this, arguments);
            }, ye = K.prototype = ye || C(this.prototype), B(
              ye,
              "constructor",
              { value: K, writable: !0, configurable: !0 }
            ), pe(K, this), arguments.length && this.inject.apply(K, arguments), K.base = q, K;
          }
        }).inject({
          enumerable: !1,
          initialize: P,
          set: P,
          inject: function() {
            for (var q = 0, K = arguments.length; q < K; q++) {
              var ye = arguments[q];
              ye && pe(this, ye, ye.enumerable, ye.beans, ye.preserve);
            }
            return this;
          },
          extend: function() {
            var q = C(this);
            return q.inject.apply(q, arguments);
          },
          each: function(q, K) {
            return ue(this, q, K);
          },
          clone: function() {
            return new this.constructor(this);
          },
          statics: {
            set: X,
            each: ue,
            create: C,
            define: B,
            describe: R,
            clone: function(q) {
              return X(new q.constructor(), q);
            },
            isPlainObject: function(q) {
              var K = q != null && q.constructor;
              return K && (K === Object || K === P || K.name === "Object");
            },
            pick: function(q, K) {
              return q !== ae ? q : K;
            },
            slice: function(q, K, ye) {
              return f.call(q, K, ye);
            }
          }
        });
      }();
      Re.exports = _, _.inject({
        enumerable: !1,
        toString: function() {
          return this._id != null ? (this._class || "Object") + (this._name ? " '" + this._name + "'" : " @" + this._id) : "{ " + _.each(this, function(e, r) {
            if (!/^_/.test(r)) {
              var f = typeof e;
              this.push(r + ": " + (f === "number" ? c.instance.number(e) : f === "string" ? "'" + e + "'" : e));
            }
          }, []).join(", ") + " }";
        },
        getClassName: function() {
          return this._class || "";
        },
        importJSON: function(e) {
          return _.importJSON(e, this);
        },
        exportJSON: function(e) {
          return _.exportJSON(this, e);
        },
        toJSON: function() {
          return _.serialize(this);
        },
        set: function(e, r) {
          return e && _.filter(this, e, r, this._prioritize), this;
        }
      }, {
        beans: !1,
        statics: {
          exports: {},
          extend: function e() {
            var r = e.base.apply(this, arguments), f = r.prototype._class;
            return f && !_.exports[f] && (_.exports[f] = r), r;
          },
          equals: function(e, r) {
            if (e === r)
              return !0;
            if (e && e.equals)
              return e.equals(r);
            if (r && r.equals)
              return r.equals(e);
            if (e && r && typeof e == "object" && typeof r == "object") {
              if (Array.isArray(e) && Array.isArray(r)) {
                var f = e.length;
                if (f !== r.length)
                  return !1;
                for (; f--; )
                  if (!_.equals(e[f], r[f]))
                    return !1;
              } else {
                var C = Object.keys(e), f = C.length;
                if (f !== Object.keys(r).length)
                  return !1;
                for (; f--; ) {
                  var R = C[f];
                  if (!(r.hasOwnProperty(R) && _.equals(e[R], r[R])))
                    return !1;
                }
              }
              return !0;
            }
            return !1;
          },
          read: function(e, r, f, C) {
            if (this === _) {
              var R = this.peek(e, r);
              return e.__index++, R;
            }
            var B = this.prototype, j = B._readIndex, H = r || j && e.__index || 0, X = e.length, ue = e[H];
            if (C = C || X - H, ue instanceof this || f && f.readNull && ue == null && C <= 1)
              return j && (e.__index = H + 1), ue && f && f.clone ? ue.clone() : ue;
            if (ue = _.create(B), j && (ue.__read = !0), ue = ue.initialize.apply(ue, H > 0 || H + C < X ? _.slice(e, H, H + C) : e) || ue, j) {
              e.__index = H + ue.__read;
              var pe = ue.__filtered;
              pe && (e.__filtered = pe, ue.__filtered = ae), ue.__read = ae;
            }
            return ue;
          },
          peek: function(e, r) {
            return e[e.__index = r || e.__index || 0];
          },
          remain: function(e) {
            return e.length - (e.__index || 0);
          },
          readList: function(e, r, f, C) {
            for (var R = [], B, j = r || 0, H = C ? j + C : e.length, X = j; X < H; X++)
              R.push(Array.isArray(B = e[X]) ? this.read(B, 0, f) : this.read(e, X, f, 1));
            return R;
          },
          readNamed: function(e, r, f, C, R) {
            var B = this.getNamed(e, r), j = B !== ae;
            if (j) {
              var H = e.__filtered;
              if (!H) {
                var X = this.getSource(e);
                H = e.__filtered = _.create(X), H.__unfiltered = X;
              }
              H[r] = ae;
            }
            return this.read(j ? [B] : e, f, C, R);
          },
          readSupported: function(e, r) {
            var f = this.getSource(e), C = this, R = !1;
            return f && Object.keys(f).forEach(function(B) {
              if (B in r) {
                var j = C.readNamed(e, B);
                j !== ae && (r[B] = j), R = !0;
              }
            }), R;
          },
          getSource: function(e) {
            var r = e.__source;
            if (r === ae) {
              var f = e.length === 1 && e[0];
              r = e.__source = f && _.isPlainObject(f) ? f : null;
            }
            return r;
          },
          getNamed: function(e, r) {
            var f = this.getSource(e);
            if (f)
              return r ? f[r] : e.__filtered || f;
          },
          hasNamed: function(e, r) {
            return !!this.getNamed(e, r);
          },
          filter: function(e, r, f, C) {
            var R;
            function B(pe) {
              if (!(f && pe in f) && !(R && pe in R)) {
                var P = r[pe];
                P !== ae && (e[pe] = P);
              }
            }
            if (C) {
              for (var j = {}, H = 0, X, ue = C.length; H < ue; H++)
                (X = C[H]) in r && (B(X), j[X] = !0);
              R = j;
            }
            return Object.keys(r.__unfiltered || r).forEach(B), e;
          },
          isPlainValue: function(e, r) {
            return _.isPlainObject(e) || Array.isArray(e) || r && typeof e == "string";
          },
          serialize: function(e, r, f, C) {
            r = r || {};
            var R = !C, B;
            if (R && (r.formatter = new c(r.precision), C = {
              length: 0,
              definitions: {},
              references: {},
              add: function(P, q) {
                var K = "#" + P._id, ye = this.references[K];
                if (!ye) {
                  this.length++;
                  var te = q.call(P), he = P._class;
                  he && te[0] !== he && te.unshift(he), this.definitions[K] = te, ye = this.references[K] = [K];
                }
                return ye;
              }
            }), e && e._serialize) {
              B = e._serialize(r, C);
              var j = e._class;
              j && !e._compactSerialize && (R || !f) && B[0] !== j && B.unshift(j);
            } else if (Array.isArray(e)) {
              B = [];
              for (var H = 0, X = e.length; H < X; H++)
                B[H] = _.serialize(e[H], r, f, C);
            } else if (_.isPlainObject(e)) {
              B = {};
              for (var ue = Object.keys(e), H = 0, X = ue.length; H < X; H++) {
                var pe = ue[H];
                B[pe] = _.serialize(
                  e[pe],
                  r,
                  f,
                  C
                );
              }
            } else typeof e == "number" ? B = r.formatter.number(e, r.precision) : B = e;
            return R && C.length > 0 ? [["dictionary", C.definitions], B] : B;
          },
          deserialize: function(e, r, f, C, R) {
            var B = e, j = !f, H = j && e && e.length && e[0][0] === "dictionary";
            if (f = f || {}, Array.isArray(e)) {
              var X = e[0], ue = X === "dictionary";
              if (e.length == 1 && /^#/.test(X))
                return f.dictionary[X];
              X = _.exports[X], B = [];
              for (var pe = X ? 1 : 0, P = e.length; pe < P; pe++)
                B.push(_.deserialize(
                  e[pe],
                  r,
                  f,
                  ue,
                  H
                ));
              if (X) {
                var q = B;
                r ? B = r(X, q, j || R) : B = new X(q);
              }
            } else if (_.isPlainObject(e)) {
              B = {}, C && (f.dictionary = B);
              for (var K in e)
                B[K] = _.deserialize(e[K], r, f);
            }
            return H ? B[1] : B;
          },
          exportJSON: function(e, r) {
            var f = _.serialize(e, r);
            return r && r.asString == !1 ? f : JSON.stringify(f);
          },
          importJSON: function(e, r) {
            return _.deserialize(
              typeof e == "string" ? JSON.parse(e) : e,
              function(f, C, R) {
                var B = R && r && r.constructor === f, j = B ? r : _.create(f.prototype);
                if (C.length === 1 && j instanceof o && (B || !(j instanceof T))) {
                  var H = C[0];
                  _.isPlainObject(H) && (H.insert = !1, B && (C = C.concat([o.INSERT])));
                }
                return (B ? j.set : f).apply(j, C), B && (r = null), j;
              }
            );
          },
          push: function(e, r) {
            var f = r.length;
            if (f < 4096)
              e.push.apply(e, r);
            else {
              var C = e.length;
              e.length += f;
              for (var R = 0; R < f; R++)
                e[C + R] = r[R];
            }
            return e;
          },
          splice: function(e, r, f, C) {
            var R = r && r.length, B = f === ae;
            f = B ? e.length : f, f > e.length && (f = e.length);
            for (var j = 0; j < R; j++)
              r[j]._index = f + j;
            if (B)
              return _.push(e, r), [];
            var H = [f, C];
            r && _.push(H, r);
            for (var X = e.splice.apply(e, H), j = 0, ue = X.length; j < ue; j++)
              X[j]._index = ae;
            for (var j = f + R, ue = e.length; j < ue; j++)
              e[j]._index = j;
            return X;
          },
          capitalize: function(e) {
            return e.replace(/\b[a-z]/g, function(r) {
              return r.toUpperCase();
            });
          },
          camelize: function(e) {
            return e.replace(/-(.)/g, function(r, f) {
              return f.toUpperCase();
            });
          },
          hyphenate: function(e) {
            return e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
          }
        }
      });
      var M = {
        on: function(e, r) {
          if (typeof e != "string")
            _.each(e, function(B, j) {
              this.on(j, B);
            }, this);
          else {
            var f = this._eventTypes, C = f && f[e], R = this._callbacks = this._callbacks || {};
            R = R[e] = R[e] || [], R.indexOf(r) === -1 && (R.push(r), C && C.install && R.length === 1 && C.install.call(this, e));
          }
          return this;
        },
        off: function(e, r) {
          if (typeof e != "string") {
            _.each(e, function(j, H) {
              this.off(H, j);
            }, this);
            return;
          }
          var f = this._eventTypes, C = f && f[e], R = this._callbacks && this._callbacks[e], B;
          return R && (!r || (B = R.indexOf(r)) !== -1 && R.length === 1 ? (C && C.uninstall && C.uninstall.call(this, e), delete this._callbacks[e]) : B !== -1 && R.splice(B, 1)), this;
        },
        once: function(e, r) {
          return this.on(e, function f() {
            r.apply(this, arguments), this.off(e, f);
          });
        },
        emit: function(e, r) {
          var f = this._callbacks && this._callbacks[e];
          if (!f)
            return !1;
          var C = _.slice(arguments, 1), R = r && r.target && !r.currentTarget;
          f = f.slice(), R && (r.currentTarget = this);
          for (var B = 0, j = f.length; B < j; B++)
            if (f[B].apply(this, C) == !1) {
              r && r.stop && r.stop();
              break;
            }
          return R && delete r.currentTarget, !0;
        },
        responds: function(e) {
          return !!(this._callbacks && this._callbacks[e]);
        },
        attach: "#on",
        detach: "#off",
        fire: "#emit",
        _installEvents: function(e) {
          var r = this._eventTypes, f = this._callbacks, C = e ? "install" : "uninstall";
          if (r) {
            for (var R in f)
              if (f[R].length > 0) {
                var B = r[R], j = B && B[C];
                j && j.call(this, R);
              }
          }
        },
        statics: {
          inject: function e(r) {
            var f = r._events;
            if (f) {
              var C = {};
              _.each(f, function(R, B) {
                var j = typeof R == "string", H = j ? R : B, X = _.capitalize(H), ue = H.substring(2).toLowerCase();
                C[ue] = j ? {} : R, H = "_" + H, r["get" + X] = function() {
                  return this[H];
                }, r["set" + X] = function(pe) {
                  var P = this[H];
                  P && this.off(ue, P), pe && this.on(ue, pe), this[H] = pe;
                };
              }), r._eventTypes = C;
            }
            return e.base.apply(this, arguments);
          }
        }
      }, x = _.extend({
        _class: "PaperScope",
        initialize: function e() {
          Ae = this, this.settings = new _({
            applyMatrix: !0,
            insertItems: !0,
            handleSize: 4,
            hitTolerance: 0
          }), this.project = null, this.projects = [], this.tools = [], this._id = e._id++, e._scopes[this._id] = this;
          var r = e.prototype;
          if (!this.support) {
            var f = Ce.getContext(1, 1) || {};
            r.support = {
              nativeDash: "setLineDash" in f || "mozDash" in f,
              nativeBlendModes: ve.nativeModes
            }, Ce.release(f);
          }
          if (!this.agent) {
            var C = be.navigator.userAgent.toLowerCase(), R = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(C) || [])[0], B = R === "darwin" ? "mac" : R, j = r.agent = r.browser = { platform: B };
            B && (j[B] = !0), C.replace(
              /(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g,
              function(H, X, ue, pe, P) {
                if (!j.chrome) {
                  var q = X === "opera" ? pe : /^(node|trident)$/.test(X) ? P : ue;
                  j.version = q, j.versionNumber = parseFloat(q), X = { trident: "msie", jsdom: "node" }[X] || X, j.name = X, j[X] = !0;
                }
              }
            ), j.chrome && delete j.webkit, j.atom && delete j.chrome;
          }
        },
        version: "0.12.18",
        getView: function() {
          var e = this.project;
          return e && e._view;
        },
        getPaper: function() {
          return this;
        },
        execute: function(e, r) {
          var f = Ae.PaperScript.execute(e, this, r);
          return Ze.updateFocus(), f;
        },
        install: function(e) {
          var r = this;
          _.each(["project", "view", "tool"], function(C) {
            _.define(e, C, {
              configurable: !0,
              get: function() {
                return r[C];
              }
            });
          });
          for (var f in this)
            !/^_/.test(f) && this[f] && (e[f] = this[f]);
        },
        setup: function(e) {
          return Ae = this, this.project = new S(e), this;
        },
        createCanvas: function(e, r) {
          return Ce.getCanvas(e, r);
        },
        activate: function() {
          Ae = this;
        },
        clear: function() {
          for (var e = this.projects, r = this.tools, f = e.length - 1; f >= 0; f--)
            e[f].remove();
          for (var f = r.length - 1; f >= 0; f--)
            r[f].remove();
        },
        remove: function() {
          this.clear(), delete x._scopes[this._id];
        },
        statics: new function() {
          function e(r) {
            return r += "Attribute", function(f, C) {
              return f[r](C) || f[r]("data-paper-" + C);
            };
          }
          return {
            _scopes: {},
            _id: 0,
            get: function(r) {
              return this._scopes[r] || null;
            },
            getAttribute: e("get"),
            hasAttribute: e("has")
          };
        }()
      }), y = _.extend(M, {
        initialize: function(e) {
          this._scope = Ae, this._index = this._scope[this._list].push(this) - 1, (e || !this._scope[this._reference]) && this.activate();
        },
        activate: function() {
          if (!this._scope)
            return !1;
          var e = this._scope[this._reference];
          return e && e !== this && e.emit("deactivate"), this._scope[this._reference] = this, this.emit("activate", e), !0;
        },
        isActive: function() {
          return this._scope[this._reference] === this;
        },
        remove: function() {
          return this._index == null ? !1 : (_.splice(this._scope[this._list], null, this._index, 1), this._scope[this._reference] == this && (this._scope[this._reference] = null), this._scope = null, !0);
        },
        getView: function() {
          return this._scope.getView();
        }
      }), E = {
        findItemBoundsCollisions: function(e, r, f) {
          function C(j) {
            for (var H = new Array(j.length), X = 0; X < j.length; X++) {
              var ue = j[X].getBounds();
              H[X] = [ue.left, ue.top, ue.right, ue.bottom];
            }
            return H;
          }
          var R = C(e), B = !r || r === e ? R : C(r);
          return this.findBoundsCollisions(R, B, f || 0);
        },
        findCurveBoundsCollisions: function(e, r, f, C) {
          function R(q) {
            for (var K = Math.min, ye = Math.max, te = new Array(q.length), he = 0; he < q.length; he++) {
              var D = q[he];
              te[he] = [
                K(D[0], D[2], D[4], D[6]),
                K(D[1], D[3], D[5], D[7]),
                ye(D[0], D[2], D[4], D[6]),
                ye(D[1], D[3], D[5], D[7])
              ];
            }
            return te;
          }
          var B = R(e), j = !r || r === e ? B : R(r);
          if (C) {
            for (var H = this.findBoundsCollisions(
              B,
              j,
              f || 0,
              !1,
              !0
            ), X = this.findBoundsCollisions(
              B,
              j,
              f || 0,
              !0,
              !0
            ), ue = [], pe = 0, P = H.length; pe < P; pe++)
              ue[pe] = { hor: H[pe], ver: X[pe] };
            return ue;
          }
          return this.findBoundsCollisions(B, j, f || 0);
        },
        findBoundsCollisions: function(e, r, f, C, R) {
          var B = !r || e === r, j = B ? e : e.concat(r), H = e.length, X = j.length;
          function ue(vt, bt, At) {
            for (var ot = 0, ht = vt.length; ot < ht; ) {
              var gt = ht + ot >>> 1;
              j[vt[gt]][bt] < At ? ot = gt + 1 : ht = gt;
            }
            return ot - 1;
          }
          for (var pe = C ? 1 : 0, P = pe + 2, q = C ? 0 : 1, K = q + 2, ye = new Array(X), te = 0; te < X; te++)
            ye[te] = te;
          ye.sort(function(vt, bt) {
            return j[vt][pe] - j[bt][pe];
          });
          for (var he = [], D = new Array(H), te = 0; te < X; te++) {
            var Se = ye[te], le = j[Se], v = B ? Se : Se - H, se = Se < H, me = B || !se, O = se ? [] : null;
            if (he.length) {
              var ce = ue(
                he,
                P,
                le[pe] - f
              ) + 1;
              if (he.splice(0, ce), B && R) {
                O = O.concat(he);
                for (var Oe = 0; Oe < he.length; Oe++) {
                  var Be = he[Oe];
                  D[Be].push(v);
                }
              } else
                for (var je = le[K], Fe = le[q], Oe = 0; Oe < he.length; Oe++) {
                  var Be = he[Oe], Ye = j[Be], Ke = Be < H, et = B || Be >= H;
                  (R || (se && et || me && Ke) && je >= Ye[q] - f && Fe <= Ye[K] + f) && (se && et && O.push(
                    B ? Be : Be - H
                  ), me && Ke && D[Be].push(v));
                }
            }
            if (se && (e === r && O.push(Se), D[Se] = O), he.length) {
              var Je = le[P], nt = ue(he, P, Je);
              he.splice(nt + 1, 0, Se);
            } else
              he.push(Se);
          }
          for (var te = 0; te < D.length; te++) {
            var dt = D[te];
            dt && dt.sort(function(bt, At) {
              return bt - At;
            });
          }
          return D;
        }
      }, c = _.extend({
        initialize: function(e) {
          this.precision = _.pick(e, 5), this.multiplier = Math.pow(10, this.precision);
        },
        number: function(e) {
          return this.precision < 16 ? Math.round(e * this.multiplier) / this.multiplier : e;
        },
        pair: function(e, r, f) {
          return this.number(e) + (f || ",") + this.number(r);
        },
        point: function(e, r) {
          return this.number(e.x) + (r || ",") + this.number(e.y);
        },
        size: function(e, r) {
          return this.number(e.width) + (r || ",") + this.number(e.height);
        },
        rectangle: function(e, r) {
          return this.point(e, r) + (r || ",") + this.size(e, r);
        }
      });
      c.instance = new c();
      var u = new function() {
        var e = [
          [0.5773502691896257],
          [0, 0.7745966692414834],
          [0.33998104358485626, 0.8611363115940526],
          [0, 0.5384693101056831, 0.906179845938664],
          [0.2386191860831969, 0.6612093864662645, 0.932469514203152],
          [0, 0.4058451513773972, 0.7415311855993945, 0.9491079123427585],
          [0.1834346424956498, 0.525532409916329, 0.7966664774136267, 0.9602898564975363],
          [0, 0.3242534234038089, 0.6133714327005904, 0.8360311073266358, 0.9681602395076261],
          [0.14887433898163122, 0.4333953941292472, 0.6794095682990244, 0.8650633666889845, 0.9739065285171717],
          [0, 0.26954315595234496, 0.5190961292068118, 0.7301520055740494, 0.8870625997680953, 0.978228658146057],
          [0.1252334085114689, 0.3678314989981802, 0.5873179542866175, 0.7699026741943047, 0.9041172563704749, 0.9815606342467192],
          [0, 0.2304583159551348, 0.44849275103644687, 0.6423493394403402, 0.8015780907333099, 0.9175983992229779, 0.9841830547185881],
          [0.10805494870734367, 0.31911236892788974, 0.5152486363581541, 0.6872929048116855, 0.827201315069765, 0.9284348836635735, 0.9862838086968123],
          [0, 0.20119409399743451, 0.3941513470775634, 0.5709721726085388, 0.7244177313601701, 0.8482065834104272, 0.937273392400706, 0.9879925180204854],
          [0.09501250983763744, 0.2816035507792589, 0.45801677765722737, 0.6178762444026438, 0.755404408355003, 0.8656312023878318, 0.9445750230732326, 0.9894009349916499]
        ], r = [
          [1],
          [0.8888888888888888, 0.5555555555555556],
          [0.6521451548625461, 0.34785484513745385],
          [0.5688888888888889, 0.47862867049936647, 0.23692688505618908],
          [0.46791393457269104, 0.3607615730481386, 0.17132449237917036],
          [0.4179591836734694, 0.3818300505051189, 0.27970539148927664, 0.1294849661688697],
          [0.362683783378362, 0.31370664587788727, 0.22238103445337448, 0.10122853629037626],
          [0.3302393550012598, 0.31234707704000286, 0.26061069640293544, 0.1806481606948574, 0.08127438836157441],
          [0.29552422471475287, 0.26926671930999635, 0.21908636251598204, 0.1494513491505806, 0.06667134430868814],
          [0.2729250867779006, 0.26280454451024665, 0.23319376459199048, 0.18629021092773426, 0.1255803694649046, 0.05566856711617366],
          [0.24914704581340277, 0.2334925365383548, 0.20316742672306592, 0.16007832854334622, 0.10693932599531843, 0.04717533638651183],
          [0.2325515532308739, 0.22628318026289723, 0.2078160475368885, 0.17814598076194574, 0.13887351021978725, 0.09212149983772845, 0.04048400476531588],
          [0.2152638534631578, 0.2051984637212956, 0.18553839747793782, 0.15720316715819355, 0.12151857068790319, 0.08015808715976021, 0.03511946033175186],
          [0.2025782419255613, 0.19843148532711158, 0.1861610000155622, 0.16626920581699392, 0.13957067792615432, 0.10715922046717194, 0.07036604748810812, 0.03075324199611727],
          [0.1894506104550685, 0.18260341504492358, 0.16915651939500254, 0.14959598881657674, 0.12462897125553388, 0.09515851168249279, 0.062253523938647894, 0.027152459411754096]
        ], f = Math.abs, C = Math.sqrt, R = Math.pow, B = Math.log2 || function(P) {
          return Math.log(P) * Math.LOG2E;
        }, j = 1e-12, H = 112e-18;
        function X(P, q, K) {
          return P < q ? q : P > K ? K : P;
        }
        function ue(P, q, K) {
          function ye(ce) {
            var Oe = ce * 134217729, Be = ce - Oe, je = Be + Oe, Fe = ce - je;
            return [je, Fe];
          }
          var te = q * q - P * K, he = q * q + P * K;
          if (f(te) * 3 < he) {
            var D = ye(P), Se = ye(q), le = ye(K), v = q * q, se = Se[0] * Se[0] - v + 2 * Se[0] * Se[1] + Se[1] * Se[1], me = P * K, O = D[0] * le[0] - me + D[0] * le[1] + D[1] * le[0] + D[1] * le[1];
            te = v - me + (se - O);
          }
          return te;
        }
        function pe() {
          var P = Math.max.apply(Math, arguments);
          return P && (P < 1e-8 || P > 1e8) ? R(2, -Math.round(B(P))) : 0;
        }
        return {
          EPSILON: j,
          MACHINE_EPSILON: H,
          CURVETIME_EPSILON: 1e-8,
          GEOMETRIC_EPSILON: 1e-7,
          TRIGONOMETRIC_EPSILON: 1e-8,
          ANGULAR_EPSILON: 1e-5,
          KAPPA: 4 * (C(2) - 1) / 3,
          isZero: function(P) {
            return P >= -1e-12 && P <= j;
          },
          isMachineZero: function(P) {
            return P >= -112e-18 && P <= H;
          },
          clamp: X,
          integrate: function(P, q, K, ye) {
            for (var te = e[ye - 2], he = r[ye - 2], D = (K - q) * 0.5, Se = D + q, le = 0, v = ye + 1 >> 1, se = ye & 1 ? he[le++] * P(Se) : 0; le < v; ) {
              var me = D * te[le];
              se += he[le++] * (P(Se + me) + P(Se - me));
            }
            return D * se;
          },
          findRoot: function(P, q, K, ye, te, he, D) {
            for (var Se = 0; Se < he; Se++) {
              var le = P(K), v = le / q(K), se = K - v;
              if (f(v) < D) {
                K = se;
                break;
              }
              le > 0 ? (te = K, K = se <= ye ? (ye + te) * 0.5 : se) : (ye = K, K = se >= te ? (ye + te) * 0.5 : se);
            }
            return X(K, ye, te);
          },
          solveQuadratic: function(P, q, K, ye, te, he) {
            var D, Se = 1 / 0;
            if (f(P) < j) {
              if (f(q) < j)
                return f(K) < j ? -1 : 0;
              D = -K / q;
            } else {
              q *= -0.5;
              var le = ue(P, q, K);
              if (le && f(le) < H) {
                var v = pe(f(P), f(q), f(K));
                v && (P *= v, q *= v, K *= v, le = ue(P, q, K));
              }
              if (le >= -112e-18) {
                var se = le < 0 ? 0 : C(le), me = q + (q < 0 ? -se : se);
                me === 0 ? (D = K / P, Se = -D) : (D = me / P, Se = K / me);
              }
            }
            var O = 0, ce = te == null, Oe = te - j, Be = he + j;
            return isFinite(D) && (ce || D > Oe && D < Be) && (ye[O++] = ce ? D : X(D, te, he)), Se !== D && isFinite(Se) && (ce || Se > Oe && Se < Be) && (ye[O++] = ce ? Se : X(Se, te, he)), O;
          },
          solveCubic: function(P, q, K, ye, te, he, D) {
            var Se = pe(f(P), f(q), f(K), f(ye)), le, v, se, me, O;
            Se && (P *= Se, q *= Se, K *= Se, ye *= Se);
            function ce(nt) {
              le = nt;
              var dt = P * le;
              v = dt + q, se = v * le + K, me = (dt + v) * le + se, O = se * le + ye;
            }
            if (f(P) < j)
              P = q, v = K, se = ye, le = 1 / 0;
            else if (f(ye) < j)
              v = q, se = K, le = 0;
            else {
              ce(-(q / P) / 3);
              var Oe = O / P, Be = R(f(Oe), 1 / 3), je = Oe < 0 ? -1 : 1, Fe = -me / P, Ye = Fe > 0 ? 1.324717957244746 * Math.max(Be, C(Fe)) : Be, Ke = le - je * Ye;
              if (Ke !== le) {
                do
                  ce(Ke), Ke = me === 0 ? le : le - O / me / (1 + H);
                while (je * Ke > je * le);
                f(P) * le * le > f(ye / le) && (se = -ye / le, v = (se - K) / le);
              }
            }
            var et = u.solveQuadratic(P, v, se, te, he, D), Je = he == null;
            return isFinite(le) && (et === 0 || et > 0 && le !== te[0] && le !== te[1]) && (Je || le > he - j && le < D + j) && (te[et++] = Je ? le : X(le, he, D)), et;
          }
        };
      }(), l = {
        _id: 1,
        _pools: {},
        get: function(e) {
          if (e) {
            var r = this._pools[e];
            return r || (r = this._pools[e] = { _id: 1 }), r._id++;
          } else
            return this._id++;
        }
      }, a = _.extend({
        _class: "Point",
        _readIndex: !0,
        initialize: function(r, f) {
          var C = typeof r, R = this.__read, B = 0;
          if (C === "number") {
            var j = typeof f == "number";
            this._set(r, j ? f : r), R && (B = j ? 2 : 1);
          } else if (C === "undefined" || r === null)
            this._set(0, 0), R && (B = r === null ? 1 : 0);
          else {
            var H = C === "string" ? r.split(/[\s,]+/) || [] : r;
            B = 1, Array.isArray(H) ? this._set(+H[0], +(H.length > 1 ? H[1] : H[0])) : "x" in H ? this._set(H.x || 0, H.y || 0) : "width" in H ? this._set(H.width || 0, H.height || 0) : "angle" in H ? (this._set(H.length || 0, 0), this.setAngle(H.angle || 0)) : (this._set(0, 0), B = 0);
          }
          return R && (this.__read = B), this;
        },
        set: "#initialize",
        _set: function(e, r) {
          return this.x = e, this.y = r, this;
        },
        equals: function(e) {
          return this === e || e && (this.x === e.x && this.y === e.y || Array.isArray(e) && this.x === e[0] && this.y === e[1]) || !1;
        },
        clone: function() {
          return new a(this.x, this.y);
        },
        toString: function() {
          var e = c.instance;
          return "{ x: " + e.number(this.x) + ", y: " + e.number(this.y) + " }";
        },
        _serialize: function(e) {
          var r = e.formatter;
          return [r.number(this.x), r.number(this.y)];
        },
        getLength: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        setLength: function(e) {
          if (this.isZero()) {
            var r = this._angle || 0;
            this._set(
              Math.cos(r) * e,
              Math.sin(r) * e
            );
          } else {
            var f = e / this.getLength();
            u.isZero(f) && this.getAngle(), this._set(
              this.x * f,
              this.y * f
            );
          }
        },
        getAngle: function() {
          return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
        },
        setAngle: function(e) {
          this.setAngleInRadians.call(this, e * Math.PI / 180);
        },
        getAngleInDegrees: "#getAngle",
        setAngleInDegrees: "#setAngle",
        getAngleInRadians: function() {
          if (arguments.length) {
            var e = a.read(arguments), r = this.getLength() * e.getLength();
            if (u.isZero(r))
              return NaN;
            var f = this.dot(e) / r;
            return Math.acos(f < -1 ? -1 : f > 1 ? 1 : f);
          } else
            return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);
        },
        setAngleInRadians: function(e) {
          if (this._angle = e, !this.isZero()) {
            var r = this.getLength();
            this._set(
              Math.cos(e) * r,
              Math.sin(e) * r
            );
          }
        },
        getQuadrant: function() {
          return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
        }
      }, {
        beans: !1,
        getDirectedAngle: function() {
          var e = a.read(arguments);
          return Math.atan2(this.cross(e), this.dot(e)) * 180 / Math.PI;
        },
        getDistance: function() {
          var e = arguments, r = a.read(e), f = r.x - this.x, C = r.y - this.y, R = f * f + C * C, B = _.read(e);
          return B ? R : Math.sqrt(R);
        },
        normalize: function(e) {
          e === ae && (e = 1);
          var r = this.getLength(), f = r !== 0 ? e / r : 0, C = new a(this.x * f, this.y * f);
          return f >= 0 && (C._angle = this._angle), C;
        },
        rotate: function(e, r) {
          if (e === 0)
            return this.clone();
          e = e * Math.PI / 180;
          var f = r ? this.subtract(r) : this, C = Math.sin(e), R = Math.cos(e);
          return f = new a(
            f.x * R - f.y * C,
            f.x * C + f.y * R
          ), r ? f.add(r) : f;
        },
        transform: function(e) {
          return e ? e._transformPoint(this) : this;
        },
        add: function() {
          var e = a.read(arguments);
          return new a(this.x + e.x, this.y + e.y);
        },
        subtract: function() {
          var e = a.read(arguments);
          return new a(this.x - e.x, this.y - e.y);
        },
        multiply: function() {
          var e = a.read(arguments);
          return new a(this.x * e.x, this.y * e.y);
        },
        divide: function() {
          var e = a.read(arguments);
          return new a(this.x / e.x, this.y / e.y);
        },
        modulo: function() {
          var e = a.read(arguments);
          return new a(this.x % e.x, this.y % e.y);
        },
        negate: function() {
          return new a(-this.x, -this.y);
        },
        isInside: function() {
          return h.read(arguments).contains(this);
        },
        isClose: function() {
          var e = arguments, r = a.read(e), f = _.read(e);
          return this.getDistance(r) <= f;
        },
        isCollinear: function() {
          var e = a.read(arguments);
          return a.isCollinear(this.x, this.y, e.x, e.y);
        },
        isColinear: "#isCollinear",
        isOrthogonal: function() {
          var e = a.read(arguments);
          return a.isOrthogonal(this.x, this.y, e.x, e.y);
        },
        isZero: function() {
          var e = u.isZero;
          return e(this.x) && e(this.y);
        },
        isNaN: function() {
          return isNaN(this.x) || isNaN(this.y);
        },
        isInQuadrant: function(e) {
          return this.x * (e > 1 && e < 4 ? -1 : 1) >= 0 && this.y * (e > 2 ? -1 : 1) >= 0;
        },
        dot: function() {
          var e = a.read(arguments);
          return this.x * e.x + this.y * e.y;
        },
        cross: function() {
          var e = a.read(arguments);
          return this.x * e.y - this.y * e.x;
        },
        project: function() {
          var e = a.read(arguments), r = e.isZero() ? 0 : this.dot(e) / e.dot(e);
          return new a(
            e.x * r,
            e.y * r
          );
        },
        statics: {
          min: function() {
            var e = arguments, r = a.read(e), f = a.read(e);
            return new a(
              Math.min(r.x, f.x),
              Math.min(r.y, f.y)
            );
          },
          max: function() {
            var e = arguments, r = a.read(e), f = a.read(e);
            return new a(
              Math.max(r.x, f.x),
              Math.max(r.y, f.y)
            );
          },
          random: function() {
            return new a(Math.random(), Math.random());
          },
          isCollinear: function(e, r, f, C) {
            return Math.abs(e * C - r * f) <= Math.sqrt((e * e + r * r) * (f * f + C * C)) * 1e-8;
          },
          isOrthogonal: function(e, r, f, C) {
            return Math.abs(e * f + r * C) <= Math.sqrt((e * e + r * r) * (f * f + C * C)) * 1e-8;
          }
        }
      }, _.each(["round", "ceil", "floor", "abs"], function(e) {
        var r = Math[e];
        this[e] = function() {
          return new a(r(this.x), r(this.y));
        };
      }, {})), n = a.extend({
        initialize: function(r, f, C, R) {
          this._x = r, this._y = f, this._owner = C, this._setter = R;
        },
        _set: function(e, r, f) {
          return this._x = e, this._y = r, f || this._owner[this._setter](this), this;
        },
        getX: function() {
          return this._x;
        },
        setX: function(e) {
          this._x = e, this._owner[this._setter](this);
        },
        getY: function() {
          return this._y;
        },
        setY: function(e) {
          this._y = e, this._owner[this._setter](this);
        },
        isSelected: function() {
          return !!(this._owner._selection & this._getSelection());
        },
        setSelected: function(e) {
          this._owner._changeSelection(this._getSelection(), e);
        },
        _getSelection: function() {
          return this._setter === "setPosition" ? 4 : 0;
        }
      }), d = _.extend({
        _class: "Size",
        _readIndex: !0,
        initialize: function(r, f) {
          var C = typeof r, R = this.__read, B = 0;
          if (C === "number") {
            var j = typeof f == "number";
            this._set(r, j ? f : r), R && (B = j ? 2 : 1);
          } else if (C === "undefined" || r === null)
            this._set(0, 0), R && (B = r === null ? 1 : 0);
          else {
            var H = C === "string" ? r.split(/[\s,]+/) || [] : r;
            B = 1, Array.isArray(H) ? this._set(+H[0], +(H.length > 1 ? H[1] : H[0])) : "width" in H ? this._set(H.width || 0, H.height || 0) : "x" in H ? this._set(H.x || 0, H.y || 0) : (this._set(0, 0), B = 0);
          }
          return R && (this.__read = B), this;
        },
        set: "#initialize",
        _set: function(e, r) {
          return this.width = e, this.height = r, this;
        },
        equals: function(e) {
          return e === this || e && (this.width === e.width && this.height === e.height || Array.isArray(e) && this.width === e[0] && this.height === e[1]) || !1;
        },
        clone: function() {
          return new d(this.width, this.height);
        },
        toString: function() {
          var e = c.instance;
          return "{ width: " + e.number(this.width) + ", height: " + e.number(this.height) + " }";
        },
        _serialize: function(e) {
          var r = e.formatter;
          return [
            r.number(this.width),
            r.number(this.height)
          ];
        },
        add: function() {
          var e = d.read(arguments);
          return new d(this.width + e.width, this.height + e.height);
        },
        subtract: function() {
          var e = d.read(arguments);
          return new d(this.width - e.width, this.height - e.height);
        },
        multiply: function() {
          var e = d.read(arguments);
          return new d(this.width * e.width, this.height * e.height);
        },
        divide: function() {
          var e = d.read(arguments);
          return new d(this.width / e.width, this.height / e.height);
        },
        modulo: function() {
          var e = d.read(arguments);
          return new d(this.width % e.width, this.height % e.height);
        },
        negate: function() {
          return new d(-this.width, -this.height);
        },
        isZero: function() {
          var e = u.isZero;
          return e(this.width) && e(this.height);
        },
        isNaN: function() {
          return isNaN(this.width) || isNaN(this.height);
        },
        statics: {
          min: function(e, r) {
            return new d(
              Math.min(e.width, r.width),
              Math.min(e.height, r.height)
            );
          },
          max: function(e, r) {
            return new d(
              Math.max(e.width, r.width),
              Math.max(e.height, r.height)
            );
          },
          random: function() {
            return new d(Math.random(), Math.random());
          }
        }
      }, _.each(["round", "ceil", "floor", "abs"], function(e) {
        var r = Math[e];
        this[e] = function() {
          return new d(r(this.width), r(this.height));
        };
      }, {})), g = d.extend({
        initialize: function(r, f, C, R) {
          this._width = r, this._height = f, this._owner = C, this._setter = R;
        },
        _set: function(e, r, f) {
          return this._width = e, this._height = r, f || this._owner[this._setter](this), this;
        },
        getWidth: function() {
          return this._width;
        },
        setWidth: function(e) {
          this._width = e, this._owner[this._setter](this);
        },
        getHeight: function() {
          return this._height;
        },
        setHeight: function(e) {
          this._height = e, this._owner[this._setter](this);
        }
      }), h = _.extend({
        _class: "Rectangle",
        _readIndex: !0,
        beans: !0,
        initialize: function(r, f, C, R) {
          var B = arguments, j = typeof r, H;
          if (j === "number" ? (this._set(r, f, C, R), H = 4) : j === "undefined" || r === null ? (this._set(0, 0, 0, 0), H = r === null ? 1 : 0) : B.length === 1 && (Array.isArray(r) ? (this._set.apply(this, r), H = 1) : r.x !== ae || r.width !== ae ? (this._set(
            r.x || 0,
            r.y || 0,
            r.width || 0,
            r.height || 0
          ), H = 1) : r.from === ae && r.to === ae && (this._set(0, 0, 0, 0), _.readSupported(B, this) && (H = 1))), H === ae) {
            var X = a.readNamed(B, "from"), ue = _.peek(B), pe = X.x, P = X.y, q, K;
            if (ue && ue.x !== ae || _.hasNamed(B, "to")) {
              var ye = a.readNamed(B, "to");
              q = ye.x - pe, K = ye.y - P, q < 0 && (pe = ye.x, q = -q), K < 0 && (P = ye.y, K = -K);
            } else {
              var te = d.read(B);
              q = te.width, K = te.height;
            }
            this._set(pe, P, q, K), H = B.__index;
          }
          var he = B.__filtered;
          return he && (this.__filtered = he), this.__read && (this.__read = H), this;
        },
        set: "#initialize",
        _set: function(e, r, f, C) {
          return this.x = e, this.y = r, this.width = f, this.height = C, this;
        },
        clone: function() {
          return new h(this.x, this.y, this.width, this.height);
        },
        equals: function(e) {
          var r = _.isPlainValue(e) ? h.read(arguments) : e;
          return r === this || r && this.x === r.x && this.y === r.y && this.width === r.width && this.height === r.height || !1;
        },
        toString: function() {
          var e = c.instance;
          return "{ x: " + e.number(this.x) + ", y: " + e.number(this.y) + ", width: " + e.number(this.width) + ", height: " + e.number(this.height) + " }";
        },
        _serialize: function(e) {
          var r = e.formatter;
          return [
            r.number(this.x),
            r.number(this.y),
            r.number(this.width),
            r.number(this.height)
          ];
        },
        getPoint: function(e) {
          var r = e ? a : n;
          return new r(this.x, this.y, this, "setPoint");
        },
        setPoint: function() {
          var e = a.read(arguments);
          this.x = e.x, this.y = e.y;
        },
        getSize: function(e) {
          var r = e ? d : g;
          return new r(this.width, this.height, this, "setSize");
        },
        _fw: 1,
        _fh: 1,
        setSize: function() {
          var e = d.read(arguments), r = this._sx, f = this._sy, C = e.width, R = e.height;
          r && (this.x += (this.width - C) * r), f && (this.y += (this.height - R) * f), this.width = C, this.height = R, this._fw = this._fh = 1;
        },
        getLeft: function() {
          return this.x;
        },
        setLeft: function(e) {
          if (!this._fw) {
            var r = e - this.x;
            this.width -= this._sx === 0.5 ? r * 2 : r;
          }
          this.x = e, this._sx = this._fw = 0;
        },
        getTop: function() {
          return this.y;
        },
        setTop: function(e) {
          if (!this._fh) {
            var r = e - this.y;
            this.height -= this._sy === 0.5 ? r * 2 : r;
          }
          this.y = e, this._sy = this._fh = 0;
        },
        getRight: function() {
          return this.x + this.width;
        },
        setRight: function(e) {
          if (!this._fw) {
            var r = e - this.x;
            this.width = this._sx === 0.5 ? r * 2 : r;
          }
          this.x = e - this.width, this._sx = 1, this._fw = 0;
        },
        getBottom: function() {
          return this.y + this.height;
        },
        setBottom: function(e) {
          if (!this._fh) {
            var r = e - this.y;
            this.height = this._sy === 0.5 ? r * 2 : r;
          }
          this.y = e - this.height, this._sy = 1, this._fh = 0;
        },
        getCenterX: function() {
          return this.x + this.width / 2;
        },
        setCenterX: function(e) {
          this._fw || this._sx === 0.5 ? this.x = e - this.width / 2 : (this._sx && (this.x += (e - this.x) * 2 * this._sx), this.width = (e - this.x) * 2), this._sx = 0.5, this._fw = 0;
        },
        getCenterY: function() {
          return this.y + this.height / 2;
        },
        setCenterY: function(e) {
          this._fh || this._sy === 0.5 ? this.y = e - this.height / 2 : (this._sy && (this.y += (e - this.y) * 2 * this._sy), this.height = (e - this.y) * 2), this._sy = 0.5, this._fh = 0;
        },
        getCenter: function(e) {
          var r = e ? a : n;
          return new r(this.getCenterX(), this.getCenterY(), this, "setCenter");
        },
        setCenter: function() {
          var e = a.read(arguments);
          return this.setCenterX(e.x), this.setCenterY(e.y), this;
        },
        getArea: function() {
          return this.width * this.height;
        },
        isEmpty: function() {
          return this.width === 0 || this.height === 0;
        },
        contains: function(e) {
          return e && e.width !== ae || (Array.isArray(e) ? e : arguments).length === 4 ? this._containsRectangle(h.read(arguments)) : this._containsPoint(a.read(arguments));
        },
        _containsPoint: function(e) {
          var r = e.x, f = e.y;
          return r >= this.x && f >= this.y && r <= this.x + this.width && f <= this.y + this.height;
        },
        _containsRectangle: function(e) {
          var r = e.x, f = e.y;
          return r >= this.x && f >= this.y && r + e.width <= this.x + this.width && f + e.height <= this.y + this.height;
        },
        intersects: function() {
          var e = h.read(arguments), r = _.read(arguments) || 0;
          return e.x + e.width > this.x - r && e.y + e.height > this.y - r && e.x < this.x + this.width + r && e.y < this.y + this.height + r;
        },
        intersect: function() {
          var e = h.read(arguments), r = Math.max(this.x, e.x), f = Math.max(this.y, e.y), C = Math.min(this.x + this.width, e.x + e.width), R = Math.min(this.y + this.height, e.y + e.height);
          return new h(r, f, C - r, R - f);
        },
        unite: function() {
          var e = h.read(arguments), r = Math.min(this.x, e.x), f = Math.min(this.y, e.y), C = Math.max(this.x + this.width, e.x + e.width), R = Math.max(this.y + this.height, e.y + e.height);
          return new h(r, f, C - r, R - f);
        },
        include: function() {
          var e = a.read(arguments), r = Math.min(this.x, e.x), f = Math.min(this.y, e.y), C = Math.max(this.x + this.width, e.x), R = Math.max(this.y + this.height, e.y);
          return new h(r, f, C - r, R - f);
        },
        expand: function() {
          var e = d.read(arguments), r = e.width, f = e.height;
          return new h(
            this.x - r / 2,
            this.y - f / 2,
            this.width + r,
            this.height + f
          );
        },
        scale: function(e, r) {
          return this.expand(
            this.width * e - this.width,
            this.height * (r === ae ? e : r) - this.height
          );
        }
      }, _.each(
        [
          ["Top", "Left"],
          ["Top", "Right"],
          ["Bottom", "Left"],
          ["Bottom", "Right"],
          ["Left", "Center"],
          ["Top", "Center"],
          ["Right", "Center"],
          ["Bottom", "Center"]
        ],
        function(e, r) {
          var f = e.join(""), C = /^[RL]/.test(f);
          r >= 4 && (e[1] += C ? "Y" : "X");
          var R = e[C ? 0 : 1], B = e[C ? 1 : 0], j = "get" + R, H = "get" + B, X = "set" + R, ue = "set" + B, pe = "get" + f, P = "set" + f;
          this[pe] = function(q) {
            var K = q ? a : n;
            return new K(this[j](), this[H](), this, P);
          }, this[P] = function() {
            var q = a.read(arguments);
            this[X](q.x), this[ue](q.y);
          };
        },
        {
          beans: !0
        }
      )), m = h.extend(
        {
          initialize: function(r, f, C, R, B, j) {
            this._set(r, f, C, R, !0), this._owner = B, this._setter = j;
          },
          _set: function(e, r, f, C, R) {
            return this._x = e, this._y = r, this._width = f, this._height = C, R || this._owner[this._setter](this), this;
          }
        },
        new function() {
          var e = h.prototype;
          return _.each(
            ["x", "y", "width", "height"],
            function(r) {
              var f = _.capitalize(r), C = "_" + r;
              this["get" + f] = function() {
                return this[C];
              }, this["set" + f] = function(R) {
                this[C] = R, this._dontNotify || this._owner[this._setter](this);
              };
            },
            _.each(
              [
                "Point",
                "Size",
                "Center",
                "Left",
                "Top",
                "Right",
                "Bottom",
                "CenterX",
                "CenterY",
                "TopLeft",
                "TopRight",
                "BottomLeft",
                "BottomRight",
                "LeftCenter",
                "TopCenter",
                "RightCenter",
                "BottomCenter"
              ],
              function(r) {
                var f = "set" + r;
                this[f] = function() {
                  this._dontNotify = !0, e[f].apply(this, arguments), this._dontNotify = !1, this._owner[this._setter](this);
                };
              },
              {
                isSelected: function() {
                  return !!(this._owner._selection & 2);
                },
                setSelected: function(r) {
                  var f = this._owner;
                  f._changeSelection && f._changeSelection(2, r);
                }
              }
            )
          );
        }()
      ), s = _.extend({
        _class: "Matrix",
        initialize: function e(r, f) {
          var C = arguments, R = C.length, B = !0;
          if (R >= 6 ? this._set.apply(this, C) : R === 1 || R === 2 ? r instanceof e ? this._set(
            r._a,
            r._b,
            r._c,
            r._d,
            r._tx,
            r._ty,
            f
          ) : Array.isArray(r) ? this._set.apply(
            this,
            f ? r.concat([f]) : r
          ) : B = !1 : R ? B = !1 : this.reset(), !B)
            throw new Error("Unsupported matrix parameters");
          return this;
        },
        set: "#initialize",
        _set: function(e, r, f, C, R, B, j) {
          return this._a = e, this._b = r, this._c = f, this._d = C, this._tx = R, this._ty = B, j || this._changed(), this;
        },
        _serialize: function(e, r) {
          return _.serialize(this.getValues(), e, !0, r);
        },
        _changed: function() {
          var e = this._owner;
          e && (e._applyMatrix ? e.transform(null, !0) : e._changed(25));
        },
        clone: function() {
          return new s(
            this._a,
            this._b,
            this._c,
            this._d,
            this._tx,
            this._ty
          );
        },
        equals: function(e) {
          return e === this || e && this._a === e._a && this._b === e._b && this._c === e._c && this._d === e._d && this._tx === e._tx && this._ty === e._ty;
        },
        toString: function() {
          var e = c.instance;
          return "[[" + [
            e.number(this._a),
            e.number(this._c),
            e.number(this._tx)
          ].join(", ") + "], [" + [
            e.number(this._b),
            e.number(this._d),
            e.number(this._ty)
          ].join(", ") + "]]";
        },
        reset: function(e) {
          return this._a = this._d = 1, this._b = this._c = this._tx = this._ty = 0, e || this._changed(), this;
        },
        apply: function(e, r) {
          var f = this._owner;
          return f ? (f.transform(null, _.pick(e, !0), r), this.isIdentity()) : !1;
        },
        translate: function() {
          var e = a.read(arguments), r = e.x, f = e.y;
          return this._tx += r * this._a + f * this._c, this._ty += r * this._b + f * this._d, this._changed(), this;
        },
        scale: function() {
          var e = arguments, r = a.read(e), f = a.read(e, 0, { readNull: !0 });
          return f && this.translate(f), this._a *= r.x, this._b *= r.x, this._c *= r.y, this._d *= r.y, f && this.translate(f.negate()), this._changed(), this;
        },
        rotate: function(e) {
          e *= Math.PI / 180;
          var r = a.read(arguments, 1), f = r.x, C = r.y, R = Math.cos(e), B = Math.sin(e), j = f - f * R + C * B, H = C - f * B - C * R, X = this._a, ue = this._b, pe = this._c, P = this._d;
          return this._a = R * X + B * pe, this._b = R * ue + B * P, this._c = -B * X + R * pe, this._d = -B * ue + R * P, this._tx += j * X + H * pe, this._ty += j * ue + H * P, this._changed(), this;
        },
        shear: function() {
          var e = arguments, r = a.read(e), f = a.read(e, 0, { readNull: !0 });
          f && this.translate(f);
          var C = this._a, R = this._b;
          return this._a += r.y * this._c, this._b += r.y * this._d, this._c += r.x * C, this._d += r.x * R, f && this.translate(f.negate()), this._changed(), this;
        },
        skew: function() {
          var e = arguments, r = a.read(e), f = a.read(e, 0, { readNull: !0 }), C = Math.PI / 180, R = new a(
            Math.tan(r.x * C),
            Math.tan(r.y * C)
          );
          return this.shear(R, f);
        },
        append: function(e, r) {
          if (e) {
            var f = this._a, C = this._b, R = this._c, B = this._d, j = e._a, H = e._c, X = e._b, ue = e._d, pe = e._tx, P = e._ty;
            this._a = j * f + X * R, this._c = H * f + ue * R, this._b = j * C + X * B, this._d = H * C + ue * B, this._tx += pe * f + P * R, this._ty += pe * C + P * B, r || this._changed();
          }
          return this;
        },
        prepend: function(e, r) {
          if (e) {
            var f = this._a, C = this._b, R = this._c, B = this._d, j = this._tx, H = this._ty, X = e._a, ue = e._c, pe = e._b, P = e._d, q = e._tx, K = e._ty;
            this._a = X * f + ue * C, this._c = X * R + ue * B, this._b = pe * f + P * C, this._d = pe * R + P * B, this._tx = X * j + ue * H + q, this._ty = pe * j + P * H + K, r || this._changed();
          }
          return this;
        },
        appended: function(e) {
          return this.clone().append(e);
        },
        prepended: function(e) {
          return this.clone().prepend(e);
        },
        invert: function() {
          var e = this._a, r = this._b, f = this._c, C = this._d, R = this._tx, B = this._ty, j = e * C - r * f, H = null;
          return j && !isNaN(j) && isFinite(R) && isFinite(B) && (this._a = C / j, this._b = -r / j, this._c = -f / j, this._d = e / j, this._tx = (f * B - C * R) / j, this._ty = (r * R - e * B) / j, H = this), H;
        },
        inverted: function() {
          return this.clone().invert();
        },
        concatenate: "#append",
        preConcatenate: "#prepend",
        chain: "#appended",
        _shiftless: function() {
          return new s(this._a, this._b, this._c, this._d, 0, 0);
        },
        _orNullIfIdentity: function() {
          return this.isIdentity() ? null : this;
        },
        isIdentity: function() {
          return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1 && this._tx === 0 && this._ty === 0;
        },
        isInvertible: function() {
          var e = this._a * this._d - this._c * this._b;
          return e && !isNaN(e) && isFinite(this._tx) && isFinite(this._ty);
        },
        isSingular: function() {
          return !this.isInvertible();
        },
        transform: function(e, r, f) {
          return arguments.length < 3 ? this._transformPoint(a.read(arguments)) : this._transformCoordinates(e, r, f);
        },
        _transformPoint: function(e, r, f) {
          var C = e.x, R = e.y;
          return r || (r = new a()), r._set(
            C * this._a + R * this._c + this._tx,
            C * this._b + R * this._d + this._ty,
            f
          );
        },
        _transformCoordinates: function(e, r, f) {
          for (var C = 0, R = 2 * f; C < R; C += 2) {
            var B = e[C], j = e[C + 1];
            r[C] = B * this._a + j * this._c + this._tx, r[C + 1] = B * this._b + j * this._d + this._ty;
          }
          return r;
        },
        _transformCorners: function(e) {
          var r = e.x, f = e.y, C = r + e.width, R = f + e.height, B = [r, f, C, f, C, R, r, R];
          return this._transformCoordinates(B, B, 4);
        },
        _transformBounds: function(e, r, f) {
          for (var C = this._transformCorners(e), R = C.slice(0, 2), B = R.slice(), j = 2; j < 8; j++) {
            var H = C[j], X = j & 1;
            H < R[X] ? R[X] = H : H > B[X] && (B[X] = H);
          }
          return r || (r = new h()), r._set(
            R[0],
            R[1],
            B[0] - R[0],
            B[1] - R[1],
            f
          );
        },
        inverseTransform: function() {
          return this._inverseTransform(a.read(arguments));
        },
        _inverseTransform: function(e, r, f) {
          var C = this._a, R = this._b, B = this._c, j = this._d, H = this._tx, X = this._ty, ue = C * j - R * B, pe = null;
          if (ue && !isNaN(ue) && isFinite(H) && isFinite(X)) {
            var P = e.x - this._tx, q = e.y - this._ty;
            r || (r = new a()), pe = r._set(
              (P * j - q * B) / ue,
              (q * C - P * R) / ue,
              f
            );
          }
          return pe;
        },
        decompose: function() {
          var e = this._a, r = this._b, f = this._c, C = this._d, R = e * C - r * f, B = Math.sqrt, j = Math.atan2, H = 180 / Math.PI, X, ue, pe;
          if (e !== 0 || r !== 0) {
            var P = B(e * e + r * r);
            X = Math.acos(e / P) * (r > 0 ? 1 : -1), ue = [P, R / P], pe = [j(e * f + r * C, P * P), 0];
          } else if (f !== 0 || C !== 0) {
            var q = B(f * f + C * C);
            X = Math.asin(f / q) * (C > 0 ? 1 : -1), ue = [R / q, q], pe = [0, j(e * f + r * C, q * q)];
          } else
            X = 0, pe = ue = [0, 0];
          return {
            translation: this.getTranslation(),
            rotation: X * H,
            scaling: new a(ue),
            skewing: new a(pe[0] * H, pe[1] * H)
          };
        },
        getValues: function() {
          return [this._a, this._b, this._c, this._d, this._tx, this._ty];
        },
        getTranslation: function() {
          return new a(this._tx, this._ty);
        },
        getScaling: function() {
          return this.decompose().scaling;
        },
        getRotation: function() {
          return this.decompose().rotation;
        },
        applyToContext: function(e) {
          this.isIdentity() || e.transform(
            this._a,
            this._b,
            this._c,
            this._d,
            this._tx,
            this._ty
          );
        }
      }, _.each(["a", "b", "c", "d", "tx", "ty"], function(e) {
        var r = _.capitalize(e), f = "_" + e;
        this["get" + r] = function() {
          return this[f];
        }, this["set" + r] = function(C) {
          this[f] = C, this._changed();
        };
      }, {})), b = _.extend({
        _class: "Line",
        initialize: function(r, f, C, R, B) {
          var j = !1;
          arguments.length >= 4 ? (this._px = r, this._py = f, this._vx = C, this._vy = R, j = B) : (this._px = r.x, this._py = r.y, this._vx = f.x, this._vy = f.y, j = C), j || (this._vx -= this._px, this._vy -= this._py);
        },
        getPoint: function() {
          return new a(this._px, this._py);
        },
        getVector: function() {
          return new a(this._vx, this._vy);
        },
        getLength: function() {
          return this.getVector().getLength();
        },
        intersect: function(e, r) {
          return b.intersect(
            this._px,
            this._py,
            this._vx,
            this._vy,
            e._px,
            e._py,
            e._vx,
            e._vy,
            !0,
            r
          );
        },
        getSide: function(e, r) {
          return b.getSide(
            this._px,
            this._py,
            this._vx,
            this._vy,
            e.x,
            e.y,
            !0,
            r
          );
        },
        getDistance: function(e) {
          return Math.abs(this.getSignedDistance(e));
        },
        getSignedDistance: function(e) {
          return b.getSignedDistance(
            this._px,
            this._py,
            this._vx,
            this._vy,
            e.x,
            e.y,
            !0
          );
        },
        isCollinear: function(e) {
          return a.isCollinear(this._vx, this._vy, e._vx, e._vy);
        },
        isOrthogonal: function(e) {
          return a.isOrthogonal(this._vx, this._vy, e._vx, e._vy);
        },
        statics: {
          intersect: function(e, r, f, C, R, B, j, H, X, ue) {
            X || (f -= e, C -= r, j -= R, H -= B);
            var pe = f * H - C * j;
            if (!u.isMachineZero(pe)) {
              var P = e - R, q = r - B, K = (j * q - H * P) / pe, ye = (f * q - C * P) / pe, te = 1e-12, he = -te, D = 1 + te;
              if (ue || he < K && K < D && he < ye && ye < D)
                return ue || (K = K <= 0 ? 0 : K >= 1 ? 1 : K), new a(
                  e + K * f,
                  r + K * C
                );
            }
          },
          getSide: function(e, r, f, C, R, B, j, H) {
            j || (f -= e, C -= r);
            var X = R - e, ue = B - r, pe = X * C - ue * f;
            return !H && u.isMachineZero(pe) && (pe = (X * f + X * f) / (f * f + C * C), pe >= 0 && pe <= 1 && (pe = 0)), pe < 0 ? -1 : pe > 0 ? 1 : 0;
          },
          getSignedDistance: function(e, r, f, C, R, B, j) {
            return j || (f -= e, C -= r), f === 0 ? C > 0 ? R - e : e - R : C === 0 ? f < 0 ? B - r : r - B : ((R - e) * C - (B - r) * f) / (C > f ? C * Math.sqrt(1 + f * f / (C * C)) : f * Math.sqrt(1 + C * C / (f * f)));
          },
          getDistance: function(e, r, f, C, R, B, j) {
            return Math.abs(
              b.getSignedDistance(e, r, f, C, R, B, j)
            );
          }
        }
      }), S = y.extend({
        _class: "Project",
        _list: "projects",
        _reference: "project",
        _compactSerialize: !0,
        initialize: function(r) {
          y.call(this, !0), this._children = [], this._namedChildren = {}, this._activeLayer = null, this._currentStyle = new Ue(null, null, this), this._view = Ze.create(
            this,
            r || Ce.getCanvas(1, 1)
          ), this._selectionItems = {}, this._selectionCount = 0, this._updateVersion = 0;
        },
        _serialize: function(e, r) {
          return _.serialize(this._children, e, !0, r);
        },
        _changed: function(e, r) {
          if (e & 1) {
            var f = this._view;
            f && (f._needsUpdate = !0, !f._requested && f._autoUpdate && f.requestUpdate());
          }
          var C = this._changes;
          if (C && r) {
            var R = this._changesById, B = r._id, j = R[B];
            j ? j.flags |= e : C.push(R[B] = { item: r, flags: e });
          }
        },
        clear: function() {
          for (var e = this._children, r = e.length - 1; r >= 0; r--)
            e[r].remove();
        },
        isEmpty: function() {
          return !this._children.length;
        },
        remove: function e() {
          return e.base.call(this) ? (this._view && this._view.remove(), !0) : !1;
        },
        getView: function() {
          return this._view;
        },
        getCurrentStyle: function() {
          return this._currentStyle;
        },
        setCurrentStyle: function(e) {
          this._currentStyle.set(e);
        },
        getIndex: function() {
          return this._index;
        },
        getOptions: function() {
          return this._scope.settings;
        },
        getLayers: function() {
          return this._children;
        },
        getActiveLayer: function() {
          return this._activeLayer || new T({ project: this, insert: !0 });
        },
        getSymbolDefinitions: function() {
          var e = [], r = {};
          return this.getItems({
            class: z,
            match: function(f) {
              var C = f._definition, R = C._id;
              return r[R] || (r[R] = !0, e.push(C)), !1;
            }
          }), e;
        },
        getSymbols: "getSymbolDefinitions",
        getSelectedItems: function() {
          var e = this._selectionItems, r = [];
          for (var f in e) {
            var C = e[f], R = C._selection;
            R & 1 && C.isInserted() ? r.push(C) : R || this._updateSelection(C);
          }
          return r;
        },
        _updateSelection: function(e) {
          var r = e._id, f = this._selectionItems;
          e._selection ? f[r] !== e && (this._selectionCount++, f[r] = e) : f[r] === e && (this._selectionCount--, delete f[r]);
        },
        selectAll: function() {
          for (var e = this._children, r = 0, f = e.length; r < f; r++)
            e[r].setFullySelected(!0);
        },
        deselectAll: function() {
          var e = this._selectionItems;
          for (var r in e)
            e[r].setFullySelected(!1);
        },
        addLayer: function(e) {
          return this.insertLayer(ae, e);
        },
        insertLayer: function(e, r) {
          if (r instanceof T) {
            r._remove(!1, !0), _.splice(this._children, [r], e, 0), r._setProject(this, !0);
            var f = r._name;
            f && r.setName(f), this._changes && r._changed(5), this._activeLayer || (this._activeLayer = r);
          } else
            r = null;
          return r;
        },
        _insertItem: function(e, r, f) {
          return r = this.insertLayer(e, r) || (this._activeLayer || this._insertItem(
            ae,
            new T(o.NO_INSERT),
            !0
          )).insertChild(e, r), f && r.activate && r.activate(), r;
        },
        getItems: function(e) {
          return o._getItems(this, e);
        },
        getItem: function(e) {
          return o._getItems(this, e, null, null, !0)[0] || null;
        },
        importJSON: function(e) {
          this.activate();
          var r = this._activeLayer;
          return _.importJSON(e, r && r.isEmpty() && r);
        },
        removeOn: function(e) {
          var r = this._removeSets;
          if (r) {
            e === "mouseup" && (r.mousedrag = null);
            var f = r[e];
            if (f) {
              for (var C in f) {
                var R = f[C];
                for (var B in r) {
                  var j = r[B];
                  j && j != f && delete j[R._id];
                }
                R.remove();
              }
              r[e] = null;
            }
          }
        },
        draw: function(e, r, f) {
          this._updateVersion++, e.save(), r.applyToContext(e);
          for (var C = this._children, R = new _({
            offset: new a(0, 0),
            pixelRatio: f,
            viewMatrix: r.isIdentity() ? null : r,
            matrices: [new s()],
            updateMatrix: !0
          }), B = 0, j = C.length; B < j; B++)
            C[B].draw(e, R);
          if (e.restore(), this._selectionCount > 0) {
            e.save(), e.strokeWidth = 1;
            var H = this._selectionItems, X = this._scope.settings.handleSize, ue = this._updateVersion;
            for (var pe in H)
              H[pe]._drawSelection(e, r, X, H, ue);
            e.restore();
          }
        }
      }), o = _.extend(
        M,
        {
          statics: {
            extend: function e(r) {
              return r._serializeFields && (r._serializeFields = _.set(
                {},
                this.prototype._serializeFields,
                r._serializeFields
              )), e.base.apply(this, arguments);
            },
            INSERT: { insert: !0 },
            NO_INSERT: { insert: !1 }
          },
          _class: "Item",
          _name: null,
          _applyMatrix: !0,
          _canApplyMatrix: !0,
          _canScaleStroke: !1,
          _pivot: null,
          _visible: !0,
          _blendMode: "normal",
          _opacity: 1,
          _locked: !1,
          _guide: !1,
          _clipMask: !1,
          _selection: 0,
          _selectBounds: !0,
          _selectChildren: !1,
          _serializeFields: {
            name: null,
            applyMatrix: null,
            matrix: new s(),
            pivot: null,
            visible: !0,
            blendMode: "normal",
            opacity: 1,
            locked: !1,
            guide: !1,
            clipMask: !1,
            selected: !1,
            data: {}
          },
          _prioritize: ["applyMatrix"]
        },
        new function() {
          var e = [
            "onMouseDown",
            "onMouseUp",
            "onMouseDrag",
            "onClick",
            "onDoubleClick",
            "onMouseMove",
            "onMouseEnter",
            "onMouseLeave"
          ];
          return _.each(
            e,
            function(r) {
              this._events[r] = {
                install: function(f) {
                  this.getView()._countItemEvent(f, 1);
                },
                uninstall: function(f) {
                  this.getView()._countItemEvent(f, -1);
                }
              };
            },
            {
              _events: {
                onFrame: {
                  install: function() {
                    this.getView()._animateItem(this, !0);
                  },
                  uninstall: function() {
                    this.getView()._animateItem(this, !1);
                  }
                },
                onLoad: {},
                onError: {}
              },
              statics: {
                _itemHandlers: e
              }
            }
          );
        }(),
        {
          initialize: function() {
          },
          _initialize: function(e, r) {
            var f = e && _.isPlainObject(e), C = f && e.internal === !0, R = this._matrix = new s(), B = f && e.project || Ae.project, j = Ae.settings;
            return this._id = C ? null : l.get(), this._parent = this._index = null, this._applyMatrix = this._canApplyMatrix && j.applyMatrix, r && R.translate(r), R._owner = this, this._style = new Ue(B._currentStyle, this, B), C || f && e.insert == !1 || !j.insertItems && !(f && e.insert == !0) ? this._setProject(B) : (f && e.parent || B)._insertItem(ae, this, !0), f && e !== o.NO_INSERT && e !== o.INSERT && this.set(e, {
              internal: !0,
              insert: !0,
              project: !0,
              parent: !0
            }), f;
          },
          _serialize: function(e, r) {
            var f = {}, C = this;
            function R(B) {
              for (var j in B) {
                var H = C[j];
                _.equals(H, j === "leading" ? B.fontSize * 1.2 : B[j]) || (f[j] = _.serialize(
                  H,
                  e,
                  j !== "data",
                  r
                ));
              }
            }
            return R(this._serializeFields), this instanceof A || R(this._style._defaults), [this._class, f];
          },
          _changed: function(e) {
            var r = this._symbol, f = this._parent || r, C = this._project;
            e & 8 && (this._bounds = this._position = this._decomposed = ae), e & 16 && (this._globalMatrix = ae), f && e & 72 && o._clearBoundsCache(f), e & 2 && o._clearBoundsCache(this), C && C._changed(e, this), r && r._changed(e);
          },
          getId: function() {
            return this._id;
          },
          getName: function() {
            return this._name;
          },
          setName: function(e) {
            if (this._name && this._removeNamed(), e === +e + "")
              throw new Error(
                "Names consisting only of numbers are not supported."
              );
            var r = this._getOwner();
            if (e && r) {
              var f = r._children, C = r._namedChildren;
              (C[e] = C[e] || []).push(this), e in f || (f[e] = this);
            }
            this._name = e || ae, this._changed(256);
          },
          getStyle: function() {
            return this._style;
          },
          setStyle: function(e) {
            this.getStyle().set(e);
          }
        },
        _.each(
          ["locked", "visible", "blendMode", "opacity", "guide"],
          function(e) {
            var r = _.capitalize(e), f = "_" + e, C = {
              locked: 256,
              visible: 265
            };
            this["get" + r] = function() {
              return this[f];
            }, this["set" + r] = function(R) {
              R != this[f] && (this[f] = R, this._changed(C[e] || 257));
            };
          },
          {}
        ),
        {
          beans: !0,
          getSelection: function() {
            return this._selection;
          },
          setSelection: function(e) {
            if (e !== this._selection) {
              this._selection = e;
              var r = this._project;
              r && (r._updateSelection(this), this._changed(257));
            }
          },
          _changeSelection: function(e, r) {
            var f = this._selection;
            this.setSelection(r ? f | e : f & ~e);
          },
          isSelected: function() {
            if (this._selectChildren) {
              for (var e = this._children, r = 0, f = e.length; r < f; r++)
                if (e[r].isSelected())
                  return !0;
            }
            return !!(this._selection & 1);
          },
          setSelected: function(e) {
            if (this._selectChildren)
              for (var r = this._children, f = 0, C = r.length; f < C; f++)
                r[f].setSelected(e);
            this._changeSelection(1, e);
          },
          isFullySelected: function() {
            var e = this._children, r = !!(this._selection & 1);
            if (e && r) {
              for (var f = 0, C = e.length; f < C; f++)
                if (!e[f].isFullySelected())
                  return !1;
              return !0;
            }
            return r;
          },
          setFullySelected: function(e) {
            var r = this._children;
            if (r)
              for (var f = 0, C = r.length; f < C; f++)
                r[f].setFullySelected(e);
            this._changeSelection(1, e);
          },
          isClipMask: function() {
            return this._clipMask;
          },
          setClipMask: function(e) {
            this._clipMask != (e = !!e) && (this._clipMask = e, e && (this.setFillColor(null), this.setStrokeColor(null)), this._changed(257), this._parent && this._parent._changed(2048));
          },
          getData: function() {
            return this._data || (this._data = {}), this._data;
          },
          setData: function(e) {
            this._data = e;
          },
          getPosition: function(e) {
            var r = e ? a : n, f = this._position || (this._position = this._getPositionFromBounds());
            return new r(f.x, f.y, this, "setPosition");
          },
          setPosition: function() {
            this.translate(a.read(arguments).subtract(this.getPosition(!0)));
          },
          _getPositionFromBounds: function(e) {
            return this._pivot ? this._matrix._transformPoint(this._pivot) : (e || this.getBounds()).getCenter(!0);
          },
          getPivot: function() {
            var e = this._pivot;
            return e ? new n(e.x, e.y, this, "setPivot") : null;
          },
          setPivot: function() {
            this._pivot = a.read(arguments, 0, { clone: !0, readNull: !0 }), this._position = ae;
          }
        },
        _.each(
          {
            getStrokeBounds: { stroke: !0 },
            getHandleBounds: { handle: !0 },
            getInternalBounds: { internal: !0 }
          },
          function(e, r) {
            this[r] = function(f) {
              return this.getBounds(f, e);
            };
          },
          {
            beans: !0,
            getBounds: function(e, r) {
              var f = r || e instanceof s, C = _.set(
                {},
                f ? r : e,
                this._boundsOptions
              );
              (!C.stroke || this.getStrokeScaling()) && (C.cacheItem = this);
              var R = this._getCachedBounds(f && e, C).rect;
              return arguments.length ? R : new m(
                R.x,
                R.y,
                R.width,
                R.height,
                this,
                "setBounds"
              );
            },
            setBounds: function() {
              var e = h.read(arguments), r = this.getBounds(), f = this._matrix, C = new s(), R = e.getCenter();
              C.translate(R), (e.width != r.width || e.height != r.height) && (f.isInvertible() || (f.set(f._backup || new s().translate(f.getTranslation())), r = this.getBounds()), C.scale(
                r.width !== 0 ? e.width / r.width : 0,
                r.height !== 0 ? e.height / r.height : 0
              )), R = r.getCenter(), C.translate(-R.x, -R.y), this.transform(C);
            },
            _getBounds: function(e, r) {
              var f = this._children;
              return !f || !f.length ? new h() : (o._updateBoundsCache(this, r.cacheItem), o._getBounds(f, e, r));
            },
            _getBoundsCacheKey: function(e, r) {
              return [
                e.stroke ? 1 : 0,
                e.handle ? 1 : 0,
                r ? 1 : 0
              ].join("");
            },
            _getCachedBounds: function(e, r, f) {
              e = e && e._orNullIfIdentity();
              var C = r.internal && !f, R = r.cacheItem, B = C ? null : this._matrix._orNullIfIdentity(), j = R && (!e || e.equals(B)) && this._getBoundsCacheKey(r, C), H = this._bounds;
              if (o._updateBoundsCache(this._parent || this._symbol, R), j && H && j in H) {
                var X = H[j];
                return {
                  rect: X.rect.clone(),
                  nonscaling: X.nonscaling
                };
              }
              var ue = this._getBounds(e || B, r), pe = ue.rect || ue, P = this._style, q = ue.nonscaling || P.hasStroke() && !P.getStrokeScaling();
              if (j) {
                H || (this._bounds = H = {});
                var X = H[j] = {
                  rect: pe.clone(),
                  nonscaling: q,
                  internal: C
                };
              }
              return {
                rect: pe,
                nonscaling: q
              };
            },
            _getStrokeMatrix: function(e, r) {
              var f = this.getStrokeScaling() ? null : r && r.internal ? this : this._parent || this._symbol && this._symbol._item, C = f ? f.getViewMatrix().invert() : e;
              return C && C._shiftless();
            },
            statics: {
              _updateBoundsCache: function(e, r) {
                if (e && r) {
                  var f = r._id, C = e._boundsCache = e._boundsCache || {
                    ids: {},
                    list: []
                  };
                  C.ids[f] || (C.list.push(r), C.ids[f] = r);
                }
              },
              _clearBoundsCache: function(e) {
                var r = e._boundsCache;
                if (r) {
                  e._bounds = e._position = e._boundsCache = ae;
                  for (var f = 0, C = r.list, R = C.length; f < R; f++) {
                    var B = C[f];
                    B !== e && (B._bounds = B._position = ae, B._boundsCache && o._clearBoundsCache(B));
                  }
                }
              },
              _getBounds: function(e, r, f) {
                var C = 1 / 0, R = -C, B = C, j = R, H = !1;
                f = f || {};
                for (var X = 0, ue = e.length; X < ue; X++) {
                  var pe = e[X];
                  if (pe._visible && !pe.isEmpty(!0)) {
                    var P = pe._getCachedBounds(
                      r && r.appended(pe._matrix),
                      f,
                      !0
                    ), q = P.rect;
                    C = Math.min(q.x, C), B = Math.min(q.y, B), R = Math.max(q.x + q.width, R), j = Math.max(q.y + q.height, j), P.nonscaling && (H = !0);
                  }
                }
                return {
                  rect: isFinite(C) ? new h(C, B, R - C, j - B) : new h(),
                  nonscaling: H
                };
              }
            }
          }
        ),
        {
          beans: !0,
          _decompose: function() {
            return this._applyMatrix ? null : this._decomposed || (this._decomposed = this._matrix.decompose());
          },
          getRotation: function() {
            var e = this._decompose();
            return e ? e.rotation : 0;
          },
          setRotation: function(e) {
            var r = this.getRotation();
            if (r != null && e != null) {
              var f = this._decomposed;
              this.rotate(e - r), f && (f.rotation = e, this._decomposed = f);
            }
          },
          getScaling: function() {
            var e = this._decompose(), r = e && e.scaling;
            return new n(r ? r.x : 1, r ? r.y : 1, this, "setScaling");
          },
          setScaling: function() {
            var e = this.getScaling(), r = a.read(arguments, 0, { clone: !0, readNull: !0 });
            if (e && r && !e.equals(r)) {
              var f = this.getRotation(), C = this._decomposed, R = new s(), B = u.isZero;
              if (B(e.x) || B(e.y))
                R.translate(C.translation), f && R.rotate(f), R.scale(r.x, r.y), this._matrix.set(R);
              else {
                var j = this.getPosition(!0);
                R.translate(j), f && R.rotate(f), R.scale(r.x / e.x, r.y / e.y), f && R.rotate(-f), R.translate(j.negate()), this.transform(R);
              }
              C && (C.scaling = r, this._decomposed = C);
            }
          },
          getMatrix: function() {
            return this._matrix;
          },
          setMatrix: function() {
            var e = this._matrix;
            e.set.apply(e, arguments);
          },
          getGlobalMatrix: function(e) {
            var r = this._globalMatrix;
            if (r)
              for (var f = this._parent, C = []; f; ) {
                if (!f._globalMatrix) {
                  r = null;
                  for (var R = 0, B = C.length; R < B; R++)
                    C[R]._globalMatrix = null;
                  break;
                }
                C.push(f), f = f._parent;
              }
            if (!r) {
              r = this._globalMatrix = this._matrix.clone();
              var f = this._parent;
              f && r.prepend(f.getGlobalMatrix(!0));
            }
            return e ? r : r.clone();
          },
          getViewMatrix: function() {
            return this.getGlobalMatrix().prepend(this.getView()._matrix);
          },
          getApplyMatrix: function() {
            return this._applyMatrix;
          },
          setApplyMatrix: function(e) {
            (this._applyMatrix = this._canApplyMatrix && !!e) && this.transform(null, !0);
          },
          getTransformContent: "#getApplyMatrix",
          setTransformContent: "#setApplyMatrix"
        },
        {
          getProject: function() {
            return this._project;
          },
          _setProject: function(e, r) {
            if (this._project !== e) {
              this._project && this._installEvents(!1), this._project = e;
              for (var f = this._children, C = 0, R = f && f.length; C < R; C++)
                f[C]._setProject(e);
              r = !0;
            }
            r && this._installEvents(!0);
          },
          getView: function() {
            return this._project._view;
          },
          _installEvents: function e(r) {
            e.base.call(this, r);
            for (var f = this._children, C = 0, R = f && f.length; C < R; C++)
              f[C]._installEvents(r);
          },
          getLayer: function() {
            for (var e = this; e = e._parent; )
              if (e instanceof T)
                return e;
            return null;
          },
          getParent: function() {
            return this._parent;
          },
          setParent: function(e) {
            return e.addChild(this);
          },
          _getOwner: "#getParent",
          getChildren: function() {
            return this._children;
          },
          setChildren: function(e) {
            this.removeChildren(), this.addChildren(e);
          },
          getFirstChild: function() {
            return this._children && this._children[0] || null;
          },
          getLastChild: function() {
            return this._children && this._children[this._children.length - 1] || null;
          },
          getNextSibling: function() {
            var e = this._getOwner();
            return e && e._children[this._index + 1] || null;
          },
          getPreviousSibling: function() {
            var e = this._getOwner();
            return e && e._children[this._index - 1] || null;
          },
          getIndex: function() {
            return this._index;
          },
          setIndex: function(e) {
            var r = this._parent, f = r && r._children;
            f && r.insertChildren(
              e in f ? e : ae,
              [this]
            );
          },
          equals: function(e) {
            return e === this || e && this._class === e._class && this._style.equals(e._style) && this._matrix.equals(e._matrix) && this._locked === e._locked && this._visible === e._visible && this._blendMode === e._blendMode && this._opacity === e._opacity && this._clipMask === e._clipMask && this._guide === e._guide && this._equals(e) || !1;
          },
          _equals: function(e) {
            return _.equals(this._children, e._children);
          },
          clone: function(e) {
            var r = new this.constructor(o.NO_INSERT), f = this._children, C = _.pick(
              e ? e.insert : ae,
              e === ae || e === !0
            ), R = _.pick(e ? e.deep : ae, !0);
            f && r.copyAttributes(this), (!f || R) && r.copyContent(this), f || r.copyAttributes(this), C && r.insertAbove(this);
            var B = this._name, j = this._parent;
            if (B && j) {
              for (var f = j._children, H = B, X = 1; f[B]; )
                B = H + " " + X++;
              B !== H && r.setName(B);
            }
            return r;
          },
          copyContent: function(e) {
            for (var r = e._children, f = 0, C = r && r.length; f < C; f++)
              this.addChild(r[f].clone(!1), !0);
          },
          copyAttributes: function(e, r) {
            this.setStyle(e._style);
            for (var f = [
              "_locked",
              "_visible",
              "_blendMode",
              "_opacity",
              "_clipMask",
              "_guide"
            ], C = 0, R = f.length; C < R; C++) {
              var B = f[C];
              e.hasOwnProperty(B) && (this[B] = e[B]);
            }
            r || this._matrix.set(e._matrix, !0), this.setApplyMatrix(e._applyMatrix), this.setPivot(e._pivot), this.setSelection(e._selection);
            var j = e._data, H = e._name;
            this._data = j ? _.clone(j) : null, H && this.setName(H);
          },
          rasterize: function(e, r) {
            var f, C, R;
            _.isPlainObject(e) ? (f = e.resolution, C = e.insert, R = e.raster) : (f = e, C = r), R || (R = new L(o.NO_INSERT));
            var B = this.getStrokeBounds(), j = (f || this.getView().getResolution()) / 72, H = B.getTopLeft().floor(), X = B.getBottomRight().ceil(), ue = new d(X.subtract(H)), pe = ue.multiply(j);
            if (R.setSize(pe, !0), !pe.isZero()) {
              var P = R.getContext(!0), q = new s().scale(j).translate(H.negate());
              P.save(), q.applyToContext(P), this.draw(P, new _({ matrices: [q] })), P.restore();
            }
            return R._matrix.set(
              new s().translate(H.add(ue.divide(2))).scale(1 / j)
            ), (C === ae || C) && R.insertAbove(this), R;
          },
          contains: function() {
            var e = this._matrix;
            return e.isInvertible() && !!this._contains(e._inverseTransform(a.read(arguments)));
          },
          _contains: function(e) {
            var r = this._children;
            if (r) {
              for (var f = r.length - 1; f >= 0; f--)
                if (r[f].contains(e))
                  return !0;
              return !1;
            }
            return e.isInside(this.getInternalBounds());
          },
          isInside: function() {
            return h.read(arguments).contains(this.getBounds());
          },
          _asPathItem: function() {
            return new Q.Rectangle({
              rectangle: this.getInternalBounds(),
              matrix: this._matrix,
              insert: !1
            });
          },
          intersects: function(e, r) {
            return e instanceof o ? this._asPathItem().getIntersections(
              e._asPathItem(),
              null,
              r,
              !0
            ).length > 0 : !1;
          }
        },
        new function() {
          function e() {
            var C = arguments;
            return this._hitTest(
              a.read(C),
              J.getOptions(C)
            );
          }
          function r() {
            var C = arguments, R = a.read(C), B = J.getOptions(C), j = [];
            return this._hitTest(R, new _({ all: j }, B)), j;
          }
          function f(C, R, B, j) {
            var H = this._children;
            if (H)
              for (var X = H.length - 1; X >= 0; X--) {
                var ue = H[X], pe = ue !== j && ue._hitTest(
                  C,
                  R,
                  B
                );
                if (pe && !R.all)
                  return pe;
              }
            return null;
          }
          return S.inject({
            hitTest: e,
            hitTestAll: r,
            _hitTest: f
          }), {
            hitTest: e,
            hitTestAll: r,
            _hitTestChildren: f
          };
        }(),
        {
          _hitTest: function(e, r, f) {
            if (this._locked || !this._visible || this._guide && !r.guides || this.isEmpty())
              return null;
            var C = this._matrix, R = f ? f.appended(C) : this.getGlobalMatrix().prepend(this.getView()._matrix), B = Math.max(r.tolerance, 1e-12), j = r._tolerancePadding = new d(
              Q._getStrokePadding(
                B,
                C._shiftless().invert()
              )
            );
            if (e = C._inverseTransform(e), !e || !this._children && !this.getBounds({ internal: !0, stroke: !0, handle: !0 }).expand(j.multiply(2))._containsPoint(e))
              return null;
            var H = !(r.guides && !this._guide || r.selected && !this.isSelected() || r.type && r.type !== _.hyphenate(this._class) || r.class && !(this instanceof r.class)), X = r.match, ue = this, pe, P;
            function q(le) {
              return le && X && !X(le) && (le = null), le && r.all && r.all.push(le), le;
            }
            function K(le, v) {
              var se = v ? pe["get" + v]() : ue.getPosition();
              if (e.subtract(se).divide(j).length <= 1)
                return new J(le, ue, {
                  name: v ? _.hyphenate(v) : le,
                  point: se
                });
            }
            var ye = r.position, te = r.center, he = r.bounds;
            if (H && this._parent && (ye || te || he)) {
              if ((te || he) && (pe = this.getInternalBounds()), P = ye && K("position") || te && K("center", "Center"), !P && he)
                for (var D = [
                  "TopLeft",
                  "TopRight",
                  "BottomLeft",
                  "BottomRight",
                  "LeftCenter",
                  "TopCenter",
                  "RightCenter",
                  "BottomCenter"
                ], Se = 0; Se < 8 && !P; Se++)
                  P = K("bounds", D[Se]);
              P = q(P);
            }
            return P || (P = this._hitTestChildren(e, r, R) || H && q(this._hitTestSelf(
              e,
              r,
              R,
              this.getStrokeScaling() ? null : R._shiftless().invert()
            )) || null), P && P.point && (P.point = C.transform(P.point)), P;
          },
          _hitTestSelf: function(e, r) {
            if (r.fill && this.hasFill() && this._contains(e))
              return new J("fill", this);
          },
          matches: function(e, r) {
            function f(j, H) {
              for (var X in j)
                if (j.hasOwnProperty(X)) {
                  var ue = j[X], pe = H[X];
                  if (_.isPlainObject(ue) && _.isPlainObject(pe)) {
                    if (!f(ue, pe))
                      return !1;
                  } else if (!_.equals(ue, pe))
                    return !1;
                }
              return !0;
            }
            var C = typeof e;
            if (C === "object") {
              for (var R in e)
                if (e.hasOwnProperty(R) && !this.matches(R, e[R]))
                  return !1;
              return !0;
            } else {
              if (C === "function")
                return e(this);
              if (e === "match")
                return r(this);
              var B = /^(empty|editable)$/.test(e) ? this["is" + _.capitalize(e)]() : e === "type" ? _.hyphenate(this._class) : this[e];
              if (e === "class") {
                if (typeof r == "function")
                  return this instanceof r;
                B = this._class;
              }
              if (typeof r == "function")
                return !!r(B);
              if (r) {
                if (r.test)
                  return r.test(B);
                if (_.isPlainObject(r))
                  return f(r, B);
              }
              return _.equals(B, r);
            }
          },
          getItems: function(e) {
            return o._getItems(this, e, this._matrix);
          },
          getItem: function(e) {
            return o._getItems(this, e, this._matrix, null, !0)[0] || null;
          },
          statics: {
            _getItems: function e(r, f, C, R, B) {
              if (!R) {
                var j = typeof f == "object" && f, H = j && j.overlapping, X = j && j.inside, ue = H || X, q = ue && h.read([ue]);
                R = {
                  items: [],
                  recursive: j && j.recursive !== !1,
                  inside: !!X,
                  overlapping: !!H,
                  rect: q,
                  path: H && new Q.Rectangle({
                    rectangle: q,
                    insert: !1
                  })
                }, j && (f = _.filter({}, f, {
                  recursive: !0,
                  inside: !0,
                  overlapping: !0
                }));
              }
              var pe = r._children, P = R.items, q = R.rect;
              C = q && (C || new s());
              for (var K = 0, ye = pe && pe.length; K < ye; K++) {
                var te = pe[K], he = C && C.appended(te._matrix), D = !0;
                if (q) {
                  var ue = te.getBounds(he);
                  if (!q.intersects(ue))
                    continue;
                  q.contains(ue) || R.overlapping && (ue.contains(q) || R.path.intersects(te, he)) || (D = !1);
                }
                if (D && te.matches(f) && (P.push(te), B) || (R.recursive !== !1 && e(te, f, he, R, B), B && P.length > 0))
                  break;
              }
              return P;
            }
          }
        },
        {
          importJSON: function(e) {
            var r = _.importJSON(e, this);
            return r !== this ? this.addChild(r) : r;
          },
          addChild: function(e) {
            return this.insertChild(ae, e);
          },
          insertChild: function(e, r) {
            var f = r ? this.insertChildren(e, [r]) : null;
            return f && f[0];
          },
          addChildren: function(e) {
            return this.insertChildren(this._children.length, e);
          },
          insertChildren: function(e, r) {
            var f = this._children;
            if (f && r && r.length > 0) {
              r = _.slice(r);
              for (var C = {}, R = r.length - 1; R >= 0; R--) {
                var B = r[R], j = B && B._id;
                !B || C[j] ? r.splice(R, 1) : (B._remove(!1, !0), C[j] = !0);
              }
              _.splice(f, r, e, 0);
              for (var H = this._project, X = H._changes, R = 0, ue = r.length; R < ue; R++) {
                var B = r[R], pe = B._name;
                B._parent = this, B._setProject(H, !0), pe && B.setName(pe), X && B._changed(5);
              }
              this._changed(11);
            } else
              r = null;
            return r;
          },
          _insertItem: "#insertChild",
          _insertAt: function(e, r) {
            var f = e && e._getOwner(), C = e !== this && f ? this : null;
            return C && (C._remove(!1, !0), f._insertItem(e._index + r, C)), C;
          },
          insertAbove: function(e) {
            return this._insertAt(e, 1);
          },
          insertBelow: function(e) {
            return this._insertAt(e, 0);
          },
          sendToBack: function() {
            var e = this._getOwner();
            return e ? e._insertItem(0, this) : null;
          },
          bringToFront: function() {
            var e = this._getOwner();
            return e ? e._insertItem(ae, this) : null;
          },
          appendTop: "#addChild",
          appendBottom: function(e) {
            return this.insertChild(0, e);
          },
          moveAbove: "#insertAbove",
          moveBelow: "#insertBelow",
          addTo: function(e) {
            return e._insertItem(ae, this);
          },
          copyTo: function(e) {
            return this.clone(!1).addTo(e);
          },
          reduce: function(e) {
            var r = this._children;
            if (r && r.length === 1) {
              var f = r[0].reduce(e);
              return this._parent ? (f.insertAbove(this), this.remove()) : f.remove(), f;
            }
            return this;
          },
          _removeNamed: function() {
            var e = this._getOwner();
            if (e) {
              var r = e._children, f = e._namedChildren, C = this._name, R = f[C], B = R ? R.indexOf(this) : -1;
              B !== -1 && (r[C] == this && delete r[C], R.splice(B, 1), R.length ? r[C] = R[0] : delete f[C]);
            }
          },
          _remove: function(e, r) {
            var f = this._getOwner(), C = this._project, R = this._index;
            return this._style && this._style._dispose(), f ? (this._name && this._removeNamed(), R != null && (C._activeLayer === this && (C._activeLayer = this.getNextSibling() || this.getPreviousSibling()), _.splice(f._children, null, R, 1)), this._installEvents(!1), e && C._changes && this._changed(5), r && f._changed(11, this), this._parent = null, !0) : !1;
          },
          remove: function() {
            return this._remove(!0, !0);
          },
          replaceWith: function(e) {
            var r = e && e.insertBelow(this);
            return r && this.remove(), r;
          },
          removeChildren: function(e, r) {
            if (!this._children)
              return null;
            e = e || 0, r = _.pick(r, this._children.length);
            for (var f = _.splice(this._children, null, e, r - e), C = f.length - 1; C >= 0; C--)
              f[C]._remove(!0, !1);
            return f.length > 0 && this._changed(11), f;
          },
          clear: "#removeChildren",
          reverseChildren: function() {
            if (this._children) {
              this._children.reverse();
              for (var e = 0, r = this._children.length; e < r; e++)
                this._children[e]._index = e;
              this._changed(11);
            }
          },
          isEmpty: function(e) {
            var r = this._children, f = r ? r.length : 0;
            if (e) {
              for (var C = 0; C < f; C++)
                if (!r[C].isEmpty(e))
                  return !1;
              return !0;
            }
            return !f;
          },
          isEditable: function() {
            for (var e = this; e; ) {
              if (!e._visible || e._locked)
                return !1;
              e = e._parent;
            }
            return !0;
          },
          hasFill: function() {
            return this.getStyle().hasFill();
          },
          hasStroke: function() {
            return this.getStyle().hasStroke();
          },
          hasShadow: function() {
            return this.getStyle().hasShadow();
          },
          _getOrder: function(e) {
            function r(j) {
              var H = [];
              do
                H.unshift(j);
              while (j = j._parent);
              return H;
            }
            for (var f = r(this), C = r(e), R = 0, B = Math.min(f.length, C.length); R < B; R++)
              if (f[R] != C[R])
                return f[R]._index < C[R]._index ? 1 : -1;
            return 0;
          },
          hasChildren: function() {
            return this._children && this._children.length > 0;
          },
          isInserted: function() {
            return this._parent ? this._parent.isInserted() : !1;
          },
          isAbove: function(e) {
            return this._getOrder(e) === -1;
          },
          isBelow: function(e) {
            return this._getOrder(e) === 1;
          },
          isParent: function(e) {
            return this._parent === e;
          },
          isChild: function(e) {
            return e && e._parent === this;
          },
          isDescendant: function(e) {
            for (var r = this; r = r._parent; )
              if (r === e)
                return !0;
            return !1;
          },
          isAncestor: function(e) {
            return e ? e.isDescendant(this) : !1;
          },
          isSibling: function(e) {
            return this._parent === e._parent;
          },
          isGroupedWith: function(e) {
            for (var r = this._parent; r; ) {
              if (r._parent && /^(Group|Layer|CompoundPath)$/.test(r._class) && e.isDescendant(r))
                return !0;
              r = r._parent;
            }
            return !1;
          }
        },
        _.each(["rotate", "scale", "shear", "skew"], function(e) {
          var r = e === "rotate";
          this[e] = function() {
            var f = arguments, C = (r ? _ : a).read(f), R = a.read(f, 0, { readNull: !0 });
            return this.transform(new s()[e](
              C,
              R || this.getPosition(!0)
            ));
          };
        }, {
          translate: function() {
            var e = new s();
            return this.transform(e.translate.apply(e, arguments));
          },
          transform: function(e, r, f) {
            var C = this._matrix, R = e && !e.isIdentity(), B = f && this._canApplyMatrix || this._applyMatrix && (R || !C.isIdentity() || r && this._children);
            if (!R && !B)
              return this;
            if (R) {
              !e.isInvertible() && C.isInvertible() && (C._backup = C.getValues()), C.prepend(e, !0);
              var j = this._style, H = j.getFillColor(!0), X = j.getStrokeColor(!0);
              H && H.transform(e), X && X.transform(e);
            }
            if (B && (B = this._transformContent(
              C,
              r,
              f
            ))) {
              var ue = this._pivot;
              ue && C._transformPoint(ue, ue, !0), C.reset(!0), f && this._canApplyMatrix && (this._applyMatrix = !0);
            }
            var pe = this._bounds, P = this._position;
            (R || B) && this._changed(25);
            var q = R && pe && e.decompose();
            if (q && q.skewing.isZero() && q.rotation % 90 === 0) {
              for (var K in pe) {
                var ye = pe[K];
                if (ye.nonscaling)
                  delete pe[K];
                else if (B || !ye.internal) {
                  var te = ye.rect;
                  e._transformBounds(te, te);
                }
              }
              this._bounds = pe;
              var he = pe[this._getBoundsCacheKey(
                this._boundsOptions || {}
              )];
              he && (this._position = this._getPositionFromBounds(he.rect));
            } else R && P && this._pivot && (this._position = e._transformPoint(P, P));
            return this;
          },
          _transformContent: function(e, r, f) {
            var C = this._children;
            if (C) {
              for (var R = 0, B = C.length; R < B; R++)
                C[R].transform(e, r, f);
              return !0;
            }
          },
          globalToLocal: function() {
            return this.getGlobalMatrix(!0)._inverseTransform(
              a.read(arguments)
            );
          },
          localToGlobal: function() {
            return this.getGlobalMatrix(!0)._transformPoint(
              a.read(arguments)
            );
          },
          parentToLocal: function() {
            return this._matrix._inverseTransform(a.read(arguments));
          },
          localToParent: function() {
            return this._matrix._transformPoint(a.read(arguments));
          },
          fitBounds: function(e, r) {
            e = h.read(arguments);
            var f = this.getBounds(), C = f.height / f.width, R = e.height / e.width, B = (r ? C > R : C < R) ? e.width / f.width : e.height / f.height, j = new h(
              new a(),
              new d(f.width * B, f.height * B)
            );
            j.setCenter(e.getCenter()), this.setBounds(j);
          }
        }),
        {
          _setStyles: function(e, r, f) {
            var C = this._style, R = this._matrix;
            if (C.hasFill() && (e.fillStyle = C.getFillColor().toCanvasStyle(e, R)), C.hasStroke()) {
              e.strokeStyle = C.getStrokeColor().toCanvasStyle(e, R), e.lineWidth = C.getStrokeWidth();
              var B = C.getStrokeJoin(), j = C.getStrokeCap(), H = C.getMiterLimit();
              if (B && (e.lineJoin = B), j && (e.lineCap = j), H && (e.miterLimit = H), Ae.support.nativeDash) {
                var X = C.getDashArray(), ue = C.getDashOffset();
                X && X.length && ("setLineDash" in e ? (e.setLineDash(X), e.lineDashOffset = ue) : (e.mozDash = X, e.mozDashOffset = ue));
              }
            }
            if (C.hasShadow()) {
              var pe = r.pixelRatio || 1, P = f._shiftless().prepend(
                new s().scale(pe, pe)
              ), q = P.transform(new a(C.getShadowBlur(), 0)), K = P.transform(this.getShadowOffset());
              e.shadowColor = C.getShadowColor().toCanvasStyle(e), e.shadowBlur = q.getLength(), e.shadowOffsetX = K.x, e.shadowOffsetY = K.y;
            }
          },
          draw: function(e, r, f) {
            if (this._updateVersion = this._project._updateVersion, !(!this._visible || this._opacity === 0)) {
              var C = r.matrices, R = r.viewMatrix, B = this._matrix, j = C[C.length - 1].appended(B);
              if (j.isInvertible()) {
                R = R ? R.appended(j) : j, C.push(j), r.updateMatrix && (this._globalMatrix = j);
                var H = this._blendMode, X = u.clamp(this._opacity, 0, 1), ue = H === "normal", pe = ve.nativeModes[H], P = ue && X === 1 || r.dontStart || r.clip || (pe || ue && X < 1) && this._canComposite(), q = r.pixelRatio || 1, K, ye, te;
                if (!P) {
                  var he = this.getStrokeBounds(R);
                  if (!he.width || !he.height) {
                    C.pop();
                    return;
                  }
                  te = r.offset, ye = r.offset = he.getTopLeft().floor(), K = e, e = Ce.getContext(he.getSize().ceil().add(1).multiply(q)), q !== 1 && e.scale(q, q);
                }
                e.save();
                var D = f ? f.appended(B) : this._canScaleStroke && !this.getStrokeScaling(!0) && R, Se = !P && r.clipItem, le = !D || Se;
                if (P ? (e.globalAlpha = X, pe && (e.globalCompositeOperation = H)) : le && e.translate(-ye.x, -ye.y), le && (P ? B : R).applyToContext(e), Se && r.clipItem.draw(e, r.extend({ clip: !0 })), D) {
                  e.setTransform(q, 0, 0, q, 0, 0);
                  var v = r.offset;
                  v && e.translate(-v.x, -v.y);
                }
                this._draw(e, r, R, D), e.restore(), C.pop(), r.clip && !r.dontFinish && e.clip(this.getFillRule()), P || (ve.process(
                  H,
                  e,
                  K,
                  X,
                  ye.subtract(te).multiply(q)
                ), Ce.release(e), r.offset = te);
              }
            }
          },
          _isUpdated: function(e) {
            var r = this._parent;
            if (r instanceof de)
              return r._isUpdated(e);
            var f = this._updateVersion === e;
            return !f && r && r._visible && r._isUpdated(e) && (this._updateVersion = e, f = !0), f;
          },
          _drawSelection: function(e, r, f, C, R) {
            var B = this._selection, j = B & 1, H = B & 2 || j && this._selectBounds, X = B & 4;
            if (this._drawSelected || (j = !1), (j || H || X) && this._isUpdated(R)) {
              var ue, pe = this.getSelectedColor(!0) || (ue = this.getLayer()) && ue.getSelectedColor(!0), P = r.appended(this.getGlobalMatrix(!0)), q = f / 2;
              if (e.strokeStyle = e.fillStyle = pe ? pe.toCanvasStyle(e) : "#009dec", j && this._drawSelected(e, P, C), X) {
                var K = this.getPosition(!0), ye = this._parent, te = ye ? ye.localToGlobal(K) : K, he = te.x, D = te.y;
                e.beginPath(), e.arc(he, D, q, 0, Math.PI * 2, !0), e.stroke();
                for (var Se = [[0, -1], [1, 0], [0, 1], [-1, 0]], le = q, v = f + 1, se = 0; se < 4; se++) {
                  var me = Se[se], O = me[0], ce = me[1];
                  e.moveTo(he + O * le, D + ce * le), e.lineTo(he + O * v, D + ce * v), e.stroke();
                }
              }
              if (H) {
                var Oe = P._transformCorners(this.getInternalBounds());
                e.beginPath();
                for (var se = 0; se < 8; se++)
                  e[se ? "lineTo" : "moveTo"](Oe[se], Oe[++se]);
                e.closePath(), e.stroke();
                for (var se = 0; se < 8; se++)
                  e.fillRect(
                    Oe[se] - q,
                    Oe[++se] - q,
                    f,
                    f
                  );
              }
            }
          },
          _canComposite: function() {
            return !1;
          }
        },
        _.each(["down", "drag", "up", "move"], function(e) {
          this["removeOn" + _.capitalize(e)] = function() {
            var r = {};
            return r[e] = !0, this.removeOn(r);
          };
        }, {
          removeOn: function(e) {
            for (var r in e)
              if (e[r]) {
                var f = "mouse" + r, C = this._project, R = C._removeSets = C._removeSets || {};
                R[f] = R[f] || {}, R[f][this._id] = this;
              }
            return this;
          }
        }),
        {
          tween: function(e, r, f) {
            f || (f = r, r = e, e = null, f || (f = r, r = null));
            var C = f && f.easing, R = f && f.start, B = f != null && (typeof f == "number" ? f : f.duration), j = new re(this, e, r, B, C, R);
            function H(X) {
              j._handleFrame(X.time * 1e3), j.running || this.off("frame", H);
            }
            return B && this.on("frame", H), j;
          },
          tweenTo: function(e, r) {
            return this.tween(null, e, r);
          },
          tweenFrom: function(e, r) {
            return this.tween(e, null, r);
          }
        }
      ), A = o.extend({
        _class: "Group",
        _selectBounds: !1,
        _selectChildren: !0,
        _serializeFields: {
          children: []
        },
        initialize: function(r) {
          this._children = [], this._namedChildren = {}, this._initialize(r) || this.addChildren(Array.isArray(r) ? r : arguments);
        },
        _changed: function e(r) {
          e.base.call(this, r), r & 2050 && (this._clipItem = ae);
        },
        _getClipItem: function() {
          var e = this._clipItem;
          if (e === ae) {
            e = null;
            for (var r = this._children, f = 0, C = r.length; f < C; f++)
              if (r[f]._clipMask) {
                e = r[f];
                break;
              }
            this._clipItem = e;
          }
          return e;
        },
        isClipped: function() {
          return !!this._getClipItem();
        },
        setClipped: function(e) {
          var r = this.getFirstChild();
          r && r.setClipMask(e);
        },
        _getBounds: function e(r, f) {
          var C = this._getClipItem();
          return C ? C._getCachedBounds(
            C._matrix.prepended(r),
            _.set({}, f, { stroke: !1 })
          ) : e.base.call(this, r, f);
        },
        _hitTestChildren: function e(r, f, C) {
          var R = this._getClipItem();
          return (!R || R.contains(r)) && e.base.call(
            this,
            r,
            f,
            C,
            R
          );
        },
        _draw: function(e, r) {
          var f = r.clip, C = !f && this._getClipItem();
          r = r.extend({ clipItem: C, clip: !1 }), f ? (e.beginPath(), r.dontStart = r.dontFinish = !0) : C && C.draw(e, r.extend({ clip: !0 }));
          for (var R = this._children, B = 0, j = R.length; B < j; B++) {
            var H = R[B];
            H !== C && H.draw(e, r);
          }
        }
      }), T = A.extend({
        _class: "Layer",
        initialize: function() {
          A.apply(this, arguments);
        },
        _getOwner: function() {
          return this._parent || this._index != null && this._project;
        },
        isInserted: function e() {
          return this._parent ? e.base.call(this) : this._index != null;
        },
        activate: function() {
          this._project._activeLayer = this;
        },
        _hitTestSelf: function() {
        }
      }), I = o.extend(
        {
          _class: "Shape",
          _applyMatrix: !1,
          _canApplyMatrix: !1,
          _canScaleStroke: !0,
          _serializeFields: {
            type: null,
            size: null,
            radius: null
          },
          initialize: function(r, f) {
            this._initialize(r, f);
          },
          _equals: function(e) {
            return this._type === e._type && this._size.equals(e._size) && _.equals(this._radius, e._radius);
          },
          copyContent: function(e) {
            this.setType(e._type), this.setSize(e._size), this.setRadius(e._radius);
          },
          getType: function() {
            return this._type;
          },
          setType: function(e) {
            this._type = e;
          },
          getShape: "#getType",
          setShape: "#setType",
          getSize: function() {
            var e = this._size;
            return new g(e.width, e.height, this, "setSize");
          },
          setSize: function() {
            var e = d.read(arguments);
            if (!this._size)
              this._size = e.clone();
            else if (!this._size.equals(e)) {
              var r = this._type, f = e.width, C = e.height;
              r === "rectangle" ? this._radius.set(d.min(this._radius, e.divide(2).abs())) : r === "circle" ? (f = C = (f + C) / 2, this._radius = f / 2) : r === "ellipse" && this._radius._set(f / 2, C / 2), this._size._set(f, C), this._changed(9);
            }
          },
          getRadius: function() {
            var e = this._radius;
            return this._type === "circle" ? e : new g(e.width, e.height, this, "setRadius");
          },
          setRadius: function(e) {
            var r = this._type;
            if (r === "circle") {
              if (e === this._radius)
                return;
              var f = e * 2;
              this._radius = e, this._size._set(f, f);
            } else if (e = d.read(arguments), !this._radius)
              this._radius = e.clone();
            else {
              if (this._radius.equals(e))
                return;
              if (this._radius.set(e), r === "rectangle") {
                var f = d.max(this._size, e.multiply(2));
                this._size.set(f);
              } else r === "ellipse" && this._size._set(e.width * 2, e.height * 2);
            }
            this._changed(9);
          },
          isEmpty: function() {
            return !1;
          },
          toPath: function(e) {
            var r = new Q[_.capitalize(this._type)]({
              center: new a(),
              size: this._size,
              radius: this._radius,
              insert: !1
            });
            return r.copyAttributes(this), Ae.settings.applyMatrix && r.setApplyMatrix(!0), (e === ae || e) && r.insertAbove(this), r;
          },
          toShape: "#clone",
          _asPathItem: function() {
            return this.toPath(!1);
          },
          _draw: function(e, r, f, C) {
            var R = this._style, B = R.hasFill(), j = R.hasStroke(), H = r.dontFinish || r.clip, X = !C;
            if (B || j || H) {
              var ue = this._type, pe = this._radius, P = ue === "circle";
              if (r.dontStart || e.beginPath(), X && P)
                e.arc(0, 0, pe, 0, Math.PI * 2, !0);
              else {
                var q = P ? pe : pe.width, K = P ? pe : pe.height, ye = this._size, te = ye.width, he = ye.height;
                if (X && ue === "rectangle" && q === 0 && K === 0)
                  e.rect(-te / 2, -he / 2, te, he);
                else {
                  var D = te / 2, Se = he / 2, le = 1 - 0.5522847498307936, v = q * le, se = K * le, me = [
                    -D,
                    -Se + K,
                    -D,
                    -Se + se,
                    -D + v,
                    -Se,
                    -D + q,
                    -Se,
                    D - q,
                    -Se,
                    D - v,
                    -Se,
                    D,
                    -Se + se,
                    D,
                    -Se + K,
                    D,
                    Se - K,
                    D,
                    Se - se,
                    D - v,
                    Se,
                    D - q,
                    Se,
                    -D + q,
                    Se,
                    -D + v,
                    Se,
                    -D,
                    Se - se,
                    -D,
                    Se - K
                  ];
                  C && C.transform(me, me, 32), e.moveTo(me[0], me[1]), e.bezierCurveTo(me[2], me[3], me[4], me[5], me[6], me[7]), D !== q && e.lineTo(me[8], me[9]), e.bezierCurveTo(me[10], me[11], me[12], me[13], me[14], me[15]), Se !== K && e.lineTo(me[16], me[17]), e.bezierCurveTo(me[18], me[19], me[20], me[21], me[22], me[23]), D !== q && e.lineTo(me[24], me[25]), e.bezierCurveTo(me[26], me[27], me[28], me[29], me[30], me[31]);
                }
              }
              e.closePath();
            }
            !H && (B || j) && (this._setStyles(e, r, f), B && (e.fill(R.getFillRule()), e.shadowColor = "rgba(0,0,0,0)"), j && e.stroke());
          },
          _canComposite: function() {
            return !(this.hasFill() && this.hasStroke());
          },
          _getBounds: function(e, r) {
            var f = new h(this._size).setCenter(0, 0), C = this._style, R = r.stroke && C.hasStroke() && C.getStrokeWidth();
            return e && (f = e._transformBounds(f)), R ? f.expand(Q._getStrokePadding(
              R,
              this._getStrokeMatrix(e, r)
            )) : f;
          }
        },
        new function() {
          function e(f, C, R) {
            var B = f._radius;
            if (!B.isZero())
              for (var j = f._size.divide(2), H = 1; H <= 4; H++) {
                var X = new a(H > 1 && H < 4 ? -1 : 1, H > 2 ? -1 : 1), ue = X.multiply(j), pe = ue.subtract(X.multiply(B)), P = new h(
                  R ? ue.add(X.multiply(R)) : ue,
                  pe
                );
                if (P.contains(C))
                  return { point: pe, quadrant: H };
              }
          }
          function r(f, C, R, B) {
            var j = f.divide(C);
            return (!B || j.isInQuadrant(B)) && j.subtract(j.normalize()).multiply(C).divide(R).length <= 1;
          }
          return {
            _contains: function f(C) {
              if (this._type === "rectangle") {
                var R = e(this, C);
                return R ? C.subtract(R.point).divide(this._radius).getLength() <= 1 : f.base.call(this, C);
              } else
                return C.divide(this.size).getLength() <= 0.5;
            },
            _hitTestSelf: function f(C, R, B, j) {
              var H = !1, X = this._style, ue = R.stroke && X.hasStroke(), pe = R.fill && X.hasFill();
              if (ue || pe) {
                var P = this._type, q = this._radius, K = ue ? X.getStrokeWidth() / 2 : 0, ye = R._tolerancePadding.add(
                  Q._getStrokePadding(
                    K,
                    !X.getStrokeScaling() && j
                  )
                );
                if (P === "rectangle") {
                  var te = ye.multiply(2), he = e(this, C, te);
                  if (he)
                    H = r(
                      C.subtract(he.point),
                      q,
                      ye,
                      he.quadrant
                    );
                  else {
                    var D = new h(this._size).setCenter(0, 0), Se = D.expand(te), le = D.expand(te.negate());
                    H = Se._containsPoint(C) && !le._containsPoint(C);
                  }
                } else
                  H = r(C, q, ye);
              }
              return H ? new J(ue ? "stroke" : "fill", this) : f.base.apply(this, arguments);
            }
          };
        }(),
        {
          statics: new function() {
            function e(r, f, C, R, B) {
              var j = _.create(I.prototype);
              return j._type = r, j._size = C, j._radius = R, j._initialize(_.getNamed(B), f), j;
            }
            return {
              Circle: function() {
                var r = arguments, f = a.readNamed(r, "center"), C = _.readNamed(r, "radius");
                return e(
                  "circle",
                  f,
                  new d(C * 2),
                  C,
                  r
                );
              },
              Rectangle: function() {
                var r = arguments, f = h.readNamed(r, "rectangle"), C = d.min(
                  d.readNamed(r, "radius"),
                  f.getSize(!0).divide(2)
                );
                return e(
                  "rectangle",
                  f.getCenter(!0),
                  f.getSize(!0),
                  C,
                  r
                );
              },
              Ellipse: function() {
                var r = arguments, f = I._readEllipse(r), C = f.radius;
                return e(
                  "ellipse",
                  f.center,
                  C.multiply(2),
                  C,
                  r
                );
              },
              _readEllipse: function(r) {
                var f, C;
                if (_.hasNamed(r, "radius"))
                  f = a.readNamed(r, "center"), C = d.readNamed(r, "radius");
                else {
                  var R = h.readNamed(r, "rectangle");
                  f = R.getCenter(!0), C = R.getSize(!0).divide(2);
                }
                return { center: f, radius: C };
              }
            };
          }()
        }
      ), L = o.extend({
        _class: "Raster",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _boundsOptions: { stroke: !1, handle: !1 },
        _serializeFields: {
          crossOrigin: null,
          source: null
        },
        _prioritize: ["crossOrigin"],
        _smoothing: "low",
        beans: !0,
        initialize: function(r, f) {
          if (!this._initialize(
            r,
            f !== ae && a.read(arguments)
          )) {
            var C, R = typeof r, B = R === "string" ? Z.getElementById(r) : R === "object" ? r : null;
            if (B && B !== o.NO_INSERT) {
              if (B.getContext || B.naturalHeight != null)
                C = B;
              else if (B) {
                var j = d.read(arguments);
                j.isZero() || (C = Ce.getCanvas(j));
              }
            }
            C ? this.setImage(C) : this.setSource(r);
          }
          this._size || (this._size = new d(), this._loaded = !1);
        },
        _equals: function(e) {
          return this.getSource() === e.getSource();
        },
        copyContent: function(e) {
          var r = e._image, f = e._canvas;
          if (r)
            this._setImage(r);
          else if (f) {
            var C = Ce.getCanvas(e._size);
            C.getContext("2d").drawImage(f, 0, 0), this._setImage(C);
          }
          this._crossOrigin = e._crossOrigin;
        },
        getSize: function() {
          var e = this._size;
          return new g(
            e ? e.width : 0,
            e ? e.height : 0,
            this,
            "setSize"
          );
        },
        setSize: function(e, r) {
          var f = d.read(arguments);
          if (f.equals(this._size))
            r && this.clear();
          else if (f.width > 0 && f.height > 0) {
            var C = !r && this.getElement();
            this._setImage(Ce.getCanvas(f)), C && this.getContext(!0).drawImage(
              C,
              0,
              0,
              f.width,
              f.height
            );
          } else
            this._canvas && Ce.release(this._canvas), this._size = f.clone();
        },
        getWidth: function() {
          return this._size ? this._size.width : 0;
        },
        setWidth: function(e) {
          this.setSize(e, this.getHeight());
        },
        getHeight: function() {
          return this._size ? this._size.height : 0;
        },
        setHeight: function(e) {
          this.setSize(this.getWidth(), e);
        },
        getLoaded: function() {
          return this._loaded;
        },
        isEmpty: function() {
          var e = this._size;
          return !e || e.width === 0 && e.height === 0;
        },
        getResolution: function() {
          var e = this._matrix, r = new a(0, 0).transform(e), f = new a(1, 0).transform(e).subtract(r), C = new a(0, 1).transform(e).subtract(r);
          return new d(
            72 / f.getLength(),
            72 / C.getLength()
          );
        },
        getPpi: "#getResolution",
        getImage: function() {
          return this._image;
        },
        setImage: function(e) {
          var r = this;
          function f(C) {
            var R = r.getView(), B = C && C.type || "load";
            R && r.responds(B) && (Ae = R._scope, r.emit(B, new Ve(C)));
          }
          this._setImage(e), this._loaded ? setTimeout(f, 0) : e && We.add(e, {
            load: function(C) {
              r._setImage(e), f(C);
            },
            error: f
          });
        },
        _setImage: function(e) {
          this._canvas && Ce.release(this._canvas), e && e.getContext ? (this._image = null, this._canvas = e, this._loaded = !0) : (this._image = e, this._canvas = null, this._loaded = !!(e && e.src && e.complete)), this._size = new d(
            e ? e.naturalWidth || e.width : 0,
            e ? e.naturalHeight || e.height : 0
          ), this._context = null, this._changed(1033);
        },
        getCanvas: function() {
          if (!this._canvas) {
            var e = Ce.getContext(this._size);
            try {
              this._image && e.drawImage(this._image, 0, 0), this._canvas = e.canvas;
            } catch {
              Ce.release(e);
            }
          }
          return this._canvas;
        },
        setCanvas: "#setImage",
        getContext: function(e) {
          return this._context || (this._context = this.getCanvas().getContext("2d")), e && (this._image = null, this._changed(1025)), this._context;
        },
        setContext: function(e) {
          this._context = e;
        },
        getSource: function() {
          var e = this._image;
          return e && e.src || this.toDataURL();
        },
        setSource: function(e) {
          var r = new be.Image(), f = this._crossOrigin;
          f && (r.crossOrigin = f), e && (r.src = e), this.setImage(r);
        },
        getCrossOrigin: function() {
          var e = this._image;
          return e && e.crossOrigin || this._crossOrigin || "";
        },
        setCrossOrigin: function(e) {
          this._crossOrigin = e;
          var r = this._image;
          r && (r.crossOrigin = e);
        },
        getSmoothing: function() {
          return this._smoothing;
        },
        setSmoothing: function(e) {
          this._smoothing = typeof e == "string" ? e : e ? "low" : "off", this._changed(257);
        },
        getElement: function() {
          return this._canvas || this._loaded && this._image;
        }
      }, {
        beans: !1,
        getSubCanvas: function() {
          var e = h.read(arguments), r = Ce.getContext(e.getSize());
          return r.drawImage(
            this.getCanvas(),
            e.x,
            e.y,
            e.width,
            e.height,
            0,
            0,
            e.width,
            e.height
          ), r.canvas;
        },
        getSubRaster: function() {
          var e = h.read(arguments), r = new L(o.NO_INSERT);
          return r._setImage(this.getSubCanvas(e)), r.translate(e.getCenter().subtract(this.getSize().divide(2))), r._matrix.prepend(this._matrix), r.insertAbove(this), r;
        },
        toDataURL: function() {
          var e = this._image, r = e && e.src;
          if (/^data:/.test(r))
            return r;
          var f = this.getCanvas();
          return f ? f.toDataURL.apply(f, arguments) : null;
        },
        drawImage: function(e) {
          var r = a.read(arguments, 1);
          this.getContext(!0).drawImage(e, r.x, r.y);
        },
        getAverageColor: function(e) {
          var r, f;
          if (e ? e instanceof W ? (f = e, r = e.getBounds()) : typeof e == "object" && ("width" in e ? r = new h(e) : "x" in e && (r = new h(e.x - 0.5, e.y - 0.5, 1, 1))) : r = this.getBounds(), !r)
            return null;
          var C = 32, R = Math.min(r.width, C), B = Math.min(r.height, C), j = L._sampleContext;
          j ? j.clearRect(0, 0, C + 1, C + 1) : j = L._sampleContext = Ce.getContext(
            new d(C)
          ), j.save();
          var H = new s().scale(R / r.width, B / r.height).translate(-r.x, -r.y);
          H.applyToContext(j), f && f.draw(j, new _({ clip: !0, matrices: [H] })), this._matrix.applyToContext(j);
          var X = this.getElement(), ue = this._size;
          X && j.drawImage(X, -ue.width / 2, -ue.height / 2), j.restore();
          for (var pe = j.getImageData(
            0.5,
            0.5,
            Math.ceil(R),
            Math.ceil(B)
          ).data, P = [0, 0, 0], q = 0, K = 0, ye = pe.length; K < ye; K += 4) {
            var te = pe[K + 3];
            q += te, te /= 255, P[0] += pe[K] * te, P[1] += pe[K + 1] * te, P[2] += pe[K + 2] * te;
          }
          for (var K = 0; K < 3; K++)
            P[K] /= q;
          return q ? xe.read(P) : null;
        },
        getPixel: function() {
          var e = a.read(arguments), r = this.getContext().getImageData(e.x, e.y, 1, 1).data;
          return new xe(
            "rgb",
            [r[0] / 255, r[1] / 255, r[2] / 255],
            r[3] / 255
          );
        },
        setPixel: function() {
          var e = arguments, r = a.read(e), f = xe.read(e), C = f._convert("rgb"), R = f._alpha, B = this.getContext(!0), j = B.createImageData(1, 1), H = j.data;
          H[0] = C[0] * 255, H[1] = C[1] * 255, H[2] = C[2] * 255, H[3] = R != null ? R * 255 : 255, B.putImageData(j, r.x, r.y);
        },
        clear: function() {
          var e = this._size;
          this.getContext(!0).clearRect(0, 0, e.width + 1, e.height + 1);
        },
        createImageData: function() {
          var e = d.read(arguments);
          return this.getContext().createImageData(e.width, e.height);
        },
        getImageData: function() {
          var e = h.read(arguments);
          return e.isEmpty() && (e = new h(this._size)), this.getContext().getImageData(
            e.x,
            e.y,
            e.width,
            e.height
          );
        },
        putImageData: function(e) {
          var r = a.read(arguments, 1);
          this.getContext(!0).putImageData(e, r.x, r.y);
        },
        setImageData: function(e) {
          this.setSize(e), this.getContext(!0).putImageData(e, 0, 0);
        },
        _getBounds: function(e, r) {
          var f = new h(this._size).setCenter(0, 0);
          return e ? e._transformBounds(f) : f;
        },
        _hitTestSelf: function(e) {
          if (this._contains(e)) {
            var r = this;
            return new J("pixel", r, {
              offset: e.add(r._size.divide(2)).round(),
              color: {
                get: function() {
                  return r.getPixel(this.offset);
                }
              }
            });
          }
        },
        _draw: function(e, r, f) {
          var C = this.getElement();
          if (C && C.width > 0 && C.height > 0) {
            e.globalAlpha = u.clamp(this._opacity, 0, 1), this._setStyles(e, r, f);
            var R = this._smoothing, B = R === "off";
            He.setPrefixed(
              e,
              B ? "imageSmoothingEnabled" : "imageSmoothingQuality",
              B ? !1 : R
            ), e.drawImage(
              C,
              -this._size.width / 2,
              -this._size.height / 2
            );
          }
        },
        _canComposite: function() {
          return !0;
        }
      }), z = o.extend({
        _class: "SymbolItem",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _boundsOptions: { stroke: !0 },
        _serializeFields: {
          symbol: null
        },
        initialize: function(r, f) {
          this._initialize(
            r,
            f !== ae && a.read(arguments, 1)
          ) || this.setDefinition(r instanceof U ? r : new U(r));
        },
        _equals: function(e) {
          return this._definition === e._definition;
        },
        copyContent: function(e) {
          this.setDefinition(e._definition);
        },
        getDefinition: function() {
          return this._definition;
        },
        setDefinition: function(e) {
          this._definition = e, this._changed(9);
        },
        getSymbol: "#getDefinition",
        setSymbol: "#setDefinition",
        isEmpty: function() {
          return this._definition._item.isEmpty();
        },
        _getBounds: function(e, r) {
          var f = this._definition._item;
          return f._getCachedBounds(f._matrix.prepended(e), r);
        },
        _hitTestSelf: function(e, r, f) {
          var C = r.extend({ all: !1 }), R = this._definition._item._hitTest(e, C, f);
          return R && (R.item = this), R;
        },
        _draw: function(e, r) {
          this._definition._item.draw(e, r);
        }
      }), U = _.extend({
        _class: "SymbolDefinition",
        initialize: function(r, f) {
          this._id = l.get(), this.project = Ae.project, r && this.setItem(r, f);
        },
        _serialize: function(e, r) {
          return r.add(this, function() {
            return _.serialize(
              [this._class, this._item],
              e,
              !1,
              r
            );
          });
        },
        _changed: function(e) {
          e & 8 && o._clearBoundsCache(this), e & 1 && this.project._changed(e);
        },
        getItem: function() {
          return this._item;
        },
        setItem: function(e, r) {
          e._symbol && (e = e.clone()), this._item && (this._item._symbol = null), this._item = e, e.remove(), e.setSelected(!1), r || e.setPosition(new a()), e._symbol = this, this._changed(9);
        },
        getDefinition: "#getItem",
        setDefinition: "#setItem",
        place: function(e) {
          return new z(this, e);
        },
        clone: function() {
          return new U(this._item.clone(!1));
        },
        equals: function(e) {
          return e === this || e && this._item.equals(e._item) || !1;
        }
      }), J = _.extend({
        _class: "HitResult",
        initialize: function(r, f, C) {
          this.type = r, this.item = f, C && this.inject(C);
        },
        statics: {
          getOptions: function(e) {
            var r = e && _.read(e);
            return new _({
              type: null,
              tolerance: Ae.settings.hitTolerance,
              fill: !r,
              stroke: !r,
              segments: !r,
              handles: !1,
              ends: !1,
              position: !1,
              center: !1,
              bounds: !1,
              guides: !1,
              selected: !1
            }, r);
          }
        }
      }), F = _.extend({
        _class: "Segment",
        beans: !0,
        _selection: 0,
        initialize: function(r, f, C, R, B, j) {
          var H = arguments.length, X, ue, pe, P;
          H > 0 && (r == null || typeof r == "object" ? H === 1 && r && "point" in r ? (X = r.point, ue = r.handleIn, pe = r.handleOut, P = r.selection) : (X = r, ue = f, pe = C, P = R) : (X = [r, f], ue = C !== ae ? [C, R] : null, pe = B !== ae ? [B, j] : null)), new oe(X, this, "_point"), new oe(ue, this, "_handleIn"), new oe(pe, this, "_handleOut"), P && this.setSelection(P);
        },
        _serialize: function(e, r) {
          var f = this._point, C = this._selection, R = C || this.hasHandles() ? [f, this._handleIn, this._handleOut] : f;
          return C && R.push(C), _.serialize(R, e, !0, r);
        },
        _changed: function(e) {
          var r = this._path;
          if (r) {
            var f = r._curves, C = this._index, R;
            f && ((!e || e === this._point || e === this._handleIn) && (R = C > 0 ? f[C - 1] : r._closed ? f[f.length - 1] : null) && R._changed(), (!e || e === this._point || e === this._handleOut) && (R = f[C]) && R._changed()), r._changed(41);
          }
        },
        getPoint: function() {
          return this._point;
        },
        setPoint: function() {
          this._point.set(a.read(arguments));
        },
        getHandleIn: function() {
          return this._handleIn;
        },
        setHandleIn: function() {
          this._handleIn.set(a.read(arguments));
        },
        getHandleOut: function() {
          return this._handleOut;
        },
        setHandleOut: function() {
          this._handleOut.set(a.read(arguments));
        },
        hasHandles: function() {
          return !this._handleIn.isZero() || !this._handleOut.isZero();
        },
        isSmooth: function() {
          var e = this._handleIn, r = this._handleOut;
          return !e.isZero() && !r.isZero() && e.isCollinear(r);
        },
        clearHandles: function() {
          this._handleIn._set(0, 0), this._handleOut._set(0, 0);
        },
        getSelection: function() {
          return this._selection;
        },
        setSelection: function(e) {
          var r = this._selection, f = this._path;
          this._selection = e = e || 0, f && e !== r && (f._updateSelection(this, r, e), f._changed(257));
        },
        _changeSelection: function(e, r) {
          var f = this._selection;
          this.setSelection(r ? f | e : f & ~e);
        },
        isSelected: function() {
          return !!(this._selection & 7);
        },
        setSelected: function(e) {
          this._changeSelection(7, e);
        },
        getIndex: function() {
          return this._index !== ae ? this._index : null;
        },
        getPath: function() {
          return this._path || null;
        },
        getCurve: function() {
          var e = this._path, r = this._index;
          return e ? (r > 0 && !e._closed && r === e._segments.length - 1 && r--, e.getCurves()[r] || null) : null;
        },
        getLocation: function() {
          var e = this.getCurve();
          return e ? new ie(e, this === e._segment1 ? 0 : 1) : null;
        },
        getNext: function() {
          var e = this._path && this._path._segments;
          return e && (e[this._index + 1] || this._path._closed && e[0]) || null;
        },
        smooth: function(e, r, f) {
          var C = e || {}, R = C.type, B = C.factor, j = this.getPrevious(), H = this.getNext(), X = (j || this)._point, ue = this._point, pe = (H || this)._point, P = X.getDistance(ue), q = ue.getDistance(pe);
          if (!R || R === "catmull-rom") {
            var K = B === ae ? 0.5 : B, ye = Math.pow(P, K), te = ye * ye, he = Math.pow(q, K), D = he * he;
            if (!r && j) {
              var Se = 2 * D + 3 * he * ye + te, le = 3 * he * (he + ye);
              this.setHandleIn(le !== 0 ? new a(
                (D * X._x + Se * ue._x - te * pe._x) / le - ue._x,
                (D * X._y + Se * ue._y - te * pe._y) / le - ue._y
              ) : new a());
            }
            if (!f && H) {
              var Se = 2 * te + 3 * ye * he + D, le = 3 * ye * (ye + he);
              this.setHandleOut(le !== 0 ? new a(
                (te * pe._x + Se * ue._x - D * X._x) / le - ue._x,
                (te * pe._y + Se * ue._y - D * X._y) / le - ue._y
              ) : new a());
            }
          } else if (R === "geometric") {
            if (j && H) {
              var v = X.subtract(pe), se = B === ae ? 0.4 : B, me = se * P / (P + q);
              r || this.setHandleIn(v.multiply(me)), f || this.setHandleOut(v.multiply(me - se));
            }
          } else
            throw new Error("Smoothing method '" + R + "' not supported.");
        },
        getPrevious: function() {
          var e = this._path && this._path._segments;
          return e && (e[this._index - 1] || this._path._closed && e[e.length - 1]) || null;
        },
        isFirst: function() {
          return !this._index;
        },
        isLast: function() {
          var e = this._path;
          return e && this._index === e._segments.length - 1 || !1;
        },
        reverse: function() {
          var e = this._handleIn, r = this._handleOut, f = e.clone();
          e.set(r), r.set(f);
        },
        reversed: function() {
          return new F(this._point, this._handleOut, this._handleIn);
        },
        remove: function() {
          return this._path ? !!this._path.removeSegment(this._index) : !1;
        },
        clone: function() {
          return new F(this._point, this._handleIn, this._handleOut);
        },
        equals: function(e) {
          return e === this || e && this._class === e._class && this._point.equals(e._point) && this._handleIn.equals(e._handleIn) && this._handleOut.equals(e._handleOut) || !1;
        },
        toString: function() {
          var e = ["point: " + this._point];
          return this._handleIn.isZero() || e.push("handleIn: " + this._handleIn), this._handleOut.isZero() || e.push("handleOut: " + this._handleOut), "{ " + e.join(", ") + " }";
        },
        transform: function(e) {
          this._transformCoordinates(e, new Array(6), !0), this._changed();
        },
        interpolate: function(e, r, f) {
          var C = 1 - f, R = f, B = e._point, j = r._point, H = e._handleIn, X = r._handleIn, ue = r._handleOut, pe = e._handleOut;
          this._point._set(
            C * B._x + R * j._x,
            C * B._y + R * j._y,
            !0
          ), this._handleIn._set(
            C * H._x + R * X._x,
            C * H._y + R * X._y,
            !0
          ), this._handleOut._set(
            C * pe._x + R * ue._x,
            C * pe._y + R * ue._y,
            !0
          ), this._changed();
        },
        _transformCoordinates: function(e, r, f) {
          var C = this._point, R = !f || !this._handleIn.isZero() ? this._handleIn : null, B = !f || !this._handleOut.isZero() ? this._handleOut : null, j = C._x, H = C._y, X = 2;
          return r[0] = j, r[1] = H, R && (r[X++] = R._x + j, r[X++] = R._y + H), B && (r[X++] = B._x + j, r[X++] = B._y + H), e && (e._transformCoordinates(r, r, X / 2), j = r[0], H = r[1], f ? (C._x = j, C._y = H, X = 2, R && (R._x = r[X++] - j, R._y = r[X++] - H), B && (B._x = r[X++] - j, B._y = r[X++] - H)) : (R || (r[X++] = j, r[X++] = H), B || (r[X++] = j, r[X++] = H))), r;
        }
      }), oe = a.extend({
        initialize: function(r, f, C) {
          var R, B, j;
          if (!r)
            R = B = 0;
          else if ((R = r[0]) !== ae)
            B = r[1];
          else {
            var H = r;
            (R = H.x) === ae && (H = a.read(arguments), R = H.x), B = H.y, j = H.selected;
          }
          this._x = R, this._y = B, this._owner = f, f[C] = this, j && this.setSelected(!0);
        },
        _set: function(e, r) {
          return this._x = e, this._y = r, this._owner._changed(this), this;
        },
        getX: function() {
          return this._x;
        },
        setX: function(e) {
          this._x = e, this._owner._changed(this);
        },
        getY: function() {
          return this._y;
        },
        setY: function(e) {
          this._y = e, this._owner._changed(this);
        },
        isZero: function() {
          var e = u.isZero;
          return e(this._x) && e(this._y);
        },
        isSelected: function() {
          return !!(this._owner._selection & this._getSelection());
        },
        setSelected: function(e) {
          this._owner._changeSelection(this._getSelection(), e);
        },
        _getSelection: function() {
          var e = this._owner;
          return this === e._point ? 1 : this === e._handleIn ? 2 : this === e._handleOut ? 4 : 0;
        }
      }), ee = _.extend(
        {
          _class: "Curve",
          beans: !0,
          initialize: function(r, f, C, R, B, j, H, X) {
            var ue = arguments.length, pe, P, q, K, ye, te;
            ue === 3 ? (this._path = r, pe = f, P = C) : ue ? ue === 1 ? "segment1" in r ? (pe = new F(r.segment1), P = new F(r.segment2)) : "point1" in r ? (q = r.point1, ye = r.handle1, te = r.handle2, K = r.point2) : Array.isArray(r) && (q = [r[0], r[1]], K = [r[6], r[7]], ye = [r[2] - r[0], r[3] - r[1]], te = [r[4] - r[6], r[5] - r[7]]) : ue === 2 ? (pe = new F(r), P = new F(f)) : ue === 4 ? (q = r, ye = f, te = C, K = R) : ue === 8 && (q = [r, f], K = [H, X], ye = [C - r, R - f], te = [B - H, j - X]) : (pe = new F(), P = new F()), this._segment1 = pe || new F(q, null, ye), this._segment2 = P || new F(K, te, null);
          },
          _serialize: function(e, r) {
            return _.serialize(
              this.hasHandles() ? [
                this.getPoint1(),
                this.getHandle1(),
                this.getHandle2(),
                this.getPoint2()
              ] : [this.getPoint1(), this.getPoint2()],
              e,
              !0,
              r
            );
          },
          _changed: function() {
            this._length = this._bounds = ae;
          },
          clone: function() {
            return new ee(this._segment1, this._segment2);
          },
          toString: function() {
            var e = ["point1: " + this._segment1._point];
            return this._segment1._handleOut.isZero() || e.push("handle1: " + this._segment1._handleOut), this._segment2._handleIn.isZero() || e.push("handle2: " + this._segment2._handleIn), e.push("point2: " + this._segment2._point), "{ " + e.join(", ") + " }";
          },
          classify: function() {
            return ee.classify(this.getValues());
          },
          remove: function() {
            var e = !1;
            if (this._path) {
              var r = this._segment2, f = r._handleOut;
              e = r.remove(), e && this._segment1._handleOut.set(f);
            }
            return e;
          },
          getPoint1: function() {
            return this._segment1._point;
          },
          setPoint1: function() {
            this._segment1._point.set(a.read(arguments));
          },
          getPoint2: function() {
            return this._segment2._point;
          },
          setPoint2: function() {
            this._segment2._point.set(a.read(arguments));
          },
          getHandle1: function() {
            return this._segment1._handleOut;
          },
          setHandle1: function() {
            this._segment1._handleOut.set(a.read(arguments));
          },
          getHandle2: function() {
            return this._segment2._handleIn;
          },
          setHandle2: function() {
            this._segment2._handleIn.set(a.read(arguments));
          },
          getSegment1: function() {
            return this._segment1;
          },
          getSegment2: function() {
            return this._segment2;
          },
          getPath: function() {
            return this._path;
          },
          getIndex: function() {
            return this._segment1._index;
          },
          getNext: function() {
            var e = this._path && this._path._curves;
            return e && (e[this._segment1._index + 1] || this._path._closed && e[0]) || null;
          },
          getPrevious: function() {
            var e = this._path && this._path._curves;
            return e && (e[this._segment1._index - 1] || this._path._closed && e[e.length - 1]) || null;
          },
          isFirst: function() {
            return !this._segment1._index;
          },
          isLast: function() {
            var e = this._path;
            return e && this._segment1._index === e._curves.length - 1 || !1;
          },
          isSelected: function() {
            return this.getPoint1().isSelected() && this.getHandle1().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();
          },
          setSelected: function(e) {
            this.getPoint1().setSelected(e), this.getHandle1().setSelected(e), this.getHandle2().setSelected(e), this.getPoint2().setSelected(e);
          },
          getValues: function(e) {
            return ee.getValues(this._segment1, this._segment2, e);
          },
          getPoints: function() {
            for (var e = this.getValues(), r = [], f = 0; f < 8; f += 2)
              r.push(new a(e[f], e[f + 1]));
            return r;
          }
        },
        {
          getLength: function() {
            return this._length == null && (this._length = ee.getLength(this.getValues(), 0, 1)), this._length;
          },
          getArea: function() {
            return ee.getArea(this.getValues());
          },
          getLine: function() {
            return new b(this._segment1._point, this._segment2._point);
          },
          getPart: function(e, r) {
            return new ee(ee.getPart(this.getValues(), e, r));
          },
          getPartLength: function(e, r) {
            return ee.getLength(this.getValues(), e, r);
          },
          divideAt: function(e) {
            return this.divideAtTime(e && e.curve === this ? e.time : this.getTimeAt(e));
          },
          divideAtTime: function(e, r) {
            var f = 1e-8, C = 1 - f, R = null;
            if (e >= f && e <= C) {
              var B = ee.subdivide(this.getValues(), e), j = B[0], H = B[1], X = r || this.hasHandles(), ue = this._segment1, pe = this._segment2, P = this._path;
              X && (ue._handleOut._set(j[2] - j[0], j[3] - j[1]), pe._handleIn._set(H[4] - H[6], H[5] - H[7]));
              var q = j[6], K = j[7], ye = new F(
                new a(q, K),
                X && new a(j[4] - q, j[5] - K),
                X && new a(H[2] - q, H[3] - K)
              );
              P ? (P.insert(ue._index + 1, ye), R = this.getNext()) : (this._segment2 = ye, this._changed(), R = new ee(ye, pe));
            }
            return R;
          },
          splitAt: function(e) {
            var r = this._path;
            return r ? r.splitAt(e) : null;
          },
          splitAtTime: function(e) {
            return this.splitAt(this.getLocationAtTime(e));
          },
          divide: function(e, r) {
            return this.divideAtTime(e === ae ? 0.5 : r ? e : this.getTimeAt(e));
          },
          split: function(e, r) {
            return this.splitAtTime(e === ae ? 0.5 : r ? e : this.getTimeAt(e));
          },
          reversed: function() {
            return new ee(this._segment2.reversed(), this._segment1.reversed());
          },
          clearHandles: function() {
            this._segment1._handleOut._set(0, 0), this._segment2._handleIn._set(0, 0);
          },
          statics: {
            getValues: function(e, r, f, C) {
              var R = e._point, B = e._handleOut, j = r._handleIn, H = r._point, X = R.x, ue = R.y, pe = H.x, P = H.y, q = C ? [X, ue, X, ue, pe, P, pe, P] : [
                X,
                ue,
                X + B._x,
                ue + B._y,
                pe + j._x,
                P + j._y,
                pe,
                P
              ];
              return f && f._transformCoordinates(q, q, 4), q;
            },
            subdivide: function(e, r) {
              var f = e[0], C = e[1], R = e[2], B = e[3], j = e[4], H = e[5], X = e[6], ue = e[7];
              r === ae && (r = 0.5);
              var pe = 1 - r, P = pe * f + r * R, q = pe * C + r * B, K = pe * R + r * j, ye = pe * B + r * H, te = pe * j + r * X, he = pe * H + r * ue, D = pe * P + r * K, Se = pe * q + r * ye, le = pe * K + r * te, v = pe * ye + r * he, se = pe * D + r * le, me = pe * Se + r * v;
              return [
                [f, C, P, q, D, Se, se, me],
                [se, me, le, v, te, he, X, ue]
              ];
            },
            getMonoCurves: function(e, r) {
              var f = [], C = r ? 0 : 1, R = e[C + 0], B = e[C + 2], j = e[C + 4], H = e[C + 6];
              if (R >= B == B >= j && B >= j == j >= H || ee.isStraight(e))
                f.push(e);
              else {
                var X = 3 * (B - j) - R + H, ue = 2 * (R + j) - 4 * B, pe = B - R, P = 1e-8, q = 1 - P, K = [], ye = u.solveQuadratic(X, ue, pe, K, P, q);
                if (!ye)
                  f.push(e);
                else {
                  K.sort();
                  var te = K[0], he = ee.subdivide(e, te);
                  f.push(he[0]), ye > 1 && (te = (K[1] - te) / (1 - te), he = ee.subdivide(he[1], te), f.push(he[0])), f.push(he[1]);
                }
              }
              return f;
            },
            solveCubic: function(e, r, f, C, R, B) {
              var j = e[r], H = e[r + 2], X = e[r + 4], ue = e[r + 6], pe = 0;
              if (!(j < f && ue < f && H < f && X < f || j > f && ue > f && H > f && X > f)) {
                var P = 3 * (H - j), q = 3 * (X - H) - P, K = ue - j - P - q;
                pe = u.solveCubic(K, q, P, j - f, C, R, B);
              }
              return pe;
            },
            getTimeOf: function(e, r) {
              var f = new a(e[0], e[1]), C = new a(e[6], e[7]), R = 1e-12, B = 1e-7, j = r.isClose(f, R) ? 0 : r.isClose(C, R) ? 1 : null;
              if (j === null)
                for (var H = [r.x, r.y], X = [], ue = 0; ue < 2; ue++)
                  for (var pe = ee.solveCubic(e, ue, H[ue], X, 0, 1), P = 0; P < pe; P++) {
                    var q = X[P];
                    if (r.isClose(ee.getPoint(e, q), B))
                      return q;
                  }
              return r.isClose(f, B) ? 0 : r.isClose(C, B) ? 1 : null;
            },
            getNearestTime: function(e, r) {
              if (ee.isStraight(e)) {
                var f = e[0], C = e[1], R = e[6], B = e[7], j = R - f, H = B - C, X = j * j + H * H;
                if (X === 0)
                  return 0;
                var ue = ((r.x - f) * j + (r.y - C) * H) / X;
                return ue < 1e-12 ? 0 : ue > 0.999999999999 ? 1 : ee.getTimeOf(
                  e,
                  new a(f + ue * j, C + ue * H)
                );
              }
              var pe = 100, P = 1 / 0, q = 0;
              function K(he) {
                if (he >= 0 && he <= 1) {
                  var D = r.getDistance(ee.getPoint(e, he), !0);
                  if (D < P)
                    return P = D, q = he, !0;
                }
              }
              for (var ye = 0; ye <= pe; ye++)
                K(ye / pe);
              for (var te = 1 / (pe * 2); te > 1e-8; )
                !K(q - te) && !K(q + te) && (te /= 2);
              return q;
            },
            getPart: function(e, r, f) {
              var C = r > f;
              if (C) {
                var R = r;
                r = f, f = R;
              }
              return r > 0 && (e = ee.subdivide(e, r)[1]), f < 1 && (e = ee.subdivide(e, (f - r) / (1 - r))[0]), C ? [e[6], e[7], e[4], e[5], e[2], e[3], e[0], e[1]] : e;
            },
            isFlatEnough: function(e, r) {
              var f = e[0], C = e[1], R = e[2], B = e[3], j = e[4], H = e[5], X = e[6], ue = e[7], pe = 3 * R - 2 * f - X, P = 3 * B - 2 * C - ue, q = 3 * j - 2 * X - f, K = 3 * H - 2 * ue - C;
              return Math.max(pe * pe, q * q) + Math.max(P * P, K * K) <= 16 * r * r;
            },
            getArea: function(e) {
              var r = e[0], f = e[1], C = e[2], R = e[3], B = e[4], j = e[5], H = e[6], X = e[7];
              return 3 * ((X - f) * (C + B) - (H - r) * (R + j) + R * (r - B) - C * (f - j) + X * (B + r / 3) - H * (j + f / 3)) / 20;
            },
            getBounds: function(e) {
              for (var r = e.slice(0, 2), f = r.slice(), C = [0, 0], R = 0; R < 2; R++)
                ee._addBounds(
                  e[R],
                  e[R + 2],
                  e[R + 4],
                  e[R + 6],
                  R,
                  0,
                  r,
                  f,
                  C
                );
              return new h(r[0], r[1], f[0] - r[0], f[1] - r[1]);
            },
            _addBounds: function(e, r, f, C, R, B, j, H, X) {
              function ue(se, me) {
                var O = se - me, ce = se + me;
                O < j[R] && (j[R] = O), ce > H[R] && (H[R] = ce);
              }
              B /= 2;
              var pe = j[R] + B, P = H[R] - B;
              if (e < pe || r < pe || f < pe || C < pe || e > P || r > P || f > P || C > P)
                if (r < e != r < C && f < e != f < C)
                  ue(e, 0), ue(C, 0);
                else {
                  var q = 3 * (r - f) - e + C, K = 2 * (e + f) - 4 * r, ye = r - e, te = u.solveQuadratic(q, K, ye, X), he = 1e-8, D = 1 - he;
                  ue(C, 0);
                  for (var Se = 0; Se < te; Se++) {
                    var le = X[Se], v = 1 - le;
                    he <= le && le <= D && ue(
                      v * v * v * e + 3 * v * v * le * r + 3 * v * le * le * f + le * le * le * C,
                      B
                    );
                  }
                }
            }
          }
        },
        _.each(
          ["getBounds", "getStrokeBounds", "getHandleBounds"],
          function(e) {
            this[e] = function() {
              this._bounds || (this._bounds = {});
              var r = this._bounds[e];
              return r || (r = this._bounds[e] = Q[e](
                [this._segment1, this._segment2],
                !1,
                this._path
              )), r.clone();
            };
          },
          {}
        ),
        _.each({
          isStraight: function(e, r, f, C) {
            if (r.isZero() && f.isZero())
              return !0;
            var R = C.subtract(e);
            if (R.isZero())
              return !1;
            if (R.isCollinear(r) && R.isCollinear(f)) {
              var B = new b(e, C), j = 1e-7;
              if (B.getDistance(e.add(r)) < j && B.getDistance(C.add(f)) < j) {
                var H = R.dot(R), X = R.dot(r) / H, ue = R.dot(f) / H;
                return X >= 0 && X <= 1 && ue <= 0 && ue >= -1;
              }
            }
            return !1;
          },
          isLinear: function(e, r, f, C) {
            var R = C.subtract(e).divide(3);
            return r.equals(R) && f.negate().equals(R);
          }
        }, function(e, r) {
          this[r] = function(f) {
            var C = this._segment1, R = this._segment2;
            return e(
              C._point,
              C._handleOut,
              R._handleIn,
              R._point,
              f
            );
          }, this.statics[r] = function(f, C) {
            var R = f[0], B = f[1], j = f[6], H = f[7];
            return e(
              new a(R, B),
              new a(f[2] - R, f[3] - B),
              new a(f[4] - j, f[5] - H),
              new a(j, H),
              C
            );
          };
        }, {
          statics: {},
          hasHandles: function() {
            return !this._segment1._handleOut.isZero() || !this._segment2._handleIn.isZero();
          },
          hasLength: function(e) {
            return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles()) && this.getLength() > (e || 0);
          },
          isCollinear: function(e) {
            return e && this.isStraight() && e.isStraight() && this.getLine().isCollinear(e.getLine());
          },
          isHorizontal: function() {
            return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y) < 1e-8;
          },
          isVertical: function() {
            return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x) < 1e-8;
          }
        }),
        {
          beans: !1,
          getLocationAt: function(e, r) {
            return this.getLocationAtTime(
              r ? e : this.getTimeAt(e)
            );
          },
          getLocationAtTime: function(e) {
            return e != null && e >= 0 && e <= 1 ? new ie(this, e) : null;
          },
          getTimeAt: function(e, r) {
            return ee.getTimeAt(this.getValues(), e, r);
          },
          getParameterAt: "#getTimeAt",
          getTimesWithTangent: function() {
            var e = a.read(arguments);
            return e.isZero() ? [] : ee.getTimesWithTangent(this.getValues(), e);
          },
          getOffsetAtTime: function(e) {
            return this.getPartLength(0, e);
          },
          getLocationOf: function() {
            return this.getLocationAtTime(this.getTimeOf(a.read(arguments)));
          },
          getOffsetOf: function() {
            var e = this.getLocationOf.apply(this, arguments);
            return e ? e.getOffset() : null;
          },
          getTimeOf: function() {
            return ee.getTimeOf(this.getValues(), a.read(arguments));
          },
          getParameterOf: "#getTimeOf",
          getNearestLocation: function() {
            var e = a.read(arguments), r = this.getValues(), f = ee.getNearestTime(r, e), C = ee.getPoint(r, f);
            return new ie(this, f, C, null, e.getDistance(C));
          },
          getNearestPoint: function() {
            var e = this.getNearestLocation.apply(this, arguments);
            return e && e.getPoint();
          }
        },
        new function() {
          var e = [
            "getPoint",
            "getTangent",
            "getNormal",
            "getWeightedTangent",
            "getWeightedNormal",
            "getCurvature"
          ];
          return _.each(
            e,
            function(r) {
              this[r + "At"] = function(f, C) {
                var R = this.getValues();
                return ee[r](R, C ? f : ee.getTimeAt(R, f));
              }, this[r + "AtTime"] = function(f) {
                return ee[r](this.getValues(), f);
              };
            },
            {
              statics: {
                _evaluateMethods: e
              }
            }
          );
        }(),
        new function() {
          function e(C) {
            var R = C[0], B = C[1], j = C[2], H = C[3], X = C[4], ue = C[5], pe = C[6], P = C[7], q = 9 * (j - X) + 3 * (pe - R), K = 6 * (R + X) - 12 * j, ye = 3 * (j - R), te = 9 * (H - ue) + 3 * (P - B), he = 6 * (B + ue) - 12 * H, D = 3 * (H - B);
            return function(Se) {
              var le = (q * Se + K) * Se + ye, v = (te * Se + he) * Se + D;
              return Math.sqrt(le * le + v * v);
            };
          }
          function r(C, R) {
            return Math.max(2, Math.min(16, Math.ceil(Math.abs(R - C) * 32)));
          }
          function f(C, R, B, j) {
            if (R == null || R < 0 || R > 1)
              return null;
            var H = C[0], X = C[1], ue = C[2], pe = C[3], P = C[4], q = C[5], K = C[6], ye = C[7], te = u.isZero;
            te(ue - H) && te(pe - X) && (ue = H, pe = X), te(P - K) && te(q - ye) && (P = K, q = ye);
            var he = 3 * (ue - H), D = 3 * (P - ue) - he, Se = K - H - he - D, le = 3 * (pe - X), v = 3 * (q - pe) - le, se = ye - X - le - v, me, O;
            if (B === 0)
              me = R === 0 ? H : R === 1 ? K : ((Se * R + D) * R + he) * R + H, O = R === 0 ? X : R === 1 ? ye : ((se * R + v) * R + le) * R + X;
            else {
              var ce = 1e-8, Oe = 1 - ce;
              if (R < ce ? (me = he, O = le) : R > Oe ? (me = 3 * (K - P), O = 3 * (ye - q)) : (me = (3 * Se * R + 2 * D) * R + he, O = (3 * se * R + 2 * v) * R + le), j) {
                me === 0 && O === 0 && (R < ce || R > Oe) && (me = P - ue, O = q - pe);
                var Be = Math.sqrt(me * me + O * O);
                Be && (me /= Be, O /= Be);
              }
              if (B === 3) {
                var P = 6 * Se * R + 2 * D, q = 6 * se * R + 2 * v, je = Math.pow(me * me + O * O, 3 / 2);
                me = je !== 0 ? (me * q - O * P) / je : 0, O = 0;
              }
            }
            return B === 2 ? new a(O, -me) : new a(me, O);
          }
          return { statics: {
            classify: function(C) {
              var R = C[0], B = C[1], j = C[2], H = C[3], X = C[4], ue = C[5], pe = C[6], P = C[7], q = R * (P - ue) + B * (X - pe) + pe * ue - P * X, K = j * (B - P) + H * (pe - R) + R * P - B * pe, ye = X * (H - B) + ue * (R - j) + j * B - H * R, te = 3 * ye, he = te - K, D = he - K + q, Se = Math.sqrt(D * D + he * he + te * te), le = Se !== 0 ? 1 / Se : 0, v = u.isZero, se = "serpentine";
              D *= le, he *= le, te *= le;
              function me(Be, je, Fe) {
                var Ye = je !== ae, Ke = Ye && je > 0 && je < 1, et = Ye && Fe > 0 && Fe < 1;
                return Ye && (!(Ke || et) || Be === "loop" && !(Ke && et)) && (Be = "arch", Ke = et = !1), {
                  type: Be,
                  roots: Ke || et ? Ke && et ? je < Fe ? [je, Fe] : [Fe, je] : [Ke ? je : Fe] : null
                };
              }
              if (v(D))
                return v(he) ? me(v(te) ? "line" : "quadratic") : me(se, te / (3 * he));
              var O = 3 * he * he - 4 * D * te;
              if (v(O))
                return me("cusp", he / (2 * D));
              var ce = O > 0 ? Math.sqrt(O / 3) : Math.sqrt(-O), Oe = 2 * D;
              return me(
                O > 0 ? se : "loop",
                (he + ce) / Oe,
                (he - ce) / Oe
              );
            },
            getLength: function(C, R, B, j) {
              if (R === ae && (R = 0), B === ae && (B = 1), ee.isStraight(C)) {
                var H = C;
                B < 1 && (H = ee.subdivide(H, B)[0], R /= B), R > 0 && (H = ee.subdivide(H, R)[1]);
                var X = H[6] - H[0], ue = H[7] - H[1];
                return Math.sqrt(X * X + ue * ue);
              }
              return u.integrate(
                j || e(C),
                R,
                B,
                r(R, B)
              );
            },
            getTimeAt: function(C, R, B) {
              if (B === ae && (B = R < 0 ? 1 : 0), R === 0)
                return B;
              var j = Math.abs, H = 1e-12, X = R > 0, ue = X ? B : 0, pe = X ? 1 : B, P = e(C), q = ee.getLength(C, ue, pe, P), K = j(R) - q;
              if (j(K) < H)
                return X ? pe : ue;
              if (K > H)
                return null;
              var ye = R / q, te = 0;
              function he(D) {
                return te += u.integrate(
                  P,
                  B,
                  D,
                  r(B, D)
                ), B = D, te - R;
              }
              return u.findRoot(
                he,
                P,
                B + ye,
                ue,
                pe,
                32,
                1e-12
              );
            },
            getPoint: function(C, R) {
              return f(C, R, 0, !1);
            },
            getTangent: function(C, R) {
              return f(C, R, 1, !0);
            },
            getWeightedTangent: function(C, R) {
              return f(C, R, 1, !1);
            },
            getNormal: function(C, R) {
              return f(C, R, 2, !0);
            },
            getWeightedNormal: function(C, R) {
              return f(C, R, 2, !1);
            },
            getCurvature: function(C, R) {
              return f(C, R, 3, !1).x;
            },
            getPeaks: function(C) {
              var R = C[0], B = C[1], j = C[2], H = C[3], X = C[4], ue = C[5], pe = C[6], P = C[7], q = -R + 3 * j - 3 * X + pe, K = 3 * R - 6 * j + 3 * X, ye = -3 * R + 3 * j, te = -B + 3 * H - 3 * ue + P, he = 3 * B - 6 * H + 3 * ue, D = -3 * B + 3 * H, Se = 1e-8, le = 1 - Se, v = [];
              return u.solveCubic(
                9 * (q * q + te * te),
                9 * (q * K + he * te),
                2 * (K * K + he * he) + 3 * (ye * q + D * te),
                ye * K + he * D,
                v,
                Se,
                le
              ), v.sort();
            }
          } };
        }(),
        new function() {
          function e(K, ye, te, he, D, Se, le) {
            var v = !le && te.getPrevious() === D, se = !le && te !== D && te.getNext() === D, me = 1e-8, O = 1 - me;
            if (he !== null && he >= (v ? me : 0) && he <= (se ? O : 1) && Se !== null && Se >= (se ? me : 0) && Se <= (v ? O : 1)) {
              var ce = new ie(te, he, null, le), Oe = new ie(D, Se, null, le);
              ce._intersection = Oe, Oe._intersection = ce, (!ye || ye(ce)) && ie.insert(K, ce, !0);
            }
          }
          function r(K, ye, te, he, D, Se, le, v, se, me, O, ce, Oe) {
            if (++se >= 4096 || ++v >= 40)
              return se;
            var Be = 1e-9, je = ye[0], Fe = ye[1], Ye = ye[6], Ke = ye[7], et = b.getSignedDistance, Je = et(je, Fe, Ye, Ke, ye[2], ye[3]), nt = et(je, Fe, Ye, Ke, ye[4], ye[5]), dt = Je * nt > 0 ? 3 / 4 : 4 / 9, vt = dt * Math.min(0, Je, nt), bt = dt * Math.max(0, Je, nt), At = et(je, Fe, Ye, Ke, K[0], K[1]), ot = et(je, Fe, Ye, Ke, K[2], K[3]), ht = et(je, Fe, Ye, Ke, K[4], K[5]), gt = et(je, Fe, Ye, Ke, K[6], K[7]), Ct = f(At, ot, ht, gt), xt = Ct[0], Ot = Ct[1], Nt, Mt;
            if (Je === 0 && nt === 0 && At === 0 && ot === 0 && ht === 0 && gt === 0 || (Nt = C(xt, Ot, vt, bt)) == null || (Mt = C(
              xt.reverse(),
              Ot.reverse(),
              vt,
              bt
            )) == null)
              return se;
            var Gt = me + (O - me) * Nt, Bt = me + (O - me) * Mt;
            if (Math.max(Oe - ce, Bt - Gt) < Be) {
              var or = (Gt + Bt) / 2, ar = (ce + Oe) / 2;
              e(
                D,
                Se,
                le ? he : te,
                le ? ar : or,
                le ? te : he,
                le ? or : ar
              );
            } else {
              K = ee.getPart(K, Nt, Mt);
              var ur = Oe - ce;
              if (Mt - Nt > 0.8)
                if (Bt - Gt > ur) {
                  var hr = ee.subdivide(K, 0.5), or = (Gt + Bt) / 2;
                  se = r(
                    ye,
                    hr[0],
                    he,
                    te,
                    D,
                    Se,
                    !le,
                    v,
                    se,
                    ce,
                    Oe,
                    Gt,
                    or
                  ), se = r(
                    ye,
                    hr[1],
                    he,
                    te,
                    D,
                    Se,
                    !le,
                    v,
                    se,
                    ce,
                    Oe,
                    or,
                    Bt
                  );
                } else {
                  var hr = ee.subdivide(ye, 0.5), ar = (ce + Oe) / 2;
                  se = r(
                    hr[0],
                    K,
                    he,
                    te,
                    D,
                    Se,
                    !le,
                    v,
                    se,
                    ce,
                    ar,
                    Gt,
                    Bt
                  ), se = r(
                    hr[1],
                    K,
                    he,
                    te,
                    D,
                    Se,
                    !le,
                    v,
                    se,
                    ar,
                    Oe,
                    Gt,
                    Bt
                  );
                }
              else
                ur === 0 || ur >= Be ? se = r(
                  ye,
                  K,
                  he,
                  te,
                  D,
                  Se,
                  !le,
                  v,
                  se,
                  ce,
                  Oe,
                  Gt,
                  Bt
                ) : se = r(
                  K,
                  ye,
                  te,
                  he,
                  D,
                  Se,
                  le,
                  v,
                  se,
                  Gt,
                  Bt,
                  ce,
                  Oe
                );
            }
            return se;
          }
          function f(K, ye, te, he) {
            var D = [0, K], Se = [1 / 3, ye], le = [2 / 3, te], v = [1, he], se = ye - (2 * K + he) / 3, me = te - (K + 2 * he) / 3, O;
            if (se * me < 0)
              O = [[D, Se, v], [D, le, v]];
            else {
              var ce = se / me;
              O = [
                ce >= 2 ? [D, Se, v] : ce <= 0.5 ? [D, le, v] : [D, Se, le, v],
                [D, v]
              ];
            }
            return (se || me) < 0 ? O.reverse() : O;
          }
          function C(K, ye, te, he) {
            return K[0][1] < te ? R(K, !0, te) : ye[0][1] > he ? R(ye, !1, he) : K[0][0];
          }
          function R(K, ye, te) {
            for (var he = K[0][0], D = K[0][1], Se = 1, le = K.length; Se < le; Se++) {
              var v = K[Se][0], se = K[Se][1];
              if (ye ? se >= te : se <= te)
                return se === te ? v : he + (te - D) * (v - he) / (se - D);
              he = v, D = se;
            }
            return null;
          }
          function B(K, ye, te, he, D) {
            var Se = u.isZero;
            if (Se(he) && Se(D)) {
              var le = ee.getTimeOf(K, new a(ye, te));
              return le === null ? [] : [le];
            }
            for (var v = Math.atan2(-D, he), se = Math.sin(v), me = Math.cos(v), O = [], ce = [], Oe = 0; Oe < 8; Oe += 2) {
              var Be = K[Oe] - ye, je = K[Oe + 1] - te;
              O.push(
                Be * me - je * se,
                Be * se + je * me
              );
            }
            return ee.solveCubic(O, 1, 0, ce, 0, 1), ce;
          }
          function j(K, ye, te, he, D, Se, le) {
            for (var v = ye[0], se = ye[1], me = ye[6], O = ye[7], ce = B(K, v, se, me - v, O - se), Oe = 0, Be = ce.length; Oe < Be; Oe++) {
              var je = ce[Oe], Fe = ee.getPoint(K, je), Ye = ee.getTimeOf(ye, Fe);
              Ye !== null && e(
                D,
                Se,
                le ? he : te,
                le ? Ye : je,
                le ? te : he,
                le ? je : Ye
              );
            }
          }
          function H(K, ye, te, he, D, Se) {
            var le = b.intersect(
              K[0],
              K[1],
              K[6],
              K[7],
              ye[0],
              ye[1],
              ye[6],
              ye[7]
            );
            le && e(
              D,
              Se,
              te,
              ee.getTimeOf(K, le),
              he,
              ee.getTimeOf(ye, le)
            );
          }
          function X(K, ye, te, he, D, Se) {
            var le = 1e-12, v = Math.min, se = Math.max;
            if (se(K[0], K[2], K[4], K[6]) + le > v(ye[0], ye[2], ye[4], ye[6]) && v(K[0], K[2], K[4], K[6]) - le < se(ye[0], ye[2], ye[4], ye[6]) && se(K[1], K[3], K[5], K[7]) + le > v(ye[1], ye[3], ye[5], ye[7]) && v(K[1], K[3], K[5], K[7]) - le < se(ye[1], ye[3], ye[5], ye[7])) {
              var me = P(K, ye);
              if (me)
                for (var O = 0; O < 2; O++) {
                  var ce = me[O];
                  e(
                    D,
                    Se,
                    te,
                    ce[0],
                    he,
                    ce[1],
                    !0
                  );
                }
              else {
                var Oe = ee.isStraight(K), Be = ee.isStraight(ye), je = Oe && Be, Fe = Oe && !Be, Ye = D.length;
                if ((je ? H : Oe || Be ? j : r)(
                  Fe ? ye : K,
                  Fe ? K : ye,
                  Fe ? he : te,
                  Fe ? te : he,
                  D,
                  Se,
                  Fe,
                  0,
                  0,
                  0,
                  1,
                  0,
                  1
                ), !je || D.length === Ye)
                  for (var O = 0; O < 4; O++) {
                    var Ke = O >> 1, et = O & 1, Je = Ke * 6, nt = et * 6, dt = new a(K[Je], K[Je + 1]), vt = new a(ye[nt], ye[nt + 1]);
                    dt.isClose(vt, le) && e(
                      D,
                      Se,
                      te,
                      Ke,
                      he,
                      et
                    );
                  }
              }
            }
            return D;
          }
          function ue(K, ye, te, he) {
            var D = ee.classify(K);
            if (D.type === "loop") {
              var Se = D.roots;
              e(
                te,
                he,
                ye,
                Se[0],
                ye,
                Se[1]
              );
            }
            return te;
          }
          function pe(K, ye, te, he, D, Se) {
            var le = 1e-7, v = !ye;
            v && (ye = K);
            for (var se = K.length, me = ye.length, O = new Array(se), ce = v ? O : new Array(me), Oe = [], Be = 0; Be < se; Be++)
              O[Be] = K[Be].getValues(he);
            if (!v)
              for (var Be = 0; Be < me; Be++)
                ce[Be] = ye[Be].getValues(D);
            for (var je = E.findCurveBoundsCollisions(
              O,
              ce,
              le
            ), Fe = 0; Fe < se; Fe++) {
              var Ye = K[Fe], Ke = O[Fe];
              v && ue(Ke, Ye, Oe, te);
              var et = je[Fe];
              if (et)
                for (var Je = 0; Je < et.length; Je++) {
                  if (Se && Oe.length)
                    return Oe;
                  var nt = et[Je];
                  if (!v || nt > Fe) {
                    var dt = ye[nt], vt = ce[nt];
                    X(
                      Ke,
                      vt,
                      Ye,
                      dt,
                      Oe,
                      te
                    );
                  }
                }
            }
            return Oe;
          }
          function P(K, ye) {
            function te(gt) {
              var Ct = gt[6] - gt[0], xt = gt[7] - gt[1];
              return Ct * Ct + xt * xt;
            }
            var he = Math.abs, D = b.getDistance, Se = 1e-8, le = 1e-7, v = ee.isStraight(K), se = ee.isStraight(ye), me = v && se, O = te(K) < te(ye), ce = O ? ye : K, Oe = O ? K : ye, Be = ce[0], je = ce[1], Fe = ce[6] - Be, Ye = ce[7] - je;
            if (D(Be, je, Fe, Ye, Oe[0], Oe[1], !0) < le && D(Be, je, Fe, Ye, Oe[6], Oe[7], !0) < le)
              !me && D(Be, je, Fe, Ye, ce[2], ce[3], !0) < le && D(Be, je, Fe, Ye, ce[4], ce[5], !0) < le && D(Be, je, Fe, Ye, Oe[2], Oe[3], !0) < le && D(Be, je, Fe, Ye, Oe[4], Oe[5], !0) < le && (v = se = me = !0);
            else if (me)
              return null;
            if (v ^ se)
              return null;
            for (var Ke = [K, ye], et = [], Je = 0; Je < 4 && et.length < 2; Je++) {
              var nt = Je & 1, dt = nt ^ 1, vt = Je >> 1, bt = ee.getTimeOf(Ke[nt], new a(
                Ke[dt][vt ? 6 : 0],
                Ke[dt][vt ? 7 : 1]
              ));
              if (bt != null) {
                var At = nt ? [vt, bt] : [bt, vt];
                (!et.length || he(At[0] - et[0][0]) > Se && he(At[1] - et[0][1]) > Se) && et.push(At);
              }
              if (Je > 2 && !et.length)
                break;
            }
            if (et.length !== 2)
              et = null;
            else if (!me) {
              var ot = ee.getPart(K, et[0][0], et[1][0]), ht = ee.getPart(ye, et[0][1], et[1][1]);
              (he(ht[2] - ot[2]) > le || he(ht[3] - ot[3]) > le || he(ht[4] - ot[4]) > le || he(ht[5] - ot[5]) > le) && (et = null);
            }
            return et;
          }
          function q(K, ye) {
            var te = K[0], he = K[1], D = K[2], Se = K[3], le = K[4], v = K[5], se = K[6], me = K[7], O = ye.normalize(), ce = O.x, Oe = O.y, Be = 3 * se - 9 * le + 9 * D - 3 * te, je = 3 * me - 9 * v + 9 * Se - 3 * he, Fe = 6 * le - 12 * D + 6 * te, Ye = 6 * v - 12 * Se + 6 * he, Ke = 3 * D - 3 * te, et = 3 * Se - 3 * he, Je = 2 * Be * Oe - 2 * je * ce, nt = [];
            if (Math.abs(Je) < u.CURVETIME_EPSILON) {
              var dt = Be * et - je * Ke, Je = Be * Ye - je * Fe;
              if (Je != 0) {
                var vt = -dt / Je;
                vt >= 0 && vt <= 1 && nt.push(vt);
              }
            } else {
              var bt = (Fe * Fe - 4 * Be * Ke) * Oe * Oe + (-2 * Fe * Ye + 4 * je * Ke + 4 * Be * et) * ce * Oe + (Ye * Ye - 4 * je * et) * ce * ce, At = Fe * Oe - Ye * ce;
              if (bt >= 0 && Je != 0) {
                var ot = Math.sqrt(bt), ht = -(At + ot) / Je, gt = (-At + ot) / Je;
                ht >= 0 && ht <= 1 && nt.push(ht), gt >= 0 && gt <= 1 && nt.push(gt);
              }
            }
            return nt;
          }
          return {
            getIntersections: function(K) {
              var ye = this.getValues(), te = K && K !== this && K.getValues();
              return te ? X(ye, te, this, K, []) : ue(ye, this, []);
            },
            statics: {
              getOverlaps: P,
              getIntersections: pe,
              getCurveLineIntersections: B,
              getTimesWithTangent: q
            }
          };
        }()
      ), ie = _.extend(
        {
          _class: "CurveLocation",
          initialize: function(r, f, C, R, B) {
            if (f >= 0.99999999) {
              var j = r.getNext();
              j && (f = 0, r = j);
            }
            this._setCurve(r), this._time = f, this._point = C || r.getPointAtTime(f), this._overlap = R, this._distance = B, this._intersection = this._next = this._previous = null;
          },
          _setPath: function(e) {
            this._path = e, this._version = e ? e._version : 0;
          },
          _setCurve: function(e) {
            this._setPath(e._path), this._curve = e, this._segment = null, this._segment1 = e._segment1, this._segment2 = e._segment2;
          },
          _setSegment: function(e) {
            var r = e.getCurve();
            r ? this._setCurve(r) : (this._setPath(e._path), this._segment1 = e, this._segment2 = null), this._segment = e, this._time = e === this._segment1 ? 0 : 1, this._point = e._point.clone();
          },
          getSegment: function() {
            var e = this._segment;
            if (!e) {
              var r = this.getCurve(), f = this.getTime();
              f === 0 ? e = r._segment1 : f === 1 ? e = r._segment2 : f != null && (e = r.getPartLength(0, f) < r.getPartLength(f, 1) ? r._segment1 : r._segment2), this._segment = e;
            }
            return e;
          },
          getCurve: function() {
            var e = this._path, r = this;
            e && e._version !== this._version && (this._time = this._offset = this._curveOffset = this._curve = null);
            function f(C) {
              var R = C && C.getCurve();
              if (R && (r._time = R.getTimeOf(r._point)) != null)
                return r._setCurve(R), R;
            }
            return this._curve || f(this._segment) || f(this._segment1) || f(this._segment2.getPrevious());
          },
          getPath: function() {
            var e = this.getCurve();
            return e && e._path;
          },
          getIndex: function() {
            var e = this.getCurve();
            return e && e.getIndex();
          },
          getTime: function() {
            var e = this.getCurve(), r = this._time;
            return e && r == null ? this._time = e.getTimeOf(this._point) : r;
          },
          getParameter: "#getTime",
          getPoint: function() {
            return this._point;
          },
          getOffset: function() {
            var e = this._offset;
            if (e == null) {
              e = 0;
              var r = this.getPath(), f = this.getIndex();
              if (r && f != null)
                for (var C = r.getCurves(), R = 0; R < f; R++)
                  e += C[R].getLength();
              this._offset = e += this.getCurveOffset();
            }
            return e;
          },
          getCurveOffset: function() {
            var e = this._curveOffset;
            if (e == null) {
              var r = this.getCurve(), f = this.getTime();
              this._curveOffset = e = f != null && r && r.getPartLength(0, f);
            }
            return e;
          },
          getIntersection: function() {
            return this._intersection;
          },
          getDistance: function() {
            return this._distance;
          },
          divide: function() {
            var e = this.getCurve(), r = e && e.divideAtTime(this.getTime());
            return r && this._setSegment(r._segment1), r;
          },
          split: function() {
            var e = this.getCurve(), r = e._path, f = e && e.splitAtTime(this.getTime());
            return f && this._setSegment(r.getLastSegment()), f;
          },
          equals: function(e, r) {
            var f = this === e;
            if (!f && e instanceof ie) {
              var C = this.getCurve(), R = e.getCurve(), B = C._path, j = R._path;
              if (B === j) {
                var H = Math.abs, X = 1e-7, ue = H(this.getOffset() - e.getOffset()), pe = !r && this._intersection, P = !r && e._intersection;
                f = (ue < X || B && H(B.getLength() - ue) < X) && (!pe && !P || pe && P && pe.equals(P, !0));
              }
            }
            return f;
          },
          toString: function() {
            var e = [], r = this.getPoint(), f = c.instance;
            r && e.push("point: " + r);
            var C = this.getIndex();
            C != null && e.push("index: " + C);
            var R = this.getTime();
            return R != null && e.push("time: " + f.number(R)), this._distance != null && e.push("distance: " + f.number(this._distance)), "{ " + e.join(", ") + " }";
          },
          isTouching: function() {
            var e = this._intersection;
            if (e && this.getTangent().isCollinear(e.getTangent())) {
              var r = this.getCurve(), f = e.getCurve();
              return !(r.isStraight() && f.isStraight() && r.getLine().intersect(f.getLine()));
            }
            return !1;
          },
          isCrossing: function() {
            var e = this._intersection;
            if (!e)
              return !1;
            var r = this.getTime(), f = e.getTime(), C = 1e-8, R = 1 - C, B = r >= C && r <= R, j = f >= C && f <= R;
            if (B && j)
              return !this.isTouching();
            var H = this.getCurve(), X = H && r < C ? H.getPrevious() : H, ue = e.getCurve(), pe = ue && f < C ? ue.getPrevious() : ue;
            if (r > R && (H = H.getNext()), f > R && (ue = ue.getNext()), !X || !H || !pe || !ue)
              return !1;
            var P = [];
            function q(ce, Oe) {
              var Be = ce.getValues(), je = ee.classify(Be).roots || ee.getPeaks(Be), Fe = je.length, Ye = ee.getLength(
                Be,
                Oe && Fe ? je[Fe - 1] : 0,
                !Oe && Fe ? je[0] : 1
              );
              P.push(Fe ? Ye : Ye / 32);
            }
            function K(ce, Oe, Be) {
              return Oe < Be ? ce > Oe && ce < Be : ce > Oe || ce < Be;
            }
            B || (q(X, !0), q(H, !1)), j || (q(pe, !0), q(ue, !1));
            var ye = this.getPoint(), te = Math.min.apply(Math, P), he = B ? H.getTangentAtTime(r) : H.getPointAt(te).subtract(ye), D = B ? he.negate() : X.getPointAt(-te).subtract(ye), Se = j ? ue.getTangentAtTime(f) : ue.getPointAt(te).subtract(ye), le = j ? Se.negate() : pe.getPointAt(-te).subtract(ye), v = D.getAngle(), se = he.getAngle(), me = le.getAngle(), O = Se.getAngle();
            return !!(B ? K(v, me, O) ^ K(se, me, O) && K(v, O, me) ^ K(se, O, me) : K(me, v, se) ^ K(O, v, se) && K(me, se, v) ^ K(O, se, v));
          },
          hasOverlap: function() {
            return !!this._overlap;
          }
        },
        _.each(ee._evaluateMethods, function(e) {
          var r = e + "At";
          this[e] = function() {
            var f = this.getCurve(), C = this.getTime();
            return C != null && f && f[r](C, !0);
          };
        }, {
          preserve: !0
        }),
        new function() {
          function e(r, f, C) {
            var R = r.length, B = 0, j = R - 1;
            function H(ye, te) {
              for (var he = ye + te; he >= -1 && he <= R; he += te) {
                var D = r[(he % R + R) % R];
                if (!f.getPoint().isClose(
                  D.getPoint(),
                  1e-7
                ))
                  break;
                if (f.equals(D))
                  return D;
              }
              return null;
            }
            for (; B <= j; ) {
              var X = B + j >>> 1, ue = r[X], pe;
              if (C && (pe = f.equals(ue) ? ue : H(X, -1) || H(X, 1)))
                return f._overlap && (pe._overlap = pe._intersection._overlap = !0), pe;
              var P = f.getPath(), q = ue.getPath(), K = P !== q ? P._id - q._id : f.getIndex() + f.getTime() - (ue.getIndex() + ue.getTime());
              K < 0 ? j = X - 1 : B = X + 1;
            }
            return r.splice(B, 0, f), f;
          }
          return { statics: {
            insert: e,
            expand: function(r) {
              for (var f = r.slice(), C = r.length - 1; C >= 0; C--)
                e(f, r[C]._intersection, !1);
              return f;
            }
          } };
        }()
      ), W = o.extend({
        _class: "PathItem",
        _selectBounds: !1,
        _canScaleStroke: !0,
        beans: !0,
        initialize: function() {
        },
        statics: {
          create: function(e) {
            var r, f, C;
            if (_.isPlainObject(e) ? (f = e.segments, r = e.pathData) : Array.isArray(e) ? f = e : typeof e == "string" && (r = e), f) {
              var R = f[0];
              C = R && Array.isArray(R[0]);
            } else r && (C = (r.match(/m/gi) || []).length > 1 || /z\s*\S+/i.test(r));
            var B = C ? de : Q;
            return new B(e);
          }
        },
        _asPathItem: function() {
          return this;
        },
        isClockwise: function() {
          return this.getArea() >= 0;
        },
        setClockwise: function(e) {
          this.isClockwise() != (e = !!e) && this.reverse();
        },
        setPathData: function(e) {
          var r = e && e.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig), f, C = !1, R, B, j = new a(), H = new a();
          function X(le, v) {
            var se = +f[le];
            return C && (se += j[v]), se;
          }
          function ue(le) {
            return new a(
              X(le, "x"),
              X(le + 1, "y")
            );
          }
          this.clear();
          for (var pe = 0, P = r && r.length; pe < P; pe++) {
            var q = r[pe], K = q[0], ye = K.toLowerCase();
            f = q.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
            var te = f && f.length;
            switch (C = K === ye, R === "z" && !/[mz]/.test(ye) && this.moveTo(j), ye) {
              case "m":
              case "l":
                for (var he = ye === "m", D = 0; D < te; D += 2)
                  this[he ? "moveTo" : "lineTo"](j = ue(D)), he && (H = j, he = !1);
                B = j;
                break;
              case "h":
              case "v":
                var Se = ye === "h" ? "x" : "y";
                j = j.clone();
                for (var D = 0; D < te; D++)
                  j[Se] = X(D, Se), this.lineTo(j);
                B = j;
                break;
              case "c":
                for (var D = 0; D < te; D += 6)
                  this.cubicCurveTo(
                    ue(D),
                    B = ue(D + 2),
                    j = ue(D + 4)
                  );
                break;
              case "s":
                for (var D = 0; D < te; D += 4)
                  this.cubicCurveTo(
                    /[cs]/.test(R) ? j.multiply(2).subtract(B) : j,
                    B = ue(D),
                    j = ue(D + 2)
                  ), R = ye;
                break;
              case "q":
                for (var D = 0; D < te; D += 4)
                  this.quadraticCurveTo(
                    B = ue(D),
                    j = ue(D + 2)
                  );
                break;
              case "t":
                for (var D = 0; D < te; D += 2)
                  this.quadraticCurveTo(
                    B = /[qt]/.test(R) ? j.multiply(2).subtract(B) : j,
                    j = ue(D)
                  ), R = ye;
                break;
              case "a":
                for (var D = 0; D < te; D += 7)
                  this.arcTo(
                    j = ue(D + 5),
                    new d(+f[D], +f[D + 1]),
                    +f[D + 2],
                    +f[D + 4],
                    +f[D + 3]
                  );
                break;
              case "z":
                this.closePath(1e-12), j = H;
                break;
            }
            R = ye;
          }
        },
        _canComposite: function() {
          return !(this.hasFill() && this.hasStroke());
        },
        _contains: function(e) {
          var r = e.isInside(
            this.getBounds({ internal: !0, handle: !0 })
          ) ? this._getWinding(e) : {};
          return r.onPath || !!(this.getFillRule() === "evenodd" ? r.windingL & 1 || r.windingR & 1 : r.winding);
        },
        getIntersections: function(e, r, f, C) {
          var R = this === e || !e, B = this._matrix._orNullIfIdentity(), j = R ? B : (f || e._matrix)._orNullIfIdentity();
          return R || this.getBounds(B).intersects(
            e.getBounds(j),
            1e-12
          ) ? ee.getIntersections(
            this.getCurves(),
            !R && e.getCurves(),
            r,
            B,
            j,
            C
          ) : [];
        },
        getCrossings: function(e) {
          return this.getIntersections(e, function(r) {
            return r.isCrossing();
          });
        },
        getNearestLocation: function() {
          for (var e = a.read(arguments), r = this.getCurves(), f = 1 / 0, C = null, R = 0, B = r.length; R < B; R++) {
            var j = r[R].getNearestLocation(e);
            j._distance < f && (f = j._distance, C = j);
          }
          return C;
        },
        getNearestPoint: function() {
          var e = this.getNearestLocation.apply(this, arguments);
          return e && e.getPoint();
        },
        interpolate: function(e, r, f) {
          var C = !this._children, R = C ? "_segments" : "_children", B = e[R], j = r[R], H = this[R];
          if (!B || !j || B.length !== j.length)
            throw new Error("Invalid operands in interpolate() call: " + e + ", " + r);
          var X = H.length, ue = j.length;
          if (X < ue)
            for (var pe = C ? F : Q, P = X; P < ue; P++)
              this.add(new pe());
          else X > ue && this[C ? "removeSegments" : "removeChildren"](ue, X);
          for (var P = 0; P < ue; P++)
            H[P].interpolate(B[P], j[P], f);
          C && (this.setClosed(e._closed), this._changed(9));
        },
        compare: function(e) {
          var r = !1;
          if (e) {
            var f = this._children || [this], C = e._children ? e._children.slice() : [e], R = f.length, B = C.length, j = [], H = 0;
            r = !0;
            for (var X = E.findItemBoundsCollisions(f, C, u.GEOMETRIC_EPSILON), ue = R - 1; ue >= 0 && r; ue--) {
              var pe = f[ue];
              r = !1;
              var P = X[ue];
              if (P)
                for (var q = P.length - 1; q >= 0 && !r; q--)
                  pe.compare(C[P[q]]) && (j[P[q]] || (j[P[q]] = !0, H++), r = !0);
            }
            r = r && H === B;
          }
          return r;
        }
      }), Q = W.extend(
        {
          _class: "Path",
          _serializeFields: {
            segments: [],
            closed: !1
          },
          initialize: function(r) {
            this._closed = !1, this._segments = [], this._version = 0;
            var f = arguments, C = Array.isArray(r) ? typeof r[0] == "object" ? r : f : r && r.size === ae && (r.x !== ae || r.point !== ae) ? f : null;
            C && C.length > 0 ? this.setSegments(C) : (this._curves = ae, this._segmentSelection = 0, !C && typeof r == "string" && (this.setPathData(r), r = null)), this._initialize(!C && r);
          },
          _equals: function(e) {
            return this._closed === e._closed && _.equals(this._segments, e._segments);
          },
          copyContent: function(e) {
            this.setSegments(e._segments), this._closed = e._closed;
          },
          _changed: function e(r) {
            if (e.base.call(this, r), r & 8) {
              if (this._length = this._area = ae, r & 32)
                this._version++;
              else if (this._curves)
                for (var f = 0, C = this._curves.length; f < C; f++)
                  this._curves[f]._changed();
            } else r & 64 && (this._bounds = ae);
          },
          getStyle: function() {
            var e = this._parent;
            return (e instanceof de ? e : this)._style;
          },
          getSegments: function() {
            return this._segments;
          },
          setSegments: function(e) {
            var r = this.isFullySelected(), f = e && e.length;
            if (this._segments.length = 0, this._segmentSelection = 0, this._curves = ae, f) {
              var C = e[f - 1];
              typeof C == "boolean" && (this.setClosed(C), f--), this._add(F.readList(e, 0, {}, f));
            }
            r && this.setFullySelected(!0);
          },
          getFirstSegment: function() {
            return this._segments[0];
          },
          getLastSegment: function() {
            return this._segments[this._segments.length - 1];
          },
          getCurves: function() {
            var e = this._curves, r = this._segments;
            if (!e) {
              var f = this._countCurves();
              e = this._curves = new Array(f);
              for (var C = 0; C < f; C++)
                e[C] = new ee(
                  this,
                  r[C],
                  r[C + 1] || r[0]
                );
            }
            return e;
          },
          getFirstCurve: function() {
            return this.getCurves()[0];
          },
          getLastCurve: function() {
            var e = this.getCurves();
            return e[e.length - 1];
          },
          isClosed: function() {
            return this._closed;
          },
          setClosed: function(e) {
            if (this._closed != (e = !!e)) {
              if (this._closed = e, this._curves) {
                var r = this._curves.length = this._countCurves();
                e && (this._curves[r - 1] = new ee(
                  this,
                  this._segments[r - 1],
                  this._segments[0]
                ));
              }
              this._changed(41);
            }
          }
        },
        {
          beans: !0,
          getPathData: function(e, r) {
            var f = this._segments, C = f.length, R = new c(r), B = new Array(6), j = !0, H, X, ue, pe, P, q, K, ye, te = [];
            function he(Se, le) {
              if (Se._transformCoordinates(e, B), H = B[0], X = B[1], j)
                te.push("M" + R.pair(H, X)), j = !1;
              else if (P = B[2], q = B[3], P === H && q === X && K === ue && ye === pe) {
                if (!le) {
                  var v = H - ue, se = X - pe;
                  te.push(
                    v === 0 ? "v" + R.number(se) : se === 0 ? "h" + R.number(v) : "l" + R.pair(v, se)
                  );
                }
              } else
                te.push("c" + R.pair(K - ue, ye - pe) + " " + R.pair(P - ue, q - pe) + " " + R.pair(H - ue, X - pe));
              ue = H, pe = X, K = B[4], ye = B[5];
            }
            if (!C)
              return "";
            for (var D = 0; D < C; D++)
              he(f[D]);
            return this._closed && C > 0 && (he(f[0], !0), te.push("z")), te.join("");
          },
          isEmpty: function() {
            return !this._segments.length;
          },
          _transformContent: function(e) {
            for (var r = this._segments, f = new Array(6), C = 0, R = r.length; C < R; C++)
              r[C]._transformCoordinates(e, f, !0);
            return !0;
          },
          _add: function(e, j) {
            for (var f = this._segments, C = this._curves, R = e.length, B = j == null, j = B ? f.length : j, H = 0; H < R; H++) {
              var X = e[H];
              X._path && (X = e[H] = X.clone()), X._path = this, X._index = j + H, X._selection && this._updateSelection(X, 0, X._selection);
            }
            if (B)
              _.push(f, e);
            else {
              f.splice.apply(f, [j, 0].concat(e));
              for (var H = j + R, ue = f.length; H < ue; H++)
                f[H]._index = H;
            }
            if (C) {
              var pe = this._countCurves(), P = j > 0 && j + R - 1 === pe ? j - 1 : j, q = P, K = Math.min(P + R, pe);
              e._curves && (C.splice.apply(C, [P, 0].concat(e._curves)), q += e._curves.length);
              for (var H = q; H < K; H++)
                C.splice(H, 0, new ee(this, null, null));
              this._adjustCurves(P, K);
            }
            return this._changed(41), e;
          },
          _adjustCurves: function(e, r) {
            for (var f = this._segments, C = this._curves, R, B = e; B < r; B++)
              R = C[B], R._path = this, R._segment1 = f[B], R._segment2 = f[B + 1] || f[0], R._changed();
            (R = C[this._closed && !e ? f.length - 1 : e - 1]) && (R._segment2 = f[e] || f[0], R._changed()), (R = C[r]) && (R._segment1 = f[r], R._changed());
          },
          _countCurves: function() {
            var e = this._segments.length;
            return !this._closed && e > 0 ? e - 1 : e;
          },
          add: function(e) {
            var r = arguments;
            return r.length > 1 && typeof e != "number" ? this._add(F.readList(r)) : this._add([F.read(r)])[0];
          },
          insert: function(e, r) {
            var f = arguments;
            return f.length > 2 && typeof r != "number" ? this._add(F.readList(f, 1), e) : this._add([F.read(f, 1)], e)[0];
          },
          addSegment: function() {
            return this._add([F.read(arguments)])[0];
          },
          insertSegment: function(e) {
            return this._add([F.read(arguments, 1)], e)[0];
          },
          addSegments: function(e) {
            return this._add(F.readList(e));
          },
          insertSegments: function(e, r) {
            return this._add(F.readList(r), e);
          },
          removeSegment: function(e) {
            return this.removeSegments(e, e + 1)[0] || null;
          },
          removeSegments: function(e, r, f) {
            e = e || 0, r = _.pick(r, this._segments.length);
            var C = this._segments, R = this._curves, B = C.length, j = C.splice(e, r - e), H = j.length;
            if (!H)
              return j;
            for (var X = 0; X < H; X++) {
              var ue = j[X];
              ue._selection && this._updateSelection(ue, ue._selection, 0), ue._index = ue._path = null;
            }
            for (var X = e, pe = C.length; X < pe; X++)
              C[X]._index = X;
            if (R) {
              for (var P = e > 0 && r === B + (this._closed ? 1 : 0) ? e - 1 : e, R = R.splice(P, H), X = R.length - 1; X >= 0; X--)
                R[X]._path = null;
              f && (j._curves = R.slice(1)), this._adjustCurves(P, P);
            }
            return this._changed(41), j;
          },
          clear: "#removeSegments",
          hasHandles: function() {
            for (var e = this._segments, r = 0, f = e.length; r < f; r++)
              if (e[r].hasHandles())
                return !0;
            return !1;
          },
          clearHandles: function() {
            for (var e = this._segments, r = 0, f = e.length; r < f; r++)
              e[r].clearHandles();
          },
          getLength: function() {
            if (this._length == null) {
              for (var e = this.getCurves(), r = 0, f = 0, C = e.length; f < C; f++)
                r += e[f].getLength();
              this._length = r;
            }
            return this._length;
          },
          getArea: function() {
            var e = this._area;
            if (e == null) {
              var r = this._segments, f = this._closed;
              e = 0;
              for (var C = 0, R = r.length; C < R; C++) {
                var B = C + 1 === R;
                e += ee.getArea(ee.getValues(
                  r[C],
                  r[B ? 0 : C + 1],
                  null,
                  B && !f
                ));
              }
              this._area = e;
            }
            return e;
          },
          isFullySelected: function() {
            var e = this._segments.length;
            return this.isSelected() && e > 0 && this._segmentSelection === e * 7;
          },
          setFullySelected: function(e) {
            e && this._selectSegments(!0), this.setSelected(e);
          },
          setSelection: function e(r) {
            r & 1 || this._selectSegments(!1), e.base.call(this, r);
          },
          _selectSegments: function(e) {
            var r = this._segments, f = r.length, C = e ? 7 : 0;
            this._segmentSelection = C * f;
            for (var R = 0; R < f; R++)
              r[R]._selection = C;
          },
          _updateSelection: function(e, r, f) {
            e._selection = f;
            var C = this._segmentSelection += f - r;
            C > 0 && this.setSelected(!0);
          },
          divideAt: function(e) {
            var r = this.getLocationAt(e), f;
            return r && (f = r.getCurve().divideAt(r.getCurveOffset())) ? f._segment1 : null;
          },
          splitAt: function(e) {
            var r = this.getLocationAt(e), f = r && r.index, C = r && r.time, R = 1e-8, B = 1 - R;
            C > B && (f++, C = 0);
            var j = this.getCurves();
            if (f >= 0 && f < j.length) {
              C >= R && j[f++].divideAtTime(C);
              var H = this.removeSegments(f, this._segments.length, !0), X;
              return this._closed ? (this.setClosed(!1), X = this) : (X = new Q(o.NO_INSERT), X.insertAbove(this), X.copyAttributes(this)), X._add(H, 0), this.addSegment(H[0]), X;
            }
            return null;
          },
          split: function(e, r) {
            var f, C = r === ae ? e : (f = this.getCurves()[e]) && f.getLocationAtTime(r);
            return C != null ? this.splitAt(C) : null;
          },
          join: function(e, r) {
            var f = r || 0;
            if (e && e !== this) {
              var C = e._segments, R = this.getLastSegment(), B = e.getLastSegment();
              if (!B)
                return this;
              R && R._point.isClose(B._point, f) && e.reverse();
              var j = e.getFirstSegment();
              if (R && R._point.isClose(j._point, f))
                R.setHandleOut(j._handleOut), this._add(C.slice(1));
              else {
                var H = this.getFirstSegment();
                H && H._point.isClose(j._point, f) && e.reverse(), B = e.getLastSegment(), H && H._point.isClose(B._point, f) ? (H.setHandleIn(B._handleIn), this._add(C.slice(0, C.length - 1), 0)) : this._add(C.slice());
              }
              e._closed && this._add([C[0]]), e.remove();
            }
            var X = this.getFirstSegment(), ue = this.getLastSegment();
            return X !== ue && X._point.isClose(ue._point, f) && (X.setHandleIn(ue._handleIn), ue.remove(), this.setClosed(!0)), this;
          },
          reduce: function(e) {
            for (var r = this.getCurves(), f = e && e.simplify, C = f ? 1e-7 : 0, R = r.length - 1; R >= 0; R--) {
              var B = r[R];
              !B.hasHandles() && (!B.hasLength(C) || f && B.isCollinear(B.getNext())) && B.remove();
            }
            return this;
          },
          reverse: function() {
            this._segments.reverse();
            for (var e = 0, r = this._segments.length; e < r; e++) {
              var f = this._segments[e], C = f._handleIn;
              f._handleIn = f._handleOut, f._handleOut = C, f._index = e;
            }
            this._curves = null, this._changed(9);
          },
          flatten: function(e) {
            for (var r = new we(this, e || 0.25, 256, !0), f = r.parts, C = f.length, R = [], B = 0; B < C; B++)
              R.push(new F(f[B].curve.slice(0, 2)));
            !this._closed && C > 0 && R.push(new F(f[C - 1].curve.slice(6))), this.setSegments(R);
          },
          simplify: function(e) {
            var r = new ke(this).fit(e || 2.5);
            return r && this.setSegments(r), !!r;
          },
          smooth: function(e) {
            var r = this, f = e || {}, C = f.type || "asymmetric", R = this._segments, B = R.length, j = this._closed;
            function H(xt, Ot) {
              var Nt = xt && xt.index;
              if (Nt != null) {
                var Mt = xt.path;
                if (Mt && Mt !== r)
                  throw new Error(xt._class + " " + Nt + " of " + Mt + " is not part of " + r);
                Ot && xt instanceof ee && Nt++;
              } else
                Nt = typeof xt == "number" ? xt : Ot;
              return Math.min(Nt < 0 && j ? Nt % B : Nt < 0 ? Nt + B : Nt, B - 1);
            }
            var X = j && f.from === ae && f.to === ae, ue = H(f.from, 0), pe = H(f.to, B - 1);
            if (ue > pe)
              if (j)
                ue -= B;
              else {
                var P = ue;
                ue = pe, pe = P;
              }
            if (/^(?:asymmetric|continuous)$/.test(C)) {
              var q = C === "asymmetric", K = Math.min, ye = pe - ue + 1, te = ye - 1, he = X ? K(ye, 4) : 1, D = he, Se = he, le = [];
              if (j || (D = K(1, ue), Se = K(1, B - pe - 1)), te += D + Se, te <= 1)
                return;
              for (var v = 0, se = ue - D; v <= te; v++, se++)
                le[v] = R[(se < 0 ? se + B : se) % B]._point;
              for (var me = le[0]._x + 2 * le[1]._x, O = le[0]._y + 2 * le[1]._y, ce = 2, Oe = te - 1, Be = [me], je = [O], Fe = [ce], Ye = [], Ke = [], v = 1; v < te; v++) {
                var et = v < Oe, Je = et || q ? 1 : 2, nt = et ? 4 : q ? 2 : 7, dt = et ? 4 : q ? 3 : 8, vt = et ? 2 : q ? 0 : 1, bt = Je / ce;
                ce = Fe[v] = nt - bt, me = Be[v] = dt * le[v]._x + vt * le[v + 1]._x - bt * me, O = je[v] = dt * le[v]._y + vt * le[v + 1]._y - bt * O;
              }
              Ye[Oe] = Be[Oe] / Fe[Oe], Ke[Oe] = je[Oe] / Fe[Oe];
              for (var v = te - 2; v >= 0; v--)
                Ye[v] = (Be[v] - Ye[v + 1]) / Fe[v], Ke[v] = (je[v] - Ke[v + 1]) / Fe[v];
              Ye[te] = (3 * le[te]._x - Ye[Oe]) / 2, Ke[te] = (3 * le[te]._y - Ke[Oe]) / 2;
              for (var v = D, At = te - Se, se = ue; v <= At; v++, se++) {
                var ot = R[se < 0 ? se + B : se], ht = ot._point, gt = Ye[v] - ht._x, Ct = Ke[v] - ht._y;
                (X || v < At) && ot.setHandleOut(gt, Ct), (X || v > D) && ot.setHandleIn(-gt, -Ct);
              }
            } else
              for (var v = ue; v <= pe; v++)
                R[v < 0 ? v + B : v].smooth(
                  f,
                  !X && v === ue,
                  !X && v === pe
                );
          },
          toShape: function(e) {
            if (!this._closed)
              return null;
            var r = this._segments, f, C, R, B;
            function j(q, K) {
              var ye = r[q], te = ye.getNext(), he = r[K], D = he.getNext();
              return ye._handleOut.isZero() && te._handleIn.isZero() && he._handleOut.isZero() && D._handleIn.isZero() && te._point.subtract(ye._point).isCollinear(
                D._point.subtract(he._point)
              );
            }
            function H(q) {
              var K = r[q], ye = K.getPrevious(), te = K.getNext();
              return ye._handleOut.isZero() && K._handleIn.isZero() && K._handleOut.isZero() && te._handleIn.isZero() && K._point.subtract(ye._point).isOrthogonal(
                te._point.subtract(K._point)
              );
            }
            function X(q) {
              var K = r[q], ye = K.getNext(), te = K._handleOut, he = ye._handleIn, D = 0.5522847498307936;
              if (te.isOrthogonal(he)) {
                var Se = K._point, le = ye._point, v = new b(Se, te, !0).intersect(
                  new b(le, he, !0),
                  !0
                );
                return v && u.isZero(te.getLength() / v.subtract(Se).getLength() - D) && u.isZero(he.getLength() / v.subtract(le).getLength() - D);
              }
              return !1;
            }
            function ue(q, K) {
              return r[q]._point.getDistance(r[K]._point);
            }
            if (!this.hasHandles() && r.length === 4 && j(0, 2) && j(1, 3) && H(1) ? (f = I.Rectangle, C = new d(ue(0, 3), ue(0, 1)), B = r[1]._point.add(r[2]._point).divide(2)) : r.length === 8 && X(0) && X(2) && X(4) && X(6) && j(1, 5) && j(3, 7) ? (f = I.Rectangle, C = new d(ue(1, 6), ue(0, 3)), R = C.subtract(new d(
              ue(0, 7),
              ue(1, 2)
            )).divide(2), B = r[3]._point.add(r[4]._point).divide(2)) : r.length === 4 && X(0) && X(1) && X(2) && X(3) && (u.isZero(ue(0, 2) - ue(1, 3)) ? (f = I.Circle, R = ue(0, 2) / 2) : (f = I.Ellipse, R = new d(ue(2, 0) / 2, ue(3, 1) / 2)), B = r[1]._point), f) {
              var pe = this.getPosition(!0), P = new f({
                center: pe,
                size: C,
                radius: R,
                insert: !1
              });
              return P.copyAttributes(this, !0), P._matrix.prepend(this._matrix), P.rotate(B.subtract(pe).getAngle() + 90), (e === ae || e) && P.insertAbove(this), P;
            }
            return null;
          },
          toPath: "#clone",
          compare: function e(r) {
            if (!r || r instanceof de)
              return e.base.call(this, r);
            var f = this.getCurves(), C = r.getCurves(), R = f.length, B = C.length;
            if (!R || !B)
              return R == B;
            for (var j = f[0].getValues(), H = [], X = 0, ue, pe = 0, P, q = 0; q < B; q++) {
              var he = C[q].getValues();
              H.push(he);
              var K = ee.getOverlaps(j, he);
              if (K) {
                ue = !q && K[0][0] > 0 ? B - 1 : q, P = K[0][1];
                break;
              }
            }
            for (var ye = Math.abs, te = 1e-8, he = H[ue], D; j && he; ) {
              var K = ee.getOverlaps(j, he);
              if (K) {
                var Se = K[0][0];
                if (ye(Se - pe) < te) {
                  pe = K[1][0], pe === 1 && (j = ++X < R ? f[X].getValues() : null, pe = 0);
                  var le = K[0][1];
                  if (ye(le - P) < te) {
                    if (D || (D = [ue, le]), P = K[1][1], P === 1 && (++ue >= B && (ue = 0), he = H[ue] || C[ue].getValues(), P = 0), !j)
                      return D[0] === ue && D[1] === P;
                    continue;
                  }
                }
              }
              break;
            }
            return !1;
          },
          _hitTestSelf: function(e, r, f, C) {
            var R = this, B = this.getStyle(), j = this._segments, H = j.length, X = this._closed, ue = r._tolerancePadding, pe = ue, P, q, K, ye, te, he, D = r.stroke && B.hasStroke(), Se = r.fill && B.hasFill(), le = r.curves, v = D ? B.getStrokeWidth() / 2 : Se && r.tolerance > 0 || le ? 0 : null;
            v !== null && (v > 0 ? (P = B.getStrokeJoin(), q = B.getStrokeCap(), K = B.getMiterLimit(), pe = pe.add(
              Q._getStrokePadding(v, C)
            )) : P = q = "round");
            function se(Ye, Ke) {
              return e.subtract(Ye).divide(Ke).length <= 1;
            }
            function me(Ye, Ke, et) {
              if (!r.selected || Ke.isSelected()) {
                var Je = Ye._point;
                if (Ke !== Je && (Ke = Ke.add(Je)), se(Ke, pe))
                  return new J(et, R, {
                    segment: Ye,
                    point: Ke
                  });
              }
            }
            function O(Ye, Ke) {
              return (Ke || r.segments) && me(Ye, Ye._point, "segment") || !Ke && r.handles && (me(Ye, Ye._handleIn, "handle-in") || me(Ye, Ye._handleOut, "handle-out"));
            }
            function ce(Ye) {
              ye.add(Ye);
            }
            function Oe(Ye) {
              var Ke = X || Ye._index > 0 && Ye._index < H - 1;
              if ((Ke ? P : q) === "round")
                return se(Ye._point, pe);
              if (ye = new Q({ internal: !0, closed: !0 }), Ke ? Ye.isSmooth() || Q._addBevelJoin(
                Ye,
                P,
                v,
                K,
                null,
                C,
                ce,
                !0
              ) : q === "square" && Q._addSquareCap(
                Ye,
                q,
                v,
                null,
                C,
                ce,
                !0
              ), !ye.isEmpty()) {
                var et;
                return ye.contains(e) || (et = ye.getNearestLocation(e)) && se(et.getPoint(), ue);
              }
            }
            if (r.ends && !r.segments && !X) {
              if (he = O(j[0], !0) || O(j[H - 1], !0))
                return he;
            } else if (r.segments || r.handles) {
              for (var Be = 0; Be < H; Be++)
                if (he = O(j[Be]))
                  return he;
            }
            if (v !== null) {
              if (te = this.getNearestLocation(e), te) {
                var je = te.getTime();
                je === 0 || je === 1 && H > 1 ? Oe(te.getSegment()) || (te = null) : se(te.getPoint(), pe) || (te = null);
              }
              if (!te && P === "miter" && H > 1)
                for (var Be = 0; Be < H; Be++) {
                  var Fe = j[Be];
                  if (e.getDistance(Fe._point) <= K * v && Oe(Fe)) {
                    te = Fe.getLocation();
                    break;
                  }
                }
            }
            return !te && Se && this._contains(e) || te && !D && !le ? new J("fill", this) : te ? new J(D ? "stroke" : "curve", this, {
              location: te,
              point: te.getPoint()
            }) : null;
          }
        },
        _.each(
          ee._evaluateMethods,
          function(e) {
            this[e + "At"] = function(r) {
              var f = this.getLocationAt(r);
              return f && f[e]();
            };
          },
          {
            beans: !1,
            getLocationOf: function() {
              for (var e = a.read(arguments), r = this.getCurves(), f = 0, C = r.length; f < C; f++) {
                var R = r[f].getLocationOf(e);
                if (R)
                  return R;
              }
              return null;
            },
            getOffsetOf: function() {
              var e = this.getLocationOf.apply(this, arguments);
              return e ? e.getOffset() : null;
            },
            getLocationAt: function(e) {
              if (typeof e == "number") {
                for (var r = this.getCurves(), f = 0, C = 0, R = r.length; C < R; C++) {
                  var B = f, j = r[C];
                  if (f += j.getLength(), f > e)
                    return j.getLocationAt(e - B);
                }
                if (r.length > 0 && e <= this.getLength())
                  return new ie(r[r.length - 1], 1);
              } else if (e && e.getPath && e.getPath() === this)
                return e;
              return null;
            },
            getOffsetsWithTangent: function() {
              var e = a.read(arguments);
              if (e.isZero())
                return [];
              for (var r = [], f = 0, C = this.getCurves(), R = 0, B = C.length; R < B; R++) {
                for (var j = C[R], H = j.getTimesWithTangent(e), X = 0, ue = H.length; X < ue; X++) {
                  var pe = f + j.getOffsetAtTime(H[X]);
                  r.indexOf(pe) < 0 && r.push(pe);
                }
                f += j.length;
              }
              return r;
            }
          }
        ),
        new function() {
          function e(f, C, R, B) {
            if (B <= 0) return;
            var j = B / 2, H = B - 2, X = j - 1, ue = new Array(6), pe, P;
            function q(Se) {
              var le = ue[Se], v = ue[Se + 1];
              (pe != le || P != v) && (f.beginPath(), f.moveTo(pe, P), f.lineTo(le, v), f.stroke(), f.beginPath(), f.arc(le, v, j, 0, Math.PI * 2, !0), f.fill());
            }
            for (var K = 0, ye = C.length; K < ye; K++) {
              var te = C[K], he = te._selection;
              if (te._transformCoordinates(R, ue), pe = ue[0], P = ue[1], he & 2 && q(2), he & 4 && q(4), f.fillRect(pe - j, P - j, B, B), H > 0 && !(he & 1)) {
                var D = f.fillStyle;
                f.fillStyle = "#ffffff", f.fillRect(pe - X, P - X, H, H), f.fillStyle = D;
              }
            }
          }
          function r(f, C, R) {
            var B = C._segments, j = B.length, H = new Array(6), X = !0, ue, pe, P, q, K, ye, te, he;
            function D(le) {
              if (R)
                le._transformCoordinates(R, H), ue = H[0], pe = H[1];
              else {
                var v = le._point;
                ue = v._x, pe = v._y;
              }
              if (X)
                f.moveTo(ue, pe), X = !1;
              else {
                if (R)
                  K = H[2], ye = H[3];
                else {
                  var se = le._handleIn;
                  K = ue + se._x, ye = pe + se._y;
                }
                K === ue && ye === pe && te === P && he === q ? f.lineTo(ue, pe) : f.bezierCurveTo(te, he, K, ye, ue, pe);
              }
              if (P = ue, q = pe, R)
                te = H[4], he = H[5];
              else {
                var se = le._handleOut;
                te = P + se._x, he = q + se._y;
              }
            }
            for (var Se = 0; Se < j; Se++)
              D(B[Se]);
            C._closed && j > 0 && D(B[0]);
          }
          return {
            _draw: function(f, C, R, B) {
              var j = C.dontStart, H = C.dontFinish || C.clip, X = this.getStyle(), ue = X.hasFill(), pe = X.hasStroke(), P = X.getDashArray(), q = !Ae.support.nativeDash && pe && P && P.length;
              j || f.beginPath(), (ue || pe && !q || H) && (r(f, this, B), this._closed && f.closePath());
              function K(le) {
                return P[(le % q + q) % q];
              }
              if (!H && (ue || pe) && (this._setStyles(f, C, R), ue && (f.fill(X.getFillRule()), f.shadowColor = "rgba(0,0,0,0)"), pe)) {
                if (q) {
                  j || f.beginPath();
                  for (var ye = new we(
                    this,
                    0.25,
                    32,
                    !1,
                    B
                  ), te = ye.length, he = -X.getDashOffset(), D, Se = 0; he > 0; )
                    he -= K(Se--) + K(Se--);
                  for (; he < te; )
                    D = he + K(Se++), (he > 0 || D > 0) && ye.drawPart(
                      f,
                      Math.max(he, 0),
                      Math.max(D, 0)
                    ), he = D + K(Se++);
                }
                f.stroke();
              }
            },
            _drawSelected: function(f, C) {
              f.beginPath(), r(f, this, C), f.stroke(), e(f, this._segments, C, Ae.settings.handleSize);
            }
          };
        }(),
        new function() {
          function e(r) {
            var f = r._segments;
            if (!f.length)
              throw new Error("Use a moveTo() command first");
            return f[f.length - 1];
          }
          return {
            moveTo: function() {
              var r = this._segments;
              r.length === 1 && this.removeSegment(0), r.length || this._add([new F(a.read(arguments))]);
            },
            moveBy: function() {
              throw new Error("moveBy() is unsupported on Path items.");
            },
            lineTo: function() {
              this._add([new F(a.read(arguments))]);
            },
            cubicCurveTo: function() {
              var r = arguments, f = a.read(r), C = a.read(r), R = a.read(r), B = e(this);
              B.setHandleOut(f.subtract(B._point)), this._add([new F(R, C.subtract(R))]);
            },
            quadraticCurveTo: function() {
              var r = arguments, f = a.read(r), C = a.read(r), R = e(this)._point;
              this.cubicCurveTo(
                f.add(R.subtract(f).multiply(1 / 3)),
                f.add(C.subtract(f).multiply(1 / 3)),
                C
              );
            },
            curveTo: function() {
              var r = arguments, f = a.read(r), C = a.read(r), R = _.pick(_.read(r), 0.5), B = 1 - R, j = e(this)._point, H = f.subtract(j.multiply(B * B)).subtract(C.multiply(R * R)).divide(2 * R * B);
              if (H.isNaN())
                throw new Error(
                  "Cannot put a curve through points with parameter = " + R
                );
              this.quadraticCurveTo(H, C);
            },
            arcTo: function() {
              var r = arguments, f = Math.abs, C = Math.sqrt, R = e(this), B = R._point, j = a.read(r), H, X = _.peek(r), ue = _.pick(X, !0), pe, P, q, K;
              if (typeof ue == "boolean")
                var ye = B.add(j).divide(2), H = ye.add(ye.subtract(B).rotate(
                  ue ? -90 : 90
                ));
              else if (_.remain(r) <= 2)
                H = j, j = a.read(r);
              else if (!B.equals(j)) {
                var te = d.read(r), he = u.isZero;
                if (he(te.width) || he(te.height))
                  return this.lineTo(j);
                var D = _.read(r), ue = !!_.read(r), Se = !!_.read(r), ye = B.add(j).divide(2), le = B.subtract(ye).rotate(-D), v = le.x, se = le.y, me = f(te.width), O = f(te.height), ce = me * me, Oe = O * O, Be = v * v, je = se * se, Fe = C(Be / ce + je / Oe);
                if (Fe > 1 && (me *= Fe, O *= Fe, ce = me * me, Oe = O * O), Fe = (ce * Oe - ce * je - Oe * Be) / (ce * je + Oe * Be), f(Fe) < 1e-12 && (Fe = 0), Fe < 0)
                  throw new Error(
                    "Cannot create an arc with the given arguments"
                  );
                pe = new a(me * se / O, -O * v / me).multiply((Se === ue ? -1 : 1) * C(Fe)).rotate(D).add(ye), K = new s().translate(pe).rotate(D).scale(me, O), q = K._inverseTransform(B), P = q.getDirectedAngle(K._inverseTransform(j)), !ue && P > 0 ? P -= 360 : ue && P < 0 && (P += 360);
              }
              if (H) {
                var Ye = new b(
                  B.add(H).divide(2),
                  H.subtract(B).rotate(90),
                  !0
                ), Ke = new b(
                  H.add(j).divide(2),
                  j.subtract(H).rotate(90),
                  !0
                ), et = new b(B, j), Je = et.getSide(H);
                if (pe = Ye.intersect(Ke, !0), !pe) {
                  if (!Je)
                    return this.lineTo(j);
                  throw new Error(
                    "Cannot create an arc with the given arguments"
                  );
                }
                q = B.subtract(pe), P = q.getDirectedAngle(j.subtract(pe));
                var nt = et.getSide(pe, !0);
                nt === 0 ? P = Je * f(P) : Je === nt && (P += P < 0 ? 360 : -360);
              }
              if (P) {
                for (var dt = 1e-5, vt = f(P), bt = vt >= 360 ? 4 : Math.ceil((vt - dt) / 90), At = P / bt, ot = At * Math.PI / 360, ht = 4 / 3 * Math.sin(ot) / (1 + Math.cos(ot)), gt = [], Ct = 0; Ct <= bt; Ct++) {
                  var le = j, xt = null;
                  if (Ct < bt && (xt = q.rotate(90).multiply(ht), K ? (le = K._transformPoint(q), xt = K._transformPoint(q.add(xt)).subtract(le)) : le = pe.add(q)), !Ct)
                    R.setHandleOut(xt);
                  else {
                    var Ot = q.rotate(-90).multiply(ht);
                    K && (Ot = K._transformPoint(q.add(Ot)).subtract(le)), gt.push(new F(le, Ot, xt));
                  }
                  q = q.rotate(At);
                }
                this._add(gt);
              }
            },
            lineBy: function() {
              var r = a.read(arguments), f = e(this)._point;
              this.lineTo(f.add(r));
            },
            curveBy: function() {
              var r = arguments, f = a.read(r), C = a.read(r), R = _.read(r), B = e(this)._point;
              this.curveTo(B.add(f), B.add(C), R);
            },
            cubicCurveBy: function() {
              var r = arguments, f = a.read(r), C = a.read(r), R = a.read(r), B = e(this)._point;
              this.cubicCurveTo(
                B.add(f),
                B.add(C),
                B.add(R)
              );
            },
            quadraticCurveBy: function() {
              var r = arguments, f = a.read(r), C = a.read(r), R = e(this)._point;
              this.quadraticCurveTo(R.add(f), R.add(C));
            },
            arcBy: function() {
              var r = arguments, f = e(this)._point, C = f.add(a.read(r)), R = _.pick(_.peek(r), !0);
              typeof R == "boolean" ? this.arcTo(C, R) : this.arcTo(C, f.add(a.read(r)));
            },
            closePath: function(r) {
              this.setClosed(!0), this.join(this, r);
            }
          };
        }(),
        {
          _getBounds: function(e, r) {
            var f = r.handle ? "getHandleBounds" : r.stroke ? "getStrokeBounds" : "getBounds";
            return Q[f](this._segments, this._closed, this, e, r);
          },
          statics: {
            getBounds: function(e, r, f, C, R, B) {
              var j = e[0];
              if (!j)
                return new h();
              var H = new Array(6), X = j._transformCoordinates(C, new Array(6)), ue = X.slice(0, 2), pe = ue.slice(), P = new Array(2);
              function q(te) {
                te._transformCoordinates(C, H);
                for (var he = 0; he < 2; he++)
                  ee._addBounds(
                    X[he],
                    X[he + 4],
                    H[he + 2],
                    H[he],
                    he,
                    B ? B[he] : 0,
                    ue,
                    pe,
                    P
                  );
                var D = X;
                X = H, H = D;
              }
              for (var K = 1, ye = e.length; K < ye; K++)
                q(e[K]);
              return r && q(j), new h(ue[0], ue[1], pe[0] - ue[0], pe[1] - ue[1]);
            },
            getStrokeBounds: function(e, r, f, C, R) {
              var B = f.getStyle(), j = B.hasStroke(), H = B.getStrokeWidth(), X = j && f._getStrokeMatrix(C, R), ue = j && Q._getStrokePadding(
                H,
                X
              ), pe = Q.getBounds(
                e,
                r,
                f,
                C,
                R,
                ue
              );
              if (!j)
                return pe;
              var P = H / 2, q = B.getStrokeJoin(), K = B.getStrokeCap(), ye = B.getMiterLimit(), te = new h(new d(ue));
              function he(me) {
                pe = pe.include(me);
              }
              function D(me) {
                pe = pe.unite(
                  te.setCenter(me._point.transform(C))
                );
              }
              function Se(me, O) {
                O === "round" || me.isSmooth() ? D(me) : Q._addBevelJoin(
                  me,
                  O,
                  P,
                  ye,
                  C,
                  X,
                  he
                );
              }
              function le(me, O) {
                O === "round" ? D(me) : Q._addSquareCap(
                  me,
                  O,
                  P,
                  C,
                  X,
                  he
                );
              }
              var v = e.length - (r ? 0 : 1);
              if (v > 0) {
                for (var se = 1; se < v; se++)
                  Se(e[se], q);
                r ? Se(e[0], q) : (le(e[0], K), le(e[e.length - 1], K));
              }
              return pe;
            },
            _getStrokePadding: function(e, r) {
              if (!r)
                return [e, e];
              var f = new a(e, 0).transform(r), C = new a(0, e).transform(r), R = f.getAngleInRadians(), B = f.getLength(), j = C.getLength(), H = Math.sin(R), X = Math.cos(R), ue = Math.tan(R), pe = Math.atan2(j * ue, B), P = Math.atan2(j, ue * B);
              return [
                Math.abs(B * Math.cos(pe) * X + j * Math.sin(pe) * H),
                Math.abs(j * Math.sin(P) * X + B * Math.cos(P) * H)
              ];
            },
            _addBevelJoin: function(e, r, f, C, R, B, j, H) {
              var X = e.getCurve(), ue = X.getPrevious(), pe = X.getPoint1().transform(R), P = ue.getNormalAtTime(1).multiply(f).transform(B), q = X.getNormalAtTime(0).multiply(f).transform(B), K = P.getDirectedAngle(q);
              if ((K < 0 || K >= 180) && (P = P.negate(), q = q.negate()), H && j(pe), j(pe.add(P)), r === "miter") {
                var ye = new b(
                  pe.add(P),
                  new a(-P.y, P.x),
                  !0
                ).intersect(new b(
                  pe.add(q),
                  new a(-q.y, q.x),
                  !0
                ), !0);
                ye && pe.getDistance(ye) <= C * f && j(ye);
              }
              j(pe.add(q));
            },
            _addSquareCap: function(e, r, f, C, R, B, j) {
              var H = e._point.transform(C), X = e.getLocation(), ue = X.getNormal().multiply(X.getTime() === 0 ? f : -f).transform(R);
              r === "square" && (j && (B(H.subtract(ue)), B(H.add(ue))), H = H.add(ue.rotate(-90))), B(H.add(ue)), B(H.subtract(ue));
            },
            getHandleBounds: function(e, r, f, C, R) {
              var B = f.getStyle(), j = R.stroke && B.hasStroke(), H, X;
              if (j) {
                var ue = f._getStrokeMatrix(C, R), pe = B.getStrokeWidth() / 2, P = pe;
                B.getStrokeJoin() === "miter" && (P = pe * B.getMiterLimit()), B.getStrokeCap() === "square" && (P = Math.max(P, pe * Math.SQRT2)), H = Q._getStrokePadding(pe, ue), X = Q._getStrokePadding(P, ue);
              }
              for (var q = new Array(6), K = 1 / 0, ye = -K, te = K, he = ye, D = 0, Se = e.length; D < Se; D++) {
                var le = e[D];
                le._transformCoordinates(C, q);
                for (var v = 0; v < 6; v += 2) {
                  var se = v ? H : X, me = se ? se[0] : 0, O = se ? se[1] : 0, ce = q[v], Oe = q[v + 1], Be = ce - me, je = ce + me, Fe = Oe - O, Ye = Oe + O;
                  Be < K && (K = Be), je > ye && (ye = je), Fe < te && (te = Fe), Ye > he && (he = Ye);
                }
              }
              return new h(K, te, ye - K, he - te);
            }
          }
        }
      );
      Q.inject({ statics: new function() {
        var e = 0.5522847498307936, r = [
          new F([-1, 0], [0, e], [0, -0.5522847498307936]),
          new F([0, -1], [-0.5522847498307936, 0], [e, 0]),
          new F([1, 0], [0, -0.5522847498307936], [0, e]),
          new F([0, 1], [e, 0], [-0.5522847498307936, 0])
        ];
        function f(R, B, j) {
          var H = _.getNamed(j), X = new Q(H && (H.insert == !0 ? o.INSERT : H.insert == !1 ? o.NO_INSERT : null));
          return X._add(R), X._closed = B, X.set(H, o.INSERT);
        }
        function C(R, B, j) {
          for (var H = new Array(4), X = 0; X < 4; X++) {
            var ue = r[X];
            H[X] = new F(
              ue._point.multiply(B).add(R),
              ue._handleIn.multiply(B),
              ue._handleOut.multiply(B)
            );
          }
          return f(H, !0, j);
        }
        return {
          Line: function() {
            var R = arguments;
            return f([
              new F(a.readNamed(R, "from")),
              new F(a.readNamed(R, "to"))
            ], !1, R);
          },
          Circle: function() {
            var R = arguments, B = a.readNamed(R, "center"), j = _.readNamed(R, "radius");
            return C(B, new d(j), R);
          },
          Rectangle: function() {
            var R = arguments, B = h.readNamed(R, "rectangle"), j = d.readNamed(
              R,
              "radius",
              0,
              { readNull: !0 }
            ), H = B.getBottomLeft(!0), X = B.getTopLeft(!0), ue = B.getTopRight(!0), pe = B.getBottomRight(!0), P;
            if (!j || j.isZero())
              P = [
                new F(H),
                new F(X),
                new F(ue),
                new F(pe)
              ];
            else {
              j = d.min(j, B.getSize(!0).divide(2));
              var q = j.width, K = j.height, ye = q * e, te = K * e;
              P = [
                new F(H.add(q, 0), null, [-ye, 0]),
                new F(H.subtract(0, K), [0, te]),
                new F(X.add(0, K), null, [0, -te]),
                new F(X.add(q, 0), [-ye, 0], null),
                new F(ue.subtract(q, 0), null, [ye, 0]),
                new F(ue.add(0, K), [0, -te], null),
                new F(pe.subtract(0, K), null, [0, te]),
                new F(pe.subtract(q, 0), [ye, 0])
              ];
            }
            return f(P, !0, R);
          },
          RoundRectangle: "#Rectangle",
          Ellipse: function() {
            var R = arguments, B = I._readEllipse(R);
            return C(B.center, B.radius, R);
          },
          Oval: "#Ellipse",
          Arc: function() {
            var R = arguments, B = a.readNamed(R, "from"), j = a.readNamed(R, "through"), H = a.readNamed(R, "to"), X = _.getNamed(R), ue = new Q(X && X.insert == !1 && o.NO_INSERT);
            return ue.moveTo(B), ue.arcTo(j, H), ue.set(X);
          },
          RegularPolygon: function() {
            for (var R = arguments, B = a.readNamed(R, "center"), j = _.readNamed(R, "sides"), H = _.readNamed(R, "radius"), X = 360 / j, ue = j % 3 === 0, pe = new a(0, ue ? -H : H), P = ue ? -1 : 0.5, q = new Array(j), K = 0; K < j; K++)
              q[K] = new F(B.add(
                pe.rotate((K + P) * X)
              ));
            return f(q, !0, R);
          },
          Star: function() {
            for (var R = arguments, B = a.readNamed(R, "center"), j = _.readNamed(R, "points") * 2, H = _.readNamed(R, "radius1"), X = _.readNamed(R, "radius2"), ue = 360 / j, pe = new a(0, -1), P = new Array(j), q = 0; q < j; q++)
              P[q] = new F(B.add(pe.rotate(ue * q).multiply(q % 2 ? X : H)));
            return f(P, !0, R);
          }
        };
      }() });
      var de = W.extend(
        {
          _class: "CompoundPath",
          _serializeFields: {
            children: []
          },
          beans: !0,
          initialize: function(r) {
            this._children = [], this._namedChildren = {}, this._initialize(r) || (typeof r == "string" ? this.setPathData(r) : this.addChildren(Array.isArray(r) ? r : arguments));
          },
          insertChildren: function e(r, f) {
            var C = f, R = C[0];
            R && typeof R[0] == "number" && (C = [C]);
            for (var B = f.length - 1; B >= 0; B--) {
              var j = C[B];
              C === f && !(j instanceof Q) && (C = _.slice(C)), Array.isArray(j) ? C[B] = new Q({ segments: j, insert: !1 }) : j instanceof de && (C.splice.apply(C, [B, 1].concat(j.removeChildren())), j.remove());
            }
            return e.base.call(this, r, C);
          },
          reduce: function e(r) {
            for (var f = this._children, C = f.length - 1; C >= 0; C--) {
              var R = f[C].reduce(r);
              R.isEmpty() && R.remove();
            }
            if (!f.length) {
              var R = new Q(o.NO_INSERT);
              return R.copyAttributes(this), R.insertAbove(this), this.remove(), R;
            }
            return e.base.call(this);
          },
          isClosed: function() {
            for (var e = this._children, r = 0, f = e.length; r < f; r++)
              if (!e[r]._closed)
                return !1;
            return !0;
          },
          setClosed: function(e) {
            for (var r = this._children, f = 0, C = r.length; f < C; f++)
              r[f].setClosed(e);
          },
          getFirstSegment: function() {
            var e = this.getFirstChild();
            return e && e.getFirstSegment();
          },
          getLastSegment: function() {
            var e = this.getLastChild();
            return e && e.getLastSegment();
          },
          getCurves: function() {
            for (var e = this._children, r = [], f = 0, C = e.length; f < C; f++)
              _.push(r, e[f].getCurves());
            return r;
          },
          getFirstCurve: function() {
            var e = this.getFirstChild();
            return e && e.getFirstCurve();
          },
          getLastCurve: function() {
            var e = this.getLastChild();
            return e && e.getLastCurve();
          },
          getArea: function() {
            for (var e = this._children, r = 0, f = 0, C = e.length; f < C; f++)
              r += e[f].getArea();
            return r;
          },
          getLength: function() {
            for (var e = this._children, r = 0, f = 0, C = e.length; f < C; f++)
              r += e[f].getLength();
            return r;
          },
          getPathData: function(e, r) {
            for (var f = this._children, C = [], R = 0, B = f.length; R < B; R++) {
              var j = f[R], H = j._matrix;
              C.push(j.getPathData(e && !H.isIdentity() ? e.appended(H) : e, r));
            }
            return C.join("");
          },
          _hitTestChildren: function e(r, f, C) {
            return e.base.call(
              this,
              r,
              f.class === Q || f.type === "path" ? f : _.set({}, f, { fill: !1 }),
              C
            );
          },
          _draw: function(e, r, f, C) {
            var R = this._children;
            if (R.length) {
              r = r.extend({ dontStart: !0, dontFinish: !0 }), e.beginPath();
              for (var B = 0, j = R.length; B < j; B++)
                R[B].draw(e, r, C);
              if (!r.clip) {
                this._setStyles(e, r, f);
                var H = this._style;
                H.hasFill() && (e.fill(H.getFillRule()), e.shadowColor = "rgba(0,0,0,0)"), H.hasStroke() && e.stroke();
              }
            }
          },
          _drawSelected: function(e, r, f) {
            for (var C = this._children, R = 0, B = C.length; R < B; R++) {
              var j = C[R], H = j._matrix;
              f[j._id] || j._drawSelected(e, H.isIdentity() ? r : r.appended(H));
            }
          }
        },
        new function() {
          function e(r, f) {
            var C = r._children;
            if (f && !C.length)
              throw new Error("Use a moveTo() command first");
            return C[C.length - 1];
          }
          return _.each(
            [
              "lineTo",
              "cubicCurveTo",
              "quadraticCurveTo",
              "curveTo",
              "arcTo",
              "lineBy",
              "cubicCurveBy",
              "quadraticCurveBy",
              "curveBy",
              "arcBy"
            ],
            function(r) {
              this[r] = function() {
                var f = e(this, !0);
                f[r].apply(f, arguments);
              };
            },
            {
              moveTo: function() {
                var r = e(this), f = r && r.isEmpty() ? r : new Q(o.NO_INSERT);
                f !== r && this.addChild(f), f.moveTo.apply(f, arguments);
              },
              moveBy: function() {
                var r = e(this, !0), f = r && r.getLastSegment(), C = a.read(arguments);
                this.moveTo(f ? C.add(f._point) : C);
              },
              closePath: function(r) {
                e(this, !0).closePath(r);
              }
            }
          );
        }(),
        _.each(["reverse", "flatten", "simplify", "smooth"], function(e) {
          this[e] = function(r) {
            for (var f = this._children, C, R = 0, B = f.length; R < B; R++)
              C = f[R][e](r) || C;
            return C;
          };
        }, {})
      );
      W.inject(new function() {
        var e = Math.min, r = Math.max, f = Math.abs, C = {
          unite: { 1: !0, 2: !0 },
          intersect: { 2: !0 },
          subtract: { 1: !0 },
          exclude: { 1: !0, "-1": !0 }
        };
        function R(D) {
          return D._children || [D];
        }
        function B(D, Se) {
          var le = D.clone(!1).reduce({ simplify: !0 }).transform(null, !0, !0);
          if (Se) {
            for (var v = R(le), se = 0, me = v.length; se < me; se++) {
              var D = v[se];
              !D._closed && !D.isEmpty() && (D.closePath(1e-12), D.getFirstSegment().setHandleIn(0, 0), D.getLastSegment().setHandleOut(0, 0));
            }
            le = le.resolveCrossings().reorient(le.getFillRule() === "nonzero", !0);
          }
          return le;
        }
        function j(D, Se, le, v, se) {
          var me = new de(o.NO_INSERT);
          return me.addChildren(D, !0), me = me.reduce({ simplify: Se }), se && se.insert == !1 || me.insertAbove(v && le.isSibling(v) && le.getIndex() < v.getIndex() ? v : le), me.copyAttributes(le, !0), me;
        }
        function H(D) {
          return D.hasOverlap() || D.isCrossing();
        }
        function X(D, Se, le, v) {
          if (v && (v.trace == !1 || v.stroke) && /^(subtract|intersect)$/.test(le))
            return ue(D, Se, le);
          var se = B(D, !0), me = Se && D !== Se && B(Se, !0), O = C[le];
          O[le] = !0, me && (O.subtract || O.exclude) ^ (me.isClockwise() ^ se.isClockwise()) && me.reverse();
          var ce = K(ie.expand(
            se.getIntersections(me, H)
          )), Oe = R(se), Be = me && R(me), je = [], Fe = [], Ye;
          function Ke(xt) {
            for (var Ot = 0, Nt = xt.length; Ot < Nt; Ot++) {
              var Mt = xt[Ot];
              _.push(je, Mt._segments), _.push(Fe, Mt.getCurves()), Mt._overlapsOnly = !0;
            }
          }
          function et(xt) {
            for (var Ot = [], Nt = 0, Mt = xt && xt.length; Nt < Mt; Nt++)
              Ot.push(Fe[xt[Nt]]);
            return Ot;
          }
          if (ce.length) {
            Ke(Oe), Be && Ke(Be);
            for (var Je = new Array(Fe.length), nt = 0, dt = Fe.length; nt < dt; nt++)
              Je[nt] = Fe[nt].getValues();
            for (var vt = E.findCurveBoundsCollisions(
              Je,
              Je,
              0,
              !0
            ), bt = {}, nt = 0; nt < Fe.length; nt++) {
              var At = Fe[nt], ot = At._path._id, ht = bt[ot] = bt[ot] || {};
              ht[At.getIndex()] = {
                hor: et(vt[nt].hor),
                ver: et(vt[nt].ver)
              };
            }
            for (var nt = 0, dt = ce.length; nt < dt; nt++)
              te(
                ce[nt]._segment,
                se,
                me,
                bt,
                O
              );
            for (var nt = 0, dt = je.length; nt < dt; nt++) {
              var gt = je[nt], Ct = gt._intersection;
              gt._winding || te(
                gt,
                se,
                me,
                bt,
                O
              ), Ct && Ct._overlap || (gt._path._overlapsOnly = !1);
            }
            Ye = he(je, O);
          } else
            Ye = q(
              Be ? Oe.concat(Be) : Oe.slice(),
              function(xt) {
                return !!O[xt];
              }
            );
          return j(Ye, !0, D, Se, v);
        }
        function ue(D, Se, le) {
          var v = B(D), se = B(Se), me = v.getIntersections(se, H), O = le === "subtract", ce = le === "divide", Oe = {}, Be = [];
          function je(Ke) {
            if (!Oe[Ke._id] && (ce || se.contains(Ke.getPointAt(Ke.getLength() / 2)) ^ O))
              return Be.unshift(Ke), Oe[Ke._id] = !0;
          }
          for (var Fe = me.length - 1; Fe >= 0; Fe--) {
            var Ye = me[Fe].split();
            Ye && (je(Ye) && Ye.getFirstSegment().setHandleIn(0, 0), v.getLastSegment().setHandleOut(0, 0));
          }
          return je(v), j(Be, !1, D, Se);
        }
        function pe(D, Se) {
          for (var le = D; le; ) {
            if (le === Se)
              return;
            le = le._previous;
          }
          for (; D._next && D._next !== Se; )
            D = D._next;
          if (!D._next) {
            for (; Se._previous; )
              Se = Se._previous;
            D._next = Se, Se._previous = D;
          }
        }
        function P(D) {
          for (var Se = D.length - 1; Se >= 0; Se--)
            D[Se].clearHandles();
        }
        function q(D, Se, le) {
          var v = D && D.length;
          if (v) {
            var se = _.each(D, function(vt, bt) {
              this[vt._id] = {
                container: null,
                winding: vt.isClockwise() ? 1 : -1,
                index: bt
              };
            }, {}), me = D.slice().sort(function(vt, bt) {
              return f(bt.getArea()) - f(vt.getArea());
            }), O = me[0], ce = E.findItemBoundsCollisions(
              me,
              null,
              u.GEOMETRIC_EPSILON
            );
            le == null && (le = O.isClockwise());
            for (var Oe = 0; Oe < v; Oe++) {
              var Be = me[Oe], je = se[Be._id], Fe = 0, Ye = ce[Oe];
              if (Ye) {
                for (var Ke = null, et = Ye.length - 1; et >= 0; et--)
                  if (Ye[et] < Oe) {
                    Ke = Ke || Be.getInteriorPoint();
                    var Je = me[Ye[et]];
                    if (Je.contains(Ke)) {
                      var nt = se[Je._id];
                      Fe = nt.winding, je.winding += Fe, je.container = nt.exclude ? nt.container : Je;
                      break;
                    }
                  }
              }
              if (Se(je.winding) === Se(Fe))
                je.exclude = !0, D[je.index] = null;
              else {
                var dt = je.container;
                Be.setClockwise(
                  dt ? !dt.isClockwise() : le
                );
              }
            }
          }
          return D;
        }
        function K(D, Se, le) {
          var v = Se && [], se = 1e-8, me = 1 - se, O = !1, ce = le || [], Oe = le && {}, Be, je, Fe;
          function Ye(Ot) {
            return Ot._path._id + "." + Ot._segment1._index;
          }
          for (var Ke = (le && le.length) - 1; Ke >= 0; Ke--) {
            var et = le[Ke];
            et._path && (Oe[Ye(et)] = !0);
          }
          for (var Ke = D.length - 1; Ke >= 0; Ke--) {
            var Je = D[Ke], nt = Je._time, dt = nt, vt = Se && !Se(Je), et = Je._curve, bt;
            if (et && (et !== je ? (O = !et.hasHandles() || Oe && Oe[Ye(et)], Be = [], Fe = null, je = et) : Fe >= se && (nt /= Fe)), vt) {
              Be && Be.push(Je);
              continue;
            } else Se && v.unshift(Je);
            if (Fe = dt, nt < se)
              bt = et._segment1;
            else if (nt > me)
              bt = et._segment2;
            else {
              var At = et.divideAtTime(nt, !0);
              O && ce.push(et, At), bt = At._segment1;
              for (var ot = Be.length - 1; ot >= 0; ot--) {
                var ht = Be[ot];
                ht._time = (ht._time - nt) / (1 - nt);
              }
            }
            Je._setSegment(bt);
            var gt = bt._intersection, Ct = Je._intersection;
            if (gt) {
              pe(gt, Ct);
              for (var xt = gt; xt; )
                pe(xt._intersection, gt), xt = xt._next;
            } else
              bt._intersection = Ct;
          }
          return le || P(ce), v || D;
        }
        function ye(D, Se, le, v, se) {
          var me = Array.isArray(Se) ? Se : Se[le ? "hor" : "ver"], O = le ? 1 : 0, ce = O ^ 1, Oe = [D.x, D.y], Be = Oe[O], je = Oe[ce], Fe = 1e-9, Ye = 1e-6, Ke = Be - Fe, et = Be + Fe, Je = 0, nt = 0, dt = 0, vt = 0, bt = !1, At = !1, ot = 1, ht = [], gt, Ct;
          function xt(wt) {
            var $t = wt[ce + 0], lr = wt[ce + 6];
            if (!(je < e($t, lr) || je > r($t, lr))) {
              var tr = wt[O + 0], Xr = wt[O + 2], gi = wt[O + 4], ii = wt[O + 6];
              if ($t === lr) {
                (tr < et && ii > Ke || ii < et && tr > Ke) && (bt = !0);
                return;
              }
              var Br = je === $t ? 0 : je === lr || Ke > r(tr, Xr, gi, ii) || et < e(tr, Xr, gi, ii) ? 1 : ee.solveCubic(wt, ce, je, ht, 0, 1) > 0 ? ht[0] : 1, Er = Br === 0 ? tr : Br === 1 ? ii : ee.getPoint(wt, Br)[le ? "y" : "x"], kr = $t > lr ? 1 : -1, qr = gt[ce] > gt[ce + 6] ? 1 : -1, yr = gt[O + 6];
              return je !== $t ? (Er < Ke ? dt += kr : Er > et ? vt += kr : bt = !0, Er > Be - Ye && Er < Be + Ye && (ot /= 2)) : (kr !== qr ? tr < Ke ? dt += kr : tr > et && (vt += kr) : tr != yr && (yr < et && Er > et ? (vt += kr, bt = !0) : yr > Ke && Er < Ke && (dt += kr, bt = !0)), ot /= 4), gt = wt, !se && Er > Ke && Er < et && ee.getTangent(wt, Br)[le ? "x" : "y"] === 0 && ye(D, Se, !le, v, !0);
            }
          }
          function Ot(wt) {
            var $t = wt[ce + 0], lr = wt[ce + 2], tr = wt[ce + 4], Xr = wt[ce + 6];
            if (je <= r($t, lr, tr, Xr) && je >= e($t, lr, tr, Xr)) {
              for (var gi = wt[O + 0], ii = wt[O + 2], Br = wt[O + 4], Er = wt[O + 6], kr = Ke > r(gi, ii, Br, Er) || et < e(gi, ii, Br, Er) ? [wt] : ee.getMonoCurves(wt, le), qr, yr = 0, Or = kr.length; yr < Or; yr++)
                if (qr = xt(kr[yr]))
                  return qr;
            }
          }
          for (var Nt = 0, Mt = me.length; Nt < Mt; Nt++) {
            var Gt = me[Nt], Bt = Gt._path, or = Gt.getValues(), ar;
            if ((!Nt || me[Nt - 1]._path !== Bt) && (gt = null, Bt._closed || (Ct = ee.getValues(
              Bt.getLastCurve().getSegment2(),
              Gt.getSegment1(),
              null,
              !v
            ), Ct[ce] !== Ct[ce + 6] && (gt = Ct)), !gt)) {
              gt = or;
              for (var ur = Bt.getLastCurve(); ur && ur !== Gt; ) {
                var hr = ur.getValues();
                if (hr[ce] !== hr[ce + 6]) {
                  gt = hr;
                  break;
                }
                ur = ur.getPrevious();
              }
            }
            if (ar = Ot(or))
              return ar;
            if (Nt + 1 === Mt || me[Nt + 1]._path !== Bt) {
              if (Ct && (ar = Ot(Ct)))
                return ar;
              bt && !dt && !vt && (dt = vt = Bt.isClockwise(v) ^ le ? 1 : -1), Je += dt, nt += vt, dt = vt = 0, bt && (At = !0, bt = !1), Ct = null;
            }
          }
          return Je = f(Je), nt = f(nt), {
            winding: r(Je, nt),
            windingL: Je,
            windingR: nt,
            quality: ot,
            onPath: At
          };
        }
        function te(D, Se, le, v, se) {
          var me = [], O = D, ce = 0, Fe;
          do {
            var Oe = D.getCurve();
            if (Oe) {
              var Be = Oe.getLength();
              me.push({ segment: D, curve: Oe, length: Be }), ce += Be;
            }
            D = D.getNext();
          } while (D && !D._intersection && D !== O);
          for (var je = [0.5, 0.25, 0.75], Fe = { winding: 0, quality: -1 }, Ye = 1e-3, Ke = 1 - Ye, et = 0; et < je.length && Fe.quality < 0.5; et++)
            for (var Be = ce * je[et], Je = 0, nt = me.length; Je < nt; Je++) {
              var dt = me[Je], vt = dt.length;
              if (Be <= vt) {
                var Oe = dt.curve, bt = Oe._path, At = bt._parent, ot = At instanceof de ? At : bt, ht = u.clamp(Oe.getTimeAt(Be), Ye, Ke), gt = Oe.getPointAtTime(ht), Ct = f(Oe.getTangentAtTime(ht).y) < Math.SQRT1_2, xt = null;
                if (se.subtract && le) {
                  var Ot = ot === Se ? le : Se, Nt = Ot._getWinding(gt, Ct, !0);
                  if (ot === Se && Nt.winding || ot === le && !Nt.winding) {
                    if (Nt.quality < 1)
                      continue;
                    xt = { winding: 0, quality: 1 };
                  }
                }
                xt = xt || ye(
                  gt,
                  v[bt._id][Oe.getIndex()],
                  Ct,
                  !0
                ), xt.quality > Fe.quality && (Fe = xt);
                break;
              }
              Be -= vt;
            }
          for (var Je = me.length - 1; Je >= 0; Je--)
            me[Je].segment._winding = Fe;
        }
        function he(D, Se) {
          var le = [], v;
          function se(Mt) {
            var Gt;
            return !!(Mt && !Mt._visited && (!Se || Se[(Gt = Mt._winding || {}).winding] && !(Se.unite && Gt.winding === 2 && Gt.windingL && Gt.windingR)));
          }
          function me(Mt) {
            if (Mt) {
              for (var Gt = 0, Bt = v.length; Gt < Bt; Gt++)
                if (Mt === v[Gt])
                  return !0;
            }
            return !1;
          }
          function O(Mt) {
            for (var Gt = Mt._segments, Bt = 0, or = Gt.length; Bt < or; Bt++)
              Gt[Bt]._visited = !0;
          }
          function ce(Mt, Gt) {
            var Bt = Mt._intersection, or = Bt, ar = [];
            Gt && (v = [Mt]);
            function ur(hr, wt) {
              for (; hr && hr !== wt; ) {
                var $t = hr._segment, lr = $t && $t._path;
                if (lr) {
                  var tr = $t.getNext() || lr.getFirstSegment(), Xr = tr._intersection;
                  $t !== Mt && (me($t) || me(tr) || tr && se($t) && (se(tr) || Xr && se(Xr._segment))) && ar.push($t), Gt && v.push($t);
                }
                hr = hr._next;
              }
            }
            if (Bt) {
              for (ur(Bt); Bt && Bt._previous; )
                Bt = Bt._previous;
              ur(Bt, or);
            }
            return ar;
          }
          D.sort(function(Mt, Gt) {
            var Bt = Mt._intersection, or = Gt._intersection, ar = !!(Bt && Bt._overlap), ur = !!(or && or._overlap), hr = Mt._path, wt = Gt._path;
            return ar ^ ur ? ar ? 1 : -1 : !Bt ^ !or ? Bt ? 1 : -1 : hr !== wt ? hr._id - wt._id : Mt._index - Gt._index;
          });
          for (var Oe = 0, Be = D.length; Oe < Be; Oe++) {
            var je = D[Oe], Fe = se(je), Ye = null, Ke = !1, et = !0, Je = [], nt, dt, vt;
            if (Fe && je._path._overlapsOnly) {
              var bt = je._path, At = je._intersection._segment._path;
              bt.compare(At) && (bt.getArea() && le.push(bt.clone(!1)), O(bt), O(At), Fe = !1);
            }
            for (; Fe; ) {
              var ot = !Ye, ht = ce(je, ot), gt = ht.shift(), Ke = !ot && (me(je) || me(gt)), Ct = !Ke && gt;
              if (ot && (Ye = new Q(o.NO_INSERT), nt = null), Ke) {
                (je.isFirst() || je.isLast()) && (et = je._path._closed), je._visited = !0;
                break;
              }
              if (Ct && nt && (Je.push(nt), nt = null), nt || (Ct && ht.push(je), nt = {
                start: Ye._segments.length,
                crossings: ht,
                visited: dt = [],
                handleIn: vt
              }), Ct && (je = gt), !se(je)) {
                Ye.removeSegments(nt.start);
                for (var xt = 0, Ot = dt.length; xt < Ot; xt++)
                  dt[xt]._visited = !1;
                dt.length = 0;
                do
                  je = nt && nt.crossings.shift(), (!je || !je._path) && (je = null, nt = Je.pop(), nt && (dt = nt.visited, vt = nt.handleIn));
                while (nt && !se(je));
                if (!je)
                  break;
              }
              var Nt = je.getNext();
              Ye.add(new F(
                je._point,
                vt,
                Nt && je._handleOut
              )), je._visited = !0, dt.push(je), je = Nt || je._path.getFirstSegment(), vt = Nt && Nt._handleIn;
            }
            Ke && (et && (Ye.getFirstSegment().setHandleIn(vt), Ye.setClosed(et)), Ye.getArea() !== 0 && le.push(Ye));
          }
          return le;
        }
        return {
          _getWinding: function(D, Se, le) {
            return ye(D, this.getCurves(), Se, le);
          },
          unite: function(D, Se) {
            return X(this, D, "unite", Se);
          },
          intersect: function(D, Se) {
            return X(this, D, "intersect", Se);
          },
          subtract: function(D, Se) {
            return X(this, D, "subtract", Se);
          },
          exclude: function(D, Se) {
            return X(this, D, "exclude", Se);
          },
          divide: function(D, Se) {
            return Se && (Se.trace == !1 || Se.stroke) ? ue(this, D, "divide") : j([
              this.subtract(D, Se),
              this.intersect(D, Se)
            ], !0, this, D, Se);
          },
          resolveCrossings: function() {
            var D = this._children, Se = D || [this];
            function le(nt, dt) {
              var vt = nt && nt._intersection;
              return vt && vt._overlap && vt._path === dt;
            }
            var v = !1, se = !1, me = this.getIntersections(null, function(nt) {
              return nt.hasOverlap() && (v = !0) || nt.isCrossing() && (se = !0);
            }), O = v && se && [];
            if (me = ie.expand(me), v)
              for (var ce = K(me, function(nt) {
                return nt.hasOverlap();
              }, O), Oe = ce.length - 1; Oe >= 0; Oe--) {
                var Be = ce[Oe], je = Be._path, Fe = Be._segment, Ye = Fe.getPrevious(), Ke = Fe.getNext();
                le(Ye, je) && le(Ke, je) && (Fe.remove(), Ye._handleOut._set(0, 0), Ke._handleIn._set(0, 0), Ye !== Fe && !Ye.getCurve().hasLength() && (Ke._handleIn.set(Ye._handleIn), Ye.remove()));
              }
            se && (K(me, v && function(nt) {
              var dt = nt.getCurve(), vt = nt.getSegment(), bt = nt._intersection, At = bt._curve, ot = bt._segment;
              if (dt && At && dt._path && At._path)
                return !0;
              vt && (vt._intersection = null), ot && (ot._intersection = null);
            }, O), O && P(O), Se = he(_.each(Se, function(nt) {
              _.push(this, nt._segments);
            }, [])));
            var et = Se.length, Je;
            return et > 1 && D ? (Se !== D && this.setChildren(Se), Je = this) : et === 1 && !D && (Se[0] !== this && this.setSegments(Se[0].removeSegments()), Je = this), Je || (Je = new de(o.NO_INSERT), Je.addChildren(Se), Je = Je.reduce(), Je.copyAttributes(this), this.replaceWith(Je)), Je;
          },
          reorient: function(D, Se) {
            var le = this._children;
            return le && le.length ? this.setChildren(q(
              this.removeChildren(),
              function(v) {
                return !!(D ? v : v & 1);
              },
              Se
            )) : Se !== ae && this.setClockwise(Se), this;
          },
          getInteriorPoint: function() {
            var D = this.getBounds(), Se = D.getCenter(!0);
            if (!this.contains(Se)) {
              for (var le = this.getCurves(), v = Se.y, se = [], me = [], O = 0, ce = le.length; O < ce; O++) {
                var Oe = le[O].getValues(), Be = Oe[1], je = Oe[3], Fe = Oe[5], Ye = Oe[7];
                if (v >= e(Be, je, Fe, Ye) && v <= r(Be, je, Fe, Ye))
                  for (var Ke = ee.getMonoCurves(Oe), et = 0, Je = Ke.length; et < Je; et++) {
                    var nt = Ke[et], dt = nt[1], vt = nt[7];
                    if (dt !== vt && (v >= dt && v <= vt || v >= vt && v <= dt)) {
                      var bt = v === dt ? nt[0] : v === vt ? nt[6] : ee.solveCubic(nt, 1, v, me, 0, 1) === 1 ? ee.getPoint(nt, me[0]).x : (nt[0] + nt[6]) / 2;
                      se.push(bt);
                    }
                  }
              }
              se.length > 1 && (se.sort(function(At, ot) {
                return At - ot;
              }), Se.x = (se[0] + se[1]) / 2);
            }
            return Se;
          }
        };
      }());
      var we = _.extend(
        {
          _class: "PathFlattener",
          initialize: function(e, r, f, C, R) {
            var B = [], j = [], H = 0, X = 1 / (f || 32), ue = e._segments, pe = ue[0], P;
            function q(he, D) {
              var Se = ee.getValues(he, D, R);
              B.push(Se), K(Se, he._index, 0, 1);
            }
            function K(he, D, Se, le) {
              if (le - Se > X && !(C && ee.isStraight(he)) && !ee.isFlatEnough(he, r || 0.25)) {
                var v = ee.subdivide(he, 0.5), se = (Se + le) / 2;
                K(v[0], D, Se, se), K(v[1], D, se, le);
              } else {
                var me = he[6] - he[0], O = he[7] - he[1], ce = Math.sqrt(me * me + O * O);
                ce > 0 && (H += ce, j.push({
                  offset: H,
                  curve: he,
                  index: D,
                  time: le
                }));
              }
            }
            for (var ye = 1, te = ue.length; ye < te; ye++)
              P = ue[ye], q(pe, P), pe = P;
            e._closed && q(P || pe, ue[0]), this.curves = B, this.parts = j, this.length = H, this.index = 0;
          },
          _get: function(e) {
            for (var r = this.parts, f = r.length, C, R = this.index; C = R, !(!R || r[--R].offset < e); )
              ;
            for (; C < f; C++) {
              var B = r[C];
              if (B.offset >= e) {
                this.index = C;
                var j = r[C - 1], H = j && j.index === B.index ? j.time : 0, X = j ? j.offset : 0;
                return {
                  index: B.index,
                  time: H + (B.time - H) * (e - X) / (B.offset - X)
                };
              }
            }
            return {
              index: r[f - 1].index,
              time: 1
            };
          },
          drawPart: function(e, r, f) {
            for (var C = this._get(r), R = this._get(f), B = C.index, j = R.index; B <= j; B++) {
              var H = ee.getPart(
                this.curves[B],
                B === C.index ? C.time : 0,
                B === R.index ? R.time : 1
              );
              B === C.index && e.moveTo(H[0], H[1]), e.bezierCurveTo.apply(e, H.slice(2));
            }
          }
        },
        _.each(
          ee._evaluateMethods,
          function(e) {
            this[e + "At"] = function(r) {
              var f = this._get(r);
              return ee[e](this.curves[f.index], f.time);
            };
          },
          {}
        )
      ), ke = _.extend({
        initialize: function(e) {
          for (var r = this.points = [], f = e._segments, C = e._closed, R = 0, B, j = f.length; R < j; R++) {
            var H = f[R].point;
            (!B || !B.equals(H)) && r.push(B = H.clone());
          }
          C && (r.unshift(r[r.length - 1]), r.push(r[1])), this.closed = C;
        },
        fit: function(e) {
          var r = this.points, f = r.length, C = null;
          return f > 0 && (C = [new F(r[0])], f > 1 && (this.fitCubic(
            C,
            e,
            0,
            f - 1,
            r[1].subtract(r[0]),
            r[f - 2].subtract(r[f - 1])
          ), this.closed && (C.shift(), C.pop()))), C;
        },
        fitCubic: function(e, r, f, C, R, B) {
          var j = this.points;
          if (C - f === 1) {
            var H = j[f], X = j[C], ue = H.getDistance(X) / 3;
            this.addCurve(e, [
              H,
              H.add(R.normalize(ue)),
              X.add(B.normalize(ue)),
              X
            ]);
            return;
          }
          for (var pe = this.chordLengthParameterize(f, C), P = Math.max(r, r * r), q, K = !0, ye = 0; ye <= 4; ye++) {
            var te = this.generateBezier(f, C, pe, R, B), he = this.findMaxError(f, C, te, pe);
            if (he.error < r && K) {
              this.addCurve(e, te);
              return;
            }
            if (q = he.index, he.error >= P)
              break;
            K = this.reparameterize(f, C, pe, te), P = he.error;
          }
          var D = j[q - 1].subtract(j[q + 1]);
          this.fitCubic(e, r, f, q, R, D), this.fitCubic(e, r, q, C, D.negate(), B);
        },
        addCurve: function(e, r) {
          var f = e[e.length - 1];
          f.setHandleOut(r[1].subtract(r[0])), e.push(new F(r[3], r[2].subtract(r[3])));
        },
        generateBezier: function(e, r, f, C, R) {
          for (var B = 1e-12, j = Math.abs, H = this.points, X = H[e], ue = H[r], pe = [[0, 0], [0, 0]], P = [0, 0], q = 0, K = r - e + 1; q < K; q++) {
            var ye = f[q], te = 1 - ye, he = 3 * ye * te, D = te * te * te, Se = he * te, le = he * ye, v = ye * ye * ye, se = C.normalize(Se), me = R.normalize(le), O = H[e + q].subtract(X.multiply(D + Se)).subtract(ue.multiply(le + v));
            pe[0][0] += se.dot(se), pe[0][1] += se.dot(me), pe[1][0] = pe[0][1], pe[1][1] += me.dot(me), P[0] += se.dot(O), P[1] += me.dot(O);
          }
          var ce = pe[0][0] * pe[1][1] - pe[1][0] * pe[0][1], Oe, Be;
          if (j(ce) > B) {
            var je = pe[0][0] * P[1] - pe[1][0] * P[0], Fe = P[0] * pe[1][1] - P[1] * pe[0][1];
            Oe = Fe / ce, Be = je / ce;
          } else {
            var Ye = pe[0][0] + pe[0][1], Ke = pe[1][0] + pe[1][1];
            Oe = Be = j(Ye) > B ? P[0] / Ye : j(Ke) > B ? P[1] / Ke : 0;
          }
          var et = ue.getDistance(X), Je = B * et, nt, dt;
          if (Oe < Je || Be < Je)
            Oe = Be = et / 3;
          else {
            var vt = ue.subtract(X);
            nt = C.normalize(Oe), dt = R.normalize(Be), nt.dot(vt) - dt.dot(vt) > et * et && (Oe = Be = et / 3, nt = dt = null);
          }
          return [
            X,
            X.add(nt || C.normalize(Oe)),
            ue.add(dt || R.normalize(Be)),
            ue
          ];
        },
        reparameterize: function(e, r, f, C) {
          for (var R = e; R <= r; R++)
            f[R - e] = this.findRoot(C, this.points[R], f[R - e]);
          for (var R = 1, B = f.length; R < B; R++)
            if (f[R] <= f[R - 1])
              return !1;
          return !0;
        },
        findRoot: function(e, r, f) {
          for (var C = [], R = [], B = 0; B <= 2; B++)
            C[B] = e[B + 1].subtract(e[B]).multiply(3);
          for (var B = 0; B <= 1; B++)
            R[B] = C[B + 1].subtract(C[B]).multiply(2);
          var j = this.evaluate(3, e, f), H = this.evaluate(2, C, f), X = this.evaluate(1, R, f), ue = j.subtract(r), pe = H.dot(H) + ue.dot(X);
          return u.isMachineZero(pe) ? f : f - ue.dot(H) / pe;
        },
        evaluate: function(e, r, f) {
          for (var C = r.slice(), R = 1; R <= e; R++)
            for (var B = 0; B <= e - R; B++)
              C[B] = C[B].multiply(1 - f).add(C[B + 1].multiply(f));
          return C[0];
        },
        chordLengthParameterize: function(e, r) {
          for (var f = [0], C = e + 1; C <= r; C++)
            f[C - e] = f[C - e - 1] + this.points[C].getDistance(this.points[C - 1]);
          for (var C = 1, R = r - e; C <= R; C++)
            f[C] /= f[R];
          return f;
        },
        findMaxError: function(e, r, f, C) {
          for (var R = Math.floor((r - e + 1) / 2), B = 0, j = e + 1; j < r; j++) {
            var H = this.evaluate(3, f, C[j - e]), X = H.subtract(this.points[j]), ue = X.x * X.x + X.y * X.y;
            ue >= B && (B = ue, R = j);
          }
          return {
            error: B,
            index: R
          };
        }
      }), Me = o.extend({
        _class: "TextItem",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _serializeFields: {
          content: null
        },
        _boundsOptions: { stroke: !1, handle: !1 },
        initialize: function(r) {
          this._content = "", this._lines = [];
          var f = r && _.isPlainObject(r) && r.x === ae && r.y === ae;
          this._initialize(f && r, !f && a.read(arguments));
        },
        _equals: function(e) {
          return this._content === e._content;
        },
        copyContent: function(e) {
          this.setContent(e._content);
        },
        getContent: function() {
          return this._content;
        },
        setContent: function(e) {
          this._content = "" + e, this._lines = this._content.split(/\r\n|\n|\r/mg), this._changed(521);
        },
        isEmpty: function() {
          return !this._content;
        },
        getCharacterStyle: "#getStyle",
        setCharacterStyle: "#setStyle",
        getParagraphStyle: "#getStyle",
        setParagraphStyle: "#setStyle"
      }), fe = Me.extend({
        _class: "PointText",
        initialize: function() {
          Me.apply(this, arguments);
        },
        getPoint: function() {
          var e = this._matrix.getTranslation();
          return new n(e.x, e.y, this, "setPoint");
        },
        setPoint: function() {
          var e = a.read(arguments);
          this.translate(e.subtract(this._matrix.getTranslation()));
        },
        _draw: function(e, r, f) {
          if (this._content) {
            this._setStyles(e, r, f);
            var C = this._lines, R = this._style, B = R.hasFill(), j = R.hasStroke(), H = R.getLeading(), X = e.shadowColor;
            e.font = R.getFontStyle(), e.textAlign = R.getJustification();
            for (var ue = 0, pe = C.length; ue < pe; ue++) {
              e.shadowColor = X;
              var P = C[ue];
              B && (e.fillText(P, 0, 0), e.shadowColor = "rgba(0,0,0,0)"), j && e.strokeText(P, 0, 0), e.translate(0, H);
            }
          }
        },
        _getBounds: function(e, r) {
          var f = this._style, C = this._lines, R = C.length, B = f.getJustification(), j = f.getLeading(), H = this.getView().getTextWidth(f.getFontStyle(), C), X = 0;
          B !== "left" && (X -= H / (B === "center" ? 2 : 1));
          var ue = new h(
            X,
            R ? -0.75 * j : 0,
            H,
            R * j
          );
          return e ? e._transformBounds(ue, ue) : ue;
        }
      }), xe = _.extend(
        new function() {
          var e = {
            gray: ["gray"],
            rgb: ["red", "green", "blue"],
            hsb: ["hue", "saturation", "brightness"],
            hsl: ["hue", "saturation", "lightness"],
            gradient: ["gradient", "origin", "destination", "highlight"]
          }, r = {}, f = {
            transparent: [0, 0, 0, 0]
          }, C;
          function R(H) {
            var X = H.match(
              /^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i
            ) || H.match(
              /^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i
            ), ue = "rgb", pe;
            if (X) {
              var P = X[4] ? 4 : 3;
              pe = new Array(P);
              for (var q = 0; q < P; q++) {
                var K = X[q + 1];
                pe[q] = parseInt(K.length == 1 ? K + K : K, 16) / 255;
              }
            } else if (X = H.match(/^(rgb|hsl)a?\((.*)\)$/)) {
              ue = X[1], pe = X[2].trim().split(/[,\s]+/g);
              for (var ye = ue === "hsl", q = 0, te = Math.min(pe.length, 4); q < te; q++) {
                var he = pe[q], K = parseFloat(he);
                if (ye)
                  if (q === 0) {
                    var D = he.match(/([a-z]*)$/)[1];
                    K *= {
                      turn: 360,
                      rad: 180 / Math.PI,
                      grad: 0.9
                    }[D] || 1;
                  } else q < 3 && (K /= 100);
                else q < 3 && (K /= /%$/.test(he) ? 100 : 255);
                pe[q] = K;
              }
            } else {
              var Se = f[H];
              if (!Se)
                if (k) {
                  C || (C = Ce.getContext(1, 1, {
                    willReadFrequently: !0
                  }), C.globalCompositeOperation = "copy"), C.fillStyle = "rgba(0,0,0,0)", C.fillStyle = H, C.fillRect(0, 0, 1, 1);
                  var le = C.getImageData(0, 0, 1, 1).data;
                  Se = f[H] = [
                    le[0] / 255,
                    le[1] / 255,
                    le[2] / 255
                  ];
                } else
                  Se = [0, 0, 0];
              pe = Se.slice();
            }
            return [ue, pe];
          }
          var B = [
            [0, 3, 1],
            [2, 0, 1],
            [1, 0, 3],
            [1, 2, 0],
            [3, 1, 0],
            [0, 1, 2]
          ], j = {
            "rgb-hsb": function(H, X, ue) {
              var pe = Math.max(H, X, ue), P = Math.min(H, X, ue), q = pe - P, K = q === 0 ? 0 : (pe == H ? (X - ue) / q + (X < ue ? 6 : 0) : pe == X ? (ue - H) / q + 2 : (H - X) / q + 4) * 60;
              return [K, pe === 0 ? 0 : q / pe, pe];
            },
            "hsb-rgb": function(H, X, ue) {
              H = (H / 60 % 6 + 6) % 6;
              var P = Math.floor(H), pe = H - P, P = B[P], q = [
                ue,
                ue * (1 - X),
                ue * (1 - X * pe),
                ue * (1 - X * (1 - pe))
              ];
              return [q[P[0]], q[P[1]], q[P[2]]];
            },
            "rgb-hsl": function(H, X, ue) {
              var pe = Math.max(H, X, ue), P = Math.min(H, X, ue), q = pe - P, K = q === 0, ye = K ? 0 : (pe == H ? (X - ue) / q + (X < ue ? 6 : 0) : pe == X ? (ue - H) / q + 2 : (H - X) / q + 4) * 60, te = (pe + P) / 2, he = K ? 0 : te < 0.5 ? q / (pe + P) : q / (2 - pe - P);
              return [ye, he, te];
            },
            "hsl-rgb": function(H, X, ue) {
              if (H = (H / 360 % 1 + 1) % 1, X === 0)
                return [ue, ue, ue];
              for (var pe = [H + 1 / 3, H, H - 1 / 3], P = ue < 0.5 ? ue * (1 + X) : ue + X - ue * X, q = 2 * ue - P, K = [], ye = 0; ye < 3; ye++) {
                var te = pe[ye];
                te < 0 && (te += 1), te > 1 && (te -= 1), K[ye] = 6 * te < 1 ? q + (P - q) * 6 * te : 2 * te < 1 ? P : 3 * te < 2 ? q + (P - q) * (2 / 3 - te) * 6 : q;
              }
              return K;
            },
            "rgb-gray": function(H, X, ue) {
              return [H * 0.2989 + X * 0.587 + ue * 0.114];
            },
            "gray-rgb": function(H) {
              return [H, H, H];
            },
            "gray-hsb": function(H) {
              return [0, 0, H];
            },
            "gray-hsl": function(H) {
              return [0, 0, H];
            },
            "gradient-rgb": function() {
              return [];
            },
            "rgb-gradient": function() {
              return [];
            }
          };
          return _.each(e, function(H, X) {
            r[X] = [], _.each(H, function(ue, pe) {
              var P = _.capitalize(ue), q = /^(hue|saturation)$/.test(ue), K = r[X][pe] = X === "gradient" ? ue === "gradient" ? function(ye) {
                var te = this._components[0];
                return ye = Ee.read(
                  Array.isArray(ye) ? ye : arguments,
                  0,
                  { readNull: !0 }
                ), te !== ye && (te && te._removeOwner(this), ye && ye._addOwner(this)), ye;
              } : function() {
                return a.read(arguments, 0, {
                  readNull: ue === "highlight",
                  clone: !0
                });
              } : function(ye) {
                return ye == null || isNaN(ye) ? 0 : +ye;
              };
              this["get" + P] = function() {
                return this._type === X || q && /^hs[bl]$/.test(this._type) ? this._components[pe] : this._convert(X)[pe];
              }, this["set" + P] = function(ye) {
                this._type !== X && !(q && /^hs[bl]$/.test(this._type)) && (this._components = this._convert(X), this._properties = e[X], this._type = X), this._components[pe] = K.call(this, ye), this._changed();
              };
            }, this);
          }, {
            _class: "Color",
            _readIndex: !0,
            initialize: function H(X) {
              var ue = arguments, pe = this.__read, P = 0, q, K, ye, te;
              Array.isArray(X) && (ue = X, X = ue[0]);
              var he = X != null && typeof X;
              if (he === "string" && X in e && (q = X, X = ue[1], Array.isArray(X) ? (K = X, ye = ue[2]) : (pe && (P = 1), ue = _.slice(ue, 1), he = typeof X)), !K) {
                if (te = he === "number" ? ue : he === "object" && X.length != null ? X : null, te) {
                  q || (q = te.length >= 3 ? "rgb" : "gray");
                  var D = e[q].length;
                  ye = te[D], pe && (P += te === arguments ? D + (ye != null ? 1 : 0) : 1), te.length > D && (te = _.slice(te, 0, D));
                } else if (he === "string") {
                  var Se = R(X);
                  q = Se[0], K = Se[1], K.length === 4 && (ye = K[3], K.length--);
                } else if (he === "object")
                  if (X.constructor === H) {
                    if (q = X._type, K = X._components.slice(), ye = X._alpha, q === "gradient")
                      for (var le = 1, v = K.length; le < v; le++) {
                        var se = K[le];
                        se && (K[le] = se.clone());
                      }
                  } else if (X.constructor === Ee)
                    q = "gradient", te = ue;
                  else {
                    q = "hue" in X ? "lightness" in X ? "hsl" : "hsb" : "gradient" in X || "stops" in X || "radial" in X ? "gradient" : "gray" in X ? "gray" : "rgb";
                    var me = e[q], O = r[q];
                    this._components = K = [];
                    for (var le = 0, v = me.length; le < v; le++) {
                      var ce = X[me[le]];
                      ce == null && !le && q === "gradient" && "stops" in X && (ce = {
                        stops: X.stops,
                        radial: X.radial
                      }), ce = O[le].call(this, ce), ce != null && (K[le] = ce);
                    }
                    ye = X.alpha;
                  }
                pe && q && (P = 1);
              }
              if (this._type = q || "rgb", !K) {
                this._components = K = [];
                for (var O = r[this._type], le = 0, v = O.length; le < v; le++) {
                  var ce = O[le].call(this, te && te[le]);
                  ce != null && (K[le] = ce);
                }
              }
              return this._components = K, this._properties = e[this._type], this._alpha = ye, pe && (this.__read = P), this;
            },
            set: "#initialize",
            _serialize: function(H, X) {
              var ue = this.getComponents();
              return _.serialize(
                /^(gray|rgb)$/.test(this._type) ? ue : [this._type].concat(ue),
                H,
                !0,
                X
              );
            },
            _changed: function() {
              this._canvasStyle = null, this._owner && (this._setter ? this._owner[this._setter](this) : this._owner._changed(129));
            },
            _convert: function(H) {
              var X;
              return this._type === H ? this._components.slice() : (X = j[this._type + "-" + H]) ? X.apply(this, this._components) : j["rgb-" + H].apply(
                this,
                j[this._type + "-rgb"].apply(
                  this,
                  this._components
                )
              );
            },
            convert: function(H) {
              return new xe(H, this._convert(H), this._alpha);
            },
            getType: function() {
              return this._type;
            },
            setType: function(H) {
              this._components = this._convert(H), this._properties = e[H], this._type = H;
            },
            getComponents: function() {
              var H = this._components.slice();
              return this._alpha != null && H.push(this._alpha), H;
            },
            getAlpha: function() {
              return this._alpha != null ? this._alpha : 1;
            },
            setAlpha: function(H) {
              this._alpha = H == null ? null : Math.min(Math.max(H, 0), 1), this._changed();
            },
            hasAlpha: function() {
              return this._alpha != null;
            },
            equals: function(H) {
              var X = _.isPlainValue(H, !0) ? xe.read(arguments) : H;
              return X === this || X && this._class === X._class && this._type === X._type && this.getAlpha() === X.getAlpha() && _.equals(this._components, X._components) || !1;
            },
            toString: function() {
              for (var H = this._properties, X = [], ue = this._type === "gradient", pe = c.instance, P = 0, q = H.length; P < q; P++) {
                var K = this._components[P];
                K != null && X.push(H[P] + ": " + (ue ? K : pe.number(K)));
              }
              return this._alpha != null && X.push("alpha: " + pe.number(this._alpha)), "{ " + X.join(", ") + " }";
            },
            toCSS: function(H) {
              var X = this._convert("rgb"), ue = H || this._alpha == null ? 1 : this._alpha;
              function pe(P) {
                return Math.round((P < 0 ? 0 : P > 1 ? 1 : P) * 255);
              }
              return X = [
                pe(X[0]),
                pe(X[1]),
                pe(X[2])
              ], ue < 1 && X.push(ue < 0 ? 0 : ue), H ? "#" + ((1 << 24) + (X[0] << 16) + (X[1] << 8) + X[2]).toString(16).slice(1) : (X.length == 4 ? "rgba(" : "rgb(") + X.join(",") + ")";
            },
            toCanvasStyle: function(H, X) {
              if (this._canvasStyle)
                return this._canvasStyle;
              if (this._type !== "gradient")
                return this._canvasStyle = this.toCSS();
              var ue = this._components, pe = ue[0], P = pe._stops, q = ue[1], K = ue[2], ye = ue[3], te = X && X.inverted(), he;
              if (te && (q = te._transformPoint(q), K = te._transformPoint(K), ye && (ye = te._transformPoint(ye))), pe._radial) {
                var D = K.getDistance(q);
                if (ye) {
                  var Se = ye.subtract(q);
                  Se.getLength() > D && (ye = q.add(Se.normalize(D - 0.1)));
                }
                var le = ye || q;
                he = H.createRadialGradient(
                  le.x,
                  le.y,
                  0,
                  q.x,
                  q.y,
                  D
                );
              } else
                he = H.createLinearGradient(
                  q.x,
                  q.y,
                  K.x,
                  K.y
                );
              for (var v = 0, se = P.length; v < se; v++) {
                var me = P[v], O = me._offset;
                he.addColorStop(
                  O ?? v / (se - 1),
                  me._color.toCanvasStyle()
                );
              }
              return this._canvasStyle = he;
            },
            transform: function(H) {
              if (this._type === "gradient") {
                for (var X = this._components, ue = 1, pe = X.length; ue < pe; ue++) {
                  var P = X[ue];
                  H._transformPoint(P, P, !0);
                }
                this._changed();
              }
            },
            statics: {
              _types: e,
              random: function() {
                var H = Math.random;
                return new xe(H(), H(), H());
              },
              _setOwner: function(H, X, ue) {
                return H && (H._owner && X && H._owner !== X && (H = H.clone()), !H._owner ^ !X && (H._owner = X || null, H._setter = ue || null)), H;
              }
            }
          });
        }(),
        new function() {
          var e = {
            add: function(r, f) {
              return r + f;
            },
            subtract: function(r, f) {
              return r - f;
            },
            multiply: function(r, f) {
              return r * f;
            },
            divide: function(r, f) {
              return r / f;
            }
          };
          return _.each(e, function(r, f) {
            this[f] = function(C) {
              C = xe.read(arguments);
              for (var R = this._type, B = this._components, j = C._convert(R), H = 0, X = B.length; H < X; H++)
                j[H] = r(B[H], j[H]);
              return new xe(
                R,
                j,
                this._alpha != null ? r(this._alpha, C.getAlpha()) : null
              );
            };
          }, {});
        }()
      ), Ee = _.extend({
        _class: "Gradient",
        initialize: function(r, f) {
          this._id = l.get(), r && _.isPlainObject(r) && (this.set(r), r = f = null), this._stops == null && this.setStops(r || ["white", "black"]), this._radial == null && this.setRadial(typeof f == "string" && f === "radial" || f || !1);
        },
        _serialize: function(e, r) {
          return r.add(this, function() {
            return _.serialize(
              [this._stops, this._radial],
              e,
              !0,
              r
            );
          });
        },
        _changed: function() {
          for (var e = 0, r = this._owners && this._owners.length; e < r; e++)
            this._owners[e]._changed();
        },
        _addOwner: function(e) {
          this._owners || (this._owners = []), this._owners.push(e);
        },
        _removeOwner: function(e) {
          var r = this._owners ? this._owners.indexOf(e) : -1;
          r != -1 && (this._owners.splice(r, 1), this._owners.length || (this._owners = ae));
        },
        clone: function() {
          for (var e = [], r = 0, f = this._stops.length; r < f; r++)
            e[r] = this._stops[r].clone();
          return new Ee(e, this._radial);
        },
        getStops: function() {
          return this._stops;
        },
        setStops: function(e) {
          if (e.length < 2)
            throw new Error(
              "Gradient stop list needs to contain at least two stops."
            );
          var r = this._stops;
          if (r)
            for (var f = 0, C = r.length; f < C; f++)
              r[f]._owner = ae;
          r = this._stops = Pe.readList(e, 0, { clone: !0 });
          for (var f = 0, C = r.length; f < C; f++)
            r[f]._owner = this;
          this._changed();
        },
        getRadial: function() {
          return this._radial;
        },
        setRadial: function(e) {
          this._radial = e, this._changed();
        },
        equals: function(e) {
          if (e === this)
            return !0;
          if (e && this._class === e._class) {
            var r = this._stops, f = e._stops, C = r.length;
            if (C === f.length) {
              for (var R = 0; R < C; R++)
                if (!r[R].equals(f[R]))
                  return !1;
              return !0;
            }
          }
          return !1;
        }
      }), Pe = _.extend({
        _class: "GradientStop",
        initialize: function(r, f) {
          var C = r, R = f;
          typeof r == "object" && f === ae && (Array.isArray(r) && typeof r[0] != "number" ? (C = r[0], R = r[1]) : ("color" in r || "offset" in r || "rampPoint" in r) && (C = r.color, R = r.offset || r.rampPoint || 0)), this.setColor(C), this.setOffset(R);
        },
        clone: function() {
          return new Pe(this._color.clone(), this._offset);
        },
        _serialize: function(e, r) {
          var f = this._color, C = this._offset;
          return _.serialize(
            C == null ? [f] : [f, C],
            e,
            !0,
            r
          );
        },
        _changed: function() {
          this._owner && this._owner._changed(129);
        },
        getOffset: function() {
          return this._offset;
        },
        setOffset: function(e) {
          this._offset = e, this._changed();
        },
        getRampPoint: "#getOffset",
        setRampPoint: "#setOffset",
        getColor: function() {
          return this._color;
        },
        setColor: function() {
          xe._setOwner(this._color, null), this._color = xe._setOwner(
            xe.read(arguments, 0),
            this,
            "setColor"
          ), this._changed();
        },
        equals: function(e) {
          return e === this || e && this._class === e._class && this._color.equals(e._color) && this._offset == e._offset || !1;
        }
      }), Ue = _.extend(new function() {
        var e = {
          fillColor: null,
          fillRule: "nonzero",
          strokeColor: null,
          strokeWidth: 1,
          strokeCap: "butt",
          strokeJoin: "miter",
          strokeScaling: !0,
          miterLimit: 10,
          dashOffset: 0,
          dashArray: [],
          shadowColor: null,
          shadowBlur: 0,
          shadowOffset: new a(),
          selectedColor: null
        }, r = _.set({}, e, {
          fontFamily: "sans-serif",
          fontWeight: "normal",
          fontSize: 12,
          leading: null,
          justification: "left"
        }), f = _.set({}, r, {
          fillColor: new xe()
        }), C = {
          strokeWidth: 193,
          strokeCap: 193,
          strokeJoin: 193,
          strokeScaling: 201,
          miterLimit: 193,
          fontFamily: 9,
          fontWeight: 9,
          fontSize: 9,
          font: 9,
          leading: 9,
          justification: 9
        }, R = {
          beans: !0
        }, B = {
          _class: "Style",
          beans: !0,
          initialize: function(H, X, ue) {
            this._values = {}, this._owner = X, this._project = X && X._project || ue || Ae.project, this._defaults = !X || X instanceof A ? r : X instanceof Me ? f : e, H && this.set(H);
          }
        };
        return _.each(r, function(j, H) {
          var X = /Color$/.test(H), ue = H === "shadowOffset", pe = _.capitalize(H), P = C[H], q = "set" + pe, K = "get" + pe;
          B[q] = function(ye) {
            var te = this._owner, he = te && te._children, D = he && he.length > 0 && !(te instanceof de);
            if (D)
              for (var Se = 0, le = he.length; Se < le; Se++)
                he[Se]._style[q](ye);
            if ((H === "selectedColor" || !D) && H in this._defaults) {
              var v = this._values[H];
              v !== ye && (X && (v && (xe._setOwner(v, null), v._canvasStyle = null), ye && ye.constructor === xe && (ye = xe._setOwner(
                ye,
                te,
                D && q
              ))), this._values[H] = ye, te && te._changed(P || 129));
            }
          }, B[K] = function(ye) {
            var te = this._owner, he = te && te._children, D = he && he.length > 0 && !(te instanceof de), Se;
            if (D && !ye)
              for (var le = 0, v = he.length; le < v; le++) {
                var se = he[le]._style[K]();
                if (!le)
                  Se = se;
                else if (!_.equals(Se, se))
                  return ae;
              }
            else if (H in this._defaults) {
              var Se = this._values[H];
              if (Se === ae)
                Se = this._defaults[H], Se && Se.clone && (Se = Se.clone());
              else {
                var me = X ? xe : ue ? a : null;
                me && !(Se && Se.constructor === me) && (this._values[H] = Se = me.read(
                  [Se],
                  0,
                  { readNull: !0, clone: !0 }
                ));
              }
            }
            return Se && X && (Se = xe._setOwner(Se, te, D && q)), Se;
          }, R[K] = function(ye) {
            return this._style[K](ye);
          }, R[q] = function(ye) {
            this._style[q](ye);
          };
        }), _.each({
          Font: "FontFamily",
          WindingRule: "FillRule"
        }, function(j, H) {
          var X = "get" + H, ue = "set" + H;
          B[X] = R[X] = "#get" + j, B[ue] = R[ue] = "#set" + j;
        }), o.inject(R), B;
      }(), {
        set: function(e) {
          var r = e instanceof Ue, f = r ? e._values : e;
          if (f) {
            for (var C in f)
              if (C in this._defaults) {
                var R = f[C];
                this[C] = R && r && R.clone ? R.clone() : R;
              }
          }
        },
        equals: function(e) {
          function r(f, C, R) {
            var B = f._values, j = C._values, H = C._defaults;
            for (var X in B) {
              var ue = B[X], pe = j[X];
              if (!(R && X in j) && !_.equals(
                ue,
                pe === ae ? H[X] : pe
              ))
                return !1;
            }
            return !0;
          }
          return e === this || e && this._class === e._class && r(this, e) && r(e, this, !0) || !1;
        },
        _dispose: function() {
          var e;
          e = this.getFillColor(), e && (e._canvasStyle = null), e = this.getStrokeColor(), e && (e._canvasStyle = null), e = this.getShadowColor(), e && (e._canvasStyle = null);
        },
        hasFill: function() {
          var e = this.getFillColor();
          return !!e && e.alpha > 0;
        },
        hasStroke: function() {
          var e = this.getStrokeColor();
          return !!e && e.alpha > 0 && this.getStrokeWidth() > 0;
        },
        hasShadow: function() {
          var e = this.getShadowColor();
          return !!e && e.alpha > 0 && (this.getShadowBlur() > 0 || !this.getShadowOffset().isZero());
        },
        getView: function() {
          return this._project._view;
        },
        getFontStyle: function() {
          var e = this.getFontSize();
          return this.getFontWeight() + " " + e + (/[a-z]/i.test(e + "") ? " " : "px ") + this.getFontFamily();
        },
        getFont: "#getFontFamily",
        setFont: "#setFontFamily",
        getLeading: function e() {
          var r = e.base.call(this), f = this.getFontSize();
          return /pt|em|%|px/.test(f) && (f = this.getView().getPixelSize(f)), r ?? f * 1.2;
        }
      }), He = new function() {
        function e(r, f, C, R) {
          for (var B = ["", "webkit", "moz", "Moz", "ms", "o"], j = f[0].toUpperCase() + f.substring(1), H = 0; H < 6; H++) {
            var X = B[H], ue = X ? X + j : f;
            if (ue in r) {
              if (C)
                r[ue] = R;
              else
                return r[ue];
              break;
            }
          }
        }
        return {
          getStyles: function(r) {
            var f = r && r.nodeType !== 9 ? r.ownerDocument : r, C = f && f.defaultView;
            return C && C.getComputedStyle(r, "");
          },
          getBounds: function(r, f) {
            var C = r.ownerDocument, R = C.body, B = C.documentElement, j;
            try {
              j = r.getBoundingClientRect();
            } catch {
              j = { left: 0, top: 0, width: 0, height: 0 };
            }
            var H = j.left - (B.clientLeft || R.clientLeft || 0), X = j.top - (B.clientTop || R.clientTop || 0);
            if (!f) {
              var ue = C.defaultView;
              H += ue.pageXOffset || B.scrollLeft || R.scrollLeft, X += ue.pageYOffset || B.scrollTop || R.scrollTop;
            }
            return new h(H, X, j.width, j.height);
          },
          getViewportBounds: function(r) {
            var f = r.ownerDocument, C = f.defaultView, R = f.documentElement;
            return new h(
              0,
              0,
              C.innerWidth || R.clientWidth,
              C.innerHeight || R.clientHeight
            );
          },
          getOffset: function(r, f) {
            return He.getBounds(r, f).getPoint();
          },
          getSize: function(r) {
            return He.getBounds(r, !0).getSize();
          },
          isInvisible: function(r) {
            return He.getSize(r).equals(new d(0, 0));
          },
          isInView: function(r) {
            return !He.isInvisible(r) && He.getViewportBounds(r).intersects(
              He.getBounds(r, !0)
            );
          },
          isInserted: function(r) {
            return Z.body.contains(r);
          },
          getPrefixed: function(r, f) {
            return r && e(r, f);
          },
          setPrefixed: function(r, f, C) {
            if (typeof f == "object")
              for (var R in f)
                e(r, R, !0, f[R]);
            else
              e(r, f, !0, C);
          }
        };
      }(), We = {
        add: function(e, r) {
          if (e)
            for (var f in r)
              for (var C = r[f], R = f.split(/[\s,]+/g), B = 0, j = R.length; B < j; B++) {
                var H = R[B], X = e === Z && (H === "touchstart" || H === "touchmove") ? { passive: !1 } : !1;
                e.addEventListener(H, C, X);
              }
        },
        remove: function(e, r) {
          if (e)
            for (var f in r)
              for (var C = r[f], R = f.split(/[\s,]+/g), B = 0, j = R.length; B < j; B++)
                e.removeEventListener(R[B], C, !1);
        },
        getPoint: function(e) {
          var r = e.targetTouches ? e.targetTouches.length ? e.targetTouches[0] : e.changedTouches[0] : e;
          return new a(
            r.pageX || r.clientX + Z.documentElement.scrollLeft,
            r.pageY || r.clientY + Z.documentElement.scrollTop
          );
        },
        getTarget: function(e) {
          return e.target || e.srcElement;
        },
        getRelatedTarget: function(e) {
          return e.relatedTarget || e.toElement;
        },
        getOffset: function(e, r) {
          return We.getPoint(e).subtract(He.getOffset(
            r || We.getTarget(e)
          ));
        }
      };
      We.requestAnimationFrame = new function() {
        var e = He.getPrefixed(k, "requestAnimationFrame"), r = !1, f = [], C;
        function R() {
          var B = f;
          f = [];
          for (var j = 0, H = B.length; j < H; j++)
            B[j]();
          r = e && f.length, r && e(R);
        }
        return function(B) {
          f.push(B), e ? r || (e(R), r = !0) : C || (C = setInterval(R, 1e3 / 60));
        };
      }();
      var Ze = _.extend(
        M,
        {
          _class: "View",
          initialize: function e(r, f) {
            function C(P) {
              return f[P] || parseInt(f.getAttribute(P), 10);
            }
            function R() {
              var P = He.getSize(f);
              return P.isNaN() || P.isZero() ? new d(C("width"), C("height")) : P;
            }
            var B;
            if (k && f) {
              this._id = f.getAttribute("id"), this._id == null && f.setAttribute("id", this._id = "paper-view-" + e._id++), We.add(f, this._viewEvents);
              var j = "none";
              if (He.setPrefixed(f.style, {
                userDrag: j,
                userSelect: j,
                touchCallout: j,
                contentZooming: j,
                tapHighlightColor: "rgba(0,0,0,0)"
              }), x.hasAttribute(f, "resize")) {
                var H = this;
                We.add(k, this._windowEvents = {
                  resize: function() {
                    H.setViewSize(R());
                  }
                });
              }
              if (B = R(), x.hasAttribute(f, "stats") && typeof Stats < "u") {
                this._stats = new Stats();
                var X = this._stats.domElement, ue = X.style, pe = He.getOffset(f);
                ue.position = "absolute", ue.left = pe.x + "px", ue.top = pe.y + "px", Z.body.appendChild(X);
              }
            } else
              B = new d(f), f = null;
            this._project = r, this._scope = r._scope, this._element = f, this._pixelRatio || (this._pixelRatio = k && k.devicePixelRatio || 1), this._setElementSize(B.width, B.height), this._viewSize = B, e._views.push(this), e._viewsById[this._id] = this, (this._matrix = new s())._owner = this, e._focused || (e._focused = this), this._frameItems = {}, this._frameItemCount = 0, this._itemEvents = { native: {}, virtual: {} }, this._autoUpdate = !Ae.agent.node, this._needsUpdate = !1;
          },
          remove: function() {
            if (!this._project)
              return !1;
            Ze._focused === this && (Ze._focused = null), Ze._views.splice(Ze._views.indexOf(this), 1), delete Ze._viewsById[this._id];
            var e = this._project;
            return e._view === this && (e._view = null), We.remove(this._element, this._viewEvents), We.remove(k, this._windowEvents), this._element = this._project = null, this.off("frame"), this._animate = !1, this._frameItems = {}, !0;
          },
          _events: _.each(
            o._itemHandlers.concat(["onResize", "onKeyDown", "onKeyUp"]),
            function(e) {
              this[e] = {};
            },
            {
              onFrame: {
                install: function() {
                  this.play();
                },
                uninstall: function() {
                  this.pause();
                }
              }
            }
          ),
          _animate: !1,
          _time: 0,
          _count: 0,
          getAutoUpdate: function() {
            return this._autoUpdate;
          },
          setAutoUpdate: function(e) {
            this._autoUpdate = e, e && this.requestUpdate();
          },
          update: function() {
          },
          draw: function() {
            this.update();
          },
          requestUpdate: function() {
            if (!this._requested) {
              var e = this;
              We.requestAnimationFrame(function() {
                if (e._requested = !1, e._animate) {
                  e.requestUpdate();
                  var r = e._element;
                  (!He.getPrefixed(Z, "hidden") || x.getAttribute(r, "keepalive") === "true") && He.isInView(r) && e._handleFrame();
                }
                e._autoUpdate && e.update();
              }), this._requested = !0;
            }
          },
          play: function() {
            this._animate = !0, this.requestUpdate();
          },
          pause: function() {
            this._animate = !1;
          },
          _handleFrame: function() {
            Ae = this._scope;
            var e = Date.now() / 1e3, r = this._last ? e - this._last : 0;
            this._last = e, this.emit("frame", new _({
              delta: r,
              time: this._time += r,
              count: this._count++
            })), this._stats && this._stats.update();
          },
          _animateItem: function(e, r) {
            var f = this._frameItems;
            r ? (f[e._id] = {
              item: e,
              time: 0,
              count: 0
            }, ++this._frameItemCount === 1 && this.on("frame", this._handleFrameItems)) : (delete f[e._id], --this._frameItemCount === 0 && this.off("frame", this._handleFrameItems));
          },
          _handleFrameItems: function(e) {
            for (var r in this._frameItems) {
              var f = this._frameItems[r];
              f.item.emit("frame", new _(e, {
                time: f.time += e.delta,
                count: f.count++
              }));
            }
          },
          _changed: function() {
            this._project._changed(4097), this._bounds = this._decomposed = ae;
          },
          getElement: function() {
            return this._element;
          },
          getPixelRatio: function() {
            return this._pixelRatio;
          },
          getResolution: function() {
            return this._pixelRatio * 72;
          },
          getViewSize: function() {
            var e = this._viewSize;
            return new g(e.width, e.height, this, "setViewSize");
          },
          setViewSize: function() {
            var e = d.read(arguments), r = e.subtract(this._viewSize);
            r.isZero() || (this._setElementSize(e.width, e.height), this._viewSize.set(e), this._changed(), this.emit("resize", { size: e, delta: r }), this._autoUpdate && this.update());
          },
          _setElementSize: function(e, r) {
            var f = this._element;
            f && (f.width !== e && (f.width = e), f.height !== r && (f.height = r));
          },
          getBounds: function() {
            return this._bounds || (this._bounds = this._matrix.inverted()._transformBounds(
              new h(new a(), this._viewSize)
            )), this._bounds;
          },
          getSize: function() {
            return this.getBounds().getSize();
          },
          isVisible: function() {
            return He.isInView(this._element);
          },
          isInserted: function() {
            return He.isInserted(this._element);
          },
          getPixelSize: function(e) {
            var r = this._element, f;
            if (r) {
              var C = r.parentNode, R = Z.createElement("div");
              R.style.fontSize = e, C.appendChild(R), f = parseFloat(He.getStyles(R).fontSize), C.removeChild(R);
            } else
              f = parseFloat(f);
            return f;
          },
          getTextWidth: function(e, r) {
            return 0;
          }
        },
        _.each(["rotate", "scale", "shear", "skew"], function(e) {
          var r = e === "rotate";
          this[e] = function() {
            var f = arguments, C = (r ? _ : a).read(f), R = a.read(f, 0, { readNull: !0 });
            return this.transform(new s()[e](
              C,
              R || this.getCenter(!0)
            ));
          };
        }, {
          _decompose: function() {
            return this._decomposed || (this._decomposed = this._matrix.decompose());
          },
          translate: function() {
            var e = new s();
            return this.transform(e.translate.apply(e, arguments));
          },
          getCenter: function() {
            return this.getBounds().getCenter();
          },
          setCenter: function() {
            var e = a.read(arguments);
            this.translate(this.getCenter().subtract(e));
          },
          getZoom: function() {
            var e = this._decompose().scaling;
            return (e.x + e.y) / 2;
          },
          setZoom: function(e) {
            this.transform(new s().scale(
              e / this.getZoom(),
              this.getCenter()
            ));
          },
          getRotation: function() {
            return this._decompose().rotation;
          },
          setRotation: function(e) {
            var r = this.getRotation();
            r != null && e != null && this.rotate(e - r);
          },
          getScaling: function() {
            var e = this._decompose().scaling;
            return new n(e.x, e.y, this, "setScaling");
          },
          setScaling: function() {
            var e = this.getScaling(), r = a.read(arguments, 0, { clone: !0, readNull: !0 });
            e && r && this.scale(r.x / e.x, r.y / e.y);
          },
          getMatrix: function() {
            return this._matrix;
          },
          setMatrix: function() {
            var e = this._matrix;
            e.set.apply(e, arguments);
          },
          transform: function(e) {
            this._matrix.append(e);
          },
          scrollBy: function() {
            this.translate(a.read(arguments).negate());
          }
        }),
        {
          projectToView: function() {
            return this._matrix._transformPoint(a.read(arguments));
          },
          viewToProject: function() {
            return this._matrix._inverseTransform(a.read(arguments));
          },
          getEventPoint: function(e) {
            return this.viewToProject(We.getOffset(e, this._element));
          }
        },
        {
          statics: {
            _views: [],
            _viewsById: {},
            _id: 0,
            create: function(e, r) {
              Z && typeof r == "string" && (r = Z.getElementById(r));
              var f = k ? $e : Ze;
              return new f(e, r);
            }
          }
        },
        new function() {
          if (!k)
            return;
          var e, r, f = !1, C = !1;
          function R(Fe) {
            var Ye = We.getTarget(Fe);
            return Ye.getAttribute && Ze._viewsById[Ye.getAttribute("id")];
          }
          function B() {
            var Fe = Ze._focused;
            if (!Fe || !Fe.isVisible()) {
              for (var Ye = 0, Ke = Ze._views.length; Ye < Ke; Ye++)
                if ((Fe = Ze._views[Ye]).isVisible()) {
                  Ze._focused = r = Fe;
                  break;
                }
            }
          }
          function j(Fe, Ye, Ke) {
            Fe._handleMouseEvent("mousemove", Ye, Ke);
          }
          var H = k.navigator, X, ue, pe;
          H.pointerEnabled || H.msPointerEnabled ? (X = "pointerdown MSPointerDown", ue = "pointermove MSPointerMove", pe = "pointerup pointercancel MSPointerUp MSPointerCancel") : (X = "touchstart", ue = "touchmove", pe = "touchend touchcancel", "ontouchstart" in k && H.userAgent.match(
            /mobile|tablet|ip(ad|hone|od)|android|silk/i
          ) || (X += " mousedown", ue += " mousemove", pe += " mouseup"));
          var P = {}, q = {
            mouseout: function(Fe) {
              var Ye = Ze._focused, Ke = We.getRelatedTarget(Fe);
              if (Ye && (!Ke || Ke.nodeName === "HTML")) {
                var et = We.getOffset(Fe, Ye._element), Je = et.x, nt = Math.abs, dt = nt(Je), vt = 1 << 25, bt = dt - vt;
                et.x = nt(bt) < dt ? bt * (Je < 0 ? -1 : 1) : Je, j(Ye, Fe, Ye.viewToProject(et));
              }
            },
            scroll: B
          };
          P[X] = function(Fe) {
            var Ye = Ze._focused = R(Fe);
            f || (f = !0, Ye._handleMouseEvent("mousedown", Fe));
          }, q[ue] = function(Fe) {
            var Ye = Ze._focused;
            if (!C) {
              var Ke = R(Fe);
              Ke ? Ye !== Ke && (Ye && j(Ye, Fe), e || (e = Ye), Ye = Ze._focused = r = Ke) : r && r === Ye && (e && !e.isInserted() && (e = null), Ye = Ze._focused = e, e = null, B());
            }
            Ye && j(Ye, Fe);
          }, q[X] = function() {
            C = !0;
          }, q[pe] = function(Fe) {
            var Ye = Ze._focused;
            Ye && f && Ye._handleMouseEvent("mouseup", Fe), C = f = !1;
          }, We.add(Z, q), We.add(k, {
            load: B
          });
          var K = !1, ye = !1, te = {
            doubleclick: "click",
            mousedrag: "mousemove"
          }, he = !1, D, Se, le, v, se, me, O, ce;
          function Oe(Fe, Ye, Ke, et, Je, nt, dt) {
            var vt = !1, bt;
            function At(ot, ht) {
              if (ot.responds(ht)) {
                if (bt || (bt = new De(
                  ht,
                  et,
                  Je,
                  Ye || ot,
                  nt ? Je.subtract(nt) : null
                )), ot.emit(ht, bt) && (K = !0, bt.prevented && (ye = !0), bt.stopped))
                  return vt = !0;
              } else {
                var gt = te[ht];
                if (gt)
                  return At(ot, gt);
              }
            }
            for (; Fe && Fe !== dt && !At(Fe, Ke); )
              Fe = Fe._parent;
            return vt;
          }
          function Be(Fe, Ye, Ke, et, Je, nt) {
            return Fe._project.removeOn(Ke), ye = K = !1, se && Oe(
              se,
              null,
              Ke,
              et,
              Je,
              nt
            ) || Ye && Ye !== se && !Ye.isDescendant(se) && Oe(Ye, null, Ke === "mousedrag" ? "mousemove" : Ke, et, Je, nt, se) || Oe(
              Fe,
              se || Ye || Fe,
              Ke,
              et,
              Je,
              nt
            );
          }
          var je = {
            mousedown: {
              mousedown: 1,
              mousedrag: 1,
              click: 1,
              doubleclick: 1
            },
            mouseup: {
              mouseup: 1,
              mousedrag: 1,
              click: 1,
              doubleclick: 1
            },
            mousemove: {
              mousedrag: 1,
              mousemove: 1,
              mouseenter: 1,
              mouseleave: 1
            }
          };
          return {
            _viewEvents: P,
            _handleMouseEvent: function(Fe, Ye, Ke) {
              var et = this._itemEvents, Je = et.native[Fe], nt = Fe === "mousemove", dt = this._scope.tool, vt = this;
              function bt(Ot) {
                return et.virtual[Ot] || vt.responds(Ot) || dt && dt.responds(Ot);
              }
              nt && f && bt("mousedrag") && (Fe = "mousedrag"), Ke || (Ke = this.getEventPoint(Ye));
              var At = this.getBounds().contains(Ke), ot = Je && At && vt._project.hitTest(Ke, {
                tolerance: 0,
                fill: !0,
                stroke: !0
              }), ht = ot && ot.item || null, gt = !1, Ct = {};
              if (Ct[Fe.substr(5)] = !0, Je && ht !== v && (v && Oe(v, null, "mouseleave", Ye, Ke), ht && Oe(ht, null, "mouseenter", Ye, Ke), v = ht), he ^ At && (Oe(
                this,
                null,
                At ? "mouseenter" : "mouseleave",
                Ye,
                Ke
              ), gt = !0), (At || Ct.drag) && !Ke.equals(Se) && (Be(
                this,
                ht,
                nt ? Fe : "mousemove",
                Ye,
                Ke,
                Se
              ), gt = !0), he = At, Ct.down && At || Ct.up && D) {
                if (Be(this, ht, Fe, Ye, Ke, D), Ct.down) {
                  if (ce = ht === me && Date.now() - O < 300, le = me = ht, !ye && ht) {
                    for (var xt = ht; xt && !xt.responds("mousedrag"); )
                      xt = xt._parent;
                    xt && (se = ht);
                  }
                  D = Ke;
                } else Ct.up && (!ye && ht === le && (O = Date.now(), Be(this, ht, ce ? "doubleclick" : "click", Ye, Ke, D), ce = !1), le = se = null);
                he = !1, gt = !0;
              }
              Se = Ke, gt && dt && (K = dt._handleMouseEvent(Fe, Ye, Ke, Ct) || K), Ye.cancelable !== !1 && (K && !Ct.move || Ct.down && bt("mouseup")) && Ye.preventDefault();
            },
            _handleKeyEvent: function(Fe, Ye, Ke, et) {
              var Je = this._scope, nt = Je.tool, dt;
              function vt(bt) {
                bt.responds(Fe) && (Ae = Je, bt.emit(Fe, dt = dt || new Ge(Fe, Ye, Ke, et)));
              }
              this.isVisible() && (vt(this), nt && nt.responds(Fe) && vt(nt));
            },
            _countItemEvent: function(Fe, Ye) {
              var Ke = this._itemEvents, et = Ke.native, Je = Ke.virtual;
              for (var nt in je)
                et[nt] = (et[nt] || 0) + (je[nt][Fe] || 0) * Ye;
              Je[Fe] = (Je[Fe] || 0) + Ye;
            },
            statics: {
              updateFocus: B,
              _resetState: function() {
                f = C = K = he = !1, e = r = D = Se = le = v = se = me = O = ce = null;
              }
            }
          };
        }()
      ), $e = Ze.extend({
        _class: "CanvasView",
        initialize: function(r, f) {
          if (!(f instanceof k.HTMLCanvasElement)) {
            var C = d.read(arguments, 1);
            if (C.isZero())
              throw new Error(
                "Cannot create CanvasView with the provided argument: " + _.slice(arguments, 1)
              );
            f = Ce.getCanvas(C);
          }
          var R = this._context = f.getContext("2d");
          if (R.save(), this._pixelRatio = 1, !/^off|false$/.test(x.getAttribute(f, "hidpi"))) {
            var B = k.devicePixelRatio || 1, j = He.getPrefixed(
              R,
              "backingStorePixelRatio"
            ) || 1;
            this._pixelRatio = B / j;
          }
          Ze.call(this, r, f), this._needsUpdate = !0;
        },
        remove: function e() {
          return this._context.restore(), e.base.call(this);
        },
        _setElementSize: function e(r, f) {
          var C = this._pixelRatio;
          if (e.base.call(this, r * C, f * C), C !== 1) {
            var R = this._element, B = this._context;
            if (!x.hasAttribute(R, "resize")) {
              var j = R.style;
              j.width = r + "px", j.height = f + "px";
            }
            B.restore(), B.save(), B.scale(C, C);
          }
        },
        getContext: function() {
          return this._context;
        },
        getPixelSize: function e(r) {
          var f = Ae.agent, C;
          if (f && f.firefox)
            C = e.base.call(this, r);
          else {
            var R = this._context, B = R.font;
            R.font = r + " serif", C = parseFloat(R.font), R.font = B;
          }
          return C;
        },
        getTextWidth: function(e, r) {
          var f = this._context, C = f.font, R = 0;
          f.font = e;
          for (var B = 0, j = r.length; B < j; B++)
            R = Math.max(R, f.measureText(r[B]).width);
          return f.font = C, R;
        },
        update: function() {
          if (!this._needsUpdate)
            return !1;
          var e = this._project, r = this._context, f = this._viewSize;
          return r.clearRect(0, 0, f.width + 1, f.height + 1), e && e.draw(r, this._matrix, this._pixelRatio), this._needsUpdate = !1, !0;
        }
      }), Ve = _.extend({
        _class: "Event",
        initialize: function(r) {
          this.event = r, this.type = r && r.type;
        },
        prevented: !1,
        stopped: !1,
        preventDefault: function() {
          this.prevented = !0, this.event.preventDefault();
        },
        stopPropagation: function() {
          this.stopped = !0, this.event.stopPropagation();
        },
        stop: function() {
          this.stopPropagation(), this.preventDefault();
        },
        getTimeStamp: function() {
          return this.event.timeStamp;
        },
        getModifiers: function() {
          return Ie.modifiers;
        }
      }), Ge = Ve.extend({
        _class: "KeyEvent",
        initialize: function(r, f, C, R) {
          this.type = r, this.event = f, this.key = C, this.character = R;
        },
        toString: function() {
          return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }";
        }
      }), Ie = new function() {
        var e = {
          "	": "tab",
          " ": "space",
          "\b": "backspace",
          "": "delete",
          Spacebar: "space",
          Del: "delete",
          Win: "meta",
          Esc: "escape"
        }, r = {
          tab: "	",
          space: " ",
          enter: "\r"
        }, f = {}, C = {}, R, B, j = new _({
          shift: !1,
          control: !1,
          alt: !1,
          meta: !1,
          capsLock: !1,
          space: !1
        }).inject({
          option: {
            get: function() {
              return this.alt;
            }
          },
          command: {
            get: function() {
              var ue = Ae && Ae.agent;
              return ue && ue.mac ? this.meta : this.control;
            }
          }
        });
        function H(ue) {
          var pe = ue.key || ue.keyIdentifier;
          return pe = /^U\+/.test(pe) ? String.fromCharCode(parseInt(pe.substr(2), 16)) : /^Arrow[A-Z]/.test(pe) ? pe.substr(5) : pe === "Unidentified" || pe === ae ? String.fromCharCode(ue.keyCode) : pe, e[pe] || (pe.length > 1 ? _.hyphenate(pe) : pe.toLowerCase());
        }
        function X(ue, pe, P, q) {
          var K = Ze._focused, ye;
          if (f[pe] = ue, ue ? C[pe] = P : delete C[pe], pe.length > 1 && (ye = _.camelize(pe)) in j) {
            j[ye] = ue;
            var te = Ae && Ae.agent;
            if (ye === "meta" && te && te.mac)
              if (ue)
                R = {};
              else {
                for (var he in R)
                  he in C && X(!1, he, R[he], q);
                R = null;
              }
          } else ue && R && (R[pe] = P);
          K && K._handleKeyEvent(
            ue ? "keydown" : "keyup",
            q,
            pe,
            P
          );
        }
        return We.add(Z, {
          keydown: function(ue) {
            var pe = H(ue), P = Ae && Ae.agent;
            pe.length > 1 || P && P.chrome && (ue.altKey || P.mac && ue.metaKey || !P.mac && ue.ctrlKey) ? X(
              !0,
              pe,
              r[pe] || (pe.length > 1 ? "" : pe),
              ue
            ) : B = pe;
          },
          keypress: function(ue) {
            if (B) {
              var pe = H(ue), P = ue.charCode, q = P >= 32 ? String.fromCharCode(P) : pe.length > 1 ? "" : pe;
              pe !== B && (pe = q.toLowerCase()), X(!0, pe, q, ue), B = null;
            }
          },
          keyup: function(ue) {
            var pe = H(ue);
            pe in C && X(!1, pe, C[pe], ue);
          }
        }), We.add(k, {
          blur: function(ue) {
            for (var pe in C)
              X(!1, pe, C[pe], ue);
          }
        }), {
          modifiers: j,
          isDown: function(ue) {
            return !!f[ue];
          }
        };
      }(), De = Ve.extend({
        _class: "MouseEvent",
        initialize: function(r, f, C, R, B) {
          this.type = r, this.event = f, this.point = C, this.target = R, this.delta = B;
        },
        toString: function() {
          return "{ type: '" + this.type + "', point: " + this.point + ", target: " + this.target + (this.delta ? ", delta: " + this.delta : "") + ", modifiers: " + this.getModifiers() + " }";
        }
      }), Ne = Ve.extend({
        _class: "ToolEvent",
        _item: null,
        initialize: function(r, f, C) {
          this.tool = r, this.type = f, this.event = C;
        },
        _choosePoint: function(e, r) {
          return e || (r ? r.clone() : null);
        },
        getPoint: function() {
          return this._choosePoint(this._point, this.tool._point);
        },
        setPoint: function(e) {
          this._point = e;
        },
        getLastPoint: function() {
          return this._choosePoint(this._lastPoint, this.tool._lastPoint);
        },
        setLastPoint: function(e) {
          this._lastPoint = e;
        },
        getDownPoint: function() {
          return this._choosePoint(this._downPoint, this.tool._downPoint);
        },
        setDownPoint: function(e) {
          this._downPoint = e;
        },
        getMiddlePoint: function() {
          return !this._middlePoint && this.tool._lastPoint ? this.tool._point.add(this.tool._lastPoint).divide(2) : this._middlePoint;
        },
        setMiddlePoint: function(e) {
          this._middlePoint = e;
        },
        getDelta: function() {
          return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;
        },
        setDelta: function(e) {
          this._delta = e;
        },
        getCount: function() {
          return this.tool[/^mouse(down|up)$/.test(this.type) ? "_downCount" : "_moveCount"];
        },
        setCount: function(e) {
          this.tool[/^mouse(down|up)$/.test(this.type) ? "downCount" : "count"] = e;
        },
        getItem: function() {
          if (!this._item) {
            var e = this.tool._scope.project.hitTest(this.getPoint());
            if (e) {
              for (var r = e.item, f = r._parent; /^(Group|CompoundPath)$/.test(f._class); )
                r = f, f = f._parent;
              this._item = r;
            }
          }
          return this._item;
        },
        setItem: function(e) {
          this._item = e;
        },
        toString: function() {
          return "{ type: " + this.type + ", point: " + this.getPoint() + ", count: " + this.getCount() + ", modifiers: " + this.getModifiers() + " }";
        }
      }), _e = y.extend({
        _class: "Tool",
        _list: "tools",
        _reference: "tool",
        _events: [
          "onMouseDown",
          "onMouseUp",
          "onMouseDrag",
          "onMouseMove",
          "onActivate",
          "onDeactivate",
          "onEditOptions",
          "onKeyDown",
          "onKeyUp"
        ],
        initialize: function(r) {
          y.call(this), this._moveCount = -1, this._downCount = -1, this.set(r);
        },
        getMinDistance: function() {
          return this._minDistance;
        },
        setMinDistance: function(e) {
          this._minDistance = e, e != null && this._maxDistance != null && e > this._maxDistance && (this._maxDistance = e);
        },
        getMaxDistance: function() {
          return this._maxDistance;
        },
        setMaxDistance: function(e) {
          this._maxDistance = e, this._minDistance != null && e != null && e < this._minDistance && (this._minDistance = e);
        },
        getFixedDistance: function() {
          return this._minDistance == this._maxDistance ? this._minDistance : null;
        },
        setFixedDistance: function(e) {
          this._minDistance = this._maxDistance = e;
        },
        _handleMouseEvent: function(e, r, f, C) {
          Ae = this._scope, C.drag && !this.responds(e) && (e = "mousemove");
          var R = C.move || C.drag, B = this.responds(e), j = !1, H = this;
          function X(pe, P) {
            var q = f, K = R ? H._point : H._downPoint || q;
            if (R) {
              if (H._moveCount >= 0 && q.equals(K))
                return !1;
              if (K && (pe != null || P != null)) {
                var ye = q.subtract(K), te = ye.getLength();
                if (te < (pe || 0))
                  return !1;
                P && (q = K.add(ye.normalize(
                  Math.min(te, P)
                )));
              }
              H._moveCount++;
            }
            return H._point = q, H._lastPoint = K || q, C.down && (H._moveCount = -1, H._downPoint = q, H._downCount++), !0;
          }
          function ue() {
            B && (j = H.emit(e, new Ne(H, e, r)) || j);
          }
          if (C.down)
            X(), ue();
          else if (C.up)
            X(null, this._maxDistance), ue();
          else if (B)
            for (; X(this._minDistance, this._maxDistance); )
              ue();
          return j;
        }
      }), re = _.extend(M, {
        _class: "Tween",
        statics: {
          easings: new _({
            linear: function(e) {
              return e;
            },
            easeInQuad: function(e) {
              return e * e;
            },
            easeOutQuad: function(e) {
              return e * (2 - e);
            },
            easeInOutQuad: function(e) {
              return e < 0.5 ? 2 * e * e : -1 + 2 * (2 - e) * e;
            },
            easeInCubic: function(e) {
              return e * e * e;
            },
            easeOutCubic: function(e) {
              return --e * e * e + 1;
            },
            easeInOutCubic: function(e) {
              return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
            },
            easeInQuart: function(e) {
              return e * e * e * e;
            },
            easeOutQuart: function(e) {
              return 1 - --e * e * e * e;
            },
            easeInOutQuart: function(e) {
              return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
            },
            easeInQuint: function(e) {
              return e * e * e * e * e;
            },
            easeOutQuint: function(e) {
              return 1 + --e * e * e * e * e;
            },
            easeInOutQuint: function(e) {
              return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
            }
          })
        },
        initialize: function e(r, f, C, R, B, j) {
          this.object = r;
          var H = typeof B, X = H === "function";
          this.type = X ? H : H === "string" ? B : "linear", this.easing = X ? B : e.easings[this.type], this.duration = R, this.running = !1, this._then = null, this._startTime = null;
          var ue = f || C;
          this._keys = ue ? Object.keys(ue) : [], this._parsedKeys = this._parseKeys(this._keys), this._from = ue && this._getState(f), this._to = ue && this._getState(C), j !== !1 && this.start();
        },
        then: function(e) {
          return this._then = e, this;
        },
        start: function() {
          return this._startTime = null, this.running = !0, this;
        },
        stop: function() {
          return this.running = !1, this;
        },
        update: function(e) {
          if (this.running) {
            e >= 1 && (e = 1, this.running = !1);
            for (var r = this.easing(e), f = this._keys, C = function(pe) {
              return typeof pe == "function" ? pe(r, e) : pe;
            }, R = 0, B = f && f.length; R < B; R++) {
              var j = f[R], H = C(this._from[j]), X = C(this._to[j]), ue = H && X && H.__add && X.__add ? X.__subtract(H).__multiply(r).__add(H) : (X - H) * r + H;
              this._setProperty(this._parsedKeys[j], ue);
            }
            this.responds("update") && this.emit("update", new _({
              progress: e,
              factor: r
            })), !this.running && this._then && this._then(this.object);
          }
          return this;
        },
        _events: {
          onUpdate: {}
        },
        _handleFrame: function(e) {
          var r = this._startTime, f = r ? (e - r) / this.duration : 0;
          r || (this._startTime = e), this.update(f);
        },
        _getState: function(e) {
          for (var r = this._keys, f = {}, C = 0, R = r.length; C < R; C++) {
            var B = r[C], j = this._parsedKeys[B], H = this._getProperty(j), X;
            if (e) {
              var ue = this._resolveValue(H, e[B]);
              this._setProperty(j, ue), X = this._getProperty(j), X = X && X.clone ? X.clone() : X, this._setProperty(j, H);
            } else
              X = H && H.clone ? H.clone() : H;
            f[B] = X;
          }
          return f;
        },
        _resolveValue: function(e, r) {
          if (r) {
            if (Array.isArray(r) && r.length === 2) {
              var f = r[0];
              return f && f.match && f.match(/^[+\-\*\/]=/) ? this._calculate(e, f[0], r[1]) : r;
            } else if (typeof r == "string") {
              var C = r.match(/^[+\-*/]=(.*)/);
              if (C) {
                var R = JSON.parse(C[1].replace(
                  /(['"])?([a-zA-Z0-9_]+)(['"])?:/g,
                  '"$2": '
                ));
                return this._calculate(e, r[0], R);
              }
            }
          }
          return r;
        },
        _calculate: function(e, r, f) {
          return Ae.PaperScript.calculateBinary(e, r, f);
        },
        _parseKeys: function(e) {
          for (var r = {}, f = 0, C = e.length; f < C; f++) {
            var R = e[f], B = R.replace(/\.([^.]*)/g, "/$1").replace(/\[['"]?([^'"\]]*)['"]?\]/g, "/$1");
            r[R] = B.split("/");
          }
          return r;
        },
        _getProperty: function(e, r) {
          for (var f = this.object, C = 0, R = e.length - (r || 0); C < R && f; C++)
            f = f[e[C]];
          return f;
        },
        _setProperty: function(e, r) {
          var f = this._getProperty(e, 1);
          f && (f[e[e.length - 1]] = r);
        }
      }), $ = {
        request: function(e) {
          var r = new be.XMLHttpRequest();
          return r.open(
            (e.method || "get").toUpperCase(),
            e.url,
            _.pick(e.async, !0)
          ), e.mimeType && r.overrideMimeType(e.mimeType), r.onload = function() {
            var f = r.status;
            f === 0 || f === 200 ? e.onLoad && e.onLoad.call(r, r.responseText) : r.onerror();
          }, r.onerror = function() {
            var f = r.status, C = 'Could not load "' + e.url + '" (Status: ' + f + ")";
            if (e.onError)
              e.onError(C, f);
            else
              throw new Error(C);
          }, r.send(null);
        }
      }, Ce = _.exports.CanvasProvider = {
        canvases: [],
        getCanvas: function(e, r, f) {
          if (!k)
            return null;
          var C, R = !0;
          typeof e == "object" && (r = e.height, e = e.width), this.canvases.length ? C = this.canvases.pop() : (C = Z.createElement("canvas"), R = !1);
          var B = C.getContext("2d", f || {});
          if (!B)
            throw new Error("Canvas " + C + " is unable to provide a 2D context.");
          return C.width === e && C.height === r ? R && B.clearRect(0, 0, e + 1, r + 1) : (C.width = e, C.height = r), B.save(), C;
        },
        getContext: function(e, r, f) {
          var C = this.getCanvas(e, r, f);
          return C ? C.getContext("2d", f || {}) : null;
        },
        release: function(e) {
          var r = e && e.canvas ? e.canvas : e;
          r && r.getContext && (r.getContext("2d").restore(), this.canvases.push(r));
        }
      }, ve = new function() {
        var e = Math.min, r = Math.max, f = Math.abs, C, R, B, j, H, X, ue, pe, P, q, K;
        function ye(se, me, O) {
          return 0.2989 * se + 0.587 * me + 0.114 * O;
        }
        function te(se, me, O, Be) {
          var Oe = Be - ye(se, me, O);
          P = se + Oe, q = me + Oe, K = O + Oe;
          var Be = ye(P, q, K), je = e(P, q, K), Fe = r(P, q, K);
          if (je < 0) {
            var Ye = Be - je;
            P = Be + (P - Be) * Be / Ye, q = Be + (q - Be) * Be / Ye, K = Be + (K - Be) * Be / Ye;
          }
          if (Fe > 255) {
            var Ke = 255 - Be, et = Fe - Be;
            P = Be + (P - Be) * Ke / et, q = Be + (q - Be) * Ke / et, K = Be + (K - Be) * Ke / et;
          }
        }
        function he(se, me, O) {
          return r(se, me, O) - e(se, me, O);
        }
        function D(se, me, O, ce) {
          var Oe = [se, me, O], Be = r(se, me, O), je = e(se, me, O), Fe;
          je = je === se ? 0 : je === me ? 1 : 2, Be = Be === se ? 0 : Be === me ? 1 : 2, Fe = e(je, Be) === 0 ? r(je, Be) === 1 ? 2 : 1 : 0, Oe[Be] > Oe[je] ? (Oe[Fe] = (Oe[Fe] - Oe[je]) * ce / (Oe[Be] - Oe[je]), Oe[Be] = ce) : Oe[Fe] = Oe[Be] = 0, Oe[je] = 0, P = Oe[0], q = Oe[1], K = Oe[2];
        }
        var Se = {
          multiply: function() {
            P = H * C / 255, q = X * R / 255, K = ue * B / 255;
          },
          screen: function() {
            P = H + C - H * C / 255, q = X + R - X * R / 255, K = ue + B - ue * B / 255;
          },
          overlay: function() {
            P = H < 128 ? 2 * H * C / 255 : 255 - 2 * (255 - H) * (255 - C) / 255, q = X < 128 ? 2 * X * R / 255 : 255 - 2 * (255 - X) * (255 - R) / 255, K = ue < 128 ? 2 * ue * B / 255 : 255 - 2 * (255 - ue) * (255 - B) / 255;
          },
          "soft-light": function() {
            var se = C * H / 255;
            P = se + H * (255 - (255 - H) * (255 - C) / 255 - se) / 255, se = R * X / 255, q = se + X * (255 - (255 - X) * (255 - R) / 255 - se) / 255, se = B * ue / 255, K = se + ue * (255 - (255 - ue) * (255 - B) / 255 - se) / 255;
          },
          "hard-light": function() {
            P = C < 128 ? 2 * C * H / 255 : 255 - 2 * (255 - C) * (255 - H) / 255, q = R < 128 ? 2 * R * X / 255 : 255 - 2 * (255 - R) * (255 - X) / 255, K = B < 128 ? 2 * B * ue / 255 : 255 - 2 * (255 - B) * (255 - ue) / 255;
          },
          "color-dodge": function() {
            P = H === 0 ? 0 : C === 255 ? 255 : e(255, 255 * H / (255 - C)), q = X === 0 ? 0 : R === 255 ? 255 : e(255, 255 * X / (255 - R)), K = ue === 0 ? 0 : B === 255 ? 255 : e(255, 255 * ue / (255 - B));
          },
          "color-burn": function() {
            P = H === 255 ? 255 : C === 0 ? 0 : r(0, 255 - (255 - H) * 255 / C), q = X === 255 ? 255 : R === 0 ? 0 : r(0, 255 - (255 - X) * 255 / R), K = ue === 255 ? 255 : B === 0 ? 0 : r(0, 255 - (255 - ue) * 255 / B);
          },
          darken: function() {
            P = H < C ? H : C, q = X < R ? X : R, K = ue < B ? ue : B;
          },
          lighten: function() {
            P = H > C ? H : C, q = X > R ? X : R, K = ue > B ? ue : B;
          },
          difference: function() {
            P = H - C, P < 0 && (P = -P), q = X - R, q < 0 && (q = -q), K = ue - B, K < 0 && (K = -K);
          },
          exclusion: function() {
            P = H + C * (255 - H - H) / 255, q = X + R * (255 - X - X) / 255, K = ue + B * (255 - ue - ue) / 255;
          },
          hue: function() {
            D(C, R, B, he(H, X, ue)), te(P, q, K, ye(H, X, ue));
          },
          saturation: function() {
            D(H, X, ue, he(C, R, B)), te(P, q, K, ye(H, X, ue));
          },
          luminosity: function() {
            te(H, X, ue, ye(C, R, B));
          },
          color: function() {
            te(C, R, B, ye(H, X, ue));
          },
          add: function() {
            P = e(H + C, 255), q = e(X + R, 255), K = e(ue + B, 255);
          },
          subtract: function() {
            P = r(H - C, 0), q = r(X - R, 0), K = r(ue - B, 0);
          },
          average: function() {
            P = (H + C) / 2, q = (X + R) / 2, K = (ue + B) / 2;
          },
          negation: function() {
            P = 255 - f(255 - C - H), q = 255 - f(255 - R - X), K = 255 - f(255 - B - ue);
          }
        }, le = this.nativeModes = _.each([
          "source-over",
          "source-in",
          "source-out",
          "source-atop",
          "destination-over",
          "destination-in",
          "destination-out",
          "destination-atop",
          "lighter",
          "darker",
          "copy",
          "xor"
        ], function(se) {
          this[se] = !0;
        }, {}), v = Ce.getContext(1, 1, { willReadFrequently: !0 });
        v && (_.each(Se, function(se, me) {
          var O = me === "darken", ce = !1;
          v.save();
          try {
            v.fillStyle = O ? "#300" : "#a00", v.fillRect(0, 0, 1, 1), v.globalCompositeOperation = me, v.globalCompositeOperation === me && (v.fillStyle = O ? "#a00" : "#300", v.fillRect(0, 0, 1, 1), ce = v.getImageData(0, 0, 1, 1).data[0] !== O ? 170 : 51);
          } catch {
          }
          v.restore(), le[me] = ce;
        }), Ce.release(v)), this.process = function(se, me, O, ce, Oe) {
          var Be = me.canvas, je = se === "normal";
          if (je || le[se])
            O.save(), O.setTransform(1, 0, 0, 1, 0, 0), O.globalAlpha = ce, je || (O.globalCompositeOperation = se), O.drawImage(Be, Oe.x, Oe.y), O.restore();
          else {
            var Fe = Se[se];
            if (!Fe)
              return;
            for (var Ye = O.getImageData(
              Oe.x,
              Oe.y,
              Be.width,
              Be.height
            ), Ke = Ye.data, et = me.getImageData(
              0,
              0,
              Be.width,
              Be.height
            ).data, Je = 0, nt = Ke.length; Je < nt; Je += 4) {
              C = et[Je], H = Ke[Je], R = et[Je + 1], X = Ke[Je + 1], B = et[Je + 2], ue = Ke[Je + 2], j = et[Je + 3], pe = Ke[Je + 3], Fe();
              var dt = j * ce / 255, vt = 1 - dt;
              Ke[Je] = dt * P + vt * H, Ke[Je + 1] = dt * q + vt * X, Ke[Je + 2] = dt * K + vt * ue, Ke[Je + 3] = j * ce + vt * pe;
            }
            O.putImageData(Ye, Oe.x, Oe.y);
          }
        };
      }(), Y = new function() {
        var e = "http://www.w3.org/2000/svg", r = "http://www.w3.org/2000/xmlns", f = "http://www.w3.org/1999/xlink", C = {
          href: f,
          xlink: r,
          xmlns: r + "/",
          "xmlns:xlink": r + "/"
        };
        function R(H, X, ue) {
          return j(Z.createElementNS(e, H), X, ue);
        }
        function B(H, X) {
          var ue = C[X], pe = ue ? H.getAttributeNS(ue, X) : H.getAttribute(X);
          return pe === "null" ? null : pe;
        }
        function j(H, X, ue) {
          for (var pe in X) {
            var P = X[pe], q = C[pe];
            typeof P == "number" && ue && (P = ue.number(P)), q ? H.setAttributeNS(q, pe, P) : H.setAttribute(pe, P);
          }
          return H;
        }
        return {
          svg: e,
          xmlns: r,
          xlink: f,
          create: R,
          get: B,
          set: j
        };
      }(), G = _.each({
        fillColor: ["fill", "color"],
        fillRule: ["fill-rule", "string"],
        strokeColor: ["stroke", "color"],
        strokeWidth: ["stroke-width", "number"],
        strokeCap: ["stroke-linecap", "string"],
        strokeJoin: ["stroke-linejoin", "string"],
        strokeScaling: ["vector-effect", "lookup", {
          true: "none",
          false: "non-scaling-stroke"
        }, function(e, r) {
          return !r && (e instanceof W || e instanceof I || e instanceof Me);
        }],
        miterLimit: ["stroke-miterlimit", "number"],
        dashArray: ["stroke-dasharray", "array"],
        dashOffset: ["stroke-dashoffset", "number"],
        fontFamily: ["font-family", "string"],
        fontWeight: ["font-weight", "string"],
        fontSize: ["font-size", "number"],
        justification: ["text-anchor", "lookup", {
          left: "start",
          center: "middle",
          right: "end"
        }],
        opacity: ["opacity", "number"],
        blendMode: ["mix-blend-mode", "style"]
      }, function(e, r) {
        var f = _.capitalize(r), C = e[2];
        this[r] = {
          type: e[1],
          property: r,
          attribute: e[0],
          toSVG: C,
          fromSVG: C && _.each(C, function(R, B) {
            this[R] = B;
          }, {}),
          exportFilter: e[3],
          get: "get" + f,
          set: "set" + f
        };
      }, {});
      new function() {
        var e;
        function r(Se, le, v) {
          var se = new _(), me = Se.getTranslation();
          if (le) {
            var O;
            Se.isInvertible() ? (Se = Se._shiftless(), O = Se._inverseTransform(me), me = null) : O = new a(), se[v ? "cx" : "x"] = O.x, se[v ? "cy" : "y"] = O.y;
          }
          if (!Se.isIdentity()) {
            var ce = Se.decompose();
            if (ce) {
              var Oe = [], Be = ce.rotation, je = ce.scaling, Fe = ce.skewing;
              me && !me.isZero() && Oe.push("translate(" + e.point(me) + ")"), Be && Oe.push("rotate(" + e.number(Be) + ")"), (!u.isZero(je.x - 1) || !u.isZero(je.y - 1)) && Oe.push("scale(" + e.point(je) + ")"), Fe.x && Oe.push("skewX(" + e.number(Fe.x) + ")"), Fe.y && Oe.push("skewY(" + e.number(Fe.y) + ")"), se.transform = Oe.join(" ");
            } else
              se.transform = "matrix(" + Se.getValues().join(",") + ")";
          }
          return se;
        }
        function f(Se, le) {
          for (var v = r(Se._matrix), se = Se._children, me = Y.create("g", v, e), O = 0, ce = se.length; O < ce; O++) {
            var Oe = se[O], Be = he(Oe, le);
            if (Be)
              if (Oe.isClipMask()) {
                var je = Y.create("clipPath");
                je.appendChild(Be), ye(Oe, je, "clip"), Y.set(me, {
                  "clip-path": "url(#" + je.id + ")"
                });
              } else
                me.appendChild(Be);
          }
          return me;
        }
        function C(Se, le) {
          var v = r(Se._matrix, !0), se = Se.getSize(), me = Se.getImage();
          return v.x -= se.width / 2, v.y -= se.height / 2, v.width = se.width, v.height = se.height, v.href = le.embedImages == !1 && me && me.src || Se.toDataURL(), Y.create("image", v, e);
        }
        function R(Se, le) {
          var v = le.matchShapes;
          if (v) {
            var se = Se.toShape(!1);
            if (se)
              return B(se);
          }
          var me = Se._segments, O = me.length, ce, Oe = r(Se._matrix);
          if (v && O >= 2 && !Se.hasHandles())
            if (O > 2) {
              ce = Se._closed ? "polygon" : "polyline";
              for (var Be = [], je = 0; je < O; je++)
                Be.push(e.point(me[je]._point));
              Oe.points = Be.join(" ");
            } else {
              ce = "line";
              var Fe = me[0]._point, Ye = me[1]._point;
              Oe.set({
                x1: Fe.x,
                y1: Fe.y,
                x2: Ye.x,
                y2: Ye.y
              });
            }
          else
            ce = "path", Oe.d = Se.getPathData(null, le.precision);
          return Y.create(ce, Oe, e);
        }
        function B(Se) {
          var le = Se._type, v = Se._radius, se = r(Se._matrix, !0, le !== "rectangle");
          if (le === "rectangle") {
            le = "rect";
            var me = Se._size, O = me.width, ce = me.height;
            se.x -= O / 2, se.y -= ce / 2, se.width = O, se.height = ce, v.isZero() && (v = null);
          }
          return v && (le === "circle" ? se.r = v : (se.rx = v.width, se.ry = v.height)), Y.create(le, se, e);
        }
        function j(Se, le) {
          var v = r(Se._matrix), se = Se.getPathData(null, le.precision);
          return se && (v.d = se), Y.create("path", v, e);
        }
        function H(Se, le) {
          var v = r(Se._matrix, !0), se = Se._definition, me = K(se, "symbol"), O = se._item, ce = O.getStrokeBounds();
          return me || (me = Y.create("symbol", {
            viewBox: e.rectangle(ce)
          }), me.appendChild(he(O, le)), ye(se, me, "symbol")), v.href = "#" + me.id, v.x += ce.x, v.y += ce.y, v.width = ce.width, v.height = ce.height, v.overflow = "visible", Y.create("use", v, e);
        }
        function X(Se) {
          var le = K(Se, "color");
          if (!le) {
            var v = Se.getGradient(), se = v._radial, me = Se.getOrigin(), O = Se.getDestination(), ce;
            if (se) {
              ce = {
                cx: me.x,
                cy: me.y,
                r: me.getDistance(O)
              };
              var Oe = Se.getHighlight();
              Oe && (ce.fx = Oe.x, ce.fy = Oe.y);
            } else
              ce = {
                x1: me.x,
                y1: me.y,
                x2: O.x,
                y2: O.y
              };
            ce.gradientUnits = "userSpaceOnUse", le = Y.create((se ? "radial" : "linear") + "Gradient", ce, e);
            for (var Be = v._stops, je = 0, Fe = Be.length; je < Fe; je++) {
              var Ye = Be[je], Ke = Ye._color, et = Ke.getAlpha(), Je = Ye._offset;
              ce = {
                offset: Je ?? je / (Fe - 1)
              }, Ke && (ce["stop-color"] = Ke.toCSS(!0)), et < 1 && (ce["stop-opacity"] = et), le.appendChild(
                Y.create("stop", ce, e)
              );
            }
            ye(Se, le, "color");
          }
          return "url(#" + le.id + ")";
        }
        function ue(Se) {
          var le = Y.create(
            "text",
            r(Se._matrix, !0),
            e
          );
          return le.textContent = Se._content, le;
        }
        var pe = {
          Group: f,
          Layer: f,
          Raster: C,
          Path: R,
          Shape: B,
          CompoundPath: j,
          SymbolItem: H,
          PointText: ue
        };
        function P(Se, le, v, se) {
          var me = {}, O = !se && Se.getParent(), ce = [];
          return Se._name != null && (me.id = Se._name), _.each(G, function(Oe) {
            var Be = Oe.get, je = Oe.type, Fe = Se[Be]();
            if (Oe.exportFilter ? Oe.exportFilter(Se, Fe) : v.reduceAttributes == !1 || !O || !_.equals(O[Be](), Fe)) {
              if (je === "color" && Fe != null) {
                var Ye = Fe.getAlpha();
                Ye < 1 && (me[Oe.attribute + "-opacity"] = Ye);
              }
              je === "style" ? ce.push(Oe.attribute + ": " + Fe) : me[Oe.attribute] = Fe == null ? "none" : je === "color" ? Fe.gradient ? X(Fe) : Fe.toCSS(!0) : je === "array" ? Fe.join(",") : je === "lookup" ? Oe.toSVG[Fe] : Fe;
            }
          }), ce.length && (me.style = ce.join(";")), me.opacity === 1 && delete me.opacity, Se._visible || (me.visibility = "hidden"), Y.set(le, me, e);
        }
        var q;
        function K(Se, le) {
          return q || (q = { ids: {}, svgs: {} }), Se && q.svgs[le + "-" + (Se._id || Se.__id || (Se.__id = l.get("svg")))];
        }
        function ye(Se, le, v) {
          q || K();
          var se = q.ids[v] = (q.ids[v] || 0) + 1;
          le.id = v + "-" + se, q.svgs[v + "-" + (Se._id || Se.__id)] = le;
        }
        function te(Se, le) {
          var v = Se, se = null;
          if (q) {
            v = Se.nodeName.toLowerCase() === "svg" && Se;
            for (var me in q.svgs)
              se || (v || (v = Y.create("svg"), v.appendChild(Se)), se = v.insertBefore(
                Y.create("defs"),
                v.firstChild
              )), se.appendChild(q.svgs[me]);
            q = null;
          }
          return le.asString ? new be.XMLSerializer().serializeToString(v) : v;
        }
        function he(Se, le, v) {
          var se = pe[Se._class], me = se && se(Se, le);
          if (me) {
            var O = le.onExport;
            O && (me = O(Se, me, le) || me);
            var ce = JSON.stringify(Se._data);
            ce && ce !== "{}" && ce !== "null" && me.setAttribute("data-paper-data", ce);
          }
          return me && P(Se, me, le, v);
        }
        function D(Se) {
          return Se || (Se = {}), e = new c(Se.precision), Se;
        }
        o.inject({
          exportSVG: function(Se) {
            return Se = D(Se), te(he(this, Se, !0), Se);
          }
        }), S.inject({
          exportSVG: function(Se) {
            Se = D(Se);
            var le = this._children, v = this.getView(), se = _.pick(Se.bounds, "view"), me = Se.matrix || se === "view" && v._matrix, O = me && s.read([me]), ce = se === "view" ? new h([0, 0], v.getViewSize()) : se === "content" ? o._getBounds(le, O, { stroke: !0 }).rect : h.read([se], 0, { readNull: !0 }), Oe = {
              version: "1.1",
              xmlns: Y.svg,
              "xmlns:xlink": Y.xlink
            };
            ce && (Oe.width = ce.width, Oe.height = ce.height, (ce.x || ce.x === 0 || ce.y || ce.y === 0) && (Oe.viewBox = e.rectangle(ce)));
            var Be = Y.create("svg", Oe, e), je = Be;
            O && !O.isIdentity() && (je = Be.appendChild(Y.create(
              "g",
              r(O),
              e
            )));
            for (var Fe = 0, Ye = le.length; Fe < Ye; Fe++)
              je.appendChild(he(le[Fe], Se, !0));
            return te(Be, Se);
          }
        });
      }(), new function() {
        var e = {}, r;
        function f(le, v, se, me, O, ce) {
          var Oe = Y.get(le, v) || ce, Be = Oe == null ? me ? null : se ? "" : 0 : se ? Oe : parseFloat(Oe);
          return /%\s*$/.test(Oe) ? Be / 100 * (O ? 1 : r[/x|^width/.test(v) ? "width" : "height"]) : Be;
        }
        function C(le, v, se, me, O, ce, Oe) {
          return v = f(le, v || "x", !1, me, O, ce), se = f(le, se || "y", !1, me, O, Oe), me && (v == null || se == null) ? null : new a(v, se);
        }
        function R(le, v, se, me, O) {
          return v = f(le, v || "width", !1, me, O), se = f(le, se || "height", !1, me, O), me && (v == null || se == null) ? null : new d(v, se);
        }
        function B(le, v, se) {
          return le === "none" ? null : v === "number" ? parseFloat(le) : v === "array" ? le ? le.split(/[\s,]+/g).map(parseFloat) : [] : v === "color" ? he(le) || le : v === "lookup" ? se[le] : le;
        }
        function j(le, v, se, me) {
          var O = le.childNodes, ce = v === "clippath", Oe = v === "defs", Be = new A(), je = Be._project, Fe = je._currentStyle, Ye = [];
          if (!ce && !Oe && (Be = te(Be, le, me), je._currentStyle = Be._style.clone()), me)
            for (var Ke = le.querySelectorAll("defs"), et = 0, Je = Ke.length; et < Je; et++)
              D(Ke[et], se, !1);
          for (var et = 0, Je = O.length; et < Je; et++) {
            var nt = O[et], dt;
            nt.nodeType === 1 && !/^defs$/i.test(nt.nodeName) && (dt = D(nt, se, !1)) && !(dt instanceof U) && Ye.push(dt);
          }
          return Be.addChildren(Ye), ce && (Be = te(Be.reduce(), le, me)), je._currentStyle = Fe, (ce || Oe) && (Be.remove(), Be = null), Be;
        }
        function H(le, v) {
          for (var se = le.getAttribute("points").match(
            /[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g
          ), me = [], O = 0, ce = se.length; O < ce; O += 2)
            me.push(new a(
              parseFloat(se[O]),
              parseFloat(se[O + 1])
            ));
          var Oe = new Q(me);
          return v === "polygon" && Oe.closePath(), Oe;
        }
        function X(le) {
          return W.create(le.getAttribute("d"));
        }
        function ue(le, v) {
          var se = (f(le, "href", !0) || "").substring(1), me = v === "radialgradient", O;
          if (se)
            O = e[se].getGradient(), O._radial ^ me && (O = O.clone(), O._radial = me);
          else {
            for (var ce = le.childNodes, Oe = [], Be = 0, je = ce.length; Be < je; Be++) {
              var Fe = ce[Be];
              Fe.nodeType === 1 && Oe.push(te(new Pe(), Fe));
            }
            O = new Ee(Oe, me);
          }
          var Ye, Ke, et, Je = f(le, "gradientUnits", !0) !== "userSpaceOnUse";
          me ? (Ye = C(
            le,
            "cx",
            "cy",
            !1,
            Je,
            "50%",
            "50%"
          ), Ke = Ye.add(
            f(le, "r", !1, !1, Je, "50%"),
            0
          ), et = C(le, "fx", "fy", !0, Je)) : (Ye = C(
            le,
            "x1",
            "y1",
            !1,
            Je,
            "0%",
            "0%"
          ), Ke = C(
            le,
            "x2",
            "y2",
            !1,
            Je,
            "100%",
            "0%"
          ));
          var nt = te(
            new xe(O, Ye, Ke, et),
            le
          );
          return nt._scaleToBounds = Je, null;
        }
        var pe = {
          "#document": function(le, v, se, me) {
            for (var O = le.childNodes, ce = 0, Oe = O.length; ce < Oe; ce++) {
              var Be = O[ce];
              if (Be.nodeType === 1)
                return D(Be, se, me);
            }
          },
          g: j,
          svg: j,
          clippath: j,
          polygon: H,
          polyline: H,
          path: X,
          lineargradient: ue,
          radialgradient: ue,
          image: function(le) {
            var v = new L(f(le, "href", !0));
            return v.on("load", function() {
              var se = R(le);
              this.setSize(se);
              var me = C(le).add(se.divide(2));
              this._matrix.append(new s().translate(me));
            }), v;
          },
          symbol: function(le, v, se, me) {
            return new U(
              j(le, v, se, me),
              !0
            );
          },
          defs: j,
          use: function(le) {
            var v = (f(le, "href", !0) || "").substring(1), se = e[v], me = C(le);
            return se ? se instanceof U ? se.place(me) : se.clone().translate(me) : null;
          },
          circle: function(le) {
            return new I.Circle(
              C(le, "cx", "cy"),
              f(le, "r")
            );
          },
          ellipse: function(le) {
            return new I.Ellipse({
              center: C(le, "cx", "cy"),
              radius: R(le, "rx", "ry")
            });
          },
          rect: function(le) {
            return new I.Rectangle(new h(
              C(le),
              R(le)
            ), R(le, "rx", "ry"));
          },
          line: function(le) {
            return new Q.Line(
              C(le, "x1", "y1"),
              C(le, "x2", "y2")
            );
          },
          text: function(le) {
            var v = new fe(C(le).add(
              C(le, "dx", "dy")
            ));
            return v.setContent(le.textContent.trim() || ""), v;
          },
          switch: j
        };
        function P(le, v, se, me) {
          if (le.transform) {
            for (var O = (me.getAttribute(se) || "").split(/\)\s*/g), ce = new s(), Oe = 0, Be = O.length; Oe < Be; Oe++) {
              var je = O[Oe];
              if (!je)
                break;
              for (var Fe = je.split(/\(\s*/), Ye = Fe[0].trim(), Ke = Fe[1].split(/[\s,]+/g), et = 0, Je = Ke.length; et < Je; et++)
                Ke[et] = parseFloat(Ke[et]);
              switch (Ye) {
                case "matrix":
                  ce.append(
                    new s(Ke[0], Ke[1], Ke[2], Ke[3], Ke[4], Ke[5])
                  );
                  break;
                case "rotate":
                  ce.rotate(Ke[0], Ke[1] || 0, Ke[2] || 0);
                  break;
                case "translate":
                  ce.translate(Ke[0], Ke[1] || 0);
                  break;
                case "scale":
                  ce.scale(Ke);
                  break;
                case "skewX":
                  ce.skew(Ke[0], 0);
                  break;
                case "skewY":
                  ce.skew(0, Ke[0]);
                  break;
              }
            }
            le.transform(ce);
          }
        }
        function q(le, v, se) {
          var me = se === "fill-opacity" ? "getFillColor" : "getStrokeColor", O = le[me] && le[me]();
          O && O.setAlpha(parseFloat(v));
        }
        var K = _.set(_.each(G, function(le) {
          this[le.attribute] = function(v, se) {
            if (v[le.set] && (v[le.set](B(se, le.type, le.fromSVG)), le.type === "color")) {
              var me = v[le.get]();
              if (me && me._scaleToBounds) {
                var O = v.getBounds();
                me.transform(new s().translate(O.getPoint()).scale(O.getSize()));
              }
            }
          };
        }, {}), {
          id: function(le, v) {
            e[v] = le, le.setName && le.setName(v);
          },
          "clip-path": function(le, v) {
            var se = he(v);
            if (se)
              if (se = se.clone(), se.setClipMask(!0), le instanceof A)
                le.insertChild(0, se);
              else
                return new A(se, le);
          },
          gradientTransform: P,
          transform: P,
          "fill-opacity": q,
          "stroke-opacity": q,
          visibility: function(le, v) {
            le.setVisible && le.setVisible(v === "visible");
          },
          display: function(le, v) {
            le.setVisible && le.setVisible(v !== null);
          },
          "stop-color": function(le, v) {
            le.setColor && le.setColor(v);
          },
          "stop-opacity": function(le, v) {
            le._color && le._color.setAlpha(parseFloat(v));
          },
          offset: function(le, v) {
            if (le.setOffset) {
              var se = v.match(/(.*)%$/);
              le.setOffset(se ? se[1] / 100 : parseFloat(v));
            }
          },
          viewBox: function(le, v, se, me, O) {
            var ce = new h(B(v, "array")), Oe = R(me, null, null, !0), Be, je;
            if (le instanceof A) {
              var Fe = Oe ? Oe.divide(ce.getSize()) : 1, je = new s().scale(Fe).translate(ce.getPoint().negate());
              Be = le;
            } else le instanceof U && (Oe && ce.setSize(Oe), Be = le._item);
            if (Be) {
              if (ye(me, "overflow", O) !== "visible") {
                var Ye = new I.Rectangle(ce);
                Ye.setClipMask(!0), Be.addChild(Ye);
              }
              je && Be.transform(je);
            }
          }
        });
        function ye(le, v, se) {
          var me = le.attributes[v], O = me && me.value;
          if (!O && le.style) {
            var ce = _.camelize(v);
            O = le.style[ce], !O && se.node[ce] !== se.parent[ce] && (O = se.node[ce]);
          }
          return O ? O === "none" ? null : O : ae;
        }
        function te(le, v, se) {
          var me = v.parentNode, O = {
            node: He.getStyles(v) || {},
            parent: !se && !/^defs$/i.test(me.tagName) && He.getStyles(me) || {}
          };
          return _.each(K, function(ce, Oe) {
            var Be = ye(v, Oe, O);
            le = Be !== ae && ce(le, Be, Oe, v, O) || le;
          }), le;
        }
        function he(le) {
          var v = le && le.match(/\((?:["'#]*)([^"')]+)/), se = v && v[1], me = se && e[k ? se.replace(k.location.href.split("#")[0] + "#", "") : se];
          return me && me._scaleToBounds && (me = me.clone(), me._scaleToBounds = !0), me;
        }
        function D(le, v, se) {
          var me = le.nodeName.toLowerCase(), O = me !== "#document", ce = Z.body, Oe, Be, je;
          se && O && (r = Ae.getView().getSize(), r = R(le, null, null, !0) || r, Oe = Y.create("svg", {
            style: "stroke-width: 1px; stroke-miterlimit: 10"
          }), Be = le.parentNode, je = le.nextSibling, Oe.appendChild(le), ce.appendChild(Oe));
          var Fe = Ae.settings, Ye = Fe.applyMatrix, Ke = Fe.insertItems;
          Fe.applyMatrix = !1, Fe.insertItems = !1;
          var et = pe[me], Je = et && et(le, me, v, se) || null;
          if (Fe.insertItems = Ke, Fe.applyMatrix = Ye, Je) {
            O && !(Je instanceof A) && (Je = te(Je, le, se));
            var nt = v.onImport, dt = O && le.getAttribute("data-paper-data");
            nt && (Je = nt(le, Je, v) || Je), v.expandShapes && Je instanceof I && (Je.remove(), Je = Je.toPath()), dt && (Je._data = JSON.parse(dt));
          }
          return Oe && (ce.removeChild(Oe), Be && (je ? Be.insertBefore(le, je) : Be.appendChild(le))), se && (e = {}, Je && _.pick(v.applyMatrix, Ye) && Je.matrix.apply(!0, !0)), Je;
        }
        function Se(le, v, se) {
          if (!le)
            return null;
          v = typeof v == "function" ? { onLoad: v } : v || {};
          var me = Ae, O = null;
          function ce(Fe) {
            try {
              var Ye = typeof Fe == "object" ? Fe : new be.DOMParser().parseFromString(
                Fe.trim(),
                "image/svg+xml"
              );
              if (!Ye.nodeName)
                throw Ye = null, new Error("Unsupported SVG source: " + le);
              Ae = me, O = D(Ye, v, !0), (!v || v.insert !== !1) && se._insertItem(ae, O);
              var Ke = v.onLoad;
              Ke && Ke(O, Fe);
            } catch (et) {
              Oe(et);
            }
          }
          function Oe(Fe, Ye) {
            var Ke = v.onError;
            if (Ke)
              Ke(Fe, Ye);
            else
              throw new Error(Fe);
          }
          if (typeof le == "string" && !/^[\s\S]*</.test(le)) {
            var Be = Z.getElementById(le);
            Be ? ce(Be) : $.request({
              url: le,
              async: !0,
              onLoad: ce,
              onError: Oe
            });
          } else if (typeof File < "u" && le instanceof File) {
            var je = new FileReader();
            return je.onload = function() {
              ce(je.result);
            }, je.onerror = function() {
              Oe(je.error);
            }, je.readAsText(le);
          } else
            ce(le);
          return O;
        }
        o.inject({
          importSVG: function(le, v) {
            return Se(le, v, this);
          }
        }), S.inject({
          importSVG: function(le, v) {
            return this.activate(), Se(le, v, this);
          }
        });
      }(), _.exports.PaperScript = (function() {
        var e = this, r = e.acorn;
        if (!r && typeof Ms < "u")
          try {
            r = L0();
          } catch {
          }
        if (!r) {
          var f, C;
          r = f = C = {}, function(te, he) {
            if (typeof f == "object" && typeof C == "object") return he(f);
            if (typeof ae == "function" && ae.amd) return ae(["exports"], he);
            he(te.acorn || (te.acorn = {}));
          }(this, function(te) {
            te.version = "0.5.0";
            var he, D, Se, le;
            te.parse = function(qe, tt) {
              return D = String(qe), Se = D.length, se(tt), Ns(), Hs(he.program);
            };
            var v = te.defaultOptions = {
              ecmaVersion: 5,
              strictSemicolons: !1,
              allowTrailingCommas: !0,
              forbidReserved: !1,
              allowReturnOutsideFunction: !1,
              locations: !1,
              onComment: null,
              ranges: !1,
              program: null,
              sourceFile: null,
              directSourceFile: null
            };
            function se(qe) {
              he = qe || {};
              for (var tt in v) Object.prototype.hasOwnProperty.call(he, tt) || (he[tt] = v[tt]);
              le = he.sourceFile || null;
            }
            var me = te.getLineInfo = function(qe, tt) {
              for (var ct = 1, mt = 0; ; ) {
                Mr.lastIndex = mt;
                var Ft = Mr.exec(qe);
                if (Ft && Ft.index < tt)
                  ++ct, mt = Ft.index + Ft[0].length;
                else break;
              }
              return { line: ct, column: tt - mt };
            };
            te.tokenize = function(qe, tt) {
              D = String(qe), Se = D.length, se(tt), Ns();
              var ct = {};
              function mt(Ft) {
                return dt = Oe, ln(Ft), ct.start = ce, ct.end = Oe, ct.startLoc = Be, ct.endLoc = je, ct.type = Fe, ct.value = Ye, ct;
              }
              return mt.jumpTo = function(Ft, Ut) {
                if (O = Ft, he.locations) {
                  et = 1, Je = Mr.lastIndex = 0;
                  for (var Wt; (Wt = Mr.exec(D)) && Wt.index < Ft; )
                    ++et, Je = Wt.index + Wt[0].length;
                }
                Ke = Ut, Fi();
              }, mt;
            };
            var O, ce, Oe, Be, je, Fe, Ye, Ke, et, Je, nt, dt, vt, bt, At, ot;
            function ht(qe, tt) {
              var ct = me(D, qe);
              tt += " (" + ct.line + ":" + ct.column + ")";
              var mt = new SyntaxError(tt);
              throw mt.pos = qe, mt.loc = ct, mt.raisedAt = O, mt;
            }
            var gt = [], Ct = { type: "num" }, xt = { type: "regexp" }, Ot = { type: "string" }, Nt = { type: "name" }, Mt = { type: "eof" }, Gt = { keyword: "break" }, Bt = { keyword: "case", beforeExpr: !0 }, or = { keyword: "catch" }, ar = { keyword: "continue" }, ur = { keyword: "debugger" }, hr = { keyword: "default" }, wt = { keyword: "do", isLoop: !0 }, $t = { keyword: "else", beforeExpr: !0 }, lr = { keyword: "finally" }, tr = { keyword: "for", isLoop: !0 }, Xr = { keyword: "function" }, gi = { keyword: "if" }, ii = { keyword: "return", beforeExpr: !0 }, Br = { keyword: "switch" }, Er = { keyword: "throw", beforeExpr: !0 }, kr = { keyword: "try" }, qr = { keyword: "var" }, yr = { keyword: "while", isLoop: !0 }, Or = { keyword: "with" }, yn = { keyword: "new", beforeExpr: !0 }, wn = { keyword: "this" }, bn = { keyword: "null", atomValue: null }, Yi = { keyword: "true", atomValue: !0 }, ya = { keyword: "false", atomValue: !1 }, Xi = { keyword: "in", binop: 7, beforeExpr: !0 }, qt = {
              break: Gt,
              case: Bt,
              catch: or,
              continue: ar,
              debugger: ur,
              default: hr,
              do: wt,
              else: $t,
              finally: lr,
              for: tr,
              function: Xr,
              if: gi,
              return: ii,
              switch: Br,
              throw: Er,
              try: kr,
              var: qr,
              while: yr,
              with: Or,
              null: bn,
              true: Yi,
              false: ya,
              new: yn,
              in: Xi,
              instanceof: { keyword: "instanceof", binop: 7, beforeExpr: !0 },
              this: wn,
              typeof: { keyword: "typeof", prefix: !0, beforeExpr: !0 },
              void: { keyword: "void", prefix: !0, beforeExpr: !0 },
              delete: { keyword: "delete", prefix: !0, beforeExpr: !0 }
            }, qi = { type: "[", beforeExpr: !0 }, Qi = { type: "]" }, _i = { type: "{", beforeExpr: !0 }, ni = { type: "}" }, Vt = { type: "(", beforeExpr: !0 }, Qr = { type: ")" }, Kr = { type: ",", beforeExpr: !0 }, zr = { type: ";", beforeExpr: !0 }, Fr = { type: ":", beforeExpr: !0 }, oi = { type: "." }, ui = { type: "?", beforeExpr: !0 }, Di = { binop: 10, beforeExpr: !0 }, p = { isAssign: !0, beforeExpr: !0 }, V = { isAssign: !0, beforeExpr: !0 }, Te = { postfix: !0, prefix: !0, isUpdate: !0 }, Le = { prefix: !0, beforeExpr: !0 }, Xe = { binop: 1, beforeExpr: !0 }, at = { binop: 2, beforeExpr: !0 }, lt = { binop: 3, beforeExpr: !0 }, Et = { binop: 4, beforeExpr: !0 }, Tt = { binop: 5, beforeExpr: !0 }, Yt = { binop: 6, beforeExpr: !0 }, zt = { binop: 7, beforeExpr: !0 }, fr = { binop: 8, beforeExpr: !0 }, $r = { binop: 9, prefix: !0, beforeExpr: !0 }, Ci = { binop: 10, beforeExpr: !0 };
            te.tokTypes = {
              bracketL: qi,
              bracketR: Qi,
              braceL: _i,
              braceR: ni,
              parenL: Vt,
              parenR: Qr,
              comma: Kr,
              semi: zr,
              colon: Fr,
              dot: oi,
              question: ui,
              slash: Di,
              eq: p,
              name: Nt,
              eof: Mt,
              num: Ct,
              regexp: xt,
              string: Ot
            };
            for (var Bi in qt) te.tokTypes["_" + Bi] = qt[Bi];
            function ki(qe) {
              qe = qe.split(" ");
              var tt = "", ct = [];
              e: for (var mt = 0; mt < qe.length; ++mt) {
                for (var Ft = 0; Ft < ct.length; ++Ft)
                  if (ct[Ft][0].length == qe[mt].length) {
                    ct[Ft].push(qe[mt]);
                    continue e;
                  }
                ct.push([qe[mt]]);
              }
              function Ut(rr) {
                if (rr.length == 1) return tt += "return str === " + JSON.stringify(rr[0]) + ";";
                tt += "switch(str){";
                for (var jr = 0; jr < rr.length; ++jr) tt += "case " + JSON.stringify(rr[jr]) + ":";
                tt += "return true}return false;";
              }
              if (ct.length > 3) {
                ct.sort(function(rr, jr) {
                  return jr.length - rr.length;
                }), tt += "switch(str.length){";
                for (var mt = 0; mt < ct.length; ++mt) {
                  var Wt = ct[mt];
                  tt += "case " + Wt[0].length + ":", Ut(Wt);
                }
                tt += "}";
              } else
                Ut(qe);
              return new Function("str", tt);
            }
            var Ai = ki("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"), yi = ki("class enum extends super const export import"), wa = ki("implements interface let package private protected public static yield"), Yn = ki("eval arguments"), Ki = ki("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"), Qa = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/, Xn = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԧԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠࢢ-ࢬऄ-हऽॐक़-ॡॱ-ॷॹ-ॿঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-ళవ-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛰᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤜᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚗꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞓꞠ-Ɦꟸ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꪀ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", Ls = "̀-ͯ҃-֑҇-ׇֽֿׁׂׅׄؐ-ؚؠ-ىٲ-ۓۧ-ۨۻ-ۼܰ-݊ࠀ-ࠔࠛ-ࠣࠥ-ࠧࠩ-࠭ࡀ-ࡗࣤ-ࣾऀ-ःऺ-़ा-ॏ॑-ॗॢ-ॣ०-९ঁ-ঃ়া-ৄেৈৗয়-ৠਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢ-ૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୟ-ୠ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఁ-ఃె-ైొ-్ౕౖౢ-ౣ౦-౯ಂಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢ-ೣ೦-೯ംഃെ-ൈൗൢ-ൣ൦-൯ංඃ්ා-ුූෘ-ෟෲෳิ-ฺเ-ๅ๐-๙ິ-ູ່-ໍ໐-໙༘༙༠-༩༹༵༷ཁ-ཇཱ-྄྆-྇ྍ-ྗྙ-ྼ࿆က-ဩ၀-၉ၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟ᜎ-ᜐᜠ-ᜰᝀ-ᝐᝲᝳក-ឲ៝០-៩᠋-᠍᠐-᠙ᤠ-ᤫᤰ-᤻ᥑ-ᥭᦰ-ᧀᧈ-ᧉ᧐-᧙ᨀ-ᨕᨠ-ᩓ᩠-᩿᩼-᪉᪐-᪙ᭆ-ᭋ᭐-᭙᭫-᭳᮰-᮹᯦-᯳ᰀ-ᰢ᱀-᱉ᱛ-ᱽ᳐-᳒ᴀ-ᶾḁ-ἕ‌‍‿⁀⁔⃐-⃥⃜⃡-⃰ⶁ-ⶖⷠ-ⷿ〡-〨゙゚Ꙁ-ꙭꙴ-꙽ꚟ꛰-꛱ꟸ-ꠀ꠆ꠋꠣ-ꠧꢀ-ꢁꢴ-꣄꣐-꣙ꣳ-ꣷ꤀-꤉ꤦ-꤭ꤰ-ꥅꦀ-ꦃ꦳-꧀ꨀ-ꨧꩀ-ꩁꩌ-ꩍ꩐-꩙ꩻꫠ-ꫩꫲ-ꫳꯀ-ꯡ꯬꯭꯰-꯹ﬠ-ﬨ︀-️︠-︦︳︴﹍-﹏０-９＿", qn = new RegExp("[" + Xn + "]"), ba = new RegExp("[" + Xn + Ls + "]"), Qn = /[\n\r\u2028\u2029]/, Mr = /\r\n|[\n\r\u2028\u2029]/g, zi = te.isIdentifierStart = function(qe) {
              return qe < 65 ? qe === 36 : qe < 91 ? !0 : qe < 97 ? qe === 95 : qe < 123 ? !0 : qe >= 170 && qn.test(String.fromCharCode(qe));
            }, Sa = te.isIdentifierChar = function(qe) {
              return qe < 48 ? qe === 36 : qe < 58 ? !0 : qe < 65 ? !1 : qe < 91 ? !0 : qe < 97 ? qe === 95 : qe < 123 ? !0 : qe >= 170 && ba.test(String.fromCharCode(qe));
            };
            function wi() {
              this.line = et, this.column = O - Je;
            }
            function Ns() {
              et = 1, O = Je = 0, Ke = !0, Fi();
            }
            function xr(qe, tt) {
              Oe = O, he.locations && (je = new wi()), Fe = qe, Fi(), Ye = tt, Ke = qe.beforeExpr;
            }
            function Ka() {
              var qe = he.onComment && he.locations && new wi(), tt = O, ct = D.indexOf("*/", O += 2);
              if (ct === -1 && ht(O - 2, "Unterminated comment"), O = ct + 2, he.locations) {
                Mr.lastIndex = tt;
                for (var mt; (mt = Mr.exec(D)) && mt.index < O; )
                  ++et, Je = mt.index + mt[0].length;
              }
              he.onComment && he.onComment(
                !0,
                D.slice(tt + 2, ct),
                tt,
                O,
                qe,
                he.locations && new wi()
              );
            }
            function un() {
              for (var qe = O, tt = he.onComment && he.locations && new wi(), ct = D.charCodeAt(O += 2); O < Se && ct !== 10 && ct !== 13 && ct !== 8232 && ct !== 8233; )
                ++O, ct = D.charCodeAt(O);
              he.onComment && he.onComment(
                !1,
                D.slice(qe + 2, O),
                qe,
                O,
                tt,
                he.locations && new wi()
              );
            }
            function Fi() {
              for (; O < Se; ) {
                var qe = D.charCodeAt(O);
                if (qe === 32)
                  ++O;
                else if (qe === 13) {
                  ++O;
                  var tt = D.charCodeAt(O);
                  tt === 10 && ++O, he.locations && (++et, Je = O);
                } else if (qe === 10 || qe === 8232 || qe === 8233)
                  ++O, he.locations && (++et, Je = O);
                else if (qe > 8 && qe < 14)
                  ++O;
                else if (qe === 47) {
                  var tt = D.charCodeAt(O + 1);
                  if (tt === 42)
                    Ka();
                  else if (tt === 47)
                    un();
                  else break;
                } else if (qe === 160)
                  ++O;
                else if (qe >= 5760 && Qa.test(String.fromCharCode(qe)))
                  ++O;
                else
                  break;
              }
            }
            function Ds() {
              var qe = D.charCodeAt(O + 1);
              return qe >= 48 && qe <= 57 ? zs(!0) : (++O, xr(oi));
            }
            function Ko() {
              var qe = D.charCodeAt(O + 1);
              return Ke ? (++O, Bs()) : qe === 61 ? Ar(V, 2) : Ar(Di, 1);
            }
            function $o() {
              var qe = D.charCodeAt(O + 1);
              return qe === 61 ? Ar(V, 2) : Ar(Ci, 1);
            }
            function Jo(qe) {
              var tt = D.charCodeAt(O + 1);
              return tt === qe ? Ar(qe === 124 ? Xe : at, 2) : tt === 61 ? Ar(V, 2) : Ar(qe === 124 ? lt : Tt, 1);
            }
            function $a() {
              var qe = D.charCodeAt(O + 1);
              return qe === 61 ? Ar(V, 2) : Ar(Et, 1);
            }
            function eu(qe) {
              var tt = D.charCodeAt(O + 1);
              return tt === qe ? tt == 45 && D.charCodeAt(O + 2) == 62 && Qn.test(D.slice(dt, O)) ? (O += 3, un(), Fi(), ln()) : Ar(Te, 2) : tt === 61 ? Ar(V, 2) : Ar($r, 1);
            }
            function tu(qe) {
              var tt = D.charCodeAt(O + 1), ct = 1;
              return tt === qe ? (ct = qe === 62 && D.charCodeAt(O + 2) === 62 ? 3 : 2, D.charCodeAt(O + ct) === 61 ? Ar(V, ct + 1) : Ar(fr, ct)) : tt == 33 && qe == 60 && D.charCodeAt(O + 2) == 45 && D.charCodeAt(O + 3) == 45 ? (O += 4, un(), Fi(), ln()) : (tt === 61 && (ct = D.charCodeAt(O + 2) === 61 ? 3 : 2), Ar(zt, ct));
            }
            function ru(qe) {
              var tt = D.charCodeAt(O + 1);
              return tt === 61 ? Ar(Yt, D.charCodeAt(O + 2) === 61 ? 3 : 2) : Ar(qe === 61 ? p : Le, 1);
            }
            function iu(qe) {
              switch (qe) {
                case 46:
                  return Ds();
                case 40:
                  return ++O, xr(Vt);
                case 41:
                  return ++O, xr(Qr);
                case 59:
                  return ++O, xr(zr);
                case 44:
                  return ++O, xr(Kr);
                case 91:
                  return ++O, xr(qi);
                case 93:
                  return ++O, xr(Qi);
                case 123:
                  return ++O, xr(_i);
                case 125:
                  return ++O, xr(ni);
                case 58:
                  return ++O, xr(Fr);
                case 63:
                  return ++O, xr(ui);
                case 48:
                  var tt = D.charCodeAt(O + 1);
                  if (tt === 120 || tt === 88) return nu();
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  return zs(!1);
                case 34:
                case 39:
                  return Ja(qe);
                case 47:
                  return Ko();
                case 37:
                case 42:
                  return $o();
                case 124:
                case 38:
                  return Jo(qe);
                case 94:
                  return $a();
                case 43:
                case 45:
                  return eu(qe);
                case 60:
                case 62:
                  return tu(qe);
                case 61:
                case 33:
                  return ru(qe);
                case 126:
                  return Ar(Le, 1);
              }
              return !1;
            }
            function ln(qe) {
              if (qe ? O = ce + 1 : ce = O, he.locations && (Be = new wi()), qe) return Bs();
              if (O >= Se) return xr(Mt);
              var tt = D.charCodeAt(O);
              if (zi(tt) || tt === 92) return es();
              var ct = iu(tt);
              if (ct === !1) {
                var mt = String.fromCharCode(tt);
                if (mt === "\\" || qn.test(mt)) return es();
                ht(O, "Unexpected character '" + mt + "'");
              }
              return ct;
            }
            function Ar(qe, tt) {
              var ct = D.slice(O, O + tt);
              O += tt, xr(qe, ct);
            }
            function Bs() {
              for (var Ft = "", qe, tt, ct = O; ; ) {
                O >= Se && ht(ct, "Unterminated regular expression");
                var mt = D.charAt(O);
                if (Qn.test(mt) && ht(ct, "Unterminated regular expression"), qe)
                  qe = !1;
                else {
                  if (mt === "[") tt = !0;
                  else if (mt === "]" && tt) tt = !1;
                  else if (mt === "/" && !tt) break;
                  qe = mt === "\\";
                }
                ++O;
              }
              var Ft = D.slice(ct, O);
              ++O;
              var Ut = Fs();
              Ut && !/^[gmsiy]*$/.test(Ut) && ht(ct, "Invalid regexp flag");
              try {
                var Wt = new RegExp(Ft, Ut);
              } catch (rr) {
                rr instanceof SyntaxError && ht(ct, rr.message), ht(rr);
              }
              return xr(xt, Wt);
            }
            function Kn(qe, tt) {
              for (var ct = O, mt = 0, Ft = 0, Ut = tt ?? 1 / 0; Ft < Ut; ++Ft) {
                var Wt = D.charCodeAt(O), rr;
                if (Wt >= 97 ? rr = Wt - 97 + 10 : Wt >= 65 ? rr = Wt - 65 + 10 : Wt >= 48 && Wt <= 57 ? rr = Wt - 48 : rr = 1 / 0, rr >= qe) break;
                ++O, mt = mt * qe + rr;
              }
              return O === ct || tt != null && O - ct !== tt ? null : mt;
            }
            function nu() {
              O += 2;
              var qe = Kn(16);
              return qe == null && ht(ce + 2, "Expected hexadecimal number"), zi(D.charCodeAt(O)) && ht(O, "Identifier directly after number"), xr(Ct, qe);
            }
            function zs(qe) {
              var tt = O, ct = !1, mt = D.charCodeAt(O) === 48;
              !qe && Kn(10) === null && ht(tt, "Invalid number"), D.charCodeAt(O) === 46 && (++O, Kn(10), ct = !0);
              var Ft = D.charCodeAt(O);
              (Ft === 69 || Ft === 101) && (Ft = D.charCodeAt(++O), (Ft === 43 || Ft === 45) && ++O, Kn(10) === null && ht(tt, "Invalid number"), ct = !0), zi(D.charCodeAt(O)) && ht(O, "Identifier directly after number");
              var Ut = D.slice(tt, O), Wt;
              return ct ? Wt = parseFloat(Ut) : !mt || Ut.length === 1 ? Wt = parseInt(Ut, 10) : /[89]/.test(Ut) || ot ? ht(tt, "Invalid number") : Wt = parseInt(Ut, 8), xr(Ct, Wt);
            }
            function Ja(qe) {
              O++;
              for (var tt = ""; ; ) {
                O >= Se && ht(ce, "Unterminated string constant");
                var ct = D.charCodeAt(O);
                if (ct === qe)
                  return ++O, xr(Ot, tt);
                if (ct === 92) {
                  ct = D.charCodeAt(++O);
                  var mt = /^[0-7]+/.exec(D.slice(O, O + 3));
                  for (mt && (mt = mt[0]); mt && parseInt(mt, 8) > 255; ) mt = mt.slice(0, -1);
                  if (mt === "0" && (mt = null), ++O, mt)
                    ot && ht(O - 2, "Octal literal in strict mode"), tt += String.fromCharCode(parseInt(mt, 8)), O += mt.length - 1;
                  else
                    switch (ct) {
                      case 110:
                        tt += `
`;
                        break;
                      case 114:
                        tt += "\r";
                        break;
                      case 120:
                        tt += String.fromCharCode(Ea(2));
                        break;
                      case 117:
                        tt += String.fromCharCode(Ea(4));
                        break;
                      case 85:
                        tt += String.fromCharCode(Ea(8));
                        break;
                      case 116:
                        tt += "	";
                        break;
                      case 98:
                        tt += "\b";
                        break;
                      case 118:
                        tt += "\v";
                        break;
                      case 102:
                        tt += "\f";
                        break;
                      case 48:
                        tt += "\0";
                        break;
                      case 13:
                        D.charCodeAt(O) === 10 && ++O;
                      case 10:
                        he.locations && (Je = O, ++et);
                        break;
                      default:
                        tt += String.fromCharCode(ct);
                        break;
                    }
                } else
                  (ct === 13 || ct === 10 || ct === 8232 || ct === 8233) && ht(ce, "Unterminated string constant"), tt += String.fromCharCode(ct), ++O;
              }
            }
            function Ea(qe) {
              var tt = Kn(16, qe);
              return tt === null && ht(ce, "Bad character escape sequence"), tt;
            }
            var Sn;
            function Fs() {
              Sn = !1;
              for (var qe, tt = !0, ct = O; ; ) {
                var mt = D.charCodeAt(O);
                if (Sa(mt))
                  Sn && (qe += D.charAt(O)), ++O;
                else if (mt === 92) {
                  Sn || (qe = D.slice(ct, O)), Sn = !0, D.charCodeAt(++O) != 117 && ht(O, "Expecting Unicode escape sequence \\uXXXX"), ++O;
                  var Ft = Ea(4), Ut = String.fromCharCode(Ft);
                  Ut || ht(O - 1, "Invalid Unicode escape"), (tt ? zi(Ft) : Sa(Ft)) || ht(O - 4, "Invalid Unicode escape"), qe += Ut;
                } else
                  break;
                tt = !1;
              }
              return Sn ? qe : D.slice(ct, O);
            }
            function es() {
              var qe = Fs(), tt = Nt;
              return !Sn && Ki(qe) && (tt = qt[qe]), xr(tt, qe);
            }
            function er() {
              nt = ce, dt = Oe, vt = je, ln();
            }
            function ts(qe) {
              if (ot = qe, O = ce, he.locations)
                for (; O < Je; )
                  Je = D.lastIndexOf(`
`, Je - 2) + 1, --et;
              Fi(), ln();
            }
            function Us() {
              this.type = null, this.start = ce, this.end = null;
            }
            function js() {
              this.start = Be, this.end = null, le !== null && (this.source = le);
            }
            function Lr() {
              var qe = new Us();
              return he.locations && (qe.loc = new js()), he.directSourceFile && (qe.sourceFile = he.directSourceFile), he.ranges && (qe.range = [ce, 0]), qe;
            }
            function $i(qe) {
              var tt = new Us();
              return tt.start = qe.start, he.locations && (tt.loc = new js(), tt.loc.start = qe.loc.start), he.ranges && (tt.range = [qe.range[0], 0]), tt;
            }
            function Xt(qe, tt) {
              return qe.type = tt, qe.end = dt, he.locations && (qe.loc.end = vt), he.ranges && (qe.range[1] = dt), qe;
            }
            function $n(qe) {
              return he.ecmaVersion >= 5 && qe.type === "ExpressionStatement" && qe.expression.type === "Literal" && qe.expression.value === "use strict";
            }
            function sr(qe) {
              if (Fe === qe)
                return er(), !0;
            }
            function xa() {
              return !he.strictSemicolons && (Fe === Mt || Fe === ni || Qn.test(D.slice(dt, ce)));
            }
            function Ji() {
              !sr(zr) && !xa() && Ti();
            }
            function wr(qe) {
              Fe === qe ? er() : Ti();
            }
            function Ti() {
              ht(ce, "Unexpected token");
            }
            function Jn(qe) {
              qe.type !== "Identifier" && qe.type !== "MemberExpression" && ht(qe.start, "Assigning to rvalue"), ot && qe.type === "Identifier" && Yn(qe.name) && ht(qe.start, "Assigning to " + qe.name + " in strict mode");
            }
            function Hs(qe) {
              nt = dt = O, he.locations && (vt = new wi()), bt = ot = null, At = [], ln();
              var tt = qe || Lr(), ct = !0;
              for (qe || (tt.body = []); Fe !== Mt; ) {
                var mt = bi();
                tt.body.push(mt), ct && $n(mt) && ts(!0), ct = !1;
              }
              return Xt(tt, "Program");
            }
            var en = { kind: "loop" }, au = { kind: "switch" };
            function bi() {
              (Fe === Di || Fe === V && Ye == "/=") && ln(!0);
              var qe = Fe, tt = Lr();
              switch (qe) {
                case Gt:
                case ar:
                  er();
                  var ct = qe === Gt;
                  sr(zr) || xa() ? tt.label = null : Fe !== Nt ? Ti() : (tt.label = Pr(), Ji());
                  for (var mt = 0; mt < At.length; ++mt) {
                    var Ft = At[mt];
                    if ((tt.label == null || Ft.name === tt.label.name) && (Ft.kind != null && (ct || Ft.kind === "loop") || tt.label && ct))
                      break;
                  }
                  return mt === At.length && ht(tt.start, "Unsyntactic " + qe.keyword), Xt(tt, ct ? "BreakStatement" : "ContinueStatement");
                case ur:
                  return er(), Ji(), Xt(tt, "DebuggerStatement");
                case wt:
                  return er(), At.push(en), tt.body = bi(), At.pop(), wr(yr), tt.test = ea(), Ji(), Xt(tt, "DoWhileStatement");
                case tr:
                  if (er(), At.push(en), wr(Vt), Fe === zr) return Ca(tt, null);
                  if (Fe === qr) {
                    var Ut = Lr();
                    return er(), Cn(Ut, !0), Xt(Ut, "VariableDeclaration"), Ut.declarations.length === 1 && sr(Xi) ? xn(tt, Ut) : Ca(tt, Ut);
                  }
                  var Ut = Ur(!1, !0);
                  return sr(Xi) ? (Jn(Ut), xn(tt, Ut)) : Ca(tt, Ut);
                case Xr:
                  return er(), rs(tt, !0);
                case gi:
                  return er(), tt.test = ea(), tt.consequent = bi(), tt.alternate = sr($t) ? bi() : null, Xt(tt, "IfStatement");
                case ii:
                  return !bt && !he.allowReturnOutsideFunction && ht(ce, "'return' outside of function"), er(), sr(zr) || xa() ? tt.argument = null : (tt.argument = Ur(), Ji()), Xt(tt, "ReturnStatement");
                case Br:
                  er(), tt.discriminant = ea(), tt.cases = [], wr(_i), At.push(au);
                  for (var Wt, rr; Fe != ni; )
                    if (Fe === Bt || Fe === hr) {
                      var jr = Fe === Bt;
                      Wt && Xt(Wt, "SwitchCase"), tt.cases.push(Wt = Lr()), Wt.consequent = [], er(), jr ? Wt.test = Ur() : (rr && ht(nt, "Multiple default clauses"), rr = !0, Wt.test = null), wr(Fr);
                    } else
                      Wt || Ti(), Wt.consequent.push(bi());
                  return Wt && Xt(Wt, "SwitchCase"), er(), At.pop(), Xt(tt, "SwitchStatement");
                case Er:
                  return er(), Qn.test(D.slice(dt, ce)) && ht(dt, "Illegal newline after throw"), tt.argument = Ur(), Ji(), Xt(tt, "ThrowStatement");
                case kr:
                  if (er(), tt.block = En(), tt.handler = null, Fe === or) {
                    var Ui = Lr();
                    er(), wr(Vt), Ui.param = Pr(), ot && Yn(Ui.param.name) && ht(Ui.param.start, "Binding " + Ui.param.name + " in strict mode"), wr(Qr), Ui.guard = null, Ui.body = En(), tt.handler = Xt(Ui, "CatchClause");
                  }
                  return tt.guardedHandlers = gt, tt.finalizer = sr(lr) ? En() : null, !tt.handler && !tt.finalizer && ht(tt.start, "Missing catch or finally clause"), Xt(tt, "TryStatement");
                case qr:
                  return er(), Cn(tt), Ji(), Xt(tt, "VariableDeclaration");
                case yr:
                  return er(), tt.test = ea(), At.push(en), tt.body = bi(), At.pop(), Xt(tt, "WhileStatement");
                case Or:
                  return ot && ht(ce, "'with' in strict mode"), er(), tt.object = ea(), tt.body = bi(), Xt(tt, "WithStatement");
                case _i:
                  return En();
                case zr:
                  return er(), Xt(tt, "EmptyStatement");
                default:
                  var fn = Ye, Tn = Ur();
                  if (qe === Nt && Tn.type === "Identifier" && sr(Fr)) {
                    for (var mt = 0; mt < At.length; ++mt)
                      At[mt].name === fn && ht(Tn.start, "Label '" + fn + "' is already declared");
                    var Zs = Fe.isLoop ? "loop" : Fe === Br ? "switch" : null;
                    return At.push({ name: fn, kind: Zs }), tt.body = bi(), At.pop(), tt.label = Tn, Xt(tt, "LabeledStatement");
                  } else
                    return tt.expression = Tn, Ji(), Xt(tt, "ExpressionStatement");
              }
            }
            function ea() {
              wr(Vt);
              var qe = Ur();
              return wr(Qr), qe;
            }
            function En(qe) {
              var tt = Lr(), ct = !0, mt = !1, Ft;
              for (tt.body = [], wr(_i); !sr(ni); ) {
                var Ut = bi();
                tt.body.push(Ut), ct && qe && $n(Ut) && (Ft = mt, ts(mt = !0)), ct = !1;
              }
              return mt && !Ft && ts(!1), Xt(tt, "BlockStatement");
            }
            function Ca(qe, tt) {
              return qe.init = tt, wr(zr), qe.test = Fe === zr ? null : Ur(), wr(zr), qe.update = Fe === Qr ? null : Ur(), wr(Qr), qe.body = bi(), At.pop(), Xt(qe, "ForStatement");
            }
            function xn(qe, tt) {
              return qe.left = tt, qe.right = Ur(), wr(Qr), qe.body = bi(), At.pop(), Xt(qe, "ForInStatement");
            }
            function Cn(qe, tt) {
              for (qe.declarations = [], qe.kind = "var"; ; ) {
                var ct = Lr();
                if (ct.id = Pr(), ot && Yn(ct.id.name) && ht(ct.id.start, "Binding " + ct.id.name + " in strict mode"), ct.init = sr(p) ? Ur(!0, tt) : null, qe.declarations.push(Xt(ct, "VariableDeclarator")), !sr(Kr)) break;
              }
              return qe;
            }
            function Ur(qe, tt) {
              var ct = kn(tt);
              if (!qe && Fe === Kr) {
                var mt = $i(ct);
                for (mt.expressions = [ct]; sr(Kr); ) mt.expressions.push(kn(tt));
                return Xt(mt, "SequenceExpression");
              }
              return ct;
            }
            function kn(qe) {
              var tt = su(qe);
              if (Fe.isAssign) {
                var ct = $i(tt);
                return ct.operator = Ye, ct.left = tt, er(), ct.right = kn(qe), Jn(tt), Xt(ct, "AssignmentExpression");
              }
              return tt;
            }
            function su(qe) {
              var tt = Gs(qe);
              if (sr(ui)) {
                var ct = $i(tt);
                return ct.test = tt, ct.consequent = Ur(!0), wr(Fr), ct.alternate = Ur(!0, qe), Xt(ct, "ConditionalExpression");
              }
              return tt;
            }
            function Gs(qe) {
              return ta(ra(), -1, qe);
            }
            function ta(qe, tt, ct) {
              var mt = Fe.binop;
              if (mt != null && (!ct || Fe !== Xi) && mt > tt) {
                var Ft = $i(qe);
                Ft.left = qe, Ft.operator = Ye;
                var Ut = Fe;
                er(), Ft.right = ta(ra(), mt, ct);
                var Wt = Xt(Ft, Ut === Xe || Ut === at ? "LogicalExpression" : "BinaryExpression");
                return ta(Wt, tt, ct);
              }
              return qe;
            }
            function ra() {
              if (Fe.prefix) {
                var qe = Lr(), tt = Fe.isUpdate;
                return qe.operator = Ye, qe.prefix = !0, Ke = !0, er(), qe.argument = ra(), tt ? Jn(qe.argument) : ot && qe.operator === "delete" && qe.argument.type === "Identifier" && ht(qe.start, "Deleting local variable in strict mode"), Xt(qe, tt ? "UpdateExpression" : "UnaryExpression");
              }
              for (var ct = Vs(); Fe.postfix && !xa(); ) {
                var qe = $i(ct);
                qe.operator = Ye, qe.prefix = !1, qe.argument = ct, Jn(ct), er(), ct = Xt(qe, "UpdateExpression");
              }
              return ct;
            }
            function Vs() {
              return An(ka());
            }
            function An(qe, tt) {
              if (sr(oi)) {
                var ct = $i(qe);
                return ct.object = qe, ct.property = Pr(!0), ct.computed = !1, An(Xt(ct, "MemberExpression"), tt);
              } else if (sr(qi)) {
                var ct = $i(qe);
                return ct.object = qe, ct.property = Ur(), ct.computed = !0, wr(Qi), An(Xt(ct, "MemberExpression"), tt);
              } else if (!tt && sr(Vt)) {
                var ct = $i(qe);
                return ct.callee = qe, ct.arguments = is(Qr, !1), An(Xt(ct, "CallExpression"), tt);
              } else return qe;
            }
            function ka() {
              switch (Fe) {
                case wn:
                  var mt = Lr();
                  return er(), Xt(mt, "ThisExpression");
                case Nt:
                  return Pr();
                case Ct:
                case Ot:
                case xt:
                  var mt = Lr();
                  return mt.value = Ye, mt.raw = D.slice(ce, Oe), er(), Xt(mt, "Literal");
                case bn:
                case Yi:
                case ya:
                  var mt = Lr();
                  return mt.value = Fe.atomValue, mt.raw = Fe.keyword, er(), Xt(mt, "Literal");
                case Vt:
                  var qe = Be, tt = ce;
                  er();
                  var ct = Ur();
                  return ct.start = tt, ct.end = Oe, he.locations && (ct.loc.start = qe, ct.loc.end = je), he.ranges && (ct.range = [tt, Oe]), wr(Qr), ct;
                case qi:
                  var mt = Lr();
                  return er(), mt.elements = is(Qi, !0, !0), Xt(mt, "ArrayExpression");
                case _i:
                  return uu();
                case Xr:
                  var mt = Lr();
                  return er(), rs(mt, !1);
                case yn:
                  return ou();
                default:
                  Ti();
              }
            }
            function ou() {
              var qe = Lr();
              return er(), qe.callee = An(ka(), !0), sr(Vt) ? qe.arguments = is(Qr, !1) : qe.arguments = gt, Xt(qe, "NewExpression");
            }
            function uu() {
              var qe = Lr(), tt = !0, ct = !1;
              for (qe.properties = [], er(); !sr(ni); ) {
                if (tt)
                  tt = !1;
                else if (wr(Kr), he.allowTrailingCommas && sr(ni)) break;
                var mt = { key: Ws() }, Ft = !1, Ut;
                if (sr(Fr) ? (mt.value = Ur(!0), Ut = mt.kind = "init") : he.ecmaVersion >= 5 && mt.key.type === "Identifier" && (mt.key.name === "get" || mt.key.name === "set") ? (Ft = ct = !0, Ut = mt.kind = mt.key.name, mt.key = Ws(), Fe !== Vt && Ti(), mt.value = rs(Lr(), !1)) : Ti(), mt.key.type === "Identifier" && (ot || ct))
                  for (var Wt = 0; Wt < qe.properties.length; ++Wt) {
                    var rr = qe.properties[Wt];
                    if (rr.key.name === mt.key.name) {
                      var jr = Ut == rr.kind || Ft && rr.kind === "init" || Ut === "init" && (rr.kind === "get" || rr.kind === "set");
                      jr && !ot && Ut === "init" && rr.kind === "init" && (jr = !1), jr && ht(mt.key.start, "Redefinition of property");
                    }
                  }
                qe.properties.push(mt);
              }
              return Xt(qe, "ObjectExpression");
            }
            function Ws() {
              return Fe === Ct || Fe === Ot ? ka() : Pr(!0);
            }
            function rs(qe, tt) {
              Fe === Nt ? qe.id = Pr() : tt ? Ti() : qe.id = null, qe.params = [];
              var ct = !0;
              for (wr(Vt); !sr(Qr); )
                ct ? ct = !1 : wr(Kr), qe.params.push(Pr());
              var mt = bt, Ft = At;
              if (bt = !0, At = [], qe.body = En(!0), bt = mt, At = Ft, ot || qe.body.body.length && $n(qe.body.body[0]))
                for (var Ut = qe.id ? -1 : 0; Ut < qe.params.length; ++Ut) {
                  var Wt = Ut < 0 ? qe.id : qe.params[Ut];
                  if ((wa(Wt.name) || Yn(Wt.name)) && ht(Wt.start, "Defining '" + Wt.name + "' in strict mode"), Ut >= 0) for (var rr = 0; rr < Ut; ++rr) Wt.name === qe.params[rr].name && ht(Wt.start, "Argument name clash in strict mode");
                }
              return Xt(qe, tt ? "FunctionDeclaration" : "FunctionExpression");
            }
            function is(qe, tt, ct) {
              for (var mt = [], Ft = !0; !sr(qe); ) {
                if (Ft)
                  Ft = !1;
                else if (wr(Kr), tt && he.allowTrailingCommas && sr(qe)) break;
                ct && Fe === Kr ? mt.push(null) : mt.push(Ur(!0));
              }
              return mt;
            }
            function Pr(qe) {
              var tt = Lr();
              return qe && he.forbidReserved == "everywhere" && (qe = !1), Fe === Nt ? (!qe && (he.forbidReserved && (he.ecmaVersion === 3 ? Ai : yi)(Ye) || ot && wa(Ye)) && D.slice(ce, Oe).indexOf("\\") == -1 && ht(ce, "The keyword '" + Ye + "' is reserved"), tt.name = Ye) : qe && Fe.keyword ? tt.name = Fe.keyword : Ti(), Ke = !1, er(), Xt(tt, "Identifier");
            }
          }), r.version || (r = null);
        }
        function R(te, he) {
          return (e.acorn || r).parse(te, he);
        }
        var B = {
          "+": "__add",
          "-": "__subtract",
          "*": "__multiply",
          "/": "__divide",
          "%": "__modulo",
          "==": "__equals",
          "!=": "__equals"
        }, j = {
          "-": "__negate",
          "+": "__self"
        }, H = _.each(
          ["add", "subtract", "multiply", "divide", "modulo", "equals", "negate"],
          function(te) {
            this["__" + te] = "#" + te;
          },
          {
            __self: function() {
              return this;
            }
          }
        );
        a.inject(H), d.inject(H), xe.inject(H);
        function X(te, he, D) {
          var Se = B[he];
          if (te && te[Se]) {
            var le = te[Se](D);
            return he === "!=" ? !le : le;
          }
          switch (he) {
            case "+":
              return te + D;
            case "-":
              return te - D;
            case "*":
              return te * D;
            case "/":
              return te / D;
            case "%":
              return te % D;
            case "==":
              return te == D;
            case "!=":
              return te != D;
          }
        }
        function ue(te, he) {
          var D = j[te];
          if (he && he[D])
            return he[D]();
          switch (te) {
            case "+":
              return +he;
            case "-":
              return -he;
          }
        }
        function pe(te, he) {
          if (!te)
            return "";
          he = he || {};
          var D = [];
          function Se(ot) {
            for (var ht = 0, gt = D.length; ht < gt; ht++) {
              var Ct = D[ht];
              if (Ct[0] >= ot)
                break;
              ot += Ct[1];
            }
            return ot;
          }
          function le(ot) {
            return te.substring(
              Se(ot.range[0]),
              Se(ot.range[1])
            );
          }
          function v(ot, ht) {
            return te.substring(
              Se(ot.range[1]),
              Se(ht.range[0])
            );
          }
          function se(ot, ht) {
            for (var gt = Se(ot.range[0]), Ct = Se(ot.range[1]), xt = 0, Ot = D.length - 1; Ot >= 0; Ot--)
              if (gt > D[Ot][0]) {
                xt = Ot + 1;
                break;
              }
            D.splice(xt, 0, [gt, ht.length - Ct + gt]), te = te.substring(0, gt) + ht + te.substring(Ct);
          }
          function me(ot, ht) {
            switch (ot.type) {
              case "UnaryExpression":
                if (ot.operator in j && ot.argument.type !== "Literal") {
                  var gt = le(ot.argument);
                  se(ot, '$__("' + ot.operator + '", ' + gt + ")");
                }
                break;
              case "BinaryExpression":
                if (ot.operator in B && ot.left.type !== "Literal") {
                  var Ct = le(ot.left), xt = le(ot.right), Ot = v(ot.left, ot.right), Nt = ot.operator;
                  se(ot, "__$__(" + Ct + "," + Ot.replace(
                    new RegExp("\\" + Nt),
                    '"' + Nt + '"'
                  ) + ", " + xt + ")");
                }
                break;
              case "UpdateExpression":
              case "AssignmentExpression":
                var Mt = ht && ht.type;
                if (!(Mt === "ForStatement" || Mt === "BinaryExpression" && /^[=!<>]/.test(ht.operator) || Mt === "MemberExpression" && ht.computed)) {
                  if (ot.type === "UpdateExpression") {
                    var gt = le(ot.argument), Gt = "__$__(" + gt + ', "' + ot.operator[0] + '", 1)', Bt = gt + " = " + Gt;
                    ot.prefix ? Bt = "(" + Bt + ")" : (Mt === "AssignmentExpression" || Mt === "VariableDeclarator" || Mt === "BinaryExpression") && (le(ht.left || ht.id) === gt && (Bt = Gt), Bt = gt + "; " + Bt), se(ot, Bt);
                  } else if (/^.=$/.test(ot.operator) && ot.left.type !== "Literal") {
                    var Ct = le(ot.left), xt = le(ot.right), Gt = Ct + " = __$__(" + Ct + ', "' + ot.operator[0] + '", ' + xt + ")";
                    se(ot, /^\(.*\)$/.test(le(ot)) ? "(" + Gt + ")" : Gt);
                  }
                }
                break;
            }
          }
          function O(ot) {
            switch (ot.type) {
              case "ExportDefaultDeclaration":
                se({
                  range: [ot.start, ot.declaration.start]
                }, "module.exports = ");
                break;
              case "ExportNamedDeclaration":
                var ht = ot.declaration, gt = ot.specifiers;
                if (ht) {
                  var Ct = ht.declarations;
                  Ct && (Ct.forEach(function(Ot) {
                    se(Ot, "module.exports." + le(Ot));
                  }), se({
                    range: [
                      ot.start,
                      ht.start + ht.kind.length
                    ]
                  }, ""));
                } else if (gt) {
                  var xt = gt.map(function(Ot) {
                    var Nt = le(Ot);
                    return "module.exports." + Nt + " = " + Nt + "; ";
                  }).join("");
                  xt && se(ot, xt);
                }
                break;
            }
          }
          function ce(ot, ht, gt) {
            if (ot) {
              for (var Ct in ot)
                if (Ct !== "range" && Ct !== "loc") {
                  var xt = ot[Ct];
                  if (Array.isArray(xt))
                    for (var Ot = 0, Nt = xt.length; Ot < Nt; Ot++)
                      ce(xt[Ot], ot, gt);
                  else xt && typeof xt == "object" && ce(xt, ot, gt);
                }
              gt.operatorOverloading !== !1 && me(ot, ht), gt.moduleExports !== !1 && O(ot);
            }
          }
          function Oe(ot) {
            var ht = "", gt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (ot = (Math.abs(ot) << 1) + (ot < 0 ? 1 : 0); ot || !ht; ) {
              var Ct = ot & 31;
              ot >>= 5, ot && (Ct |= 32), ht += gt[Ct];
            }
            return ht;
          }
          var Be = he.url || "", je = he.sourceMaps, Fe = he.paperFeatures || {}, Ye = he.source || te, Ke = he.offset || 0, et = Ae.agent, Je = et.versionNumber, nt = !1, dt = /\r\n|\n|\r/mg, vt;
          if (je && (et.chrome && Je >= 30 || et.webkit && Je >= 537.76 || et.firefox && Je >= 23 || et.node)) {
            if (et.node)
              Ke -= 2;
            else if (k && Be && !k.location.href.indexOf(Be)) {
              var bt = Z.getElementsByTagName("html")[0].innerHTML;
              Ke = bt.substr(0, bt.indexOf(te) + 1).match(
                dt
              ).length + 1;
            }
            nt = Ke > 0 && !(et.chrome && Je >= 36 || et.safari && Je >= 600 || et.firefox && Je >= 40 || et.node);
            var At = ["AA" + Oe(nt ? 0 : Ke) + "A"];
            At.length = (te.match(dt) || []).length + 1 + (nt ? Ke : 0), vt = {
              version: 3,
              file: Be,
              names: [],
              mappings: At.join(";AACA"),
              sourceRoot: "",
              sources: [Be],
              sourcesContent: [Ye]
            };
          }
          return (Fe.operatorOverloading !== !1 || Fe.moduleExports !== !1) && ce(R(te, {
            ranges: !0,
            preserveParens: !0,
            sourceType: "module"
          }), null, Fe), vt && (nt && (te = new Array(Ke + 1).join(`
`) + te), /^(inline|both)$/.test(je) && (te += `
//# sourceMappingURL=data:application/json;base64,` + be.btoa(unescape(encodeURIComponent(
            JSON.stringify(vt)
          )))), te += `
//# sourceURL=` + (Be || "paperscript")), {
            url: Be,
            source: Ye,
            code: te,
            map: vt
          };
        }
        function P(te, he, D) {
          Ae = he;
          var Se = he.getView(), le = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(te) && !/\bnew\s+Tool\b/.test(te) ? new _e() : null, v = le ? le._events : [], se = ["onFrame", "onResize"].concat(v), me = [], O = [], ce, Oe = typeof te == "object" ? te : pe(te, D);
          te = Oe.code;
          function Be(Je, nt) {
            for (var dt in Je)
              (nt || !/^_/.test(dt)) && new RegExp("([\\b\\s\\W]|^)" + dt.replace(/\$/g, "\\$") + "\\b").test(te) && (me.push(dt), O.push(Je[dt]));
          }
          Be(
            { __$__: X, $__: ue, paper: he, tool: le },
            !0
          ), Be(he), te = "var module = { exports: {} }; " + te;
          var Ke = _.each(se, function(Je) {
            new RegExp("\\s+" + Je + "\\b").test(te) && (me.push(Je), this.push("module.exports." + Je + " = " + Je + ";"));
          }, []).join(`
`);
          Ke && (te += `
` + Ke), te += `
return module.exports;`;
          var je = Ae.agent;
          if (Z && (je.chrome || je.firefox && je.versionNumber < 40)) {
            var Fe = Z.createElement("script"), Ye = Z.head || Z.getElementsByTagName("head")[0];
            je.firefox && (te = `
` + te), Fe.appendChild(Z.createTextNode(
              "document.__paperscript__ = function(" + me + ") {" + te + `
}`
            )), Ye.appendChild(Fe), ce = Z.__paperscript__, delete Z.__paperscript__, Ye.removeChild(Fe);
          } else
            ce = Function(me, te);
          var Ke = ce && ce.apply(he, O), et = Ke || {};
          return _.each(v, function(Je) {
            var nt = et[Je];
            nt && (le[Je] = nt);
          }), Se && (et.onResize && Se.setOnResize(et.onResize), Se.emit("resize", {
            size: Se.size,
            delta: new a()
          }), et.onFrame && Se.setOnFrame(et.onFrame), Se.requestUpdate()), Ke;
        }
        function q(te) {
          if (/^text\/(?:x-|)paperscript$/.test(te.type) && x.getAttribute(te, "ignore") !== "true") {
            var he = x.getAttribute(te, "canvas"), D = Z.getElementById(he), Se = te.src || te.getAttribute("data-src"), le = x.hasAttribute(te, "async"), v = "data-paper-scope";
            if (!D)
              throw new Error('Unable to find canvas with id "' + he + '"');
            var se = x.get(D.getAttribute(v)) || new x().setup(D);
            return D.setAttribute(v, se._id), Se ? $.request({
              url: Se,
              async: le,
              mimeType: "text/plain",
              onLoad: function(me) {
                P(me, se, Se);
              }
            }) : P(te.innerHTML, se, te.baseURI), te.setAttribute("data-paper-ignore", "true"), se;
          }
        }
        function K() {
          _.each(
            Z && Z.getElementsByTagName("script"),
            q
          );
        }
        function ye(te) {
          return te ? q(te) : K();
        }
        return k && (Z.readyState === "complete" ? setTimeout(K) : We.add(k, { load: K })), {
          compile: pe,
          execute: P,
          load: ye,
          parse: R,
          calculateBinary: X,
          calculateUnary: ue
        };
      }).call(this);
      var Ae = new (x.inject(_.exports, {
        Base: _,
        Numerical: u,
        Key: Ie,
        DomEvent: We,
        DomElement: He,
        document: Z,
        window: k,
        Symbol: U,
        PlacedSymbol: z
      }))();
      return Ae.agent.node && Gc(Ae), typeof ae == "function" && ae.amd ? ae("paper", Ae) : Re && (Re.exports = Ae), Ae;
    }).call(N0, typeof self == "object" ? self : null);
  }(Vo)), Vo.exports;
}
var B0 = D0();
const Ts = /* @__PURE__ */ Yo(B0), Vn = {
  heart: {
    name: "Heart",
    width: 150,
    height: 150,
    svg: "<svg version='1.0' xmlns='http://www.w3.org/2000/svg' width='150' height='150' viewBox='0 0 150 150'><path d='M54.0982,131.36312c-37.55979,-34.26132 -50.98892,-55.93441 -51.09775,-82.4662c-0.09925,-24.18698 16.47831,-47.53097 33.65802,-47.39635c8.57878,0.06736 26.98082,8.96949 33.49705,16.20469c3.28326,3.64551 4.83837,3.28603 12.14819,-2.80822c19.89425,-16.58593 39.32119,-16.93407 51.90293,-0.93003c20.10829,25.57781 16.44736,56.12239 -10.52395,87.80537c-14.3395,16.84451 -45.65381,46.72762 -48.96555,46.72762c-1.00772,0 -10.28624,-7.71161 -20.61895,-17.13688l0,0.00001z' fill='black'/></svg>",
    svg_d: "M54.0982,131.36312c-37.55979,-34.26132 -50.98892,-55.93441 -51.09775,-82.4662c-0.09925,-24.18698 16.47831,-47.53097 33.65802,-47.39635c8.57878,0.06736 26.98082,8.96949 33.49705,16.20469c3.28326,3.64551 4.83837,3.28603 12.14819,-2.80822c19.89425,-16.58593 39.32119,-16.93407 51.90293,-0.93003c20.10829,25.57781 16.44736,56.12239 -10.52395,87.80537c-14.3395,16.84451 -45.65381,46.72762 -48.96555,46.72762c-1.00772,0 -10.28624,-7.71161 -20.61895,-17.13688l0,0.00001z",
    svg_border: "M119.3 2.15c13.2 4.35 24.25 19.95 27.2 38.5.85 5.2.35 17.2-.95 22.85-3.55 15.6-11.65 29.05-28.45 47.3-9.6 10.4-32.75 31.7-39.75 36.55l-1.9 1.35-1.8-.95c-6.5-3.5-36.95-33.35-50.25-49.3-9.7-11.6-17.5-27.5-19.7-40.15-1.15-6.65-.75-16.45 1-22.95 3.1-11.55 11.8-24.65 19.35-29.1 13.05-7.65 27.5-4.7 44.55 9.15 3.8 3.1 6.3 4.6 7.65 4.6.4 0 2.05-1.2 3.65-2.65 6.2-5.7 14.6-10.6 23.85-13.85 5.3-1.9 12.1-2.45 15.55-1.35zm-12.6 2.65c-8.6 2.45-18.65 7.95-24.85 13.6-1.85 1.65-3.9 3.15-4.65 3.3-2.15.55-4.5-.6-9.6-4.6-6.85-5.35-12.4-8.75-17.5-10.6-3.65-1.4-5.25-1.7-10-1.9-6.9-.3-10.65.6-15.1 3.45-7.7 4.95-15.15 16.25-18.35 27.7-1.25 4.55-1.4 5.75-1.4 13.25.05 6.85.2 9 1.15 12.75 3.25 13 9.95 25.2 21.05 38.45 13 15.5 44.5 45.8 47.6 45.8 2.1 0 17.75-13.75 33-29 18.95-18.95 27.8-31.15 33.1-45.5 2.95-8.05 3.6-12.05 3.6-22.5-.05-8.2-.15-9.75-1.2-13.5-2.85-10.1-6.85-17.35-13-23.5-8.05-8-14.4-9.95-23.85-7.2z",
    svg_border_width: 4,
    maskClass: "mask-heart",
    fillColor: "rgba(255,255,255,0.7)",
    mapDimensions: {
      zoom: 12,
      targetSize: 300
    }
  },
  dogtag: {
    name: "Dog Tag",
    width: 84,
    height: 150,
    svg: `<svg version='1.0' xmlns='http://www.w3.org/2000/svg' width='84' height='150' viewBox='0 0 84 150'><path transform="translate(0, 0)" d='M42 150c-15.4 0-27.9-2.8-37.5-8.4C1.7 140 0 137.7 0 135V15C0 12.3 1.7 10 4.5 8.4 14.1 2.8 26.6 0 42 0s27.9 2.8 37.5 8.4C82.3 10 84 12.3 84 15v120c0 2.7-1.7 5-4.5 6.6C69.9 147.2 57.4 150 42 150z' fill='#000000'/></svg>`,
    svg_d: "M42 150c-15.4 0-27.9-2.8-37.5-8.4C1.7 140 0 137.7 0 135V15C0 12.3 1.7 10 4.5 8.4 14.1 2.8 26.6 0 42 0s27.9 2.8 37.5 8.4C82.3 10 84 12.3 84 15v120c0 2.7-1.7 5-4.5 6.6C69.9 147.2 57.4 150 42 150z",
    svg_border: "M42 150c-15.4 0-27.9-2.8-37.5-8.4C1.7 140 0 137.7 0 135V15C0 12.3 1.7 10 4.5 8.4 14.1 2.8 26.6 0 42 0s27.9 2.8 37.5 8.4C82.3 10 84 12.3 84 15v120c0 2.7-1.7 5-4.5 6.6C69.9 147.2 57.4 150 42 150z",
    svg_border_width: 4,
    maskClass: "mask-dogtag",
    fillColor: "rgba(255,255,255,0.7)",
    mapDimensions: {
      zoom: 13,
      targetSize: 400
    }
  }
}, z0 = ({
  map: Re,
  metalType: be,
  previewContent: ae,
  setPreviewContent: k,
  setPreviewType: Z,
  cf: _,
  setCustomFields: M,
  shape: x,
  selectedMarker: y,
  showErrors: E
}) => {
  const c = () => {
    var W;
    const u = Vn[x], l = Re.current.getCenter(), a = Re.current.project(l), n = 24, d = 24, g = document.createElement("canvas");
    g.width = u.width, g.height = u.height, Ts.setup(g);
    const h = new Ts.Path(u.svg_d);
    h.position = new Ts.Point(u.width / 2, u.height / 2);
    const m = Re.current.queryRenderedFeatures({
      layers: ["road-network", "parks", "water", "background"],
      geometry: {
        type: "Circle",
        coordinates: l.toArray()
      }
    });
    let s = [];
    const b = document.createElement("canvas");
    b.width = u.width, b.height = u.height;
    const S = b.getContext("2d");
    m.forEach((Q) => {
      if (Q.layer.id === "parks" && Q.geometry.coordinates.forEach((de) => {
        const we = de[0].map((fe) => {
          if (fe[0] && fe[1]) {
            const xe = Re.current.project([fe[0], fe[1]]);
            return {
              x: xe.x - (a.x - u.width / 2),
              y: xe.y - (a.y - u.height / 2)
            };
          }
        }).filter(Boolean), ke = new Ts.Path();
        we.forEach((fe) => {
          ke.add(new Ts.Point(fe.x, fe.y));
        }), ke.closed = !0;
        const Me = ke.intersect(h);
        Me && Me.segments && (S.fillStyle = "#91d891", S.beginPath(), Me.segments.forEach((fe, xe) => {
          const Ee = fe.point;
          xe === 0 ? S.moveTo(Ee.x, Ee.y) : S.lineTo(Ee.x, Ee.y);
        }), S.closePath(), S.fill());
      }), Q.geometry.type === "LineString") {
        const de = Q.geometry.coordinates.map((we) => {
          const ke = Re.current.project([we[0], we[1]]);
          return {
            x: ke.x - (a.x - u.width / 2),
            y: ke.y - (a.y - u.height / 2)
          };
        });
        s.push(de);
      }
      Q.geometry.type === "MultiLineString" && Q.geometry.coordinates.forEach((de) => {
        const we = de.map((ke) => {
          const Me = Re.current.project([ke[0], ke[1]]);
          return {
            x: Me.x - (a.x - u.width / 2),
            y: Me.y - (a.y - u.height / 2)
          };
        });
        s.push(we);
      });
    });
    const o = document.createElement("canvas");
    o.width = u.width, o.height = u.height;
    const A = o.getContext("2d");
    A.save(), A.beginPath();
    const T = new Path2D(u.svg_d);
    A.clip(T), y !== "none" && (A.rect(0, 0, u.width, u.height), A.rect(
      u.width / 2 - n / 2,
      u.height / 2 - d / 2,
      n,
      d
    ), A.clip("evenodd")), A.strokeStyle = `var(--metal-${be}-color)`, A.beginPath(), s.forEach((Q) => {
      Q.forEach((de, we) => {
        we === 0 ? A.moveTo(de.x, de.y) : A.lineTo(de.x, de.y);
      });
    }), A.stroke();
    const I = document.createElement("canvas");
    I.width = u.width, I.height = u.height;
    const L = I.getContext("2d");
    L.fillStyle = `var(--metal-${be}-color)`, L.beginPath();
    const z = y && ((W = Zo[y]) != null && W.props.d) ? Zo[y].props.d : "", U = new Path2D(z), J = u.width / 2 - n / 2, F = u.height / 2 - d / 2;
    L.translate(J, F), L.fill(U);
    const oe = new Vl.Potrace(), ee = new Vl.Potrace(), ie = new Vl.Potrace();
    ie.loadImage(I.toDataURL(), () => {
      const Q = ie.getPathTag().replace("<path", '<path class="marker-path"');
      ee.loadImage(b.toDataURL(), () => {
        const de = ee.getPathTag().replace("<path", '<path class="park-area"');
        oe.loadImage(o.toDataURL(), () => {
          const we = oe.getPathTag(), ke = `<svg width="${u.width}" height="${u.height}" viewBox="0 0 ${u.width} ${u.height}" xmlns="http://www.w3.org/2000/svg">
                        ${we}${de}${Q}
                    </svg>`;
          k(ke), Z("svg"), M(_);
        });
      });
    });
  };
  return /* @__PURE__ */ pt.jsx("div", { className: "design-confirmation", children: /* @__PURE__ */ pt.jsx(
    "div",
    {
      className: `confirm-button ${E && !ae ? "so-btn-danger" : ""}`,
      onClick: c,
      children: "Capture Map"
    }
  ) });
}, F0 = ({
  previewContent: Re,
  previewType: be,
  width: ae,
  height: k,
  currentVariant: Z,
  setUploads: _,
  showErrors: M,
  setUserInteracted: x
}) => {
  const [y, E] = Kt.useState("transparent"), [c, u] = Kt.useState(null), l = {
    image: {
      type: "image/jpeg",
      extension: "jpg",
      accept: ".jpg,.jpeg,.png,.tiff,.bmp,.webp,.bpg",
      getBlob: (a) => fetch(a).then((n) => n.blob())
    },
    svg: {
      type: "image/svg+xml",
      extension: "svg",
      accept: ".svg",
      getBlob: (a) => {
        const n = a.startsWith("<?xml") ? a : `<?xml version="1.0" encoding="UTF-8"?>${a}`;
        return new Blob([n], { type: "image/svg+xml" });
      }
    }
  };
  return ga.useEffect(() => {
    Re && (async () => {
      const n = document.querySelector(".preview-block");
      let d;
      if (be === "image") {
        const m = await htmlToImage.toPng(n, {
          quality: 1,
          pixelRatio: 2,
          skipAutoScale: !0
        });
        d = await fetch(m).then((s) => s.blob());
      } else {
        const s = n.querySelector("svg").outerHTML;
        d = s.startsWith("<?xml") ? s : `<?xml version="1.0" encoding="UTF-8"?>${s}`;
      }
      const g = l[be], h = new File([d], `map-snapshot.${g.extension}`, { type: g.type });
      _((m) => ({
        ...m,
        file: h,
        Upload: null
      })), x(!1), u(h);
    })();
  }, [Re, be]), /* @__PURE__ */ pt.jsxs("div", { className: "preview-wrapper", children: [
    /* @__PURE__ */ pt.jsx("div", { className: "preview-grid", children: /* @__PURE__ */ pt.jsx(
      "div",
      {
        className: `preview-block bg-${y}`,
        style: {
          width: ae + "px",
          height: k + "px"
        },
        children: be === "image" ? /* @__PURE__ */ pt.jsx("img", { src: Re, alt: "Map preview" }) : /* @__PURE__ */ pt.jsx("div", { dangerouslySetInnerHTML: { __html: Re } })
      }
    ) }),
    c && /* @__PURE__ */ pt.jsx(
      ud,
      {
        currentVariant: Z,
        registeredFile: c,
        setUploads: _,
        showErrors: M,
        setUserInteracted: x
      },
      c ? c.lastModified : "no-file"
    )
  ] });
}, U0 = ({ currentVariant: Re, productInfo: be, setUploads: ae, showErrors: k, setUserInteracted: Z }) => {
  var T, I, L, z;
  const [_, M] = Kt.useState("none"), x = ga.useRef(null), y = ga.useRef(null), c = nf().filter((U) => {
    var J;
    return U.field_type === "custom" && ((J = U.slug) == null ? void 0 : J.includes("capture-"));
  }), u = ((T = be.variant_metafields[Re.id]) == null ? void 0 : T.metal) || "", [l, a] = Kt.useState(u), [n, d] = Kt.useState(null), [g, h] = Kt.useState(null), [m, s] = Kt.useState(null), b = (I = be.variant_metafields[Re.id]) == null ? void 0 : I.shape;
  Kt.useEffect(() => {
    var J;
    const U = ((J = be.variant_metafields[Re.id]) == null ? void 0 : J.metal) || "";
    a(U);
  }, [Re, be]);
  const S = ga.useRef(null), [o, A] = ga.useState({ x: 0, y: 0 });
  return ga.useEffect(() => {
    var F, oe;
    const U = ((F = S.current) == null ? void 0 : F.offsetWidth) / 2 - Vn[b].width / 2, J = ((oe = S.current) == null ? void 0 : oe.offsetHeight) / 2 - Vn[b].height / 2;
    A({ x: U, y: J });
  }, []), ga.useEffect(() => ((async () => {
    const J = document.createElement("link");
    J.href = "https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css", J.rel = "stylesheet", document.head.appendChild(J);
    const F = document.createElement("link");
    F.href = "https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.css", F.rel = "stylesheet", document.head.appendChild(F);
    const oe = document.createElement("script");
    oe.src = "https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js", document.head.appendChild(oe), await new Promise((W) => oe.onload = W);
    const ee = document.createElement("script");
    ee.src = "https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.min.js", document.head.appendChild(ee), await new Promise((W) => ee.onload = W), window.mapboxgl.accessToken = be.additions.mapbox.access_token, y.current = new window.mapboxgl.Map({
      container: x.current,
      preserveDrawingBuffer: !0,
      style: {
        version: 8,
        sources: {
          "mapbox-streets": {
            type: "vector",
            url: "mapbox://mapbox.mapbox-streets-v8"
          }
        },
        layers: [
          {
            id: "buildings",
            type: "fill-extrusion",
            source: "mapbox-streets",
            "source-layer": "building",
            paint: {
              "fill-extrusion-color": "#aaa",
              "fill-extrusion-height": ["get", "height"],
              "fill-extrusion-base": ["get", "min_height"],
              "fill-extrusion-opacity": 0.6
            }
          },
          {
            id: "background",
            type: "background",
            paint: {
              "background-color": "#ffffff"
            }
          },
          {
            id: "water",
            type: "fill",
            source: "mapbox-streets",
            "source-layer": "water",
            paint: {
              "fill-color": "#82b8ff"
            }
          },
          {
            id: "parks",
            type: "fill",
            source: "mapbox-streets",
            "source-layer": "landuse",
            filter: ["==", "class", "park"],
            paint: {
              "fill-color": "#91d891"
            }
          },
          {
            id: "road-network",
            type: "line",
            source: "mapbox-streets",
            "source-layer": "road",
            filter: [
              "in",
              "class",
              "motorway",
              "trunk",
              "primary",
              "secondary",
              "tertiary",
              "street",
              "street_limited",
              "residential"
            ],
            paint: {
              "line-color": "#222222",
              "line-width": [
                "match",
                ["get", "class"],
                "motorway",
                2,
                "trunk",
                1.5,
                "primary",
                1,
                "secondary",
                0.8,
                "tertiary",
                0.6,
                "street",
                0.5,
                "street_limited",
                0.4,
                "residential",
                0.3,
                0.3
              ]
            }
          }
        ]
      },
      center: [-74.006, 40.7128],
      zoom: 12
    });
    const ie = new window.MapboxGeocoder({
      accessToken: window.mapboxgl.accessToken,
      mapboxgl: window.mapboxgl,
      marker: !1,
      placeholder: "Enter address to search"
    });
    y.current.addControl(ie, "top-left");
  })(), () => {
    y.current && y.current.remove();
    const J = document.querySelectorAll('link[href*="mapbox"]'), F = document.querySelectorAll('script[src*="mapbox"]');
    J.forEach((oe) => oe.remove()), F.forEach((oe) => oe.remove());
  }), []), /* @__PURE__ */ pt.jsx(pt.Fragment, { children: /* @__PURE__ */ pt.jsxs("div", { className: "so-tw", children: [
    /* @__PURE__ */ pt.jsxs("div", { className: "map-container", children: [
      /* @__PURE__ */ pt.jsx("div", { ref: x, className: "map" }),
      /* @__PURE__ */ pt.jsx("div", { className: "map-overlay", ref: S, children: /* @__PURE__ */ pt.jsxs("svg", { width: "100%", height: "100%", children: [
        /* @__PURE__ */ pt.jsx("defs", { children: /* @__PURE__ */ pt.jsxs("mask", { id: "shape-mask", children: [
          /* @__PURE__ */ pt.jsx("rect", { width: "100%", height: "100%", fill: Vn[b].fillColor }),
          /* @__PURE__ */ pt.jsx("g", { transform: `translate(${o.x}, ${o.y})`, children: /* @__PURE__ */ pt.jsx("path", { d: Vn[b].svg_d, fill: "black" }) })
        ] }) }),
        /* @__PURE__ */ pt.jsx(
          "rect",
          {
            width: "100%",
            height: "100%",
            fill: Vn[b].fillColor,
            mask: "url(#shape-mask)"
          }
        ),
        /* @__PURE__ */ pt.jsx(
          "g",
          {
            className: `metal-${l}-border`,
            transform: `translate(${o.x}, ${o.y})`,
            children: /* @__PURE__ */ pt.jsx(
              "path",
              {
                d: Vn[b].svg_border,
                strokeWidth: Vn[b].svg_border_width
              }
            )
          }
        )
      ] }) }),
      /* @__PURE__ */ pt.jsx(Tc, { renderInMap: !0, selectedType: _, metalType: l })
    ] }),
    /* @__PURE__ */ pt.jsxs("div", { className: "flex items-end justify-between", children: [
      /* @__PURE__ */ pt.jsx(
        Tc,
        {
          renderInMap: !1,
          selectedType: _,
          onMarkerChange: M,
          metalType: l
        }
      ),
      c.map((U) => /* @__PURE__ */ pt.jsx(
        z0,
        {
          map: y,
          metalType: l,
          currentVariant: Re,
          previewContent: n,
          setPreviewContent: d,
          setPreviewType: s,
          setCustomFields: h,
          selectedMarker: _,
          cf: U,
          shape: b,
          showErrors: k,
          setUserInteracted: Z
        },
        U.id
      ))
    ] }),
    n && /* @__PURE__ */ pt.jsx(
      F0,
      {
        previewContent: n,
        previewType: m,
        width: ((L = S.current) == null ? void 0 : L.offsetWidth) + "px",
        height: ((z = S.current) == null ? void 0 : z.offsetHeight) + "px",
        currentVariant: Re,
        customFields: g,
        setUploads: ae,
        showErrors: k,
        setUserInteracted: Z
      }
    )
  ] }) });
}, j0 = () => {
  var o;
  const Re = rf(), be = nf(), ae = Re.shop_info.sectionID ? "product-form-" + Re.shop_info.sectionID : _p(), [k, Z] = Kt.useState(yp()), [_, M] = Kt.useState({}), [x, y] = Kt.useState({}), [E, c] = Kt.useState({}), [u, l] = Kt.useState(!1);
  Kt.useEffect(() => {
    const A = (L) => {
      Z(
        Re.product.variants.filter(
          (z) => z.id === parseInt(document.querySelector('[name="id"]').value)
        )[0]
      ), l(!1);
    }, T = Re.trigger_selector ? Re.trigger_selector : Re.variant_id_input, I = document.querySelectorAll(T);
    return I.forEach((L) => L.addEventListener("change", A)), () => {
      I.forEach((L) => L.removeEventListener("change", A));
    };
  }, []);
  const a = be.filter(
    (A) => {
      var T;
      return A.field_type === "engraving" && ((T = Re.variant_metafields[k.id]) == null ? void 0 : T.engravable);
    }
  ), n = be.filter((A) => {
    var T;
    return A.field_type === "custom" && ((T = A.slug) == null ? void 0 : T.includes("capture-"));
  }), d = (n == null ? void 0 : n.length) > 0 ? !1 : (o = Re.variant_metafields[k.id]) == null ? void 0 : o.uploadable, g = {
    inputs: a.slice(0, Re.variant_metafields[k.id].engravings || a.length).reduce((A, T) => {
      var I;
      return (I = E[T.id.key]) != null && I.length || A.push(T.id.key), A;
    }, []),
    upload: d || (n == null ? void 0 : n.length) > 0 ? ["file"].filter((A) => !_[A]).concat(_.file ? ["Upload"].filter((A) => !_[A]) : []) : []
  }, h = Kt.useMemo(() => g.inputs.length > 0, [g.inputs]), m = Kt.useMemo(() => g.upload.length > 0, [g.upload]), s = h || m, b = h && u, S = m && u;
  return /* @__PURE__ */ pt.jsxs("div", { className: "so-hyper so-tw", "data-version": "2.0.14", children: [
    a.length > 0 && /* @__PURE__ */ pt.jsx(
      xp,
      {
        currentVariant: k,
        productInfo: Re,
        productCustomFields: be,
        formId: ae,
        inputFields: a,
        inputs: E,
        setInputs: c,
        validationErrors: g,
        showErrors: b
      }
    ),
    (n == null ? void 0 : n.length) > 0 ? /* @__PURE__ */ pt.jsx(
      U0,
      {
        currentVariant: k,
        productInfo: Re,
        productCustomFields: be,
        formId: ae,
        uploads: _,
        setUploads: M,
        validationErrors: g,
        showErrors: S,
        setUserInteracted: l
      }
    ) : d == 1 && /* @__PURE__ */ pt.jsx(
      S0,
      {
        currentVariant: k,
        productInfo: Re,
        productCustomFields: be,
        formId: ae,
        uploads: _,
        setUploads: M,
        validationErrors: g,
        showErrors: S,
        setUserInteracted: l
      }
    ),
    /* @__PURE__ */ pt.jsx(
      mp,
      {
        uploads: _,
        validationErrors: g,
        hasErrors: s,
        setUserInteracted: l
      }
    )
  ] });
};
document.addEventListener("DOMContentLoaded", () => {
  const Re = document.getElementById("so-hyper");
  Re && dp.createRoot(Re).render(
    /* @__PURE__ */ pt.jsx(Kt.StrictMode, { children: /* @__PURE__ */ pt.jsx(j0, {}) })
  );
});
