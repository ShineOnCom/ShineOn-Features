var Qn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Hp(Qe) {
  return Qe && Qe.__esModule && Object.prototype.hasOwnProperty.call(Qe, "default") ? Qe.default : Qe;
}
var s_ = { exports: {} }, Yd = {}, l_ = { exports: {} }, _n = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Gy;
function sb() {
  if (Gy) return _n;
  Gy = 1;
  var Qe = Symbol.for("react.element"), Mt = Symbol.for("react.portal"), pt = Symbol.for("react.fragment"), te = Symbol.for("react.strict_mode"), Ee = Symbol.for("react.profiler"), $ = Symbol.for("react.provider"), Q = Symbol.for("react.context"), r = Symbol.for("react.forward_ref"), F = Symbol.for("react.suspense"), H = Symbol.for("react.memo"), P = Symbol.for("react.lazy"), M = Symbol.iterator;
  function E(ze) {
    return ze === null || typeof ze != "object" ? null : (ze = M && ze[M] || ze["@@iterator"], typeof ze == "function" ? ze : null);
  }
  var x = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, m = Object.assign, I = {};
  function z(ze, Ze, Ue) {
    this.props = ze, this.context = Ze, this.refs = I, this.updater = Ue || x;
  }
  z.prototype.isReactComponent = {}, z.prototype.setState = function(ze, Ze) {
    if (typeof ze != "object" && typeof ze != "function" && ze != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, ze, Ze, "setState");
  }, z.prototype.forceUpdate = function(ze) {
    this.updater.enqueueForceUpdate(this, ze, "forceUpdate");
  };
  function w() {
  }
  w.prototype = z.prototype;
  function C(ze, Ze, Ue) {
    this.props = ze, this.context = Ze, this.refs = I, this.updater = Ue || x;
  }
  var b = C.prototype = new w();
  b.constructor = C, m(b, z.prototype), b.isPureReactComponent = !0;
  var B = Array.isArray, N = Object.prototype.hasOwnProperty, U = { current: null }, V = { key: !0, ref: !0, __self: !0, __source: !0 };
  function W(ze, Ze, Ue) {
    var Ie, je = {}, Fe = null, $e = null;
    if (Ze != null) for (Ie in Ze.ref !== void 0 && ($e = Ze.ref), Ze.key !== void 0 && (Fe = "" + Ze.key), Ze) N.call(Ze, Ie) && !V.hasOwnProperty(Ie) && (je[Ie] = Ze[Ie]);
    var ct = arguments.length - 2;
    if (ct === 1) je.children = Ue;
    else if (1 < ct) {
      for (var wt = Array(ct), Oe = 0; Oe < ct; Oe++) wt[Oe] = arguments[Oe + 2];
      je.children = wt;
    }
    if (ze && ze.defaultProps) for (Ie in ct = ze.defaultProps, ct) je[Ie] === void 0 && (je[Ie] = ct[Ie]);
    return { $$typeof: Qe, type: ze, key: Fe, ref: $e, props: je, _owner: U.current };
  }
  function q(ze, Ze) {
    return { $$typeof: Qe, type: ze.type, key: Ze, ref: ze.ref, props: ze.props, _owner: ze._owner };
  }
  function Y(ze) {
    return typeof ze == "object" && ze !== null && ze.$$typeof === Qe;
  }
  function re(ze) {
    var Ze = { "=": "=0", ":": "=2" };
    return "$" + ze.replace(/[=:]/g, function(Ue) {
      return Ze[Ue];
    });
  }
  var se = /\/+/g;
  function ve(ze, Ze) {
    return typeof ze == "object" && ze !== null && ze.key != null ? re("" + ze.key) : Ze.toString(36);
  }
  function ce(ze, Ze, Ue, Ie, je) {
    var Fe = typeof ze;
    (Fe === "undefined" || Fe === "boolean") && (ze = null);
    var $e = !1;
    if (ze === null) $e = !0;
    else switch (Fe) {
      case "string":
      case "number":
        $e = !0;
        break;
      case "object":
        switch (ze.$$typeof) {
          case Qe:
          case Mt:
            $e = !0;
        }
    }
    if ($e) return $e = ze, je = je($e), ze = Ie === "" ? "." + ve($e, 0) : Ie, B(je) ? (Ue = "", ze != null && (Ue = ze.replace(se, "$&/") + "/"), ce(je, Ze, Ue, "", function(Oe) {
      return Oe;
    })) : je != null && (Y(je) && (je = q(je, Ue + (!je.key || $e && $e.key === je.key ? "" : ("" + je.key).replace(se, "$&/") + "/") + ze)), Ze.push(je)), 1;
    if ($e = 0, Ie = Ie === "" ? "." : Ie + ":", B(ze)) for (var ct = 0; ct < ze.length; ct++) {
      Fe = ze[ct];
      var wt = Ie + ve(Fe, ct);
      $e += ce(Fe, Ze, Ue, wt, je);
    }
    else if (wt = E(ze), typeof wt == "function") for (ze = wt.call(ze), ct = 0; !(Fe = ze.next()).done; ) Fe = Fe.value, wt = Ie + ve(Fe, ct++), $e += ce(Fe, Ze, Ue, wt, je);
    else if (Fe === "object") throw Ze = String(ze), Error("Objects are not valid as a React child (found: " + (Ze === "[object Object]" ? "object with keys {" + Object.keys(ze).join(", ") + "}" : Ze) + "). If you meant to render a collection of children, use an array instead.");
    return $e;
  }
  function be(ze, Ze, Ue) {
    if (ze == null) return ze;
    var Ie = [], je = 0;
    return ce(ze, Ie, "", "", function(Fe) {
      return Ze.call(Ue, Fe, je++);
    }), Ie;
  }
  function Me(ze) {
    if (ze._status === -1) {
      var Ze = ze._result;
      Ze = Ze(), Ze.then(function(Ue) {
        (ze._status === 0 || ze._status === -1) && (ze._status = 1, ze._result = Ue);
      }, function(Ue) {
        (ze._status === 0 || ze._status === -1) && (ze._status = 2, ze._result = Ue);
      }), ze._status === -1 && (ze._status = 0, ze._result = Ze);
    }
    if (ze._status === 1) return ze._result.default;
    throw ze._result;
  }
  var xe = { current: null }, le = { transition: null }, de = { ReactCurrentDispatcher: xe, ReactCurrentBatchConfig: le, ReactCurrentOwner: U };
  function De() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return _n.Children = { map: be, forEach: function(ze, Ze, Ue) {
    be(ze, function() {
      Ze.apply(this, arguments);
    }, Ue);
  }, count: function(ze) {
    var Ze = 0;
    return be(ze, function() {
      Ze++;
    }), Ze;
  }, toArray: function(ze) {
    return be(ze, function(Ze) {
      return Ze;
    }) || [];
  }, only: function(ze) {
    if (!Y(ze)) throw Error("React.Children.only expected to receive a single React element child.");
    return ze;
  } }, _n.Component = z, _n.Fragment = pt, _n.Profiler = Ee, _n.PureComponent = C, _n.StrictMode = te, _n.Suspense = F, _n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = de, _n.act = De, _n.cloneElement = function(ze, Ze, Ue) {
    if (ze == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + ze + ".");
    var Ie = m({}, ze.props), je = ze.key, Fe = ze.ref, $e = ze._owner;
    if (Ze != null) {
      if (Ze.ref !== void 0 && (Fe = Ze.ref, $e = U.current), Ze.key !== void 0 && (je = "" + Ze.key), ze.type && ze.type.defaultProps) var ct = ze.type.defaultProps;
      for (wt in Ze) N.call(Ze, wt) && !V.hasOwnProperty(wt) && (Ie[wt] = Ze[wt] === void 0 && ct !== void 0 ? ct[wt] : Ze[wt]);
    }
    var wt = arguments.length - 2;
    if (wt === 1) Ie.children = Ue;
    else if (1 < wt) {
      ct = Array(wt);
      for (var Oe = 0; Oe < wt; Oe++) ct[Oe] = arguments[Oe + 2];
      Ie.children = ct;
    }
    return { $$typeof: Qe, type: ze.type, key: je, ref: Fe, props: Ie, _owner: $e };
  }, _n.createContext = function(ze) {
    return ze = { $$typeof: Q, _currentValue: ze, _currentValue2: ze, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, ze.Provider = { $$typeof: $, _context: ze }, ze.Consumer = ze;
  }, _n.createElement = W, _n.createFactory = function(ze) {
    var Ze = W.bind(null, ze);
    return Ze.type = ze, Ze;
  }, _n.createRef = function() {
    return { current: null };
  }, _n.forwardRef = function(ze) {
    return { $$typeof: r, render: ze };
  }, _n.isValidElement = Y, _n.lazy = function(ze) {
    return { $$typeof: P, _payload: { _status: -1, _result: ze }, _init: Me };
  }, _n.memo = function(ze, Ze) {
    return { $$typeof: H, type: ze, compare: Ze === void 0 ? null : Ze };
  }, _n.startTransition = function(ze) {
    var Ze = le.transition;
    le.transition = {};
    try {
      ze();
    } finally {
      le.transition = Ze;
    }
  }, _n.unstable_act = De, _n.useCallback = function(ze, Ze) {
    return xe.current.useCallback(ze, Ze);
  }, _n.useContext = function(ze) {
    return xe.current.useContext(ze);
  }, _n.useDebugValue = function() {
  }, _n.useDeferredValue = function(ze) {
    return xe.current.useDeferredValue(ze);
  }, _n.useEffect = function(ze, Ze) {
    return xe.current.useEffect(ze, Ze);
  }, _n.useId = function() {
    return xe.current.useId();
  }, _n.useImperativeHandle = function(ze, Ze, Ue) {
    return xe.current.useImperativeHandle(ze, Ze, Ue);
  }, _n.useInsertionEffect = function(ze, Ze) {
    return xe.current.useInsertionEffect(ze, Ze);
  }, _n.useLayoutEffect = function(ze, Ze) {
    return xe.current.useLayoutEffect(ze, Ze);
  }, _n.useMemo = function(ze, Ze) {
    return xe.current.useMemo(ze, Ze);
  }, _n.useReducer = function(ze, Ze, Ue) {
    return xe.current.useReducer(ze, Ze, Ue);
  }, _n.useRef = function(ze) {
    return xe.current.useRef(ze);
  }, _n.useState = function(ze) {
    return xe.current.useState(ze);
  }, _n.useSyncExternalStore = function(ze, Ze, Ue) {
    return xe.current.useSyncExternalStore(ze, Ze, Ue);
  }, _n.useTransition = function() {
    return xe.current.useTransition();
  }, _n.version = "18.3.1", _n;
}
var Hy;
function D_() {
  return Hy || (Hy = 1, l_.exports = sb()), l_.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Wy;
function lb() {
  if (Wy) return Yd;
  Wy = 1;
  var Qe = D_(), Mt = Symbol.for("react.element"), pt = Symbol.for("react.fragment"), te = Object.prototype.hasOwnProperty, Ee = Qe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, $ = { key: !0, ref: !0, __self: !0, __source: !0 };
  function Q(r, F, H) {
    var P, M = {}, E = null, x = null;
    H !== void 0 && (E = "" + H), F.key !== void 0 && (E = "" + F.key), F.ref !== void 0 && (x = F.ref);
    for (P in F) te.call(F, P) && !$.hasOwnProperty(P) && (M[P] = F[P]);
    if (r && r.defaultProps) for (P in F = r.defaultProps, F) M[P] === void 0 && (M[P] = F[P]);
    return { $$typeof: Mt, type: r, key: E, ref: x, props: M, _owner: Ee.current };
  }
  return Yd.Fragment = pt, Yd.jsx = Q, Yd.jsxs = Q, Yd;
}
var Zy;
function ub() {
  return Zy || (Zy = 1, s_.exports = lb()), s_.exports;
}
var gi = ub(), Un = D_();
const Up = /* @__PURE__ */ Hp(Un);
var Fp = {}, u_ = { exports: {} }, cs = {}, c_ = { exports: {} }, h_ = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qy;
function cb() {
  return qy || (qy = 1, function(Qe) {
    function Mt(le, de) {
      var De = le.length;
      le.push(de);
      e: for (; 0 < De; ) {
        var ze = De - 1 >>> 1, Ze = le[ze];
        if (0 < Ee(Ze, de)) le[ze] = de, le[De] = Ze, De = ze;
        else break e;
      }
    }
    function pt(le) {
      return le.length === 0 ? null : le[0];
    }
    function te(le) {
      if (le.length === 0) return null;
      var de = le[0], De = le.pop();
      if (De !== de) {
        le[0] = De;
        e: for (var ze = 0, Ze = le.length, Ue = Ze >>> 1; ze < Ue; ) {
          var Ie = 2 * (ze + 1) - 1, je = le[Ie], Fe = Ie + 1, $e = le[Fe];
          if (0 > Ee(je, De)) Fe < Ze && 0 > Ee($e, je) ? (le[ze] = $e, le[Fe] = De, ze = Fe) : (le[ze] = je, le[Ie] = De, ze = Ie);
          else if (Fe < Ze && 0 > Ee($e, De)) le[ze] = $e, le[Fe] = De, ze = Fe;
          else break e;
        }
      }
      return de;
    }
    function Ee(le, de) {
      var De = le.sortIndex - de.sortIndex;
      return De !== 0 ? De : le.id - de.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var $ = performance;
      Qe.unstable_now = function() {
        return $.now();
      };
    } else {
      var Q = Date, r = Q.now();
      Qe.unstable_now = function() {
        return Q.now() - r;
      };
    }
    var F = [], H = [], P = 1, M = null, E = 3, x = !1, m = !1, I = !1, z = typeof setTimeout == "function" ? setTimeout : null, w = typeof clearTimeout == "function" ? clearTimeout : null, C = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function b(le) {
      for (var de = pt(H); de !== null; ) {
        if (de.callback === null) te(H);
        else if (de.startTime <= le) te(H), de.sortIndex = de.expirationTime, Mt(F, de);
        else break;
        de = pt(H);
      }
    }
    function B(le) {
      if (I = !1, b(le), !m) if (pt(F) !== null) m = !0, Me(N);
      else {
        var de = pt(H);
        de !== null && xe(B, de.startTime - le);
      }
    }
    function N(le, de) {
      m = !1, I && (I = !1, w(W), W = -1), x = !0;
      var De = E;
      try {
        for (b(de), M = pt(F); M !== null && (!(M.expirationTime > de) || le && !re()); ) {
          var ze = M.callback;
          if (typeof ze == "function") {
            M.callback = null, E = M.priorityLevel;
            var Ze = ze(M.expirationTime <= de);
            de = Qe.unstable_now(), typeof Ze == "function" ? M.callback = Ze : M === pt(F) && te(F), b(de);
          } else te(F);
          M = pt(F);
        }
        if (M !== null) var Ue = !0;
        else {
          var Ie = pt(H);
          Ie !== null && xe(B, Ie.startTime - de), Ue = !1;
        }
        return Ue;
      } finally {
        M = null, E = De, x = !1;
      }
    }
    var U = !1, V = null, W = -1, q = 5, Y = -1;
    function re() {
      return !(Qe.unstable_now() - Y < q);
    }
    function se() {
      if (V !== null) {
        var le = Qe.unstable_now();
        Y = le;
        var de = !0;
        try {
          de = V(!0, le);
        } finally {
          de ? ve() : (U = !1, V = null);
        }
      } else U = !1;
    }
    var ve;
    if (typeof C == "function") ve = function() {
      C(se);
    };
    else if (typeof MessageChannel < "u") {
      var ce = new MessageChannel(), be = ce.port2;
      ce.port1.onmessage = se, ve = function() {
        be.postMessage(null);
      };
    } else ve = function() {
      z(se, 0);
    };
    function Me(le) {
      V = le, U || (U = !0, ve());
    }
    function xe(le, de) {
      W = z(function() {
        le(Qe.unstable_now());
      }, de);
    }
    Qe.unstable_IdlePriority = 5, Qe.unstable_ImmediatePriority = 1, Qe.unstable_LowPriority = 4, Qe.unstable_NormalPriority = 3, Qe.unstable_Profiling = null, Qe.unstable_UserBlockingPriority = 2, Qe.unstable_cancelCallback = function(le) {
      le.callback = null;
    }, Qe.unstable_continueExecution = function() {
      m || x || (m = !0, Me(N));
    }, Qe.unstable_forceFrameRate = function(le) {
      0 > le || 125 < le ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : q = 0 < le ? Math.floor(1e3 / le) : 5;
    }, Qe.unstable_getCurrentPriorityLevel = function() {
      return E;
    }, Qe.unstable_getFirstCallbackNode = function() {
      return pt(F);
    }, Qe.unstable_next = function(le) {
      switch (E) {
        case 1:
        case 2:
        case 3:
          var de = 3;
          break;
        default:
          de = E;
      }
      var De = E;
      E = de;
      try {
        return le();
      } finally {
        E = De;
      }
    }, Qe.unstable_pauseExecution = function() {
    }, Qe.unstable_requestPaint = function() {
    }, Qe.unstable_runWithPriority = function(le, de) {
      switch (le) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          le = 3;
      }
      var De = E;
      E = le;
      try {
        return de();
      } finally {
        E = De;
      }
    }, Qe.unstable_scheduleCallback = function(le, de, De) {
      var ze = Qe.unstable_now();
      switch (typeof De == "object" && De !== null ? (De = De.delay, De = typeof De == "number" && 0 < De ? ze + De : ze) : De = ze, le) {
        case 1:
          var Ze = -1;
          break;
        case 2:
          Ze = 250;
          break;
        case 5:
          Ze = 1073741823;
          break;
        case 4:
          Ze = 1e4;
          break;
        default:
          Ze = 5e3;
      }
      return Ze = De + Ze, le = { id: P++, callback: de, priorityLevel: le, startTime: De, expirationTime: Ze, sortIndex: -1 }, De > ze ? (le.sortIndex = De, Mt(H, le), pt(F) === null && le === pt(H) && (I ? (w(W), W = -1) : I = !0, xe(B, De - ze))) : (le.sortIndex = Ze, Mt(F, le), m || x || (m = !0, Me(N))), le;
    }, Qe.unstable_shouldYield = re, Qe.unstable_wrapCallback = function(le) {
      var de = E;
      return function() {
        var De = E;
        E = de;
        try {
          return le.apply(this, arguments);
        } finally {
          E = De;
        }
      };
    };
  }(h_)), h_;
}
var $y;
function hb() {
  return $y || ($y = 1, c_.exports = cb()), c_.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xy;
function fb() {
  if (Xy) return cs;
  Xy = 1;
  var Qe = D_(), Mt = hb();
  function pt(f) {
    for (var p = "https://reactjs.org/docs/error-decoder.html?invariant=" + f, O = 1; O < arguments.length; O++) p += "&args[]=" + encodeURIComponent(arguments[O]);
    return "Minified React error #" + f + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var te = /* @__PURE__ */ new Set(), Ee = {};
  function $(f, p) {
    Q(f, p), Q(f + "Capture", p);
  }
  function Q(f, p) {
    for (Ee[f] = p, f = 0; f < p.length; f++) te.add(p[f]);
  }
  var r = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), F = Object.prototype.hasOwnProperty, H = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, P = {}, M = {};
  function E(f) {
    return F.call(M, f) ? !0 : F.call(P, f) ? !1 : H.test(f) ? M[f] = !0 : (P[f] = !0, !1);
  }
  function x(f, p, O, ee) {
    if (O !== null && O.type === 0) return !1;
    switch (typeof p) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return ee ? !1 : O !== null ? !O.acceptsBooleans : (f = f.toLowerCase().slice(0, 5), f !== "data-" && f !== "aria-");
      default:
        return !1;
    }
  }
  function m(f, p, O, ee) {
    if (p === null || typeof p > "u" || x(f, p, O, ee)) return !0;
    if (ee) return !1;
    if (O !== null) switch (O.type) {
      case 3:
        return !p;
      case 4:
        return p === !1;
      case 5:
        return isNaN(p);
      case 6:
        return isNaN(p) || 1 > p;
    }
    return !1;
  }
  function I(f, p, O, ee, ye, Le, ot) {
    this.acceptsBooleans = p === 2 || p === 3 || p === 4, this.attributeName = ee, this.attributeNamespace = ye, this.mustUseProperty = O, this.propertyName = f, this.type = p, this.sanitizeURL = Le, this.removeEmptyString = ot;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(f) {
    z[f] = new I(f, 0, !1, f, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(f) {
    var p = f[0];
    z[p] = new I(p, 1, !1, f[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(f) {
    z[f] = new I(f, 2, !1, f.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(f) {
    z[f] = new I(f, 2, !1, f, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(f) {
    z[f] = new I(f, 3, !1, f.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(f) {
    z[f] = new I(f, 3, !0, f, null, !1, !1);
  }), ["capture", "download"].forEach(function(f) {
    z[f] = new I(f, 4, !1, f, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(f) {
    z[f] = new I(f, 6, !1, f, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(f) {
    z[f] = new I(f, 5, !1, f.toLowerCase(), null, !1, !1);
  });
  var w = /[\-:]([a-z])/g;
  function C(f) {
    return f[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(f) {
    var p = f.replace(
      w,
      C
    );
    z[p] = new I(p, 1, !1, f, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(f) {
    var p = f.replace(w, C);
    z[p] = new I(p, 1, !1, f, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(f) {
    var p = f.replace(w, C);
    z[p] = new I(p, 1, !1, f, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(f) {
    z[f] = new I(f, 1, !1, f.toLowerCase(), null, !1, !1);
  }), z.xlinkHref = new I("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(f) {
    z[f] = new I(f, 1, !1, f.toLowerCase(), null, !0, !0);
  });
  function b(f, p, O, ee) {
    var ye = z.hasOwnProperty(p) ? z[p] : null;
    (ye !== null ? ye.type !== 0 : ee || !(2 < p.length) || p[0] !== "o" && p[0] !== "O" || p[1] !== "n" && p[1] !== "N") && (m(p, O, ye, ee) && (O = null), ee || ye === null ? E(p) && (O === null ? f.removeAttribute(p) : f.setAttribute(p, "" + O)) : ye.mustUseProperty ? f[ye.propertyName] = O === null ? ye.type === 3 ? !1 : "" : O : (p = ye.attributeName, ee = ye.attributeNamespace, O === null ? f.removeAttribute(p) : (ye = ye.type, O = ye === 3 || ye === 4 && O === !0 ? "" : "" + O, ee ? f.setAttributeNS(ee, p, O) : f.setAttribute(p, O))));
  }
  var B = Qe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, N = Symbol.for("react.element"), U = Symbol.for("react.portal"), V = Symbol.for("react.fragment"), W = Symbol.for("react.strict_mode"), q = Symbol.for("react.profiler"), Y = Symbol.for("react.provider"), re = Symbol.for("react.context"), se = Symbol.for("react.forward_ref"), ve = Symbol.for("react.suspense"), ce = Symbol.for("react.suspense_list"), be = Symbol.for("react.memo"), Me = Symbol.for("react.lazy"), xe = Symbol.for("react.offscreen"), le = Symbol.iterator;
  function de(f) {
    return f === null || typeof f != "object" ? null : (f = le && f[le] || f["@@iterator"], typeof f == "function" ? f : null);
  }
  var De = Object.assign, ze;
  function Ze(f) {
    if (ze === void 0) try {
      throw Error();
    } catch (O) {
      var p = O.stack.trim().match(/\n( *(at )?)/);
      ze = p && p[1] || "";
    }
    return `
` + ze + f;
  }
  var Ue = !1;
  function Ie(f, p) {
    if (!f || Ue) return "";
    Ue = !0;
    var O = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (p) if (p = function() {
        throw Error();
      }, Object.defineProperty(p.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(p, []);
        } catch (Er) {
          var ee = Er;
        }
        Reflect.construct(f, [], p);
      } else {
        try {
          p.call();
        } catch (Er) {
          ee = Er;
        }
        f.call(p.prototype);
      }
      else {
        try {
          throw Error();
        } catch (Er) {
          ee = Er;
        }
        f();
      }
    } catch (Er) {
      if (Er && ee && typeof Er.stack == "string") {
        for (var ye = Er.stack.split(`
`), Le = ee.stack.split(`
`), ot = ye.length - 1, Ht = Le.length - 1; 1 <= ot && 0 <= Ht && ye[ot] !== Le[Ht]; ) Ht--;
        for (; 1 <= ot && 0 <= Ht; ot--, Ht--) if (ye[ot] !== Le[Ht]) {
          if (ot !== 1 || Ht !== 1)
            do
              if (ot--, Ht--, 0 > Ht || ye[ot] !== Le[Ht]) {
                var nr = `
` + ye[ot].replace(" at new ", " at ");
                return f.displayName && nr.includes("<anonymous>") && (nr = nr.replace("<anonymous>", f.displayName)), nr;
              }
            while (1 <= ot && 0 <= Ht);
          break;
        }
      }
    } finally {
      Ue = !1, Error.prepareStackTrace = O;
    }
    return (f = f ? f.displayName || f.name : "") ? Ze(f) : "";
  }
  function je(f) {
    switch (f.tag) {
      case 5:
        return Ze(f.type);
      case 16:
        return Ze("Lazy");
      case 13:
        return Ze("Suspense");
      case 19:
        return Ze("SuspenseList");
      case 0:
      case 2:
      case 15:
        return f = Ie(f.type, !1), f;
      case 11:
        return f = Ie(f.type.render, !1), f;
      case 1:
        return f = Ie(f.type, !0), f;
      default:
        return "";
    }
  }
  function Fe(f) {
    if (f == null) return null;
    if (typeof f == "function") return f.displayName || f.name || null;
    if (typeof f == "string") return f;
    switch (f) {
      case V:
        return "Fragment";
      case U:
        return "Portal";
      case q:
        return "Profiler";
      case W:
        return "StrictMode";
      case ve:
        return "Suspense";
      case ce:
        return "SuspenseList";
    }
    if (typeof f == "object") switch (f.$$typeof) {
      case re:
        return (f.displayName || "Context") + ".Consumer";
      case Y:
        return (f._context.displayName || "Context") + ".Provider";
      case se:
        var p = f.render;
        return f = f.displayName, f || (f = p.displayName || p.name || "", f = f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef"), f;
      case be:
        return p = f.displayName || null, p !== null ? p : Fe(f.type) || "Memo";
      case Me:
        p = f._payload, f = f._init;
        try {
          return Fe(f(p));
        } catch {
        }
    }
    return null;
  }
  function $e(f) {
    var p = f.type;
    switch (f.tag) {
      case 24:
        return "Cache";
      case 9:
        return (p.displayName || "Context") + ".Consumer";
      case 10:
        return (p._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return f = p.render, f = f.displayName || f.name || "", p.displayName || (f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return p;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Fe(p);
      case 8:
        return p === W ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof p == "function") return p.displayName || p.name || null;
        if (typeof p == "string") return p;
    }
    return null;
  }
  function ct(f) {
    switch (typeof f) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return f;
      case "object":
        return f;
      default:
        return "";
    }
  }
  function wt(f) {
    var p = f.type;
    return (f = f.nodeName) && f.toLowerCase() === "input" && (p === "checkbox" || p === "radio");
  }
  function Oe(f) {
    var p = wt(f) ? "checked" : "value", O = Object.getOwnPropertyDescriptor(f.constructor.prototype, p), ee = "" + f[p];
    if (!f.hasOwnProperty(p) && typeof O < "u" && typeof O.get == "function" && typeof O.set == "function") {
      var ye = O.get, Le = O.set;
      return Object.defineProperty(f, p, { configurable: !0, get: function() {
        return ye.call(this);
      }, set: function(ot) {
        ee = "" + ot, Le.call(this, ot);
      } }), Object.defineProperty(f, p, { enumerable: O.enumerable }), { getValue: function() {
        return ee;
      }, setValue: function(ot) {
        ee = "" + ot;
      }, stopTracking: function() {
        f._valueTracker = null, delete f[p];
      } };
    }
  }
  function Ct(f) {
    f._valueTracker || (f._valueTracker = Oe(f));
  }
  function Xt(f) {
    if (!f) return !1;
    var p = f._valueTracker;
    if (!p) return !0;
    var O = p.getValue(), ee = "";
    return f && (ee = wt(f) ? f.checked ? "true" : "false" : f.value), f = ee, f !== O ? (p.setValue(f), !0) : !1;
  }
  function vt(f) {
    if (f = f || (typeof document < "u" ? document : void 0), typeof f > "u") return null;
    try {
      return f.activeElement || f.body;
    } catch {
      return f.body;
    }
  }
  function Ye(f, p) {
    var O = p.checked;
    return De({}, p, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: O ?? f._wrapperState.initialChecked });
  }
  function qe(f, p) {
    var O = p.defaultValue == null ? "" : p.defaultValue, ee = p.checked != null ? p.checked : p.defaultChecked;
    O = ct(p.value != null ? p.value : O), f._wrapperState = { initialChecked: ee, initialValue: O, controlled: p.type === "checkbox" || p.type === "radio" ? p.checked != null : p.value != null };
  }
  function rt(f, p) {
    p = p.checked, p != null && b(f, "checked", p, !1);
  }
  function it(f, p) {
    rt(f, p);
    var O = ct(p.value), ee = p.type;
    if (O != null) ee === "number" ? (O === 0 && f.value === "" || f.value != O) && (f.value = "" + O) : f.value !== "" + O && (f.value = "" + O);
    else if (ee === "submit" || ee === "reset") {
      f.removeAttribute("value");
      return;
    }
    p.hasOwnProperty("value") ? _e(f, p.type, O) : p.hasOwnProperty("defaultValue") && _e(f, p.type, ct(p.defaultValue)), p.checked == null && p.defaultChecked != null && (f.defaultChecked = !!p.defaultChecked);
  }
  function Ae(f, p, O) {
    if (p.hasOwnProperty("value") || p.hasOwnProperty("defaultValue")) {
      var ee = p.type;
      if (!(ee !== "submit" && ee !== "reset" || p.value !== void 0 && p.value !== null)) return;
      p = "" + f._wrapperState.initialValue, O || p === f.value || (f.value = p), f.defaultValue = p;
    }
    O = f.name, O !== "" && (f.name = ""), f.defaultChecked = !!f._wrapperState.initialChecked, O !== "" && (f.name = O);
  }
  function _e(f, p, O) {
    (p !== "number" || vt(f.ownerDocument) !== f) && (O == null ? f.defaultValue = "" + f._wrapperState.initialValue : f.defaultValue !== "" + O && (f.defaultValue = "" + O));
  }
  var fe = Array.isArray;
  function We(f, p, O, ee) {
    if (f = f.options, p) {
      p = {};
      for (var ye = 0; ye < O.length; ye++) p["$" + O[ye]] = !0;
      for (O = 0; O < f.length; O++) ye = p.hasOwnProperty("$" + f[O].value), f[O].selected !== ye && (f[O].selected = ye), ye && ee && (f[O].defaultSelected = !0);
    } else {
      for (O = "" + ct(O), p = null, ye = 0; ye < f.length; ye++) {
        if (f[ye].value === O) {
          f[ye].selected = !0, ee && (f[ye].defaultSelected = !0);
          return;
        }
        p !== null || f[ye].disabled || (p = f[ye]);
      }
      p !== null && (p.selected = !0);
    }
  }
  function Pe(f, p) {
    if (p.dangerouslySetInnerHTML != null) throw Error(pt(91));
    return De({}, p, { value: void 0, defaultValue: void 0, children: "" + f._wrapperState.initialValue });
  }
  function he(f, p) {
    var O = p.value;
    if (O == null) {
      if (O = p.children, p = p.defaultValue, O != null) {
        if (p != null) throw Error(pt(92));
        if (fe(O)) {
          if (1 < O.length) throw Error(pt(93));
          O = O[0];
        }
        p = O;
      }
      p == null && (p = ""), O = p;
    }
    f._wrapperState = { initialValue: ct(O) };
  }
  function ie(f, p) {
    var O = ct(p.value), ee = ct(p.defaultValue);
    O != null && (O = "" + O, O !== f.value && (f.value = O), p.defaultValue == null && f.defaultValue !== O && (f.defaultValue = O)), ee != null && (f.defaultValue = "" + ee);
  }
  function Xe(f) {
    var p = f.textContent;
    p === f._wrapperState.initialValue && p !== "" && p !== null && (f.value = p);
  }
  function bt(f) {
    switch (f) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Wt(f, p) {
    return f == null || f === "http://www.w3.org/1999/xhtml" ? bt(p) : f === "http://www.w3.org/2000/svg" && p === "foreignObject" ? "http://www.w3.org/1999/xhtml" : f;
  }
  var Qt, Sr = function(f) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(p, O, ee, ye) {
      MSApp.execUnsafeLocalFunction(function() {
        return f(p, O, ee, ye);
      });
    } : f;
  }(function(f, p) {
    if (f.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in f) f.innerHTML = p;
    else {
      for (Qt = Qt || document.createElement("div"), Qt.innerHTML = "<svg>" + p.valueOf().toString() + "</svg>", p = Qt.firstChild; f.firstChild; ) f.removeChild(f.firstChild);
      for (; p.firstChild; ) f.appendChild(p.firstChild);
    }
  });
  function Fr(f, p) {
    if (p) {
      var O = f.firstChild;
      if (O && O === f.lastChild && O.nodeType === 3) {
        O.nodeValue = p;
        return;
      }
    }
    f.textContent = p;
  }
  var kr = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Ur = ["Webkit", "ms", "Moz", "O"];
  Object.keys(kr).forEach(function(f) {
    Ur.forEach(function(p) {
      p = p + f.charAt(0).toUpperCase() + f.substring(1), kr[p] = kr[f];
    });
  });
  function Rr(f, p, O) {
    return p == null || typeof p == "boolean" || p === "" ? "" : O || typeof p != "number" || p === 0 || kr.hasOwnProperty(f) && kr[f] ? ("" + p).trim() : p + "px";
  }
  function Pr(f, p) {
    f = f.style;
    for (var O in p) if (p.hasOwnProperty(O)) {
      var ee = O.indexOf("--") === 0, ye = Rr(O, p[O], ee);
      O === "float" && (O = "cssFloat"), ee ? f.setProperty(O, ye) : f[O] = ye;
    }
  }
  var hi = De({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Vr(f, p) {
    if (p) {
      if (hi[f] && (p.children != null || p.dangerouslySetInnerHTML != null)) throw Error(pt(137, f));
      if (p.dangerouslySetInnerHTML != null) {
        if (p.children != null) throw Error(pt(60));
        if (typeof p.dangerouslySetInnerHTML != "object" || !("__html" in p.dangerouslySetInnerHTML)) throw Error(pt(61));
      }
      if (p.style != null && typeof p.style != "object") throw Error(pt(62));
    }
  }
  function Te(f, p) {
    if (f.indexOf("-") === -1) return typeof p.is == "string";
    switch (f) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Tt = null;
  function Gt(f) {
    return f = f.target || f.srcElement || window, f.correspondingUseElement && (f = f.correspondingUseElement), f.nodeType === 3 ? f.parentNode : f;
  }
  var pr = null, kt = null, tr = null;
  function Je(f) {
    if (f = Pl(f)) {
      if (typeof pr != "function") throw Error(pt(280));
      var p = f.stateNode;
      p && (p = xu(p), pr(f.stateNode, f.type, p));
    }
  }
  function wr(f) {
    kt ? tr ? tr.push(f) : tr = [f] : kt = f;
  }
  function ni() {
    if (kt) {
      var f = kt, p = tr;
      if (tr = kt = null, Je(f), p) for (f = 0; f < p.length; f++) Je(p[f]);
    }
  }
  function Z(f, p) {
    return f(p);
  }
  function Dt() {
  }
  var er = !1;
  function we(f, p, O) {
    if (er) return f(p, O);
    er = !0;
    try {
      return Z(f, p, O);
    } finally {
      er = !1, (kt !== null || tr !== null) && (Dt(), ni());
    }
  }
  function yt(f, p) {
    var O = f.stateNode;
    if (O === null) return null;
    var ee = xu(O);
    if (ee === null) return null;
    O = ee[p];
    e: switch (p) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (ee = !ee.disabled) || (f = f.type, ee = !(f === "button" || f === "input" || f === "select" || f === "textarea")), f = !ee;
        break e;
      default:
        f = !1;
    }
    if (f) return null;
    if (O && typeof O != "function") throw Error(pt(231, p, typeof O));
    return O;
  }
  var ar = !1;
  if (r) try {
    var Or = {};
    Object.defineProperty(Or, "passive", { get: function() {
      ar = !0;
    } }), window.addEventListener("test", Or, Or), window.removeEventListener("test", Or, Or);
  } catch {
    ar = !1;
  }
  function Dr(f, p, O, ee, ye, Le, ot, Ht, nr) {
    var Er = Array.prototype.slice.call(arguments, 3);
    try {
      p.apply(O, Er);
    } catch (Jr) {
      this.onError(Jr);
    }
  }
  var Kr = !1, di = null, $t = !1, Ce = null, Ne = { onError: function(f) {
    Kr = !0, di = f;
  } };
  function Ke(f, p, O, ee, ye, Le, ot, Ht, nr) {
    Kr = !1, di = null, Dr.apply(Ne, arguments);
  }
  function ht(f, p, O, ee, ye, Le, ot, Ht, nr) {
    if (Ke.apply(this, arguments), Kr) {
      if (Kr) {
        var Er = di;
        Kr = !1, di = null;
      } else throw Error(pt(198));
      $t || ($t = !0, Ce = Er);
    }
  }
  function ft(f) {
    var p = f, O = f;
    if (f.alternate) for (; p.return; ) p = p.return;
    else {
      f = p;
      do
        p = f, p.flags & 4098 && (O = p.return), f = p.return;
      while (f);
    }
    return p.tag === 3 ? O : null;
  }
  function Pt(f) {
    if (f.tag === 13) {
      var p = f.memoizedState;
      if (p === null && (f = f.alternate, f !== null && (p = f.memoizedState)), p !== null) return p.dehydrated;
    }
    return null;
  }
  function Nt(f) {
    if (ft(f) !== f) throw Error(pt(188));
  }
  function At(f) {
    var p = f.alternate;
    if (!p) {
      if (p = ft(f), p === null) throw Error(pt(188));
      return p !== f ? null : f;
    }
    for (var O = f, ee = p; ; ) {
      var ye = O.return;
      if (ye === null) break;
      var Le = ye.alternate;
      if (Le === null) {
        if (ee = ye.return, ee !== null) {
          O = ee;
          continue;
        }
        break;
      }
      if (ye.child === Le.child) {
        for (Le = ye.child; Le; ) {
          if (Le === O) return Nt(ye), f;
          if (Le === ee) return Nt(ye), p;
          Le = Le.sibling;
        }
        throw Error(pt(188));
      }
      if (O.return !== ee.return) O = ye, ee = Le;
      else {
        for (var ot = !1, Ht = ye.child; Ht; ) {
          if (Ht === O) {
            ot = !0, O = ye, ee = Le;
            break;
          }
          if (Ht === ee) {
            ot = !0, ee = ye, O = Le;
            break;
          }
          Ht = Ht.sibling;
        }
        if (!ot) {
          for (Ht = Le.child; Ht; ) {
            if (Ht === O) {
              ot = !0, O = Le, ee = ye;
              break;
            }
            if (Ht === ee) {
              ot = !0, ee = Le, O = ye;
              break;
            }
            Ht = Ht.sibling;
          }
          if (!ot) throw Error(pt(189));
        }
      }
      if (O.alternate !== ee) throw Error(pt(190));
    }
    if (O.tag !== 3) throw Error(pt(188));
    return O.stateNode.current === O ? f : p;
  }
  function Zt(f) {
    return f = At(f), f !== null ? jt(f) : null;
  }
  function jt(f) {
    if (f.tag === 5 || f.tag === 6) return f;
    for (f = f.child; f !== null; ) {
      var p = jt(f);
      if (p !== null) return p;
      f = f.sibling;
    }
    return null;
  }
  var Yt = Mt.unstable_scheduleCallback, fr = Mt.unstable_cancelCallback, Ir = Mt.unstable_shouldYield, Lr = Mt.unstable_requestPaint, qr = Mt.unstable_now, pi = Mt.unstable_getCurrentPriorityLevel, fi = Mt.unstable_ImmediatePriority, si = Mt.unstable_UserBlockingPriority, ki = Mt.unstable_NormalPriority, Ni = Mt.unstable_LowPriority, Li = Mt.unstable_IdlePriority, Wi = null, Bi = null;
  function Gn(f) {
    if (Bi && typeof Bi.onCommitFiberRoot == "function") try {
      Bi.onCommitFiberRoot(Wi, f, void 0, (f.current.flags & 128) === 128);
    } catch {
    }
  }
  var sa = Math.clz32 ? Math.clz32 : Pa, Yn = Math.log, ea = Math.LN2;
  function Pa(f) {
    return f >>>= 0, f === 0 ? 32 : 31 - (Yn(f) / ea | 0) | 0;
  }
  var Fs = 64, wo = 4194304;
  function fs(f) {
    switch (f & -f) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return f & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return f;
    }
  }
  function ou(f, p) {
    var O = f.pendingLanes;
    if (O === 0) return 0;
    var ee = 0, ye = f.suspendedLanes, Le = f.pingedLanes, ot = O & 268435455;
    if (ot !== 0) {
      var Ht = ot & ~ye;
      Ht !== 0 ? ee = fs(Ht) : (Le &= ot, Le !== 0 && (ee = fs(Le)));
    } else ot = O & ~ye, ot !== 0 ? ee = fs(ot) : Le !== 0 && (ee = fs(Le));
    if (ee === 0) return 0;
    if (p !== 0 && p !== ee && !(p & ye) && (ye = ee & -ee, Le = p & -p, ye >= Le || ye === 16 && (Le & 4194240) !== 0)) return p;
    if (ee & 4 && (ee |= O & 16), p = f.entangledLanes, p !== 0) for (f = f.entanglements, p &= ee; 0 < p; ) O = 31 - sa(p), ye = 1 << O, ee |= f[O], p &= ~ye;
    return ee;
  }
  function mf(f, p) {
    switch (f) {
      case 1:
      case 2:
      case 4:
        return p + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return p + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Th(f, p) {
    for (var O = f.suspendedLanes, ee = f.pingedLanes, ye = f.expirationTimes, Le = f.pendingLanes; 0 < Le; ) {
      var ot = 31 - sa(Le), Ht = 1 << ot, nr = ye[ot];
      nr === -1 ? (!(Ht & O) || Ht & ee) && (ye[ot] = mf(Ht, p)) : nr <= p && (f.expiredLanes |= Ht), Le &= ~Ht;
    }
  }
  function Vu(f) {
    return f = f.pendingLanes & -1073741825, f !== 0 ? f : f & 1073741824 ? 1073741824 : 0;
  }
  function Sa() {
    var f = Fs;
    return Fs <<= 1, !(Fs & 4194240) && (Fs = 64), f;
  }
  function lo(f) {
    for (var p = [], O = 0; 31 > O; O++) p.push(f);
    return p;
  }
  function uo(f, p, O) {
    f.pendingLanes |= p, p !== 536870912 && (f.suspendedLanes = 0, f.pingedLanes = 0), f = f.eventTimes, p = 31 - sa(p), f[p] = O;
  }
  function Wo(f, p) {
    var O = f.pendingLanes & ~p;
    f.pendingLanes = p, f.suspendedLanes = 0, f.pingedLanes = 0, f.expiredLanes &= p, f.mutableReadLanes &= p, f.entangledLanes &= p, p = f.entanglements;
    var ee = f.eventTimes;
    for (f = f.expirationTimes; 0 < O; ) {
      var ye = 31 - sa(O), Le = 1 << ye;
      p[ye] = 0, ee[ye] = -1, f[ye] = -1, O &= ~Le;
    }
  }
  function co(f, p) {
    var O = f.entangledLanes |= p;
    for (f = f.entanglements; O; ) {
      var ee = 31 - sa(O), ye = 1 << ee;
      ye & p | f[ee] & p && (f[ee] |= p), O &= ~ye;
    }
  }
  var on = 0;
  function Gu(f) {
    return f &= -f, 1 < f ? 4 < f ? f & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Cc, Zo, ds, Mh, Pc, Xa = !1, Xi = [], qo = null, li = null, ps = null, Ns = /* @__PURE__ */ new Map(), Us = /* @__PURE__ */ new Map(), Mi = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function js(f, p) {
    switch (f) {
      case "focusin":
      case "focusout":
        qo = null;
        break;
      case "dragenter":
      case "dragleave":
        li = null;
        break;
      case "mouseover":
      case "mouseout":
        ps = null;
        break;
      case "pointerover":
      case "pointerout":
        Ns.delete(p.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Us.delete(p.pointerId);
    }
  }
  function Xr(f, p, O, ee, ye, Le) {
    return f === null || f.nativeEvent !== Le ? (f = { blockedOn: p, domEventName: O, eventSystemFlags: ee, nativeEvent: Le, targetContainers: [ye] }, p !== null && (p = Pl(p), p !== null && Zo(p)), f) : (f.eventSystemFlags |= ee, p = f.targetContainers, ye !== null && p.indexOf(ye) === -1 && p.push(ye), f);
  }
  function nn(f, p, O, ee, ye) {
    switch (p) {
      case "focusin":
        return qo = Xr(qo, f, p, O, ee, ye), !0;
      case "dragenter":
        return li = Xr(li, f, p, O, ee, ye), !0;
      case "mouseover":
        return ps = Xr(ps, f, p, O, ee, ye), !0;
      case "pointerover":
        var Le = ye.pointerId;
        return Ns.set(Le, Xr(Ns.get(Le) || null, f, p, O, ee, ye)), !0;
      case "gotpointercapture":
        return Le = ye.pointerId, Us.set(Le, Xr(Us.get(Le) || null, f, p, O, ee, ye)), !0;
    }
    return !1;
  }
  function Zi(f) {
    var p = Js(f.target);
    if (p !== null) {
      var O = ft(p);
      if (O !== null) {
        if (p = O.tag, p === 13) {
          if (p = Pt(O), p !== null) {
            f.blockedOn = p, Pc(f.priority, function() {
              ds(O);
            });
            return;
          }
        } else if (p === 3 && O.stateNode.current.memoizedState.isDehydrated) {
          f.blockedOn = O.tag === 3 ? O.stateNode.containerInfo : null;
          return;
        }
      }
    }
    f.blockedOn = null;
  }
  function la(f) {
    if (f.blockedOn !== null) return !1;
    for (var p = f.targetContainers; 0 < p.length; ) {
      var O = yl(f.domEventName, f.eventSystemFlags, p[0], f.nativeEvent);
      if (O === null) {
        O = f.nativeEvent;
        var ee = new O.constructor(O.type, O);
        Tt = ee, O.target.dispatchEvent(ee), Tt = null;
      } else return p = Pl(O), p !== null && Zo(p), f.blockedOn = O, !1;
      p.shift();
    }
    return !0;
  }
  function $o(f, p, O) {
    la(f) && O.delete(p);
  }
  function Ji() {
    Xa = !1, qo !== null && la(qo) && (qo = null), li !== null && la(li) && (li = null), ps !== null && la(ps) && (ps = null), Ns.forEach($o), Us.forEach($o);
  }
  function ms(f, p) {
    f.blockedOn === p && (f.blockedOn = null, Xa || (Xa = !0, Mt.unstable_scheduleCallback(Mt.unstable_NormalPriority, Ji)));
  }
  function Ya(f) {
    function p(ye) {
      return ms(ye, f);
    }
    if (0 < Xi.length) {
      ms(Xi[0], f);
      for (var O = 1; O < Xi.length; O++) {
        var ee = Xi[O];
        ee.blockedOn === f && (ee.blockedOn = null);
      }
    }
    for (qo !== null && ms(qo, f), li !== null && ms(li, f), ps !== null && ms(ps, f), Ns.forEach(p), Us.forEach(p), O = 0; O < Mi.length; O++) ee = Mi[O], ee.blockedOn === f && (ee.blockedOn = null);
    for (; 0 < Mi.length && (O = Mi[0], O.blockedOn === null); ) Zi(O), O.blockedOn === null && Mi.shift();
  }
  var Xo = B.ReactCurrentBatchConfig, Kn = !0;
  function zn(f, p, O, ee) {
    var ye = on, Le = Xo.transition;
    Xo.transition = null;
    try {
      on = 1, Ta(f, p, O, ee);
    } finally {
      on = ye, Xo.transition = Le;
    }
  }
  function Ah(f, p, O, ee) {
    var ye = on, Le = Xo.transition;
    Xo.transition = null;
    try {
      on = 4, Ta(f, p, O, ee);
    } finally {
      on = ye, Xo.transition = Le;
    }
  }
  function Ta(f, p, O, ee) {
    if (Kn) {
      var ye = yl(f, p, O, ee);
      if (ye === null) Ml(f, p, ee, gl, O), js(f, ee);
      else if (nn(ye, f, p, O, ee)) ee.stopPropagation();
      else if (js(f, ee), p & 4 && -1 < Rc.indexOf(f)) {
        for (; ye !== null; ) {
          var Le = Pl(ye);
          if (Le !== null && Cc(Le), Le = yl(f, p, O, ee), Le === null && Ml(f, p, ee, gl, O), Le === ye) break;
          ye = Le;
        }
        ye !== null && ee.stopPropagation();
      } else Ml(f, p, ee, null, O);
    }
  }
  var gl = null;
  function yl(f, p, O, ee) {
    if (gl = null, f = Gt(ee), f = Js(f), f !== null) if (p = ft(f), p === null) f = null;
    else if (O = p.tag, O === 13) {
      if (f = Pt(p), f !== null) return f;
      f = null;
    } else if (O === 3) {
      if (p.stateNode.current.memoizedState.isDehydrated) return p.tag === 3 ? p.stateNode.containerInfo : null;
      f = null;
    } else p !== f && (f = null);
    return gl = f, null;
  }
  function Hu(f) {
    switch (f) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (pi()) {
          case fi:
            return 1;
          case si:
            return 4;
          case ki:
          case Ni:
            return 16;
          case Li:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Eo = null, pa = null, ho = null;
  function ma() {
    if (ho) return ho;
    var f, p = pa, O = p.length, ee, ye = "value" in Eo ? Eo.value : Eo.textContent, Le = ye.length;
    for (f = 0; f < O && p[f] === ye[f]; f++) ;
    var ot = O - f;
    for (ee = 1; ee <= ot && p[O - ee] === ye[Le - ee]; ee++) ;
    return ho = ye.slice(f, 1 < ee ? 1 - ee : void 0);
  }
  function su(f) {
    var p = f.keyCode;
    return "charCode" in f ? (f = f.charCode, f === 0 && p === 13 && (f = 13)) : f = p, f === 10 && (f = 13), 32 <= f || f === 13 ? f : 0;
  }
  function So() {
    return !0;
  }
  function An() {
    return !1;
  }
  function Hn(f) {
    function p(O, ee, ye, Le, ot) {
      this._reactName = O, this._targetInst = ye, this.type = ee, this.nativeEvent = Le, this.target = ot, this.currentTarget = null;
      for (var Ht in f) f.hasOwnProperty(Ht) && (O = f[Ht], this[Ht] = O ? O(Le) : Le[Ht]);
      return this.isDefaultPrevented = (Le.defaultPrevented != null ? Le.defaultPrevented : Le.returnValue === !1) ? So : An, this.isPropagationStopped = An, this;
    }
    return De(p.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var O = this.nativeEvent;
      O && (O.preventDefault ? O.preventDefault() : typeof O.returnValue != "unknown" && (O.returnValue = !1), this.isDefaultPrevented = So);
    }, stopPropagation: function() {
      var O = this.nativeEvent;
      O && (O.stopPropagation ? O.stopPropagation() : typeof O.cancelBubble != "unknown" && (O.cancelBubble = !0), this.isPropagationStopped = So);
    }, persist: function() {
    }, isPersistent: So }), p;
  }
  var Wn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(f) {
    return f.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, On = Hn(Wn), _s = De({}, Wn, { view: 0, detail: 0 }), zo = Hn(_s), gs, vl, Ba, lu = De({}, _s, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Oo, button: 0, buttons: 0, relatedTarget: function(f) {
    return f.relatedTarget === void 0 ? f.fromElement === f.srcElement ? f.toElement : f.fromElement : f.relatedTarget;
  }, movementX: function(f) {
    return "movementX" in f ? f.movementX : (f !== Ba && (Ba && f.type === "mousemove" ? (gs = f.screenX - Ba.screenX, vl = f.screenY - Ba.screenY) : vl = gs = 0, Ba = f), gs);
  }, movementY: function(f) {
    return "movementY" in f ? f.movementY : vl;
  } }), Yo = Hn(lu), ad = De({}, lu, { dataTransfer: 0 }), Ih = Hn(ad), Fa = De({}, _s, { relatedTarget: 0 }), Wu = Hn(Fa), Lc = De({}, Wn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Zu = Hn(Lc), qu = De({}, Wn, { clipboardData: function(f) {
    return "clipboardData" in f ? f.clipboardData : window.clipboardData;
  } }), od = Hn(qu), sd = De({}, Wn, { data: 0 }), uu = Hn(sd), $u = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, ld = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, cu = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Ch(f) {
    var p = this.nativeEvent;
    return p.getModifierState ? p.getModifierState(f) : (f = cu[f]) ? !!p[f] : !1;
  }
  function Oo() {
    return Ch;
  }
  var Vs = De({}, _s, { key: function(f) {
    if (f.key) {
      var p = $u[f.key] || f.key;
      if (p !== "Unidentified") return p;
    }
    return f.type === "keypress" ? (f = su(f), f === 13 ? "Enter" : String.fromCharCode(f)) : f.type === "keydown" || f.type === "keyup" ? ld[f.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Oo, charCode: function(f) {
    return f.type === "keypress" ? su(f) : 0;
  }, keyCode: function(f) {
    return f.type === "keydown" || f.type === "keyup" ? f.keyCode : 0;
  }, which: function(f) {
    return f.type === "keypress" ? su(f) : f.type === "keydown" || f.type === "keyup" ? f.keyCode : 0;
  } }), ud = Hn(Vs), Ph = De({}, lu, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), _f = Hn(Ph), gf = De({}, _s, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Oo }), cd = Hn(gf), Rh = De({}, Wn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), xl = Hn(Rh), zi = De({}, lu, {
    deltaX: function(f) {
      return "deltaX" in f ? f.deltaX : "wheelDeltaX" in f ? -f.wheelDeltaX : 0;
    },
    deltaY: function(f) {
      return "deltaY" in f ? f.deltaY : "wheelDeltaY" in f ? -f.wheelDeltaY : "wheelDelta" in f ? -f.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), ui = Hn(zi), Dc = [9, 13, 27, 32], _i = r && "CompositionEvent" in window, Ko = null;
  r && "documentMode" in document && (Ko = document.documentMode);
  var kc = r && "TextEvent" in window && !Ko, vi = r && (!_i || Ko && 8 < Ko && 11 >= Ko), bl = " ", Gs = !1;
  function zc(f, p) {
    switch (f) {
      case "keyup":
        return Dc.indexOf(p.keyCode) !== -1;
      case "keydown":
        return p.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Xu(f) {
    return f = f.detail, typeof f == "object" && "data" in f ? f.data : null;
  }
  var ua = !1;
  function xa(f, p) {
    switch (f) {
      case "compositionend":
        return Xu(p);
      case "keypress":
        return p.which !== 32 ? null : (Gs = !0, bl);
      case "textInput":
        return f = p.data, f === bl && Gs ? null : f;
      default:
        return null;
    }
  }
  function Br(f, p) {
    if (ua) return f === "compositionend" || !_i && zc(f, p) ? (f = ma(), ho = pa = Eo = null, ua = !1, f) : null;
    switch (f) {
      case "paste":
        return null;
      case "keypress":
        if (!(p.ctrlKey || p.altKey || p.metaKey) || p.ctrlKey && p.altKey) {
          if (p.char && 1 < p.char.length) return p.char;
          if (p.which) return String.fromCharCode(p.which);
        }
        return null;
      case "compositionend":
        return vi && p.locale !== "ko" ? null : p.data;
      default:
        return null;
    }
  }
  var Lh = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Yu(f) {
    var p = f && f.nodeName && f.nodeName.toLowerCase();
    return p === "input" ? !!Lh[f.type] : p === "textarea";
  }
  function hu(f, p, O, ee) {
    wr(ee), p = ac(p, "onChange"), 0 < p.length && (O = new On("onChange", "change", null, O, ee), f.push({ event: O, listeners: p }));
  }
  var To = null, qn = null;
  function ys(f) {
    jc(f, 0);
  }
  function fu(f) {
    var p = fo(f);
    if (Xt(p)) return f;
  }
  function wl(f, p) {
    if (f === "change") return p;
  }
  var Hs = !1;
  if (r) {
    var vs;
    if (r) {
      var Ku = "oninput" in document;
      if (!Ku) {
        var yf = document.createElement("div");
        yf.setAttribute("oninput", "return;"), Ku = typeof yf.oninput == "function";
      }
      vs = Ku;
    } else vs = !1;
    Hs = vs && (!document.documentMode || 9 < document.documentMode);
  }
  function Oc() {
    To && (To.detachEvent("onpropertychange", vf), qn = To = null);
  }
  function vf(f) {
    if (f.propertyName === "value" && fu(qn)) {
      var p = [];
      hu(p, qn, f, Gt(f)), we(ys, p);
    }
  }
  function xf(f, p, O) {
    f === "focusin" ? (Oc(), To = p, qn = O, To.attachEvent("onpropertychange", vf)) : f === "focusout" && Oc();
  }
  function Dh(f) {
    if (f === "selectionchange" || f === "keyup" || f === "keydown") return fu(qn);
  }
  function kh(f, p) {
    if (f === "click") return fu(p);
  }
  function hd(f, p) {
    if (f === "input" || f === "change") return fu(p);
  }
  function bf(f, p) {
    return f === p && (f !== 0 || 1 / f === 1 / p) || f !== f && p !== p;
  }
  var Ma = typeof Object.is == "function" ? Object.is : bf;
  function Ju(f, p) {
    if (Ma(f, p)) return !0;
    if (typeof f != "object" || f === null || typeof p != "object" || p === null) return !1;
    var O = Object.keys(f), ee = Object.keys(p);
    if (O.length !== ee.length) return !1;
    for (ee = 0; ee < O.length; ee++) {
      var ye = O[ee];
      if (!F.call(p, ye) || !Ma(f[ye], p[ye])) return !1;
    }
    return !0;
  }
  function zh(f) {
    for (; f && f.firstChild; ) f = f.firstChild;
    return f;
  }
  function Bc(f, p) {
    var O = zh(f);
    f = 0;
    for (var ee; O; ) {
      if (O.nodeType === 3) {
        if (ee = f + O.textContent.length, f <= p && ee >= p) return { node: O, offset: p - f };
        f = ee;
      }
      e: {
        for (; O; ) {
          if (O.nextSibling) {
            O = O.nextSibling;
            break e;
          }
          O = O.parentNode;
        }
        O = void 0;
      }
      O = zh(O);
    }
  }
  function du(f, p) {
    return f && p ? f === p ? !0 : f && f.nodeType === 3 ? !1 : p && p.nodeType === 3 ? du(f, p.parentNode) : "contains" in f ? f.contains(p) : f.compareDocumentPosition ? !!(f.compareDocumentPosition(p) & 16) : !1 : !1;
  }
  function Oh() {
    for (var f = window, p = vt(); p instanceof f.HTMLIFrameElement; ) {
      try {
        var O = typeof p.contentWindow.location.href == "string";
      } catch {
        O = !1;
      }
      if (O) f = p.contentWindow;
      else break;
      p = vt(f.document);
    }
    return p;
  }
  function Ka(f) {
    var p = f && f.nodeName && f.nodeName.toLowerCase();
    return p && (p === "input" && (f.type === "text" || f.type === "search" || f.type === "tel" || f.type === "url" || f.type === "password") || p === "textarea" || f.contentEditable === "true");
  }
  function Fc(f) {
    var p = Oh(), O = f.focusedElem, ee = f.selectionRange;
    if (p !== O && O && O.ownerDocument && du(O.ownerDocument.documentElement, O)) {
      if (ee !== null && Ka(O)) {
        if (p = ee.start, f = ee.end, f === void 0 && (f = p), "selectionStart" in O) O.selectionStart = p, O.selectionEnd = Math.min(f, O.value.length);
        else if (f = (p = O.ownerDocument || document) && p.defaultView || window, f.getSelection) {
          f = f.getSelection();
          var ye = O.textContent.length, Le = Math.min(ee.start, ye);
          ee = ee.end === void 0 ? Le : Math.min(ee.end, ye), !f.extend && Le > ee && (ye = ee, ee = Le, Le = ye), ye = Bc(O, Le);
          var ot = Bc(
            O,
            ee
          );
          ye && ot && (f.rangeCount !== 1 || f.anchorNode !== ye.node || f.anchorOffset !== ye.offset || f.focusNode !== ot.node || f.focusOffset !== ot.offset) && (p = p.createRange(), p.setStart(ye.node, ye.offset), f.removeAllRanges(), Le > ee ? (f.addRange(p), f.extend(ot.node, ot.offset)) : (p.setEnd(ot.node, ot.offset), f.addRange(p)));
        }
      }
      for (p = [], f = O; f = f.parentNode; ) f.nodeType === 1 && p.push({ element: f, left: f.scrollLeft, top: f.scrollTop });
      for (typeof O.focus == "function" && O.focus(), O = 0; O < p.length; O++) f = p[O], f.element.scrollLeft = f.left, f.element.scrollTop = f.top;
    }
  }
  var Qu = r && "documentMode" in document && 11 >= document.documentMode, xs = null, Jo = null, Ws = null, ec = !1;
  function Zs(f, p, O) {
    var ee = O.window === O ? O.document : O.nodeType === 9 ? O : O.ownerDocument;
    ec || xs == null || xs !== vt(ee) || (ee = xs, "selectionStart" in ee && Ka(ee) ? ee = { start: ee.selectionStart, end: ee.selectionEnd } : (ee = (ee.ownerDocument && ee.ownerDocument.defaultView || window).getSelection(), ee = { anchorNode: ee.anchorNode, anchorOffset: ee.anchorOffset, focusNode: ee.focusNode, focusOffset: ee.focusOffset }), Ws && Ju(Ws, ee) || (Ws = ee, ee = ac(Jo, "onSelect"), 0 < ee.length && (p = new On("onSelect", "select", null, p, O), f.push({ event: p, listeners: ee }), p.target = xs)));
  }
  function bs(f, p) {
    var O = {};
    return O[f.toLowerCase()] = p.toLowerCase(), O["Webkit" + f] = "webkit" + p, O["Moz" + f] = "moz" + p, O;
  }
  var Qo = { animationend: bs("Animation", "AnimationEnd"), animationiteration: bs("Animation", "AnimationIteration"), animationstart: bs("Animation", "AnimationStart"), transitionend: bs("Transition", "TransitionEnd") }, El = {}, qs = {};
  r && (qs = document.createElement("div").style, "AnimationEvent" in window || (delete Qo.animationend.animation, delete Qo.animationiteration.animation, delete Qo.animationstart.animation), "TransitionEvent" in window || delete Qo.transitionend.transition);
  function es(f) {
    if (El[f]) return El[f];
    if (!Qo[f]) return f;
    var p = Qo[f], O;
    for (O in p) if (p.hasOwnProperty(O) && O in qs) return El[f] = p[O];
    return f;
  }
  var Sl = es("animationend"), pu = es("animationiteration"), tc = es("animationstart"), mu = es("transitionend"), Tl = /* @__PURE__ */ new Map(), $s = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Oi(f, p) {
    Tl.set(f, p), $(p, [f]);
  }
  for (var Nc = 0; Nc < $s.length; Nc++) {
    var Xs = $s[Nc], wf = Xs.toLowerCase(), Ef = Xs[0].toUpperCase() + Xs.slice(1);
    Oi(wf, "on" + Ef);
  }
  Oi(Sl, "onAnimationEnd"), Oi(pu, "onAnimationIteration"), Oi(tc, "onAnimationStart"), Oi("dblclick", "onDoubleClick"), Oi("focusin", "onFocus"), Oi("focusout", "onBlur"), Oi(mu, "onTransitionEnd"), Q("onMouseEnter", ["mouseout", "mouseover"]), Q("onMouseLeave", ["mouseout", "mouseover"]), Q("onPointerEnter", ["pointerout", "pointerover"]), Q("onPointerLeave", ["pointerout", "pointerover"]), $("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), $("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), $("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), $("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), $("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), $("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var rc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), yn = new Set("cancel close invalid load scroll toggle".split(" ").concat(rc));
  function Uc(f, p, O) {
    var ee = f.type || "unknown-event";
    f.currentTarget = O, ht(ee, p, void 0, f), f.currentTarget = null;
  }
  function jc(f, p) {
    p = (p & 4) !== 0;
    for (var O = 0; O < f.length; O++) {
      var ee = f[O], ye = ee.event;
      ee = ee.listeners;
      e: {
        var Le = void 0;
        if (p) for (var ot = ee.length - 1; 0 <= ot; ot--) {
          var Ht = ee[ot], nr = Ht.instance, Er = Ht.currentTarget;
          if (Ht = Ht.listener, nr !== Le && ye.isPropagationStopped()) break e;
          Uc(ye, Ht, Er), Le = nr;
        }
        else for (ot = 0; ot < ee.length; ot++) {
          if (Ht = ee[ot], nr = Ht.instance, Er = Ht.currentTarget, Ht = Ht.listener, nr !== Le && ye.isPropagationStopped()) break e;
          Uc(ye, Ht, Er), Le = nr;
        }
      }
    }
    if ($t) throw f = Ce, $t = !1, Ce = null, f;
  }
  function Ln(f, p) {
    var O = p[Ks];
    O === void 0 && (O = p[Ks] = /* @__PURE__ */ new Set());
    var ee = f + "__bubble";
    O.has(ee) || (Sf(p, f, 2, !1), O.add(ee));
  }
  function ic(f, p, O) {
    var ee = 0;
    p && (ee |= 4), Sf(O, f, ee, p);
  }
  var nc = "_reactListening" + Math.random().toString(36).slice(2);
  function _u(f) {
    if (!f[nc]) {
      f[nc] = !0, te.forEach(function(O) {
        O !== "selectionchange" && (yn.has(O) || ic(O, !1, f), ic(O, !0, f));
      });
      var p = f.nodeType === 9 ? f : f.ownerDocument;
      p === null || p[nc] || (p[nc] = !0, ic("selectionchange", !1, p));
    }
  }
  function Sf(f, p, O, ee) {
    switch (Hu(p)) {
      case 1:
        var ye = zn;
        break;
      case 4:
        ye = Ah;
        break;
      default:
        ye = Ta;
    }
    O = ye.bind(null, p, O, f), ye = void 0, !ar || p !== "touchstart" && p !== "touchmove" && p !== "wheel" || (ye = !0), ee ? ye !== void 0 ? f.addEventListener(p, O, { capture: !0, passive: ye }) : f.addEventListener(p, O, !0) : ye !== void 0 ? f.addEventListener(p, O, { passive: ye }) : f.addEventListener(p, O, !1);
  }
  function Ml(f, p, O, ee, ye) {
    var Le = ee;
    if (!(p & 1) && !(p & 2) && ee !== null) e: for (; ; ) {
      if (ee === null) return;
      var ot = ee.tag;
      if (ot === 3 || ot === 4) {
        var Ht = ee.stateNode.containerInfo;
        if (Ht === ye || Ht.nodeType === 8 && Ht.parentNode === ye) break;
        if (ot === 4) for (ot = ee.return; ot !== null; ) {
          var nr = ot.tag;
          if ((nr === 3 || nr === 4) && (nr = ot.stateNode.containerInfo, nr === ye || nr.nodeType === 8 && nr.parentNode === ye)) return;
          ot = ot.return;
        }
        for (; Ht !== null; ) {
          if (ot = Js(Ht), ot === null) return;
          if (nr = ot.tag, nr === 5 || nr === 6) {
            ee = Le = ot;
            continue e;
          }
          Ht = Ht.parentNode;
        }
      }
      ee = ee.return;
    }
    we(function() {
      var Er = Le, Jr = Gt(O), ei = [];
      e: {
        var Qr = Tl.get(f);
        if (Qr !== void 0) {
          var wi = On, Ei = f;
          switch (f) {
            case "keypress":
              if (su(O) === 0) break e;
            case "keydown":
            case "keyup":
              wi = ud;
              break;
            case "focusin":
              Ei = "focus", wi = Wu;
              break;
            case "focusout":
              Ei = "blur", wi = Wu;
              break;
            case "beforeblur":
            case "afterblur":
              wi = Wu;
              break;
            case "click":
              if (O.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              wi = Yo;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              wi = Ih;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              wi = cd;
              break;
            case Sl:
            case pu:
            case tc:
              wi = Zu;
              break;
            case mu:
              wi = xl;
              break;
            case "scroll":
              wi = zo;
              break;
            case "wheel":
              wi = ui;
              break;
            case "copy":
            case "cut":
            case "paste":
              wi = od;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              wi = _f;
          }
          var Ti = (p & 4) !== 0, na = !Ti && f === "scroll", _r = Ti ? Qr !== null ? Qr + "Capture" : null : Qr;
          Ti = [];
          for (var lr = Er, xr; lr !== null; ) {
            xr = lr;
            var ai = xr.stateNode;
            if (xr.tag === 5 && ai !== null && (xr = ai, _r !== null && (ai = yt(lr, _r), ai != null && Ti.push(ws(lr, ai, xr)))), na) break;
            lr = lr.return;
          }
          0 < Ti.length && (Qr = new wi(Qr, Ei, null, O, Jr), ei.push({ event: Qr, listeners: Ti }));
        }
      }
      if (!(p & 7)) {
        e: {
          if (Qr = f === "mouseover" || f === "pointerover", wi = f === "mouseout" || f === "pointerout", Qr && O !== Tt && (Ei = O.relatedTarget || O.fromElement) && (Js(Ei) || Ei[Ao])) break e;
          if ((wi || Qr) && (Qr = Jr.window === Jr ? Jr : (Qr = Jr.ownerDocument) ? Qr.defaultView || Qr.parentWindow : window, wi ? (Ei = O.relatedTarget || O.toElement, wi = Er, Ei = Ei ? Js(Ei) : null, Ei !== null && (na = ft(Ei), Ei !== na || Ei.tag !== 5 && Ei.tag !== 6) && (Ei = null)) : (wi = null, Ei = Er), wi !== Ei)) {
            if (Ti = Yo, ai = "onMouseLeave", _r = "onMouseEnter", lr = "mouse", (f === "pointerout" || f === "pointerover") && (Ti = _f, ai = "onPointerLeave", _r = "onPointerEnter", lr = "pointer"), na = wi == null ? Qr : fo(wi), xr = Ei == null ? Qr : fo(Ei), Qr = new Ti(ai, lr + "leave", wi, O, Jr), Qr.target = na, Qr.relatedTarget = xr, ai = null, Js(Jr) === Er && (Ti = new Ti(_r, lr + "enter", Ei, O, Jr), Ti.target = xr, Ti.relatedTarget = na, ai = Ti), na = ai, wi && Ei) t: {
              for (Ti = wi, _r = Ei, lr = 0, xr = Ti; xr; xr = _a(xr)) lr++;
              for (xr = 0, ai = _r; ai; ai = _a(ai)) xr++;
              for (; 0 < lr - xr; ) Ti = _a(Ti), lr--;
              for (; 0 < xr - lr; ) _r = _a(_r), xr--;
              for (; lr--; ) {
                if (Ti === _r || _r !== null && Ti === _r.alternate) break t;
                Ti = _a(Ti), _r = _a(_r);
              }
              Ti = null;
            }
            else Ti = null;
            wi !== null && Vc(ei, Qr, wi, Ti, !1), Ei !== null && na !== null && Vc(ei, na, Ei, Ti, !0);
          }
        }
        e: {
          if (Qr = Er ? fo(Er) : window, wi = Qr.nodeName && Qr.nodeName.toLowerCase(), wi === "select" || wi === "input" && Qr.type === "file") var Ai = wl;
          else if (Yu(Qr)) if (Hs) Ai = hd;
          else {
            Ai = Dh;
            var Ii = xf;
          }
          else (wi = Qr.nodeName) && wi.toLowerCase() === "input" && (Qr.type === "checkbox" || Qr.type === "radio") && (Ai = kh);
          if (Ai && (Ai = Ai(f, Er))) {
            hu(ei, Ai, O, Jr);
            break e;
          }
          Ii && Ii(f, Qr, Er), f === "focusout" && (Ii = Qr._wrapperState) && Ii.controlled && Qr.type === "number" && _e(Qr, "number", Qr.value);
        }
        switch (Ii = Er ? fo(Er) : window, f) {
          case "focusin":
            (Yu(Ii) || Ii.contentEditable === "true") && (xs = Ii, Jo = Er, Ws = null);
            break;
          case "focusout":
            Ws = Jo = xs = null;
            break;
          case "mousedown":
            ec = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            ec = !1, Zs(ei, O, Jr);
            break;
          case "selectionchange":
            if (Qu) break;
          case "keydown":
          case "keyup":
            Zs(ei, O, Jr);
        }
        var Gi;
        if (_i) e: {
          switch (f) {
            case "compositionstart":
              var en = "onCompositionStart";
              break e;
            case "compositionend":
              en = "onCompositionEnd";
              break e;
            case "compositionupdate":
              en = "onCompositionUpdate";
              break e;
          }
          en = void 0;
        }
        else ua ? zc(f, O) && (en = "onCompositionEnd") : f === "keydown" && O.keyCode === 229 && (en = "onCompositionStart");
        en && (vi && O.locale !== "ko" && (ua || en !== "onCompositionStart" ? en === "onCompositionEnd" && ua && (Gi = ma()) : (Eo = Jr, pa = "value" in Eo ? Eo.value : Eo.textContent, ua = !0)), Ii = ac(Er, en), 0 < Ii.length && (en = new uu(en, f, null, O, Jr), ei.push({ event: en, listeners: Ii }), Gi ? en.data = Gi : (Gi = Xu(O), Gi !== null && (en.data = Gi)))), (Gi = kc ? xa(f, O) : Br(f, O)) && (Er = ac(Er, "onBeforeInput"), 0 < Er.length && (Jr = new uu("onBeforeInput", "beforeinput", null, O, Jr), ei.push({ event: Jr, listeners: Er }), Jr.data = Gi));
      }
      jc(ei, p);
    });
  }
  function ws(f, p, O) {
    return { instance: f, listener: p, currentTarget: O };
  }
  function ac(f, p) {
    for (var O = p + "Capture", ee = []; f !== null; ) {
      var ye = f, Le = ye.stateNode;
      ye.tag === 5 && Le !== null && (ye = Le, Le = yt(f, O), Le != null && ee.unshift(ws(f, Le, ye)), Le = yt(f, p), Le != null && ee.push(ws(f, Le, ye))), f = f.return;
    }
    return ee;
  }
  function _a(f) {
    if (f === null) return null;
    do
      f = f.return;
    while (f && f.tag !== 5);
    return f || null;
  }
  function Vc(f, p, O, ee, ye) {
    for (var Le = p._reactName, ot = []; O !== null && O !== ee; ) {
      var Ht = O, nr = Ht.alternate, Er = Ht.stateNode;
      if (nr !== null && nr === ee) break;
      Ht.tag === 5 && Er !== null && (Ht = Er, ye ? (nr = yt(O, Le), nr != null && ot.unshift(ws(O, nr, Ht))) : ye || (nr = yt(O, Le), nr != null && ot.push(ws(O, nr, Ht)))), O = O.return;
    }
    ot.length !== 0 && f.push({ event: p, listeners: ot });
  }
  var Gc = /\r\n?/g, Hc = /\u0000|\uFFFD/g;
  function Wc(f) {
    return (typeof f == "string" ? f : "" + f).replace(Gc, `
`).replace(Hc, "");
  }
  function gu(f, p, O) {
    if (p = Wc(p), Wc(f) !== p && O) throw Error(pt(425));
  }
  function Al() {
  }
  var oc = null, sc = null;
  function yu(f, p) {
    return f === "textarea" || f === "noscript" || typeof p.children == "string" || typeof p.children == "number" || typeof p.dangerouslySetInnerHTML == "object" && p.dangerouslySetInnerHTML !== null && p.dangerouslySetInnerHTML.__html != null;
  }
  var Zc = typeof setTimeout == "function" ? setTimeout : void 0, Tf = typeof clearTimeout == "function" ? clearTimeout : void 0, Il = typeof Promise == "function" ? Promise : void 0, fd = typeof queueMicrotask == "function" ? queueMicrotask : typeof Il < "u" ? function(f) {
    return Il.resolve(null).then(f).catch(dd);
  } : Zc;
  function dd(f) {
    setTimeout(function() {
      throw f;
    });
  }
  function Bh(f, p) {
    var O = p, ee = 0;
    do {
      var ye = O.nextSibling;
      if (f.removeChild(O), ye && ye.nodeType === 8) if (O = ye.data, O === "/$") {
        if (ee === 0) {
          f.removeChild(ye), Ya(p);
          return;
        }
        ee--;
      } else O !== "$" && O !== "$?" && O !== "$!" || ee++;
      O = ye;
    } while (O);
    Ya(p);
  }
  function Ys(f) {
    for (; f != null; f = f.nextSibling) {
      var p = f.nodeType;
      if (p === 1 || p === 3) break;
      if (p === 8) {
        if (p = f.data, p === "$" || p === "$!" || p === "$?") break;
        if (p === "/$") return null;
      }
    }
    return f;
  }
  function Mf(f) {
    f = f.previousSibling;
    for (var p = 0; f; ) {
      if (f.nodeType === 8) {
        var O = f.data;
        if (O === "$" || O === "$!" || O === "$?") {
          if (p === 0) return f;
          p--;
        } else O === "/$" && p++;
      }
      f = f.previousSibling;
    }
    return null;
  }
  var vu = Math.random().toString(36).slice(2), Mo = "__reactFiber$" + vu, Cl = "__reactProps$" + vu, Ao = "__reactContainer$" + vu, Ks = "__reactEvents$" + vu, Fh = "__reactListeners$" + vu, Af = "__reactHandles$" + vu;
  function Js(f) {
    var p = f[Mo];
    if (p) return p;
    for (var O = f.parentNode; O; ) {
      if (p = O[Ao] || O[Mo]) {
        if (O = p.alternate, p.child !== null || O !== null && O.child !== null) for (f = Mf(f); f !== null; ) {
          if (O = f[Mo]) return O;
          f = Mf(f);
        }
        return p;
      }
      f = O, O = f.parentNode;
    }
    return null;
  }
  function Pl(f) {
    return f = f[Mo] || f[Ao], !f || f.tag !== 5 && f.tag !== 6 && f.tag !== 13 && f.tag !== 3 ? null : f;
  }
  function fo(f) {
    if (f.tag === 5 || f.tag === 6) return f.stateNode;
    throw Error(pt(33));
  }
  function xu(f) {
    return f[Cl] || null;
  }
  var Na = [], Es = -1;
  function Io(f) {
    return { current: f };
  }
  function Bn(f) {
    0 > Es || (f.current = Na[Es], Na[Es] = null, Es--);
  }
  function Tn(f, p) {
    Es++, Na[Es] = f.current, f.current = p;
  }
  var Co = {}, ba = Io(Co), Ja = Io(!1), Ss = Co;
  function Bo(f, p) {
    var O = f.type.contextTypes;
    if (!O) return Co;
    var ee = f.stateNode;
    if (ee && ee.__reactInternalMemoizedUnmaskedChildContext === p) return ee.__reactInternalMemoizedMaskedChildContext;
    var ye = {}, Le;
    for (Le in O) ye[Le] = p[Le];
    return ee && (f = f.stateNode, f.__reactInternalMemoizedUnmaskedChildContext = p, f.__reactInternalMemoizedMaskedChildContext = ye), ye;
  }
  function Qa(f) {
    return f = f.childContextTypes, f != null;
  }
  function qc() {
    Bn(Ja), Bn(ba);
  }
  function Nh(f, p, O) {
    if (ba.current !== Co) throw Error(pt(168));
    Tn(ba, p), Tn(Ja, O);
  }
  function Uh(f, p, O) {
    var ee = f.stateNode;
    if (p = p.childContextTypes, typeof ee.getChildContext != "function") return O;
    ee = ee.getChildContext();
    for (var ye in ee) if (!(ye in p)) throw Error(pt(108, $e(f) || "Unknown", ye));
    return De({}, O, ee);
  }
  function Rl(f) {
    return f = (f = f.stateNode) && f.__reactInternalMemoizedMergedChildContext || Co, Ss = ba.current, Tn(ba, f), Tn(Ja, Ja.current), !0;
  }
  function Ll(f, p, O) {
    var ee = f.stateNode;
    if (!ee) throw Error(pt(169));
    O ? (f = Uh(f, p, Ss), ee.__reactInternalMemoizedMergedChildContext = f, Bn(Ja), Bn(ba), Tn(ba, f)) : Bn(Ja), Tn(Ja, O);
  }
  var eo = null, Dl = !1, kl = !1;
  function jh(f) {
    eo === null ? eo = [f] : eo.push(f);
  }
  function lc(f) {
    Dl = !0, jh(f);
  }
  function Po() {
    if (!kl && eo !== null) {
      kl = !0;
      var f = 0, p = on;
      try {
        var O = eo;
        for (on = 1; f < O.length; f++) {
          var ee = O[f];
          do
            ee = ee(!0);
          while (ee !== null);
        }
        eo = null, Dl = !1;
      } catch (ye) {
        throw eo !== null && (eo = eo.slice(f + 1)), Yt(fi, Po), ye;
      } finally {
        on = p, kl = !1;
      }
    }
    return null;
  }
  var Qs = [], zl = 0, $c = null, ts = 0, Ua = [], Gr = 0, Ts = null, Fo = 1, Ra = "";
  function po(f, p) {
    Qs[zl++] = ts, Qs[zl++] = $c, $c = f, ts = p;
  }
  function ri(f, p, O) {
    Ua[Gr++] = Fo, Ua[Gr++] = Ra, Ua[Gr++] = Ts, Ts = f;
    var ee = Fo;
    f = Ra;
    var ye = 32 - sa(ee) - 1;
    ee &= ~(1 << ye), O += 1;
    var Le = 32 - sa(p) + ye;
    if (30 < Le) {
      var ot = ye - ye % 5;
      Le = (ee & (1 << ot) - 1).toString(32), ee >>= ot, ye -= ot, Fo = 1 << 32 - sa(p) + ye | O << ye | ee, Ra = Le + f;
    } else Fo = 1 << Le | O << ye | ee, Ra = f;
  }
  function uc(f) {
    f.return !== null && (po(f, 1), ri(f, 1, 0));
  }
  function Vh(f) {
    for (; f === $c; ) $c = Qs[--zl], Qs[zl] = null, ts = Qs[--zl], Qs[zl] = null;
    for (; f === Ts; ) Ts = Ua[--Gr], Ua[Gr] = null, Ra = Ua[--Gr], Ua[Gr] = null, Fo = Ua[--Gr], Ua[Gr] = null;
  }
  var mo = null, La = null, Fn = !1, _o = null;
  function Gh(f, p) {
    var O = us(5, null, null, 0);
    O.elementType = "DELETED", O.stateNode = p, O.return = f, p = f.deletions, p === null ? (f.deletions = [O], f.flags |= 16) : p.push(O);
  }
  function Xc(f, p) {
    switch (f.tag) {
      case 5:
        var O = f.type;
        return p = p.nodeType !== 1 || O.toLowerCase() !== p.nodeName.toLowerCase() ? null : p, p !== null ? (f.stateNode = p, mo = f, La = Ys(p.firstChild), !0) : !1;
      case 6:
        return p = f.pendingProps === "" || p.nodeType !== 3 ? null : p, p !== null ? (f.stateNode = p, mo = f, La = null, !0) : !1;
      case 13:
        return p = p.nodeType !== 8 ? null : p, p !== null ? (O = Ts !== null ? { id: Fo, overflow: Ra } : null, f.memoizedState = { dehydrated: p, treeContext: O, retryLane: 1073741824 }, O = us(18, null, null, 0), O.stateNode = p, O.return = f, f.child = O, mo = f, La = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Ol(f) {
    return (f.mode & 1) !== 0 && (f.flags & 128) === 0;
  }
  function bu(f) {
    if (Fn) {
      var p = La;
      if (p) {
        var O = p;
        if (!Xc(f, p)) {
          if (Ol(f)) throw Error(pt(418));
          p = Ys(O.nextSibling);
          var ee = mo;
          p && Xc(f, p) ? Gh(ee, O) : (f.flags = f.flags & -4097 | 2, Fn = !1, mo = f);
        }
      } else {
        if (Ol(f)) throw Error(pt(418));
        f.flags = f.flags & -4097 | 2, Fn = !1, mo = f;
      }
    }
  }
  function Yc(f) {
    for (f = f.return; f !== null && f.tag !== 5 && f.tag !== 3 && f.tag !== 13; ) f = f.return;
    mo = f;
  }
  function go(f) {
    if (f !== mo) return !1;
    if (!Fn) return Yc(f), Fn = !0, !1;
    var p;
    if ((p = f.tag !== 3) && !(p = f.tag !== 5) && (p = f.type, p = p !== "head" && p !== "body" && !yu(f.type, f.memoizedProps)), p && (p = La)) {
      if (Ol(f)) throw ja(), Error(pt(418));
      for (; p; ) Gh(f, p), p = Ys(p.nextSibling);
    }
    if (Yc(f), f.tag === 13) {
      if (f = f.memoizedState, f = f !== null ? f.dehydrated : null, !f) throw Error(pt(317));
      e: {
        for (f = f.nextSibling, p = 0; f; ) {
          if (f.nodeType === 8) {
            var O = f.data;
            if (O === "/$") {
              if (p === 0) {
                La = Ys(f.nextSibling);
                break e;
              }
              p--;
            } else O !== "$" && O !== "$!" && O !== "$?" || p++;
          }
          f = f.nextSibling;
        }
        La = null;
      }
    } else La = mo ? Ys(f.stateNode.nextSibling) : null;
    return !0;
  }
  function ja() {
    for (var f = La; f; ) f = Ys(f.nextSibling);
  }
  function yo() {
    La = mo = null, Fn = !1;
  }
  function cc(f) {
    _o === null ? _o = [f] : _o.push(f);
  }
  var Hh = B.ReactCurrentBatchConfig;
  function rs(f, p, O) {
    if (f = O.ref, f !== null && typeof f != "function" && typeof f != "object") {
      if (O._owner) {
        if (O = O._owner, O) {
          if (O.tag !== 1) throw Error(pt(309));
          var ee = O.stateNode;
        }
        if (!ee) throw Error(pt(147, f));
        var ye = ee, Le = "" + f;
        return p !== null && p.ref !== null && typeof p.ref == "function" && p.ref._stringRef === Le ? p.ref : (p = function(ot) {
          var Ht = ye.refs;
          ot === null ? delete Ht[Le] : Ht[Le] = ot;
        }, p._stringRef = Le, p);
      }
      if (typeof f != "string") throw Error(pt(284));
      if (!O._owner) throw Error(pt(290, f));
    }
    return f;
  }
  function Bl(f, p) {
    throw f = Object.prototype.toString.call(p), Error(pt(31, f === "[object Object]" ? "object with keys {" + Object.keys(p).join(", ") + "}" : f));
  }
  function wu(f) {
    var p = f._init;
    return p(f._payload);
  }
  function to(f) {
    function p(_r, lr) {
      if (f) {
        var xr = _r.deletions;
        xr === null ? (_r.deletions = [lr], _r.flags |= 16) : xr.push(lr);
      }
    }
    function O(_r, lr) {
      if (!f) return null;
      for (; lr !== null; ) p(_r, lr), lr = lr.sibling;
      return null;
    }
    function ee(_r, lr) {
      for (_r = /* @__PURE__ */ new Map(); lr !== null; ) lr.key !== null ? _r.set(lr.key, lr) : _r.set(lr.index, lr), lr = lr.sibling;
      return _r;
    }
    function ye(_r, lr) {
      return _r = Jl(_r, lr), _r.index = 0, _r.sibling = null, _r;
    }
    function Le(_r, lr, xr) {
      return _r.index = xr, f ? (xr = _r.alternate, xr !== null ? (xr = xr.index, xr < lr ? (_r.flags |= 2, lr) : xr) : (_r.flags |= 2, lr)) : (_r.flags |= 1048576, lr);
    }
    function ot(_r) {
      return f && _r.alternate === null && (_r.flags |= 2), _r;
    }
    function Ht(_r, lr, xr, ai) {
      return lr === null || lr.tag !== 6 ? (lr = Df(xr, _r.mode, ai), lr.return = _r, lr) : (lr = ye(lr, xr), lr.return = _r, lr);
    }
    function nr(_r, lr, xr, ai) {
      var Ai = xr.type;
      return Ai === V ? Jr(_r, lr, xr.props.children, ai, xr.key) : lr !== null && (lr.elementType === Ai || typeof Ai == "object" && Ai !== null && Ai.$$typeof === Me && wu(Ai) === lr.type) ? (ai = ye(lr, xr.props), ai.ref = rs(_r, lr, xr), ai.return = _r, ai) : (ai = nf(xr.type, xr.key, xr.props, null, _r.mode, ai), ai.ref = rs(_r, lr, xr), ai.return = _r, ai);
    }
    function Er(_r, lr, xr, ai) {
      return lr === null || lr.tag !== 4 || lr.stateNode.containerInfo !== xr.containerInfo || lr.stateNode.implementation !== xr.implementation ? (lr = kf(xr, _r.mode, ai), lr.return = _r, lr) : (lr = ye(lr, xr.children || []), lr.return = _r, lr);
    }
    function Jr(_r, lr, xr, ai, Ai) {
      return lr === null || lr.tag !== 7 ? (lr = Fu(xr, _r.mode, ai, Ai), lr.return = _r, lr) : (lr = ye(lr, xr), lr.return = _r, lr);
    }
    function ei(_r, lr, xr) {
      if (typeof lr == "string" && lr !== "" || typeof lr == "number") return lr = Df("" + lr, _r.mode, xr), lr.return = _r, lr;
      if (typeof lr == "object" && lr !== null) {
        switch (lr.$$typeof) {
          case N:
            return xr = nf(lr.type, lr.key, lr.props, null, _r.mode, xr), xr.ref = rs(_r, null, lr), xr.return = _r, xr;
          case U:
            return lr = kf(lr, _r.mode, xr), lr.return = _r, lr;
          case Me:
            var ai = lr._init;
            return ei(_r, ai(lr._payload), xr);
        }
        if (fe(lr) || de(lr)) return lr = Fu(lr, _r.mode, xr, null), lr.return = _r, lr;
        Bl(_r, lr);
      }
      return null;
    }
    function Qr(_r, lr, xr, ai) {
      var Ai = lr !== null ? lr.key : null;
      if (typeof xr == "string" && xr !== "" || typeof xr == "number") return Ai !== null ? null : Ht(_r, lr, "" + xr, ai);
      if (typeof xr == "object" && xr !== null) {
        switch (xr.$$typeof) {
          case N:
            return xr.key === Ai ? nr(_r, lr, xr, ai) : null;
          case U:
            return xr.key === Ai ? Er(_r, lr, xr, ai) : null;
          case Me:
            return Ai = xr._init, Qr(
              _r,
              lr,
              Ai(xr._payload),
              ai
            );
        }
        if (fe(xr) || de(xr)) return Ai !== null ? null : Jr(_r, lr, xr, ai, null);
        Bl(_r, xr);
      }
      return null;
    }
    function wi(_r, lr, xr, ai, Ai) {
      if (typeof ai == "string" && ai !== "" || typeof ai == "number") return _r = _r.get(xr) || null, Ht(lr, _r, "" + ai, Ai);
      if (typeof ai == "object" && ai !== null) {
        switch (ai.$$typeof) {
          case N:
            return _r = _r.get(ai.key === null ? xr : ai.key) || null, nr(lr, _r, ai, Ai);
          case U:
            return _r = _r.get(ai.key === null ? xr : ai.key) || null, Er(lr, _r, ai, Ai);
          case Me:
            var Ii = ai._init;
            return wi(_r, lr, xr, Ii(ai._payload), Ai);
        }
        if (fe(ai) || de(ai)) return _r = _r.get(xr) || null, Jr(lr, _r, ai, Ai, null);
        Bl(lr, ai);
      }
      return null;
    }
    function Ei(_r, lr, xr, ai) {
      for (var Ai = null, Ii = null, Gi = lr, en = lr = 0, Oa = null; Gi !== null && en < xr.length; en++) {
        Gi.index > en ? (Oa = Gi, Gi = null) : Oa = Gi.sibling;
        var En = Qr(_r, Gi, xr[en], ai);
        if (En === null) {
          Gi === null && (Gi = Oa);
          break;
        }
        f && Gi && En.alternate === null && p(_r, Gi), lr = Le(En, lr, en), Ii === null ? Ai = En : Ii.sibling = En, Ii = En, Gi = Oa;
      }
      if (en === xr.length) return O(_r, Gi), Fn && po(_r, en), Ai;
      if (Gi === null) {
        for (; en < xr.length; en++) Gi = ei(_r, xr[en], ai), Gi !== null && (lr = Le(Gi, lr, en), Ii === null ? Ai = Gi : Ii.sibling = Gi, Ii = Gi);
        return Fn && po(_r, en), Ai;
      }
      for (Gi = ee(_r, Gi); en < xr.length; en++) Oa = wi(Gi, _r, en, xr[en], ai), Oa !== null && (f && Oa.alternate !== null && Gi.delete(Oa.key === null ? en : Oa.key), lr = Le(Oa, lr, en), Ii === null ? Ai = Oa : Ii.sibling = Oa, Ii = Oa);
      return f && Gi.forEach(function(Uu) {
        return p(_r, Uu);
      }), Fn && po(_r, en), Ai;
    }
    function Ti(_r, lr, xr, ai) {
      var Ai = de(xr);
      if (typeof Ai != "function") throw Error(pt(150));
      if (xr = Ai.call(xr), xr == null) throw Error(pt(151));
      for (var Ii = Ai = null, Gi = lr, en = lr = 0, Oa = null, En = xr.next(); Gi !== null && !En.done; en++, En = xr.next()) {
        Gi.index > en ? (Oa = Gi, Gi = null) : Oa = Gi.sibling;
        var Uu = Qr(_r, Gi, En.value, ai);
        if (Uu === null) {
          Gi === null && (Gi = Oa);
          break;
        }
        f && Gi && Uu.alternate === null && p(_r, Gi), lr = Le(Uu, lr, en), Ii === null ? Ai = Uu : Ii.sibling = Uu, Ii = Uu, Gi = Oa;
      }
      if (En.done) return O(
        _r,
        Gi
      ), Fn && po(_r, en), Ai;
      if (Gi === null) {
        for (; !En.done; en++, En = xr.next()) En = ei(_r, En.value, ai), En !== null && (lr = Le(En, lr, en), Ii === null ? Ai = En : Ii.sibling = En, Ii = En);
        return Fn && po(_r, en), Ai;
      }
      for (Gi = ee(_r, Gi); !En.done; en++, En = xr.next()) En = wi(Gi, _r, en, En.value, ai), En !== null && (f && En.alternate !== null && Gi.delete(En.key === null ? en : En.key), lr = Le(En, lr, en), Ii === null ? Ai = En : Ii.sibling = En, Ii = En);
      return f && Gi.forEach(function(Jp) {
        return p(_r, Jp);
      }), Fn && po(_r, en), Ai;
    }
    function na(_r, lr, xr, ai) {
      if (typeof xr == "object" && xr !== null && xr.type === V && xr.key === null && (xr = xr.props.children), typeof xr == "object" && xr !== null) {
        switch (xr.$$typeof) {
          case N:
            e: {
              for (var Ai = xr.key, Ii = lr; Ii !== null; ) {
                if (Ii.key === Ai) {
                  if (Ai = xr.type, Ai === V) {
                    if (Ii.tag === 7) {
                      O(_r, Ii.sibling), lr = ye(Ii, xr.props.children), lr.return = _r, _r = lr;
                      break e;
                    }
                  } else if (Ii.elementType === Ai || typeof Ai == "object" && Ai !== null && Ai.$$typeof === Me && wu(Ai) === Ii.type) {
                    O(_r, Ii.sibling), lr = ye(Ii, xr.props), lr.ref = rs(_r, Ii, xr), lr.return = _r, _r = lr;
                    break e;
                  }
                  O(_r, Ii);
                  break;
                } else p(_r, Ii);
                Ii = Ii.sibling;
              }
              xr.type === V ? (lr = Fu(xr.props.children, _r.mode, ai, xr.key), lr.return = _r, _r = lr) : (ai = nf(xr.type, xr.key, xr.props, null, _r.mode, ai), ai.ref = rs(_r, lr, xr), ai.return = _r, _r = ai);
            }
            return ot(_r);
          case U:
            e: {
              for (Ii = xr.key; lr !== null; ) {
                if (lr.key === Ii) if (lr.tag === 4 && lr.stateNode.containerInfo === xr.containerInfo && lr.stateNode.implementation === xr.implementation) {
                  O(_r, lr.sibling), lr = ye(lr, xr.children || []), lr.return = _r, _r = lr;
                  break e;
                } else {
                  O(_r, lr);
                  break;
                }
                else p(_r, lr);
                lr = lr.sibling;
              }
              lr = kf(xr, _r.mode, ai), lr.return = _r, _r = lr;
            }
            return ot(_r);
          case Me:
            return Ii = xr._init, na(_r, lr, Ii(xr._payload), ai);
        }
        if (fe(xr)) return Ei(_r, lr, xr, ai);
        if (de(xr)) return Ti(_r, lr, xr, ai);
        Bl(_r, xr);
      }
      return typeof xr == "string" && xr !== "" || typeof xr == "number" ? (xr = "" + xr, lr !== null && lr.tag === 6 ? (O(_r, lr.sibling), lr = ye(lr, xr), lr.return = _r, _r = lr) : (O(_r, lr), lr = Df(xr, _r.mode, ai), lr.return = _r, _r = lr), ot(_r)) : O(_r, lr);
    }
    return na;
  }
  var sn = to(!0), hc = to(!1), el = Io(null), Fl = null, tl = null, Nl = null;
  function rl() {
    Nl = tl = Fl = null;
  }
  function il(f) {
    var p = el.current;
    Bn(el), f._currentValue = p;
  }
  function nl(f, p, O) {
    for (; f !== null; ) {
      var ee = f.alternate;
      if ((f.childLanes & p) !== p ? (f.childLanes |= p, ee !== null && (ee.childLanes |= p)) : ee !== null && (ee.childLanes & p) !== p && (ee.childLanes |= p), f === O) break;
      f = f.return;
    }
  }
  function Mr(f, p) {
    Fl = f, Nl = tl = null, f = f.dependencies, f !== null && f.firstContext !== null && (f.lanes & p && (Da = !0), f.firstContext = null);
  }
  function Nr(f) {
    var p = f._currentValue;
    if (Nl !== f) if (f = { context: f, memoizedValue: p, next: null }, tl === null) {
      if (Fl === null) throw Error(pt(308));
      tl = f, Fl.dependencies = { lanes: 0, firstContext: f };
    } else tl = tl.next = f;
    return p;
  }
  var Ro = null;
  function vn(f) {
    Ro === null ? Ro = [f] : Ro.push(f);
  }
  function Kt(f, p, O, ee) {
    var ye = p.interleaved;
    return ye === null ? (O.next = O, vn(p)) : (O.next = ye.next, ye.next = O), p.interleaved = O, is(f, ee);
  }
  function is(f, p) {
    f.lanes |= p;
    var O = f.alternate;
    for (O !== null && (O.lanes |= p), O = f, f = f.return; f !== null; ) f.childLanes |= p, O = f.alternate, O !== null && (O.childLanes |= p), O = f, f = f.return;
    return O.tag === 3 ? O.stateNode : null;
  }
  var No = !1;
  function fc(f) {
    f.updateQueue = { baseState: f.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function Wh(f, p) {
    f = f.updateQueue, p.updateQueue === f && (p.updateQueue = { baseState: f.baseState, firstBaseUpdate: f.firstBaseUpdate, lastBaseUpdate: f.lastBaseUpdate, shared: f.shared, effects: f.effects });
  }
  function ns(f, p) {
    return { eventTime: f, lane: p, tag: 0, payload: null, callback: null, next: null };
  }
  function Ms(f, p, O) {
    var ee = f.updateQueue;
    if (ee === null) return null;
    if (ee = ee.shared, gt & 2) {
      var ye = ee.pending;
      return ye === null ? p.next = p : (p.next = ye.next, ye.next = p), ee.pending = p, is(f, O);
    }
    return ye = ee.interleaved, ye === null ? (p.next = p, vn(ee)) : (p.next = ye.next, ye.next = p), ee.interleaved = p, is(f, O);
  }
  function As(f, p, O) {
    if (p = p.updateQueue, p !== null && (p = p.shared, (O & 4194240) !== 0)) {
      var ee = p.lanes;
      ee &= f.pendingLanes, O |= ee, p.lanes = O, co(f, O);
    }
  }
  function If(f, p) {
    var O = f.updateQueue, ee = f.alternate;
    if (ee !== null && (ee = ee.updateQueue, O === ee)) {
      var ye = null, Le = null;
      if (O = O.firstBaseUpdate, O !== null) {
        do {
          var ot = { eventTime: O.eventTime, lane: O.lane, tag: O.tag, payload: O.payload, callback: O.callback, next: null };
          Le === null ? ye = Le = ot : Le = Le.next = ot, O = O.next;
        } while (O !== null);
        Le === null ? ye = Le = p : Le = Le.next = p;
      } else ye = Le = p;
      O = { baseState: ee.baseState, firstBaseUpdate: ye, lastBaseUpdate: Le, shared: ee.shared, effects: ee.effects }, f.updateQueue = O;
      return;
    }
    f = O.lastBaseUpdate, f === null ? O.firstBaseUpdate = p : f.next = p, O.lastBaseUpdate = p;
  }
  function Kc(f, p, O, ee) {
    var ye = f.updateQueue;
    No = !1;
    var Le = ye.firstBaseUpdate, ot = ye.lastBaseUpdate, Ht = ye.shared.pending;
    if (Ht !== null) {
      ye.shared.pending = null;
      var nr = Ht, Er = nr.next;
      nr.next = null, ot === null ? Le = Er : ot.next = Er, ot = nr;
      var Jr = f.alternate;
      Jr !== null && (Jr = Jr.updateQueue, Ht = Jr.lastBaseUpdate, Ht !== ot && (Ht === null ? Jr.firstBaseUpdate = Er : Ht.next = Er, Jr.lastBaseUpdate = nr));
    }
    if (Le !== null) {
      var ei = ye.baseState;
      ot = 0, Jr = Er = nr = null, Ht = Le;
      do {
        var Qr = Ht.lane, wi = Ht.eventTime;
        if ((ee & Qr) === Qr) {
          Jr !== null && (Jr = Jr.next = {
            eventTime: wi,
            lane: 0,
            tag: Ht.tag,
            payload: Ht.payload,
            callback: Ht.callback,
            next: null
          });
          e: {
            var Ei = f, Ti = Ht;
            switch (Qr = p, wi = O, Ti.tag) {
              case 1:
                if (Ei = Ti.payload, typeof Ei == "function") {
                  ei = Ei.call(wi, ei, Qr);
                  break e;
                }
                ei = Ei;
                break e;
              case 3:
                Ei.flags = Ei.flags & -65537 | 128;
              case 0:
                if (Ei = Ti.payload, Qr = typeof Ei == "function" ? Ei.call(wi, ei, Qr) : Ei, Qr == null) break e;
                ei = De({}, ei, Qr);
                break e;
              case 2:
                No = !0;
            }
          }
          Ht.callback !== null && Ht.lane !== 0 && (f.flags |= 64, Qr = ye.effects, Qr === null ? ye.effects = [Ht] : Qr.push(Ht));
        } else wi = { eventTime: wi, lane: Qr, tag: Ht.tag, payload: Ht.payload, callback: Ht.callback, next: null }, Jr === null ? (Er = Jr = wi, nr = ei) : Jr = Jr.next = wi, ot |= Qr;
        if (Ht = Ht.next, Ht === null) {
          if (Ht = ye.shared.pending, Ht === null) break;
          Qr = Ht, Ht = Qr.next, Qr.next = null, ye.lastBaseUpdate = Qr, ye.shared.pending = null;
        }
      } while (!0);
      if (Jr === null && (nr = ei), ye.baseState = nr, ye.firstBaseUpdate = Er, ye.lastBaseUpdate = Jr, p = ye.shared.interleaved, p !== null) {
        ye = p;
        do
          ot |= ye.lane, ye = ye.next;
        while (ye !== p);
      } else Le === null && (ye.shared.lanes = 0);
      gr |= ot, f.lanes = ot, f.memoizedState = ei;
    }
  }
  function Zh(f, p, O) {
    if (f = p.effects, p.effects = null, f !== null) for (p = 0; p < f.length; p++) {
      var ee = f[p], ye = ee.callback;
      if (ye !== null) {
        if (ee.callback = null, ee = O, typeof ye != "function") throw Error(pt(191, ye));
        ye.call(ee);
      }
    }
  }
  var al = {}, Aa = Io(al), Ul = Io(al), jl = Io(al);
  function vo(f) {
    if (f === al) throw Error(pt(174));
    return f;
  }
  function Eu(f, p) {
    switch (Tn(jl, p), Tn(Ul, f), Tn(Aa, al), f = p.nodeType, f) {
      case 9:
      case 11:
        p = (p = p.documentElement) ? p.namespaceURI : Wt(null, "");
        break;
      default:
        f = f === 8 ? p.parentNode : p, p = f.namespaceURI || null, f = f.tagName, p = Wt(p, f);
    }
    Bn(Aa), Tn(Aa, p);
  }
  function Va() {
    Bn(Aa), Bn(Ul), Bn(jl);
  }
  function as(f) {
    vo(jl.current);
    var p = vo(Aa.current), O = Wt(p, f.type);
    p !== O && (Tn(Ul, f), Tn(Aa, O));
  }
  function Jc(f) {
    Ul.current === f && (Bn(Aa), Bn(Ul));
  }
  var rn = Io(0);
  function Qc(f) {
    for (var p = f; p !== null; ) {
      if (p.tag === 13) {
        var O = p.memoizedState;
        if (O !== null && (O = O.dehydrated, O === null || O.data === "$?" || O.data === "$!")) return p;
      } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
        if (p.flags & 128) return p;
      } else if (p.child !== null) {
        p.child.return = p, p = p.child;
        continue;
      }
      if (p === f) break;
      for (; p.sibling === null; ) {
        if (p.return === null || p.return === f) return null;
        p = p.return;
      }
      p.sibling.return = p.return, p = p.sibling;
    }
    return null;
  }
  var Vl = [];
  function dn() {
    for (var f = 0; f < Vl.length; f++) Vl[f]._workInProgressVersionPrimary = null;
    Vl.length = 0;
  }
  var Yi = B.ReactCurrentDispatcher, eh = B.ReactCurrentBatchConfig, Ga = 0, In = null, Dn = null, ta = null, ol = !1, ro = !1, ra = 0, th = 0;
  function ca() {
    throw Error(pt(321));
  }
  function dc(f, p) {
    if (p === null) return !1;
    for (var O = 0; O < p.length && O < f.length; O++) if (!Ma(f[O], p[O])) return !1;
    return !0;
  }
  function pc(f, p, O, ee, ye, Le) {
    if (Ga = Le, In = p, p.memoizedState = null, p.updateQueue = null, p.lanes = 0, Yi.current = f === null || f.memoizedState === null ? pd : Nn, f = O(ee, ye), ro) {
      Le = 0;
      do {
        if (ro = !1, ra = 0, 25 <= Le) throw Error(pt(301));
        Le += 1, ta = Dn = null, p.updateQueue = null, Yi.current = lh, f = O(ee, ye);
      } while (ro);
    }
    if (Yi.current = sh, p = Dn !== null && Dn.next !== null, Ga = 0, ta = Dn = In = null, ol = !1, p) throw Error(pt(300));
    return f;
  }
  function Is() {
    var f = ra !== 0;
    return ra = 0, f;
  }
  function Lo() {
    var f = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return ta === null ? In.memoizedState = ta = f : ta = ta.next = f, ta;
  }
  function ga() {
    if (Dn === null) {
      var f = In.alternate;
      f = f !== null ? f.memoizedState : null;
    } else f = Dn.next;
    var p = ta === null ? In.memoizedState : ta.next;
    if (p !== null) ta = p, Dn = f;
    else {
      if (f === null) throw Error(pt(310));
      Dn = f, f = { memoizedState: Dn.memoizedState, baseState: Dn.baseState, baseQueue: Dn.baseQueue, queue: Dn.queue, next: null }, ta === null ? In.memoizedState = ta = f : ta = ta.next = f;
    }
    return ta;
  }
  function Gl(f, p) {
    return typeof p == "function" ? p(f) : p;
  }
  function Su(f) {
    var p = ga(), O = p.queue;
    if (O === null) throw Error(pt(311));
    O.lastRenderedReducer = f;
    var ee = Dn, ye = ee.baseQueue, Le = O.pending;
    if (Le !== null) {
      if (ye !== null) {
        var ot = ye.next;
        ye.next = Le.next, Le.next = ot;
      }
      ee.baseQueue = ye = Le, O.pending = null;
    }
    if (ye !== null) {
      Le = ye.next, ee = ee.baseState;
      var Ht = ot = null, nr = null, Er = Le;
      do {
        var Jr = Er.lane;
        if ((Ga & Jr) === Jr) nr !== null && (nr = nr.next = { lane: 0, action: Er.action, hasEagerState: Er.hasEagerState, eagerState: Er.eagerState, next: null }), ee = Er.hasEagerState ? Er.eagerState : f(ee, Er.action);
        else {
          var ei = {
            lane: Jr,
            action: Er.action,
            hasEagerState: Er.hasEagerState,
            eagerState: Er.eagerState,
            next: null
          };
          nr === null ? (Ht = nr = ei, ot = ee) : nr = nr.next = ei, In.lanes |= Jr, gr |= Jr;
        }
        Er = Er.next;
      } while (Er !== null && Er !== Le);
      nr === null ? ot = ee : nr.next = Ht, Ma(ee, p.memoizedState) || (Da = !0), p.memoizedState = ee, p.baseState = ot, p.baseQueue = nr, O.lastRenderedState = ee;
    }
    if (f = O.interleaved, f !== null) {
      ye = f;
      do
        Le = ye.lane, In.lanes |= Le, gr |= Le, ye = ye.next;
      while (ye !== f);
    } else ye === null && (O.lanes = 0);
    return [p.memoizedState, O.dispatch];
  }
  function mc(f) {
    var p = ga(), O = p.queue;
    if (O === null) throw Error(pt(311));
    O.lastRenderedReducer = f;
    var ee = O.dispatch, ye = O.pending, Le = p.memoizedState;
    if (ye !== null) {
      O.pending = null;
      var ot = ye = ye.next;
      do
        Le = f(Le, ot.action), ot = ot.next;
      while (ot !== ye);
      Ma(Le, p.memoizedState) || (Da = !0), p.memoizedState = Le, p.baseQueue === null && (p.baseState = Le), O.lastRenderedState = Le;
    }
    return [Le, ee];
  }
  function rh() {
  }
  function ha(f, p) {
    var O = In, ee = ga(), ye = p(), Le = !Ma(ee.memoizedState, ye);
    if (Le && (ee.memoizedState = ye, Da = !0), ee = ee.queue, Wl(Tu.bind(null, O, ee, f), [f]), ee.getSnapshot !== p || Le || ta !== null && ta.memoizedState.tag & 1) {
      if (O.flags |= 2048, sl(9, nh.bind(null, O, ee, ye, p), void 0, null), Rt === null) throw Error(pt(349));
      Ga & 30 || ih(O, p, ye);
    }
    return ye;
  }
  function ih(f, p, O) {
    f.flags |= 16384, f = { getSnapshot: p, value: O }, p = In.updateQueue, p === null ? (p = { lastEffect: null, stores: null }, In.updateQueue = p, p.stores = [f]) : (O = p.stores, O === null ? p.stores = [f] : O.push(f));
  }
  function nh(f, p, O, ee) {
    p.value = O, p.getSnapshot = ee, Cs(p) && _c(f);
  }
  function Tu(f, p, O) {
    return O(function() {
      Cs(p) && _c(f);
    });
  }
  function Cs(f) {
    var p = f.getSnapshot;
    f = f.value;
    try {
      var O = p();
      return !Ma(f, O);
    } catch {
      return !0;
    }
  }
  function _c(f) {
    var p = is(f, 1);
    p !== null && Di(p, f, 1, -1);
  }
  function Uo(f) {
    var p = Lo();
    return typeof f == "function" && (f = f()), p.memoizedState = p.baseState = f, f = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Gl, lastRenderedState: f }, p.queue = f, f = f.dispatch = vc.bind(null, In, f), [p.memoizedState, f];
  }
  function sl(f, p, O, ee) {
    return f = { tag: f, create: p, destroy: O, deps: ee, next: null }, p = In.updateQueue, p === null ? (p = { lastEffect: null, stores: null }, In.updateQueue = p, p.lastEffect = f.next = f) : (O = p.lastEffect, O === null ? p.lastEffect = f.next = f : (ee = O.next, O.next = f, f.next = ee, p.lastEffect = f)), f;
  }
  function Hl() {
    return ga().memoizedState;
  }
  function Mu(f, p, O, ee) {
    var ye = Lo();
    In.flags |= f, ye.memoizedState = sl(1 | p, O, void 0, ee === void 0 ? null : ee);
  }
  function Au(f, p, O, ee) {
    var ye = ga();
    ee = ee === void 0 ? null : ee;
    var Le = void 0;
    if (Dn !== null) {
      var ot = Dn.memoizedState;
      if (Le = ot.destroy, ee !== null && dc(ee, ot.deps)) {
        ye.memoizedState = sl(p, O, Le, ee);
        return;
      }
    }
    In.flags |= f, ye.memoizedState = sl(1 | p, O, Le, ee);
  }
  function Iu(f, p) {
    return Mu(8390656, 8, f, p);
  }
  function Wl(f, p) {
    return Au(2048, 8, f, p);
  }
  function ah(f, p) {
    return Au(4, 2, f, p);
  }
  function gc(f, p) {
    return Au(4, 4, f, p);
  }
  function qh(f, p) {
    if (typeof p == "function") return f = f(), p(f), function() {
      p(null);
    };
    if (p != null) return f = f(), p.current = f, function() {
      p.current = null;
    };
  }
  function oh(f, p, O) {
    return O = O != null ? O.concat([f]) : null, Au(4, 4, qh.bind(null, p, f), O);
  }
  function Zl() {
  }
  function $h(f, p) {
    var O = ga();
    p = p === void 0 ? null : p;
    var ee = O.memoizedState;
    return ee !== null && p !== null && dc(p, ee[1]) ? ee[0] : (O.memoizedState = [f, p], f);
  }
  function Xh(f, p) {
    var O = ga();
    p = p === void 0 ? null : p;
    var ee = O.memoizedState;
    return ee !== null && p !== null && dc(p, ee[1]) ? ee[0] : (f = f(), O.memoizedState = [f, p], f);
  }
  function Yh(f, p, O) {
    return Ga & 21 ? (Ma(O, p) || (O = Sa(), In.lanes |= O, gr |= O, f.baseState = !0), p) : (f.baseState && (f.baseState = !1, Da = !0), f.memoizedState = O);
  }
  function Cf(f, p) {
    var O = on;
    on = O !== 0 && 4 > O ? O : 4, f(!0);
    var ee = eh.transition;
    eh.transition = {};
    try {
      f(!1), p();
    } finally {
      on = O, eh.transition = ee;
    }
  }
  function Kh() {
    return ga().memoizedState;
  }
  function yc(f, p, O) {
    var ee = xi(f);
    if (O = { lane: ee, action: O, hasEagerState: !1, eagerState: null, next: null }, Ha(f)) Cu(p, O);
    else if (O = Kt(f, p, O, ee), O !== null) {
      var ye = $i();
      Di(O, f, ee, ye), Jh(O, p, ee);
    }
  }
  function vc(f, p, O) {
    var ee = xi(f), ye = { lane: ee, action: O, hasEagerState: !1, eagerState: null, next: null };
    if (Ha(f)) Cu(p, ye);
    else {
      var Le = f.alternate;
      if (f.lanes === 0 && (Le === null || Le.lanes === 0) && (Le = p.lastRenderedReducer, Le !== null)) try {
        var ot = p.lastRenderedState, Ht = Le(ot, O);
        if (ye.hasEagerState = !0, ye.eagerState = Ht, Ma(Ht, ot)) {
          var nr = p.interleaved;
          nr === null ? (ye.next = ye, vn(p)) : (ye.next = nr.next, nr.next = ye), p.interleaved = ye;
          return;
        }
      } catch {
      } finally {
      }
      O = Kt(f, p, ye, ee), O !== null && (ye = $i(), Di(O, f, ee, ye), Jh(O, p, ee));
    }
  }
  function Ha(f) {
    var p = f.alternate;
    return f === In || p !== null && p === In;
  }
  function Cu(f, p) {
    ro = ol = !0;
    var O = f.pending;
    O === null ? p.next = p : (p.next = O.next, O.next = p), f.pending = p;
  }
  function Jh(f, p, O) {
    if (O & 4194240) {
      var ee = p.lanes;
      ee &= f.pendingLanes, O |= ee, p.lanes = O, co(f, O);
    }
  }
  var sh = { readContext: Nr, useCallback: ca, useContext: ca, useEffect: ca, useImperativeHandle: ca, useInsertionEffect: ca, useLayoutEffect: ca, useMemo: ca, useReducer: ca, useRef: ca, useState: ca, useDebugValue: ca, useDeferredValue: ca, useTransition: ca, useMutableSource: ca, useSyncExternalStore: ca, useId: ca, unstable_isNewReconciler: !1 }, pd = { readContext: Nr, useCallback: function(f, p) {
    return Lo().memoizedState = [f, p === void 0 ? null : p], f;
  }, useContext: Nr, useEffect: Iu, useImperativeHandle: function(f, p, O) {
    return O = O != null ? O.concat([f]) : null, Mu(
      4194308,
      4,
      qh.bind(null, p, f),
      O
    );
  }, useLayoutEffect: function(f, p) {
    return Mu(4194308, 4, f, p);
  }, useInsertionEffect: function(f, p) {
    return Mu(4, 2, f, p);
  }, useMemo: function(f, p) {
    var O = Lo();
    return p = p === void 0 ? null : p, f = f(), O.memoizedState = [f, p], f;
  }, useReducer: function(f, p, O) {
    var ee = Lo();
    return p = O !== void 0 ? O(p) : p, ee.memoizedState = ee.baseState = p, f = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: f, lastRenderedState: p }, ee.queue = f, f = f.dispatch = yc.bind(null, In, f), [ee.memoizedState, f];
  }, useRef: function(f) {
    var p = Lo();
    return f = { current: f }, p.memoizedState = f;
  }, useState: Uo, useDebugValue: Zl, useDeferredValue: function(f) {
    return Lo().memoizedState = f;
  }, useTransition: function() {
    var f = Uo(!1), p = f[0];
    return f = Cf.bind(null, f[1]), Lo().memoizedState = f, [p, f];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(f, p, O) {
    var ee = In, ye = Lo();
    if (Fn) {
      if (O === void 0) throw Error(pt(407));
      O = O();
    } else {
      if (O = p(), Rt === null) throw Error(pt(349));
      Ga & 30 || ih(ee, p, O);
    }
    ye.memoizedState = O;
    var Le = { value: O, getSnapshot: p };
    return ye.queue = Le, Iu(Tu.bind(
      null,
      ee,
      Le,
      f
    ), [f]), ee.flags |= 2048, sl(9, nh.bind(null, ee, Le, O, p), void 0, null), O;
  }, useId: function() {
    var f = Lo(), p = Rt.identifierPrefix;
    if (Fn) {
      var O = Ra, ee = Fo;
      O = (ee & ~(1 << 32 - sa(ee) - 1)).toString(32) + O, p = ":" + p + "R" + O, O = ra++, 0 < O && (p += "H" + O.toString(32)), p += ":";
    } else O = th++, p = ":" + p + "r" + O.toString(32) + ":";
    return f.memoizedState = p;
  }, unstable_isNewReconciler: !1 }, Nn = {
    readContext: Nr,
    useCallback: $h,
    useContext: Nr,
    useEffect: Wl,
    useImperativeHandle: oh,
    useInsertionEffect: ah,
    useLayoutEffect: gc,
    useMemo: Xh,
    useReducer: Su,
    useRef: Hl,
    useState: function() {
      return Su(Gl);
    },
    useDebugValue: Zl,
    useDeferredValue: function(f) {
      var p = ga();
      return Yh(p, Dn.memoizedState, f);
    },
    useTransition: function() {
      var f = Su(Gl)[0], p = ga().memoizedState;
      return [f, p];
    },
    useMutableSource: rh,
    useSyncExternalStore: ha,
    useId: Kh,
    unstable_isNewReconciler: !1
  }, lh = { readContext: Nr, useCallback: $h, useContext: Nr, useEffect: Wl, useImperativeHandle: oh, useInsertionEffect: ah, useLayoutEffect: gc, useMemo: Xh, useReducer: mc, useRef: Hl, useState: function() {
    return mc(Gl);
  }, useDebugValue: Zl, useDeferredValue: function(f) {
    var p = ga();
    return Dn === null ? p.memoizedState = f : Yh(p, Dn.memoizedState, f);
  }, useTransition: function() {
    var f = mc(Gl)[0], p = ga().memoizedState;
    return [f, p];
  }, useMutableSource: rh, useSyncExternalStore: ha, useId: Kh, unstable_isNewReconciler: !1 };
  function jo(f, p) {
    if (f && f.defaultProps) {
      p = De({}, p), f = f.defaultProps;
      for (var O in f) p[O] === void 0 && (p[O] = f[O]);
      return p;
    }
    return p;
  }
  function xc(f, p, O, ee) {
    p = f.memoizedState, O = O(ee, p), O = O == null ? p : De({}, p, O), f.memoizedState = O, f.lanes === 0 && (f.updateQueue.baseState = O);
  }
  var ll = { isMounted: function(f) {
    return (f = f._reactInternals) ? ft(f) === f : !1;
  }, enqueueSetState: function(f, p, O) {
    f = f._reactInternals;
    var ee = $i(), ye = xi(f), Le = ns(ee, ye);
    Le.payload = p, O != null && (Le.callback = O), p = Ms(f, Le, ye), p !== null && (Di(p, f, ye, ee), As(p, f, ye));
  }, enqueueReplaceState: function(f, p, O) {
    f = f._reactInternals;
    var ee = $i(), ye = xi(f), Le = ns(ee, ye);
    Le.tag = 1, Le.payload = p, O != null && (Le.callback = O), p = Ms(f, Le, ye), p !== null && (Di(p, f, ye, ee), As(p, f, ye));
  }, enqueueForceUpdate: function(f, p) {
    f = f._reactInternals;
    var O = $i(), ee = xi(f), ye = ns(O, ee);
    ye.tag = 2, p != null && (ye.callback = p), p = Ms(f, ye, ee), p !== null && (Di(p, f, ee, O), As(p, f, ee));
  } };
  function Qh(f, p, O, ee, ye, Le, ot) {
    return f = f.stateNode, typeof f.shouldComponentUpdate == "function" ? f.shouldComponentUpdate(ee, Le, ot) : p.prototype && p.prototype.isPureReactComponent ? !Ju(O, ee) || !Ju(ye, Le) : !0;
  }
  function Pu(f, p, O) {
    var ee = !1, ye = Co, Le = p.contextType;
    return typeof Le == "object" && Le !== null ? Le = Nr(Le) : (ye = Qa(p) ? Ss : ba.current, ee = p.contextTypes, Le = (ee = ee != null) ? Bo(f, ye) : Co), p = new p(O, Le), f.memoizedState = p.state !== null && p.state !== void 0 ? p.state : null, p.updater = ll, f.stateNode = p, p._reactInternals = f, ee && (f = f.stateNode, f.__reactInternalMemoizedUnmaskedChildContext = ye, f.__reactInternalMemoizedMaskedChildContext = Le), p;
  }
  function bc(f, p, O, ee) {
    f = p.state, typeof p.componentWillReceiveProps == "function" && p.componentWillReceiveProps(O, ee), typeof p.UNSAFE_componentWillReceiveProps == "function" && p.UNSAFE_componentWillReceiveProps(O, ee), p.state !== f && ll.enqueueReplaceState(p, p.state, null);
  }
  function Do(f, p, O, ee) {
    var ye = f.stateNode;
    ye.props = O, ye.state = f.memoizedState, ye.refs = {}, fc(f);
    var Le = p.contextType;
    typeof Le == "object" && Le !== null ? ye.context = Nr(Le) : (Le = Qa(p) ? Ss : ba.current, ye.context = Bo(f, Le)), ye.state = f.memoizedState, Le = p.getDerivedStateFromProps, typeof Le == "function" && (xc(f, p, Le, O), ye.state = f.memoizedState), typeof p.getDerivedStateFromProps == "function" || typeof ye.getSnapshotBeforeUpdate == "function" || typeof ye.UNSAFE_componentWillMount != "function" && typeof ye.componentWillMount != "function" || (p = ye.state, typeof ye.componentWillMount == "function" && ye.componentWillMount(), typeof ye.UNSAFE_componentWillMount == "function" && ye.UNSAFE_componentWillMount(), p !== ye.state && ll.enqueueReplaceState(ye, ye.state, null), Kc(f, O, ye, ee), ye.state = f.memoizedState), typeof ye.componentDidMount == "function" && (f.flags |= 4194308);
  }
  function os(f, p) {
    try {
      var O = "", ee = p;
      do
        O += je(ee), ee = ee.return;
      while (ee);
      var ye = O;
    } catch (Le) {
      ye = `
Error generating stack: ` + Le.message + `
` + Le.stack;
    }
    return { value: f, source: p, stack: ye, digest: null };
  }
  function kn(f, p, O) {
    return { value: f, source: null, stack: O ?? null, digest: p ?? null };
  }
  function io(f, p) {
    try {
      console.error(p.value);
    } catch (O) {
      setTimeout(function() {
        throw O;
      });
    }
  }
  var Ru = typeof WeakMap == "function" ? WeakMap : Map;
  function Lu(f, p, O) {
    O = ns(-1, O), O.tag = 3, O.payload = { element: null };
    var ee = p.value;
    return O.callback = function() {
      Cr || (Cr = !0, Hr = ee), io(f, p);
    }, O;
  }
  function ef(f, p, O) {
    O = ns(-1, O), O.tag = 3;
    var ee = f.type.getDerivedStateFromError;
    if (typeof ee == "function") {
      var ye = p.value;
      O.payload = function() {
        return ee(ye);
      }, O.callback = function() {
        io(f, p);
      };
    }
    var Le = f.stateNode;
    return Le !== null && typeof Le.componentDidCatch == "function" && (O.callback = function() {
      io(f, p), typeof ee != "function" && (Zr === null ? Zr = /* @__PURE__ */ new Set([this]) : Zr.add(this));
      var ot = p.stack;
      this.componentDidCatch(p.value, { componentStack: ot !== null ? ot : "" });
    }), O;
  }
  function tf(f, p, O) {
    var ee = f.pingCache;
    if (ee === null) {
      ee = f.pingCache = new Ru();
      var ye = /* @__PURE__ */ new Set();
      ee.set(p, ye);
    } else ye = ee.get(p), ye === void 0 && (ye = /* @__PURE__ */ new Set(), ee.set(p, ye));
    ye.has(O) || (ye.add(O), f = Yl.bind(null, f, p, O), p.then(f, f));
  }
  function Du(f) {
    do {
      var p;
      if ((p = f.tag === 13) && (p = f.memoizedState, p = p !== null ? p.dehydrated !== null : !0), p) return f;
      f = f.return;
    } while (f !== null);
    return null;
  }
  function uh(f, p, O, ee, ye) {
    return f.mode & 1 ? (f.flags |= 65536, f.lanes = ye, f) : (f === p ? f.flags |= 65536 : (f.flags |= 128, O.flags |= 131072, O.flags &= -52805, O.tag === 1 && (O.alternate === null ? O.tag = 17 : (p = ns(-1, 1), p.tag = 2, Ms(O, p, 1))), O.lanes |= 1), f);
  }
  var md = B.ReactCurrentOwner, Da = !1;
  function Ia(f, p, O, ee) {
    p.child = f === null ? hc(p, null, O, ee) : sn(p, f.child, O, ee);
  }
  function ul(f, p, O, ee, ye) {
    O = O.render;
    var Le = p.ref;
    return Mr(p, ye), ee = pc(f, p, O, ee, Le, ye), O = Is(), f !== null && !Da ? (p.updateQueue = f.updateQueue, p.flags &= -2053, f.lanes &= ~ye, ao(f, p, ye)) : (Fn && O && uc(p), p.flags |= 1, Ia(f, p, ee, ye), p.child);
  }
  function cl(f, p, O, ee, ye) {
    if (f === null) {
      var Le = O.type;
      return typeof Le == "function" && !_d(Le) && Le.defaultProps === void 0 && O.compare === null && O.defaultProps === void 0 ? (p.tag = 15, p.type = Le, ss(f, p, Le, ee, ye)) : (f = nf(O.type, null, ee, p, p.mode, ye), f.ref = p.ref, f.return = p, p.child = f);
    }
    if (Le = f.child, !(f.lanes & ye)) {
      var ot = Le.memoizedProps;
      if (O = O.compare, O = O !== null ? O : Ju, O(ot, ee) && f.ref === p.ref) return ao(f, p, ye);
    }
    return p.flags |= 1, f = Jl(Le, ee), f.ref = p.ref, f.return = p, p.child = f;
  }
  function ss(f, p, O, ee, ye) {
    if (f !== null) {
      var Le = f.memoizedProps;
      if (Ju(Le, ee) && f.ref === p.ref) if (Da = !1, p.pendingProps = ee = Le, (f.lanes & ye) !== 0) f.flags & 131072 && (Da = !0);
      else return p.lanes = f.lanes, ao(f, p, ye);
    }
    return Rs(f, p, O, ee, ye);
  }
  function ko(f, p, O) {
    var ee = p.pendingProps, ye = ee.children, Le = f !== null ? f.memoizedState : null;
    if (ee.mode === "hidden") if (!(p.mode & 1)) p.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Tn(sr, or), or |= O;
    else {
      if (!(O & 1073741824)) return f = Le !== null ? Le.baseLanes | O : O, p.lanes = p.childLanes = 1073741824, p.memoizedState = { baseLanes: f, cachePool: null, transitions: null }, p.updateQueue = null, Tn(sr, or), or |= f, null;
      p.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ee = Le !== null ? Le.baseLanes : O, Tn(sr, or), or |= ee;
    }
    else Le !== null ? (ee = Le.baseLanes | O, p.memoizedState = null) : ee = O, Tn(sr, or), or |= ee;
    return Ia(f, p, ye, O), p.child;
  }
  function Ps(f, p) {
    var O = p.ref;
    (f === null && O !== null || f !== null && f.ref !== O) && (p.flags |= 512, p.flags |= 2097152);
  }
  function Rs(f, p, O, ee, ye) {
    var Le = Qa(O) ? Ss : ba.current;
    return Le = Bo(p, Le), Mr(p, ye), O = pc(f, p, O, ee, Le, ye), ee = Is(), f !== null && !Da ? (p.updateQueue = f.updateQueue, p.flags &= -2053, f.lanes &= ~ye, ao(f, p, ye)) : (Fn && ee && uc(p), p.flags |= 1, Ia(f, p, O, ye), p.child);
  }
  function Ls(f, p, O, ee, ye) {
    if (Qa(O)) {
      var Le = !0;
      Rl(p);
    } else Le = !1;
    if (Mr(p, ye), p.stateNode === null) ka(f, p), Pu(p, O, ee), Do(p, O, ee, ye), ee = !0;
    else if (f === null) {
      var ot = p.stateNode, Ht = p.memoizedProps;
      ot.props = Ht;
      var nr = ot.context, Er = O.contextType;
      typeof Er == "object" && Er !== null ? Er = Nr(Er) : (Er = Qa(O) ? Ss : ba.current, Er = Bo(p, Er));
      var Jr = O.getDerivedStateFromProps, ei = typeof Jr == "function" || typeof ot.getSnapshotBeforeUpdate == "function";
      ei || typeof ot.UNSAFE_componentWillReceiveProps != "function" && typeof ot.componentWillReceiveProps != "function" || (Ht !== ee || nr !== Er) && bc(p, ot, ee, Er), No = !1;
      var Qr = p.memoizedState;
      ot.state = Qr, Kc(p, ee, ot, ye), nr = p.memoizedState, Ht !== ee || Qr !== nr || Ja.current || No ? (typeof Jr == "function" && (xc(p, O, Jr, ee), nr = p.memoizedState), (Ht = No || Qh(p, O, Ht, ee, Qr, nr, Er)) ? (ei || typeof ot.UNSAFE_componentWillMount != "function" && typeof ot.componentWillMount != "function" || (typeof ot.componentWillMount == "function" && ot.componentWillMount(), typeof ot.UNSAFE_componentWillMount == "function" && ot.UNSAFE_componentWillMount()), typeof ot.componentDidMount == "function" && (p.flags |= 4194308)) : (typeof ot.componentDidMount == "function" && (p.flags |= 4194308), p.memoizedProps = ee, p.memoizedState = nr), ot.props = ee, ot.state = nr, ot.context = Er, ee = Ht) : (typeof ot.componentDidMount == "function" && (p.flags |= 4194308), ee = !1);
    } else {
      ot = p.stateNode, Wh(f, p), Ht = p.memoizedProps, Er = p.type === p.elementType ? Ht : jo(p.type, Ht), ot.props = Er, ei = p.pendingProps, Qr = ot.context, nr = O.contextType, typeof nr == "object" && nr !== null ? nr = Nr(nr) : (nr = Qa(O) ? Ss : ba.current, nr = Bo(p, nr));
      var wi = O.getDerivedStateFromProps;
      (Jr = typeof wi == "function" || typeof ot.getSnapshotBeforeUpdate == "function") || typeof ot.UNSAFE_componentWillReceiveProps != "function" && typeof ot.componentWillReceiveProps != "function" || (Ht !== ei || Qr !== nr) && bc(p, ot, ee, nr), No = !1, Qr = p.memoizedState, ot.state = Qr, Kc(p, ee, ot, ye);
      var Ei = p.memoizedState;
      Ht !== ei || Qr !== Ei || Ja.current || No ? (typeof wi == "function" && (xc(p, O, wi, ee), Ei = p.memoizedState), (Er = No || Qh(p, O, Er, ee, Qr, Ei, nr) || !1) ? (Jr || typeof ot.UNSAFE_componentWillUpdate != "function" && typeof ot.componentWillUpdate != "function" || (typeof ot.componentWillUpdate == "function" && ot.componentWillUpdate(ee, Ei, nr), typeof ot.UNSAFE_componentWillUpdate == "function" && ot.UNSAFE_componentWillUpdate(ee, Ei, nr)), typeof ot.componentDidUpdate == "function" && (p.flags |= 4), typeof ot.getSnapshotBeforeUpdate == "function" && (p.flags |= 1024)) : (typeof ot.componentDidUpdate != "function" || Ht === f.memoizedProps && Qr === f.memoizedState || (p.flags |= 4), typeof ot.getSnapshotBeforeUpdate != "function" || Ht === f.memoizedProps && Qr === f.memoizedState || (p.flags |= 1024), p.memoizedProps = ee, p.memoizedState = Ei), ot.props = ee, ot.state = Ei, ot.context = nr, ee = Er) : (typeof ot.componentDidUpdate != "function" || Ht === f.memoizedProps && Qr === f.memoizedState || (p.flags |= 4), typeof ot.getSnapshotBeforeUpdate != "function" || Ht === f.memoizedProps && Qr === f.memoizedState || (p.flags |= 1024), ee = !1);
    }
    return rf(f, p, O, ee, Le, ye);
  }
  function rf(f, p, O, ee, ye, Le) {
    Ps(f, p);
    var ot = (p.flags & 128) !== 0;
    if (!ee && !ot) return ye && Ll(p, O, !1), ao(f, p, Le);
    ee = p.stateNode, md.current = p;
    var Ht = ot && typeof O.getDerivedStateFromError != "function" ? null : ee.render();
    return p.flags |= 1, f !== null && ot ? (p.child = sn(p, f.child, null, Le), p.child = sn(p, null, Ht, Le)) : Ia(f, p, Ht, Le), p.memoizedState = ee.state, ye && Ll(p, O, !0), p.child;
  }
  function Pf(f) {
    var p = f.stateNode;
    p.pendingContext ? Nh(f, p.pendingContext, p.pendingContext !== p.context) : p.context && Nh(f, p.context, !1), Eu(f, p.containerInfo);
  }
  function Rf(f, p, O, ee, ye) {
    return yo(), cc(ye), p.flags |= 256, Ia(f, p, O, ee), p.child;
  }
  var ku = { dehydrated: null, treeContext: null, retryLane: 0 };
  function ch(f) {
    return { baseLanes: f, cachePool: null, transitions: null };
  }
  function Ca(f, p, O) {
    var ee = p.pendingProps, ye = rn.current, Le = !1, ot = (p.flags & 128) !== 0, Ht;
    if ((Ht = ot) || (Ht = f !== null && f.memoizedState === null ? !1 : (ye & 2) !== 0), Ht ? (Le = !0, p.flags &= -129) : (f === null || f.memoizedState !== null) && (ye |= 1), Tn(rn, ye & 1), f === null)
      return bu(p), f = p.memoizedState, f !== null && (f = f.dehydrated, f !== null) ? (p.mode & 1 ? f.data === "$!" ? p.lanes = 8 : p.lanes = 1073741824 : p.lanes = 1, null) : (ot = ee.children, f = ee.fallback, Le ? (ee = p.mode, Le = p.child, ot = { mode: "hidden", children: ot }, !(ee & 1) && Le !== null ? (Le.childLanes = 0, Le.pendingProps = ot) : Le = af(ot, ee, 0, null), f = Fu(f, ee, O, null), Le.return = p, f.return = p, Le.sibling = f, p.child = Le, p.child.memoizedState = ch(O), p.memoizedState = ku, f) : hl(p, ot));
    if (ye = f.memoizedState, ye !== null && (Ht = ye.dehydrated, Ht !== null)) return Lf(f, p, ot, ee, Ht, ye, O);
    if (Le) {
      Le = ee.fallback, ot = p.mode, ye = f.child, Ht = ye.sibling;
      var nr = { mode: "hidden", children: ee.children };
      return !(ot & 1) && p.child !== ye ? (ee = p.child, ee.childLanes = 0, ee.pendingProps = nr, p.deletions = null) : (ee = Jl(ye, nr), ee.subtreeFlags = ye.subtreeFlags & 14680064), Ht !== null ? Le = Jl(Ht, Le) : (Le = Fu(Le, ot, O, null), Le.flags |= 2), Le.return = p, ee.return = p, ee.sibling = Le, p.child = ee, ee = Le, Le = p.child, ot = f.child.memoizedState, ot = ot === null ? ch(O) : { baseLanes: ot.baseLanes | O, cachePool: null, transitions: ot.transitions }, Le.memoizedState = ot, Le.childLanes = f.childLanes & ~O, p.memoizedState = ku, ee;
    }
    return Le = f.child, f = Le.sibling, ee = Jl(Le, { mode: "visible", children: ee.children }), !(p.mode & 1) && (ee.lanes = O), ee.return = p, ee.sibling = null, f !== null && (O = p.deletions, O === null ? (p.deletions = [f], p.flags |= 16) : O.push(f)), p.child = ee, p.memoizedState = null, ee;
  }
  function hl(f, p) {
    return p = af({ mode: "visible", children: p }, f.mode, 0, null), p.return = f, f.child = p;
  }
  function wc(f, p, O, ee) {
    return ee !== null && cc(ee), sn(p, f.child, null, O), f = hl(p, p.pendingProps.children), f.flags |= 2, p.memoizedState = null, f;
  }
  function Lf(f, p, O, ee, ye, Le, ot) {
    if (O)
      return p.flags & 256 ? (p.flags &= -257, ee = kn(Error(pt(422))), wc(f, p, ot, ee)) : p.memoizedState !== null ? (p.child = f.child, p.flags |= 128, null) : (Le = ee.fallback, ye = p.mode, ee = af({ mode: "visible", children: ee.children }, ye, 0, null), Le = Fu(Le, ye, ot, null), Le.flags |= 2, ee.return = p, Le.return = p, ee.sibling = Le, p.child = ee, p.mode & 1 && sn(p, f.child, null, ot), p.child.memoizedState = ch(ot), p.memoizedState = ku, Le);
    if (!(p.mode & 1)) return wc(f, p, ot, null);
    if (ye.data === "$!") {
      if (ee = ye.nextSibling && ye.nextSibling.dataset, ee) var Ht = ee.dgst;
      return ee = Ht, Le = Error(pt(419)), ee = kn(Le, ee, void 0), wc(f, p, ot, ee);
    }
    if (Ht = (ot & f.childLanes) !== 0, Da || Ht) {
      if (ee = Rt, ee !== null) {
        switch (ot & -ot) {
          case 4:
            ye = 2;
            break;
          case 16:
            ye = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            ye = 32;
            break;
          case 536870912:
            ye = 268435456;
            break;
          default:
            ye = 0;
        }
        ye = ye & (ee.suspendedLanes | ot) ? 0 : ye, ye !== 0 && ye !== Le.retryLane && (Le.retryLane = ye, is(f, ye), Di(ee, f, ye, -1));
      }
      return Vi(), ee = kn(Error(pt(421))), wc(f, p, ot, ee);
    }
    return ye.data === "$?" ? (p.flags |= 128, p.child = f.child, p = Kl.bind(null, f), ye._reactRetry = p, null) : (f = Le.treeContext, La = Ys(ye.nextSibling), mo = p, Fn = !0, _o = null, f !== null && (Ua[Gr++] = Fo, Ua[Gr++] = Ra, Ua[Gr++] = Ts, Fo = f.id, Ra = f.overflow, Ts = p), p = hl(p, ee.children), p.flags |= 4096, p);
  }
  function ql(f, p, O) {
    f.lanes |= p;
    var ee = f.alternate;
    ee !== null && (ee.lanes |= p), nl(f.return, p, O);
  }
  function zu(f, p, O, ee, ye) {
    var Le = f.memoizedState;
    Le === null ? f.memoizedState = { isBackwards: p, rendering: null, renderingStartTime: 0, last: ee, tail: O, tailMode: ye } : (Le.isBackwards = p, Le.rendering = null, Le.renderingStartTime = 0, Le.last = ee, Le.tail = O, Le.tailMode = ye);
  }
  function no(f, p, O) {
    var ee = p.pendingProps, ye = ee.revealOrder, Le = ee.tail;
    if (Ia(f, p, ee.children, O), ee = rn.current, ee & 2) ee = ee & 1 | 2, p.flags |= 128;
    else {
      if (f !== null && f.flags & 128) e: for (f = p.child; f !== null; ) {
        if (f.tag === 13) f.memoizedState !== null && ql(f, O, p);
        else if (f.tag === 19) ql(f, O, p);
        else if (f.child !== null) {
          f.child.return = f, f = f.child;
          continue;
        }
        if (f === p) break e;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === p) break e;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      ee &= 1;
    }
    if (Tn(rn, ee), !(p.mode & 1)) p.memoizedState = null;
    else switch (ye) {
      case "forwards":
        for (O = p.child, ye = null; O !== null; ) f = O.alternate, f !== null && Qc(f) === null && (ye = O), O = O.sibling;
        O = ye, O === null ? (ye = p.child, p.child = null) : (ye = O.sibling, O.sibling = null), zu(p, !1, ye, O, Le);
        break;
      case "backwards":
        for (O = null, ye = p.child, p.child = null; ye !== null; ) {
          if (f = ye.alternate, f !== null && Qc(f) === null) {
            p.child = ye;
            break;
          }
          f = ye.sibling, ye.sibling = O, O = ye, ye = f;
        }
        zu(p, !0, O, null, Le);
        break;
      case "together":
        zu(p, !1, null, null, void 0);
        break;
      default:
        p.memoizedState = null;
    }
    return p.child;
  }
  function ka(f, p) {
    !(p.mode & 1) && f !== null && (f.alternate = null, p.alternate = null, p.flags |= 2);
  }
  function ao(f, p, O) {
    if (f !== null && (p.dependencies = f.dependencies), gr |= p.lanes, !(O & p.childLanes)) return null;
    if (f !== null && p.child !== f.child) throw Error(pt(153));
    if (p.child !== null) {
      for (f = p.child, O = Jl(f, f.pendingProps), p.child = O, O.return = p; f.sibling !== null; ) f = f.sibling, O = O.sibling = Jl(f, f.pendingProps), O.return = p;
      O.sibling = null;
    }
    return p.child;
  }
  function $l(f, p, O) {
    switch (p.tag) {
      case 3:
        Pf(p), yo();
        break;
      case 5:
        as(p);
        break;
      case 1:
        Qa(p.type) && Rl(p);
        break;
      case 4:
        Eu(p, p.stateNode.containerInfo);
        break;
      case 10:
        var ee = p.type._context, ye = p.memoizedProps.value;
        Tn(el, ee._currentValue), ee._currentValue = ye;
        break;
      case 13:
        if (ee = p.memoizedState, ee !== null)
          return ee.dehydrated !== null ? (Tn(rn, rn.current & 1), p.flags |= 128, null) : O & p.child.childLanes ? Ca(f, p, O) : (Tn(rn, rn.current & 1), f = ao(f, p, O), f !== null ? f.sibling : null);
        Tn(rn, rn.current & 1);
        break;
      case 19:
        if (ee = (O & p.childLanes) !== 0, f.flags & 128) {
          if (ee) return no(f, p, O);
          p.flags |= 128;
        }
        if (ye = p.memoizedState, ye !== null && (ye.rendering = null, ye.tail = null, ye.lastEffect = null), Tn(rn, rn.current), ee) break;
        return null;
      case 22:
      case 23:
        return p.lanes = 0, ko(f, p, O);
    }
    return ao(f, p, O);
  }
  var fl, Ec, qi, Ds;
  fl = function(f, p) {
    for (var O = p.child; O !== null; ) {
      if (O.tag === 5 || O.tag === 6) f.appendChild(O.stateNode);
      else if (O.tag !== 4 && O.child !== null) {
        O.child.return = O, O = O.child;
        continue;
      }
      if (O === p) break;
      for (; O.sibling === null; ) {
        if (O.return === null || O.return === p) return;
        O = O.return;
      }
      O.sibling.return = O.return, O = O.sibling;
    }
  }, Ec = function() {
  }, qi = function(f, p, O, ee) {
    var ye = f.memoizedProps;
    if (ye !== ee) {
      f = p.stateNode, vo(Aa.current);
      var Le = null;
      switch (O) {
        case "input":
          ye = Ye(f, ye), ee = Ye(f, ee), Le = [];
          break;
        case "select":
          ye = De({}, ye, { value: void 0 }), ee = De({}, ee, { value: void 0 }), Le = [];
          break;
        case "textarea":
          ye = Pe(f, ye), ee = Pe(f, ee), Le = [];
          break;
        default:
          typeof ye.onClick != "function" && typeof ee.onClick == "function" && (f.onclick = Al);
      }
      Vr(O, ee);
      var ot;
      O = null;
      for (Er in ye) if (!ee.hasOwnProperty(Er) && ye.hasOwnProperty(Er) && ye[Er] != null) if (Er === "style") {
        var Ht = ye[Er];
        for (ot in Ht) Ht.hasOwnProperty(ot) && (O || (O = {}), O[ot] = "");
      } else Er !== "dangerouslySetInnerHTML" && Er !== "children" && Er !== "suppressContentEditableWarning" && Er !== "suppressHydrationWarning" && Er !== "autoFocus" && (Ee.hasOwnProperty(Er) ? Le || (Le = []) : (Le = Le || []).push(Er, null));
      for (Er in ee) {
        var nr = ee[Er];
        if (Ht = ye != null ? ye[Er] : void 0, ee.hasOwnProperty(Er) && nr !== Ht && (nr != null || Ht != null)) if (Er === "style") if (Ht) {
          for (ot in Ht) !Ht.hasOwnProperty(ot) || nr && nr.hasOwnProperty(ot) || (O || (O = {}), O[ot] = "");
          for (ot in nr) nr.hasOwnProperty(ot) && Ht[ot] !== nr[ot] && (O || (O = {}), O[ot] = nr[ot]);
        } else O || (Le || (Le = []), Le.push(
          Er,
          O
        )), O = nr;
        else Er === "dangerouslySetInnerHTML" ? (nr = nr ? nr.__html : void 0, Ht = Ht ? Ht.__html : void 0, nr != null && Ht !== nr && (Le = Le || []).push(Er, nr)) : Er === "children" ? typeof nr != "string" && typeof nr != "number" || (Le = Le || []).push(Er, "" + nr) : Er !== "suppressContentEditableWarning" && Er !== "suppressHydrationWarning" && (Ee.hasOwnProperty(Er) ? (nr != null && Er === "onScroll" && Ln("scroll", f), Le || Ht === nr || (Le = [])) : (Le = Le || []).push(Er, nr));
      }
      O && (Le = Le || []).push("style", O);
      var Er = Le;
      (p.updateQueue = Er) && (p.flags |= 4);
    }
  }, Ds = function(f, p, O, ee) {
    O !== ee && (p.flags |= 4);
  };
  function Sc(f, p) {
    if (!Fn) switch (f.tailMode) {
      case "hidden":
        p = f.tail;
        for (var O = null; p !== null; ) p.alternate !== null && (O = p), p = p.sibling;
        O === null ? f.tail = null : O.sibling = null;
        break;
      case "collapsed":
        O = f.tail;
        for (var ee = null; O !== null; ) O.alternate !== null && (ee = O), O = O.sibling;
        ee === null ? p || f.tail === null ? f.tail = null : f.tail.sibling = null : ee.sibling = null;
    }
  }
  function za(f) {
    var p = f.alternate !== null && f.alternate.child === f.child, O = 0, ee = 0;
    if (p) for (var ye = f.child; ye !== null; ) O |= ye.lanes | ye.childLanes, ee |= ye.subtreeFlags & 14680064, ee |= ye.flags & 14680064, ye.return = f, ye = ye.sibling;
    else for (ye = f.child; ye !== null; ) O |= ye.lanes | ye.childLanes, ee |= ye.subtreeFlags, ee |= ye.flags, ye.return = f, ye = ye.sibling;
    return f.subtreeFlags |= ee, f.childLanes = O, p;
  }
  function hh(f, p, O) {
    var ee = p.pendingProps;
    switch (Vh(p), p.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return za(p), null;
      case 1:
        return Qa(p.type) && qc(), za(p), null;
      case 3:
        return ee = p.stateNode, Va(), Bn(Ja), Bn(ba), dn(), ee.pendingContext && (ee.context = ee.pendingContext, ee.pendingContext = null), (f === null || f.child === null) && (go(p) ? p.flags |= 4 : f === null || f.memoizedState.isDehydrated && !(p.flags & 256) || (p.flags |= 1024, _o !== null && (Qi(_o), _o = null))), Ec(f, p), za(p), null;
      case 5:
        Jc(p);
        var ye = vo(jl.current);
        if (O = p.type, f !== null && p.stateNode != null) qi(f, p, O, ee, ye), f.ref !== p.ref && (p.flags |= 512, p.flags |= 2097152);
        else {
          if (!ee) {
            if (p.stateNode === null) throw Error(pt(166));
            return za(p), null;
          }
          if (f = vo(Aa.current), go(p)) {
            ee = p.stateNode, O = p.type;
            var Le = p.memoizedProps;
            switch (ee[Mo] = p, ee[Cl] = Le, f = (p.mode & 1) !== 0, O) {
              case "dialog":
                Ln("cancel", ee), Ln("close", ee);
                break;
              case "iframe":
              case "object":
              case "embed":
                Ln("load", ee);
                break;
              case "video":
              case "audio":
                for (ye = 0; ye < rc.length; ye++) Ln(rc[ye], ee);
                break;
              case "source":
                Ln("error", ee);
                break;
              case "img":
              case "image":
              case "link":
                Ln(
                  "error",
                  ee
                ), Ln("load", ee);
                break;
              case "details":
                Ln("toggle", ee);
                break;
              case "input":
                qe(ee, Le), Ln("invalid", ee);
                break;
              case "select":
                ee._wrapperState = { wasMultiple: !!Le.multiple }, Ln("invalid", ee);
                break;
              case "textarea":
                he(ee, Le), Ln("invalid", ee);
            }
            Vr(O, Le), ye = null;
            for (var ot in Le) if (Le.hasOwnProperty(ot)) {
              var Ht = Le[ot];
              ot === "children" ? typeof Ht == "string" ? ee.textContent !== Ht && (Le.suppressHydrationWarning !== !0 && gu(ee.textContent, Ht, f), ye = ["children", Ht]) : typeof Ht == "number" && ee.textContent !== "" + Ht && (Le.suppressHydrationWarning !== !0 && gu(
                ee.textContent,
                Ht,
                f
              ), ye = ["children", "" + Ht]) : Ee.hasOwnProperty(ot) && Ht != null && ot === "onScroll" && Ln("scroll", ee);
            }
            switch (O) {
              case "input":
                Ct(ee), Ae(ee, Le, !0);
                break;
              case "textarea":
                Ct(ee), Xe(ee);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof Le.onClick == "function" && (ee.onclick = Al);
            }
            ee = ye, p.updateQueue = ee, ee !== null && (p.flags |= 4);
          } else {
            ot = ye.nodeType === 9 ? ye : ye.ownerDocument, f === "http://www.w3.org/1999/xhtml" && (f = bt(O)), f === "http://www.w3.org/1999/xhtml" ? O === "script" ? (f = ot.createElement("div"), f.innerHTML = "<script><\/script>", f = f.removeChild(f.firstChild)) : typeof ee.is == "string" ? f = ot.createElement(O, { is: ee.is }) : (f = ot.createElement(O), O === "select" && (ot = f, ee.multiple ? ot.multiple = !0 : ee.size && (ot.size = ee.size))) : f = ot.createElementNS(f, O), f[Mo] = p, f[Cl] = ee, fl(f, p, !1, !1), p.stateNode = f;
            e: {
              switch (ot = Te(O, ee), O) {
                case "dialog":
                  Ln("cancel", f), Ln("close", f), ye = ee;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Ln("load", f), ye = ee;
                  break;
                case "video":
                case "audio":
                  for (ye = 0; ye < rc.length; ye++) Ln(rc[ye], f);
                  ye = ee;
                  break;
                case "source":
                  Ln("error", f), ye = ee;
                  break;
                case "img":
                case "image":
                case "link":
                  Ln(
                    "error",
                    f
                  ), Ln("load", f), ye = ee;
                  break;
                case "details":
                  Ln("toggle", f), ye = ee;
                  break;
                case "input":
                  qe(f, ee), ye = Ye(f, ee), Ln("invalid", f);
                  break;
                case "option":
                  ye = ee;
                  break;
                case "select":
                  f._wrapperState = { wasMultiple: !!ee.multiple }, ye = De({}, ee, { value: void 0 }), Ln("invalid", f);
                  break;
                case "textarea":
                  he(f, ee), ye = Pe(f, ee), Ln("invalid", f);
                  break;
                default:
                  ye = ee;
              }
              Vr(O, ye), Ht = ye;
              for (Le in Ht) if (Ht.hasOwnProperty(Le)) {
                var nr = Ht[Le];
                Le === "style" ? Pr(f, nr) : Le === "dangerouslySetInnerHTML" ? (nr = nr ? nr.__html : void 0, nr != null && Sr(f, nr)) : Le === "children" ? typeof nr == "string" ? (O !== "textarea" || nr !== "") && Fr(f, nr) : typeof nr == "number" && Fr(f, "" + nr) : Le !== "suppressContentEditableWarning" && Le !== "suppressHydrationWarning" && Le !== "autoFocus" && (Ee.hasOwnProperty(Le) ? nr != null && Le === "onScroll" && Ln("scroll", f) : nr != null && b(f, Le, nr, ot));
              }
              switch (O) {
                case "input":
                  Ct(f), Ae(f, ee, !1);
                  break;
                case "textarea":
                  Ct(f), Xe(f);
                  break;
                case "option":
                  ee.value != null && f.setAttribute("value", "" + ct(ee.value));
                  break;
                case "select":
                  f.multiple = !!ee.multiple, Le = ee.value, Le != null ? We(f, !!ee.multiple, Le, !1) : ee.defaultValue != null && We(
                    f,
                    !!ee.multiple,
                    ee.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof ye.onClick == "function" && (f.onclick = Al);
              }
              switch (O) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  ee = !!ee.autoFocus;
                  break e;
                case "img":
                  ee = !0;
                  break e;
                default:
                  ee = !1;
              }
            }
            ee && (p.flags |= 4);
          }
          p.ref !== null && (p.flags |= 512, p.flags |= 2097152);
        }
        return za(p), null;
      case 6:
        if (f && p.stateNode != null) Ds(f, p, f.memoizedProps, ee);
        else {
          if (typeof ee != "string" && p.stateNode === null) throw Error(pt(166));
          if (O = vo(jl.current), vo(Aa.current), go(p)) {
            if (ee = p.stateNode, O = p.memoizedProps, ee[Mo] = p, (Le = ee.nodeValue !== O) && (f = mo, f !== null)) switch (f.tag) {
              case 3:
                gu(ee.nodeValue, O, (f.mode & 1) !== 0);
                break;
              case 5:
                f.memoizedProps.suppressHydrationWarning !== !0 && gu(ee.nodeValue, O, (f.mode & 1) !== 0);
            }
            Le && (p.flags |= 4);
          } else ee = (O.nodeType === 9 ? O : O.ownerDocument).createTextNode(ee), ee[Mo] = p, p.stateNode = ee;
        }
        return za(p), null;
      case 13:
        if (Bn(rn), ee = p.memoizedState, f === null || f.memoizedState !== null && f.memoizedState.dehydrated !== null) {
          if (Fn && La !== null && p.mode & 1 && !(p.flags & 128)) ja(), yo(), p.flags |= 98560, Le = !1;
          else if (Le = go(p), ee !== null && ee.dehydrated !== null) {
            if (f === null) {
              if (!Le) throw Error(pt(318));
              if (Le = p.memoizedState, Le = Le !== null ? Le.dehydrated : null, !Le) throw Error(pt(317));
              Le[Mo] = p;
            } else yo(), !(p.flags & 128) && (p.memoizedState = null), p.flags |= 4;
            za(p), Le = !1;
          } else _o !== null && (Qi(_o), _o = null), Le = !0;
          if (!Le) return p.flags & 65536 ? p : null;
        }
        return p.flags & 128 ? (p.lanes = O, p) : (ee = ee !== null, ee !== (f !== null && f.memoizedState !== null) && ee && (p.child.flags |= 8192, p.mode & 1 && (f === null || rn.current & 1 ? Bt === 0 && (Bt = 3) : Vi())), p.updateQueue !== null && (p.flags |= 4), za(p), null);
      case 4:
        return Va(), Ec(f, p), f === null && _u(p.stateNode.containerInfo), za(p), null;
      case 10:
        return il(p.type._context), za(p), null;
      case 17:
        return Qa(p.type) && qc(), za(p), null;
      case 19:
        if (Bn(rn), Le = p.memoizedState, Le === null) return za(p), null;
        if (ee = (p.flags & 128) !== 0, ot = Le.rendering, ot === null) if (ee) Sc(Le, !1);
        else {
          if (Bt !== 0 || f !== null && f.flags & 128) for (f = p.child; f !== null; ) {
            if (ot = Qc(f), ot !== null) {
              for (p.flags |= 128, Sc(Le, !1), ee = ot.updateQueue, ee !== null && (p.updateQueue = ee, p.flags |= 4), p.subtreeFlags = 0, ee = O, O = p.child; O !== null; ) Le = O, f = ee, Le.flags &= 14680066, ot = Le.alternate, ot === null ? (Le.childLanes = 0, Le.lanes = f, Le.child = null, Le.subtreeFlags = 0, Le.memoizedProps = null, Le.memoizedState = null, Le.updateQueue = null, Le.dependencies = null, Le.stateNode = null) : (Le.childLanes = ot.childLanes, Le.lanes = ot.lanes, Le.child = ot.child, Le.subtreeFlags = 0, Le.deletions = null, Le.memoizedProps = ot.memoizedProps, Le.memoizedState = ot.memoizedState, Le.updateQueue = ot.updateQueue, Le.type = ot.type, f = ot.dependencies, Le.dependencies = f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }), O = O.sibling;
              return Tn(rn, rn.current & 1 | 2), p.child;
            }
            f = f.sibling;
          }
          Le.tail !== null && qr() > hr && (p.flags |= 128, ee = !0, Sc(Le, !1), p.lanes = 4194304);
        }
        else {
          if (!ee) if (f = Qc(ot), f !== null) {
            if (p.flags |= 128, ee = !0, O = f.updateQueue, O !== null && (p.updateQueue = O, p.flags |= 4), Sc(Le, !0), Le.tail === null && Le.tailMode === "hidden" && !ot.alternate && !Fn) return za(p), null;
          } else 2 * qr() - Le.renderingStartTime > hr && O !== 1073741824 && (p.flags |= 128, ee = !0, Sc(Le, !1), p.lanes = 4194304);
          Le.isBackwards ? (ot.sibling = p.child, p.child = ot) : (O = Le.last, O !== null ? O.sibling = ot : p.child = ot, Le.last = ot);
        }
        return Le.tail !== null ? (p = Le.tail, Le.rendering = p, Le.tail = p.sibling, Le.renderingStartTime = qr(), p.sibling = null, O = rn.current, Tn(rn, ee ? O & 1 | 2 : O & 1), p) : (za(p), null);
      case 22:
      case 23:
        return va(), ee = p.memoizedState !== null, f !== null && f.memoizedState !== null !== ee && (p.flags |= 8192), ee && p.mode & 1 ? or & 1073741824 && (za(p), p.subtreeFlags & 6 && (p.flags |= 8192)) : za(p), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(pt(156, p.tag));
  }
  function ls(f, p) {
    switch (Vh(p), p.tag) {
      case 1:
        return Qa(p.type) && qc(), f = p.flags, f & 65536 ? (p.flags = f & -65537 | 128, p) : null;
      case 3:
        return Va(), Bn(Ja), Bn(ba), dn(), f = p.flags, f & 65536 && !(f & 128) ? (p.flags = f & -65537 | 128, p) : null;
      case 5:
        return Jc(p), null;
      case 13:
        if (Bn(rn), f = p.memoizedState, f !== null && f.dehydrated !== null) {
          if (p.alternate === null) throw Error(pt(340));
          yo();
        }
        return f = p.flags, f & 65536 ? (p.flags = f & -65537 | 128, p) : null;
      case 19:
        return Bn(rn), null;
      case 4:
        return Va(), null;
      case 10:
        return il(p.type._context), null;
      case 22:
      case 23:
        return va(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var oo = !1, xn = !1, so = typeof WeakSet == "function" ? WeakSet : Set, ci = null;
  function Xl(f, p) {
    var O = f.ref;
    if (O !== null) if (typeof O == "function") try {
      O(null);
    } catch (ee) {
      mn(f, p, ee);
    }
    else O.current = null;
  }
  function Cn(f, p, O) {
    try {
      O();
    } catch (ee) {
      mn(f, p, ee);
    }
  }
  var fh = !1;
  function Ou(f, p) {
    if (oc = Kn, f = Oh(), Ka(f)) {
      if ("selectionStart" in f) var O = { start: f.selectionStart, end: f.selectionEnd };
      else e: {
        O = (O = f.ownerDocument) && O.defaultView || window;
        var ee = O.getSelection && O.getSelection();
        if (ee && ee.rangeCount !== 0) {
          O = ee.anchorNode;
          var ye = ee.anchorOffset, Le = ee.focusNode;
          ee = ee.focusOffset;
          try {
            O.nodeType, Le.nodeType;
          } catch {
            O = null;
            break e;
          }
          var ot = 0, Ht = -1, nr = -1, Er = 0, Jr = 0, ei = f, Qr = null;
          t: for (; ; ) {
            for (var wi; ei !== O || ye !== 0 && ei.nodeType !== 3 || (Ht = ot + ye), ei !== Le || ee !== 0 && ei.nodeType !== 3 || (nr = ot + ee), ei.nodeType === 3 && (ot += ei.nodeValue.length), (wi = ei.firstChild) !== null; )
              Qr = ei, ei = wi;
            for (; ; ) {
              if (ei === f) break t;
              if (Qr === O && ++Er === ye && (Ht = ot), Qr === Le && ++Jr === ee && (nr = ot), (wi = ei.nextSibling) !== null) break;
              ei = Qr, Qr = ei.parentNode;
            }
            ei = wi;
          }
          O = Ht === -1 || nr === -1 ? null : { start: Ht, end: nr };
        } else O = null;
      }
      O = O || { start: 0, end: 0 };
    } else O = null;
    for (sc = { focusedElem: f, selectionRange: O }, Kn = !1, ci = p; ci !== null; ) if (p = ci, f = p.child, (p.subtreeFlags & 1028) !== 0 && f !== null) f.return = p, ci = f;
    else for (; ci !== null; ) {
      p = ci;
      try {
        var Ei = p.alternate;
        if (p.flags & 1024) switch (p.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (Ei !== null) {
              var Ti = Ei.memoizedProps, na = Ei.memoizedState, _r = p.stateNode, lr = _r.getSnapshotBeforeUpdate(p.elementType === p.type ? Ti : jo(p.type, Ti), na);
              _r.__reactInternalSnapshotBeforeUpdate = lr;
            }
            break;
          case 3:
            var xr = p.stateNode.containerInfo;
            xr.nodeType === 1 ? xr.textContent = "" : xr.nodeType === 9 && xr.documentElement && xr.removeChild(xr.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(pt(163));
        }
      } catch (ai) {
        mn(p, p.return, ai);
      }
      if (f = p.sibling, f !== null) {
        f.return = p.return, ci = f;
        break;
      }
      ci = p.return;
    }
    return Ei = fh, fh = !1, Ei;
  }
  function l(f, p, O) {
    var ee = p.updateQueue;
    if (ee = ee !== null ? ee.lastEffect : null, ee !== null) {
      var ye = ee = ee.next;
      do {
        if ((ye.tag & f) === f) {
          var Le = ye.destroy;
          ye.destroy = void 0, Le !== void 0 && Cn(p, O, Le);
        }
        ye = ye.next;
      } while (ye !== ee);
    }
  }
  function t(f, p) {
    if (p = p.updateQueue, p = p !== null ? p.lastEffect : null, p !== null) {
      var O = p = p.next;
      do {
        if ((O.tag & f) === f) {
          var ee = O.create;
          O.destroy = ee();
        }
        O = O.next;
      } while (O !== p);
    }
  }
  function n(f) {
    var p = f.ref;
    if (p !== null) {
      var O = f.stateNode;
      switch (f.tag) {
        case 5:
          f = O;
          break;
        default:
          f = O;
      }
      typeof p == "function" ? p(f) : p.current = f;
    }
  }
  function u(f) {
    var p = f.alternate;
    p !== null && (f.alternate = null, u(p)), f.child = null, f.deletions = null, f.sibling = null, f.tag === 5 && (p = f.stateNode, p !== null && (delete p[Mo], delete p[Cl], delete p[Ks], delete p[Fh], delete p[Af])), f.stateNode = null, f.return = null, f.dependencies = null, f.memoizedProps = null, f.memoizedState = null, f.pendingProps = null, f.stateNode = null, f.updateQueue = null;
  }
  function d(f) {
    return f.tag === 5 || f.tag === 3 || f.tag === 4;
  }
  function _(f) {
    e: for (; ; ) {
      for (; f.sibling === null; ) {
        if (f.return === null || d(f.return)) return null;
        f = f.return;
      }
      for (f.sibling.return = f.return, f = f.sibling; f.tag !== 5 && f.tag !== 6 && f.tag !== 18; ) {
        if (f.flags & 2 || f.child === null || f.tag === 4) continue e;
        f.child.return = f, f = f.child;
      }
      if (!(f.flags & 2)) return f.stateNode;
    }
  }
  function v(f, p, O) {
    var ee = f.tag;
    if (ee === 5 || ee === 6) f = f.stateNode, p ? O.nodeType === 8 ? O.parentNode.insertBefore(f, p) : O.insertBefore(f, p) : (O.nodeType === 8 ? (p = O.parentNode, p.insertBefore(f, O)) : (p = O, p.appendChild(f)), O = O._reactRootContainer, O != null || p.onclick !== null || (p.onclick = Al));
    else if (ee !== 4 && (f = f.child, f !== null)) for (v(f, p, O), f = f.sibling; f !== null; ) v(f, p, O), f = f.sibling;
  }
  function L(f, p, O) {
    var ee = f.tag;
    if (ee === 5 || ee === 6) f = f.stateNode, p ? O.insertBefore(f, p) : O.appendChild(f);
    else if (ee !== 4 && (f = f.child, f !== null)) for (L(f, p, O), f = f.sibling; f !== null; ) L(f, p, O), f = f.sibling;
  }
  var G = null, X = !1;
  function K(f, p, O) {
    for (O = O.child; O !== null; ) ae(f, p, O), O = O.sibling;
  }
  function ae(f, p, O) {
    if (Bi && typeof Bi.onCommitFiberUnmount == "function") try {
      Bi.onCommitFiberUnmount(Wi, O);
    } catch {
    }
    switch (O.tag) {
      case 5:
        xn || Xl(O, p);
      case 6:
        var ee = G, ye = X;
        G = null, K(f, p, O), G = ee, X = ye, G !== null && (X ? (f = G, O = O.stateNode, f.nodeType === 8 ? f.parentNode.removeChild(O) : f.removeChild(O)) : G.removeChild(O.stateNode));
        break;
      case 18:
        G !== null && (X ? (f = G, O = O.stateNode, f.nodeType === 8 ? Bh(f.parentNode, O) : f.nodeType === 1 && Bh(f, O), Ya(f)) : Bh(G, O.stateNode));
        break;
      case 4:
        ee = G, ye = X, G = O.stateNode.containerInfo, X = !0, K(f, p, O), G = ee, X = ye;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!xn && (ee = O.updateQueue, ee !== null && (ee = ee.lastEffect, ee !== null))) {
          ye = ee = ee.next;
          do {
            var Le = ye, ot = Le.destroy;
            Le = Le.tag, ot !== void 0 && (Le & 2 || Le & 4) && Cn(O, p, ot), ye = ye.next;
          } while (ye !== ee);
        }
        K(f, p, O);
        break;
      case 1:
        if (!xn && (Xl(O, p), ee = O.stateNode, typeof ee.componentWillUnmount == "function")) try {
          ee.props = O.memoizedProps, ee.state = O.memoizedState, ee.componentWillUnmount();
        } catch (Ht) {
          mn(O, p, Ht);
        }
        K(f, p, O);
        break;
      case 21:
        K(f, p, O);
        break;
      case 22:
        O.mode & 1 ? (xn = (ee = xn) || O.memoizedState !== null, K(f, p, O), xn = ee) : K(f, p, O);
        break;
      default:
        K(f, p, O);
    }
  }
  function oe(f) {
    var p = f.updateQueue;
    if (p !== null) {
      f.updateQueue = null;
      var O = f.stateNode;
      O === null && (O = f.stateNode = new so()), p.forEach(function(ee) {
        var ye = Bu.bind(null, f, ee);
        O.has(ee) || (O.add(ee), ee.then(ye, ye));
      });
    }
  }
  function pe(f, p) {
    var O = p.deletions;
    if (O !== null) for (var ee = 0; ee < O.length; ee++) {
      var ye = O[ee];
      try {
        var Le = f, ot = p, Ht = ot;
        e: for (; Ht !== null; ) {
          switch (Ht.tag) {
            case 5:
              G = Ht.stateNode, X = !1;
              break e;
            case 3:
              G = Ht.stateNode.containerInfo, X = !0;
              break e;
            case 4:
              G = Ht.stateNode.containerInfo, X = !0;
              break e;
          }
          Ht = Ht.return;
        }
        if (G === null) throw Error(pt(160));
        ae(Le, ot, ye), G = null, X = !1;
        var nr = ye.alternate;
        nr !== null && (nr.return = null), ye.return = null;
      } catch (Er) {
        mn(ye, p, Er);
      }
    }
    if (p.subtreeFlags & 12854) for (p = p.child; p !== null; ) Be(p, f), p = p.sibling;
  }
  function Be(f, p) {
    var O = f.alternate, ee = f.flags;
    switch (f.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (pe(p, f), Re(f), ee & 4) {
          try {
            l(3, f, f.return), t(3, f);
          } catch (Ti) {
            mn(f, f.return, Ti);
          }
          try {
            l(5, f, f.return);
          } catch (Ti) {
            mn(f, f.return, Ti);
          }
        }
        break;
      case 1:
        pe(p, f), Re(f), ee & 512 && O !== null && Xl(O, O.return);
        break;
      case 5:
        if (pe(p, f), Re(f), ee & 512 && O !== null && Xl(O, O.return), f.flags & 32) {
          var ye = f.stateNode;
          try {
            Fr(ye, "");
          } catch (Ti) {
            mn(f, f.return, Ti);
          }
        }
        if (ee & 4 && (ye = f.stateNode, ye != null)) {
          var Le = f.memoizedProps, ot = O !== null ? O.memoizedProps : Le, Ht = f.type, nr = f.updateQueue;
          if (f.updateQueue = null, nr !== null) try {
            Ht === "input" && Le.type === "radio" && Le.name != null && rt(ye, Le), Te(Ht, ot);
            var Er = Te(Ht, Le);
            for (ot = 0; ot < nr.length; ot += 2) {
              var Jr = nr[ot], ei = nr[ot + 1];
              Jr === "style" ? Pr(ye, ei) : Jr === "dangerouslySetInnerHTML" ? Sr(ye, ei) : Jr === "children" ? Fr(ye, ei) : b(ye, Jr, ei, Er);
            }
            switch (Ht) {
              case "input":
                it(ye, Le);
                break;
              case "textarea":
                ie(ye, Le);
                break;
              case "select":
                var Qr = ye._wrapperState.wasMultiple;
                ye._wrapperState.wasMultiple = !!Le.multiple;
                var wi = Le.value;
                wi != null ? We(ye, !!Le.multiple, wi, !1) : Qr !== !!Le.multiple && (Le.defaultValue != null ? We(
                  ye,
                  !!Le.multiple,
                  Le.defaultValue,
                  !0
                ) : We(ye, !!Le.multiple, Le.multiple ? [] : "", !1));
            }
            ye[Cl] = Le;
          } catch (Ti) {
            mn(f, f.return, Ti);
          }
        }
        break;
      case 6:
        if (pe(p, f), Re(f), ee & 4) {
          if (f.stateNode === null) throw Error(pt(162));
          ye = f.stateNode, Le = f.memoizedProps;
          try {
            ye.nodeValue = Le;
          } catch (Ti) {
            mn(f, f.return, Ti);
          }
        }
        break;
      case 3:
        if (pe(p, f), Re(f), ee & 4 && O !== null && O.memoizedState.isDehydrated) try {
          Ya(p.containerInfo);
        } catch (Ti) {
          mn(f, f.return, Ti);
        }
        break;
      case 4:
        pe(p, f), Re(f);
        break;
      case 13:
        pe(p, f), Re(f), ye = f.child, ye.flags & 8192 && (Le = ye.memoizedState !== null, ye.stateNode.isHidden = Le, !Le || ye.alternate !== null && ye.alternate.memoizedState !== null || (mr = qr())), ee & 4 && oe(f);
        break;
      case 22:
        if (Jr = O !== null && O.memoizedState !== null, f.mode & 1 ? (xn = (Er = xn) || Jr, pe(p, f), xn = Er) : pe(p, f), Re(f), ee & 8192) {
          if (Er = f.memoizedState !== null, (f.stateNode.isHidden = Er) && !Jr && f.mode & 1) for (ci = f, Jr = f.child; Jr !== null; ) {
            for (ei = ci = Jr; ci !== null; ) {
              switch (Qr = ci, wi = Qr.child, Qr.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  l(4, Qr, Qr.return);
                  break;
                case 1:
                  Xl(Qr, Qr.return);
                  var Ei = Qr.stateNode;
                  if (typeof Ei.componentWillUnmount == "function") {
                    ee = Qr, O = Qr.return;
                    try {
                      p = ee, Ei.props = p.memoizedProps, Ei.state = p.memoizedState, Ei.componentWillUnmount();
                    } catch (Ti) {
                      mn(ee, O, Ti);
                    }
                  }
                  break;
                case 5:
                  Xl(Qr, Qr.return);
                  break;
                case 22:
                  if (Qr.memoizedState !== null) {
                    ut(ei);
                    continue;
                  }
              }
              wi !== null ? (wi.return = Qr, ci = wi) : ut(ei);
            }
            Jr = Jr.sibling;
          }
          e: for (Jr = null, ei = f; ; ) {
            if (ei.tag === 5) {
              if (Jr === null) {
                Jr = ei;
                try {
                  ye = ei.stateNode, Er ? (Le = ye.style, typeof Le.setProperty == "function" ? Le.setProperty("display", "none", "important") : Le.display = "none") : (Ht = ei.stateNode, nr = ei.memoizedProps.style, ot = nr != null && nr.hasOwnProperty("display") ? nr.display : null, Ht.style.display = Rr("display", ot));
                } catch (Ti) {
                  mn(f, f.return, Ti);
                }
              }
            } else if (ei.tag === 6) {
              if (Jr === null) try {
                ei.stateNode.nodeValue = Er ? "" : ei.memoizedProps;
              } catch (Ti) {
                mn(f, f.return, Ti);
              }
            } else if ((ei.tag !== 22 && ei.tag !== 23 || ei.memoizedState === null || ei === f) && ei.child !== null) {
              ei.child.return = ei, ei = ei.child;
              continue;
            }
            if (ei === f) break e;
            for (; ei.sibling === null; ) {
              if (ei.return === null || ei.return === f) break e;
              Jr === ei && (Jr = null), ei = ei.return;
            }
            Jr === ei && (Jr = null), ei.sibling.return = ei.return, ei = ei.sibling;
          }
        }
        break;
      case 19:
        pe(p, f), Re(f), ee & 4 && oe(f);
        break;
      case 21:
        break;
      default:
        pe(
          p,
          f
        ), Re(f);
    }
  }
  function Re(f) {
    var p = f.flags;
    if (p & 2) {
      try {
        e: {
          for (var O = f.return; O !== null; ) {
            if (d(O)) {
              var ee = O;
              break e;
            }
            O = O.return;
          }
          throw Error(pt(160));
        }
        switch (ee.tag) {
          case 5:
            var ye = ee.stateNode;
            ee.flags & 32 && (Fr(ye, ""), ee.flags &= -33);
            var Le = _(f);
            L(f, Le, ye);
            break;
          case 3:
          case 4:
            var ot = ee.stateNode.containerInfo, Ht = _(f);
            v(f, Ht, ot);
            break;
          default:
            throw Error(pt(161));
        }
      } catch (nr) {
        mn(f, f.return, nr);
      }
      f.flags &= -3;
    }
    p & 4096 && (f.flags &= -4097);
  }
  function Ge(f, p, O) {
    ci = f, Ve(f);
  }
  function Ve(f, p, O) {
    for (var ee = (f.mode & 1) !== 0; ci !== null; ) {
      var ye = ci, Le = ye.child;
      if (ye.tag === 22 && ee) {
        var ot = ye.memoizedState !== null || oo;
        if (!ot) {
          var Ht = ye.alternate, nr = Ht !== null && Ht.memoizedState !== null || xn;
          Ht = oo;
          var Er = xn;
          if (oo = ot, (xn = nr) && !Er) for (ci = ye; ci !== null; ) ot = ci, nr = ot.child, ot.tag === 22 && ot.memoizedState !== null ? st(ye) : nr !== null ? (nr.return = ot, ci = nr) : st(ye);
          for (; Le !== null; ) ci = Le, Ve(Le), Le = Le.sibling;
          ci = ye, oo = Ht, xn = Er;
        }
        et(f);
      } else ye.subtreeFlags & 8772 && Le !== null ? (Le.return = ye, ci = Le) : et(f);
    }
  }
  function et(f) {
    for (; ci !== null; ) {
      var p = ci;
      if (p.flags & 8772) {
        var O = p.alternate;
        try {
          if (p.flags & 8772) switch (p.tag) {
            case 0:
            case 11:
            case 15:
              xn || t(5, p);
              break;
            case 1:
              var ee = p.stateNode;
              if (p.flags & 4 && !xn) if (O === null) ee.componentDidMount();
              else {
                var ye = p.elementType === p.type ? O.memoizedProps : jo(p.type, O.memoizedProps);
                ee.componentDidUpdate(ye, O.memoizedState, ee.__reactInternalSnapshotBeforeUpdate);
              }
              var Le = p.updateQueue;
              Le !== null && Zh(p, Le, ee);
              break;
            case 3:
              var ot = p.updateQueue;
              if (ot !== null) {
                if (O = null, p.child !== null) switch (p.child.tag) {
                  case 5:
                    O = p.child.stateNode;
                    break;
                  case 1:
                    O = p.child.stateNode;
                }
                Zh(p, ot, O);
              }
              break;
            case 5:
              var Ht = p.stateNode;
              if (O === null && p.flags & 4) {
                O = Ht;
                var nr = p.memoizedProps;
                switch (p.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    nr.autoFocus && O.focus();
                    break;
                  case "img":
                    nr.src && (O.src = nr.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (p.memoizedState === null) {
                var Er = p.alternate;
                if (Er !== null) {
                  var Jr = Er.memoizedState;
                  if (Jr !== null) {
                    var ei = Jr.dehydrated;
                    ei !== null && Ya(ei);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(pt(163));
          }
          xn || p.flags & 512 && n(p);
        } catch (Qr) {
          mn(p, p.return, Qr);
        }
      }
      if (p === f) {
        ci = null;
        break;
      }
      if (O = p.sibling, O !== null) {
        O.return = p.return, ci = O;
        break;
      }
      ci = p.return;
    }
  }
  function ut(f) {
    for (; ci !== null; ) {
      var p = ci;
      if (p === f) {
        ci = null;
        break;
      }
      var O = p.sibling;
      if (O !== null) {
        O.return = p.return, ci = O;
        break;
      }
      ci = p.return;
    }
  }
  function st(f) {
    for (; ci !== null; ) {
      var p = ci;
      try {
        switch (p.tag) {
          case 0:
          case 11:
          case 15:
            var O = p.return;
            try {
              t(4, p);
            } catch (nr) {
              mn(p, O, nr);
            }
            break;
          case 1:
            var ee = p.stateNode;
            if (typeof ee.componentDidMount == "function") {
              var ye = p.return;
              try {
                ee.componentDidMount();
              } catch (nr) {
                mn(p, ye, nr);
              }
            }
            var Le = p.return;
            try {
              n(p);
            } catch (nr) {
              mn(p, Le, nr);
            }
            break;
          case 5:
            var ot = p.return;
            try {
              n(p);
            } catch (nr) {
              mn(p, ot, nr);
            }
        }
      } catch (nr) {
        mn(p, p.return, nr);
      }
      if (p === f) {
        ci = null;
        break;
      }
      var Ht = p.sibling;
      if (Ht !== null) {
        Ht.return = p.return, ci = Ht;
        break;
      }
      ci = p.return;
    }
  }
  var xt = Math.ceil, mt = B.ReactCurrentDispatcher, _t = B.ReactCurrentOwner, dt = B.ReactCurrentBatchConfig, gt = 0, Rt = null, Jt = null, Vt = 0, or = 0, sr = Io(0), Bt = 0, rr = null, gr = 0, Ut = 0, dr = 0, ir = null, Tr = null, mr = 0, hr = 1 / 0, br = null, Cr = !1, Hr = null, Zr = null, mi = !1, ii = null, oi = 0, yi = 0, Ui = null, tn = -1, bn = 0;
  function $i() {
    return gt & 6 ? qr() : tn !== -1 ? tn : tn = qr();
  }
  function xi(f) {
    return f.mode & 1 ? gt & 2 && Vt !== 0 ? Vt & -Vt : Hh.transition !== null ? (bn === 0 && (bn = Sa()), bn) : (f = on, f !== 0 || (f = window.event, f = f === void 0 ? 16 : Hu(f.type)), f) : 1;
  }
  function Di(f, p, O, ee) {
    if (50 < yi) throw yi = 0, Ui = null, Error(pt(185));
    uo(f, O, ee), (!(gt & 2) || f !== Rt) && (f === Rt && (!(gt & 2) && (Ut |= O), Bt === 4 && Pn(f, Vt)), Yr(f, ee), O === 1 && gt === 0 && !(p.mode & 1) && (hr = qr() + 500, Dl && Po()));
  }
  function Yr(f, p) {
    var O = f.callbackNode;
    Th(f, p);
    var ee = ou(f, f === Rt ? Vt : 0);
    if (ee === 0) O !== null && fr(O), f.callbackNode = null, f.callbackPriority = 0;
    else if (p = ee & -ee, f.callbackPriority !== p) {
      if (O != null && fr(O), p === 1) f.tag === 0 ? lc(Zn.bind(null, f)) : jh(Zn.bind(null, f)), fd(function() {
        !(gt & 6) && Po();
      }), O = null;
      else {
        switch (Gu(ee)) {
          case 1:
            O = fi;
            break;
          case 4:
            O = si;
            break;
          case 16:
            O = ki;
            break;
          case 536870912:
            O = Li;
            break;
          default:
            O = ki;
        }
        O = dh(O, Fi.bind(null, f));
      }
      f.callbackPriority = p, f.callbackNode = O;
    }
  }
  function Fi(f, p) {
    if (tn = -1, bn = 0, gt & 6) throw Error(pt(327));
    var O = f.callbackNode;
    if (Za() && f.callbackNode !== O) return null;
    var ee = ou(f, f === Rt ? Vt : 0);
    if (ee === 0) return null;
    if (ee & 30 || ee & f.expiredLanes || p) p = Rn(f, ee);
    else {
      p = ee;
      var ye = gt;
      gt |= 2;
      var Le = ln();
      (Rt !== f || Vt !== p) && (br = null, hr = qr() + 500, pn(f, p));
      do
        try {
          fn();
          break;
        } catch (Ht) {
          hn(f, Ht);
        }
      while (!0);
      rl(), mt.current = Le, gt = ye, Jt !== null ? p = 0 : (Rt = null, Vt = 0, p = Bt);
    }
    if (p !== 0) {
      if (p === 2 && (ye = Vu(f), ye !== 0 && (ee = ye, p = Ki(f, ye))), p === 1) throw O = rr, pn(f, 0), Pn(f, ee), Yr(f, qr()), O;
      if (p === 6) Pn(f, ee);
      else {
        if (ye = f.current.alternate, !(ee & 30) && !Mn(ye) && (p = Rn(f, ee), p === 2 && (Le = Vu(f), Le !== 0 && (ee = Le, p = Ki(f, Le))), p === 1)) throw O = rr, pn(f, 0), Pn(f, ee), Yr(f, qr()), O;
        switch (f.finishedWork = ye, f.finishedLanes = ee, p) {
          case 0:
          case 1:
            throw Error(pt(345));
          case 2:
            fa(f, Tr, br);
            break;
          case 3:
            if (Pn(f, ee), (ee & 130023424) === ee && (p = mr + 500 - qr(), 10 < p)) {
              if (ou(f, 0) !== 0) break;
              if (ye = f.suspendedLanes, (ye & ee) !== ee) {
                $i(), f.pingedLanes |= f.suspendedLanes & ye;
                break;
              }
              f.timeoutHandle = Zc(fa.bind(null, f, Tr, br), p);
              break;
            }
            fa(f, Tr, br);
            break;
          case 4:
            if (Pn(f, ee), (ee & 4194240) === ee) break;
            for (p = f.eventTimes, ye = -1; 0 < ee; ) {
              var ot = 31 - sa(ee);
              Le = 1 << ot, ot = p[ot], ot > ye && (ye = ot), ee &= ~Le;
            }
            if (ee = ye, ee = qr() - ee, ee = (120 > ee ? 120 : 480 > ee ? 480 : 1080 > ee ? 1080 : 1920 > ee ? 1920 : 3e3 > ee ? 3e3 : 4320 > ee ? 4320 : 1960 * xt(ee / 1960)) - ee, 10 < ee) {
              f.timeoutHandle = Zc(fa.bind(null, f, Tr, br), ee);
              break;
            }
            fa(f, Tr, br);
            break;
          case 5:
            fa(f, Tr, br);
            break;
          default:
            throw Error(pt(329));
        }
      }
    }
    return Yr(f, qr()), f.callbackNode === O ? Fi.bind(null, f) : null;
  }
  function Ki(f, p) {
    var O = ir;
    return f.current.memoizedState.isDehydrated && (pn(f, p).flags |= 256), f = Rn(f, p), f !== 2 && (p = Tr, Tr = O, p !== null && Qi(p)), f;
  }
  function Qi(f) {
    Tr === null ? Tr = f : Tr.push.apply(Tr, f);
  }
  function Mn(f) {
    for (var p = f; ; ) {
      if (p.flags & 16384) {
        var O = p.updateQueue;
        if (O !== null && (O = O.stores, O !== null)) for (var ee = 0; ee < O.length; ee++) {
          var ye = O[ee], Le = ye.getSnapshot;
          ye = ye.value;
          try {
            if (!Ma(Le(), ye)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (O = p.child, p.subtreeFlags & 16384 && O !== null) O.return = p, p = O;
      else {
        if (p === f) break;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === f) return !0;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
    }
    return !0;
  }
  function Pn(f, p) {
    for (p &= ~dr, p &= ~Ut, f.suspendedLanes |= p, f.pingedLanes &= ~p, f = f.expirationTimes; 0 < p; ) {
      var O = 31 - sa(p), ee = 1 << O;
      f[O] = -1, p &= ~ee;
    }
  }
  function Zn(f) {
    if (gt & 6) throw Error(pt(327));
    Za();
    var p = ou(f, 0);
    if (!(p & 1)) return Yr(f, qr()), null;
    var O = Rn(f, p);
    if (f.tag !== 0 && O === 2) {
      var ee = Vu(f);
      ee !== 0 && (p = ee, O = Ki(f, ee));
    }
    if (O === 1) throw O = rr, pn(f, 0), Pn(f, p), Yr(f, qr()), O;
    if (O === 6) throw Error(pt(345));
    return f.finishedWork = f.current.alternate, f.finishedLanes = p, fa(f, Tr, br), Yr(f, qr()), null;
  }
  function jn(f, p) {
    var O = gt;
    gt |= 1;
    try {
      return f(p);
    } finally {
      gt = O, gt === 0 && (hr = qr() + 500, Dl && Po());
    }
  }
  function ya(f) {
    ii !== null && ii.tag === 0 && !(gt & 6) && Za();
    var p = gt;
    gt |= 1;
    var O = dt.transition, ee = on;
    try {
      if (dt.transition = null, on = 1, f) return f();
    } finally {
      on = ee, dt.transition = O, gt = p, !(gt & 6) && Po();
    }
  }
  function va() {
    or = sr.current, Bn(sr);
  }
  function pn(f, p) {
    f.finishedWork = null, f.finishedLanes = 0;
    var O = f.timeoutHandle;
    if (O !== -1 && (f.timeoutHandle = -1, Tf(O)), Jt !== null) for (O = Jt.return; O !== null; ) {
      var ee = O;
      switch (Vh(ee), ee.tag) {
        case 1:
          ee = ee.type.childContextTypes, ee != null && qc();
          break;
        case 3:
          Va(), Bn(Ja), Bn(ba), dn();
          break;
        case 5:
          Jc(ee);
          break;
        case 4:
          Va();
          break;
        case 13:
          Bn(rn);
          break;
        case 19:
          Bn(rn);
          break;
        case 10:
          il(ee.type._context);
          break;
        case 22:
        case 23:
          va();
      }
      O = O.return;
    }
    if (Rt = f, Jt = f = Jl(f.current, null), Vt = or = p, Bt = 0, rr = null, dr = Ut = gr = 0, Tr = ir = null, Ro !== null) {
      for (p = 0; p < Ro.length; p++) if (O = Ro[p], ee = O.interleaved, ee !== null) {
        O.interleaved = null;
        var ye = ee.next, Le = O.pending;
        if (Le !== null) {
          var ot = Le.next;
          Le.next = ye, ee.next = ot;
        }
        O.pending = ee;
      }
      Ro = null;
    }
    return f;
  }
  function hn(f, p) {
    do {
      var O = Jt;
      try {
        if (rl(), Yi.current = sh, ol) {
          for (var ee = In.memoizedState; ee !== null; ) {
            var ye = ee.queue;
            ye !== null && (ye.pending = null), ee = ee.next;
          }
          ol = !1;
        }
        if (Ga = 0, ta = Dn = In = null, ro = !1, ra = 0, _t.current = null, O === null || O.return === null) {
          Bt = 1, rr = p, Jt = null;
          break;
        }
        e: {
          var Le = f, ot = O.return, Ht = O, nr = p;
          if (p = Vt, Ht.flags |= 32768, nr !== null && typeof nr == "object" && typeof nr.then == "function") {
            var Er = nr, Jr = Ht, ei = Jr.tag;
            if (!(Jr.mode & 1) && (ei === 0 || ei === 11 || ei === 15)) {
              var Qr = Jr.alternate;
              Qr ? (Jr.updateQueue = Qr.updateQueue, Jr.memoizedState = Qr.memoizedState, Jr.lanes = Qr.lanes) : (Jr.updateQueue = null, Jr.memoizedState = null);
            }
            var wi = Du(ot);
            if (wi !== null) {
              wi.flags &= -257, uh(wi, ot, Ht, Le, p), wi.mode & 1 && tf(Le, Er, p), p = wi, nr = Er;
              var Ei = p.updateQueue;
              if (Ei === null) {
                var Ti = /* @__PURE__ */ new Set();
                Ti.add(nr), p.updateQueue = Ti;
              } else Ei.add(nr);
              break e;
            } else {
              if (!(p & 1)) {
                tf(Le, Er, p), Vi();
                break e;
              }
              nr = Error(pt(426));
            }
          } else if (Fn && Ht.mode & 1) {
            var na = Du(ot);
            if (na !== null) {
              !(na.flags & 65536) && (na.flags |= 256), uh(na, ot, Ht, Le, p), cc(os(nr, Ht));
              break e;
            }
          }
          Le = nr = os(nr, Ht), Bt !== 4 && (Bt = 2), ir === null ? ir = [Le] : ir.push(Le), Le = ot;
          do {
            switch (Le.tag) {
              case 3:
                Le.flags |= 65536, p &= -p, Le.lanes |= p;
                var _r = Lu(Le, nr, p);
                If(Le, _r);
                break e;
              case 1:
                Ht = nr;
                var lr = Le.type, xr = Le.stateNode;
                if (!(Le.flags & 128) && (typeof lr.getDerivedStateFromError == "function" || xr !== null && typeof xr.componentDidCatch == "function" && (Zr === null || !Zr.has(xr)))) {
                  Le.flags |= 65536, p &= -p, Le.lanes |= p;
                  var ai = ef(Le, Ht, p);
                  If(Le, ai);
                  break e;
                }
            }
            Le = Le.return;
          } while (Le !== null);
        }
        xo(O);
      } catch (Ai) {
        p = Ai, Jt === O && O !== null && (Jt = O = O.return);
        continue;
      }
      break;
    } while (!0);
  }
  function ln() {
    var f = mt.current;
    return mt.current = sh, f === null ? sh : f;
  }
  function Vi() {
    (Bt === 0 || Bt === 3 || Bt === 2) && (Bt = 4), Rt === null || !(gr & 268435455) && !(Ut & 268435455) || Pn(Rt, Vt);
  }
  function Rn(f, p) {
    var O = gt;
    gt |= 2;
    var ee = ln();
    (Rt !== f || Vt !== p) && (br = null, pn(f, p));
    do
      try {
        ia();
        break;
      } catch (ye) {
        hn(f, ye);
      }
    while (!0);
    if (rl(), gt = O, mt.current = ee, Jt !== null) throw Error(pt(261));
    return Rt = null, Vt = 0, Bt;
  }
  function ia() {
    for (; Jt !== null; ) wa(Jt);
  }
  function fn() {
    for (; Jt !== null && !Ir(); ) wa(Jt);
  }
  function wa(f) {
    var p = Tc(f.alternate, f, or);
    f.memoizedProps = f.pendingProps, p === null ? xo(f) : Jt = p, _t.current = null;
  }
  function xo(f) {
    var p = f;
    do {
      var O = p.alternate;
      if (f = p.return, p.flags & 32768) {
        if (O = ls(O, p), O !== null) {
          O.flags &= 32767, Jt = O;
          return;
        }
        if (f !== null) f.flags |= 32768, f.subtreeFlags = 0, f.deletions = null;
        else {
          Bt = 6, Jt = null;
          return;
        }
      } else if (O = hh(O, p, or), O !== null) {
        Jt = O;
        return;
      }
      if (p = p.sibling, p !== null) {
        Jt = p;
        return;
      }
      Jt = p = f;
    } while (p !== null);
    Bt === 0 && (Bt = 5);
  }
  function fa(f, p, O) {
    var ee = on, ye = dt.transition;
    try {
      dt.transition = null, on = 1, Wa(f, p, O, ee);
    } finally {
      dt.transition = ye, on = ee;
    }
    return null;
  }
  function Wa(f, p, O, ee) {
    do
      Za();
    while (ii !== null);
    if (gt & 6) throw Error(pt(327));
    O = f.finishedWork;
    var ye = f.finishedLanes;
    if (O === null) return null;
    if (f.finishedWork = null, f.finishedLanes = 0, O === f.current) throw Error(pt(177));
    f.callbackNode = null, f.callbackPriority = 0;
    var Le = O.lanes | O.childLanes;
    if (Wo(f, Le), f === Rt && (Jt = Rt = null, Vt = 0), !(O.subtreeFlags & 2064) && !(O.flags & 2064) || mi || (mi = !0, dh(ki, function() {
      return Za(), null;
    })), Le = (O.flags & 15990) !== 0, O.subtreeFlags & 15990 || Le) {
      Le = dt.transition, dt.transition = null;
      var ot = on;
      on = 1;
      var Ht = gt;
      gt |= 4, _t.current = null, Ou(f, O), Be(O, f), Fc(sc), Kn = !!oc, sc = oc = null, f.current = O, Ge(O), Lr(), gt = Ht, on = ot, dt.transition = Le;
    } else f.current = O;
    if (mi && (mi = !1, ii = f, oi = ye), Le = f.pendingLanes, Le === 0 && (Zr = null), Gn(O.stateNode), Yr(f, qr()), p !== null) for (ee = f.onRecoverableError, O = 0; O < p.length; O++) ye = p[O], ee(ye.value, { componentStack: ye.stack, digest: ye.digest });
    if (Cr) throw Cr = !1, f = Hr, Hr = null, f;
    return oi & 1 && f.tag !== 0 && Za(), Le = f.pendingLanes, Le & 1 ? f === Ui ? yi++ : (yi = 0, Ui = f) : yi = 0, Po(), null;
  }
  function Za() {
    if (ii !== null) {
      var f = Gu(oi), p = dt.transition, O = on;
      try {
        if (dt.transition = null, on = 16 > f ? 16 : f, ii === null) var ee = !1;
        else {
          if (f = ii, ii = null, oi = 0, gt & 6) throw Error(pt(331));
          var ye = gt;
          for (gt |= 4, ci = f.current; ci !== null; ) {
            var Le = ci, ot = Le.child;
            if (ci.flags & 16) {
              var Ht = Le.deletions;
              if (Ht !== null) {
                for (var nr = 0; nr < Ht.length; nr++) {
                  var Er = Ht[nr];
                  for (ci = Er; ci !== null; ) {
                    var Jr = ci;
                    switch (Jr.tag) {
                      case 0:
                      case 11:
                      case 15:
                        l(8, Jr, Le);
                    }
                    var ei = Jr.child;
                    if (ei !== null) ei.return = Jr, ci = ei;
                    else for (; ci !== null; ) {
                      Jr = ci;
                      var Qr = Jr.sibling, wi = Jr.return;
                      if (u(Jr), Jr === Er) {
                        ci = null;
                        break;
                      }
                      if (Qr !== null) {
                        Qr.return = wi, ci = Qr;
                        break;
                      }
                      ci = wi;
                    }
                  }
                }
                var Ei = Le.alternate;
                if (Ei !== null) {
                  var Ti = Ei.child;
                  if (Ti !== null) {
                    Ei.child = null;
                    do {
                      var na = Ti.sibling;
                      Ti.sibling = null, Ti = na;
                    } while (Ti !== null);
                  }
                }
                ci = Le;
              }
            }
            if (Le.subtreeFlags & 2064 && ot !== null) ot.return = Le, ci = ot;
            else e: for (; ci !== null; ) {
              if (Le = ci, Le.flags & 2048) switch (Le.tag) {
                case 0:
                case 11:
                case 15:
                  l(9, Le, Le.return);
              }
              var _r = Le.sibling;
              if (_r !== null) {
                _r.return = Le.return, ci = _r;
                break e;
              }
              ci = Le.return;
            }
          }
          var lr = f.current;
          for (ci = lr; ci !== null; ) {
            ot = ci;
            var xr = ot.child;
            if (ot.subtreeFlags & 2064 && xr !== null) xr.return = ot, ci = xr;
            else e: for (ot = lr; ci !== null; ) {
              if (Ht = ci, Ht.flags & 2048) try {
                switch (Ht.tag) {
                  case 0:
                  case 11:
                  case 15:
                    t(9, Ht);
                }
              } catch (Ai) {
                mn(Ht, Ht.return, Ai);
              }
              if (Ht === ot) {
                ci = null;
                break e;
              }
              var ai = Ht.sibling;
              if (ai !== null) {
                ai.return = Ht.return, ci = ai;
                break e;
              }
              ci = Ht.return;
            }
          }
          if (gt = ye, Po(), Bi && typeof Bi.onPostCommitFiberRoot == "function") try {
            Bi.onPostCommitFiberRoot(Wi, f);
          } catch {
          }
          ee = !0;
        }
        return ee;
      } finally {
        on = O, dt.transition = p;
      }
    }
    return !1;
  }
  function bo(f, p, O) {
    p = os(O, p), p = Lu(f, p, 1), f = Ms(f, p, 1), p = $i(), f !== null && (uo(f, 1, p), Yr(f, p));
  }
  function mn(f, p, O) {
    if (f.tag === 3) bo(f, f, O);
    else for (; p !== null; ) {
      if (p.tag === 3) {
        bo(p, f, O);
        break;
      } else if (p.tag === 1) {
        var ee = p.stateNode;
        if (typeof p.type.getDerivedStateFromError == "function" || typeof ee.componentDidCatch == "function" && (Zr === null || !Zr.has(ee))) {
          f = os(O, f), f = ef(p, f, 1), p = Ms(p, f, 1), f = $i(), p !== null && (uo(p, 1, f), Yr(p, f));
          break;
        }
      }
      p = p.return;
    }
  }
  function Yl(f, p, O) {
    var ee = f.pingCache;
    ee !== null && ee.delete(p), p = $i(), f.pingedLanes |= f.suspendedLanes & O, Rt === f && (Vt & O) === O && (Bt === 4 || Bt === 3 && (Vt & 130023424) === Vt && 500 > qr() - mr ? pn(f, 0) : dr |= O), Yr(f, p);
  }
  function Vo(f, p) {
    p === 0 && (f.mode & 1 ? (p = wo, wo <<= 1, !(wo & 130023424) && (wo = 4194304)) : p = 1);
    var O = $i();
    f = is(f, p), f !== null && (uo(f, p, O), Yr(f, O));
  }
  function Kl(f) {
    var p = f.memoizedState, O = 0;
    p !== null && (O = p.retryLane), Vo(f, O);
  }
  function Bu(f, p) {
    var O = 0;
    switch (f.tag) {
      case 13:
        var ee = f.stateNode, ye = f.memoizedState;
        ye !== null && (O = ye.retryLane);
        break;
      case 19:
        ee = f.stateNode;
        break;
      default:
        throw Error(pt(314));
    }
    ee !== null && ee.delete(p), Vo(f, O);
  }
  var Tc;
  Tc = function(f, p, O) {
    if (f !== null) if (f.memoizedProps !== p.pendingProps || Ja.current) Da = !0;
    else {
      if (!(f.lanes & O) && !(p.flags & 128)) return Da = !1, $l(f, p, O);
      Da = !!(f.flags & 131072);
    }
    else Da = !1, Fn && p.flags & 1048576 && ri(p, ts, p.index);
    switch (p.lanes = 0, p.tag) {
      case 2:
        var ee = p.type;
        ka(f, p), f = p.pendingProps;
        var ye = Bo(p, ba.current);
        Mr(p, O), ye = pc(null, p, ee, f, ye, O);
        var Le = Is();
        return p.flags |= 1, typeof ye == "object" && ye !== null && typeof ye.render == "function" && ye.$$typeof === void 0 ? (p.tag = 1, p.memoizedState = null, p.updateQueue = null, Qa(ee) ? (Le = !0, Rl(p)) : Le = !1, p.memoizedState = ye.state !== null && ye.state !== void 0 ? ye.state : null, fc(p), ye.updater = ll, p.stateNode = ye, ye._reactInternals = p, Do(p, ee, f, O), p = rf(null, p, ee, !0, Le, O)) : (p.tag = 0, Fn && Le && uc(p), Ia(null, p, ye, O), p = p.child), p;
      case 16:
        ee = p.elementType;
        e: {
          switch (ka(f, p), f = p.pendingProps, ye = ee._init, ee = ye(ee._payload), p.type = ee, ye = p.tag = Jd(ee), f = jo(ee, f), ye) {
            case 0:
              p = Rs(null, p, ee, f, O);
              break e;
            case 1:
              p = Ls(null, p, ee, f, O);
              break e;
            case 11:
              p = ul(null, p, ee, f, O);
              break e;
            case 14:
              p = cl(null, p, ee, jo(ee.type, f), O);
              break e;
          }
          throw Error(pt(
            306,
            ee,
            ""
          ));
        }
        return p;
      case 0:
        return ee = p.type, ye = p.pendingProps, ye = p.elementType === ee ? ye : jo(ee, ye), Rs(f, p, ee, ye, O);
      case 1:
        return ee = p.type, ye = p.pendingProps, ye = p.elementType === ee ? ye : jo(ee, ye), Ls(f, p, ee, ye, O);
      case 3:
        e: {
          if (Pf(p), f === null) throw Error(pt(387));
          ee = p.pendingProps, Le = p.memoizedState, ye = Le.element, Wh(f, p), Kc(p, ee, null, O);
          var ot = p.memoizedState;
          if (ee = ot.element, Le.isDehydrated) if (Le = { element: ee, isDehydrated: !1, cache: ot.cache, pendingSuspenseBoundaries: ot.pendingSuspenseBoundaries, transitions: ot.transitions }, p.updateQueue.baseState = Le, p.memoizedState = Le, p.flags & 256) {
            ye = os(Error(pt(423)), p), p = Rf(f, p, ee, O, ye);
            break e;
          } else if (ee !== ye) {
            ye = os(Error(pt(424)), p), p = Rf(f, p, ee, O, ye);
            break e;
          } else for (La = Ys(p.stateNode.containerInfo.firstChild), mo = p, Fn = !0, _o = null, O = hc(p, null, ee, O), p.child = O; O; ) O.flags = O.flags & -3 | 4096, O = O.sibling;
          else {
            if (yo(), ee === ye) {
              p = ao(f, p, O);
              break e;
            }
            Ia(f, p, ee, O);
          }
          p = p.child;
        }
        return p;
      case 5:
        return as(p), f === null && bu(p), ee = p.type, ye = p.pendingProps, Le = f !== null ? f.memoizedProps : null, ot = ye.children, yu(ee, ye) ? ot = null : Le !== null && yu(ee, Le) && (p.flags |= 32), Ps(f, p), Ia(f, p, ot, O), p.child;
      case 6:
        return f === null && bu(p), null;
      case 13:
        return Ca(f, p, O);
      case 4:
        return Eu(p, p.stateNode.containerInfo), ee = p.pendingProps, f === null ? p.child = sn(p, null, ee, O) : Ia(f, p, ee, O), p.child;
      case 11:
        return ee = p.type, ye = p.pendingProps, ye = p.elementType === ee ? ye : jo(ee, ye), ul(f, p, ee, ye, O);
      case 7:
        return Ia(f, p, p.pendingProps, O), p.child;
      case 8:
        return Ia(f, p, p.pendingProps.children, O), p.child;
      case 12:
        return Ia(f, p, p.pendingProps.children, O), p.child;
      case 10:
        e: {
          if (ee = p.type._context, ye = p.pendingProps, Le = p.memoizedProps, ot = ye.value, Tn(el, ee._currentValue), ee._currentValue = ot, Le !== null) if (Ma(Le.value, ot)) {
            if (Le.children === ye.children && !Ja.current) {
              p = ao(f, p, O);
              break e;
            }
          } else for (Le = p.child, Le !== null && (Le.return = p); Le !== null; ) {
            var Ht = Le.dependencies;
            if (Ht !== null) {
              ot = Le.child;
              for (var nr = Ht.firstContext; nr !== null; ) {
                if (nr.context === ee) {
                  if (Le.tag === 1) {
                    nr = ns(-1, O & -O), nr.tag = 2;
                    var Er = Le.updateQueue;
                    if (Er !== null) {
                      Er = Er.shared;
                      var Jr = Er.pending;
                      Jr === null ? nr.next = nr : (nr.next = Jr.next, Jr.next = nr), Er.pending = nr;
                    }
                  }
                  Le.lanes |= O, nr = Le.alternate, nr !== null && (nr.lanes |= O), nl(
                    Le.return,
                    O,
                    p
                  ), Ht.lanes |= O;
                  break;
                }
                nr = nr.next;
              }
            } else if (Le.tag === 10) ot = Le.type === p.type ? null : Le.child;
            else if (Le.tag === 18) {
              if (ot = Le.return, ot === null) throw Error(pt(341));
              ot.lanes |= O, Ht = ot.alternate, Ht !== null && (Ht.lanes |= O), nl(ot, O, p), ot = Le.sibling;
            } else ot = Le.child;
            if (ot !== null) ot.return = Le;
            else for (ot = Le; ot !== null; ) {
              if (ot === p) {
                ot = null;
                break;
              }
              if (Le = ot.sibling, Le !== null) {
                Le.return = ot.return, ot = Le;
                break;
              }
              ot = ot.return;
            }
            Le = ot;
          }
          Ia(f, p, ye.children, O), p = p.child;
        }
        return p;
      case 9:
        return ye = p.type, ee = p.pendingProps.children, Mr(p, O), ye = Nr(ye), ee = ee(ye), p.flags |= 1, Ia(f, p, ee, O), p.child;
      case 14:
        return ee = p.type, ye = jo(ee, p.pendingProps), ye = jo(ee.type, ye), cl(f, p, ee, ye, O);
      case 15:
        return ss(f, p, p.type, p.pendingProps, O);
      case 17:
        return ee = p.type, ye = p.pendingProps, ye = p.elementType === ee ? ye : jo(ee, ye), ka(f, p), p.tag = 1, Qa(ee) ? (f = !0, Rl(p)) : f = !1, Mr(p, O), Pu(p, ee, ye), Do(p, ee, ye, O), rf(null, p, ee, !0, f, O);
      case 19:
        return no(f, p, O);
      case 22:
        return ko(f, p, O);
    }
    throw Error(pt(156, p.tag));
  };
  function dh(f, p) {
    return Yt(f, p);
  }
  function Kd(f, p, O, ee) {
    this.tag = f, this.key = O, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = p, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = ee, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function us(f, p, O, ee) {
    return new Kd(f, p, O, ee);
  }
  function _d(f) {
    return f = f.prototype, !(!f || !f.isReactComponent);
  }
  function Jd(f) {
    if (typeof f == "function") return _d(f) ? 1 : 0;
    if (f != null) {
      if (f = f.$$typeof, f === se) return 11;
      if (f === be) return 14;
    }
    return 2;
  }
  function Jl(f, p) {
    var O = f.alternate;
    return O === null ? (O = us(f.tag, p, f.key, f.mode), O.elementType = f.elementType, O.type = f.type, O.stateNode = f.stateNode, O.alternate = f, f.alternate = O) : (O.pendingProps = p, O.type = f.type, O.flags = 0, O.subtreeFlags = 0, O.deletions = null), O.flags = f.flags & 14680064, O.childLanes = f.childLanes, O.lanes = f.lanes, O.child = f.child, O.memoizedProps = f.memoizedProps, O.memoizedState = f.memoizedState, O.updateQueue = f.updateQueue, p = f.dependencies, O.dependencies = p === null ? null : { lanes: p.lanes, firstContext: p.firstContext }, O.sibling = f.sibling, O.index = f.index, O.ref = f.ref, O;
  }
  function nf(f, p, O, ee, ye, Le) {
    var ot = 2;
    if (ee = f, typeof f == "function") _d(f) && (ot = 1);
    else if (typeof f == "string") ot = 5;
    else e: switch (f) {
      case V:
        return Fu(O.children, ye, Le, p);
      case W:
        ot = 8, ye |= 8;
        break;
      case q:
        return f = us(12, O, p, ye | 2), f.elementType = q, f.lanes = Le, f;
      case ve:
        return f = us(13, O, p, ye), f.elementType = ve, f.lanes = Le, f;
      case ce:
        return f = us(19, O, p, ye), f.elementType = ce, f.lanes = Le, f;
      case xe:
        return af(O, ye, Le, p);
      default:
        if (typeof f == "object" && f !== null) switch (f.$$typeof) {
          case Y:
            ot = 10;
            break e;
          case re:
            ot = 9;
            break e;
          case se:
            ot = 11;
            break e;
          case be:
            ot = 14;
            break e;
          case Me:
            ot = 16, ee = null;
            break e;
        }
        throw Error(pt(130, f == null ? f : typeof f, ""));
    }
    return p = us(ot, O, p, ye), p.elementType = f, p.type = ee, p.lanes = Le, p;
  }
  function Fu(f, p, O, ee) {
    return f = us(7, f, ee, p), f.lanes = O, f;
  }
  function af(f, p, O, ee) {
    return f = us(22, f, ee, p), f.elementType = xe, f.lanes = O, f.stateNode = { isHidden: !1 }, f;
  }
  function Df(f, p, O) {
    return f = us(6, f, null, p), f.lanes = O, f;
  }
  function kf(f, p, O) {
    return p = us(4, f.children !== null ? f.children : [], f.key, p), p.lanes = O, p.stateNode = { containerInfo: f.containerInfo, pendingChildren: null, implementation: f.implementation }, p;
  }
  function gd(f, p, O, ee, ye) {
    this.tag = p, this.containerInfo = f, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = lo(0), this.expirationTimes = lo(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = lo(0), this.identifierPrefix = ee, this.onRecoverableError = ye, this.mutableSourceEagerHydrationData = null;
  }
  function dl(f, p, O, ee, ye, Le, ot, Ht, nr) {
    return f = new gd(f, p, O, Ht, nr), p === 1 ? (p = 1, Le === !0 && (p |= 8)) : p = 0, Le = us(3, null, null, p), f.current = Le, Le.stateNode = f, Le.memoizedState = { element: ee, isDehydrated: O, cache: null, transitions: null, pendingSuspenseBoundaries: null }, fc(Le), f;
  }
  function Ea(f, p, O) {
    var ee = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: U, key: ee == null ? null : "" + ee, children: f, containerInfo: p, implementation: O };
  }
  function yd(f) {
    if (!f) return Co;
    f = f._reactInternals;
    e: {
      if (ft(f) !== f || f.tag !== 1) throw Error(pt(170));
      var p = f;
      do {
        switch (p.tag) {
          case 3:
            p = p.stateNode.context;
            break e;
          case 1:
            if (Qa(p.type)) {
              p = p.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        p = p.return;
      } while (p !== null);
      throw Error(pt(171));
    }
    if (f.tag === 1) {
      var O = f.type;
      if (Qa(O)) return Uh(f, O, p);
    }
    return p;
  }
  function ph(f, p, O, ee, ye, Le, ot, Ht, nr) {
    return f = dl(O, ee, !0, f, ye, Le, ot, Ht, nr), f.context = yd(null), O = f.current, ee = $i(), ye = xi(O), Le = ns(ee, ye), Le.callback = p ?? null, Ms(O, Le, ye), f.current.lanes = ye, uo(f, ye, ee), Yr(f, ee), f;
  }
  function zf(f, p, O, ee) {
    var ye = p.current, Le = $i(), ot = xi(ye);
    return O = yd(O), p.context === null ? p.context = O : p.pendingContext = O, p = ns(Le, ot), p.payload = { element: f }, ee = ee === void 0 ? null : ee, ee !== null && (p.callback = ee), f = Ms(ye, p, ot), f !== null && (Di(f, ye, ot, Le), As(f, ye, ot)), ot;
  }
  function Of(f) {
    if (f = f.current, !f.child) return null;
    switch (f.child.tag) {
      case 5:
        return f.child.stateNode;
      default:
        return f.child.stateNode;
    }
  }
  function mh(f, p) {
    if (f = f.memoizedState, f !== null && f.dehydrated !== null) {
      var O = f.retryLane;
      f.retryLane = O !== 0 && O < p ? O : p;
    }
  }
  function Bf(f, p) {
    mh(f, p), (f = f.alternate) && mh(f, p);
  }
  var Nu = typeof reportError == "function" ? reportError : function(f) {
    console.error(f);
  };
  function Mc(f) {
    this._internalRoot = f;
  }
  Ff.prototype.render = Mc.prototype.render = function(f) {
    var p = this._internalRoot;
    if (p === null) throw Error(pt(409));
    zf(f, p, null, null);
  }, Ff.prototype.unmount = Mc.prototype.unmount = function() {
    var f = this._internalRoot;
    if (f !== null) {
      this._internalRoot = null;
      var p = f.containerInfo;
      ya(function() {
        zf(null, f, null, null);
      }), p[Ao] = null;
    }
  };
  function Ff(f) {
    this._internalRoot = f;
  }
  Ff.prototype.unstable_scheduleHydration = function(f) {
    if (f) {
      var p = Mh();
      f = { blockedOn: null, target: f, priority: p };
      for (var O = 0; O < Mi.length && p !== 0 && p < Mi[O].priority; O++) ;
      Mi.splice(O, 0, f), O === 0 && Zi(f);
    }
  };
  function vd(f) {
    return !(!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11);
  }
  function Nf(f) {
    return !(!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11 && (f.nodeType !== 8 || f.nodeValue !== " react-mount-point-unstable "));
  }
  function Qd() {
  }
  function Xp(f, p, O, ee, ye) {
    if (ye) {
      if (typeof ee == "function") {
        var Le = ee;
        ee = function() {
          var Er = Of(ot);
          Le.call(Er);
        };
      }
      var ot = ph(p, ee, f, 0, null, !1, !1, "", Qd);
      return f._reactRootContainer = ot, f[Ao] = ot.current, _u(f.nodeType === 8 ? f.parentNode : f), ya(), ot;
    }
    for (; ye = f.lastChild; ) f.removeChild(ye);
    if (typeof ee == "function") {
      var Ht = ee;
      ee = function() {
        var Er = Of(nr);
        Ht.call(Er);
      };
    }
    var nr = dl(f, 0, !1, null, null, !1, !1, "", Qd);
    return f._reactRootContainer = nr, f[Ao] = nr.current, _u(f.nodeType === 8 ? f.parentNode : f), ya(function() {
      zf(p, nr, O, ee);
    }), nr;
  }
  function Uf(f, p, O, ee, ye) {
    var Le = O._reactRootContainer;
    if (Le) {
      var ot = Le;
      if (typeof ye == "function") {
        var Ht = ye;
        ye = function() {
          var nr = Of(ot);
          Ht.call(nr);
        };
      }
      zf(p, ot, f, ye);
    } else ot = Xp(O, p, f, ye, ee);
    return Of(ot);
  }
  Cc = function(f) {
    switch (f.tag) {
      case 3:
        var p = f.stateNode;
        if (p.current.memoizedState.isDehydrated) {
          var O = fs(p.pendingLanes);
          O !== 0 && (co(p, O | 1), Yr(p, qr()), !(gt & 6) && (hr = qr() + 500, Po()));
        }
        break;
      case 13:
        ya(function() {
          var ee = is(f, 1);
          if (ee !== null) {
            var ye = $i();
            Di(ee, f, 1, ye);
          }
        }), Bf(f, 1);
    }
  }, Zo = function(f) {
    if (f.tag === 13) {
      var p = is(f, 134217728);
      if (p !== null) {
        var O = $i();
        Di(p, f, 134217728, O);
      }
      Bf(f, 134217728);
    }
  }, ds = function(f) {
    if (f.tag === 13) {
      var p = xi(f), O = is(f, p);
      if (O !== null) {
        var ee = $i();
        Di(O, f, p, ee);
      }
      Bf(f, p);
    }
  }, Mh = function() {
    return on;
  }, Pc = function(f, p) {
    var O = on;
    try {
      return on = f, p();
    } finally {
      on = O;
    }
  }, pr = function(f, p, O) {
    switch (p) {
      case "input":
        if (it(f, O), p = O.name, O.type === "radio" && p != null) {
          for (O = f; O.parentNode; ) O = O.parentNode;
          for (O = O.querySelectorAll("input[name=" + JSON.stringify("" + p) + '][type="radio"]'), p = 0; p < O.length; p++) {
            var ee = O[p];
            if (ee !== f && ee.form === f.form) {
              var ye = xu(ee);
              if (!ye) throw Error(pt(90));
              Xt(ee), it(ee, ye);
            }
          }
        }
        break;
      case "textarea":
        ie(f, O);
        break;
      case "select":
        p = O.value, p != null && We(f, !!O.multiple, p, !1);
    }
  }, Z = jn, Dt = ya;
  var Yp = { usingClientEntryPoint: !1, Events: [Pl, fo, xu, wr, ni, jn] }, Ac = { findFiberByHostInstance: Js, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Kp = { bundleType: Ac.bundleType, version: Ac.version, rendererPackageName: Ac.rendererPackageName, rendererConfig: Ac.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: B.ReactCurrentDispatcher, findHostInstanceByFiber: function(f) {
    return f = Zt(f), f === null ? null : f.stateNode;
  }, findFiberByHostInstance: Ac.findFiberByHostInstance, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Ql = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Ql.isDisabled && Ql.supportsFiber) try {
      Wi = Ql.inject(Kp), Bi = Ql;
    } catch {
    }
  }
  return cs.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Yp, cs.createPortal = function(f, p) {
    var O = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!vd(p)) throw Error(pt(200));
    return Ea(f, p, null, O);
  }, cs.createRoot = function(f, p) {
    if (!vd(f)) throw Error(pt(299));
    var O = !1, ee = "", ye = Nu;
    return p != null && (p.unstable_strictMode === !0 && (O = !0), p.identifierPrefix !== void 0 && (ee = p.identifierPrefix), p.onRecoverableError !== void 0 && (ye = p.onRecoverableError)), p = dl(f, 1, !1, null, null, O, !1, ee, ye), f[Ao] = p.current, _u(f.nodeType === 8 ? f.parentNode : f), new Mc(p);
  }, cs.findDOMNode = function(f) {
    if (f == null) return null;
    if (f.nodeType === 1) return f;
    var p = f._reactInternals;
    if (p === void 0)
      throw typeof f.render == "function" ? Error(pt(188)) : (f = Object.keys(f).join(","), Error(pt(268, f)));
    return f = Zt(p), f = f === null ? null : f.stateNode, f;
  }, cs.flushSync = function(f) {
    return ya(f);
  }, cs.hydrate = function(f, p, O) {
    if (!Nf(p)) throw Error(pt(200));
    return Uf(null, f, p, !0, O);
  }, cs.hydrateRoot = function(f, p, O) {
    if (!vd(f)) throw Error(pt(405));
    var ee = O != null && O.hydratedSources || null, ye = !1, Le = "", ot = Nu;
    if (O != null && (O.unstable_strictMode === !0 && (ye = !0), O.identifierPrefix !== void 0 && (Le = O.identifierPrefix), O.onRecoverableError !== void 0 && (ot = O.onRecoverableError)), p = ph(p, null, f, 1, O ?? null, ye, !1, Le, ot), f[Ao] = p.current, _u(f), ee) for (f = 0; f < ee.length; f++) O = ee[f], ye = O._getVersion, ye = ye(O._source), p.mutableSourceEagerHydrationData == null ? p.mutableSourceEagerHydrationData = [O, ye] : p.mutableSourceEagerHydrationData.push(
      O,
      ye
    );
    return new Ff(p);
  }, cs.render = function(f, p, O) {
    if (!Nf(p)) throw Error(pt(200));
    return Uf(null, f, p, !1, O);
  }, cs.unmountComponentAtNode = function(f) {
    if (!Nf(f)) throw Error(pt(40));
    return f._reactRootContainer ? (ya(function() {
      Uf(null, null, f, !1, function() {
        f._reactRootContainer = null, f[Ao] = null;
      });
    }), !0) : !1;
  }, cs.unstable_batchedUpdates = jn, cs.unstable_renderSubtreeIntoContainer = function(f, p, O, ee) {
    if (!Nf(O)) throw Error(pt(200));
    if (f == null || f._reactInternals === void 0) throw Error(pt(38));
    return Uf(f, p, O, !1, ee);
  }, cs.version = "18.3.1-next-f1338f8080-20240426", cs;
}
var Yy;
function db() {
  if (Yy) return u_.exports;
  Yy = 1;
  function Qe() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Qe);
      } catch (Mt) {
        console.error(Mt);
      }
  }
  return Qe(), u_.exports = fb(), u_.exports;
}
var Ky;
function pb() {
  if (Ky) return Fp;
  Ky = 1;
  var Qe = db();
  return Fp.createRoot = Qe.createRoot, Fp.hydrateRoot = Qe.hydrateRoot, Fp;
}
var mb = pb();
const _b = /* @__PURE__ */ Hp(mb), nd = () => {
  const Qe = document.getElementById("product-info"), Mt = JSON.parse((Qe == null ? void 0 : Qe.textContent) || "{}");
  return window.shineon = window.shineon || {}, window.shineon.product_info = Mt, Mt;
}, Wp = () => {
  const Qe = nd();
  return gb(Qe);
}, gb = (Qe) => {
  var Mt;
  return !Qe.shop_cf || !((Mt = Qe.shop_pt_id_obj) != null && Mt.custom_fields) ? [] : Qe.shop_pt_id_obj.custom_fields.map((pt) => ({
    ...Qe.shop_cf[pt.key],
    id: pt
  }));
}, yb = {
  en: {
    errors: {
      invalid_character: " isn't available"
    }
  },
  fr: {
    errors: {
      invalid_character: " n'est pas disponible"
    }
  },
  es: {
    errors: {
      invalid_character: " no está disponible"
    }
  },
  de: {
    errors: {
      invalid_character: " ist nicht verfügbar"
    }
  },
  it: {
    errors: {
      invalid_character: " non è disponibile"
    }
  },
  pt: {
    errors: {
      invalid_character: " não está disponível"
    }
  },
  ua: {
    errors: {
      invalid_character: " недоступний"
    }
  },
  pl: {
    errors: {
      invalid_character: " jest niedostępny"
    }
  }
}, k_ = nd();
let f_ = k_.selected_variant;
const C_ = {
  get variantInputs() {
    return document.querySelectorAll(k_.variant_id_input);
  }
}, vb = () => {
  const Qe = document.querySelectorAll('form[action="/cart/add"]');
  return Array.from(Qe).map((Mt) => Mt.getAttribute("id"));
}, xb = () => (f_ || C_.variantInputs.forEach((Qe) => {
  if (Qe) {
    const Mt = parseInt(Qe.value);
    f_ = k_.product.variants.find((pt) => pt.id === Mt);
  }
}), f_), bb = (Qe) => {
  clearTimeout(window.variantChangeTimeout), window.variantChangeTimeout = setTimeout(() => {
    Qe();
  }, 300);
}, wb = (Qe) => (C_.variantInputs.forEach((Mt) => {
  Mt.addEventListener("change", Qe);
}), () => {
  C_.variantInputs.forEach((Mt) => {
    Mt.removeEventListener("change", Qe);
  });
}), Eb = ({ product_cf: Qe, required: Mt, formId: pt, onBeforeInput: te, onChange: Ee }) => {
  const $ = (Q, r) => ({
    type: "text",
    id: Q.id.key,
    name: `properties[${Q.name}]`,
    autoComplete: "off",
    placeholder: Q.placeholder,
    form: r,
    required: Mt,
    className: `so-field__input ${Q.class || ""}`,
    minLength: Q.minlength > 0 ? Q.minlength : void 0,
    maxLength: Q.maxlength > 0 ? Q.maxlength : 20,
    onBeforeInput: te,
    onChange: Ee
  });
  return /* @__PURE__ */ gi.jsx("input", { ...$(Qe, pt) });
};
var jp = { exports: {} }, Sb = jp.exports, Jy;
function Tb() {
  return Jy || (Jy = 1, function(Qe, Mt) {
    (function(pt, te) {
      Qe.exports = te();
    })(Sb, function() {
      var pt, te, Ee;
      function $(r, F) {
        if (!pt)
          pt = F;
        else if (!te)
          te = F;
        else {
          var H = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + pt + ")(sharedChunk); (" + te + ")(sharedChunk); self.onerror = null;", P = {};
          pt(P), Ee = F(P), typeof window < "u" && window && window.URL && window.URL.createObjectURL && (Ee.workerUrl = window.URL.createObjectURL(new Blob([H], { type: "text/javascript" })));
        }
      }
      $(["exports"], function(r) {
        function F(a) {
          return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
        }
        var H, P = {}, M = {};
        function E() {
          if (H) return M;
          H = 1, Object.defineProperty(M, "__esModule", { value: !0 }), M.setMatrixArrayType = function(c) {
            M.ARRAY_TYPE = e = c;
          }, M.toRadian = function(c) {
            return c * o;
          }, M.equals = function(c, s) {
            return Math.abs(c - s) <= a * Math.max(1, Math.abs(c), Math.abs(s));
          }, M.RANDOM = M.ARRAY_TYPE = M.EPSILON = void 0;
          var a = 1e-6;
          M.EPSILON = a;
          var e = typeof Float32Array < "u" ? Float32Array : Array;
          M.ARRAY_TYPE = e;
          var i = Math.random;
          M.RANDOM = i;
          var o = Math.PI / 180;
          return Math.hypot || (Math.hypot = function() {
            for (var c = 0, s = arguments.length; s--; ) c += arguments[s] * arguments[s];
            return Math.sqrt(c);
          }), M;
        }
        var x, m = {};
        function I() {
          if (x) return m;
          function a(s) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
              return typeof h;
            } : function(h) {
              return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
            }, a(s);
          }
          x = 1, Object.defineProperty(m, "__esModule", { value: !0 }), m.create = function() {
            var s = new e.ARRAY_TYPE(4);
            return e.ARRAY_TYPE != Float32Array && (s[1] = 0, s[2] = 0), s[0] = 1, s[3] = 1, s;
          }, m.clone = function(s) {
            var h = new e.ARRAY_TYPE(4);
            return h[0] = s[0], h[1] = s[1], h[2] = s[2], h[3] = s[3], h;
          }, m.copy = function(s, h) {
            return s[0] = h[0], s[1] = h[1], s[2] = h[2], s[3] = h[3], s;
          }, m.identity = function(s) {
            return s[0] = 1, s[1] = 0, s[2] = 0, s[3] = 1, s;
          }, m.fromValues = function(s, h, y, T) {
            var k = new e.ARRAY_TYPE(4);
            return k[0] = s, k[1] = h, k[2] = y, k[3] = T, k;
          }, m.set = function(s, h, y, T, k) {
            return s[0] = h, s[1] = y, s[2] = T, s[3] = k, s;
          }, m.transpose = function(s, h) {
            if (s === h) {
              var y = h[1];
              s[1] = h[2], s[2] = y;
            } else s[0] = h[0], s[1] = h[2], s[2] = h[1], s[3] = h[3];
            return s;
          }, m.invert = function(s, h) {
            var y = h[0], T = h[1], k = h[2], g = h[3], A = y * g - k * T;
            return A ? (s[0] = g * (A = 1 / A), s[1] = -T * A, s[2] = -k * A, s[3] = y * A, s) : null;
          }, m.adjoint = function(s, h) {
            var y = h[0];
            return s[0] = h[3], s[1] = -h[1], s[2] = -h[2], s[3] = y, s;
          }, m.determinant = function(s) {
            return s[0] * s[3] - s[2] * s[1];
          }, m.multiply = o, m.rotate = function(s, h, y) {
            var T = h[0], k = h[1], g = h[2], A = h[3], D = Math.sin(y), S = Math.cos(y);
            return s[0] = T * S + g * D, s[1] = k * S + A * D, s[2] = T * -D + g * S, s[3] = k * -D + A * S, s;
          }, m.scale = function(s, h, y) {
            var T = h[1], k = h[2], g = h[3], A = y[0], D = y[1];
            return s[0] = h[0] * A, s[1] = T * A, s[2] = k * D, s[3] = g * D, s;
          }, m.fromRotation = function(s, h) {
            var y = Math.sin(h), T = Math.cos(h);
            return s[0] = T, s[1] = y, s[2] = -y, s[3] = T, s;
          }, m.fromScaling = function(s, h) {
            return s[0] = h[0], s[1] = 0, s[2] = 0, s[3] = h[1], s;
          }, m.str = function(s) {
            return "mat2(" + s[0] + ", " + s[1] + ", " + s[2] + ", " + s[3] + ")";
          }, m.frob = function(s) {
            return Math.hypot(s[0], s[1], s[2], s[3]);
          }, m.LDU = function(s, h, y, T) {
            return s[2] = T[2] / T[0], y[0] = T[0], y[1] = T[1], y[3] = T[3] - s[2] * y[1], [s, h, y];
          }, m.add = function(s, h, y) {
            return s[0] = h[0] + y[0], s[1] = h[1] + y[1], s[2] = h[2] + y[2], s[3] = h[3] + y[3], s;
          }, m.subtract = c, m.exactEquals = function(s, h) {
            return s[0] === h[0] && s[1] === h[1] && s[2] === h[2] && s[3] === h[3];
          }, m.equals = function(s, h) {
            var y = s[0], T = s[1], k = s[2], g = s[3], A = h[0], D = h[1], S = h[2], R = h[3];
            return Math.abs(y - A) <= e.EPSILON * Math.max(1, Math.abs(y), Math.abs(A)) && Math.abs(T - D) <= e.EPSILON * Math.max(1, Math.abs(T), Math.abs(D)) && Math.abs(k - S) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs(S)) && Math.abs(g - R) <= e.EPSILON * Math.max(1, Math.abs(g), Math.abs(R));
          }, m.multiplyScalar = function(s, h, y) {
            return s[0] = h[0] * y, s[1] = h[1] * y, s[2] = h[2] * y, s[3] = h[3] * y, s;
          }, m.multiplyScalarAndAdd = function(s, h, y, T) {
            return s[0] = h[0] + y[0] * T, s[1] = h[1] + y[1] * T, s[2] = h[2] + y[2] * T, s[3] = h[3] + y[3] * T, s;
          }, m.sub = m.mul = void 0;
          var e = function(s, h) {
            if (s && s.__esModule) return s;
            if (s === null || a(s) !== "object" && typeof s != "function") return { default: s };
            var y = i(void 0);
            if (y && y.has(s)) return y.get(s);
            var T = {}, k = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var g in s) if (g !== "default" && Object.prototype.hasOwnProperty.call(s, g)) {
              var A = k ? Object.getOwnPropertyDescriptor(s, g) : null;
              A && (A.get || A.set) ? Object.defineProperty(T, g, A) : T[g] = s[g];
            }
            return T.default = s, y && y.set(s, T), T;
          }(E());
          function i(s) {
            if (typeof WeakMap != "function") return null;
            var h = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap();
            return (i = function(T) {
              return T ? y : h;
            })(s);
          }
          function o(s, h, y) {
            var T = h[0], k = h[1], g = h[2], A = h[3], D = y[0], S = y[1], R = y[2], j = y[3];
            return s[0] = T * D + g * S, s[1] = k * D + A * S, s[2] = T * R + g * j, s[3] = k * R + A * j, s;
          }
          function c(s, h, y) {
            return s[0] = h[0] - y[0], s[1] = h[1] - y[1], s[2] = h[2] - y[2], s[3] = h[3] - y[3], s;
          }
          return m.mul = o, m.sub = c, m;
        }
        var z, w = {};
        function C() {
          if (z) return w;
          function a(s) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
              return typeof h;
            } : function(h) {
              return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
            }, a(s);
          }
          z = 1, Object.defineProperty(w, "__esModule", { value: !0 }), w.create = function() {
            var s = new e.ARRAY_TYPE(6);
            return e.ARRAY_TYPE != Float32Array && (s[1] = 0, s[2] = 0, s[4] = 0, s[5] = 0), s[0] = 1, s[3] = 1, s;
          }, w.clone = function(s) {
            var h = new e.ARRAY_TYPE(6);
            return h[0] = s[0], h[1] = s[1], h[2] = s[2], h[3] = s[3], h[4] = s[4], h[5] = s[5], h;
          }, w.copy = function(s, h) {
            return s[0] = h[0], s[1] = h[1], s[2] = h[2], s[3] = h[3], s[4] = h[4], s[5] = h[5], s;
          }, w.identity = function(s) {
            return s[0] = 1, s[1] = 0, s[2] = 0, s[3] = 1, s[4] = 0, s[5] = 0, s;
          }, w.fromValues = function(s, h, y, T, k, g) {
            var A = new e.ARRAY_TYPE(6);
            return A[0] = s, A[1] = h, A[2] = y, A[3] = T, A[4] = k, A[5] = g, A;
          }, w.set = function(s, h, y, T, k, g, A) {
            return s[0] = h, s[1] = y, s[2] = T, s[3] = k, s[4] = g, s[5] = A, s;
          }, w.invert = function(s, h) {
            var y = h[0], T = h[1], k = h[2], g = h[3], A = h[4], D = h[5], S = y * g - T * k;
            return S ? (s[0] = g * (S = 1 / S), s[1] = -T * S, s[2] = -k * S, s[3] = y * S, s[4] = (k * D - g * A) * S, s[5] = (T * A - y * D) * S, s) : null;
          }, w.determinant = function(s) {
            return s[0] * s[3] - s[1] * s[2];
          }, w.multiply = o, w.rotate = function(s, h, y) {
            var T = h[0], k = h[1], g = h[2], A = h[3], D = h[4], S = h[5], R = Math.sin(y), j = Math.cos(y);
            return s[0] = T * j + g * R, s[1] = k * j + A * R, s[2] = T * -R + g * j, s[3] = k * -R + A * j, s[4] = D, s[5] = S, s;
          }, w.scale = function(s, h, y) {
            var T = h[1], k = h[2], g = h[3], A = h[4], D = h[5], S = y[0], R = y[1];
            return s[0] = h[0] * S, s[1] = T * S, s[2] = k * R, s[3] = g * R, s[4] = A, s[5] = D, s;
          }, w.translate = function(s, h, y) {
            var T = h[0], k = h[1], g = h[2], A = h[3], D = h[4], S = h[5], R = y[0], j = y[1];
            return s[0] = T, s[1] = k, s[2] = g, s[3] = A, s[4] = T * R + g * j + D, s[5] = k * R + A * j + S, s;
          }, w.fromRotation = function(s, h) {
            var y = Math.sin(h), T = Math.cos(h);
            return s[0] = T, s[1] = y, s[2] = -y, s[3] = T, s[4] = 0, s[5] = 0, s;
          }, w.fromScaling = function(s, h) {
            return s[0] = h[0], s[1] = 0, s[2] = 0, s[3] = h[1], s[4] = 0, s[5] = 0, s;
          }, w.fromTranslation = function(s, h) {
            return s[0] = 1, s[1] = 0, s[2] = 0, s[3] = 1, s[4] = h[0], s[5] = h[1], s;
          }, w.str = function(s) {
            return "mat2d(" + s[0] + ", " + s[1] + ", " + s[2] + ", " + s[3] + ", " + s[4] + ", " + s[5] + ")";
          }, w.frob = function(s) {
            return Math.hypot(s[0], s[1], s[2], s[3], s[4], s[5], 1);
          }, w.add = function(s, h, y) {
            return s[0] = h[0] + y[0], s[1] = h[1] + y[1], s[2] = h[2] + y[2], s[3] = h[3] + y[3], s[4] = h[4] + y[4], s[5] = h[5] + y[5], s;
          }, w.subtract = c, w.multiplyScalar = function(s, h, y) {
            return s[0] = h[0] * y, s[1] = h[1] * y, s[2] = h[2] * y, s[3] = h[3] * y, s[4] = h[4] * y, s[5] = h[5] * y, s;
          }, w.multiplyScalarAndAdd = function(s, h, y, T) {
            return s[0] = h[0] + y[0] * T, s[1] = h[1] + y[1] * T, s[2] = h[2] + y[2] * T, s[3] = h[3] + y[3] * T, s[4] = h[4] + y[4] * T, s[5] = h[5] + y[5] * T, s;
          }, w.exactEquals = function(s, h) {
            return s[0] === h[0] && s[1] === h[1] && s[2] === h[2] && s[3] === h[3] && s[4] === h[4] && s[5] === h[5];
          }, w.equals = function(s, h) {
            var y = s[0], T = s[1], k = s[2], g = s[3], A = s[4], D = s[5], S = h[0], R = h[1], j = h[2], J = h[3], ne = h[4], me = h[5];
            return Math.abs(y - S) <= e.EPSILON * Math.max(1, Math.abs(y), Math.abs(S)) && Math.abs(T - R) <= e.EPSILON * Math.max(1, Math.abs(T), Math.abs(R)) && Math.abs(k - j) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs(j)) && Math.abs(g - J) <= e.EPSILON * Math.max(1, Math.abs(g), Math.abs(J)) && Math.abs(A - ne) <= e.EPSILON * Math.max(1, Math.abs(A), Math.abs(ne)) && Math.abs(D - me) <= e.EPSILON * Math.max(1, Math.abs(D), Math.abs(me));
          }, w.sub = w.mul = void 0;
          var e = function(s, h) {
            if (s && s.__esModule) return s;
            if (s === null || a(s) !== "object" && typeof s != "function") return { default: s };
            var y = i(void 0);
            if (y && y.has(s)) return y.get(s);
            var T = {}, k = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var g in s) if (g !== "default" && Object.prototype.hasOwnProperty.call(s, g)) {
              var A = k ? Object.getOwnPropertyDescriptor(s, g) : null;
              A && (A.get || A.set) ? Object.defineProperty(T, g, A) : T[g] = s[g];
            }
            return T.default = s, y && y.set(s, T), T;
          }(E());
          function i(s) {
            if (typeof WeakMap != "function") return null;
            var h = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap();
            return (i = function(T) {
              return T ? y : h;
            })(s);
          }
          function o(s, h, y) {
            var T = h[0], k = h[1], g = h[2], A = h[3], D = h[4], S = h[5], R = y[0], j = y[1], J = y[2], ne = y[3], me = y[4], ge = y[5];
            return s[0] = T * R + g * j, s[1] = k * R + A * j, s[2] = T * J + g * ne, s[3] = k * J + A * ne, s[4] = T * me + g * ge + D, s[5] = k * me + A * ge + S, s;
          }
          function c(s, h, y) {
            return s[0] = h[0] - y[0], s[1] = h[1] - y[1], s[2] = h[2] - y[2], s[3] = h[3] - y[3], s[4] = h[4] - y[4], s[5] = h[5] - y[5], s;
          }
          return w.mul = o, w.sub = c, w;
        }
        var b, B = {};
        function N() {
          if (b) return B;
          function a(s) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
              return typeof h;
            } : function(h) {
              return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
            }, a(s);
          }
          b = 1, Object.defineProperty(B, "__esModule", { value: !0 }), B.create = function() {
            var s = new e.ARRAY_TYPE(9);
            return e.ARRAY_TYPE != Float32Array && (s[1] = 0, s[2] = 0, s[3] = 0, s[5] = 0, s[6] = 0, s[7] = 0), s[0] = 1, s[4] = 1, s[8] = 1, s;
          }, B.fromMat4 = function(s, h) {
            return s[0] = h[0], s[1] = h[1], s[2] = h[2], s[3] = h[4], s[4] = h[5], s[5] = h[6], s[6] = h[8], s[7] = h[9], s[8] = h[10], s;
          }, B.clone = function(s) {
            var h = new e.ARRAY_TYPE(9);
            return h[0] = s[0], h[1] = s[1], h[2] = s[2], h[3] = s[3], h[4] = s[4], h[5] = s[5], h[6] = s[6], h[7] = s[7], h[8] = s[8], h;
          }, B.copy = function(s, h) {
            return s[0] = h[0], s[1] = h[1], s[2] = h[2], s[3] = h[3], s[4] = h[4], s[5] = h[5], s[6] = h[6], s[7] = h[7], s[8] = h[8], s;
          }, B.fromValues = function(s, h, y, T, k, g, A, D, S) {
            var R = new e.ARRAY_TYPE(9);
            return R[0] = s, R[1] = h, R[2] = y, R[3] = T, R[4] = k, R[5] = g, R[6] = A, R[7] = D, R[8] = S, R;
          }, B.set = function(s, h, y, T, k, g, A, D, S, R) {
            return s[0] = h, s[1] = y, s[2] = T, s[3] = k, s[4] = g, s[5] = A, s[6] = D, s[7] = S, s[8] = R, s;
          }, B.identity = function(s) {
            return s[0] = 1, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 1, s[5] = 0, s[6] = 0, s[7] = 0, s[8] = 1, s;
          }, B.transpose = function(s, h) {
            if (s === h) {
              var y = h[1], T = h[2], k = h[5];
              s[1] = h[3], s[2] = h[6], s[3] = y, s[5] = h[7], s[6] = T, s[7] = k;
            } else s[0] = h[0], s[1] = h[3], s[2] = h[6], s[3] = h[1], s[4] = h[4], s[5] = h[7], s[6] = h[2], s[7] = h[5], s[8] = h[8];
            return s;
          }, B.invert = function(s, h) {
            var y = h[0], T = h[1], k = h[2], g = h[3], A = h[4], D = h[5], S = h[6], R = h[7], j = h[8], J = j * A - D * R, ne = -j * g + D * S, me = R * g - A * S, ge = y * J + T * ne + k * me;
            return ge ? (s[0] = J * (ge = 1 / ge), s[1] = (-j * T + k * R) * ge, s[2] = (D * T - k * A) * ge, s[3] = ne * ge, s[4] = (j * y - k * S) * ge, s[5] = (-D * y + k * g) * ge, s[6] = me * ge, s[7] = (-R * y + T * S) * ge, s[8] = (A * y - T * g) * ge, s) : null;
          }, B.adjoint = function(s, h) {
            var y = h[0], T = h[1], k = h[2], g = h[3], A = h[4], D = h[5], S = h[6], R = h[7], j = h[8];
            return s[0] = A * j - D * R, s[1] = k * R - T * j, s[2] = T * D - k * A, s[3] = D * S - g * j, s[4] = y * j - k * S, s[5] = k * g - y * D, s[6] = g * R - A * S, s[7] = T * S - y * R, s[8] = y * A - T * g, s;
          }, B.determinant = function(s) {
            var h = s[3], y = s[4], T = s[5], k = s[6], g = s[7], A = s[8];
            return s[0] * (A * y - T * g) + s[1] * (-A * h + T * k) + s[2] * (g * h - y * k);
          }, B.multiply = o, B.translate = function(s, h, y) {
            var T = h[0], k = h[1], g = h[2], A = h[3], D = h[4], S = h[5], R = h[6], j = h[7], J = h[8], ne = y[0], me = y[1];
            return s[0] = T, s[1] = k, s[2] = g, s[3] = A, s[4] = D, s[5] = S, s[6] = ne * T + me * A + R, s[7] = ne * k + me * D + j, s[8] = ne * g + me * S + J, s;
          }, B.rotate = function(s, h, y) {
            var T = h[0], k = h[1], g = h[2], A = h[3], D = h[4], S = h[5], R = h[6], j = h[7], J = h[8], ne = Math.sin(y), me = Math.cos(y);
            return s[0] = me * T + ne * A, s[1] = me * k + ne * D, s[2] = me * g + ne * S, s[3] = me * A - ne * T, s[4] = me * D - ne * k, s[5] = me * S - ne * g, s[6] = R, s[7] = j, s[8] = J, s;
          }, B.scale = function(s, h, y) {
            var T = y[0], k = y[1];
            return s[0] = T * h[0], s[1] = T * h[1], s[2] = T * h[2], s[3] = k * h[3], s[4] = k * h[4], s[5] = k * h[5], s[6] = h[6], s[7] = h[7], s[8] = h[8], s;
          }, B.fromTranslation = function(s, h) {
            return s[0] = 1, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 1, s[5] = 0, s[6] = h[0], s[7] = h[1], s[8] = 1, s;
          }, B.fromRotation = function(s, h) {
            var y = Math.sin(h), T = Math.cos(h);
            return s[0] = T, s[1] = y, s[2] = 0, s[3] = -y, s[4] = T, s[5] = 0, s[6] = 0, s[7] = 0, s[8] = 1, s;
          }, B.fromScaling = function(s, h) {
            return s[0] = h[0], s[1] = 0, s[2] = 0, s[3] = 0, s[4] = h[1], s[5] = 0, s[6] = 0, s[7] = 0, s[8] = 1, s;
          }, B.fromMat2d = function(s, h) {
            return s[0] = h[0], s[1] = h[1], s[2] = 0, s[3] = h[2], s[4] = h[3], s[5] = 0, s[6] = h[4], s[7] = h[5], s[8] = 1, s;
          }, B.fromQuat = function(s, h) {
            var y = h[0], T = h[1], k = h[2], g = h[3], A = y + y, D = T + T, S = k + k, R = y * A, j = T * A, J = T * D, ne = k * A, me = k * D, ge = k * S, ue = g * A, Se = g * D, ke = g * S;
            return s[0] = 1 - J - ge, s[3] = j - ke, s[6] = ne + Se, s[1] = j + ke, s[4] = 1 - R - ge, s[7] = me - ue, s[2] = ne - Se, s[5] = me + ue, s[8] = 1 - R - J, s;
          }, B.normalFromMat4 = function(s, h) {
            var y = h[0], T = h[1], k = h[2], g = h[3], A = h[4], D = h[5], S = h[6], R = h[7], j = h[8], J = h[9], ne = h[10], me = h[11], ge = h[12], ue = h[13], Se = h[14], ke = h[15], He = y * D - T * A, at = y * S - k * A, nt = y * R - g * A, tt = T * S - k * D, Et = T * R - g * D, lt = k * R - g * S, St = j * ue - J * ge, Lt = j * Se - ne * ge, It = j * ke - me * ge, zt = J * Se - ne * ue, Ft = J * ke - me * ue, qt = ne * ke - me * Se, Ot = He * qt - at * Ft + nt * zt + tt * It - Et * Lt + lt * St;
            return Ot ? (s[0] = (D * qt - S * Ft + R * zt) * (Ot = 1 / Ot), s[1] = (S * It - A * qt - R * Lt) * Ot, s[2] = (A * Ft - D * It + R * St) * Ot, s[3] = (k * Ft - T * qt - g * zt) * Ot, s[4] = (y * qt - k * It + g * Lt) * Ot, s[5] = (T * It - y * Ft - g * St) * Ot, s[6] = (ue * lt - Se * Et + ke * tt) * Ot, s[7] = (Se * nt - ge * lt - ke * at) * Ot, s[8] = (ge * Et - ue * nt + ke * He) * Ot, s) : null;
          }, B.projection = function(s, h, y) {
            return s[0] = 2 / h, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = -2 / y, s[5] = 0, s[6] = -1, s[7] = 1, s[8] = 1, s;
          }, B.str = function(s) {
            return "mat3(" + s[0] + ", " + s[1] + ", " + s[2] + ", " + s[3] + ", " + s[4] + ", " + s[5] + ", " + s[6] + ", " + s[7] + ", " + s[8] + ")";
          }, B.frob = function(s) {
            return Math.hypot(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8]);
          }, B.add = function(s, h, y) {
            return s[0] = h[0] + y[0], s[1] = h[1] + y[1], s[2] = h[2] + y[2], s[3] = h[3] + y[3], s[4] = h[4] + y[4], s[5] = h[5] + y[5], s[6] = h[6] + y[6], s[7] = h[7] + y[7], s[8] = h[8] + y[8], s;
          }, B.subtract = c, B.multiplyScalar = function(s, h, y) {
            return s[0] = h[0] * y, s[1] = h[1] * y, s[2] = h[2] * y, s[3] = h[3] * y, s[4] = h[4] * y, s[5] = h[5] * y, s[6] = h[6] * y, s[7] = h[7] * y, s[8] = h[8] * y, s;
          }, B.multiplyScalarAndAdd = function(s, h, y, T) {
            return s[0] = h[0] + y[0] * T, s[1] = h[1] + y[1] * T, s[2] = h[2] + y[2] * T, s[3] = h[3] + y[3] * T, s[4] = h[4] + y[4] * T, s[5] = h[5] + y[5] * T, s[6] = h[6] + y[6] * T, s[7] = h[7] + y[7] * T, s[8] = h[8] + y[8] * T, s;
          }, B.exactEquals = function(s, h) {
            return s[0] === h[0] && s[1] === h[1] && s[2] === h[2] && s[3] === h[3] && s[4] === h[4] && s[5] === h[5] && s[6] === h[6] && s[7] === h[7] && s[8] === h[8];
          }, B.equals = function(s, h) {
            var y = s[0], T = s[1], k = s[2], g = s[3], A = s[4], D = s[5], S = s[6], R = s[7], j = s[8], J = h[0], ne = h[1], me = h[2], ge = h[3], ue = h[4], Se = h[5], ke = h[6], He = h[7], at = h[8];
            return Math.abs(y - J) <= e.EPSILON * Math.max(1, Math.abs(y), Math.abs(J)) && Math.abs(T - ne) <= e.EPSILON * Math.max(1, Math.abs(T), Math.abs(ne)) && Math.abs(k - me) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs(me)) && Math.abs(g - ge) <= e.EPSILON * Math.max(1, Math.abs(g), Math.abs(ge)) && Math.abs(A - ue) <= e.EPSILON * Math.max(1, Math.abs(A), Math.abs(ue)) && Math.abs(D - Se) <= e.EPSILON * Math.max(1, Math.abs(D), Math.abs(Se)) && Math.abs(S - ke) <= e.EPSILON * Math.max(1, Math.abs(S), Math.abs(ke)) && Math.abs(R - He) <= e.EPSILON * Math.max(1, Math.abs(R), Math.abs(He)) && Math.abs(j - at) <= e.EPSILON * Math.max(1, Math.abs(j), Math.abs(at));
          }, B.sub = B.mul = void 0;
          var e = function(s, h) {
            if (s && s.__esModule) return s;
            if (s === null || a(s) !== "object" && typeof s != "function") return { default: s };
            var y = i(void 0);
            if (y && y.has(s)) return y.get(s);
            var T = {}, k = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var g in s) if (g !== "default" && Object.prototype.hasOwnProperty.call(s, g)) {
              var A = k ? Object.getOwnPropertyDescriptor(s, g) : null;
              A && (A.get || A.set) ? Object.defineProperty(T, g, A) : T[g] = s[g];
            }
            return T.default = s, y && y.set(s, T), T;
          }(E());
          function i(s) {
            if (typeof WeakMap != "function") return null;
            var h = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap();
            return (i = function(T) {
              return T ? y : h;
            })(s);
          }
          function o(s, h, y) {
            var T = h[0], k = h[1], g = h[2], A = h[3], D = h[4], S = h[5], R = h[6], j = h[7], J = h[8], ne = y[0], me = y[1], ge = y[2], ue = y[3], Se = y[4], ke = y[5], He = y[6], at = y[7], nt = y[8];
            return s[0] = ne * T + me * A + ge * R, s[1] = ne * k + me * D + ge * j, s[2] = ne * g + me * S + ge * J, s[3] = ue * T + Se * A + ke * R, s[4] = ue * k + Se * D + ke * j, s[5] = ue * g + Se * S + ke * J, s[6] = He * T + at * A + nt * R, s[7] = He * k + at * D + nt * j, s[8] = He * g + at * S + nt * J, s;
          }
          function c(s, h, y) {
            return s[0] = h[0] - y[0], s[1] = h[1] - y[1], s[2] = h[2] - y[2], s[3] = h[3] - y[3], s[4] = h[4] - y[4], s[5] = h[5] - y[5], s[6] = h[6] - y[6], s[7] = h[7] - y[7], s[8] = h[8] - y[8], s;
          }
          return B.mul = o, B.sub = c, B;
        }
        var U, V = {};
        function W() {
          if (U) return V;
          function a(g) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(A) {
              return typeof A;
            } : function(A) {
              return A && typeof Symbol == "function" && A.constructor === Symbol && A !== Symbol.prototype ? "symbol" : typeof A;
            }, a(g);
          }
          U = 1, Object.defineProperty(V, "__esModule", { value: !0 }), V.create = function() {
            var g = new e.ARRAY_TYPE(16);
            return e.ARRAY_TYPE != Float32Array && (g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[6] = 0, g[7] = 0, g[8] = 0, g[9] = 0, g[11] = 0, g[12] = 0, g[13] = 0, g[14] = 0), g[0] = 1, g[5] = 1, g[10] = 1, g[15] = 1, g;
          }, V.clone = function(g) {
            var A = new e.ARRAY_TYPE(16);
            return A[0] = g[0], A[1] = g[1], A[2] = g[2], A[3] = g[3], A[4] = g[4], A[5] = g[5], A[6] = g[6], A[7] = g[7], A[8] = g[8], A[9] = g[9], A[10] = g[10], A[11] = g[11], A[12] = g[12], A[13] = g[13], A[14] = g[14], A[15] = g[15], A;
          }, V.copy = function(g, A) {
            return g[0] = A[0], g[1] = A[1], g[2] = A[2], g[3] = A[3], g[4] = A[4], g[5] = A[5], g[6] = A[6], g[7] = A[7], g[8] = A[8], g[9] = A[9], g[10] = A[10], g[11] = A[11], g[12] = A[12], g[13] = A[13], g[14] = A[14], g[15] = A[15], g;
          }, V.fromValues = function(g, A, D, S, R, j, J, ne, me, ge, ue, Se, ke, He, at, nt) {
            var tt = new e.ARRAY_TYPE(16);
            return tt[0] = g, tt[1] = A, tt[2] = D, tt[3] = S, tt[4] = R, tt[5] = j, tt[6] = J, tt[7] = ne, tt[8] = me, tt[9] = ge, tt[10] = ue, tt[11] = Se, tt[12] = ke, tt[13] = He, tt[14] = at, tt[15] = nt, tt;
          }, V.set = function(g, A, D, S, R, j, J, ne, me, ge, ue, Se, ke, He, at, nt, tt) {
            return g[0] = A, g[1] = D, g[2] = S, g[3] = R, g[4] = j, g[5] = J, g[6] = ne, g[7] = me, g[8] = ge, g[9] = ue, g[10] = Se, g[11] = ke, g[12] = He, g[13] = at, g[14] = nt, g[15] = tt, g;
          }, V.identity = o, V.transpose = function(g, A) {
            if (g === A) {
              var D = A[1], S = A[2], R = A[3], j = A[6], J = A[7], ne = A[11];
              g[1] = A[4], g[2] = A[8], g[3] = A[12], g[4] = D, g[6] = A[9], g[7] = A[13], g[8] = S, g[9] = j, g[11] = A[14], g[12] = R, g[13] = J, g[14] = ne;
            } else g[0] = A[0], g[1] = A[4], g[2] = A[8], g[3] = A[12], g[4] = A[1], g[5] = A[5], g[6] = A[9], g[7] = A[13], g[8] = A[2], g[9] = A[6], g[10] = A[10], g[11] = A[14], g[12] = A[3], g[13] = A[7], g[14] = A[11], g[15] = A[15];
            return g;
          }, V.invert = function(g, A) {
            var D = A[0], S = A[1], R = A[2], j = A[3], J = A[4], ne = A[5], me = A[6], ge = A[7], ue = A[8], Se = A[9], ke = A[10], He = A[11], at = A[12], nt = A[13], tt = A[14], Et = A[15], lt = D * ne - S * J, St = D * me - R * J, Lt = D * ge - j * J, It = S * me - R * ne, zt = S * ge - j * ne, Ft = R * ge - j * me, qt = ue * nt - Se * at, Ot = ue * tt - ke * at, cr = ue * Et - He * at, yr = Se * tt - ke * nt, ur = Se * Et - He * nt, jr = ke * Et - He * tt, zr = lt * jr - St * ur + Lt * yr + It * cr - zt * Ot + Ft * qt;
            return zr ? (g[0] = (ne * jr - me * ur + ge * yr) * (zr = 1 / zr), g[1] = (R * ur - S * jr - j * yr) * zr, g[2] = (nt * Ft - tt * zt + Et * It) * zr, g[3] = (ke * zt - Se * Ft - He * It) * zr, g[4] = (me * cr - J * jr - ge * Ot) * zr, g[5] = (D * jr - R * cr + j * Ot) * zr, g[6] = (tt * Lt - at * Ft - Et * St) * zr, g[7] = (ue * Ft - ke * Lt + He * St) * zr, g[8] = (J * ur - ne * cr + ge * qt) * zr, g[9] = (S * cr - D * ur - j * qt) * zr, g[10] = (at * zt - nt * Lt + Et * lt) * zr, g[11] = (Se * Lt - ue * zt - He * lt) * zr, g[12] = (ne * Ot - J * yr - me * qt) * zr, g[13] = (D * yr - S * Ot + R * qt) * zr, g[14] = (nt * St - at * It - tt * lt) * zr, g[15] = (ue * It - Se * St + ke * lt) * zr, g) : null;
          }, V.adjoint = function(g, A) {
            var D = A[0], S = A[1], R = A[2], j = A[3], J = A[4], ne = A[5], me = A[6], ge = A[7], ue = A[8], Se = A[9], ke = A[10], He = A[11], at = A[12], nt = A[13], tt = A[14], Et = A[15];
            return g[0] = ne * (ke * Et - He * tt) - Se * (me * Et - ge * tt) + nt * (me * He - ge * ke), g[1] = -(S * (ke * Et - He * tt) - Se * (R * Et - j * tt) + nt * (R * He - j * ke)), g[2] = S * (me * Et - ge * tt) - ne * (R * Et - j * tt) + nt * (R * ge - j * me), g[3] = -(S * (me * He - ge * ke) - ne * (R * He - j * ke) + Se * (R * ge - j * me)), g[4] = -(J * (ke * Et - He * tt) - ue * (me * Et - ge * tt) + at * (me * He - ge * ke)), g[5] = D * (ke * Et - He * tt) - ue * (R * Et - j * tt) + at * (R * He - j * ke), g[6] = -(D * (me * Et - ge * tt) - J * (R * Et - j * tt) + at * (R * ge - j * me)), g[7] = D * (me * He - ge * ke) - J * (R * He - j * ke) + ue * (R * ge - j * me), g[8] = J * (Se * Et - He * nt) - ue * (ne * Et - ge * nt) + at * (ne * He - ge * Se), g[9] = -(D * (Se * Et - He * nt) - ue * (S * Et - j * nt) + at * (S * He - j * Se)), g[10] = D * (ne * Et - ge * nt) - J * (S * Et - j * nt) + at * (S * ge - j * ne), g[11] = -(D * (ne * He - ge * Se) - J * (S * He - j * Se) + ue * (S * ge - j * ne)), g[12] = -(J * (Se * tt - ke * nt) - ue * (ne * tt - me * nt) + at * (ne * ke - me * Se)), g[13] = D * (Se * tt - ke * nt) - ue * (S * tt - R * nt) + at * (S * ke - R * Se), g[14] = -(D * (ne * tt - me * nt) - J * (S * tt - R * nt) + at * (S * me - R * ne)), g[15] = D * (ne * ke - me * Se) - J * (S * ke - R * Se) + ue * (S * me - R * ne), g;
          }, V.determinant = function(g) {
            var A = g[0], D = g[1], S = g[2], R = g[3], j = g[4], J = g[5], ne = g[6], me = g[7], ge = g[8], ue = g[9], Se = g[10], ke = g[11], He = g[12], at = g[13], nt = g[14], tt = g[15];
            return (A * J - D * j) * (Se * tt - ke * nt) - (A * ne - S * j) * (ue * tt - ke * at) + (A * me - R * j) * (ue * nt - Se * at) + (D * ne - S * J) * (ge * tt - ke * He) - (D * me - R * J) * (ge * nt - Se * He) + (S * me - R * ne) * (ge * at - ue * He);
          }, V.multiply = c, V.translate = function(g, A, D) {
            var S, R, j, J, ne, me, ge, ue, Se, ke, He, at, nt = D[0], tt = D[1], Et = D[2];
            return A === g ? (g[12] = A[0] * nt + A[4] * tt + A[8] * Et + A[12], g[13] = A[1] * nt + A[5] * tt + A[9] * Et + A[13], g[14] = A[2] * nt + A[6] * tt + A[10] * Et + A[14], g[15] = A[3] * nt + A[7] * tt + A[11] * Et + A[15]) : (R = A[1], j = A[2], J = A[3], ne = A[4], me = A[5], ge = A[6], ue = A[7], Se = A[8], ke = A[9], He = A[10], at = A[11], g[0] = S = A[0], g[1] = R, g[2] = j, g[3] = J, g[4] = ne, g[5] = me, g[6] = ge, g[7] = ue, g[8] = Se, g[9] = ke, g[10] = He, g[11] = at, g[12] = S * nt + ne * tt + Se * Et + A[12], g[13] = R * nt + me * tt + ke * Et + A[13], g[14] = j * nt + ge * tt + He * Et + A[14], g[15] = J * nt + ue * tt + at * Et + A[15]), g;
          }, V.scale = function(g, A, D) {
            var S = D[0], R = D[1], j = D[2];
            return g[0] = A[0] * S, g[1] = A[1] * S, g[2] = A[2] * S, g[3] = A[3] * S, g[4] = A[4] * R, g[5] = A[5] * R, g[6] = A[6] * R, g[7] = A[7] * R, g[8] = A[8] * j, g[9] = A[9] * j, g[10] = A[10] * j, g[11] = A[11] * j, g[12] = A[12], g[13] = A[13], g[14] = A[14], g[15] = A[15], g;
          }, V.rotate = function(g, A, D, S) {
            var R, j, J, ne, me, ge, ue, Se, ke, He, at, nt, tt, Et, lt, St, Lt, It, zt, Ft, qt, Ot, cr, yr, ur = S[0], jr = S[1], zr = S[2], Ar = Math.hypot(ur, jr, zr);
            return Ar < e.EPSILON ? null : (ur *= Ar = 1 / Ar, jr *= Ar, zr *= Ar, R = Math.sin(D), j = Math.cos(D), me = A[1], ge = A[2], ue = A[3], ke = A[5], He = A[6], at = A[7], tt = A[9], Et = A[10], lt = A[11], St = ur * ur * (J = 1 - j) + j, zt = ur * jr * J - zr * R, Ft = jr * jr * J + j, qt = zr * jr * J + ur * R, Ot = ur * zr * J + jr * R, cr = jr * zr * J - ur * R, yr = zr * zr * J + j, g[0] = (ne = A[0]) * St + (Se = A[4]) * (Lt = jr * ur * J + zr * R) + (nt = A[8]) * (It = zr * ur * J - jr * R), g[1] = me * St + ke * Lt + tt * It, g[2] = ge * St + He * Lt + Et * It, g[3] = ue * St + at * Lt + lt * It, g[4] = ne * zt + Se * Ft + nt * qt, g[5] = me * zt + ke * Ft + tt * qt, g[6] = ge * zt + He * Ft + Et * qt, g[7] = ue * zt + at * Ft + lt * qt, g[8] = ne * Ot + Se * cr + nt * yr, g[9] = me * Ot + ke * cr + tt * yr, g[10] = ge * Ot + He * cr + Et * yr, g[11] = ue * Ot + at * cr + lt * yr, A !== g && (g[12] = A[12], g[13] = A[13], g[14] = A[14], g[15] = A[15]), g);
          }, V.rotateX = function(g, A, D) {
            var S = Math.sin(D), R = Math.cos(D), j = A[4], J = A[5], ne = A[6], me = A[7], ge = A[8], ue = A[9], Se = A[10], ke = A[11];
            return A !== g && (g[0] = A[0], g[1] = A[1], g[2] = A[2], g[3] = A[3], g[12] = A[12], g[13] = A[13], g[14] = A[14], g[15] = A[15]), g[4] = j * R + ge * S, g[5] = J * R + ue * S, g[6] = ne * R + Se * S, g[7] = me * R + ke * S, g[8] = ge * R - j * S, g[9] = ue * R - J * S, g[10] = Se * R - ne * S, g[11] = ke * R - me * S, g;
          }, V.rotateY = function(g, A, D) {
            var S = Math.sin(D), R = Math.cos(D), j = A[0], J = A[1], ne = A[2], me = A[3], ge = A[8], ue = A[9], Se = A[10], ke = A[11];
            return A !== g && (g[4] = A[4], g[5] = A[5], g[6] = A[6], g[7] = A[7], g[12] = A[12], g[13] = A[13], g[14] = A[14], g[15] = A[15]), g[0] = j * R - ge * S, g[1] = J * R - ue * S, g[2] = ne * R - Se * S, g[3] = me * R - ke * S, g[8] = j * S + ge * R, g[9] = J * S + ue * R, g[10] = ne * S + Se * R, g[11] = me * S + ke * R, g;
          }, V.rotateZ = function(g, A, D) {
            var S = Math.sin(D), R = Math.cos(D), j = A[0], J = A[1], ne = A[2], me = A[3], ge = A[4], ue = A[5], Se = A[6], ke = A[7];
            return A !== g && (g[8] = A[8], g[9] = A[9], g[10] = A[10], g[11] = A[11], g[12] = A[12], g[13] = A[13], g[14] = A[14], g[15] = A[15]), g[0] = j * R + ge * S, g[1] = J * R + ue * S, g[2] = ne * R + Se * S, g[3] = me * R + ke * S, g[4] = ge * R - j * S, g[5] = ue * R - J * S, g[6] = Se * R - ne * S, g[7] = ke * R - me * S, g;
          }, V.fromTranslation = function(g, A) {
            return g[0] = 1, g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[5] = 1, g[6] = 0, g[7] = 0, g[8] = 0, g[9] = 0, g[10] = 1, g[11] = 0, g[12] = A[0], g[13] = A[1], g[14] = A[2], g[15] = 1, g;
          }, V.fromScaling = function(g, A) {
            return g[0] = A[0], g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[5] = A[1], g[6] = 0, g[7] = 0, g[8] = 0, g[9] = 0, g[10] = A[2], g[11] = 0, g[12] = 0, g[13] = 0, g[14] = 0, g[15] = 1, g;
          }, V.fromRotation = function(g, A, D) {
            var S, R, j, J = D[0], ne = D[1], me = D[2], ge = Math.hypot(J, ne, me);
            return ge < e.EPSILON ? null : (J *= ge = 1 / ge, ne *= ge, me *= ge, S = Math.sin(A), R = Math.cos(A), g[0] = J * J * (j = 1 - R) + R, g[1] = ne * J * j + me * S, g[2] = me * J * j - ne * S, g[3] = 0, g[4] = J * ne * j - me * S, g[5] = ne * ne * j + R, g[6] = me * ne * j + J * S, g[7] = 0, g[8] = J * me * j + ne * S, g[9] = ne * me * j - J * S, g[10] = me * me * j + R, g[11] = 0, g[12] = 0, g[13] = 0, g[14] = 0, g[15] = 1, g);
          }, V.fromXRotation = function(g, A) {
            var D = Math.sin(A), S = Math.cos(A);
            return g[0] = 1, g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[5] = S, g[6] = D, g[7] = 0, g[8] = 0, g[9] = -D, g[10] = S, g[11] = 0, g[12] = 0, g[13] = 0, g[14] = 0, g[15] = 1, g;
          }, V.fromYRotation = function(g, A) {
            var D = Math.sin(A), S = Math.cos(A);
            return g[0] = S, g[1] = 0, g[2] = -D, g[3] = 0, g[4] = 0, g[5] = 1, g[6] = 0, g[7] = 0, g[8] = D, g[9] = 0, g[10] = S, g[11] = 0, g[12] = 0, g[13] = 0, g[14] = 0, g[15] = 1, g;
          }, V.fromZRotation = function(g, A) {
            var D = Math.sin(A), S = Math.cos(A);
            return g[0] = S, g[1] = D, g[2] = 0, g[3] = 0, g[4] = -D, g[5] = S, g[6] = 0, g[7] = 0, g[8] = 0, g[9] = 0, g[10] = 1, g[11] = 0, g[12] = 0, g[13] = 0, g[14] = 0, g[15] = 1, g;
          }, V.fromRotationTranslation = s, V.fromQuat2 = function(g, A) {
            var D = new e.ARRAY_TYPE(3), S = -A[0], R = -A[1], j = -A[2], J = A[3], ne = A[4], me = A[5], ge = A[6], ue = A[7], Se = S * S + R * R + j * j + J * J;
            return Se > 0 ? (D[0] = 2 * (ne * J + ue * S + me * j - ge * R) / Se, D[1] = 2 * (me * J + ue * R + ge * S - ne * j) / Se, D[2] = 2 * (ge * J + ue * j + ne * R - me * S) / Se) : (D[0] = 2 * (ne * J + ue * S + me * j - ge * R), D[1] = 2 * (me * J + ue * R + ge * S - ne * j), D[2] = 2 * (ge * J + ue * j + ne * R - me * S)), s(g, A, D), g;
          }, V.getTranslation = function(g, A) {
            return g[0] = A[12], g[1] = A[13], g[2] = A[14], g;
          }, V.getScaling = h, V.getRotation = function(g, A) {
            var D = new e.ARRAY_TYPE(3);
            h(D, A);
            var S = 1 / D[0], R = 1 / D[1], j = 1 / D[2], J = A[0] * S, ne = A[1] * R, me = A[2] * j, ge = A[4] * S, ue = A[5] * R, Se = A[6] * j, ke = A[8] * S, He = A[9] * R, at = A[10] * j, nt = J + ue + at, tt = 0;
            return nt > 0 ? (tt = 2 * Math.sqrt(nt + 1), g[3] = 0.25 * tt, g[0] = (Se - He) / tt, g[1] = (ke - me) / tt, g[2] = (ne - ge) / tt) : J > ue && J > at ? (tt = 2 * Math.sqrt(1 + J - ue - at), g[3] = (Se - He) / tt, g[0] = 0.25 * tt, g[1] = (ne + ge) / tt, g[2] = (ke + me) / tt) : ue > at ? (tt = 2 * Math.sqrt(1 + ue - J - at), g[3] = (ke - me) / tt, g[0] = (ne + ge) / tt, g[1] = 0.25 * tt, g[2] = (Se + He) / tt) : (tt = 2 * Math.sqrt(1 + at - J - ue), g[3] = (ne - ge) / tt, g[0] = (ke + me) / tt, g[1] = (Se + He) / tt, g[2] = 0.25 * tt), g;
          }, V.fromRotationTranslationScale = function(g, A, D, S) {
            var R = A[0], j = A[1], J = A[2], ne = A[3], me = R + R, ge = j + j, ue = J + J, Se = R * me, ke = R * ge, He = R * ue, at = j * ge, nt = j * ue, tt = J * ue, Et = ne * me, lt = ne * ge, St = ne * ue, Lt = S[0], It = S[1], zt = S[2];
            return g[0] = (1 - (at + tt)) * Lt, g[1] = (ke + St) * Lt, g[2] = (He - lt) * Lt, g[3] = 0, g[4] = (ke - St) * It, g[5] = (1 - (Se + tt)) * It, g[6] = (nt + Et) * It, g[7] = 0, g[8] = (He + lt) * zt, g[9] = (nt - Et) * zt, g[10] = (1 - (Se + at)) * zt, g[11] = 0, g[12] = D[0], g[13] = D[1], g[14] = D[2], g[15] = 1, g;
          }, V.fromRotationTranslationScaleOrigin = function(g, A, D, S, R) {
            var j = A[0], J = A[1], ne = A[2], me = A[3], ge = j + j, ue = J + J, Se = ne + ne, ke = j * ge, He = j * ue, at = j * Se, nt = J * ue, tt = J * Se, Et = ne * Se, lt = me * ge, St = me * ue, Lt = me * Se, It = S[0], zt = S[1], Ft = S[2], qt = R[0], Ot = R[1], cr = R[2], yr = (1 - (nt + Et)) * It, ur = (He + Lt) * It, jr = (at - St) * It, zr = (He - Lt) * zt, Ar = (1 - (ke + Et)) * zt, vr = (tt + lt) * zt, ti = (at + St) * Ft, Wr = (tt - lt) * Ft, $r = (1 - (ke + nt)) * Ft;
            return g[0] = yr, g[1] = ur, g[2] = jr, g[3] = 0, g[4] = zr, g[5] = Ar, g[6] = vr, g[7] = 0, g[8] = ti, g[9] = Wr, g[10] = $r, g[11] = 0, g[12] = D[0] + qt - (yr * qt + zr * Ot + ti * cr), g[13] = D[1] + Ot - (ur * qt + Ar * Ot + Wr * cr), g[14] = D[2] + cr - (jr * qt + vr * Ot + $r * cr), g[15] = 1, g;
          }, V.fromQuat = function(g, A) {
            var D = A[0], S = A[1], R = A[2], j = A[3], J = D + D, ne = S + S, me = R + R, ge = D * J, ue = S * J, Se = S * ne, ke = R * J, He = R * ne, at = R * me, nt = j * J, tt = j * ne, Et = j * me;
            return g[0] = 1 - Se - at, g[1] = ue + Et, g[2] = ke - tt, g[3] = 0, g[4] = ue - Et, g[5] = 1 - ge - at, g[6] = He + nt, g[7] = 0, g[8] = ke + tt, g[9] = He - nt, g[10] = 1 - ge - Se, g[11] = 0, g[12] = 0, g[13] = 0, g[14] = 0, g[15] = 1, g;
          }, V.frustum = function(g, A, D, S, R, j, J) {
            var ne = 1 / (D - A), me = 1 / (R - S), ge = 1 / (j - J);
            return g[0] = 2 * j * ne, g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[5] = 2 * j * me, g[6] = 0, g[7] = 0, g[8] = (D + A) * ne, g[9] = (R + S) * me, g[10] = (J + j) * ge, g[11] = -1, g[12] = 0, g[13] = 0, g[14] = J * j * 2 * ge, g[15] = 0, g;
          }, V.perspectiveNO = y, V.perspectiveZO = function(g, A, D, S, R) {
            var j, J = 1 / Math.tan(A / 2);
            return g[0] = J / D, g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[5] = J, g[6] = 0, g[7] = 0, g[8] = 0, g[9] = 0, g[11] = -1, g[12] = 0, g[13] = 0, g[15] = 0, R != null && R !== 1 / 0 ? (g[10] = R * (j = 1 / (S - R)), g[14] = R * S * j) : (g[10] = -1, g[14] = -S), g;
          }, V.perspectiveFromFieldOfView = function(g, A, D, S) {
            var R = Math.tan(A.upDegrees * Math.PI / 180), j = Math.tan(A.downDegrees * Math.PI / 180), J = Math.tan(A.leftDegrees * Math.PI / 180), ne = Math.tan(A.rightDegrees * Math.PI / 180), me = 2 / (J + ne), ge = 2 / (R + j);
            return g[0] = me, g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[5] = ge, g[6] = 0, g[7] = 0, g[8] = -(J - ne) * me * 0.5, g[9] = (R - j) * ge * 0.5, g[10] = S / (D - S), g[11] = -1, g[12] = 0, g[13] = 0, g[14] = S * D / (D - S), g[15] = 0, g;
          }, V.orthoNO = T, V.orthoZO = function(g, A, D, S, R, j, J) {
            var ne = 1 / (A - D), me = 1 / (S - R), ge = 1 / (j - J);
            return g[0] = -2 * ne, g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[5] = -2 * me, g[6] = 0, g[7] = 0, g[8] = 0, g[9] = 0, g[10] = ge, g[11] = 0, g[12] = (A + D) * ne, g[13] = (R + S) * me, g[14] = j * ge, g[15] = 1, g;
          }, V.lookAt = function(g, A, D, S) {
            var R, j, J, ne, me, ge, ue, Se, ke, He, at = A[0], nt = A[1], tt = A[2], Et = S[0], lt = S[1], St = S[2], Lt = D[0], It = D[1], zt = D[2];
            return Math.abs(at - Lt) < e.EPSILON && Math.abs(nt - It) < e.EPSILON && Math.abs(tt - zt) < e.EPSILON ? o(g) : (ue = at - Lt, Se = nt - It, ke = tt - zt, R = lt * (ke *= He = 1 / Math.hypot(ue, Se, ke)) - St * (Se *= He), j = St * (ue *= He) - Et * ke, J = Et * Se - lt * ue, (He = Math.hypot(R, j, J)) ? (R *= He = 1 / He, j *= He, J *= He) : (R = 0, j = 0, J = 0), ne = Se * J - ke * j, me = ke * R - ue * J, ge = ue * j - Se * R, (He = Math.hypot(ne, me, ge)) ? (ne *= He = 1 / He, me *= He, ge *= He) : (ne = 0, me = 0, ge = 0), g[0] = R, g[1] = ne, g[2] = ue, g[3] = 0, g[4] = j, g[5] = me, g[6] = Se, g[7] = 0, g[8] = J, g[9] = ge, g[10] = ke, g[11] = 0, g[12] = -(R * at + j * nt + J * tt), g[13] = -(ne * at + me * nt + ge * tt), g[14] = -(ue * at + Se * nt + ke * tt), g[15] = 1, g);
          }, V.targetTo = function(g, A, D, S) {
            var R = A[0], j = A[1], J = A[2], ne = S[0], me = S[1], ge = S[2], ue = R - D[0], Se = j - D[1], ke = J - D[2], He = ue * ue + Se * Se + ke * ke;
            He > 0 && (ue *= He = 1 / Math.sqrt(He), Se *= He, ke *= He);
            var at = me * ke - ge * Se, nt = ge * ue - ne * ke, tt = ne * Se - me * ue;
            return (He = at * at + nt * nt + tt * tt) > 0 && (at *= He = 1 / Math.sqrt(He), nt *= He, tt *= He), g[0] = at, g[1] = nt, g[2] = tt, g[3] = 0, g[4] = Se * tt - ke * nt, g[5] = ke * at - ue * tt, g[6] = ue * nt - Se * at, g[7] = 0, g[8] = ue, g[9] = Se, g[10] = ke, g[11] = 0, g[12] = R, g[13] = j, g[14] = J, g[15] = 1, g;
          }, V.str = function(g) {
            return "mat4(" + g[0] + ", " + g[1] + ", " + g[2] + ", " + g[3] + ", " + g[4] + ", " + g[5] + ", " + g[6] + ", " + g[7] + ", " + g[8] + ", " + g[9] + ", " + g[10] + ", " + g[11] + ", " + g[12] + ", " + g[13] + ", " + g[14] + ", " + g[15] + ")";
          }, V.frob = function(g) {
            return Math.hypot(g[0], g[1], g[2], g[3], g[4], g[5], g[6], g[7], g[8], g[9], g[10], g[11], g[12], g[13], g[14], g[15]);
          }, V.add = function(g, A, D) {
            return g[0] = A[0] + D[0], g[1] = A[1] + D[1], g[2] = A[2] + D[2], g[3] = A[3] + D[3], g[4] = A[4] + D[4], g[5] = A[5] + D[5], g[6] = A[6] + D[6], g[7] = A[7] + D[7], g[8] = A[8] + D[8], g[9] = A[9] + D[9], g[10] = A[10] + D[10], g[11] = A[11] + D[11], g[12] = A[12] + D[12], g[13] = A[13] + D[13], g[14] = A[14] + D[14], g[15] = A[15] + D[15], g;
          }, V.subtract = k, V.multiplyScalar = function(g, A, D) {
            return g[0] = A[0] * D, g[1] = A[1] * D, g[2] = A[2] * D, g[3] = A[3] * D, g[4] = A[4] * D, g[5] = A[5] * D, g[6] = A[6] * D, g[7] = A[7] * D, g[8] = A[8] * D, g[9] = A[9] * D, g[10] = A[10] * D, g[11] = A[11] * D, g[12] = A[12] * D, g[13] = A[13] * D, g[14] = A[14] * D, g[15] = A[15] * D, g;
          }, V.multiplyScalarAndAdd = function(g, A, D, S) {
            return g[0] = A[0] + D[0] * S, g[1] = A[1] + D[1] * S, g[2] = A[2] + D[2] * S, g[3] = A[3] + D[3] * S, g[4] = A[4] + D[4] * S, g[5] = A[5] + D[5] * S, g[6] = A[6] + D[6] * S, g[7] = A[7] + D[7] * S, g[8] = A[8] + D[8] * S, g[9] = A[9] + D[9] * S, g[10] = A[10] + D[10] * S, g[11] = A[11] + D[11] * S, g[12] = A[12] + D[12] * S, g[13] = A[13] + D[13] * S, g[14] = A[14] + D[14] * S, g[15] = A[15] + D[15] * S, g;
          }, V.exactEquals = function(g, A) {
            return g[0] === A[0] && g[1] === A[1] && g[2] === A[2] && g[3] === A[3] && g[4] === A[4] && g[5] === A[5] && g[6] === A[6] && g[7] === A[7] && g[8] === A[8] && g[9] === A[9] && g[10] === A[10] && g[11] === A[11] && g[12] === A[12] && g[13] === A[13] && g[14] === A[14] && g[15] === A[15];
          }, V.equals = function(g, A) {
            var D = g[0], S = g[1], R = g[2], j = g[3], J = g[4], ne = g[5], me = g[6], ge = g[7], ue = g[8], Se = g[9], ke = g[10], He = g[11], at = g[12], nt = g[13], tt = g[14], Et = g[15], lt = A[0], St = A[1], Lt = A[2], It = A[3], zt = A[4], Ft = A[5], qt = A[6], Ot = A[7], cr = A[8], yr = A[9], ur = A[10], jr = A[11], zr = A[12], Ar = A[13], vr = A[14], ti = A[15];
            return Math.abs(D - lt) <= e.EPSILON * Math.max(1, Math.abs(D), Math.abs(lt)) && Math.abs(S - St) <= e.EPSILON * Math.max(1, Math.abs(S), Math.abs(St)) && Math.abs(R - Lt) <= e.EPSILON * Math.max(1, Math.abs(R), Math.abs(Lt)) && Math.abs(j - It) <= e.EPSILON * Math.max(1, Math.abs(j), Math.abs(It)) && Math.abs(J - zt) <= e.EPSILON * Math.max(1, Math.abs(J), Math.abs(zt)) && Math.abs(ne - Ft) <= e.EPSILON * Math.max(1, Math.abs(ne), Math.abs(Ft)) && Math.abs(me - qt) <= e.EPSILON * Math.max(1, Math.abs(me), Math.abs(qt)) && Math.abs(ge - Ot) <= e.EPSILON * Math.max(1, Math.abs(ge), Math.abs(Ot)) && Math.abs(ue - cr) <= e.EPSILON * Math.max(1, Math.abs(ue), Math.abs(cr)) && Math.abs(Se - yr) <= e.EPSILON * Math.max(1, Math.abs(Se), Math.abs(yr)) && Math.abs(ke - ur) <= e.EPSILON * Math.max(1, Math.abs(ke), Math.abs(ur)) && Math.abs(He - jr) <= e.EPSILON * Math.max(1, Math.abs(He), Math.abs(jr)) && Math.abs(at - zr) <= e.EPSILON * Math.max(1, Math.abs(at), Math.abs(zr)) && Math.abs(nt - Ar) <= e.EPSILON * Math.max(1, Math.abs(nt), Math.abs(Ar)) && Math.abs(tt - vr) <= e.EPSILON * Math.max(1, Math.abs(tt), Math.abs(vr)) && Math.abs(Et - ti) <= e.EPSILON * Math.max(1, Math.abs(Et), Math.abs(ti));
          }, V.sub = V.mul = V.ortho = V.perspective = void 0;
          var e = function(g, A) {
            if (g && g.__esModule) return g;
            if (g === null || a(g) !== "object" && typeof g != "function") return { default: g };
            var D = i(void 0);
            if (D && D.has(g)) return D.get(g);
            var S = {}, R = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var j in g) if (j !== "default" && Object.prototype.hasOwnProperty.call(g, j)) {
              var J = R ? Object.getOwnPropertyDescriptor(g, j) : null;
              J && (J.get || J.set) ? Object.defineProperty(S, j, J) : S[j] = g[j];
            }
            return S.default = g, D && D.set(g, S), S;
          }(E());
          function i(g) {
            if (typeof WeakMap != "function") return null;
            var A = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap();
            return (i = function(S) {
              return S ? D : A;
            })(g);
          }
          function o(g) {
            return g[0] = 1, g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[5] = 1, g[6] = 0, g[7] = 0, g[8] = 0, g[9] = 0, g[10] = 1, g[11] = 0, g[12] = 0, g[13] = 0, g[14] = 0, g[15] = 1, g;
          }
          function c(g, A, D) {
            var S = A[0], R = A[1], j = A[2], J = A[3], ne = A[4], me = A[5], ge = A[6], ue = A[7], Se = A[8], ke = A[9], He = A[10], at = A[11], nt = A[12], tt = A[13], Et = A[14], lt = A[15], St = D[0], Lt = D[1], It = D[2], zt = D[3];
            return g[0] = St * S + Lt * ne + It * Se + zt * nt, g[1] = St * R + Lt * me + It * ke + zt * tt, g[2] = St * j + Lt * ge + It * He + zt * Et, g[3] = St * J + Lt * ue + It * at + zt * lt, g[4] = (St = D[4]) * S + (Lt = D[5]) * ne + (It = D[6]) * Se + (zt = D[7]) * nt, g[5] = St * R + Lt * me + It * ke + zt * tt, g[6] = St * j + Lt * ge + It * He + zt * Et, g[7] = St * J + Lt * ue + It * at + zt * lt, g[8] = (St = D[8]) * S + (Lt = D[9]) * ne + (It = D[10]) * Se + (zt = D[11]) * nt, g[9] = St * R + Lt * me + It * ke + zt * tt, g[10] = St * j + Lt * ge + It * He + zt * Et, g[11] = St * J + Lt * ue + It * at + zt * lt, g[12] = (St = D[12]) * S + (Lt = D[13]) * ne + (It = D[14]) * Se + (zt = D[15]) * nt, g[13] = St * R + Lt * me + It * ke + zt * tt, g[14] = St * j + Lt * ge + It * He + zt * Et, g[15] = St * J + Lt * ue + It * at + zt * lt, g;
          }
          function s(g, A, D) {
            var S = A[0], R = A[1], j = A[2], J = A[3], ne = S + S, me = R + R, ge = j + j, ue = S * ne, Se = S * me, ke = S * ge, He = R * me, at = R * ge, nt = j * ge, tt = J * ne, Et = J * me, lt = J * ge;
            return g[0] = 1 - (He + nt), g[1] = Se + lt, g[2] = ke - Et, g[3] = 0, g[4] = Se - lt, g[5] = 1 - (ue + nt), g[6] = at + tt, g[7] = 0, g[8] = ke + Et, g[9] = at - tt, g[10] = 1 - (ue + He), g[11] = 0, g[12] = D[0], g[13] = D[1], g[14] = D[2], g[15] = 1, g;
          }
          function h(g, A) {
            var D = A[4], S = A[5], R = A[6], j = A[8], J = A[9], ne = A[10];
            return g[0] = Math.hypot(A[0], A[1], A[2]), g[1] = Math.hypot(D, S, R), g[2] = Math.hypot(j, J, ne), g;
          }
          function y(g, A, D, S, R) {
            var j, J = 1 / Math.tan(A / 2);
            return g[0] = J / D, g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[5] = J, g[6] = 0, g[7] = 0, g[8] = 0, g[9] = 0, g[11] = -1, g[12] = 0, g[13] = 0, g[15] = 0, R != null && R !== 1 / 0 ? (g[10] = (R + S) * (j = 1 / (S - R)), g[14] = 2 * R * S * j) : (g[10] = -1, g[14] = -2 * S), g;
          }
          function T(g, A, D, S, R, j, J) {
            var ne = 1 / (A - D), me = 1 / (S - R), ge = 1 / (j - J);
            return g[0] = -2 * ne, g[1] = 0, g[2] = 0, g[3] = 0, g[4] = 0, g[5] = -2 * me, g[6] = 0, g[7] = 0, g[8] = 0, g[9] = 0, g[10] = 2 * ge, g[11] = 0, g[12] = (A + D) * ne, g[13] = (R + S) * me, g[14] = (J + j) * ge, g[15] = 1, g;
          }
          function k(g, A, D) {
            return g[0] = A[0] - D[0], g[1] = A[1] - D[1], g[2] = A[2] - D[2], g[3] = A[3] - D[3], g[4] = A[4] - D[4], g[5] = A[5] - D[5], g[6] = A[6] - D[6], g[7] = A[7] - D[7], g[8] = A[8] - D[8], g[9] = A[9] - D[9], g[10] = A[10] - D[10], g[11] = A[11] - D[11], g[12] = A[12] - D[12], g[13] = A[13] - D[13], g[14] = A[14] - D[14], g[15] = A[15] - D[15], g;
          }
          return V.perspective = y, V.ortho = T, V.mul = c, V.sub = k, V;
        }
        var q, Y = {}, re = {};
        function se() {
          if (q) return re;
          function a(R) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(j) {
              return typeof j;
            } : function(j) {
              return j && typeof Symbol == "function" && j.constructor === Symbol && j !== Symbol.prototype ? "symbol" : typeof j;
            }, a(R);
          }
          q = 1, Object.defineProperty(re, "__esModule", { value: !0 }), re.create = o, re.clone = function(R) {
            var j = new e.ARRAY_TYPE(3);
            return j[0] = R[0], j[1] = R[1], j[2] = R[2], j;
          }, re.length = c, re.fromValues = function(R, j, J) {
            var ne = new e.ARRAY_TYPE(3);
            return ne[0] = R, ne[1] = j, ne[2] = J, ne;
          }, re.copy = function(R, j) {
            return R[0] = j[0], R[1] = j[1], R[2] = j[2], R;
          }, re.set = function(R, j, J, ne) {
            return R[0] = j, R[1] = J, R[2] = ne, R;
          }, re.add = function(R, j, J) {
            return R[0] = j[0] + J[0], R[1] = j[1] + J[1], R[2] = j[2] + J[2], R;
          }, re.subtract = s, re.multiply = h, re.divide = y, re.ceil = function(R, j) {
            return R[0] = Math.ceil(j[0]), R[1] = Math.ceil(j[1]), R[2] = Math.ceil(j[2]), R;
          }, re.floor = function(R, j) {
            return R[0] = Math.floor(j[0]), R[1] = Math.floor(j[1]), R[2] = Math.floor(j[2]), R;
          }, re.min = function(R, j, J) {
            return R[0] = Math.min(j[0], J[0]), R[1] = Math.min(j[1], J[1]), R[2] = Math.min(j[2], J[2]), R;
          }, re.max = function(R, j, J) {
            return R[0] = Math.max(j[0], J[0]), R[1] = Math.max(j[1], J[1]), R[2] = Math.max(j[2], J[2]), R;
          }, re.round = function(R, j) {
            return R[0] = Math.round(j[0]), R[1] = Math.round(j[1]), R[2] = Math.round(j[2]), R;
          }, re.scale = function(R, j, J) {
            return R[0] = j[0] * J, R[1] = j[1] * J, R[2] = j[2] * J, R;
          }, re.scaleAndAdd = function(R, j, J, ne) {
            return R[0] = j[0] + J[0] * ne, R[1] = j[1] + J[1] * ne, R[2] = j[2] + J[2] * ne, R;
          }, re.distance = T, re.squaredDistance = k, re.squaredLength = g, re.negate = function(R, j) {
            return R[0] = -j[0], R[1] = -j[1], R[2] = -j[2], R;
          }, re.inverse = function(R, j) {
            return R[0] = 1 / j[0], R[1] = 1 / j[1], R[2] = 1 / j[2], R;
          }, re.normalize = function(R, j) {
            var J = j[0], ne = j[1], me = j[2], ge = J * J + ne * ne + me * me;
            return ge > 0 && (ge = 1 / Math.sqrt(ge)), R[0] = j[0] * ge, R[1] = j[1] * ge, R[2] = j[2] * ge, R;
          }, re.dot = A, re.cross = function(R, j, J) {
            var ne = j[0], me = j[1], ge = j[2], ue = J[0], Se = J[1], ke = J[2];
            return R[0] = me * ke - ge * Se, R[1] = ge * ue - ne * ke, R[2] = ne * Se - me * ue, R;
          }, re.lerp = function(R, j, J, ne) {
            var me = j[0], ge = j[1], ue = j[2];
            return R[0] = me + ne * (J[0] - me), R[1] = ge + ne * (J[1] - ge), R[2] = ue + ne * (J[2] - ue), R;
          }, re.hermite = function(R, j, J, ne, me, ge) {
            var ue = ge * ge, Se = ue * (2 * ge - 3) + 1, ke = ue * (ge - 2) + ge, He = ue * (ge - 1), at = ue * (3 - 2 * ge);
            return R[0] = j[0] * Se + J[0] * ke + ne[0] * He + me[0] * at, R[1] = j[1] * Se + J[1] * ke + ne[1] * He + me[1] * at, R[2] = j[2] * Se + J[2] * ke + ne[2] * He + me[2] * at, R;
          }, re.bezier = function(R, j, J, ne, me, ge) {
            var ue = 1 - ge, Se = ue * ue, ke = ge * ge, He = Se * ue, at = 3 * ge * Se, nt = 3 * ke * ue, tt = ke * ge;
            return R[0] = j[0] * He + J[0] * at + ne[0] * nt + me[0] * tt, R[1] = j[1] * He + J[1] * at + ne[1] * nt + me[1] * tt, R[2] = j[2] * He + J[2] * at + ne[2] * nt + me[2] * tt, R;
          }, re.random = function(R, j) {
            j = j || 1;
            var J = 2 * e.RANDOM() * Math.PI, ne = 2 * e.RANDOM() - 1, me = Math.sqrt(1 - ne * ne) * j;
            return R[0] = Math.cos(J) * me, R[1] = Math.sin(J) * me, R[2] = ne * j, R;
          }, re.transformMat4 = function(R, j, J) {
            var ne = j[0], me = j[1], ge = j[2], ue = J[3] * ne + J[7] * me + J[11] * ge + J[15];
            return R[0] = (J[0] * ne + J[4] * me + J[8] * ge + J[12]) / (ue = ue || 1), R[1] = (J[1] * ne + J[5] * me + J[9] * ge + J[13]) / ue, R[2] = (J[2] * ne + J[6] * me + J[10] * ge + J[14]) / ue, R;
          }, re.transformMat3 = function(R, j, J) {
            var ne = j[0], me = j[1], ge = j[2];
            return R[0] = ne * J[0] + me * J[3] + ge * J[6], R[1] = ne * J[1] + me * J[4] + ge * J[7], R[2] = ne * J[2] + me * J[5] + ge * J[8], R;
          }, re.transformQuat = function(R, j, J) {
            var ne = J[0], me = J[1], ge = J[2], ue = j[0], Se = j[1], ke = j[2], He = me * ke - ge * Se, at = ge * ue - ne * ke, nt = ne * Se - me * ue, tt = me * nt - ge * at, Et = ge * He - ne * nt, lt = ne * at - me * He, St = 2 * J[3];
            return at *= St, nt *= St, Et *= 2, lt *= 2, R[0] = ue + (He *= St) + (tt *= 2), R[1] = Se + at + Et, R[2] = ke + nt + lt, R;
          }, re.rotateX = function(R, j, J, ne) {
            var me = [], ge = [];
            return me[0] = j[0] - J[0], me[1] = j[1] - J[1], me[2] = j[2] - J[2], ge[0] = me[0], ge[1] = me[1] * Math.cos(ne) - me[2] * Math.sin(ne), ge[2] = me[1] * Math.sin(ne) + me[2] * Math.cos(ne), R[0] = ge[0] + J[0], R[1] = ge[1] + J[1], R[2] = ge[2] + J[2], R;
          }, re.rotateY = function(R, j, J, ne) {
            var me = [], ge = [];
            return me[0] = j[0] - J[0], me[1] = j[1] - J[1], me[2] = j[2] - J[2], ge[0] = me[2] * Math.sin(ne) + me[0] * Math.cos(ne), ge[1] = me[1], ge[2] = me[2] * Math.cos(ne) - me[0] * Math.sin(ne), R[0] = ge[0] + J[0], R[1] = ge[1] + J[1], R[2] = ge[2] + J[2], R;
          }, re.rotateZ = function(R, j, J, ne) {
            var me = [], ge = [];
            return me[0] = j[0] - J[0], me[1] = j[1] - J[1], me[2] = j[2] - J[2], ge[0] = me[0] * Math.cos(ne) - me[1] * Math.sin(ne), ge[1] = me[0] * Math.sin(ne) + me[1] * Math.cos(ne), ge[2] = me[2], R[0] = ge[0] + J[0], R[1] = ge[1] + J[1], R[2] = ge[2] + J[2], R;
          }, re.angle = function(R, j) {
            var J = R[0], ne = R[1], me = R[2], ge = j[0], ue = j[1], Se = j[2], ke = Math.sqrt(J * J + ne * ne + me * me) * Math.sqrt(ge * ge + ue * ue + Se * Se), He = ke && A(R, j) / ke;
            return Math.acos(Math.min(Math.max(He, -1), 1));
          }, re.zero = function(R) {
            return R[0] = 0, R[1] = 0, R[2] = 0, R;
          }, re.str = function(R) {
            return "vec3(" + R[0] + ", " + R[1] + ", " + R[2] + ")";
          }, re.exactEquals = function(R, j) {
            return R[0] === j[0] && R[1] === j[1] && R[2] === j[2];
          }, re.equals = function(R, j) {
            var J = R[0], ne = R[1], me = R[2], ge = j[0], ue = j[1], Se = j[2];
            return Math.abs(J - ge) <= e.EPSILON * Math.max(1, Math.abs(J), Math.abs(ge)) && Math.abs(ne - ue) <= e.EPSILON * Math.max(1, Math.abs(ne), Math.abs(ue)) && Math.abs(me - Se) <= e.EPSILON * Math.max(1, Math.abs(me), Math.abs(Se));
          }, re.forEach = re.sqrLen = re.len = re.sqrDist = re.dist = re.div = re.mul = re.sub = void 0;
          var e = function(R, j) {
            if (R && R.__esModule) return R;
            if (R === null || a(R) !== "object" && typeof R != "function") return { default: R };
            var J = i(void 0);
            if (J && J.has(R)) return J.get(R);
            var ne = {}, me = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var ge in R) if (ge !== "default" && Object.prototype.hasOwnProperty.call(R, ge)) {
              var ue = me ? Object.getOwnPropertyDescriptor(R, ge) : null;
              ue && (ue.get || ue.set) ? Object.defineProperty(ne, ge, ue) : ne[ge] = R[ge];
            }
            return ne.default = R, J && J.set(R, ne), ne;
          }(E());
          function i(R) {
            if (typeof WeakMap != "function") return null;
            var j = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap();
            return (i = function(ne) {
              return ne ? J : j;
            })(R);
          }
          function o() {
            var R = new e.ARRAY_TYPE(3);
            return e.ARRAY_TYPE != Float32Array && (R[0] = 0, R[1] = 0, R[2] = 0), R;
          }
          function c(R) {
            return Math.hypot(R[0], R[1], R[2]);
          }
          function s(R, j, J) {
            return R[0] = j[0] - J[0], R[1] = j[1] - J[1], R[2] = j[2] - J[2], R;
          }
          function h(R, j, J) {
            return R[0] = j[0] * J[0], R[1] = j[1] * J[1], R[2] = j[2] * J[2], R;
          }
          function y(R, j, J) {
            return R[0] = j[0] / J[0], R[1] = j[1] / J[1], R[2] = j[2] / J[2], R;
          }
          function T(R, j) {
            return Math.hypot(j[0] - R[0], j[1] - R[1], j[2] - R[2]);
          }
          function k(R, j) {
            var J = j[0] - R[0], ne = j[1] - R[1], me = j[2] - R[2];
            return J * J + ne * ne + me * me;
          }
          function g(R) {
            var j = R[0], J = R[1], ne = R[2];
            return j * j + J * J + ne * ne;
          }
          function A(R, j) {
            return R[0] * j[0] + R[1] * j[1] + R[2] * j[2];
          }
          re.sub = s, re.mul = h, re.div = y, re.dist = T, re.sqrDist = k, re.len = c, re.sqrLen = g;
          var D, S = (D = o(), function(R, j, J, ne, me, ge) {
            var ue, Se;
            for (j || (j = 3), J || (J = 0), Se = ne ? Math.min(ne * j + J, R.length) : R.length, ue = J; ue < Se; ue += j) D[0] = R[ue], D[1] = R[ue + 1], D[2] = R[ue + 2], me(D, D, ge), R[ue] = D[0], R[ue + 1] = D[1], R[ue + 2] = D[2];
            return R;
          });
          return re.forEach = S, re;
        }
        var ve, ce, be = {};
        function Me() {
          if (ve) return be;
          function a(S) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(R) {
              return typeof R;
            } : function(R) {
              return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
            }, a(S);
          }
          ve = 1, Object.defineProperty(be, "__esModule", { value: !0 }), be.create = o, be.clone = function(S) {
            var R = new e.ARRAY_TYPE(4);
            return R[0] = S[0], R[1] = S[1], R[2] = S[2], R[3] = S[3], R;
          }, be.fromValues = function(S, R, j, J) {
            var ne = new e.ARRAY_TYPE(4);
            return ne[0] = S, ne[1] = R, ne[2] = j, ne[3] = J, ne;
          }, be.copy = function(S, R) {
            return S[0] = R[0], S[1] = R[1], S[2] = R[2], S[3] = R[3], S;
          }, be.set = function(S, R, j, J, ne) {
            return S[0] = R, S[1] = j, S[2] = J, S[3] = ne, S;
          }, be.add = function(S, R, j) {
            return S[0] = R[0] + j[0], S[1] = R[1] + j[1], S[2] = R[2] + j[2], S[3] = R[3] + j[3], S;
          }, be.subtract = c, be.multiply = s, be.divide = h, be.ceil = function(S, R) {
            return S[0] = Math.ceil(R[0]), S[1] = Math.ceil(R[1]), S[2] = Math.ceil(R[2]), S[3] = Math.ceil(R[3]), S;
          }, be.floor = function(S, R) {
            return S[0] = Math.floor(R[0]), S[1] = Math.floor(R[1]), S[2] = Math.floor(R[2]), S[3] = Math.floor(R[3]), S;
          }, be.min = function(S, R, j) {
            return S[0] = Math.min(R[0], j[0]), S[1] = Math.min(R[1], j[1]), S[2] = Math.min(R[2], j[2]), S[3] = Math.min(R[3], j[3]), S;
          }, be.max = function(S, R, j) {
            return S[0] = Math.max(R[0], j[0]), S[1] = Math.max(R[1], j[1]), S[2] = Math.max(R[2], j[2]), S[3] = Math.max(R[3], j[3]), S;
          }, be.round = function(S, R) {
            return S[0] = Math.round(R[0]), S[1] = Math.round(R[1]), S[2] = Math.round(R[2]), S[3] = Math.round(R[3]), S;
          }, be.scale = function(S, R, j) {
            return S[0] = R[0] * j, S[1] = R[1] * j, S[2] = R[2] * j, S[3] = R[3] * j, S;
          }, be.scaleAndAdd = function(S, R, j, J) {
            return S[0] = R[0] + j[0] * J, S[1] = R[1] + j[1] * J, S[2] = R[2] + j[2] * J, S[3] = R[3] + j[3] * J, S;
          }, be.distance = y, be.squaredDistance = T, be.length = k, be.squaredLength = g, be.negate = function(S, R) {
            return S[0] = -R[0], S[1] = -R[1], S[2] = -R[2], S[3] = -R[3], S;
          }, be.inverse = function(S, R) {
            return S[0] = 1 / R[0], S[1] = 1 / R[1], S[2] = 1 / R[2], S[3] = 1 / R[3], S;
          }, be.normalize = function(S, R) {
            var j = R[0], J = R[1], ne = R[2], me = R[3], ge = j * j + J * J + ne * ne + me * me;
            return ge > 0 && (ge = 1 / Math.sqrt(ge)), S[0] = j * ge, S[1] = J * ge, S[2] = ne * ge, S[3] = me * ge, S;
          }, be.dot = function(S, R) {
            return S[0] * R[0] + S[1] * R[1] + S[2] * R[2] + S[3] * R[3];
          }, be.cross = function(S, R, j, J) {
            var ne = j[0] * J[1] - j[1] * J[0], me = j[0] * J[2] - j[2] * J[0], ge = j[0] * J[3] - j[3] * J[0], ue = j[1] * J[2] - j[2] * J[1], Se = j[1] * J[3] - j[3] * J[1], ke = j[2] * J[3] - j[3] * J[2], He = R[0], at = R[1], nt = R[2], tt = R[3];
            return S[0] = at * ke - nt * Se + tt * ue, S[1] = -He * ke + nt * ge - tt * me, S[2] = He * Se - at * ge + tt * ne, S[3] = -He * ue + at * me - nt * ne, S;
          }, be.lerp = function(S, R, j, J) {
            var ne = R[0], me = R[1], ge = R[2], ue = R[3];
            return S[0] = ne + J * (j[0] - ne), S[1] = me + J * (j[1] - me), S[2] = ge + J * (j[2] - ge), S[3] = ue + J * (j[3] - ue), S;
          }, be.random = function(S, R) {
            var j, J, ne, me, ge, ue;
            R = R || 1;
            do
              ge = (j = 2 * e.RANDOM() - 1) * j + (J = 2 * e.RANDOM() - 1) * J;
            while (ge >= 1);
            do
              ue = (ne = 2 * e.RANDOM() - 1) * ne + (me = 2 * e.RANDOM() - 1) * me;
            while (ue >= 1);
            var Se = Math.sqrt((1 - ge) / ue);
            return S[0] = R * j, S[1] = R * J, S[2] = R * ne * Se, S[3] = R * me * Se, S;
          }, be.transformMat4 = function(S, R, j) {
            var J = R[0], ne = R[1], me = R[2], ge = R[3];
            return S[0] = j[0] * J + j[4] * ne + j[8] * me + j[12] * ge, S[1] = j[1] * J + j[5] * ne + j[9] * me + j[13] * ge, S[2] = j[2] * J + j[6] * ne + j[10] * me + j[14] * ge, S[3] = j[3] * J + j[7] * ne + j[11] * me + j[15] * ge, S;
          }, be.transformQuat = function(S, R, j) {
            var J = R[0], ne = R[1], me = R[2], ge = j[0], ue = j[1], Se = j[2], ke = j[3], He = ke * J + ue * me - Se * ne, at = ke * ne + Se * J - ge * me, nt = ke * me + ge * ne - ue * J, tt = -ge * J - ue * ne - Se * me;
            return S[0] = He * ke + tt * -ge + at * -Se - nt * -ue, S[1] = at * ke + tt * -ue + nt * -ge - He * -Se, S[2] = nt * ke + tt * -Se + He * -ue - at * -ge, S[3] = R[3], S;
          }, be.zero = function(S) {
            return S[0] = 0, S[1] = 0, S[2] = 0, S[3] = 0, S;
          }, be.str = function(S) {
            return "vec4(" + S[0] + ", " + S[1] + ", " + S[2] + ", " + S[3] + ")";
          }, be.exactEquals = function(S, R) {
            return S[0] === R[0] && S[1] === R[1] && S[2] === R[2] && S[3] === R[3];
          }, be.equals = function(S, R) {
            var j = S[0], J = S[1], ne = S[2], me = S[3], ge = R[0], ue = R[1], Se = R[2], ke = R[3];
            return Math.abs(j - ge) <= e.EPSILON * Math.max(1, Math.abs(j), Math.abs(ge)) && Math.abs(J - ue) <= e.EPSILON * Math.max(1, Math.abs(J), Math.abs(ue)) && Math.abs(ne - Se) <= e.EPSILON * Math.max(1, Math.abs(ne), Math.abs(Se)) && Math.abs(me - ke) <= e.EPSILON * Math.max(1, Math.abs(me), Math.abs(ke));
          }, be.forEach = be.sqrLen = be.len = be.sqrDist = be.dist = be.div = be.mul = be.sub = void 0;
          var e = function(S, R) {
            if (S && S.__esModule) return S;
            if (S === null || a(S) !== "object" && typeof S != "function") return { default: S };
            var j = i(void 0);
            if (j && j.has(S)) return j.get(S);
            var J = {}, ne = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var me in S) if (me !== "default" && Object.prototype.hasOwnProperty.call(S, me)) {
              var ge = ne ? Object.getOwnPropertyDescriptor(S, me) : null;
              ge && (ge.get || ge.set) ? Object.defineProperty(J, me, ge) : J[me] = S[me];
            }
            return J.default = S, j && j.set(S, J), J;
          }(E());
          function i(S) {
            if (typeof WeakMap != "function") return null;
            var R = /* @__PURE__ */ new WeakMap(), j = /* @__PURE__ */ new WeakMap();
            return (i = function(J) {
              return J ? j : R;
            })(S);
          }
          function o() {
            var S = new e.ARRAY_TYPE(4);
            return e.ARRAY_TYPE != Float32Array && (S[0] = 0, S[1] = 0, S[2] = 0, S[3] = 0), S;
          }
          function c(S, R, j) {
            return S[0] = R[0] - j[0], S[1] = R[1] - j[1], S[2] = R[2] - j[2], S[3] = R[3] - j[3], S;
          }
          function s(S, R, j) {
            return S[0] = R[0] * j[0], S[1] = R[1] * j[1], S[2] = R[2] * j[2], S[3] = R[3] * j[3], S;
          }
          function h(S, R, j) {
            return S[0] = R[0] / j[0], S[1] = R[1] / j[1], S[2] = R[2] / j[2], S[3] = R[3] / j[3], S;
          }
          function y(S, R) {
            return Math.hypot(R[0] - S[0], R[1] - S[1], R[2] - S[2], R[3] - S[3]);
          }
          function T(S, R) {
            var j = R[0] - S[0], J = R[1] - S[1], ne = R[2] - S[2], me = R[3] - S[3];
            return j * j + J * J + ne * ne + me * me;
          }
          function k(S) {
            return Math.hypot(S[0], S[1], S[2], S[3]);
          }
          function g(S) {
            var R = S[0], j = S[1], J = S[2], ne = S[3];
            return R * R + j * j + J * J + ne * ne;
          }
          be.sub = c, be.mul = s, be.div = h, be.dist = y, be.sqrDist = T, be.len = k, be.sqrLen = g;
          var A, D = (A = o(), function(S, R, j, J, ne, me) {
            var ge, ue;
            for (R || (R = 4), j || (j = 0), ue = J ? Math.min(J * R + j, S.length) : S.length, ge = j; ge < ue; ge += R) A[0] = S[ge], A[1] = S[ge + 1], A[2] = S[ge + 2], A[3] = S[ge + 3], ne(A, A, me), S[ge] = A[0], S[ge + 1] = A[1], S[ge + 2] = A[2], S[ge + 3] = A[3];
            return S;
          });
          return be.forEach = D, be;
        }
        function xe() {
          if (ce) return Y;
          function a(lt) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(St) {
              return typeof St;
            } : function(St) {
              return St && typeof Symbol == "function" && St.constructor === Symbol && St !== Symbol.prototype ? "symbol" : typeof St;
            }, a(lt);
          }
          ce = 1, Object.defineProperty(Y, "__esModule", { value: !0 }), Y.create = y, Y.identity = function(lt) {
            return lt[0] = 0, lt[1] = 0, lt[2] = 0, lt[3] = 1, lt;
          }, Y.setAxisAngle = T, Y.getAxisAngle = function(lt, St) {
            var Lt = 2 * Math.acos(St[3]), It = Math.sin(Lt / 2);
            return It > e.EPSILON ? (lt[0] = St[0] / It, lt[1] = St[1] / It, lt[2] = St[2] / It) : (lt[0] = 1, lt[1] = 0, lt[2] = 0), Lt;
          }, Y.getAngle = function(lt, St) {
            var Lt = j(lt, St);
            return Math.acos(2 * Lt * Lt - 1);
          }, Y.multiply = k, Y.rotateX = function(lt, St, Lt) {
            Lt *= 0.5;
            var It = St[0], zt = St[1], Ft = St[2], qt = St[3], Ot = Math.sin(Lt), cr = Math.cos(Lt);
            return lt[0] = It * cr + qt * Ot, lt[1] = zt * cr + Ft * Ot, lt[2] = Ft * cr - zt * Ot, lt[3] = qt * cr - It * Ot, lt;
          }, Y.rotateY = function(lt, St, Lt) {
            Lt *= 0.5;
            var It = St[0], zt = St[1], Ft = St[2], qt = St[3], Ot = Math.sin(Lt), cr = Math.cos(Lt);
            return lt[0] = It * cr - Ft * Ot, lt[1] = zt * cr + qt * Ot, lt[2] = Ft * cr + It * Ot, lt[3] = qt * cr - zt * Ot, lt;
          }, Y.rotateZ = function(lt, St, Lt) {
            Lt *= 0.5;
            var It = St[0], zt = St[1], Ft = St[2], qt = St[3], Ot = Math.sin(Lt), cr = Math.cos(Lt);
            return lt[0] = It * cr + zt * Ot, lt[1] = zt * cr - It * Ot, lt[2] = Ft * cr + qt * Ot, lt[3] = qt * cr - Ft * Ot, lt;
          }, Y.calculateW = function(lt, St) {
            var Lt = St[0], It = St[1], zt = St[2];
            return lt[0] = Lt, lt[1] = It, lt[2] = zt, lt[3] = Math.sqrt(Math.abs(1 - Lt * Lt - It * It - zt * zt)), lt;
          }, Y.exp = g, Y.ln = A, Y.pow = function(lt, St, Lt) {
            return A(lt, St), R(lt, lt, Lt), g(lt, lt), lt;
          }, Y.slerp = D, Y.random = function(lt) {
            var St = e.RANDOM(), Lt = e.RANDOM(), It = e.RANDOM(), zt = Math.sqrt(1 - St), Ft = Math.sqrt(St);
            return lt[0] = zt * Math.sin(2 * Math.PI * Lt), lt[1] = zt * Math.cos(2 * Math.PI * Lt), lt[2] = Ft * Math.sin(2 * Math.PI * It), lt[3] = Ft * Math.cos(2 * Math.PI * It), lt;
          }, Y.invert = function(lt, St) {
            var Lt = St[0], It = St[1], zt = St[2], Ft = St[3], qt = Lt * Lt + It * It + zt * zt + Ft * Ft, Ot = qt ? 1 / qt : 0;
            return lt[0] = -Lt * Ot, lt[1] = -It * Ot, lt[2] = -zt * Ot, lt[3] = Ft * Ot, lt;
          }, Y.conjugate = function(lt, St) {
            return lt[0] = -St[0], lt[1] = -St[1], lt[2] = -St[2], lt[3] = St[3], lt;
          }, Y.fromMat3 = S, Y.fromEuler = function(lt, St, Lt, It) {
            var zt = 0.5 * Math.PI / 180;
            St *= zt, Lt *= zt, It *= zt;
            var Ft = Math.sin(St), qt = Math.cos(St), Ot = Math.sin(Lt), cr = Math.cos(Lt), yr = Math.sin(It), ur = Math.cos(It);
            return lt[0] = Ft * cr * ur - qt * Ot * yr, lt[1] = qt * Ot * ur + Ft * cr * yr, lt[2] = qt * cr * yr - Ft * Ot * ur, lt[3] = qt * cr * ur + Ft * Ot * yr, lt;
          }, Y.str = function(lt) {
            return "quat(" + lt[0] + ", " + lt[1] + ", " + lt[2] + ", " + lt[3] + ")";
          }, Y.setAxes = Y.sqlerp = Y.rotationTo = Y.equals = Y.exactEquals = Y.normalize = Y.sqrLen = Y.squaredLength = Y.len = Y.length = Y.lerp = Y.dot = Y.scale = Y.mul = Y.add = Y.set = Y.copy = Y.fromValues = Y.clone = void 0;
          var e = h(E()), i = h(N()), o = h(se()), c = h(Me());
          function s(lt) {
            if (typeof WeakMap != "function") return null;
            var St = /* @__PURE__ */ new WeakMap(), Lt = /* @__PURE__ */ new WeakMap();
            return (s = function(It) {
              return It ? Lt : St;
            })(lt);
          }
          function h(lt, St) {
            if (lt && lt.__esModule) return lt;
            if (lt === null || a(lt) !== "object" && typeof lt != "function") return { default: lt };
            var Lt = s(St);
            if (Lt && Lt.has(lt)) return Lt.get(lt);
            var It = {}, zt = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var Ft in lt) if (Ft !== "default" && Object.prototype.hasOwnProperty.call(lt, Ft)) {
              var qt = zt ? Object.getOwnPropertyDescriptor(lt, Ft) : null;
              qt && (qt.get || qt.set) ? Object.defineProperty(It, Ft, qt) : It[Ft] = lt[Ft];
            }
            return It.default = lt, Lt && Lt.set(lt, It), It;
          }
          function y() {
            var lt = new e.ARRAY_TYPE(4);
            return e.ARRAY_TYPE != Float32Array && (lt[0] = 0, lt[1] = 0, lt[2] = 0), lt[3] = 1, lt;
          }
          function T(lt, St, Lt) {
            Lt *= 0.5;
            var It = Math.sin(Lt);
            return lt[0] = It * St[0], lt[1] = It * St[1], lt[2] = It * St[2], lt[3] = Math.cos(Lt), lt;
          }
          function k(lt, St, Lt) {
            var It = St[0], zt = St[1], Ft = St[2], qt = St[3], Ot = Lt[0], cr = Lt[1], yr = Lt[2], ur = Lt[3];
            return lt[0] = It * ur + qt * Ot + zt * yr - Ft * cr, lt[1] = zt * ur + qt * cr + Ft * Ot - It * yr, lt[2] = Ft * ur + qt * yr + It * cr - zt * Ot, lt[3] = qt * ur - It * Ot - zt * cr - Ft * yr, lt;
          }
          function g(lt, St) {
            var Lt = St[0], It = St[1], zt = St[2], Ft = St[3], qt = Math.sqrt(Lt * Lt + It * It + zt * zt), Ot = Math.exp(Ft), cr = qt > 0 ? Ot * Math.sin(qt) / qt : 0;
            return lt[0] = Lt * cr, lt[1] = It * cr, lt[2] = zt * cr, lt[3] = Ot * Math.cos(qt), lt;
          }
          function A(lt, St) {
            var Lt = St[0], It = St[1], zt = St[2], Ft = St[3], qt = Math.sqrt(Lt * Lt + It * It + zt * zt), Ot = qt > 0 ? Math.atan2(qt, Ft) / qt : 0;
            return lt[0] = Lt * Ot, lt[1] = It * Ot, lt[2] = zt * Ot, lt[3] = 0.5 * Math.log(Lt * Lt + It * It + zt * zt + Ft * Ft), lt;
          }
          function D(lt, St, Lt, It) {
            var zt, Ft, qt, Ot, cr, yr = St[0], ur = St[1], jr = St[2], zr = St[3], Ar = Lt[0], vr = Lt[1], ti = Lt[2], Wr = Lt[3];
            return (Ft = yr * Ar + ur * vr + jr * ti + zr * Wr) < 0 && (Ft = -Ft, Ar = -Ar, vr = -vr, ti = -ti, Wr = -Wr), 1 - Ft > e.EPSILON ? (zt = Math.acos(Ft), qt = Math.sin(zt), Ot = Math.sin((1 - It) * zt) / qt, cr = Math.sin(It * zt) / qt) : (Ot = 1 - It, cr = It), lt[0] = Ot * yr + cr * Ar, lt[1] = Ot * ur + cr * vr, lt[2] = Ot * jr + cr * ti, lt[3] = Ot * zr + cr * Wr, lt;
          }
          function S(lt, St) {
            var Lt, It = St[0] + St[4] + St[8];
            if (It > 0) Lt = Math.sqrt(It + 1), lt[3] = 0.5 * Lt, lt[0] = (St[5] - St[7]) * (Lt = 0.5 / Lt), lt[1] = (St[6] - St[2]) * Lt, lt[2] = (St[1] - St[3]) * Lt;
            else {
              var zt = 0;
              St[4] > St[0] && (zt = 1), St[8] > St[3 * zt + zt] && (zt = 2);
              var Ft = (zt + 1) % 3, qt = (zt + 2) % 3;
              Lt = Math.sqrt(St[3 * zt + zt] - St[3 * Ft + Ft] - St[3 * qt + qt] + 1), lt[zt] = 0.5 * Lt, lt[3] = (St[3 * Ft + qt] - St[3 * qt + Ft]) * (Lt = 0.5 / Lt), lt[Ft] = (St[3 * Ft + zt] + St[3 * zt + Ft]) * Lt, lt[qt] = (St[3 * qt + zt] + St[3 * zt + qt]) * Lt;
            }
            return lt;
          }
          Y.clone = c.clone, Y.fromValues = c.fromValues, Y.copy = c.copy, Y.set = c.set, Y.add = c.add, Y.mul = k;
          var R = c.scale;
          Y.scale = R;
          var j = c.dot;
          Y.dot = j, Y.lerp = c.lerp;
          var J = c.length;
          Y.length = J, Y.len = J;
          var ne = c.squaredLength;
          Y.squaredLength = ne, Y.sqrLen = ne;
          var me = c.normalize;
          Y.normalize = me, Y.exactEquals = c.exactEquals, Y.equals = c.equals;
          var ge, ue, Se, ke = (ge = o.create(), ue = o.fromValues(1, 0, 0), Se = o.fromValues(0, 1, 0), function(lt, St, Lt) {
            var It = o.dot(St, Lt);
            return It < -0.999999 ? (o.cross(ge, ue, St), o.len(ge) < 1e-6 && o.cross(ge, Se, St), o.normalize(ge, ge), T(lt, ge, Math.PI), lt) : It > 0.999999 ? (lt[0] = 0, lt[1] = 0, lt[2] = 0, lt[3] = 1, lt) : (o.cross(ge, St, Lt), lt[0] = ge[0], lt[1] = ge[1], lt[2] = ge[2], lt[3] = 1 + It, me(lt, lt));
          });
          Y.rotationTo = ke;
          var He, at, nt = (He = y(), at = y(), function(lt, St, Lt, It, zt, Ft) {
            return D(He, St, zt, Ft), D(at, Lt, It, Ft), D(lt, He, at, 2 * Ft * (1 - Ft)), lt;
          });
          Y.sqlerp = nt;
          var tt, Et = (tt = i.create(), function(lt, St, Lt, It) {
            return tt[0] = Lt[0], tt[3] = Lt[1], tt[6] = Lt[2], tt[1] = It[0], tt[4] = It[1], tt[7] = It[2], tt[2] = -St[0], tt[5] = -St[1], tt[8] = -St[2], me(lt, S(lt, tt));
          });
          return Y.setAxes = Et, Y;
        }
        var le, de = {};
        function De() {
          if (le) return de;
          function a(D) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(S) {
              return typeof S;
            } : function(S) {
              return S && typeof Symbol == "function" && S.constructor === Symbol && S !== Symbol.prototype ? "symbol" : typeof S;
            }, a(D);
          }
          le = 1, Object.defineProperty(de, "__esModule", { value: !0 }), de.create = function() {
            var D = new e.ARRAY_TYPE(8);
            return e.ARRAY_TYPE != Float32Array && (D[0] = 0, D[1] = 0, D[2] = 0, D[4] = 0, D[5] = 0, D[6] = 0, D[7] = 0), D[3] = 1, D;
          }, de.clone = function(D) {
            var S = new e.ARRAY_TYPE(8);
            return S[0] = D[0], S[1] = D[1], S[2] = D[2], S[3] = D[3], S[4] = D[4], S[5] = D[5], S[6] = D[6], S[7] = D[7], S;
          }, de.fromValues = function(D, S, R, j, J, ne, me, ge) {
            var ue = new e.ARRAY_TYPE(8);
            return ue[0] = D, ue[1] = S, ue[2] = R, ue[3] = j, ue[4] = J, ue[5] = ne, ue[6] = me, ue[7] = ge, ue;
          }, de.fromRotationTranslationValues = function(D, S, R, j, J, ne, me) {
            var ge = new e.ARRAY_TYPE(8);
            ge[0] = D, ge[1] = S, ge[2] = R, ge[3] = j;
            var ue = 0.5 * J, Se = 0.5 * ne, ke = 0.5 * me;
            return ge[4] = ue * j + Se * R - ke * S, ge[5] = Se * j + ke * D - ue * R, ge[6] = ke * j + ue * S - Se * D, ge[7] = -ue * D - Se * S - ke * R, ge;
          }, de.fromRotationTranslation = h, de.fromTranslation = function(D, S) {
            return D[0] = 0, D[1] = 0, D[2] = 0, D[3] = 1, D[4] = 0.5 * S[0], D[5] = 0.5 * S[1], D[6] = 0.5 * S[2], D[7] = 0, D;
          }, de.fromRotation = function(D, S) {
            return D[0] = S[0], D[1] = S[1], D[2] = S[2], D[3] = S[3], D[4] = 0, D[5] = 0, D[6] = 0, D[7] = 0, D;
          }, de.fromMat4 = function(D, S) {
            var R = i.create();
            o.getRotation(R, S);
            var j = new e.ARRAY_TYPE(3);
            return o.getTranslation(j, S), h(D, R, j), D;
          }, de.copy = y, de.identity = function(D) {
            return D[0] = 0, D[1] = 0, D[2] = 0, D[3] = 1, D[4] = 0, D[5] = 0, D[6] = 0, D[7] = 0, D;
          }, de.set = function(D, S, R, j, J, ne, me, ge, ue) {
            return D[0] = S, D[1] = R, D[2] = j, D[3] = J, D[4] = ne, D[5] = me, D[6] = ge, D[7] = ue, D;
          }, de.getDual = function(D, S) {
            return D[0] = S[4], D[1] = S[5], D[2] = S[6], D[3] = S[7], D;
          }, de.setDual = function(D, S) {
            return D[4] = S[0], D[5] = S[1], D[6] = S[2], D[7] = S[3], D;
          }, de.getTranslation = function(D, S) {
            var R = S[4], j = S[5], J = S[6], ne = S[7], me = -S[0], ge = -S[1], ue = -S[2], Se = S[3];
            return D[0] = 2 * (R * Se + ne * me + j * ue - J * ge), D[1] = 2 * (j * Se + ne * ge + J * me - R * ue), D[2] = 2 * (J * Se + ne * ue + R * ge - j * me), D;
          }, de.translate = function(D, S, R) {
            var j = S[0], J = S[1], ne = S[2], me = S[3], ge = 0.5 * R[0], ue = 0.5 * R[1], Se = 0.5 * R[2], ke = S[4], He = S[5], at = S[6], nt = S[7];
            return D[0] = j, D[1] = J, D[2] = ne, D[3] = me, D[4] = me * ge + J * Se - ne * ue + ke, D[5] = me * ue + ne * ge - j * Se + He, D[6] = me * Se + j * ue - J * ge + at, D[7] = -j * ge - J * ue - ne * Se + nt, D;
          }, de.rotateX = function(D, S, R) {
            var j = -S[0], J = -S[1], ne = -S[2], me = S[3], ge = S[4], ue = S[5], Se = S[6], ke = S[7], He = ge * me + ke * j + ue * ne - Se * J, at = ue * me + ke * J + Se * j - ge * ne, nt = Se * me + ke * ne + ge * J - ue * j, tt = ke * me - ge * j - ue * J - Se * ne;
            return i.rotateX(D, S, R), D[4] = He * (me = D[3]) + tt * (j = D[0]) + at * (ne = D[2]) - nt * (J = D[1]), D[5] = at * me + tt * J + nt * j - He * ne, D[6] = nt * me + tt * ne + He * J - at * j, D[7] = tt * me - He * j - at * J - nt * ne, D;
          }, de.rotateY = function(D, S, R) {
            var j = -S[0], J = -S[1], ne = -S[2], me = S[3], ge = S[4], ue = S[5], Se = S[6], ke = S[7], He = ge * me + ke * j + ue * ne - Se * J, at = ue * me + ke * J + Se * j - ge * ne, nt = Se * me + ke * ne + ge * J - ue * j, tt = ke * me - ge * j - ue * J - Se * ne;
            return i.rotateY(D, S, R), D[4] = He * (me = D[3]) + tt * (j = D[0]) + at * (ne = D[2]) - nt * (J = D[1]), D[5] = at * me + tt * J + nt * j - He * ne, D[6] = nt * me + tt * ne + He * J - at * j, D[7] = tt * me - He * j - at * J - nt * ne, D;
          }, de.rotateZ = function(D, S, R) {
            var j = -S[0], J = -S[1], ne = -S[2], me = S[3], ge = S[4], ue = S[5], Se = S[6], ke = S[7], He = ge * me + ke * j + ue * ne - Se * J, at = ue * me + ke * J + Se * j - ge * ne, nt = Se * me + ke * ne + ge * J - ue * j, tt = ke * me - ge * j - ue * J - Se * ne;
            return i.rotateZ(D, S, R), D[4] = He * (me = D[3]) + tt * (j = D[0]) + at * (ne = D[2]) - nt * (J = D[1]), D[5] = at * me + tt * J + nt * j - He * ne, D[6] = nt * me + tt * ne + He * J - at * j, D[7] = tt * me - He * j - at * J - nt * ne, D;
          }, de.rotateByQuatAppend = function(D, S, R) {
            var j = R[0], J = R[1], ne = R[2], me = R[3], ge = S[0], ue = S[1], Se = S[2], ke = S[3];
            return D[0] = ge * me + ke * j + ue * ne - Se * J, D[1] = ue * me + ke * J + Se * j - ge * ne, D[2] = Se * me + ke * ne + ge * J - ue * j, D[3] = ke * me - ge * j - ue * J - Se * ne, D[4] = (ge = S[4]) * me + (ke = S[7]) * j + (ue = S[5]) * ne - (Se = S[6]) * J, D[5] = ue * me + ke * J + Se * j - ge * ne, D[6] = Se * me + ke * ne + ge * J - ue * j, D[7] = ke * me - ge * j - ue * J - Se * ne, D;
          }, de.rotateByQuatPrepend = function(D, S, R) {
            var j = S[0], J = S[1], ne = S[2], me = S[3], ge = R[0], ue = R[1], Se = R[2], ke = R[3];
            return D[0] = j * ke + me * ge + J * Se - ne * ue, D[1] = J * ke + me * ue + ne * ge - j * Se, D[2] = ne * ke + me * Se + j * ue - J * ge, D[3] = me * ke - j * ge - J * ue - ne * Se, D[4] = j * (ke = R[7]) + me * (ge = R[4]) + J * (Se = R[6]) - ne * (ue = R[5]), D[5] = J * ke + me * ue + ne * ge - j * Se, D[6] = ne * ke + me * Se + j * ue - J * ge, D[7] = me * ke - j * ge - J * ue - ne * Se, D;
          }, de.rotateAroundAxis = function(D, S, R, j) {
            if (Math.abs(j) < e.EPSILON) return y(D, S);
            var J = Math.hypot(R[0], R[1], R[2]);
            j *= 0.5;
            var ne = Math.sin(j), me = ne * R[0] / J, ge = ne * R[1] / J, ue = ne * R[2] / J, Se = Math.cos(j), ke = S[0], He = S[1], at = S[2], nt = S[3];
            D[0] = ke * Se + nt * me + He * ue - at * ge, D[1] = He * Se + nt * ge + at * me - ke * ue, D[2] = at * Se + nt * ue + ke * ge - He * me, D[3] = nt * Se - ke * me - He * ge - at * ue;
            var tt = S[4], Et = S[5], lt = S[6], St = S[7];
            return D[4] = tt * Se + St * me + Et * ue - lt * ge, D[5] = Et * Se + St * ge + lt * me - tt * ue, D[6] = lt * Se + St * ue + tt * ge - Et * me, D[7] = St * Se - tt * me - Et * ge - lt * ue, D;
          }, de.add = function(D, S, R) {
            return D[0] = S[0] + R[0], D[1] = S[1] + R[1], D[2] = S[2] + R[2], D[3] = S[3] + R[3], D[4] = S[4] + R[4], D[5] = S[5] + R[5], D[6] = S[6] + R[6], D[7] = S[7] + R[7], D;
          }, de.multiply = T, de.scale = function(D, S, R) {
            return D[0] = S[0] * R, D[1] = S[1] * R, D[2] = S[2] * R, D[3] = S[3] * R, D[4] = S[4] * R, D[5] = S[5] * R, D[6] = S[6] * R, D[7] = S[7] * R, D;
          }, de.lerp = function(D, S, R, j) {
            var J = 1 - j;
            return k(S, R) < 0 && (j = -j), D[0] = S[0] * J + R[0] * j, D[1] = S[1] * J + R[1] * j, D[2] = S[2] * J + R[2] * j, D[3] = S[3] * J + R[3] * j, D[4] = S[4] * J + R[4] * j, D[5] = S[5] * J + R[5] * j, D[6] = S[6] * J + R[6] * j, D[7] = S[7] * J + R[7] * j, D;
          }, de.invert = function(D, S) {
            var R = A(S);
            return D[0] = -S[0] / R, D[1] = -S[1] / R, D[2] = -S[2] / R, D[3] = S[3] / R, D[4] = -S[4] / R, D[5] = -S[5] / R, D[6] = -S[6] / R, D[7] = S[7] / R, D;
          }, de.conjugate = function(D, S) {
            return D[0] = -S[0], D[1] = -S[1], D[2] = -S[2], D[3] = S[3], D[4] = -S[4], D[5] = -S[5], D[6] = -S[6], D[7] = S[7], D;
          }, de.normalize = function(D, S) {
            var R = A(S);
            if (R > 0) {
              R = Math.sqrt(R);
              var j = S[0] / R, J = S[1] / R, ne = S[2] / R, me = S[3] / R, ge = S[4], ue = S[5], Se = S[6], ke = S[7], He = j * ge + J * ue + ne * Se + me * ke;
              D[0] = j, D[1] = J, D[2] = ne, D[3] = me, D[4] = (ge - j * He) / R, D[5] = (ue - J * He) / R, D[6] = (Se - ne * He) / R, D[7] = (ke - me * He) / R;
            }
            return D;
          }, de.str = function(D) {
            return "quat2(" + D[0] + ", " + D[1] + ", " + D[2] + ", " + D[3] + ", " + D[4] + ", " + D[5] + ", " + D[6] + ", " + D[7] + ")";
          }, de.exactEquals = function(D, S) {
            return D[0] === S[0] && D[1] === S[1] && D[2] === S[2] && D[3] === S[3] && D[4] === S[4] && D[5] === S[5] && D[6] === S[6] && D[7] === S[7];
          }, de.equals = function(D, S) {
            var R = D[0], j = D[1], J = D[2], ne = D[3], me = D[4], ge = D[5], ue = D[6], Se = D[7], ke = S[0], He = S[1], at = S[2], nt = S[3], tt = S[4], Et = S[5], lt = S[6], St = S[7];
            return Math.abs(R - ke) <= e.EPSILON * Math.max(1, Math.abs(R), Math.abs(ke)) && Math.abs(j - He) <= e.EPSILON * Math.max(1, Math.abs(j), Math.abs(He)) && Math.abs(J - at) <= e.EPSILON * Math.max(1, Math.abs(J), Math.abs(at)) && Math.abs(ne - nt) <= e.EPSILON * Math.max(1, Math.abs(ne), Math.abs(nt)) && Math.abs(me - tt) <= e.EPSILON * Math.max(1, Math.abs(me), Math.abs(tt)) && Math.abs(ge - Et) <= e.EPSILON * Math.max(1, Math.abs(ge), Math.abs(Et)) && Math.abs(ue - lt) <= e.EPSILON * Math.max(1, Math.abs(ue), Math.abs(lt)) && Math.abs(Se - St) <= e.EPSILON * Math.max(1, Math.abs(Se), Math.abs(St));
          }, de.sqrLen = de.squaredLength = de.len = de.length = de.dot = de.mul = de.setReal = de.getReal = void 0;
          var e = s(E()), i = s(xe()), o = s(W());
          function c(D) {
            if (typeof WeakMap != "function") return null;
            var S = /* @__PURE__ */ new WeakMap(), R = /* @__PURE__ */ new WeakMap();
            return (c = function(j) {
              return j ? R : S;
            })(D);
          }
          function s(D, S) {
            if (D && D.__esModule) return D;
            if (D === null || a(D) !== "object" && typeof D != "function") return { default: D };
            var R = c(S);
            if (R && R.has(D)) return R.get(D);
            var j = {}, J = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var ne in D) if (ne !== "default" && Object.prototype.hasOwnProperty.call(D, ne)) {
              var me = J ? Object.getOwnPropertyDescriptor(D, ne) : null;
              me && (me.get || me.set) ? Object.defineProperty(j, ne, me) : j[ne] = D[ne];
            }
            return j.default = D, R && R.set(D, j), j;
          }
          function h(D, S, R) {
            var j = 0.5 * R[0], J = 0.5 * R[1], ne = 0.5 * R[2], me = S[0], ge = S[1], ue = S[2], Se = S[3];
            return D[0] = me, D[1] = ge, D[2] = ue, D[3] = Se, D[4] = j * Se + J * ue - ne * ge, D[5] = J * Se + ne * me - j * ue, D[6] = ne * Se + j * ge - J * me, D[7] = -j * me - J * ge - ne * ue, D;
          }
          function y(D, S) {
            return D[0] = S[0], D[1] = S[1], D[2] = S[2], D[3] = S[3], D[4] = S[4], D[5] = S[5], D[6] = S[6], D[7] = S[7], D;
          }
          function T(D, S, R) {
            var j = S[0], J = S[1], ne = S[2], me = S[3], ge = R[4], ue = R[5], Se = R[6], ke = R[7], He = S[4], at = S[5], nt = S[6], tt = S[7], Et = R[0], lt = R[1], St = R[2], Lt = R[3];
            return D[0] = j * Lt + me * Et + J * St - ne * lt, D[1] = J * Lt + me * lt + ne * Et - j * St, D[2] = ne * Lt + me * St + j * lt - J * Et, D[3] = me * Lt - j * Et - J * lt - ne * St, D[4] = j * ke + me * ge + J * Se - ne * ue + He * Lt + tt * Et + at * St - nt * lt, D[5] = J * ke + me * ue + ne * ge - j * Se + at * Lt + tt * lt + nt * Et - He * St, D[6] = ne * ke + me * Se + j * ue - J * ge + nt * Lt + tt * St + He * lt - at * Et, D[7] = me * ke - j * ge - J * ue - ne * Se + tt * Lt - He * Et - at * lt - nt * St, D;
          }
          de.getReal = i.copy, de.setReal = i.copy, de.mul = T;
          var k = i.dot;
          de.dot = k;
          var g = i.length;
          de.length = g, de.len = g;
          var A = i.squaredLength;
          return de.squaredLength = A, de.sqrLen = A, de;
        }
        var ze, Ze, Ue = {};
        function Ie() {
          if (ze) return Ue;
          function a(S) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(R) {
              return typeof R;
            } : function(R) {
              return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
            }, a(S);
          }
          ze = 1, Object.defineProperty(Ue, "__esModule", { value: !0 }), Ue.create = o, Ue.clone = function(S) {
            var R = new e.ARRAY_TYPE(2);
            return R[0] = S[0], R[1] = S[1], R;
          }, Ue.fromValues = function(S, R) {
            var j = new e.ARRAY_TYPE(2);
            return j[0] = S, j[1] = R, j;
          }, Ue.copy = function(S, R) {
            return S[0] = R[0], S[1] = R[1], S;
          }, Ue.set = function(S, R, j) {
            return S[0] = R, S[1] = j, S;
          }, Ue.add = function(S, R, j) {
            return S[0] = R[0] + j[0], S[1] = R[1] + j[1], S;
          }, Ue.subtract = c, Ue.multiply = s, Ue.divide = h, Ue.ceil = function(S, R) {
            return S[0] = Math.ceil(R[0]), S[1] = Math.ceil(R[1]), S;
          }, Ue.floor = function(S, R) {
            return S[0] = Math.floor(R[0]), S[1] = Math.floor(R[1]), S;
          }, Ue.min = function(S, R, j) {
            return S[0] = Math.min(R[0], j[0]), S[1] = Math.min(R[1], j[1]), S;
          }, Ue.max = function(S, R, j) {
            return S[0] = Math.max(R[0], j[0]), S[1] = Math.max(R[1], j[1]), S;
          }, Ue.round = function(S, R) {
            return S[0] = Math.round(R[0]), S[1] = Math.round(R[1]), S;
          }, Ue.scale = function(S, R, j) {
            return S[0] = R[0] * j, S[1] = R[1] * j, S;
          }, Ue.scaleAndAdd = function(S, R, j, J) {
            return S[0] = R[0] + j[0] * J, S[1] = R[1] + j[1] * J, S;
          }, Ue.distance = y, Ue.squaredDistance = T, Ue.length = k, Ue.squaredLength = g, Ue.negate = function(S, R) {
            return S[0] = -R[0], S[1] = -R[1], S;
          }, Ue.inverse = function(S, R) {
            return S[0] = 1 / R[0], S[1] = 1 / R[1], S;
          }, Ue.normalize = function(S, R) {
            var j = R[0], J = R[1], ne = j * j + J * J;
            return ne > 0 && (ne = 1 / Math.sqrt(ne)), S[0] = R[0] * ne, S[1] = R[1] * ne, S;
          }, Ue.dot = function(S, R) {
            return S[0] * R[0] + S[1] * R[1];
          }, Ue.cross = function(S, R, j) {
            var J = R[0] * j[1] - R[1] * j[0];
            return S[0] = S[1] = 0, S[2] = J, S;
          }, Ue.lerp = function(S, R, j, J) {
            var ne = R[0], me = R[1];
            return S[0] = ne + J * (j[0] - ne), S[1] = me + J * (j[1] - me), S;
          }, Ue.random = function(S, R) {
            R = R || 1;
            var j = 2 * e.RANDOM() * Math.PI;
            return S[0] = Math.cos(j) * R, S[1] = Math.sin(j) * R, S;
          }, Ue.transformMat2 = function(S, R, j) {
            var J = R[0], ne = R[1];
            return S[0] = j[0] * J + j[2] * ne, S[1] = j[1] * J + j[3] * ne, S;
          }, Ue.transformMat2d = function(S, R, j) {
            var J = R[0], ne = R[1];
            return S[0] = j[0] * J + j[2] * ne + j[4], S[1] = j[1] * J + j[3] * ne + j[5], S;
          }, Ue.transformMat3 = function(S, R, j) {
            var J = R[0], ne = R[1];
            return S[0] = j[0] * J + j[3] * ne + j[6], S[1] = j[1] * J + j[4] * ne + j[7], S;
          }, Ue.transformMat4 = function(S, R, j) {
            var J = R[0], ne = R[1];
            return S[0] = j[0] * J + j[4] * ne + j[12], S[1] = j[1] * J + j[5] * ne + j[13], S;
          }, Ue.rotate = function(S, R, j, J) {
            var ne = R[0] - j[0], me = R[1] - j[1], ge = Math.sin(J), ue = Math.cos(J);
            return S[0] = ne * ue - me * ge + j[0], S[1] = ne * ge + me * ue + j[1], S;
          }, Ue.angle = function(S, R) {
            var j = S[0], J = S[1], ne = R[0], me = R[1], ge = Math.sqrt(j * j + J * J) * Math.sqrt(ne * ne + me * me);
            return Math.acos(Math.min(Math.max(ge && (j * ne + J * me) / ge, -1), 1));
          }, Ue.zero = function(S) {
            return S[0] = 0, S[1] = 0, S;
          }, Ue.str = function(S) {
            return "vec2(" + S[0] + ", " + S[1] + ")";
          }, Ue.exactEquals = function(S, R) {
            return S[0] === R[0] && S[1] === R[1];
          }, Ue.equals = function(S, R) {
            var j = S[0], J = S[1], ne = R[0], me = R[1];
            return Math.abs(j - ne) <= e.EPSILON * Math.max(1, Math.abs(j), Math.abs(ne)) && Math.abs(J - me) <= e.EPSILON * Math.max(1, Math.abs(J), Math.abs(me));
          }, Ue.forEach = Ue.sqrLen = Ue.sqrDist = Ue.dist = Ue.div = Ue.mul = Ue.sub = Ue.len = void 0;
          var e = function(S, R) {
            if (S && S.__esModule) return S;
            if (S === null || a(S) !== "object" && typeof S != "function") return { default: S };
            var j = i(void 0);
            if (j && j.has(S)) return j.get(S);
            var J = {}, ne = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var me in S) if (me !== "default" && Object.prototype.hasOwnProperty.call(S, me)) {
              var ge = ne ? Object.getOwnPropertyDescriptor(S, me) : null;
              ge && (ge.get || ge.set) ? Object.defineProperty(J, me, ge) : J[me] = S[me];
            }
            return J.default = S, j && j.set(S, J), J;
          }(E());
          function i(S) {
            if (typeof WeakMap != "function") return null;
            var R = /* @__PURE__ */ new WeakMap(), j = /* @__PURE__ */ new WeakMap();
            return (i = function(J) {
              return J ? j : R;
            })(S);
          }
          function o() {
            var S = new e.ARRAY_TYPE(2);
            return e.ARRAY_TYPE != Float32Array && (S[0] = 0, S[1] = 0), S;
          }
          function c(S, R, j) {
            return S[0] = R[0] - j[0], S[1] = R[1] - j[1], S;
          }
          function s(S, R, j) {
            return S[0] = R[0] * j[0], S[1] = R[1] * j[1], S;
          }
          function h(S, R, j) {
            return S[0] = R[0] / j[0], S[1] = R[1] / j[1], S;
          }
          function y(S, R) {
            return Math.hypot(R[0] - S[0], R[1] - S[1]);
          }
          function T(S, R) {
            var j = R[0] - S[0], J = R[1] - S[1];
            return j * j + J * J;
          }
          function k(S) {
            return Math.hypot(S[0], S[1]);
          }
          function g(S) {
            var R = S[0], j = S[1];
            return R * R + j * j;
          }
          Ue.len = k, Ue.sub = c, Ue.mul = s, Ue.div = h, Ue.dist = y, Ue.sqrDist = T, Ue.sqrLen = g;
          var A, D = (A = o(), function(S, R, j, J, ne, me) {
            var ge, ue;
            for (R || (R = 2), j || (j = 0), ue = J ? Math.min(J * R + j, S.length) : S.length, ge = j; ge < ue; ge += R) A[0] = S[ge], A[1] = S[ge + 1], ne(A, A, me), S[ge] = A[0], S[ge + 1] = A[1];
            return S;
          });
          return Ue.forEach = D, Ue;
        }
        function je() {
          if (Ze) return P;
          function a(S) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(R) {
              return typeof R;
            } : function(R) {
              return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
            }, a(S);
          }
          Ze = 1, Object.defineProperty(P, "__esModule", { value: !0 }), P.vec4 = P.vec3 = P.vec2 = P.quat2 = P.quat = P.mat4 = P.mat3 = P.mat2d = P.mat2 = P.glMatrix = void 0;
          var e = D(E());
          P.glMatrix = e;
          var i = D(I());
          P.mat2 = i;
          var o = D(C());
          P.mat2d = o;
          var c = D(N());
          P.mat3 = c;
          var s = D(W());
          P.mat4 = s;
          var h = D(xe());
          P.quat = h;
          var y = D(De());
          P.quat2 = y;
          var T = D(Ie());
          P.vec2 = T;
          var k = D(se());
          P.vec3 = k;
          var g = D(Me());
          function A(S) {
            if (typeof WeakMap != "function") return null;
            var R = /* @__PURE__ */ new WeakMap(), j = /* @__PURE__ */ new WeakMap();
            return (A = function(J) {
              return J ? j : R;
            })(S);
          }
          function D(S, R) {
            if (S && S.__esModule) return S;
            if (S === null || a(S) !== "object" && typeof S != "function") return { default: S };
            var j = A(R);
            if (j && j.has(S)) return j.get(S);
            var J = {}, ne = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var me in S) if (me !== "default" && Object.prototype.hasOwnProperty.call(S, me)) {
              var ge = ne ? Object.getOwnPropertyDescriptor(S, me) : null;
              ge && (ge.get || ge.set) ? Object.defineProperty(J, me, ge) : J[me] = S[me];
            }
            return J.default = S, j && j.set(S, J), J;
          }
          return P.vec4 = g, P;
        }
        var Fe, $e, ct, wt, Oe = je(), Ct = function() {
          if ($e) return Fe;
          function a(e, i, o, c) {
            this.cx = 3 * e, this.bx = 3 * (o - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * i, this.by = 3 * (c - i) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = i, this.p2x = o, this.p2y = c;
          }
          return $e = 1, Fe = a, a.prototype = { sampleCurveX: function(e) {
            return ((this.ax * e + this.bx) * e + this.cx) * e;
          }, sampleCurveY: function(e) {
            return ((this.ay * e + this.by) * e + this.cy) * e;
          }, sampleCurveDerivativeX: function(e) {
            return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
          }, solveCurveX: function(e, i) {
            if (i === void 0 && (i = 1e-6), e < 0) return 0;
            if (e > 1) return 1;
            for (var o = e, c = 0; c < 8; c++) {
              var s = this.sampleCurveX(o) - e;
              if (Math.abs(s) < i) return o;
              var h = this.sampleCurveDerivativeX(o);
              if (Math.abs(h) < 1e-6) break;
              o -= s / h;
            }
            var y = 0, T = 1;
            for (o = e, c = 0; c < 20 && (s = this.sampleCurveX(o), !(Math.abs(s - e) < i)); c++) e > s ? y = o : T = o, o = 0.5 * (T - y) + y;
            return o;
          }, solve: function(e, i) {
            return this.sampleCurveY(this.solveCurveX(e, i));
          } }, Fe;
        }(), Xt = F(Ct);
        function vt() {
          if (wt) return ct;
          function a(e, i) {
            this.x = e, this.y = i;
          }
          return wt = 1, ct = a, a.prototype = { clone: function() {
            return new a(this.x, this.y);
          }, add: function(e) {
            return this.clone()._add(e);
          }, sub: function(e) {
            return this.clone()._sub(e);
          }, multByPoint: function(e) {
            return this.clone()._multByPoint(e);
          }, divByPoint: function(e) {
            return this.clone()._divByPoint(e);
          }, mult: function(e) {
            return this.clone()._mult(e);
          }, div: function(e) {
            return this.clone()._div(e);
          }, rotate: function(e) {
            return this.clone()._rotate(e);
          }, rotateAround: function(e, i) {
            return this.clone()._rotateAround(e, i);
          }, matMult: function(e) {
            return this.clone()._matMult(e);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(e) {
            return this.x === e.x && this.y === e.y;
          }, dist: function(e) {
            return Math.sqrt(this.distSqr(e));
          }, distSqr: function(e) {
            var i = e.x - this.x, o = e.y - this.y;
            return i * i + o * o;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(e) {
            return Math.atan2(this.y - e.y, this.x - e.x);
          }, angleWith: function(e) {
            return this.angleWithSep(e.x, e.y);
          }, angleWithSep: function(e, i) {
            return Math.atan2(this.x * i - this.y * e, this.x * e + this.y * i);
          }, _matMult: function(e) {
            var i = e[2] * this.x + e[3] * this.y;
            return this.x = e[0] * this.x + e[1] * this.y, this.y = i, this;
          }, _add: function(e) {
            return this.x += e.x, this.y += e.y, this;
          }, _sub: function(e) {
            return this.x -= e.x, this.y -= e.y, this;
          }, _mult: function(e) {
            return this.x *= e, this.y *= e, this;
          }, _div: function(e) {
            return this.x /= e, this.y /= e, this;
          }, _multByPoint: function(e) {
            return this.x *= e.x, this.y *= e.y, this;
          }, _divByPoint: function(e) {
            return this.x /= e.x, this.y /= e.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var e = this.y;
            return this.y = this.x, this.x = -e, this;
          }, _rotate: function(e) {
            var i = Math.cos(e), o = Math.sin(e), c = o * this.x + i * this.y;
            return this.x = i * this.x - o * this.y, this.y = c, this;
          }, _rotateAround: function(e, i) {
            var o = Math.cos(e), c = Math.sin(e), s = i.y + c * (this.x - i.x) + o * (this.y - i.y);
            return this.x = i.x + o * (this.x - i.x) - c * (this.y - i.y), this.y = s, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, a.convert = function(e) {
            return e instanceof a ? e : Array.isArray(e) ? new a(e[0], e[1]) : e;
          }, ct;
        }
        var Ye = F(vt());
        function qe(a, e) {
          if (Array.isArray(a)) {
            if (!Array.isArray(e) || a.length !== e.length) return !1;
            for (let i = 0; i < a.length; i++) if (!qe(a[i], e[i])) return !1;
            return !0;
          }
          if (typeof a == "object" && a !== null && e !== null) {
            if (typeof e != "object" || Object.keys(a).length !== Object.keys(e).length) return !1;
            for (const i in a) if (!qe(a[i], e[i])) return !1;
            return !0;
          }
          return a === e;
        }
        const rt = Math.PI / 180, it = 180 / Math.PI;
        function Ae(a) {
          return a * rt;
        }
        function _e(a) {
          return a * it;
        }
        const fe = [[0, 0], [1, 0], [1, 1], [0, 1]];
        function We(a) {
          if (a <= 0) return 0;
          if (a >= 1) return 1;
          const e = a * a, i = e * a;
          return 4 * (a < 0.5 ? i : 3 * (a - e) + i - 0.75);
        }
        function Pe(a, e, i, o) {
          const c = new Xt(a, e, i, o);
          return function(s) {
            return c.solve(s);
          };
        }
        const he = Pe(0.25, 0.1, 0.25, 1);
        function ie(a, e, i) {
          return Math.min(i, Math.max(e, a));
        }
        function Xe(a, e, i) {
          return (i = ie((i - a) / (e - a), 0, 1)) * i * (3 - 2 * i);
        }
        function bt(a, e, i) {
          const o = i - e, c = ((a - e) % o + o) % o + e;
          return c === e ? i : c;
        }
        function Wt(a, e, i) {
          if (!a.length) return i(null, []);
          let o = a.length;
          const c = new Array(a.length);
          let s = null;
          a.forEach((h, y) => {
            e(h, (T, k) => {
              T && (s = T), c[y] = k, --o == 0 && i(s, c);
            });
          });
        }
        function Qt(a, ...e) {
          for (const i of e) for (const o in i) a[o] = i[o];
          return a;
        }
        let Sr = 1;
        function Fr() {
          return Sr++;
        }
        function kr(a) {
          return a <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
        }
        function Ur(a, e) {
          a.forEach((i) => {
            e[i] && (e[i] = e[i].bind(e));
          });
        }
        function Rr(a, e) {
          return a.indexOf(e, a.length - e.length) !== -1;
        }
        function Pr(a, e, i) {
          const o = {};
          for (const c in a) o[c] = e.call(this, a[c], c, a);
          return o;
        }
        function hi(a, e, i) {
          const o = {};
          for (const c in a) e.call(this, a[c], c, a) && (o[c] = a[c]);
          return o;
        }
        function Vr(a) {
          return Array.isArray(a) ? a.map(Vr) : typeof a == "object" && a ? Pr(a, Vr) : a;
        }
        const Te = {};
        function Tt(a) {
          Te[a] || (typeof console < "u" && console.warn(a), Te[a] = !0);
        }
        function Gt(a, e, i) {
          return (i.y - a.y) * (e.x - a.x) > (e.y - a.y) * (i.x - a.x);
        }
        function pr(a) {
          let e = 0;
          for (let i, o, c = 0, s = a.length, h = s - 1; c < s; h = c++) i = a[c], o = a[h], e += (o.x - i.x) * (i.y + o.y);
          return e;
        }
        function kt([a, e, i]) {
          const o = Ae(e + 90), c = Ae(i);
          return { x: a * Math.cos(o) * Math.sin(c), y: a * Math.sin(o) * Math.sin(c), z: a * Math.cos(c), azimuthal: e, polar: i };
        }
        function tr() {
          return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
        }
        function Je(a) {
          const e = {};
          if (a.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (i, o, c, s) => {
            const h = c || s;
            return e[o] = !h || h.toLowerCase(), "";
          }), e["max-age"]) {
            const i = parseInt(e["max-age"], 10);
            isNaN(i) ? delete e["max-age"] : e["max-age"] = i;
          }
          return e;
        }
        let wr = null;
        function ni(a, e) {
          return [a[4 * e], a[4 * e + 1], a[4 * e + 2], a[4 * e + 3]];
        }
        function Z(a, e, i, o) {
          for (; e < i; ) {
            const c = e + i >> 1;
            a[c] < o ? e = c + 1 : i = c;
          }
          return e;
        }
        function Dt(a, e, i, o) {
          for (; e < i; ) {
            const c = e + i >> 1;
            a[c] <= o ? e = c + 1 : i = c;
          }
          return e;
        }
        function er(a) {
          return a > 0 ? 1 / (1.001 - a) : 1 + a;
        }
        function we(a) {
          return a > 0 ? 1 - 1 / (1.001 - a) : -a;
        }
        const yt = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
        }, get API_TILEJSON_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
        }, get API_SPRITE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
        }, get API_FONTS_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
        }, get API_STYLE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
        }, get API_CDN_URL_REGEX() {
          return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
        }, get EVENTS_URL() {
          if (!yt.API_URL) return null;
          try {
            const a = new URL(yt.API_URL);
            return a.hostname === "api.mapbox.cn" ? "https://events.mapbox.cn/events/v2" : a.hostname === "api.mapbox.com" ? "https://events.mapbox.com/events/v2" : null;
          } catch {
            return null;
          }
        }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf", TILES3D_URL_PREFIX: "3dtiles/v1" };
        function ar(a) {
          return yt.API_URL_REGEX.test(a);
        }
        function Or(a) {
          return yt.API_SPRITE_REGEX.test(a);
        }
        let Dr, Kr, di, $t, Ce, Ne;
        function Ke() {
          return Dr == null && (Dr = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && typeof self.createImageBitmap == "function"), Dr;
        }
        const ht = { now: () => $t !== void 0 ? $t : performance.now(), setNow(a) {
          $t = a;
        }, restoreNow() {
          $t = void 0;
        }, frame(a) {
          const e = requestAnimationFrame(a);
          return { cancel: () => cancelAnimationFrame(e) };
        }, getImageData(a, e = 0) {
          const { width: i, height: o } = a;
          Ce || (Ce = document.createElement("canvas"));
          const c = Ce.getContext("2d", { willReadFrequently: !0 });
          if (!c) throw new Error("failed to create canvas 2d context");
          return (i > Ce.width || o > Ce.height) && (Ce.width = i, Ce.height = o), c.clearRect(-e, -e, i + 2 * e, o + 2 * e), c.drawImage(a, 0, 0, i, o), c.getImageData(-e, -e, i + 2 * e, o + 2 * e);
        }, resolveURL: (a) => (Kr || (Kr = document.createElement("a")), Kr.href = a, Kr.href), get devicePixelRatio() {
          return window.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!window.matchMedia && (di == null && (di = window.matchMedia("(prefers-reduced-motion: reduce)")), di.matches);
        }, hasCanvasFingerprintNoise() {
          if (Ne !== void 0) return Ne;
          if (!Ke()) return Ne = !1, !1;
          const a = new OffscreenCanvas(85, 1), e = a.getContext("2d", { willReadFrequently: !0 });
          let i = 0;
          for (let c = 0; c < a.width; ++c) e.fillStyle = `rgba(${i++},${i++},${i++}, 255)`, e.fillRect(c, 0, 1, 1);
          const o = e.getImageData(0, 0, a.width, a.height);
          i = 0;
          for (let c = 0; c < o.data.length; ++c) if (c % 4 != 3 && i++ !== o.data[c]) return Ne = !0, !0;
          return Ne = !1, !1;
        } };
        function ft(a, e) {
          const i = a.indexOf("?");
          if (i < 0) return `${a}?${new URLSearchParams(e).toString()}`;
          const o = new URLSearchParams(a.slice(i));
          for (const c in e) o.set(c, e[c]);
          return `${a.slice(0, i)}?${o.toString()}`;
        }
        function Pt(a, e = { persistentParams: [] }) {
          const i = a.indexOf("?");
          if (i < 0) return a;
          const o = new URLSearchParams(), c = new URLSearchParams(a.slice(i));
          for (const h of e.persistentParams) {
            const y = c.get(h);
            y && o.set(h, y);
          }
          const s = o.toString();
          return `${a.slice(0, i)}${s.length > 0 ? `?${s}` : ""}`;
        }
        const Nt = "mapbox-tiles";
        let At = 500, Zt = 50;
        const jt = ["language", "worldview", "jobid"];
        let Yt, fr;
        function Ir() {
          try {
            return caches;
          } catch {
          }
        }
        function Lr() {
          const a = Ir();
          a && Yt == null && (Yt = a.open(Nt));
        }
        let qr = 1 / 0;
        const pi = { supported: !1, testSupport: function(a) {
          !ki && si && (Ni ? Wi(a) : fi = a);
        } };
        let fi, si, ki = !1, Ni = !1;
        const Li = typeof self < "u" ? self : {};
        function Wi(a) {
          const e = a.createTexture();
          a.bindTexture(a.TEXTURE_2D, e);
          try {
            if (a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, si), a.isContextLost()) return;
            pi.supported = !0;
          } catch {
          }
          a.deleteTexture(e), ki = !0;
        }
        Li.document && (si = Li.document.createElement("img"), si.onload = function() {
          fi && Wi(fi), fi = null, Ni = !0;
        }, si.onerror = function() {
          ki = !0, fi = null;
        }, si.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const Bi = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Iconset: "Iconset", Image: "Image", Model: "Model" };
        typeof Object.freeze == "function" && Object.freeze(Bi);
        class Gn extends Error {
          constructor(e, i, o) {
            i === 401 && ar(o) && (e += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(e), this.status = i, this.url = o;
          }
          toString() {
            return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
          }
        }
        const sa = tr() ? () => self.worker && self.worker.referrer : () => (location.protocol === "blob:" ? parent : self).location.href, Yn = function(a, e) {
          if (!(/^file:/.test(i = a.url) || /^file:/.test(sa()) && !/^\w+:/.test(i))) {
            if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function(o, c) {
              const s = new AbortController(), h = new Request(o.url, { method: o.method || "GET", body: o.body, credentials: o.credentials, headers: o.headers, referrer: sa(), referrerPolicy: o.referrerPolicy, signal: s.signal });
              let y = !1, T = !1;
              const k = (g = h.url).indexOf("sku=") > 0 && ar(g);
              var g;
              o.type === "json" && h.headers.set("Accept", "application/json");
              const A = (S, R, j) => {
                if (T) return;
                if (S && S.message !== "SecurityError" && Tt(S.toString()), R && j) return D(R);
                const J = Date.now();
                fetch(h).then((ne) => {
                  if (ne.ok) {
                    const me = k ? ne.clone() : null;
                    return D(ne, me, J);
                  }
                  return c(new Gn(ne.statusText, ne.status, o.url));
                }).catch((ne) => {
                  ne.name !== "AbortError" && c(new Error(`${ne.message} ${o.url}`));
                });
              }, D = (S, R, j) => {
                (o.type === "arrayBuffer" ? S.arrayBuffer() : o.type === "json" ? S.json() : S.text()).then((J) => {
                  T || (R && j && function(ne, me, ge) {
                    if (Lr(), Yt == null) return;
                    const ue = Je(me.headers.get("Cache-Control") || "");
                    if (ue["no-store"]) return;
                    const Se = { status: me.status, statusText: me.statusText, headers: new Headers() };
                    me.headers.forEach((at, nt) => Se.headers.set(nt, at)), ue["max-age"] && Se.headers.set("Expires", new Date(ge + 1e3 * ue["max-age"]).toUTCString());
                    const ke = Se.headers.get("Expires");
                    if (!ke || new Date(ke).getTime() - ge < 42e4) return;
                    let He = Pt(ne.url, { persistentParams: jt });
                    if (me.status === 206) {
                      const at = ne.headers.get("Range");
                      if (!at) return;
                      Se.status = 200, He = ft(He, { range: at });
                    }
                    (function(at, nt) {
                      if (fr === void 0) try {
                        new Response(new ReadableStream()), fr = !0;
                      } catch {
                        fr = !1;
                      }
                      fr ? nt(at.body) : at.blob().then(nt);
                    })(me, (at) => {
                      const nt = new Response((tt = me.status) !== 200 && tt !== 404 && [101, 103, 204, 205, 304].includes(tt) ? null : at, Se);
                      var tt;
                      Lr(), Yt != null && Yt.then((Et) => Et.put(He, nt)).catch((Et) => Tt(Et.message));
                    });
                  }(h, R, j), y = !0, c(null, J, S.headers.get("Cache-Control"), S.headers.get("Expires")));
                }).catch((J) => {
                  T || c(new Error(J.message));
                });
              };
              return k ? function(S, R) {
                if (Lr(), Yt == null) return R(null);
                Yt.then((j) => {
                  let J = Pt(S.url, { persistentParams: jt });
                  const ne = S.headers.get("Range");
                  ne && (J = ft(J, { range: ne })), j.match(J).then((me) => {
                    const ge = function(ue) {
                      if (!ue) return !1;
                      const Se = new Date(ue.headers.get("Expires") || 0), ke = Je(ue.headers.get("Cache-Control") || "");
                      return Se > Date.now() && !ke["no-cache"];
                    }(me);
                    j.delete(J), ge && j.put(J, me.clone()), R(null, me, ge);
                  }).catch(R);
                }).catch(R);
              }(h, A) : A(null, null), { cancel: () => {
                T = !0, y || s.abort();
              } };
            }(a, e);
            if (tr() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", a, e, void 0, !0);
          }
          var i;
          return function(o, c) {
            const s = new XMLHttpRequest();
            s.open(o.method || "GET", o.url, !0), o.type === "arrayBuffer" && (s.responseType = "arraybuffer");
            for (const h in o.headers) s.setRequestHeader(h, o.headers[h]);
            return o.type === "json" && (s.responseType = "text", s.setRequestHeader("Accept", "application/json")), s.withCredentials = o.credentials === "include", s.onerror = () => {
              c(new Error(s.statusText));
            }, s.onload = () => {
              if ((s.status >= 200 && s.status < 300 || s.status === 0) && s.response !== null) {
                let h = s.response;
                if (o.type === "json") try {
                  h = JSON.parse(s.response);
                } catch (y) {
                  return c(y);
                }
                c(null, h, s.getResponseHeader("Cache-Control"), s.getResponseHeader("Expires"));
              } else c(new Gn(s.statusText, s.status, o.url));
            }, s.send(o.body), { cancel: () => s.abort() };
          }(a, e);
        }, ea = function(a, e) {
          return Yn(Qt(a, { type: "arrayBuffer" }), e);
        };
        function Pa(a) {
          const e = document.createElement("a");
          return e.href = a, e.protocol === location.protocol && e.host === location.host;
        }
        const Fs = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let wo, fs;
        wo = [], fs = 0;
        const ou = function(a, e) {
          if (pi.supported && (a.headers || (a.headers = {}), a.headers.accept = "image/webp,*/*"), fs >= yt.MAX_PARALLEL_IMAGE_REQUESTS) {
            const s = { requestParameters: a, callback: e, cancelled: !1, cancel() {
              this.cancelled = !0;
            } };
            return wo.push(s), s;
          }
          fs++;
          let i = !1;
          const o = () => {
            if (!i) for (i = !0, fs--; wo.length && fs < yt.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const s = wo.shift(), { requestParameters: h, callback: y, cancelled: T } = s;
              T || (s.cancel = ou(h, y).cancel);
            }
          }, c = ea(a, (s, h, y, T) => {
            o(), s ? e(s) : h && (self.createImageBitmap ? function(k, g) {
              const A = new Blob([new Uint8Array(k)], { type: "image/png" });
              createImageBitmap(A).then((D) => {
                g(null, D);
              }).catch((D) => {
                g(new Error(`Could not load image because of ${D.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
              });
            }(h, (k, g) => e(k, g, y, T)) : function(k, g) {
              const A = new Image();
              A.onload = () => {
                g(null, A), URL.revokeObjectURL(A.src), A.onload = null, requestAnimationFrame(() => {
                  A.src = Fs;
                });
              }, A.onerror = () => g(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              const D = new Blob([new Uint8Array(k)], { type: "image/png" });
              A.src = k.byteLength ? URL.createObjectURL(D) : Fs;
            }(h, (k, g) => e(k, g, y, T)));
          });
          return { cancel: () => {
            c.cancel(), o();
          } };
        };
        var mf, Th, Vu, Sa = { exports: {} }, lo = { exports: {} }, uo = { exports: {} }, Wo = function() {
          if (Vu) return Sa.exports;
          Vu = 1;
          var a = (mf || (mf = 1, lo.exports = function(i, o) {
            var c, s, h, y, T, k, g, A;
            for (s = i.length - (c = 3 & i.length), h = o, T = 3432918353, k = 461845907, A = 0; A < s; ) g = 255 & i.charCodeAt(A) | (255 & i.charCodeAt(++A)) << 8 | (255 & i.charCodeAt(++A)) << 16 | (255 & i.charCodeAt(++A)) << 24, ++A, h = 27492 + (65535 & (y = 5 * (65535 & (h = (h ^= g = (65535 & (g = (g = (65535 & g) * T + (((g >>> 16) * T & 65535) << 16) & 4294967295) << 15 | g >>> 17)) * k + (((g >>> 16) * k & 65535) << 16) & 4294967295) << 13 | h >>> 19)) + ((5 * (h >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (y >>> 16) & 65535) << 16);
            switch (g = 0, c) {
              case 3:
                g ^= (255 & i.charCodeAt(A + 2)) << 16;
              case 2:
                g ^= (255 & i.charCodeAt(A + 1)) << 8;
              case 1:
                h ^= g = (65535 & (g = (g = (65535 & (g ^= 255 & i.charCodeAt(A))) * T + (((g >>> 16) * T & 65535) << 16) & 4294967295) << 15 | g >>> 17)) * k + (((g >>> 16) * k & 65535) << 16) & 4294967295;
            }
            return h ^= i.length, h = 2246822507 * (65535 & (h ^= h >>> 16)) + ((2246822507 * (h >>> 16) & 65535) << 16) & 4294967295, h = 3266489909 * (65535 & (h ^= h >>> 13)) + ((3266489909 * (h >>> 16) & 65535) << 16) & 4294967295, (h ^= h >>> 16) >>> 0;
          }), lo.exports), e = (Th || (Th = 1, uo.exports = function(i, o) {
            for (var c, s = i.length, h = o ^ s, y = 0; s >= 4; ) c = 1540483477 * (65535 & (c = 255 & i.charCodeAt(y) | (255 & i.charCodeAt(++y)) << 8 | (255 & i.charCodeAt(++y)) << 16 | (255 & i.charCodeAt(++y)) << 24)) + ((1540483477 * (c >>> 16) & 65535) << 16), h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ (c = 1540483477 * (65535 & (c ^= c >>> 24)) + ((1540483477 * (c >>> 16) & 65535) << 16)), s -= 4, ++y;
            switch (s) {
              case 3:
                h ^= (255 & i.charCodeAt(y + 2)) << 16;
              case 2:
                h ^= (255 & i.charCodeAt(y + 1)) << 8;
              case 1:
                h = 1540483477 * (65535 & (h ^= 255 & i.charCodeAt(y))) + ((1540483477 * (h >>> 16) & 65535) << 16);
            }
            return h = 1540483477 * (65535 & (h ^= h >>> 13)) + ((1540483477 * (h >>> 16) & 65535) << 16), (h ^= h >>> 15) >>> 0;
          }), uo.exports);
          return Sa.exports = a, Sa.exports.murmur3 = a, Sa.exports.murmur2 = e, Sa.exports;
        }(), co = F(Wo);
        class on {
          constructor(e, ...i) {
            Qt(this, i[0] || {}), this.type = e;
          }
        }
        class Gu extends on {
          constructor(e, i = {}) {
            super("error", Qt({ error: e }, i));
          }
        }
        function Cc(a, e, i) {
          i[a] && i[a].indexOf(e) !== -1 || (i[a] = i[a] || [], i[a].push(e));
        }
        function Zo(a, e, i) {
          if (i && i[a]) {
            const o = i[a].indexOf(e);
            o !== -1 && i[a].splice(o, 1);
          }
        }
        class ds {
          on(e, i) {
            return this._listeners = this._listeners || {}, Cc(e, i, this._listeners), this;
          }
          off(e, i) {
            return Zo(e, i, this._listeners), Zo(e, i, this._oneTimeListeners), this;
          }
          once(e, i) {
            return i ? (this._oneTimeListeners = this._oneTimeListeners || {}, Cc(e, i, this._oneTimeListeners), this) : new Promise((o) => this.once(e, o));
          }
          fire(e, i) {
            const o = typeof e == "string" ? new on(e, i) : e, c = o.type;
            if (this.listens(c)) {
              o.target = this;
              const s = this._listeners && this._listeners[c] ? this._listeners[c].slice() : [];
              for (const T of s) T.call(this, o);
              const h = this._oneTimeListeners && this._oneTimeListeners[c] ? this._oneTimeListeners[c].slice() : [];
              for (const T of h) Zo(c, T, this._oneTimeListeners), T.call(this, o);
              const y = this._eventedParent;
              y && (Qt(o, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), y.fire(o));
            } else o instanceof Gu && console.error(o.error);
            return this;
          }
          listens(e) {
            return !!(this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e));
          }
          setEventedParent(e, i) {
            return this._eventedParent = e, this._eventedParentData = i, this;
          }
        }
        var Mh, Pc = {}, Xa = function() {
          if (Mh) return Pc;
          Mh = 1;
          var a = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
          function e(s) {
            return (s = Math.round(s)) < 0 ? 0 : s > 255 ? 255 : s;
          }
          function i(s) {
            return e(s[s.length - 1] === "%" ? parseFloat(s) / 100 * 255 : parseInt(s));
          }
          function o(s) {
            return (h = s[s.length - 1] === "%" ? parseFloat(s) / 100 : parseFloat(s)) < 0 ? 0 : h > 1 ? 1 : h;
            var h;
          }
          function c(s, h, y) {
            return y < 0 ? y += 1 : y > 1 && (y -= 1), 6 * y < 1 ? s + (h - s) * y * 6 : 2 * y < 1 ? h : 3 * y < 2 ? s + (h - s) * (2 / 3 - y) * 6 : s;
          }
          try {
            Pc.parseCSSColor = function(s) {
              var h, y = s.replace(/ /g, "").toLowerCase();
              if (y in a) return a[y].slice();
              if (y[0] === "#") return y.length === 4 ? (h = parseInt(y.substr(1), 16)) >= 0 && h <= 4095 ? [(3840 & h) >> 4 | (3840 & h) >> 8, 240 & h | (240 & h) >> 4, 15 & h | (15 & h) << 4, 1] : null : y.length === 7 && (h = parseInt(y.substr(1), 16)) >= 0 && h <= 16777215 ? [(16711680 & h) >> 16, (65280 & h) >> 8, 255 & h, 1] : null;
              var T = y.indexOf("("), k = y.indexOf(")");
              if (T !== -1 && k + 1 === y.length) {
                var g = y.substr(0, T), A = y.substr(T + 1, k - (T + 1)).split(","), D = 1;
                switch (g) {
                  case "rgba":
                    if (A.length !== 4) return null;
                    D = o(A.pop());
                  case "rgb":
                    return A.length !== 3 ? null : [i(A[0]), i(A[1]), i(A[2]), D];
                  case "hsla":
                    if (A.length !== 4) return null;
                    D = o(A.pop());
                  case "hsl":
                    if (A.length !== 3) return null;
                    var S = (parseFloat(A[0]) % 360 + 360) % 360 / 360, R = o(A[1]), j = o(A[2]), J = j <= 0.5 ? j * (R + 1) : j + R - j * R, ne = 2 * j - J;
                    return [e(255 * c(ne, J, S + 1 / 3)), e(255 * c(ne, J, S)), e(255 * c(ne, J, S - 1 / 3)), D];
                  default:
                    return null;
                }
              }
              return null;
            };
          } catch {
          }
          return Pc;
        }();
        class Xi {
          constructor(e, i, o, c = 1) {
            this.r = e, this.g = i, this.b = o, this.a = c;
          }
          static parse(e) {
            if (!e) return;
            if (e instanceof Xi) return e;
            if (typeof e != "string") return;
            const i = Xa.parseCSSColor(e);
            return i ? new Xi(i[0] / 255 * i[3], i[1] / 255 * i[3], i[2] / 255 * i[3], i[3]) : void 0;
          }
          toStringPremultipliedAlpha() {
            const [e, i, o, c] = this.a === 0 ? [0, 0, 0, 0] : [255 * this.r / this.a, 255 * this.g / this.a, 255 * this.b / this.a, this.a];
            return `rgba(${Math.round(e)},${Math.round(i)},${Math.round(o)},${c})`;
          }
          toString() {
            const [e, i, o, c] = [this.r, this.g, this.b, this.a];
            return `rgba(${Math.round(255 * e)},${Math.round(255 * i)},${Math.round(255 * o)},${c})`;
          }
          toRenderColor(e) {
            const { r: i, g: o, b: c, a: s } = this;
            return new qo(e, i, o, c, s);
          }
          clone() {
            return new Xi(this.r, this.g, this.b, this.a);
          }
        }
        class qo {
          constructor(e, i, o, c, s) {
            if (e) {
              const h = e.image.height, y = h * h;
              i = s === 0 ? 0 : i / s * (h - 1), o = s === 0 ? 0 : o / s * (h - 1), c = s === 0 ? 0 : c / s * (h - 1);
              const T = Math.floor(i), k = Math.floor(o), g = Math.floor(c), A = Math.ceil(i), D = Math.ceil(o), S = Math.ceil(c), R = i - T, j = o - k, J = c - g, ne = e.image.data, me = 4 * (T + k * y + g * h), ge = 4 * (T + k * y + S * h), ue = 4 * (T + D * y + g * h), Se = 4 * (T + D * y + S * h), ke = 4 * (A + k * y + g * h), He = 4 * (A + k * y + S * h), at = 4 * (A + D * y + g * h), nt = 4 * (A + D * y + S * h);
              if (me < 0 || nt >= ne.length) throw new Error("out of range");
              this.r = li(li(li(ne[me], ne[ge], J), li(ne[ue], ne[Se], J), j), li(li(ne[ke], ne[He], J), li(ne[at], ne[nt], J), j), R) / 255 * s, this.g = li(li(li(ne[me + 1], ne[ge + 1], J), li(ne[ue + 1], ne[Se + 1], J), j), li(li(ne[ke + 1], ne[He + 1], J), li(ne[at + 1], ne[nt + 1], J), j), R) / 255 * s, this.b = li(li(li(ne[me + 2], ne[ge + 2], J), li(ne[ue + 2], ne[Se + 2], J), j), li(li(ne[ke + 2], ne[He + 2], J), li(ne[at + 2], ne[nt + 2], J), j), R) / 255 * s, this.a = s;
            } else this.r = i, this.g = o, this.b = c, this.a = s;
          }
          toArray() {
            const { r: e, g: i, b: o, a: c } = this;
            return c === 0 ? [0, 0, 0, 0] : [255 * e / c, 255 * i / c, 255 * o / c, c];
          }
          toHslaArray() {
            if (this.a === 0) return [0, 0, 0, 0];
            const { r: e, g: i, b: o, a: c } = this, s = Math.min(Math.max(e / c, 0), 1), h = Math.min(Math.max(i / c, 0), 1), y = Math.min(Math.max(o / c, 0), 1), T = Math.min(s, h, y), k = Math.max(s, h, y), g = (T + k) / 2;
            if (T === k) return [0, 0, 100 * g, c];
            const A = k - T, D = g > 0.5 ? A / (2 - k - T) : A / (k + T);
            let S = 0;
            return k === s ? S = (h - y) / A + (h < y ? 6 : 0) : k === h ? S = (y - s) / A + 2 : k === y && (S = (s - h) / A + 4), S *= 60, [Math.min(Math.max(S, 0), 360), Math.min(Math.max(100 * D, 0), 100), Math.min(Math.max(100 * g, 0), 100), c];
          }
          toArray01() {
            const { r: e, g: i, b: o, a: c } = this;
            return c === 0 ? [0, 0, 0, 0] : [e / c, i / c, o / c, c];
          }
          toArray01Scaled(e) {
            const { r: i, g: o, b: c, a: s } = this;
            return s === 0 ? [0, 0, 0] : [i / s * e, o / s * e, c / s * e];
          }
          toArray01PremultipliedAlpha() {
            const { r: e, g: i, b: o, a: c } = this;
            return [e, i, o, c];
          }
          toArray01Linear() {
            const { r: e, g: i, b: o, a: c } = this;
            return c === 0 ? [0, 0, 0, 0] : [Math.pow(e / c, 2.2), Math.pow(i / c, 2.2), Math.pow(o / c, 2.2), c];
          }
        }
        function li(a, e, i) {
          return a * (1 - i) + e * i;
        }
        function ps(a, e, i) {
          return a.map((o, c) => li(o, e[c], i));
        }
        Xi.black = new Xi(0, 0, 0, 1), Xi.white = new Xi(1, 1, 1, 1), Xi.transparent = new Xi(0, 0, 0, 0), Xi.red = new Xi(1, 0, 0, 1), Xi.blue = new Xi(0, 0, 1, 1);
        var Ns = Object.freeze({ __proto__: null, array: ps, color: function(a, e, i) {
          return new Xi(li(a.r, e.r, i), li(a.g, e.g, i), li(a.b, e.b, i), li(a.a, e.a, i));
        }, number: li });
        function Us(a, ...e) {
          for (const i of e) for (const o in i) a[o] = i[o];
          return a;
        }
        class Mi extends Error {
          constructor(e, i) {
            super(i), this.message = i, this.key = e;
          }
        }
        class Rc {
          constructor(e, i = []) {
            this.parent = e, this.bindings = {};
            for (const [o, c] of i) this.bindings[o] = c;
          }
          concat(e) {
            return new Rc(this, e);
          }
          get(e) {
            if (this.bindings[e]) return this.bindings[e];
            if (this.parent) return this.parent.get(e);
            throw new Error(`${e} not found in scope.`);
          }
          has(e) {
            return !!this.bindings[e] || !!this.parent && this.parent.has(e);
          }
        }
        const js = { kind: "null" }, Xr = { kind: "number" }, nn = { kind: "string" }, Zi = { kind: "boolean" }, la = { kind: "color" }, $o = { kind: "object" }, Ji = { kind: "value" }, ms = { kind: "collator" }, Ya = { kind: "formatted" }, Xo = { kind: "resolvedImage" };
        function Kn(a, e) {
          return { kind: "array", itemType: a, N: e };
        }
        function zn(a) {
          if (a.kind === "array") {
            const e = zn(a.itemType);
            return typeof a.N == "number" ? `array<${e}, ${a.N}>` : a.itemType.kind === "value" ? "array" : `array<${e}>`;
          }
          return a.kind;
        }
        const Ah = [js, Xr, nn, Zi, la, Ya, $o, Kn(Ji), Xo];
        function Ta(a, e) {
          if (e.kind === "error") return null;
          if (a.kind === "array") {
            if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !Ta(a.itemType, e.itemType)) && (typeof a.N != "number" || a.N === e.N)) return null;
          } else {
            if (a.kind === e.kind) return null;
            if (a.kind === "value") {
              for (const i of Ah) if (!Ta(i, e)) return null;
            }
          }
          return `Expected ${zn(a)} but found ${zn(e)} instead.`;
        }
        function gl(a, e) {
          return e.some((i) => i.kind === a.kind);
        }
        function yl(a, e) {
          return e.some((i) => i === "null" ? a === null : i === "array" ? Array.isArray(a) : i === "object" ? a && !Array.isArray(a) && typeof a == "object" : i === typeof a);
        }
        class Hu {
          constructor(e, i, o) {
            this.sensitivity = e ? i ? "variant" : "case" : i ? "accent" : "base", this.locale = o, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(e, i) {
            return this.collator.compare(e, i);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Eo {
          constructor(e, i, o, c, s) {
            this.text = e.normalize ? e.normalize() : e, this.image = i, this.scale = o, this.fontStack = c, this.textColor = s;
          }
        }
        class pa {
          constructor(e) {
            this.sections = e;
          }
          static fromString(e) {
            return new pa([new Eo(e, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.namePrimary);
          }
          static factory(e) {
            return e instanceof pa ? e : pa.fromString(e);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
          }
          serialize() {
            const e = ["format"];
            for (const i of this.sections) {
              if (i.image) {
                e.push(["image", i.image.namePrimary]);
                continue;
              }
              e.push(i.text);
              const o = {};
              i.fontStack && (o["text-font"] = ["literal", i.fontStack.split(",")]), i.scale && (o["font-scale"] = i.scale), i.textColor && (o["text-color"] = ["rgba"].concat(i.textColor.toRenderColor(null).toArray())), e.push(o);
            }
            return e;
          }
        }
        class ho {
          constructor(e, i) {
            if (this.id = e, this.options = i || { params: {} }, this.options.transform) {
              const { a: o, b: c, c: s, d: h, e: y, f: T } = this.options.transform;
              this.options.transform = new DOMMatrix([o, c, s, h, y, T]);
            } else this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0]);
          }
          static deserializeId(e) {
            return JSON.parse(e).id;
          }
          static deserializeFromString(e) {
            const i = JSON.parse(e), { a: o, b: c, c: s, d: h, e: y, f: T } = i.options.transform;
            return new DOMMatrix([o, c, s, h, y, T]), new ho(i.id, i.options);
          }
          scaleSelf(e) {
            return this.options.transform = this.options.transform.scale(e), this;
          }
          serialize() {
            const e = { id: this.id };
            this.options && (e.options = this.options);
            const { a: i, b: o, c, d: s, e: h, f: y } = this.options.transform;
            return e.options.transform = { a: i, b: o, c, d: s, e: h, f: y }, JSON.stringify(e);
          }
        }
        class ma {
          constructor(e) {
            this.namePrimary = e.namePrimary, e.nameSecondary && (this.nameSecondary = e.nameSecondary), e.optionsPrimary && (this.optionsPrimary = e.optionsPrimary), e.optionsSecondary && (this.optionsSecondary = e.optionsSecondary), this.available = e.available;
          }
          toString() {
            return this.namePrimary && this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
          }
          getPrimary() {
            return new ho(this.namePrimary, { params: this.optionsPrimary && this.optionsPrimary.params || {} });
          }
          getSerializedPrimary() {
            return this.getPrimary().serialize();
          }
          getSecondary() {
            return this.nameSecondary ? new ho(this.nameSecondary, { params: this.optionsSecondary && this.optionsSecondary.params || {} }) : null;
          }
          static from(e) {
            return typeof e == "string" ? ma.build(e) : e;
          }
          static build(e, i, o, c) {
            return e ? new ma({ namePrimary: e, nameSecondary: i, optionsPrimary: o, optionsSecondary: c, available: !1 }) : null;
          }
        }
        function su(a, e, i, o) {
          return typeof a == "number" && a >= 0 && a <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof i == "number" && i >= 0 && i <= 255 ? o === void 0 || typeof o == "number" && o >= 0 && o <= 1 ? null : `Invalid rgba value [${[a, e, i, o].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof o == "number" ? [a, e, i, o] : [a, e, i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function So(a) {
          if (a === null || typeof a == "string" || typeof a == "boolean" || typeof a == "number" || a instanceof Xi || a instanceof Hu || a instanceof pa || a instanceof ma) return !0;
          if (Array.isArray(a)) {
            for (const e of a) if (!So(e)) return !1;
            return !0;
          }
          if (typeof a == "object") {
            for (const e in a) if (!So(a[e])) return !1;
            return !0;
          }
          return !1;
        }
        function An(a) {
          if (a === null) return js;
          if (typeof a == "string") return nn;
          if (typeof a == "boolean") return Zi;
          if (typeof a == "number") return Xr;
          if (a instanceof Xi) return la;
          if (a instanceof Hu) return ms;
          if (a instanceof pa) return Ya;
          if (a instanceof ma) return Xo;
          if (Array.isArray(a)) {
            const e = a.length;
            let i;
            for (const o of a) {
              const c = An(o);
              if (i) {
                if (i === c) continue;
                i = Ji;
                break;
              }
              i = c;
            }
            return Kn(i || Ji, e);
          }
          return $o;
        }
        function Hn(a) {
          const e = typeof a;
          return a === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(a) : a instanceof Xi ? a.toStringPremultipliedAlpha() : a instanceof pa || a instanceof ma ? a.toString() : JSON.stringify(a);
        }
        class Wn {
          constructor(e, i) {
            this.type = e, this.value = i;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (!So(e[1])) return i.error("invalid value");
            const o = e[1];
            let c = An(o);
            const s = i.expectedType;
            return c.kind !== "array" || c.N !== 0 || !s || s.kind !== "array" || typeof s.N == "number" && s.N !== 0 || (c = s), new Wn(c, o);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof Xi ? ["rgba"].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof pa ? this.value.serialize() : this.value;
          }
        }
        class On {
          constructor(e) {
            this.name = "ExpressionEvaluationError", this.message = e;
          }
          toJSON() {
            return this.message;
          }
        }
        const _s = { string: nn, number: Xr, boolean: Zi, object: $o };
        class zo {
          constructor(e, i) {
            this.type = e, this.args = i;
          }
          static parse(e, i) {
            if (e.length < 2) return i.error("Expected at least one argument.");
            let o, c = 1;
            const s = e[0];
            if (s === "array") {
              let y, T;
              if (e.length > 2) {
                const k = e[1];
                if (typeof k != "string" || !(k in _s) || k === "object") return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
                y = _s[k], c++;
              } else y = Ji;
              if (e.length > 3) {
                if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return i.error('The length argument to "array" must be a positive integer literal', 2);
                T = e[2], c++;
              }
              o = Kn(y, T);
            } else o = _s[s];
            const h = [];
            for (; c < e.length; c++) {
              const y = i.parse(e[c], c, Ji);
              if (!y) return null;
              h.push(y);
            }
            return new zo(o, h);
          }
          evaluate(e) {
            for (let i = 0; i < this.args.length; i++) {
              const o = this.args[i].evaluate(e);
              if (!Ta(this.type, An(o))) return o;
              if (i === this.args.length - 1) throw new On(`The expression ${JSON.stringify(this.args[i].serialize())} evaluated to ${zn(An(o))} but was expected to be of type ${zn(this.type)}.`);
            }
            return null;
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every((e) => e.outputDefined());
          }
          serialize() {
            const e = this.type, i = [e.kind];
            if (e.kind === "array") {
              const o = e.itemType;
              if (o.kind === "string" || o.kind === "number" || o.kind === "boolean") {
                i.push(o.kind);
                const c = e.N;
                (typeof c == "number" || this.args.length > 1) && i.push(c);
              }
            }
            return i.concat(this.args.map((o) => o.serialize()));
          }
        }
        class gs {
          constructor(e) {
            this.type = Ya, this.sections = e;
          }
          static parse(e, i) {
            if (e.length < 2) return i.error("Expected at least one argument.");
            const o = e[1];
            if (!Array.isArray(o) && typeof o == "object") return i.error("First argument must be an image or text section.");
            const c = [];
            let s = !1;
            for (let h = 1; h <= e.length - 1; ++h) {
              const y = e[h];
              if (s && typeof y == "object" && !Array.isArray(y)) {
                s = !1;
                let T = null;
                if (y["font-scale"] && (T = i.parseObjectValue(y["font-scale"], h, "font-scale", Xr), !T)) return null;
                let k = null;
                if (y["text-font"] && (k = i.parseObjectValue(y["text-font"], h, "text-font", Kn(nn)), !k)) return null;
                let g = null;
                if (y["text-color"] && (g = i.parseObjectValue(y["text-color"], h, "text-color", la), !g)) return null;
                const A = c[c.length - 1];
                A.scale = T, A.font = k, A.textColor = g;
              } else {
                const T = i.parse(e[h], h, Ji);
                if (!T) return null;
                const k = T.type.kind;
                if (k !== "string" && k !== "value" && k !== "null" && k !== "resolvedImage") return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                s = !0, c.push({ content: T, scale: null, font: null, textColor: null });
              }
            }
            return new gs(c);
          }
          evaluate(e) {
            return new pa(this.sections.map((i) => {
              const o = i.content.evaluate(e);
              return An(o) === Xo ? new Eo("", o, null, null, null) : new Eo(Hn(o), null, i.scale ? i.scale.evaluate(e) : null, i.font ? i.font.evaluate(e).join(",") : null, i.textColor ? i.textColor.evaluate(e) : null);
            }));
          }
          eachChild(e) {
            for (const i of this.sections) e(i.content), i.scale && e(i.scale), i.font && e(i.font), i.textColor && e(i.textColor);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            const e = ["format"];
            for (const i of this.sections) {
              e.push(i.content.serialize());
              const o = {};
              i.scale && (o["font-scale"] = i.scale.serialize()), i.font && (o["text-font"] = i.font.serialize()), i.textColor && (o["text-color"] = i.textColor.serialize()), e.push(o);
            }
            return e;
          }
        }
        class vl {
          constructor(e, i, o, c) {
            this._imageWarnHistory = {}, this.type = Xo, this.inputPrimary = e, this.inputSecondary = i, this.inputPrimaryParams = o, this.inputSecondaryParams = c;
          }
          static parse(e, i) {
            if (e.length < 2) return i.error("Expected two or more arguments.");
            let o = 1;
            const c = [];
            function s() {
              if (o < e.length) {
                const y = i.parse(e[o], o++, nn);
                return y ? (c.push({ image: y, options: void 0 }), !0) : (i.error(c.length ? "Secondary image variant is not a string." : "No image name provided."), !1);
              }
              return !0;
            }
            function h() {
              if (o < e.length) {
                if ((y = e[o]) === null || typeof y != "object" || Array.isArray(y)) return !0;
                const T = e[o].params, k = i.concat(o);
                if (!T) return o++, !0;
                if (typeof T != "object" || T.constructor !== Object) return k.error('Image options "params" should be an object'), !1;
                const g = {}, A = k.concat(void 0, "params");
                for (const D in T) {
                  if (!D) return A.error("Image parameter name should be non-empty"), !1;
                  const S = A.concat(void 0, D).parse(T[D], void 0, la, void 0, { typeAnnotation: "coerce" });
                  if (!S) return !1;
                  g[D] = S;
                }
                return c[c.length - 1].options = g, o++, !0;
              }
              var y;
              return !0;
            }
            for (let y = 0; y < 2; y++) if (!s() || !h()) return;
            return new vl(c[0].image, c[1] ? c[1].image : void 0, c[0].options, c[1] ? c[1].options : void 0);
          }
          evaluateParams(e, i) {
            const o = {};
            if (i) {
              for (const c in i) if (i[c]) try {
                const s = i[c].evaluate(e), h = `Ignoring image parameter "${c}" with semi-transparent color ${s.toString()}`;
                if (s.a !== 1) {
                  this._imageWarnHistory[h] || (console.warn(h), this._imageWarnHistory[h] = !0);
                  continue;
                }
                o[c] = s;
              } catch {
                continue;
              }
              if (Object.keys(o).length !== 0) return { params: o };
            }
          }
          evaluate(e) {
            const i = ma.build(this.inputPrimary.evaluate(e), this.inputSecondary ? this.inputSecondary.evaluate(e) : void 0, this.inputPrimaryParams ? this.evaluateParams(e, this.inputPrimaryParams) : void 0, this.inputSecondaryParams ? this.evaluateParams(e, this.inputSecondaryParams) : void 0);
            return i && e.availableImages && (i.available = e.availableImages.indexOf(i.namePrimary) > -1, i.nameSecondary && i.available && e.availableImages && (i.available = e.availableImages.indexOf(i.nameSecondary) > -1)), i;
          }
          eachChild(e) {
            if (e(this.inputPrimary), this.inputPrimaryParams) for (const i in this.inputPrimaryParams) this.inputPrimaryParams[i] && e(this.inputPrimaryParams[i]);
            if (this.inputSecondary && (e(this.inputSecondary), this.inputSecondaryParams)) for (const i in this.inputSecondaryParams) this.inputSecondaryParams[i] && e(this.inputSecondaryParams[i]);
          }
          outputDefined() {
            return !1;
          }
          serializeParams(e) {
            const i = {};
            if (e) {
              for (const o in e) e[o] && (i[o] = e[o].serialize());
              return { params: i };
            }
          }
          serialize() {
            const e = ["image", this.inputPrimary.serialize()];
            return this.inputPrimaryParams && e.push(this.serializeParams(this.inputPrimaryParams)), this.inputSecondary && (e.push(this.inputSecondary.serialize()), this.inputSecondaryParams && e.push(this.serializeParams(this.inputSecondaryParams))), e;
          }
        }
        function Ba(a) {
          return a instanceof Number ? "number" : a instanceof String ? "string" : a instanceof Boolean ? "boolean" : Array.isArray(a) ? "array" : a === null ? "null" : typeof a;
        }
        const lu = { "to-boolean": Zi, "to-color": la, "to-number": Xr, "to-string": nn };
        class Yo {
          constructor(e, i) {
            this.type = e, this.args = i;
          }
          static parse(e, i) {
            if (e.length < 2) return i.error("Expected at least one argument.");
            const o = e[0], c = [];
            let s = js;
            if (o === "to-array") {
              if (!Array.isArray(e[1])) return null;
              const h = e[1].length;
              if (i.expectedType) {
                if (i.expectedType.kind !== "array") return i.error(`Expected ${i.expectedType.kind} but found array.`);
                s = Kn(i.expectedType.itemType, h);
              } else {
                if (!(h > 0 && So(e[1][0]))) return null;
                s = Kn(An(e[1][0]), h);
              }
              for (let y = 0; y < h; y++) {
                const T = e[1][y];
                let k;
                if (Ba(T) === "array") k = i.parse(T, void 0, s.itemType);
                else {
                  const g = Ba(T);
                  if (g !== s.itemType.kind) return i.error(`Expected ${s.itemType.kind} but found ${g}.`);
                  k = i.registry.literal.parse(["literal", T === void 0 ? null : T], i);
                }
                if (!k) return null;
                c.push(k);
              }
            } else {
              if ((o === "to-boolean" || o === "to-string") && e.length !== 2) return i.error("Expected one argument.");
              s = lu[o];
              for (let h = 1; h < e.length; h++) {
                const y = i.parse(e[h], h, Ji);
                if (!y) return null;
                c.push(y);
              }
            }
            return new Yo(s, c);
          }
          evaluate(e) {
            if (this.type.kind === "boolean") return !!this.args[0].evaluate(e);
            if (this.type.kind === "color") {
              let i, o;
              for (const c of this.args) {
                if (i = c.evaluate(e), o = null, i instanceof Xi) return i;
                if (typeof i == "string") {
                  const s = e.parseColor(i);
                  if (s) return s;
                } else if (Array.isArray(i) && (o = i.length < 3 || i.length > 4 ? `Invalid rbga value ${JSON.stringify(i)}: expected an array containing either three or four numeric values.` : su(i[0], i[1], i[2], i[3]), !o)) return new Xi(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
              }
              throw new On(o || `Could not parse color from value '${typeof i == "string" ? i : String(JSON.stringify(i))}'`);
            }
            if (this.type.kind === "number") {
              let i = null;
              for (const o of this.args) {
                if (i = o.evaluate(e), i === null) return 0;
                const c = Number(i);
                if (!isNaN(c)) return c;
              }
              throw new On(`Could not convert ${JSON.stringify(i)} to number.`);
            }
            return this.type.kind === "formatted" ? pa.fromString(Hn(this.args[0].evaluate(e))) : this.type.kind === "resolvedImage" ? ma.build(Hn(this.args[0].evaluate(e))) : this.type.kind === "array" ? this.args.map((i) => i.evaluate(e)) : Hn(this.args[0].evaluate(e));
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every((e) => e.outputDefined());
          }
          serialize() {
            if (this.type.kind === "formatted") return new gs([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
            if (this.type.kind === "resolvedImage") return new vl(this.args[0]).serialize();
            const e = this.type.kind === "array" ? [] : [`to-${this.type.kind}`];
            return this.eachChild((i) => {
              e.push(i.serialize());
            }), e;
          }
        }
        const ad = ["Unknown", "Point", "LineString", "Polygon"];
        class Ih {
          constructor(e, i) {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = e, this.options = i;
          }
          id() {
            return this.feature && this.feature.id !== void 0 ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? ad[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          measureLight(e) {
            return this.globals.brightness || 0;
          }
          distanceFromCenter() {
            if (this.featureTileCoord && this.featureDistanceData) {
              const e = this.featureDistanceData.center, i = this.featureDistanceData.scale, { x: o, y: c } = this.featureTileCoord;
              return this.featureDistanceData.bearing[0] * (o * i - e[0]) + this.featureDistanceData.bearing[1] * (c * i - e[1]);
            }
            return 0;
          }
          parseColor(e) {
            let i = this._parseColorCache[e];
            return i || (i = this._parseColorCache[e] = Xi.parse(e)), i;
          }
          getConfig(e) {
            return this.options ? this.options.get(e) : null;
          }
        }
        class Fa {
          constructor(e, i, o, c, s) {
            this.name = e, this.type = i, this._evaluate = o, this.args = c, this._overloadIndex = s;
          }
          evaluate(e) {
            if (!this._evaluate) {
              const i = Fa.definitions[this.name];
              this._evaluate = Array.isArray(i) ? i[2] : i.overloads[this._overloadIndex][1];
            }
            return this._evaluate(e, this.args);
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return [this.name].concat(this.args.map((e) => e.serialize()));
          }
          static parse(e, i) {
            const o = e[0], c = Fa.definitions[o];
            if (!c) return i.error(`Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const s = Array.isArray(c) ? c[0] : c.type, h = Array.isArray(c) ? [[c[1], c[2]]] : c.overloads, y = [];
            let T = null, k = -1;
            for (const [g, A] of h) {
              if (Array.isArray(g) && g.length !== e.length - 1) continue;
              y.push(g), k++, T = new pu(i.registry, i.path, null, i.scope, void 0, i._scope, i.options);
              const D = [];
              let S = !1;
              for (let R = 1; R < e.length; R++) {
                const j = e[R], J = Array.isArray(g) ? g[R - 1] : g.type, ne = T.parse(j, 1 + D.length, J);
                if (!ne) {
                  S = !0;
                  break;
                }
                D.push(ne);
              }
              if (!S) if (Array.isArray(g) && g.length !== D.length) T.error(`Expected ${g.length} arguments, but found ${D.length} instead.`);
              else {
                for (let R = 0; R < D.length; R++) {
                  const j = Array.isArray(g) ? g[R] : g.type, J = D[R];
                  T.concat(R + 1).checkSubtype(j, J.type);
                }
                if (T.errors.length === 0) return new Fa(o, s, A, D, k);
              }
            }
            if (y.length === 1) i.errors.push(...T.errors);
            else {
              const g = (y.length ? y : h.map(([D]) => D)).map(Wu).join(" | "), A = [];
              for (let D = 1; D < e.length; D++) {
                const S = i.parse(e[D], 1 + A.length);
                if (!S) return null;
                A.push(zn(S.type));
              }
              i.error(`Expected arguments of type ${g}, but found (${A.join(", ")}) instead.`);
            }
            return null;
          }
          static register(e, i) {
            Fa.definitions = i;
            for (const o in i) e[o] = Fa;
          }
        }
        function Wu(a) {
          return Array.isArray(a) ? `(${a.map(zn).join(", ")})` : `(${zn(a.type)}...)`;
        }
        class Lc {
          constructor(e, i, o) {
            this.type = ms, this.locale = o, this.caseSensitive = e, this.diacriticSensitive = i;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error("Expected one argument.");
            const o = e[1];
            if (typeof o != "object" || Array.isArray(o)) return i.error("Collator options argument must be an object.");
            const c = o["case-sensitive"] === void 0 ? i.parse(!1, 1, Zi) : i.parseObjectValue(o["case-sensitive"], 1, "case-sensitive", Zi);
            if (!c) return null;
            const s = o["diacritic-sensitive"] === void 0 ? i.parse(!1, 1, Zi) : i.parseObjectValue(o["diacritic-sensitive"], 1, "diacritic-sensitive", Zi);
            if (!s) return null;
            let h = null;
            return o.locale && (h = i.parseObjectValue(o.locale, 1, "locale", nn), !h) ? null : new Lc(c, s, h);
          }
          evaluate(e) {
            return new Hu(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
          }
          eachChild(e) {
            e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            const e = {};
            return e["case-sensitive"] = this.caseSensitive.serialize(), e["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e.locale = this.locale.serialize()), ["collator", e];
          }
        }
        function Zu(a, e, i = 0, o = a.length - 1, c = od) {
          for (; o > i; ) {
            if (o - i > 600) {
              const T = o - i + 1, k = e - i + 1, g = Math.log(T), A = 0.5 * Math.exp(2 * g / 3), D = 0.5 * Math.sqrt(g * A * (T - A) / T) * (k - T / 2 < 0 ? -1 : 1);
              Zu(a, e, Math.max(i, Math.floor(e - k * A / T + D)), Math.min(o, Math.floor(e + (T - k) * A / T + D)), c);
            }
            const s = a[e];
            let h = i, y = o;
            for (qu(a, i, e), c(a[o], s) > 0 && qu(a, i, o); h < y; ) {
              for (qu(a, h, y), h++, y--; c(a[h], s) < 0; ) h++;
              for (; c(a[y], s) > 0; ) y--;
            }
            c(a[i], s) === 0 ? qu(a, i, y) : (y++, qu(a, y, o)), y <= e && (i = y + 1), e <= y && (o = y - 1);
          }
        }
        function qu(a, e, i) {
          const o = a[e];
          a[e] = a[i], a[i] = o;
        }
        function od(a, e) {
          return a < e ? -1 : a > e ? 1 : 0;
        }
        function sd(a) {
          let e = 0;
          for (let i, o, c = 0, s = a.length, h = s - 1; c < s; h = c++) i = a[c], o = a[h], e += (o.x - i.x) * (i.y + o.y);
          return e;
        }
        function uu(a, e) {
          a[0] = Math.min(a[0], e[0]), a[1] = Math.min(a[1], e[1]), a[2] = Math.max(a[2], e[0]), a[3] = Math.max(a[3], e[1]);
        }
        function $u(a, e) {
          return !(a[0] <= e[0] || a[2] >= e[2] || a[1] <= e[1] || a[3] >= e[3]);
        }
        function ld(a, e, i) {
          const o = a[0] - e[0], c = a[1] - e[1], s = a[0] - i[0], h = a[1] - i[1];
          return o * h - s * c == 0 && o * s <= 0 && c * h <= 0;
        }
        function cu(a, e, i = !1) {
          let o = !1;
          for (let y = 0, T = e.length; y < T; y++) {
            const k = e[y];
            for (let g = 0, A = k.length, D = A - 1; g < A; D = g++) {
              const S = k[D], R = k[g];
              if (ld(a, S, R)) return i;
              (s = S)[1] > (c = a)[1] != (h = R)[1] > c[1] && c[0] < (h[0] - s[0]) * (c[1] - s[1]) / (h[1] - s[1]) + s[0] && (o = !o);
            }
          }
          var c, s, h;
          return o;
        }
        function Ch(a, e, i, o) {
          const c = o[0] - i[0], s = o[1] - i[1], h = (a[0] - i[0]) * s - c * (a[1] - i[1]), y = (e[0] - i[0]) * s - c * (e[1] - i[1]);
          return h > 0 && y < 0 || h < 0 && y > 0;
        }
        function Oo(a, e, i, o) {
          return (c = [o[0] - i[0], o[1] - i[1]])[0] * (s = [e[0] - a[0], e[1] - a[1]])[1] - c[1] * s[0] != 0 && !(!Ch(a, e, i, o) || !Ch(i, o, a, e));
          var c, s;
        }
        const Vs = 8192;
        function ud(a, e) {
          const i = (180 + a[0]) / 360, o = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a[1] * Math.PI / 360))) / 360, c = Math.pow(2, e.z);
          return [Math.round(i * c * Vs), Math.round(o * c * Vs)];
        }
        function Ph(a, e) {
          for (let i = 0; i < e.length; i++) if (cu(a, e[i])) return !0;
          return !1;
        }
        function _f(a, e, i) {
          for (const o of i) for (let c = 0, s = o.length, h = s - 1; c < s; h = c++) if (Oo(a, e, o[h], o[c])) return !0;
          return !1;
        }
        function gf(a, e) {
          for (let i = 0; i < a.length; ++i) if (!cu(a[i], e)) return !1;
          for (let i = 0; i < a.length - 1; ++i) if (_f(a[i], a[i + 1], e)) return !1;
          return !0;
        }
        function cd(a, e) {
          for (let i = 0; i < e.length; i++) if (gf(a, e[i])) return !0;
          return !1;
        }
        function Rh(a, e, i) {
          const o = [];
          for (let c = 0; c < a.length; c++) {
            const s = [];
            for (let h = 0; h < a[c].length; h++) {
              const y = ud(a[c][h], i);
              uu(e, y), s.push(y);
            }
            o.push(s);
          }
          return o;
        }
        function xl(a, e, i) {
          const o = [];
          for (let c = 0; c < a.length; c++) {
            const s = Rh(a[c], e, i);
            o.push(s);
          }
          return o;
        }
        function zi(a, e, i, o) {
          if (a[0] < i[0] || a[0] > i[2]) {
            const c = 0.5 * o;
            let s = a[0] - i[0] > c ? -o : i[0] - a[0] > c ? o : 0;
            s === 0 && (s = a[0] - i[2] > c ? -o : i[2] - a[0] > c ? o : 0), a[0] += s;
          }
          uu(e, a);
        }
        function ui(a, e, i, o) {
          const c = Math.pow(2, o.z) * Vs, s = [o.x * Vs, o.y * Vs], h = [];
          if (!a) return h;
          for (const y of a) for (const T of y) {
            const k = [T.x + s[0], T.y + s[1]];
            zi(k, e, i, c), h.push(k);
          }
          return h;
        }
        function Dc(a, e, i, o) {
          const c = Math.pow(2, o.z) * Vs, s = [o.x * Vs, o.y * Vs], h = [];
          if (!a) return h;
          for (const T of a) {
            const k = [];
            for (const g of T) {
              const A = [g.x + s[0], g.y + s[1]];
              uu(e, A), k.push(A);
            }
            h.push(k);
          }
          if (e[2] - e[0] <= c / 2) {
            (y = e)[0] = y[1] = 1 / 0, y[2] = y[3] = -1 / 0;
            for (const T of h) for (const k of T) zi(k, e, i, c);
          }
          var y;
          return h;
        }
        class _i {
          constructor(e, i) {
            this.type = Zi, this.geojson = e, this.geometries = i;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (So(e[1])) {
              const o = e[1];
              if (o.type === "FeatureCollection") for (let c = 0; c < o.features.length; ++c) {
                const s = o.features[c].geometry.type;
                if (s === "Polygon" || s === "MultiPolygon") return new _i(o, o.features[c].geometry);
              }
              else if (o.type === "Feature") {
                const c = o.geometry.type;
                if (c === "Polygon" || c === "MultiPolygon") return new _i(o, o.geometry);
              } else if (o.type === "Polygon" || o.type === "MultiPolygon") return new _i(o, o);
            }
            return i.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(e) {
            if (e.geometry() != null && e.canonicalID() != null) {
              if (e.geometryType() === "Point") return function(i, o) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0], s = [1 / 0, 1 / 0, -1 / 0, -1 / 0], h = i.canonicalID();
                if (!h) return !1;
                if (o.type === "Polygon") {
                  const y = Rh(o.coordinates, s, h), T = ui(i.geometry(), c, s, h);
                  if (!$u(c, s)) return !1;
                  for (const k of T) if (!cu(k, y)) return !1;
                }
                if (o.type === "MultiPolygon") {
                  const y = xl(o.coordinates, s, h), T = ui(i.geometry(), c, s, h);
                  if (!$u(c, s)) return !1;
                  for (const k of T) if (!Ph(k, y)) return !1;
                }
                return !0;
              }(e, this.geometries);
              if (e.geometryType() === "LineString") return function(i, o) {
                const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0], s = [1 / 0, 1 / 0, -1 / 0, -1 / 0], h = i.canonicalID();
                if (!h) return !1;
                if (o.type === "Polygon") {
                  const y = Rh(o.coordinates, s, h), T = Dc(i.geometry(), c, s, h);
                  if (!$u(c, s)) return !1;
                  for (const k of T) if (!gf(k, y)) return !1;
                }
                if (o.type === "MultiPolygon") {
                  const y = xl(o.coordinates, s, h), T = Dc(i.geometry(), c, s, h);
                  if (!$u(c, s)) return !1;
                  for (const k of T) if (!cd(k, y)) return !1;
                }
                return !0;
              }(e, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            return ["within", this.geojson];
          }
        }
        const Ko = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, kc = 1 / 298.257223563, vi = kc * (2 - kc), bl = Math.PI / 180;
        class Gs {
          static fromTile(e, i, o) {
            const c = Math.PI * (1 - 2 * (e + 0.5) / Math.pow(2, i)), s = Math.atan(0.5 * (Math.exp(c) - Math.exp(-c))) / bl;
            return new Gs(s, o);
          }
          static get units() {
            return Ko;
          }
          constructor(e, i) {
            if (e === void 0) throw new Error("No latitude given.");
            if (i && !Ko[i]) throw new Error(`Unknown unit ${i}. Use one of: ${Object.keys(Ko).join(", ")}`);
            const o = 6378.137 * bl * (i ? Ko[i] : 1), c = Math.cos(e * bl), s = 1 / (1 - vi * (1 - c * c)), h = Math.sqrt(s);
            this.kx = o * h * c, this.ky = o * h * s * (1 - vi);
          }
          distance(e, i) {
            const o = ua(e[0] - i[0]) * this.kx, c = (e[1] - i[1]) * this.ky;
            return Math.sqrt(o * o + c * c);
          }
          bearing(e, i) {
            const o = ua(i[0] - e[0]) * this.kx;
            return Math.atan2(o, (i[1] - e[1]) * this.ky) / bl;
          }
          destination(e, i, o) {
            const c = o * bl;
            return this.offset(e, Math.sin(c) * i, Math.cos(c) * i);
          }
          offset(e, i, o) {
            return [e[0] + i / this.kx, e[1] + o / this.ky];
          }
          lineDistance(e) {
            let i = 0;
            for (let o = 0; o < e.length - 1; o++) i += this.distance(e[o], e[o + 1]);
            return i;
          }
          area(e) {
            let i = 0;
            for (let o = 0; o < e.length; o++) {
              const c = e[o];
              for (let s = 0, h = c.length, y = h - 1; s < h; y = s++) i += ua(c[s][0] - c[y][0]) * (c[s][1] + c[y][1]) * (o ? -1 : 1);
            }
            return Math.abs(i) / 2 * this.kx * this.ky;
          }
          along(e, i) {
            let o = 0;
            if (i <= 0) return e[0];
            for (let c = 0; c < e.length - 1; c++) {
              const s = e[c], h = e[c + 1], y = this.distance(s, h);
              if (o += y, o > i) return Xu(s, h, (i - (o - y)) / y);
            }
            return e[e.length - 1];
          }
          pointToSegmentDistance(e, i, o) {
            let [c, s] = i, h = ua(o[0] - c) * this.kx, y = (o[1] - s) * this.ky;
            if (h !== 0 || y !== 0) {
              const T = (ua(e[0] - c) * this.kx * h + (e[1] - s) * this.ky * y) / (h * h + y * y);
              T > 1 ? (c = o[0], s = o[1]) : T > 0 && (c += h / this.kx * T, s += y / this.ky * T);
            }
            return h = ua(e[0] - c) * this.kx, y = (e[1] - s) * this.ky, Math.sqrt(h * h + y * y);
          }
          pointOnLine(e, i) {
            let o = 1 / 0, c = e[0][0], s = e[0][1], h = 0, y = 0;
            for (let T = 0; T < e.length - 1; T++) {
              let k = e[T][0], g = e[T][1], A = ua(e[T + 1][0] - k) * this.kx, D = (e[T + 1][1] - g) * this.ky, S = 0;
              A === 0 && D === 0 || (S = (ua(i[0] - k) * this.kx * A + (i[1] - g) * this.ky * D) / (A * A + D * D), S > 1 ? (k = e[T + 1][0], g = e[T + 1][1]) : S > 0 && (k += A / this.kx * S, g += D / this.ky * S)), A = ua(i[0] - k) * this.kx, D = (i[1] - g) * this.ky;
              const R = A * A + D * D;
              R < o && (o = R, c = k, s = g, h = T, y = S);
            }
            return { point: [c, s], index: h, t: Math.max(0, Math.min(1, y)) };
          }
          lineSlice(e, i, o) {
            let c = this.pointOnLine(o, e), s = this.pointOnLine(o, i);
            if (c.index > s.index || c.index === s.index && c.t > s.t) {
              const k = c;
              c = s, s = k;
            }
            const h = [c.point], y = c.index + 1, T = s.index;
            !zc(o[y], h[0]) && y <= T && h.push(o[y]);
            for (let k = y + 1; k <= T; k++) h.push(o[k]);
            return zc(o[T], s.point) || h.push(s.point), h;
          }
          lineSliceAlong(e, i, o) {
            let c = 0;
            const s = [];
            for (let h = 0; h < o.length - 1; h++) {
              const y = o[h], T = o[h + 1], k = this.distance(y, T);
              if (c += k, c > e && s.length === 0 && s.push(Xu(y, T, (e - (c - k)) / k)), c >= i) return s.push(Xu(y, T, (i - (c - k)) / k)), s;
              c > e && s.push(T);
            }
            return s;
          }
          bufferPoint(e, i) {
            const o = i / this.ky, c = i / this.kx;
            return [e[0] - c, e[1] - o, e[0] + c, e[1] + o];
          }
          bufferBBox(e, i) {
            const o = i / this.ky, c = i / this.kx;
            return [e[0] - c, e[1] - o, e[2] + c, e[3] + o];
          }
          insideBBox(e, i) {
            return ua(e[0] - i[0]) >= 0 && ua(e[0] - i[2]) <= 0 && e[1] >= i[1] && e[1] <= i[3];
          }
        }
        function zc(a, e) {
          return a[0] === e[0] && a[1] === e[1];
        }
        function Xu(a, e, i) {
          const o = ua(e[0] - a[0]);
          return [a[0] + o * i, a[1] + (e[1] - a[1]) * i];
        }
        function ua(a) {
          for (; a < -180; ) a += 360;
          for (; a > 180; ) a -= 360;
          return a;
        }
        class xa {
          constructor(e = [], i = (o, c) => o < c ? -1 : o > c ? 1 : 0) {
            if (this.data = e, this.length = this.data.length, this.compare = i, this.length > 0) for (let o = (this.length >> 1) - 1; o >= 0; o--) this._down(o);
          }
          push(e) {
            this.data.push(e), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const e = this.data[0], i = this.data.pop();
            return --this.length > 0 && (this.data[0] = i, this._down(0)), e;
          }
          peek() {
            return this.data[0];
          }
          _up(e) {
            const { data: i, compare: o } = this, c = i[e];
            for (; e > 0; ) {
              const s = e - 1 >> 1, h = i[s];
              if (o(c, h) >= 0) break;
              i[e] = h, e = s;
            }
            i[e] = c;
          }
          _down(e) {
            const { data: i, compare: o } = this, c = this.length >> 1, s = i[e];
            for (; e < c; ) {
              let h = 1 + (e << 1);
              const y = h + 1;
              if (y < this.length && o(i[y], i[h]) < 0 && (h = y), o(i[h], s) >= 0) break;
              i[e] = i[h], e = h;
            }
            i[e] = s;
          }
        }
        var Br = 8192;
        function Lh(a, e) {
          return e.dist - a.dist;
        }
        const Yu = 100, hu = 50;
        function To(a) {
          const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          if (e.length !== a.length) return !1;
          for (let i = 0; i < e.length; i++) if (e[i] !== a[i]) return !1;
          return !0;
        }
        function qn(a) {
          return a[1] - a[0] + 1;
        }
        function ys(a, e) {
          const i = a[1] >= a[0] && a[1] < e;
          return i || console.warn("Distance Expression: Index is out of range"), i;
        }
        function fu(a, e) {
          if (a[0] > a[1]) return [null, null];
          const i = qn(a);
          if (e) {
            if (i === 2) return [a, null];
            const o = Math.floor(i / 2);
            return [[a[0], a[0] + o], [a[0] + o, a[1]]];
          }
          {
            if (i === 1) return [a, null];
            const o = Math.floor(i / 2) - 1;
            return [[a[0], a[0] + o], [a[0] + o + 1, a[1]]];
          }
        }
        function wl(a, e) {
          const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          if (!ys(e, a.length)) return i;
          for (let o = e[0]; o <= e[1]; ++o) uu(i, a[o]);
          return i;
        }
        function Hs(a) {
          const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let i = 0; i < a.length; ++i) for (let o = 0; o < a[i].length; ++o) uu(e, a[i][o]);
          return e;
        }
        function vs(a, e, i) {
          if (To(a) || To(e)) return NaN;
          let o = 0, c = 0;
          return a[2] < e[0] && (o = e[0] - a[2]), a[0] > e[2] && (o = a[0] - e[2]), a[1] > e[3] && (c = a[1] - e[3]), a[3] < e[1] && (c = e[1] - a[3]), i.distance([0, 0], [o, c]);
        }
        function Ku(a) {
          return 360 * a - 180;
        }
        function yf(a) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90;
        }
        function Oc(a, e) {
          const i = Math.pow(2, e.z), o = (a.y / Br + e.y) / i;
          return [Ku((a.x / Br + e.x) / i), yf(o)];
        }
        function vf(a, e) {
          const i = [];
          for (let o = 0; o < a.length; ++o) i.push(Oc(a[o], e));
          return i;
        }
        function xf(a, e, i) {
          const o = i.pointOnLine(e, a).point;
          return i.distance(a, o);
        }
        function Dh(a, e, i, o, c) {
          const s = i.slice(o[0], o[1] + 1);
          let h = 1 / 0;
          for (let y = e[0]; y <= e[1]; ++y) if ((h = Math.min(h, xf(a[y], s, c))) === 0) return 0;
          return h;
        }
        function kh(a, e, i, o, c) {
          const s = Math.min(c.pointToSegmentDistance(a, i, o), c.pointToSegmentDistance(e, i, o)), h = Math.min(c.pointToSegmentDistance(i, a, e), c.pointToSegmentDistance(o, a, e));
          return Math.min(s, h);
        }
        function hd(a, e, i, o, c) {
          if (!ys(e, a.length) || !ys(o, i.length)) return NaN;
          let s = 1 / 0;
          for (let h = e[0]; h < e[1]; ++h) for (let y = o[0]; y < o[1]; ++y) {
            if (Oo(a[h], a[h + 1], i[y], i[y + 1])) return 0;
            s = Math.min(s, kh(a[h], a[h + 1], i[y], i[y + 1], c));
          }
          return s;
        }
        function bf(a, e, i, o, c) {
          if (!ys(e, a.length) || !ys(o, i.length)) return NaN;
          let s = 1 / 0;
          for (let h = e[0]; h <= e[1]; ++h) for (let y = o[0]; y <= o[1]; ++y) if ((s = Math.min(s, c.distance(a[h], i[y]))) === 0) return s;
          return s;
        }
        function Ma(a, e, i) {
          if (cu(a, e, !0)) return 0;
          let o = 1 / 0;
          for (const c of e) {
            const s = c.length;
            if (s < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
            if (c[0] !== c[s - 1] && (o = Math.min(o, i.pointToSegmentDistance(a, c[s - 1], c[0]))) === 0 || (o = Math.min(o, xf(a, c, i))) === 0) return o;
          }
          return o;
        }
        function Ju(a, e, i, o) {
          if (!ys(e, a.length)) return NaN;
          for (let s = e[0]; s <= e[1]; ++s) if (cu(a[s], i, !0)) return 0;
          let c = 1 / 0;
          for (let s = e[0]; s < e[1]; ++s) for (const h of i) for (let y = 0, T = h.length, k = T - 1; y < T; k = y++) {
            if (Oo(a[s], a[s + 1], h[k], h[y])) return 0;
            c = Math.min(c, kh(a[s], a[s + 1], h[k], h[y], o));
          }
          return c;
        }
        function zh(a, e) {
          for (const i of a) for (let o = 0; o <= i.length - 1; ++o) if (cu(i[o], e, !0)) return !0;
          return !1;
        }
        function Bc(a, e, i, o = 1 / 0) {
          const c = Hs(a), s = Hs(e);
          if (o !== 1 / 0 && vs(c, s, i) >= o) return o;
          if ($u(c, s)) {
            if (zh(a, e)) return 0;
          } else if (zh(e, a)) return 0;
          let h = o;
          for (const y of a) for (let T = 0, k = y.length, g = k - 1; T < k; g = T++) for (const A of e) for (let D = 0, S = A.length, R = S - 1; D < S; R = D++) {
            if (Oo(y[g], y[T], A[R], A[D])) return 0;
            h = Math.min(h, kh(y[g], y[T], A[R], A[D], i));
          }
          return h;
        }
        function du(a, e, i, o, c, s, h) {
          if (s === null || h === null) return;
          const y = vs(wl(o, s), wl(c, h), i);
          y < e && a.push({ dist: y, range1: s, range2: h });
        }
        function Oh(a, e, i, o, c = 1 / 0) {
          let s = Math.min(o.distance(a[0], i[0][0]), c);
          if (s === 0) return s;
          const h = new xa([{ dist: 0, range1: [0, a.length - 1], range2: [0, 0] }], Lh), y = e ? hu : Yu, T = Hs(i);
          for (; h.length; ) {
            const k = h.pop();
            if (k.dist >= s) continue;
            const g = k.range1;
            if (qn(g) <= y) {
              if (!ys(g, a.length)) return NaN;
              if (e) {
                const A = Ju(a, g, i, o);
                if ((s = Math.min(s, A)) === 0) return s;
              } else for (let A = g[0]; A <= g[1]; ++A) {
                const D = Ma(a[A], i, o);
                if ((s = Math.min(s, D)) === 0) return s;
              }
            } else {
              const A = fu(g, e);
              if (A[0] !== null) {
                const D = vs(wl(a, A[0]), T, o);
                D < s && h.push({ dist: D, range1: A[0], range2: [0, 0] });
              }
              if (A[1] !== null) {
                const D = vs(wl(a, A[1]), T, o);
                D < s && h.push({ dist: D, range1: A[1], range2: [0, 0] });
              }
            }
          }
          return s;
        }
        function Ka(a, e, i, o, c, s = 1 / 0) {
          let h = Math.min(s, c.distance(a[0], i[0]));
          if (h === 0) return h;
          const y = new xa([{ dist: 0, range1: [0, a.length - 1], range2: [0, i.length - 1] }], Lh), T = e ? hu : Yu, k = o ? hu : Yu;
          for (; y.length; ) {
            const g = y.pop();
            if (g.dist >= h) continue;
            const A = g.range1, D = g.range2;
            if (qn(A) <= T && qn(D) <= k) {
              if (!ys(A, a.length) || !ys(D, i.length)) return NaN;
              if (e && o ? h = Math.min(h, hd(a, A, i, D, c)) : e || o ? e && !o ? h = Math.min(h, Dh(i, D, a, A, c)) : !e && o && (h = Math.min(h, Dh(a, A, i, D, c))) : h = Math.min(h, bf(a, A, i, D, c)), h === 0) return h;
            } else {
              const S = fu(A, e), R = fu(D, o);
              du(y, h, c, a, i, S[0], R[0]), du(y, h, c, a, i, S[0], R[1]), du(y, h, c, a, i, S[1], R[0]), du(y, h, c, a, i, S[1], R[1]);
            }
          }
          return h;
        }
        function Fc(a, e, i, o, c = 1 / 0) {
          let s = c;
          const h = wl(a, [0, a.length - 1]);
          for (const y of i) if (!(s !== 1 / 0 && vs(h, wl(y, [0, y.length - 1]), o) >= s) && (s = Math.min(s, Ka(a, e, y, !0, o, s)), s === 0)) return s;
          return s;
        }
        function Qu(a, e, i, o, c = 1 / 0) {
          let s = c;
          const h = wl(a, [0, a.length - 1]);
          for (const y of i) {
            if (s !== 1 / 0 && vs(h, Hs(y), o) >= s) continue;
            const T = Oh(a, e, y, o, s);
            if (isNaN(T)) return T;
            if ((s = Math.min(s, T)) === 0) return s;
          }
          return s;
        }
        function xs(a) {
          return a === "Point" || a === "MultiPoint" || a === "LineString" || a === "MultiLineString" || a === "Polygon" || a === "MultiPolygon";
        }
        class Jo {
          constructor(e, i) {
            this.type = Xr, this.geojson = e, this.geometries = i;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error(`'distance' expression requires either one argument, but found ' ${e.length - 1} instead.`);
            if (So(e[1])) {
              const o = e[1];
              if (o.type === "FeatureCollection") {
                for (let c = 0; c < o.features.length; ++c) if (xs(o.features[c].geometry.type)) return new Jo(o, o.features[c].geometry);
              } else if (o.type === "Feature") {
                if (xs(o.geometry.type)) return new Jo(o, o.geometry);
              } else if (xs(o.type)) return new Jo(o, o);
            }
            return i.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
          }
          evaluate(e) {
            const i = e.geometry(), o = e.canonicalID();
            if (i != null && o != null) {
              if (e.geometryType() === "Point") return function(c, s, h) {
                const y = [];
                for (const k of c) for (const g of k) y.push(Oc(g, s));
                const T = new Gs(y[0][1], "meters");
                return h.type === "Point" || h.type === "MultiPoint" || h.type === "LineString" ? Ka(y, !1, h.type === "Point" ? [h.coordinates] : h.coordinates, h.type === "LineString", T) : h.type === "MultiLineString" ? Fc(y, !1, h.coordinates, T) : h.type === "Polygon" || h.type === "MultiPolygon" ? Qu(y, !1, h.type === "Polygon" ? [h.coordinates] : h.coordinates, T) : null;
              }(i, o, this.geometries);
              if (e.geometryType() === "LineString") return function(c, s, h) {
                const y = [];
                for (const k of c) {
                  const g = [];
                  for (const A of k) g.push(Oc(A, s));
                  y.push(g);
                }
                const T = new Gs(y[0][0][1], "meters");
                if (h.type === "Point" || h.type === "MultiPoint" || h.type === "LineString") return Fc(h.type === "Point" ? [h.coordinates] : h.coordinates, h.type === "LineString", y, T);
                if (h.type === "MultiLineString") {
                  let k = 1 / 0;
                  for (let g = 0; g < h.coordinates.length; g++) {
                    const A = Fc(h.coordinates[g], !0, y, T, k);
                    if (isNaN(A)) return A;
                    if ((k = Math.min(k, A)) === 0) return k;
                  }
                  return k;
                }
                if (h.type === "Polygon" || h.type === "MultiPolygon") {
                  let k = 1 / 0;
                  for (let g = 0; g < y.length; g++) {
                    const A = Qu(y[g], !0, h.type === "Polygon" ? [h.coordinates] : h.coordinates, T, k);
                    if (isNaN(A)) return A;
                    if ((k = Math.min(k, A)) === 0) return k;
                  }
                  return k;
                }
                return null;
              }(i, o, this.geometries);
              if (e.geometryType() === "Polygon") return function(c, s, h) {
                const y = [];
                for (const k of function(g, A) {
                  const D = g.length;
                  if (D <= 1) return [g];
                  const S = [];
                  let R, j;
                  for (let J = 0; J < D; J++) {
                    const ne = sd(g[J]);
                    ne !== 0 && (g[J].area = Math.abs(ne), j === void 0 && (j = ne < 0), j === ne < 0 ? (R && S.push(R), R = [g[J]]) : R.push(g[J]));
                  }
                  return R && S.push(R), S;
                }(c)) {
                  const g = [];
                  for (let A = 0; A < k.length; ++A) g.push(vf(k[A], s));
                  y.push(g);
                }
                const T = new Gs(y[0][0][0][1], "meters");
                if (h.type === "Point" || h.type === "MultiPoint" || h.type === "LineString") return Qu(h.type === "Point" ? [h.coordinates] : h.coordinates, h.type === "LineString", y, T);
                if (h.type === "MultiLineString") {
                  let k = 1 / 0;
                  for (let g = 0; g < h.coordinates.length; g++) {
                    const A = Qu(h.coordinates[g], !0, y, T, k);
                    if (isNaN(A)) return A;
                    if ((k = Math.min(k, A)) === 0) return k;
                  }
                  return k;
                }
                return h.type === "Polygon" || h.type === "MultiPolygon" ? function(k, g, A) {
                  let D = 1 / 0;
                  for (const S of k) for (const R of g) {
                    const j = Bc(S, R, A, D);
                    if (isNaN(j)) return j;
                    if ((D = Math.min(D, j)) === 0) return D;
                  }
                  return D;
                }(h.type === "Polygon" ? [h.coordinates] : h.coordinates, y, T) : null;
              }(i, o, this.geometries);
              console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
            } else console.warn("Distance Expression: requirs valid feature and canonical information.");
            return null;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            return ["distance", this.geojson];
          }
        }
        function Ws(a, e) {
          switch (a) {
            case "string":
              return Hn(e);
            case "number":
              return +e;
            case "boolean":
              return !!e;
            case "color":
              return Xi.parse(e);
            case "formatted":
              return pa.fromString(Hn(e));
            case "resolvedImage":
              return ma.build(Hn(e));
          }
          return e;
        }
        function ec(a, e, i, o) {
          return o !== void 0 && (a = o * Math.round(a / o)), e !== void 0 && a < e && (a = e), i !== void 0 && a > i && (a = i), a;
        }
        class Zs {
          constructor(e, i, o) {
            this.type = e, this.key = i, this.scope = o;
          }
          static parse(e, i) {
            let o = i.expectedType;
            if (o == null && (o = Ji), e.length < 2 || e.length > 3) return i.error("Invalid number of arguments for 'config' expression.");
            const c = i.parse(e[1], 1);
            if (!(c instanceof Wn)) return i.error("Key name of 'config' expression must be a string literal.");
            if (e.length >= 3) {
              const s = i.parse(e[2], 2);
              return s instanceof Wn ? new Zs(o, Hn(c.value), Hn(s.value)) : i.error("Scope of 'config' expression must be a string literal.");
            }
            return new Zs(o, Hn(c.value));
          }
          evaluate(e) {
            const i = [this.key, this.scope, e.scope].filter(Boolean).join(""), o = e.getConfig(i);
            if (!o) return null;
            const { type: c, value: s, values: h, minValue: y, maxValue: T, stepValue: k } = o, g = o.default.evaluate(e);
            let A = g;
            if (s) {
              const D = e.scope;
              e.scope = (D || "").split("").slice(1).join(""), A = s.evaluate(e), e.scope = D;
            }
            return c && (A = Ws(c, A)), A === void 0 || y === void 0 && T === void 0 && k === void 0 || (typeof A == "number" ? A = ec(A, y, T, k) : Array.isArray(A) && (A = A.map((D) => typeof D == "number" ? ec(D, y, T, k) : D))), s !== void 0 && A !== void 0 && h && !h.includes(A) && (A = g, c && (A = Ws(c, A))), (c && c !== this.type || A !== void 0 && An(A) !== this.type) && (A = Ws(this.type.kind, A)), A;
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            const e = ["config", this.key];
            return this.scope && e.concat(this.key), e;
          }
        }
        function bs(a) {
          if (a instanceof Fa && (a.name === "get" && a.args.length === 1 || a.name === "feature-state" || a.name === "has" && a.args.length === 1 || a.name === "properties" || a.name === "geometry-type" || a.name === "id" || /^filter-/.test(a.name)) || a instanceof _i || a instanceof Jo) return !1;
          let e = !0;
          return a.eachChild((i) => {
            e && !bs(i) && (e = !1);
          }), e;
        }
        function Qo(a) {
          if (a instanceof Fa && a.name === "feature-state") return !1;
          let e = !0;
          return a.eachChild((i) => {
            e && !Qo(i) && (e = !1);
          }), e;
        }
        function El(a) {
          if (a instanceof Zs) return /* @__PURE__ */ new Set([a.key]);
          let e = /* @__PURE__ */ new Set();
          return a.eachChild((i) => {
            e = /* @__PURE__ */ new Set([...e, ...El(i)]);
          }), e;
        }
        function qs(a, e) {
          if (a instanceof Fa && e.indexOf(a.name) >= 0) return !1;
          let i = !0;
          return a.eachChild((o) => {
            i && !qs(o, e) && (i = !1);
          }), i;
        }
        class es {
          constructor(e, i) {
            this.type = i.type, this.name = e, this.boundExpression = i;
          }
          static parse(e, i) {
            if (e.length !== 2 || typeof e[1] != "string") return i.error("'var' expression requires exactly one string literal argument.");
            const o = e[1];
            return i.scope.has(o) ? new es(o, i.scope.get(o)) : i.error(`Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(e) {
            return this.boundExpression.evaluate(e);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return ["var", this.name];
          }
        }
        class Sl {
          constructor(e, i = [], o, c = new Rc(), s = [], h, y) {
            this.registry = e, this.path = i, this.key = i.map((T) => typeof T == "string" ? `['${T}']` : `[${T}]`).join(""), this.scope = c, this.errors = s, this.expectedType = o, this._scope = h, this.options = y;
          }
          parse(e, i, o, c, s = {}) {
            return i || o ? this.concat(i, null, o, c)._parse(e, s) : this._parse(e, s);
          }
          parseObjectValue(e, i, o, c, s, h = {}) {
            return this.concat(i, o, c, s)._parse(e, h);
          }
          _parse(e, i) {
            function o(c, s, h) {
              return h === "assert" ? new zo(s, [c]) : h === "coerce" ? new Yo(s, [c]) : c;
            }
            if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
              if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const c = typeof e[0] == "string" ? this.registry[e[0]] : void 0;
              if (c) {
                let s = c.parse(e, this);
                if (!s) return null;
                if (this.expectedType) {
                  const h = this.expectedType, y = s.type;
                  if (h.kind !== "string" && h.kind !== "number" && h.kind !== "boolean" && h.kind !== "object" && h.kind !== "array" || y.kind !== "value") if (h.kind !== "color" && h.kind !== "formatted" && h.kind !== "resolvedImage" || y.kind !== "value" && y.kind !== "string") {
                    if (this.checkSubtype(h, y)) return null;
                  } else s = o(s, h, i.typeAnnotation || "coerce");
                  else s = o(s, h, i.typeAnnotation || "assert");
                }
                if (!(s instanceof Wn) && s.type.kind !== "resolvedImage" && tc(s)) {
                  const h = new Ih(this._scope, this.options);
                  try {
                    s = new Wn(s.type, s.evaluate(h));
                  } catch (y) {
                    return this.error(y.message), null;
                  }
                }
                return s;
              }
              return Yo.parse(["to-array", e], this);
            }
            return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`);
          }
          concat(e, i, o, c) {
            let s = typeof e == "number" ? this.path.concat(e) : this.path;
            s = typeof i == "string" ? s.concat(i) : s;
            const h = c ? this.scope.concat(c) : this.scope;
            return new Sl(this.registry, s, o || null, h, this.errors, this._scope, this.options);
          }
          error(e, ...i) {
            const o = `${this.key}${i.map((c) => `[${c}]`).join("")}`;
            this.errors.push(new Mi(o, e));
          }
          checkSubtype(e, i) {
            const o = Ta(e, i);
            return o && this.error(o), o;
          }
        }
        var pu = Sl;
        function tc(a) {
          if (a instanceof es) return tc(a.boundExpression);
          if (a instanceof Fa && a.name === "error" || a instanceof Lc || a instanceof _i || a instanceof Jo || a instanceof Zs) return !1;
          const e = a instanceof Yo || a instanceof zo;
          let i = !0;
          return a.eachChild((o) => {
            i = e ? i && tc(o) : i && o instanceof Wn;
          }), !!i && bs(a) && qs(a, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]);
        }
        function mu(a, e) {
          const i = a.length - 1;
          let o, c, s = 0, h = i, y = 0;
          for (; s <= h; ) if (y = Math.floor((s + h) / 2), o = a[y], c = a[y + 1], o <= e) {
            if (y === i || e < c) return y;
            s = y + 1;
          } else {
            if (!(o > e)) throw new On("Input is not a number.");
            h = y - 1;
          }
          return 0;
        }
        class Tl {
          constructor(e, i, o) {
            this.type = e, this.input = i, this.labels = [], this.outputs = [];
            for (const [c, s] of o) this.labels.push(c), this.outputs.push(s);
          }
          static parse(e, i) {
            if (e.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if ((e.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
            const o = i.parse(e[1], 1, Xr);
            if (!o) return null;
            const c = [];
            let s = null;
            i.expectedType && i.expectedType.kind !== "value" && (s = i.expectedType);
            for (let h = 1; h < e.length; h += 2) {
              const y = h === 1 ? -1 / 0 : e[h], T = e[h + 1], k = h, g = h + 1;
              if (typeof y != "number") return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', k);
              if (c.length && c[c.length - 1][0] >= y) return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', k);
              const A = i.parse(T, g, s);
              if (!A) return null;
              s = s || A.type, c.push([y, A]);
            }
            return new Tl(s, o, c);
          }
          evaluate(e) {
            const i = this.labels, o = this.outputs;
            if (i.length === 1) return o[0].evaluate(e);
            const c = this.input.evaluate(e);
            if (c <= i[0]) return o[0].evaluate(e);
            const s = i.length;
            return c >= i[s - 1] ? o[s - 1].evaluate(e) : o[mu(i, c)].evaluate(e);
          }
          eachChild(e) {
            e(this.input);
            for (const i of this.outputs) e(i);
          }
          outputDefined() {
            return this.outputs.every((e) => e.outputDefined());
          }
          serialize() {
            const e = ["step", this.input.serialize()];
            for (let i = 0; i < this.labels.length; i++) i > 0 && e.push(this.labels[i]), e.push(this.outputs[i].serialize());
            return e;
          }
        }
        const $s = 0.95047, Oi = 1.08883, Nc = 4 / 29, Xs = 6 / 29, wf = 3 * Xs * Xs, Ef = Xs * Xs * Xs, rc = Math.PI / 180, yn = 180 / Math.PI;
        function Uc(a) {
          return a > Ef ? Math.pow(a, 1 / 3) : a / wf + Nc;
        }
        function jc(a) {
          return a > Xs ? a * a * a : wf * (a - Nc);
        }
        function Ln(a) {
          return 255 * (a <= 31308e-7 ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - 0.055);
        }
        function ic(a) {
          return (a /= 255) <= 0.04045 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4);
        }
        function nc(a) {
          const e = ic(a.r), i = ic(a.g), o = ic(a.b), c = Uc((0.4124564 * e + 0.3575761 * i + 0.1804375 * o) / $s), s = Uc((0.2126729 * e + 0.7151522 * i + 0.072175 * o) / 1);
          return { l: 116 * s - 16, a: 500 * (c - s), b: 200 * (s - Uc((0.0193339 * e + 0.119192 * i + 0.9503041 * o) / Oi)), alpha: a.a };
        }
        function _u(a) {
          let e = (a.l + 16) / 116, i = isNaN(a.a) ? e : e + a.a / 500, o = isNaN(a.b) ? e : e - a.b / 200;
          return e = 1 * jc(e), i = $s * jc(i), o = Oi * jc(o), new Xi(Ln(3.2404542 * i - 1.5371385 * e - 0.4985314 * o), Ln(-0.969266 * i + 1.8760108 * e + 0.041556 * o), Ln(0.0556434 * i - 0.2040259 * e + 1.0572252 * o), a.alpha);
        }
        function Sf(a, e, i) {
          const o = e - a;
          return a + i * (o > 180 || o < -180 ? o - 360 * Math.round(o / 360) : o);
        }
        const Ml = { forward: nc, reverse: _u, interpolate: function(a, e, i) {
          return { l: li(a.l, e.l, i), a: li(a.a, e.a, i), b: li(a.b, e.b, i), alpha: li(a.alpha, e.alpha, i) };
        } }, ws = { forward: function(a) {
          const { l: e, a: i, b: o } = nc(a), c = Math.atan2(o, i) * yn;
          return { h: c < 0 ? c + 360 : c, c: Math.sqrt(i * i + o * o), l: e, alpha: a.a };
        }, reverse: function(a) {
          const e = a.h * rc, i = a.c;
          return _u({ l: a.l, a: Math.cos(e) * i, b: Math.sin(e) * i, alpha: a.alpha });
        }, interpolate: function(a, e, i) {
          return { h: Sf(a.h, e.h, i), c: li(a.c, e.c, i), l: li(a.l, e.l, i), alpha: li(a.alpha, e.alpha, i) };
        } };
        var ac = Object.freeze({ __proto__: null, hcl: ws, lab: Ml });
        class _a {
          constructor(e, i, o, c, s, h) {
            this.type = e, this.operator = i, this.interpolation = o, this.input = c, this.dynamicStops = s, this.labels = [], this.outputs = [];
            for (const [y, T] of h) this.labels.push(y), this.outputs.push(T);
          }
          static interpolationFactor(e, i, o, c) {
            let s = 0;
            if (e.name === "exponential") s = Vc(i, e.base, o, c);
            else if (e.name === "linear") s = Vc(i, 1, o, c);
            else if (e.name === "cubic-bezier") {
              const h = e.controlPoints;
              s = new Xt(h[0], h[1], h[2], h[3]).solve(Vc(i, 1, o, c));
            }
            return s;
          }
          static parse(e, i) {
            let [o, c, s, ...h] = e;
            if (!Array.isArray(c) || c.length === 0) return i.error("Expected an interpolation type expression.", 1);
            if (c[0] === "linear") c = { name: "linear" };
            else if (c[0] === "exponential") {
              const k = c[1];
              if (typeof k != "number") return i.error("Exponential interpolation requires a numeric base.", 1, 1);
              c = { name: "exponential", base: k };
            } else {
              if (c[0] !== "cubic-bezier") return i.error(`Unknown interpolation type ${String(c[0])}`, 1, 0);
              {
                const k = c.slice(1);
                if (k.length !== 4 || k.some((g) => typeof g != "number" || g < 0 || g > 1)) return i.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                c = { name: "cubic-bezier", controlPoints: k };
              }
            }
            if (e.length - 1 < 3) return i.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
            if (e.length - 1 > 3 && (e.length - 1) % 2 != 0) return i.error("Expected an even number of arguments.");
            if (s = i.parse(s, 2, Xr), !s) return null;
            const y = [];
            let T = null;
            if (o === "interpolate-hcl" || o === "interpolate-lab" ? T = la : i.expectedType && i.expectedType.kind !== "value" && (T = i.expectedType), e.length - 1 == 3) {
              const k = i.parse(h[0], 3, Ji);
              return k ? new _a(T, o, c, s, k, y) : null;
            }
            for (let k = 0; k < h.length; k += 2) {
              const g = h[k], A = h[k + 1], D = k + 3, S = k + 4;
              if (typeof g != "number") return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', D);
              if (y.length && y[y.length - 1][0] >= g) return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', D);
              const R = i.parse(A, S, T);
              if (!R) return null;
              T = T || R.type, y.push([g, R]);
            }
            return T.kind === "number" || T.kind === "color" || T.kind === "array" && T.itemType.kind === "number" && typeof T.N == "number" ? new _a(T, o, c, s, null, y) : i.error(`Type ${zn(T)} is not interpolatable.`);
          }
          evaluate(e) {
            let i = this.labels, o = this.outputs;
            if (this.dynamicStops) {
              const g = this.dynamicStops.evaluate(e);
              if (g.length % 2 != 0) throw new On("Expected an even number of arguments.");
              i = [], o = [];
              for (let A = 0; A < g.length; A += 2) {
                const D = g[A], S = new Wn(Xr, g[A + 1]);
                if (typeof D != "number") throw new On('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.');
                if (i.length && i[i.length - 1] >= D) throw new On('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.');
                i.push(D), o.push(S);
              }
              if (i.length === 0) throw new On("Expected at least one input/output pair.");
            }
            if (i.length === 1) return o[0].evaluate(e);
            const c = this.input.evaluate(e);
            if (c <= i[0]) return o[0].evaluate(e);
            const s = i.length;
            if (c >= i[s - 1]) return o[s - 1].evaluate(e);
            const h = mu(i, c), y = _a.interpolationFactor(this.interpolation, c, i[h], i[h + 1]), T = o[h].evaluate(e), k = o[h + 1].evaluate(e);
            return this.operator === "interpolate" ? Ns[this.type.kind.toLowerCase()](T, k, y) : this.operator === "interpolate-hcl" ? ws.reverse(ws.interpolate(ws.forward(T), ws.forward(k), y)) : Ml.reverse(Ml.interpolate(Ml.forward(T), Ml.forward(k), y));
          }
          eachChild(e) {
            e(this.input);
            for (const i of this.outputs) e(i);
          }
          outputDefined() {
            return this.outputs.every((e) => e.outputDefined());
          }
          serialize() {
            let e;
            e = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
            const i = [this.operator, e, this.input.serialize()];
            if (this.dynamicStops) i.push(this.dynamicStops.serialize());
            else for (let o = 0; o < this.labels.length; o++) i.push(this.labels[o], this.outputs[o].serialize());
            return i;
          }
        }
        function Vc(a, e, i, o) {
          const c = o - i, s = a - i;
          return c === 0 ? 0 : e === 1 ? s / c : (Math.pow(e, s) - 1) / (Math.pow(e, c) - 1);
        }
        class Gc {
          constructor(e, i) {
            this.type = e, this.args = i;
          }
          static parse(e, i) {
            if (e.length < 2) return i.error("Expectected at least one argument.");
            let o = null;
            const c = i.expectedType;
            c && c.kind !== "value" && (o = c);
            const s = [];
            for (const y of e.slice(1)) {
              const T = i.parse(y, 1 + s.length, o, void 0, { typeAnnotation: "omit" });
              if (!T) return null;
              o = o || T.type, s.push(T);
            }
            const h = c && s.some((y) => Ta(c, y.type));
            return new Gc(h ? Ji : o, s);
          }
          evaluate(e) {
            let i, o = null, c = 0;
            for (const s of this.args) {
              if (c++, o = s.evaluate(e), o && o instanceof ma && !o.available && (i || (i = o), o = null, c === this.args.length)) return i;
              if (o !== null) break;
            }
            return o;
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every((e) => e.outputDefined());
          }
          serialize() {
            const e = ["coalesce"];
            return this.eachChild((i) => {
              e.push(i.serialize());
            }), e;
          }
        }
        class Hc {
          constructor(e, i) {
            this.type = i.type, this.bindings = [].concat(e), this.result = i;
          }
          evaluate(e) {
            return this.result.evaluate(e);
          }
          eachChild(e) {
            for (const i of this.bindings) e(i[1]);
            e(this.result);
          }
          static parse(e, i) {
            if (e.length < 4) return i.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
            const o = [];
            for (let s = 1; s < e.length - 1; s += 2) {
              const h = e[s];
              if (typeof h != "string") return i.error(`Expected string, but found ${typeof h} instead.`, s);
              if (/[^a-zA-Z0-9_]/.test(h)) return i.error("Variable names must contain only alphanumeric characters or '_'.", s);
              const y = i.parse(e[s + 1], s + 1);
              if (!y) return null;
              o.push([h, y]);
            }
            const c = i.parse(e[e.length - 1], e.length - 1, i.expectedType, o);
            return c ? new Hc(o, c) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
          serialize() {
            const e = ["let"];
            for (const [i, o] of this.bindings) e.push(i, o.serialize());
            return e.push(this.result.serialize()), e;
          }
        }
        class Wc {
          constructor(e, i, o) {
            this.type = e, this.index = i, this.input = o;
          }
          static parse(e, i) {
            if (e.length !== 3) return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
            const o = i.parse(e[1], 1, Xr), c = i.parse(e[2], 2, Kn(i.expectedType || Ji));
            return o && c ? new Wc(c.type.itemType, o, c) : null;
          }
          evaluate(e) {
            const i = this.index.evaluate(e), o = this.input.evaluate(e);
            if (i < 0) throw new On(`Array index out of bounds: ${i} < 0.`);
            if (i > o.length - 1) throw new On(`Array index out of bounds: ${i} > ${o.length - 1}.`);
            if (i === Math.floor(i)) return o[i];
            const c = Math.floor(i), s = Math.ceil(i), h = o[c], y = o[s];
            if (typeof h != "number" || typeof y != "number") throw new On(`Cannot interpolate between non-number values at index ${i}.`);
            const T = i - c;
            return h * (1 - T) + y * T;
          }
          eachChild(e) {
            e(this.index), e(this.input);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return ["at", this.index.serialize(), this.input.serialize()];
          }
        }
        class gu {
          constructor(e, i) {
            this.type = Zi, this.needle = e, this.haystack = i;
          }
          static parse(e, i) {
            if (e.length !== 3) return i.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
            const o = i.parse(e[1], 1, Ji), c = i.parse(e[2], 2, Ji);
            return o && c ? gl(o.type, [Zi, nn, Xr, js, Ji]) ? new gu(o, c) : i.error(`Expected first argument to be of type boolean, string, number or null, but found ${zn(o.type)} instead`) : null;
          }
          evaluate(e) {
            const i = this.needle.evaluate(e), o = this.haystack.evaluate(e);
            if (o == null) return !1;
            if (!yl(i, ["boolean", "string", "number", "null"])) throw new On(`Expected first argument to be of type boolean, string, number or null, but found ${zn(An(i))} instead.`);
            if (!yl(o, ["string", "array"])) throw new On(`Expected second argument to be of type array or string, but found ${zn(An(o))} instead.`);
            return o.indexOf(i) >= 0;
          }
          eachChild(e) {
            e(this.needle), e(this.haystack);
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            return ["in", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class Al {
          constructor(e, i, o) {
            this.type = Xr, this.needle = e, this.haystack = i, this.fromIndex = o;
          }
          static parse(e, i) {
            if (e.length <= 2 || e.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
            const o = i.parse(e[1], 1, Ji), c = i.parse(e[2], 2, Ji);
            if (!o || !c) return null;
            if (!gl(o.type, [Zi, nn, Xr, js, Ji])) return i.error(`Expected first argument to be of type boolean, string, number or null, but found ${zn(o.type)} instead`);
            if (e.length === 4) {
              const s = i.parse(e[3], 3, Xr);
              return s ? new Al(o, c, s) : null;
            }
            return new Al(o, c);
          }
          evaluate(e) {
            const i = this.needle.evaluate(e), o = this.haystack.evaluate(e);
            if (!yl(i, ["boolean", "string", "number", "null"])) throw new On(`Expected first argument to be of type boolean, string, number or null, but found ${zn(An(i))} instead.`);
            if (!yl(o, ["string", "array"])) throw new On(`Expected second argument to be of type array or string, but found ${zn(An(o))} instead.`);
            if (this.fromIndex) {
              const c = this.fromIndex.evaluate(e);
              return o.indexOf(i, c);
            }
            return o.indexOf(i);
          }
          eachChild(e) {
            e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            if (this.fromIndex != null && this.fromIndex !== void 0) {
              const e = this.fromIndex.serialize();
              return ["index-of", this.needle.serialize(), this.haystack.serialize(), e];
            }
            return ["index-of", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class oc {
          constructor(e, i, o, c, s, h) {
            this.inputType = e, this.type = i, this.input = o, this.cases = c, this.outputs = s, this.otherwise = h;
          }
          static parse(e, i) {
            if (e.length < 5) return i.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if (e.length % 2 != 1) return i.error("Expected an even number of arguments.");
            let o, c;
            i.expectedType && i.expectedType.kind !== "value" && (c = i.expectedType);
            const s = {}, h = [];
            for (let k = 2; k < e.length - 1; k += 2) {
              let g = e[k];
              const A = e[k + 1];
              Array.isArray(g) || (g = [g]);
              const D = i.concat(k);
              if (g.length === 0) return D.error("Expected at least one branch label.");
              for (const R of g) {
                if (typeof R != "number" && typeof R != "string") return D.error("Branch labels must be numbers or strings.");
                if (typeof R == "number" && Math.abs(R) > Number.MAX_SAFE_INTEGER) return D.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof R == "number" && Math.floor(R) !== R) return D.error("Numeric branch labels must be integer values.");
                if (o) {
                  if (D.checkSubtype(o, An(R))) return null;
                } else o = An(R);
                if (s[String(R)] !== void 0) return D.error("Branch labels must be unique.");
                s[String(R)] = h.length;
              }
              const S = i.parse(A, k, c);
              if (!S) return null;
              c = c || S.type, h.push(S);
            }
            const y = i.parse(e[1], 1, Ji);
            if (!y) return null;
            const T = i.parse(e[e.length - 1], e.length - 1, c);
            return T ? y.type.kind !== "value" && i.concat(1).checkSubtype(o, y.type) ? null : new oc(o, c, y, s, h, T) : null;
          }
          evaluate(e) {
            const i = this.input.evaluate(e);
            return (An(i) === this.inputType && this.outputs[this.cases[i]] || this.otherwise).evaluate(e);
          }
          eachChild(e) {
            e(this.input), this.outputs.forEach(e), e(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const e = ["match", this.input.serialize()], i = Object.keys(this.cases).sort(), o = [], c = {};
            for (const h of i) {
              const y = c[this.cases[h]];
              y === void 0 ? (c[this.cases[h]] = o.length, o.push([this.cases[h], [h]])) : o[y][1].push(h);
            }
            const s = (h) => this.inputType.kind === "number" ? Number(h) : h;
            for (const [h, y] of o) e.push(y.length === 1 ? s(y[0]) : y.map(s)), e.push(this.outputs[h].serialize());
            return e.push(this.otherwise.serialize()), e;
          }
        }
        class sc {
          constructor(e, i, o) {
            this.type = e, this.branches = i, this.otherwise = o;
          }
          static parse(e, i) {
            if (e.length < 4) return i.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
            if (e.length % 2 != 0) return i.error("Expected an odd number of arguments.");
            let o;
            i.expectedType && i.expectedType.kind !== "value" && (o = i.expectedType);
            const c = [];
            for (let h = 1; h < e.length - 1; h += 2) {
              const y = i.parse(e[h], h, Zi);
              if (!y) return null;
              const T = i.parse(e[h + 1], h + 1, o);
              if (!T) return null;
              c.push([y, T]), o = o || T.type;
            }
            const s = i.parse(e[e.length - 1], e.length - 1, o);
            return s ? new sc(o, c, s) : null;
          }
          evaluate(e) {
            for (const [i, o] of this.branches) if (i.evaluate(e)) return o.evaluate(e);
            return this.otherwise.evaluate(e);
          }
          eachChild(e) {
            for (const [i, o] of this.branches) e(i), e(o);
            e(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([e, i]) => i.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const e = ["case"];
            return this.eachChild((i) => {
              e.push(i.serialize());
            }), e;
          }
        }
        class yu {
          constructor(e, i, o, c) {
            this.type = e, this.input = i, this.beginIndex = o, this.endIndex = c;
          }
          static parse(e, i) {
            if (e.length <= 2 || e.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
            const o = i.parse(e[1], 1, Ji), c = i.parse(e[2], 2, Xr);
            if (!o || !c) return null;
            if (!gl(o.type, [Kn(Ji), nn, Ji])) return i.error(`Expected first argument to be of type array or string, but found ${zn(o.type)} instead`);
            if (e.length === 4) {
              const s = i.parse(e[3], 3, Xr);
              return s ? new yu(o.type, o, c, s) : null;
            }
            return new yu(o.type, o, c);
          }
          evaluate(e) {
            const i = this.input.evaluate(e), o = this.beginIndex.evaluate(e);
            if (!yl(i, ["string", "array"])) throw new On(`Expected first argument to be of type array or string, but found ${zn(An(i))} instead.`);
            if (this.endIndex) {
              const c = this.endIndex.evaluate(e);
              return i.slice(o, c);
            }
            return i.slice(o);
          }
          eachChild(e) {
            e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            if (this.endIndex != null && this.endIndex !== void 0) {
              const e = this.endIndex.serialize();
              return ["slice", this.input.serialize(), this.beginIndex.serialize(), e];
            }
            return ["slice", this.input.serialize(), this.beginIndex.serialize()];
          }
        }
        function Zc(a, e) {
          return a === "==" || a === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
        }
        function Tf(a, e, i, o) {
          return o.compare(e, i) === 0;
        }
        function Il(a, e, i) {
          const o = a !== "==" && a !== "!=";
          return class bv {
            constructor(s, h, y) {
              this.type = Zi, this.lhs = s, this.rhs = h, this.collator = y, this.hasUntypedArgument = s.type.kind === "value" || h.type.kind === "value";
            }
            static parse(s, h) {
              if (s.length !== 3 && s.length !== 4) return h.error("Expected two or three arguments.");
              const y = s[0];
              let T = h.parse(s[1], 1, Ji);
              if (!T) return null;
              if (!Zc(y, T.type)) return h.concat(1).error(`"${y}" comparisons are not supported for type '${zn(T.type)}'.`);
              let k = h.parse(s[2], 2, Ji);
              if (!k) return null;
              if (!Zc(y, k.type)) return h.concat(2).error(`"${y}" comparisons are not supported for type '${zn(k.type)}'.`);
              if (T.type.kind !== k.type.kind && T.type.kind !== "value" && k.type.kind !== "value") return h.error(`Cannot compare types '${zn(T.type)}' and '${zn(k.type)}'.`);
              o && (T.type.kind === "value" && k.type.kind !== "value" ? T = new zo(k.type, [T]) : T.type.kind !== "value" && k.type.kind === "value" && (k = new zo(T.type, [k])));
              let g = null;
              if (s.length === 4) {
                if (T.type.kind !== "string" && k.type.kind !== "string" && T.type.kind !== "value" && k.type.kind !== "value") return h.error("Cannot use collator to compare non-string types.");
                if (g = h.parse(s[3], 3, ms), !g) return null;
              }
              return new bv(T, k, g);
            }
            evaluate(s) {
              const h = this.lhs.evaluate(s), y = this.rhs.evaluate(s);
              if (o && this.hasUntypedArgument) {
                const T = An(h), k = An(y);
                if (T.kind !== k.kind || T.kind !== "string" && T.kind !== "number") throw new On(`Expected arguments for "${a}" to be (string, string) or (number, number), but found (${T.kind}, ${k.kind}) instead.`);
              }
              if (this.collator && !o && this.hasUntypedArgument) {
                const T = An(h), k = An(y);
                if (T.kind !== "string" || k.kind !== "string") return e(s, h, y);
              }
              return this.collator ? i(s, h, y, this.collator.evaluate(s)) : e(s, h, y);
            }
            eachChild(s) {
              s(this.lhs), s(this.rhs), this.collator && s(this.collator);
            }
            outputDefined() {
              return !0;
            }
            serialize() {
              const s = [a];
              return this.eachChild((h) => {
                s.push(h.serialize());
              }), s;
            }
          };
        }
        const fd = Il("==", function(a, e, i) {
          return e === i;
        }, Tf), dd = Il("!=", function(a, e, i) {
          return e !== i;
        }, function(a, e, i, o) {
          return !Tf(0, e, i, o);
        }), Bh = Il("<", function(a, e, i) {
          return e < i;
        }, function(a, e, i, o) {
          return o.compare(e, i) < 0;
        }), Ys = Il(">", function(a, e, i) {
          return e > i;
        }, function(a, e, i, o) {
          return o.compare(e, i) > 0;
        }), Mf = Il("<=", function(a, e, i) {
          return e <= i;
        }, function(a, e, i, o) {
          return o.compare(e, i) <= 0;
        }), vu = Il(">=", function(a, e, i) {
          return e >= i;
        }, function(a, e, i, o) {
          return o.compare(e, i) >= 0;
        });
        class Mo {
          constructor(e, i, o, c, s, h) {
            this.type = nn, this.number = e, this.locale = i, this.currency = o, this.unit = c, this.minFractionDigits = s, this.maxFractionDigits = h;
          }
          static parse(e, i) {
            if (e.length !== 3) return i.error("Expected two arguments.");
            const o = i.parse(e[1], 1, Xr);
            if (!o) return null;
            const c = e[2];
            if (typeof c != "object" || Array.isArray(c)) return i.error("NumberFormat options argument must be an object.");
            let s = null;
            if (c.locale && (s = i.parseObjectValue(c.locale, 2, "locale", nn), !s)) return null;
            let h = null;
            if (c.currency && (h = i.parseObjectValue(c.currency, 2, "currency", nn), !h)) return null;
            let y = null;
            if (c.unit && (y = i.parseObjectValue(c.unit, 2, "unit", nn), !y)) return null;
            let T = null;
            if (c["min-fraction-digits"] && (T = i.parseObjectValue(c["min-fraction-digits"], 2, "min-fraction-digits", Xr), !T)) return null;
            let k = null;
            return c["max-fraction-digits"] && (k = i.parseObjectValue(c["max-fraction-digits"], 2, "max-fraction-digits", Xr), !k) ? null : new Mo(o, s, h, y, T, k);
          }
          evaluate(e) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, unit: this.unit ? this.unit.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
          }
          eachChild(e) {
            e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.unit && e(this.unit), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            const e = {};
            return this.locale && (e.locale = this.locale.serialize()), this.currency && (e.currency = this.currency.serialize()), this.unit && (e.unit = this.unit.serialize()), this.minFractionDigits && (e["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), e];
          }
        }
        class Cl {
          constructor(e) {
            this.type = Xr, this.input = e;
          }
          static parse(e, i) {
            if (e.length !== 2) return i.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
            const o = i.parse(e[1], 1);
            return o ? o.type.kind !== "array" && o.type.kind !== "string" && o.type.kind !== "value" ? i.error(`Expected argument of type string or array, but found ${zn(o.type)} instead.`) : new Cl(o) : null;
          }
          evaluate(e) {
            const i = this.input.evaluate(e);
            if (typeof i == "string" || Array.isArray(i)) return i.length;
            throw new On(`Expected value to be of type string or array, but found ${zn(An(i))} instead.`);
          }
          eachChild(e) {
            e(this.input);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            const e = ["length"];
            return this.eachChild((i) => {
              e.push(i.serialize());
            }), e;
          }
        }
        function Ao(a) {
          return function() {
            a = 1831565813 + (a |= 0) | 0;
            let e = Math.imul(a ^ a >>> 15, 1 | a);
            return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;
          };
        }
        const Ks = { "==": fd, "!=": dd, ">": Ys, "<": Bh, ">=": vu, "<=": Mf, array: zo, at: Wc, boolean: zo, case: sc, coalesce: Gc, collator: Lc, format: gs, image: vl, in: gu, "index-of": Al, interpolate: _a, "interpolate-hcl": _a, "interpolate-lab": _a, length: Cl, let: Hc, literal: Wn, match: oc, number: zo, "number-format": Mo, object: zo, slice: yu, step: Tl, string: zo, "to-boolean": Yo, "to-color": Yo, "to-number": Yo, "to-string": Yo, var: es, within: _i, distance: Jo, config: Zs };
        function Fh(a, [e, i, o, c]) {
          e = e.evaluate(a), i = i.evaluate(a), o = o.evaluate(a);
          const s = c ? c.evaluate(a) : 1, h = su(e, i, o, s);
          if (h) throw new On(h);
          return new Xi(e / 255 * s, i / 255 * s, o / 255 * s, s);
        }
        function Af(a, [e, i, o, c]) {
          e = e.evaluate(a), i = i.evaluate(a), o = o.evaluate(a);
          const s = c ? c.evaluate(a) : 1, h = function(k, g, A, D) {
            return typeof k == "number" && k >= 0 && k <= 360 ? typeof g == "number" && g >= 0 && g <= 100 && typeof A == "number" && A >= 0 && A <= 100 ? D === void 0 || typeof D == "number" && D >= 0 && D <= 1 ? null : `Invalid hsla value [${[k, g, A, D].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${(typeof D == "number" ? [k, g, A, D] : [k, g, A]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${(typeof D == "number" ? [k, g, A, D] : [k, g, A]).join(", ")}]: 'h' must be between 0 and 360.`;
          }(e, i, o, s);
          if (h) throw new On(h);
          const y = `hsla(${e}, ${i}%, ${o}%, ${s})`, T = Xi.parse(y);
          if (!T) throw new On(`Failed to parse HSLA color: ${y}`);
          return T;
        }
        function Js(a, e) {
          return a in e;
        }
        function Pl(a, e) {
          const i = e[a];
          return i === void 0 ? null : i;
        }
        function fo(a) {
          return { type: a };
        }
        function xu(a) {
          return { result: "success", value: a };
        }
        function Na(a) {
          return { result: "error", value: a };
        }
        function Es(a, e) {
          return !!a && !!a.parameters && a.parameters.indexOf(e) > -1;
        }
        function Io(a) {
          return a["property-type"] === "data-driven";
        }
        function Bn(a) {
          return Es(a.expression, "measure-light");
        }
        function Tn(a) {
          return Es(a.expression, "zoom");
        }
        function Co(a) {
          return !!a.expression && a.expression.interpolated;
        }
        function ba(a) {
          return typeof a == "object" && a !== null && !Array.isArray(a);
        }
        function Ja(a) {
          return a;
        }
        function Ss(a, e) {
          const i = e.type === "color", o = a.stops && typeof a.stops[0][0] == "object", c = o || !(o || a.property !== void 0), s = a.type || (Co(e) ? "exponential" : "interval");
          if (i && ((a = Us({}, a)).stops && (a.stops = a.stops.map((k) => [k[0], Xi.parse(k[1])])), a.default = Xi.parse(a.default ? a.default : e.default)), a.colorSpace && a.colorSpace !== "rgb" && !ac[a.colorSpace]) throw new Error(`Unknown color space: ${a.colorSpace}`);
          let h, y, T;
          if (s === "exponential") h = Nh;
          else if (s === "interval") h = qc;
          else if (s === "categorical") {
            h = Qa, y = /* @__PURE__ */ Object.create(null);
            for (const k of a.stops) y[k[0]] = k[1];
            T = typeof a.stops[0][0];
          } else {
            if (s !== "identity") throw new Error(`Unknown function type "${s}"`);
            h = Uh;
          }
          if (o) {
            const k = {}, g = [];
            for (let S = 0; S < a.stops.length; S++) {
              const R = a.stops[S], j = R[0].zoom;
              k[j] === void 0 && (k[j] = { zoom: j, type: a.type, property: a.property, default: a.default, stops: [] }, g.push(j)), k[j].stops.push([R[0].value, R[1]]);
            }
            const A = [];
            for (const S of g) A.push([k[S].zoom, Ss(k[S], e)]);
            const D = { name: "linear" };
            return { kind: "composite", interpolationType: D, interpolationFactor: _a.interpolationFactor.bind(void 0, D), zoomStops: A.map((S) => S[0]), evaluate: ({ zoom: S }, R) => Nh({ stops: A, base: a.base }, e, S).evaluate(S, R) };
          }
          if (c) {
            const k = s === "exponential" ? { name: "exponential", base: a.base !== void 0 ? a.base : 1 } : null;
            return { kind: "camera", interpolationType: k, interpolationFactor: _a.interpolationFactor.bind(void 0, k), zoomStops: a.stops.map((g) => g[0]), evaluate: ({ zoom: g }) => h(a, e, g, y, T) };
          }
          return { kind: "source", evaluate(k, g) {
            const A = g && g.properties ? g.properties[a.property] : void 0;
            return A === void 0 ? Bo(a.default, e.default) : h(a, e, A, y, T);
          } };
        }
        function Bo(a, e, i) {
          return a !== void 0 ? a : e !== void 0 ? e : i !== void 0 ? i : void 0;
        }
        function Qa(a, e, i, o, c) {
          return Bo(typeof i === c ? o[i] : void 0, a.default, e.default);
        }
        function qc(a, e, i) {
          if (Ba(i) !== "number") return Bo(a.default, e.default);
          const o = a.stops.length;
          if (o === 1 || i <= a.stops[0][0]) return a.stops[0][1];
          if (i >= a.stops[o - 1][0]) return a.stops[o - 1][1];
          const c = mu(a.stops.map((s) => s[0]), i);
          return a.stops[c][1];
        }
        function Nh(a, e, i) {
          const o = a.base !== void 0 ? a.base : 1;
          if (Ba(i) !== "number") return Bo(a.default, e.default);
          const c = a.stops.length;
          if (c === 1 || i <= a.stops[0][0]) return a.stops[0][1];
          if (i >= a.stops[c - 1][0]) return a.stops[c - 1][1];
          const s = mu(a.stops.map((g) => g[0]), i), h = function(g, A, D, S) {
            const R = S - D, j = g - D;
            return R === 0 ? 0 : A === 1 ? j / R : (Math.pow(A, j) - 1) / (Math.pow(A, R) - 1);
          }(i, o, a.stops[s][0], a.stops[s + 1][0]), y = a.stops[s][1], T = a.stops[s + 1][1];
          let k = Ns[e.type] || Ja;
          if (a.colorSpace && a.colorSpace !== "rgb") {
            const g = ac[a.colorSpace];
            k = (A, D) => g.reverse(g.interpolate(g.forward(A), g.forward(D), h));
          }
          return typeof y.evaluate == "function" ? { evaluate(...g) {
            const A = y.evaluate.apply(void 0, g), D = T.evaluate.apply(void 0, g);
            if (A !== void 0 && D !== void 0) return k(A, D, h);
          } } : k(y, T, h);
        }
        function Uh(a, e, i) {
          return e.type === "color" ? i = Xi.parse(i) : e.type === "formatted" ? i = pa.fromString(i.toString()) : e.type === "resolvedImage" ? i = ma.build(i.toString()) : Ba(i) === e.type || e.type === "enum" && e.values[i] || (i = void 0), Bo(i, a.default, e.default);
        }
        Fa.register(Ks, { error: [{ kind: "error" }, [nn], (a, [e]) => {
          throw new On(e.evaluate(a));
        }], typeof: [nn, [Ji], (a, [e]) => zn(An(e.evaluate(a)))], "to-rgba": [Kn(Xr, 4), [la], (a, [e]) => e.evaluate(a).toRenderColor(null).toArray()], "to-hsla": [Kn(Xr, 4), [la], (a, [e]) => e.evaluate(a).toRenderColor(null).toHslaArray()], rgb: [la, [Xr, Xr, Xr], Fh], rgba: [la, [Xr, Xr, Xr, Xr], Fh], hsl: [la, [Xr, Xr, Xr], Af], hsla: [la, [Xr, Xr, Xr, Xr], Af], has: { type: Zi, overloads: [[[nn], (a, [e]) => Js(e.evaluate(a), a.properties())], [[nn, $o], (a, [e, i]) => Js(e.evaluate(a), i.evaluate(a))]] }, get: { type: Ji, overloads: [[[nn], (a, [e]) => Pl(e.evaluate(a), a.properties())], [[nn, $o], (a, [e, i]) => Pl(e.evaluate(a), i.evaluate(a))]] }, "feature-state": [Ji, [nn], (a, [e]) => Pl(e.evaluate(a), a.featureState || {})], properties: [$o, [], (a) => a.properties()], "geometry-type": [nn, [], (a) => a.geometryType()], id: [Ji, [], (a) => a.id()], zoom: [Xr, [], (a) => a.globals.zoom], pitch: [Xr, [], (a) => a.globals.pitch || 0], "distance-from-center": [Xr, [], (a) => a.distanceFromCenter()], "measure-light": [Xr, [nn], (a, [e]) => a.measureLight(e.evaluate(a))], "heatmap-density": [Xr, [], (a) => a.globals.heatmapDensity || 0], "line-progress": [Xr, [], (a) => a.globals.lineProgress || 0], "raster-value": [Xr, [], (a) => a.globals.rasterValue || 0], "raster-particle-speed": [Xr, [], (a) => a.globals.rasterParticleSpeed || 0], "sky-radial-progress": [Xr, [], (a) => a.globals.skyRadialProgress || 0], accumulated: [Ji, [], (a) => a.globals.accumulated === void 0 ? null : a.globals.accumulated], "+": [Xr, fo(Xr), (a, e) => {
          let i = 0;
          for (const o of e) i += o.evaluate(a);
          return i;
        }], "*": [Xr, fo(Xr), (a, e) => {
          let i = 1;
          for (const o of e) i *= o.evaluate(a);
          return i;
        }], "-": { type: Xr, overloads: [[[Xr, Xr], (a, [e, i]) => e.evaluate(a) - i.evaluate(a)], [[Xr], (a, [e]) => -e.evaluate(a)]] }, "/": [Xr, [Xr, Xr], (a, [e, i]) => e.evaluate(a) / i.evaluate(a)], "%": [Xr, [Xr, Xr], (a, [e, i]) => e.evaluate(a) % i.evaluate(a)], ln2: [Xr, [], () => Math.LN2], pi: [Xr, [], () => Math.PI], e: [Xr, [], () => Math.E], "^": [Xr, [Xr, Xr], (a, [e, i]) => Math.pow(e.evaluate(a), i.evaluate(a))], sqrt: [Xr, [Xr], (a, [e]) => Math.sqrt(e.evaluate(a))], log10: [Xr, [Xr], (a, [e]) => Math.log(e.evaluate(a)) / Math.LN10], ln: [Xr, [Xr], (a, [e]) => Math.log(e.evaluate(a))], log2: [Xr, [Xr], (a, [e]) => Math.log(e.evaluate(a)) / Math.LN2], sin: [Xr, [Xr], (a, [e]) => Math.sin(e.evaluate(a))], cos: [Xr, [Xr], (a, [e]) => Math.cos(e.evaluate(a))], tan: [Xr, [Xr], (a, [e]) => Math.tan(e.evaluate(a))], asin: [Xr, [Xr], (a, [e]) => Math.asin(e.evaluate(a))], acos: [Xr, [Xr], (a, [e]) => Math.acos(e.evaluate(a))], atan: [Xr, [Xr], (a, [e]) => Math.atan(e.evaluate(a))], min: [Xr, fo(Xr), (a, e) => Math.min(...e.map((i) => i.evaluate(a)))], max: [Xr, fo(Xr), (a, e) => Math.max(...e.map((i) => i.evaluate(a)))], abs: [Xr, [Xr], (a, [e]) => Math.abs(e.evaluate(a))], round: [Xr, [Xr], (a, [e]) => {
          const i = e.evaluate(a);
          return i < 0 ? -Math.round(-i) : Math.round(i);
        }], floor: [Xr, [Xr], (a, [e]) => Math.floor(e.evaluate(a))], ceil: [Xr, [Xr], (a, [e]) => Math.ceil(e.evaluate(a))], "filter-==": [Zi, [nn, Ji], (a, [e, i]) => a.properties()[e.value] === i.value], "filter-id-==": [Zi, [Ji], (a, [e]) => a.id() === e.value], "filter-type-==": [Zi, [nn], (a, [e]) => a.geometryType() === e.value], "filter-<": [Zi, [nn, Ji], (a, [e, i]) => {
          const o = a.properties()[e.value], c = i.value;
          return typeof o == typeof c && o < c;
        }], "filter-id-<": [Zi, [Ji], (a, [e]) => {
          const i = a.id(), o = e.value;
          return typeof i == typeof o && i < o;
        }], "filter->": [Zi, [nn, Ji], (a, [e, i]) => {
          const o = a.properties()[e.value], c = i.value;
          return typeof o == typeof c && o > c;
        }], "filter-id->": [Zi, [Ji], (a, [e]) => {
          const i = a.id(), o = e.value;
          return typeof i == typeof o && i > o;
        }], "filter-<=": [Zi, [nn, Ji], (a, [e, i]) => {
          const o = a.properties()[e.value], c = i.value;
          return typeof o == typeof c && o <= c;
        }], "filter-id-<=": [Zi, [Ji], (a, [e]) => {
          const i = a.id(), o = e.value;
          return typeof i == typeof o && i <= o;
        }], "filter->=": [Zi, [nn, Ji], (a, [e, i]) => {
          const o = a.properties()[e.value], c = i.value;
          return typeof o == typeof c && o >= c;
        }], "filter-id->=": [Zi, [Ji], (a, [e]) => {
          const i = a.id(), o = e.value;
          return typeof i == typeof o && i >= o;
        }], "filter-has": [Zi, [Ji], (a, [e]) => e.value in a.properties()], "filter-has-id": [Zi, [], (a) => a.id() !== null && a.id() !== void 0], "filter-type-in": [Zi, [Kn(nn)], (a, [e]) => e.value.indexOf(a.geometryType()) >= 0], "filter-id-in": [Zi, [Kn(Ji)], (a, [e]) => e.value.indexOf(a.id()) >= 0], "filter-in-small": [Zi, [nn, Kn(Ji)], (a, [e, i]) => i.value.indexOf(a.properties()[e.value]) >= 0], "filter-in-large": [Zi, [nn, Kn(Ji)], (a, [e, i]) => function(o, c, s, h) {
          for (; s <= h; ) {
            const y = s + h >> 1;
            if (c[y] === o) return !0;
            c[y] > o ? h = y - 1 : s = y + 1;
          }
          return !1;
        }(a.properties()[e.value], i.value, 0, i.value.length - 1)], all: { type: Zi, overloads: [[[Zi, Zi], (a, [e, i]) => e.evaluate(a) && i.evaluate(a)], [fo(Zi), (a, e) => {
          for (const i of e) if (!i.evaluate(a)) return !1;
          return !0;
        }]] }, any: { type: Zi, overloads: [[[Zi, Zi], (a, [e, i]) => e.evaluate(a) || i.evaluate(a)], [fo(Zi), (a, e) => {
          for (const i of e) if (i.evaluate(a)) return !0;
          return !1;
        }]] }, "!": [Zi, [Zi], (a, [e]) => !e.evaluate(a)], "is-supported-script": [Zi, [nn], (a, [e]) => {
          const i = a.globals && a.globals.isSupportedScript;
          return !i || i(e.evaluate(a));
        }], upcase: [nn, [nn], (a, [e]) => e.evaluate(a).toUpperCase()], downcase: [nn, [nn], (a, [e]) => e.evaluate(a).toLowerCase()], concat: [nn, fo(Ji), (a, e) => e.map((i) => Hn(i.evaluate(a))).join("")], "resolved-locale": [nn, [ms], (a, [e]) => e.evaluate(a).resolvedLocale()], random: [Xr, [Xr, Xr, Ji], (a, e) => {
          const [i, o, c] = e.map((h) => h.evaluate(a));
          if (i > o || i === o) return i;
          let s;
          if (typeof c == "string") s = function(h) {
            let y = 0;
            if (h.length === 0) return y;
            for (let T = 0; T < h.length; T++) y = (y << 5) - y + h.charCodeAt(T), y |= 0;
            return y;
          }(c);
          else {
            if (typeof c != "number") throw new On(`Invalid seed input: ${c}`);
            s = c;
          }
          return i + Ao(s)() * (o - i);
        }] });
        class Rl {
          constructor(e, i, o, c) {
            this.expression = e, this._warningHistory = {}, this._evaluator = new Ih(o, c), this._defaultValue = i ? function(s) {
              return s.type === "color" && (ba(s.default) || Array.isArray(s.default)) ? new Xi(0, 0, 0, 0) : s.type === "color" ? Xi.parse(s.default) || null : s.default === void 0 ? null : s.default;
            }(i) : null, this._enumValues = i && i.type === "enum" ? i.values : null, this.configDependencies = El(e);
          }
          evaluateWithoutErrorHandling(e, i, o, c, s, h, y, T) {
            return this._evaluator.globals = e, this._evaluator.feature = i, this._evaluator.featureState = o, this._evaluator.canonical = c || null, this._evaluator.availableImages = s || null, this._evaluator.formattedSection = h, this._evaluator.featureTileCoord = y || null, this._evaluator.featureDistanceData = T || null, this.expression.evaluate(this._evaluator);
          }
          evaluate(e, i, o, c, s, h, y, T) {
            this._evaluator.globals = e, this._evaluator.feature = i || null, this._evaluator.featureState = o || null, this._evaluator.canonical = c || null, this._evaluator.availableImages = s || null, this._evaluator.formattedSection = h || null, this._evaluator.featureTileCoord = y || null, this._evaluator.featureDistanceData = T || null;
            try {
              const k = this.expression.evaluate(this._evaluator);
              if (k == null || typeof k == "number" && k != k) return this._defaultValue;
              if (this._enumValues && !(k in this._enumValues)) throw new On(`Expected value to be one of ${Object.keys(this._enumValues).map((g) => JSON.stringify(g)).join(", ")}, but found ${JSON.stringify(k)} instead.`);
              return k;
            } catch (k) {
              return this._warningHistory[k.message] || (this._warningHistory[k.message] = !0, typeof console < "u" && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${k.message}`)), this._defaultValue;
            }
          }
        }
        function Ll(a) {
          return Array.isArray(a) && a.length > 0 && typeof a[0] == "string" && a[0] in Ks;
        }
        function eo(a, e, i, o) {
          const c = new pu(Ks, [], e ? function(h) {
            const y = { color: la, string: nn, number: Xr, enum: nn, boolean: Zi, formatted: Ya, resolvedImage: Xo };
            return h.type === "array" ? Kn(y[h.value] || Ji, h.length) : y[h.type];
          }(e) : void 0, void 0, void 0, i, o), s = c.parse(a, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return s ? xu(new Rl(s, e, i, o)) : Na(c.errors);
        }
        class Dl {
          constructor(e, i, o, c) {
            this.kind = e, this._styleExpression = i, this.isLightConstant = o, this.isLineProgressConstant = c, this.isStateDependent = e !== "constant" && !Qo(i.expression), this.configDependencies = El(i.expression);
          }
          evaluateWithoutErrorHandling(e, i, o, c, s, h) {
            return this._styleExpression.evaluateWithoutErrorHandling(e, i, o, c, s, h);
          }
          evaluate(e, i, o, c, s, h) {
            return this._styleExpression.evaluate(e, i, o, c, s, h);
          }
        }
        class kl {
          constructor(e, i, o, c, s, h) {
            this.kind = e, this.zoomStops = o, this._styleExpression = i, this.isStateDependent = e !== "camera" && !Qo(i.expression), this.isLightConstant = s, this.isLineProgressConstant = h, this.configDependencies = El(i.expression), this.interpolationType = c;
          }
          evaluateWithoutErrorHandling(e, i, o, c, s, h) {
            return this._styleExpression.evaluateWithoutErrorHandling(e, i, o, c, s, h);
          }
          evaluate(e, i, o, c, s, h) {
            return this._styleExpression.evaluate(e, i, o, c, s, h);
          }
          interpolationFactor(e, i, o) {
            return this.interpolationType ? _a.interpolationFactor(this.interpolationType, e, i, o) : 0;
          }
        }
        function jh(a, e, i, o) {
          if ((a = eo(a, e, i, o)).result === "error") return a;
          const c = a.value.expression, s = bs(c);
          if (!s && !Io(e)) return Na([new Mi("", "data expressions not supported")]);
          const h = qs(c, ["zoom", "pitch", "distance-from-center"]);
          if (!h && !Tn(e)) return Na([new Mi("", "zoom expressions not supported")]);
          const y = qs(c, ["measure-light"]);
          if (!y && !Bn(e)) return Na([new Mi("", "measure-light expression not supported")]);
          const T = qs(c, ["line-progress"]);
          if (!T && !function(A) {
            return Es(A.expression, "line-progress");
          }(e)) return Na([new Mi("", "line-progress expression not supported")]);
          const k = e.expression && e.expression.relaxZoomRestriction, g = Po(c);
          return g || h || k ? g instanceof Mi ? Na([g]) : g instanceof _a && !Co(e) ? Na([new Mi("", '"interpolate" expressions cannot be used with this property')]) : xu(g ? new kl(s && T ? "camera" : "composite", a.value, g.labels, g instanceof _a ? g.interpolation : void 0, y, T) : new Dl(s && T ? "constant" : "source", a.value, y, T)) : Na([new Mi("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
        }
        class lc {
          constructor(e, i) {
            this._parameters = e, this._specification = i, Us(this, Ss(this._parameters, this._specification));
          }
          static deserialize(e) {
            return new lc(e._parameters, e._specification);
          }
          static serialize(e) {
            return { _parameters: e._parameters, _specification: e._specification };
          }
        }
        function Po(a) {
          let e = null;
          if (a instanceof Hc) e = Po(a.result);
          else if (a instanceof Gc) {
            for (const i of a.args) if (e = Po(i), e) break;
          } else (a instanceof Tl || a instanceof _a) && a.input instanceof Fa && a.input.name === "zoom" && (e = a);
          return e instanceof Mi || a.eachChild((i) => {
            const o = Po(i);
            o instanceof Mi ? e = o : e && o && e !== o && (e = new Mi("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e;
        }
        var Qs, zl, $c = function() {
          if (zl) return Qs;
          zl = 1, Qs = e;
          var a = 3;
          function e(i, o, c) {
            var s = this.cells = [];
            if (i instanceof ArrayBuffer) {
              this.arrayBuffer = i;
              var h = new Int32Array(this.arrayBuffer);
              i = h[0], this.d = (o = h[1]) + 2 * (c = h[2]);
              for (var y = 0; y < this.d * this.d; y++) {
                var T = h[a + y], k = h[a + y + 1];
                s.push(T === k ? null : h.subarray(T, k));
              }
              var g = h[a + s.length + 1];
              this.keys = h.subarray(h[a + s.length], g), this.bboxes = h.subarray(g), this.insert = this._insertReadonly;
            } else {
              this.d = o + 2 * c;
              for (var A = 0; A < this.d * this.d; A++) s.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = o, this.extent = i, this.padding = c, this.scale = o / i, this.uid = 0;
            var D = c / o * i;
            this.min = -D, this.max = i + D;
          }
          return e.prototype.insert = function(i, o, c, s, h) {
            this._forEachCell(o, c, s, h, this._insertCell, this.uid++), this.keys.push(i), this.bboxes.push(o), this.bboxes.push(c), this.bboxes.push(s), this.bboxes.push(h);
          }, e.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
          }, e.prototype._insertCell = function(i, o, c, s, h, y) {
            this.cells[h].push(y);
          }, e.prototype.query = function(i, o, c, s, h) {
            var y = this.min, T = this.max;
            if (i <= y && o <= y && T <= c && T <= s && !h) return Array.prototype.slice.call(this.keys);
            var k = [];
            return this._forEachCell(i, o, c, s, this._queryCell, k, {}, h), k;
          }, e.prototype._queryCell = function(i, o, c, s, h, y, T, k) {
            var g = this.cells[h];
            if (g !== null) for (var A = this.keys, D = this.bboxes, S = 0; S < g.length; S++) {
              var R = g[S];
              if (T[R] === void 0) {
                var j = 4 * R;
                (k ? k(D[j + 0], D[j + 1], D[j + 2], D[j + 3]) : i <= D[j + 2] && o <= D[j + 3] && c >= D[j + 0] && s >= D[j + 1]) ? (T[R] = !0, y.push(A[R])) : T[R] = !1;
              }
            }
          }, e.prototype._forEachCell = function(i, o, c, s, h, y, T, k) {
            for (var g = this._convertToCellCoord(i), A = this._convertToCellCoord(o), D = this._convertToCellCoord(c), S = this._convertToCellCoord(s), R = g; R <= D; R++) for (var j = A; j <= S; j++) {
              var J = this.d * j + R;
              if ((!k || k(this._convertFromCellCoord(R), this._convertFromCellCoord(j), this._convertFromCellCoord(R + 1), this._convertFromCellCoord(j + 1))) && h.call(this, i, o, c, s, J, y, T, k)) return;
            }
          }, e.prototype._convertFromCellCoord = function(i) {
            return (i - this.padding) / this.scale;
          }, e.prototype._convertToCellCoord = function(i) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(i * this.scale) + this.padding));
          }, e.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer) return this.arrayBuffer;
            for (var i = this.cells, o = a + this.cells.length + 1 + 1, c = 0, s = 0; s < this.cells.length; s++) c += this.cells[s].length;
            var h = new Int32Array(o + c + this.keys.length + this.bboxes.length);
            h[0] = this.extent, h[1] = this.n, h[2] = this.padding;
            for (var y = o, T = 0; T < i.length; T++) {
              var k = i[T];
              h[a + T] = y, h.set(k, y), y += k.length;
            }
            return h[a + i.length] = y, h.set(this.keys, y), h[a + i.length + 1] = y += this.keys.length, h.set(this.bboxes, y), y += this.bboxes.length, h.buffer;
          }, Qs;
        }(), ts = F($c);
        const Ua = {};
        function Gr(a, e, i = {}) {
          Object.defineProperty(a, "_classRegistryKey", { value: e, writable: !1 }), Ua[e] = { klass: a, omit: i.omit || [] };
        }
        Gr(Object, "Object"), ts.serialize = function(a, e) {
          const i = a.toArrayBuffer();
          return e && e.add(i), { buffer: i };
        }, ts.deserialize = function(a) {
          return new ts(a.buffer);
        }, Object.defineProperty(ts, "name", { value: "Grid" }), Gr(ts, "Grid"), typeof DOMMatrix < "u" && Gr(DOMMatrix, "DOMMatrix"), Gr(Xi, "Color"), Gr(Error, "Error"), Gr(pa, "Formatted"), Gr(Eo, "FormattedSection"), Gr(Gn, "AJAXError"), Gr(ma, "ResolvedImage"), Gr(lc, "StylePropertyFunction"), Gr(Rl, "StyleExpression", { omit: ["_evaluator"] }), Gr(ho, "ImageIdWithOptions"), Gr(kl, "ZoomDependentExpression"), Gr(Dl, "ZoomConstantExpression"), Gr(Fa, "CompoundExpression", { omit: ["_evaluate"] });
        for (const a in Ks) Ua[Ks[a]._classRegistryKey] || Gr(Ks[a], `Expression${a}`);
        function Ts(a) {
          return a && typeof ArrayBuffer < "u" && (a instanceof ArrayBuffer || a.constructor && a.constructor.name === "ArrayBuffer");
        }
        function Fo(a) {
          return self.ImageBitmap && a instanceof ImageBitmap;
        }
        function Ra(a, e) {
          if (a == null || typeof a == "boolean" || typeof a == "number" || typeof a == "string" || a instanceof Boolean || a instanceof Number || a instanceof String || a instanceof Date || a instanceof RegExp) return a;
          if (Ts(a) || Fo(a)) return e && e.add(a), a;
          if (ArrayBuffer.isView(a)) return e && e.add(a.buffer), a;
          if (a instanceof ImageData) return e && e.add(a.data.buffer), a;
          if (Array.isArray(a)) {
            const i = [];
            for (const o of a) i.push(Ra(o, e));
            return i;
          }
          if (a instanceof Map) {
            const i = { $name: "Map" };
            for (const [o, c] of a.entries()) i[o] = Ra(c);
            return i;
          }
          if (a instanceof Set) {
            const i = { $name: "Set" };
            let o = 0;
            for (const c of a.values()) i[++o] = Ra(c);
            return i;
          }
          if (typeof a == "object") {
            const i = a.constructor, o = i._classRegistryKey;
            if (!o) throw new Error(`Can't serialize object of unregistered class "${o}".`);
            const c = i.serialize ? i.serialize(a, e) : {};
            if (!i.serialize) {
              for (const s in a) a.hasOwnProperty(s) && (Ua[o].omit.indexOf(s) >= 0 || (c[s] = Ra(a[s], e)));
              a instanceof Error && (c.message = a.message);
            }
            if (c.$name) throw new Error("$name property is reserved for worker serialization logic.");
            return o !== "Object" && (c.$name = o), c;
          }
          throw new Error("can't serialize object of type " + typeof a);
        }
        function po(a) {
          if (a == null || typeof a == "boolean" || typeof a == "number" || typeof a == "string" || a instanceof Boolean || a instanceof Number || a instanceof String || a instanceof Date || a instanceof RegExp || Ts(a) || Fo(a) || ArrayBuffer.isView(a) || a instanceof ImageData) return a;
          if (Array.isArray(a)) return a.map(po);
          if (typeof a == "object") {
            const e = a.$name || "Object";
            if (e === "Map") {
              const c = /* @__PURE__ */ new Map();
              for (const s of Object.keys(a)) s !== "$name" && c.set(s, po(a[s]));
              return c;
            }
            if (e === "Set") {
              const c = /* @__PURE__ */ new Set();
              for (const s of Object.keys(a)) s !== "$name" && c.add(po(a[s]));
              return c;
            }
            const { klass: i } = Ua[e];
            if (!i) throw new Error(`Can't deserialize unregistered class "${e}".`);
            if (i.deserialize) return i.deserialize(a);
            const o = Object.create(i.prototype);
            for (const c of Object.keys(a)) c !== "$name" && (o[c] = po(a[c]));
            return o;
          }
          throw new Error("can't deserialize object of type " + typeof a);
        }
        const ri = { "Latin-1 Supplement": (a) => a >= 128 && a <= 255, Arabic: (a) => a >= 1536 && a <= 1791, "Arabic Supplement": (a) => a >= 1872 && a <= 1919, "Arabic Extended-A": (a) => a >= 2208 && a <= 2303, "Hangul Jamo": (a) => a >= 4352 && a <= 4607, "Unified Canadian Aboriginal Syllabics": (a) => a >= 5120 && a <= 5759, Khmer: (a) => a >= 6016 && a <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (a) => a >= 6320 && a <= 6399, "General Punctuation": (a) => a >= 8192 && a <= 8303, "Letterlike Symbols": (a) => a >= 8448 && a <= 8527, "Number Forms": (a) => a >= 8528 && a <= 8591, "Miscellaneous Technical": (a) => a >= 8960 && a <= 9215, "Control Pictures": (a) => a >= 9216 && a <= 9279, "Optical Character Recognition": (a) => a >= 9280 && a <= 9311, "Enclosed Alphanumerics": (a) => a >= 9312 && a <= 9471, "Geometric Shapes": (a) => a >= 9632 && a <= 9727, "Miscellaneous Symbols": (a) => a >= 9728 && a <= 9983, "Miscellaneous Symbols and Arrows": (a) => a >= 11008 && a <= 11263, "CJK Radicals Supplement": (a) => a >= 11904 && a <= 12031, "Kangxi Radicals": (a) => a >= 12032 && a <= 12255, "Ideographic Description Characters": (a) => a >= 12272 && a <= 12287, "CJK Symbols and Punctuation": (a) => a >= 12288 && a <= 12351, Hiragana: (a) => a >= 12352 && a <= 12447, Katakana: (a) => a >= 12448 && a <= 12543, Bopomofo: (a) => a >= 12544 && a <= 12591, "Hangul Compatibility Jamo": (a) => a >= 12592 && a <= 12687, Kanbun: (a) => a >= 12688 && a <= 12703, "Bopomofo Extended": (a) => a >= 12704 && a <= 12735, "CJK Strokes": (a) => a >= 12736 && a <= 12783, "Katakana Phonetic Extensions": (a) => a >= 12784 && a <= 12799, "Enclosed CJK Letters and Months": (a) => a >= 12800 && a <= 13055, "CJK Compatibility": (a) => a >= 13056 && a <= 13311, "CJK Unified Ideographs Extension A": (a) => a >= 13312 && a <= 19903, "Yijing Hexagram Symbols": (a) => a >= 19904 && a <= 19967, "CJK Unified Ideographs": (a) => a >= 19968 && a <= 40959, "Yi Syllables": (a) => a >= 40960 && a <= 42127, "Yi Radicals": (a) => a >= 42128 && a <= 42191, "Hangul Jamo Extended-A": (a) => a >= 43360 && a <= 43391, "Hangul Syllables": (a) => a >= 44032 && a <= 55215, "Hangul Jamo Extended-B": (a) => a >= 55216 && a <= 55295, "Private Use Area": (a) => a >= 57344 && a <= 63743, "CJK Compatibility Ideographs": (a) => a >= 63744 && a <= 64255, "Arabic Presentation Forms-A": (a) => a >= 64336 && a <= 65023, "Vertical Forms": (a) => a >= 65040 && a <= 65055, "CJK Compatibility Forms": (a) => a >= 65072 && a <= 65103, "Small Form Variants": (a) => a >= 65104 && a <= 65135, "Arabic Presentation Forms-B": (a) => a >= 65136 && a <= 65279, "Halfwidth and Fullwidth Forms": (a) => a >= 65280 && a <= 65519, Osage: (a) => a >= 66736 && a <= 66815, "CJK Unified Ideographs Extension B": (a) => a >= 131072 && a <= 173791 };
        function uc(a) {
          for (const e of a) if (La(e.charCodeAt(0))) return !0;
          return !1;
        }
        function Vh(a) {
          for (const e of a) if (!mo(e.charCodeAt(0))) return !1;
          return !0;
        }
        function mo(a) {
          return !(ri.Arabic(a) || ri["Arabic Supplement"](a) || ri["Arabic Extended-A"](a) || ri["Arabic Presentation Forms-A"](a) || ri["Arabic Presentation Forms-B"](a));
        }
        function La(a) {
          return !(a !== 746 && a !== 747 && (a < 4352 || !(ri["Bopomofo Extended"](a) || ri.Bopomofo(a) || ri["CJK Compatibility Forms"](a) && !(a >= 65097 && a <= 65103) || ri["CJK Compatibility Ideographs"](a) || ri["CJK Compatibility"](a) || ri["CJK Radicals Supplement"](a) || ri["CJK Strokes"](a) || !(!ri["CJK Symbols and Punctuation"](a) || a >= 12296 && a <= 12305 || a >= 12308 && a <= 12319 || a === 12336) || ri["CJK Unified Ideographs Extension A"](a) || ri["CJK Unified Ideographs"](a) || ri["Enclosed CJK Letters and Months"](a) || ri["Hangul Compatibility Jamo"](a) || ri["Hangul Jamo Extended-A"](a) || ri["Hangul Jamo Extended-B"](a) || ri["Hangul Jamo"](a) || ri["Hangul Syllables"](a) || ri.Hiragana(a) || ri["Ideographic Description Characters"](a) || ri.Kanbun(a) || ri["Kangxi Radicals"](a) || ri["Katakana Phonetic Extensions"](a) || ri.Katakana(a) && a !== 12540 || !(!ri["Halfwidth and Fullwidth Forms"](a) || a === 65288 || a === 65289 || a === 65293 || a >= 65306 && a <= 65310 || a === 65339 || a === 65341 || a === 65343 || a >= 65371 && a <= 65503 || a === 65507 || a >= 65512 && a <= 65519) || !(!ri["Small Form Variants"](a) || a >= 65112 && a <= 65118 || a >= 65123 && a <= 65126) || ri["Unified Canadian Aboriginal Syllabics"](a) || ri["Unified Canadian Aboriginal Syllabics Extended"](a) || ri["Vertical Forms"](a) || ri["Yijing Hexagram Symbols"](a) || ri["Yi Syllables"](a) || ri["Yi Radicals"](a))));
        }
        function Fn(a) {
          return !(La(a) || function(e) {
            return !!(ri["Latin-1 Supplement"](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || ri["General Punctuation"](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || ri["Letterlike Symbols"](e) || ri["Number Forms"](e) || ri["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || ri["Control Pictures"](e) && e !== 9251 || ri["Optical Character Recognition"](e) || ri["Enclosed Alphanumerics"](e) || ri["Geometric Shapes"](e) || ri["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || ri["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || ri["CJK Symbols and Punctuation"](e) || ri.Katakana(e) || ri["Private Use Area"](e) || ri["CJK Compatibility Forms"](e) || ri["Small Form Variants"](e) || ri["Halfwidth and Fullwidth Forms"](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533);
          }(a));
        }
        function _o(a) {
          return a >= 1424 && a <= 2303 || ri["Arabic Presentation Forms-A"](a) || ri["Arabic Presentation Forms-B"](a);
        }
        function Gh(a, e) {
          return !(!e && _o(a) || a >= 2304 && a <= 3583 || a >= 3840 && a <= 4255 || ri.Khmer(a));
        }
        function Xc(a) {
          for (const e of a) if (_o(e.charCodeAt(0))) return !0;
          return !1;
        }
        const Ol = "deferred", bu = "loading", Yc = "loaded";
        let go = null, ja = "unavailable", yo = null;
        const cc = function(a) {
          a && typeof a == "string" && a.indexOf("NetworkError") > -1 && (ja = "error"), go && go(a);
        };
        function Hh() {
          rs.fire(new on("pluginStateChange", { pluginStatus: ja, pluginURL: yo }));
        }
        const rs = new ds(), Bl = function() {
          return ja;
        }, wu = function() {
          if (ja !== Ol || !yo) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          ja = bu, Hh(), yo && ea({ url: yo }, (a) => {
            a ? cc(a) : (ja = Yc, Hh());
          });
        }, to = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => ja === Yc || to.applyArabicShaping != null, isLoading: () => ja === bu, setState(a) {
          ja = a.pluginStatus, yo = a.pluginURL;
        }, isParsed: () => to.applyArabicShaping != null && to.processBidirectionalText != null && to.processStyledBidirectionalText != null, getPluginURL: () => yo };
        class sn {
          constructor(e, i) {
            this.zoom = e, i ? (this.now = i.now, this.fadeDuration = i.fadeDuration, this.transition = i.transition, this.pitch = i.pitch, this.brightness = i.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
          }
          isSupportedScript(e) {
            return function(i, o) {
              for (const c of i) if (!Gh(c.charCodeAt(0), o)) return !1;
              return !0;
            }(e, to.isLoaded());
          }
        }
        class hc {
          constructor(e, i, o, c) {
            this.property = e, this.value = i, this.expression = function(s, h, y, T) {
              if (ba(s)) return new lc(s, h);
              if (Ll(s) || Array.isArray(s) && s.length > 0) {
                const k = jh(s, h, y, T);
                if (k.result === "error") throw new Error(k.value.map((g) => `${g.key}: ${g.message}`).join(", "));
                return k.value;
              }
              {
                let k = s;
                return typeof s == "string" && h.type === "color" && (k = Xi.parse(s)), { kind: "constant", configDependencies: /* @__PURE__ */ new Set(), evaluate: () => k };
              }
            }(i === void 0 ? e.specification.default : i, e.specification, o, c);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          possiblyEvaluate(e, i, o) {
            return this.property.possiblyEvaluate(this, e, i, o);
          }
        }
        class el {
          constructor(e, i, o) {
            this.property = e, this.value = new hc(e, void 0, i, o);
          }
          transitioned(e, i) {
            return new tl(this.property, this.value, i, Qt({}, e.transition, this.transition), e.now);
          }
          untransitioned() {
            return new tl(this.property, this.value, null, {}, 0);
          }
        }
        class Fl {
          constructor(e, i, o) {
            this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues), this._scope = i, this._options = o, this.configDependencies = /* @__PURE__ */ new Set();
          }
          getValue(e) {
            return Vr(this._values[e].value.value);
          }
          setValue(e, i) {
            this._values.hasOwnProperty(e) || (this._values[e] = new el(this._values[e].property, this._scope, this._options)), this._values[e].value = new hc(this._values[e].property, i === null ? void 0 : Vr(i), this._scope, this._options), this._values[e].value.expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[e].value.expression.configDependencies]));
          }
          setTransitionOrValue(e, i) {
            i && (this._options = i);
            const o = this._properties.properties;
            if (e) for (const c in e) {
              const s = e[c];
              if (Rr(c, "-transition")) {
                const h = c.slice(0, -11);
                o[h] && this.setTransition(h, s);
              } else o.hasOwnProperty(c) && this.setValue(c, s);
            }
          }
          getTransition(e) {
            return Vr(this._values[e].transition);
          }
          setTransition(e, i) {
            this._values.hasOwnProperty(e) || (this._values[e] = new el(this._values[e].property)), this._values[e].transition = Vr(i) || void 0;
          }
          serialize() {
            const e = {};
            for (const i of Object.keys(this._values)) {
              const o = this.getValue(i);
              o !== void 0 && (e[i] = o);
              const c = this.getTransition(i);
              c !== void 0 && (e[`${i}-transition`] = c);
            }
            return e;
          }
          transitioned(e, i) {
            const o = new Nl(this._properties);
            for (const c of Object.keys(this._values)) o._values[c] = this._values[c].transitioned(e, i._values[c]);
            return o;
          }
          untransitioned() {
            const e = new Nl(this._properties);
            for (const i of Object.keys(this._values)) e._values[i] = this._values[i].untransitioned();
            return e;
          }
        }
        class tl {
          constructor(e, i, o, c, s) {
            const h = c.delay || 0, y = c.duration || 0;
            s = s || 0, this.property = e, this.value = i, this.begin = s + h, this.end = this.begin + y, e.specification.transition && (c.delay || c.duration) && (this.prior = o);
          }
          possiblyEvaluate(e, i, o) {
            const c = e.now || 0, s = this.value.possiblyEvaluate(e, i, o), h = this.prior;
            if (h) {
              if (c > this.end) return this.prior = null, s;
              if (this.value.isDataDriven()) return this.prior = null, s;
              if (c < this.begin) return h.possiblyEvaluate(e, i, o);
              {
                const y = (c - this.begin) / (this.end - this.begin);
                return this.property.interpolate(h.possiblyEvaluate(e, i, o), s, We(y));
              }
            }
            return s;
          }
        }
        class Nl {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(e, i, o) {
            const c = new nl(this._properties);
            for (const s of Object.keys(this._values)) c._values[s] = this._values[s].possiblyEvaluate(e, i, o);
            return c;
          }
          hasTransition() {
            for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
            return !1;
          }
        }
        class rl {
          constructor(e, i, o) {
            this._properties = e, this._values = Object.create(e.defaultPropertyValues), this._scope = i, this._options = o, this.configDependencies = /* @__PURE__ */ new Set();
          }
          getValue(e) {
            return Vr(this._values[e].value);
          }
          setValue(e, i) {
            this._values[e] = new hc(this._values[e].property, i === null ? void 0 : Vr(i), this._scope, this._options), this._values[e].expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[e].expression.configDependencies]));
          }
          serialize() {
            const e = {};
            for (const i of Object.keys(this._values)) {
              const o = this.getValue(i);
              o !== void 0 && (e[i] = o);
            }
            return e;
          }
          possiblyEvaluate(e, i, o) {
            const c = new nl(this._properties);
            for (const s of Object.keys(this._values)) c._values[s] = this._values[s].possiblyEvaluate(e, i, o);
            return c;
          }
        }
        class il {
          constructor(e, i, o) {
            this.property = e, this.value = i, this.parameters = o;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(e) {
            return this.value.kind === "constant" ? this.value.value : e;
          }
          evaluate(e, i, o, c) {
            return this.property.evaluate(this.value, this.parameters, e, i, o, c);
          }
        }
        class nl {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
          }
          get(e) {
            return this._values[e];
          }
        }
        class Mr {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, i) {
            return e.expression.evaluate(i);
          }
          interpolate(e, i, o) {
            const c = Ns[this.specification.type];
            return c ? c(e, i, o) : e;
          }
        }
        class Nr {
          constructor(e, i) {
            this.specification = e, this.overrides = i;
          }
          possiblyEvaluate(e, i, o, c) {
            return new il(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(i, null, {}, o, c) } : e.expression, i);
          }
          interpolate(e, i, o) {
            if (e.value.kind !== "constant" || i.value.kind !== "constant") return e;
            if (e.value.value === void 0 || i.value.value === void 0) return new il(this, { kind: "constant", value: void 0 }, e.parameters);
            const c = Ns[this.specification.type];
            return c ? new il(this, { kind: "constant", value: c(e.value.value, i.value.value, o) }, e.parameters) : e;
          }
          evaluate(e, i, o, c, s, h) {
            return e.kind === "constant" ? e.value : e.evaluate(i, o, c, s, h);
          }
        }
        class Ro {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, i, o, c) {
            return !!e.expression.evaluate(i, null, {}, o, c);
          }
          interpolate() {
            return !1;
          }
        }
        class vn {
          constructor(e) {
            this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            const i = new sn(0, {});
            for (const o in e) {
              const c = e[o];
              c.specification.overridable && this.overridableProperties.push(o);
              const s = this.defaultPropertyValues[o] = new hc(c, void 0), h = this.defaultTransitionablePropertyValues[o] = new el(c);
              this.defaultTransitioningPropertyValues[o] = h.untransitioned(), this.defaultPossiblyEvaluatedValues[o] = s.possiblyEvaluate(i);
            }
          }
        }
        Gr(Nr, "DataDrivenProperty"), Gr(Mr, "DataConstantProperty"), Gr(Ro, "ColorRampProperty");
        var Kt = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow","experimental":true},"rain":{"type":"rain","experimental":true},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor","experimental":true},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"experimental":true,"type":"featuresets"}},"featuresets":{"experimental":true,"*":{"type":"featureset"}},"featureset":{"experimental":true,"metadata":{"experimental":true,"type":"*"},"selectors":{"experimental":true,"type":"array","value":"selector"}},"selector":{"experimental":true,"layer":{"experimental":true,"type":"string","required":true},"properties":{"experimental":true,"type":"selectorProperty","required":false},"featureNamespace":{"experimental":true,"type":"string","required":false},"_uniqueFeatureID":{"experimental":true,"type":"boolean","private":true,"required":false}},"selectorProperty":{"experimental":true,"*":{"experimental":true,"type":"*"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","property-type":"data-constant","expression":{},"required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"property-type":"data-constant"},"shadow-quality":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]},"experimental":true},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"experimental":true,"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{"experimental":true},"hillshade":{},"model":{"experimental":true},"background":{},"sky":{},"slot":{},"clip":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{},"property-type":"data-constant"},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{},"property-type":"data-constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","experimental":true,"private":true,"expression":{},"property-type":"data-constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"circle-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-markup":1},"default":"none","experimental":true,"expression":{},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","experimental":true,"default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","experimental":true,"expression":{},"property-type":"data-constant"},"line-cross-slope":{"type":"number","experimental":true,"expression":{},"property-type":"constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","experimental":true,"private":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","experimental":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.4,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","property-type":"data-constant","default":0.71,"minimum":0,"maximum":5,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.57,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","property-type":"data-constant","default":0.7,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"colorTheme":{"data":{"type":"string","property-type":"data-constant","expression":{}}},"indoor":{"floorplanFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}},"buildingFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"flat","property-type":"data-constant"},"fill-extrusion-base-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"terrain","property-type":"data-constant"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","experimental":true,"default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","experimental":true,"default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"experimental":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-trim-fade-range":{"type":"array","value":"number","experimental":true,"length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-trim-color":{"type":"color","experimental":true,"default":"transparent","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"property-type":"data-constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"experimental":true,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]},"experimental":true,"property-type":"data-constant"},"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"model-front-cutoff":{"type":"array","private":true,"value":"number","property-type":"data-constant","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"*"}}}');
        function is(a) {
          return a instanceof Number || a instanceof String || a instanceof Boolean ? a.valueOf() : a;
        }
        function No(a) {
          if (Array.isArray(a)) return a.map(No);
          if (a instanceof Object && !(a instanceof Number || a instanceof String || a instanceof Boolean)) {
            const e = {};
            for (const i in a) e[i] = No(a[i]);
            return e;
          }
          return is(a);
        }
        function fc(a) {
          if (a === !0 || a === !1) return !0;
          if (!Array.isArray(a) || a.length === 0) return !1;
          switch (a[0]) {
            case "has":
              return a.length >= 2 && a[1] !== "$id" && a[1] !== "$type";
            case "in":
              return a.length >= 3 && (typeof a[1] != "string" || Array.isArray(a[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return a.length !== 3 || Array.isArray(a[1]) || Array.isArray(a[2]);
            case "any":
            case "all":
              for (const e of a.slice(1)) if (!fc(e) && typeof e != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        function Wh(a, e = "", i = null, o = "fill") {
          if (a == null) return { filter: () => !0, needGeometry: !1, needFeature: !1 };
          fc(a) || (a = al(a));
          const c = a;
          let s = !0;
          try {
            s = function(g) {
              if (!As(g)) return g;
              let A = No(g);
              return Ms(A), A = ns(A), A;
            }(c);
          } catch {
            console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(c, null, 2)}
        `);
          }
          let h = null, y = null;
          if (o !== "background" && o !== "sky" && o !== "slot") {
            y = Kt[`filter_${o}`];
            const g = eo(s, y, e, i);
            if (g.result === "error") throw new Error(g.value.map((A) => `${A.key}: ${A.message}`).join(", "));
            h = (A, D, S) => g.value.evaluate(A, D, {}, S);
          }
          let T = null, k = null;
          if (s !== c) {
            const g = eo(c, y, e, i);
            if (g.result === "error") throw new Error(g.value.map((A) => `${A.key}: ${A.message}`).join(", "));
            T = (A, D, S, R, j) => g.value.evaluate(A, D, {}, S, void 0, void 0, R, j), k = !bs(g.value.expression);
          }
          return { filter: h, dynamicFilter: T || void 0, needGeometry: Zh(s), needFeature: !!k };
        }
        function ns(a) {
          if (!Array.isArray(a)) return a;
          const e = function(i) {
            if (If.has(i[0])) {
              for (let o = 1; o < i.length; o++) if (As(i[o])) return !0;
            }
            return i;
          }(a);
          return e === !0 ? e : e.map((i) => ns(i));
        }
        function Ms(a) {
          let e = !1;
          const i = [];
          if (a[0] === "case") {
            for (let o = 1; o < a.length - 1; o += 2) e = e || As(a[o]), i.push(a[o + 1]);
            i.push(a[a.length - 1]);
          } else if (a[0] === "match") {
            e = e || As(a[1]);
            for (let o = 2; o < a.length - 1; o += 2) i.push(a[o + 1]);
            i.push(a[a.length - 1]);
          } else if (a[0] === "step") {
            e = e || As(a[1]);
            for (let o = 1; o < a.length - 1; o += 2) i.push(a[o + 1]);
          }
          e && (a.length = 0, a.push("any", ...i));
          for (let o = 1; o < a.length; o++) Ms(a[o]);
        }
        function As(a) {
          if (!Array.isArray(a)) return !1;
          if ((e = a[0]) === "pitch" || e === "distance-from-center") return !0;
          var e;
          for (let i = 1; i < a.length; i++) if (As(a[i])) return !0;
          return !1;
        }
        const If = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
        function Kc(a, e) {
          return a < e ? -1 : a > e ? 1 : 0;
        }
        function Zh(a) {
          if (!Array.isArray(a)) return !1;
          if (a[0] === "within" || a[0] === "distance") return !0;
          for (let e = 1; e < a.length; e++) if (Zh(a[e])) return !0;
          return !1;
        }
        function al(a) {
          if (!a) return !0;
          const e = a[0];
          return a.length <= 1 ? e !== "any" : e === "==" ? Aa(a[1], a[2], "==") : e === "!=" ? vo(Aa(a[1], a[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? Aa(a[1], a[2], e) : e === "any" ? (i = a.slice(1), ["any"].concat(i.map(al))) : e === "all" ? ["all"].concat(a.slice(1).map(al)) : e === "none" ? ["all"].concat(a.slice(1).map(al).map(vo)) : e === "in" ? Ul(a[1], a.slice(2)) : e === "!in" ? vo(Ul(a[1], a.slice(2))) : e === "has" ? jl(a[1]) : e !== "!has" || vo(jl(a[1]));
          var i;
        }
        function Aa(a, e, i) {
          switch (a) {
            case "$type":
              return [`filter-type-${i}`, e];
            case "$id":
              return [`filter-id-${i}`, e];
            default:
              return [`filter-${i}`, a, e];
          }
        }
        function Ul(a, e) {
          if (e.length === 0) return !1;
          switch (a) {
            case "$type":
              return ["filter-type-in", ["literal", e]];
            case "$id":
              return ["filter-id-in", ["literal", e]];
            default:
              return e.length > 200 && !e.some((i) => typeof i != typeof e[0]) ? ["filter-in-large", a, ["literal", e.sort(Kc)]] : ["filter-in-small", a, ["literal", e]];
          }
        }
        function jl(a) {
          switch (a) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", a];
          }
        }
        function vo(a) {
          return ["!", a];
        }
        const Eu = "";
        function Va(a, e) {
          return e ? `${a}${Eu}${e}` : a;
        }
        const as = "-transition", Jc = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
        class rn extends ds {
          constructor(e, i, o, c, s) {
            if (super(), this.id = e.id, this.fqid = Va(this.id, o), this.type = e.type, this.scope = o, this.lut = c, this.options = s, this._featureFilter = { filter: () => !0, needGeometry: !1, needFeature: !1 }, this._filterCompiled = !1, this.configDependencies = /* @__PURE__ */ new Set(), e.type !== "custom") {
              if (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type && e.type !== "background" && e.type !== "sky" && e.type !== "slot") {
                this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter;
                const h = eo(this.filter, Kt[`filter_${e.type}`]);
                h.result !== "error" && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...h.value.configDependencies]));
              }
              if (e.slot && (this.slot = e.slot), i.layout && (this._unevaluatedLayout = new rl(i.layout, this.scope, s), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), i.paint) {
                this._transitionablePaint = new Fl(i.paint, this.scope, s);
                for (const h in e.paint) this.setPaintProperty(h, e.paint[h]);
                for (const h in e.layout) this.setLayoutProperty(h, e.layout[h]);
                this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new nl(i.paint);
              }
            }
          }
          onAdd(e) {
          }
          onRemove(e) {
          }
          isDraped(e) {
            return !this.is3D() && Jc.has(this.type);
          }
          getLayoutProperty(e) {
            return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
          }
          setLayoutProperty(e, i) {
            if (this.type === "custom" && e === "visibility") return void (this.visibility = i);
            const o = this._unevaluatedLayout;
            o._properties.properties[e] && (o.setValue(e, i), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...o.configDependencies]), e === "visibility" && this.possiblyEvaluateVisibility());
          }
          possiblyEvaluateVisibility() {
            this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 }));
          }
          getPaintProperty(e) {
            return Rr(e, as) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
          }
          setPaintProperty(e, i) {
            const o = this._transitionablePaint, c = o._properties.properties;
            if (Rr(e, as)) {
              const A = e.slice(0, -11);
              return c[A] && o.setTransition(A, i || void 0), !1;
            }
            if (!c[e]) return !1;
            const s = o._values[e], h = s.value.isDataDriven(), y = s.value;
            o.setValue(e, i), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...o.configDependencies]), this._handleSpecialPaintPropertyUpdate(e);
            const T = o._values[e].value, k = T.isDataDriven(), g = Rr(e, "pattern") || e === "line-dasharray";
            return k || h || g || this._handleOverridablePaintPropertyUpdate(e, y, T);
          }
          _handleSpecialPaintPropertyUpdate(e) {
          }
          getProgramIds() {
            return null;
          }
          getDefaultProgramParams(e, i, o) {
            return null;
          }
          _handleOverridablePaintPropertyUpdate(e, i, o) {
            return !1;
          }
          isHidden(e) {
            return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(e) {
            this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(e, i) {
            this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, i)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, i);
          }
          serialize() {
            return hi({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (e, i) => !(e === void 0 || i === "layout" && !Object.keys(e).length || i === "paint" && !Object.keys(e).length));
          }
          is3D() {
            return !1;
          }
          isSky() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          hasShadowPass() {
            return !1;
          }
          canCastShadows() {
            return !1;
          }
          hasLightBeamPass() {
            return !1;
          }
          cutoffRange() {
            return 0;
          }
          tileCoverLift() {
            return 0;
          }
          resize() {
          }
          isStateDependent() {
            for (const e in this.paint._values) {
              const i = this.paint.get(e);
              if (i instanceof il && Io(i.property.specification) && (i.value.kind === "source" || i.value.kind === "composite") && i.value.isStateDependent) return !0;
            }
            return !1;
          }
          compileFilter(e) {
            this._filterCompiled || (this._featureFilter = Wh(this.filter, this.scope, e), this._filterCompiled = !0);
          }
          invalidateCompiledFilter() {
            this._filterCompiled = !1;
          }
          dynamicFilter() {
            return this._featureFilter.dynamicFilter;
          }
          dynamicFilterNeedsFeature() {
            return this._featureFilter.needFeature;
          }
          getLayerRenderingStats() {
            return this._stats;
          }
          resetLayerRenderingStats(e) {
            this._stats && (e.renderPass === "shadow" ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
          }
          queryRadius(e) {
          }
          queryIntersectsFeature(e, i, o, c, s, h, y, T, k) {
          }
        }
        const Qc = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Vl {
          constructor(e, i) {
            this._structArray = e, this._pos1 = i * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class dn {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(e, i) {
            return e._trim(), i && (e.isTransferred = !0, i.add(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
          }
          static deserialize(e) {
            const i = Object.create(this.prototype);
            return i.arrayBuffer = e.arrayBuffer, i.length = e.length, i.capacity = e.arrayBuffer.byteLength / i.bytesPerElement, i._refreshViews(), i;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(e) {
            this.reserve(e), this.length = e;
          }
          reserve(e) {
            if (e > this.capacity) {
              this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const i = this.uint8;
              this._refreshViews(), i && this.uint8.set(i);
            }
          }
          _refreshViews() {
            throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
          }
          emplace(...e) {
            throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
          }
          emplaceBack(...e) {
            throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
          }
          destroy() {
            this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
          }
        }
        function Yi(a, e = 1) {
          let i = 0, o = 0;
          return { members: a.map((c) => {
            const s = Qc[c.type].BYTES_PER_ELEMENT, h = i = eh(i, Math.max(e, s)), y = c.components || 1;
            return o = Math.max(o, s), i += s * y, { name: c.name, type: c.type, components: y, offset: h };
          }), size: eh(i, Math.max(o, e)), alignment: e };
        }
        function eh(a, e) {
          return Math.ceil(a / e) * e;
        }
        class Ga extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, e, i);
          }
          emplace(e, i, o) {
            const c = 2 * e;
            return this.int16[c + 0] = i, this.int16[c + 1] = o, e;
          }
        }
        Ga.prototype.bytesPerElement = 4, Gr(Ga, "StructArrayLayout2i4");
        class In extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, i, o);
          }
          emplace(e, i, o, c) {
            const s = 3 * e;
            return this.int16[s + 0] = i, this.int16[s + 1] = o, this.int16[s + 2] = c, e;
          }
        }
        In.prototype.bytesPerElement = 6, Gr(In, "StructArrayLayout3i6");
        class Dn extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, e, i, o, c);
          }
          emplace(e, i, o, c, s) {
            const h = 4 * e;
            return this.int16[h + 0] = i, this.int16[h + 1] = o, this.int16[h + 2] = c, this.int16[h + 3] = s, e;
          }
        }
        Dn.prototype.bytesPerElement = 8, Gr(Dn, "StructArrayLayout4i8");
        class ta extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, e, i, o, c, s);
          }
          emplace(e, i, o, c, s, h) {
            const y = 5 * e;
            return this.int16[y + 0] = i, this.int16[y + 1] = o, this.int16[y + 2] = c, this.int16[y + 3] = s, this.int16[y + 4] = h, e;
          }
        }
        ta.prototype.bytesPerElement = 10, Gr(ta, "StructArrayLayout5i10");
        class ol extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h, y) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, e, i, o, c, s, h, y);
          }
          emplace(e, i, o, c, s, h, y, T) {
            const k = 6 * e, g = 12 * e, A = 3 * e;
            return this.int16[k + 0] = i, this.int16[k + 1] = o, this.uint8[g + 4] = c, this.uint8[g + 5] = s, this.uint8[g + 6] = h, this.uint8[g + 7] = y, this.float32[A + 2] = T, e;
          }
        }
        ol.prototype.bytesPerElement = 12, Gr(ol, "StructArrayLayout2i4ub1f12");
        class ro extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, i, o);
          }
          emplace(e, i, o, c) {
            const s = 3 * e;
            return this.float32[s + 0] = i, this.float32[s + 1] = o, this.float32[s + 2] = c, e;
          }
        }
        ro.prototype.bytesPerElement = 12, Gr(ro, "StructArrayLayout3f12");
        class ra extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, e, i, o, c, s);
          }
          emplace(e, i, o, c, s, h) {
            const y = 6 * e, T = 3 * e;
            return this.uint16[y + 0] = i, this.uint16[y + 1] = o, this.uint16[y + 2] = c, this.uint16[y + 3] = s, this.float32[T + 2] = h, e;
          }
        }
        ra.prototype.bytesPerElement = 12, Gr(ra, "StructArrayLayout4ui1f12");
        class th extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, e, i, o, c);
          }
          emplace(e, i, o, c, s) {
            const h = 4 * e;
            return this.uint16[h + 0] = i, this.uint16[h + 1] = o, this.uint16[h + 2] = c, this.uint16[h + 3] = s, e;
          }
        }
        th.prototype.bytesPerElement = 8, Gr(th, "StructArrayLayout4ui8");
        class ca extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, e, i, o, c, s, h);
          }
          emplace(e, i, o, c, s, h, y) {
            const T = 6 * e;
            return this.int16[T + 0] = i, this.int16[T + 1] = o, this.int16[T + 2] = c, this.int16[T + 3] = s, this.int16[T + 4] = h, this.int16[T + 5] = y, e;
          }
        }
        ca.prototype.bytesPerElement = 12, Gr(ca, "StructArrayLayout6i12");
        class dc extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h, y, T, k, g, A, D) {
            const S = this.length;
            return this.resize(S + 1), this.emplace(S, e, i, o, c, s, h, y, T, k, g, A, D);
          }
          emplace(e, i, o, c, s, h, y, T, k, g, A, D, S) {
            const R = 12 * e;
            return this.int16[R + 0] = i, this.int16[R + 1] = o, this.int16[R + 2] = c, this.int16[R + 3] = s, this.uint16[R + 4] = h, this.uint16[R + 5] = y, this.uint16[R + 6] = T, this.uint16[R + 7] = k, this.int16[R + 8] = g, this.int16[R + 9] = A, this.int16[R + 10] = D, this.int16[R + 11] = S, e;
          }
        }
        dc.prototype.bytesPerElement = 24, Gr(dc, "StructArrayLayout4i4ui4i24");
        class pc extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, e, i, o, c, s, h);
          }
          emplace(e, i, o, c, s, h, y) {
            const T = 10 * e, k = 5 * e;
            return this.int16[T + 0] = i, this.int16[T + 1] = o, this.int16[T + 2] = c, this.float32[k + 2] = s, this.float32[k + 3] = h, this.float32[k + 4] = y, e;
          }
        }
        pc.prototype.bytesPerElement = 20, Gr(pc, "StructArrayLayout3i3f20");
        class Is extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, e, i, o, c);
          }
          emplace(e, i, o, c, s) {
            const h = 4 * e;
            return this.float32[h + 0] = i, this.float32[h + 1] = o, this.float32[h + 2] = c, this.float32[h + 3] = s, e;
          }
        }
        Is.prototype.bytesPerElement = 16, Gr(Is, "StructArrayLayout4f16");
        class Lo extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, e);
          }
          emplace(e, i) {
            return this.uint32[1 * e + 0] = i, e;
          }
        }
        Lo.prototype.bytesPerElement = 4, Gr(Lo, "StructArrayLayout1ul4");
        class ga extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, e, i);
          }
          emplace(e, i, o) {
            const c = 2 * e;
            return this.uint16[c + 0] = i, this.uint16[c + 1] = o, e;
          }
        }
        ga.prototype.bytesPerElement = 4, Gr(ga, "StructArrayLayout2ui4");
        class Gl extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h, y, T, k, g, A, D, S) {
            const R = this.length;
            return this.resize(R + 1), this.emplace(R, e, i, o, c, s, h, y, T, k, g, A, D, S);
          }
          emplace(e, i, o, c, s, h, y, T, k, g, A, D, S, R) {
            const j = 20 * e, J = 10 * e;
            return this.int16[j + 0] = i, this.int16[j + 1] = o, this.int16[j + 2] = c, this.int16[j + 3] = s, this.int16[j + 4] = h, this.float32[J + 3] = y, this.float32[J + 4] = T, this.float32[J + 5] = k, this.float32[J + 6] = g, this.int16[j + 14] = A, this.uint32[J + 8] = D, this.uint16[j + 18] = S, this.uint16[j + 19] = R, e;
          }
        }
        Gl.prototype.bytesPerElement = 40, Gr(Gl, "StructArrayLayout5i4f1i1ul2ui40");
        class Su extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h, y) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, e, i, o, c, s, h, y);
          }
          emplace(e, i, o, c, s, h, y, T) {
            const k = 8 * e;
            return this.int16[k + 0] = i, this.int16[k + 1] = o, this.int16[k + 2] = c, this.int16[k + 4] = s, this.int16[k + 5] = h, this.int16[k + 6] = y, this.int16[k + 7] = T, e;
          }
        }
        Su.prototype.bytesPerElement = 16, Gr(Su, "StructArrayLayout3i2i2i16");
        class mc extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, e, i, o, c, s);
          }
          emplace(e, i, o, c, s, h) {
            const y = 4 * e, T = 8 * e;
            return this.float32[y + 0] = i, this.float32[y + 1] = o, this.float32[y + 2] = c, this.int16[T + 6] = s, this.int16[T + 7] = h, e;
          }
        }
        mc.prototype.bytesPerElement = 16, Gr(mc, "StructArrayLayout2f1f2i16");
        class rh extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, e, i, o, c, s, h);
          }
          emplace(e, i, o, c, s, h, y) {
            const T = 20 * e, k = 5 * e;
            return this.uint8[T + 0] = i, this.uint8[T + 1] = o, this.float32[k + 1] = c, this.float32[k + 2] = s, this.float32[k + 3] = h, this.float32[k + 4] = y, e;
          }
        }
        rh.prototype.bytesPerElement = 20, Gr(rh, "StructArrayLayout2ub4f20");
        class ha extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o) {
            const c = this.length;
            return this.resize(c + 1), this.emplace(c, e, i, o);
          }
          emplace(e, i, o, c) {
            const s = 3 * e;
            return this.uint16[s + 0] = i, this.uint16[s + 1] = o, this.uint16[s + 2] = c, e;
          }
        }
        ha.prototype.bytesPerElement = 6, Gr(ha, "StructArrayLayout3ui6");
        class ih extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h, y, T, k, g, A, D, S, R, j, J, ne, me, ge, ue, Se) {
            const ke = this.length;
            return this.resize(ke + 1), this.emplace(ke, e, i, o, c, s, h, y, T, k, g, A, D, S, R, j, J, ne, me, ge, ue, Se);
          }
          emplace(e, i, o, c, s, h, y, T, k, g, A, D, S, R, j, J, ne, me, ge, ue, Se, ke) {
            const He = 30 * e, at = 15 * e, nt = 60 * e;
            return this.int16[He + 0] = i, this.int16[He + 1] = o, this.int16[He + 2] = c, this.float32[at + 2] = s, this.float32[at + 3] = h, this.uint16[He + 8] = y, this.uint16[He + 9] = T, this.uint32[at + 5] = k, this.uint32[at + 6] = g, this.uint32[at + 7] = A, this.uint16[He + 16] = D, this.uint16[He + 17] = S, this.uint16[He + 18] = R, this.float32[at + 10] = j, this.float32[at + 11] = J, this.uint8[nt + 48] = ne, this.uint8[nt + 49] = me, this.uint8[nt + 50] = ge, this.uint32[at + 13] = ue, this.int16[He + 28] = Se, this.uint8[nt + 58] = ke, e;
          }
        }
        ih.prototype.bytesPerElement = 60, Gr(ih, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class nh extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h, y, T, k, g, A, D, S, R, j, J, ne, me, ge, ue, Se, ke, He, at, nt, tt, Et, lt, St, Lt, It, zt) {
            const Ft = this.length;
            return this.resize(Ft + 1), this.emplace(Ft, e, i, o, c, s, h, y, T, k, g, A, D, S, R, j, J, ne, me, ge, ue, Se, ke, He, at, nt, tt, Et, lt, St, Lt, It, zt);
          }
          emplace(e, i, o, c, s, h, y, T, k, g, A, D, S, R, j, J, ne, me, ge, ue, Se, ke, He, at, nt, tt, Et, lt, St, Lt, It, zt, Ft) {
            const qt = 20 * e, Ot = 40 * e, cr = 80 * e;
            return this.float32[qt + 0] = i, this.float32[qt + 1] = o, this.int16[Ot + 4] = c, this.int16[Ot + 5] = s, this.int16[Ot + 6] = h, this.int16[Ot + 7] = y, this.int16[Ot + 8] = T, this.int16[Ot + 9] = k, this.int16[Ot + 10] = g, this.int16[Ot + 11] = A, this.int16[Ot + 12] = D, this.uint16[Ot + 13] = S, this.uint16[Ot + 14] = R, this.uint16[Ot + 15] = j, this.uint16[Ot + 16] = J, this.uint16[Ot + 17] = ne, this.uint16[Ot + 18] = me, this.uint16[Ot + 19] = ge, this.uint16[Ot + 20] = ue, this.uint16[Ot + 21] = Se, this.uint16[Ot + 22] = ke, this.uint16[Ot + 23] = He, this.uint16[Ot + 24] = at, this.uint16[Ot + 25] = nt, this.uint16[Ot + 26] = tt, this.uint16[Ot + 27] = Et, this.uint32[qt + 14] = lt, this.float32[qt + 15] = St, this.float32[qt + 16] = Lt, this.float32[qt + 17] = It, this.float32[qt + 18] = zt, this.uint8[cr + 76] = Ft, e;
          }
        }
        nh.prototype.bytesPerElement = 80, Gr(nh, "StructArrayLayout2f9i15ui1ul4f1ub80");
        class Tu extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, e);
          }
          emplace(e, i) {
            return this.float32[1 * e + 0] = i, e;
          }
        }
        Tu.prototype.bytesPerElement = 4, Gr(Tu, "StructArrayLayout1f4");
        class Cs extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, e, i, o, c, s);
          }
          emplace(e, i, o, c, s, h) {
            const y = 5 * e;
            return this.float32[y + 0] = i, this.float32[y + 1] = o, this.float32[y + 2] = c, this.float32[y + 3] = s, this.float32[y + 4] = h, e;
          }
        }
        Cs.prototype.bytesPerElement = 20, Gr(Cs, "StructArrayLayout5f20");
        class _c extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h, y) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, e, i, o, c, s, h, y);
          }
          emplace(e, i, o, c, s, h, y, T) {
            const k = 7 * e;
            return this.float32[k + 0] = i, this.float32[k + 1] = o, this.float32[k + 2] = c, this.float32[k + 3] = s, this.float32[k + 4] = h, this.float32[k + 5] = y, this.float32[k + 6] = T, e;
          }
        }
        _c.prototype.bytesPerElement = 28, Gr(_c, "StructArrayLayout7f28");
        class Uo extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h, y, T, k, g, A) {
            const D = this.length;
            return this.resize(D + 1), this.emplace(D, e, i, o, c, s, h, y, T, k, g, A);
          }
          emplace(e, i, o, c, s, h, y, T, k, g, A, D) {
            const S = 11 * e;
            return this.float32[S + 0] = i, this.float32[S + 1] = o, this.float32[S + 2] = c, this.float32[S + 3] = s, this.float32[S + 4] = h, this.float32[S + 5] = y, this.float32[S + 6] = T, this.float32[S + 7] = k, this.float32[S + 8] = g, this.float32[S + 9] = A, this.float32[S + 10] = D, e;
          }
        }
        Uo.prototype.bytesPerElement = 44, Gr(Uo, "StructArrayLayout11f44");
        class sl extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h, y, T, k) {
            const g = this.length;
            return this.resize(g + 1), this.emplace(g, e, i, o, c, s, h, y, T, k);
          }
          emplace(e, i, o, c, s, h, y, T, k, g) {
            const A = 9 * e;
            return this.float32[A + 0] = i, this.float32[A + 1] = o, this.float32[A + 2] = c, this.float32[A + 3] = s, this.float32[A + 4] = h, this.float32[A + 5] = y, this.float32[A + 6] = T, this.float32[A + 7] = k, this.float32[A + 8] = g, e;
          }
        }
        sl.prototype.bytesPerElement = 36, Gr(sl, "StructArrayLayout9f36");
        class Hl extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, e, i);
          }
          emplace(e, i, o) {
            const c = 2 * e;
            return this.float32[c + 0] = i, this.float32[c + 1] = o, e;
          }
        }
        Hl.prototype.bytesPerElement = 8, Gr(Hl, "StructArrayLayout2f8");
        class Mu extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, e, i, o, c);
          }
          emplace(e, i, o, c, s) {
            const h = 6 * e;
            return this.uint32[3 * e + 0] = i, this.uint16[h + 2] = o, this.uint16[h + 3] = c, this.uint16[h + 4] = s, e;
          }
        }
        Mu.prototype.bytesPerElement = 12, Gr(Mu, "StructArrayLayout1ul3ui12");
        class Au extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, e);
          }
          emplace(e, i) {
            return this.uint16[1 * e + 0] = i, e;
          }
        }
        Au.prototype.bytesPerElement = 2, Gr(Au, "StructArrayLayout1ui2");
        class Iu extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h, y, T, k, g, A, D, S, R, j, J) {
            const ne = this.length;
            return this.resize(ne + 1), this.emplace(ne, e, i, o, c, s, h, y, T, k, g, A, D, S, R, j, J);
          }
          emplace(e, i, o, c, s, h, y, T, k, g, A, D, S, R, j, J, ne) {
            const me = 16 * e;
            return this.float32[me + 0] = i, this.float32[me + 1] = o, this.float32[me + 2] = c, this.float32[me + 3] = s, this.float32[me + 4] = h, this.float32[me + 5] = y, this.float32[me + 6] = T, this.float32[me + 7] = k, this.float32[me + 8] = g, this.float32[me + 9] = A, this.float32[me + 10] = D, this.float32[me + 11] = S, this.float32[me + 12] = R, this.float32[me + 13] = j, this.float32[me + 14] = J, this.float32[me + 15] = ne, e;
          }
        }
        Iu.prototype.bytesPerElement = 64, Gr(Iu, "StructArrayLayout16f64");
        class Wl extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, i, o, c, s, h, y) {
            const T = this.length;
            return this.resize(T + 1), this.emplace(T, e, i, o, c, s, h, y);
          }
          emplace(e, i, o, c, s, h, y, T) {
            const k = 10 * e, g = 5 * e;
            return this.uint16[k + 0] = i, this.uint16[k + 1] = o, this.uint16[k + 2] = c, this.uint16[k + 3] = s, this.float32[g + 2] = h, this.float32[g + 3] = y, this.float32[g + 4] = T, e;
          }
        }
        Wl.prototype.bytesPerElement = 20, Gr(Wl, "StructArrayLayout4ui3f20");
        class ah extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, e);
          }
          emplace(e, i) {
            return this.int16[1 * e + 0] = i, e;
          }
        }
        ah.prototype.bytesPerElement = 2, Gr(ah, "StructArrayLayout1i2");
        class gc extends dn {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const i = this.length;
            return this.resize(i + 1), this.emplace(i, e);
          }
          emplace(e, i) {
            return this.uint8[1 * e + 0] = i, e;
          }
        }
        gc.prototype.bytesPerElement = 1, Gr(gc, "StructArrayLayout1ub1");
        class qh extends Vl {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get tileAnchorY() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get x1() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get y1() {
            return this._structArray.float32[this._pos4 + 4];
          }
          get x2() {
            return this._structArray.float32[this._pos4 + 5];
          }
          get y2() {
            return this._structArray.float32[this._pos4 + 6];
          }
          get padding() {
            return this._structArray.int16[this._pos2 + 14];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 8];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
        }
        qh.prototype.size = 40;
        class oh extends Gl {
          get(e) {
            return new qh(this, e);
          }
        }
        Gr(oh, "CollisionBoxArray");
        class Zl extends Vl {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 5];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 6];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 7];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 10];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 11];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 48];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 49];
          }
          set placedOrientation(e) {
            this._structArray.uint8[this._pos1 + 49] = e;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 50];
          }
          set hidden(e) {
            this._structArray.uint8[this._pos1 + 50] = e;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 13];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 13] = e;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 28];
          }
          get flipState() {
            return this._structArray.uint8[this._pos1 + 58];
          }
          set flipState(e) {
            this._structArray.uint8[this._pos1 + 58] = e;
          }
        }
        Zl.prototype.size = 60;
        class $h extends ih {
          get(e) {
            return new Zl(this, e);
          }
        }
        Gr($h, "PlacedSymbolArray");
        class Xh extends Vl {
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 0];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 8];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 9];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 10];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 11];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 12];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 23];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 24];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 25];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 26];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 27];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 14];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 14] = e;
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 15];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 16];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 17];
          }
          get zOffset() {
            return this._structArray.float32[this._pos4 + 18];
          }
          set zOffset(e) {
            this._structArray.float32[this._pos4 + 18] = e;
          }
          get hasIconTextFit() {
            return this._structArray.uint8[this._pos1 + 76];
          }
        }
        Xh.prototype.size = 80;
        class Yh extends nh {
          get(e) {
            return new Xh(this, e);
          }
        }
        Gr(Yh, "SymbolInstanceArray");
        class Cf extends Tu {
          getoffsetX(e) {
            return this.float32[1 * e + 0];
          }
        }
        Gr(Cf, "GlyphOffsetArray");
        class Kh extends Ga {
          getx(e) {
            return this.int16[2 * e + 0];
          }
          gety(e) {
            return this.int16[2 * e + 1];
          }
        }
        Gr(Kh, "SymbolLineVertexArray");
        class yc extends Vl {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get layoutVertexArrayOffset() {
            return this._structArray.uint16[this._pos2 + 4];
          }
        }
        yc.prototype.size = 12;
        class vc extends Mu {
          get(e) {
            return new yc(this, e);
          }
        }
        Gr(vc, "FeatureIndexArray");
        class Ha extends ga {
          geta_centroid_pos0(e) {
            return this.uint16[2 * e + 0];
          }
          geta_centroid_pos1(e) {
            return this.uint16[2 * e + 1];
          }
        }
        Gr(Ha, "FillExtrusionCentroidArray");
        class Cu extends Vl {
          get a_join_normal_inside0() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get a_join_normal_inside1() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get a_join_normal_inside2() {
            return this._structArray.int16[this._pos2 + 2];
          }
        }
        Cu.prototype.size = 6;
        class Jh extends In {
          get(e) {
            return new Cu(this, e);
          }
        }
        Gr(Jh, "FillExtrusionWallArray");
        const sh = Yi([{ name: "a_pos", components: 2, type: "Int16" }], 4), pd = Yi([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
        class Nn {
          constructor(e = []) {
            this.segments = e;
          }
          _prepareSegment(e, i, o, c) {
            let s = this.segments[this.segments.length - 1];
            return e > Nn.MAX_VERTEX_ARRAY_LENGTH && Tt(`Max vertices per segment is ${Nn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!s || s.vertexLength + e > Nn.MAX_VERTEX_ARRAY_LENGTH || s.sortKey !== c) && (s = { vertexOffset: i, primitiveOffset: o, vertexLength: 0, primitiveLength: 0 }, c !== void 0 && (s.sortKey = c), this.segments.push(s)), s;
          }
          prepareSegment(e, i, o, c) {
            return this._prepareSegment(e, i.length, o.length, c);
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const e of this.segments) for (const i in e.vaos) e.vaos[i].destroy();
          }
          static simpleSegment(e, i, o, c) {
            return new Nn([{ vertexOffset: e, primitiveOffset: i, vertexLength: o, primitiveLength: c, vaos: {}, sortKey: 0 }]);
          }
        }
        function lh(a, e) {
          return 256 * (a = ie(Math.floor(a), 0, 255)) + ie(Math.floor(e), 0, 255);
        }
        Nn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Gr(Nn, "SegmentVector");
        const jo = Yi([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), xc = Yi([{ name: "a_dash", components: 4, type: "Uint16" }]);
        class ll {
          constructor() {
            this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;
          }
          add(e, i, o, c) {
            this.ids.push(Qh(e)), this.positions.push(i, o, c);
          }
          eachPosition(e, i) {
            const o = Qh(e);
            let c = 0, s = this.ids.length - 1;
            for (; c < s; ) {
              const h = c + s >> 1;
              this.ids[h] >= o ? s = h : c = h + 1;
            }
            for (; this.ids[c] === o; ) i(this.positions[3 * c], this.positions[3 * c + 1], this.positions[3 * c + 2]), c++;
          }
          static serialize(e, i) {
            const o = new Float64Array(e.ids), c = new Uint32Array(e.positions);
            return Pu(o, c, 0, o.length - 1), i && (i.add(o.buffer), i.add(c.buffer)), { ids: o, positions: c };
          }
          static deserialize(e) {
            const i = new ll();
            let o;
            i.ids = e.ids, i.positions = e.positions;
            for (const c of i.ids) c !== o && i.uniqueIds.push(c), o = c;
            return i.indexed = !0, i;
          }
        }
        function Qh(a) {
          const e = +a;
          return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : co(String(a));
        }
        function Pu(a, e, i, o) {
          for (; i < o; ) {
            const c = a[i + o >> 1];
            let s = i - 1, h = o + 1;
            for (; ; ) {
              do
                s++;
              while (a[s] < c);
              do
                h--;
              while (a[h] > c);
              if (s >= h) break;
              bc(a, s, h), bc(e, 3 * s, 3 * h), bc(e, 3 * s + 1, 3 * h + 1), bc(e, 3 * s + 2, 3 * h + 2);
            }
            h - i < o - h ? (Pu(a, e, i, h), i = h + 1) : (Pu(a, e, h + 1, o), o = h);
          }
        }
        function bc(a, e, i) {
          const o = a[e];
          a[e] = a[i], a[i] = o;
        }
        Gr(ll, "FeaturePositionMap");
        class Do {
          constructor(e) {
            this.gl = e.gl, this.initialized = !1;
          }
          fetchUniformLocation(e, i) {
            return this.location || this.initialized || (this.location = this.gl.getUniformLocation(e, i), this.initialized = !0), !!this.location;
          }
          set(e, i, o) {
            throw new Error("Uniform#set() must be implemented by each concrete Uniform");
          }
        }
        class os extends Do {
          constructor(e) {
            super(e), this.current = 0;
          }
          set(e, i, o) {
            this.fetchUniformLocation(e, i) && this.current !== o && (this.current = o, this.gl.uniform1i(this.location, o));
          }
        }
        class kn extends Do {
          constructor(e) {
            super(e), this.current = 0;
          }
          set(e, i, o) {
            this.fetchUniformLocation(e, i) && this.current !== o && (this.current = o, this.gl.uniform1f(this.location, o));
          }
        }
        class io extends Do {
          constructor(e) {
            super(e), this.current = [0, 0];
          }
          set(e, i, o) {
            this.fetchUniformLocation(e, i) && (o[0] === this.current[0] && o[1] === this.current[1] || (this.current = o, this.gl.uniform2f(this.location, o[0], o[1])));
          }
        }
        class Ru extends Do {
          constructor(e) {
            super(e), this.current = [0, 0, 0];
          }
          set(e, i, o) {
            this.fetchUniformLocation(e, i) && (o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] || (this.current = o, this.gl.uniform3f(this.location, o[0], o[1], o[2])));
          }
        }
        class Lu extends Do {
          constructor(e) {
            super(e), this.current = [0, 0, 0, 0];
          }
          set(e, i, o) {
            this.fetchUniformLocation(e, i) && (o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] && o[3] === this.current[3] || (this.current = o, this.gl.uniform4f(this.location, o[0], o[1], o[2], o[3])));
          }
        }
        class ef extends Do {
          constructor(e) {
            super(e), this.current = Xi.transparent.toRenderColor(null);
          }
          set(e, i, o) {
            this.fetchUniformLocation(e, i) && (o.r === this.current.r && o.g === this.current.g && o.b === this.current.b && o.a === this.current.a || (this.current = o, this.gl.uniform4f(this.location, o.r, o.g, o.b, o.a)));
          }
        }
        const tf = new Float32Array(16);
        class Du extends Do {
          constructor(e) {
            super(e), this.current = tf;
          }
          set(e, i, o) {
            if (this.fetchUniformLocation(e, i)) {
              if (o[12] !== this.current[12] || o[0] !== this.current[0]) return this.current = o, void this.gl.uniformMatrix4fv(this.location, !1, o);
              for (let c = 1; c < 16; c++) if (o[c] !== this.current[c]) {
                this.current = o, this.gl.uniformMatrix4fv(this.location, !1, o);
                break;
              }
            }
          }
        }
        const uh = new Float32Array(9), md = new Float32Array(4);
        class Da extends Do {
          constructor(e) {
            super(e), this.current = md;
          }
          set(e, i, o) {
            if (this.fetchUniformLocation(e, i)) {
              for (let c = 0; c < 4; c++) if (o[c] !== this.current[c]) {
                this.current = o, this.gl.uniformMatrix2fv(this.location, !1, o);
                break;
              }
            }
          }
        }
        function Ia(a) {
          return [lh(255 * a.r, 255 * a.g), lh(255 * a.b, 255 * a.a)];
        }
        class ul {
          constructor(e, i, o, c) {
            this.value = e, this.uniformNames = i.map((s) => `u_${s}`), this.type = o, this.context = c;
          }
          setUniform(e, i, o, c, s) {
            const h = c.constantOr(this.value);
            i.set(e, s, h instanceof Xi ? h.toRenderColor(this.ignoreLut ? null : this.context.lut) : h);
          }
          getBinding(e, i) {
            return this.type === "color" ? new ef(e) : new kn(e);
          }
        }
        class cl {
          constructor(e, i) {
            this.uniformNames = i.map((o) => `u_${o}`), this.pattern = null, this.pixelRatio = 1;
          }
          setConstantPatternPositions(e) {
            this.pixelRatio = e.pixelRatio || 1, this.pattern = e.tl.concat(e.br);
          }
          setUniform(e, i, o, c, s) {
            const h = s === "u_pattern" || s === "u_dash" ? this.pattern : s === "u_pixel_ratio" ? this.pixelRatio : null;
            h && i.set(e, s, h);
          }
          getBinding(e, i) {
            return i === "u_pattern" || i === "u_dash" ? new Lu(e) : new kn(e);
          }
        }
        class ss {
          constructor(e, i, o, c) {
            this.expression = e, this.type = o, this.maxValue = 0, this.paintVertexAttributes = i.map((s) => ({ name: `a_${s}`, type: "Float32", components: o === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new c();
          }
          populatePaintArray(e, i, o, c, s, h, y) {
            const T = this.paintVertexArray.length, k = this.expression.kind === "composite" || this.expression.kind === "source" ? this.expression.evaluate(new sn(0, { brightness: h }), i, {}, s, c, y) : this.expression.kind === "constant" && this.expression.value;
            !this.lutExpression || this.lutExpression.kind !== "composite" && this.lutExpression.kind !== "source" || (this.ignoreLut = this.lutExpression.evaluate(new sn(0, { brightness: h }), i, {}, s, c, y) === "none"), this.paintVertexArray.resize(e), this._setPaintValue(T, e, k, this.context);
          }
          updatePaintArray(e, i, o, c, s, h, y) {
            const T = this.expression.kind === "composite" || this.expression.kind === "source" ? this.expression.evaluate({ zoom: 0, brightness: y }, o, c, void 0, s) : this.expression.kind === "constant" && this.expression.value;
            !this.lutExpression || this.lutExpression.kind !== "composite" && this.lutExpression.kind !== "source" || (this.ignoreLut = this.lutExpression.evaluate({ zoom: 0, brightness: y }, o, c, void 0, s) === "none"), this._setPaintValue(e, i, T, this.context);
          }
          _setPaintValue(e, i, o, c) {
            if (this.type === "color") {
              const s = Ia(o.toRenderColor(this.ignoreLut ? null : c.lut));
              for (let h = e; h < i; h++) this.paintVertexArray.emplace(h, s[0], s[1]);
            } else {
              for (let s = e; s < i; s++) this.paintVertexArray.emplace(s, o);
              this.maxValue = Math.max(this.maxValue, Math.abs(o));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && this.lutExpression.kind !== "constant" && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || this.expression.kind !== "constant" && (this.expression.isStateDependent || !this.expression.isLightConstant)));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class ko {
          constructor(e, i, o, c, s, h) {
            this.expression = e, this.uniformNames = i.map((y) => `u_${y}_t`), this.type = o, this.useIntegerZoom = c, this.context = s, this.maxValue = 0, this.paintVertexAttributes = i.map((y) => ({ name: `a_${y}`, type: "Float32", components: o === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new h();
          }
          populatePaintArray(e, i, o, c, s, h, y) {
            const T = this.expression.evaluate(new sn(this.context.zoom, { brightness: h }), i, {}, s, c, y), k = this.expression.evaluate(new sn(this.context.zoom + 1, { brightness: h }), i, {}, s, c, y);
            !this.lutExpression || this.lutExpression.kind !== "composite" && this.lutExpression.kind !== "source" || (this.ignoreLut = this.lutExpression.evaluate(new sn(this.context.zoom, { brightness: h }), i, {}, s, c, y) === "none");
            const g = this.paintVertexArray.length;
            this.paintVertexArray.resize(e), this._setPaintValue(g, e, T, k, this.context);
          }
          updatePaintArray(e, i, o, c, s, h, y) {
            const T = this.expression.evaluate({ zoom: this.context.zoom, brightness: y }, o, c, void 0, s), k = this.expression.evaluate({ zoom: this.context.zoom + 1, brightness: y }, o, c, void 0, s);
            !this.lutExpression || this.lutExpression.kind !== "composite" && this.lutExpression.kind !== "source" || (this.ignoreLut = this.lutExpression.evaluate({ zoom: this.context.zoom, brightness: y }, o, c, void 0, s) === "none"), this._setPaintValue(e, i, T, k, this.context);
          }
          _setPaintValue(e, i, o, c, s) {
            if (this.type === "color") {
              const h = Ia(o.toRenderColor(this.ignoreLut ? null : s.lut)), y = Ia(o.toRenderColor(this.ignoreLut ? null : s.lut));
              for (let T = e; T < i; T++) this.paintVertexArray.emplace(T, h[0], h[1], y[0], y[1]);
            } else {
              for (let h = e; h < i; h++) this.paintVertexArray.emplace(h, o, c);
              this.maxValue = Math.max(this.maxValue, Math.abs(o), Math.abs(c));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(e, i, o, c, s) {
            const h = this.useIntegerZoom ? Math.floor(o.zoom) : o.zoom, y = ie(this.expression.interpolationFactor(h, this.context.zoom, this.context.zoom + 1), 0, 1);
            i.set(e, s, y);
          }
          getBinding(e, i) {
            return new kn(e);
          }
        }
        class Ps {
          constructor(e, i, o, c, s) {
            this.expression = e, this.layerId = s, this.paintVertexAttributes = (o === "array" ? xc : jo).members;
            for (let h = 0; h < i.length; ++h) ;
            this.paintVertexArray = new c();
          }
          populatePaintArray(e, i, o, c) {
            const s = this.paintVertexArray.length;
            this.paintVertexArray.resize(e), this._setPaintValues(s, e, i.patterns && i.patterns[this.layerId], o);
          }
          updatePaintArray(e, i, o, c, s, h, y) {
            this._setPaintValues(e, i, o.patterns && o.patterns[this.layerId], h);
          }
          _setPaintValues(e, i, o, c) {
            if (!c || !o) return;
            const s = c[o];
            if (!s) return;
            const { tl: h, br: y, pixelRatio: T } = s;
            for (let k = e; k < i; k++) this.paintVertexArray.emplace(k, h[0], h[1], y[0], y[1], T);
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Rs {
          constructor(e, i, o = () => !0) {
            this.binders = {}, this._buffers = [], this.context = i;
            const c = [];
            for (const s in e.paint._values) {
              const h = e.paint.get(s), y = e.paint.get(`${s}-use-theme`);
              if (s.endsWith("-use-theme") || !o(s) || !(h instanceof il && Io(h.property.specification))) continue;
              const T = Pf(s, e.type), k = h.value, g = h.property.specification.type, A = !!h.property.useIntegerZoom, D = s === "line-dasharray" || s.endsWith("pattern"), S = s === "line-dasharray" && e.layout.get("line-cap").value.kind !== "constant" || y && y.value.kind !== "constant";
              if (k.kind !== "constant" || S) if (k.kind === "source" || S || D) {
                const R = ch(s, g, "source");
                this.binders[s] = D ? new Ps(k, T, g, R, e.id) : new ss(k, T, g, R), c.push(`/a_${s}`);
              } else {
                const R = ch(s, g, "composite");
                this.binders[s] = new ko(k, T, g, A, i, R), c.push(`/z_${s}`);
              }
              else this.binders[s] = D ? new cl(k.value, T) : new ul(k.value, T, g, i), c.push(`/u_${s}`);
              y && (this.binders[s].ignoreLut = y.constantOr("default") === "none", this.binders[s].lutExpression = y.value, this.binders[s].checkUseTheme = !0);
            }
            this.cacheKey = c.sort().join("");
          }
          getMaxValue(e) {
            const i = this.binders[e];
            return i instanceof ss || i instanceof ko ? i.maxValue : 0;
          }
          populatePaintArrays(e, i, o, c, s, h, y) {
            for (const T in this.binders) {
              const k = this.binders[T];
              k.context = this.context, k instanceof ss || k instanceof ko || k instanceof Ps ? k.populatePaintArray(e, i, o, c, s, h, y) : k.lutExpression && k instanceof ul && k.lutExpression && (k.lutExpression.kind === "composite" || k.lutExpression.kind === "source") && (k.ignoreLut = k.lutExpression.evaluate(new sn(0, { brightness: h }), i, {}, s, c, y) === "none");
            }
          }
          setConstantPatternPositions(e) {
            for (const i in this.binders) {
              const o = this.binders[i];
              o instanceof cl && o.setConstantPatternPositions(e);
            }
          }
          updatePaintArrays(e, i, o, c, s, h, y, T, k) {
            let g = !1;
            const A = Object.keys(e), D = A.length !== 0 && !T, S = D ? A : i.uniqueIds;
            this.context.lut = s.lut;
            for (const R in this.binders) {
              const j = this.binders[R];
              if (j.context = this.context, (j instanceof ss || j instanceof ko || j instanceof Ps) && j.expression && j.expression.kind && j.expression.kind !== "constant" && (j.expression.isStateDependent === !0 || j.expression.isLightConstant === !1)) {
                const J = s.paint.get(R);
                j.expression = J.value;
                for (const ne of S) {
                  const me = e[ne.toString()];
                  i.eachPosition(ne, (ge, ue, Se) => {
                    const ke = c.feature(ge);
                    j.updatePaintArray(ue, Se, ke, me, h, y, k);
                  });
                }
                if (!D) for (const ne of o.uniqueIds) {
                  const me = e[ne.toString()];
                  o.eachPosition(ne, (ge, ue, Se) => {
                    const ke = c.feature(ge);
                    j.updatePaintArray(ue, Se, ke, me, h, y, k);
                  });
                }
                g = !0;
              }
            }
            return g;
          }
          defines() {
            const e = [];
            for (const i in this.binders) {
              const o = this.binders[i];
              (o instanceof ul || o instanceof cl) && e.push(...o.uniformNames.map((c) => `#define HAS_UNIFORM_${c}`));
            }
            return e;
          }
          getBinderAttributes() {
            const e = [];
            for (const i in this.binders) {
              const o = this.binders[i];
              if (o instanceof ss || o instanceof ko || o instanceof Ps) for (let c = 0; c < o.paintVertexAttributes.length; c++) e.push(o.paintVertexAttributes[c].name);
            }
            return e;
          }
          getBinderUniforms() {
            const e = [];
            for (const i in this.binders) {
              const o = this.binders[i];
              if (o instanceof ul || o instanceof cl || o instanceof ko) for (const c of o.uniformNames) e.push(c);
            }
            return e;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(e) {
            const i = [];
            for (const o in this.binders) {
              const c = this.binders[o];
              if (c instanceof ul || c instanceof cl || c instanceof ko) for (const s of c.uniformNames) i.push({ name: s, property: o, binding: c.getBinding(e, s) });
            }
            return i;
          }
          setUniforms(e, i, o, c, s) {
            for (const { name: h, property: y, binding: T } of o) {
              if (this.binders[y].checkUseTheme && this.binders[y] instanceof ul) {
                const k = c.get(`${y}-use-theme`);
                k.isConstant() && (this.binders[y].ignoreLut = k.constantOr("default") === "none");
              }
              this.binders[y].setUniform(e, T, s, c.get(y), h);
            }
          }
          updatePaintBuffers() {
            this._buffers = [];
            for (const e in this.binders) {
              const i = this.binders[e];
              (i instanceof ss || i instanceof ko || i instanceof Ps) && i.paintVertexBuffer && this._buffers.push(i.paintVertexBuffer);
            }
          }
          upload(e) {
            for (const i in this.binders) {
              const o = this.binders[i];
              (o instanceof ss || o instanceof ko || o instanceof Ps) && o.upload(e);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const e in this.binders) {
              const i = this.binders[e];
              (i instanceof ss || i instanceof ko || i instanceof Ps) && i.destroy();
            }
          }
        }
        class Ls {
          constructor(e, i, o = () => !0) {
            this.programConfigurations = {};
            for (const c of e) this.programConfigurations[c.id] = new Rs(c, i, o);
            this.needsUpload = !1, this._featureMap = new ll(), this._featureMapWithoutIds = new ll(), this._bufferOffset = 0, this._idlessCounter = 0;
          }
          populatePaintArrays(e, i, o, c, s, h, y, T) {
            for (const k in this.programConfigurations) this.programConfigurations[k].populatePaintArrays(e, i, c, s, h, y, T);
            i.id !== void 0 ? this._featureMap.add(i.id, o, this._bufferOffset, e) : (this._featureMapWithoutIds.add(this._idlessCounter, o, this._bufferOffset, e), this._idlessCounter += 1), this._bufferOffset = e, this.needsUpload = !0;
          }
          updatePaintArrays(e, i, o, c, s, h, y) {
            for (const T of o) this.needsUpload = this.programConfigurations[T.id].updatePaintArrays(e, this._featureMap, this._featureMapWithoutIds, i, T, c, s, h, y || 0) || this.needsUpload;
          }
          get(e) {
            return this.programConfigurations[e];
          }
          upload(e) {
            if (this.needsUpload) {
              for (const i in this.programConfigurations) this.programConfigurations[i].upload(e);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const e in this.programConfigurations) this.programConfigurations[e].destroy();
          }
        }
        const rf = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-occlusion-opacity": ["occlusion_opacity"], "icon-occlusion-opacity": ["occlusion_opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "symbol-z-offset": ["z_offset"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
        function Pf(a, e) {
          return rf[a] || [a.replace(`${e}-`, "").replace(/-/g, "_")];
        }
        const Rf = { "line-pattern": { source: ra, composite: ra }, "fill-pattern": { source: ra, composite: ra }, "fill-extrusion-pattern": { source: ra, composite: ra }, "line-dasharray": { source: th, composite: th } }, ku = { color: { source: Hl, composite: Is }, number: { source: Tu, composite: Hl } };
        function ch(a, e, i) {
          const o = Rf[a];
          return o && o[i] || ku[e][i];
        }
        Gr(ul, "ConstantBinder"), Gr(cl, "PatternConstantBinder"), Gr(ss, "SourceExpressionBinder"), Gr(Ps, "PatternCompositeBinder"), Gr(ko, "CompositeExpressionBinder"), Gr(Rs, "ProgramConfiguration", { omit: ["_buffers"] }), Gr(Ls, "ProgramConfigurationSet");
        const Ca = Br / Math.PI / 2, hl = 5, wc = 6, Lf = 16383, ql = 64, zu = [ql, 32, 16], no = -Ca, ka = Ca;
        function ao(a, e, i, o = Ca) {
          return i = Ae(i), [a * Math.sin(i) * o, -e * o, a * Math.cos(i) * o];
        }
        function $l(a, e, i) {
          return ao(Math.cos(Ae(a)), Math.sin(Ae(a)), e, i);
        }
        const fl = 63710088e-1, Ec = 2 * Math.PI * fl;
        class qi {
          constructor(e, i) {
            if (isNaN(e) || isNaN(i)) throw new Error(`Invalid LngLat object: (${e}, ${i})`);
            if (this.lng = +e, this.lat = +i, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new qi(bt(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(e) {
            const i = Math.PI / 180, o = this.lat * i, c = e.lat * i, s = Math.sin(o) * Math.sin(c) + Math.cos(o) * Math.cos(c) * Math.cos((e.lng - this.lng) * i);
            return fl * Math.acos(Math.min(s, 1));
          }
          toBounds(e = 0) {
            const i = 360 * e / 40075017, o = i / Math.cos(Math.PI / 180 * this.lat);
            return new Ds({ lng: this.lng - o, lat: this.lat - i }, { lng: this.lng + o, lat: this.lat + i });
          }
          toEcef(e) {
            return $l(this.lat, this.lng, Ca + e * Ca / fl);
          }
          static convert(e) {
            if (e instanceof qi) return e;
            if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new qi(Number(e[0]), Number(e[1]));
            if (!Array.isArray(e) && typeof e == "object" && e !== null) return new qi(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        class Ds {
          constructor(e, i) {
            if (e) if (i) this.setSouthWest(e).setNorthEast(i);
            else if (e.length === 4) {
              const o = e;
              this.setSouthWest([o[0], o[1]]).setNorthEast([o[2], o[3]]);
            } else {
              const o = e;
              this.setSouthWest(o[0]).setNorthEast(o[1]);
            }
          }
          setNorthEast(e) {
            return this._ne = e instanceof qi ? new qi(e.lng, e.lat) : qi.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof qi ? new qi(e.lng, e.lat) : qi.convert(e), this;
          }
          extend(e) {
            const i = this._sw, o = this._ne;
            let c, s;
            if (e instanceof qi) c = e, s = e;
            else {
              if (!(e instanceof Ds)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(Ds.convert(e)) : this.extend(qi.convert(e)) : typeof e == "object" && e !== null && e.hasOwnProperty("lat") && (e.hasOwnProperty("lon") || e.hasOwnProperty("lng")) ? this.extend(qi.convert(e)) : this;
              if (c = e._sw, s = e._ne, !c || !s) return this;
            }
            return i || o ? (i.lng = Math.min(c.lng, i.lng), i.lat = Math.min(c.lat, i.lat), o.lng = Math.max(s.lng, o.lng), o.lat = Math.max(s.lat, o.lat)) : (this._sw = new qi(c.lng, c.lat), this._ne = new qi(s.lng, s.lat)), this;
          }
          getCenter() {
            return new qi((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new qi(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new qi(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: i, lat: o } = qi.convert(e);
            let c = this._sw.lng <= i && i <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (c = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= o && o <= this._ne.lat && c;
          }
          static convert(e) {
            if (e) return e instanceof Ds ? e : new Ds(e);
          }
        }
        const Sc = 0, za = 25.5;
        function hh(a) {
          return Ec * Math.cos(a * Math.PI / 180);
        }
        function ls(a) {
          return (180 + a) / 360;
        }
        function oo(a) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a * Math.PI / 360))) / 360;
        }
        function xn(a, e) {
          return a / hh(e);
        }
        function so(a) {
          return 360 * a - 180;
        }
        function ci(a) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90;
        }
        function Xl(a, e) {
          return a * hh(ci(e));
        }
        const Cn = 85.051129;
        function fh(a) {
          return Math.cos(Ae(ie(a, -Cn, Cn)));
        }
        function Ou(a, e) {
          const i = ie(e, Sc, za), o = Math.pow(2, i);
          return fh(a) * Ec / (512 * o);
        }
        function l(a) {
          return 1 / Math.cos(a * Math.PI / 180);
        }
        function t(a, e = 0) {
          const i = Math.exp(Math.PI * (1 - (a.y + e / Br) / (1 << a.z) * 2));
          return 80150034 * i / (i * i + 1) / Br / (1 << a.z);
        }
        class n {
          constructor(e, i, o = 0) {
            this.x = +e, this.y = +i, this.z = +o;
          }
          static fromLngLat(e, i = 0) {
            const o = qi.convert(e);
            return new n(ls(o.lng), oo(o.lat), xn(i, o.lat));
          }
          toLngLat() {
            return new qi(so(this.x), ci(this.y));
          }
          toAltitude() {
            return Xl(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Ec * l(ci(this.y));
          }
        }
        function u(a, e, i, o, c, s, h, y, T) {
          const k = (e + o) / 2, g = (i + c) / 2, A = new Ye(k, g);
          y(A), function(D, S, R, j, J, ne) {
            const me = R - J, ge = j - ne;
            return Math.abs((j - S) * me - (R - D) * ge) / Math.hypot(me, ge);
          }(A.x, A.y, s.x, s.y, h.x, h.y) >= T ? (u(a, e, i, k, g, s, A, y, T), u(a, k, g, o, c, A, h, y, T)) : a.push(h);
        }
        function d(a, e, i) {
          let o = a[0], c = o.x, s = o.y;
          e(o);
          const h = [o];
          for (let y = 1; y < a.length; y++) {
            const T = a[y], { x: k, y: g } = T;
            e(T), u(h, c, s, k, g, o, T, e, i), c = k, s = g, o = T;
          }
          return h;
        }
        function _(a, e, i, o) {
          if (o(e, i)) {
            const c = e.add(i)._mult(0.5);
            _(a, e, c, o), _(a, c, i, o);
          } else a.push(i);
        }
        function v(a, e) {
          let i = a[0];
          const o = [i];
          for (let c = 1; c < a.length; c++) {
            const s = a[c];
            _(o, i, s, e), i = s;
          }
          return o;
        }
        const L = Math.pow(2, 14) - 1, G = -L - 1;
        function X(a, e) {
          const i = Math.round(a.x * e), o = Math.round(a.y * e);
          return a.x = ie(i, G, L), a.y = ie(o, G, L), (i < a.x || i > a.x + 1 || o < a.y || o > a.y + 1) && Tt("Geometry exceeds allowed extent, reduce your vector tile buffer size"), a;
        }
        function K(a, e, i) {
          const o = a.loadGeometry(), c = a.extent, s = Br / c;
          if (e && i && i.projection.isReprojectedInTileSpace) {
            const h = 1 << e.z, { scale: y, x: T, y: k, projection: g } = i, A = (D) => {
              const S = so((e.x + D.x / c) / h), R = ci((e.y + D.y / c) / h), j = g.project(S, R);
              D.x = (j.x * y - T) * c, D.y = (j.y * y - k) * c;
            };
            for (let D = 0; D < o.length; D++) if (a.type !== 1) o[D] = d(o[D], A, 1);
            else {
              const S = [];
              for (const R of o[D]) R.x < 0 || R.x >= c || R.y < 0 || R.y >= c || (A(R), S.push(R));
              o[D] = S;
            }
          }
          for (const h of o) for (const y of h) X(y, s);
          return o;
        }
        function ae(a, e) {
          return { type: a.type, id: a.id, properties: a.properties, geometry: e ? K(a) : [] };
        }
        function oe(a, e, i, o, c) {
          a.emplaceBack(2 * e + (o + 1) / 2, 2 * i + (c + 1) / 2);
        }
        function pe(a, e, i) {
          a.emplaceBack(e.x, e.y, e.z, i[0] * 16384, i[1] * 16384, i[2] * 16384);
        }
        class Be {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((i) => i.fqid), this.index = e.index, this.hasPattern = !1, this.projection = e.projection, this.layoutVertexArray = new Ga(), this.indexArray = new ha(), this.segments = new Nn(), this.programConfigurations = new Ls(e.layers, { zoom: e.zoom, lut: e.lut }), this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id);
          }
          updateFootprints(e, i) {
          }
          populate(e, i, o, c) {
            const s = this.layers[0], h = [];
            let y = null;
            s.type === "circle" && (y = s.layout.get("circle-sort-key"));
            for (const { feature: k, id: g, index: A, sourceLayerIndex: D } of e) {
              const S = this.layers[0]._featureFilter.needGeometry, R = ae(k, S);
              if (!this.layers[0]._featureFilter.filter(new sn(this.zoom), R, o)) continue;
              const j = y ? y.evaluate(R, {}, o) : void 0, J = { id: g, properties: k.properties, type: k.type, sourceLayerIndex: D, index: A, geometry: S ? R.geometry : K(k, o, c), patterns: {}, sortKey: j };
              h.push(J);
            }
            y && h.sort((k, g) => k.sortKey - g.sortKey);
            let T = null;
            c.projection.name === "globe" && (this.globeExtVertexArray = new ca(), T = c.projection);
            for (const k of h) {
              const { geometry: g, index: A, sourceLayerIndex: D } = k, S = e[A].feature;
              this.addFeature(k, g, A, i.availableImages, o, T, i.brightness), i.featureIndex.insert(S, g, A, D, this.index);
            }
          }
          update(e, i, o, c, s, h, y) {
            this.programConfigurations.updatePaintArrays(e, i, s, o, c, h, y);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, sh.members), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, pd.members))), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
          }
          addFeature(e, i, o, c, s, h, y) {
            for (const T of i) for (const k of T) {
              const g = k.x, A = k.y;
              if (g < 0 || g >= Br || A < 0 || A >= Br) continue;
              if (h) {
                const R = h.projectTilePoint(g, A, s), j = h.upVector(s, g, A), J = this.globeExtVertexArray;
                pe(J, R, j), pe(J, R, j), pe(J, R, j), pe(J, R, j);
              }
              const D = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), S = D.vertexLength;
              oe(this.layoutVertexArray, g, A, -1, -1), oe(this.layoutVertexArray, g, A, 1, -1), oe(this.layoutVertexArray, g, A, 1, 1), oe(this.layoutVertexArray, g, A, -1, 1), this.indexArray.emplaceBack(S, S + 1, S + 2), this.indexArray.emplaceBack(S, S + 2, S + 3), D.vertexLength += 4, D.primitiveLength += 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, {}, c, s, y);
          }
        }
        function Re(a, e) {
          for (let i = 0; i < a.length; i++) if (dt(e, a[i])) return !0;
          for (let i = 0; i < e.length; i++) if (dt(a, e[i])) return !0;
          return !!ut(a, e);
        }
        function Ge(a, e, i) {
          return !!dt(a, e) || !!xt(e, a, i);
        }
        function Ve(a, e) {
          if (a.length === 1) return _t(e, a[0]);
          for (let i = 0; i < e.length; i++) {
            const o = e[i];
            for (let c = 0; c < o.length; c++) if (dt(a, o[c])) return !0;
          }
          for (let i = 0; i < a.length; i++) if (_t(e, a[i])) return !0;
          for (let i = 0; i < e.length; i++) if (ut(a, e[i])) return !0;
          return !1;
        }
        function et(a, e, i) {
          if (a.length > 1) {
            if (ut(a, e)) return !0;
            for (let o = 0; o < e.length; o++) if (xt(e[o], a, i)) return !0;
          }
          for (let o = 0; o < a.length; o++) if (xt(a[o], e, i)) return !0;
          return !1;
        }
        function ut(a, e) {
          if (a.length === 0 || e.length === 0) return !1;
          for (let i = 0; i < a.length - 1; i++) {
            const o = a[i], c = a[i + 1];
            for (let s = 0; s < e.length - 1; s++) if (st(o, c, e[s], e[s + 1])) return !0;
          }
          return !1;
        }
        function st(a, e, i, o) {
          return Gt(a, i, o) !== Gt(e, i, o) && Gt(a, e, i) !== Gt(a, e, o);
        }
        function xt(a, e, i) {
          const o = i * i;
          if (e.length === 1) return a.distSqr(e[0]) < o;
          for (let c = 1; c < e.length; c++) if (mt(a, e[c - 1], e[c]) < o) return !0;
          return !1;
        }
        function mt(a, e, i) {
          const o = e.distSqr(i);
          if (o === 0) return a.distSqr(e);
          const c = ((a.x - e.x) * (i.x - e.x) + (a.y - e.y) * (i.y - e.y)) / o;
          return a.distSqr(c < 0 ? e : c > 1 ? i : i.sub(e)._mult(c)._add(e));
        }
        function _t(a, e) {
          let i, o, c, s = !1;
          for (let h = 0; h < a.length; h++) {
            i = a[h];
            for (let y = 0, T = i.length - 1; y < i.length; T = y++) o = i[y], c = i[T], o.y > e.y != c.y > e.y && e.x < (c.x - o.x) * (e.y - o.y) / (c.y - o.y) + o.x && (s = !s);
          }
          return s;
        }
        function dt(a, e) {
          let i = !1;
          for (let o = 0, c = a.length - 1; o < a.length; c = o++) {
            const s = a[o], h = a[c];
            s.y > e.y != h.y > e.y && e.x < (h.x - s.x) * (e.y - s.y) / (h.y - s.y) + s.x && (i = !i);
          }
          return i;
        }
        function gt(a, e, i, o, c) {
          for (const h of a) if (e <= h.x && i <= h.y && o >= h.x && c >= h.y) return !0;
          const s = [new Ye(e, i), new Ye(e, c), new Ye(o, c), new Ye(o, i)];
          if (a.length > 2) {
            for (const h of s) if (dt(a, h)) return !0;
          }
          for (let h = 0; h < a.length - 1; h++) if (Rt(a[h], a[h + 1], s)) return !0;
          return !1;
        }
        function Rt(a, e, i) {
          const o = i[0], c = i[2];
          if (a.x < o.x && e.x < o.x || a.x > c.x && e.x > c.x || a.y < o.y && e.y < o.y || a.y > c.y && e.y > c.y) return !1;
          const s = Gt(a, e, i[0]);
          return s !== Gt(a, e, i[1]) || s !== Gt(a, e, i[2]) || s !== Gt(a, e, i[3]);
        }
        function Jt(a, e, i, o, c, s) {
          let h = e.y - a.y, y = a.x - e.x;
          if (s = s || 0) {
            const T = h * h + y * y;
            if (T === 0) return !0;
            const k = Math.sqrt(T);
            h /= k, y /= k;
          }
          return !((i.x - a.x) * h + (i.y - a.y) * y - s < 0 || (o.x - a.x) * h + (o.y - a.y) * y - s < 0 || (c.x - a.x) * h + (c.y - a.y) * y - s < 0);
        }
        function Vt(a, e, i, o, c, s, h) {
          return !(Jt(a, e, o, c, s, h) || Jt(e, i, o, c, s, h) || Jt(i, a, o, c, s, h) || Jt(o, c, a, e, i, h) || Jt(c, s, a, e, i, h) || Jt(s, o, a, e, i, h));
        }
        function or(a, e, i) {
          const o = e.paint.get(a).value;
          return o.kind === "constant" ? o.value : i.programConfigurations.get(e.id).getMaxValue(a);
        }
        function sr(a) {
          return Math.sqrt(a[0] * a[0] + a[1] * a[1]);
        }
        function Bt(a, e, i, o, c) {
          if (!e[0] && !e[1]) return a;
          const s = Ye.convert(e)._mult(c);
          i === "viewport" && s._rotate(-o);
          const h = [];
          for (let y = 0; y < a.length; y++) h.push(a[y].sub(s));
          return h;
        }
        function rr(a, e, i, o) {
          const c = Ye.convert(a)._mult(o);
          return e === "viewport" && c._rotate(-i), c;
        }
        let gr, Ut;
        Gr(Be, "CircleBucket", { omit: ["layers"] });
        var dr, ir = { exports: {} }, Tr = (dr || (dr = 1, function(a, e) {
          (function(i) {
            function o(s, h, y) {
              var T = c(256 * s, 256 * (h = Math.pow(2, y) - h - 1), y), k = c(256 * (s + 1), 256 * (h + 1), y);
              return T[0] + "," + T[1] + "," + k[0] + "," + k[1];
            }
            function c(s, h, y) {
              var T = 2 * Math.PI * 6378137 / 256 / Math.pow(2, y);
              return [s * T - 2 * Math.PI * 6378137 / 2, h * T - 2 * Math.PI * 6378137 / 2];
            }
            i.getURL = function(s, h, y, T, k, g) {
              return g = g || {}, s + "?" + ["bbox=" + o(y, T, k), "format=" + (g.format || "image/png"), "service=" + (g.service || "WMS"), "version=" + (g.version || "1.1.1"), "request=" + (g.request || "GetMap"), "srs=" + (g.srs || "EPSG:3857"), "width=" + (g.width || 256), "height=" + (g.height || 256), "layers=" + h].join("&");
            }, i.getTileBBox = o, i.getMercCoords = c, Object.defineProperty(i, "__esModule", { value: !0 });
          })(e);
        }(0, ir.exports)), ir.exports);
        class mr {
          constructor(e, i, o) {
            this.z = e, this.x = i, this.y = o, this.key = Cr(0, e, e, i, o);
          }
          equals(e) {
            return this.z === e.z && this.x === e.x && this.y === e.y;
          }
          url(e, i) {
            const o = Tr.getTileBBox(this.x, this.y, this.z), c = function(s, h, y) {
              let T, k = "";
              for (let g = s; g > 0; g--) T = 1 << g - 1, k += (h & T ? 1 : 0) + (y & T ? 2 : 0);
              return k;
            }(this.z, this.x, this.y);
            return e[(this.x + this.y) % e.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", c).replace("{bbox-epsg-3857}", o);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class hr {
          constructor(e, i) {
            this.wrap = e, this.canonical = i, this.key = Cr(e, i.z, i.z, i.x, i.y);
          }
        }
        class br {
          constructor(e, i, o, c, s) {
            this.overscaledZ = e, this.wrap = i, this.canonical = new mr(o, +c, +s), this.key = i === 0 && e === o ? this.canonical.key : Cr(i, e, o, c, s);
          }
          equals(e) {
            return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
          }
          scaledTo(e) {
            const i = this.canonical.z - e;
            return e > this.canonical.z ? new br(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new br(e, this.wrap, e, this.canonical.x >> i, this.canonical.y >> i);
          }
          calculateScaledKey(e, i = !0) {
            if (this.overscaledZ === e && i) return this.key;
            if (e > this.canonical.z) return Cr(this.wrap * +i, e, this.canonical.z, this.canonical.x, this.canonical.y);
            {
              const o = this.canonical.z - e;
              return Cr(this.wrap * +i, e, e, this.canonical.x >> o, this.canonical.y >> o);
            }
          }
          isChildOf(e) {
            if (e.wrap !== this.wrap) return !1;
            const i = this.canonical.z - e.canonical.z;
            return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.z < this.canonical.z && e.canonical.x === this.canonical.x >> i && e.canonical.y === this.canonical.y >> i;
          }
          children(e) {
            if (this.overscaledZ >= e) return [new br(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const i = this.canonical.z + 1, o = 2 * this.canonical.x, c = 2 * this.canonical.y;
            return [new br(i, this.wrap, i, o, c), new br(i, this.wrap, i, o + 1, c), new br(i, this.wrap, i, o, c + 1), new br(i, this.wrap, i, o + 1, c + 1)];
          }
          isLessThan(e) {
            return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
          }
          wrapped() {
            return new br(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(e) {
            return new br(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new hr(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
        }
        function Cr(a, e, i, o, c) {
          const s = 1 << Math.min(i, 22);
          let h = s * (c % s) + o % s;
          return a && i < 22 && (h += s * s * ((a < 0 ? -2 * a - 1 : 2 * a) % (1 << 2 * (22 - i)))), 16 * (32 * h + i) + (e - i);
        }
        const Hr = [(a) => {
          let e = a.canonical.x - 1, i = a.wrap;
          return e < 0 && (e = (1 << a.canonical.z) - 1, i--), new br(a.overscaledZ, i, a.canonical.z, e, a.canonical.y);
        }, (a) => {
          let e = a.canonical.x + 1, i = a.wrap;
          return e === 1 << a.canonical.z && (e = 0, i++), new br(a.overscaledZ, i, a.canonical.z, e, a.canonical.y);
        }, (a) => new br(a.overscaledZ, a.wrap, a.canonical.z, a.canonical.x, (a.canonical.y === 0 ? 1 << a.canonical.z : a.canonical.y) - 1), (a) => new br(a.overscaledZ, a.wrap, a.canonical.z, a.canonical.x, a.canonical.y === (1 << a.canonical.z) - 1 ? 0 : a.canonical.y + 1)];
        Gr(mr, "CanonicalTileID"), Gr(br, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
        const Zr = Yi([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: mi } = Zr, ii = Yi([{ name: "a_pos_3", components: 3, type: "Int16" }]);
        var oi = Yi([{ name: "a_pos", type: "Int16", components: 2 }]);
        class yi {
          constructor(e, i) {
            this.pos = e, this.dir = i;
          }
          intersectsPlane(e, i, o) {
            const c = Oe.vec3.dot(i, this.dir);
            if (Math.abs(c) < 1e-6) return !1;
            const s = ((e[0] - this.pos[0]) * i[0] + (e[1] - this.pos[1]) * i[1] + (e[2] - this.pos[2]) * i[2]) / c;
            return o[0] = this.pos[0] + this.dir[0] * s, o[1] = this.pos[1] + this.dir[1] * s, o[2] = this.pos[2] + this.dir[2] * s, !0;
          }
          closestPointOnSphere(e, i, o) {
            if (Oe.vec3.equals(this.pos, e) || i === 0) return o[0] = o[1] = o[2] = 0, !1;
            const [c, s, h] = this.dir, y = this.pos[0] - e[0], T = this.pos[1] - e[1], k = this.pos[2] - e[2], g = c * c + s * s + h * h, A = 2 * (y * c + T * s + k * h), D = A * A - 4 * g * (y * y + T * T + k * k - i * i);
            if (D < 0) {
              const S = Math.max(-A / 2, 0), R = y + c * S, j = T + s * S, J = k + h * S, ne = Math.hypot(R, j, J);
              return o[0] = R * i / ne, o[1] = j * i / ne, o[2] = J * i / ne, !1;
            }
            {
              const S = (-A - Math.sqrt(D)) / (2 * g);
              if (S < 0) {
                const R = Math.hypot(y, T, k);
                return o[0] = y * i / R, o[1] = T * i / R, o[2] = k * i / R, !1;
              }
              return o[0] = y + c * S, o[1] = T + s * S, o[2] = k + h * S, !0;
            }
          }
        }
        class Ui {
          constructor(e, i, o, c, s) {
            this.TL = e, this.TR = i, this.BR = o, this.BL = c, this.horizon = s;
          }
          static fromInvProjectionMatrix(e, i, o) {
            const c = [-1, 1, 1], s = [1, 1, 1], h = [1, -1, 1], y = [-1, -1, 1], T = Oe.vec3.transformMat4(c, c, e), k = Oe.vec3.transformMat4(s, s, e), g = Oe.vec3.transformMat4(h, h, e), A = Oe.vec3.transformMat4(y, y, e);
            return new Ui(T, k, g, A, i / o);
          }
        }
        function tn(a, e, i) {
          let o = 1 / 0, c = -1 / 0;
          const s = [];
          for (const h of a) {
            Oe.vec3.sub(s, h, e);
            const y = Oe.vec3.dot(s, i);
            o = Math.min(o, y), c = Math.max(c, y);
          }
          return [o, c];
        }
        function bn(a, e) {
          let i = !0;
          for (let o = 0; o < a.planes.length; o++) {
            const c = a.planes[o];
            let s = 0;
            for (let h = 0; h < e.length; h++) s += Oe.vec3.dot(c, e[h]) + c[3] >= 0;
            if (s === 0) return 0;
            s !== e.length && (i = !1);
          }
          return i ? 2 : 1;
        }
        function $i(a, e) {
          for (const i of a.projections) {
            const o = tn(e, a.points[0], i.axis);
            if (i.projection[1] < o[0] || i.projection[0] > o[1]) return 0;
          }
          return 1;
        }
        function xi(a, e) {
          let i = 0;
          const o = [0, 0, 0, 0];
          for (let c = 0; c < a.length; c++) o[0] = a[c][0], o[1] = a[c][1], o[2] = a[c][2], o[3] = 1, Oe.vec4.dot(o, e) >= 0 && i++;
          return i;
        }
        class Di {
          constructor(e, i) {
            this.points = e || new Array(8).fill([0, 0, 0]), this.planes = i || new Array(6).fill([0, 0, 0, 0]), this.bounds = Yr.fromPoints(this.points), this.projections = [], this.frustumEdges = [Oe.vec3.sub([], this.points[2], this.points[3]), Oe.vec3.sub([], this.points[0], this.points[3]), Oe.vec3.sub([], this.points[4], this.points[0]), Oe.vec3.sub([], this.points[5], this.points[1]), Oe.vec3.sub([], this.points[6], this.points[2]), Oe.vec3.sub([], this.points[7], this.points[3])];
            for (const o of this.frustumEdges) {
              const c = [0, -o[2], o[1]], s = [o[2], 0, -o[0]];
              this.projections.push({ axis: c, projection: tn(this.points, this.points[0], c) }), this.projections.push({ axis: s, projection: tn(this.points, this.points[0], s) });
            }
          }
          static fromInvProjectionMatrix(e, i, o, c) {
            const s = Math.pow(2, o), h = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((k) => {
              const g = Oe.vec4.transformMat4([], k, e), A = 1 / g[3] / i * s;
              return Oe.vec4.mul(g, g, [A, A, c ? 1 / g[3] : A, A]);
            }), y = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((k) => {
              const g = Oe.vec3.sub([], h[k[0]], h[k[1]]), A = Oe.vec3.sub([], h[k[2]], h[k[1]]), D = Oe.vec3.normalize([], Oe.vec3.cross([], g, A)), S = -Oe.vec3.dot(D, h[k[1]]);
              return D.concat(S);
            }), T = [];
            for (let k = 0; k < h.length; k++) T.push([h[k][0], h[k][1], h[k][2]]);
            return new Di(T, y);
          }
          intersectsPrecise(e, i, o) {
            for (let c = 0; c < i.length; c++) if (!xi(e, i[c])) return 0;
            for (let c = 0; c < this.planes.length; c++) if (!xi(e, this.planes[c])) return 0;
            for (const c of o) for (const s of this.frustumEdges) {
              const h = Oe.vec3.cross([], c, s), y = Oe.vec3.length(h);
              if (y === 0) continue;
              Oe.vec3.scale(h, h, 1 / y);
              const T = tn(this.points, this.points[0], h), k = tn(e, this.points[0], h);
              if (T[0] > k[1] || k[0] > T[1]) return 0;
            }
            return 1;
          }
          containsPoint(e) {
            for (const i of this.planes) {
              const o = i[3];
              if (Oe.vec3.dot([i[0], i[1], i[2]], e) + o < 0) return !1;
            }
            return !0;
          }
        }
        class Yr {
          static fromPoints(e) {
            const i = [1 / 0, 1 / 0, 1 / 0], o = [-1 / 0, -1 / 0, -1 / 0];
            for (const c of e) Oe.vec3.min(i, i, c), Oe.vec3.max(o, o, c);
            return new Yr(i, o);
          }
          static fromTileIdAndHeight(e, i, o) {
            const c = 1 << e.canonical.z, s = e.canonical.x, h = e.canonical.y;
            return new Yr([s / c, h / c, i], [(s + 1) / c, (h + 1) / c, o]);
          }
          static applyTransform(e, i) {
            const o = e.getCorners();
            for (let c = 0; c < o.length; ++c) Oe.vec3.transformMat4(o[c], o[c], i);
            return Yr.fromPoints(o);
          }
          static applyTransformFast(e, i) {
            const o = [i[12], i[13], i[14]], c = [...o];
            for (let s = 0; s < 3; s++) for (let h = 0; h < 3; h++) {
              const y = i[4 * h + s], T = y * e.min[h], k = y * e.max[h];
              o[s] += Math.min(T, k), c[s] += Math.max(T, k);
            }
            return new Yr(o, c);
          }
          static projectAabbCorners(e, i) {
            const o = e.getCorners();
            for (let c = 0; c < o.length; ++c) Oe.vec3.transformMat4(o[c], o[c], i);
            return o;
          }
          constructor(e, i) {
            this.min = e, this.max = i, this.center = Oe.vec3.scale([], Oe.vec3.add([], this.min, this.max), 0.5);
          }
          quadrant(e) {
            const i = [e % 2 == 0, e < 2], o = Oe.vec3.clone(this.min), c = Oe.vec3.clone(this.max);
            for (let s = 0; s < i.length; s++) o[s] = i[s] ? this.min[s] : this.center[s], c[s] = i[s] ? this.center[s] : this.max[s];
            return c[2] = this.max[2], new Yr(o, c);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          distanceZ(e) {
            return Math.max(Math.min(this.max[2], e[2]), this.min[2]) - e[2];
          }
          getCorners() {
            const e = this.min, i = this.max;
            return [[e[0], e[1], e[2]], [i[0], e[1], e[2]], [i[0], i[1], e[2]], [e[0], i[1], e[2]], [e[0], e[1], i[2]], [i[0], e[1], i[2]], [i[0], i[1], i[2]], [e[0], i[1], i[2]]];
          }
          intersects(e) {
            return this.intersectsAabb(e.bounds) ? bn(e, this.getCorners()) : 0;
          }
          intersectsFlat(e) {
            return this.intersectsAabb(e.bounds) ? bn(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
          }
          intersectsPrecise(e, i) {
            return i || this.intersects(e) ? $i(e, this.getCorners()) : 0;
          }
          intersectsPreciseFlat(e, i) {
            return i || this.intersectsFlat(e) ? $i(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
          }
          intersectsAabb(e) {
            for (let i = 0; i < 3; ++i) if (this.min[i] > e.max[i] || e.min[i] > this.max[i]) return !1;
            return !0;
          }
          intersectsAabbXY(e) {
            return !(this.min[0] > e.max[0] || e.min[0] > this.max[0] || this.min[1] > e.max[1] || e.min[1] > this.max[1]);
          }
          encapsulate(e) {
            for (let i = 0; i < 3; i++) this.min[i] = Math.min(this.min[i], e.min[i]), this.max[i] = Math.max(this.max[i], e.max[i]);
          }
          encapsulatePoint(e) {
            for (let i = 0; i < 3; i++) this.min[i] = Math.min(this.min[i], e[i]), this.max[i] = Math.max(this.max[i], e[i]);
          }
          closestPoint(e) {
            return [Math.max(Math.min(this.max[0], e[0]), this.min[0]), Math.max(Math.min(this.max[1], e[1]), this.min[1]), Math.max(Math.min(this.max[2], e[2]), this.min[2])];
          }
        }
        function Fi(a) {
          return a * Ca / fl;
        }
        Gr(Yr, "Aabb");
        const Ki = [new Yr([no, no, no], [ka, ka, ka]), new Yr([no, no, no], [0, 0, ka]), new Yr([0, no, no], [ka, 0, ka]), new Yr([no, 0, no], [0, ka, ka]), new Yr([0, 0, no], [ka, ka, ka])];
        function Qi(a, e, i, o = !0) {
          const c = Oe.vec3.scale([], a._camera.position, a.worldSize), s = [e, i, 1, 1];
          Oe.vec4.transformMat4(s, s, a.pixelMatrixInverse), Oe.vec4.scale(s, s, 1 / s[3]);
          const h = Oe.vec3.sub([], s, c), y = Oe.vec3.normalize([], h), T = a.globeMatrix, k = [T[12], T[13], T[14]], g = Oe.vec3.sub([], k, c), A = Oe.vec3.length(g), D = Oe.vec3.normalize([], g), S = a.worldSize / (2 * Math.PI), R = Oe.vec3.dot(D, y), j = Math.asin(S / A);
          if (j < Math.acos(R)) {
            if (!o) return null;
            const Et = [], lt = [];
            Oe.vec3.scale(Et, y, A / R), Oe.vec3.normalize(lt, Oe.vec3.sub(lt, Et, g)), Oe.vec3.normalize(y, Oe.vec3.add(y, g, Oe.vec3.scale(y, lt, Math.tan(j) * A)));
          }
          const J = [];
          new yi(c, y).closestPointOnSphere(k, S, J);
          const ne = Oe.vec3.normalize([], ni(T, 0)), me = Oe.vec3.normalize([], ni(T, 1)), ge = Oe.vec3.normalize([], ni(T, 2)), ue = Oe.vec3.dot(ne, J), Se = Oe.vec3.dot(me, J), ke = Oe.vec3.dot(ge, J), He = _e(Math.asin(-Se / S));
          let at = _e(Math.atan2(ue, ke));
          at = a.center.lng + function(Et, lt) {
            const St = (lt - Et + 180) % 360 - 180;
            return St < -180 ? St + 360 : St;
          }(a.center.lng, at);
          const nt = ls(at), tt = ie(oo(He), 0, 1);
          return new n(nt, tt);
        }
        class Mn {
          constructor(e, i, o) {
            this.a = Oe.vec3.sub([], e, o), this.b = Oe.vec3.sub([], i, o), this.center = o;
            const c = Oe.vec3.normalize([], this.a), s = Oe.vec3.normalize([], this.b);
            this.angle = Math.acos(Oe.vec3.dot(c, s));
          }
        }
        function Pn(a, e) {
          if (a.angle === 0) return null;
          let i;
          return i = a.a[e] === 0 ? 1 / a.angle * 0.5 * Math.PI : 1 / a.angle * Math.atan(a.b[e] / a.a[e] / Math.sin(a.angle) - 1 / Math.tan(a.angle)), i < 0 || i > 1 ? null : function(o, c, s, h) {
            const y = Math.sin(s);
            return o * (Math.sin((1 - h) * s) / y) + c * (Math.sin(h * s) / y);
          }(a.a[e], a.b[e], a.angle, ie(i, 0, 1)) + a.center[e];
        }
        function Zn(a) {
          if (a.z <= 1) return Ki[a.z + 2 * a.y + a.x];
          const e = hn(pn(a));
          return Yr.fromPoints(e);
        }
        function jn(a, e, i) {
          return Oe.vec3.scale(a, a, 1 - i), Oe.vec3.scaleAndAdd(a, a, e, i);
        }
        function ya(a, e, i) {
          for (const o of a) Oe.vec3.transformMat4(o, o, e), Oe.vec3.scale(o, o, i);
        }
        function va(a, e, i, o) {
          const c = e / a.worldSize, s = a.globeMatrix;
          if (i.z <= 1) {
            const nt = Zn(i).getCorners();
            return ya(nt, s, c), Yr.fromPoints(nt);
          }
          const h = pn(i, o), y = hn(h, Ca + Fi(a._tileCoverLift));
          ya(y, s, c);
          const T = Number.MAX_VALUE, k = [-T, -T, -T], g = [T, T, T];
          if (h.contains(a.center)) {
            for (const Et of y) Oe.vec3.min(g, g, Et), Oe.vec3.max(k, k, Et);
            k[2] = 0;
            const nt = a.point, tt = [nt.x * c, nt.y * c, 0];
            return Oe.vec3.min(g, g, tt), Oe.vec3.max(k, k, tt), new Yr(g, k);
          }
          if (a._tileCoverLift > 0) {
            for (const nt of y) Oe.vec3.min(g, g, nt), Oe.vec3.max(k, k, nt);
            return new Yr(g, k);
          }
          const A = [s[12] * c, s[13] * c, s[14] * c], D = h.getCenter(), S = ie(a.center.lat, -Cn, Cn), R = ie(D.lat, -Cn, Cn), j = ls(a.center.lng), J = oo(S);
          let ne = j - ls(D.lng);
          const me = J - oo(R);
          ne > 0.5 ? ne -= 1 : ne < -0.5 && (ne += 1);
          let ge = 0;
          if (Math.abs(ne) > Math.abs(me)) ge = ne >= 0 ? 1 : 3;
          else {
            ge = me >= 0 ? 0 : 2;
            const nt = [s[4] * c, s[5] * c, s[6] * c], tt = -Math.sin(Ae(me >= 0 ? h.getSouth() : h.getNorth())) * Ca;
            Oe.vec3.scaleAndAdd(A, A, nt, tt);
          }
          const ue = y[ge], Se = y[(ge + 1) % 4], ke = new Mn(ue, Se, A), He = [Pn(ke, 0) || ue[0], Pn(ke, 1) || ue[1], Pn(ke, 2) || ue[2]], at = Wa(a.zoom);
          if (at > 0) {
            const nt = function({ x: Et, y: lt, z: St }, Lt, It, zt, Ft) {
              const qt = 1 / (1 << St);
              let Ot = Et * qt, cr = Ot + qt, yr = lt * qt, ur = yr + qt, jr = 0;
              const zr = (Ot + cr) / 2 - zt;
              return zr > 0.5 ? jr = -1 : zr < -0.5 && (jr = 1), Ot = ((Ot + jr) * Lt - (zt *= Lt)) * It + zt, cr = ((cr + jr) * Lt - zt) * It + zt, yr = (yr * Lt - (Ft *= Lt)) * It + Ft, ur = (ur * Lt - Ft) * It + Ft, [[Ot, ur, 0], [cr, ur, 0], [cr, yr, 0], [Ot, yr, 0]];
            }(i, e, a._pixelsPerMercatorPixel, j, J);
            for (let Et = 0; Et < y.length; Et++) jn(y[Et], nt[Et], at);
            const tt = Oe.vec3.add([], nt[ge], nt[(ge + 1) % 4]);
            Oe.vec3.scale(tt, tt, 0.5), jn(He, tt, at);
          }
          for (const nt of y) Oe.vec3.min(g, g, nt), Oe.vec3.max(k, k, nt);
          return g[2] = Math.min(ue[2], Se[2]), Oe.vec3.min(g, g, He), Oe.vec3.max(k, k, He), new Yr(g, k);
        }
        function pn({ x: a, y: e, z: i }, o = !1) {
          const c = 1 / (1 << i), s = new qi(so(a * c), e === (1 << i) - 1 && o ? -90 : ci((e + 1) * c)), h = new qi(so((a + 1) * c), e === 0 && o ? 90 : ci(e * c));
          return new Ds(s, h);
        }
        function hn(a, e = Ca) {
          const i = Ae(a.getNorth()), o = Ae(a.getSouth()), c = Math.cos(i), s = Math.cos(o), h = Math.sin(i), y = Math.sin(o), T = a.getWest(), k = a.getEast();
          return [ao(s, y, T, e), ao(s, y, k, e), ao(c, h, k, e), ao(c, h, T, e)];
        }
        function ln(a, e, i, o) {
          const c = 1 << i.z, s = (a / Br + i.x) / c;
          return $l(ci((e / Br + i.y) / c), so(s), o);
        }
        function Vi({ min: a, max: e }) {
          return Lf / Math.max(e[0] - a[0], e[1] - a[1], e[2] - a[2]);
        }
        const Rn = new Float64Array(16);
        function ia(a) {
          const e = Vi(a), i = Oe.mat4.fromScaling(Rn, [e, e, e]);
          return Oe.mat4.translate(i, i, Oe.vec3.negate([], a.min));
        }
        function fn(a) {
          const e = Oe.mat4.fromTranslation(Rn, a.min), i = 1 / Vi(a);
          return Oe.mat4.scale(e, e, [i, i, i]);
        }
        function wa(a) {
          const e = Br / (2 * Math.PI);
          return a / (2 * Math.PI) / e;
        }
        function xo(a, e) {
          return Br / (512 * Math.pow(2, a)) * Vi(Zn(e));
        }
        function fa(a, e, i, o, c) {
          const s = wa(i), h = [a, e, -i / (2 * Math.PI)], y = Oe.mat4.identity(new Float64Array(16));
          return Oe.mat4.translate(y, y, h), Oe.mat4.scale(y, y, [s, s, s]), Oe.mat4.rotateX(y, y, Ae(-c)), Oe.mat4.rotateY(y, y, Ae(-o)), y;
        }
        function Wa(a) {
          return Xe(hl, wc, a);
        }
        function Za(a, e) {
          const i = $l(e.lat, e.lng), o = function(s) {
            const h = $l(s._center.lat, s._center.lng), y = Oe.vec3.fromValues(0, 1, 0);
            let T = Oe.vec3.cross([], y, h);
            const k = Oe.mat4.fromRotation([], -s.angle, h);
            T = Oe.vec3.transformMat4(T, T, k), Oe.mat4.fromRotation(k, -s._pitch, T);
            const g = Oe.vec3.normalize([], h);
            return Oe.vec3.scale(g, g, Fi(s.cameraToCenterDistance / s.pixelsPerMeter)), Oe.vec3.transformMat4(g, g, k), Oe.vec3.add([], h, g);
          }(a), c = Oe.vec3.subtract([], o, i);
          return Oe.vec3.angle(c, i);
        }
        function bo(a, e) {
          return Za(a, e) > Math.PI / 2 * 1.01;
        }
        const mn = Ae(85), Yl = Math.cos(mn), Vo = Math.sin(mn), Kl = Oe.mat4.create(), Bu = (a) => {
          const e = [];
          return a.paint.get("circle-pitch-alignment") === "map" && e.push("PITCH_WITH_MAP"), a.paint.get("circle-pitch-scale") === "map" && e.push("SCALE_WITH_MAP"), e;
        };
        function Tc(a, e, i, o, c, s, h, y, T) {
          if (s && a.queryGeometry.isAboveHorizon) return !1;
          s && (T *= a.pixelToTileUnitsFactor);
          const k = a.tileID.canonical, g = i.projection.upVectorScale(k, i.center.lat, i.worldSize).metersToTile;
          for (const A of e) for (const D of A) {
            const S = D.add(y), R = c && i.elevation ? i.elevation.exaggeration() * c.getElevationAt(S.x, S.y, !0) : 0, j = i.projection.projectTilePoint(S.x, S.y, k);
            if (R > 0) {
              const ge = i.projection.upVector(k, S.x, S.y);
              j.x += ge[0] * g * R, j.y += ge[1] * g * R, j.z += ge[2] * g * R;
            }
            const J = s ? S : dh(j.x, j.y, j.z, o), ne = s ? a.tilespaceRays.map((ge) => _d(ge, R)) : a.queryGeometry.screenGeometry, me = Oe.vec4.transformMat4([], [j.x, j.y, j.z, 1], o);
            if (!h && s ? T *= me[3] / i.cameraToCenterDistance : h && !s && (T *= i.cameraToCenterDistance / me[3]), s) {
              const ge = ci((D.y / Br + k.y) / (1 << k.z));
              T /= i.projection.pixelsPerMeter(ge, 1) / xn(1, ge);
            }
            if (Ge(ne, J, T)) return !0;
          }
          return !1;
        }
        function dh(a, e, i, o) {
          const c = Oe.vec4.transformMat4([], [a, e, i, 1], o);
          return new Ye(c[0] / c[3], c[1] / c[3]);
        }
        const Kd = Oe.vec3.fromValues(0, 0, 0), us = Oe.vec3.fromValues(0, 0, 1);
        function _d(a, e) {
          const i = Oe.vec3.create();
          return Kd[2] = e, a.intersectsPlane(Kd, us, i), new Ye(i[0], i[1]);
        }
        class Jd extends Be {
        }
        let Jl, nf, Fu, af;
        function Df(a, { width: e, height: i }, o, c) {
          if (c) {
            if (c instanceof Uint8ClampedArray) c = new Uint8Array(c.buffer);
            else if (c.length !== e * i * o) throw new RangeError("mismatched image size");
          } else c = new Uint8Array(e * i * o);
          return a.width = e, a.height = i, a.data = c, a;
        }
        function kf(a, e, i) {
          const { width: o, height: c } = e;
          o === a.width && c === a.height || (gd(a, e, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(a.width, o), height: Math.min(a.height, c) }, i, null), a.width = o, a.height = c, a.data = e.data);
        }
        function gd(a, e, i, o, c, s, h, y) {
          if (c.width === 0 || c.height === 0) return e;
          if (c.width > a.width || c.height > a.height || i.x > a.width - c.width || i.y > a.height - c.height) throw new RangeError("out of range source coordinates for image copy");
          if (c.width > e.width || c.height > e.height || o.x > e.width - c.width || o.y > e.height - c.height) throw new RangeError("out of range destination coordinates for image copy");
          const T = a.data, k = e.data, g = s === 4 && y;
          for (let A = 0; A < c.height; A++) {
            const D = ((i.y + A) * a.width + i.x) * s, S = ((o.y + A) * e.width + o.x) * s;
            if (g) for (let R = 0; R < c.width; R++) {
              const j = D + R * s + 3, J = S + R * s;
              k[J + 0] = 255, k[J + 1] = 255, k[J + 2] = 255, k[J + 3] = T[j];
            }
            else if (h) for (let R = 0; R < c.width; R++) {
              const j = D + R * s, J = S + R * s, ne = T[j + 3], me = new Xi(T[j + 0] / 255 * ne, T[j + 1] / 255 * ne, T[j + 2] / 255 * ne, ne).toRenderColor(h).toArray();
              k[J + 0] = me[0], k[J + 1] = me[1], k[J + 2] = me[2], k[J + 3] = me[3];
            }
            else for (let R = 0; R < c.width * s; R++) k[S + R] = T[D + R];
          }
          return e;
        }
        Gr(Jd, "HeatmapBucket", { omit: ["layers"] });
        class dl {
          constructor(e, i) {
            Df(this, e, 1, i);
          }
          resize(e) {
            kf(this, new dl(e), 1);
          }
          clone() {
            return new dl({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(e, i, o, c, s) {
            gd(e, i, o, c, s, 1, null);
          }
        }
        class Ea {
          constructor(e, i) {
            Df(this, e, 4, i);
          }
          resize(e) {
            kf(this, new Ea(e), 4);
          }
          replace(e, i) {
            i ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
          }
          clone() {
            return new Ea({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(e, i, o, c, s, h, y) {
            gd(e, i, o, c, s, 4, h, y);
          }
        }
        class yd {
          constructor(e, i) {
            this.width = e.width, this.height = e.height, this.data = i instanceof Uint8Array ? new Float32Array(i.buffer) : i;
          }
        }
        function ph(a) {
          const e = {}, i = a.resolution || 256, o = a.clips ? a.clips.length : 1, c = a.image || new Ea({ width: i, height: o }), s = (h, y, T) => {
            e[a.evaluationKey] = T;
            const k = a.expression.evaluate(e);
            k && (c.data[h + y + 0] = Math.floor(255 * k.r / k.a), c.data[h + y + 1] = Math.floor(255 * k.g / k.a), c.data[h + y + 2] = Math.floor(255 * k.b / k.a), c.data[h + y + 3] = Math.floor(255 * k.a));
          };
          if (a.clips) for (let h = 0, y = 0; h < o; ++h, y += 4 * i) for (let T = 0, k = 0; T < i; T++, k += 4) {
            const g = T / (i - 1), { start: A, end: D } = a.clips[h];
            s(y, k, A * (1 - g) + D * g);
          }
          else for (let h = 0, y = 0; h < i; h++, y += 4) s(0, y, h / (i - 1));
          return c;
        }
        Gr(dl, "AlphaImage"), Gr(Ea, "RGBAImage");
        const zf = Yi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Of } = zf;
        function mh(a, e, i = 2) {
          const o = e && e.length, c = o ? e[0] * i : a.length;
          let s = Bf(a, 0, c, i, !0);
          const h = [];
          if (!s || s.next === s.prev) return h;
          let y, T, k;
          if (o && (s = function(g, A, D, S) {
            const R = [];
            for (let j = 0, J = A.length; j < J; j++) {
              const ne = Bf(g, A[j] * S, j < J - 1 ? A[j + 1] * S : g.length, S, !1);
              ne === ne.next && (ne.steiner = !0), R.push(Kp(ne));
            }
            R.sort(Xp);
            for (let j = 0; j < R.length; j++) D = Uf(R[j], D);
            return D;
          }(a, e, s, i)), a.length > 80 * i) {
            y = 1 / 0, T = 1 / 0;
            let g = -1 / 0, A = -1 / 0;
            for (let D = i; D < c; D += i) {
              const S = a[D], R = a[D + 1];
              S < y && (y = S), R < T && (T = R), S > g && (g = S), R > A && (A = R);
            }
            k = Math.max(g - y, A - T), k = k !== 0 ? 32767 / k : 0;
          }
          return Mc(s, h, i, y, T, k, 0), h;
        }
        function Bf(a, e, i, o, c) {
          let s;
          if (c === function(h, y, T, k) {
            let g = 0;
            for (let A = y, D = T - k; A < T; A += k) g += (h[D] - h[A]) * (h[A + 1] + h[D + 1]), D = A;
            return g;
          }(a, e, i, o) > 0) for (let h = e; h < i; h += o) s = nr(h / o | 0, a[h], a[h + 1], s);
          else for (let h = i - o; h >= e; h -= o) s = nr(h / o | 0, a[h], a[h + 1], s);
          return s && O(s, s.next) && (Er(s), s = s.next), s;
        }
        function Nu(a, e) {
          if (!a) return a;
          e || (e = a);
          let i, o = a;
          do
            if (i = !1, o.steiner || !O(o, o.next) && p(o.prev, o, o.next) !== 0) o = o.next;
            else {
              if (Er(o), o = e = o.prev, o === o.next) break;
              i = !0;
            }
          while (i || o !== e);
          return e;
        }
        function Mc(a, e, i, o, c, s, h) {
          if (!a) return;
          !h && s && function(T, k, g, A) {
            let D = T;
            do
              D.z === 0 && (D.z = Ac(D.x, D.y, k, g, A)), D.prevZ = D.prev, D.nextZ = D.next, D = D.next;
            while (D !== T);
            D.prevZ.nextZ = null, D.prevZ = null, function(S) {
              let R, j = 1;
              do {
                let J, ne = S;
                S = null;
                let me = null;
                for (R = 0; ne; ) {
                  R++;
                  let ge = ne, ue = 0;
                  for (let ke = 0; ke < j && (ue++, ge = ge.nextZ, ge); ke++) ;
                  let Se = j;
                  for (; ue > 0 || Se > 0 && ge; ) ue !== 0 && (Se === 0 || !ge || ne.z <= ge.z) ? (J = ne, ne = ne.nextZ, ue--) : (J = ge, ge = ge.nextZ, Se--), me ? me.nextZ = J : S = J, J.prevZ = me, me = J;
                  ne = ge;
                }
                me.nextZ = null, j *= 2;
              } while (R > 1);
            }(D);
          }(a, o, c, s);
          let y = a;
          for (; a.prev !== a.next; ) {
            const T = a.prev, k = a.next;
            if (s ? vd(a, o, c, s) : Ff(a)) e.push(T.i, a.i, k.i), Er(a), a = k.next, y = k.next;
            else if ((a = k) === y) {
              h ? h === 1 ? Mc(a = Nf(Nu(a), e), e, i, o, c, s, 2) : h === 2 && Qd(a, e, i, o, c, s) : Mc(Nu(a), e, i, o, c, s, 1);
              break;
            }
          }
        }
        function Ff(a) {
          const e = a.prev, i = a, o = a.next;
          if (p(e, i, o) >= 0) return !1;
          const c = e.x, s = i.x, h = o.x, y = e.y, T = i.y, k = o.y, g = c < s ? c < h ? c : h : s < h ? s : h, A = y < T ? y < k ? y : k : T < k ? T : k, D = c > s ? c > h ? c : h : s > h ? s : h, S = y > T ? y > k ? y : k : T > k ? T : k;
          let R = o.next;
          for (; R !== e; ) {
            if (R.x >= g && R.x <= D && R.y >= A && R.y <= S && Ql(c, y, s, T, h, k, R.x, R.y) && p(R.prev, R, R.next) >= 0) return !1;
            R = R.next;
          }
          return !0;
        }
        function vd(a, e, i, o) {
          const c = a.prev, s = a, h = a.next;
          if (p(c, s, h) >= 0) return !1;
          const y = c.x, T = s.x, k = h.x, g = c.y, A = s.y, D = h.y, S = y < T ? y < k ? y : k : T < k ? T : k, R = g < A ? g < D ? g : D : A < D ? A : D, j = y > T ? y > k ? y : k : T > k ? T : k, J = g > A ? g > D ? g : D : A > D ? A : D, ne = Ac(S, R, e, i, o), me = Ac(j, J, e, i, o);
          let ge = a.prevZ, ue = a.nextZ;
          for (; ge && ge.z >= ne && ue && ue.z <= me; ) {
            if (ge.x >= S && ge.x <= j && ge.y >= R && ge.y <= J && ge !== c && ge !== h && Ql(y, g, T, A, k, D, ge.x, ge.y) && p(ge.prev, ge, ge.next) >= 0 || (ge = ge.prevZ, ue.x >= S && ue.x <= j && ue.y >= R && ue.y <= J && ue !== c && ue !== h && Ql(y, g, T, A, k, D, ue.x, ue.y) && p(ue.prev, ue, ue.next) >= 0)) return !1;
            ue = ue.nextZ;
          }
          for (; ge && ge.z >= ne; ) {
            if (ge.x >= S && ge.x <= j && ge.y >= R && ge.y <= J && ge !== c && ge !== h && Ql(y, g, T, A, k, D, ge.x, ge.y) && p(ge.prev, ge, ge.next) >= 0) return !1;
            ge = ge.prevZ;
          }
          for (; ue && ue.z <= me; ) {
            if (ue.x >= S && ue.x <= j && ue.y >= R && ue.y <= J && ue !== c && ue !== h && Ql(y, g, T, A, k, D, ue.x, ue.y) && p(ue.prev, ue, ue.next) >= 0) return !1;
            ue = ue.nextZ;
          }
          return !0;
        }
        function Nf(a, e) {
          let i = a;
          do {
            const o = i.prev, c = i.next.next;
            !O(o, c) && ee(o, i, i.next, c) && ot(o, c) && ot(c, o) && (e.push(o.i, i.i, c.i), Er(i), Er(i.next), i = a = c), i = i.next;
          } while (i !== a);
          return Nu(i);
        }
        function Qd(a, e, i, o, c, s) {
          let h = a;
          do {
            let y = h.next.next;
            for (; y !== h.prev; ) {
              if (h.i !== y.i && f(h, y)) {
                let T = Ht(h, y);
                return h = Nu(h, h.next), T = Nu(T, T.next), Mc(h, e, i, o, c, s, 0), void Mc(T, e, i, o, c, s, 0);
              }
              y = y.next;
            }
            h = h.next;
          } while (h !== a);
        }
        function Xp(a, e) {
          return a.x - e.x;
        }
        function Uf(a, e) {
          const i = function(c, s) {
            let h = s;
            const y = c.x, T = c.y;
            let k, g = -1 / 0;
            do {
              if (T <= h.y && T >= h.next.y && h.next.y !== h.y) {
                const j = h.x + (T - h.y) * (h.next.x - h.x) / (h.next.y - h.y);
                if (j <= y && j > g && (g = j, k = h.x < h.next.x ? h : h.next, j === y)) return k;
              }
              h = h.next;
            } while (h !== s);
            if (!k) return null;
            const A = k, D = k.x, S = k.y;
            let R = 1 / 0;
            h = k;
            do {
              if (y >= h.x && h.x >= D && y !== h.x && Ql(T < S ? y : g, T, D, S, T < S ? g : y, T, h.x, h.y)) {
                const j = Math.abs(T - h.y) / (y - h.x);
                ot(h, c) && (j < R || j === R && (h.x > k.x || h.x === k.x && Yp(k, h))) && (k = h, R = j);
              }
              h = h.next;
            } while (h !== A);
            return k;
          }(a, e);
          if (!i) return e;
          const o = Ht(i, a);
          return Nu(o, o.next), Nu(i, i.next);
        }
        function Yp(a, e) {
          return p(a.prev, a, e.prev) < 0 && p(e.next, a, a.next) < 0;
        }
        function Ac(a, e, i, o, c) {
          return (a = 1431655765 & ((a = 858993459 & ((a = 252645135 & ((a = 16711935 & ((a = (a - i) * c | 0) | a << 8)) | a << 4)) | a << 2)) | a << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - o) * c | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
        }
        function Kp(a) {
          let e = a, i = a;
          do
            (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next;
          while (e !== a);
          return i;
        }
        function Ql(a, e, i, o, c, s, h, y) {
          return (c - h) * (e - y) >= (a - h) * (s - y) && (a - h) * (o - y) >= (i - h) * (e - y) && (i - h) * (s - y) >= (c - h) * (o - y);
        }
        function f(a, e) {
          return a.next.i !== e.i && a.prev.i !== e.i && !function(i, o) {
            let c = i;
            do {
              if (c.i !== i.i && c.next.i !== i.i && c.i !== o.i && c.next.i !== o.i && ee(c, c.next, i, o)) return !0;
              c = c.next;
            } while (c !== i);
            return !1;
          }(a, e) && (ot(a, e) && ot(e, a) && function(i, o) {
            let c = i, s = !1;
            const h = (i.x + o.x) / 2, y = (i.y + o.y) / 2;
            do
              c.y > y != c.next.y > y && c.next.y !== c.y && h < (c.next.x - c.x) * (y - c.y) / (c.next.y - c.y) + c.x && (s = !s), c = c.next;
            while (c !== i);
            return s;
          }(a, e) && (p(a.prev, a, e.prev) || p(a, e.prev, e)) || O(a, e) && p(a.prev, a, a.next) > 0 && p(e.prev, e, e.next) > 0);
        }
        function p(a, e, i) {
          return (e.y - a.y) * (i.x - e.x) - (e.x - a.x) * (i.y - e.y);
        }
        function O(a, e) {
          return a.x === e.x && a.y === e.y;
        }
        function ee(a, e, i, o) {
          const c = Le(p(a, e, i)), s = Le(p(a, e, o)), h = Le(p(i, o, a)), y = Le(p(i, o, e));
          return c !== s && h !== y || !(c !== 0 || !ye(a, i, e)) || !(s !== 0 || !ye(a, o, e)) || !(h !== 0 || !ye(i, a, o)) || !(y !== 0 || !ye(i, e, o));
        }
        function ye(a, e, i) {
          return e.x <= Math.max(a.x, i.x) && e.x >= Math.min(a.x, i.x) && e.y <= Math.max(a.y, i.y) && e.y >= Math.min(a.y, i.y);
        }
        function Le(a) {
          return a > 0 ? 1 : a < 0 ? -1 : 0;
        }
        function ot(a, e) {
          return p(a.prev, a, a.next) < 0 ? p(a, e, a.next) >= 0 && p(a, a.prev, e) >= 0 : p(a, e, a.prev) < 0 || p(a, a.next, e) < 0;
        }
        function Ht(a, e) {
          const i = Jr(a.i, a.x, a.y), o = Jr(e.i, e.x, e.y), c = a.next, s = e.prev;
          return a.next = e, e.prev = a, i.next = c, c.prev = i, o.next = i, i.prev = o, s.next = o, o.prev = s, o;
        }
        function nr(a, e, i, o) {
          const c = Jr(a, e, i);
          return o ? (c.next = o.next, c.prev = o, o.next.prev = c, o.next = c) : (c.prev = c, c.next = c), c;
        }
        function Er(a) {
          a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ);
        }
        function Jr(a, e, i) {
          return { i: a, x: e, y: i, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        function ei(a, e) {
          const i = a.length;
          if (i <= 1) return [a];
          const o = [];
          let c, s;
          for (let h = 0; h < i; h++) {
            const y = pr(a[h]);
            y !== 0 && (a[h].area = Math.abs(y), s === void 0 && (s = y < 0), s === y < 0 ? (c && o.push(c), c = [a[h]]) : c.push(a[h]));
          }
          if (c && o.push(c), e > 1) for (let h = 0; h < o.length; h++) o[h].length <= e || (Zu(o[h], e, 1, o[h].length - 1, Qr), o[h] = o[h].slice(0, e));
          return o;
        }
        function Qr(a, e) {
          return e.area - a.area;
        }
        function wi(a, e, i = 1) {
          if (!a) return null;
          const o = typeof a == "string" ? a : a.getPrimary().id;
          e[o] || (e[o] = []);
          const c = ma.from(o).getPrimary().scaleSelf(i);
          return e[o].push(c), c.serialize();
        }
        function Ei(a, e, i, o) {
          const c = o.patternDependencies;
          let s = !1;
          for (const h of e) {
            const y = h.paint.get(`${a}-pattern`);
            y.isConstant() || (s = !0), wi(y.constantOr(null), c, i) && (s = !0);
          }
          return s;
        }
        function Ti(a, e, i, o, c, s) {
          const h = s.patternDependencies;
          for (const y of e) {
            const T = y.paint.get(`${a}-pattern`).value;
            if (T.kind !== "constant") {
              let k = T.evaluate({ zoom: o }, i, {}, s.availableImages);
              k = k && k.name ? k.name : k;
              const g = wi(k, h, c);
              g && (i.patterns[y.id] = g);
            }
          }
          return i;
        }
        class na {
          constructor(e) {
            this.zoom = e.zoom, this.pixelRatio = e.pixelRatio, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((i) => i.fqid), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Ga(), this.indexArray = new ha(), this.indexArray2 = new ga(), this.programConfigurations = new Ls(e.layers, { zoom: e.zoom, lut: e.lut }), this.segments = new Nn(), this.segments2 = new Nn(), this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id), this.projection = e.projection;
          }
          updateFootprints(e, i) {
          }
          populate(e, i, o, c) {
            this.hasPattern = Ei("fill", this.layers, this.pixelRatio, i);
            const s = this.layers[0].layout.get("fill-sort-key"), h = [];
            for (const { feature: y, id: T, index: k, sourceLayerIndex: g } of e) {
              const A = this.layers[0]._featureFilter.needGeometry, D = ae(y, A);
              if (!this.layers[0]._featureFilter.filter(new sn(this.zoom), D, o)) continue;
              const S = s ? s.evaluate(D, {}, o, i.availableImages) : void 0, R = { id: T, properties: y.properties, type: y.type, sourceLayerIndex: g, index: k, geometry: A ? D.geometry : K(y, o, c), patterns: {}, sortKey: S };
              h.push(R);
            }
            s && h.sort((y, T) => y.sortKey - T.sortKey);
            for (const y of h) {
              const { geometry: T, index: k, sourceLayerIndex: g } = y;
              if (this.hasPattern) {
                const A = Ti("fill", this.layers, y, this.zoom, this.pixelRatio, i);
                this.patternFeatures.push(A);
              } else this.addFeature(y, T, k, o, {}, i.availableImages, i.brightness, i.elevationFeatures);
              i.featureIndex.insert(e[k].feature, T, k, g, this.index);
            }
          }
          update(e, i, o, c, s, h, y) {
            this.programConfigurations.updatePaintArrays(e, i, s, o, c, h, y);
          }
          addFeatures(e, i, o, c, s, h) {
            for (const y of this.patternFeatures) this.addFeature(y, y.geometry, y.index, i, o, c, h, e.elevationFeatures);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Of), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(e, i, o, c, s, h = [], y, T) {
            for (const k of ei(i, 500)) {
              let g = 0;
              for (const J of k) g += J.length;
              const A = this.segments.prepareSegment(g, this.layoutVertexArray, this.indexArray), D = A.vertexLength, S = [], R = [];
              for (const J of k) {
                if (J.length === 0) continue;
                J !== k[0] && R.push(S.length / 2);
                const ne = this.segments2.prepareSegment(J.length, this.layoutVertexArray, this.indexArray2), me = ne.vertexLength;
                this.layoutVertexArray.emplaceBack(J[0].x, J[0].y), this.indexArray2.emplaceBack(me + J.length - 1, me), S.push(J[0].x), S.push(J[0].y);
                for (let ge = 1; ge < J.length; ge++) this.layoutVertexArray.emplaceBack(J[ge].x, J[ge].y), this.indexArray2.emplaceBack(me + ge - 1, me + ge), S.push(J[ge].x), S.push(J[ge].y);
                ne.vertexLength += J.length, ne.primitiveLength += J.length;
              }
              const j = mh(S, R);
              for (let J = 0; J < j.length; J += 3) this.indexArray.emplaceBack(D + j[J], D + j[J + 1], D + j[J + 2]);
              A.vertexLength += g, A.primitiveLength += j.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, s, h, c, y);
          }
        }
        let _r, lr, xr, ai;
        Gr(na, "FillBucket", { omit: ["layers", "patternFeatures"] });
        class Ai {
          constructor(e, i, o, c) {
            if (this.triangleCount = i.length / 3, this.min = new Ye(0, 0), this.max = new Ye(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], this.triangleCount === 0 || e.length === 0) return;
            const [s, h] = [e[0].clone(), e[0].clone()];
            for (let A = 1; A < e.length; ++A) {
              const D = e[A];
              s.x = Math.min(s.x, D.x), s.y = Math.min(s.y, D.y), h.x = Math.max(h.x, D.x), h.y = Math.max(h.y, D.y);
            }
            if (c) {
              const A = Math.ceil(Math.max(h.x - s.x, h.y - s.y) / c);
              o = Math.max(o, A);
            }
            if (o === 0) return;
            this.min = s, this.max = h;
            const y = this.max.sub(this.min);
            y.x = Math.max(y.x, 1), y.y = Math.max(y.y, 1);
            const T = Math.max(y.x, y.y) / o;
            this.cellsX = Math.max(1, Math.ceil(y.x / T)), this.cellsY = Math.max(1, Math.ceil(y.y / T)), this.xScale = 1 / T, this.yScale = 1 / T;
            const k = [];
            for (let A = 0; A < this.triangleCount; A++) {
              const D = e[i[3 * A + 0]].sub(this.min), S = e[i[3 * A + 1]].sub(this.min), R = e[i[3 * A + 2]].sub(this.min), j = Ii(Math.floor(Math.min(D.x, S.x, R.x)), this.xScale, this.cellsX), J = Ii(Math.floor(Math.max(D.x, S.x, R.x)), this.xScale, this.cellsX), ne = Ii(Math.floor(Math.min(D.y, S.y, R.y)), this.yScale, this.cellsY), me = Ii(Math.floor(Math.max(D.y, S.y, R.y)), this.yScale, this.cellsY), ge = new Ye(0, 0), ue = new Ye(0, 0), Se = new Ye(0, 0), ke = new Ye(0, 0);
              for (let He = ne; He <= me; ++He) {
                ge.y = ue.y = He * T, Se.y = ke.y = (He + 1) * T;
                for (let at = j; at <= J; ++at) ge.x = Se.x = at * T, ue.x = ke.x = (at + 1) * T, (Vt(D, S, R, ge, ue, ke) || Vt(D, S, R, ge, ke, Se)) && k.push({ cellIdx: He * this.cellsX + at, triIdx: A });
              }
            }
            if (k.length === 0) return;
            k.sort((A, D) => A.cellIdx - D.cellIdx || A.triIdx - D.triIdx);
            let g = 0;
            for (; g < k.length; ) {
              const A = k[g].cellIdx, D = { start: this.payload.length, len: 0 };
              for (; g < k.length && k[g].cellIdx === A; ) ++D.len, this.payload.push(k[g++].triIdx);
              this.cells[A] = D;
            }
          }
          _lazyInitLookup() {
            this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
          }
          queryPoint(e, i) {
            if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > e.x || e.y > this.max.y || this.min.y > e.y) return;
            const o = Ii(e.x - this.min.x, this.xScale, this.cellsX), c = Ii(e.y - this.min.y, this.yScale, this.cellsY), s = this.cells[c * this.cellsX + o];
            if (s) {
              this._lazyInitLookup();
              for (let h = 0; h < s.len; h++) {
                const y = this.payload[s.start + h], T = Math.floor(y / 8), k = 1 << y % 8;
                if (!(this.lookup[T] & k) && (this.lookup[T] |= k, i.push(y), i.length === this.triangleCount)) return;
              }
            }
          }
          query(e, i, o) {
            if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > i.x || e.y > this.max.y || this.min.y > i.y) return;
            this._lazyInitLookup();
            const c = Ii(e.x - this.min.x, this.xScale, this.cellsX), s = Ii(i.x - this.min.x, this.xScale, this.cellsX), h = Ii(e.y - this.min.y, this.yScale, this.cellsY), y = Ii(i.y - this.min.y, this.yScale, this.cellsY);
            for (let T = h; T <= y; T++) for (let k = c; k <= s; k++) {
              const g = this.cells[T * this.cellsX + k];
              if (g) for (let A = 0; A < g.len; A++) {
                const D = this.payload[g.start + A], S = Math.floor(D / 8), R = 1 << D % 8;
                if (!(this.lookup[S] & R) && (this.lookup[S] |= R, o.push(D), o.length === this.triangleCount)) return;
              }
            }
          }
        }
        function Ii(a, e, i) {
          return Math.max(0, Math.min(i - 1, Math.floor(a * e)));
        }
        Gr(Ai, "TriangleGridIndex");
        class Gi {
          constructor(e) {
            this.zoom = e.zoom, this.layers = e.layers, this.layerIds = this.layers.map((i) => i.fqid), this.index = e.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id), this.footprints = [];
          }
          updateFootprints(e, i) {
            for (const o of this.footprints) i.push({ footprint: o, id: e });
          }
          populate(e, i, o, c) {
            const s = [];
            for (const { feature: h, id: y, index: T, sourceLayerIndex: k } of e) {
              const g = this.layers[0]._featureFilter.needGeometry, A = ae(h, g);
              if (!this.layers[0]._featureFilter.filter(new sn(this.zoom), A, o)) continue;
              const D = { id: y, properties: h.properties, type: h.type, sourceLayerIndex: k, index: T, geometry: g ? A.geometry : K(h, o, c), patterns: {} };
              s.push(D);
            }
            for (const h of s) {
              const { geometry: y, index: T, sourceLayerIndex: k } = h;
              this.addFeature(h, y, T, o, {}, i.availableImages, i.brightness), i.featureIndex.insert(e[T].feature, y, T, k, this.index);
            }
          }
          isEmpty() {
            return this.footprints.length === 0;
          }
          uploadPending() {
            return !1;
          }
          upload(e) {
          }
          update(e, i, o, c, s, h, y) {
          }
          destroy() {
          }
          addFeature(e, i, o, c, s, h = [], y) {
            for (const T of ei(i, 2)) {
              const k = [], g = [], A = [], D = new Ye(1 / 0, 1 / 0), S = new Ye(-1 / 0, -1 / 0);
              for (const J of T) if (J.length !== 0) {
                J !== T[0] && A.push(g.length / 2);
                for (let ne = 0; ne < J.length; ne++) g.push(J[ne].x), g.push(J[ne].y), k.push(J[ne]), D.x = Math.min(D.x, J[ne].x), D.y = Math.min(D.y, J[ne].y), S.x = Math.max(S.x, J[ne].x), S.y = Math.max(S.y, J[ne].y);
              }
              const R = mh(g, A), j = new Ai(k, R, 8, 256);
              this.footprints.push({ vertices: k, indices: R, grid: j, min: D, max: S });
            }
          }
        }
        Gr(Gi, "ClipBucket", { omit: ["layers"] });
        const en = Yi([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Oa = Yi([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), En = Yi([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Uu = Yi([{ name: "a_join_normal_inside", components: 3, type: "Int16" }]), Jp = Yi([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), kv = Yi([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: zv } = en;
        var Qp, F_, em, N_, tm, U_, j_, ep = {};
        function V_() {
          if (F_) return Qp;
          F_ = 1;
          var a = vt();
          function e(c, s, h, y, T) {
            this.properties = {}, this.extent = h, this.type = 0, this._pbf = c, this._geometry = -1, this._keys = y, this._values = T, c.readFields(i, this, s);
          }
          function i(c, s, h) {
            c == 1 ? s.id = h.readVarint() : c == 2 ? function(y, T) {
              for (var k = y.readVarint() + y.pos; y.pos < k; ) {
                var g = T._keys[y.readVarint()], A = T._values[y.readVarint()];
                T.properties[g] = A;
              }
            }(h, s) : c == 3 ? s.type = h.readVarint() : c == 4 && (s._geometry = h.pos);
          }
          function o(c) {
            for (var s, h, y = 0, T = 0, k = c.length, g = k - 1; T < k; g = T++) y += ((h = c[g]).x - (s = c[T]).x) * (s.y + h.y);
            return y;
          }
          return Qp = e, e.types = ["Unknown", "Point", "LineString", "Polygon"], e.prototype.loadGeometry = function() {
            var c = this._pbf;
            c.pos = this._geometry;
            for (var s, h = c.readVarint() + c.pos, y = 1, T = 0, k = 0, g = 0, A = []; c.pos < h; ) {
              if (T <= 0) {
                var D = c.readVarint();
                y = 7 & D, T = D >> 3;
              }
              if (T--, y === 1 || y === 2) k += c.readSVarint(), g += c.readSVarint(), y === 1 && (s && A.push(s), s = []), s.push(new a(k, g));
              else {
                if (y !== 7) throw new Error("unknown command " + y);
                s && s.push(s[0].clone());
              }
            }
            return s && A.push(s), A;
          }, e.prototype.bbox = function() {
            var c = this._pbf;
            c.pos = this._geometry;
            for (var s = c.readVarint() + c.pos, h = 1, y = 0, T = 0, k = 0, g = 1 / 0, A = -1 / 0, D = 1 / 0, S = -1 / 0; c.pos < s; ) {
              if (y <= 0) {
                var R = c.readVarint();
                h = 7 & R, y = R >> 3;
              }
              if (y--, h === 1 || h === 2) (T += c.readSVarint()) < g && (g = T), T > A && (A = T), (k += c.readSVarint()) < D && (D = k), k > S && (S = k);
              else if (h !== 7) throw new Error("unknown command " + h);
            }
            return [g, D, A, S];
          }, e.prototype.toGeoJSON = function(c, s, h) {
            var y, T, k = this.extent * Math.pow(2, h), g = this.extent * c, A = this.extent * s, D = this.loadGeometry(), S = e.types[this.type];
            function R(ne) {
              for (var me = 0; me < ne.length; me++) {
                var ge = ne[me];
                ne[me] = [360 * (ge.x + g) / k - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (ge.y + A) / k) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var j = [];
                for (y = 0; y < D.length; y++) j[y] = D[y][0];
                R(D = j);
                break;
              case 2:
                for (y = 0; y < D.length; y++) R(D[y]);
                break;
              case 3:
                for (D = function(ne) {
                  var me = ne.length;
                  if (me <= 1) return [ne];
                  for (var ge, ue, Se = [], ke = 0; ke < me; ke++) {
                    var He = o(ne[ke]);
                    He !== 0 && (ue === void 0 && (ue = He < 0), ue === He < 0 ? (ge && Se.push(ge), ge = [ne[ke]]) : ge.push(ne[ke]));
                  }
                  return ge && Se.push(ge), Se;
                }(D), y = 0; y < D.length; y++) for (T = 0; T < D[y].length; T++) R(D[y][T]);
            }
            D.length === 1 ? D = D[0] : S = "Multi" + S;
            var J = { type: "Feature", geometry: { type: S, coordinates: D }, properties: this.properties };
            return "id" in this && (J.id = this.id), J;
          }, Qp;
        }
        function G_() {
          if (N_) return em;
          N_ = 1;
          var a = V_();
          function e(o, c) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = o, this._keys = [], this._values = [], this._features = [], o.readFields(i, this, c), this.length = this._features.length;
          }
          function i(o, c, s) {
            o === 15 ? c.version = s.readVarint() : o === 1 ? c.name = s.readString() : o === 5 ? c.extent = s.readVarint() : o === 2 ? c._features.push(s.pos) : o === 3 ? c._keys.push(s.readString()) : o === 4 && c._values.push(function(h) {
              for (var y = null, T = h.readVarint() + h.pos; h.pos < T; ) {
                var k = h.readVarint() >> 3;
                y = k === 1 ? h.readString() : k === 2 ? h.readFloat() : k === 3 ? h.readDouble() : k === 4 ? h.readVarint64() : k === 5 ? h.readVarint() : k === 6 ? h.readSVarint() : k === 7 ? h.readBoolean() : null;
              }
              return y;
            }(s));
          }
          return em = e, e.prototype.feature = function(o) {
            if (o < 0 || o >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[o];
            var c = this._pbf.readVarint() + this._pbf.pos;
            return new a(this._pbf, c, this.extent, this._keys, this._values);
          }, em;
        }
        function H_() {
          return j_ || (j_ = 1, ep.VectorTile = function() {
            if (U_) return tm;
            U_ = 1;
            var a = G_();
            function e(i, o, c) {
              if (i === 3) {
                var s = new a(c, c.readVarint() + c.pos);
                s.length && (o[s.name] = s);
              }
            }
            return tm = function(i, o) {
              this.layers = i.readFields(e, {}, o);
            }, tm;
          }(), ep.VectorTileFeature = V_(), ep.VectorTileLayer = G_()), ep;
        }
        var jf = H_();
        class of extends Ye {
          constructor(e, i, o) {
            super(e, i), this.z = o;
          }
        }
        class W_ extends of {
          constructor(e, i, o, c) {
            super(e, i, o), this.w = c;
          }
        }
        function tp(a, e, i, o) {
          const c = [], s = o === 0 ? (h, y, T, k, g, A) => {
            h.push(new Ye(A, T + (A - y) / (k - y) * (g - T)));
          } : (h, y, T, k, g, A) => {
            h.push(new Ye(y + (A - T) / (g - T) * (k - y), A));
          };
          for (const h of a) {
            const y = [];
            for (const T of h) {
              if (T.length <= 2) continue;
              const k = [];
              for (let D = 0; D < T.length - 1; D++) {
                const S = T[D].x, R = T[D].y, j = T[D + 1].x, J = T[D + 1].y, ne = o === 0 ? S : R, me = o === 0 ? j : J;
                ne < e ? me > e && s(k, S, R, j, J, e) : ne > i ? me < i && s(k, S, R, j, J, i) : k.push(T[D]), me < e && ne >= e && s(k, S, R, j, J, e), me > i && ne <= i && s(k, S, R, j, J, i);
              }
              let g = T[T.length - 1];
              const A = o === 0 ? g.x : g.y;
              A >= e && A <= i && k.push(g), k.length && (g = k[k.length - 1], k[0].x === g.x && k[0].y === g.y || k.push(k[0]), y.push(k));
            }
            y.length && c.push(y);
          }
          return c;
        }
        function Z_(a, e, i, o) {
          const c = i === "x" ? "y" : "x", s = (o - a[i]) / (e[i] - a[i]);
          a[c] = a[c] + (e[c] - a[c]) * s, a[i] = o, a.hasOwnProperty("z") && (a.z = li(a.z, e.z, s)), a.hasOwnProperty("w") && (a.w = li(a.w, e.w, s));
        }
        function q_(a, e, i, o) {
          const c = i, s = o;
          for (const h of ["x", "y"]) {
            let y = a, T = e;
            y[h] >= T[h] && (y = e, T = a), y[h] < c && T[h] > c && Z_(y, T, h, c), y[h] < s && T[h] > s && Z_(T, y, h, s);
          }
        }
        const rp = Number.MAX_SAFE_INTEGER;
        function $_(a, e, i, o) {
          return a.order < e || a.order === rp || !(a.clipMask & i) || function(c, s) {
            return s.length !== 0 && s.find((h) => h === c) === void 0;
          }(o, a.clipScope);
        }
        function ip(a, e) {
          return a.x - e.x || a.y - e.y;
        }
        function X_(a, e) {
          return ip(a.min, e.min) === 0 && ip(a.max, e.max) === 0;
        }
        function rm(a, e) {
          return !(a.min.x > e.max.x || a.max.x < e.min.x || a.min.y > e.max.y || a.max.y < e.min.y);
        }
        function im(a, e) {
          if (a.length !== e.length) return !1;
          for (let i = 0; i < a.length; i++) if (a[i].sourceId !== e[i].sourceId || !X_(a[i], e[i]) || a[i].order !== e[i].order || a[i].clipMask !== e[i].clipMask || !qe(a[i].clipScope, e[i].clipScope)) return !1;
          return !0;
        }
        function Y_(a, e, i) {
          const o = 1 / Br, c = 1 / (1 << i.canonical.z), s = (e.x * o + i.canonical.x) * c + i.wrap, h = (e.y * o + i.canonical.y) * c;
          return { min: new Ye((a.x * o + i.canonical.x) * c + i.wrap, (a.y * o + i.canonical.y) * c), max: new Ye(s, h) };
        }
        function Ov(a, e, i) {
          const o = 1 << i.canonical.z, c = ((e.x - i.wrap) * o - i.canonical.x) * Br, s = (e.y * o - i.canonical.y) * Br;
          return { min: new Ye(((a.x - i.wrap) * o - i.canonical.x) * Br, (a.y * o - i.canonical.y) * Br), max: new Ye(c, s) };
        }
        function K_(a, e, i, o, c, s, h) {
          const y = a.indices, T = a.vertices, k = [];
          for (let g = o; g < o + c; g += 3) {
            const A = e[i[g + 0] + s], D = e[i[g + 1] + s], S = e[i[g + 2] + s], R = Math.min(A.x, D.x, S.x), j = Math.max(A.x, D.x, S.x), J = Math.min(A.y, D.y, S.y), ne = Math.max(A.y, D.y, S.y);
            k.length = 0, a.grid.query(new Ye(R, J), new Ye(j, ne), k);
            for (let me = 0; me < k.length; me++) {
              const ge = k[me];
              if (Vt(T[y[3 * ge + 0]], T[y[3 * ge + 1]], T[y[3 * ge + 2]], A, D, S, h)) return !0;
            }
          }
          return !1;
        }
        function J_(a, e, i, o) {
          if (!a || !i) return !1;
          let c = a.vertices;
          if (!e.canonical.equals(o.canonical) || e.wrap !== o.wrap) {
            if (i.vertices.length < a.vertices.length) return J_(i, o, a, e);
            const s = e.canonical, h = o.canonical, y = Math.pow(2, h.z - s.z);
            c = a.vertices.map((T) => new Ye((T.x + s.x * Br) * y - h.x * Br, (T.y + s.y * Br) * y - h.y * Br));
          }
          return K_(i, c, a.indices, 0, a.indices.length, 0, 0);
        }
        function Q_(a, e, i, o) {
          const c = Math.pow(2, o.z - i.z);
          return new Ye((a + i.x * Br) * c - o.x * Br, (e + i.y * Br) * c - o.y * Br);
        }
        function eg(a, e) {
          const i = [];
          e.grid.queryPoint(a, i);
          const o = e.indices, c = e.vertices;
          for (let s = 0; s < i.length; s++) {
            const h = i[s];
            if (dt([c[o[3 * h + 0]], c[o[3 * h + 1]], c[o[3 * h + 2]]], a)) return !0;
          }
          return !1;
        }
        const nm = [new Ye(0, 0), new Ye(Br, 0), new Ye(Br, Br), new Ye(0, Br)];
        function tg(a, e) {
          const i = [];
          let o = [];
          if (!e || a.length < 2) return [a];
          if (a.length === 2) return Rt(a[0], a[1], nm) ? [a] : [];
          for (let c = 0; c < a.length + 2; c++) {
            const s = a[c % a.length], h = a[(c + 1) % a.length], y = Rt(c === 0 ? a[a.length - 1] : a[(c - 1) % a.length], s, nm), T = Rt(s, h, nm), k = y || T;
            k && o.push(s), k && T || o.length > 0 && (o.length > 1 && i.push(o), o = []);
          }
          return o.length > 1 && i.push(o), i;
        }
        const am = jf.VectorTileFeature.types, Bv = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"], Fv = ["fill-extrusion-flood-light-ground-radius"], Nv = Math.pow(2, 13), Uv = Math.pow(2, 15) - 1, rg = new Ye(0, 1), _h = 2147483648;
        function xd(a, e, i, o, c, s, h, y) {
          a.emplaceBack((e << 1) + h, (i << 1) + s, (Math.floor(o * Nv) << 1) + c, Math.round(y));
        }
        function bd(a, e, i) {
          a.emplaceBack(e.x * Br, e.y * Br, i ? 1 : 0);
        }
        function np(a, e, i, o, c, s) {
          a.emplaceBack(e.x, e.y, (i.x << 1) + o, (i.y << 1) + c, s);
        }
        function wd(a, e, i) {
          a.emplaceBack(e.x, e.y, e.z, i[0] * 16384, i[1] * 16384, i[2] * 16384);
        }
        class ig {
          constructor() {
            this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
          }
        }
        class ng {
          constructor() {
            this.centroidXY = new Ye(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new Ye(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new Ye(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
          }
          span() {
            return new Ye(this.max.x - this.min.x, this.max.y - this.min.y);
          }
        }
        class ag {
          constructor() {
            this.acc = new Ye(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
          }
          startRing(e, i) {
            e.min.x === Number.MAX_VALUE && (e.min.x = e.max.x = i.x, e.min.y = e.max.y = i.y);
          }
          appendEdge(e, i, o) {
            this.accCount++, this.acc._add(i);
            let c = !!this.borders;
            i.x < e.min.x ? (e.min.x = i.x, c = !0) : i.x > e.max.x && (e.max.x = i.x, c = !0), i.y < e.min.y ? (e.min.y = i.y, c = !0) : i.y > e.max.y && (e.max.y = i.y, c = !0), ((i.x === 0 || i.x === Br) && i.x === o.x) != ((i.y === 0 || i.y === Br) && i.y === o.y) && this.processBorderOverlap(i, o), c && this.checkBorderIntersection(i, o);
          }
          checkBorderIntersection(e, i) {
            i.x < 0 != e.x < 0 && this.addBorderIntersection(0, li(i.y, e.y, (0 - i.x) / (e.x - i.x))), i.x > Br != e.x > Br && this.addBorderIntersection(1, li(i.y, e.y, (Br - i.x) / (e.x - i.x))), i.y < 0 != e.y < 0 && this.addBorderIntersection(2, li(i.x, e.x, (0 - i.y) / (e.y - i.y))), i.y > Br != e.y > Br && this.addBorderIntersection(3, li(i.x, e.x, (Br - i.y) / (e.y - i.y)));
          }
          addBorderIntersection(e, i) {
            this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
            const o = this.borders[e];
            i < o[0] && (o[0] = i), i > o[1] && (o[1] = i);
          }
          processBorderOverlap(e, i) {
            if (e.x === i.x) {
              if (e.y === i.y) return;
              const o = e.x === 0 ? 0 : 1;
              this.addBorderIntersection(o, i.y), this.addBorderIntersection(o, e.y);
            } else {
              const o = e.y === 0 ? 2 : 3;
              this.addBorderIntersection(o, i.x), this.addBorderIntersection(o, e.x);
            }
          }
          centroid() {
            return this.accCount === 0 ? new Ye(0, 0) : new Ye(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
          }
          intersectsCount() {
            return this.borders ? this.borders.reduce((e, i) => e + +(i[0] !== Number.MAX_VALUE), 0) : 0;
          }
        }
        function og(a, e) {
          const i = a.add(e)._unit(), o = ie(a.x * i.x + a.y * i.y, -1, 1);
          var c, s, h;
          return h = Math.acos(o), Math.min(4, Math.max(-4, Math.tan(h))) / 4 * Uv * ((c = a).x * (s = e).y - c.y * s.x < 0 ? -1 : 1);
        }
        const jv = [(a) => a.x < 0, (a) => a.x > Br, (a) => a.y < 0, (a) => a.y > Br];
        function Vv(a, e, i, o) {
          const c = [4];
          if (o === 0) return c;
          i._mult(o);
          const s = a.sub(i), h = e.sub(i), y = [a, e, s, h];
          for (let T = 0; T < 4; T++) for (const k of y) if (jv[T](k)) {
            c.push(T);
            break;
          }
          return c;
        }
        class sg {
          constructor(e) {
            this.vertexArray = new ta(), this.indexArray = new ha(), this.programConfigurations = new Ls(e.layers, { zoom: e.zoom, lut: e.lut }, (i) => Fv.includes(i)), this._segments = new Nn(), this.hiddenByLandmarkVertexArray = new gc(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new Nn();
          }
          getDefaultSegment() {
            return this.regionSegments[4];
          }
          hasData() {
            return this.vertexArray.length !== 0;
          }
          addData(e, i, o, c = !1) {
            const s = e.length;
            if (s > 2) {
              let h = Math.max(0, this._segments.get().length - 1);
              const y = this._segments._prepareSegment(4 * s, this.vertexArray.length, 2 * this._segmentToGroundQuads[h].length);
              let T;
              h !== this._segments.get().length - 1 && (h++, this._segmentToGroundQuads[h] = [], this._segmentToRegionTriCounts[h] = [0, 0, 0, 0, 0]);
              {
                const k = e[0], g = e[1];
                T = og(k.sub(e[s - 1])._perp()._unit(), g.sub(k)._perp()._unit());
              }
              for (let k = 0; k < s; k++) {
                const g = k === s - 1 ? 0 : k + 1, A = e[k], D = e[g], S = e[g === s - 1 ? 0 : g + 1], R = D.sub(A)._perp()._unit(), j = og(R, S.sub(D)._perp()._unit()), J = T, ne = j;
                if (om(A, D, i) || c && cg(A, i) && cg(D, i)) {
                  T = j;
                  continue;
                }
                const me = y.vertexLength;
                np(this.vertexArray, A, D, 1, 1, J), np(this.vertexArray, A, D, 1, 0, J), np(this.vertexArray, A, D, 0, 1, ne), np(this.vertexArray, A, D, 0, 0, ne), y.vertexLength += 4;
                const ge = Vv(A, D, R, o);
                for (const ue of ge) this._segmentToGroundQuads[h].push({ id: me, region: ue }), this._segmentToRegionTriCounts[h][ue] += 2, y.primitiveLength += 2;
                T = j;
              }
            }
          }
          prepareBorderSegments() {
            if (!this.hasData()) return;
            const e = this._segments.get(), i = e.length;
            for (let o = 0; o < i; o++) this._segmentToGroundQuads[o].sort((c, s) => c.region - s.region);
            for (let o = 0; o < i; o++) {
              const c = this._segmentToGroundQuads[o], s = e[o], h = this._segmentToRegionTriCounts[o];
              h.reduce((T, k) => T + k, 0);
              let y = 0;
              for (let T = 0; T <= 4; T++) {
                const k = h[T];
                if (k !== 0) {
                  let g = this.regionSegments[T];
                  g || (g = this.regionSegments[T] = new Nn());
                  const A = { vertexOffset: s.vertexOffset, primitiveOffset: s.primitiveOffset + y, vertexLength: s.vertexLength, primitiveLength: k };
                  g.get().push(A);
                }
                y += k;
              }
              for (let T = 0; T < c.length; T++) {
                const k = c[T].id;
                this.indexArray.emplaceBack(k, k + 1, k + 3), this.indexArray.emplaceBack(k, k + 3, k + 2);
              }
            }
            this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
          }
          addPaintPropertiesData(e, i, o, c, s, h) {
            this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, e, i, o, c, s, h);
          }
          upload(e) {
            this.hasData() && (this.vertexBuffer = e.createVertexBuffer(this.vertexArray, Oa.members), this.indexBuffer = e.createIndexBuffer(this.indexArray));
          }
          uploadPaintProperties(e) {
            this.hasData() && this.programConfigurations.upload(e);
          }
          update(e, i, o, c, s, h, y) {
            this.hasData() && this.programConfigurations.updatePaintArrays(e, i, o, c, s, h, y);
          }
          updateHiddenByLandmark(e) {
            if (!this.hasData()) return;
            const i = e.groundVertexCount + e.groundVertexArrayOffset;
            if (e.groundVertexCount === 0) return;
            const o = e.flags & _h ? 1 : 0;
            for (let c = e.groundVertexArrayOffset; c < i; ++c) this.hiddenByLandmarkVertexArray.emplace(c, o);
            this._needsHiddenByLandmarkUpdate = !0;
          }
          uploadHiddenByLandmark(e) {
            this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = e.createVertexBuffer(this.hiddenByLandmarkVertexArray, Jp.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);
          }
          destroy() {
            if (this.vertexBuffer) {
              this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
              for (let e = 0; e <= 4; e++) {
                const i = this.regionSegments[e];
                i && i.destroy();
              }
            }
          }
        }
        class ap {
          constructor(e) {
            this.zoom = e.zoom, this.canonical = e.canonical, this.overscaling = e.overscaling, this.layers = e.layers, this.pixelRatio = e.pixelRatio, this.layerIds = this.layers.map((i) => i.fqid), this.index = e.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = e.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new ha(), this.footprintVertices = new Ga(), this.footprintSegments = [], this.layoutVertexArray = new Dn(), this.centroidVertexArray = new Ha(), this.wallVertexArray = new Jh(), this.indexArray = new ha(), this.programConfigurations = new Ls(e.layers, { zoom: e.zoom, lut: e.lut }, (i) => Bv.includes(i)), this.segments = new Nn(), this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id), this.groundEffect = new sg(e), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
          }
          updateFootprints(e, i) {
          }
          populate(e, i, o, c) {
            this.features = [], this.hasPattern = Ei("fill-extrusion", this.layers, this.pixelRatio, i), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this.tileToMeter = t(o), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1) !== 0;
            for (const { feature: s, id: h, index: y, sourceLayerIndex: T } of e) {
              const k = this.layers[0]._featureFilter.needGeometry, g = ae(s, k);
              if (!this.layers[0]._featureFilter.filter(new sn(this.zoom), g, o)) continue;
              const A = { id: h, sourceLayerIndex: T, index: y, geometry: k ? g.geometry : K(s, o, c), properties: s.properties, type: s.type, patterns: {} }, D = this.layoutVertexArray.length, S = am[A.type] === "Polygon";
              if (this.hasPattern) this.features.push(Ti("fill-extrusion", this.layers, A, this.zoom, this.pixelRatio, i));
              else if (this.wallMode) for (const R of A.geometry) for (const j of tg(R, S)) this.addFeature(A, [j], y, o, {}, i.availableImages, c, i.brightness);
              else this.addFeature(A, A.geometry, y, o, {}, i.availableImages, c, i.brightness);
              i.featureIndex.insert(s, A.geometry, y, T, this.index, D);
            }
            this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
          }
          addFeatures(e, i, o, c, s, h) {
            for (const y of this.features) {
              const T = am[y.type] === "Polygon", { geometry: k } = y;
              if (this.wallMode) for (const g of k) for (const A of tg(g, T)) this.addFeature(y, [A], y.index, i, o, c, s, h);
              else this.addFeature(y, k, y.index, i, o, c, s, h);
            }
            this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles();
          }
          update(e, i, o, c, s, h, y) {
            this.programConfigurations.updatePaintArrays(e, i, s, o, c, h, y), this.groundEffect.update(e, i, s, o, c, h, y);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, zv), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.wallVertexBuffer = e.createVertexBuffer(this.wallVertexArray, Uu.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = e.createVertexBuffer(this.layoutVertexExtArray, kv.members, !0)), this.groundEffect.upload(e)), this.groundEffect.uploadPaintProperties(e), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          uploadCentroid(e) {
            this.groundEffect.uploadHiddenByLandmark(e), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, En.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(e, i, o, c, s, h, y, T) {
            const k = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(e, {}) / this.tileToMeter, g = [new Ye(0, 0), new Ye(Br, Br)], A = y.projection, D = A.name === "globe", S = this.wallMode || am[e.type] === "Polygon", R = new ag();
            R.centroidDataIndex = this.centroidData.length;
            const j = new ng(), J = this.layers[0].paint.get("fill-extrusion-base").evaluate(e, {}, c) <= 0, ne = this.layers[0].paint.get("fill-extrusion-height").evaluate(e, {}, c);
            let me;
            if (j.height = ne, j.vertexArrayOffset = this.layoutVertexArray.length, j.groundVertexArrayOffset = this.groundEffect.vertexArray.length, D && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new ca()), this.wallMode) {
              if (D) return void Tt("Non zero fill-extrusion-line-width is not yet supported on globe.");
              if (i.length !== 1) return;
              me = function(tt) {
                const Et = tt[0].x === tt[tt.length - 1].x && tt[0].y === tt[tt.length - 1].y;
                (function(Ar) {
                  let vr = 0;
                  const ti = Ar.length;
                  for (let Wr = 0; Wr < ti; Wr++) vr += (Ar[(Wr + 1) % ti].x - Ar[Wr].x) * (Ar[(Wr + 1) % ti].y + Ar[Wr].y);
                  return vr >= 0;
                })(tt) || (tt = tt.reverse());
                const St = { geometry: [], joinNormals: [], indices: [] }, Lt = [], It = [], zt = [];
                let Ft = tt.length;
                for (; Ft >= 2 && tt[Ft - 1].equals(tt[Ft - 2]); ) Ft--;
                if (Ft < (Et ? 3 : 2)) return St;
                let qt, Ot, cr, yr, ur, jr = 0;
                for (; jr < Ft - 1 && tt[jr].equals(tt[jr + 1]); ) jr++;
                Et && (qt = tt[Ft - 2], ur = tt[jr].sub(qt)._unit()._perp());
                for (let Ar = jr; Ar < Ft; Ar++) {
                  if (cr = Ar === Ft - 1 ? Et ? tt[jr + 1] : void 0 : tt[Ar + 1], cr && tt[Ar].equals(cr)) continue;
                  ur && (yr = ur), qt && (Ot = qt), qt = tt[Ar], ur = cr ? cr.sub(qt)._unit()._perp() : yr, yr = yr || ur;
                  let vr = yr.add(ur);
                  vr.x === 0 && vr.y === 0 || vr._unit();
                  const ti = vr.x * ur.x + vr.y * ur.y, Wr = ti !== 0 ? 1 / ti : 1 / 0, $r = yr.x * ur.y - yr.y * ur.x > 0;
                  let bi = "miter";
                  const Ci = 2;
                  bi === "miter" && Wr > Ci && (bi = "bevel"), bi === "bevel" && (Wr > 100 && (bi = "flipbevel"), Wr < Ci && (bi = "miter"));
                  const Pi = (Ri, ji, Hi, gn) => {
                    const cn = new Ye(Ri.x, Ri.y), Si = new Ye(Ri.x, Ri.y);
                    cn.x += ji.x * gn, cn.y += ji.y * gn, Si.x -= ji.x * Math.max(Hi, 1), Si.y -= ji.y * Math.max(Hi, 1), zt.push(ji), Lt.push(cn), It.push(Si);
                  };
                  if (bi === "miter") vr._mult(Wr), Pi(qt, vr, 0, 0);
                  else if (bi === "flipbevel") vr = ur.mult(-1), Pi(qt, vr, 0, 0), Pi(qt, vr.mult(-1), 0, 0);
                  else {
                    const Ri = -Math.sqrt(Wr * Wr - 1), ji = $r ? Ri : 0, Hi = $r ? 0 : Ri;
                    Ot && Pi(qt, yr, ji, Hi), cr && Pi(qt, ur, ji, Hi);
                  }
                }
                St.geometry = [...Lt, ...It.reverse(), Lt[0]], St.joinNormals = [...zt, ...zt.reverse(), zt[zt.length - 1]];
                const zr = St.geometry.length - 1;
                for (let Ar = 0; Ar < zr / 2; Ar++) if (Ar + 1 < zr / 2) {
                  let vr = Ar, ti = Ar + 1, Wr = zr - 1 - Ar, $r = zr - 2 - Ar;
                  vr = vr === 0 ? zr - 1 : vr - 1, ti = ti === 0 ? zr - 1 : ti - 1, Wr = Wr === 0 ? zr - 1 : Wr - 1, $r = $r === 0 ? zr - 1 : $r - 1, St.indices.push(Wr), St.indices.push(ti), St.indices.push(vr), St.indices.push(Wr), St.indices.push($r), St.indices.push(ti);
                }
                return St;
              }(i[0]), i = [me.geometry];
            }
            const ge = (tt, Et) => tt < (Et.length - 1) / 2 || tt === Et.length - 1, ue = this.wallMode ? [i] : ei(i, 500);
            for (let tt = ue.length - 1; tt >= 0; tt--) {
              const Et = ue[tt];
              (Et.length === 0 || (Se = Et[0]).every((lt) => lt.x <= 0) || Se.every((lt) => lt.x >= Br) || Se.every((lt) => lt.y <= 0) || Se.every((lt) => lt.y >= Br)) && ue.splice(tt, 1);
            }
            var Se;
            let ke;
            if (D) ke = pg(ue, g, c);
            else {
              ke = [];
              for (const tt of ue) ke.push({ polygon: tt, bounds: g });
            }
            const He = S ? this.edgeRadius : 0, at = He > 0 && this.zoom < 17, nt = (tt, Et) => {
              if (tt.length === 0) return !1;
              const lt = tt[tt.length - 1];
              return Et.x === lt.x && Et.y === lt.y;
            };
            for (const { polygon: tt, bounds: Et } of ke) {
              let lt = 0, St = 0;
              for (const Ft of tt) S && !Ft[0].equals(Ft[Ft.length - 1]) && Ft.push(Ft[0]), St += S ? Ft.length - 1 : Ft.length;
              const Lt = this.segments.prepareSegment((S ? 5 : 4) * St, this.layoutVertexArray, this.indexArray);
              j.footprintSegIdx < 0 && (j.footprintSegIdx = this.footprintSegments.length), j.polygonSegIdx < 0 && (j.polygonSegIdx = this.polygonSegments.length);
              const It = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, zt = new ig();
              if (zt.vertexOffset = this.footprintVertices.length, zt.indexOffset = 3 * this.footprintIndices.length, zt.ringIndices = [], S) {
                const Ft = [], qt = [];
                lt = Lt.vertexLength;
                for (let cr = 0; cr < tt.length; cr++) {
                  const yr = tt[cr];
                  yr.length && cr !== 0 && qt.push(Ft.length / 2);
                  const ur = [];
                  let jr, zr;
                  jr = yr[1].sub(yr[0])._perp()._unit(), zt.ringIndices.push(yr.length - 1);
                  for (let Ar = 1; Ar < yr.length; Ar++) {
                    const vr = yr[Ar], ti = yr[Ar === yr.length - 1 ? 1 : Ar + 1], Wr = vr.clone();
                    if (He) {
                      zr = ti.sub(vr)._perp()._unit();
                      const $r = jr.add(zr)._unit(), bi = He * Math.min(4, 1 / (jr.x * $r.x + jr.y * $r.y));
                      Wr.x += bi * $r.x, Wr.y += bi * $r.y, Wr.x = Math.round(Wr.x), Wr.y = Math.round(Wr.y), jr = zr;
                    }
                    if (!J || He !== 0 && !at || nt(ur, Wr) || ur.push(Wr), xd(this.layoutVertexArray, Wr.x, Wr.y, 0, 0, 1, 1, 0), this.wallMode) {
                      const $r = ge(Ar, yr);
                      bd(this.wallVertexArray, me.joinNormals[Ar], !$r);
                    }
                    Lt.vertexLength++, this.footprintVertices.emplaceBack(vr.x, vr.y), Ft.push(vr.x, vr.y), D && wd(this.layoutVertexExtArray, A.projectTilePoint(Wr.x, Wr.y, c), A.upVector(c, Wr.x, Wr.y));
                  }
                  J && (He === 0 || at) && (ur.length !== 0 && nt(ur, ur[0]) && ur.pop(), this.groundEffect.addData(ur, Et, k));
                }
                const Ot = this.wallMode ? me.indices : mh(Ft, qt);
                for (let cr = 0; cr < Ot.length; cr += 3) this.footprintIndices.emplaceBack(zt.vertexOffset + Ot[cr + 0], zt.vertexOffset + Ot[cr + 1], zt.vertexOffset + Ot[cr + 2]), this.indexArray.emplaceBack(lt + Ot[cr], lt + Ot[cr + 2], lt + Ot[cr + 1]), Lt.primitiveLength++;
                zt.indexCount += Ot.length, zt.vertexCount += this.footprintVertices.length - zt.vertexOffset;
              }
              for (let Ft = 0; Ft < tt.length; Ft++) {
                const qt = tt[Ft];
                R.startRing(j, qt[0]);
                let Ot = qt.length > 4 && hg(qt[qt.length - 2], qt[0], qt[1]), cr = He ? Gv(qt[qt.length - 2], qt[0], qt[1], He) : 0;
                const yr = [];
                let ur, jr, zr;
                jr = qt[1].sub(qt[0])._perp()._unit();
                let Ar = !0;
                for (let vr = 1, ti = 0; vr < qt.length; vr++) {
                  let Wr = qt[vr - 1], $r = qt[vr];
                  const bi = qt[vr === qt.length - 1 ? 1 : vr + 1];
                  if (R.appendEdge(j, $r, Wr), om($r, Wr, Et)) {
                    He && (jr = bi.sub($r)._perp()._unit(), Ar = !Ar);
                    continue;
                  }
                  const Ci = $r.sub(Wr)._perp(), Pi = Ci.x / (Math.abs(Ci.x) + Math.abs(Ci.y)), Ri = Ci.y > 0 ? 1 : 0, ji = Wr.dist($r);
                  if (ti + ji > 32768 && (ti = 0), He) {
                    zr = bi.sub($r)._perp()._unit();
                    let Si = ug(Wr, $r, bi, lg(jr, zr), He);
                    isNaN(Si) && (Si = 0);
                    const an = $r.sub(Wr)._unit();
                    Wr = Wr.add(an.mult(cr))._round(), $r = $r.add(an.mult(-Si))._round(), cr = Si, jr = zr, J && this.zoom >= 17 && (nt(yr, Wr) || yr.push(Wr), nt(yr, $r) || yr.push($r));
                  }
                  const Hi = Lt.vertexLength, gn = qt.length > 4 && hg(Wr, $r, bi);
                  let cn = fg(ti, Ot, Ar);
                  if (xd(this.layoutVertexArray, Wr.x, Wr.y, Pi, Ri, 0, 0, cn), xd(this.layoutVertexArray, Wr.x, Wr.y, Pi, Ri, 0, 1, cn), this.wallMode) {
                    const Si = ge(vr - 1, qt), an = me.joinNormals[vr - 1];
                    bd(this.wallVertexArray, an, Si), bd(this.wallVertexArray, an, Si);
                  }
                  if (ti += ji, cn = fg(ti, gn, !Ar), Ot = gn, xd(this.layoutVertexArray, $r.x, $r.y, Pi, Ri, 0, 0, cn), xd(this.layoutVertexArray, $r.x, $r.y, Pi, Ri, 0, 1, cn), this.wallMode) {
                    const Si = ge(vr, qt), an = me.joinNormals[vr];
                    bd(this.wallVertexArray, an, Si), bd(this.wallVertexArray, an, Si);
                  }
                  if (Lt.vertexLength += 4, this.indexArray.emplaceBack(Hi + 0, Hi + 1, Hi + 2), this.indexArray.emplaceBack(Hi + 1, Hi + 3, Hi + 2), Lt.primitiveLength += 2, He) {
                    const Si = lt + (vr === 1 ? qt.length - 2 : vr - 2), an = vr === 1 ? lt : Si + 1;
                    if (this.indexArray.emplaceBack(Hi + 1, Si, Hi + 3), this.indexArray.emplaceBack(Si, an, Hi + 3), Lt.primitiveLength += 2, ur === void 0 && (ur = Hi), !om(bi, qt[vr], Et)) {
                      const un = vr === qt.length - 1 ? ur : Lt.vertexLength;
                      this.indexArray.emplaceBack(Hi + 2, Hi + 3, un), this.indexArray.emplaceBack(Hi + 3, un + 1, un), this.indexArray.emplaceBack(Hi + 3, an, un + 1), Lt.primitiveLength += 3;
                    }
                    Ar = !Ar;
                  }
                  if (D) {
                    const Si = this.layoutVertexExtArray, an = A.projectTilePoint(Wr.x, Wr.y, c), un = A.projectTilePoint($r.x, $r.y, c), Sn = A.upVector(c, Wr.x, Wr.y), $n = A.upVector(c, $r.x, $r.y);
                    wd(Si, an, Sn), wd(Si, an, Sn), wd(Si, un, $n), wd(Si, un, $n);
                  }
                }
                S && (lt += qt.length - 1), J && He && this.zoom >= 17 && (yr.length !== 0 && nt(yr, yr[0]) && yr.pop(), this.groundEffect.addData(yr, Et, k, He > 0));
              }
              this.footprintSegments.push(zt), It.triangleCount = this.indexArray.length - It.triangleArrayOffset, this.polygonSegments.push(It), ++j.footprintSegLen, ++j.polygonSegLen;
            }
            if (j.vertexCount = this.layoutVertexArray.length - j.vertexArrayOffset, j.groundVertexCount = this.groundEffect.vertexArray.length - j.groundVertexArrayOffset, j.vertexCount !== 0) {
              if (j.centroidXY = R.borders ? rg : this.encodeCentroid(R, j), this.centroidData.push(j), R.borders) {
                this.featuresOnBorder.push(R);
                const tt = this.featuresOnBorder.length - 1;
                for (let Et = 0; Et < R.borders.length; Et++) R.borders[Et][0] !== Number.MAX_VALUE && this.borderFeatureIndices[Et].push(tt);
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, s, h, c, T), this.groundEffect.addPaintPropertiesData(e, o, s, h, c, T), this.maxHeight = Math.max(this.maxHeight, ne);
            }
          }
          sortBorders() {
            for (let e = 0; e < this.borderFeatureIndices.length; e++) this.borderFeatureIndices[e].sort((i, o) => this.featuresOnBorder[i].borders[e][0] - this.featuresOnBorder[o].borders[e][0]);
          }
          splitToSubtiles() {
            const e = [];
            for (let y = 0; y < this.centroidData.length; y++) {
              const T = this.centroidData[y], k = +(T.min.y + T.max.y > Br), g = 2 * k + (+(T.min.x + T.max.x > Br) ^ k);
              for (let A = 0; A < T.polygonSegLen; A++) {
                const D = T.polygonSegIdx + A;
                e.push({ centroidIdx: y, subtile: g, polygonSegmentIdx: D, triangleSegmentIdx: this.polygonSegments[D].triangleSegIdx });
              }
            }
            const i = new ha();
            e.sort((y, T) => y.triangleSegmentIdx === T.triangleSegmentIdx ? y.subtile - T.subtile : y.triangleSegmentIdx - T.triangleSegmentIdx);
            let o = 0, c = 0, s = 0;
            for (const y of e) {
              if (y.triangleSegmentIdx !== o) break;
              s++;
            }
            const h = e.length;
            for (; c !== e.length; ) {
              o = e[c].triangleSegmentIdx;
              let y = 0, T = c, k = c;
              for (let g = T; g < s && e[g].subtile === y; g++) k++;
              for (; T !== s; ) {
                const g = e[T];
                y = g.subtile;
                const A = this.centroidData[g.centroidIdx].min.clone(), D = this.centroidData[g.centroidIdx].max.clone(), S = { vertexOffset: this.segments.segments[o].vertexOffset, primitiveOffset: i.length, vertexLength: this.segments.segments[o].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
                for (let R = T; R < k; R++) {
                  const j = e[R], J = this.polygonSegments[j.polygonSegmentIdx], ne = this.centroidData[j.centroidIdx].min, me = this.centroidData[j.centroidIdx].max, ge = this.indexArray.uint16;
                  for (let ue = J.triangleArrayOffset; ue < J.triangleArrayOffset + J.triangleCount; ue++) i.emplaceBack(ge[3 * ue], ge[3 * ue + 1], ge[3 * ue + 2]);
                  S.primitiveLength += J.triangleCount, A.x = Math.min(A.x, ne.x), A.y = Math.min(A.y, ne.y), D.x = Math.max(D.x, me.x), D.y = Math.max(D.y, me.y);
                }
                S.primitiveLength > 0 && this.triangleSubSegments.push({ segment: S, min: A, max: D }), T = k;
                for (let R = T; R < s && e[R].subtile === e[T].subtile; R++) k++;
              }
              c = s;
              for (let g = c; g < h && e[g].triangleSegmentIdx === e[c].triangleSegmentIdx; g++) s++;
            }
            i._trim(), this.indexArray = i;
          }
          getVisibleSegments(e, i, o) {
            const c = new Nn();
            if (this.wallMode) {
              for (const j of this.triangleSubSegments) c.segments.push(j.segment);
              return c;
            }
            let s = 0, h = 0;
            const y = 1 << e.canonical.z;
            if (i) {
              const j = i.getMinMaxForTile(e);
              j && (s = j.min, h = j.max);
            }
            h += this.maxHeight;
            const T = e.toUnwrapped();
            let k;
            const g = [T.canonical.x / y + T.wrap, T.canonical.y / y], A = [(T.canonical.x + 1) / y + T.wrap, (T.canonical.y + 1) / y], D = (j, J, ne) => [j[0] * (1 - ne[0]) + J[0] * ne[0], j[1] * (1 - ne[1]) + J[1] * ne[1]], S = [], R = [];
            for (const j of this.triangleSubSegments) {
              S[0] = j.min.x / Br, S[1] = j.min.y / Br, R[0] = j.max.x / Br, R[1] = j.max.y / Br;
              const J = D(g, A, S), ne = D(g, A, R);
              if (new Yr([J[0], J[1], s], [ne[0], ne[1], h]).intersectsPrecise(o) === 0) {
                k && (c.segments.push(k), k = void 0);
                continue;
              }
              const me = j.segment;
              k && k.vertexOffset !== me.vertexOffset && (c.segments.push(k), k = void 0), k ? (k.vertexLength += me.vertexLength, k.primitiveLength += me.primitiveLength) : k = { vertexOffset: me.vertexOffset, primitiveLength: me.primitiveLength, vertexLength: me.vertexLength, primitiveOffset: me.primitiveOffset, sortKey: void 0, vaos: {} };
            }
            return k && c.segments.push(k), c;
          }
          encodeCentroid(e, i) {
            const o = e.centroid(), c = i.span(), s = Math.min(7, Math.round(c.x * this.tileToMeter / 10)), h = Math.min(7, Math.round(c.y * this.tileToMeter / 10));
            return new Ye(ie(o.x, 1, Br - 1) << 3 | s, ie(o.y, 1, Br - 1) << 3 | h);
          }
          encodeBorderCentroid(e) {
            if (!e.borders) return new Ye(0, 0);
            const i = e.borders, o = Number.MAX_VALUE;
            if (i[0][0] !== o || i[1][0] !== o) {
              const c = i[0][0] !== o ? 0 : 1;
              return new Ye(6 | (i[0][0] !== o ? 0 : 65528), (i[c][0] + i[c][1]) / 2 << 3 | 6);
            }
            {
              const c = i[2][0] !== o ? 2 : 3;
              return new Ye((i[c][0] + i[c][1]) / 2 << 3 | 6, 6 | (i[2][0] !== o ? 0 : 65528));
            }
          }
          showCentroid(e) {
            const i = this.centroidData[e.centroidDataIndex];
            i.flags &= _h, i.centroidXY.x = 0, i.centroidXY.y = 0, this.writeCentroidToBuffer(i);
          }
          writeCentroidToBuffer(e) {
            this.groundEffect.updateHiddenByLandmark(e);
            const i = e.vertexArrayOffset, o = e.vertexCount + e.vertexArrayOffset, c = e.flags & _h ? rg : e.centroidXY, s = this.centroidVertexArray.geta_centroid_pos0(i);
            if (this.centroidVertexArray.geta_centroid_pos1(i) !== c.y || s !== c.x) {
              for (let h = i; h < o; ++h) this.centroidVertexArray.emplace(h, c.x, c.y);
              this.needsCentroidUpdate = !0;
            }
          }
          createCentroidsBuffer() {
            this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
            for (const e of this.centroidData) this.writeCentroidToBuffer(e);
          }
          updateReplacement(e, i, o) {
            if (i.updateTime === this.replacementUpdateTime) return;
            this.replacementUpdateTime = i.updateTime;
            const c = i.getReplacementRegionsForTile(e.toUnwrapped());
            if (im(this.activeReplacements, c)) return;
            if (this.activeReplacements = c, this.centroidVertexArray.length === 0) this.createCentroidsBuffer();
            else for (const h of this.centroidData) h.flags &= 2147483647;
            const s = [];
            for (const h of this.activeReplacements) {
              if (h.order < o) continue;
              const y = Math.max(1, Math.pow(2, h.footprintTileId.canonical.z - e.canonical.z));
              for (const T of this.centroidData) if (!(T.flags & _h || h.min.x > T.max.x || T.min.x > h.max.x || h.min.y > T.max.y || T.min.y > h.max.y)) for (let k = 0; k < T.footprintSegLen; k++) {
                const g = this.footprintSegments[T.footprintSegIdx + k];
                if (s.length = 0, Hv(this.footprintVertices, g.vertexOffset, g.vertexCount, h.footprintTileId.canonical, e.canonical, s), K_(h.footprint, s, this.footprintIndices.uint16, g.indexOffset, g.indexCount, -g.vertexOffset, -y)) {
                  T.flags |= _h;
                  break;
                }
              }
            }
            for (const h of this.centroidData) this.writeCentroidToBuffer(h);
            this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
          }
          footprintContainsPoint(e, i, o) {
            let c = !1;
            for (let s = 0; s < o.footprintSegLen; s++) {
              const h = this.footprintSegments[o.footprintSegIdx + s];
              let y = 0;
              for (const T of h.ringIndices) {
                for (let k = y, g = T + y - 1; k < T + y; g = k++) {
                  const A = this.footprintVertices.int16[2 * (k + h.vertexOffset) + 0], D = this.footprintVertices.int16[2 * (k + h.vertexOffset) + 1], S = this.footprintVertices.int16[2 * (g + h.vertexOffset) + 1];
                  D > i != S > i && e < (this.footprintVertices.int16[2 * (g + h.vertexOffset) + 0] - A) * (i - D) / (S - D) + A && (c = !c);
                }
                y = T;
              }
            }
            return c;
          }
          getHeightAtTileCoord(e, i) {
            let o = Number.NEGATIVE_INFINITY, c = !0;
            const s = 4 * (e + Br) * Br + (i + Br);
            if (this.partLookup.hasOwnProperty(s)) {
              const h = this.partLookup[s];
              return h ? { height: h.height, hidden: !!(h.flags & _h) } : void 0;
            }
            for (const h of this.centroidData) e > h.max.x || h.min.x > e || i > h.max.y || h.min.y > i || this.footprintContainsPoint(e, i, h) && h && h.height > o && (o = h.height, this.partLookup[s] = h, c = !!(h.flags & _h));
            if (o !== Number.NEGATIVE_INFINITY) return { height: o, hidden: c };
            this.partLookup[s] = void 0;
          }
        }
        function lg(a, e) {
          const i = a.add(e)._unit();
          return a.x * i.x + a.y * i.y;
        }
        function Gv(a, e, i, o) {
          const c = e.sub(a)._perp()._unit(), s = i.sub(e)._perp()._unit();
          return ug(a, e, i, lg(c, s), o);
        }
        function ug(a, e, i, o, c) {
          const s = Math.sqrt(1 - o * o);
          return Math.min(a.dist(e) / 3, e.dist(i) / 3, c * s / o);
        }
        function om(a, e, i) {
          return a.x < i[0].x && e.x < i[0].x || a.x > i[1].x && e.x > i[1].x || a.y < i[0].y && e.y < i[0].y || a.y > i[1].y && e.y > i[1].y;
        }
        function cg(a, e) {
          return a.x < e[0].x || a.x > e[1].x || a.y < e[0].y || a.y > e[1].y;
        }
        function hg(a, e, i) {
          if (a.x < 0 || a.x >= Br || e.x < 0 || e.x >= Br || i.x < 0 || i.x >= Br) return !1;
          const o = i.sub(e), c = o.perp(), s = a.sub(e);
          return (o.x * s.x + o.y * s.y) / Math.sqrt((o.x * o.x + o.y * o.y) * (s.x * s.x + s.y * s.y)) > -0.866 && c.x * s.x + c.y * s.y < 0;
        }
        function fg(a, e, i) {
          const o = e ? 2 | a : -3 & a;
          return i ? 1 | o : -2 & o;
        }
        function dg() {
          const a = Math.PI / 32, e = Math.tan(a), i = fl;
          return i * Math.sqrt(1 + 2 * e * e) - i;
        }
        function pg(a, e, i) {
          const o = 1 << i.z, c = so(i.x / o), s = so((i.x + 1) / o), h = ci(i.y / o), y = ci((i.y + 1) / o);
          return function(T, k, g, A, D = 0, S) {
            const R = [];
            if (!T.length || !g || !A) return R;
            const j = (ke, He) => {
              for (const at of ke) R.push({ polygon: at, bounds: He });
            }, J = Math.ceil(Math.log2(g)), ne = Math.ceil(Math.log2(A)), me = J - ne, ge = [];
            for (let ke = 0; ke < Math.abs(me); ke++) ge.push(me > 0 ? 0 : 1);
            for (let ke = 0; ke < Math.min(J, ne); ke++) ge.push(0), ge.push(1);
            let ue = T;
            if (ue = tp(ue, k[0].y - D, k[1].y + D, 1), ue = tp(ue, k[0].x - D, k[1].x + D, 0), !ue.length) return R;
            const Se = [];
            for (ge.length ? Se.push({ polygons: ue, bounds: k, depth: 0 }) : j(ue, k); Se.length; ) {
              const ke = Se.pop(), He = ke.depth, at = ge[He], nt = ke.bounds[0], tt = ke.bounds[1], Et = at === 0 ? nt.x : nt.y, lt = at === 0 ? tt.x : tt.y, St = S(at, Et, lt), Lt = tp(ke.polygons, Et - D, St + D, at), It = tp(ke.polygons, St - D, lt + D, at);
              if (Lt.length) {
                const zt = [nt, new Ye(at === 0 ? St : tt.x, at === 1 ? St : tt.y)];
                ge.length > He + 1 ? Se.push({ polygons: Lt, bounds: zt, depth: He + 1 }) : j(Lt, zt);
              }
              if (It.length) {
                const zt = [new Ye(at === 0 ? St : nt.x, at === 1 ? St : nt.y), tt];
                ge.length > He + 1 ? Se.push({ polygons: It, bounds: zt, depth: He + 1 }) : j(It, zt);
              }
            }
            return R;
          }(a, e, Math.ceil((s - c) / 11.25), Math.ceil((h - y) / 11.25), 1, (T, k, g) => {
            if (T === 0) return 0.5 * (k + g);
            {
              const A = ci((i.y + k / Br) / o);
              return (oo(0.5 * (ci((i.y + g / Br) / o) + A)) * o - i.y) * Br;
            }
          });
        }
        function Hv(a, e, i, o, c, s) {
          const h = Math.pow(2, o.z - c.z);
          for (let y = 0; y < i; y++) {
            let T = a.int16[2 * (y + e) + 0], k = a.int16[2 * (y + e) + 1];
            T = (T + c.x * Br) * h - o.x * Br, k = (k + c.y * Br) * h - o.y * Br, s.push(new Ye(T, k));
          }
        }
        let mg, _g;
        function Ed(a, e) {
          return a.x * e.x + a.y * e.y;
        }
        function gg(a, e) {
          if (a.length === 1) {
            let i = 0;
            const o = e[i++];
            let c;
            for (; !c || o.equals(c); ) if (c = e[i++], !c) return 1 / 0;
            for (; i < e.length; i++) {
              const s = e[i], h = a[0], y = c.sub(o), T = s.sub(o), k = h.sub(o), g = Ed(y, y), A = Ed(y, T), D = Ed(T, T), S = Ed(k, y), R = Ed(k, T), j = g * D - A * A, J = (D * S - A * R) / j, ne = (g * R - A * S) / j, me = o.z * (1 - J - ne) + c.z * J + s.z * ne;
              if (isFinite(me)) return me;
            }
            return 1 / 0;
          }
          {
            let i = 1 / 0;
            for (const o of e) i = Math.min(i, o.z);
            return i;
          }
        }
        function yg(a, e, i, o, c, s, h, y) {
          const T = h * c.getElevationAt(a, e, !0, !0), k = s[0] !== 0, g = k ? s[1] === 0 ? h * (s[0] / 7 - 450) : h * function(A, D, S) {
            const R = Math.floor(D[0] / 8), j = Math.floor(D[1] / 8), J = 10 * (D[0] - 8 * R), ne = 10 * (D[1] - 8 * j), me = A.getElevationAt(R, j, !0, !0), ge = A.getMeterToDEM(S), ue = Math.floor(0.5 * (J * ge - 1)), Se = Math.floor(0.5 * (ne * ge - 1)), ke = A.tileCoordToPixel(R, j), He = 2 * ue + 1, at = 2 * Se + 1, nt = function(It, zt, Ft, qt, Ot) {
              return [It.getElevationAtPixel(zt, Ft, !0), It.getElevationAtPixel(zt + Ot, Ft, !0), It.getElevationAtPixel(zt, Ft + Ot, !0), It.getElevationAtPixel(zt + qt, Ft + Ot, !0)];
            }(A, ke.x - ue, ke.y - Se, He, at), tt = Math.abs(nt[0] - nt[1]), Et = Math.abs(nt[2] - nt[3]), lt = Math.abs(nt[0] - nt[2]) + Math.abs(nt[1] - nt[3]), St = Math.min(0.25, 0.5 * ge * (tt + Et) / He), Lt = Math.min(0.25, 0.5 * ge * lt / at);
            return me + Math.max(St * J, Lt * ne);
          }(c, s, y) : T;
          return { base: T + (i === 0 ? -1 : i), top: k ? Math.max(g + o, T + i + 2) : T + o };
        }
        Gr(ap, "FillExtrusionBucket", { omit: ["layers", "features"] }), Gr(ng, "PartData"), Gr(ig, "FootprintSegment"), Gr(ag, "BorderCentroidData"), Gr(sg, "GroundEffect");
        const Wv = Yi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), Zv = Yi([{ name: "a_z_offset_width", components: 3, type: "Float32" }], 4), { members: qv } = Wv, $v = Yi([{ name: "a_packed", components: 3, type: "Float32" }]), { members: Xv } = $v, Yv = Yi([{ name: "a_pattern_data", components: 3, type: "Float32" }]), { members: Kv } = Yv;
        class vg {
          constructor(e, i) {
            this.width = e, this.height = i, this.nextRow = 0, this.image = new dl({ width: e, height: i }), this.positions = {}, this.uploaded = !1;
          }
          getDash(e, i) {
            const o = this.getKey(e, i);
            return this.positions[o];
          }
          trim() {
            const e = this.width, i = this.height = kr(this.nextRow);
            this.image.resize({ width: e, height: i });
          }
          getKey(e, i) {
            return e.join(",") + i;
          }
          getDashRanges(e, i, o) {
            const c = [];
            let s = e.length % 2 == 1 ? -e[e.length - 1] * o : 0, h = e[0] * o, y = !0;
            c.push({ left: s, right: h, isDash: y, zeroLength: e[0] === 0 });
            let T = e[0];
            for (let k = 1; k < e.length; k++) {
              y = !y;
              const g = e[k];
              s = T * o, T += g, h = T * o, c.push({ left: s, right: h, isDash: y, zeroLength: g === 0 });
            }
            return c;
          }
          addRoundDash(e, i, o) {
            const c = i / 2;
            for (let s = -o; s <= o; s++) {
              const h = this.width * (this.nextRow + o + s);
              let y = 0, T = e[y];
              for (let k = 0; k < this.width; k++) {
                k / T.right > 1 && (T = e[++y]);
                const g = Math.abs(k - T.left), A = Math.abs(k - T.right), D = Math.min(g, A);
                let S;
                const R = s / o * (c + 1);
                if (T.isDash) {
                  const j = c - Math.abs(R);
                  S = Math.sqrt(D * D + j * j);
                } else S = c - Math.sqrt(D * D + R * R);
                this.image.data[h + k] = Math.max(0, Math.min(255, S + 128));
              }
            }
          }
          addRegularDash(e, i) {
            for (let T = e.length - 1; T >= 0; --T) {
              const k = e[T], g = e[T + 1];
              k.zeroLength ? e.splice(T, 1) : g && g.isDash === k.isDash && (g.left = k.left, e.splice(T, 1));
            }
            const o = e[0], c = e[e.length - 1];
            o.isDash === c.isDash && (o.left = c.left - this.width, c.right = o.right + this.width);
            const s = this.width * this.nextRow;
            let h = 0, y = e[h];
            for (let T = 0; T < this.width; T++) {
              T / y.right > 1 && (y = e[++h]);
              const k = Math.abs(T - y.left), g = Math.abs(T - y.right), A = Math.min(k, g);
              this.image.data[s + T] = Math.max(0, Math.min(255, (y.isDash ? A : -A) + i + 128));
            }
          }
          addDash(e, i) {
            const o = this.getKey(e, i);
            if (this.positions[o]) return this.positions[o];
            const c = i === "round", s = c ? 7 : 0, h = 2 * s + 1;
            if (this.nextRow + h > this.height) return Tt("LineAtlas out of space"), null;
            e.length === 0 && e.push(1);
            let y = 0;
            for (let g = 0; g < e.length; g++) e[g] < 0 && (Tt("Negative value is found in line dasharray, replacing values with 0"), e[g] = 0), y += e[g];
            if (y !== 0) {
              const g = this.width / y, A = this.getDashRanges(e, this.width, g);
              c ? this.addRoundDash(A, g, s) : this.addRegularDash(A, i === "square" ? 0.5 * g : 0);
            }
            const T = this.nextRow + s;
            this.nextRow += h;
            const k = { tl: [T, s], br: [y, 0] };
            return this.positions[o] = k, k;
          }
        }
        Gr(vg, "LineAtlas");
        const Jv = jf.VectorTileFeature.types, Qv = Math.cos(Math.PI / 180 * 37.5), e1 = Math.cos(Math.PI / 180 * 5);
        class sm {
          constructor(e) {
            this.evaluationGlobals = { zoom: 0, lineProgress: void 0 }, this.zoom = e.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = e.overscaling, this.pixelRatio = e.pixelRatio, this.layers = e.layers, this.layerIds = this.layers.map((i) => i.fqid), this.index = e.index, this.projection = e.projection, this.hasPattern = !1, this.hasZOffset = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((i) => {
              this.gradients[i.id] = {};
            }), this.layoutVertexArray = new ol(), this.layoutVertexArray2 = new ro(), this.patternVertexArray = new ro(), this.indexArray = new ha(), this.programConfigurations = new Ls(e.layers, { zoom: e.zoom, lut: e.lut }), this.segments = new Nn(), this.maxLineLength = 0, this.zOffsetVertexArray = new ro(), this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id), this.tessellationStep = e.tessellationStep ? e.tessellationStep : Br / 64;
          }
          updateFootprints(e, i) {
          }
          populate(e, i, o, c) {
            this.hasPattern = Ei("line", this.layers, this.pixelRatio, i);
            const s = this.layers[0].layout.get("line-sort-key");
            this.tileToMeter = t(o);
            const h = this.layers[0].layout.get("line-z-offset"), y = h.isConstant() && !h.constantOr(0), T = this.layers[0].layout.get("line-elevation-reference");
            this.hasZOffset = T === "sea" || T === "ground" || !y && T === "none", this.hasZOffset && T === "none" && Tt(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
            const k = this.layers[0].layout.get("line-cross-slope");
            this.hasCrossSlope = this.hasZOffset && k !== void 0;
            const g = [];
            for (const { feature: R, id: j, index: J, sourceLayerIndex: ne } of e) {
              const me = this.layers[0]._featureFilter.needGeometry, ge = ae(R, me);
              if (!this.layers[0]._featureFilter.filter(new sn(this.zoom), ge, o)) continue;
              const ue = s ? s.evaluate(ge, {}, o) : void 0, Se = { id: j, properties: R.properties, type: R.type, sourceLayerIndex: ne, index: J, geometry: me ? ge.geometry : K(R, o, c), patterns: {}, sortKey: ue };
              g.push(Se);
            }
            s && g.sort((R, j) => R.sortKey - j.sortKey);
            const { lineAtlas: A, featureIndex: D } = i, S = this.addConstantDashes(A);
            for (const R of g) {
              const { geometry: j, index: J, sourceLayerIndex: ne } = R;
              if (S && this.addFeatureDashes(R, A), this.hasPattern) {
                const me = Ti("line", this.layers, R, this.zoom, this.pixelRatio, i);
                this.patternFeatures.push(me);
              } else this.addFeature(R, j, J, o, A.positions, i.availableImages, i.brightness);
              D.insert(e[J].feature, j, J, ne, this.index);
            }
          }
          addConstantDashes(e) {
            let i = !1;
            for (const o of this.layers) {
              const c = o.paint.get("line-dasharray").value, s = o.layout.get("line-cap").value;
              if (c.kind !== "constant" || s.kind !== "constant") i = !0;
              else {
                const h = s.value, y = c.value;
                if (!y) continue;
                e.addDash(y, h);
              }
            }
            return i;
          }
          addFeatureDashes(e, i) {
            const o = this.zoom;
            for (const c of this.layers) {
              const s = c.paint.get("line-dasharray").value, h = c.layout.get("line-cap").value;
              if (s.kind === "constant" && h.kind === "constant") continue;
              let y, T;
              if (s.kind === "constant") {
                if (y = s.value, !y) continue;
              } else y = s.evaluate({ zoom: o }, e);
              T = h.kind === "constant" ? h.value : h.evaluate({ zoom: o }, e), i.addDash(y, T), e.patterns[c.id] = i.getKey(y, T);
            }
          }
          update(e, i, o, c, s, h, y) {
            this.programConfigurations.updatePaintArrays(e, i, s, o, c, h, y);
          }
          addFeatures(e, i, o, c, s, h) {
            for (const y of this.patternFeatures) this.addFeature(y, y.geometry, y.index, i, o, c, h);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, Xv)), this.patternVertexArray.length !== 0 && (this.patternVertexBuffer = e.createVertexBuffer(this.patternVertexArray, Kv)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, Zv.members, !0)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, qv), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(e) {
            if (e.properties && e.properties.hasOwnProperty("mapbox_clip_start") && e.properties.hasOwnProperty("mapbox_clip_end")) return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end };
          }
          addFeature(e, i, o, c, s, h, y) {
            const T = this.layers[0].layout, k = T.get("line-join").evaluate(e, {}), g = T.get("line-cap").evaluate(e, {}), A = T.get("line-miter-limit"), D = T.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(e), this.lineFeature = e, this.zOffsetValue = T.get("line-z-offset").value;
            const S = this.layers[0].paint.get("line-width").value;
            S.kind !== "constant" && S.isLineProgressConstant === !1 && (this.variableWidthValue = S);
            for (const R of i) this.addLine(R, e, c, k, g, A, D);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, s, h, c, y);
          }
          addLine(e, i, o, c, s, h, y) {
            this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0;
            const T = c === "none";
            if (this.patternJoinNone = this.hasPattern && T, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [], this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ge = 0; ge < e.length - 1; ge++) this.totalDistance += e[ge].dist(e[ge + 1]);
              this.totalFeatureLength = this.totalDistance / (this.lineClips.end - this.lineClips.start), this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const k = Jv[i.type] === "Polygon";
            let g = e.length;
            for (; g >= 2 && e[g - 1].equals(e[g - 2]); ) g--;
            let A = 0;
            for (; A < g - 1 && e[A].equals(e[A + 1]); ) A++;
            if (g < (k ? 3 : 2)) return;
            c === "bevel" && (h = 1.05);
            const D = this.segments.prepareSegment(10 * g, this.layoutVertexArray, this.indexArray);
            let S, R, j, J, ne, me;
            this.e1 = this.e2 = -1, k && (S = e[g - 2], ne = e[A].sub(S)._unit()._perp());
            for (let ge = A; ge < g; ge++) {
              if (j = ge === g - 1 ? k ? e[A + 1] : void 0 : e[ge + 1], j && e[ge].equals(j)) continue;
              ne && (J = ne), S && (R = S), S = e[ge], me = this.evaluateLineProgressFeatures(R ? R.dist(S) : 0), ne = j ? j.sub(S)._unit()._perp() : J, J = J || ne;
              const ue = R && j;
              let Se = ue ? c : k || T ? "butt" : s;
              const ke = J.x * ne.x + J.y * ne.y;
              if (T) {
                const Lt = function(It) {
                  if (It.patternJoinNone) {
                    const zt = It.segmentPoints.length / 2, Ft = It.lineSoFar - It.segmentStart;
                    for (let qt = 0; qt < zt; ++qt) {
                      const Ot = It.segmentPoints[2 * qt + 1], cr = Math.round(It.segmentPoints[2 * qt]) + 0.5 + 0.25 * Ot;
                      It.patternVertexArray.emplaceBack(cr, Ft, It.segmentStart), It.patternVertexArray.emplaceBack(cr, Ft, It.segmentStart);
                    }
                    It.segmentPoints.length = 0;
                  }
                  It.e1 = It.e2 = -1;
                };
                if (ue && ke < e1) {
                  this.updateDistance(R, S), this.addCurrentVertex(S, J, 1, 1, D, me), Lt(this), this.addCurrentVertex(S, ne, -1, -1, D, me);
                  continue;
                }
                if (R) {
                  if (!j) {
                    this.updateDistance(R, S), this.addCurrentVertex(S, J, 1, 1, D, me), Lt(this);
                    continue;
                  }
                  Se = "miter";
                }
              }
              let He = J.add(ne);
              He.x === 0 && He.y === 0 || He._unit();
              const at = He.x * ne.x + He.y * ne.y, nt = at !== 0 ? 1 / at : 1 / 0, tt = 2 * Math.sqrt(2 - 2 * at), Et = at < Qv && R && j, lt = J.x * ne.y - J.y * ne.x > 0, St = this.overscaling <= 16 ? 15 * Br / (512 * this.overscaling) : 0;
              if (ue && Se === "round") {
                if (nt < y) Se = "miter";
                else if (nt <= 2) {
                  const Lt = lm(S, -10, Br + 10);
                  Se = this.hasZOffset && (Lt || this.hasCrossSlope) ? "miter" : "fakeround";
                }
              }
              if (Se === "miter" && nt > h && (Se = "bevel"), Se === "bevel" && (nt > 2 && (Se = "flipbevel"), nt < h && (Se = "miter")), R && !(Se === "miter" && Et) && this.updateDistance(R, S), Se === "miter") if (Et) {
                const Lt = S.dist(R);
                if (Lt > 2 * St) {
                  const zt = S.sub(S.sub(R)._mult(St / Lt)._round());
                  this.updateDistance(R, zt), this.addCurrentVertex(zt, J, 0, 0, D, me), R = zt;
                }
                this.updateDistance(R, S), He._mult(nt), this.addCurrentVertex(S, He, 0, 0, D, me);
                const It = S.dist(j);
                if (It > 2 * St) {
                  const zt = S.add(j.sub(S)._mult(St / It)._round());
                  this.updateDistance(S, zt), this.addCurrentVertex(zt, ne, 0, 0, D, me), S = zt;
                }
              } else He._mult(nt), this.addCurrentVertex(S, He, 0, 0, D, me);
              else if (Se === "flipbevel") {
                if (nt > 100) He = ne.mult(-1);
                else {
                  const Lt = nt * J.add(ne).mag() / J.sub(ne).mag();
                  He._perp()._mult(Lt * (lt ? -1 : 1));
                }
                this.addCurrentVertex(S, He, 0, 0, D, me), this.addCurrentVertex(S, He.mult(-1), 0, 0, D, me);
              } else if (Se === "bevel" || Se === "fakeround") {
                me != null && R && this.addCurrentVertex(S, J, -1, -1, D, me);
                const Lt = S.dist(R) <= 2 * St && Se !== "bevel", It = He.mult(lt ? 1 : -1);
                It._mult(nt);
                const zt = ne.mult(lt ? -1 : 1), Ft = J.mult(lt ? -1 : 1), qt = this.evaluateLineProgressFeatures(this.distance);
                if (me == null && (this.addHalfVertex(S, It.x, It.y, !1, !lt, 0, D, qt), Lt || this.addHalfVertex(S, It.x + 2 * Ft.x, It.y + 2 * Ft.y, !1, lt, 0, D, qt)), Se === "fakeround") {
                  const Ot = Math.round(180 * tt / Math.PI / 20);
                  this.addHalfVertex(S, Ft.x, Ft.y, !1, lt, 0, D, qt);
                  for (let cr = 0; cr < Ot; cr++) {
                    let yr = cr / Ot;
                    if (yr !== 0.5) {
                      const jr = yr - 0.5;
                      yr += yr * jr * (yr - 1) * ((1.0904 + ke * (ke * (3.55645 - 1.43519 * ke) - 3.2452)) * jr * jr + (0.848013 + ke * (0.215638 * ke - 1.06021)));
                    }
                    const ur = zt.sub(Ft)._mult(yr)._add(Ft)._unit();
                    this.addHalfVertex(S, ur.x, ur.y, !1, lt, 0, D, qt);
                  }
                  this.addHalfVertex(S, zt.x, zt.y, !1, lt, 0, D, qt);
                }
                Lt || me != null || this.addHalfVertex(S, It.x + 2 * zt.x, It.y + 2 * zt.y, !1, lt, 0, D, qt), me != null && j && this.addCurrentVertex(S, ne, 1, 1, D, me);
              } else Se === "butt" ? this.addCurrentVertex(S, He, 0, 0, D, me) : Se === "square" ? (R || this.addCurrentVertex(S, He, -1, -1, D, me), this.addCurrentVertex(S, He, 0, 0, D, me), R && this.addCurrentVertex(S, He, 1, 1, D, me)) : Se === "round" && (R && (this.addCurrentVertex(S, J, 0, 0, D, me), this.addCurrentVertex(S, J, 1, 1, D, me, !0)), j && (this.addCurrentVertex(S, ne, -1, -1, D, me, !0), this.addCurrentVertex(S, ne, 0, 0, D, me)));
            }
          }
          addVerticesTo(e, i, o, c, s, h, y, T, k, g) {
            const A = (i.w - e.w) / this.tessellationStep | 0;
            let D = 0;
            const S = this.scaledDistance;
            if (A > 1) {
              this.lineSoFar = e.w;
              const j = (i.x - e.x) / A, J = (i.y - e.y) / A, ne = (i.z - e.z) / A, me = (i.w - e.w) / A;
              for (let ge = 1; ge < A; ++ge) {
                e.x += j, e.y += J, e.z += ne, this.lineSoFar += me, D += me;
                const ue = this.evaluateLineProgressFeatures(this.prevDistance + D);
                this.scaledDistance = (this.prevDistance + D) / this.totalDistance, this.addHalfVertex(e, o, c, g, !1, y, k, ue), this.addHalfVertex(e, s, h, g, !0, -T, k, ue);
              }
            }
            this.lineSoFar = i.w, this.scaledDistance = S;
            const R = this.evaluateLineProgressFeatures(this.distance);
            this.addHalfVertex(i, o, c, g, !1, y, k, R), this.addHalfVertex(i, s, h, g, !0, -T, k, R);
          }
          evaluateLineProgressFeatures(e) {
            if (!this.variableWidthValue && !this.hasZOffset) return null;
            this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + e) / this.totalFeatureLength) : Tt(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
            let i = 0;
            return this.variableWidthValue && this.variableWidthValue.kind !== "constant" && (i = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), this.hasZOffset ? this.zOffsetValue.kind === "constant" ? { zOffset: this.zOffsetValue.value, variableWidth: i } : { zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0, variableWidth: i } : { zOffset: 0, variableWidth: i };
          }
          addCurrentVertex(e, i, o, c, s, h, y = !1) {
            const T = i.x + i.y * o, k = i.y - i.x * o, g = i.y * c - i.x, A = -i.y - i.x * c;
            if (h != null) {
              const D = this.hasZOffset, S = -10, R = Br + 10, j = h.zOffset, J = new W_(e.x, e.y, j, this.lineSoFar), ne = !!D && lm(e, S, R), me = this.lineSoFar, ge = this.distance;
              if (this.currentVertex) if (ne) {
                const ue = this.currentVertexIsOutside, Se = this.currentVertex, ke = new W_(e.x, e.y, j, this.lineSoFar);
                if (q_(Se, ke, S, R), !lm(ke, S, R)) {
                  if (ue) {
                    this.e1 = this.e2 = -1, this.distance -= Se.dist(J), this.lineSoFar = Se.w;
                    const He = this.evaluateLineProgressFeatures(Se.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                    this.addHalfVertex(Se, T, k, y, !1, o, s, He), this.addHalfVertex(Se, g, A, y, !0, -c, s, He), this.prevDistance = this.distance;
                  }
                  this.distance = this.prevDistance + Se.dist(ke), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(Se, ke, T, k, g, A, o, c, s, y), this.distance = ge, this.scaledDistance = this.distance / this.totalDistance;
                }
              } else {
                const ue = this.currentVertex;
                if (this.currentVertexIsOutside) {
                  q_(ue, J, S, R), this.e1 = this.e2 = -1, this.distance -= ue.dist(J), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = ue.w;
                  const Se = this.evaluateLineProgressFeatures(ue.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                  this.addHalfVertex(ue, T, k, y, !1, o, s, Se), this.addHalfVertex(ue, g, A, y, !0, -c, s, Se), this.prevDistance = this.distance, this.distance = ge, this.scaledDistance = this.distance / this.totalDistance;
                }
                this.addVerticesTo(ue, J, T, k, g, A, o, c, s, y);
              }
              else ne || (this.addHalfVertex(e, T, k, y, !1, o, s, h), this.addHalfVertex(e, g, A, y, !0, -c, s, h));
              this.currentVertex = J, this.currentVertexIsOutside = ne, this.lineSoFar = me;
            } else this.addHalfVertex(e, T, k, y, !1, o, s, h), this.addHalfVertex(e, g, A, y, !0, -c, s, h);
          }
          addHalfVertex({ x: e, y: i }, o, c, s, h, y, T, k) {
            if (this.patternJoinNone && (this.segmentPoints.length === 0 && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), h || this.segmentPoints.push(this.lineSoFar - this.segmentStart, y)), this.layoutVertexArray.emplaceBack((e << 1) + (s ? 1 : 0), (i << 1) + (h ? 1 : 0), Math.round(63 * o) + 128, Math.round(63 * c) + 128, 1 + (y === 0 ? 0 : y < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {
              const A = li(this.lineClips.start, this.lineClips.end, this.scaledDistance);
              this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, A);
            }
            const g = T.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, g), T.primitiveLength++), h ? this.e2 = g : this.e1 = g, k != null && this.zOffsetVertexArray.emplaceBack(k.zOffset, k.variableWidth, k.variableWidth);
          }
          updateScaledDistance() {
            this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;
          }
          updateDistance(e, i) {
            this.prevDistance = this.distance, this.distance += e.dist(i), this.updateScaledDistance();
          }
        }
        function lm(a, e, i) {
          return a.x < e || a.x > i || a.y < e || a.y > i;
        }
        let xg, bg;
        function wg(a, e, i) {
          return e * (Br / (a.tileSize * Math.pow(2, i - a.tileID.overscaledZ)));
        }
        Gr(sm, "LineBucket", { omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"] });
        const Eg = (a, e, i) => (1 - i) * a + i * e;
        function Sg(a, e) {
          return 1 / wg(a, 1, e.tileZoom);
        }
        function Tg(a, e, i, o) {
          return a.translatePosMatrix(o || e.tileID.projMatrix, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));
        }
        const Mg = (a) => {
          const e = [];
          Ag(a) && e.push("RENDER_LINE_DASH"), a.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
          const i = a.paint.get("line-trim-offset");
          i[0] === 0 && i[1] === 0 || e.push("RENDER_LINE_TRIM_OFFSET"), a.paint.get("line-border-width").constantOr(1) !== 0 && e.push("RENDER_LINE_BORDER");
          const o = a.layout.get("line-join").constantOr("miter") === "none", c = !!a.paint.get("line-pattern").constantOr(1);
          return o && c && e.push("LINE_JOIN_NONE"), e;
        };
        function Ag(a) {
          const e = a.paint.get("line-dasharray").value;
          return e.value || e.kind !== "constant";
        }
        let um;
        const Ig = () => um || (um = { layout: xg || (xg = new vn({ "line-cap": new Nr(Kt.layout_line["line-cap"]), "line-join": new Nr(Kt.layout_line["line-join"]), "line-miter-limit": new Mr(Kt.layout_line["line-miter-limit"]), "line-round-limit": new Mr(Kt.layout_line["line-round-limit"]), "line-sort-key": new Nr(Kt.layout_line["line-sort-key"]), "line-z-offset": new Nr(Kt.layout_line["line-z-offset"]), "line-elevation-reference": new Mr(Kt.layout_line["line-elevation-reference"]), "line-cross-slope": new Mr(Kt.layout_line["line-cross-slope"]), visibility: new Mr(Kt.layout_line.visibility), "line-width-unit": new Mr(Kt.layout_line["line-width-unit"]) })), paint: bg || (bg = new vn({ "line-opacity": new Nr(Kt.paint_line["line-opacity"]), "line-color": new Nr(Kt.paint_line["line-color"]), "line-translate": new Mr(Kt.paint_line["line-translate"]), "line-translate-anchor": new Mr(Kt.paint_line["line-translate-anchor"]), "line-width": new Nr(Kt.paint_line["line-width"]), "line-gap-width": new Nr(Kt.paint_line["line-gap-width"]), "line-offset": new Nr(Kt.paint_line["line-offset"]), "line-blur": new Nr(Kt.paint_line["line-blur"]), "line-dasharray": new Nr(Kt.paint_line["line-dasharray"]), "line-pattern": new Nr(Kt.paint_line["line-pattern"]), "line-gradient": new Ro(Kt.paint_line["line-gradient"]), "line-trim-offset": new Mr(Kt.paint_line["line-trim-offset"]), "line-trim-fade-range": new Mr(Kt.paint_line["line-trim-fade-range"]), "line-trim-color": new Mr(Kt.paint_line["line-trim-color"]), "line-emissive-strength": new Mr(Kt.paint_line["line-emissive-strength"]), "line-border-width": new Nr(Kt.paint_line["line-border-width"]), "line-border-color": new Nr(Kt.paint_line["line-border-color"]), "line-occlusion-opacity": new Mr(Kt.paint_line["line-occlusion-opacity"]), "line-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "line-gradient-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "line-trim-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "line-border-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, um);
        class t1 extends Nr {
          possiblyEvaluate(e, i) {
            return i = new sn(Math.floor(i.zoom), { now: i.now, fadeDuration: i.fadeDuration, transition: i.transition }), super.possiblyEvaluate(e, i);
          }
          evaluate(e, i, o, c) {
            return i = Qt({}, i, { zoom: Math.floor(i.zoom) }), super.evaluate(e, i, o, c);
          }
        }
        let Sd;
        function Cg(a, e) {
          return e > 0 ? e + 2 * a : a;
        }
        const r1 = Yi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), i1 = Yi([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), n1 = Yi([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
        Yi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const a1 = Yi([{ name: "a_auto_z_offset", components: 1, type: "Float32" }], 4), o1 = Yi([{ name: "a_texb", components: 2, type: "Uint16" }]), s1 = Yi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_elevation_from_sea", components: 2, type: "Float32" }]), l1 = Yi([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_auto_z_offset", components: 1, type: "Float32" }]);
        Yi([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Pg = Yi([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), u1 = Yi([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        Yi([{ name: "triangle", components: 3, type: "Uint16" }]), Yi([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Yi([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }]), Yi([{ type: "Float32", name: "offsetX" }]), Yi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
        var qa = 24;
        const eu = 128;
        function cm(a, e, i, o, c) {
          if (a.kind === "camera") return a.maxSize;
          if (a.kind === "composite") {
            const s = e.possiblyEvaluate(new sn(a.maxZoom), i).evaluate(c, {}, i), h = e.possiblyEvaluate(new sn(a.minZoom), i).evaluate(c, {}, i);
            return Math.max(s, h);
          }
          return e.possiblyEvaluate(new sn(o)).evaluate(c, {}, i);
        }
        function hm(a, e) {
          const { expression: i } = e;
          if (i.kind === "constant") return { kind: "constant", layoutSize: i.evaluate(new sn(a + 1)) };
          if (i.kind === "source") return { kind: "source" };
          {
            const { zoomStops: o, interpolationType: c } = i;
            let s = 0;
            for (; s < o.length && o[s] <= a; ) s++;
            s = Math.max(0, s - 1);
            let h = s;
            for (; h < o.length && o[h] < a + 1; ) h++;
            h = Math.min(o.length - 1, h);
            const y = o[s], T = o[h];
            return i.kind === "composite" ? { kind: "composite", minZoom: y, maxZoom: T, interpolationType: c } : { kind: "camera", minZoom: y, maxZoom: T, minSize: i.evaluate(new sn(y)), maxSize: i.evaluate(new sn(T)), interpolationType: c };
          }
        }
        function op(a, { uSize: e, uSizeT: i }, { lowerSize: o, upperSize: c }) {
          return a.kind === "source" ? o / eu : a.kind === "composite" ? li(o / eu, c / eu, i) : e;
        }
        function Vf(a, e, i = 1) {
          let o = 0, c = 0;
          if (a.kind === "constant") c = a.layoutSize * i;
          else if (a.kind !== "source") {
            const { interpolationType: s, minZoom: h, maxZoom: y } = a, T = s ? ie(_a.interpolationFactor(s, e, h, y), 0, 1) : 0;
            a.kind === "camera" ? c = li(a.minSize, a.maxSize, T) * i : o = T * i;
          }
          return { uSizeT: o, uSize: c };
        }
        var c1 = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: eu, evaluateSizeForFeature: op, evaluateSizeForZoom: Vf, getRasterizedIconSize: cm, getSizeData: hm });
        function h1(a, e, i) {
          return a.sections.forEach((o) => {
            o.text = function(c, s, h) {
              const y = s.layout.get("text-transform").evaluate(h, {});
              return y === "uppercase" ? c = c.toLocaleUpperCase() : y === "lowercase" && (c = c.toLocaleLowerCase()), to.applyArabicShaping && (c = to.applyArabicShaping(c)), c;
            }(o.text, e, i);
          }), a;
        }
        const Td = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂", "←": "↑", "→": "↓" };
        function f1(a) {
          return a === "︶" || a === "﹈" || a === "︸" || a === "﹄" || a === "﹂" || a === "︾" || a === "︼" || a === "︺" || a === "︘" || a === "﹀" || a === "︐" || a === "︓" || a === "︔" || a === "｀" || a === "￣" || a === "︑" || a === "︒";
        }
        function d1(a) {
          return a === "︵" || a === "﹇" || a === "︷" || a === "﹃" || a === "﹁" || a === "︽" || a === "︻" || a === "︹" || a === "︗" || a === "︿";
        }
        var Rg, fm, Lg, dm = {};
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        function p1() {
          return Rg || (Rg = 1, dm.read = function(a, e, i, o, c) {
            var s, h, y = 8 * c - o - 1, T = (1 << y) - 1, k = T >> 1, g = -7, A = i ? c - 1 : 0, D = i ? -1 : 1, S = a[e + A];
            for (A += D, s = S & (1 << -g) - 1, S >>= -g, g += y; g > 0; s = 256 * s + a[e + A], A += D, g -= 8) ;
            for (h = s & (1 << -g) - 1, s >>= -g, g += o; g > 0; h = 256 * h + a[e + A], A += D, g -= 8) ;
            if (s === 0) s = 1 - k;
            else {
              if (s === T) return h ? NaN : 1 / 0 * (S ? -1 : 1);
              h += Math.pow(2, o), s -= k;
            }
            return (S ? -1 : 1) * h * Math.pow(2, s - o);
          }, dm.write = function(a, e, i, o, c, s) {
            var h, y, T, k = 8 * s - c - 1, g = (1 << k) - 1, A = g >> 1, D = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, S = o ? 0 : s - 1, R = o ? 1 : -1, j = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
            for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (y = isNaN(e) ? 1 : 0, h = g) : (h = Math.floor(Math.log(e) / Math.LN2), e * (T = Math.pow(2, -h)) < 1 && (h--, T *= 2), (e += h + A >= 1 ? D / T : D * Math.pow(2, 1 - A)) * T >= 2 && (h++, T /= 2), h + A >= g ? (y = 0, h = g) : h + A >= 1 ? (y = (e * T - 1) * Math.pow(2, c), h += A) : (y = e * Math.pow(2, A - 1) * Math.pow(2, c), h = 0)); c >= 8; a[i + S] = 255 & y, S += R, y /= 256, c -= 8) ;
            for (h = h << c | y, k += c; k > 0; a[i + S] = 255 & h, S += R, h /= 256, k -= 8) ;
            a[i + S - R] |= 128 * j;
          }), dm;
        }
        function Dg() {
          if (Lg) return fm;
          Lg = 1, fm = e;
          var a = p1();
          function e(ue) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(ue) ? ue : new Uint8Array(ue || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          e.Varint = 0, e.Fixed64 = 1, e.Bytes = 2, e.Fixed32 = 5;
          var i = 4294967296, o = 1 / i, c = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
          function s(ue) {
            return ue.type === e.Bytes ? ue.readVarint() + ue.pos : ue.pos + 1;
          }
          function h(ue, Se, ke) {
            return ke ? 4294967296 * Se + (ue >>> 0) : 4294967296 * (Se >>> 0) + (ue >>> 0);
          }
          function y(ue, Se, ke) {
            var He = Se <= 16383 ? 1 : Se <= 2097151 ? 2 : Se <= 268435455 ? 3 : Math.floor(Math.log(Se) / (7 * Math.LN2));
            ke.realloc(He);
            for (var at = ke.pos - 1; at >= ue; at--) ke.buf[at + He] = ke.buf[at];
          }
          function T(ue, Se) {
            for (var ke = 0; ke < ue.length; ke++) Se.writeVarint(ue[ke]);
          }
          function k(ue, Se) {
            for (var ke = 0; ke < ue.length; ke++) Se.writeSVarint(ue[ke]);
          }
          function g(ue, Se) {
            for (var ke = 0; ke < ue.length; ke++) Se.writeFloat(ue[ke]);
          }
          function A(ue, Se) {
            for (var ke = 0; ke < ue.length; ke++) Se.writeDouble(ue[ke]);
          }
          function D(ue, Se) {
            for (var ke = 0; ke < ue.length; ke++) Se.writeBoolean(ue[ke]);
          }
          function S(ue, Se) {
            for (var ke = 0; ke < ue.length; ke++) Se.writeFixed32(ue[ke]);
          }
          function R(ue, Se) {
            for (var ke = 0; ke < ue.length; ke++) Se.writeSFixed32(ue[ke]);
          }
          function j(ue, Se) {
            for (var ke = 0; ke < ue.length; ke++) Se.writeFixed64(ue[ke]);
          }
          function J(ue, Se) {
            for (var ke = 0; ke < ue.length; ke++) Se.writeSFixed64(ue[ke]);
          }
          function ne(ue, Se) {
            return (ue[Se] | ue[Se + 1] << 8 | ue[Se + 2] << 16) + 16777216 * ue[Se + 3];
          }
          function me(ue, Se, ke) {
            ue[ke] = Se, ue[ke + 1] = Se >>> 8, ue[ke + 2] = Se >>> 16, ue[ke + 3] = Se >>> 24;
          }
          function ge(ue, Se) {
            return (ue[Se] | ue[Se + 1] << 8 | ue[Se + 2] << 16) + (ue[Se + 3] << 24);
          }
          return e.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(ue, Se, ke) {
            for (ke = ke || this.length; this.pos < ke; ) {
              var He = this.readVarint(), at = He >> 3, nt = this.pos;
              this.type = 7 & He, ue(at, Se, this), this.pos === nt && this.skip(He);
            }
            return Se;
          }, readMessage: function(ue, Se) {
            return this.readFields(ue, Se, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var ue = ne(this.buf, this.pos);
            return this.pos += 4, ue;
          }, readSFixed32: function() {
            var ue = ge(this.buf, this.pos);
            return this.pos += 4, ue;
          }, readFixed64: function() {
            var ue = ne(this.buf, this.pos) + ne(this.buf, this.pos + 4) * i;
            return this.pos += 8, ue;
          }, readSFixed64: function() {
            var ue = ne(this.buf, this.pos) + ge(this.buf, this.pos + 4) * i;
            return this.pos += 8, ue;
          }, readFloat: function() {
            var ue = a.read(this.buf, this.pos, !0, 23, 4);
            return this.pos += 4, ue;
          }, readDouble: function() {
            var ue = a.read(this.buf, this.pos, !0, 52, 8);
            return this.pos += 8, ue;
          }, readVarint: function(ue) {
            var Se, ke, He = this.buf;
            return Se = 127 & (ke = He[this.pos++]), ke < 128 ? Se : (Se |= (127 & (ke = He[this.pos++])) << 7, ke < 128 ? Se : (Se |= (127 & (ke = He[this.pos++])) << 14, ke < 128 ? Se : (Se |= (127 & (ke = He[this.pos++])) << 21, ke < 128 ? Se : function(at, nt, tt) {
              var Et, lt, St = tt.buf;
              if (Et = (112 & (lt = St[tt.pos++])) >> 4, lt < 128 || (Et |= (127 & (lt = St[tt.pos++])) << 3, lt < 128) || (Et |= (127 & (lt = St[tt.pos++])) << 10, lt < 128) || (Et |= (127 & (lt = St[tt.pos++])) << 17, lt < 128) || (Et |= (127 & (lt = St[tt.pos++])) << 24, lt < 128) || (Et |= (1 & (lt = St[tt.pos++])) << 31, lt < 128)) return h(at, Et, nt);
              throw new Error("Expected varint not more than 10 bytes");
            }(Se |= (15 & (ke = He[this.pos])) << 28, ue, this))));
          }, readVarint64: function() {
            return this.readVarint(!0);
          }, readSVarint: function() {
            var ue = this.readVarint();
            return ue % 2 == 1 ? (ue + 1) / -2 : ue / 2;
          }, readBoolean: function() {
            return !!this.readVarint();
          }, readString: function() {
            var ue = this.readVarint() + this.pos, Se = this.pos;
            return this.pos = ue, ue - Se >= 12 && c ? function(ke, He, at) {
              return c.decode(ke.subarray(He, at));
            }(this.buf, Se, ue) : function(ke, He, at) {
              for (var nt = "", tt = He; tt < at; ) {
                var Et, lt, St, Lt = ke[tt], It = null, zt = Lt > 239 ? 4 : Lt > 223 ? 3 : Lt > 191 ? 2 : 1;
                if (tt + zt > at) break;
                zt === 1 ? Lt < 128 && (It = Lt) : zt === 2 ? (192 & (Et = ke[tt + 1])) == 128 && (It = (31 & Lt) << 6 | 63 & Et) <= 127 && (It = null) : zt === 3 ? (lt = ke[tt + 2], (192 & (Et = ke[tt + 1])) == 128 && (192 & lt) == 128 && ((It = (15 & Lt) << 12 | (63 & Et) << 6 | 63 & lt) <= 2047 || It >= 55296 && It <= 57343) && (It = null)) : zt === 4 && (lt = ke[tt + 2], St = ke[tt + 3], (192 & (Et = ke[tt + 1])) == 128 && (192 & lt) == 128 && (192 & St) == 128 && ((It = (15 & Lt) << 18 | (63 & Et) << 12 | (63 & lt) << 6 | 63 & St) <= 65535 || It >= 1114112) && (It = null)), It === null ? (It = 65533, zt = 1) : It > 65535 && (It -= 65536, nt += String.fromCharCode(It >>> 10 & 1023 | 55296), It = 56320 | 1023 & It), nt += String.fromCharCode(It), tt += zt;
              }
              return nt;
            }(this.buf, Se, ue);
          }, readBytes: function() {
            var ue = this.readVarint() + this.pos, Se = this.buf.subarray(this.pos, ue);
            return this.pos = ue, Se;
          }, readPackedVarint: function(ue, Se) {
            if (this.type !== e.Bytes) return ue.push(this.readVarint(Se));
            var ke = s(this);
            for (ue = ue || []; this.pos < ke; ) ue.push(this.readVarint(Se));
            return ue;
          }, readPackedSVarint: function(ue) {
            if (this.type !== e.Bytes) return ue.push(this.readSVarint());
            var Se = s(this);
            for (ue = ue || []; this.pos < Se; ) ue.push(this.readSVarint());
            return ue;
          }, readPackedBoolean: function(ue) {
            if (this.type !== e.Bytes) return ue.push(this.readBoolean());
            var Se = s(this);
            for (ue = ue || []; this.pos < Se; ) ue.push(this.readBoolean());
            return ue;
          }, readPackedFloat: function(ue) {
            if (this.type !== e.Bytes) return ue.push(this.readFloat());
            var Se = s(this);
            for (ue = ue || []; this.pos < Se; ) ue.push(this.readFloat());
            return ue;
          }, readPackedDouble: function(ue) {
            if (this.type !== e.Bytes) return ue.push(this.readDouble());
            var Se = s(this);
            for (ue = ue || []; this.pos < Se; ) ue.push(this.readDouble());
            return ue;
          }, readPackedFixed32: function(ue) {
            if (this.type !== e.Bytes) return ue.push(this.readFixed32());
            var Se = s(this);
            for (ue = ue || []; this.pos < Se; ) ue.push(this.readFixed32());
            return ue;
          }, readPackedSFixed32: function(ue) {
            if (this.type !== e.Bytes) return ue.push(this.readSFixed32());
            var Se = s(this);
            for (ue = ue || []; this.pos < Se; ) ue.push(this.readSFixed32());
            return ue;
          }, readPackedFixed64: function(ue) {
            if (this.type !== e.Bytes) return ue.push(this.readFixed64());
            var Se = s(this);
            for (ue = ue || []; this.pos < Se; ) ue.push(this.readFixed64());
            return ue;
          }, readPackedSFixed64: function(ue) {
            if (this.type !== e.Bytes) return ue.push(this.readSFixed64());
            var Se = s(this);
            for (ue = ue || []; this.pos < Se; ) ue.push(this.readSFixed64());
            return ue;
          }, skip: function(ue) {
            var Se = 7 & ue;
            if (Se === e.Varint) for (; this.buf[this.pos++] > 127; ) ;
            else if (Se === e.Bytes) this.pos = this.readVarint() + this.pos;
            else if (Se === e.Fixed32) this.pos += 4;
            else {
              if (Se !== e.Fixed64) throw new Error("Unimplemented type: " + Se);
              this.pos += 8;
            }
          }, writeTag: function(ue, Se) {
            this.writeVarint(ue << 3 | Se);
          }, realloc: function(ue) {
            for (var Se = this.length || 16; Se < this.pos + ue; ) Se *= 2;
            if (Se !== this.length) {
              var ke = new Uint8Array(Se);
              ke.set(this.buf), this.buf = ke, this.length = Se;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(ue) {
            this.realloc(4), me(this.buf, ue, this.pos), this.pos += 4;
          }, writeSFixed32: function(ue) {
            this.realloc(4), me(this.buf, ue, this.pos), this.pos += 4;
          }, writeFixed64: function(ue) {
            this.realloc(8), me(this.buf, -1 & ue, this.pos), me(this.buf, Math.floor(ue * o), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(ue) {
            this.realloc(8), me(this.buf, -1 & ue, this.pos), me(this.buf, Math.floor(ue * o), this.pos + 4), this.pos += 8;
          }, writeVarint: function(ue) {
            (ue = +ue || 0) > 268435455 || ue < 0 ? function(Se, ke) {
              var He, at;
              if (Se >= 0 ? (He = Se % 4294967296 | 0, at = Se / 4294967296 | 0) : (at = ~(-Se / 4294967296), 4294967295 ^ (He = ~(-Se % 4294967296)) ? He = He + 1 | 0 : (He = 0, at = at + 1 | 0)), Se >= 18446744073709552e3 || Se < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              ke.realloc(10), function(nt, tt, Et) {
                Et.buf[Et.pos++] = 127 & nt | 128, nt >>>= 7, Et.buf[Et.pos++] = 127 & nt | 128, nt >>>= 7, Et.buf[Et.pos++] = 127 & nt | 128, nt >>>= 7, Et.buf[Et.pos++] = 127 & nt | 128, Et.buf[Et.pos] = 127 & (nt >>>= 7);
              }(He, 0, ke), function(nt, tt) {
                var Et = (7 & nt) << 4;
                tt.buf[tt.pos++] |= Et | ((nt >>>= 3) ? 128 : 0), nt && (tt.buf[tt.pos++] = 127 & nt | ((nt >>>= 7) ? 128 : 0), nt && (tt.buf[tt.pos++] = 127 & nt | ((nt >>>= 7) ? 128 : 0), nt && (tt.buf[tt.pos++] = 127 & nt | ((nt >>>= 7) ? 128 : 0), nt && (tt.buf[tt.pos++] = 127 & nt | ((nt >>>= 7) ? 128 : 0), nt && (tt.buf[tt.pos++] = 127 & nt)))));
              }(at, ke);
            }(ue, this) : (this.realloc(4), this.buf[this.pos++] = 127 & ue | (ue > 127 ? 128 : 0), ue <= 127 || (this.buf[this.pos++] = 127 & (ue >>>= 7) | (ue > 127 ? 128 : 0), ue <= 127 || (this.buf[this.pos++] = 127 & (ue >>>= 7) | (ue > 127 ? 128 : 0), ue <= 127 || (this.buf[this.pos++] = ue >>> 7 & 127))));
          }, writeSVarint: function(ue) {
            this.writeVarint(ue < 0 ? 2 * -ue - 1 : 2 * ue);
          }, writeBoolean: function(ue) {
            this.writeVarint(!!ue);
          }, writeString: function(ue) {
            ue = String(ue), this.realloc(4 * ue.length), this.pos++;
            var Se = this.pos;
            this.pos = function(He, at, nt) {
              for (var tt, Et, lt = 0; lt < at.length; lt++) {
                if ((tt = at.charCodeAt(lt)) > 55295 && tt < 57344) {
                  if (!Et) {
                    tt > 56319 || lt + 1 === at.length ? (He[nt++] = 239, He[nt++] = 191, He[nt++] = 189) : Et = tt;
                    continue;
                  }
                  if (tt < 56320) {
                    He[nt++] = 239, He[nt++] = 191, He[nt++] = 189, Et = tt;
                    continue;
                  }
                  tt = Et - 55296 << 10 | tt - 56320 | 65536, Et = null;
                } else Et && (He[nt++] = 239, He[nt++] = 191, He[nt++] = 189, Et = null);
                tt < 128 ? He[nt++] = tt : (tt < 2048 ? He[nt++] = tt >> 6 | 192 : (tt < 65536 ? He[nt++] = tt >> 12 | 224 : (He[nt++] = tt >> 18 | 240, He[nt++] = tt >> 12 & 63 | 128), He[nt++] = tt >> 6 & 63 | 128), He[nt++] = 63 & tt | 128);
              }
              return nt;
            }(this.buf, ue, this.pos);
            var ke = this.pos - Se;
            ke >= 128 && y(Se, ke, this), this.pos = Se - 1, this.writeVarint(ke), this.pos += ke;
          }, writeFloat: function(ue) {
            this.realloc(4), a.write(this.buf, ue, this.pos, !0, 23, 4), this.pos += 4;
          }, writeDouble: function(ue) {
            this.realloc(8), a.write(this.buf, ue, this.pos, !0, 52, 8), this.pos += 8;
          }, writeBytes: function(ue) {
            var Se = ue.length;
            this.writeVarint(Se), this.realloc(Se);
            for (var ke = 0; ke < Se; ke++) this.buf[this.pos++] = ue[ke];
          }, writeRawMessage: function(ue, Se) {
            this.pos++;
            var ke = this.pos;
            ue(Se, this);
            var He = this.pos - ke;
            He >= 128 && y(ke, He, this), this.pos = ke - 1, this.writeVarint(He), this.pos += He;
          }, writeMessage: function(ue, Se, ke) {
            this.writeTag(ue, e.Bytes), this.writeRawMessage(Se, ke);
          }, writePackedVarint: function(ue, Se) {
            Se.length && this.writeMessage(ue, T, Se);
          }, writePackedSVarint: function(ue, Se) {
            Se.length && this.writeMessage(ue, k, Se);
          }, writePackedBoolean: function(ue, Se) {
            Se.length && this.writeMessage(ue, D, Se);
          }, writePackedFloat: function(ue, Se) {
            Se.length && this.writeMessage(ue, g, Se);
          }, writePackedDouble: function(ue, Se) {
            Se.length && this.writeMessage(ue, A, Se);
          }, writePackedFixed32: function(ue, Se) {
            Se.length && this.writeMessage(ue, S, Se);
          }, writePackedSFixed32: function(ue, Se) {
            Se.length && this.writeMessage(ue, R, Se);
          }, writePackedFixed64: function(ue, Se) {
            Se.length && this.writeMessage(ue, j, Se);
          }, writePackedSFixed64: function(ue, Se) {
            Se.length && this.writeMessage(ue, J, Se);
          }, writeBytesField: function(ue, Se) {
            this.writeTag(ue, e.Bytes), this.writeBytes(Se);
          }, writeFixed32Field: function(ue, Se) {
            this.writeTag(ue, e.Fixed32), this.writeFixed32(Se);
          }, writeSFixed32Field: function(ue, Se) {
            this.writeTag(ue, e.Fixed32), this.writeSFixed32(Se);
          }, writeFixed64Field: function(ue, Se) {
            this.writeTag(ue, e.Fixed64), this.writeFixed64(Se);
          }, writeSFixed64Field: function(ue, Se) {
            this.writeTag(ue, e.Fixed64), this.writeSFixed64(Se);
          }, writeVarintField: function(ue, Se) {
            this.writeTag(ue, e.Varint), this.writeVarint(Se);
          }, writeSVarintField: function(ue, Se) {
            this.writeTag(ue, e.Varint), this.writeSVarint(Se);
          }, writeStringField: function(ue, Se) {
            this.writeTag(ue, e.Bytes), this.writeString(Se);
          }, writeFloatField: function(ue, Se) {
            this.writeTag(ue, e.Fixed32), this.writeFloat(Se);
          }, writeDoubleField: function(ue, Se) {
            this.writeTag(ue, e.Fixed64), this.writeDouble(Se);
          }, writeBooleanField: function(ue, Se) {
            this.writeVarintField(ue, !!Se);
          } }, fm;
        }
        var sp = F(Dg());
        const pm = 3;
        function m1(a, e, i) {
          e.glyphs = [], a === 1 && i.readMessage(_1, e);
        }
        function _1(a, e, i) {
          if (a === 3) {
            const { id: o, bitmap: c, width: s, height: h, left: y, top: T, advance: k } = i.readMessage(g1, {});
            e.glyphs.push({ id: o, bitmap: new dl({ width: s + 2 * pm, height: h + 2 * pm }, c), metrics: { width: s, height: h, left: y, top: T, advance: k } });
          } else a === 4 ? e.ascender = i.readSVarint() : a === 5 && (e.descender = i.readSVarint());
        }
        function g1(a, e, i) {
          a === 1 ? e.id = i.readVarint() : a === 2 ? e.bitmap = i.readBytes() : a === 3 ? e.width = i.readVarint() : a === 4 ? e.height = i.readVarint() : a === 5 ? e.left = i.readSVarint() : a === 6 ? e.top = i.readSVarint() : a === 7 && (e.advance = i.readVarint());
        }
        const kg = pm, ks = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
        class Md {
          constructor() {
            this.scale = 1, this.fontStack = "", this.image = null;
          }
          static forText(e, i) {
            const o = new Md();
            return o.scale = e || 1, o.fontStack = i, o;
          }
          static forImage(e) {
            const i = new Md();
            return i.image = e, i;
          }
        }
        class Gf {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(e, i) {
            const o = new Gf();
            for (let c = 0; c < e.sections.length; c++) {
              const s = e.sections[c];
              s.image ? o.addImageSection(s) : o.addTextSection(s, i);
            }
            return o;
          }
          length() {
            return this.text.length;
          }
          getSection(e) {
            return this.sections[this.sectionIndex[e]];
          }
          getSections() {
            return this.sections;
          }
          getSectionIndex(e) {
            return this.sectionIndex[e];
          }
          getCodePoint(e) {
            return this.text.codePointAt(e);
          }
          verticalizePunctuation(e) {
            this.text = function(i, o) {
              let c = "";
              for (let s = 0; s < i.length; s++) {
                const h = i.charCodeAt(s + 1) || null, y = i.charCodeAt(s - 1) || null;
                c += !o && (h && Fn(h) && !Td[i[s + 1]] || y && Fn(y) && !Td[i[s - 1]]) || !Td[i[s]] ? i[s] : Td[i[s]];
              }
              return c;
            }(this.text, e);
          }
          trim() {
            let e = 0;
            for (let o = 0; o < this.text.length && lp[this.text.charCodeAt(o)]; o++) e++;
            let i = this.text.length;
            for (let o = this.text.length - 1; o >= 0 && o >= e && lp[this.text.charCodeAt(o)]; o--) i--;
            this.text = this.text.substring(e, i), this.sectionIndex = this.sectionIndex.slice(e, i);
          }
          substring(e, i) {
            const o = new Gf();
            return o.text = this.text.substring(e, i), o.sectionIndex = this.sectionIndex.slice(e, i), o.sections = this.sections, o;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((e, i) => Math.max(e, this.sections[i].scale), 0);
          }
          addTextSection(e, i) {
            this.text += e.text, this.sections.push(Md.forText(e.scale, e.fontStack || i));
            const o = this.sections.length - 1;
            for (let c = 0; c < e.text.length; ++c) this.sectionIndex.push(o);
          }
          addImageSection(e) {
            const i = e.image && e.image.namePrimary ? e.image.getPrimary() : null;
            if (!i) return void Tt("Can't add FormattedSection with an empty image.");
            const o = this.getNextImageSectionCharCode();
            o ? (this.text += String.fromCodePoint(o), this.sections.push(Md.forImage(i)), this.sectionIndex.push(this.sections.length - 1)) : Tt("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function mm(a, e, i, o, c, s, h, y, T, k, g, A, D, S, R) {
          const j = Gf.fromFeature(a, c);
          A === ks.vertical && j.verticalizePunctuation(D);
          let J = [];
          const ne = function(ke, He, at, nt, tt, Et) {
            if (!ke) return [];
            const lt = [], St = function(Ft, qt, Ot, cr, yr, ur) {
              let jr = 0;
              for (let zr = 0; zr < Ft.length(); zr++) {
                const Ar = Ft.getSection(zr);
                jr += zg(Ft.getCodePoint(zr), Ar, cr, yr, qt, ur);
              }
              return jr / Math.max(1, Math.ceil(jr / Ot));
            }(ke, He, at, nt, tt, Et), Lt = ke.text.indexOf("​") >= 0;
            let It = 0;
            for (let Ft = 0; Ft < ke.length(); Ft++) {
              const qt = ke.getSection(Ft), Ot = ke.getCodePoint(Ft);
              if (lp[Ot] || (It += zg(Ot, qt, nt, tt, He, Et)), Ft < ke.length() - 1) {
                const cr = !((zt = Ot) < 11904 || !(ri["Bopomofo Extended"](zt) || ri.Bopomofo(zt) || ri["CJK Compatibility Forms"](zt) || ri["CJK Compatibility Ideographs"](zt) || ri["CJK Compatibility"](zt) || ri["CJK Radicals Supplement"](zt) || ri["CJK Strokes"](zt) || ri["CJK Symbols and Punctuation"](zt) || ri["CJK Unified Ideographs Extension A"](zt) || ri["CJK Unified Ideographs"](zt) || ri["Enclosed CJK Letters and Months"](zt) || ri["Halfwidth and Fullwidth Forms"](zt) || ri.Hiragana(zt) || ri["Ideographic Description Characters"](zt) || ri["Kangxi Radicals"](zt) || ri["Katakana Phonetic Extensions"](zt) || ri.Katakana(zt) || ri["Vertical Forms"](zt) || ri["Yi Radicals"](zt) || ri["Yi Syllables"](zt)));
                (y1[Ot] || cr || qt.image) && lt.push(Bg(Ft + 1, It, St, lt, v1(Ot, ke.getCodePoint(Ft + 1), cr && Lt), !1));
              }
            }
            var zt;
            return Fg(Bg(ke.length(), It, St, lt, 0, !0));
          }(j, k, s, e, o, S), { processBidirectionalText: me, processStyledBidirectionalText: ge } = to;
          if (me && j.sections.length === 1) {
            const ke = me(j.toString(), ne);
            for (const He of ke) {
              const at = new Gf();
              at.text = He, at.sections = j.sections;
              for (let nt = 0; nt < He.length; nt++) at.sectionIndex.push(0);
              J.push(at);
            }
          } else if (ge) {
            const ke = ge(j.text, j.sectionIndex, ne);
            for (const He of ke) {
              const at = new Gf();
              at.text = He[0], at.sectionIndex = He[1], at.sections = j.sections, J.push(at);
            }
          } else J = function(ke, He) {
            const at = [], nt = ke.text;
            let tt = 0;
            for (const Et of He) at.push(ke.substring(tt, Et)), tt = Et;
            return tt < nt.length && at.push(ke.substring(tt, nt.length)), at;
          }(j, ne);
          const ue = [], Se = { positionedLines: ue, text: j.toString(), top: g[1], bottom: g[1], left: g[0], right: g[0], writingMode: A, iconsInText: !1, verticalizable: !1, hasBaseline: !1 };
          return function(ke, He, at, nt, tt, Et, lt, St, Lt, It, zt, Ft) {
            let qt = 0, Ot = 0, cr = 0;
            const yr = St === "right" ? 1 : St === "left" ? 0 : 0.5;
            let ur = !1;
            for (const Wr of tt) {
              const $r = Wr.getSections();
              for (const bi of $r) {
                if (bi.image) continue;
                const Ci = He[bi.fontStack];
                if (Ci && (ur = Ci.ascender !== void 0 && Ci.descender !== void 0, !ur)) break;
              }
              if (!ur) break;
            }
            let jr = 0;
            for (const Wr of tt) {
              Wr.trim();
              const $r = Wr.getMaxScale(), bi = ($r - 1) * qa, Ci = { positionedGlyphs: [], lineOffset: 0 };
              ke.positionedLines[jr] = Ci;
              const Pi = Ci.positionedGlyphs;
              let Ri = 0;
              if (!Wr.length()) {
                Ot += Et, ++jr;
                continue;
              }
              let ji = 0, Hi = 0;
              for (let cn = 0; cn < Wr.length(); cn++) {
                const Si = Wr.getSection(cn), an = Wr.getSectionIndex(cn), un = Wr.getCodePoint(cn);
                let Sn = Si.scale, $n = null, oa = null, Xn = null, Vn = qa, Jn = 0;
                const da = !(Lt === ks.horizontal || !zt && !La(un) || zt && (lp[un] || (zr = un, ri.Arabic(zr) || ri["Arabic Supplement"](zr) || ri["Arabic Extended-A"](zr) || ri["Arabic Presentation Forms-A"](zr) || ri["Arabic Presentation Forms-B"](zr))));
                if (Si.image) {
                  const $a = nt[Si.image.serialize()];
                  if (!$a) continue;
                  Xn = Si.image.id, ke.iconsInText = ke.iconsInText || !0, oa = $a.paddedRect;
                  const wn = $a.displaySize;
                  Sn = Sn * qa / Ft, $n = { width: wn[0], height: wn[1], left: 0, top: -kg, advance: da ? wn[1] : wn[0], localGlyph: !1 }, Jn = ur ? -$n.height * Sn : $r * qa - 17 - wn[1] * Sn, Vn = $n.advance;
                  const Go = (da ? wn[0] : wn[1]) * Sn - qa * $r;
                  Go > 0 && Go > Ri && (Ri = Go);
                } else {
                  const $a = at[Si.fontStack];
                  if (!$a) continue;
                  $a[un] && (oa = $a[un]);
                  const wn = He[Si.fontStack];
                  if (!wn) continue;
                  const Go = wn.glyphs[un];
                  if (!Go) continue;
                  if ($n = Go.metrics, Vn = un !== 8203 ? qa : 0, ur) {
                    const au = wn.ascender !== void 0 ? Math.abs(wn.ascender) : 0, ml = wn.descender !== void 0 ? Math.abs(wn.descender) : 0, _l = (au + ml) * Sn;
                    ji < _l && (ji = _l, Hi = (au - ml) / 2 * Sn), Jn = -au * Sn;
                  } else Jn = ($r - Sn) * qa - 17;
                }
                da ? (ke.verticalizable = !0, Pi.push({ glyph: un, imageName: Xn, x: qt, y: Ot + Jn, vertical: da, scale: Sn, localGlyph: $n.localGlyph, fontStack: Si.fontStack, sectionIndex: an, metrics: $n, rect: oa }), qt += Vn * Sn + It) : (Pi.push({ glyph: un, imageName: Xn, x: qt, y: Ot + Jn, vertical: da, scale: Sn, localGlyph: $n.localGlyph, fontStack: Si.fontStack, sectionIndex: an, metrics: $n, rect: oa }), qt += $n.advance * Sn + It);
              }
              Pi.length !== 0 && (cr = Math.max(qt - It, cr), ur ? Ng(Pi, yr, Ri, Hi, Et * $r / 2) : Ng(Pi, yr, Ri, 0, Et / 2)), qt = 0;
              const gn = Et * $r + Ri;
              Ci.lineOffset = Math.max(Ri, bi), Ot += gn, ++jr;
            }
            var zr;
            const Ar = Ot, { horizontalAlign: vr, verticalAlign: ti } = _m(lt);
            (function(Wr, $r, bi, Ci, Pi, Ri) {
              const ji = ($r - bi) * Pi, Hi = -Ri * Ci;
              for (const gn of Wr) for (const cn of gn.positionedGlyphs) cn.x += ji, cn.y += Hi;
            })(ke.positionedLines, yr, vr, ti, cr, Ar), ke.top += -ti * Ar, ke.bottom = ke.top + Ar, ke.left += -vr * cr, ke.right = ke.left + cr, ke.hasBaseline = ur;
          }(Se, e, i, o, J, h, y, T, A, k, D, R), !function(ke) {
            for (const He of ke) if (He.positionedGlyphs.length !== 0) return !1;
            return !0;
          }(ue) && Se;
        }
        const lp = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, y1 = { 10: !0, 32: !0, 38: !0, 40: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 };
        function zg(a, e, i, o, c, s) {
          if (e.image) {
            const h = o[e.image.serialize()];
            return h ? h.displaySize[0] * e.scale * qa / s + c : 0;
          }
          {
            const h = i[e.fontStack], y = h && h.glyphs[a];
            return y ? y.metrics.advance * e.scale + c : 0;
          }
        }
        function Og(a, e, i, o) {
          const c = Math.pow(a - e, 2);
          return o ? a < e ? c / 2 : 2 * c : c + Math.abs(i) * i;
        }
        function v1(a, e, i) {
          let o = 0;
          return a === 10 && (o -= 1e4), i && (o += 150), a !== 40 && a !== 65288 || (o += 50), e !== 41 && e !== 65289 || (o += 50), o;
        }
        function Bg(a, e, i, o, c, s) {
          let h = null, y = Og(e, i, c, s);
          for (const T of o) {
            const k = Og(e - T.x, i, c, s) + T.badness;
            k <= y && (h = T, y = k);
          }
          return { index: a, x: e, priorBreak: h, badness: y };
        }
        function Fg(a) {
          return a ? Fg(a.priorBreak).concat(a.index) : [];
        }
        function _m(a) {
          let e = 0.5, i = 0.5;
          switch (a) {
            case "right":
            case "top-right":
            case "bottom-right":
              e = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e = 0;
          }
          switch (a) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              i = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              i = 0;
          }
          return { horizontalAlign: e, verticalAlign: i };
        }
        function Ng(a, e, i, o, c) {
          if (!(e || i || o || c)) return;
          const s = a.length - 1, h = a[s], y = (h.x + h.metrics.advance * h.scale) * e;
          for (let T = 0; T <= s; T++) a[T].x -= y, a[T].y += i + o + c;
        }
        function x1(a, e, i, o) {
          const { horizontalAlign: c, verticalAlign: s } = _m(o), h = i[0] - a.displaySize[0] * c, y = i[1] - a.displaySize[1] * s;
          return { imagePrimary: a, imageSecondary: e, top: y, bottom: y + a.displaySize[1], left: h, right: h + a.displaySize[0] };
        }
        function Ug(a, e, i, o, c, s) {
          const h = a.imagePrimary;
          let y;
          if (h.content) {
            const J = h.content, ne = h.pixelRatio || 1;
            y = [J[0] / ne, J[1] / ne, h.displaySize[0] - J[2] / ne, h.displaySize[1] - J[3] / ne];
          }
          const T = e.left * s, k = e.right * s;
          let g, A, D, S;
          i === "width" || i === "both" ? (S = c[0] + T - o[3], A = c[0] + k + o[1]) : (S = c[0] + (T + k - h.displaySize[0]) / 2, A = S + h.displaySize[0]);
          const R = e.top * s, j = e.bottom * s;
          return i === "height" || i === "both" ? (g = c[1] + R - o[0], D = c[1] + j + o[2]) : (g = c[1] + (R + j - h.displaySize[1]) / 2, D = g + h.displaySize[1]), { imagePrimary: h, imageSecondary: void 0, top: g, right: A, bottom: D, left: S, collisionPadding: y };
        }
        class Ic extends Ye {
          constructor(e, i, o, c, s) {
            super(e, i), this.angle = c, this.z = o, s !== void 0 && (this.segment = s);
          }
          clone() {
            return new Ic(this.x, this.y, this.z, this.angle, this.segment);
          }
        }
        function jg(a, e, i, o, c) {
          if (e.segment === void 0) return !0;
          let s = e, h = e.segment + 1, y = 0;
          for (; y > -i / 2; ) {
            if (h--, h < 0) return !1;
            y -= a[h].dist(s), s = a[h];
          }
          y += a[h].dist(a[h + 1]), h++;
          const T = [];
          let k = 0;
          for (; y < i / 2; ) {
            const g = a[h], A = a[h + 1];
            if (!A) return !1;
            let D = a[h - 1].angleTo(g) - g.angleTo(A);
            for (D = Math.abs((D + 3 * Math.PI) % (2 * Math.PI) - Math.PI), T.push({ distance: y, angleDelta: D }), k += D; y - T[0].distance > o; ) k -= T.shift().angleDelta;
            if (k > c) return !1;
            h++, y += g.dist(A);
          }
          return !0;
        }
        function Vg(a) {
          let e = 0;
          for (let i = 0; i < a.length - 1; i++) e += a[i].dist(a[i + 1]);
          return e;
        }
        function Gg(a, e, i) {
          return a ? 0.6 * e * i : 0;
        }
        function Hg(a, e) {
          return Math.max(a ? a.right - a.left : 0, e ? e.right - e.left : 0);
        }
        function b1(a, e, i, o, c, s) {
          const h = Gg(i, c, s), y = Hg(i, o) * s;
          let T = 0;
          const k = Vg(a) / 2;
          for (let g = 0; g < a.length - 1; g++) {
            const A = a[g], D = a[g + 1], S = A.dist(D);
            if (T + S > k) {
              const R = (k - T) / S, j = li(A.x, D.x, R), J = li(A.y, D.y, R), ne = new Ic(j, J, 0, D.angleTo(A), g);
              return !h || jg(a, ne, y, h, e) ? ne : void 0;
            }
            T += S;
          }
        }
        function w1(a, e, i, o, c, s, h, y, T) {
          const k = Gg(o, s, h), g = Hg(o, c), A = g * h, D = a[0].x === 0 || a[0].x === T || a[0].y === 0 || a[0].y === T;
          return e - A < e / 4 && (e = A + e / 4), Wg(a, D ? e / 2 * y % e : (g / 2 + 2 * s) * h * y % e, e, k, i, A, D, !1, T);
        }
        function Wg(a, e, i, o, c, s, h, y, T) {
          const k = s / 2, g = Vg(a);
          let A = 0, D = e - i, S = [];
          for (let R = 0; R < a.length - 1; R++) {
            const j = a[R], J = a[R + 1], ne = j.dist(J), me = J.angleTo(j);
            for (; D + i < A + ne; ) {
              D += i;
              const ge = (D - A) / ne, ue = li(j.x, J.x, ge), Se = li(j.y, J.y, ge);
              if (ue >= 0 && ue < T && Se >= 0 && Se < T && D - k >= 0 && D + k <= g) {
                const ke = new Ic(ue, Se, 0, me, R);
                o && !jg(a, ke, s, o, c) || S.push(ke);
              }
            }
            A += ne;
          }
          return y || S.length || h || (S = Wg(a, A / 2, i, o, c, s, h, !0, T)), S;
        }
        function Zg(a, e, i, o, c) {
          const s = [];
          for (let h = 0; h < a.length; h++) {
            const y = a[h];
            let T;
            for (let k = 0; k < y.length - 1; k++) {
              let g = y[k], A = y[k + 1];
              g.x < e && A.x < e || (g.x < e ? g = new Ye(e, g.y + (e - g.x) / (A.x - g.x) * (A.y - g.y))._round() : A.x < e && (A = new Ye(e, g.y + (e - g.x) / (A.x - g.x) * (A.y - g.y))._round()), g.y < i && A.y < i || (g.y < i ? g = new Ye(g.x + (i - g.y) / (A.y - g.y) * (A.x - g.x), i)._round() : A.y < i && (A = new Ye(g.x + (i - g.y) / (A.y - g.y) * (A.x - g.x), i)._round()), g.x >= o && A.x >= o || (g.x >= o ? g = new Ye(o, g.y + (o - g.x) / (A.x - g.x) * (A.y - g.y))._round() : A.x >= o && (A = new Ye(o, g.y + (o - g.x) / (A.x - g.x) * (A.y - g.y))._round()), g.y >= c && A.y >= c || (g.y >= c ? g = new Ye(g.x + (c - g.y) / (A.y - g.y) * (A.x - g.x), c)._round() : A.y >= c && (A = new Ye(g.x + (c - g.y) / (A.y - g.y) * (A.x - g.x), c)._round()), T && g.equals(T[T.length - 1]) || (T = [g], s.push(T)), T.push(A)))));
            }
          }
          return s;
        }
        function qg(a) {
          let e = 0, i = 0;
          for (const h of a) e += h.w * h.h, i = Math.max(i, h.w);
          a.sort((h, y) => y.h - h.h);
          const o = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), i), h: 1 / 0 }];
          let c = 0, s = 0;
          for (const h of a) for (let y = o.length - 1; y >= 0; y--) {
            const T = o[y];
            if (!(h.w > T.w || h.h > T.h)) {
              if (h.x = T.x, h.y = T.y, s = Math.max(s, h.y + h.h), c = Math.max(c, h.x + h.w), h.w === T.w && h.h === T.h) {
                const k = o.pop();
                y < o.length && (o[y] = k);
              } else h.h === T.h ? (T.x += h.w, T.w -= h.w) : h.w === T.w ? (T.y += h.h, T.h -= h.h) : (o.push({ x: T.x + h.w, y: T.y, w: T.w - h.w, h: h.h }), T.y += h.h, T.h -= h.h);
              break;
            }
          }
          return { w: c, h: s, fill: e / (c * s) || 0 };
        }
        Gr(Ic, "Anchor");
        const Ad = 1;
        class Id {
          static getImagePositionScale(e, i, o) {
            return i && e && e.options && e.options.transform ? { x: e.options.transform.a, y: e.options.transform.d } : { x: o, y: o };
          }
          constructor(e, { pixelRatio: i, version: o, stretchX: c, stretchY: s, content: h, sdf: y, usvg: T }, k, g) {
            this.paddedRect = e, this.pixelRatio = i, this.stretchX = c, this.stretchY = s, this.content = h, this.version = o, this.padding = k, this.sdf = y, this.scale = Id.getImagePositionScale(g, T, i);
          }
          get tl() {
            return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * this.padding) / this.scale.x, (this.paddedRect.h - 2 * this.padding) / this.scale.y];
          }
        }
        class $g {
          constructor(e, i, o) {
            const c = {}, s = {};
            this.haveRenderCallbacks = [];
            const h = [];
            this.addImages(e, c, Ad, h), this.addImages(i, s, 2, h);
            const { w: y, h: T } = qg(h), k = new Ea({ width: y || 1, height: T || 1 });
            for (const g in e) {
              const A = e[g], D = c[g].paddedRect;
              Ea.copy(A.data, k, { x: 0, y: 0 }, { x: D.x + Ad, y: D.y + Ad }, A.data, o, A.sdf);
            }
            for (const g in i) {
              const A = i[g], D = s[g].paddedRect;
              let S = s[g].padding;
              const R = D.x + S, j = D.y + S, J = A.data.width, ne = A.data.height;
              S = S > 1 ? S - 1 : S, Ea.copy(A.data, k, { x: 0, y: 0 }, { x: R, y: j }, A.data, o), Ea.copy(A.data, k, { x: 0, y: ne - S }, { x: R, y: j - S }, { width: J, height: S }, o), Ea.copy(A.data, k, { x: 0, y: 0 }, { x: R, y: j + ne }, { width: J, height: S }, o), Ea.copy(A.data, k, { x: J - S, y: 0 }, { x: R - S, y: j }, { width: S, height: ne }, o), Ea.copy(A.data, k, { x: 0, y: 0 }, { x: R + J, y: j }, { width: S, height: ne }, o), Ea.copy(A.data, k, { x: J - S, y: ne - S }, { x: R - S, y: j - S }, { width: S, height: S }, o), Ea.copy(A.data, k, { x: 0, y: ne - S }, { x: R + J, y: j - S }, { width: S, height: S }, o), Ea.copy(A.data, k, { x: 0, y: 0 }, { x: R + J, y: j + ne }, { width: S, height: S }, o), Ea.copy(A.data, k, { x: J - S, y: 0 }, { x: R - S, y: j + ne }, { width: S, height: S }, o);
            }
            this.lut = o, this.image = k, this.iconPositions = c, this.patternPositions = s;
          }
          addImages(e, i, o, c) {
            for (const s in e) {
              const h = e[s], y = { x: 0, y: 0, w: h.data.width + 2 * o, h: h.data.height + 2 * o };
              c.push(y);
              const T = ho.deserializeFromString(s);
              i[s] = new Id(y, h, o, T), h.hasRenderCallback && this.haveRenderCallbacks.push(T.id);
            }
          }
          patchUpdatedImages(e, i, o) {
            this.haveRenderCallbacks = this.haveRenderCallbacks.filter((c) => e.hasImage(c, o)), e.dispatchRenderCallbacks(this.haveRenderCallbacks, o);
            for (const c in e.getUpdatedImages(o)) {
              for (const s of Object.keys(this.iconPositions)) ho.deserializeId(s) === c && this.patchUpdatedImage(this.iconPositions[s], e.getImage(c, o), i);
              for (const s of Object.keys(this.patternPositions)) ho.deserializeId(s) === c && this.patchUpdatedImage(this.patternPositions[s], e.getImage(c, o), i);
            }
          }
          patchUpdatedImage(e, i, o) {
            if (!e || !i || e.version === i.version) return;
            e.version = i.version;
            const [c, s] = e.tl, h = e.sdf;
            if (this.lut || h) {
              const y = { width: i.data.width, height: i.data.height }, T = new Ea(y);
              Ea.copy(i.data, T, { x: 0, y: 0 }, { x: 0, y: 0 }, y, this.lut, h), o.update(T, { position: { x: c, y: s } });
            } else o.update(i.data, { position: { x: c, y: s } });
          }
        }
        Gr(Id, "ImagePosition"), Gr($g, "ImageAtlas");
        const Cd = 1e20;
        function Xg(a, e, i, o, c, s, h, y, T) {
          for (let k = e; k < e + o; k++) Yg(a, i * s + k, s, c, h, y, T);
          for (let k = i; k < i + c; k++) Yg(a, k * s + e, 1, o, h, y, T);
        }
        function Yg(a, e, i, o, c, s, h) {
          s[0] = 0, h[0] = -Cd, h[1] = Cd, c[0] = a[e];
          for (let y = 1, T = 0, k = 0; y < o; y++) {
            c[y] = a[e + y * i];
            const g = y * y;
            do {
              const A = s[T];
              k = (c[y] - c[A] + g - A * A) / (y - A) / 2;
            } while (k <= h[T] && --T > -1);
            T++, s[T] = y, h[T] = k, h[T + 1] = Cd;
          }
          for (let y = 0, T = 0; y < o; y++) {
            for (; h[T + 1] < y; ) T++;
            const k = s[T], g = y - k;
            a[e + y * i] = c[k] + g * g;
          }
        }
        const tu = 2, gm = { none: 0, ideographs: 1, all: 2 };
        class Hf {
          constructor(e, i, o) {
            this.requestManager = e, this.localGlyphMode = i, this.localFontFamily = o, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
          }
          setURL(e, i) {
            this.urls[i] = e;
          }
          getGlyphs(e, i, o) {
            const c = [], s = this.urls[i] || yt.GLYPHS_URL;
            for (const h in e) for (const y of e[h]) c.push({ stack: h, id: y });
            Wt(c, ({ stack: h, id: y }, T) => {
              let k = this.entries[h];
              k || (k = this.entries[h] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
              let g = k.glyphs[y];
              if (g !== void 0) return void T(null, { stack: h, id: y, glyph: g });
              if (g = this._tinySDF(k, h, y), g) return k.glyphs[y] = g, void T(null, { stack: h, id: y, glyph: g });
              const A = Math.floor(y / 256);
              if (256 * A > 65535) return Tt("glyphs > 65535 not supported"), void T(null, { stack: h, id: y, glyph: g });
              if (k.ranges[A]) return void T(null, { stack: h, id: y, glyph: g });
              let D = k.requests[A];
              D || (D = k.requests[A] = [], Hf.loadGlyphRange(h, A, s, this.requestManager, (S, R) => {
                if (R) {
                  k.ascender = R.ascender, k.descender = R.descender;
                  for (const j in R.glyphs) this._doesCharSupportLocalGlyph(+j) || (k.glyphs[+j] = R.glyphs[+j]);
                  k.ranges[A] = !0;
                }
                for (const j of D) j(S, R);
                delete k.requests[A];
              })), D.push((S, R) => {
                S ? T(S) : R && T(null, { stack: h, id: y, glyph: R.glyphs[y] || null });
              });
            }, (h, y) => {
              if (h) o(h);
              else if (y) {
                const T = {};
                for (const { stack: k, id: g, glyph: A } of y) T[k] === void 0 && (T[k] = {}), T[k].glyphs === void 0 && (T[k].glyphs = {}), T[k].glyphs[g] = A && { id: A.id, bitmap: A.bitmap.clone(), metrics: A.metrics }, T[k].ascender = this.entries[k].ascender, T[k].descender = this.entries[k].descender;
                o(null, T);
              }
            });
          }
          _doesCharSupportLocalGlyph(e) {
            return this.localGlyphMode !== gm.none && (this.localGlyphMode === gm.all ? !!this.localFontFamily : !!this.localFontFamily && (ri["CJK Unified Ideographs"](e) || ri["Hangul Syllables"](e) || ri.Hiragana(e) || ri.Katakana(e) || ri["CJK Symbols and Punctuation"](e) || ri["CJK Unified Ideographs Extension A"](e) || ri["CJK Unified Ideographs Extension B"](e) || ri.Osage(e)));
          }
          _tinySDF(e, i, o) {
            const c = this.localFontFamily;
            if (!c || !this._doesCharSupportLocalGlyph(o)) return;
            let s = e.tinySDF;
            if (!s) {
              let j = "400";
              /bold/i.test(i) ? j = "900" : /medium/i.test(i) ? j = "500" : /light/i.test(i) && (j = "200"), s = e.tinySDF = new Hf.TinySDF({ fontFamily: c, fontWeight: j, fontSize: 24 * tu, buffer: 3 * tu, radius: 8 * tu }), s.fontWeight = j;
            }
            if (this.localGlyphs[s.fontWeight][o]) return this.localGlyphs[s.fontWeight][o];
            const h = String.fromCodePoint(o), { data: y, width: T, height: k, glyphWidth: g, glyphHeight: A, glyphLeft: D, glyphTop: S, glyphAdvance: R } = s.draw(h);
            return this.localGlyphs[s.fontWeight][o] = { id: o, bitmap: new dl({ width: T, height: k }, y), metrics: { width: g / tu, height: A / tu, left: D / tu, top: S / tu - 27, advance: R / tu, localGlyph: !0 } };
          }
        }
        Hf.loadGlyphRange = function(a, e, i, o, c) {
          const s = 256 * e, h = s + 255, y = o.transformRequest(o.normalizeGlyphsURL(i).replace("{fontstack}", a).replace("{range}", `${s}-${h}`), Bi.Glyphs);
          ea(y, (T, k) => {
            if (T) c(T);
            else if (k) {
              const g = {}, A = function(D) {
                return new sp(D).readFields(m1, {});
              }(k);
              for (const D of A.glyphs) g[D.id] = D;
              c(null, { glyphs: g, ascender: A.ascender, descender: A.descender });
            }
          });
        }, Hf.TinySDF = class {
          constructor({ fontSize: a = 24, buffer: e = 3, radius: i = 8, cutoff: o = 0.25, fontFamily: c = "sans-serif", fontWeight: s = "normal", fontStyle: h = "normal" } = {}) {
            this.buffer = e, this.cutoff = o, this.radius = i;
            const y = this.size = a + 4 * e, T = this._createCanvas(y), k = this.ctx = T.getContext("2d", { willReadFrequently: !0 });
            k.font = `${h} ${s} ${a}px ${c}`, k.textBaseline = "alphabetic", k.textAlign = "left", k.fillStyle = "black", this.gridOuter = new Float64Array(y * y), this.gridInner = new Float64Array(y * y), this.f = new Float64Array(y), this.z = new Float64Array(y + 1), this.v = new Uint16Array(y);
          }
          _createCanvas(a) {
            const e = document.createElement("canvas");
            return e.width = e.height = a, e;
          }
          draw(a) {
            const { width: e, actualBoundingBoxAscent: i, actualBoundingBoxDescent: o, actualBoundingBoxLeft: c, actualBoundingBoxRight: s } = this.ctx.measureText(a), h = Math.ceil(i), y = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - c))), T = Math.min(this.size - this.buffer, h + Math.ceil(o)), k = y + 2 * this.buffer, g = T + 2 * this.buffer, A = Math.max(k * g, 0), D = new Uint8ClampedArray(A), S = { data: D, width: k, height: g, glyphWidth: y, glyphHeight: T, glyphTop: h, glyphLeft: 0, glyphAdvance: e };
            if (y === 0 || T === 0) return S;
            const { ctx: R, buffer: j, gridInner: J, gridOuter: ne } = this;
            R.clearRect(j, j, y, T), R.fillText(a, j, j + h);
            const me = R.getImageData(j, j, y, T);
            ne.fill(Cd, 0, A), J.fill(0, 0, A);
            for (let ge = 0; ge < T; ge++) for (let ue = 0; ue < y; ue++) {
              const Se = me.data[4 * (ge * y + ue) + 3] / 255;
              if (Se === 0) continue;
              const ke = (ge + j) * k + ue + j;
              if (Se === 1) ne[ke] = 0, J[ke] = Cd;
              else {
                const He = 0.5 - Se;
                ne[ke] = He > 0 ? He * He : 0, J[ke] = He < 0 ? He * He : 0;
              }
            }
            Xg(ne, 0, 0, k, g, k, this.f, this.v, this.z), Xg(J, j, j, y, T, k, this.f, this.v, this.z);
            for (let ge = 0; ge < A; ge++) {
              const ue = Math.sqrt(ne[ge]) - Math.sqrt(J[ge]);
              D[ge] = Math.round(255 - 255 * (ue / this.radius + this.cutoff));
            }
            return S;
          }
        };
        const gh = Ad;
        function Kg(a, e) {
          return a + e[1] - e[0];
        }
        function Jg(a, e, i, o, c = 1) {
          const s = [], h = a.imagePrimary, y = h.pixelRatio, T = h.paddedRect.w - 2 * gh, k = h.paddedRect.h - 2 * gh, g = (a.right - a.left) * c, A = (a.bottom - a.top) * c, D = h.stretchX || [[0, T]], S = h.stretchY || [[0, k]], R = D.reduce(Kg, 0), j = S.reduce(Kg, 0), J = T - R, ne = k - j;
          let me = 0, ge = R, ue = 0, Se = j, ke = 0, He = J, at = 0, nt = ne;
          if (h.content && o) {
            const Et = h.content;
            me = up(D, 0, Et[0]), ue = up(S, 0, Et[1]), ge = up(D, Et[0], Et[2]), Se = up(S, Et[1], Et[3]), ke = Et[0] - me, at = Et[1] - ue, He = Et[2] - Et[0] - ge, nt = Et[3] - Et[1] - Se;
          }
          const tt = (Et, lt, St, Lt) => {
            const It = cp(Et.stretch - me, ge, g, a.left * c), zt = hp(Et.fixed - ke, He, Et.stretch, R), Ft = cp(lt.stretch - ue, Se, A, a.top * c), qt = hp(lt.fixed - at, nt, lt.stretch, j), Ot = cp(St.stretch - me, ge, g, a.left * c), cr = hp(St.fixed - ke, He, St.stretch, R), yr = cp(Lt.stretch - ue, Se, A, a.top * c), ur = hp(Lt.fixed - at, nt, Lt.stretch, j), jr = new Ye(It, Ft), zr = new Ye(Ot, Ft), Ar = new Ye(Ot, yr), vr = new Ye(It, yr), ti = new Ye(zt / y, qt / y), Wr = new Ye(cr / y, ur / y), $r = e * Math.PI / 180;
            if ($r) {
              const Hi = Math.sin($r), gn = Math.cos($r), cn = [gn, -Hi, Hi, gn];
              jr._matMult(cn), zr._matMult(cn), vr._matMult(cn), Ar._matMult(cn);
            }
            const bi = Et.stretch + Et.fixed, Ci = St.stretch + St.fixed, Pi = lt.stretch + lt.fixed, Ri = Lt.stretch + Lt.fixed, ji = a.imageSecondary;
            return { tl: jr, tr: zr, bl: vr, br: Ar, texPrimary: { x: h.paddedRect.x + gh + bi, y: h.paddedRect.y + gh + Pi, w: Ci - bi, h: Ri - Pi }, texSecondary: ji ? { x: ji.paddedRect.x + gh + bi, y: ji.paddedRect.y + gh + Pi, w: Ci - bi, h: Ri - Pi } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: ti, pixelOffsetBR: Wr, minFontScaleX: He / y / g, minFontScaleY: nt / y / A, isSDF: i };
          };
          if (o && (h.stretchX || h.stretchY)) {
            const Et = Qg(D, J, R), lt = Qg(S, ne, j);
            for (let St = 0; St < Et.length - 1; St++) {
              const Lt = Et[St], It = Et[St + 1];
              for (let zt = 0; zt < lt.length - 1; zt++) s.push(tt(Lt, lt[zt], It, lt[zt + 1]));
            }
          } else s.push(tt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: T + 1 }, { fixed: 0, stretch: k + 1 }));
          return s;
        }
        function up(a, e, i) {
          let o = 0;
          for (const c of a) o += Math.max(e, Math.min(i, c[1])) - Math.max(e, Math.min(i, c[0]));
          return o;
        }
        function Qg(a, e, i) {
          const o = [{ fixed: -gh, stretch: 0 }];
          for (const [c, s] of a) {
            const h = o[o.length - 1];
            o.push({ fixed: c - h.stretch, stretch: h.stretch }), o.push({ fixed: c - h.stretch, stretch: h.stretch + (s - c) });
          }
          return o.push({ fixed: e + gh, stretch: i }), o;
        }
        function cp(a, e, i, o) {
          return a / e * i + o;
        }
        function hp(a, e, i, o) {
          return a - e * i / o;
        }
        function E1(a, e, i, o) {
          const c = e + a.positionedLines[o].lineOffset;
          return o === 0 ? i + c / 2 : i + (c + (e + a.positionedLines[o - 1].lineOffset)) / 2;
        }
        function S1(a, e = 1, i = !1) {
          let o = 1 / 0, c = 1 / 0, s = -1 / 0, h = -1 / 0;
          const y = a[0];
          for (let S = 0; S < y.length; S++) {
            const R = y[S];
            (!S || R.x < o) && (o = R.x), (!S || R.y < c) && (c = R.y), (!S || R.x > s) && (s = R.x), (!S || R.y > h) && (h = R.y);
          }
          const T = Math.min(s - o, h - c);
          let k = T / 2;
          const g = new xa([], T1);
          if (T === 0) return new Ye(o, c);
          for (let S = o; S < s; S += T) for (let R = c; R < h; R += T) g.push(new Wf(S + k, R + k, k, a));
          let A = function(S) {
            let R = 0, j = 0, J = 0;
            const ne = S[0];
            for (let me = 0, ge = ne.length, ue = ge - 1; me < ge; ue = me++) {
              const Se = ne[me], ke = ne[ue], He = Se.x * ke.y - ke.x * Se.y;
              j += (Se.x + ke.x) * He, J += (Se.y + ke.y) * He, R += 3 * He;
            }
            return new Wf(j / R, J / R, 0, S);
          }(a), D = g.length;
          for (; g.length; ) {
            const S = g.pop();
            (S.d > A.d || !A.d) && (A = S, i && console.log("found best %d after %d probes", Math.round(1e4 * S.d) / 1e4, D)), S.max - A.d <= e || (k = S.h / 2, g.push(new Wf(S.p.x - k, S.p.y - k, k, a)), g.push(new Wf(S.p.x + k, S.p.y - k, k, a)), g.push(new Wf(S.p.x - k, S.p.y + k, k, a)), g.push(new Wf(S.p.x + k, S.p.y + k, k, a)), D += 4);
          }
          return i && (console.log(`num probes: ${D}`), console.log(`best distance: ${A.d}`)), A.p;
        }
        function T1(a, e) {
          return e.max - a.max;
        }
        class Wf {
          constructor(e, i, o, c) {
            this.p = new Ye(e, i), this.h = o, this.d = function(s, h) {
              let y = !1, T = 1 / 0;
              for (let k = 0; k < h.length; k++) {
                const g = h[k];
                for (let A = 0, D = g.length, S = D - 1; A < D; S = A++) {
                  const R = g[A], j = g[S];
                  R.y > s.y != j.y > s.y && s.x < (j.x - R.x) * (s.y - R.y) / (j.y - R.y) + R.x && (y = !y), T = Math.min(T, mt(s, R, j));
                }
              }
              return (y ? 1 : -1) * Math.sqrt(T);
            }(this.p, c), this.max = this.d + this.h * Math.SQRT2;
          }
        }
        const ym = Number.POSITIVE_INFINITY, M1 = Math.sqrt(2);
        function e0(a, [e, i]) {
          let o = 0, c = 0;
          if (i === ym) {
            e < 0 && (e = 0);
            const s = e / M1;
            switch (a) {
              case "top-right":
              case "top-left":
                c = s - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                c = 7 - s;
                break;
              case "bottom":
                c = 7 - e;
                break;
              case "top":
                c = e - 7;
            }
            switch (a) {
              case "top-right":
              case "bottom-right":
                o = -s;
                break;
              case "top-left":
              case "bottom-left":
                o = s;
                break;
              case "left":
                o = e;
                break;
              case "right":
                o = -e;
            }
          } else {
            switch (e = Math.abs(e), i = Math.abs(i), a) {
              case "top-right":
              case "top-left":
              case "top":
                c = i - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                c = 7 - i;
            }
            switch (a) {
              case "top-right":
              case "bottom-right":
              case "right":
                o = -e;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                o = e;
            }
          }
          return [o, c];
        }
        function vm(a) {
          switch (a) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function A1(a, e, i, o, c, s, h, y, T, k, g, A, D, S, R) {
          let j = s.textMaxSize.evaluate(e, {}, A);
          j === void 0 ? j = h * s.textScaleFactor : j *= s.textScaleFactor;
          const J = a.layers[0].layout, ne = J.get("icon-offset").evaluate(e, {}, A), me = r0(i.horizontal) || i.vertical, ge = D.name === "globe", ue = qa, Se = h * s.textScaleFactor / ue, ke = a.tilePixelRatio * j / ue, He = (It = a.overscaling, a.zoom > 18 && It > 2 && (It >>= 1), Math.max(Br / (512 * It), 1) * J.get("symbol-spacing")), at = J.get("text-padding") * a.tilePixelRatio, nt = J.get("icon-padding") * a.tilePixelRatio, tt = Ae(J.get("text-max-angle")), Et = J.get("text-rotation-alignment") === "map" && J.get("symbol-placement") !== "point", lt = J.get("icon-rotation-alignment") === "map" && J.get("symbol-placement") !== "point", St = J.get("symbol-placement"), Lt = He / 2;
          var It;
          const zt = J.get("icon-text-fit").evaluate(e, {}, A), Ft = J.get("icon-text-fit-padding").evaluate(e, {}, A), qt = zt !== "none";
          let Ot;
          a.hasAnyIconTextFit === !1 && qt && (a.hasAnyIconTextFit = !0), o && qt && (a.allowVerticalPlacement && i.vertical && (Ot = Ug(o, i.vertical, zt, Ft, ne, Se)), me && (o = Ug(o, me, zt, Ft, ne, Se)));
          const cr = (yr, ur, jr) => {
            if (ur.x < 0 || ur.x >= Br || ur.y < 0 || ur.y >= Br) return;
            let zr = null;
            if (ge) {
              const { x: Ar, y: vr, z: ti } = D.projectTilePoint(ur.x, ur.y, jr);
              zr = { anchor: new Ic(Ar, vr, ti, 0, void 0), up: D.upVector(jr, ur.x, ur.y) };
            }
            (function(Ar, vr, ti, Wr, $r, bi, Ci, Pi, Ri, ji, Hi, gn, cn, Si, an, un, Sn, $n, oa, Xn, Vn, Jn, da, $a, wn, Go, au) {
              const ml = Ar.addToLineVertexArray(vr, Wr);
              let _l, hf, wh, ff, $d, Oy, By, Fy = 0, Ny = 0, Uy = 0, jy = 0, e_ = -1, t_ = -1;
              const ju = {};
              let Vy = co("");
              const df = ti ? ti.anchor : vr, r_ = Ri.layout.get("icon-text-fit").evaluate(Vn, {}, wn) !== "none";
              let i_ = 0, n_ = 0;
              if (Ri._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [i_, n_] = Ri.layout.get("text-offset").evaluate(Vn, {}, wn).map((Os) => Os * qa) : (i_ = Ri.layout.get("text-radial-offset").evaluate(Vn, {}, wn) * qa, n_ = ym), Ar.allowVerticalPlacement && $r.vertical) {
                const Os = $r.vertical;
                if (an) Oy = xm(Os), Pi && (By = xm(Pi));
                else {
                  const Ho = Ri.layout.get("text-rotate").evaluate(Vn, {}, wn) + 90;
                  wh = fp(ji, df, vr, Hi, gn, cn, Os, Si, Ho, un), Pi && (ff = fp(ji, df, vr, Hi, gn, cn, Pi, $n, Ho));
                }
              }
              if (bi) {
                const Os = Ar.iconSizeData, Ho = Ri.layout.get("icon-rotate").evaluate(Vn, {}, wn), Xd = Jg(bi, Ho, da, r_, Jn.iconScaleFactor), o_ = Pi ? Jg(Pi, Ho, da, r_, Jn.iconScaleFactor) : void 0;
                hf = fp(ji, df, vr, Hi, gn, cn, bi, $n, Ho, null), Fy = 4 * Xd.length;
                let pf = null;
                Os.kind === "source" ? (pf = [eu * Ri.layout.get("icon-size").evaluate(Vn, {}, wn) * Jn.iconScaleFactor], pf[0] > yh && Tt(`${Ar.layerIds[0]}: Value for "icon-size" is >= ${Pd}. Reduce your "icon-size".`)) : Os.kind === "composite" && (pf = [eu * Jn.compositeIconSizes[0].evaluate(Vn, {}, wn) * Jn.iconScaleFactor, eu * Jn.compositeIconSizes[1].evaluate(Vn, {}, wn) * Jn.iconScaleFactor], (pf[0] > yh || pf[1] > yh) && Tt(`${Ar.layerIds[0]}: Value for "icon-size" is >= ${Pd}. Reduce your "icon-size".`)), Ar.addSymbols(Ar.icon, Xd, pf, Xn, oa, Vn, !1, ti, vr, ml.lineStartIndex, ml.lineLength, -1, $a, wn, Go, au), e_ = Ar.icon.placedSymbolArray.length - 1, o_ && (Ny = 4 * o_.length, Ar.addSymbols(Ar.icon, o_, pf, Xn, oa, Vn, ks.vertical, ti, vr, ml.lineStartIndex, ml.lineLength, -1, $a, wn, Go, au), t_ = Ar.icon.placedSymbolArray.length - 1);
              }
              for (const Os in $r.horizontal) {
                const Ho = $r.horizontal[Os];
                _l || (Vy = co(Ho.text), an ? $d = xm(Ho) : _l = fp(ji, df, vr, Hi, gn, cn, Ho, Si, Ri.layout.get("text-rotate").evaluate(Vn, {}, wn), un));
                const Xd = Ho.positionedLines.length === 1;
                if (Uy += t0(Ar, ti, vr, Ho, Ci, Ri, an, Vn, un, ml, $r.vertical ? ks.horizontal : ks.horizontalOnly, Xd ? Object.keys($r.horizontal) : [Os], ju, e_, Jn, $a, wn, Go), Xd) break;
              }
              $r.vertical && (jy += t0(Ar, ti, vr, $r.vertical, Ci, Ri, an, Vn, un, ml, ks.vertical, ["vertical"], ju, t_, Jn, $a, wn, Go));
              let Eh = -1;
              const a_ = (Os, Ho) => Os ? Math.max(Os, Ho) : Ho;
              Eh = a_($d, Eh), Eh = a_(Oy, Eh), Eh = a_(By, Eh);
              const ob = Eh > -1 ? 1 : 0;
              Ar.glyphOffsetArray.length >= 65535 && Tt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Vn.sortKey !== void 0 && Ar.addToSortKeyRanges(Ar.symbolInstances.length, Vn.sortKey), Ar.symbolInstances.emplaceBack(vr.x, vr.y, df.x, df.y, df.z, ju.right >= 0 ? ju.right : -1, ju.center >= 0 ? ju.center : -1, ju.left >= 0 ? ju.left : -1, ju.vertical >= 0 ? ju.vertical : -1, e_, t_, Vy, _l !== void 0 ? _l : Ar.collisionBoxArray.length, _l !== void 0 ? _l + 1 : Ar.collisionBoxArray.length, wh !== void 0 ? wh : Ar.collisionBoxArray.length, wh !== void 0 ? wh + 1 : Ar.collisionBoxArray.length, hf !== void 0 ? hf : Ar.collisionBoxArray.length, hf !== void 0 ? hf + 1 : Ar.collisionBoxArray.length, ff || Ar.collisionBoxArray.length, ff ? ff + 1 : Ar.collisionBoxArray.length, Hi, Uy, jy, Fy, Ny, ob, 0, i_, n_, Eh, 0, r_ ? 1 : 0);
            })(a, ur, zr, yr, i, o, c, Ot, a.layers[0], a.collisionBoxArray, e.index, e.sourceLayerIndex, a.index, at, Et, T, 0, nt, lt, ne, e, s, k, g, A, S, R);
          };
          if (St === "line") for (const yr of Zg(e.geometry, 0, 0, Br, Br)) {
            const ur = w1(yr, He, tt, i.vertical || me, o, ue, ke, a.overscaling, Br);
            for (const jr of ur) me && I1(a, me.text, Lt, jr) || cr(yr, jr, A);
          }
          else if (St === "line-center") {
            for (const yr of e.geometry) if (yr.length > 1) {
              const ur = b1(yr, tt, i.vertical || me, o, ue, ke);
              ur && cr(yr, ur, A);
            }
          } else if (e.type === "Polygon") for (const yr of ei(e.geometry, 0)) {
            const ur = S1(yr, 16);
            cr(yr[0], new Ic(ur.x, ur.y, 0, 0, void 0), A);
          }
          else if (e.type === "LineString") for (const yr of e.geometry) cr(yr, new Ic(yr[0].x, yr[0].y, 0, 0, void 0), A);
          else if (e.type === "Point") for (const yr of e.geometry) for (const ur of yr) cr([ur], new Ic(ur.x, ur.y, 0, 0, void 0), A);
        }
        const Pd = 255, yh = Pd * eu;
        function t0(a, e, i, o, c, s, h, y, T, k, g, A, D, S, R, j, J, ne) {
          const me = function(Se, ke, He, at, nt, tt, Et, lt) {
            const St = [];
            if (ke.positionedLines.length === 0) return St;
            const Lt = at.layout.get("text-rotate").evaluate(tt, {}) * Math.PI / 180, It = function(cr) {
              const yr = cr[0], ur = cr[1], jr = yr * ur;
              return jr > 0 ? [yr, -ur] : jr < 0 ? [-yr, ur] : yr === 0 ? [ur, yr] : [ur, -yr];
            }(He);
            let zt = Math.abs(ke.top - ke.bottom);
            for (const cr of ke.positionedLines) zt -= cr.lineOffset;
            const Ft = ke.positionedLines.length, qt = zt / Ft;
            let Ot = ke.top - He[1];
            for (let cr = 0; cr < Ft; ++cr) {
              const yr = ke.positionedLines[cr];
              Ot = E1(ke, qt, Ot, cr);
              for (const ur of yr.positionedGlyphs) {
                if (!ur.rect) continue;
                const jr = ur.rect || {};
                let zr = kg + 1, Ar = !0, vr = 1, ti = 0;
                if (ur.imageName) {
                  const Xn = Et[ma.build(ur.imageName).getSerializedPrimary()];
                  if (!Xn) continue;
                  if (Xn.sdf) {
                    Tt("SDF images are not supported in formatted text and will be ignored.");
                    continue;
                  }
                  Ar = !1, vr = Xn.pixelRatio, zr = Ad / vr;
                }
                const Wr = (nt || lt) && ur.vertical, $r = ur.metrics.advance * ur.scale / 2, bi = ur.metrics, Ci = ur.rect;
                if (Ci === null) continue;
                lt && ke.verticalizable && (ti = ur.imageName ? $r - ur.metrics.width * ur.scale / 2 : 0);
                const Pi = nt ? [ur.x + $r, ur.y] : [0, 0];
                let Ri = [0, 0], ji = [0, 0], Hi = !1;
                nt || (Wr ? (ji = [ur.x + $r + It[0], ur.y + It[1] - ti], Hi = !0) : Ri = [ur.x + $r + He[0], ur.y + He[1] - ti]);
                const gn = Ci.w * ur.scale / (vr * (ur.localGlyph ? tu : 1)), cn = Ci.h * ur.scale / (vr * (ur.localGlyph ? tu : 1));
                let Si, an, un, Sn;
                if (Wr) {
                  const Xn = ur.y - Ot, Vn = new Ye(-$r, $r - Xn), Jn = -Math.PI / 2, da = new Ye(...ji);
                  Si = new Ye(-$r + Ri[0], Ri[1]), Si._rotateAround(Jn, Vn)._add(da), Si.x += -Xn + $r, Si.y -= (bi.left - zr) * ur.scale;
                  const $a = ur.imageName ? bi.advance * ur.scale : qa * ur.scale, wn = String.fromCodePoint(ur.glyph);
                  f1(wn) ? Si.x += (1 - zr) * ur.scale : d1(wn) ? Si.x += $a - bi.height * ur.scale + (-zr - 1) * ur.scale : Si.x += ur.imageName || bi.width + 2 * zr === Ci.w && bi.height + 2 * zr === Ci.h ? ($a - cn) / 2 : ($a - (bi.height + 2 * zr) * ur.scale) / 2, an = new Ye(Si.x, Si.y - gn), un = new Ye(Si.x + cn, Si.y), Sn = new Ye(Si.x + cn, Si.y - gn);
                } else {
                  const Xn = (bi.left - zr) * ur.scale - $r + Ri[0], Vn = (-bi.top - zr) * ur.scale + Ri[1], Jn = Xn + gn, da = Vn + cn;
                  Si = new Ye(Xn, Vn), an = new Ye(Jn, Vn), un = new Ye(Xn, da), Sn = new Ye(Jn, da);
                }
                if (Lt) {
                  let Xn;
                  Xn = nt ? new Ye(0, 0) : Hi ? new Ye(It[0], It[1]) : new Ye(He[0], He[1]), Si._rotateAround(Lt, Xn), an._rotateAround(Lt, Xn), un._rotateAround(Lt, Xn), Sn._rotateAround(Lt, Xn);
                }
                const $n = new Ye(0, 0), oa = new Ye(0, 0);
                St.push({ tl: Si, tr: an, bl: un, br: Sn, texPrimary: jr, texSecondary: void 0, writingMode: ke.writingMode, glyphOffset: Pi, sectionIndex: ur.sectionIndex, isSDF: Ar, pixelOffsetTL: $n, pixelOffsetBR: oa, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
            return St;
          }(0, o, T, s, h, y, c, a.allowVerticalPlacement), ge = a.textSizeData;
          let ue = null;
          ge.kind === "source" ? (ue = [eu * s.layout.get("text-size").evaluate(y, {}, J) * R.textScaleFactor], ue[0] > yh && Tt(`${a.layerIds[0]}: Value for "text-size" is >= ${Pd}. Reduce your "text-size".`)) : ge.kind === "composite" && (ue = [eu * R.compositeTextSizes[0].evaluate(y, {}, J) * R.textScaleFactor, eu * R.compositeTextSizes[1].evaluate(y, {}, J) * R.textScaleFactor], (ue[0] > yh || ue[1] > yh) && Tt(`${a.layerIds[0]}: Value for "text-size" is >= ${Pd}. Reduce your "text-size".`)), a.addSymbols(a.text, me, ue, T, h, y, g, e, i, k.lineStartIndex, k.lineLength, S, j, J, ne, !1);
          for (const Se of A) D[Se] = a.text.placedSymbolArray.length - 1;
          return 4 * me.length;
        }
        function r0(a) {
          for (const e in a) return a[e];
          return null;
        }
        function fp(a, e, i, o, c, s, h, y, T, k) {
          let g = h.top, A = h.bottom, D = h.left, S = h.right;
          const R = h.collisionPadding;
          if (R && (D -= R[0], g -= R[1], S += R[2], A += R[3]), T) {
            const j = new Ye(D, g), J = new Ye(S, g), ne = new Ye(D, A), me = new Ye(S, A), ge = Ae(T);
            let ue = new Ye(0, 0);
            k && (ue = new Ye(k[0], k[1])), j._rotateAround(ge, ue), J._rotateAround(ge, ue), ne._rotateAround(ge, ue), me._rotateAround(ge, ue), D = Math.min(j.x, J.x, ne.x, me.x), S = Math.max(j.x, J.x, ne.x, me.x), g = Math.min(j.y, J.y, ne.y, me.y), A = Math.max(j.y, J.y, ne.y, me.y);
          }
          return a.emplaceBack(e.x, e.y, e.z, i.x, i.y, D, g, S, A, y, o, c, s), a.length - 1;
        }
        function xm(a) {
          a.collisionPadding && (a.top -= a.collisionPadding[1], a.bottom += a.collisionPadding[3]);
          const e = a.bottom - a.top;
          return e > 0 ? Math.max(10, e) : null;
        }
        function I1(a, e, i, o) {
          const c = a.compareText;
          if (e in c) {
            const s = c[e];
            for (let h = s.length - 1; h >= 0; h--) if (o.dist(s[h]) < i) return !0;
          } else c[e] = [];
          return c[e].push(o), !1;
        }
        function i0(a, e) {
          const i = a.fovAboveCenter, o = a.elevation ? a.elevation.getMinElevationBelowMSL() * e : 0, c = (a._camera.position[2] * a.worldSize - o) / Math.cos(a._pitch), s = Math.sin(i) * c / Math.sin(Math.max(Math.PI / 2 - a._pitch - i, 0.01));
          let h = Math.sin(a._pitch) * s + c;
          const y = c * (1 / a._horizonShift);
          if (!a.elevation || a.elevation.exaggeration() === 0) {
            let T = Math.max(a.zoom - 17, 0);
            a.isOrthographic && (T /= 10), h *= 1 + T;
          }
          return Math.min(1.01 * h, y);
        }
        function Rd(a, e) {
          if (!e.isReprojectedInTileSpace) return { scale: 1 << a.z, x: a.x, y: a.y, x2: a.x + 1, y2: a.y + 1, projection: e };
          const i = Math.pow(2, -a.z), o = a.x * i, c = (a.x + 1) * i, s = a.y * i, h = (a.y + 1) * i, y = so(o), T = so(c), k = ci(s), g = ci(h), A = e.project(y, k), D = e.project(T, k), S = e.project(T, g), R = e.project(y, g);
          let j = Math.min(A.x, D.x, S.x, R.x), J = Math.min(A.y, D.y, S.y, R.y), ne = Math.max(A.x, D.x, S.x, R.x), me = Math.max(A.y, D.y, S.y, R.y);
          const ge = i / 16;
          function ue(ke, He, at, nt, tt, Et) {
            const lt = (at + tt) / 2, St = (nt + Et) / 2, Lt = e.project(so(lt), ci(St)), It = Math.max(0, j - Lt.x, J - Lt.y, Lt.x - ne, Lt.y - me);
            j = Math.min(j, Lt.x), ne = Math.max(ne, Lt.x), J = Math.min(J, Lt.y), me = Math.max(me, Lt.y), It > ge && (ue(ke, Lt, at, nt, lt, St), ue(Lt, He, lt, St, tt, Et));
          }
          ue(A, D, o, s, c, s), ue(D, S, c, s, c, h), ue(S, R, c, h, o, h), ue(R, A, o, h, o, s), j -= ge, J -= ge, ne += ge, me += ge;
          const Se = 1 / Math.max(ne - j, me - J);
          return { scale: Se, x: j * Se, y: J * Se, x2: ne * Se, y2: me * Se, projection: e };
        }
        function n0(a, { x: e, y: i }, o = 0) {
          return new Ye(((e - o) * a.scale - a.x) * Br, (i * a.scale - a.y) * Br);
        }
        const C1 = Oe.mat4.identity(new Float32Array(16));
        class vh {
          constructor(e) {
            this.spec = e, this.name = e.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
          }
          project(e, i) {
            return { x: 0, y: 0, z: 0 };
          }
          unproject(e, i) {
            return new qi(0, 0);
          }
          projectTilePoint(e, i, o) {
            return { x: e, y: i, z: 0 };
          }
          locationPoint(e, i, o = !0) {
            return e._coordinatePoint(e.locationCoordinate(i), o);
          }
          pixelsPerMeter(e, i) {
            return xn(1, e) * i;
          }
          pixelSpaceConversion(e, i, o) {
            return 1;
          }
          farthestPixelDistance(e) {
            return i0(e, e.pixelsPerMeter);
          }
          pointCoordinate(e, i, o, c) {
            const s = e.horizonLineFromTop(!1), h = new Ye(i, Math.max(s, o));
            return e.rayIntersectionCoordinate(e.pointRayIntersection(h, c));
          }
          pointCoordinate3D(e, i, o) {
            const c = new Ye(i, o);
            if (e.elevation) return e.elevation.pointCoordinate(c);
            {
              const s = this.pointCoordinate(e, c.x, c.y, 0);
              return [s.x, s.y, s.z];
            }
          }
          isPointAboveHorizon(e, i) {
            if (e.elevation && e.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(e, i.x, i.y);
            const o = e.horizonLineFromTop();
            return i.y < o;
          }
          createInversionMatrix(e, i) {
            return C1;
          }
          createTileMatrix(e, i, o) {
            let c, s, h;
            const y = o.canonical, T = Oe.mat4.identity(new Float64Array(16));
            if (this.isReprojectedInTileSpace) {
              const k = Rd(y, this);
              c = 1, s = k.x + o.wrap * k.scale, h = k.y, Oe.mat4.scale(T, T, [c / k.scale, c / k.scale, e.pixelsPerMeter / i]);
            } else c = i / e.zoomScale(y.z), s = (y.x + Math.pow(2, y.z) * o.wrap) * c, h = y.y * c;
            return Oe.mat4.translate(T, T, [s, h, 0]), Oe.mat4.scale(T, T, [c / Br, c / Br, 1]), T;
          }
          upVector(e, i, o) {
            return [0, 0, 1];
          }
          upVectorScale(e, i, o) {
            return { metersToTile: 1 };
          }
        }
        class P1 extends vh {
          constructor(e) {
            super(e), this.range = [4, 7], this.center = e.center || [-96, 37.5];
            const [i, o] = this.parallels = e.parallels || [29.5, 45.5], c = Math.sin(Ae(i));
            this.n = (c + Math.sin(Ae(o))) / 2, this.c = 1 + c * (2 * this.n - c), this.r0 = Math.sqrt(this.c) / this.n;
          }
          project(e, i) {
            const { n: o, c, r0: s } = this, h = Ae(e - this.center[0]), y = Ae(i), T = Math.sqrt(c - 2 * o * Math.sin(y)) / o;
            return { x: T * Math.sin(h * o), y: T * Math.cos(h * o) - s, z: 0 };
          }
          unproject(e, i) {
            const { n: o, c, r0: s } = this, h = s + i;
            let y = Math.atan2(e, Math.abs(h)) * Math.sign(h);
            h * o < 0 && (y -= Math.PI * Math.sign(e) * Math.sign(h));
            const T = Ae(this.center[0]) * o;
            y = bt(y, -Math.PI - T, Math.PI - T);
            const k = ie(_e(y / o) + this.center[0], -180, 180), g = Math.asin(ie((c - (e * e + h * h) * o * o) / (2 * o), -1, 1)), A = ie(_e(g), -Cn, Cn);
            return new qi(k, A);
          }
        }
        const Ld = 1.340264, Dd = -0.081106, kd = 893e-6, zd = 3796e-6, dp = Math.sqrt(3) / 2;
        class R1 extends vh {
          project(e, i) {
            i = i / 180 * Math.PI, e = e / 180 * Math.PI;
            const o = Math.asin(dp * Math.sin(i)), c = o * o, s = c * c * c;
            return { x: 0.5 * (e * Math.cos(o) / (dp * (Ld + 3 * Dd * c + s * (7 * kd + 9 * zd * c))) / Math.PI + 0.5), y: 1 - 0.5 * (o * (Ld + Dd * c + s * (kd + zd * c)) / Math.PI + 1), z: 0 };
          }
          unproject(e, i) {
            e = (2 * e - 0.5) * Math.PI;
            let o = i = (2 * (1 - i) - 1) * Math.PI, c = o * o, s = c * c * c;
            for (let g, A, D, S = 0; S < 12 && (A = o * (Ld + Dd * c + s * (kd + zd * c)) - i, D = Ld + 3 * Dd * c + s * (7 * kd + 9 * zd * c), g = A / D, o = ie(o - g, -Math.PI / 3, Math.PI / 3), c = o * o, s = c * c * c, !(Math.abs(g) < 1e-12)); ++S) ;
            const h = dp * e * (Ld + 3 * Dd * c + s * (7 * kd + 9 * zd * c)) / Math.cos(o), y = Math.asin(Math.sin(o) / dp), T = ie(180 * h / Math.PI, -180, 180), k = ie(180 * y / Math.PI, -Cn, Cn);
            return new qi(T, k);
          }
        }
        class L1 extends vh {
          constructor(e) {
            super(e), this.wrap = !0, this.supportsWorldCopies = !0;
          }
          project(e, i) {
            return { x: 0.5 + e / 360, y: 0.5 - i / 360, z: 0 };
          }
          unproject(e, i) {
            const o = 360 * (e - 0.5), c = ie(360 * (0.5 - i), -Cn, Cn);
            return new qi(o, c);
          }
        }
        const Zf = Math.PI / 2;
        function pp(a) {
          return Math.tan((Zf + a) / 2);
        }
        class D1 extends vh {
          constructor(e) {
            super(e), this.center = e.center || [0, 30];
            const [i, o] = this.parallels = e.parallels || [30, 30];
            let c = Ae(i), s = Ae(o);
            this.southernCenter = c + s < 0, this.southernCenter && (c = -c, s = -s);
            const h = Math.cos(c), y = pp(c);
            this.n = c === s ? Math.sin(c) : Math.log(h / Math.cos(s)) / Math.log(pp(s) / y), this.f = h * Math.pow(pp(c), this.n) / this.n;
          }
          project(e, i) {
            i = Ae(i), this.southernCenter && (i = -i), e = Ae(e - this.center[0]);
            const o = 1e-6, { n: c, f: s } = this;
            s > 0 ? i < -Zf + o && (i = -Zf + o) : i > Zf - o && (i = Zf - o);
            const h = s / Math.pow(pp(i), c);
            let y = h * Math.sin(c * e), T = s - h * Math.cos(c * e);
            return y = 0.5 * (y / Math.PI + 0.5), T = 0.5 * (T / Math.PI + 0.5), { x: y, y: this.southernCenter ? T : 1 - T, z: 0 };
          }
          unproject(e, i) {
            e = (2 * e - 0.5) * Math.PI, this.southernCenter && (i = 1 - i), i = (2 * (1 - i) - 0.5) * Math.PI;
            const { n: o, f: c } = this, s = c - i, h = Math.sign(s), y = Math.sign(o) * Math.sqrt(e * e + s * s);
            let T = Math.atan2(e, Math.abs(s)) * h;
            s * o < 0 && (T -= Math.PI * Math.sign(e) * h);
            const k = ie(_e(T / o) + this.center[0], -180, 180), g = ie(_e(2 * Math.atan(Math.pow(c / y, 1 / o)) - Zf), -Cn, Cn);
            return new qi(k, this.southernCenter ? -g : g);
          }
        }
        class a0 extends vh {
          constructor(e) {
            super(e), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
          }
          project(e, i) {
            return { x: ls(e), y: oo(i), z: 0 };
          }
          unproject(e, i) {
            const o = so(e), c = ci(i);
            return new qi(o, c);
          }
        }
        const o0 = Ae(Cn);
        class k1 extends vh {
          project(e, i) {
            const o = (i = Ae(i)) * i, c = o * o;
            return { x: 0.5 * ((e = Ae(e)) * (0.8707 - 0.131979 * o + c * (c * (3971e-6 * o - 1529e-6 * c) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (i * (1.007226 + o * (0.015085 + c * (0.028874 * o - 0.044475 - 5916e-6 * c))) / Math.PI + 1), z: 0 };
          }
          unproject(e, i) {
            e = (2 * e - 0.5) * Math.PI;
            let o = i = (2 * (1 - i) - 1) * Math.PI, c = 25, s = 0, h = o * o;
            do {
              h = o * o;
              const k = h * h;
              s = (o * (1.007226 + h * (0.015085 + k * (0.028874 * h - 0.044475 - 5916e-6 * k))) - i) / (1.007226 + h * (0.045255 + k * (0.259866 * h - 0.311325 - 5916e-6 * 11 * k))), o = ie(o - s, -o0, o0);
            } while (Math.abs(s) > 1e-6 && --c > 0);
            h = o * o;
            const y = ie(_e(e / (0.8707 + h * (h * (h * h * h * (3971e-6 - 1529e-6 * h) - 0.013791) - 0.131979))), -180, 180), T = _e(o);
            return new qi(y, T);
          }
        }
        const s0 = Ae(Cn);
        class z1 extends vh {
          project(e, i) {
            i = Ae(i), e = Ae(e);
            const o = Math.cos(i), c = 2 / Math.PI, s = Math.acos(o * Math.cos(e / 2)), h = Math.sin(s) / s, y = 0.5 * (e * c + 2 * o * Math.sin(e / 2) / h) || 0, T = 0.5 * (i + Math.sin(i) / h) || 0;
            return { x: 0.5 * (y / Math.PI + 0.5), y: 1 - 0.5 * (T / Math.PI + 1), z: 0 };
          }
          unproject(e, i) {
            let o = e = (2 * e - 0.5) * Math.PI, c = i = (2 * (1 - i) - 1) * Math.PI, s = 25;
            const h = 1e-6;
            let y = 0, T = 0;
            do {
              const k = Math.cos(c), g = Math.sin(c), A = 2 * g * k, D = g * g, S = k * k, R = Math.cos(o / 2), j = Math.sin(o / 2), J = 2 * R * j, ne = j * j, me = 1 - S * R * R, ge = me ? 1 / me : 0, ue = me ? Math.acos(k * R) * Math.sqrt(1 / me) : 0, Se = 0.5 * (2 * ue * k * j + 2 * o / Math.PI) - e, ke = 0.5 * (ue * g + c) - i, He = 0.5 * ge * (S * ne + ue * k * R * D) + 1 / Math.PI, at = ge * (J * A / 4 - ue * g * j), nt = 0.125 * ge * (A * j - ue * g * S * J), tt = 0.5 * ge * (D * R + ue * ne * k) + 0.5, Et = at * nt - tt * He;
              y = (ke * at - Se * tt) / Et, T = (Se * nt - ke * He) / Et, o = ie(o - y, -Math.PI, Math.PI), c = ie(c - T, -s0, s0);
            } while ((Math.abs(y) > h || Math.abs(T) > h) && --s > 0);
            return new qi(_e(o), _e(c));
          }
        }
        class l0 extends vh {
          constructor(e) {
            super(e), this.center = e.center || [0, 0], this.parallels = e.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(Ae(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
          }
          project(e, i) {
            const { scale: o, cosPhi: c } = this;
            return { x: Ae(e) * c * o + 0.5, y: -Math.sin(Ae(i)) / c * o + 0.5, z: 0 };
          }
          unproject(e, i) {
            const { scale: o, cosPhi: c } = this, s = -(i - 0.5) / o, h = ie(_e((e - 0.5) / o) / c, -180, 180), y = Math.asin(ie(s * c, -1, 1)), T = ie(_e(y), -Cn, Cn);
            return new qi(h, T);
          }
        }
        class O1 extends a0 {
          constructor(e) {
            super(e), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
          }
          projectTilePoint(e, i, o) {
            const c = ln(e, i, o), s = ia(Zn(o));
            return Oe.vec3.transformMat4(c, c, s), { x: c[0], y: c[1], z: c[2] };
          }
          locationPoint(e, i) {
            const o = $l(i.lat, i.lng), c = Oe.vec3.normalize([], o), s = e.elevation ? e.elevation.getAtPointOrZero(e.locationCoordinate(i), e._centerAltitude) : e._centerAltitude, h = xn(1, 0) * Br * s;
            Oe.vec3.scaleAndAdd(o, o, c, h);
            const y = Oe.mat4.identity(new Float64Array(16));
            return Oe.mat4.multiply(y, e.pixelMatrix, e.globeMatrix), Oe.vec3.transformMat4(o, o, y), new Ye(o[0], o[1]);
          }
          pixelsPerMeter(e, i) {
            return xn(1, 0) * i;
          }
          pixelSpaceConversion(e, i, o) {
            const c = xn(1, e) * i, s = li(xn(1, 45) * i, c, o);
            return this.pixelsPerMeter(e, i) / s;
          }
          createTileMatrix(e, i, o) {
            const c = fn(Zn(o.canonical));
            return Oe.mat4.multiply(new Float64Array(16), e.globeMatrix, c);
          }
          createInversionMatrix(e, i) {
            const { center: o } = e, c = ia(Zn(i));
            return Oe.mat4.rotateY(c, c, Ae(o.lng)), Oe.mat4.rotateX(c, c, Ae(o.lat)), Oe.mat4.scale(c, c, [e._pixelsPerMercatorPixel, e._pixelsPerMercatorPixel, 1]), Float32Array.from(c);
          }
          pointCoordinate(e, i, o, c) {
            return Qi(e, i, o, !0) || new n(0, 0);
          }
          pointCoordinate3D(e, i, o) {
            const c = this.pointCoordinate(e, i, o, 0);
            return [c.x, c.y, c.z];
          }
          isPointAboveHorizon(e, i) {
            return !Qi(e, i.x, i.y, !1);
          }
          farthestPixelDistance(e) {
            const i = function(c, s) {
              const h = c.cameraToCenterDistance, y = c._centerAltitude * s, T = c._camera, k = c._camera.forward(), g = Oe.vec3.add([], Oe.vec3.scale([], k, -h), [0, 0, y]), A = c.worldSize / (2 * Math.PI), D = [0, 0, -A], S = c.width / c.height, R = Math.tan(c.fovAboveCenter), j = Oe.vec3.scale([], T.up(), R), J = Oe.vec3.scale([], T.right(), R * S), ne = Oe.vec3.normalize([], Oe.vec3.add([], Oe.vec3.add([], k, j), J)), me = [];
              let ge;
              if (new yi(g, ne).closestPointOnSphere(D, A, me)) {
                const ue = Oe.vec3.add([], me, D), Se = Oe.vec3.sub([], ue, g);
                ge = Math.cos(c.fovAboveCenter) * Oe.vec3.length(Se);
              } else {
                const ue = Oe.vec3.sub([], g, D), Se = Oe.vec3.sub([], D, g);
                Oe.vec3.normalize(Se, Se);
                const ke = Oe.vec3.length(ue) - A;
                ge = Math.sqrt(ke * (ke + 2 * A));
                const He = Math.acos(ge / (A + ke)) - Math.acos(Oe.vec3.dot(k, Se));
                ge *= Math.cos(He);
              }
              return 1.01 * ge;
            }(e, this.pixelsPerMeter(e.center.lat, e.worldSize)), o = Wa(e.zoom);
            if (o > 0) {
              const c = i0(e, xn(1, e.center.lat) * e.worldSize), s = e.worldSize / (2 * Math.PI), h = Math.max(e.width, e.height) / e.worldSize * Math.PI;
              return li(i, c + s * (1 - Math.cos(h)), Math.pow(o, 10));
            }
            return i;
          }
          upVector(e, i, o) {
            return ln(i, o, e, 1);
          }
          upVectorScale(e) {
            return { metersToTile: Fi(Vi(Zn(e))) };
          }
        }
        function u0(a) {
          const e = a.parallels, i = !!e && Math.abs(e[0] + e[1]) < 0.01;
          switch (a.name) {
            case "mercator":
              return new a0(a);
            case "equirectangular":
              return new L1(a);
            case "naturalEarth":
              return new k1(a);
            case "equalEarth":
              return new R1(a);
            case "winkelTripel":
              return new z1(a);
            case "albers":
              return i ? new l0(a) : new P1(a);
            case "lambertConformalConic":
              return i ? new l0(a) : new D1(a);
            case "globe":
              return new O1(a);
          }
          throw new Error(`Invalid projection name: ${a.name}`);
        }
        const B1 = jf.VectorTileFeature.types, F1 = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function mp(a, e, i, o, c, s, h, y, T, k, g, A, D) {
          const S = y ? Math.min(yh, Math.round(y[0])) : 0, R = y ? Math.min(yh, Math.round(y[1])) : 0;
          a.emplaceBack(e, i, Math.round(32 * o), Math.round(32 * c), s, h, (S << 1) + (T ? 1 : 0), R, 16 * k, 16 * g, 256 * A, 256 * D);
        }
        function _p(a, e, i) {
          a.emplaceBack(e, i);
        }
        function gp(a, e, i, o, c, s, h) {
          a.emplaceBack(e, i, o, c, s, h);
        }
        function yp(a, e, i, o, c) {
          a.emplaceBack(e, i, o, c), a.emplaceBack(e, i, o, c), a.emplaceBack(e, i, o, c), a.emplaceBack(e, i, o, c);
        }
        function N1(a) {
          for (const e of a.sections) if (Xc(e.text)) return !0;
          return !1;
        }
        class bm {
          constructor(e) {
            this.layoutVertexArray = new dc(), this.indexArray = new ha(), this.programConfigurations = e, this.segments = new Nn(), this.dynamicLayoutVertexArray = new Is(), this.opacityVertexArray = new Lo(), this.placedSymbolArray = new $h(), this.iconTransitioningVertexArray = new ga(), this.globeExtVertexArray = new pc(), this.zOffsetVertexArray = new Tu();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0 && this.iconTransitioningVertexArray.length === 0;
          }
          upload(e, i, o, c, s) {
            this.isEmpty() || (o && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, r1.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, i), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, n1.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, F1, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = e.createVertexBuffer(this.iconTransitioningVertexArray, o1.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, i1.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || s) && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, a1.members, !0)), this.opacityVertexBuffer.itemSize = 1), (o || c) && this.programConfigurations.upload(e));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
          }
        }
        Gr(bm, "SymbolBuffers");
        class wm {
          constructor(e, i, o) {
            this.layoutVertexArray = new e(), this.layoutAttributes = i, this.indexArray = new o(), this.segments = new Nn(), this.collisionVertexArray = new rh(), this.collisionVertexArrayExt = new Is();
          }
          upload(e) {
            this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, s1.members, !0), this.collisionVertexBufferExt = e.createVertexBuffer(this.collisionVertexArrayExt, l1.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
          }
        }
        Gr(wm, "CollisionBuffers");
        class vp {
          constructor(e) {
            this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.lut = e.lut, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((h) => h.fqid), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Oe.mat4.identity([]), this.placementViewportMatrix = Oe.mat4.identity([]);
            const i = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = hm(this.zoom, i["text-size"]), this.iconSizeData = hm(this.zoom, i["icon-size"]);
            const o = this.layers[0].layout, c = o.get("symbol-sort-key"), s = o.get("symbol-z-order");
            this.canOverlap = o.get("text-allow-overlap") || o.get("icon-allow-overlap") || o.get("text-ignore-placement") || o.get("icon-ignore-placement"), this.sortFeaturesByKey = s !== "viewport-y" && c.constantOr(1) !== void 0, this.sortFeaturesByY = (s === "viewport-y" || s === "auto" && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = o.get("text-writing-mode").map((h) => ks[h]), this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id), this.sourceID = e.sourceID, this.projection = e.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = o.get("symbol-z-elevate"), this.activeReplacements = [], this.replacementUpdateTime = 0;
          }
          createArrays() {
            this.text = new bm(new Ls(this.layers, { zoom: this.zoom, lut: this.lut }, (e) => e.startsWith("text") || e.startsWith("symbol"))), this.icon = new bm(new Ls(this.layers, { zoom: this.zoom, lut: this.lut }, (e) => e.startsWith("icon") || e.startsWith("symbol"))), this.glyphOffsetArray = new Cf(), this.lineVertexArray = new Kh(), this.symbolInstances = new Yh();
          }
          calculateGlyphDependencies(e, i, o, c, s) {
            for (const h of e) {
              const y = h.codePointAt(0);
              if (y === void 0) break;
              if (i[y] = !0, c && s && y <= 65535) {
                const T = Td[h];
                T && (i[T.charCodeAt(0)] = !0);
              }
            }
          }
          updateFootprints(e, i) {
          }
          updateReplacement(e, i) {
            if (i.updateTime === this.replacementUpdateTime) return !1;
            this.replacementUpdateTime = i.updateTime;
            const o = i.getReplacementRegionsForTile(e.toUnwrapped(), !0);
            return !im(this.activeReplacements, o) && (this.activeReplacements = o, !0);
          }
          populate(e, i, o, c) {
            const s = this.layers[0], h = s.layout, y = this.projection.name === "globe", T = h.get("text-font"), k = h.get("text-field"), g = h.get("icon-image"), [A, D] = h.get("icon-size-scale-range"), S = ie(i.scaleFactor || 1, A, D), R = (k.value.kind !== "constant" || k.value.value instanceof pa && !k.value.value.isEmpty() || k.value.value.toString().length > 0) && (T.value.kind !== "constant" || T.value.value.length > 0), j = g.value.kind !== "constant" || !!g.value.value || Object.keys(g.parameters).length > 0, J = h.get("symbol-sort-key");
            if (this.features = [], !R && !j) return;
            const ne = i.iconDependencies, me = i.glyphDependencies, ge = i.availableImages, ue = new sn(this.zoom);
            for (const { feature: Se, id: ke, index: He, sourceLayerIndex: at } of e) {
              const nt = s._featureFilter.needGeometry, tt = ae(Se, nt);
              if (!s._featureFilter.filter(ue, tt, o)) continue;
              if (nt || (tt.geometry = K(Se, o, c)), y && Se.type !== 1 && o.z <= 5) {
                const It = tt.geometry, zt = 0.98078528056, Ft = (qt, Ot) => {
                  const cr = ln(qt.x, qt.y, o, 1), yr = ln(Ot.x, Ot.y, o, 1);
                  return Oe.vec3.dot(cr, yr) < zt;
                };
                for (let qt = 0; qt < It.length; qt++) It[qt] = v(It[qt], Ft);
              }
              let Et, lt;
              if (R) {
                const It = s.getValueAndResolveTokens("text-field", tt, o, ge), zt = pa.factory(It);
                N1(zt) && (this.hasRTLText = !0), (!this.hasRTLText || Bl() === "unavailable" || this.hasRTLText && to.isParsed()) && (Et = h1(zt, s, tt));
              }
              if (j) {
                const It = s.getValueAndResolveTokens("icon-image", tt, o, ge);
                lt = It instanceof ma ? It : ma.build(It);
              }
              if (!Et && !lt) continue;
              const St = this.sortFeaturesByKey ? J.evaluate(tt, {}, o) : void 0, Lt = { id: ke, text: Et, icon: lt, index: He, sourceLayerIndex: at, geometry: tt.geometry, properties: Se.properties, type: B1[Se.type], sortKey: St };
              if (this.features.push(Lt), lt) {
                const It = cm(this.iconSizeData, this.layers[0]._unevaluatedLayout._values["icon-size"], o, this.zoom, Lt) * S * this.pixelRatio, zt = lt.getPrimary().scaleSelf(It);
                if (ne[zt.id] = ne[zt.id] || [], ne[zt.id].push(zt), lt.nameSecondary) {
                  const Ft = lt.getSecondary().scaleSelf(It);
                  ne[Ft.id] = ne[Ft.id] || [], ne[Ft.id].push(Ft);
                }
              }
              if (Et) {
                const It = T.evaluate(tt, {}, o).join(","), zt = h.get("text-rotation-alignment") === "map" && h.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(ks.vertical) >= 0;
                for (const Ft of Et.sections) if (Ft.image) {
                  const qt = Ft.image.getPrimary().scaleSelf(this.pixelRatio);
                  ne[qt.id] = ne[qt.id] || [], ne[qt.id].push(qt);
                } else {
                  const qt = uc(Et.toString()), Ot = Ft.fontStack || It, cr = me[Ot] = me[Ot] || {};
                  this.calculateGlyphDependencies(Ft.text, cr, zt, this.allowVerticalPlacement, qt);
                }
              }
            }
            h.get("symbol-placement") === "line" && (this.features = function(Se) {
              const ke = {}, He = {}, at = [];
              let nt = 0;
              function tt(Lt) {
                at.push(Se[Lt]), nt++;
              }
              function Et(Lt, It, zt) {
                const Ft = He[Lt];
                return delete He[Lt], He[It] = Ft, at[Ft].geometry[0].pop(), at[Ft].geometry[0] = at[Ft].geometry[0].concat(zt[0]), Ft;
              }
              function lt(Lt, It, zt) {
                const Ft = ke[It];
                return delete ke[It], ke[Lt] = Ft, at[Ft].geometry[0].shift(), at[Ft].geometry[0] = zt[0].concat(at[Ft].geometry[0]), Ft;
              }
              function St(Lt, It, zt) {
                const Ft = zt ? It[0][It[0].length - 1] : It[0][0];
                return `${Lt}:${Ft.x}:${Ft.y}`;
              }
              for (let Lt = 0; Lt < Se.length; Lt++) {
                const It = Se[Lt], zt = It.geometry, Ft = It.text ? It.text.toString() : null;
                if (!Ft) {
                  tt(Lt);
                  continue;
                }
                const qt = St(Ft, zt), Ot = St(Ft, zt, !0);
                if (qt in He && Ot in ke && He[qt] !== ke[Ot]) {
                  const cr = lt(qt, Ot, zt), yr = Et(qt, Ot, at[cr].geometry);
                  delete ke[qt], delete He[Ot], He[St(Ft, at[yr].geometry, !0)] = yr, at[cr].geometry = null;
                } else qt in He ? Et(qt, Ot, zt) : Ot in ke ? lt(qt, Ot, zt) : (tt(Lt), ke[qt] = nt - 1, He[Ot] = nt - 1);
              }
              return at.filter((Lt) => Lt.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((Se, ke) => Se.sortKey - ke.sortKey);
          }
          update(e, i, o, c, s, h, y) {
            this.text.programConfigurations.updatePaintArrays(e, i, s, o, c, h, y), this.icon.programConfigurations.updatePaintArrays(e, i, s, o, c, h, y);
          }
          updateZOffset() {
            const e = (s, h, y) => {
              o += h, o > s.length && s.resize(o);
              for (let T = -h; T < 0; T++) s.emplace(T + o, y);
            }, i = (s, h, y) => {
              c += h, c > s.length && s.resize(c);
              for (let T = -h; T < 0; T++) s.emplace(T + c, y);
            };
            if (!this.zOffsetBuffersNeedUpload) return;
            this.zOffsetBuffersNeedUpload = !1;
            let o = 0, c = 0;
            for (let s = 0; s < this.symbolInstances.length; s++) {
              const h = this.symbolInstances.get(s), { numHorizontalGlyphVertices: y, numVerticalGlyphVertices: T, numIconVertices: k } = h, g = h.zOffset, A = k > 0;
              if ((y > 0 || T > 0) && (e(this.text.zOffsetVertexArray, y, g), e(this.text.zOffsetVertexArray, T, g)), A) {
                const { placedIconSymbolIndex: D, verticalPlacedIconSymbolIndex: S } = h;
                D >= 0 && i(this.icon.zOffsetVertexArray, k, g), S >= 0 && i(this.icon.zOffsetVertexArray, h.numVerticalIconVertices, g);
              }
            }
            this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(e) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          getProjection() {
            return this.projectionInstance || (this.projectionInstance = u0(this.projection)), this.projectionInstance;
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(e, i) {
            const o = this.lineVertexArray.length;
            if (e.segment !== void 0) for (const { x: c, y: s } of i) this.lineVertexArray.emplaceBack(c, s);
            return { lineStartIndex: o, lineLength: this.lineVertexArray.length - o };
          }
          addSymbols(e, i, o, c, s, h, y, T, k, g, A, D, S, R, j, J) {
            const ne = e.indexArray, me = e.layoutVertexArray, ge = e.globeExtVertexArray, ue = e.segments.prepareSegment(4 * i.length, me, ne, this.canOverlap ? h.sortKey : void 0), Se = this.glyphOffsetArray.length, ke = ue.vertexLength, He = this.allowVerticalPlacement && y === ks.vertical ? Math.PI / 2 : 0, at = h.text && h.text.sections;
            for (let tt = 0; tt < i.length; tt++) {
              const { tl: Et, tr: lt, bl: St, br: Lt, texPrimary: It, texSecondary: zt, pixelOffsetTL: Ft, pixelOffsetBR: qt, minFontScaleX: Ot, minFontScaleY: cr, glyphOffset: yr, isSDF: ur, sectionIndex: jr } = i[tt], zr = ue.vertexLength, Ar = yr[1];
              if (mp(me, k.x, k.y, Et.x, Ar + Et.y, It.x, It.y, o, ur, Ft.x, Ft.y, Ot, cr), mp(me, k.x, k.y, lt.x, Ar + lt.y, It.x + It.w, It.y, o, ur, qt.x, Ft.y, Ot, cr), mp(me, k.x, k.y, St.x, Ar + St.y, It.x, It.y + It.h, o, ur, Ft.x, qt.y, Ot, cr), mp(me, k.x, k.y, Lt.x, Ar + Lt.y, It.x + It.w, It.y + It.h, o, ur, qt.x, qt.y, Ot, cr), T) {
                const { x: vr, y: ti, z: Wr } = T.anchor, [$r, bi, Ci] = T.up;
                gp(ge, vr, ti, Wr, $r, bi, Ci), gp(ge, vr, ti, Wr, $r, bi, Ci), gp(ge, vr, ti, Wr, $r, bi, Ci), gp(ge, vr, ti, Wr, $r, bi, Ci), yp(e.dynamicLayoutVertexArray, vr, ti, Wr, He);
              } else yp(e.dynamicLayoutVertexArray, k.x, k.y, k.z, He);
              if (J) {
                const vr = zt || It;
                _p(e.iconTransitioningVertexArray, vr.x, vr.y), _p(e.iconTransitioningVertexArray, vr.x + vr.w, vr.y), _p(e.iconTransitioningVertexArray, vr.x, vr.y + vr.h), _p(e.iconTransitioningVertexArray, vr.x + vr.w, vr.y + vr.h);
              }
              ne.emplaceBack(zr, zr + 1, zr + 2), ne.emplaceBack(zr + 1, zr + 2, zr + 3), ue.vertexLength += 4, ue.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(yr[0]), tt !== i.length - 1 && jr === i[tt + 1].sectionIndex || e.programConfigurations.populatePaintArrays(me.length, h, h.index, {}, S, R, j, at && at[jr]);
            }
            const nt = T ? T.anchor : k;
            e.placedSymbolArray.emplaceBack(nt.x, nt.y, nt.z, k.x, k.y, Se, this.glyphOffsetArray.length - Se, ke, g, A, k.segment, o ? o[0] : 0, o ? o[1] : 0, c[0], c[1], y, 0, !1, 0, D, 0);
          }
          _commitLayoutVertex(e, i, o, c, s, h, y) {
            e.emplaceBack(i, o, c, s, h, Math.round(y.x), Math.round(y.y));
          }
          _addCollisionDebugVertices(e, i, o, c, s, h, y) {
            const T = o.segments.prepareSegment(4, o.layoutVertexArray, o.indexArray), k = T.vertexLength, g = y.tileAnchorX, A = y.tileAnchorY;
            for (let S = 0; S < 4; S++) o.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
            this._commitDebugCollisionVertexUpdate(o.collisionVertexArrayExt, i, e.padding, y.zOffset), this._commitLayoutVertex(o.layoutVertexArray, c, s, h, g, A, new Ye(e.x1, e.y1)), this._commitLayoutVertex(o.layoutVertexArray, c, s, h, g, A, new Ye(e.x2, e.y1)), this._commitLayoutVertex(o.layoutVertexArray, c, s, h, g, A, new Ye(e.x2, e.y2)), this._commitLayoutVertex(o.layoutVertexArray, c, s, h, g, A, new Ye(e.x1, e.y2)), T.vertexLength += 4;
            const D = o.indexArray;
            D.emplaceBack(k, k + 1), D.emplaceBack(k + 1, k + 2), D.emplaceBack(k + 2, k + 3), D.emplaceBack(k + 3, k), T.primitiveLength += 4;
          }
          _addTextDebugCollisionBoxes(e, i, o, c, s, h) {
            for (let y = c; y < s; y++) {
              const T = o.get(y), k = this.getSymbolInstanceTextSize(e, h, i, y);
              this._addCollisionDebugVertices(T, k, this.textCollisionBox, T.projectedAnchorX, T.projectedAnchorY, T.projectedAnchorZ, h);
            }
          }
          _addIconDebugCollisionBoxes(e, i, o, c, s, h) {
            for (let y = c; y < s; y++) {
              const T = o.get(y), k = this.getSymbolInstanceIconSize(e, i, h.placedIconSymbolIndex);
              this._addCollisionDebugVertices(T, k, this.iconCollisionBox, T.projectedAnchorX, T.projectedAnchorY, T.projectedAnchorZ, h);
            }
          }
          generateCollisionDebugBuffers(e, i, o) {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new wm(Su, Pg.members, ga), this.iconCollisionBox = new wm(Su, Pg.members, ga);
            const c = Vf(this.iconSizeData, e), s = Vf(this.textSizeData, e, o);
            for (let h = 0; h < this.symbolInstances.length; h++) {
              const y = this.symbolInstances.get(h);
              this._addTextDebugCollisionBoxes(s, e, i, y.textBoxStartIndex, y.textBoxEndIndex, y), this._addTextDebugCollisionBoxes(s, e, i, y.verticalTextBoxStartIndex, y.verticalTextBoxEndIndex, y), this._addIconDebugCollisionBoxes(c, e, i, y.iconBoxStartIndex, y.iconBoxEndIndex, y), this._addIconDebugCollisionBoxes(c, e, i, y.verticalIconBoxStartIndex, y.verticalIconBoxEndIndex, y);
            }
          }
          getSymbolInstanceTextSize(e, i, o, c) {
            const s = this.text.placedSymbolArray.get(i.rightJustifiedTextSymbolIndex >= 0 ? i.rightJustifiedTextSymbolIndex : i.centerJustifiedTextSymbolIndex >= 0 ? i.centerJustifiedTextSymbolIndex : i.leftJustifiedTextSymbolIndex >= 0 ? i.leftJustifiedTextSymbolIndex : i.verticalPlacedTextSymbolIndex >= 0 ? i.verticalPlacedTextSymbolIndex : c), h = op(this.textSizeData, e, s) / qa;
            return this.tilePixelRatio * h;
          }
          getSymbolInstanceIconSize(e, i, o) {
            const c = this.icon.placedSymbolArray.get(o), s = op(this.iconSizeData, e, c);
            return this.tilePixelRatio * s;
          }
          _commitDebugCollisionVertexUpdate(e, i, o, c) {
            e.emplaceBack(i, -o, -o, c), e.emplaceBack(i, o, -o, c), e.emplaceBack(i, o, o, c), e.emplaceBack(i, -o, o, c);
          }
          _updateTextDebugCollisionBoxes(e, i, o, c, s, h, y) {
            for (let T = c; T < s; T++) {
              const k = o.get(T), g = this.getSymbolInstanceTextSize(e, h, i, T);
              this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, g, k.padding, h.zOffset);
            }
          }
          _updateIconDebugCollisionBoxes(e, i, o, c, s, h, y) {
            for (let T = c; T < s; T++) {
              const k = o.get(T), g = this.getSymbolInstanceIconSize(e, i, h.placedIconSymbolIndex);
              this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, g, k.padding, h.zOffset);
            }
          }
          updateCollisionDebugBuffers(e, i, o, c) {
            if (!this.hasDebugData()) return;
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
            const s = Vf(this.iconSizeData, e, c), h = Vf(this.textSizeData, e, o);
            for (let y = 0; y < this.symbolInstances.length; y++) {
              const T = this.symbolInstances.get(y);
              this._updateTextDebugCollisionBoxes(h, e, i, T.textBoxStartIndex, T.textBoxEndIndex, T, o), this._updateTextDebugCollisionBoxes(h, e, i, T.verticalTextBoxStartIndex, T.verticalTextBoxEndIndex, T, o), this._updateIconDebugCollisionBoxes(s, e, i, T.iconBoxStartIndex, T.iconBoxEndIndex, T, c), this._updateIconDebugCollisionBoxes(s, e, i, T.verticalIconBoxStartIndex, T.verticalIconBoxEndIndex, T, c);
            }
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
          }
          _deserializeCollisionBoxesForSymbol(e, i, o, c, s, h, y, T, k) {
            const g = {};
            if (i < o) {
              const { x1: A, y1: D, x2: S, y2: R, padding: j, projectedAnchorX: J, projectedAnchorY: ne, projectedAnchorZ: me, tileAnchorX: ge, tileAnchorY: ue, featureIndex: Se } = e.get(i);
              g.textBox = { x1: A, y1: D, x2: S, y2: R, padding: j, projectedAnchorX: J, projectedAnchorY: ne, projectedAnchorZ: me, tileAnchorX: ge, tileAnchorY: ue }, g.textFeatureIndex = Se;
            }
            if (c < s) {
              const { x1: A, y1: D, x2: S, y2: R, padding: j, projectedAnchorX: J, projectedAnchorY: ne, projectedAnchorZ: me, tileAnchorX: ge, tileAnchorY: ue, featureIndex: Se } = e.get(c);
              g.verticalTextBox = { x1: A, y1: D, x2: S, y2: R, padding: j, projectedAnchorX: J, projectedAnchorY: ne, projectedAnchorZ: me, tileAnchorX: ge, tileAnchorY: ue }, g.verticalTextFeatureIndex = Se;
            }
            if (h < y) {
              const { x1: A, y1: D, x2: S, y2: R, padding: j, projectedAnchorX: J, projectedAnchorY: ne, projectedAnchorZ: me, tileAnchorX: ge, tileAnchorY: ue, featureIndex: Se } = e.get(h);
              g.iconBox = { x1: A, y1: D, x2: S, y2: R, padding: j, projectedAnchorX: J, projectedAnchorY: ne, projectedAnchorZ: me, tileAnchorX: ge, tileAnchorY: ue }, g.iconFeatureIndex = Se;
            }
            if (T < k) {
              const { x1: A, y1: D, x2: S, y2: R, padding: j, projectedAnchorX: J, projectedAnchorY: ne, projectedAnchorZ: me, tileAnchorX: ge, tileAnchorY: ue, featureIndex: Se } = e.get(T);
              g.verticalIconBox = { x1: A, y1: D, x2: S, y2: R, padding: j, projectedAnchorX: J, projectedAnchorY: ne, projectedAnchorZ: me, tileAnchorX: ge, tileAnchorY: ue }, g.verticalIconFeatureIndex = Se;
            }
            return g;
          }
          deserializeCollisionBoxes(e) {
            this.collisionArrays = [];
            for (let i = 0; i < this.symbolInstances.length; i++) {
              const o = this.symbolInstances.get(i);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, o.textBoxStartIndex, o.textBoxEndIndex, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o.iconBoxStartIndex, o.iconBoxEndIndex, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          hasIconTextFit() {
            return this.hasAnyIconTextFit;
          }
          addIndicesForPlacedSymbol(e, i) {
            const o = e.placedSymbolArray.get(i), c = o.vertexStartIndex + 4 * o.numGlyphs;
            for (let s = o.vertexStartIndex; s < c; s += 4) e.indexArray.emplaceBack(s, s + 1, s + 2), e.indexArray.emplaceBack(s + 1, s + 2, s + 3);
          }
          getSortedSymbolIndexes(e) {
            if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const i = Math.sin(e), o = Math.cos(e), c = [], s = [], h = [];
            for (let y = 0; y < this.symbolInstances.length; ++y) {
              h.push(y);
              const T = this.symbolInstances.get(y);
              c.push(0 | Math.round(i * T.tileAnchorX + o * T.tileAnchorY)), s.push(T.featureIndex);
            }
            return h.sort((y, T) => c[y] - c[T] || s[T] - s[y]), h;
          }
          getSortedIndexesByZOffset() {
            if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
            if (!this.symbolInstanceIndexesSortedZOffset) {
              this.symbolInstanceIndexesSortedZOffset = [];
              for (let e = 0; e < this.symbolInstances.length; ++e) this.symbolInstanceIndexesSortedZOffset.push(e);
            }
            return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((e, i) => this.symbolInstances.get(i).zOffset - this.symbolInstances.get(e).zOffset);
          }
          addToSortKeyRanges(e, i) {
            const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            o && o.sortKey === i ? o.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: i, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
          }
          sortFeatures(e) {
            if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const i of this.symbolInstanceIndexes) {
                const o = this.symbolInstances.get(i);
                this.featureSortOrder.push(o.featureIndex);
                const { rightJustifiedTextSymbolIndex: c, centerJustifiedTextSymbolIndex: s, leftJustifiedTextSymbolIndex: h, verticalPlacedTextSymbolIndex: y, placedIconSymbolIndex: T, verticalPlacedIconSymbolIndex: k } = o;
                c >= 0 && this.addIndicesForPlacedSymbol(this.text, c), s >= 0 && s !== c && this.addIndicesForPlacedSymbol(this.text, s), h >= 0 && h !== s && h !== c && this.addIndicesForPlacedSymbol(this.text, h), y >= 0 && this.addIndicesForPlacedSymbol(this.text, y), T >= 0 && this.addIndicesForPlacedSymbol(this.icon, T), k >= 0 && this.addIndicesForPlacedSymbol(this.icon, k);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let c0, h0, Em;
        Gr(vp, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), vp.addDynamicAttributes = yp;
        class f0 {
          constructor(e) {
            this.type = e.property.overrides ? e.property.overrides.runtimeType : js, this.defaultValue = e;
          }
          evaluate(e) {
            if (e.formattedSection) {
              const i = this.defaultValue.property.overrides;
              if (i && i.hasOverride(e.formattedSection)) return i.getOverride(e.formattedSection);
            }
            return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(e) {
            this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        Gr(f0, "FormatSectionOverride", { omit: ["defaultValue"] });
        const Sm = () => Em || (Em = { layout: c0 || (c0 = new vn({ "symbol-placement": new Mr(Kt.layout_symbol["symbol-placement"]), "symbol-spacing": new Mr(Kt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Mr(Kt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Nr(Kt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Mr(Kt.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new Mr(Kt.layout_symbol["symbol-z-elevate"]), "symbol-elevation-reference": new Mr(Kt.layout_symbol["symbol-elevation-reference"]), "icon-allow-overlap": new Mr(Kt.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Mr(Kt.layout_symbol["icon-ignore-placement"]), "icon-optional": new Mr(Kt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Mr(Kt.layout_symbol["icon-rotation-alignment"]), "icon-size": new Nr(Kt.layout_symbol["icon-size"]), "icon-size-scale-range": new Mr(Kt.layout_symbol["icon-size-scale-range"]), "icon-text-fit": new Nr(Kt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Nr(Kt.layout_symbol["icon-text-fit-padding"]), "icon-image": new Nr(Kt.layout_symbol["icon-image"]), "icon-rotate": new Nr(Kt.layout_symbol["icon-rotate"]), "icon-padding": new Mr(Kt.layout_symbol["icon-padding"]), "icon-keep-upright": new Mr(Kt.layout_symbol["icon-keep-upright"]), "icon-offset": new Nr(Kt.layout_symbol["icon-offset"]), "icon-anchor": new Nr(Kt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Mr(Kt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Mr(Kt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Mr(Kt.layout_symbol["text-rotation-alignment"]), "text-field": new Nr(Kt.layout_symbol["text-field"]), "text-font": new Nr(Kt.layout_symbol["text-font"]), "text-size": new Nr(Kt.layout_symbol["text-size"]), "text-size-scale-range": new Mr(Kt.layout_symbol["text-size-scale-range"]), "text-max-width": new Nr(Kt.layout_symbol["text-max-width"]), "text-line-height": new Nr(Kt.layout_symbol["text-line-height"]), "text-letter-spacing": new Nr(Kt.layout_symbol["text-letter-spacing"]), "text-justify": new Nr(Kt.layout_symbol["text-justify"]), "text-radial-offset": new Nr(Kt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Mr(Kt.layout_symbol["text-variable-anchor"]), "text-anchor": new Nr(Kt.layout_symbol["text-anchor"]), "text-max-angle": new Mr(Kt.layout_symbol["text-max-angle"]), "text-writing-mode": new Mr(Kt.layout_symbol["text-writing-mode"]), "text-rotate": new Nr(Kt.layout_symbol["text-rotate"]), "text-padding": new Mr(Kt.layout_symbol["text-padding"]), "text-keep-upright": new Mr(Kt.layout_symbol["text-keep-upright"]), "text-transform": new Nr(Kt.layout_symbol["text-transform"]), "text-offset": new Nr(Kt.layout_symbol["text-offset"]), "text-allow-overlap": new Mr(Kt.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Mr(Kt.layout_symbol["text-ignore-placement"]), "text-optional": new Mr(Kt.layout_symbol["text-optional"]), visibility: new Mr(Kt.layout_symbol.visibility) })), paint: h0 || (h0 = new vn({ "icon-opacity": new Nr(Kt.paint_symbol["icon-opacity"]), "icon-occlusion-opacity": new Nr(Kt.paint_symbol["icon-occlusion-opacity"]), "icon-emissive-strength": new Nr(Kt.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new Nr(Kt.paint_symbol["text-emissive-strength"]), "icon-color": new Nr(Kt.paint_symbol["icon-color"]), "icon-halo-color": new Nr(Kt.paint_symbol["icon-halo-color"]), "icon-halo-width": new Nr(Kt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Nr(Kt.paint_symbol["icon-halo-blur"]), "icon-translate": new Mr(Kt.paint_symbol["icon-translate"]), "icon-translate-anchor": new Mr(Kt.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new Nr(Kt.paint_symbol["icon-image-cross-fade"]), "text-opacity": new Nr(Kt.paint_symbol["text-opacity"]), "text-occlusion-opacity": new Nr(Kt.paint_symbol["text-occlusion-opacity"]), "text-color": new Nr(Kt.paint_symbol["text-color"], { runtimeType: la, getOverride: (a) => a.textColor, hasOverride: (a) => !!a.textColor }), "text-halo-color": new Nr(Kt.paint_symbol["text-halo-color"]), "text-halo-width": new Nr(Kt.paint_symbol["text-halo-width"]), "text-halo-blur": new Nr(Kt.paint_symbol["text-halo-blur"]), "text-translate": new Mr(Kt.paint_symbol["text-translate"]), "text-translate-anchor": new Mr(Kt.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new Mr(Kt.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new Mr(Kt.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new Mr(Kt.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new Mr(Kt.paint_symbol["icon-color-brightness-max"]), "symbol-z-offset": new Nr(Kt.paint_symbol["symbol-z-offset"]), "icon-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "icon-halo-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "text-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "text-halo-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, Em);
        class xp extends rn {
          constructor(e, i, o, c) {
            super(e, Sm(), i, o, c), this._colorAdjustmentMatrix = Oe.mat4.identity([]), this.hasInitialOcclusionOpacityProperties = e.paint !== void 0 && ("icon-occlusion-opacity" in e.paint || "text-occlusion-opacity" in e.paint);
          }
          recalculate(e, i) {
            super.recalculate(e, i), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
            const o = this.layout.get("text-writing-mode");
            if (o) {
              const c = [];
              for (const s of o) c.indexOf(s) < 0 && c.push(s);
              this.layout._values["text-writing-mode"] = c;
            } else this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"];
            this._setPaintOverrides();
          }
          getColorAdjustmentMatrix(e, i, o, c) {
            return this._saturation === e && this._contrast === i && this._brightnessMin === o && this._brightnessMax === c || (this._colorAdjustmentMatrix = function(s, h, y, T) {
              s = we(s), h = er(h);
              const k = Oe.mat4.create(), g = s / 3, A = 1 - 2 * g, D = [A, g, g, 0, g, A, g, 0, g, g, A, 0, 0, 0, 0, 1], S = 0.5 - 0.5 * h, R = T - y;
              return Oe.mat4.multiply(k, [R, 0, 0, 0, 0, R, 0, 0, 0, 0, R, 0, y, y, y, 1], [h, 0, 0, 0, 0, h, 0, 0, 0, 0, h, 0, S, S, S, 1]), Oe.mat4.multiply(k, k, D), k;
            }(e, i, o, c), this._saturation = e, this._contrast = i, this._brightnessMin = o, this._brightnessMax = c), this._colorAdjustmentMatrix;
          }
          getValueAndResolveTokens(e, i, o, c) {
            const s = this.layout.get(e).evaluate(i, {}, o, c), h = this._unevaluatedLayout._values[e];
            return h.isDataDriven() || Ll(h.value) || !s ? s : function(y, T) {
              return T.replace(/{([^{}]+)}/g, (k, g) => g in y ? String(y[g]) : "");
            }(i.properties, s);
          }
          createBucket(e) {
            return new vp(e);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return !1;
          }
          _setPaintOverrides() {
            for (const e of Sm().paint.overridableProperties) {
              if (!xp.hasPaintOverride(this.layout, e)) continue;
              const i = this.paint.get(e), o = new f0(i), c = new Rl(o, i.property.specification, this.scope, this.options);
              let s = null;
              s = i.value.kind === "constant" || i.value.kind === "source" ? new Dl("source", c) : new kl("composite", c, i.value.zoomStops, i.value._interpolationType), this.paint._values[e] = new il(i.property, s, i.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(e, i, o) {
            return !(!this.layout || i.isDataDriven() || o.isDataDriven()) && xp.hasPaintOverride(this.layout, e);
          }
          static hasPaintOverride(e, i) {
            const o = e.get("text-field"), c = Sm().paint.properties[i];
            let s = !1;
            const h = (y) => {
              for (const T of y) if (c.overrides && c.overrides.hasOverride(T)) return void (s = !0);
            };
            if (o.value.kind === "constant" && o.value.value instanceof pa) h(o.value.value.sections);
            else if (o.value.kind === "source") {
              const y = (k) => {
                s || (k instanceof Wn && An(k.value) === Ya ? h(k.value.sections) : k instanceof gs ? h(k.sections) : k.eachChild(y));
              }, T = o.value;
              T._styleExpression && y(T._styleExpression.expression);
            }
            return s;
          }
          getProgramIds() {
            return ["symbol"];
          }
          getDefaultProgramParams(e, i, o) {
            return { config: new Rs(this, { zoom: i, lut: o }), overrideFog: !1 };
          }
        }
        let d0, p0, m0, _0;
        var Tm = Yi([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        function Mm(a) {
          switch (a) {
            case WebGL2RenderingContext.RGBA8:
              return WebGL2RenderingContext.RGBA;
            case WebGL2RenderingContext.DEPTH_COMPONENT16:
              return WebGL2RenderingContext.DEPTH_COMPONENT;
            case WebGL2RenderingContext.DEPTH24_STENCIL8:
              return WebGL2RenderingContext.DEPTH_STENCIL;
            case WebGL2RenderingContext.R8:
            case WebGL2RenderingContext.R32F:
              return WebGL2RenderingContext.RED;
          }
        }
        function Am(a) {
          switch (a) {
            case WebGL2RenderingContext.RGBA8:
              return WebGL2RenderingContext.UNSIGNED_BYTE;
            case WebGL2RenderingContext.DEPTH_COMPONENT16:
              return WebGL2RenderingContext.UNSIGNED_SHORT;
            case WebGL2RenderingContext.DEPTH24_STENCIL8:
              return WebGL2RenderingContext.UNSIGNED_INT_24_8;
            case WebGL2RenderingContext.R8:
              return WebGL2RenderingContext.UNSIGNED_BYTE;
            case WebGL2RenderingContext.R32F:
              return WebGL2RenderingContext.FLOAT;
          }
        }
        class Im {
          constructor(e, i, o, c) {
            this.context = e, this.format = o, this.useMipmap = c && c.useMipmap, this.texture = e.gl.createTexture(), this.update(i, { premultiply: c && c.premultiply });
          }
          update(e, i) {
            const o = e && e instanceof HTMLVideoElement && e.width === 0 ? e.videoWidth : e.width, c = e && e instanceof HTMLVideoElement && e.height === 0 ? e.videoHeight : e.height, { context: s } = this, { gl: h } = s, { x: y, y: T } = i && i.position ? i.position : { x: 0, y: 0 }, k = y + o, g = T + c;
            !this.size || this.size[0] === k && this.size[1] === g || (h.bindTexture(h.TEXTURE_2D, null), h.deleteTexture(this.texture), this.texture = h.createTexture(), this.size = null), h.bindTexture(h.TEXTURE_2D, this.texture), s.pixelStoreUnpackFlipY.set(!1), s.pixelStoreUnpack.set(1), s.pixelStoreUnpackPremultiplyAlpha.set(this.format === h.RGBA8 && (!i || i.premultiply !== !1));
            const A = e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ImageBitmap && e instanceof ImageBitmap;
            if (!this.size && k > 0 && g > 0) {
              const D = this.useMipmap ? Math.floor(Math.log2(Math.max(k, g))) + 1 : 1;
              h.texStorage2D(h.TEXTURE_2D, D, this.format, k, g), this.size = [k, g];
            }
            if (this.size) if (A) h.texSubImage2D(h.TEXTURE_2D, 0, y, T, Mm(this.format), Am(this.format), e);
            else {
              const D = e.data;
              D && h.texSubImage2D(h.TEXTURE_2D, 0, y, T, o, c, Mm(this.format), Am(this.format), D);
            }
            this.useMipmap && h.generateMipmap(h.TEXTURE_2D);
          }
          bind(e, i, o = !1) {
            const { context: c } = this, { gl: s } = c;
            s.bindTexture(s.TEXTURE_2D, this.texture), e !== this.minFilter && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, e), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, this.useMipmap && !o ? e === s.NEAREST ? s.NEAREST_MIPMAP_NEAREST : s.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), i !== this.wrapS && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, i), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, i), this.wrapS = i);
          }
          bindExtraParam(e, i, o, c) {
            const { context: s } = this, { gl: h } = s;
            h.bindTexture(h.TEXTURE_2D, this.texture), i !== this.magFilter && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, i), this.magFilter = i), e !== this.minFilter && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, this.useMipmap ? e === h.NEAREST ? h.NEAREST_MIPMAP_NEAREST : h.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), o !== this.wrapS && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, o), this.wrapS = o), c !== this.wrapT && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, c), this.wrapT = c);
          }
          destroy() {
            const { gl: e } = this.context;
            e.deleteTexture(this.texture), this.texture = null;
          }
        }
        class bp {
          constructor(e, i) {
            this.context = e, this.texture = i;
          }
          bind(e, i) {
            const { context: o } = this, { gl: c } = o;
            c.bindTexture(c.TEXTURE_2D, this.texture), e !== this.minFilter && (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, e), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, e), this.minFilter = e), i !== this.wrapS && (c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, i), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, i), this.wrapS = i);
          }
        }
        function wp(a, e, i, o, c, s, h, y) {
          const T = [a, e, 1, i, o, 1, c, s, 1], k = [h, y, 1], g = Oe.mat3.adjoint([], T), [A, D, S] = Oe.vec3.transformMat3(k, k, g);
          return Oe.mat3.multiply(T, T, [A, 0, 0, 0, D, 0, 0, 0, S]);
        }
        function g0(a, e, i, o, c, s, h, y) {
          const T = function(k, g, A, D, S, R, j, J) {
            const ne = wp(0, 0, 1, 0, 1, 1, 0, 1), me = wp(k, g, A, D, S, R, j, J), ge = Oe.mat3.adjoint([], ne);
            return Oe.mat3.multiply(me, me, ge);
          }(a, e, i, o, c, s, h, y);
          return [T[2] / T[8] / Br, T[5] / T[8] / Br];
        }
        function Ep(a) {
          return [a[0], Math.min(Math.max(a[1], -Cn), Cn)];
        }
        class y0 extends ds {
          constructor(e, i, o, c) {
            super(), this.id = e, this.dispatcher = o, this.coordinates = i.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(c), this.options = i, this._dirty = !1;
          }
          load(e, i) {
            if (this._loaded = i || !1, this.fire(new on("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url) return e && (this.coordinates = e), this._loaded = !0, void this._finishLoading();
            this._imageRequest = ou(this.map._requestManager.transformRequest(this.url, Bi.Image), (o, c) => {
              this._imageRequest = null, this._loaded = !0, o ? this.fire(new Gu(o)) : c && (this.image = c instanceof HTMLImageElement ? ht.getImageData(c) : c, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, e && (this.coordinates = e), this._finishLoading());
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e.url, this.load(e.coordinates, this._loaded), this) : this;
          }
          setTexture(e) {
            if (!(e.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
            return this.texture = new bp(this.map.painter.context, e.handle), this.width = e.dimensions[0], this.height = e.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new on("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove(e) {
            this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof bp || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
          }
          setCoordinates(e) {
            if (this.coordinates = e, this._boundsArray = void 0, this._unsupportedCoords = !1, !e.length) return this;
            this.onNorthPole = !1, this.onSouthPole = !1;
            let i = e[0][1], o = e[0][1];
            for (const s of e) s[1] > o && (o = s[1]), s[1] < i && (i = s[1]);
            const c = (o + i) / 2;
            if (c > Cn ? this.onNorthPole = !0 : c < -Cn && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {
              const s = e.map(n.fromLngLat);
              this.tileID = function(h) {
                let y = 1 / 0, T = 1 / 0, k = -1 / 0, g = -1 / 0;
                for (const j of h) y = Math.min(y, j.x), T = Math.min(T, j.y), k = Math.max(k, j.x), g = Math.max(g, j.y);
                const A = Math.max(k - y, g - T), D = Math.max(0, Math.floor(-Math.log(A) / Math.LN2)), S = Math.pow(2, D);
                let R = Math.floor((y + k) / 2 * S);
                return R > 1 && (R -= 1), new mr(D, R, Math.floor((T + g) / 2 * S));
              }(s), this.minzoom = this.maxzoom = this.tileID.z;
            }
            return this.fire(new on("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          _clear() {
            this._boundsArray = void 0, this._unsupportedCoords = !1;
          }
          _prepareData(e) {
            for (const ne in this.tiles) {
              const me = this.tiles[ne];
              me.state !== "loaded" && (me.state = "loaded", me.texture = this.texture);
            }
            if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
            const i = Rd(new mr(0, 0, 0), this.map.transform.projection), o = [i.projection.project(this.coordinates[0][0], this.coordinates[0][1]), i.projection.project(this.coordinates[1][0], this.coordinates[1][1]), i.projection.project(this.coordinates[2][0], this.coordinates[2][1]), i.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
            if (!function(ne) {
              const me = ne[1].x - ne[0].x, ge = ne[1].y - ne[0].y, ue = ne[2].x - ne[1].x, Se = ne[2].y - ne[1].y, ke = ne[3].x - ne[2].x, He = ne[3].y - ne[2].y, at = ne[0].x - ne[3].x, nt = ne[0].y - ne[3].y, tt = me * Se - ue * ge, Et = ue * He - ke * Se, lt = ke * nt - at * He, St = at * ge - me * nt;
              return tt > 0 && Et > 0 && lt > 0 && St > 0 || tt < 0 && Et < 0 && lt < 0 && St < 0;
            }(o)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = !0);
            const c = Rd(this.tileID, this.map.transform.projection), [s, h, y, T] = this.coordinates.map((ne) => {
              const me = c.projection.project(ne[0], ne[1]);
              return n0(c, me)._round();
            });
            this.perspectiveTransform = g0(s.x, s.y, h.x, h.y, y.x, y.y, T.x, T.y);
            const k = this._boundsArray = new Dn();
            k.emplaceBack(s.x, s.y, 0, 0), k.emplaceBack(h.x, h.y, Br, 0), k.emplaceBack(T.x, T.y, 0, Br), k.emplaceBack(y.x, y.y, Br, Br), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = e.createVertexBuffer(k, Tm.members), this.boundsSegments = Nn.simpleSegment(0, 0, 4, 2);
            const g = [], A = [Ep((D = this.coordinates)[0]), Ep(D[1]), Ep(D[2]), Ep(D[3])];
            var D;
            const [S, R, j, J] = function(ne) {
              let me = ne[0][0], ge = me, ue = ne[0][1], Se = ue;
              for (let ke = 1; ke < ne.length; ke++) ne[ke][0] < me ? me = ne[ke][0] : ne[ke][0] > ge && (ge = ne[ke][0]), ne[ke][1] < ue ? ue = ne[ke][1] : ne[ke][1] > Se && (Se = ne[ke][1]);
              return [me, ue, ge - me, Se - ue];
            }(A);
            {
              const ne = new Dn(), [me, ge, ue, Se] = function(Ft) {
                let qt = Ft[0].x, Ot = qt, cr = Ft[0].y, yr = cr;
                for (let ur = 1; ur < Ft.length; ur++) Ft[ur].x < qt ? qt = Ft[ur].x : Ft[ur].x > Ot && (Ot = Ft[ur].x), Ft[ur].y < cr ? cr = Ft[ur].y : Ft[ur].y > yr && (yr = Ft[ur].y);
                return [qt, cr, Ot - qt, yr - cr];
              }(o), ke = (Ft) => [(Ft.x - me) / ue, (Ft.y - ge) / Se], [He, at, nt, tt] = o.map(ke), Et = function(Ft, qt, Ot, cr, yr, ur, jr, zr) {
                const Ar = wp(0, 0, 1, 0, 1, 1, 0, 1), vr = wp(Ft, qt, Ot, cr, yr, ur, jr, zr), ti = Oe.mat3.adjoint([], vr);
                return Oe.mat3.multiply(Ar, Ar, ti);
              }(He[0], He[1], at[0], at[1], nt[0], nt[1], tt[0], tt[1]);
              this.elevatedGlobePerspectiveTransform = g0(He[0], He[1], at[0], at[1], nt[0], nt[1], tt[0], tt[1]);
              const lt = (Ft, qt) => {
                g.push(Ft.lng);
                const Ot = Math.round((Ft.lng - S) / j * Br), cr = Math.round((Ft.lat - R) / J * Br), yr = ke(qt), ur = Oe.vec3.transformMat3([], [yr[0], yr[1], 1], Et), jr = Math.round(ur[0] / ur[2] * Br), zr = Math.round(ur[1] / ur[2] * Br);
                ne.emplaceBack(Ot, cr, jr, zr);
              }, St = o[3].x - o[0].x, Lt = o[3].y - o[0].y, It = o[2].x - o[1].x, zt = o[2].y - o[1].y;
              for (let Ft = 0; Ft < 65; Ft++) {
                const qt = Ft / 64, Ot = [o[0].x + qt * St, o[0].y + qt * Lt], cr = [o[1].x + qt * It, o[1].y + qt * zt], yr = cr[0] - Ot[0], ur = cr[1] - Ot[1];
                for (let jr = 0; jr < 65; jr++) {
                  const zr = jr / 64, Ar = { x: Ot[0] + yr * zr, y: Ot[1] + ur * zr, z: 0 };
                  lt(i.projection.unproject(Ar.x, Ar.y), Ar);
                }
              }
              this.elevatedGlobeVertexBuffer = e.createVertexBuffer(ne, Tm.members);
            }
            {
              this.maxLongitudeTriangleSize = 0;
              let ne = [], me = new ha();
              const ge = (ue, Se, ke) => {
                me.emplaceBack(ue, Se, ke);
                const He = g[ue], at = g[Se], nt = g[ke], tt = Math.min(Math.min(He, at), nt), Et = Math.max(Math.max(He, at), nt) - tt;
                Et > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = Et), ne.push(tt + Et / 2);
              };
              for (let ue = 0; ue < 64; ue++) for (let Se = 0; Se < 64; Se++) {
                const ke = 65 * ue + Se, He = ke + 1, at = ke + 65, nt = at + 1;
                ge(ke, at, He), ge(He, at, nt);
              }
              [ne, me] = function(ue, Se) {
                const ke = Array.from({ length: ue.length }, (nt, tt) => tt);
                ke.sort((nt, tt) => ue[nt] - ue[tt]);
                const He = [], at = new ha();
                for (let nt = 0; nt < ke.length; nt++) {
                  const tt = ke[nt];
                  He.push(ue[tt]);
                  const Et = 3 * tt, lt = Et + 1;
                  at.emplaceBack(Se.uint16[Et], Se.uint16[lt], Se.uint16[lt + 1]);
                }
                return [He, at];
              }(ne, me), this.elevatedGlobeTrianglesCenterLongitudes = ne, this.elevatedGlobeIndexBuffer = e.createIndexBuffer(me);
            }
            this.elevatedGlobeSegments = Nn.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, j / Br, 0, J / Br, 0, 0, R, S, 0]);
          }
          prepare() {
            const e = Object.keys(this.tiles).length !== 0;
            if (this.tileID && !e) return;
            const i = this.map.painter.context, o = i.gl;
            !this._dirty || this.texture instanceof bp || (this.texture ? this.texture.update(this.image) : (this.texture = new Im(i, this.image, o.RGBA8), this.texture.bind(o.LINEAR, o.CLAMP_TO_EDGE)), this._dirty = !1), e && this._prepareData(i);
          }
          loadTile(e, i) {
            this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, i(null)) : (e.state = "errored", i(null));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
          getSegmentsForLongitude(e) {
            const i = this.elevatedGlobeSegments;
            if (!this.elevatedGlobeTrianglesCenterLongitudes || !i) return null;
            const o = this.elevatedGlobeTrianglesCenterLongitudes;
            let c = (s = e + 180) + 360 * Math.round((o[0] - s) / 360);
            var s;
            const h = new Nn(), y = (A, D) => {
              h.segments.push({ vertexOffset: 0, primitiveOffset: A, vertexLength: i.segments[0].vertexLength, primitiveLength: D, sortKey: void 0, vaos: {} });
            }, T = 0.51 * this.maxLongitudeTriangleSize;
            if (Math.abs(o[0] - c) <= T) {
              const A = Dt(o, 0, o.length, c + T);
              return A === o.length || y(A, Z(o, A + 1, o.length, c + 360 - T) - A), h;
            }
            c < o[0] && (c += 360);
            const k = Z(o, 0, o.length, c - T);
            if (k === o.length) return y(0, o.length), h;
            y(0, k - 0);
            const g = Dt(o, k + 1, o.length, c + T);
            return g !== o.length && y(g, o.length - g), h;
          }
        }
        const U1 = (Math.pow(256, 2) - 1) / 16907520;
        class v0 extends rn {
          constructor(e, i, o, c) {
            super(e, { layout: m0 || (m0 = new vn({ visibility: new Mr(Kt.layout_raster.visibility) })), paint: _0 || (_0 = new vn({ "raster-opacity": new Mr(Kt.paint_raster["raster-opacity"]), "raster-color": new Ro(Kt.paint_raster["raster-color"]), "raster-color-mix": new Mr(Kt.paint_raster["raster-color-mix"]), "raster-color-range": new Mr(Kt.paint_raster["raster-color-range"]), "raster-hue-rotate": new Mr(Kt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Mr(Kt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Mr(Kt.paint_raster["raster-brightness-max"]), "raster-saturation": new Mr(Kt.paint_raster["raster-saturation"]), "raster-contrast": new Mr(Kt.paint_raster["raster-contrast"]), "raster-resampling": new Mr(Kt.paint_raster["raster-resampling"]), "raster-fade-duration": new Mr(Kt.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new Mr(Kt.paint_raster["raster-emissive-strength"]), "raster-array-band": new Mr(Kt.paint_raster["raster-array-band"]), "raster-elevation": new Mr(Kt.paint_raster["raster-elevation"]), "raster-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, i, o, c), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
          }
          getProgramIds() {
            return ["raster"];
          }
          hasColorMap() {
            return !!this._transitionablePaint._values["raster-color"].value.value;
          }
          tileCoverLift() {
            return this.paint.get("raster-elevation");
          }
          isDraped(e) {
            return !(e && e._source instanceof y0 && (e._source.onNorthPole || e._source.onSouthPole)) && this.paint.get("raster-elevation") === 0;
          }
          _handleSpecialPaintPropertyUpdate(e) {
            e !== "raster-color" && e !== "raster-color-range" || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
          }
          updateColorRamp(e) {
            if (!this.hasColorMap() || !this._curRampRange) return;
            const i = this._transitionablePaint._values["raster-color"].value.expression, [o, c] = e || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
            isNaN(o) && isNaN(c) || o === this._curRampRange[0] && c === this._curRampRange[1] || (this.colorRamp = ph({ expression: i, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: o, end: c }], resolution: 256 }), this.colorRampTexture = null, this._curRampRange = [o, c]);
          }
        }
        let x0, b0, w0, E0, S0;
        class T0 extends rn {
          constructor(e, i, o, c) {
            super(e, { layout: x0 || (x0 = new vn({ visibility: new Mr(Kt["layout_raster-particle"].visibility) })), paint: b0 || (b0 = new vn({ "raster-particle-array-band": new Mr(Kt["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new Mr(Kt["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new Ro(Kt["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new Mr(Kt["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new Mr(Kt["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new Mr(Kt["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new Mr(Kt["paint_raster-particle"]["raster-particle-reset-rate-factor"]), "raster-particle-elevation": new Mr(Kt["paint_raster-particle"]["raster-particle-elevation"]), "raster-particle-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, i, o, c), this._updateColorRamp(), this.lastInvalidatedAt = ht.now();
          }
          onRemove(e) {
            this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
          }
          hasColorMap() {
            return !!this._transitionablePaint._values["raster-particle-color"].value.value;
          }
          getProgramIds() {
            return ["rasterParticle"];
          }
          hasOffscreenPass() {
            return this.visibility !== "none";
          }
          isDraped(e) {
            return !1;
          }
          _handleSpecialPaintPropertyUpdate(e) {
            e !== "raster-particle-color" && e !== "raster-particle-max-speed" || (this._updateColorRamp(), this._invalidateAnimationState()), e === "raster-particle-count" && this._invalidateAnimationState();
          }
          _updateColorRamp() {
            if (!this.hasColorMap()) return;
            const e = this._transitionablePaint._values["raster-particle-color"].value.expression, i = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
            this.colorRamp = ph({ expression: e, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: i }], resolution: 256 }), this.colorRampTexture = null;
          }
          _invalidateAnimationState() {
            this.lastInvalidatedAt = ht.now();
          }
          tileCoverLift() {
            return this.paint.get("raster-particle-elevation");
          }
        }
        class j1 extends rn {
          constructor(e, i) {
            super(e, {}, i, null), this.implementation = e, e.slot && (this.slot = e.slot);
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          isDraped(e) {
            return this.implementation.renderToTile !== void 0;
          }
          shouldRedrape() {
            return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
          }
          onAdd(e) {
            this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl);
          }
          onRemove(e) {
            this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl);
          }
        }
        function Cm(a, e, i) {
          const o = [0, 0, 1], c = Oe.quat.identity([]);
          return Oe.quat.rotateY(c, c, i ? -Ae(a) + Math.PI : Ae(a)), Oe.quat.rotateX(c, c, -Ae(e)), Oe.vec3.transformQuat(o, o, c), Oe.vec3.normalize(o, o);
        }
        function M0(a, e) {
          const i = Sp(a.projection, a.zoom, a.width, a.height), o = function(s, h, y, T, k) {
            const g = new qi(y.lng - 180 * xh, y.lat), A = new qi(y.lng + 180 * xh, y.lat), D = s.project(g.lng, g.lat), S = s.project(A.lng, A.lat), R = -Math.atan2(S.y - D.y, S.x - D.x), j = n.fromLngLat(y);
            j.y = ie(j.y, -1 + xh, 1 - xh);
            const J = j.toLngLat(), ne = s.project(J.lng, J.lat), me = n.fromLngLat(J);
            me.x += xh;
            const ge = me.toLngLat(), ue = s.project(ge.lng, ge.lat), Se = I0(ue.x - ne.x, ue.y - ne.y, R), ke = n.fromLngLat(J);
            ke.y += xh;
            const He = ke.toLngLat(), at = s.project(He.lng, He.lat), nt = I0(at.x - ne.x, at.y - ne.y, R), tt = Math.abs(Se.x) / Math.abs(nt.y), Et = Oe.mat4.identity([]);
            Oe.mat4.rotateZ(Et, Et, -R * (1 - (k ? 0 : T)));
            const lt = Oe.mat4.identity([]);
            return Oe.mat4.scale(lt, lt, [1, 1 - (1 - tt) * T, 1]), lt[4] = -nt.x / nt.y * T, Oe.mat4.rotateZ(lt, lt, R), Oe.mat4.multiply(lt, Et, lt), lt;
          }(a.projection, 0, a.center, i, e), c = A0(a);
          return Oe.mat4.scale(o, o, [c, c, 1]), o;
        }
        function A0(a) {
          const e = a.projection, i = Sp(a.projection, a.zoom, a.width, a.height), o = Pm(e, a.center), c = Pm(e, qi.convert(e.center));
          return Math.pow(2, o * i + (1 - i) * c);
        }
        function Sp(a, e, i, o, c = 1 / 0) {
          const s = a.range;
          if (!s) return 0;
          const h = Math.min(c, Math.max(i, o)), y = Math.log(h / 1024) / Math.LN2;
          return Xe(s[0] + y, s[1] + y, e);
        }
        const xh = 1 / 4e4;
        function Pm(a, e) {
          const i = ie(e.lat, -Cn, Cn), o = new qi(e.lng - 180 * xh, i), c = new qi(e.lng + 180 * xh, i), s = a.project(o.lng, i), h = a.project(c.lng, i), y = n.fromLngLat(o), T = n.fromLngLat(c), k = h.x - s.x, g = h.y - s.y, A = T.x - y.x, D = T.y - y.y, S = Math.sqrt((A * A + D * D) / (k * k + g * g));
          return Math.log(S) / Math.LN2;
        }
        function I0(a, e, i) {
          const o = Math.cos(i), c = Math.sin(i);
          return { x: a * o - e * c, y: a * c + e * o };
        }
        function C0(a, e, i) {
          Oe.mat4.identity(a), Oe.mat4.rotateZ(a, a, Ae(e[2])), Oe.mat4.rotateX(a, a, Ae(e[0])), Oe.mat4.rotateY(a, a, Ae(e[1])), Oe.mat4.scale(a, a, i), Oe.mat4.multiply(a, a, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        function Tp(a, e, i, o, c, s, h, y) {
          const T = [i[0] - e[0], i[1] - e[1], 0], k = [o[0] - e[0], o[1] - e[1], 0];
          if (Oe.vec3.length(T) < 1e-12 || Oe.vec3.length(k) < 1e-12) return Oe.quat.identity(a);
          const g = Oe.vec3.cross([], T, k);
          Oe.vec3.normalize(g, g), Oe.vec3.subtract(k, o, e), T[2] = (s - c) * y, k[2] = (h - c) * y;
          const A = T;
          return Oe.vec3.cross(A, T, k), Oe.vec3.normalize(A, A), Oe.quat.rotationTo(a, g, A);
        }
        function Rm(a, e, i = !1) {
          const o = Wa(e.zoom), c = function(s, h, y) {
            const T = h.worldSize, k = [s[12], s[13], s[14]], g = ci(k[1] / T), A = so(k[0] / T), D = Oe.mat4.identity([]), S = xn(1, g) * T, R = xn(1, 0) * T * Ou(g, h.zoom), j = 1 / wa(T);
            let J = R * j;
            if (y) {
              const ue = Sp(h.projection, h.zoom, h.width, h.height, 1024);
              J = j * h.projection.pixelSpaceConversion(h.center.lat, T, ue);
            }
            const ne = $l(g, A);
            Oe.vec3.add(ne, ne, Oe.vec3.scale([], Oe.vec3.normalize([], ne), S * J * k[2]));
            const me = function(ue) {
              const Se = [ue[0], ue[1], ue[2]];
              let ke = [0, 1, 0];
              const He = Oe.vec3.cross([], ke, Se);
              return Oe.vec3.cross(ke, Se, He), Oe.vec3.squaredLength(ke) === 0 && (ke = [0, 1, 0], Oe.vec3.cross(He, Se, ke)), Oe.vec3.normalize(He, He), Oe.vec3.normalize(ke, ke), Oe.vec3.normalize(Se, Se), [He[0], He[1], He[2], 0, ke[0], ke[1], ke[2], 0, Se[0], Se[1], Se[2], 0, ue[0], ue[1], ue[2], 1];
            }(ne);
            Oe.mat4.scale(D, D, [J, J, J * S]), Oe.mat4.translate(D, D, [-k[0], -k[1], -k[2]]);
            const ge = Oe.mat4.multiply([], h.globeMatrix, me);
            return Oe.mat4.multiply(ge, ge, D), Oe.mat4.multiply(ge, ge, s), ge;
          }(a, e, i);
          if (o > 0) {
            const s = function(h, y) {
              const T = y.worldSize, k = xn(1, 0) * T * Ou(y.center.lat, y.zoom) / wa(T), g = xn(1, y.center.lat) * T, A = Oe.mat4.identity([]);
              return Oe.mat4.rotateY(A, A, Ae(y.center.lng)), Oe.mat4.rotateX(A, A, Ae(y.center.lat)), Oe.mat4.translate(A, A, [0, 0, Ca]), Oe.mat4.scale(A, A, [k, k, k * g]), Oe.mat4.translate(A, A, [y.point.x - 0.5 * T, y.point.y - 0.5 * T, 0]), Oe.mat4.multiply(A, A, h), Oe.mat4.multiply(A, y.globeMatrix, A);
            }(a, e);
            return function(h, y, T) {
              const k = (R, j, J) => {
                const ne = Oe.vec3.length(R), me = Oe.vec3.length(j), ge = jn(R, j, J);
                return Oe.vec3.scale(ge, ge, 1 / Oe.vec3.length(ge) * li(ne, me, J));
              }, g = k([h[0], h[1], h[2]], [y[0], y[1], y[2]], T), A = k([h[4], h[5], h[6]], [y[4], y[5], y[6]], T), D = k([h[8], h[9], h[10]], [y[8], y[9], y[10]], T), S = jn([h[12], h[13], h[14]], [y[12], y[13], y[14]], T);
              return [g[0], g[1], g[2], 0, A[0], A[1], A[2], 0, D[0], D[1], D[2], 0, S[0], S[1], S[2], 1];
            }(c, s, o);
          }
          return c;
        }
        function P0(a, e, i, o) {
          const c = Yr.projectAabbCorners(o, i);
          let s = Number.MAX_VALUE, h = -1;
          for (let k = 0; k < c.length; ++k) {
            const g = c[k];
            g[0] = (0.5 * g[0] + 0.5) * e.width, g[1] = (0.5 - 0.5 * g[1]) * e.height, g[2] < s && (h = k, s = g[2]);
          }
          const y = (k) => new Ye(c[k][0], c[k][1]);
          let T;
          switch (h) {
            case 0:
            case 6:
              T = [y(1), y(5), y(4), y(7), y(3), y(2), y(1)];
              break;
            case 1:
            case 7:
              T = [y(0), y(4), y(5), y(6), y(2), y(3), y(0)];
              break;
            case 3:
            case 5:
              T = [y(1), y(0), y(4), y(7), y(6), y(2), y(1)];
              break;
            default:
              T = [y(1), y(5), y(6), y(7), y(3), y(0), y(1)];
          }
          if (Re(a, T)) return s;
        }
        const V1 = Yi([{ name: "a_pos_3f", components: 3, type: "Float32" }]), G1 = Yi([{ name: "a_color_3f", components: 3, type: "Float32" }]), H1 = Yi([{ name: "a_color_4f", components: 4, type: "Float32" }]), W1 = Yi([{ name: "a_uv_2f", components: 2, type: "Float32" }]), Z1 = Yi([{ name: "a_normal_3f", components: 3, type: "Float32" }]), q1 = Yi([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), $1 = Yi([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]), R0 = { None: 0, Model: 1, Symbol: 2, FillExtrusion: 4, All: 7 };
        class Mp {
          constructor(e, i, o, c) {
            this.message = (e ? `${e}: ` : "") + o, c && (this.identifier = c), i != null && i.__line__ && (this.line = i.__line__);
          }
        }
        function L0(a, e) {
          const i = a.indexOf("://") === -1;
          try {
            return new URL(a, i && e ? "http://example.com" : void 0), !0;
          } catch {
            return !1;
          }
        }
        class D0 {
          constructor(e, i) {
            this.feature = e, this.instancedDataOffset = i, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
          }
        }
        class k0 {
          constructor() {
            this.instancedDataArray = new Iu(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
          }
        }
        class Lm {
          constructor(e) {
            this.zoom = e.zoom, this.canonical = e.canonical, this.layers = e.layers, this.layerIds = this.layers.map((i) => i.fqid), this.projection = e.projection, this.index = e.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0;
          }
          updateFootprints(e, i) {
          }
          populate(e, i, o, c) {
            this.tileToMeter = t(o);
            const s = this.layers[0]._featureFilter.needGeometry;
            this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
            for (const { feature: h, id: y, index: T, sourceLayerIndex: k } of e) {
              const g = y ?? (h.properties && h.properties.hasOwnProperty("id") ? h.properties.id : void 0), A = ae(h, s);
              if (!this.layers[0]._featureFilter.filter(new sn(this.zoom), A, o)) continue;
              const D = { id: g, sourceLayerIndex: k, index: T, geometry: s ? A.geometry : K(h, o, c), properties: h.properties, type: h.type, patterns: {} }, S = this.addFeature(D, D.geometry, A);
              S && i.featureIndex.insert(h, D.geometry, T, k, this.index, this.instancesPerModel[S].instancedDataArray.length, Br / 32);
            }
            this.lookup = null;
          }
          update(e, i, o, c) {
            for (const s in this.instancesPerModel) {
              const h = this.instancesPerModel[s];
              for (const y in e) h.idToFeaturesIndex.hasOwnProperty(y) && (this.evaluate(h.features[h.idToFeaturesIndex[y]], e[y], h, !0), this.uploaded = !1);
            }
            this.maxHeight = 0;
          }
          updateZoomBasedPaintProperties() {
            if (!this.hasZoomDependentProperties) return !1;
            let e = !1;
            for (const i in this.instancesPerModel) {
              const o = this.instancesPerModel[i];
              for (const c of o.features) {
                const s = this.layers[0], h = c.feature, y = this.canonical, T = s.paint.get("model-rotation").evaluate(h, {}, y), k = s.paint.get("model-scale").evaluate(h, {}, y), g = s.paint.get("model-translation").evaluate(h, {}, y);
                Oe.vec3.exactEquals(c.rotation, T) && Oe.vec3.exactEquals(c.scale, k) && Oe.vec3.exactEquals(c.translation, g) || (this.evaluate(c, c.featureStates, o, !0), e = !0);
              }
            }
            return e;
          }
          updateReplacement(e, i, o, c) {
            if (i.updateTime === this.replacementUpdateTime) return !1;
            this.replacementUpdateTime = i.updateTime;
            const s = i.getReplacementRegionsForTile(e.toUnwrapped(), !0);
            if (im(this.activeReplacements, s)) return !1;
            this.activeReplacements = s;
            let h = !1;
            for (const y in this.instancesPerModel) {
              const T = this.instancesPerModel[y], k = T.instancedDataArray;
              for (const g of T.features) {
                const A = g.instancedDataOffset, D = g.instancedDataCount;
                for (let S = 0; S < D; S++) {
                  const R = 16 * (S + A);
                  let j = k.float32[R + 0];
                  const J = j > Br;
                  j = J ? j - Br : j;
                  const ne = Math.floor(j), me = k.float32[R + 1];
                  let ge = !1;
                  for (const ue of this.activeReplacements) if (!$_(ue, o, R0.Model, c) && !(ue.min.x > ne || ne > ue.max.x || ue.min.y > me || me > ue.max.y) && (ge = eg(Q_(ne, me, e.canonical, ue.footprintTileId.canonical), ue.footprint), ge)) break;
                  k.float32[R] = ge ? j + Br : j, h = h || ge !== J;
                }
              }
            }
            return h;
          }
          isEmpty() {
            for (const e in this.instancesPerModel) if (this.instancesPerModel[e].instancedDataArray.length !== 0) return !1;
            return !0;
          }
          uploadPending() {
            return !this.uploaded;
          }
          upload(e) {
            if (!this.uploaded) for (const i in this.instancesPerModel) {
              const o = this.instancesPerModel[i];
              o.instancedDataArray.length < 0 || o.instancedDataArray.length === 0 || (o.instancedDataBuffer ? o.instancedDataBuffer.updateData(o.instancedDataArray) : o.instancedDataBuffer = e.createVertexBuffer(o.instancedDataArray, q1.members, !0, void 0, this.instanceCount));
            }
            this.uploaded = !0;
          }
          destroy() {
            for (const i in this.instancesPerModel) {
              const o = this.instancesPerModel[i];
              o.instancedDataArray.length !== 0 && o.instancedDataBuffer && o.instancedDataBuffer.destroy();
            }
            const e = this.layers[0].modelManager;
            if (e && this.modelUris) for (const i of this.modelUris) e.removeModel(i, "");
          }
          addFeature(e, i, o) {
            const c = this.layers[0], s = c.layout.get("model-id").evaluate(o, {}, this.canonical);
            if (!s) return Tt(`modelId is not evaluated for layer ${c.id} and it is not going to get rendered.`), s;
            L0(s, !1) && (this.modelUris.includes(s) || this.modelUris.push(s)), this.instancesPerModel[s] || (this.instancesPerModel[s] = new k0());
            const h = this.instancesPerModel[s], y = h.instancedDataArray, T = new D0(o, y.length);
            for (const k of i) for (const g of k) {
              if (g.x < 0 || g.x >= Br || g.y < 0 || g.y >= Br) continue;
              const A = (this.lookupDim - 1) / Br, D = this.lookupDim * (g.y * A | 0) + g.x * A | 0;
              if (this.lookup) {
                if (this.lookup[D] !== 0) continue;
                this.lookup[D] = 1;
              }
              this.instanceCount++;
              const S = y.length;
              y.resize(S + 1), h.instancesEvaluatedElevation.push(0), y.float32[16 * S] = g.x, y.float32[16 * S + 1] = g.y;
            }
            return T.instancedDataCount = h.instancedDataArray.length - T.instancedDataOffset, T.instancedDataCount > 0 && (e.id && (h.idToFeaturesIndex[e.id] = h.features.length), h.features.push(T), this.evaluate(T, {}, h, !1)), s;
          }
          getModelUris() {
            return this.modelUris;
          }
          evaluate(e, i, o, c) {
            const s = this.layers[0], h = e.feature, y = this.canonical, T = e.rotation = s.paint.get("model-rotation").evaluate(h, i, y), k = e.scale = s.paint.get("model-scale").evaluate(h, i, y), g = e.translation = s.paint.get("model-translation").evaluate(h, i, y), A = s.paint.get("model-color").evaluate(h, i, y);
            A.a = s.paint.get("model-color-mix-intensity").evaluate(h, i, y);
            const D = [];
            this.maxVerticalOffset < g[2] && (this.maxVerticalOffset = g[2]), this.maxScale = Math.max(Math.max(this.maxScale, k[0]), Math.max(k[1], k[2])), C0(D, T, k);
            const S = Math.round(100 * A.a) + A.b / 1.05;
            for (let R = 0; R < e.instancedDataCount; ++R) {
              const j = e.instancedDataOffset + R, J = 16 * j, ne = o.instancedDataArray.float32;
              let me = 0;
              c && (me = ne[J + 6] - o.instancesEvaluatedElevation[j]);
              const ge = 0 | ne[J + 1];
              ne[J] = (0 | ne[J]) + A.r / 1.05, ne[J + 1] = ge + A.g / 1.05, ne[J + 2] = S, ne[J + 3] = 1 / (y.z > 10 ? this.tileToMeter : t(y, ge)), ne[J + 4] = g[0], ne[J + 5] = g[1], ne[J + 6] = g[2] + me, ne[J + 7] = D[0], ne[J + 8] = D[1], ne[J + 9] = D[2], ne[J + 10] = D[4], ne[J + 11] = D[5], ne[J + 12] = D[6], ne[J + 13] = D[8], ne[J + 14] = D[9], ne[J + 15] = D[10], o.instancesEvaluatedElevation[j] = g[2];
            }
          }
        }
        let z0, O0;
        Gr(Lm, "ModelBucket", { omit: ["layers"] }), Gr(k0, "PerModelAttributes"), Gr(D0, "ModelFeature");
        const sf = 64, qf = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
        function B0(a, e, i, o, c, s, h, y, T, k = !1) {
          const g = i.zoom, A = i.project(o), D = Ou(o.lat, g), S = 1 / D;
          Oe.mat4.identity(a), Oe.mat4.translate(a, a, [A.x + h[0] * S, A.y + h[1] * S, h[2]]);
          let R = 1, j = 1;
          const J = i.worldSize;
          if (k) {
            if (i.projection.name === "mercator") {
              let ue = 0;
              i.elevation && (ue = i.elevation.getAtPointOrZero(new n(A.x / J, A.y / J), 0));
              const Se = Oe.vec4.transformMat4([], [A.x, A.y, ue, 1], i.projMatrix)[3] / i.cameraToCenterDistance;
              R = Se, j = Se * Ou(i.center.lat, g);
            } else if (i.projection.name === "globe") {
              const ue = Rm(a, i), Se = Oe.mat4.multiply([], i.projMatrix, ue), ke = [0, 0, 0, 1];
              Oe.vec4.transformMat4(ke, ke, Se);
              const He = ke[3] / i.cameraToCenterDistance, at = Wa(g), nt = i.projection.pixelsPerMeter(o.lat, J) * Ou(o.lat, g), tt = i.projection.pixelsPerMeter(i.center.lat, J) * Ou(i.center.lat, g);
              R = He / li(nt, fh(i.center.lat), at), j = He * D / nt, R *= tt, j *= tt;
            }
          } else R = S;
          Oe.mat4.scale(a, a, [R, R, j]);
          const ne = [...a], me = e.orientation, ge = [];
          if (C0(ge, [me[0] + c[0], me[1] + c[1], me[2] + c[2]], s), Oe.mat4.multiply(a, ne, ge), y && i.elevation) {
            let ue = 0;
            const Se = [];
            if (T && i.elevation) {
              ue = function(at, nt, tt, Et, lt) {
                const St = nt.elevation;
                if (!St) return 0;
                const Lt = Yr.projectAabbCorners(tt, Et), It = xn(1, lt.lat) * nt.worldSize, zt = function(ti, Wr) {
                  const $r = [0, 0, 1], bi = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
                  for (const Ci of bi) {
                    const Pi = ti[Ci.corners[0]], Ri = ti[Ci.corners[1]], ji = ti[Ci.corners[2]], Hi = [Ri[0] - Pi[0], Ri[1] - Pi[1], Wr * (Ri[2] - Pi[2])], gn = Oe.vec3.cross(Hi, Hi, [ji[0] - Pi[0], ji[1] - Pi[1], Wr * (ji[2] - Pi[2])]);
                    Oe.vec3.normalize(gn, gn), Ci.dotProductWithUp = Oe.vec3.dot(gn, $r);
                  }
                  return bi.sort((Ci, Pi) => Ci.dotProductWithUp - Pi.dotProductWithUp), bi[0].corners;
                }(Lt, It), Ft = Lt[zt[0]], qt = Lt[zt[1]], Ot = Lt[zt[2]], cr = Lt[zt[3]], yr = St.getAtPointOrZero(new n(Ft[0] / nt.worldSize, Ft[1] / nt.worldSize), 0), ur = St.getAtPointOrZero(new n(qt[0] / nt.worldSize, qt[1] / nt.worldSize), 0), jr = St.getAtPointOrZero(new n(Ot[0] / nt.worldSize, Ot[1] / nt.worldSize), 0), zr = St.getAtPointOrZero(new n(cr[0] / nt.worldSize, cr[1] / nt.worldSize), 0), Ar = (yr + zr) / 2, vr = (ur + jr) / 2;
                return Ar > vr ? ur < jr ? Tp(at, qt, cr, Ft, ur, zr, yr, It) : Tp(at, Ot, Ft, cr, jr, yr, zr, It) : yr < zr ? Tp(at, Ft, qt, Ot, yr, ur, jr, It) : Tp(at, cr, Ot, qt, zr, jr, ur, It), Math.max(Ar, vr);
              }(Se, i, e.aabb, a, o);
              const ke = Oe.mat4.fromQuat([], Se), He = Oe.mat4.multiply([], ke, ge);
              Oe.mat4.multiply(a, ne, He);
            } else ue = i.elevation.getAtPointOrZero(new n(A.x / J, A.y / J), 0);
            ue !== 0 && (a[14] += ue);
          }
        }
        function Od(a, e, i = !1) {
          a.uploaded || (a.gfxTexture = new Im(e, a.image, i ? e.gl.R8 : e.gl.RGBA8, { useMipmap: a.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST }), a.uploaded = !0, a.image = null);
        }
        function X1(a, e, i) {
          a.indexBuffer = e.createIndexBuffer(a.indexArray, !1, !0), a.vertexBuffer = e.createVertexBuffer(a.vertexArray, V1.members, !1, !0), a.normalArray && (a.normalBuffer = e.createVertexBuffer(a.normalArray, Z1.members, !1, !0)), a.texcoordArray && (a.texcoordBuffer = e.createVertexBuffer(a.texcoordArray, W1.members, !1, !0)), a.colorArray && (a.colorBuffer = e.createVertexBuffer(a.colorArray, (a.colorArray.bytesPerElement === 12 ? G1 : H1).members, !1, !0)), a.featureArray && (a.pbrBuffer = e.createVertexBuffer(a.featureArray, $1.members, !0)), a.segments = Nn.simpleSegment(0, 0, a.vertexArray.length, a.indexArray.length);
          const o = a.material;
          o.pbrMetallicRoughness.baseColorTexture && Od(o.pbrMetallicRoughness.baseColorTexture, e), o.pbrMetallicRoughness.metallicRoughnessTexture && Od(o.pbrMetallicRoughness.metallicRoughnessTexture, e), o.normalTexture && Od(o.normalTexture, e), o.occlusionTexture && Od(o.occlusionTexture, e, i), o.emissionTexture && Od(o.emissionTexture, e);
        }
        function Dm(a, e, i) {
          if (a.meshes) for (const o of a.meshes) X1(o, e, i);
          if (a.children) for (const o of a.children) Dm(o, e, i);
        }
        function Ap(a) {
          if (a.meshes) for (const e of a.meshes) e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();
          if (a.children) for (const e of a.children) Ap(e);
        }
        function km(a) {
          if (a.meshes) for (const i of a.meshes) i.vertexBuffer && (i.vertexBuffer.destroy(), i.indexBuffer.destroy(), i.normalBuffer && i.normalBuffer.destroy(), i.texcoordBuffer && i.texcoordBuffer.destroy(), i.colorBuffer && i.colorBuffer.destroy(), i.pbrBuffer && i.pbrBuffer.destroy(), i.segments.destroy(), i.material && ((e = i.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));
          var e;
          if (a.children) for (const i of a.children) km(i);
        }
        class $f {
          constructor(e, i, o) {
            this._demTile = e, this._dem = this._demTile.dem, this._scale = i, this._offset = o;
          }
          static create(e, i, o) {
            const c = o || e.findDEMTileFor(i);
            if (!c || !c.dem) return;
            const s = c.dem, h = c.tileID, y = 1 << i.canonical.z - h.canonical.z;
            return new $f(c, s.dim / Br / y, [(i.canonical.x / y - h.canonical.x) * s.dim, (i.canonical.y / y - h.canonical.y) * s.dim]);
          }
          tileCoordToPixel(e, i) {
            const o = i * this._scale + this._offset[1], c = Math.floor(e * this._scale + this._offset[0]), s = Math.floor(o);
            return new Ye(c, s);
          }
          getElevationAt(e, i, o, c) {
            const s = e * this._scale + this._offset[0], h = i * this._scale + this._offset[1], y = Math.floor(s), T = Math.floor(h), k = this._dem;
            return c = !!c, o ? li(li(k.get(y, T, c), k.get(y, T + 1, c), h - T), li(k.get(y + 1, T, c), k.get(y + 1, T + 1, c), h - T), s - y) : k.get(y, T, c);
          }
          getElevationAtPixel(e, i, o) {
            return this._dem.get(e, i, !!o);
          }
          getMeterToDEM(e) {
            return (1 << this._demTile.tileID.canonical.z) * xn(1, e) * this._dem.stride;
          }
        }
        const zm = new Float32Array(262144), lf = new Uint8Array(262144);
        function F0(a) {
          let e = 0;
          if (a.meshes) for (const i of a.meshes) e = Math.max(e, i.aabb.max[2]);
          if (a.children) for (const i of a.children) e = Math.max(e, F0(i));
          return e;
        }
        function N0(a, e, i) {
          if (a.meshes) for (const o of a.meshes) {
            if (o.aabb.min[0] === 1 / 0) continue;
            const c = Yr.applyTransform(o.aabb, a.matrix);
            i.insert(e, c.min[0], c.min[1], c.max[0], c.max[1]);
          }
          if (a.children) for (const o of a.children) N0(o, e, i);
        }
        const U0 = ["", "wall", "door", "roof", "window", "lamp", "logo"];
        class j0 {
          constructor(e) {
            this.node = e, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = !1, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = { type: "Point", id: e.id, geometry: [], properties: { height: F0(e) } }, this.aabb = this._getLocalBounds(), this.state = null;
          }
          _getLocalBounds() {
            if (!this.node.meshes) return new Yr([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
            if (!this.aabb) {
              let e = 0;
              const i = new Yr([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
              for (const o of this.node.meshes) this.node.lightMeshIndex !== e && (o.transformedAabb = Yr.applyTransformFast(o.aabb, this.node.matrix), i.encapsulate(o.transformedAabb)), e++;
              this.aabb = i;
            }
            return this.aabb;
          }
        }
        class Ip {
          constructor(e, i, o, c, s, h, y) {
            this.id = o, this.layers = e, this.layerIds = this.layers.map((T) => T.fqid), this.stateDependentLayerIds = this.layers.filter((T) => T.isStateDependent()).map((T) => T.id), this.modelTraits |= qf.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, c && (this.modelTraits |= qf.HasMapboxMeshFeatures), s && (this.modelTraits |= qf.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = h, this.dirty = !0, this.needsUpload = !1, this.nodesInfo = [];
            for (const T of i) this.nodesInfo.push(new j0(T)), N0(T, y.featureIndexArray.length, y.grid), y.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, y.bucketLayerIDs.length - 1, 0);
            this.states = {};
          }
          updateFootprints(e, i) {
            for (const o of this.getNodesInfo()) {
              const c = o.node;
              c.footprint && i.push({ footprint: c.footprint, id: e });
            }
          }
          update(e) {
            const i = Object.keys(e).length !== 0;
            if (i && !this.stateDependentLayers.length) return;
            const o = i ? this.stateDependentLayers : this.layers;
            if (!qe(e, this.states)) for (const c of o) this.evaluate(c, e);
            this.states = structuredClone(e);
          }
          populate() {
            console.log("populate 3D model bucket");
          }
          uploadPending() {
            return !this.uploaded || this.needsUpload;
          }
          upload(e) {
            if (!this.needsUpload) return;
            const i = this.getNodesInfo();
            for (const o of i) {
              const c = o.node;
              this.uploaded ? this.updatePbrBuffer(c) : Dm(c, e, !0);
            }
            for (const o of i) Ap(o.node);
            this.uploaded = !0, this.needsUpload = !1;
          }
          updatePbrBuffer(e) {
            let i = !1;
            if (!e.meshes) return i;
            for (const o of e.meshes) o.pbrBuffer && (o.pbrBuffer.updateData(o.featureArray), i = !0);
            return i;
          }
          needsReEvaluation(e, i, o) {
            const c = e.transform.projectionOptions, s = e.style.getBrightness(), h = this.brightness !== s;
            if (!this.uploaded || this.dirty || c.name !== this.projection.name || Bd(o.paint.get("model-color").value, h) || Bd(o.paint.get("model-color-mix-intensity").value, h) || Bd(o.paint.get("model-roughness").value, h) || Bd(o.paint.get("model-emissive-strength").value, h) || Bd(o.paint.get("model-height-based-emissive-strength-multiplier").value, h)) {
              this.projection = c, this.brightness = s;
              const y = this.getNodesInfo();
              for (const T of y) T.state = null;
              return !0;
            }
            return !1;
          }
          evaluateScale(e, i) {
            if (e.transform.zoom === this.zoom) return;
            this.zoom = e.transform.zoom;
            const o = this.getNodesInfo(), c = this.id.canonical;
            for (const s of o) {
              const h = s.feature;
              s.evaluatedScale = i.paint.get("model-scale").evaluate(h, {}, c);
            }
          }
          evaluate(e, i) {
            const o = this.getNodesInfo();
            for (const c of o) {
              if (!c.node.meshes) continue;
              const s = c.feature, h = i && i[s.id];
              if (qe(h, c.state)) continue;
              c.state = structuredClone(h);
              const y = c.node.meshes && c.node.meshes[0].featureData, T = c.evaluatedColor[2], k = c.evaluatedRMEA[2], g = this.id.canonical;
              if (c.hasTranslucentParts = !1, y) {
                for (let A = 0; A < U0.length; A++) {
                  const D = U0[A];
                  D.length && (s.properties.part = D);
                  const S = e.paint.get("model-color").evaluate(s, h, g).toRenderColor(null), R = e.paint.get("model-color-mix-intensity").evaluate(s, h, g);
                  c.evaluatedColor[A] = [S.r, S.g, S.b, R], c.evaluatedRMEA[A][0] = e.paint.get("model-roughness").evaluate(s, h, g), c.evaluatedRMEA[A][2] = e.paint.get("model-emissive-strength").evaluate(s, h, g), c.evaluatedRMEA[A][3] = S.a, c.emissionHeightBasedParams[A] = e.paint.get("model-height-based-emissive-strength-multiplier").evaluate(s, h, g), !c.hasTranslucentParts && S.a < 1 && (c.hasTranslucentParts = !0);
                }
                delete s.properties.part, K1(c, T !== c.evaluatedColor[2] || k !== c.evaluatedRMEA[2], this.modelTraits);
              } else c.evaluatedRMEA[0][2] = e.paint.get("model-emissive-strength").evaluate(s, h, g);
              c.evaluatedScale = e.paint.get("model-scale").evaluate(s, h, g), this.updatePbrBuffer(c.node) || (this.needsUpload = !0);
            }
            this.dirty = !1;
          }
          elevationUpdate(e, i, o, c) {
            const s = e.findDEMTileFor(o);
            if (s && (s.tileID.canonical !== this.terrainTile || i !== this.terrainExaggeration)) {
              if (s.dem && s.tileID.overscaledZ !== this.elevationReadFromZ) {
                this.elevationReadFromZ = s.tileID.overscaledZ;
                const h = $f.create(e, o, s);
                if (!h) return;
                this.modelTraits & qf.HasMapboxMeshFeatures && this.updateDEM(e, h, o, c);
                for (const y of this.getNodesInfo()) {
                  const T = y.node;
                  if (!T.footprint || !T.footprint.vertices || !T.footprint.vertices.length) continue;
                  const k = T.footprint.vertices;
                  let g = h.getElevationAt(k[0].x, k[0].y, !0, !0);
                  for (let A = 1; A < k.length; A++) g = Math.min(g, h.getElevationAt(k[A].x, k[A].y, !0, !0));
                  T.elevation = g;
                }
              }
              this.terrainTile = s.tileID.canonical, this.terrainExaggeration = i;
            }
          }
          updateDEM(e, i, o, c) {
            let s = i._dem._modifiedForSources[c];
            if (s === void 0 && (i._dem._modifiedForSources[c] = [], s = i._dem._modifiedForSources[c]), s.includes(o.canonical)) return;
            const h = i._dem.dim;
            s.push(o.canonical);
            let y = !1;
            for (const T of this.getNodesInfo()) {
              const k = T.node;
              if (!k.footprint || !k.footprint.grid) continue;
              const g = k.footprint.grid, A = i.tileCoordToPixel(g.min.x, g.min.y), D = i.tileCoordToPixel(g.max.x, g.max.y), S = Math.min(Math.min(h - D.y, A.x), Math.min(A.y, h - D.x));
              if (S < 0) continue;
              const R = ie(S, 2, 5);
              let j = Math.max(0, A.x - R), J = Math.max(0, A.y - R), ne = Math.min(D.x + R, h - 1), me = Math.min(D.y + R, h - 1);
              for (let ke = J; ke <= me; ++ke) for (let He = j; He <= ne; ++He) lf[ke * h + He] = 255;
              let ge = 0, ue = 0;
              for (let ke = 0; ke < g.cellsY; ++ke) for (let He = 0; He < g.cellsX; ++He) {
                if (!g.cells[ke * g.cellsX + He]) continue;
                const at = i.tileCoordToPixel(g.min.x + He / g.xScale, g.min.y + ke / g.yScale), nt = i.tileCoordToPixel(g.min.x + (He + 1) / g.xScale, g.min.y + (ke + 1) / g.yScale);
                for (let tt = at.y; tt <= Math.min(nt.y + 1, h - 1); ++tt) for (let Et = at.x; Et <= Math.min(nt.x + 1, h - 1); ++Et) lf[tt * h + Et] === 255 && (lf[tt * h + Et] = 0, ge += i.getElevationAtPixel(Et, tt), ue++);
              }
              const Se = ge / ue;
              j = Math.max(1, A.x - R), J = Math.max(1, A.y - R), ne = Math.min(D.x + R, h - 2), me = Math.min(D.y + R, h - 2), y = !0;
              for (let ke = J; ke <= me; ++ke) for (let He = j; He <= ne; ++He) lf[ke * h + He] === 0 && (zm[ke * h + He] = i._dem.set(He, ke, Se));
              for (let ke = 1; ke < R; ++ke) {
                j = Math.max(1, A.x - ke), J = Math.max(1, A.y - ke), ne = Math.min(D.x + ke, h - 2), me = Math.min(D.y + ke, h - 2);
                for (let He = J; He <= me; ++He) for (let at = j; at <= ne; ++at) {
                  const nt = He * h + at;
                  if (lf[nt] === 255) {
                    let tt = 0, Et = 0, lt = -1, St = -1;
                    for (let Lt = -1; Lt <= 1; ++Lt) for (let It = -1; It <= 1; ++It) {
                      const zt = (He + Lt) * h + at + It;
                      if (lf[zt] >= ke) continue;
                      const Ft = zm[zt], qt = Math.abs(Ft);
                      qt > Et && (tt = Ft, Et = qt, lt = It, St = Lt);
                    }
                    if (Et > 0.1) {
                      const Lt = 1 - (ke + 0.5 * Math.abs(lt * St)) / R;
                      let It = i._dem.get(at, He) + tt * Lt;
                      const zt = i._dem.get(at + lt, He + St), Ft = i._dem.get(at - lt, He - St, !0);
                      (It - zt) * (It - Ft) > 0 && (It = (zt + Ft) / 2), zm[nt] = i._dem.set(at, He, It), lf[nt] = ke;
                    }
                  }
                }
              }
            }
            y && (i._demTile.needsDEMTextureUpload = !0, i._dem._timestamp = ht.now());
          }
          getNodesInfo() {
            return this.nodesInfo;
          }
          destroy() {
            const e = this.getNodesInfo();
            for (const i of e) Ap(i.node), km(i.node);
          }
          isEmpty() {
            return !this.nodesInfo.length;
          }
          updateReplacement(e, i) {
            if (i.updateTime === this.replacementUpdateTime) return;
            this.replacementUpdateTime = i.updateTime;
            const o = i.getReplacementRegionsForTile(e.toUnwrapped()), c = this.getNodesInfo();
            for (let s = 0; s < this.nodesInfo.length; s++) {
              const h = c[s].node;
              c[s].hiddenByReplacement = !!h.footprint && !o.find((y) => y.footprint === h.footprint);
            }
          }
          getHeightAtTileCoord(e, i) {
            const o = this.getNodesInfo(), c = [], s = [0, 0, 0], h = Oe.mat4.identity([]);
            for (let y = 0; y < this.nodesInfo.length; y++) {
              const T = o[y], k = T.node.meshes[0], g = k.transformedAabb;
              if (e < g.min[0] || i < g.min[1] || e > g.max[0] || i > g.max[1]) continue;
              if (T.node.hidden === !0) return { height: 1 / 0, maxHeight: T.feature.properties.height, hidden: !1, verticalScale: T.evaluatedScale[2] };
              Oe.mat4.invert(h, T.node.matrix), s[0] = e, s[1] = i, Oe.vec3.transformMat4(s, s, h);
              const A = (s[0] - k.aabb.min[0]) / (k.aabb.max[0] - k.aabb.min[0]) * sf | 0, D = Math.min(63, (s[1] - k.aabb.min[1]) / (k.aabb.max[1] - k.aabb.min[1]) * sf | 0) * sf + Math.min(63, A), S = k.heightmap[D];
              if (!(S < 0 && T.node.footprint))
                return T.hiddenByReplacement ? void 0 : { height: S, maxHeight: T.feature.properties.height, hidden: !1, verticalScale: T.evaluatedScale[2] };
              if (T.node.footprint.grid.query(new Ye(e, i), new Ye(e, i), c), c.length > 0) return { height: void 0, maxHeight: T.feature.properties.height, hidden: T.hiddenByReplacement, verticalScale: T.evaluatedScale[2] };
            }
          }
        }
        function Bd(a, e) {
          return !a.isLightConstant && e;
        }
        function Y1(a, e, i, o, c, s, h, y) {
          let T = (61440 & e | (61440 & e) >> 4) >> 8, k = (3840 & e | (3840 & e) >> 4) >> 4, g = 240 & e | (240 & e) >> 4;
          i[3] > 0 && (T = li(T, 255 * i[0], i[3]), k = li(k, 255 * i[1], i[3]), g = li(g, 255 * i[2], i[3]));
          const A = T << 8 | k, D = g << 8 | Math.floor(255 * o[3]), S = function(ke) {
            const He = ie(ke, 0, 2);
            return Math.min(Math.round(0.5 * He * 255), 255);
          }(o[2]) << 8 | 15 * o[0] << 4 | 15 * o[1], R = ie(c[0], 0, 1), j = ie(c[1], 0, 1), J = ie(c[2], 0, 1), ne = ie(c[3], 0, 1);
          let me, ge, ue, Se;
          if (R !== j && h !== s && j !== R) {
            const ke = h - s;
            ge = 1 / (ke * (j - R)), ue = -(s + ke * R) / (ke * (j - R));
            const He = ie(c[4], -1, 1);
            Se = Math.pow(10, He), me = 255 * J << 8 | 255 * ne;
          } else me = 65535, ge = 0, ue = 1, Se = 1;
          if (a.emplaceBack(A, D, S, me, ge, ue, Se), y) {
            const ke = y.length;
            y.clear();
            for (let He = 0; He < ke; He++) y.emplaceBack(A, D, S, me, ge, ue, Se);
          }
        }
        function K1(a, e, i) {
          const o = a.node;
          let c = 0;
          const s = i & qf.HasMeshoptCompression;
          for (const h of o.meshes) {
            if (o.lights && o.lightMeshIndex === c || !h.featureData) continue;
            h.featureArray = new Wl(), h.featureArray.reserve(h.featureData.length);
            let y = e;
            for (const T of h.featureData) {
              const k = s ? 65535 & T : T >> 16 & 65535, g = s ? T >> 16 & 65535 : 65535 & T, A = (15 & g) < 8 ? 15 & g : 0, D = a.evaluatedRMEA[A], S = a.evaluatedColor[A], R = a.emissionHeightBasedParams[A];
              let j;
              if (y && A === 2 && o.lights && (j = new Wl(), j.resize(10 * o.lights.length)), Y1(h.featureArray, k, S, D, R, h.aabb.min[2], h.aabb.max[2], j), j && y) {
                y = !1;
                const J = o.meshes[o.lightMeshIndex];
                J.featureArray = j, J.featureArray._trim();
              }
            }
            h.featureArray._trim(), c++;
          }
        }
        function V0(a, e, i, o) {
          const c = 1 << a.z;
          e.lat = ci((o / Br + a.y) / c), e.lng = so((i / Br + a.x) / c);
        }
        Gr(Ip, "Tiled3dModelBucket", { omit: ["layers"] }), Gr(j0, "Tiled3dModelFeature");
        const J1 = { circle: class extends rn {
          constructor(a, e, i, o) {
            super(a, { layout: gr || (gr = new vn({ "circle-sort-key": new Nr(Kt.layout_circle["circle-sort-key"]), "circle-elevation-reference": new Mr(Kt.layout_circle["circle-elevation-reference"]), visibility: new Mr(Kt.layout_circle.visibility) })), paint: Ut || (Ut = new vn({ "circle-radius": new Nr(Kt.paint_circle["circle-radius"]), "circle-color": new Nr(Kt.paint_circle["circle-color"]), "circle-blur": new Nr(Kt.paint_circle["circle-blur"]), "circle-opacity": new Nr(Kt.paint_circle["circle-opacity"]), "circle-translate": new Mr(Kt.paint_circle["circle-translate"]), "circle-translate-anchor": new Mr(Kt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Mr(Kt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Mr(Kt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Nr(Kt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Nr(Kt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Nr(Kt.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new Mr(Kt.paint_circle["circle-emissive-strength"]), "circle-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "circle-stroke-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, o);
          }
          createBucket(a) {
            return new Be(a);
          }
          queryRadius(a) {
            const e = a;
            return or("circle-radius", this, e) + or("circle-stroke-width", this, e) + sr(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(a, e, i, o, c, s, h, y) {
            const T = rr(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s.angle, a.pixelToTileUnitsFactor), k = this.paint.get("circle-radius").evaluate(e, i) + this.paint.get("circle-stroke-width").evaluate(e, i);
            return Tc(a, o, s, h, y, this.paint.get("circle-pitch-alignment") === "map", this.paint.get("circle-pitch-scale") === "map", T, k);
          }
          getProgramIds() {
            return ["circle"];
          }
          getDefaultProgramParams(a, e, i) {
            const o = Bu(this);
            return { config: new Rs(this, { zoom: e, lut: i }), defines: o, overrideFog: !1 };
          }
        }, heatmap: class extends rn {
          createBucket(a) {
            return new Jd(a);
          }
          constructor(a, e, i, o) {
            super(a, { layout: Jl || (Jl = new vn({ visibility: new Mr(Kt.layout_heatmap.visibility) })), paint: nf || (nf = new vn({ "heatmap-radius": new Nr(Kt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Nr(Kt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Mr(Kt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ro(Kt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Mr(Kt.paint_heatmap["heatmap-opacity"]), "heatmap-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, o), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(a) {
            a === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = ph({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius(a) {
            return or("heatmap-radius", this, a);
          }
          queryIntersectsFeature(a, e, i, o, c, s, h, y) {
            const T = this.paint.get("heatmap-radius").evaluate(e, i);
            return Tc(a, o, s, h, y, !0, !0, new Ye(0, 0), T);
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
          getProgramIds() {
            return ["heatmap", "heatmapTexture"];
          }
          getDefaultProgramParams(a, e, i) {
            return a === "heatmap" ? { config: new Rs(this, { zoom: e, lut: i }), overrideFog: !1 } : {};
          }
        }, hillshade: class extends rn {
          constructor(a, e, i, o) {
            super(a, { layout: Fu || (Fu = new vn({ visibility: new Mr(Kt.layout_hillshade.visibility) })), paint: af || (af = new vn({ "hillshade-illumination-direction": new Mr(Kt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Mr(Kt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Mr(Kt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Mr(Kt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Mr(Kt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Mr(Kt.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new Mr(Kt.paint_hillshade["hillshade-emissive-strength"]), "hillshade-shadow-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-highlight-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-accent-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, o);
          }
          shouldRedrape() {
            return this.hasOffscreenPass() && this.paint.get("hillshade-illumination-anchor") === "viewport";
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
          getProgramIds() {
            return ["hillshade", "hillshadePrepare"];
          }
          getDefaultProgramParams(a, e, i) {
            return { overrideFog: !1 };
          }
        }, fill: class extends rn {
          constructor(a, e, i, o) {
            super(a, { layout: _r || (_r = new vn({ "fill-sort-key": new Nr(Kt.layout_fill["fill-sort-key"]), visibility: new Mr(Kt.layout_fill.visibility), "fill-elevation-reference": new Mr(Kt.layout_fill["fill-elevation-reference"]) })), paint: lr || (lr = new vn({ "fill-antialias": new Mr(Kt.paint_fill["fill-antialias"]), "fill-opacity": new Nr(Kt.paint_fill["fill-opacity"]), "fill-color": new Nr(Kt.paint_fill["fill-color"]), "fill-outline-color": new Nr(Kt.paint_fill["fill-outline-color"]), "fill-translate": new Mr(Kt.paint_fill["fill-translate"]), "fill-translate-anchor": new Mr(Kt.paint_fill["fill-translate-anchor"]), "fill-pattern": new Nr(Kt.paint_fill["fill-pattern"]), "fill-emissive-strength": new Mr(Kt.paint_fill["fill-emissive-strength"]), "fill-z-offset": new Nr(Kt.paint_fill["fill-z-offset"]), "fill-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "fill-outline-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, o);
          }
          getProgramIds() {
            const a = this.paint.get("fill-pattern"), e = a && a.constantOr(1), i = [e ? "fillPattern" : "fill"];
            return this.paint.get("fill-antialias") && i.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), i;
          }
          getDefaultProgramParams(a, e, i) {
            return { config: new Rs(this, { zoom: e, lut: i }), overrideFog: !1 };
          }
          recalculate(a, e) {
            super.recalculate(a, e);
            const i = this.paint._values["fill-outline-color"];
            i.value.kind === "constant" && i.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(a) {
            return new na(a);
          }
          queryRadius() {
            return sr(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(a, e, i, o, c, s) {
            return !a.queryGeometry.isAboveHorizon && Ve(Bt(a.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s.angle, a.pixelToTileUnitsFactor), o);
          }
          isTileClipped() {
            return !0;
          }
          is3D() {
            return this.paint.get("fill-z-offset").constantOr(1) !== 0;
          }
        }, "fill-extrusion": class extends rn {
          constructor(a, e, i, o) {
            super(a, { layout: mg || (mg = new vn({ visibility: new Mr(Kt["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new Mr(Kt["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) })), paint: _g || (_g = new vn({ "fill-extrusion-opacity": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Nr(Kt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Nr(Kt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Nr(Kt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Nr(Kt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-height-alignment": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-height-alignment"]), "fill-extrusion-base-alignment": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-base-alignment"]), "fill-extrusion-vertical-gradient": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new Nr(Kt["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new Nr(Kt["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new Nr(Kt["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]), "fill-extrusion-line-width": new Nr(Kt["paint_fill-extrusion"]["fill-extrusion-line-width"]), "fill-extrusion-cast-shadows": new Mr(Kt["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]), "fill-extrusion-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "fill-extrusion-flood-light-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, o), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
          }
          createBucket(a) {
            return new ap(a);
          }
          queryRadius() {
            return sr(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          hasShadowPass() {
            return this.paint.get("fill-extrusion-cast-shadows");
          }
          cutoffRange() {
            return this.paint.get("fill-extrusion-cutoff-fade-range");
          }
          canCastShadows() {
            return !0;
          }
          getProgramIds() {
            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
          }
          queryIntersectsFeature(a, e, i, o, c, s, h, y, T) {
            const k = rr(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s.angle, a.pixelToTileUnitsFactor), g = this.paint.get("fill-extrusion-height").evaluate(e, i), A = this.paint.get("fill-extrusion-base").evaluate(e, i), D = [0, 0], S = y && s.elevation, R = s.elevation ? s.elevation.exaggeration() : 1, j = a.tile.getBucket(this);
            if (S && j instanceof ap) {
              const ue = j.centroidVertexArray, Se = T + 1;
              Se < ue.length && (D[0] = ue.geta_centroid_pos0(Se), D[1] = ue.geta_centroid_pos1(Se));
            }
            if (D[0] === 0 && D[1] === 1) return !1;
            s.projection.name === "globe" && (o = pg([o], [new Ye(0, 0), new Ye(Br, Br)], a.tileID.canonical).map((ue) => ue.polygon).flat());
            const J = S ? y : null, [ne, me] = function(ue, Se, ke, He, at, nt, tt, Et, lt, St, Lt) {
              return ue.projection.name === "globe" ? function(It, zt, Ft, qt, Ot, cr, yr, ur, jr, zr, Ar) {
                const vr = [], ti = [], Wr = It.projection.upVectorScale(Ar, It.center.lat, It.worldSize).metersToTile, $r = [0, 0, 0, 1], bi = [0, 0, 0, 1], Ci = (Ri, ji, Hi, gn) => {
                  Ri[0] = ji, Ri[1] = Hi, Ri[2] = gn, Ri[3] = 1;
                }, Pi = dg();
                Ft > 0 && (Ft += Pi), qt += Pi;
                for (const Ri of zt) {
                  const ji = [], Hi = [];
                  for (const gn of Ri) {
                    const cn = gn.x + Ot.x, Si = gn.y + Ot.y, an = It.projection.projectTilePoint(cn, Si, Ar), un = It.projection.upVector(Ar, gn.x, gn.y);
                    let Sn = Ft, $n = qt;
                    if (yr) {
                      const oa = yg(cn, Si, Ft, qt, yr, ur, jr, zr);
                      Sn += oa.base, $n += oa.top;
                    }
                    Ft !== 0 ? Ci($r, an.x + un[0] * Wr * Sn, an.y + un[1] * Wr * Sn, an.z + un[2] * Wr * Sn) : Ci($r, an.x, an.y, an.z), Ci(bi, an.x + un[0] * Wr * $n, an.y + un[1] * Wr * $n, an.z + un[2] * Wr * $n), Oe.vec3.transformMat4($r, $r, cr), Oe.vec3.transformMat4(bi, bi, cr), ji.push(new of($r[0], $r[1], $r[2])), Hi.push(new of(bi[0], bi[1], bi[2]));
                  }
                  vr.push(ji), ti.push(Hi);
                }
                return [vr, ti];
              }(ue, Se, ke, He, at, nt, tt, Et, lt, St, Lt) : tt ? function(It, zt, Ft, qt, Ot, cr, yr, ur, jr) {
                const zr = [], Ar = [], vr = [0, 0, 0, 1];
                for (const ti of It) {
                  const Wr = [], $r = [];
                  for (const bi of ti) {
                    const Ci = bi.x + qt.x, Pi = bi.y + qt.y, Ri = yg(Ci, Pi, zt, Ft, cr, yr, ur, jr);
                    vr[0] = Ci, vr[1] = Pi, vr[2] = Ri.base, vr[3] = 1, Oe.vec4.transformMat4(vr, vr, Ot), vr[3] = Math.max(vr[3], 1e-5);
                    const ji = new of(vr[0] / vr[3], vr[1] / vr[3], vr[2] / vr[3]);
                    vr[0] = Ci, vr[1] = Pi, vr[2] = Ri.top, vr[3] = 1, Oe.vec4.transformMat4(vr, vr, Ot), vr[3] = Math.max(vr[3], 1e-5);
                    const Hi = new of(vr[0] / vr[3], vr[1] / vr[3], vr[2] / vr[3]);
                    Wr.push(ji), $r.push(Hi);
                  }
                  zr.push(Wr), Ar.push($r);
                }
                return [zr, Ar];
              }(Se, ke, He, at, nt, tt, Et, lt, St) : function(It, zt, Ft, qt, Ot) {
                const cr = [], yr = [], ur = Ot[8] * zt, jr = Ot[9] * zt, zr = Ot[10] * zt, Ar = Ot[11] * zt, vr = Ot[8] * Ft, ti = Ot[9] * Ft, Wr = Ot[10] * Ft, $r = Ot[11] * Ft;
                for (const bi of It) {
                  const Ci = [], Pi = [];
                  for (const Ri of bi) {
                    const ji = Ri.x + qt.x, Hi = Ri.y + qt.y, gn = Ot[0] * ji + Ot[4] * Hi + Ot[12], cn = Ot[1] * ji + Ot[5] * Hi + Ot[13], Si = Ot[2] * ji + Ot[6] * Hi + Ot[14], an = Ot[3] * ji + Ot[7] * Hi + Ot[15], un = gn + ur, Sn = cn + jr, $n = Si + zr, oa = Math.max(an + Ar, 1e-5), Xn = gn + vr, Vn = cn + ti, Jn = Si + Wr, da = Math.max(an + $r, 1e-5);
                    Ci.push(new of(un / oa, Sn / oa, $n / oa)), Pi.push(new of(Xn / da, Vn / da, Jn / da));
                  }
                  cr.push(Ci), yr.push(Pi);
                }
                return [cr, yr];
              }(Se, ke, He, at, nt);
            }(s, o, A, g, k, h, J, D, R, s.center.lat, a.tileID.canonical), ge = a.queryGeometry;
            return function(ue, Se, ke) {
              let He = 1 / 0;
              Ve(ke, Se) && (He = gg(ke, Se[0]));
              for (let at = 0; at < Se.length; at++) {
                const nt = Se[at], tt = ue[at];
                for (let Et = 0; Et < nt.length - 1; Et++) {
                  const lt = nt[Et], St = [lt, nt[Et + 1], tt[Et + 1], tt[Et], lt];
                  Re(ke, St) && (He = Math.min(He, gg(ke, St)));
                }
              }
              return He !== 1 / 0 && He;
            }(ne, me, ge.isPointQuery() ? ge.screenBounds : ge.screenGeometry);
          }
        }, line: class extends rn {
          constructor(a, e, i, o) {
            const c = Ig();
            super(a, c, e, i, o), c.layout && (this.layout = new nl(c.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = !1, this.hasNonElevatedBuckets = !1;
          }
          _handleSpecialPaintPropertyUpdate(a) {
            if (a === "line-gradient") {
              const e = this._transitionablePaint._values["line-gradient"].value.expression;
              this.stepInterpolant = e._styleExpression && e._styleExpression.expression instanceof Tl, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          widthExpression() {
            return this._transitionablePaint._values["line-width"].value.expression;
          }
          recalculate(a, e) {
            super.recalculate(a, e), this.paint._values["line-floorwidth"] = (() => {
              if (Sd) return Sd;
              const i = Ig();
              return Sd = new t1(i.paint.properties["line-width"].specification), Sd.useIntegerZoom = !0, Sd;
            })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, a);
          }
          createBucket(a) {
            return new sm(a);
          }
          getProgramIds() {
            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
          }
          getDefaultProgramParams(a, e, i) {
            const o = Mg(this);
            return { config: new Rs(this, { zoom: e, lut: i }), defines: o, overrideFog: !1 };
          }
          queryRadius(a) {
            const e = a, i = Cg(or("line-width", this, e), or("line-gap-width", this, e)), o = or("line-offset", this, e);
            return i / 2 + Math.abs(o) + sr(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(a, e, i, o, c, s) {
            if (a.queryGeometry.isAboveHorizon) return !1;
            const h = Bt(a.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s.angle, a.pixelToTileUnitsFactor), y = a.pixelToTileUnitsFactor / 2 * Cg(this.paint.get("line-width").evaluate(e, i), this.paint.get("line-gap-width").evaluate(e, i)), T = this.paint.get("line-offset").evaluate(e, i);
            return T && (o = function(k, g) {
              const A = [], D = new Ye(0, 0);
              for (let S = 0; S < k.length; S++) {
                const R = k[S], j = [];
                for (let J = 0; J < R.length; J++) {
                  const ne = R[J], me = R[J + 1], ge = J === 0 ? D : ne.sub(R[J - 1])._unit()._perp(), ue = J === R.length - 1 ? D : me.sub(ne)._unit()._perp(), Se = ge._add(ue)._unit();
                  Se._mult(1 / (Se.x * ue.x + Se.y * ue.y)), j.push(Se._mult(g)._add(ne));
                }
                A.push(j);
              }
              return A;
            }(o, T * a.pixelToTileUnitsFactor)), function(k, g, A) {
              for (let D = 0; D < g.length; D++) {
                const S = g[D];
                if (k.length >= 3) {
                  for (let R = 0; R < S.length; R++) if (dt(k, S[R])) return !0;
                }
                if (et(k, S, A)) return !0;
              }
              return !1;
            }(h, o, y);
          }
          isTileClipped() {
            return !0;
          }
          isDraped(a) {
            return !this.hasElevatedBuckets;
          }
        }, symbol: xp, background: class extends rn {
          constructor(a, e, i, o) {
            super(a, { layout: d0 || (d0 = new vn({ visibility: new Mr(Kt.layout_background.visibility) })), paint: p0 || (p0 = new vn({ "background-pitch-alignment": new Mr(Kt.paint_background["background-pitch-alignment"]), "background-color": new Mr(Kt.paint_background["background-color"]), "background-pattern": new Mr(Kt.paint_background["background-pattern"]), "background-opacity": new Mr(Kt.paint_background["background-opacity"]), "background-emissive-strength": new Mr(Kt.paint_background["background-emissive-strength"]), "background-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, o);
          }
          getProgramIds() {
            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
          }
          getDefaultProgramParams(a, e, i) {
            return { overrideFog: !1 };
          }
          is3D() {
            return this.paint.get("background-pitch-alignment") === "viewport";
          }
        }, raster: v0, "raster-particle": T0, sky: class extends rn {
          constructor(a, e, i, o) {
            super(a, { layout: w0 || (w0 = new vn({ visibility: new Mr(Kt.layout_sky.visibility) })), paint: E0 || (E0 = new vn({ "sky-type": new Mr(Kt.paint_sky["sky-type"]), "sky-atmosphere-sun": new Mr(Kt.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Mr(Kt.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Mr(Kt.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Mr(Kt.paint_sky["sky-gradient-radius"]), "sky-gradient": new Ro(Kt.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Mr(Kt.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Mr(Kt.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Mr(Kt.paint_sky["sky-opacity"]), "sky-gradient-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-halo-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, o), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(a) {
            a === "sky-gradient" ? this._updateColorRamp() : a !== "sky-atmosphere-sun" && a !== "sky-atmosphere-halo-color" && a !== "sky-atmosphere-color" && a !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = !0);
          }
          _updateColorRamp() {
            this.colorRamp = ph({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
          }
          needsSkyboxCapture(a) {
            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
            if (!this.paint.get("sky-atmosphere-sun")) {
              const e = a.style.light.properties.get("position");
              return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
            }
            return !1;
          }
          getCenter(a, e) {
            if (this.paint.get("sky-type") === "atmosphere") {
              const o = this.paint.get("sky-atmosphere-sun"), c = !o, s = a.style.light, h = s.properties.get("position");
              return c && s.properties.get("anchor") === "viewport" && Tt("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), c ? Cm(h.azimuthal, 90 - h.polar, e) : Cm(o[0], 90 - o[1], e);
            }
            const i = this.paint.get("sky-gradient-center");
            return Cm(i[0], 90 - i[1], e);
          }
          isSky() {
            return !0;
          }
          markSkyboxValid(a) {
            this._skyboxInvalidated = !1, this._lightPosition = a.style.light.properties.get("position");
          }
          hasOffscreenPass() {
            return !0;
          }
          getProgramIds() {
            const a = this.paint.get("sky-type");
            return a === "atmosphere" ? ["skyboxCapture", "skybox"] : a === "gradient" ? ["skyboxGradient"] : null;
          }
        }, slot: class extends rn {
          constructor(a, e, i, o) {
            super(a, { paint: S0 || (S0 = new vn({})) }, e, null);
          }
        }, model: class extends rn {
          constructor(a, e, i, o) {
            super(a, { layout: z0 || (z0 = new vn({ visibility: new Mr(Kt.layout_model.visibility), "model-id": new Nr(Kt.layout_model["model-id"]) })), paint: O0 || (O0 = new vn({ "model-opacity": new Nr(Kt.paint_model["model-opacity"]), "model-rotation": new Nr(Kt.paint_model["model-rotation"]), "model-scale": new Nr(Kt.paint_model["model-scale"]), "model-translation": new Nr(Kt.paint_model["model-translation"]), "model-color": new Nr(Kt.paint_model["model-color"]), "model-color-mix-intensity": new Nr(Kt.paint_model["model-color-mix-intensity"]), "model-type": new Mr(Kt.paint_model["model-type"]), "model-cast-shadows": new Mr(Kt.paint_model["model-cast-shadows"]), "model-receive-shadows": new Mr(Kt.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new Mr(Kt.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new Nr(Kt.paint_model["model-emissive-strength"]), "model-roughness": new Nr(Kt.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new Nr(Kt.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new Mr(Kt.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new Mr(Kt.paint_model["model-front-cutoff"]), "model-color-use-theme": new Nr({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, i, o), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
          }
          createBucket(a) {
            return new Lm(a);
          }
          getProgramIds() {
            return ["model"];
          }
          is3D() {
            return !0;
          }
          hasShadowPass() {
            return !0;
          }
          canCastShadows() {
            return !0;
          }
          hasLightBeamPass() {
            return !0;
          }
          cutoffRange() {
            return this.paint.get("model-cutoff-fade-range");
          }
          queryRadius(a) {
            return a instanceof Ip ? Br - 1 : 0;
          }
          queryIntersectsFeature(a, e, i, o, c, s) {
            if (!this.modelManager) return !1;
            const h = this.modelManager, y = a.tile.getBucket(this);
            if (!(y && y instanceof Lm)) return !1;
            for (const T in y.instancesPerModel) {
              const k = y.instancesPerModel[T], g = e.id !== void 0 ? e.id : e.properties && e.properties.hasOwnProperty("id") ? e.properties.id : void 0;
              if (k.idToFeaturesIndex.hasOwnProperty(g)) {
                const A = k.features[k.idToFeaturesIndex[g]], D = h.getModel(T, this.scope);
                if (!D) return !1;
                let S = Oe.mat4.create();
                const R = new qi(0, 0), j = y.canonical;
                let J = Number.MAX_VALUE;
                for (let ne = 0; ne < A.instancedDataCount; ++ne) {
                  const me = 16 * (A.instancedDataOffset + ne), ge = k.instancedDataArray.float32, ue = [ge[me + 4], ge[me + 5], ge[me + 6]];
                  V0(j, R, ge[me], 0 | ge[me + 1]), B0(S, D, s, R, A.rotation, A.scale, ue, !1, !1, !1), s.projection.name === "globe" && (S = Rm(S, s));
                  const Se = Oe.mat4.multiply([], s.projMatrix, S), ke = a.queryGeometry, He = P0(ke.isPointQuery() ? ke.screenBounds : ke.screenGeometry, s, Se, D.aabb);
                  He != null && (J = Math.min(He, J));
                }
                return J !== Number.MAX_VALUE && J;
              }
            }
            return !1;
          }
          _handleOverridablePaintPropertyUpdate(a, e, i) {
            return !(!this.layout || e.isDataDriven() || i.isDataDriven() || a !== "model-color" && a !== "model-color-mix-intensity" && a !== "model-rotation" && a !== "model-scale" && a !== "model-translation" && a !== "model-emissive-strength");
          }
          _isPropertyZoomDependent(a) {
            const e = this._transitionablePaint._values[a];
            return e != null && e.value != null && e.value.expression != null && e.value.expression instanceof kl;
          }
          isZoomDependent() {
            return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
          }
        }, clip: class extends rn {
          constructor(a, e, i, o) {
            super(a, { layout: xr || (xr = new vn({ "clip-layer-types": new Mr(Kt.layout_clip["clip-layer-types"]), "clip-layer-scope": new Mr(Kt.layout_clip["clip-layer-scope"]) })), paint: ai || (ai = new vn({})) }, e, i, o);
          }
          recalculate(a, e) {
            super.recalculate(a, e);
          }
          createBucket(a) {
            return new Gi(a);
          }
          isTileClipped() {
            return !0;
          }
          is3D() {
            return !0;
          }
        } };
        class Q1 {
          constructor(e) {
            this._callback = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
              this._triggered = !1, this._callback();
            }, 0));
          }
          remove() {
            this._channel = void 0, this._callback = () => {
            };
          }
        }
        class ex {
          constructor() {
            this.tasks = {}, this.taskQueue = [], Ur(["process"], this), this.invoker = new Q1(this.process), this.nextId = 0;
          }
          add(e, i) {
            const o = this.nextId++, c = function({ type: s, isSymbolTile: h, zoom: y }) {
              return y = y || 0, s === "message" ? 0 : s !== "maybePrepare" || h ? s !== "parseTile" || h ? s === "parseTile" && h ? 300 - y : s === "maybePrepare" && h ? 400 - y : 500 : 200 - y : 100 - y;
            }(i);
            if (c === 0) {
              try {
                e();
              } finally {
              }
              return null;
            }
            return this.tasks[o] = { fn: e, metadata: i, priority: c, id: o }, this.taskQueue.push(o), this.invoker.trigger(), { cancel: () => {
              delete this.tasks[o];
            } };
          }
          process() {
            try {
              if (this.taskQueue = this.taskQueue.filter((o) => !!this.tasks[o]), !this.taskQueue.length) return;
              const e = this.pick();
              if (e === null) return;
              const i = this.tasks[e];
              if (delete this.tasks[e], this.taskQueue.length && this.invoker.trigger(), !i) return;
              i.fn();
            } finally {
            }
          }
          pick() {
            let e = null, i = 1 / 0;
            for (let c = 0; c < this.taskQueue.length; c++) {
              const s = this.tasks[this.taskQueue[c]];
              s.priority < i && (i = s.priority, e = c);
            }
            if (e === null) return null;
            const o = this.taskQueue[e];
            return this.taskQueue.splice(e, 1), o;
          }
          remove() {
            this.invoker.remove();
          }
        }
        class G0 {
          constructor(e, i, o) {
            this.target = e, this.parent = i, this.mapId = o, this.callbacks = {}, this.cancelCallbacks = {}, Ur(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.scheduler = new ex();
          }
          send(e, i, o, c, s = !1, h) {
            const y = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            o && (o.metadata = h, this.callbacks[y] = o);
            const T = /* @__PURE__ */ new Set();
            return this.target.postMessage({ id: y, type: e, hasCallback: !!o, targetMapId: c, mustQueue: s, sourceMapId: this.mapId, data: Ra(i, T) }, T), { cancel: () => {
              o && delete this.callbacks[y], this.target.postMessage({ id: y, type: "<cancel>", targetMapId: c, sourceMapId: this.mapId });
            } };
          }
          receive(e) {
            const i = e.data, o = i.id;
            if (o && (!i.targetMapId || this.mapId === i.targetMapId)) if (i.type === "<cancel>") {
              const c = this.cancelCallbacks[o];
              delete this.cancelCallbacks[o], c && c.cancel();
            } else if (i.mustQueue || tr()) {
              const c = this.callbacks[o], s = this.scheduler.add(() => this.processTask(o, i), c && c.metadata || { type: "message" });
              s && (this.cancelCallbacks[o] = s);
            } else this.processTask(o, i);
          }
          processTask(e, i) {
            if (delete this.cancelCallbacks[e], i.type === "<response>") {
              const o = this.callbacks[e];
              delete this.callbacks[e], o && (i.error ? o(po(i.error)) : o(null, po(i.data)));
            } else {
              const o = /* @__PURE__ */ new Set(), c = i.hasCallback ? (h, y) => {
                this.target.postMessage({ id: e, type: "<response>", sourceMapId: this.mapId, error: h ? Ra(h) : null, data: Ra(y, o) }, o);
              } : () => {
              }, s = po(i.data);
              if (this.parent[i.type]) this.parent[i.type](i.sourceMapId, s, c);
              else if (this.parent.getWorkerSource) {
                const h = i.type.split(".");
                this.parent.getWorkerSource(i.sourceMapId, h[0], s.source, s.scope)[h[1]](s, c);
              } else c(new Error(`Could not find function ${i.type}`));
            }
          }
          remove() {
            this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
          }
        }
        var Fd = { workerUrl: "", workerClass: null, workerParams: void 0 };
        const Om = "mapboxgl_preloaded_worker_pool";
        class uf {
          constructor() {
            this.active = {};
          }
          acquire(e, i = uf.workerCount) {
            if (!this.workers) for (this.workers = []; this.workers.length < i; ) this.workers.push(Fd.workerClass != null ? new Fd.workerClass() : new self.Worker(Fd.workerUrl, Fd.workerParams));
            return this.active[e] = !0, this.workers.slice();
          }
          release(e) {
            delete this.active[e], this.workers && this.numActive() === 0 && (this.workers.forEach((i) => {
              i.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Om];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        uf.workerCount = 2;
        class Xf {
          constructor(e, i, o = "Worker", c = uf.workerCount) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = Fr();
            const s = this.workerPool.acquire(this.id, c);
            for (let h = 0; h < s.length; h++) {
              const y = new Xf.Actor(s[h], i, this.id);
              y.name = `${o} ${h}`, this.actors.push(y);
            }
            this.ready = !1, this.broadcast("checkIfReady", null, () => {
              this.ready = !0;
            });
          }
          broadcast(e, i, o) {
            Wt(this.actors, (c, s) => {
              c.send(e, i, s);
            }, o = o || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            this.actors.forEach((e) => {
              e.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }
        }
        let Nd, Bm;
        function Cp() {
          return Nd || (Nd = new uf()), Nd;
        }
        Xf.Actor = G0;
        const Fm = new Xi(0, 0, 0);
        var Nm = ((a) => (a[a.PATH_RULE_UNSPECIFIED = 0] = "PATH_RULE_UNSPECIFIED", a[a.PATH_RULE_NON_ZERO = 1] = "PATH_RULE_NON_ZERO", a[a.PATH_RULE_EVEN_ODD = 2] = "PATH_RULE_EVEN_ODD", a))(Nm || {}), Pp = ((a) => (a[a.LINE_CAP_UNSPECIFIED = 0] = "LINE_CAP_UNSPECIFIED", a[a.LINE_CAP_BUTT = 1] = "LINE_CAP_BUTT", a[a.LINE_CAP_ROUND = 2] = "LINE_CAP_ROUND", a[a.LINE_CAP_SQUARE = 3] = "LINE_CAP_SQUARE", a))(Pp || {}), Ud = ((a) => (a[a.LINE_JOIN_UNSPECIFIED = 0] = "LINE_JOIN_UNSPECIFIED", a[a.LINE_JOIN_MITER = 1] = "LINE_JOIN_MITER", a[a.LINE_JOIN_MITER_CLIP = 2] = "LINE_JOIN_MITER_CLIP", a[a.LINE_JOIN_ROUND = 3] = "LINE_JOIN_ROUND", a[a.LINE_JOIN_BEVEL = 4] = "LINE_JOIN_BEVEL", a))(Ud || {}), H0 = ((a) => (a[a.PAINT_ORDER_UNSPECIFIED = 0] = "PAINT_ORDER_UNSPECIFIED", a[a.PAINT_ORDER_FILL_AND_STROKE = 1] = "PAINT_ORDER_FILL_AND_STROKE", a[a.PAINT_ORDER_STROKE_AND_FILL = 2] = "PAINT_ORDER_STROKE_AND_FILL", a))(H0 || {}), Yf = ((a) => (a[a.PATH_COMMAND_UNSPECIFIED = 0] = "PATH_COMMAND_UNSPECIFIED", a[a.PATH_COMMAND_MOVE = 1] = "PATH_COMMAND_MOVE", a[a.PATH_COMMAND_LINE = 2] = "PATH_COMMAND_LINE", a[a.PATH_COMMAND_QUAD = 3] = "PATH_COMMAND_QUAD", a[a.PATH_COMMAND_CUBIC = 4] = "PATH_COMMAND_CUBIC", a[a.PATH_COMMAND_CLOSE = 5] = "PATH_COMMAND_CLOSE", a))(Yf || {}), W0 = ((a) => (a[a.MASK_TYPE_UNSPECIFIED = 0] = "MASK_TYPE_UNSPECIFIED", a[a.MASK_TYPE_LUMINANCE = 1] = "MASK_TYPE_LUMINANCE", a[a.MASK_TYPE_ALPHA = 2] = "MASK_TYPE_ALPHA", a))(W0 || {});
        function tx(a, e, i) {
          a === 1 && e.icons.push(function(o, c) {
            return function(s) {
              if (s.usvg_tree.height || (s.usvg_tree.height = s.usvg_tree.width), !s.metadata) return s;
              const { metadata: h } = s;
              if (h.content_area) {
                const { content_area: y } = h;
                y.top == null && (y.top = y.left), y.width == null && (y.width = s.usvg_tree.width), y.height == null && (y.height = y.width);
              }
              return h.stretch_x && h.stretch_x.length && Z0(h, "x"), h.stretch_y && h.stretch_y.length && Z0(h, "y"), s;
            }(o.readFields(rx, { name: void 0 }, c));
          }(i, i.readVarint() + i.pos));
        }
        function Z0(a, e) {
          const i = [], o = a[`stretch_${e}`];
          let c = null;
          for (let s = 0; s < o.length; s++) c === null ? c = i.length === 0 ? o[0] : i[i.length - 1][1] + o[s] : (i.push([c, c + o[s]]), c = null);
          a[`stretch_${e}_areas`] = i;
        }
        function rx(a, e, i) {
          a === 1 ? e.name = i.readString() : a === 2 ? e.metadata = function(o, c) {
            return o.readFields(ix, { stretch_x: null, stretch_y: null, stretch_x_areas: null, stretch_y_areas: null, variables: [] }, c);
          }(i, i.readVarint() + i.pos) : a === 3 && (e.usvg_tree = function(o, c) {
            return o.readFields(ox, { width: 20, children: [], linear_gradients: [], radial_gradients: [], clip_paths: [], masks: [] }, c);
          }(i, i.readVarint() + i.pos), e.data = "usvg_tree");
        }
        function ix(a, e, i) {
          a === 1 ? e.stretch_x = i.readPackedVarint() : a === 2 ? e.stretch_y = i.readPackedVarint() : a === 3 ? e.content_area = function(o, c) {
            return o.readFields(nx, { left: 0 }, c);
          }(i, i.readVarint() + i.pos) : a === 4 && e.variables.push(function(o, c) {
            return o.readFields(ax, { name: void 0 }, c);
          }(i, i.readVarint() + i.pos));
        }
        function nx(a, e, i) {
          a === 1 ? e.left = i.readVarint() : a === 2 ? e.width = i.readVarint() : a === 3 ? e.top = i.readVarint() : a === 4 && (e.height = i.readVarint());
        }
        function ax(a, e, i) {
          a === 1 ? e.name = i.readString() : a === 2 && (e.rgb_color = Dp(i.readVarint()), e.value = "rgb_color");
        }
        function ox(a, e, i) {
          a === 1 ? e.width = e.height = i.readVarint() : a === 2 ? e.height = i.readVarint() : a === 3 ? e.children.push(Rp(i, i.readVarint() + i.pos)) : a === 4 ? e.linear_gradients.push(function(o, c) {
            return o.readFields(dx, { spread_method: 1, stops: [], x1: 0, y1: 0, x2: 1, y2: 0 }, c);
          }(i, i.readVarint() + i.pos)) : a === 5 ? e.radial_gradients.push(function(o, c) {
            return o.readFields(mx, { spread_method: 1, stops: [], cx: 0.5, cy: 0.5, r: 0.5, fx: 0.5, fy: 0.5, fr: 0 }, c);
          }(i, i.readVarint() + i.pos)) : a === 7 ? e.clip_paths.push(function(o, c) {
            return o.readFields(_x, { children: [] }, c);
          }(i, i.readVarint() + i.pos)) : a === 8 && e.masks.push(function(o, c) {
            const s = o.readFields(gx, { left: 0, width: 20, mask_type: 1, children: [] }, c);
            return s.height == null && (s.height = s.width), s.top == null && (s.top = s.left), s;
          }(i, i.readVarint() + i.pos));
        }
        function Rp(a, e) {
          return a.readFields(sx, {}, e);
        }
        function sx(a, e, i) {
          a === 1 ? (e.group = function(o, c) {
            return o.readFields(lx, { opacity: 255, children: [] }, c);
          }(i, i.readVarint() + i.pos), e.node = "group") : a === 2 && (e.path = function(o, c) {
            return o.readFields(cx, { paint_order: 1, commands: [], step: 1, diffs: [], rule: 1 }, c);
          }(i, i.readVarint() + i.pos), e.node = "path");
        }
        function lx(a, e, i) {
          a === 1 ? e.transform = Lp(i, i.readVarint() + i.pos) : a === 2 ? e.opacity = i.readVarint() : a === 5 ? e.clip_path_idx = i.readVarint() : a === 6 ? e.mask_idx = i.readVarint() : a === 7 && e.children.push(Rp(i, i.readVarint() + i.pos));
        }
        function Lp(a, e) {
          return a.readFields(ux, { sx: 1, ky: 0, kx: 0, sy: 1, tx: 0, ty: 0 }, e);
        }
        function ux(a, e, i) {
          a === 1 ? e.sx = i.readFloat() : a === 2 ? e.ky = i.readFloat() : a === 3 ? e.kx = i.readFloat() : a === 4 ? e.sy = i.readFloat() : a === 5 ? e.tx = i.readFloat() : a === 6 && (e.ty = i.readFloat());
        }
        function cx(a, e, i) {
          a === 1 ? e.fill = function(o, c) {
            return o.readFields(hx, { rgb_color: Fm, paint: "rgb_color", opacity: 255 }, c);
          }(i, i.readVarint() + i.pos) : a === 2 ? e.stroke = function(o, c) {
            return o.readFields(fx, { rgb_color: Fm, paint: "rgb_color", dasharray: [], dashoffset: 0, miterlimit: 4, opacity: 255, width: 1, linecap: 1, linejoin: 1 }, c);
          }(i, i.readVarint() + i.pos) : a === 3 ? e.paint_order = i.readVarint() : a === 5 ? i.readPackedVarint(e.commands) : a === 6 ? e.step = i.readFloat() : a === 7 ? i.readPackedSVarint(e.diffs) : a === 8 && (e.rule = i.readVarint());
        }
        function hx(a, e, i) {
          a === 1 ? (e.rgb_color = Dp(i.readVarint()), e.paint = "rgb_color") : a === 2 ? (e.linear_gradient_idx = i.readVarint(), e.paint = "linear_gradient_idx") : a === 3 ? (e.radial_gradient_idx = i.readVarint(), e.paint = "radial_gradient_idx") : a === 5 && (e.opacity = i.readVarint());
        }
        function Dp(a) {
          return new Xi((a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (255 & a) / 255, 1);
        }
        function fx(a, e, i) {
          a === 1 ? (e.rgb_color = Dp(i.readVarint()), e.paint = "rgb_color") : a === 2 ? (e.linear_gradient_idx = i.readVarint(), e.paint = "linear_gradient_idx") : a === 3 ? (e.radial_gradient_idx = i.readVarint(), e.paint = "radial_gradient_idx") : a === 5 ? i.readPackedFloat(e.dasharray) : a === 6 ? e.dashoffset = i.readFloat() : a === 7 ? e.miterlimit = i.readFloat() : a === 8 ? e.opacity = i.readVarint() : a === 9 ? e.width = i.readFloat() : a === 10 ? e.linecap = i.readVarint() : a === 11 && (e.linejoin = i.readVarint());
        }
        function dx(a, e, i) {
          a === 1 ? e.transform = Lp(i, i.readVarint() + i.pos) : a === 2 ? e.spread_method = i.readVarint() : a === 3 ? e.stops.push(q0(i, i.readVarint() + i.pos)) : a === 4 ? e.x1 = i.readFloat() : a === 5 ? e.y1 = i.readFloat() : a === 6 ? e.x2 = i.readFloat() : a === 7 && (e.y2 = i.readFloat());
        }
        function q0(a, e) {
          return a.readFields(px, { offset: 0, opacity: 255, rgb_color: Fm }, e);
        }
        function px(a, e, i) {
          a === 1 ? e.offset = i.readFloat() : a === 2 ? e.opacity = i.readVarint() : a === 3 && (e.rgb_color = Dp(i.readVarint()));
        }
        function mx(a, e, i) {
          a === 1 ? e.transform = Lp(i, i.readVarint() + i.pos) : a === 2 ? e.spread_method = i.readVarint() : a === 3 ? e.stops.push(q0(i, i.readVarint() + i.pos)) : a === 4 ? e.cx = i.readFloat() : a === 5 ? e.cy = i.readFloat() : a === 6 ? e.r = i.readFloat() : a === 7 ? e.fx = i.readFloat() : a === 8 ? e.fy = i.readFloat() : a === 9 && (e.fr = i.readFloat());
        }
        function _x(a, e, i) {
          a === 1 ? e.transform = Lp(i, i.readVarint() + i.pos) : a === 2 ? e.clip_path_idx = i.readVarint() : a === 3 && e.children.push(Rp(i, i.readVarint() + i.pos));
        }
        function gx(a, e, i) {
          a === 1 ? e.left = e.top = i.readFloat() : a === 2 ? e.width = e.height = i.readFloat() : a === 3 ? e.top = i.readFloat() : a === 4 ? e.height = i.readFloat() : a === 5 ? e.mask_type = i.readVarint() : a === 6 ? e.mask_idx = i.readVarint() : a === 7 && e.children.push(Rp(i, i.readVarint() + i.pos));
        }
        class yx {
          static calculate(e, i) {
            const o = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
            if (Object.keys(e).length === 0) return o;
            i.forEach((s) => {
              c.set(s.name, s.rgb_color || new Xi(0, 0, 0));
            });
            for (const [s, h] of Object.entries(e)) c.has(s) ? o.set(c.get(s).toStringPremultipliedAlpha(), h) : console.warn(`Ignoring unknown image variable "${s}"`);
            return o;
          }
        }
        function Kf(a, e = 255, i) {
          const o = e / 255, c = a.toStringPremultipliedAlpha(), s = i.has(c) ? i.get(c).clone() : a.clone();
          return s.a = o, s.toString();
        }
        function jd(a, e) {
          if (!Ke()) {
            const i = document.createElement("canvas");
            return i.width = a, i.height = e, i;
          }
          return new OffscreenCanvas(a, e);
        }
        function vx(a, e) {
          const i = yx.calculate(e.params, a.metadata ? a.metadata.variables : []), o = a.usvg_tree, c = o.width, s = o.height, h = e.transform ? e.transform : new DOMMatrix(), y = Math.max(1, Math.round(c * h.a)), T = Math.max(1, Math.round(s * h.d)), k = new DOMMatrix([y / c, 0, 0, T / s, 0, 0]), g = jd(y, T).getContext("2d");
          return Um(g, k, o, o, i), g.getImageData(0, 0, y, T);
        }
        function Um(a, e, i, o, c) {
          for (const s of o.children) $0(a, e, i, s, c);
        }
        function $0(a, e, i, o, c) {
          o.group ? (a.save(), function(s, h, y, T, k) {
            const g = T.mask_idx != null ? y.masks[T.mask_idx] : null, A = T.clip_path_idx != null ? y.clip_paths[T.clip_path_idx] : null;
            if (T.transform && (h = kp(T.transform).preMultiplySelf(h)), !function(R, j, J) {
              return R.opacity !== 255 || j || J;
            }(T, A != null, g != null)) return void Um(s, h, y, T, k);
            const D = jd(s.canvas.width, s.canvas.height), S = D.getContext("2d");
            Um(S, h, y, T, k), A && ty(S, h, y, A), g && ry(S, h, y, g, k), s.globalAlpha = T.opacity / 255, s.drawImage(D, 0, 0);
          }(a, e, i, o.group, c), a.restore()) : o.path && (a.save(), function(s, h, y, T, k) {
            const g = iy(T);
            s.setTransform(h), T.paint_order === H0.PAINT_ORDER_FILL_AND_STROKE ? (X0(s, y, T, g, k), K0(s, y, T, g, k)) : (K0(s, y, T, g, k), X0(s, y, T, g, k));
          }(a, e, i, o.path, c), a.restore());
        }
        function X0(a, e, i, o, c) {
          const s = i.fill;
          if (!s) return;
          const h = s.opacity / 255;
          switch (s.paint) {
            case "rgb_color":
              a.fillStyle = Kf(s.rgb_color, s.opacity, c);
              break;
            case "linear_gradient_idx":
              a.fillStyle = J0(a, e.linear_gradients[s.linear_gradient_idx], h, c);
              break;
            case "radial_gradient_idx":
              a.fillStyle = Q0(a, e.radial_gradients[s.radial_gradient_idx], h, c);
          }
          a.fill(o, Y0(i));
        }
        function Y0(a) {
          return a.rule === Nm.PATH_RULE_NON_ZERO ? "nonzero" : a.rule === Nm.PATH_RULE_EVEN_ODD ? "evenodd" : void 0;
        }
        function K0(a, e, i, o, c) {
          const s = i.stroke;
          if (!s) return;
          a.lineWidth = s.width, a.miterLimit = s.miterlimit, a.setLineDash(s.dasharray), a.lineDashOffset = s.dashoffset;
          const h = s.opacity / 255;
          switch (s.paint) {
            case "rgb_color":
              a.strokeStyle = Kf(s.rgb_color, s.opacity, c);
              break;
            case "linear_gradient_idx":
              a.strokeStyle = J0(a, e.linear_gradients[s.linear_gradient_idx], h, c);
              break;
            case "radial_gradient_idx":
              a.strokeStyle = Q0(a, e.radial_gradients[s.radial_gradient_idx], h, c);
          }
          switch (s.linejoin) {
            case Ud.LINE_JOIN_MITER_CLIP:
            case Ud.LINE_JOIN_MITER:
              a.lineJoin = "miter";
              break;
            case Ud.LINE_JOIN_ROUND:
              a.lineJoin = "round";
              break;
            case Ud.LINE_JOIN_BEVEL:
              a.lineJoin = "bevel";
          }
          switch (s.linecap) {
            case Pp.LINE_CAP_BUTT:
              a.lineCap = "butt";
              break;
            case Pp.LINE_CAP_ROUND:
              a.lineCap = "round";
              break;
            case Pp.LINE_CAP_SQUARE:
              a.lineCap = "square";
          }
          a.stroke(o);
        }
        function J0(a, e, i, o) {
          if (e.stops.length === 1) {
            const D = e.stops[0];
            return Kf(D.rgb_color, D.opacity * i, o);
          }
          const c = kp(e.transform), { x1: s, y1: h, x2: y, y2: T } = e, k = c.transformPoint(new DOMPoint(s, h)), g = c.transformPoint(new DOMPoint(y, T)), A = a.createLinearGradient(k.x, k.y, g.x, g.y);
          for (const D of e.stops) A.addColorStop(D.offset, Kf(D.rgb_color, D.opacity * i, o));
          return A;
        }
        function Q0(a, e, i, o) {
          if (e.stops.length === 1) {
            const D = e.stops[0];
            return Kf(D.rgb_color, D.opacity * i, o);
          }
          const c = kp(e.transform), { fx: s, fy: h, cx: y, cy: T } = e, k = c.transformPoint(new DOMPoint(s, h)), g = c.transformPoint(new DOMPoint(y, T)), A = a.createRadialGradient(k.x, k.y, 0, g.x, g.y, e.r * ((c.a + c.d) / 2));
          for (const D of e.stops) A.addColorStop(D.offset, Kf(D.rgb_color, D.opacity * i, o));
          return A;
        }
        function ey(a, e, i, o) {
          const c = o.transform ? kp(o.transform).preMultiplySelf(e) : e, s = jd(a.canvas.width, a.canvas.height), h = s.getContext("2d");
          for (const T of o.children) if (T.group) ey(h, c, i, T.group);
          else if (T.path) {
            const k = T.path, g = new Path2D();
            g.addPath(iy(k), c), h.fill(g, Y0(k));
          }
          const y = o.clip_path_idx != null ? i.clip_paths[o.clip_path_idx] : null;
          y && ty(h, c, i, y), a.globalCompositeOperation = "source-over", a.drawImage(s, 0, 0);
        }
        function ty(a, e, i, o) {
          const c = jd(a.canvas.width, a.canvas.height);
          ey(c.getContext("2d"), e, i, o), a.globalCompositeOperation = "destination-in", a.drawImage(c, 0, 0);
        }
        function ry(a, e, i, o, c) {
          if (o.children.length === 0) return;
          const s = o.mask_idx != null ? i.masks[o.mask_idx] : null;
          s && ry(a, e, i, s, c);
          const h = a.canvas.width, y = a.canvas.height, T = jd(h, y), k = T.getContext("2d"), g = o.width, A = o.height, D = o.left, S = o.top, R = new Path2D(), j = new Path2D();
          j.rect(D, S, g, A), R.addPath(j, e), k.clip(R);
          for (const me of o.children) $0(k, e, i, me, c);
          const J = k.getImageData(0, 0, h, y), ne = J.data;
          if (o.mask_type === W0.MASK_TYPE_LUMINANCE) for (let me = 0; me < ne.length; me += 4) ne[me + 3] = ne[me + 3] / 255 * (0.2126 * ne[me] + 0.7152 * ne[me + 1] + 0.0722 * ne[me + 2]);
          k.putImageData(J, 0, 0), a.globalCompositeOperation = "destination-in", a.drawImage(T, 0, 0);
        }
        function kp(a) {
          return a ? new DOMMatrix([a.sx, a.ky, a.kx, a.sy, a.tx, a.ty]) : new DOMMatrix();
        }
        function iy(a) {
          const e = new Path2D(), i = a.step;
          let o = a.diffs[0] * i, c = a.diffs[1] * i;
          e.moveTo(o, c);
          for (let s = 0, h = 2; s < a.commands.length; s++) switch (a.commands[s]) {
            case Yf.PATH_COMMAND_MOVE:
              o += a.diffs[h++] * i, c += a.diffs[h++] * i, e.moveTo(o, c);
              break;
            case Yf.PATH_COMMAND_LINE:
              o += a.diffs[h++] * i, c += a.diffs[h++] * i, e.lineTo(o, c);
              break;
            case Yf.PATH_COMMAND_QUAD: {
              const y = o + a.diffs[h++] * i, T = c + a.diffs[h++] * i;
              o = y + a.diffs[h++] * i, c = T + a.diffs[h++] * i, e.quadraticCurveTo(y, T, o, c);
              break;
            }
            case Yf.PATH_COMMAND_CUBIC: {
              const y = o + a.diffs[h++] * i, T = c + a.diffs[h++] * i, k = y + a.diffs[h++] * i, g = T + a.diffs[h++] * i;
              o = k + a.diffs[h++] * i, c = g + a.diffs[h++] * i, e.bezierCurveTo(y, T, k, g, o, c);
              break;
            }
            case Yf.PATH_COMMAND_CLOSE:
              e.closePath();
          }
          return e;
        }
        class jm {
          constructor(e) {
            this.capacity = e, this.cache = /* @__PURE__ */ new Map();
          }
          get(e) {
            if (!this.cache.has(e)) return;
            const i = this.cache.get(e);
            return this.cache.delete(e), this.cache.set(e, i), i;
          }
          put(e, i) {
            this.cache.has(e) ? this.cache.delete(e) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(e, i);
          }
          delete(e) {
            this.cache.delete(e);
          }
        }
        class Vm {
          constructor() {
            this.cacheMap = /* @__PURE__ */ new Map(), this.cacheDependenciesMap = /* @__PURE__ */ new Map();
          }
          static _getImage(e) {
            return new Ea(e, e.data);
          }
          getFromCache(e, i, o) {
            return this.cacheMap.has(o) || this.cacheMap.set(o, new jm(150)), this.cacheMap.get(o).get(Va(e.serialize(), i));
          }
          setInCache(e, i, o, c) {
            this.cacheDependenciesMap.has(c) || this.cacheDependenciesMap.set(c, /* @__PURE__ */ new Map()), this.cacheMap.has(c) || this.cacheMap.set(c, new jm(150));
            const s = this.cacheDependenciesMap.get(c);
            s.get(Va(e.id, o)) || s.set(Va(e.id, o), /* @__PURE__ */ new Set());
            const h = this.cacheMap.get(c), y = e.serialize();
            s.get(Va(e.id, o)).add(y), h.put(Va(e.serialize(), o), i);
          }
          removeImagesFromCacheByIds(e, i, o = "") {
            if (!this.cacheMap.has(o) || !this.cacheDependenciesMap.has(o)) return;
            const c = this.cacheMap.get(o), s = this.cacheDependenciesMap.get(o);
            for (const h of e) if (s.has(Va(h, i))) {
              for (const y of s.get(Va(h, i))) c.delete(y);
              s.delete(Va(h, i));
            }
          }
          rasterize(e, i, o, c, s = vx) {
            const h = this.getFromCache(e, o, c);
            if (h) return h.clone();
            const y = s(i.icon, e.options), T = Vm._getImage(y);
            return this.setInCache(e, T, o, c), T.clone();
          }
        }
        class ny {
          constructor(e) {
            this.size = e, this.minimums = [], this.maximums = [], this.leaves = [];
          }
          getElevation(e, i) {
            const o = this.toIdx(e, i);
            return { min: this.minimums[o], max: this.maximums[o] };
          }
          isLeaf(e, i) {
            return this.leaves[this.toIdx(e, i)];
          }
          toIdx(e, i) {
            return i * this.size + e;
          }
        }
        function ay(a, e, i, o) {
          let c = 0, s = Number.MAX_VALUE;
          for (let h = 0; h < 3; h++) if (Math.abs(o[h]) < 1e-15) {
            if (i[h] < a[h] || i[h] > e[h]) return null;
          } else {
            const y = 1 / o[h];
            let T = (a[h] - i[h]) * y, k = (e[h] - i[h]) * y;
            if (T > k) {
              const g = T;
              T = k, k = g;
            }
            if (T > c && (c = T), k < s && (s = k), c > s) return null;
          }
          return c;
        }
        function oy(a, e, i, o, c, s, h, y, T, k, g) {
          const A = o - a, D = c - e, S = s - i, R = h - a, j = y - e, J = T - i, ne = g[1] * J - g[2] * j, me = g[2] * R - g[0] * J, ge = g[0] * j - g[1] * R, ue = A * ne + D * me + S * ge;
          if (Math.abs(ue) < 1e-15) return null;
          const Se = 1 / ue, ke = k[0] - a, He = k[1] - e, at = k[2] - i, nt = (ke * ne + He * me + at * ge) * Se;
          if (nt < 0 || nt > 1) return null;
          const tt = He * S - at * D, Et = at * A - ke * S, lt = ke * D - He * A, St = (g[0] * tt + g[1] * Et + g[2] * lt) * Se;
          return St < 0 || nt + St > 1 ? null : (R * tt + j * Et + J * lt) * Se;
        }
        function sy(a, e, i) {
          return (a - e) / (i - e);
        }
        function ly(a, e, i, o, c, s, h, y, T) {
          const k = 1 << i, g = s - o, A = h - c, D = (a + 1) / k * g + o, S = (e + 0) / k * A + c, R = (e + 1) / k * A + c;
          y[0] = (a + 0) / k * g + o, y[1] = S, T[0] = D, T[1] = R;
        }
        class uy {
          constructor(e) {
            if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = e, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;
            const i = function(s) {
              const h = Math.ceil(Math.log2(s.dim / 8)), y = [];
              let T = Math.ceil(Math.pow(2, h));
              const k = 1 / T, g = (S, R, j, J, ne) => {
                const me = J ? 1 : 0, ge = (S + 1) * j - me, ue = R * j, Se = (R + 1) * j - me;
                ne[0] = S * j, ne[1] = ue, ne[2] = ge, ne[3] = Se;
              };
              let A = new ny(T);
              const D = [];
              for (let S = 0; S < T * T; S++) {
                g(S % T, Math.floor(S / T), k, !1, D);
                const R = bh(D[0], D[1], s), j = bh(D[2], D[1], s), J = bh(D[2], D[3], s), ne = bh(D[0], D[3], s);
                A.minimums.push(Math.min(R, j, J, ne)), A.maximums.push(Math.max(R, j, J, ne)), A.leaves.push(1);
              }
              for (y.push(A), T /= 2; T >= 1; T /= 2) {
                const S = y[y.length - 1];
                A = new ny(T);
                for (let R = 0; R < T * T; R++) {
                  g(R % T, Math.floor(R / T), 2, !0, D);
                  const j = S.getElevation(D[0], D[1]), J = S.getElevation(D[2], D[1]), ne = S.getElevation(D[2], D[3]), me = S.getElevation(D[0], D[3]), ge = S.isLeaf(D[0], D[1]), ue = S.isLeaf(D[2], D[1]), Se = S.isLeaf(D[2], D[3]), ke = S.isLeaf(D[0], D[3]), He = Math.min(j.min, J.min, ne.min, me.min), at = Math.max(j.max, J.max, ne.max, me.max), nt = ge && ue && Se && ke;
                  A.maximums.push(at), A.minimums.push(He), A.leaves.push(at - He <= 5 && nt ? 1 : 0);
                }
                y.push(A);
              }
              return y;
            }(this.dem), o = i.length - 1, c = i[o];
            this._addNode(c.minimums[0], c.maximums[0], c.leaves[0]), this._construct(i, 0, 0, o, 0);
          }
          raycastRoot(e, i, o, c, s, h, y = 1) {
            return ay([e, i, -100], [o, c, this.maximums[0] * y], s, h);
          }
          raycast(e, i, o, c, s, h, y = 1) {
            if (!this.nodeCount) return null;
            const T = this.raycastRoot(e, i, o, c, s, h, y);
            if (T == null) return null;
            const k = [], g = [], A = [], D = [], S = [{ idx: 0, t: T, nodex: 0, nodey: 0, depth: 0 }];
            for (; S.length > 0; ) {
              const { idx: R, t: j, nodex: J, nodey: ne, depth: me } = S.pop();
              if (this.leaves[R]) {
                ly(J, ne, me, e, i, o, c, A, D);
                const ue = 1 << me, Se = (J + 0) / ue, ke = (J + 1) / ue, He = (ne + 0) / ue, at = (ne + 1) / ue, nt = bh(Se, He, this.dem) * y, tt = bh(ke, He, this.dem) * y, Et = bh(ke, at, this.dem) * y, lt = bh(Se, at, this.dem) * y, St = oy(A[0], A[1], nt, D[0], A[1], tt, D[0], D[1], Et, s, h), Lt = oy(D[0], D[1], Et, A[0], D[1], lt, A[0], A[1], nt, s, h), It = Math.min(St !== null ? St : Number.MAX_VALUE, Lt !== null ? Lt : Number.MAX_VALUE);
                if (It !== Number.MAX_VALUE) return It;
                {
                  const zt = Oe.vec3.scaleAndAdd([], s, h, j);
                  if (cy(nt, tt, lt, Et, sy(zt[0], A[0], D[0]), sy(zt[1], A[1], D[1])) >= zt[2]) return j;
                }
                continue;
              }
              let ge = 0;
              for (let ue = 0; ue < this._siblingOffset.length; ue++) {
                ly((J << 1) + this._siblingOffset[ue][0], (ne << 1) + this._siblingOffset[ue][1], me + 1, e, i, o, c, A, D), A[2] = -100, D[2] = this.maximums[this.childOffsets[R] + ue] * y;
                const Se = ay(A, D, s, h);
                if (Se != null) {
                  const ke = Se;
                  k[ue] = ke;
                  let He = !1;
                  for (let at = 0; at < ge && !He; at++) ke >= k[g[at]] && (g.splice(at, 0, ue), He = !0);
                  He || (g[ge] = ue), ge++;
                }
              }
              for (let ue = 0; ue < ge; ue++) {
                const Se = g[ue];
                S.push({ idx: this.childOffsets[R] + Se, t: k[Se], nodex: (J << 1) + this._siblingOffset[Se][0], nodey: (ne << 1) + this._siblingOffset[Se][1], depth: me + 1 });
              }
            }
            return null;
          }
          _addNode(e, i, o) {
            return this.minimums.push(e), this.maximums.push(i), this.leaves.push(o), this.childOffsets.push(0), this.nodeCount++;
          }
          _construct(e, i, o, c, s) {
            if (e[c].isLeaf(i, o) === 1) return;
            this.childOffsets[s] || (this.childOffsets[s] = this.nodeCount);
            const h = c - 1, y = e[h];
            let T = 0, k = 0;
            for (let g = 0; g < this._siblingOffset.length; g++) {
              const A = 2 * i + this._siblingOffset[g][0], D = 2 * o + this._siblingOffset[g][1], S = y.getElevation(A, D), R = y.isLeaf(A, D), j = this._addNode(S.min, S.max, R);
              R && (T |= 1 << g), k || (k = j);
            }
            for (let g = 0; g < this._siblingOffset.length; g++) T & 1 << g || this._construct(e, 2 * i + this._siblingOffset[g][0], 2 * o + this._siblingOffset[g][1], h, k + g);
          }
        }
        function cy(a, e, i, o, c, s) {
          return li(li(a, i, s), li(e, o, s), c);
        }
        function bh(a, e, i) {
          const o = i.dim, c = ie(a * o - 0.5, 0, o - 1), s = ie(e * o - 0.5, 0, o - 1), h = Math.floor(c), y = Math.floor(s), T = Math.min(h + 1, o - 1), k = Math.min(y + 1, o - 1);
          return cy(i.get(h, y), i.get(T, y), i.get(h, k), i.get(T, k), c - h, s - y);
        }
        const xx = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
        function bx(a, e, i) {
          return (256 * a * 256 + 256 * e + i) / 10 - 1e4;
        }
        function wx(a, e, i) {
          return 256 * a + e + i / 256 - 32768;
        }
        class zp {
          get tree() {
            return this._tree || this._buildQuadTree(), this._tree;
          }
          constructor(e, i, o, c = !1) {
            if (this.uid = e, i.height !== i.width) throw new RangeError("DEM tiles must be square");
            if (o && o !== "mapbox" && o !== "terrarium") return void Tt(`"${o}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            this.stride = i.height;
            const s = this.dim = i.height - 2, h = new Uint32Array(i.data.buffer);
            if (this.pixels = new Uint8Array(i.data.buffer), this.floatView = new Float32Array(i.data.buffer), this.borderReady = c, this._modifiedForSources = {}, !c) {
              for (let T = 0; T < s; T++) h[this._idx(-1, T)] = h[this._idx(0, T)], h[this._idx(s, T)] = h[this._idx(s - 1, T)], h[this._idx(T, -1)] = h[this._idx(T, 0)], h[this._idx(T, s)] = h[this._idx(T, s - 1)];
              h[this._idx(-1, -1)] = h[this._idx(0, 0)], h[this._idx(s, -1)] = h[this._idx(s - 1, 0)], h[this._idx(-1, s)] = h[this._idx(0, s - 1)], h[this._idx(s, s)] = h[this._idx(s - 1, s - 1)];
            }
            const y = o === "terrarium" ? wx : bx;
            for (let T = 0; T < h.length; ++T) {
              const k = 4 * T;
              this.floatView[T] = y(this.pixels[k], this.pixels[k + 1], this.pixels[k + 2]);
            }
            this._timestamp = ht.now();
          }
          _buildQuadTree() {
            this._tree = new uy(this);
          }
          get(e, i, o = !1) {
            o && (e = ie(e, -1, this.dim), i = ie(i, -1, this.dim));
            const c = this._idx(e, i);
            return this.floatView[c];
          }
          set(e, i, o) {
            const c = this._idx(e, i), s = this.floatView[c];
            return this.floatView[c] = o, o - s;
          }
          static getUnpackVector(e) {
            return xx[e];
          }
          _idx(e, i) {
            if (e < -1 || e >= this.dim + 1 || i < -1 || i >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (i + 1) * this.stride + (e + 1);
          }
          static pack(e, i) {
            const o = [0, 0, 0, 0], c = zp.getUnpackVector(i);
            let s = Math.floor((e + c[3]) / c[2]);
            return o[2] = s % 256, s = Math.floor(s / 256), o[1] = s % 256, s = Math.floor(s / 256), o[0] = s, o;
          }
          getPixels() {
            return new yd({ width: this.stride, height: this.stride }, this.pixels);
          }
          backfillBorder(e, i, o) {
            if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
            let c = i * this.dim, s = i * this.dim + this.dim, h = o * this.dim, y = o * this.dim + this.dim;
            switch (i) {
              case -1:
                c = s - 1;
                break;
              case 1:
                s = c + 1;
            }
            switch (o) {
              case -1:
                h = y - 1;
                break;
              case 1:
                y = h + 1;
            }
            const T = -i * this.dim, k = -o * this.dim;
            for (let g = h; g < y; g++) for (let A = c; A < s; A++) {
              const D = 4 * this._idx(A, g), S = 4 * this._idx(A + T, g + k);
              this.pixels[D + 0] = e.pixels[S + 0], this.pixels[D + 1] = e.pixels[S + 1], this.pixels[D + 2] = e.pixels[S + 2], this.pixels[D + 3] = e.pixels[S + 3];
            }
          }
          onDeserialize() {
            this._tree && (this._tree.dem = this);
          }
        }
        function Ex(a, e, i) {
          a === 1 ? e.headerLength = i.readFixed32() : a === 2 ? e.x = i.readVarint() : a === 3 ? e.y = i.readVarint() : a === 4 ? e.z = i.readVarint() : a === 5 && e.layers.push(function(o, c) {
            return o.readFields(Ix, { version: 0, name: "", units: "", tileSize: 0, buffer: 0, pixelFormat: 0, dataIndex: [] }, c);
          }(i, i.readVarint() + i.pos));
        }
        function Sx(a, e, i) {
          a === 1 ? (e.delta_filter = function(o, c) {
            return o.readFields(Tx, { blockSize: 0 }, c);
          }(i, i.readVarint() + i.pos), e.filter = "delta_filter") : a === 2 ? (i.readVarint(), e.filter = "zigzag_filter") : a === 3 ? (i.readVarint(), e.filter = "bitshuffle_filter") : a === 4 && (i.readVarint(), e.filter = "byteshuffle_filter");
        }
        function Tx(a, e, i) {
          a === 1 && (e.blockSize = i.readVarint());
        }
        function Mx(a, e, i) {
          a === 1 ? (i.readVarint(), e.codec = "gzip_data") : a === 2 ? (i.readVarint(), e.codec = "jpeg_image") : a === 3 ? (i.readVarint(), e.codec = "webp_image") : a === 4 && (i.readVarint(), e.codec = "png_image");
        }
        function Ax(a, e, i) {
          let o = 0, c = 0;
          a === 1 ? e.firstByte = i.readFixed64() : a === 2 ? e.lastByte = i.readFixed64() : a === 3 ? e.filters.push(function(s, h) {
            return s.readFields(Sx, {}, h);
          }(i, i.readVarint() + i.pos)) : a === 4 ? e.codec = function(s, h) {
            return s.readFields(Mx, {}, h);
          }(i, i.readVarint() + i.pos) : a === 5 ? c = i.readFloat() : a === 6 ? o = i.readFloat() : a === 7 ? e.bands.push(i.readString()) : a === 8 ? e.offset = i.readDouble() : a === 9 && (e.scale = i.readDouble()), e.offset === 0 && (e.offset = c), e.scale === 0 && (e.scale = o);
        }
        function Ix(a, e, i) {
          a === 1 ? e.version = i.readVarint() : a === 2 ? e.name = i.readString() : a === 3 ? e.units = i.readString() : a === 4 ? e.tileSize = i.readVarint() : a === 5 ? e.buffer = i.readVarint() : a === 6 ? e.pixelFormat = i.readVarint() : a === 7 && e.dataIndex.push(function(o, c) {
            return o.readFields(Ax, { firstByte: 0, lastByte: 0, filters: [], codec: null, offset: 0, scale: 0, bands: [] }, c);
          }(i, i.readVarint() + i.pos));
        }
        function Cx(a, e, i) {
          if (a === 2) (function(o, c, s) {
            o.readFields(Px, s, c);
          })(i, i.readVarint() + i.pos, e);
          else if (a === 3) throw new Error("Not implemented");
        }
        function Px(a, e, i) {
          if (a === 1) {
            let o = 0;
            const c = i.readVarint() + i.pos;
            for (; i.pos < c; ) e[o++] = i.readVarint();
          }
        }
        function Rx(a, e) {
          if (e.length !== 4) throw new Error(`Expected data of dimension 4 but got ${e.length}.`);
          let i = e[3];
          for (let o = 2; o >= 1; o--) {
            const c = o === 1 ? 1 : 0, s = o === 2 ? 1 : 0;
            for (let h = 0; h < e[0]; h++) {
              const y = e[1] * h;
              for (let T = c; T < e[1]; T++) {
                const k = e[2] * (T + y);
                for (let g = s; g < e[2]; g++) {
                  const A = e[3] * (g + k);
                  for (let D = 0; D < e[3]; D++) {
                    const S = A + D;
                    a[S] += a[S - i];
                  }
                }
              }
            }
            i *= e[o];
          }
          return a;
        }
        function Lx(a) {
          for (let e = 0, i = a.length; e < i; e++) a[e] = a[e] >>> 1 ^ -(1 & a[e]);
          return a;
        }
        function Dx(a, e) {
          switch (e) {
            case "uint32":
              return a;
            case "uint16":
              for (let i = 0; i < a.length; i += 2) {
                const o = a[i], c = a[i + 1];
                a[i] = (240 & o) >> 4 | (61440 & o) >> 8 | (240 & c) << 4 | 61440 & c, a[i + 1] = 15 & o | (3840 & o) >> 4 | (15 & c) << 8 | (3840 & c) << 4;
              }
              return a;
            case "uint8":
              for (let i = 0; i < a.length; i += 4) {
                const o = a[i], c = a[i + 1], s = a[i + 2], h = a[i + 3];
                a[i + 0] = (192 & o) >> 6 | (192 & c) >> 4 | (192 & s) >> 2 | 192 & h, a[i + 1] = (48 & o) >> 4 | (48 & c) >> 2 | 48 & s | (48 & h) << 2, a[i + 2] = (12 & o) >> 2 | 12 & c | (12 & s) << 2 | (12 & h) << 4, a[i + 3] = 3 & o | (3 & c) << 2 | (3 & s) << 4 | (3 & h) << 6;
              }
              return a;
            default:
              throw new Error(`Invalid pixel format, "${e}"`);
          }
        }
        Gr(zp, "DEMData"), Gr(uy, "DemMinMaxQuadTree", { omit: ["dem"] });
        var zs = Uint8Array, Vd = Uint16Array, kx = Int32Array, hy = new zs([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), fy = new zs([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), zx = new zs([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), dy = function(a, e) {
          for (var i = new Vd(31), o = 0; o < 31; ++o) i[o] = e += 1 << a[o - 1];
          var c = new kx(i[30]);
          for (o = 1; o < 30; ++o) for (var s = i[o]; s < i[o + 1]; ++s) c[s] = s - i[o] << 5 | o;
          return { b: i, r: c };
        }, py = dy(hy, 2), my = py.b, Ox = py.r;
        my[28] = 258, Ox[258] = 28;
        for (var Bx = dy(fy, 0).b, _y = new Vd(32768), aa = 0; aa < 32768; ++aa) {
          var Jf = (43690 & aa) >> 1 | (21845 & aa) << 1;
          _y[aa] = ((65280 & (Jf = (61680 & (Jf = (52428 & Jf) >> 2 | (13107 & Jf) << 2)) >> 4 | (3855 & Jf) << 4)) >> 8 | (255 & Jf) << 8) >> 1;
        }
        var Gd = function(a, e, i) {
          for (var o = a.length, c = 0, s = new Vd(e); c < o; ++c) a[c] && ++s[a[c] - 1];
          var h, y = new Vd(e);
          for (c = 1; c < e; ++c) y[c] = y[c - 1] + s[c - 1] << 1;
          h = new Vd(1 << e);
          var T = 15 - e;
          for (c = 0; c < o; ++c) if (a[c]) for (var k = c << 4 | a[c], g = e - a[c], A = y[a[c] - 1]++ << g, D = A | (1 << g) - 1; A <= D; ++A) h[_y[A] >> T] = k;
          return h;
        }, Hd = new zs(288);
        for (aa = 0; aa < 144; ++aa) Hd[aa] = 8;
        for (aa = 144; aa < 256; ++aa) Hd[aa] = 9;
        for (aa = 256; aa < 280; ++aa) Hd[aa] = 7;
        for (aa = 280; aa < 288; ++aa) Hd[aa] = 8;
        var gy = new zs(32);
        for (aa = 0; aa < 32; ++aa) gy[aa] = 5;
        var Fx = Gd(Hd, 9), Nx = Gd(gy, 5), Gm = function(a) {
          for (var e = a[0], i = 1; i < a.length; ++i) a[i] > e && (e = a[i]);
          return e;
        }, ru = function(a, e, i) {
          var o = e / 8 | 0;
          return (a[o] | a[o + 1] << 8) >> (7 & e) & i;
        }, Hm = function(a, e) {
          var i = e / 8 | 0;
          return (a[i] | a[i + 1] << 8 | a[i + 2] << 16) >> (7 & e);
        }, Ux = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], iu = function(a, e, i) {
          var o = new Error(e || Ux[a]);
          if (o.code = a, Error.captureStackTrace && Error.captureStackTrace(o, iu), !i) throw o;
          return o;
        }, jx = new zs(0), Vx = typeof TextDecoder < "u" && new TextDecoder();
        try {
          Vx.decode(jx, { stream: !0 });
        } catch {
        }
        const Gx = { gzip_data: "gzip" };
        class pl extends Error {
          constructor(e) {
            super(e), this.name = "MRTError";
          }
        }
        const Hx = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, yy = { uint32: 1, uint16: 2, uint8: 4 }, Wx = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
        let Wm;
        class Zm {
          constructor(e = 5) {
            this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = e;
          }
          getLayer(e) {
            const i = this.layers[e];
            if (!i) throw new pl(`Layer '${e}' not found`);
            return i;
          }
          getHeaderLength(e) {
            const i = new Uint8Array(e), o = new DataView(e);
            if (i[0] !== 13) throw new pl("File is not a valid MRT.");
            return o.getUint32(1, !0);
          }
          parseHeader(e) {
            const i = new Uint8Array(e), o = this.getHeaderLength(e);
            if (i.length < o) throw new pl(`Expected header with length >= ${o} but got buffer of length ${i.length}`);
            const c = function(s, h) {
              return s.readFields(Ex, { headerLength: 0, x: 0, y: 0, z: 0, layers: [] }, void 0);
            }(new Wm(i.subarray(0, o)));
            if (!isNaN(this.x) && (this.x !== c.x || this.y !== c.y || this.z !== c.z)) throw new pl(`Invalid attempt to parse header ${c.z}/${c.x}/${c.y} for tile ${this.z}/${this.x}/${this.y}`);
            this.x = c.x, this.y = c.y, this.z = c.z;
            for (const s of c.layers) this.layers[s.name] = new Zx(s, { cacheSize: this._cacheSize });
            return this;
          }
          createDecodingTask(e) {
            const i = [], o = this.getLayer(e.layerName);
            for (let c of e.blockIndices) {
              const s = o.dataIndex[c], h = s.firstByte - e.firstByte, y = s.lastByte - e.firstByte;
              if (o._blocksInProgress.has(c)) continue;
              const T = { layerName: o.name, firstByte: h, lastByte: y, pixelFormat: o.pixelFormat, blockIndex: c, blockShape: [s.bands.length].concat(o.bandShape), buffer: o.buffer, codec: s.codec.codec, filters: s.filters.map((k) => k.filter) };
              o._blocksInProgress.add(c), i.push(T);
            }
            return new vy(i, () => {
              i.forEach((c) => o._blocksInProgress.delete(c.blockIndex));
            }, (c, s) => {
              if (i.forEach((h) => o._blocksInProgress.delete(h.blockIndex)), c) throw c;
              s.forEach((h) => {
                this.getLayer(h.layerName).processDecodedData(h);
              });
            });
          }
        }
        class Zx {
          constructor({ version: e, name: i, units: o, tileSize: c, pixelFormat: s, buffer: h, dataIndex: y }, T) {
            if (this.version = e, this.version !== 1) throw new pl(`Cannot parse raster layer encoded with MRT version ${e}`);
            this.name = i, this.units = o, this.tileSize = c, this.buffer = h, this.pixelFormat = Hx[s], this.dataIndex = y, this.bandShape = [c + 2 * h, c + 2 * h, yy[this.pixelFormat]], this._decodedBlocks = new jm(T ? T.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
          }
          get dimension() {
            return yy[this.pixelFormat];
          }
          get cacheSize() {
            return this._decodedBlocks.capacity;
          }
          getBandList() {
            return this.dataIndex.map(({ bands: e }) => e).flat();
          }
          processDecodedData(e) {
            const i = e.blockIndex.toString();
            this._decodedBlocks.get(i) || this._decodedBlocks.put(i, e.data);
          }
          getBlockForBand(e) {
            let i = 0;
            switch (typeof e) {
              case "string":
                for (const [o, c] of this.dataIndex.entries()) {
                  for (const [s, h] of c.bands.entries()) if (h === e) return { bandIndex: i + s, blockIndex: o, blockBandIndex: s };
                  i += c.bands.length;
                }
                break;
              case "number":
                for (const [o, c] of this.dataIndex.entries()) {
                  if (e >= i && e < i + c.bands.length) return { bandIndex: e, blockIndex: o, blockBandIndex: e - i };
                  i += c.bands.length;
                }
                break;
              default:
                throw new pl(`Invalid band \`${JSON.stringify(e)}\`. Expected string or integer.`);
            }
            throw new pl(`Band not found: ${JSON.stringify(e)}`);
          }
          getDataRange(e) {
            let i = 1 / 0, o = -1 / 0;
            const c = [], s = /* @__PURE__ */ new Set();
            for (const h of e) {
              const { blockIndex: y } = this.getBlockForBand(h);
              if (y < 0) throw new pl(`Invalid band: ${JSON.stringify(h)}`);
              const T = this.dataIndex[y];
              c.includes(y) || c.push(y), s.add(y), i = Math.min(i, T.firstByte), o = Math.max(o, T.lastByte);
            }
            if (s.size > this.cacheSize) throw new pl(`Number of blocks to decode (${s.size}) exceeds cache size (${this.cacheSize}).`);
            return { layerName: this.name, firstByte: i, lastByte: o, blockIndices: c };
          }
          hasBand(e) {
            const { blockIndex: i } = this.getBlockForBand(e);
            return i >= 0;
          }
          hasDataForBand(e) {
            const { blockIndex: i } = this.getBlockForBand(e);
            return i >= 0 && !!this._decodedBlocks.get(i.toString());
          }
          getBandView(e) {
            const { blockIndex: i, blockBandIndex: o } = this.getBlockForBand(e), c = this._decodedBlocks.get(i.toString());
            if (!c) throw new pl(`Data for band ${JSON.stringify(e)} of layer "${this.name}" not decoded.`);
            const s = this.dataIndex[i], h = this.bandShape.reduce((k, g) => k * g, 1), y = o * h, T = c.subarray(y, y + h);
            return { data: T, bytes: new Uint8Array(T.buffer).subarray(T.byteOffset, T.byteOffset + T.byteLength), tileSize: this.tileSize, buffer: this.buffer, pixelFormat: this.pixelFormat, dimension: this.dimension, offset: s.offset, scale: s.scale };
          }
        }
        Zm.setPbf = function(a) {
          Wm = a;
        };
        class vy {
          constructor(e, i, o) {
            this.tasks = e, this._onCancel = i, this._onComplete = o, this._finalized = !1;
          }
          cancel() {
            this._finalized || (this._onCancel(), this._finalized = !0);
          }
          complete(e, i) {
            this._finalized || (this._onComplete(e, i), this._finalized = !0);
          }
        }
        Zm.performDecoding = function(a, e) {
          const i = new Uint8Array(a);
          return Promise.all(e.tasks.map((o) => {
            const { layerName: c, firstByte: s, lastByte: h, pixelFormat: y, blockShape: T, blockIndex: k, filters: g, codec: A } = o, D = i.subarray(s, h + 1), S = new Uint32Array(T[0] * T[1] * T[2]);
            let R;
            if (A !== "gzip_data") throw new pl(`Unhandled codec: ${A}`);
            return R = function(j, J) {
              if (!globalThis.DecompressionStream && J === "gzip_data") return Promise.resolve(((ue = function(He) {
                He[0] == 31 && He[1] == 139 && He[2] == 8 || iu(6, "invalid gzip data");
                var at = He[3], nt = 10;
                4 & at && (nt += 2 + (He[10] | He[11] << 8));
                for (var tt = (at >> 3 & 1) + (at >> 4 & 1); tt > 0; tt -= !He[nt++]) ;
                return nt + (2 & at);
              }(ge = j)) + 8 > ge.length && iu(6, "invalid gzip data"), function(He, at, nt, tt) {
                var Et = He.length;
                if (!Et || at.f && !at.l) return nt || new zs(0);
                var lt = !nt, St = lt || at.i != 2, Lt = at.i;
                lt && (nt = new zs(3 * Et));
                var It, zt, Ft = function(wh) {
                  var ff = nt.length;
                  if (wh > ff) {
                    var $d = new zs(Math.max(2 * ff, wh));
                    $d.set(nt), nt = $d;
                  }
                }, qt = at.f || 0, Ot = at.p || 0, cr = at.b || 0, yr = at.l, ur = at.d, jr = at.m, zr = at.n, Ar = 8 * Et;
                do {
                  if (!yr) {
                    qt = ru(He, Ot, 1);
                    var vr = ru(He, Ot + 1, 3);
                    if (Ot += 3, !vr) {
                      var ti = He[(Si = 4 + ((Ot + 7) / 8 | 0)) - 4] | He[Si - 3] << 8, Wr = Si + ti;
                      if (Wr > Et) {
                        Lt && iu(0);
                        break;
                      }
                      St && Ft(cr + ti), nt.set(He.subarray(Si, Wr), cr), at.b = cr += ti, at.p = Ot = 8 * Wr, at.f = qt;
                      continue;
                    }
                    if (vr == 1) yr = Fx, ur = Nx, jr = 9, zr = 5;
                    else if (vr == 2) {
                      var $r = ru(He, Ot, 31) + 257, bi = ru(He, Ot + 10, 15) + 4, Ci = $r + ru(He, Ot + 5, 31) + 1;
                      Ot += 14;
                      for (var Pi = new zs(Ci), Ri = new zs(19), ji = 0; ji < bi; ++ji) Ri[zx[ji]] = ru(He, Ot + 3 * ji, 7);
                      Ot += 3 * bi;
                      var Hi = Gm(Ri), gn = (1 << Hi) - 1, cn = Gd(Ri, Hi);
                      for (ji = 0; ji < Ci; ) {
                        var Si, an = cn[ru(He, Ot, gn)];
                        if (Ot += 15 & an, (Si = an >> 4) < 16) Pi[ji++] = Si;
                        else {
                          var un = 0, Sn = 0;
                          for (Si == 16 ? (Sn = 3 + ru(He, Ot, 3), Ot += 2, un = Pi[ji - 1]) : Si == 17 ? (Sn = 3 + ru(He, Ot, 7), Ot += 3) : Si == 18 && (Sn = 11 + ru(He, Ot, 127), Ot += 7); Sn--; ) Pi[ji++] = un;
                        }
                      }
                      var $n = Pi.subarray(0, $r), oa = Pi.subarray($r);
                      jr = Gm($n), zr = Gm(oa), yr = Gd($n, jr), ur = Gd(oa, zr);
                    } else iu(1);
                    if (Ot > Ar) {
                      Lt && iu(0);
                      break;
                    }
                  }
                  St && Ft(cr + 131072);
                  for (var Xn = (1 << jr) - 1, Vn = (1 << zr) - 1, Jn = Ot; ; Jn = Ot) {
                    var da = (un = yr[Hm(He, Ot) & Xn]) >> 4;
                    if ((Ot += 15 & un) > Ar) {
                      Lt && iu(0);
                      break;
                    }
                    if (un || iu(2), da < 256) nt[cr++] = da;
                    else {
                      if (da == 256) {
                        Jn = Ot, yr = null;
                        break;
                      }
                      var $a = da - 254;
                      da > 264 && ($a = ru(He, Ot, (1 << (au = hy[ji = da - 257])) - 1) + my[ji], Ot += au);
                      var wn = ur[Hm(He, Ot) & Vn], Go = wn >> 4;
                      if (wn || iu(3), Ot += 15 & wn, oa = Bx[Go], Go > 3) {
                        var au = fy[Go];
                        oa += Hm(He, Ot) & (1 << au) - 1, Ot += au;
                      }
                      if (Ot > Ar) {
                        Lt && iu(0);
                        break;
                      }
                      St && Ft(cr + 131072);
                      var ml = cr + $a;
                      if (cr < oa) {
                        var _l = 0 - oa, hf = Math.min(oa, ml);
                        for (_l + cr < 0 && iu(3); cr < hf; ++cr) nt[cr] = (void 0)[_l + cr];
                      }
                      for (; cr < ml; ++cr) nt[cr] = nt[cr - oa];
                    }
                  }
                  at.l = yr, at.p = Jn, at.b = cr, at.f = qt, yr && (qt = 1, at.m = jr, at.d = ur, at.n = zr);
                } while (!qt);
                return cr != nt.length && lt ? (It = nt, ((zt = cr) == null || zt > It.length) && (zt = It.length), new zs(It.subarray(0, zt))) : nt.subarray(0, cr);
              }(ge.subarray(ue, -8), { i: 2 }, new zs(((ne = ge)[(me = ne.length) - 4] | ne[me - 3] << 8 | ne[me - 2] << 16 | ne[me - 1] << 24) >>> 0))));
              var ne, me, ge, ue;
              const Se = Gx[J];
              if (!Se) throw new Error(`Unhandled codec: ${J}`);
              const ke = new globalThis.DecompressionStream(Se);
              return new Response(new Blob([j]).stream().pipeThrough(ke)).arrayBuffer().then((He) => new Uint8Array(He));
            }(D, A).then((j) => (function(J, ne) {
              J.readFields(Cx, ne);
            }(new Wm(j), S), new Wx[y](S.buffer))), R.then((j) => {
              for (let J = g.length - 1; J >= 0; J--) switch (g[J]) {
                case "delta_filter":
                  Rx(j, T);
                  break;
                case "zigzag_filter":
                  Lx(j);
                  break;
                case "bitshuffle_filter":
                  Dx(j, y);
                  break;
                default:
                  throw new pl(`Unhandled filter "${g[J]}"`);
              }
              return { layerName: c, blockIndex: k, data: j };
            }).catch((j) => {
              throw j;
            });
          }));
        }, Gr(vy, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] });
        let Wd, qm, nu, Qf, $m, ed = null;
        function xy() {
          return tr() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : qm || yt.DRACO_URL;
        }
        function by() {
          if (tr() && self.worker && self.worker.meshoptUrl) return self.worker.meshoptUrl;
          if (Qf) return Qf;
          const a = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
          if (typeof WebAssembly != "object") throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
          return Qf = WebAssembly.validate(a) ? yt.MESHOPT_SIMD_URL : yt.MESHOPT_URL, Qf;
        }
        const Op = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, qx = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", 5123: "DT_UINT16", 5125: "DT_UINT32", 5126: "DT_FLOAT32" }, Zd = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
        function wy(a, e, i) {
          const o = i.json.bufferViews.length, c = i.buffers.length;
          e.bufferView = o, i.json.bufferViews[o] = { buffer: c, byteLength: a.byteLength }, i.buffers[c] = a;
        }
        const Xm = "KHR_draco_mesh_compression";
        function $x(a, e) {
          const i = a.extensions && a.extensions[Xm];
          if (!i) return;
          const o = new nu.Decoder(), c = My(e, i.bufferView), s = new nu.Mesh();
          if (!o.DecodeArrayToMesh(c, c.byteLength, s)) throw new Error("Failed to decode Draco mesh");
          const h = e.json.accessors[a.indices], y = Op[h.componentType], T = h.count * y.BYTES_PER_ELEMENT, k = nu._malloc(T);
          y === Uint16Array ? o.GetTrianglesUInt16Array(s, T, k) : o.GetTrianglesUInt32Array(s, T, k), wy(nu.memory.buffer.slice(k, k + T), h, e), nu._free(k);
          for (const g of Object.keys(i.attributes)) {
            const A = o.GetAttributeByUniqueId(s, i.attributes[g]), D = e.json.accessors[a.attributes[g]], S = qx[D.componentType], R = D.count * Zd[D.type] * Op[D.componentType].BYTES_PER_ELEMENT, j = nu._malloc(R);
            o.GetAttributeDataArrayForAllPoints(s, A, nu[S], R, j), wy(nu.memory.buffer.slice(j, j + R), D, e), nu._free(j);
          }
          o.destroy(), s.destroy(), delete a.extensions[Xm];
        }
        const Bp = "EXT_meshopt_compression";
        function Xx(a, e) {
          if (!a.extensions || !a.extensions[Bp]) return;
          const i = a.extensions[Bp], o = new Uint8Array(e.buffers[i.buffer], i.byteOffset || 0, i.byteLength || 0), c = new Uint8Array(i.count * i.byteStride);
          $m.decodeGltfBuffer(c, i.count, i.byteStride, o, i.mode, i.filter), a.buffer = e.buffers.length, a.byteOffset = 0, e.buffers[a.buffer] = c.buffer, delete a.extensions[Bp];
        }
        const Ey = 1179937895, Sy = new TextDecoder("utf8");
        function Ty(a, e) {
          return new URL(a, e).href;
        }
        function Yx(a, e, i, o) {
          return fetch(Ty(a.uri, o)).then((c) => c.arrayBuffer()).then((c) => {
            e.buffers[i] = c;
          });
        }
        function My(a, e) {
          const i = a.json.bufferViews[e];
          return new Uint8Array(a.buffers[i.buffer], i.byteOffset || 0, i.byteLength);
        }
        function Kx(a, e, i, o) {
          if (a.uri) {
            const c = Ty(a.uri, o);
            return fetch(c).then((s) => s.blob()).then((s) => createImageBitmap(s)).then((s) => {
              e.images[i] = s;
            });
          }
          if (a.bufferView !== void 0) {
            const c = My(e, a.bufferView), s = new Blob([c], { type: a.mimeType });
            return createImageBitmap(s).then((h) => {
              e.images[i] = h;
            });
          }
        }
        function Ay(a, e = 0, i) {
          const o = { json: null, images: [], buffers: [] };
          if (new Uint32Array(a, e, 1)[0] === Ey) {
            const g = new Uint32Array(a, e);
            let A = 2;
            const D = (g[A++] >> 2) - 3, S = g[A++] >> 2;
            if (A++, o.json = JSON.parse(Sy.decode(g.subarray(A, A + S))), A += S, A < D) {
              const R = g[A++];
              A++;
              const j = e + (A << 2);
              o.buffers[0] = a.slice(j, j + R);
            }
          } else o.json = JSON.parse(Sy.decode(new Uint8Array(a, e)));
          const { buffers: c, images: s, meshes: h, extensionsUsed: y, bufferViews: T } = o.json;
          let k = Promise.resolve();
          if (c) {
            const g = [];
            for (let A = 0; A < c.length; A++) {
              const D = c[A];
              D.uri ? g.push(Yx(D, o, A, i)) : o.buffers[A] || (o.buffers[A] = null);
            }
            k = Promise.all(g);
          }
          return k.then(() => {
            const g = [], A = y && y.includes(Xm), D = y && y.includes(Bp);
            if (A && g.push(function() {
              if (!nu) return Wd ?? (Wd = function(S) {
                let R, j = null;
                function J() {
                  R = new Uint8Array(j.buffer);
                }
                function ne() {
                  throw new Error("Unexpected Draco error.");
                }
                const me = { a: { a: ne, d: function(ge, ue, Se) {
                  return R.copyWithin(ge, ue, ue + Se);
                }, c: function(ge) {
                  const ue = R.length, Se = Math.max(ge >>> 0, Math.ceil(1.2 * ue)), ke = Math.ceil((Se - ue) / 65536);
                  try {
                    return j.grow(ke), J(), !0;
                  } catch {
                    return !1;
                  }
                }, b: ne } };
                return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(S, me) : S.then((ge) => ge.arrayBuffer()).then((ge) => WebAssembly.instantiate(ge, me))).then((ge) => {
                  const { Rb: ue, Qb: Se, P: ke, T: He, X: at, Ja: nt, La: tt, Qa: Et, Va: lt, Wa: St, eb: Lt, jb: It, f: zt, e: Ft, yb: qt, zb: Ot, Ab: cr, Bb: yr, Db: ur, Gb: jr } = ge.instance.exports;
                  j = Ft;
                  const zr = /* @__PURE__ */ (() => {
                    let Ar = 0, vr = 0, ti = 0, Wr = 0;
                    return ($r) => {
                      ti && (ue(Wr), ue(Ar), vr += ti, ti = Ar = 0), Ar || (vr += 128, Ar = Se(vr));
                      const bi = $r.length + 7 & -8;
                      let Ci = Ar;
                      bi >= vr && (ti = bi, Ci = Wr = Se(bi));
                      for (let Pi = 0; Pi < $r.length; Pi++) R[Ci + Pi] = $r[Pi];
                      return Ci;
                    };
                  })();
                  return J(), zt(), { memory: Ft, _free: ue, _malloc: Se, Mesh: class {
                    constructor() {
                      this.ptr = ke();
                    }
                    destroy() {
                      He(this.ptr);
                    }
                  }, Decoder: class {
                    constructor() {
                      this.ptr = nt();
                    }
                    destroy() {
                      It(this.ptr);
                    }
                    DecodeArrayToMesh(Ar, vr, ti) {
                      const Wr = zr(Ar), $r = tt(this.ptr, Wr, vr, ti.ptr);
                      return !!at($r);
                    }
                    GetAttributeByUniqueId(Ar, vr) {
                      return { ptr: Et(this.ptr, Ar.ptr, vr) };
                    }
                    GetTrianglesUInt16Array(Ar, vr, ti) {
                      lt(this.ptr, Ar.ptr, vr, ti);
                    }
                    GetTrianglesUInt32Array(Ar, vr, ti) {
                      St(this.ptr, Ar.ptr, vr, ti);
                    }
                    GetAttributeDataArrayForAllPoints(Ar, vr, ti, Wr, $r) {
                      Lt(this.ptr, Ar.ptr, vr.ptr, ti, Wr, $r);
                    }
                  }, DT_INT8: qt(), DT_UINT8: Ot(), DT_INT16: cr(), DT_UINT16: yr(), DT_UINT32: ur(), DT_FLOAT32: jr() };
                });
              }(fetch(xy())), Wd.then((S) => {
                nu = S, Wd = void 0;
              }));
            }()), D && g.push(function() {
              if ($m) return;
              const S = function(R) {
                let j;
                const J = WebAssembly.instantiateStreaming(R, {}).then((ge) => {
                  j = ge.instance, j.exports.__wasm_call_ctors();
                }), ne = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, me = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" };
                return { ready: J, supported: !0, decodeGltfBuffer(ge, ue, Se, ke, He, at) {
                  (function(nt, tt, Et, lt, St, Lt, It) {
                    const zt = nt.exports.sbrk, Ft = lt + 3 & -4, qt = zt(Ft * St), Ot = zt(Lt.length), cr = new Uint8Array(nt.exports.memory.buffer);
                    cr.set(Lt, Ot);
                    const yr = tt(qt, lt, St, Ot, Lt.length);
                    if (yr === 0 && It && It(qt, Ft, St), Et.set(cr.subarray(qt, qt + lt * St)), zt(qt - zt(0)), yr !== 0) throw new Error(`Malformed buffer data: ${yr}`);
                  })(j, j.exports[me[He]], ge, ue, Se, ke, j.exports[ne[at]]);
                } };
              }(fetch(by()));
              return S.ready.then(() => {
                $m = S;
              });
            }()), s) for (let S = 0; S < s.length; S++) g.push(Kx(s[S], o, S, i));
            return (g.length ? Promise.all(g) : Promise.resolve()).then(() => {
              if (A && h) for (const { primitives: S } of h) for (const R of S) $x(R, o);
              if (D && h && T) for (const S of T) Xx(S, o);
              return o;
            });
          });
        }
        function cf(a, e) {
          const i = a.json.bufferViews[e.bufferView], o = Op[e.componentType];
          return new o(a.buffers[i.buffer], (e.byteOffset || 0) + (i.byteOffset || 0), e.count * (i.byteStride && i.byteStride !== Zd[e.type] * o.BYTES_PER_ELEMENT ? i.byteStride / o.BYTES_PER_ELEMENT : Zd[e.type]));
        }
        function Ym(a, e, i, o) {
          const c = Op[e.componentType], s = function(g) {
            switch (g) {
              case Int8Array:
                return 1 / 127;
              case Uint8Array:
                return 1 / 255;
              case Int16Array:
                return 1 / 32767;
              case Uint16Array:
                return 1 / 65535;
              default:
                return 1;
            }
          }(c), h = a.json.bufferViews[e.bufferView], y = h.byteStride ? h.byteStride / c.BYTES_PER_ELEMENT : Zd[e.type], T = i.float32, k = T.length / i.capacity;
          for (let g = 0, A = 0; g < e.count * y; g += y, A += k) for (let D = 0; D < k; D++) T[A + D] = o[g + D] * s;
          i._trim();
        }
        function Jx(a, e, i) {
          const o = a.indices, c = a.attributes, s = {};
          s.indexArray = new ha();
          const h = e.json.accessors[o], y = h.count / 3;
          s.indexArray.reserve(y);
          const T = cf(e, h);
          for (let D = 0; D < y; D++) s.indexArray.emplaceBack(T[3 * D], T[3 * D + 1], T[3 * D + 2]);
          s.indexArray._trim(), s.vertexArray = new ro();
          const k = e.json.accessors[c.POSITION];
          s.vertexArray.reserve(k.count);
          const g = cf(e, k);
          for (let D = 0; D < k.count; D++) s.vertexArray.emplaceBack(g[3 * D], g[3 * D + 1], g[3 * D + 2]);
          if (s.vertexArray._trim(), s.aabb = new Yr(k.min, k.max), s.centroid = function(D, S) {
            const R = [0, 0, 0], j = D.length;
            if (j > 0) {
              for (let J = 0; J < j; J++) {
                const ne = 3 * D[J];
                R[0] += S[ne], R[1] += S[ne + 1], R[2] += S[ne + 2];
              }
              R[0] /= j, R[1] /= j, R[2] /= j;
            }
            return R;
          }(T, g), c.COLOR_0 !== void 0) {
            const D = e.json.accessors[c.COLOR_0], S = Zd[D.type], R = cf(e, D);
            s.colorArray = S === 3 ? new ro() : new Is(), s.colorArray.resize(D.count), Ym(e, D, s.colorArray, R);
          }
          if (c.NORMAL !== void 0) {
            s.normalArray = new ro();
            const D = e.json.accessors[c.NORMAL];
            s.normalArray.resize(D.count);
            const S = cf(e, D);
            Ym(e, D, s.normalArray, S);
          }
          if (c.TEXCOORD_0 !== void 0 && i.length > 0) {
            s.texcoordArray = new Hl();
            const D = e.json.accessors[c.TEXCOORD_0];
            s.texcoordArray.resize(D.count);
            const S = cf(e, D);
            Ym(e, D, s.texcoordArray, S);
          }
          if (c._FEATURE_ID_RGBA4444 !== void 0) {
            const D = e.json.accessors[c._FEATURE_ID_RGBA4444];
            e.json.extensionsUsed && e.json.extensionsUsed.includes("EXT_meshopt_compression") && (s.featureData = cf(e, D));
          }
          c._FEATURE_RGBA4444 !== void 0 && (s.featureData = new Uint32Array(cf(e, e.json.accessors[c._FEATURE_RGBA4444]).buffer));
          const A = a.material;
          return s.material = function(D, S) {
            const { emissiveFactor: R = [0, 0, 0], alphaMode: j = "OPAQUE", alphaCutoff: J = 0.5, normalTexture: ne, occlusionTexture: me, emissiveTexture: ge, doubleSided: ue } = D, { baseColorFactor: Se = [1, 1, 1, 1], metallicFactor: ke = 1, roughnessFactor: He = 1, baseColorTexture: at, metallicRoughnessTexture: nt } = D.pbrMetallicRoughness || {}, tt = me ? S[me.index] : void 0;
            if (me && me.extensions && me.extensions.KHR_texture_transform && tt) {
              const Et = me.extensions.KHR_texture_transform;
              tt.offsetScale = [Et.offset[0], Et.offset[1], Et.scale[0], Et.scale[1]];
            }
            return { pbrMetallicRoughness: { baseColorFactor: new Xi(...Se), metallicFactor: ke, roughnessFactor: He, baseColorTexture: at ? S[at.index] : void 0, metallicRoughnessTexture: nt ? S[nt.index] : void 0 }, doubleSided: ue, emissiveFactor: R, alphaMode: j, alphaCutoff: J, normalTexture: ne ? S[ne.index] : void 0, occlusionTexture: tt, emissionTexture: ge ? S[ge.index] : void 0, defined: D.defined === void 0 };
          }(A !== void 0 ? e.json.materials[A] : { defined: !1 }, i), s;
        }
        function Iy(a, e, i) {
          const { matrix: o, rotation: c, translation: s, scale: h, mesh: y, extras: T, children: k } = a, g = {};
          if (g.matrix = o || Oe.mat4.fromRotationTranslationScale([], c || [0, 0, 0, 1], s || [0, 0, 0], h || [1, 1, 1]), y !== void 0) {
            g.meshes = i[y];
            const A = g.anchor = [0, 0];
            for (const D of g.meshes) {
              const { min: S, max: R } = D.aabb;
              A[0] += S[0] + R[0], A[1] += S[1] + R[1];
            }
            A[0] = Math.floor(A[0] / g.meshes.length / 2), A[1] = Math.floor(A[1] / g.meshes.length / 2);
          }
          if (T && (T.id && (g.id = T.id), T.lights && (g.lights = function(A) {
            if (!A.length) return [];
            const D = function(ne) {
              const me = atob(ne), ge = new Uint8Array(me.length);
              for (let ue = 0; ue < me.length; ue++) ge[ue] = me.codePointAt(ue);
              return ge;
            }(A), S = [], R = D.length / 24, j = new Uint16Array(D.buffer), J = new Float32Array(D.buffer);
            for (let ne = 0; ne < R; ne++) {
              const me = j[2 * ne * 6] / 30, ge = j[2 * ne * 6 + 1] / 30, ue = j[2 * ne * 6 + 10] / 100, Se = J[6 * ne + 1], ke = J[6 * ne + 2], He = J[6 * ne + 3], at = J[6 * ne + 4], nt = He - Se, tt = at - ke, Et = Math.hypot(nt, tt);
              S.push({ pos: [Se + 0.5 * nt, ke + 0.5 * tt, ge], normal: [tt / Et, -nt / Et, 0], width: Et, height: me, depth: ue, points: [Se, ke, He, at] });
            }
            return S;
          }(T.lights))), k) {
            const A = [];
            for (const D of k) A.push(Iy(e.json.nodes[D], e, i));
            g.children = A;
          }
          return g;
        }
        function Qx(a) {
          if (a.vertices.length === 0 || a.indices.length === 0) return null;
          const e = new Ai(a.vertices, a.indices, 8, 256), [i, o] = [e.min.clone(), e.max.clone()];
          return { vertices: a.vertices, indices: a.indices, grid: e, min: i, max: o };
        }
        function eb(a) {
          if (!a.extras || !a.extras.ground) return null;
          const e = a.extras.ground;
          if (!e || !Array.isArray(e) || e.length === 0) return null;
          const i = e[0];
          if (!i || !Array.isArray(i) || i.length === 0) return null;
          const o = [];
          for (const h of i) {
            if (!Array.isArray(h) || h.length !== 2) continue;
            const y = h[0], T = h[1];
            typeof y == "number" && typeof T == "number" && o.push(new Ye(y, T));
          }
          if (o.length < 3) return null;
          o.length > 1 && o[o.length - 1].equals(o[0]) && o.pop();
          let c = 0;
          for (let h = 0; h < o.length; h++) {
            const y = o[h], T = o[(h + 1) % o.length], k = o[(h + 2) % o.length];
            c += (y.x - T.x) * (k.y - T.y) - (k.x - T.x) * (y.y - T.y);
          }
          c > 0 && o.reverse();
          const s = mh(o.flatMap((h) => [h.x, h.y]), []);
          return s.length === 0 ? null : { vertices: o, indices: s };
        }
        function tb(a, e) {
          const i = [], o = [];
          let c = 0;
          const s = [];
          for (const h of a) {
            c = i.length;
            const y = h.vertexArray.float32, T = h.indexArray.uint16;
            for (let k = 0; k < h.vertexArray.length; k++) s[0] = y[3 * k + 0], s[1] = y[3 * k + 1], s[2] = y[3 * k + 2], Oe.vec3.transformMat4(s, s, e), i.push(new Ye(s[0], s[1]));
            for (let k = 0; k < 3 * h.indexArray.length; k++) o.push(T[k] + c);
          }
          if (o.length % 3 != 0) return null;
          for (let h = 0; h < o.length; h += 3) {
            const y = i[o[h + 0]], T = i[o[h + 1]], k = i[o[h + 2]];
            (y.x - T.x) * (k.y - T.y) - (k.x - T.x) * (y.y - T.y) > 0 && ([o[h + 1], o[h + 2]] = [o[h + 2], o[h + 1]]);
          }
          return { vertices: i, indices: o };
        }
        function Cy(a) {
          const e = function(T, k) {
            const g = [], A = WebGL2RenderingContext;
            if (T.json.textures) for (const D of T.json.textures) {
              const S = { magFilter: A.LINEAR, minFilter: A.NEAREST, wrapS: A.REPEAT, wrapT: A.REPEAT };
              D.sampler !== void 0 && Object.assign(S, T.json.samplers[D.sampler]), g.push({ image: k[D.source], sampler: S, uploaded: !1 });
            }
            return g;
          }(a, a.images), i = function(T, k) {
            const g = [];
            for (const A of T.json.meshes) {
              const D = [];
              for (const S of A.primitives) D.push(Jx(S, T, k));
              g.push(D);
            }
            return g;
          }(a, e), { scenes: o, scene: c, nodes: s } = a.json, h = o ? o[c || 0].nodes : s, y = [];
          for (const T of h) y.push(Iy(s[T], a, i));
          return function(T, k, g) {
            const A = {}, D = /* @__PURE__ */ new Set();
            for (let S = 0; S < T.length; S++) {
              const R = g[k[S]];
              if (!R.extras) continue;
              const j = R.extras["mapbox:footprint:version"], J = R.extras["mapbox:footprint:id"];
              (j || J) && D.add(S), j === "1.0.0" && J && (A[J] = S);
            }
            for (let S = 0; S < T.length; S++) {
              if (D.has(S)) continue;
              const R = T[S], j = g[k[S]];
              if (!j.extras) continue;
              let J = null;
              R.id in A && (J = tb(T[A[R.id]].meshes, R.matrix)), J || (J = eb(j)), J && (R.footprint = Qx(J));
            }
            if (D.size > 0) {
              const S = Array.from(D.values()).sort((R, j) => R - j);
              for (let R = S.length - 1; R >= 0; R--) T.splice(S[R], 1);
            }
          }(y, h, a.json.nodes), y;
        }
        function rb(a) {
          a.heightmap = new Float32Array(4096), a.heightmap.fill(-1);
          const e = a.vertexArray.float32, i = a.aabb.min[0] - 1, o = a.aabb.min[1] - 1, c = sf / (a.aabb.max[0] - i + 2), s = sf / (a.aabb.max[1] - o + 2);
          for (let h = 0; h < e.length; h += 3) {
            const y = e[h + 2], T = (e[h + 0] - i) * c | 0, k = (e[h + 1] - o) * s | 0;
            y > a.heightmap[k * sf + T] && (a.heightmap[k * sf + T] = y);
          }
        }
        function ib(a, e) {
          const i = {};
          i.indexArray = new ha(), i.indexArray.reserve(4 * a.length), i.vertexArray = new ro(), i.vertexArray.reserve(10 * a.length), i.colorArray = new Is(), i.vertexArray.reserve(10 * a.length);
          let o = 0;
          for (const h of a) {
            const y = Math.min(10, Math.max(4, 1.3 * h.height)) * e, T = [-h.normal[1], h.normal[0], 0], k = Math.min(0.29, 0.1 * h.width / h.depth), g = h.width - 2 * h.depth * e * (k + 0.01), A = Oe.vec3.scaleAndAdd([], h.pos, T, g / 2), D = Oe.vec3.scaleAndAdd([], h.pos, T, -g / 2), S = [A[0], A[1], A[2] + h.height], R = [D[0], D[1], D[2] + h.height], j = Oe.vec3.scaleAndAdd([], h.normal, T, k);
            Oe.vec3.scale(j, j, y);
            const J = Oe.vec3.scaleAndAdd([], h.normal, T, -k);
            Oe.vec3.scale(J, J, y), Oe.vec3.add(j, A, j), Oe.vec3.add(J, D, J), A[2] += 0.1, D[2] += 0.1, i.vertexArray.emplaceBack(j[0], j[1], j[2]), i.vertexArray.emplaceBack(J[0], J[1], J[2]), i.vertexArray.emplaceBack(A[0], A[1], A[2]), i.vertexArray.emplaceBack(D[0], D[1], D[2]), i.vertexArray.emplaceBack(S[0], S[1], S[2]), i.vertexArray.emplaceBack(R[0], R[1], R[2]), i.vertexArray.emplaceBack(A[0], A[1], A[2]), i.vertexArray.emplaceBack(D[0], D[1], D[2]), i.vertexArray.emplaceBack(j[0], j[1], j[2]), i.vertexArray.emplaceBack(J[0], J[1], J[2]);
            const ne = g / y / 2;
            i.colorArray.emplaceBack(-ne - k, -1, ne, 0.8), i.colorArray.emplaceBack(ne + k, -1, ne, 0.8), i.colorArray.emplaceBack(-ne, 0, ne, 1.3), i.colorArray.emplaceBack(ne, 0, ne, 1.3), i.colorArray.emplaceBack(ne + k, -0.8, ne, 0.7), i.colorArray.emplaceBack(ne + k, -0.8, ne, 0.7), i.colorArray.emplaceBack(0, 0, ne, 1.3), i.colorArray.emplaceBack(0, 0, ne, 1.3), i.colorArray.emplaceBack(ne + k, -1.2, ne, 0.8), i.colorArray.emplaceBack(ne + k, -1.2, ne, 0.8), i.indexArray.emplaceBack(6 + o, 4 + o, 8 + o), i.indexArray.emplaceBack(7 + o, 9 + o, 5 + o), i.indexArray.emplaceBack(0 + o, 1 + o, 2 + o), i.indexArray.emplaceBack(1 + o, 3 + o, 2 + o), o += 10;
          }
          const c = { defined: !0, emissiveFactor: [0, 0, 0] }, s = {};
          return s.baseColorFactor = Xi.white, c.pbrMetallicRoughness = s, i.material = c, i.aabb = new Yr([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), i;
        }
        class Py {
          constructor(e) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let i = 0; i < e.length; i++) {
              const o = e[i];
              this._stringToNumber[o] = i, this._numberToString[i] = o;
            }
          }
          encode(e) {
            return this._stringToNumber[e];
          }
          decode(e) {
            return this._numberToString[e];
          }
        }
        const nb = ["id", "tile", "layer", "source", "sourceLayer", "state"];
        class td {
          constructor(e, i, o, c, s) {
            this.type = "Feature", this._vectorTileFeature = e, this._z = i, this._x = o, this._y = c, this.properties = e.properties, this.id = s;
          }
          clone() {
            const e = new td(this._vectorTileFeature, this._z, this._x, this._y, this.id);
            return this.state && (e.state = Object.assign({}, this.state)), this.layer && (e.layer = Object.assign({}, this.layer)), this.source && (e.source = this.source), this.sourceLayer && (e.sourceLayer = this.sourceLayer), e;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
          }
          set geometry(e) {
            this._geometry = e;
          }
          toJSON() {
            const e = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
            for (const i of nb) this[i] !== void 0 && (e[i] = this[i]);
            return e;
          }
        }
        class Ry {
          constructor(e, i) {
            this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new ts(Br, 16, 0), this.featureIndexArray = new vc(), this.promoteId = i, this.is3DTile = !1, this.serializedLayersCache = /* @__PURE__ */ new Map();
          }
          insert(e, i, o, c, s, h = 0, y = 0) {
            const T = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(o, c, s, h);
            const k = this.grid;
            for (let g = 0; g < i.length; g++) {
              const A = i[g], D = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let S = 0; S < A.length; S++) {
                const R = A[S];
                D[0] = Math.min(D[0], R.x), D[1] = Math.min(D[1], R.y), D[2] = Math.max(D[2], R.x), D[3] = Math.max(D[3], R.y);
              }
              y !== 0 && (D[0] -= y, D[1] -= y, D[2] += y, D[3] += y), D[0] < Br && D[1] < Br && D[2] >= 0 && D[3] >= 0 && k.insert(T, D[0], D[1], D[2], D[3]);
            }
          }
          loadVTLayers() {
            if (!this.vtLayers) {
              this.vtLayers = new jf.VectorTile(new sp(this.rawTileData)).layers, this.sourceLayerCoder = new Py(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
              for (const e in this.vtLayers) this.vtFeatures[e] = [];
            }
            return this.vtLayers;
          }
          query(e, i) {
            const { tilespaceGeometry: o, transform: c, tileTransform: s, pixelPosMatrix: h, availableImages: y } = i;
            this.loadVTLayers(), this.serializedLayersCache.clear();
            const T = o.bufferedTilespaceBounds, k = this.grid.query(T.min.x, T.min.y, T.max.x, T.max.y, (S, R, j, J) => gt(o.bufferedTilespaceGeometry, S, R, j, J));
            k.sort(ab);
            let g = null;
            c.elevation && k.length > 0 && (g = $f.create(c.elevation, this.tileID));
            const A = {};
            let D;
            for (let S = 0; S < k.length; S++) {
              const R = k[S];
              if (R === D) continue;
              D = R;
              const j = this.featureIndexArray.get(R);
              let J = null;
              this.is3DTile ? this.loadMatchingModelFeature(A, j, e, o, c) : this.loadMatchingFeature(A, j, e, y, (ne, me, ge, ue = 0) => (J || (J = K(ne, this.tileID.canonical, s)), me.queryIntersectsFeature(o, ne, ge, J, this.z, c, h, g, ue)));
            }
            return A;
          }
          loadMatchingFeature(e, i, o, c, s) {
            const { featureIndex: h, bucketIndex: y, sourceLayerIndex: T, layoutVertexArrayOffset: k } = i, g = this.bucketLayerIDs[y], A = o.layers, D = Object.keys(A);
            if (D.length && !function(ne, me) {
              for (let ge = 0; ge < ne.length; ge++) if (me.indexOf(ne[ge]) >= 0) return !0;
              return !1;
            }(D, g)) return;
            const S = o.sourceCache, R = this.sourceLayerCoder.decode(T), j = this.vtLayers[R].feature(h), J = this.getId(j, R);
            for (let ne = 0; ne < g.length; ne++) {
              const me = g[ne];
              if (!A[me]) continue;
              const { styleLayer: ge, targets: ue } = A[me];
              let Se = {};
              J !== void 0 && (Se = S.getFeatureState(ge.sourceLayer, J));
              const ke = !s || s(j, ge, Se, k);
              if (!ke) continue;
              const He = new td(j, this.z, this.x, this.y, J);
              He.tile = this.tileID.canonical, He.state = Se;
              let at = this.serializedLayersCache.get(me);
              at || (at = ge.serialize(), at.id = me, this.serializedLayersCache.set(me, at)), He.source = at.source, He.sourceLayer = at["source-layer"], He.layer = Qt({}, at), He.layer.paint = Ly(at.paint, ge.paint, j, Se, c), He.layer.layout = Ly(at.layout, ge.layout, j, Se, c);
              let nt = !1;
              for (const tt of ue) {
                this.updateFeatureProperties(He, tt);
                const { filter: Et } = tt;
                if (Et) {
                  if (j.properties = He.properties, Et.needGeometry) {
                    const lt = ae(j, !0);
                    if (!Et.filter(new sn(this.tileID.overscaledZ), lt, this.tileID.canonical)) continue;
                  } else if (!Et.filter(new sn(this.tileID.overscaledZ), j)) continue;
                }
                nt = !0, tt.targetId && this.addFeatureVariant(He, tt);
              }
              nt && this.appendToResult(e, me, h, He, ke);
            }
          }
          loadMatchingModelFeature(e, i, o, c, s) {
            const h = this.bucketLayerIDs[0][0], y = o.layers;
            if (!y[h]) return;
            const { styleLayer: T, targets: k } = y[h];
            if (T.type !== "model") return;
            const g = c.tile, A = i.featureIndex, D = g.getBucket(T);
            if (!(D && D instanceof Ip)) return;
            const S = function(at, nt, tt, Et) {
              const lt = at.getNodesInfo()[nt];
              if (lt.hiddenByReplacement || !lt.node.meshes) return;
              let St = Number.MAX_VALUE;
              const Lt = lt.node, It = tt.tile, zt = Et.calculatePosMatrix(It.tileID.toUnwrapped(), Et.worldSize), Ft = lt.evaluatedScale;
              let qt = 0;
              Et.elevation && Lt.elevation && (qt = Lt.elevation * Et.elevation.exaggeration()), Oe.mat4.translate(zt, zt, [(Lt.anchor ? Lt.anchor[0] : 0) * (Ft[0] - 1), (Lt.anchor ? Lt.anchor[1] : 0) * (Ft[1] - 1), qt]), Oe.mat4.scale(zt, zt, Ft);
              const Ot = tt.queryGeometry, cr = Ot.isPointQuery() ? Ot.screenBounds : Ot.screenGeometry, yr = function(jr) {
                const zr = Oe.mat4.multiply([], zt, jr.matrix);
                Oe.mat4.multiply(zr, Et.expandedFarZProjMatrix, zr);
                for (let Ar = 0; Ar < jr.meshes.length; ++Ar) {
                  const vr = jr.meshes[Ar];
                  if (Ar === jr.lightMeshIndex) continue;
                  const ti = P0(cr, Et, zr, vr.aabb);
                  ti != null && (St = Math.min(ti, St));
                }
                if (jr.children) for (const Ar of jr.children) yr(Ar);
              };
              if (yr(Lt), St === Number.MAX_VALUE) return;
              const ur = new qi(0, 0);
              return V0(It.tileID.canonical, ur, lt.node.anchor[0], lt.node.anchor[1]), { intersectionZ: St, position: ur, feature: lt.feature };
            }(D, A, c, s);
            if (!S) return;
            const { z: R, x: j, y: J } = g.tileID.canonical, { feature: ne, intersectionZ: me, position: ge } = S;
            let ue = {};
            ne.id !== void 0 && (ue = o.sourceCache.getFeatureState(T.sourceLayer, ne.id));
            const Se = new td({}, R, j, J, ne.id);
            Se.tile = this.tileID.canonical, Se.state = ue, Se.properties = ne.properties, Se.geometry = { type: "Point", coordinates: [ge.lng, ge.lat] };
            let ke = this.serializedLayersCache.get(h);
            ke || (ke = T.serialize(), ke.id = h, this.serializedLayersCache.set(h, ke)), Se.source = ke.source, Se.sourceLayer = ke["source-layer"], Se.layer = Qt({}, ke);
            let He = !1;
            for (const at of k) {
              this.updateFeatureProperties(Se, at);
              const { filter: nt } = at;
              if (nt) {
                if (ne.properties = Se.properties, nt.needGeometry) {
                  if (!nt.filter(new sn(this.tileID.overscaledZ), ne, this.tileID.canonical)) continue;
                } else if (!nt.filter(new sn(this.tileID.overscaledZ), ne)) continue;
              }
              He = !0, at.targetId && this.addFeatureVariant(Se, at);
            }
            He && this.appendToResult(e, h, A, Se, me);
          }
          updateFeatureProperties(e, i, o) {
            if (i.properties) {
              const c = {};
              for (const s in i.properties) {
                const h = i.properties[s].evaluate({ zoom: this.z }, e._vectorTileFeature, e.state, e.tile, o);
                h != null && (c[s] = h);
              }
              e.properties = c;
            }
          }
          addFeatureVariant(e, i, o) {
            const c = { target: i.target, namespace: i.namespace, uniqueFeatureID: i.uniqueFeatureID };
            i.properties && (c.properties = e.properties), e.variants = e.variants || {}, e.variants[i.targetId] = e.variants[i.targetId] || [], e.variants[i.targetId].push(c);
          }
          appendToResult(e, i, o, c, s) {
            let h = e[i];
            h === void 0 && (h = e[i] = []), h.push({ featureIndex: o, feature: c, intersectionZ: s });
          }
          lookupSymbolFeatures(e, i, o, c, s) {
            const h = {};
            this.loadVTLayers();
            for (const y of e) this.loadMatchingFeature(h, { bucketIndex: i, sourceLayerIndex: o, featureIndex: y, layoutVertexArrayOffset: 0 }, c, s);
            return h;
          }
          loadFeature(e) {
            const { featureIndex: i, sourceLayerIndex: o } = e;
            this.loadVTLayers();
            const c = this.sourceLayerCoder.decode(o), s = this.vtFeatures[c];
            if (s[i]) return s[i];
            const h = this.vtLayers[c].feature(i);
            return s[i] = h, h;
          }
          hasLayer(e) {
            for (const i of this.bucketLayerIDs) for (const o of i) if (e === o) return !0;
            return !1;
          }
          getId(e, i) {
            let o = e.id;
            if (this.promoteId) {
              const c = Array.isArray(this.promoteId) || typeof this.promoteId != "object" ? this.promoteId : this.promoteId[i];
              if (c != null) if (Array.isArray(c)) {
                if (!this.promoteIdExpression) {
                  const s = eo(c);
                  if (s.result !== "success") {
                    const h = s.value.map((y) => `${y.key}: ${y.message}`).join(", ");
                    return void Tt(`Failed to create expression for promoteId: ${h}`);
                  }
                  this.promoteIdExpression = s.value;
                }
                this.promoteIdExpression._evaluator || (this.promoteIdExpression._evaluator = new Ih()), o = this.promoteIdExpression.evaluate({ zoom: 0 }, e);
              } else o = e.properties[c];
              typeof o == "boolean" && (o = Number(o));
            }
            return o;
          }
        }
        function Ly(a, e, i, o, c) {
          return Pr(a, (s, h) => {
            const y = e instanceof nl ? e.get(h) : null;
            return y && y.evaluate ? y.evaluate(i, o, c) : y;
          });
        }
        function ab(a, e) {
          return e - a;
        }
        Gr(Ry, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
        const Dy = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Km {
          static from(e) {
            if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [i, o] = new Uint8Array(e, 0, 2);
            if (i !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const c = o >> 4;
            if (c !== 1) throw new Error(`Got v${c} data when expected v1.`);
            const s = Dy[15 & o];
            if (!s) throw new Error("Unrecognized array type.");
            const [h] = new Uint16Array(e, 2, 1), [y] = new Uint32Array(e, 4, 1);
            return new Km(y, h, s, e);
          }
          constructor(e, i = 64, o = Float64Array, c) {
            if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
            this.numItems = +e, this.nodeSize = Math.min(Math.max(+i, 2), 65535), this.ArrayType = o, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
            const s = Dy.indexOf(this.ArrayType), h = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, y = e * this.IndexArrayType.BYTES_PER_ELEMENT, T = (8 - y % 8) % 8;
            if (s < 0) throw new Error(`Unexpected typed array class: ${o}.`);
            c && c instanceof ArrayBuffer ? (this.data = c, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + y + T, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + h + y + T), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + y + T, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + s]), new Uint16Array(this.data, 2, 1)[0] = i, new Uint32Array(this.data, 4, 1)[0] = e);
          }
          add(e, i) {
            const o = this._pos >> 1;
            return this.ids[o] = o, this.coords[this._pos++] = e, this.coords[this._pos++] = i, o;
          }
          finish() {
            const e = this._pos >> 1;
            if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
            return Jm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(e, i, o, c) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: s, coords: h, nodeSize: y } = this, T = [0, s.length - 1, 0], k = [];
            for (; T.length; ) {
              const g = T.pop() || 0, A = T.pop() || 0, D = T.pop() || 0;
              if (A - D <= y) {
                for (let J = D; J <= A; J++) {
                  const ne = h[2 * J], me = h[2 * J + 1];
                  ne >= e && ne <= o && me >= i && me <= c && k.push(s[J]);
                }
                continue;
              }
              const S = D + A >> 1, R = h[2 * S], j = h[2 * S + 1];
              R >= e && R <= o && j >= i && j <= c && k.push(s[S]), (g === 0 ? e <= R : i <= j) && (T.push(D), T.push(S - 1), T.push(1 - g)), (g === 0 ? o >= R : c >= j) && (T.push(S + 1), T.push(A), T.push(1 - g));
            }
            return k;
          }
          within(e, i, o) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: c, coords: s, nodeSize: h } = this, y = [0, c.length - 1, 0], T = [], k = o * o;
            for (; y.length; ) {
              const g = y.pop() || 0, A = y.pop() || 0, D = y.pop() || 0;
              if (A - D <= h) {
                for (let J = D; J <= A; J++) zy(s[2 * J], s[2 * J + 1], e, i) <= k && T.push(c[J]);
                continue;
              }
              const S = D + A >> 1, R = s[2 * S], j = s[2 * S + 1];
              zy(R, j, e, i) <= k && T.push(c[S]), (g === 0 ? e - o <= R : i - o <= j) && (y.push(D), y.push(S - 1), y.push(1 - g)), (g === 0 ? e + o >= R : i + o >= j) && (y.push(S + 1), y.push(A), y.push(1 - g));
            }
            return T;
          }
        }
        function Jm(a, e, i, o, c, s) {
          if (c - o <= i) return;
          const h = o + c >> 1;
          ky(a, e, h, o, c, s), Jm(a, e, i, o, h - 1, 1 - s), Jm(a, e, i, h + 1, c, 1 - s);
        }
        function ky(a, e, i, o, c, s) {
          for (; c > o; ) {
            if (c - o > 600) {
              const k = c - o + 1, g = i - o + 1, A = Math.log(k), D = 0.5 * Math.exp(2 * A / 3), S = 0.5 * Math.sqrt(A * D * (k - D) / k) * (g - k / 2 < 0 ? -1 : 1);
              ky(a, e, i, Math.max(o, Math.floor(i - g * D / k + S)), Math.min(c, Math.floor(i + (k - g) * D / k + S)), s);
            }
            const h = e[2 * i + s];
            let y = o, T = c;
            for (qd(a, e, o, i), e[2 * c + s] > h && qd(a, e, o, c); y < T; ) {
              for (qd(a, e, y, T), y++, T--; e[2 * y + s] < h; ) y++;
              for (; e[2 * T + s] > h; ) T--;
            }
            e[2 * o + s] === h ? qd(a, e, o, T) : (T++, qd(a, e, T, c)), T <= i && (o = T + 1), i <= T && (c = T - 1);
          }
        }
        function qd(a, e, i, o) {
          Qm(a, i, o), Qm(e, 2 * i, 2 * o), Qm(e, 2 * i + 1, 2 * o + 1);
        }
        function Qm(a, e, i) {
          const o = a[e];
          a[e] = a[i], a[i] = o;
        }
        function zy(a, e, i, o) {
          const c = a - i, s = e - o;
          return c * c + s * s;
        }
        r.$ = fc, r.A = ma, r.B = 2, r.C = Id, r.D = Xf, r.E = ds, r.F = qg, r.G = class extends Mp {
        }, r.H = Ba, r.I = Vm, r.J = Us, r.K = is, r.L = Co, r.M = Io, r.N = Tn, r.O = Ll, r.P = Ye, r.Q = No, r.R = Bi, r.S = jh, r.T = Im, r.U = eo, r.V = Mp, r.W = Qo, r.X = qs, r.Y = bs, r.Z = Fa, r._ = Xa, r.a = function(a) {
          return yt.API_CDN_URL_REGEX.test(a);
        }, r.a$ = td, r.a0 = ba, r.a1 = Bn, r.a2 = function(a) {
          const e = a.value;
          let i = [];
          if (!e) return i;
          const o = Ba(e);
          return o !== "string" ? (i = i.concat([new Mp(a.key, e, `string expected, "${o}" found`)]), i) : (L0(e, !0) || (i = i.concat([new Mp(a.key, e, `invalid url "${e}"`)])), i);
        }, r.a3 = Kt, r.a4 = Fl, r.a5 = vn, r.a6 = Mr, r.a7 = class {
          constructor(a) {
            this.specification = a;
          }
          possiblyEvaluate(a, e) {
            return kt(a.expression.evaluate(e));
          }
          interpolate(a, e, i) {
            return { x: li(a.x, e.x, i), y: li(a.y, e.y, i), z: li(a.z, e.z, i), azimuthal: li(a.azimuthal, e.azimuthal, i), polar: li(a.polar, e.polar, i) };
          }
        }, r.a8 = sn, r.a9 = kl, r.aA = oo, r.aB = class {
          constructor(a) {
            this.entries = {}, this.scheduler = a;
          }
          request(a, e, i, o) {
            const c = this.entries[a] = this.entries[a] || { callbacks: [] };
            if (c.result) {
              const [s, h] = c.result;
              return this.scheduler ? this.scheduler.add(() => {
                o(s, h);
              }, e) : o(s, h), () => {
              };
            }
            return c.callbacks.push(o), c.cancel || (c.cancel = i((s, h) => {
              c.result = [s, h];
              for (const y of c.callbacks) this.scheduler ? this.scheduler.add(() => {
                y(s, h);
              }, e) : y(s, h);
              setTimeout(() => delete this.entries[a], 3e3);
            })), () => {
              c.result || (c.callbacks = c.callbacks.filter((s) => s !== o), c.callbacks.length || (c.cancel(), delete this.entries[a]));
            };
          }
        }, r.aC = Va, r.aD = function(a, e, i) {
          const o = JSON.stringify(a.request);
          return a.data && (this.deduped.entries[o] = { result: [null, a.data] }), this.deduped.request(o, { type: "parseTile", isSymbolTile: a.isSymbolTile, zoom: a.tileZoom }, (c) => {
            const s = ea(a.request, (h, y, T, k) => {
              h ? c(h) : y && c(null, { vectorTile: i ? void 0 : new jf.VectorTile(new sp(y)), rawData: y, cacheControl: T, expires: k });
            });
            return () => {
              s.cancel(), c();
            };
          }, e);
        }, r.aE = function(a) {
          qr++, qr > Zt && (a.getActor().send("enforceCacheSizeLimit", At), qr = 0);
        }, r.aF = function(a) {
          return a <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
        }, r.aG = br, r.aH = v0, r.aI = T0, r.aJ = y0, r.aK = function(a, e) {
          const i = document.createElement("video");
          i.muted = !0, i.onloadstart = function() {
            e(null, i);
          };
          for (let o = 0; o < a.length; o++) {
            const c = document.createElement("source");
            Pa(a[o]) || (i.crossOrigin = "Anonymous"), c.src = a[o], i.appendChild(c);
          }
          return { cancel: () => {
          } };
        }, r.aL = bp, r.aM = function(a) {
          return fetch(a).then((e) => e.arrayBuffer()).then((e) => Ay(e, 0, a));
        }, r.aN = Cy, r.aO = class {
          constructor(a, e, i, o) {
            this.id = a, this.position = e != null ? new qi(e[0], e[1]) : new qi(0, 0), this.orientation = i ?? [0, 0, 0], this.nodes = o, this.uploaded = !1, this.aabb = new Yr([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
          }
          _applyTransformations(a, e) {
            if (Oe.mat4.multiply(a.matrix, e, a.matrix), a.meshes) for (const i of a.meshes) {
              const o = Yr.applyTransformFast(i.aabb, a.matrix);
              this.aabb.encapsulate(o);
            }
            if (a.children) for (const i of a.children) this._applyTransformations(i, a.matrix);
          }
          computeBoundsAndApplyParent() {
            const a = Oe.mat4.identity([]);
            for (const e of this.nodes) this._applyTransformations(e, a);
          }
          computeModelMatrix(a, e, i, o, c, s, h = !1) {
            B0(this.matrix, this, a.transform, this.position, e, i, o, c, s, h);
          }
          upload(a) {
            if (!this.uploaded) {
              for (const e of this.nodes) Dm(e, a);
              for (const e of this.nodes) Ap(e);
              this.uploaded = !0;
            }
          }
          destroy() {
            for (const a of this.nodes) km(a);
          }
        }, r.aP = Ur, r.aQ = Rd, r.aR = so, r.aS = ci, r.aT = Dn, r.aU = ha, r.aV = Fr, r.aW = oh, r.aX = vp, r.aY = function() {
          to.isLoading() || to.isLoaded() || Bl() !== "deferred" || wu();
        }, r.aZ = Wh, r.a_ = ae, r.aa = n, r.ab = Oe, r.ac = Xe, r.ad = nl, r.ae = Wa, r.af = li, r.ag = Br, r.ah = ps, r.ai = Ae, r.aj = Xi, r.ak = class {
          constructor(a) {
            this.specification = a;
          }
          possiblyEvaluate(a, e) {
            return function([i, o]) {
              const c = kt([1, i, o]);
              return { x: c.x, y: c.y, z: c.z };
            }(a.expression.evaluate(e));
          }
          interpolate(a, e, i) {
            return { x: li(a.x, e.x, i), y: li(a.y, e.y, i), z: li(a.z, e.z, i) };
          }
        }, r.al = function(a, e, i = 0, o = !0) {
          const c = new Ye(i, i), s = a.sub(c), h = e.add(c), y = [s, new Ye(h.x, s.y), h, new Ye(s.x, h.y)];
          return o && y.push(s.clone()), y;
        }, r.am = function(a, e) {
          const i = [];
          for (let o = 0; o < a.length; o++) {
            const c = bt(o - 1, -1, a.length - 1), s = bt(o + 1, -1, a.length - 1), h = a[o], y = a[s], T = a[c].sub(h).unit(), k = y.sub(h).unit(), g = k.angleWithSep(T.x, T.y), A = T.add(k).unit().mult(-1 * e / Math.sin(g / 2));
            i.push(h.add(A));
          }
          return i;
        }, r.an = n0, r.ao = gt, r.ap = function(a, e, i = 0) {
          return Oe.vec3.fromValues(((e.x - i) * a.scale - a.x) * Br, (e.y * a.scale - a.y) * Br, Xl(e.z, e.y));
        }, r.aq = yi, r.ar = wg, r.as = function(a) {
          let e = 1 / 0, i = 1 / 0, o = -1 / 0, c = -1 / 0;
          for (const s of a) e = Math.min(e, s.x), i = Math.min(i, s.y), o = Math.max(o, s.x), c = Math.max(c, s.y);
          return { min: new Ye(e, i), max: new Ye(o, c) };
        }, r.at = ls, r.au = dt, r.av = d, r.aw = ie, r.ax = Ca, r.ay = function(a, e) {
          const i = {};
          for (let o = 0; o < e.length; o++) {
            const c = e[o];
            c in a && (i[c] = a[c]);
          }
          return i;
        }, r.az = Ds, r.b = function(a) {
          return yt.API_FONTS_REGEX.test(a);
        }, r.b$ = Sp, r.b0 = Je, r.b1 = sm, r.b2 = na, r.b3 = K, r.b4 = Ga, r.b5 = Au, r.b6 = oi, r.b7 = Nn, r.b8 = mh, r.b9 = Tm, r.bA = eg, r.bB = vm, r.bC = e0, r.bD = _m, r.bE = Km, r.bF = bt, r.bG = ni, r.bH = xn, r.bI = function(a, e, i) {
          a[4 * e + 0] = i[0], a[4 * e + 1] = i[1], a[4 * e + 2] = i[2], a[4 * e + 3] = i[3];
        }, r.bJ = Du, r.bK = io, r.bL = Ru, r.bM = kn, r.bN = os, r.bO = qi, r.bP = u0, r.bQ = hr, r.bR = Di, r.bS = A0, r.bT = mr, r.bU = va, r.bV = function(a, e, i, o, c, s, h, y, T) {
          if (T.name === "globe") return va(a, e, new mr(i, o, c), !1);
          const k = Rd({ z: i, x: o, y: c }, T);
          return new Yr([(s + k.x / k.scale) * e, e * (k.y / k.scale), h], [(s + k.x2 / k.scale) * e, e * (k.y2 / k.scale), y]);
        }, r.bW = function(a, e, i) {
          let o = 0;
          for (let c = 0; c < 2; ++c)
            a[c] > 0 && (o += (a[c] - 0) * (a[c] - 0)), e[c] < 0 && (o += (0 - e[c]) * (0 - e[c]));
          return o;
        }, r.bX = Cn, r.bY = wc, r.bZ = function(a) {
          const e = Oe.mat4.identity(new Float64Array(16));
          Oe.mat4.multiply(e, a.pixelMatrix, a.globeMatrix);
          const i = [0, no, 0], o = [0, ka, 0];
          return Oe.vec3.transformMat4(i, i, e), Oe.vec3.transformMat4(o, o, e), [i[0] > 0 && i[0] <= a.width && i[1] > 0 && i[1] <= a.height && !bo(a, new qi(a.center.lat, 90)), o[0] > 0 && o[0] <= a.width && o[1] > 0 && o[1] <= a.height && !bo(a, new qi(a.center.lat, -90))];
        }, r.b_ = function(a, e) {
          const { scale: i } = a.tileTransform, o = i * Br / (a.tileSize * Math.pow(2, e.zoom - a.tileID.overscaledZ + a.tileID.canonical.z));
          return Oe.mat2.scale(new Float32Array(4), e.inverseAdjustmentMatrix, [o, o]);
        }, r.ba = function(a, e) {
          const i = Wa(e.zoom);
          if (i === 0) return Zn(a);
          const o = pn(a), c = hn(o), s = ls(o.getWest()) * e.worldSize, h = ls(o.getEast()) * e.worldSize, y = oo(o.getNorth()) * e.worldSize, T = oo(o.getSouth()) * e.worldSize, k = [s, y, 0], g = [h, y, 0], A = [s, T, 0], D = [h, T, 0], S = Oe.mat4.invert([], e.globeMatrix);
          return Oe.vec3.transformMat4(k, k, S), Oe.vec3.transformMat4(g, g, S), Oe.vec3.transformMat4(A, A, S), Oe.vec3.transformMat4(D, D, S), c[0] = jn(c[0], A, i), c[1] = jn(c[1], D, i), c[2] = jn(c[2], g, i), c[3] = jn(c[3], k, i), Yr.fromPoints(c);
        }, r.bb = ia, r.bc = ln, r.bd = jn, r.be = In, r.bf = ii, r.bg = Zm, r.bh = sp, r.bi = ea, r.bj = function(a) {
          const e = [];
          for (const i in a) e.push(a[i]);
          return e;
        }, r.bk = function(a, e) {
          const i = [];
          for (const o in a) o in e || i.push(o);
          return i;
        }, r.bl = Wt, r.bm = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], r.bn = qe, r.bo = function(a, e) {
          const { x: i, y: o } = a.point, c = fa(i, o, a.worldSize / a._pixelsPerMercatorPixel, 0, 0);
          return Oe.mat4.multiply(c, c, fn(Zn(e)));
        }, r.bp = Vf, r.bq = ks, r.br = op, r.bs = function(a, e, i, o, c) {
          const s = 5 * e + 2;
          a.float32[s + 0] = i, a.float32[s + 1] = o, a.float32[s + 2] = c;
        }, r.bt = yp, r.bu = Zg, r.bv = Re, r.bw = qa, r.bx = $_, r.by = R0, r.bz = Q_, r.c = Or, r.c$ = (a, e, i, o, c, s, h, y) => {
          const T = a.transform, k = T.pitch < 15 ? Eg(0.07, 0.7, ie((14 - T.zoom) / 5, 0, 1)) : 0.07, g = i.paint.get("line-trim-color-use-theme").constantOr("default") === "none";
          return { u_matrix: Tg(a, e, i, o), u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: T.calculatePixelsToTileUnitsMatrix(e), u_device_pixel_ratio: c, u_width_scale: s, u_floor_width_scale: h, u_image: 0, u_tile_units_to_pixels: Sg(e, T), u_units_to_pixels: [1 / T.pixelsToGLUnits[0], 1 / T.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: y, u_trim_fade_range: i.paint.get("line-trim-fade-range"), u_trim_color: i.paint.get("line-trim-color").toRenderColor(g ? null : i.lut).toArray01(), u_emissive_strength: i.paint.get("line-emissive-strength"), u_zbias_factor: k, u_tile_to_meter: t(e.tileID.canonical, 0) };
        }, r.c0 = M0, r.c1 = function(a) {
          const e = M0(a, !0);
          return Oe.mat2.invert([], [e[0], e[1], e[4], e[5]]);
        }, r.c2 = Ui, r.c3 = function(a) {
          const { x: e, y: i } = a.point, { lng: o, lat: c } = a._center;
          return fa(e, i, a.worldSize, o, c);
        }, r.c4 = _e, r.c5 = Cr, r.c6 = hl, r.c7 = function(a) {
          const e = Math.round((a + 45 + 360) % 360 / 90) % 4;
          return fe[e];
        }, r.c8 = 45, r.c9 = hh, r.cA = class extends Do {
          constructor(a) {
            super(a), this.current = uh;
          }
          set(a, e, i) {
            if (this.fetchUniformLocation(a, e)) {
              for (let o = 0; o < 9; o++) if (i[o] !== this.current[o]) {
                this.current = i, this.gl.uniformMatrix3fv(this.location, !1, i);
                break;
              }
            }
          }
        }, r.cB = We, r.cC = function(a, e, i) {
          const o = Wa(i.zoom), c = a.style.map._antialias, s = a.terrain && a.terrain.exaggeration() > 0;
          return o === 0 && !c && !s;
        }, r.cD = function(a) {
          const e = a.pixelsPerMeter, i = e / xn(1, a.center.lat), o = Oe.mat4.identity(new Float64Array(16));
          return Oe.mat4.translate(o, o, [a.point.x, a.point.y, 0]), Oe.mat4.scale(o, o, [i, i, e]), Float32Array.from(o);
        }, r.cE = pn, r.cF = function(a) {
          const e = Cn - 5;
          a = ie(a, -e, e) / e * 90;
          const i = Math.pow(Math.abs(Math.sin(Ae(a))), 3);
          return Math.round(i * (zu.length - 1));
        }, r.cG = function(a, e, i, o) {
          const c = e.getNorth(), s = e.getSouth(), h = e.getWest(), y = e.getEast(), T = 1 << a.z, k = y - h, g = c - s, A = k / ql, D = -g / zu[i], S = [0, A, 0, D, 0, 0, c, h, 0];
          if (a.z > 0) {
            const R = 180 / o;
            Oe.mat3.multiply(S, S, [R / k + 1, 0, 0, 0, R / g + 1, 0, -0.5 * R / A, 0.5 * R / D, 1]);
          }
          return S[2] = T, S[5] = a.x, S[8] = a.y, S;
        }, r.cH = Zn, r.cI = function(a, e, i) {
          const o = Oe.mat4.identity(new Float64Array(16)), c = (e / (1 << a) - 0.5) * Math.PI * 2;
          return Oe.mat4.rotateY(o, i.globeMatrix, c), Float32Array.from(o);
        }, r.cJ = class {
          isDataAvailableAtPoint(a) {
            const e = this._source();
            if (this.isUsingMockSource() || !e || a.y < 0 || a.y > 1) return !1;
            const i = e.getSource().maxzoom, o = 1 << i, c = Math.floor(a.x), s = Math.floor((a.x - c) * o), h = Math.floor(a.y * o), y = this.findDEMTileFor(new br(i, c, i, s, h));
            return !(!y || !y.dem);
          }
          getAtPointOrZero(a, e = 0) {
            return this.getAtPoint(a, e) || 0;
          }
          getAtPoint(a, e, i = !0) {
            if (this.isUsingMockSource()) return null;
            e == null && (e = null);
            const o = this._source();
            if (!o || a.y < 0 || a.y > 1) return e;
            const c = o.getSource().maxzoom, s = 1 << c, h = Math.floor(a.x), y = a.x - h, T = new br(c, h, c, Math.floor(y * s), Math.floor(a.y * s)), k = this.findDEMTileFor(T);
            if (!k || !k.dem) return e;
            const g = k.dem, A = 1 << k.tileID.canonical.z, D = (y * A - k.tileID.canonical.x) * g.dim, S = (a.y * A - k.tileID.canonical.y) * g.dim, R = Math.floor(D), j = Math.floor(S);
            return (i ? this.exaggeration() : 1) * li(li(g.get(R, j), g.get(R, j + 1), S - j), li(g.get(R + 1, j), g.get(R + 1, j + 1), S - j), D - R);
          }
          getAtTileOffset(a, e, i) {
            const o = 1 << a.canonical.z;
            return this.getAtPointOrZero(new n(a.wrap + (a.canonical.x + e / Br) / o, (a.canonical.y + i / Br) / o));
          }
          getAtTileOffsetFunc(a, e, i, o) {
            return (c) => {
              const s = this.getAtTileOffset(a, c.x, c.y), h = o.upVector(a.canonical, c.x, c.y), y = o.upVectorScale(a.canonical, e, i).metersToTile;
              return Oe.vec3.scale(h, h, s * y), h;
            };
          }
          getForTilePoints(a, e, i, o) {
            if (this.isUsingMockSource()) return !1;
            const c = $f.create(this, a, o);
            return !!c && (e.forEach((s) => {
              s[2] = this.exaggeration() * c.getElevationAt(s[0], s[1], i);
            }), !0);
          }
          getMinMaxForTile(a) {
            if (this.isUsingMockSource()) return null;
            const e = this.findDEMTileFor(a);
            if (!e || !e.dem) return null;
            const i = e.dem.tree, o = e.tileID, c = 1 << a.canonical.z - o.canonical.z;
            let s = a.canonical.x / c - o.canonical.x, h = a.canonical.y / c - o.canonical.y, y = 0;
            for (let T = 0; T < a.canonical.z - o.canonical.z && !i.leaves[y]; T++) {
              s *= 2, h *= 2;
              const k = 2 * Math.floor(h) + Math.floor(s);
              y = i.childOffsets[y] + k, s %= 1, h %= 1;
            }
            return { min: this.exaggeration() * i.minimums[y], max: this.exaggeration() * i.maximums[y] };
          }
          getMinElevationBelowMSL() {
            throw new Error("Pure virtual method called.");
          }
          raycast(a, e, i) {
            throw new Error("Pure virtual method called.");
          }
          pointCoordinate(a) {
            throw new Error("Pure virtual method called.");
          }
          _source() {
            throw new Error("Pure virtual method called.");
          }
          isUsingMockSource() {
            throw new Error("Pure virtual method called.");
          }
          exaggeration() {
            throw new Error("Pure virtual method called.");
          }
          findDEMTileFor(a) {
            throw new Error("Pure virtual method called.");
          }
          get visibleDemTiles() {
            throw new Error("Getter must be implemented in subclass.");
          }
          getMinMaxForVisibleTiles() {
            const a = this.visibleDemTiles;
            if (a.length === 0) return null;
            let e = !1, i = Number.MAX_VALUE, o = Number.MIN_VALUE;
            for (const c of a) {
              const s = this.getMinMaxForTile(c.tileID);
              s && (i = Math.min(i, s.min), o = Math.max(o, s.max), e = !0);
            }
            return e ? { min: i, max: o } : null;
          }
        }, r.cK = yd, r.cL = Fi, r.cM = function(a, e) {
          return [Math.pow(a[0], 2.2) * e, Math.pow(a[1], 2.2) * e, Math.pow(a[2], 2.2) * e];
        }, r.cN = xo, r.cO = we, r.cP = er, r.cQ = 256, r.cR = function(a, e) {
          const i = [0, 0, 0], o = ia(Zn(e.canonical));
          return Oe.vec3.transformMat4(i, i, o), Oe.vec3.transformMat4(i, i, a), i;
        }, r.cS = (a) => ({ u_camera_to_center_distance: new kn(a), u_extrude_scale: new Da(a), u_device_pixel_ratio: new kn(a), u_matrix: new Du(a), u_inv_rot_matrix: new Du(a), u_merc_center: new io(a), u_tile_id: new Ru(a), u_zoom_transition: new kn(a), u_up_dir: new Ru(a), u_emissive_strength: new kn(a) }), r.cT = (a) => ({ u_matrix: new Du(a), u_pixels_to_tile_units: new Da(a), u_device_pixel_ratio: new kn(a), u_width_scale: new kn(a), u_floor_width_scale: new kn(a), u_units_to_pixels: new io(a), u_dash_image: new os(a), u_gradient_image: new os(a), u_image_height: new kn(a), u_texsize: new io(a), u_tile_units_to_pixels: new kn(a), u_alpha_discard_threshold: new kn(a), u_trim_offset: new io(a), u_trim_fade_range: new io(a), u_trim_color: new Lu(a), u_emissive_strength: new kn(a), u_zbias_factor: new kn(a), u_tile_to_meter: new kn(a) }), r.cU = (a) => ({ u_matrix: new Du(a), u_texsize: new io(a), u_pixels_to_tile_units: new Da(a), u_device_pixel_ratio: new kn(a), u_width_scale: new kn(a), u_floor_width_scale: new kn(a), u_image: new os(a), u_units_to_pixels: new io(a), u_tile_units_to_pixels: new kn(a), u_alpha_discard_threshold: new kn(a), u_trim_offset: new io(a), u_trim_fade_range: new io(a), u_trim_color: new Lu(a), u_emissive_strength: new kn(a), u_zbias_factor: new kn(a), u_tile_to_meter: new kn(a) }), r.cV = mc, r.cW = u1, r.cX = c1, r.cY = Bu, r.cZ = (a, e, i, o, c, s) => {
          const h = a.transform, y = h.projection.name === "globe";
          let T;
          if (s.paint.get("circle-pitch-alignment") === "map") if (y) {
            const g = xo(h.zoom, e.canonical) * h._pixelsPerMercatorPixel;
            T = Float32Array.from([g, 0, 0, g]);
          } else T = h.calculatePixelsToTileUnitsMatrix(i);
          else T = new Float32Array([h.pixelsToGLUnits[0], 0, 0, h.pixelsToGLUnits[1]]);
          const k = { u_camera_to_center_distance: a.transform.getCameraToCenterDistance(h.projection), u_matrix: a.translatePosMatrix(e.projMatrix, i, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")), u_device_pixel_ratio: ht.devicePixelRatio, u_extrude_scale: T, u_inv_rot_matrix: Kl, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: s.paint.get("circle-emissive-strength") };
          if (y) {
            k.u_inv_rot_matrix = o, k.u_merc_center = c, k.u_tile_id = [e.canonical.x, e.canonical.y, 1 << e.canonical.z], k.u_zoom_transition = Wa(h.zoom);
            const g = c[0] * Br, A = c[1] * Br;
            k.u_up_dir = h.projection.upVector(new mr(0, 0, 0), g, A);
          }
          return k;
        }, r.c_ = Mg, r.ca = Lu, r.cb = function(a, e, i) {
          const o = Math.sqrt(a * a + e * e + i * i), c = o > 0 ? Math.acos(i / o) * it : 0;
          let s = a !== 0 || e !== 0 ? Math.atan2(-e, -a) * it + 90 : 0;
          return s < 0 && (s += 360), [o, s, c];
        }, r.cc = t, r.cd = Yr, r.ce = kt, r.cf = function(a) {
          return [Math.pow(a[0], 1 / 2.2), Math.pow(a[1], 1 / 2.2), Math.pow(a[2], 1 / 2.2)];
        }, r.cg = function(a, e) {
          return a.readFields(tx, { icons: [] }, e);
        }, r.ch = function(a) {
          return a({ pluginStatus: ja, pluginURL: yo }), rs.on("pluginStateChange", a), a;
        }, r.ci = Cp, r.cj = Hf, r.ck = gm, r.cl = sa, r.cm = cc, r.cn = Pt, r.co = co, r.cp = Vr, r.cq = function(a) {
          const e = a.indexOf(Eu);
          return e >= 0 ? a.slice(0, e) : a;
        }, r.cr = function(a) {
          return a.indexOf(Eu) >= 0;
        }, r.cs = function(a) {
          const e = a.indexOf(Eu);
          return e >= 0 ? a.slice(e + 1) : "";
        }, r.ct = function(a) {
          const e = [], i = a.id;
          return i === void 0 && e.push({ message: `layers.${i}: missing required property "id"` }), a.render === void 0 && e.push({ message: `layers.${i}: missing required method "render"` }), a.renderingMode && a.renderingMode !== "2d" && a.renderingMode !== "3d" && e.push({ message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"` }), e;
        }, r.cu = function(a, e, i, o) {
          return a.type === "custom" ? new j1(a, e) : new J1[a.type](a, e, i, o);
        }, r.cv = hi, r.cw = class extends td {
          constructor(a, e) {
            super(a._vectorTileFeature, a._z, a._x, a._y, a.id), a.state && (this.state = Object.assign({}, a.state)), this.target = e.target, this.namespace = e.namespace, e.properties && (this.properties = e.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = a.source, this.sourceLayer = a.sourceLayer, this.layer = a.layer);
          }
          toJSON() {
            const a = super.toJSON();
            return a.target = this.target, a.namespace = this.namespace, a;
          }
        }, r.cx = rs, r.cy = Yn, r.cz = ef, r.d = function(a) {
          return yt.API_TILEJSON_REGEX.test(a);
        }, r.d$ = Ry, r.d0 = (a, e, i, o, c, s, h, y, T) => {
          const k = a.transform, g = k.calculatePixelsToTileUnitsMatrix(e), A = i.paint.get("line-trim-color-use-theme").constantOr("default") === "none", D = k.pitch < 15 ? Eg(0.07, 0.7, ie((14 - k.zoom) / 5, 0, 1)) : 0.07;
          return { u_matrix: Tg(a, e, i, o), u_pixels_to_tile_units: g, u_device_pixel_ratio: s, u_width_scale: h, u_floor_width_scale: y, u_units_to_pixels: [1 / k.pixelsToGLUnits[0], 1 / k.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: c, u_texsize: Ag(i) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Sg(e, a.transform), u_alpha_discard_threshold: 0, u_trim_offset: T, u_trim_fade_range: i.paint.get("line-trim-fade-range"), u_trim_color: i.paint.get("line-trim-color").toRenderColor(A ? null : i.lut).toArray01(), u_emissive_strength: i.paint.get("line-emissive-strength"), u_zbias_factor: D, u_tile_to_meter: t(e.tileID.canonical, 0) };
        }, r.d1 = kr, r.d2 = ph, r.d3 = dg, r.d4 = Hr, r.d5 = ap, r.d6 = _h, r.d7 = 450, r.d8 = 7, r.d9 = U1, r.dA = he, r.dB = l, r.dC = $l, r.dD = function([a, e, i]) {
          const o = Math.hypot(a, e, i), c = Math.atan2(a, i), s = 0.5 * Math.PI - Math.acos(-e / o);
          return new qi(_e(c), _e(s));
        }, r.dE = Pm, r.dF = function(a) {
          const e = a.navigator ? a.navigator.userAgent : null;
          return !!function(i) {
            if (wr == null) {
              const o = i.navigator ? i.navigator.userAgent : null;
              wr = !!i.safari || !(!o || !(/\b(iPad|iPhone|iPod)\b/.test(o) || o.match("Safari") && !o.match("Chrome")));
            }
            return wr;
          }(a) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, r.dG = function(a, e) {
          At = a, Zt = e;
        }, r.dH = bo, r.dI = Za, r.dJ = function(a) {
          const e = [0, 0, 0], i = Oe.mat4.identity(new Float64Array(16));
          return Oe.mat4.multiply(i, a.pixelMatrix, a.globeMatrix), Oe.vec3.transformMat4(e, e, i), new Ye(e[0], e[1]);
        }, r.dK = function(a, e, i = !1) {
          if (ja === Ol || ja === bu || ja === Yc) throw new Error("setRTLTextPlugin cannot be called multiple times.");
          yo = ht.resolveURL(a), ja = Ol, go = e, Hh(), i || wu();
        }, r.dL = Bl, r.dM = function() {
          Cp().acquire(Om);
        }, r.dN = function() {
          const a = Nd;
          a && (a.isPreloaded() && a.numActive() === 1 ? (a.release(Om), Nd = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, r.dO = uf, r.dP = function(a) {
          const e = Ir();
          if (!e) return;
          const i = e.delete(Nt);
          a && i.catch(a).then(() => a());
        }, r.dQ = Fd, r.dR = xy, r.dS = function(a) {
          qm = ht.resolveURL(a), ed || (ed = new Xf(Cp(), new ds())), ed.broadcast("setDracoUrl", qm);
        }, r.dT = by, r.dU = function(a) {
          Qf = ht.resolveURL(a), ed || (ed = new Xf(Cp(), new ds())), ed.broadcast("setMeshoptUrl", Qf);
        }, r.dV = Gr, r.dW = dl, r.dX = tu, r.dY = jf, r.dZ = class {
          constructor(a, e) {
            this.pos = a, this.dir = e;
          }
          intersectsPlane(a, e, i) {
            const o = Oe.vec2.dot(e, this.dir);
            if (Math.abs(o) < 1e-6) return !1;
            const c = ((a[0] - this.pos[0]) * e[0] + (a[1] - this.pos[1]) * e[1]) / o;
            return i[0] = this.pos[0] + this.dir[0] * c, i[1] = this.pos[1] + this.dir[1] * c, !0;
          }
        }, r.d_ = Py, r.da = Yi, r.db = ah, r.dc = 256, r.dd = fn, r.de = ro, r.df = Cs, r.dg = _c, r.dh = function(a, e, i, o, c) {
          return ie((a - e) / (i - e) * (c - o) + o, o, c);
        }, r.di = Ao, r.dj = Ou, r.dk = class {
          constructor(a, e, i, o) {
            this.context = a, this.format = o, this.size = i, this.texture = a.gl.createTexture();
            const [c, s, h] = this.size, { gl: y } = a;
            y.bindTexture(y.TEXTURE_3D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(!1), y.texImage3D(y.TEXTURE_3D, 0, this.format, c, s, h, 0, Mm(this.format), Am(this.format), e.data);
          }
          bind(a, e) {
            const { context: i } = this, { gl: o } = i;
            o.bindTexture(o.TEXTURE_3D, this.texture), a !== this.minFilter && (o.texParameteri(o.TEXTURE_3D, o.TEXTURE_MAG_FILTER, a), o.texParameteri(o.TEXTURE_3D, o.TEXTURE_MIN_FILTER, a), this.minFilter = a), e !== this.wrapS && (o.texParameteri(o.TEXTURE_3D, o.TEXTURE_WRAP_S, e), o.texParameteri(o.TEXTURE_3D, o.TEXTURE_WRAP_T, e), this.wrapS = e);
          }
          destroy() {
            const { gl: a } = this.context;
            a.deleteTexture(this.texture), this.texture = null;
          }
        }, r.dl = Rm, r.dm = [1, 1, 1], r.dn = $f, r.dp = qf, r.dq = ga, r.dr = Hl, r.ds = fl, r.dt = sl, r.du = Uo, r.dv = class {
          constructor() {
            this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = { min: new Ye(1 / 0, 1 / 0), max: new Ye(-1 / 0, -1 / 0) };
          }
          clear() {
            this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
          }
          get updateTime() {
            return this._updateTime;
          }
          getReplacementRegionsForTile(a, e = !1) {
            const i = Y_(new Ye(0, 0), new Ye(Br, Br), a), o = [];
            if (e && !rm(i, this._globalClipBounds)) return o;
            for (const c of this._activeRegions) {
              if (c.hiddenByOverlap || !rm(i, c)) continue;
              const s = Ov(c.min, c.max, a);
              o.push({ min: s.min, max: s.max, sourceId: this._sourceIds[c.priority], footprint: c.footprint, footprintTileId: c.tileId, order: c.order, clipMask: c.clipMask, clipScope: c.clipScope });
            }
            return o;
          }
          setSources(a) {
            this._setSources(a.map((e) => ({ getSourceId: () => e.cache.id, getFootprints: () => {
              const i = [];
              for (const o of e.cache.getVisibleCoordinates()) {
                const c = e.cache.getTile(o).buckets[e.layer];
                c && c.updateFootprints(o.toUnwrapped(), i);
              }
              return i;
            }, getOrder: () => e.order, getClipMask: () => e.clipMask, getClipScope: () => e.clipScope })));
          }
          _addSource(a) {
            const e = a.getFootprints();
            if (e.length === 0) return;
            const i = a.getOrder(), o = a.getClipMask(), c = a.getClipScope();
            for (const s of e) {
              if (!s.footprint) continue;
              const h = Y_(s.footprint.min, s.footprint.max, s.id);
              this._activeRegions.push({ min: h.min, max: h.max, hiddenByOverlap: !1, priority: this._sourceIds.length, tileId: s.id, footprint: s.footprint, order: i, clipMask: o, clipScope: c });
            }
            this._sourceIds.push(a.getSourceId());
          }
          _computeReplacement() {
            this._activeRegions.sort((e, i) => e.priority - i.priority || ip(e.min, i.min) || ip(e.max, i.max) || e.order - i.order || e.clipMask - i.clipMask || function(o, c) {
              const s = (h, y) => h + y;
              return o.length - c.length || o.reduce(s, "").localeCompare(c.reduce(s, ""));
            }(e.clipScope, i.clipScope));
            let a = this._activeRegions.length !== this._prevRegions.length;
            if (!a) {
              let e = 0;
              for (; !a && e !== this._activeRegions.length; ) {
                const i = this._activeRegions[e], o = this._prevRegions[e];
                a = i.priority !== o.priority || !X_(i, o) || i.order !== o.order || i.clipMask !== o.clipMask || !qe(i.clipScope, o.clipScope), ++e;
              }
            }
            if (a) {
              ++this._updateTime;
              for (const i of this._activeRegions) i.order !== rp && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, i.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, i.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, i.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, i.max.y));
              const e = (i) => {
                const o = this._activeRegions;
                if (i >= o.length) return i;
                const c = o[i].priority;
                for (; i < o.length && o[i].priority === c; ) ++i;
                return i;
              };
              if (this._sourceIds.length > 1) {
                let i = 0, o = e(i);
                for (; i !== o; ) {
                  let c = i;
                  const s = i;
                  for (; c !== o; ) {
                    const h = this._activeRegions[c];
                    h.hiddenByOverlap = !1;
                    for (let y = 0; y < s; y++) {
                      const T = this._activeRegions[y];
                      if (!T.hiddenByOverlap && h.order === rp && rm(h, T) && (h.hiddenByOverlap = J_(h.footprint, h.tileId, T.footprint, T.tileId), h.hiddenByOverlap)) break;
                    }
                    ++c;
                  }
                  i = o, o = e(i);
                }
              }
            }
          }
          _setSources(a) {
            [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
            for (let e = a.length - 1; e >= 0; e--) this._addSource(a[e]);
            this._computeReplacement();
          }
        }, r.dw = class {
          constructor(a) {
            this._createGrid(a), this._createPoles(a);
          }
          destroy() {
            this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
            for (const a of this._poleSegments) a.destroy();
            for (const a of this._gridSegments) a.withSkirts.destroy(), a.withoutSkirts.destroy();
          }
          _fillGridMeshWithLods(a, e) {
            const i = new Ga(), o = new ha(), c = [], s = a + 1 + 2, h = e[0] + 1, y = e[0] + 1 + (1 + e.length), T = (k, g, A) => {
              let D = k === s - 1 ? k - 2 : k === 0 ? k : k - 1;
              return D += A ? 24575 : 0, [D, g];
            };
            for (let k = 0; k < s; ++k) i.emplaceBack(...T(k, 0, !0));
            for (let k = 0; k < h; ++k) for (let g = 0; g < s; ++g) i.emplaceBack(...T(g, k, (g === 0 || g === s - 1) && !0));
            for (let k = 0; k < e.length; ++k) {
              const g = e[k];
              for (let A = 0; A < s; ++A) i.emplaceBack(...T(A, g, !0));
            }
            for (let k = 0; k < e.length; ++k) {
              const g = o.length, A = e[k] + 1 + 2, D = new ha();
              for (let j = 0; j < A - 1; j++) {
                const J = j === A - 2, ne = J ? s * (y - e.length + k - j) : s;
                for (let me = 0; me < s - 1; me++) {
                  const ge = j * s + me;
                  j === 0 || J || me === 0 || me === s - 2 ? (D.emplaceBack(ge + 1, ge, ge + ne), D.emplaceBack(ge + ne, ge + ne + 1, ge + 1)) : (o.emplaceBack(ge + 1, ge, ge + ne), o.emplaceBack(ge + ne, ge + ne + 1, ge + 1));
                }
              }
              const S = Nn.simpleSegment(0, g, i.length, o.length - g);
              for (let j = 0; j < D.uint16.length; j += 3) o.emplaceBack(D.uint16[j], D.uint16[j + 1], D.uint16[j + 2]);
              const R = Nn.simpleSegment(0, g, i.length, o.length - g);
              c.push({ withoutSkirts: S, withSkirts: R });
            }
            return { vertices: i, indices: o, segments: c };
          }
          _createGrid(a) {
            const e = this._fillGridMeshWithLods(ql, zu);
            this._gridSegments = e.segments, this._gridBuffer = a.createVertexBuffer(e.vertices, oi.members), this._gridIndexBuffer = a.createIndexBuffer(e.indices, !0);
          }
          _createPoles(a) {
            const e = new ha();
            for (let h = 0; h <= ql; h++) e.emplaceBack(0, h + 1, h + 2);
            this._poleIndexBuffer = a.createIndexBuffer(e, !0);
            const i = new Cs(), o = new Cs(), c = new Cs(), s = new Cs();
            this._poleSegments = [];
            for (let h = 0, y = 0; h < hl; h++) {
              const T = 360 / (1 << h);
              i.emplaceBack(0, -Ca, 0, 0.5, 0), o.emplaceBack(0, -Ca, 0, 0.5, 1), c.emplaceBack(0, -Ca, 0, 0.5, 0.5), s.emplaceBack(0, -Ca, 0, 0.5, 0.5);
              for (let k = 0; k <= ql; k++) {
                let g = k / ql, A = 0;
                const D = li(0, T, g), [S, R, j] = ao(Yl, Vo, D, Ca);
                i.emplaceBack(S, R, j, g, A), o.emplaceBack(S, R, j, g, 1 - A);
                const J = Ae(D);
                g = 0.5 + 0.5 * Math.sin(J), A = 0.5 + 0.5 * Math.cos(J), c.emplaceBack(S, R, j, g, A), s.emplaceBack(S, R, j, g, 1 - A);
              }
              this._poleSegments.push(Nn.simpleSegment(y, 0, 66, 64)), y += 66;
            }
            this._poleNorthVertexBuffer = a.createVertexBuffer(i, mi, !1), this._poleSouthVertexBuffer = a.createVertexBuffer(o, mi, !1), this._texturedPoleNorthVertexBuffer = a.createVertexBuffer(c, mi, !1), this._texturedPoleSouthVertexBuffer = a.createVertexBuffer(s, mi, !1);
          }
          getGridBuffers(a, e) {
            return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[a].withSkirts : this._gridSegments[a].withoutSkirts];
          }
          getPoleBuffers(a, e) {
            return [e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[a]];
          }
        }, r.dx = rp, r.dy = Pe, r.dz = function() {
          return !!document.fullscreenElement || !!document.webkitFullscreenElement;
        }, r.e = yt, r.e0 = vg, r.e1 = Pr, r.e2 = ho, r.e3 = $g, r.e4 = function(a, e, i, o, c, s, h, y, T, k, g = 1, A, D) {
          a.createArrays(), a.tilePixelRatio = Br / (512 * a.overscaling), a.compareText = {}, a.iconsNeedLinear = !1;
          const S = a.layers[0].layout, R = a.layers[0]._unevaluatedLayout._values, j = {};
          j.scaleFactor = g, j.textSizeScaleRange = S.get("text-size-scale-range"), j.iconSizeScaleRange = S.get("icon-size-scale-range");
          const [J, ne] = j.textSizeScaleRange, [me, ge] = j.iconSizeScaleRange;
          if (j.textScaleFactor = ie(j.scaleFactor, J, ne), j.iconScaleFactor = ie(j.scaleFactor, me, ge), a.textSizeData.kind === "composite") {
            const { minZoom: He, maxZoom: at } = a.textSizeData;
            j.compositeTextSizes = [R["text-size"].possiblyEvaluate(new sn(He), y), R["text-size"].possiblyEvaluate(new sn(at), y)];
          }
          if (a.iconSizeData.kind === "composite") {
            const { minZoom: He, maxZoom: at } = a.iconSizeData;
            j.compositeIconSizes = [R["icon-size"].possiblyEvaluate(new sn(He), y), R["icon-size"].possiblyEvaluate(new sn(at), y)];
          }
          j.layoutTextSize = R["text-size"].possiblyEvaluate(new sn(T + 1), y), j.layoutIconSize = R["icon-size"].possiblyEvaluate(new sn(T + 1), y), j.textMaxSize = R["text-size"].possiblyEvaluate(new sn(18), y);
          const ue = S.get("text-rotation-alignment") === "map" && S.get("symbol-placement") !== "point", Se = S.get("text-size");
          let ke = !1;
          for (const He of a.features) if (He.icon && He.icon.nameSecondary) {
            ke = !0;
            break;
          }
          for (const He of a.features) {
            const at = S.get("text-font").evaluate(He, {}, y).join(","), nt = Se.evaluate(He, {}, y) * j.textScaleFactor, tt = j.layoutTextSize.evaluate(He, {}, y) * j.textScaleFactor, Et = (j.layoutIconSize.evaluate(He, {}, y), { horizontal: {}, vertical: void 0 }), lt = He.text;
            let St, Lt = [0, 0];
            if (lt) {
              const Ft = lt.toString(), qt = S.get("text-letter-spacing").evaluate(He, {}, y) * qa, Ot = S.get("text-line-height").evaluate(He, {}, y) * qa, cr = Vh(Ft) ? qt : 0, yr = S.get("text-anchor").evaluate(He, {}, y), ur = S.get("text-variable-anchor");
              if (!ur) {
                const ti = S.get("text-radial-offset").evaluate(He, {}, y);
                Lt = ti ? e0(yr, [ti * qa, ym]) : S.get("text-offset").evaluate(He, {}, y).map((Wr) => Wr * qa);
              }
              let jr = ue ? "center" : S.get("text-justify").evaluate(He, {}, y);
              const zr = S.get("symbol-placement") === "point", Ar = zr ? S.get("text-max-width").evaluate(He, {}, y) * qa : 1 / 0, vr = (ti) => {
                a.allowVerticalPlacement && uc(Ft) && (Et.vertical = mm(lt, e, i, c, at, Ar, Ot, yr, ti, cr, Lt, ks.vertical, !0, tt, nt));
              };
              if (!ue && ur) {
                const ti = jr === "auto" ? ur.map(($r) => vm($r)) : [jr];
                let Wr = !1;
                for (let $r = 0; $r < ti.length; $r++) {
                  const bi = ti[$r];
                  if (!Et.horizontal[bi]) if (Wr) Et.horizontal[bi] = Et.horizontal[0];
                  else {
                    const Ci = mm(lt, e, i, c, at, Ar, Ot, "center", bi, cr, Lt, ks.horizontal, !1, tt, nt);
                    Ci && (Et.horizontal[bi] = Ci, Wr = Ci.positionedLines.length === 1);
                  }
                }
                vr("left");
              } else {
                if (jr === "auto" && (jr = vm(yr)), zr || S.get("text-writing-mode").indexOf("horizontal") >= 0 || !uc(Ft)) {
                  const ti = mm(lt, e, i, c, at, Ar, Ot, yr, jr, cr, Lt, ks.horizontal, !1, tt, nt);
                  ti && (Et.horizontal[jr] = ti);
                }
                vr(zr ? "left" : jr);
              }
            }
            let It = !1;
            if (He.icon && He.icon.namePrimary) {
              const Ft = cm(a.iconSizeData, R["icon-size"], y, a.zoom, He) * j.iconScaleFactor * A, qt = He.icon.getPrimary().scaleSelf(Ft).serialize(), Ot = o[qt];
              Ot && (St = x1(c[qt], He.icon.nameSecondary ? c[He.icon.getSecondary().scaleSelf(Ft).serialize()] : void 0, S.get("icon-offset").evaluate(He, {}, y), S.get("icon-anchor").evaluate(He, {}, y)), It = Ot.sdf, a.sdfIcons === void 0 ? a.sdfIcons = Ot.sdf : a.sdfIcons !== Ot.sdf && Tt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Ot.pixelRatio !== a.pixelRatio || S.get("icon-rotate").constantOr(1) !== 0) && (a.iconsNeedLinear = !0));
            }
            const zt = r0(Et.horizontal) || Et.vertical;
            a.iconsInText || (a.iconsInText = !!zt && zt.iconsInText), (zt || St) && A1(a, He, Et, St, o, j, tt, 0, Lt, It, h, y, k, D, ke);
          }
          s && a.generateCollisionDebugBuffers(T, a.collisionBoxArray, j.textScaleFactor);
        }, r.e5 = zp, r.e6 = vt, r.e7 = H_, r.e8 = Dg, r.e9 = F, r.ea = function(a) {
          let e = 0;
          if (new Uint32Array(a, 0, 1)[0] !== Ey) {
            const i = new Uint32Array(a, 0, 7), [, , o, c, s, h] = i;
            e = i.byteLength + c + s + h + s, (o !== a.byteLength || e >= a.byteLength) && Tt("Invalid b3dm header information.");
          }
          return Ay(a, e);
        }, r.eb = function(a, e) {
          const i = Cy(a);
          for (const o of i) {
            for (const c of o.meshes) rb(c);
            o.lights && (o.lightMeshIndex = o.meshes.length, o.meshes.push(ib(o.lights, e)));
          }
          return i;
        }, r.ec = Ip, r.ed = G0, r.ee = to, r.ef = function(a) {
          Lr(), Yt != null && Yt.then((e) => {
            e.keys().then((i) => {
              for (let o = 0; o < i.length - a; o++) e.delete(i[o]);
            });
          });
        }, r.f = function(a) {
          return a.indexOf("mapbox:") === 0;
        }, r.g = function(a, e) {
          return Yn(Qt(a, { method: "GET" }), e);
        }, r.h = ar, r.i = function(a) {
          return yt.API_STYLE_REGEX.test(a) && !Or(a);
        }, r.j = function(a) {
          return decodeURIComponent(atob(a).split("").map((e) => "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2)).join(""));
        }, r.k = function(a) {
          return btoa(encodeURIComponent(a).replace(/%([0-9A-F]{2})/g, (e, i) => String.fromCharCode(+("0x" + i))));
        }, r.l = Qt, r.m = pi, r.n = function(a, e) {
          return Yn(Qt(a, { type: "json" }), e);
        }, r.o = ou, r.p = function(a, e) {
          return Yn(Qt(a, { method: "POST" }), e);
        }, r.q = ht, r.r = Ea, r.s = function(a) {
          try {
            const e = self[a];
            return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;
          } catch {
            return !1;
          }
        }, r.t = Ke, r.u = function() {
          return function a(e) {
            return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, a);
          }();
        }, r.v = function(a) {
          return !!a && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(a);
        }, r.w = Tt, r.x = function() {
          return Bm || (Bm = new uf()), Bm;
        }, r.y = Gu, r.z = on;
      }), $(["./shared"], function(r) {
        function F($t) {
          const Ce = $t ? $t.url.toString() : void 0;
          return Ce ? performance.getEntriesByName(Ce) : [];
        }
        function H($t) {
          if (typeof $t == "number" || typeof $t == "boolean" || typeof $t == "string" || $t == null) return JSON.stringify($t);
          if (Array.isArray($t)) {
            let Ne = "[";
            for (const Ke of $t) Ne += `${H(Ke)},`;
            return `${Ne}]`;
          }
          let Ce = "{";
          for (const Ne of Object.keys($t).sort()) Ce += `${Ne}:${H($t[Ne])},`;
          return `${Ce}}`;
        }
        function P($t) {
          let Ce = "";
          for (const Ne of r.bm) ($t.type !== "model" || Ne !== "minzoom" && Ne !== "maxzoom") && (Ce += `/${H($t[Ne])}`);
          return Ce;
        }
        class M {
          constructor(Ce) {
            this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, Ce && this.replace(Ce);
          }
          replace(Ce, Ne) {
            this._layerConfigs = {}, this._layers = {}, this.update(Ce, [], Ne);
          }
          update(Ce, Ne, Ke) {
            this._options = Ke;
            for (const ft of Ce) this._layerConfigs[ft.id] = ft, (this._layers[ft.id] = r.cu(ft, this.scope, null, this._options)).compileFilter(Ke), this.keyCache[ft.id] && delete this.keyCache[ft.id];
            for (const ft of Ne) delete this.keyCache[ft], delete this._layerConfigs[ft], delete this._layers[ft];
            this.familiesBySource = {};
            const ht = function(ft, Pt) {
              const Nt = {};
              for (let Zt = 0; Zt < ft.length; Zt++) {
                const jt = ft[Zt];
                let Yt = Pt && Pt[jt.id];
                !Yt && (Yt = P(jt), jt.type === "line" && jt.paint) && function Ir(Lr) {
                  return typeof Lr == "string" && Lr === "line-progress" || (Array.isArray(Lr) ? Lr.some(Ir) : !(!Lr || typeof Lr != "object") && Object.values(Lr).some(Ir));
                }(jt.paint["line-width"]) && (Yt += `/${H(jt.paint["line-width"])}`), Pt && (Pt[jt.id] = Yt);
                let fr = Nt[Yt];
                fr || (fr = Nt[Yt] = []), fr.push(jt);
              }
              const At = [];
              for (const Zt in Nt) At.push(Nt[Zt]);
              return At;
            }(r.bj(this._layerConfigs), this.keyCache);
            for (const ft of ht) {
              const Pt = ft.map((fr) => this._layers[fr.id]), Nt = Pt[0];
              if (Nt.visibility === "none") continue;
              const At = Nt.source || "";
              let Zt = this.familiesBySource[At];
              Zt || (Zt = this.familiesBySource[At] = {});
              const jt = Nt.sourceLayer || "_geojsonTileLayer";
              let Yt = Zt[jt];
              Yt || (Yt = Zt[jt] = []), Yt.push(Pt);
            }
          }
        }
        const E = 1 * r.dX;
        class x {
          constructor(Ce) {
            const Ne = {}, Ke = [];
            for (const Nt in Ce) {
              const At = Ce[Nt], Zt = Ne[Nt] = {};
              for (const jt in At.glyphs) {
                const Yt = At.glyphs[+jt];
                if (!Yt || Yt.bitmap.width === 0 || Yt.bitmap.height === 0) continue;
                const fr = Yt.metrics.localGlyph ? E : 1, Ir = { x: 0, y: 0, w: Yt.bitmap.width + 2 * fr, h: Yt.bitmap.height + 2 * fr };
                Ke.push(Ir), Zt[jt] = Ir;
              }
            }
            const { w: ht, h: ft } = r.F(Ke), Pt = new r.dW({ width: ht || 1, height: ft || 1 });
            for (const Nt in Ce) {
              const At = Ce[Nt];
              for (const Zt in At.glyphs) {
                const jt = At.glyphs[+Zt];
                if (!jt || jt.bitmap.width === 0 || jt.bitmap.height === 0) continue;
                const Yt = Ne[Nt][Zt], fr = jt.metrics.localGlyph ? E : 1;
                r.dW.copy(jt.bitmap, Pt, { x: 0, y: 0 }, { x: Yt.x + fr, y: Yt.y + fr }, jt.bitmap);
              }
            }
            this.image = Pt, this.positions = Ne;
          }
        }
        r.dV(x, "GlyphAtlas");
        const m = "3d_elevation_id", I = "hd_road_elevation";
        class z {
          constructor() {
            this._valid = !1;
          }
          reset(Ce) {
            return this.feature = Ce, this._valid = !0, this._geometry = Ce.loadGeometry(), this._geometry.length !== 0 && this._geometry[0].length !== 0 || (this._valid = !1), this;
          }
          geometry(Ce, Ne) {
            return this._valid && Ce(Ne(this._geometry)), this;
          }
          require(Ce, Ne, Ke) {
            return this.get(Ce, !0, Ne, Ke);
          }
          optional(Ce, Ne, Ke) {
            return this.get(Ce, !1, Ne, Ke);
          }
          success() {
            return this._valid;
          }
          get(Ce, Ne, Ke, ht) {
            const ft = this.feature.properties.hasOwnProperty(Ce) ? +this.feature.properties[Ce] : void 0;
            return this._valid && ft !== void 0 ? Ke(ht ? ht(ft) : ft) : Ne && (this._valid = !1), this;
          }
        }
        class w {
          constructor(Ce, Ne) {
            this.featureFunc = Ce, this.vertexFunc = Ne;
          }
          parseFeature(Ce, Ne, Ke) {
            return this.featureFunc(Ce, Ne, Ke);
          }
          parseVertex(Ce, Ne, Ke) {
            return this.vertexFunc(Ce, Ne, Ke);
          }
        }
        const C = new w(($t, Ce, Ne) => $t.reset(Ce).require(m, (Ke) => {
          Ne.id = Ke;
        }).optional("fixed_height_relative", (Ke) => {
          Ne.constantHeight = Ke;
        }, B.decodeRelativeHeight).geometry((Ke) => {
          Ne.bounds = Ke;
        }, B.computeBounds).success(), ($t, Ce, Ne) => $t.reset(Ce).require(m, (Ke) => {
          Ne.id = Ke;
        }).require("elevation_idx", (Ke) => {
          Ne.idx = Ke;
        }).require("extent", (Ke) => {
          Ne.extent = Ke;
        }).require("height_relative", (Ke) => {
          Ne.height = Ke;
        }, B.decodeRelativeHeight).geometry((Ke) => {
          Ne.position = Ke;
        }, B.getPoint).success()), b = new w(($t, Ce, Ne) => $t.reset(Ce).require(m, (Ke) => {
          Ne.id = Ke;
        }).optional("fixed_height", (Ke) => {
          Ne.constantHeight = Ke;
        }, B.decodeMetricHeight).geometry((Ke) => {
          Ne.bounds = Ke;
        }, B.computeBounds).success(), ($t, Ce, Ne) => $t.reset(Ce).require(m, (Ke) => {
          Ne.id = Ke;
        }).require("elevation_idx", (Ke) => {
          Ne.idx = Ke;
        }).require("extent", (Ke) => {
          Ne.extent = Ke;
        }).require("height", (Ke) => {
          Ne.height = Ke;
        }, B.decodeMetricHeight).geometry((Ke) => {
          Ne.position = Ke;
        }, B.getPoint).success());
        class B {
          static computeBounds(Ce) {
            const Ne = new r.P(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), Ke = new r.P(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
            for (const ht of Ce[0]) Ne.x > ht.x && (Ne.x = ht.x), Ne.y > ht.y && (Ne.y = ht.y), Ke.x < ht.x && (Ke.x = ht.x), Ke.y < ht.y && (Ke.y = ht.y);
            return { min: Ne, max: Ke };
          }
          static getPoint(Ce) {
            return r.ab.vec2.fromValues(Ce[0][0].x, Ce[0][0].y);
          }
          static decodeRelativeHeight(Ce) {
            return 1e-4 * Ce * 5;
          }
          static decodeMetricHeight(Ce) {
            return 1e-4 * Ce;
          }
          static parse(Ce) {
            const Ne = [], Ke = [], ht = Ce.length, ft = new z();
            for (let Nt = 0; Nt < ht; Nt++) {
              const At = Ce.feature(Nt), Zt = At.properties.hasOwnProperty("version") ? String(At.properties.version) : void 0, jt = (Pt = Zt) ? Pt === "1.0.1" ? b : void 0 : C;
              if (jt === void 0) {
                r.w(`Unknown elevation feature version number ${Zt || "(unknown)"}`);
                continue;
              }
              const Yt = At.properties.hasOwnProperty("type") ? At.properties.type : void 0;
              if (Yt) {
                if (r.dY.VectorTileFeature.types[At.type] === "Point" && Yt === "curve_point") {
                  const fr = {};
                  jt.parseVertex(ft, At, fr) && Ne.push(fr);
                } else if (r.dY.VectorTileFeature.types[At.type] === "Polygon" && Yt === "curve_meta") {
                  const fr = {};
                  jt.parseFeature(ft, At, fr) && Ke.push(fr);
                }
              }
            }
            var Pt;
            return { vertices: Ne, features: Ke };
          }
        }
        class N {
          constructor(Ce, Ne, Ke, ht, ft, Pt) {
            if (this.vertices = new Array(), this.vertexProps = new Array(), this.edges = new Array(), this.edgeProps = new Array(), this.id = Ce, this.heightRange = { min: Ke, max: Ke }, this.safeArea = Ne, this.constantHeight = Ke, this.constantHeight == null && (this.constantHeight != null || ht.length !== 0)) {
              this.vertices = ht, this.edges = ft, this.edges = this.edges.filter((Nt) => Nt.a < this.vertices.length && Nt.b < this.vertices.length && !r.ab.vec2.exactEquals(this.vertices[Nt.a].position, this.vertices[Nt.b].position)), this.heightRange = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
              for (const Nt of this.vertices) this.vertexProps.push({ dir: r.ab.vec2.fromValues(0, 0) }), this.heightRange.min = Math.min(this.heightRange.min, Nt.height), this.heightRange.max = Math.max(this.heightRange.max, Nt.height);
              for (const Nt of this.edges) {
                const At = this.vertices[Nt.a].position, Zt = this.vertices[Nt.b].position, jt = r.ab.vec2.subtract(r.ab.vec2.create(), Zt, At), Yt = r.ab.vec2.length(jt), fr = r.ab.vec2.scale(r.ab.vec2.create(), jt, 1 / Yt);
                this.edgeProps.push({ vec: jt, dir: fr, len: Yt });
                const Ir = this.vertexProps[Nt.a].dir, Lr = this.vertexProps[Nt.b].dir;
                r.ab.vec2.add(Ir, Ir, fr), r.ab.vec2.add(Lr, Lr, fr);
              }
              for (const Nt of this.vertexProps) Nt.dir[0] === 0 && Nt.dir[1] === 0 || r.ab.vec2.normalize(Nt.dir, Nt.dir);
              this.tessellate(Pt);
            }
          }
          pointElevation(Ce) {
            if (this.constantHeight != null) return this.constantHeight;
            const Ne = this.getClosestEdge(Ce);
            if (Ne == null) return 0;
            const [Ke, ht] = Ne;
            return (1 - (ft = ht)) * this.vertices[this.edges[Ke].a].height + ft * this.vertices[this.edges[Ke].b].height;
            var ft;
          }
          getClosestEdge(Ce) {
            if (this.edges.length === 0) return;
            let Ne = 0, Ke = Number.POSITIVE_INFINITY, ht = 0;
            const ft = r.ab.vec2.fromValues(Ce.x, Ce.y);
            for (let Pt = 0; Pt < this.edges.length; Pt++) {
              const Nt = this.edges[Pt], At = this.edgeProps[Pt].dir, Zt = new r.dZ(ft, this.edgeProps[Pt].dir), jt = this.vertices[Nt.a].position, Yt = this.vertices[Nt.b].position, fr = r.ab.vec2.create(), Ir = r.ab.vec2.create(), Lr = Zt.intersectsPlane(jt, this.vertexProps[Nt.a].dir, fr), qr = Zt.intersectsPlane(Yt, this.vertexProps[Nt.b].dir, Ir);
              if (!Lr || !qr) continue;
              const pi = r.ab.vec2.subtract(r.ab.vec2.create(), Ir, fr), fi = r.ab.vec2.subtract(r.ab.vec2.create(), ft, fr), si = r.ab.vec2.dot(pi, pi), ki = si > 0 ? r.ab.vec2.dot(fi, pi) / si : 0, Ni = r.aw(ki, 0, 1), Li = Math.abs((ki - Ni) * this.edgeProps[Pt].len), Wi = r.ab.vec2.subtract(r.ab.vec2.create(), ft, jt), Bi = Li + Math.abs(r.ab.vec2.dot(Wi, r.ab.vec2.fromValues(At[1], -At[0])));
              Bi < Ke && (Ne = Pt, Ke = Bi, ht = Ni);
            }
            return [Ne, ht];
          }
          tessellate(Ce) {
            for (let Ne = this.edges.length - 1; Ne >= 0; --Ne) {
              const Ke = this.edges[Ne].a, ht = this.edges[Ne].b, { position: ft, height: Pt, extent: Nt } = this.vertices[Ke], { position: At, height: Zt, extent: jt } = this.vertices[ht], Yt = this.vertexProps[Ke].dir, fr = this.vertexProps[ht].dir, Ir = r.ab.vec3.fromValues(ft[0] / Ce, ft[1] / Ce, Pt), Lr = r.ab.vec3.fromValues(At[0] / Ce, At[1] / Ce, Zt), qr = r.ab.vec3.fromValues(Yt[1], -Yt[0], 0);
              r.ab.vec3.scale(qr, qr, Nt);
              const pi = r.ab.vec3.fromValues(fr[1], -fr[0], 0);
              if (r.ab.vec3.scale(pi, pi, jt), this.distSqLines(r.ab.vec3.fromValues(Ir[0] + 0.5 * qr[0], Ir[1] + 0.5 * qr[1], Ir[2] + 0.5 * qr[2]), r.ab.vec3.fromValues(Lr[0] - 0.5 * pi[0], Lr[1] - 0.5 * pi[1], Lr[2] - 0.5 * pi[2]), r.ab.vec3.fromValues(Ir[0] - 0.5 * qr[0], Ir[1] - 0.5 * qr[1], Ir[2] - 0.5 * qr[2]), r.ab.vec3.fromValues(Lr[0] + 0.5 * pi[0], Lr[1] + 0.5 * pi[1], Lr[2] + 0.5 * pi[2])) <= 0.05 * 0.05) continue;
              const fi = this.vertices.length, si = r.ab.vec2.add(r.ab.vec2.create(), ft, At);
              this.vertices.push({ position: r.ab.vec2.scale(si, si, 0.5), height: 0.5 * (Pt + Zt), extent: 0.5 * (Nt + jt) });
              const ki = r.ab.vec2.add(r.ab.vec2.create(), Yt, fr);
              this.vertexProps.push({ dir: r.ab.vec2.normalize(ki, ki) }), this.edges.splice(Ne, 1), this.edgeProps.splice(Ne, 1), this.edges.push({ a: Ke, b: fi }), this.edges.push({ a: fi, b: ht });
              const Ni = r.ab.vec2.subtract(r.ab.vec2.create(), this.vertices[fi].position, ft), Li = r.ab.vec2.length(Ni), Wi = { vec: Ni, dir: r.ab.vec2.scale(r.ab.vec2.create(), Ni, 1 / Li), len: Li };
              this.edgeProps.push(Wi), this.edgeProps.push(Wi);
            }
          }
          distSqLines(Ce, Ne, Ke, ht) {
            const ft = r.ab.vec3.subtract(r.ab.vec3.create(), Ne, Ce), Pt = r.ab.vec3.subtract(r.ab.vec3.create(), ht, Ke), Nt = r.ab.vec3.subtract(r.ab.vec3.create(), Ce, Ke), At = r.ab.vec3.dot(ft, ft), Zt = r.ab.vec3.dot(ft, Pt), jt = r.ab.vec3.dot(ft, Nt), Yt = r.ab.vec3.dot(Pt, Pt), fr = r.ab.vec3.dot(Pt, Nt), Ir = At * Yt - Zt * Zt;
            if (Ir === 0) {
              const si = r.ab.vec3.dot(Nt, Pt) / r.ab.vec3.dot(Pt, Pt), ki = r.ab.vec3.lerp(r.ab.vec3.create(), Ke, ht, si);
              return r.ab.vec3.squaredDistance(ki, Ce);
            }
            const Lr = (Zt * fr - jt * Yt) / Ir, qr = (At * fr - Zt * jt) / Ir, pi = r.ab.vec3.lerp(r.ab.vec3.create(), Ce, Ne, Lr), fi = r.ab.vec3.lerp(r.ab.vec3.create(), Ke, ht, qr);
            return r.ab.vec3.squaredDistance(pi, fi);
          }
        }
        class U {
          static parseFrom(Ce, Ne) {
            const Ke = B.parse(Ce);
            if (!Ke) return [];
            let { vertices: ht, features: ft } = Ke;
            const Pt = 1 / r.cc(Ne);
            ft.sort((jt, Yt) => jt.id - Yt.id), ht.sort((jt, Yt) => jt.id - Yt.id || jt.idx - Yt.idx), ht = ht.filter((jt, Yt, fr) => Yt === fr.findIndex((Ir) => Ir.id === jt.id && Ir.idx === jt.idx));
            const Nt = new Array();
            let At = 0;
            const Zt = ht.length;
            for (const jt of ft) {
              if (jt.constantHeight) {
                Nt.push(new N(jt.id, jt.bounds, jt.constantHeight));
                continue;
              }
              for (; At !== Zt && ht[At].id < jt.id; ) At++;
              if (At === Zt || ht[At].id !== jt.id) continue;
              const Yt = new Array(), fr = new Array(), Ir = At;
              for (; At !== Zt && ht[At].id === jt.id; ) {
                const Lr = ht[At];
                if (Yt.push({ position: Lr.position, height: Lr.height, extent: Lr.extent }), At !== Ir && ht[At - 1].idx === Lr.idx - 1) {
                  const qr = At - Ir;
                  fr.push({ a: qr - 1, b: qr });
                }
                At++;
              }
              Nt.push(new N(jt.id, jt.bounds, void 0, Yt, fr, Pt));
            }
            return Nt;
          }
        }
        r.dV(N, "ElevationFeature");
        class V {
          constructor(Ce) {
            this.tileID = new r.aG(Ce.tileID.overscaledZ, Ce.tileID.wrap, Ce.tileID.canonical.z, Ce.tileID.canonical.x, Ce.tileID.canonical.y), this.tileZoom = Ce.tileZoom, this.uid = Ce.uid, this.zoom = Ce.zoom, this.lut = Ce.lut, this.canonical = Ce.tileID.canonical, this.pixelRatio = Ce.pixelRatio, this.tileSize = Ce.tileSize, this.source = Ce.source, this.scope = Ce.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = Ce.showCollisionBoxes, this.collectResourceTiming = !!Ce.request && Ce.request.collectResourceTiming, this.promoteId = Ce.promoteId, this.isSymbolTile = Ce.isSymbolTile, this.tileTransform = r.aQ(Ce.tileID.canonical, Ce.projection), this.projection = Ce.projection, this.worldview = Ce.worldview, this.localizableLayerIds = Ce.localizableLayerIds, this.brightness = Ce.brightness, this.extraShadowCaster = !!Ce.extraShadowCaster, this.tessellationStep = Ce.tessellationStep, this.scaleFactor = Ce.scaleFactor;
          }
          parse(Ce, Ne, Ke, ht, ft) {
            this.status = "parsing", this.data = Ce, this.collisionBoxArray = new r.aW();
            const Pt = new r.d_(Object.keys(Ce.layers).sort()), Nt = new r.d$(this.tileID, this.promoteId);
            Nt.bucketLayerIDs = [];
            const At = {}, Zt = new r.e0(256, 256), jt = { featureIndex: Nt, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: Zt, availableImages: Ke, brightness: this.brightness, scaleFactor: this.scaleFactor, elevationFeatures: void 0 }, Yt = Ne.familiesBySource[this.source];
            for (const si in Yt) {
              const ki = Ce.layers[si];
              if (!ki) continue;
              let Ni = !1, Li = !1, Wi = !1;
              for (const Yn of Yt[si]) Yn[0].type === "symbol" ? Ni = !0 : Li = !0, Yn[0].is3D() && Yn[0].type !== "model" && (Wi = !0);
              if (this.extraShadowCaster && !Wi || this.isSymbolTile === !0 && !Ni || this.isSymbolTile === !1 && !Li) continue;
              ki.version === 1 && r.w(`Vector tile source "${this.source}" layer "${si}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const Bi = Pt.encode(si), Gn = [];
              let sa = !1;
              for (let Yn = 0, ea = 0; Yn < ki.length; Yn++) {
                const Pa = ki.feature(Yn), Fs = Nt.getId(Pa, si);
                if (this.localizableLayerIds && this.localizableLayerIds.has(si)) {
                  const wo = Pa.properties ? Pa.properties.worldview : null;
                  if (this.worldview && typeof wo == "string") if (wo === "all") Pa.properties.$localized = !0;
                  else {
                    if (!wo.split(",").includes(this.worldview)) continue;
                    Pa.properties.$localized = !0, Pa.properties.worldview = this.worldview;
                  }
                }
                !sa && Pa.properties && Pa.properties.hasOwnProperty(m) && (sa = !0), Gn.push({ feature: Pa, id: Fs, index: ea, sourceLayerIndex: Bi }), ea++;
              }
              sa && Ce.layers.hasOwnProperty(I) && (jt.elevationFeatures = U.parseFrom(Ce.layers[I], this.canonical));
              for (const Yn of Yt[si]) {
                const ea = Yn[0];
                (!this.extraShadowCaster || ea.is3D() && ea.type !== "model") && (this.isSymbolTile !== void 0 && ea.type === "symbol" !== this.isSymbolTile || ea.minzoom && this.zoom < Math.floor(ea.minzoom) || ea.maxzoom && this.zoom >= ea.maxzoom || ea.visibility !== "none" && (W(Yn, this.zoom, jt.brightness, Ke), (At[ea.id] = ea.createBucket({ index: Nt.bucketLayerIDs.length, layers: Yn, zoom: this.zoom, lut: this.lut, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Bi, sourceID: this.source, projection: this.projection.spec, tessellationStep: this.tessellationStep })).populate(Gn, jt, this.tileID.canonical, this.tileTransform), Nt.bucketLayerIDs.push(Yn.map((Pa) => r.aC(Pa.id, Pa.scope)))));
              }
            }
            let fr, Ir, Lr, qr;
            Zt.trim();
            const pi = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, fi = () => {
              if (fr) return this.status = "done", ft(fr);
              if (this.extraShadowCaster) this.status = "done", ft(null, { buckets: r.bj(At).filter((si) => !si.isEmpty()), featureIndex: Nt, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: jt.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
              else if (Ir && Lr && qr) {
                const si = new x(Ir), ki = new r.e3(Lr, qr, this.lut);
                for (const Ni in At) {
                  const Li = At[Ni];
                  Li instanceof r.aX ? (W(Li.layers, this.zoom, jt.brightness, Ke), r.e4(Li, Ir, si.positions, Lr, ki.iconPositions, this.showCollisionBoxes, Ke, this.tileID.canonical, this.tileZoom, this.projection, this.scaleFactor, this.pixelRatio, this.brightness)) : Li.hasPattern && (Li instanceof r.b1 || Li instanceof r.b2 || Li instanceof r.d5) && (W(Li.layers, this.zoom, jt.brightness, Ke), Li.addFeatures(jt, this.tileID.canonical, ki.patternPositions, Ke, this.tileTransform, this.brightness));
                }
                this.status = "done", ft(null, { buckets: r.bj(At).filter((Ni) => !Ni.isEmpty()), featureIndex: Nt, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: si.image, lineAtlas: Zt, imageAtlas: ki, brightness: jt.brightness });
              }
            };
            if (!this.extraShadowCaster) {
              const si = r.e1(jt.glyphDependencies, (Li) => Object.keys(Li).map(Number));
              Object.keys(si).length ? ht.send("getGlyphs", { uid: this.uid, stacks: si, scope: this.scope }, (Li, Wi) => {
                fr || (fr = Li, Ir = Wi, fi());
              }, void 0, !1, pi) : Ir = {};
              const ki = Object.keys(jt.iconDependencies);
              ki.length ? ht.send("getImages", { icons: ki, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (Li, Wi) => {
                if (fr) return;
                fr = Li;
                const Bi = {};
                Object.values(Wi).some((Gn) => Gn.usvg) ? this.rasterize(ht, Bi, Wi, jt.iconDependencies, () => {
                  Lr = Bi, fi();
                }) : (this.fillImageMap(Bi, jt.iconDependencies, Wi), Lr = Bi, fi());
              }, void 0, !1, pi) : Lr = {};
              const Ni = Object.keys(jt.patternDependencies);
              Ni.length ? ht.send("getImages", { icons: Ni, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (Li, Wi) => {
                if (!fr) {
                  fr = Li;
                  const Bi = {};
                  Object.values(Wi).some((Gn) => Gn.usvg) ? this.rasterize(ht, Bi, Wi, jt.patternDependencies, () => {
                    qr = Bi, fi();
                  }) : (this.fillImageMap(Bi, jt.patternDependencies, Wi), qr = Bi, fi());
                }
              }, void 0, !1, pi) : qr = {};
            }
            fi();
          }
          fillImageMap(Ce, Ne, Ke) {
            for (const ht in Ke) {
              const ft = Ne[ht] || [];
              for (const Pt of ft) Ke[Pt.id].usvg || (Ce[Pt.serialize()] = Ke[Pt.id]);
            }
          }
          getImageTaskQueue(Ce, Ne, Ke) {
            const ht = {};
            for (const ft in Ne) {
              const Pt = Ke[ft] || [];
              for (const Nt of Pt) {
                const At = Nt.serialize();
                Ne[Nt.id].usvg ? ht[At] || (ht[At] = Nt) : Ce[At] = Ne[Nt.id];
              }
            }
            return ht;
          }
          rasterize(Ce, Ne, Ke, ht, ft) {
            const Pt = this.getImageTaskQueue(Ne, Ke, ht);
            this.rasterizeTask = Ce.send("rasterizeImages", { scope: this.scope, imageTasks: Pt }, (Nt, At) => {
              if (!Nt) for (const Zt in At) {
                const { id: jt } = r.e2.deserializeFromString(Zt);
                Ne[Zt] = Object.assign({}, Ke[jt], { data: At[Zt] });
              }
              ft();
            });
          }
          cancelRasterize() {
            this.rasterizeTask && this.rasterizeTask.cancel();
          }
        }
        function W($t, Ce, Ne, Ke) {
          const ht = new r.a8(Ce, { brightness: Ne });
          for (const ft of $t) ft.recalculate(ht, Ke);
        }
        class q extends r.E {
          constructor(Ce, Ne, Ke, ht, ft, Pt) {
            super(), this.actor = Ce, this.layerIndex = Ne, this.availableImages = Ke, this.loadVectorData = ft || r.aD, this.loading = {}, this.loaded = {}, this.deduped = new r.aB(Ce.scheduler), this.isSpriteLoaded = ht, this.scheduler = Ce.scheduler, this.brightness = Pt;
          }
          loadTile(Ce, Ne) {
            const Ke = Ce.uid, ht = Ce && Ce.request, ft = ht && ht.collectResourceTiming, Pt = this.loading[Ke] = new V(Ce);
            Pt.abort = this.loadVectorData(Ce, (Nt, At) => {
              const Zt = !this.loading[Ke];
              if (delete this.loading[Ke], Pt.cancelRasterize(), Zt || Nt || !At) return Pt.status = "done", Zt || (this.loaded[Ke] = Pt), Ne(Nt);
              const jt = At.rawData, Yt = {};
              At.expires && (Yt.expires = At.expires), At.cacheControl && (Yt.cacheControl = At.cacheControl), Pt.vectorTile = At.vectorTile || new r.dY.VectorTile(new r.bh(jt));
              const fr = () => {
                Pt.parse(Pt.vectorTile, this.layerIndex, this.availableImages, this.actor, (Ir, Lr) => {
                  if (Ir || !Lr) return Ne(Ir);
                  const qr = {};
                  if (ft) {
                    const pi = F(ht);
                    pi.length > 0 && (qr.resourceTiming = JSON.parse(JSON.stringify(pi)));
                  }
                  Ne(null, r.l({ rawTileData: jt.slice(0) }, Lr, Yt, qr));
                });
              };
              this.isSpriteLoaded ? fr() : this.once("isSpriteLoaded", () => {
                this.scheduler ? this.scheduler.add(fr, { type: "parseTile", isSymbolTile: Ce.isSymbolTile, zoom: Ce.tileZoom }) : fr();
              }), this.loaded = this.loaded || {}, this.loaded[Ke] = Pt;
            });
          }
          reloadTile(Ce, Ne) {
            const Ke = this.loaded, ht = Ce.uid;
            if (Ke && Ke[ht]) {
              const ft = Ke[ht];
              ft.scaleFactor = Ce.scaleFactor, ft.showCollisionBoxes = Ce.showCollisionBoxes, ft.projection = Ce.projection, ft.brightness = Ce.brightness, ft.tileTransform = r.aQ(Ce.tileID.canonical, Ce.projection), ft.extraShadowCaster = Ce.extraShadowCaster, ft.lut = Ce.lut;
              const Pt = (Nt, At) => {
                const Zt = ft.reloadCallback;
                Zt && (delete ft.reloadCallback, ft.parse(ft.vectorTile, this.layerIndex, this.availableImages, this.actor, Zt)), Ne(Nt, At);
              };
              ft.status === "parsing" ? ft.reloadCallback = Pt : ft.status === "done" && (ft.vectorTile ? ft.parse(ft.vectorTile, this.layerIndex, this.availableImages, this.actor, Pt) : Pt());
            } else Ne(null, void 0);
          }
          abortTile(Ce, Ne) {
            const Ke = Ce.uid, ht = this.loading[Ke];
            ht && (ht.abort && ht.abort(), delete this.loading[Ke]), Ne();
          }
          removeTile(Ce, Ne) {
            const Ke = this.loaded, ht = Ce.uid;
            Ke && Ke[ht] && delete Ke[ht], Ne();
          }
        }
        class Y {
          loadTile(Ce, Ne) {
            const { uid: Ke, encoding: ht, rawImageData: ft, padding: Pt } = Ce, Nt = ImageBitmap && ft instanceof ImageBitmap ? this.getImageData(ft, Pt) : ft;
            Ne(null, new r.e5(Ke, Nt, ht, Pt < 1));
          }
          getImageData(Ce, Ne) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(Ce.width, Ce.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: !0 })), this.offscreenCanvas.width = Ce.width, this.offscreenCanvas.height = Ce.height, this.offscreenCanvasContext.drawImage(Ce, 0, 0, Ce.width, Ce.height);
            const Ke = this.offscreenCanvasContext.getImageData(-Ne, -Ne, Ce.width + 2 * Ne, Ce.height + 2 * Ne);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), Ke;
          }
        }
        r.bg.setPbf(r.bh);
        class re {
          decodeRasterArray({ task: Ce, buffer: Ne }, Ke) {
            r.bg.performDecoding(Ne, Ce).then((ht) => {
              Ke(null, ht);
            }, (ht) => {
              Ke(ht);
            });
          }
        }
        const se = r.dY.VectorTileFeature.prototype.toGeoJSON;
        class ve {
          constructor(Ce) {
            this._feature = Ce, this.extent = r.ag, this.type = Ce.type, this.properties = Ce.tags, "id" in Ce && !isNaN(Ce.id) && (this.id = parseInt(Ce.id, 10));
          }
          loadGeometry() {
            if (this._feature.type === 1) {
              const Ce = [];
              for (const Ne of this._feature.geometry) Ce.push([new r.P(Ne[0], Ne[1])]);
              return Ce;
            }
            {
              const Ce = [];
              for (const Ne of this._feature.geometry) {
                const Ke = [];
                for (const ht of Ne) Ke.push(new r.P(ht[0], ht[1]));
                Ce.push(Ke);
              }
              return Ce;
            }
          }
          toGeoJSON(Ce, Ne, Ke) {
            return se.call(this, Ce, Ne, Ke);
          }
        }
        class ce {
          constructor(Ce) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = r.ag, this.length = Ce.length, this._features = Ce;
          }
          feature(Ce) {
            return new ve(this._features[Ce]);
          }
        }
        const be = 64 / 4096, Me = 128;
        class xe {
          constructor() {
            this.features = /* @__PURE__ */ new Map();
          }
          clear() {
            this.features.clear();
          }
          load(Ce = [], Ne) {
            for (const Ke of Ce) {
              const ht = Ke.id;
              if (ht == null) continue;
              let ft = this.features.get(ht);
              ft && this.updateCache(ft, Ne), Ke.geometry ? (ft = de(Ke), this.updateCache(ft, Ne), this.features.set(ht, ft)) : this.features.delete(ht), this.updateCache(ft, Ne);
            }
          }
          updateCache(Ce, Ne) {
            for (const { canonical: Ke, uid: ht } of Object.values(Ne)) {
              const { z: ft, x: Pt, y: Nt } = Ke;
              le(Ce, Math.pow(2, ft), Pt, Nt) && delete Ne[ht];
            }
          }
          getTile(Ce, Ne, Ke) {
            const ht = Math.pow(2, Ce), ft = [];
            for (const Pt of this.features.values()) le(Pt, ht, Ne, Ke) && ft.push(Ue(Pt, ht, Ne, Ke));
            return { features: ft };
          }
          getFeatures() {
            return [...this.features.values()];
          }
        }
        function le({ minX: $t, minY: Ce, maxX: Ne, maxY: Ke }, ht, ft, Pt) {
          return $t < (ft + 1 + be) / ht && Ce < (Pt + 1 + be) / ht && Ne > (ft - be) / ht && Ke > (Pt - be) / ht;
        }
        function de($t) {
          const { id: Ce, geometry: Ne, properties: Ke } = $t;
          if (!Ne) return;
          if (Ne.type === "GeometryCollection") throw new Error("GeometryCollection not supported in dynamic mode.");
          const { type: ht, coordinates: ft } = Ne, Pt = { id: Ce, type: 1, geometry: [], tags: Ke, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }, Nt = Pt.geometry;
          if (ht === "Point") De(ft, Nt, Pt);
          else if (ht === "MultiPoint") for (const At of ft) De(At, Nt, Pt);
          else if (ht === "LineString") Pt.type = 2, ze(ft, Nt, Pt);
          else if (ht === "MultiLineString") Pt.type = 2, Ze(ft, Nt, Pt);
          else if (ht === "Polygon") Pt.type = 3, Ze(ft, Nt, Pt, !0);
          else {
            if (ht !== "MultiPolygon") throw new Error("Input data is not a valid GeoJSON object.");
            Pt.type = 3;
            for (const At of ft) Ze(At, Nt, Pt, !0);
          }
          return Pt;
        }
        function De([$t, Ce], Ne, Ke) {
          const ht = r.at($t);
          let ft = r.aA(Ce);
          ft = ft < 0 ? 0 : ft > 1 ? 1 : ft, Ne.push(ht, ft), Ke.minX = Math.min(Ke.minX, ht), Ke.minY = Math.min(Ke.minY, ft), Ke.maxX = Math.max(Ke.maxX, ht), Ke.maxY = Math.max(Ke.maxY, ft);
        }
        function ze($t, Ce, Ne, Ke = !1, ht = !1) {
          const ft = [];
          for (const Pt of $t) De(Pt, ft, Ne);
          Ce.push(ft), Ke && function(Pt, Nt) {
            let At = 0;
            for (let Zt = 0, jt = Pt.length, Yt = jt - 2; Zt < jt; Yt = Zt, Zt += 2) At += (Pt[Zt] - Pt[Yt]) * (Pt[Zt + 1] + Pt[Yt + 1]);
            if (At > 0 === Nt) for (let Zt = 0, jt = Pt.length; Zt < jt / 2; Zt += 2) {
              const Yt = Pt[Zt], fr = Pt[Zt + 1];
              Pt[Zt] = Pt[jt - 2 - Zt], Pt[Zt + 1] = Pt[jt - 1 - Zt], Pt[jt - 2 - Zt] = Yt, Pt[jt - 1 - Zt] = fr;
            }
          }(ft, ht);
        }
        function Ze($t, Ce, Ne, Ke = !1) {
          for (let ht = 0; ht < $t.length; ht++) ze($t[ht], Ce, Ne, Ke, ht === 0);
        }
        function Ue($t, Ce, Ne, Ke) {
          const { id: ht, type: ft, geometry: Pt, tags: Nt } = $t, At = [];
          if (ft === 1) (function(Zt, jt, Yt, fr, Ir) {
            for (let Lr = 0; Lr < Zt.length; Lr += 2) {
              const qr = Math.round(r.ag * (Zt[Lr + 0] * jt - Yt)), pi = Math.round(r.ag * (Zt[Lr + 1] * jt - fr));
              Ir.push([qr, pi]);
            }
          })(Pt, Ce, Ne, Ke, At);
          else for (const Zt of Pt) Ie(Zt, Ce, Ne, Ke, At);
          return { id: ht, type: ft, geometry: At, tags: Nt };
        }
        function Ie($t, Ce, Ne, Ke, ht) {
          const ft = -Me, Pt = r.ag + Me;
          let Nt;
          for (let At = 0; At < $t.length - 2; At += 2) {
            let Zt = Math.round(r.ag * ($t[At + 0] * Ce - Ne)), jt = Math.round(r.ag * ($t[At + 1] * Ce - Ke)), Yt = Math.round(r.ag * ($t[At + 2] * Ce - Ne)), fr = Math.round(r.ag * ($t[At + 3] * Ce - Ke));
            const Ir = Yt - Zt, Lr = fr - jt;
            Zt < ft && Yt < ft || (Zt < ft ? (jt += Math.round(Lr * ((ft - Zt) / Ir)), Zt = ft) : Yt < ft && (fr = jt + Math.round(Lr * ((ft - Zt) / Ir)), Yt = ft), jt < ft && fr < ft || (jt < ft ? (Zt += Math.round(Ir * ((ft - jt) / Lr)), jt = ft) : fr < ft && (Yt = Zt + Math.round(Ir * ((ft - jt) / Lr)), fr = ft), Zt >= Pt && Yt >= Pt || (Zt >= Pt ? (jt += Math.round(Lr * ((Pt - Zt) / Ir)), Zt = Pt) : Yt >= Pt && (fr = jt + Math.round(Lr * ((Pt - Zt) / Ir)), Yt = Pt), jt >= Pt && fr >= Pt || (jt >= Pt ? (Zt += Math.round(Ir * ((Pt - jt) / Lr)), jt = Pt) : fr >= Pt && (Yt = Zt + Math.round(Ir * ((Pt - jt) / Lr)), fr = Pt), Nt && Zt === Nt[Nt.length - 1][0] && jt === Nt[Nt.length - 1][1] || (Nt = [[Zt, jt]], ht.push(Nt)), Nt.push([Yt, fr])))));
          }
        }
        var je, Fe, $e, ct = { exports: {} }, wt = function() {
          if ($e) return ct.exports;
          $e = 1;
          var $t = r.e8(), Ce = function() {
            if (Fe) return je;
            Fe = 1;
            var jt = r.e6(), Yt = r.e7().VectorTileFeature;
            function fr(Lr, qr) {
              this.options = qr || {}, this.features = Lr, this.length = Lr.length;
            }
            function Ir(Lr, qr) {
              this.id = typeof Lr.id == "number" ? Lr.id : void 0, this.type = Lr.type, this.rawGeometry = Lr.type === 1 ? [Lr.geometry] : Lr.geometry, this.properties = Lr.tags, this.extent = qr || 4096;
            }
            return je = fr, fr.prototype.feature = function(Lr) {
              return new Ir(this.features[Lr], this.options.extent);
            }, Ir.prototype.loadGeometry = function() {
              var Lr = this.rawGeometry;
              this.geometry = [];
              for (var qr = 0; qr < Lr.length; qr++) {
                for (var pi = Lr[qr], fi = [], si = 0; si < pi.length; si++) fi.push(new jt(pi[si][0], pi[si][1]));
                this.geometry.push(fi);
              }
              return this.geometry;
            }, Ir.prototype.bbox = function() {
              this.geometry || this.loadGeometry();
              for (var Lr = this.geometry, qr = 1 / 0, pi = -1 / 0, fi = 1 / 0, si = -1 / 0, ki = 0; ki < Lr.length; ki++) for (var Ni = Lr[ki], Li = 0; Li < Ni.length; Li++) {
                var Wi = Ni[Li];
                qr = Math.min(qr, Wi.x), pi = Math.max(pi, Wi.x), fi = Math.min(fi, Wi.y), si = Math.max(si, Wi.y);
              }
              return [qr, fi, pi, si];
            }, Ir.prototype.toGeoJSON = Yt.prototype.toGeoJSON, je;
          }();
          function Ne(jt) {
            var Yt = new $t();
            return function(fr, Ir) {
              for (var Lr in fr.layers) Ir.writeMessage(3, Ke, fr.layers[Lr]);
            }(jt, Yt), Yt.finish();
          }
          function Ke(jt, Yt) {
            var fr;
            Yt.writeVarintField(15, jt.version || 1), Yt.writeStringField(1, jt.name || ""), Yt.writeVarintField(5, jt.extent || 4096);
            var Ir = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (fr = 0; fr < jt.length; fr++) Ir.feature = jt.feature(fr), Yt.writeMessage(2, ht, Ir);
            var Lr = Ir.keys;
            for (fr = 0; fr < Lr.length; fr++) Yt.writeStringField(3, Lr[fr]);
            var qr = Ir.values;
            for (fr = 0; fr < qr.length; fr++) Yt.writeMessage(4, Zt, qr[fr]);
          }
          function ht(jt, Yt) {
            var fr = jt.feature;
            fr.id !== void 0 && Yt.writeVarintField(1, fr.id), Yt.writeMessage(2, ft, jt), Yt.writeVarintField(3, fr.type), Yt.writeMessage(4, At, fr);
          }
          function ft(jt, Yt) {
            var fr = jt.feature, Ir = jt.keys, Lr = jt.values, qr = jt.keycache, pi = jt.valuecache;
            for (var fi in fr.properties) {
              var si = fr.properties[fi], ki = qr[fi];
              if (si !== null) {
                ki === void 0 && (Ir.push(fi), qr[fi] = ki = Ir.length - 1), Yt.writeVarint(ki);
                var Ni = typeof si;
                Ni !== "string" && Ni !== "boolean" && Ni !== "number" && (si = JSON.stringify(si));
                var Li = Ni + ":" + si, Wi = pi[Li];
                Wi === void 0 && (Lr.push(si), pi[Li] = Wi = Lr.length - 1), Yt.writeVarint(Wi);
              }
            }
          }
          function Pt(jt, Yt) {
            return (Yt << 3) + (7 & jt);
          }
          function Nt(jt) {
            return jt << 1 ^ jt >> 31;
          }
          function At(jt, Yt) {
            for (var fr = jt.loadGeometry(), Ir = jt.type, Lr = 0, qr = 0, pi = fr.length, fi = 0; fi < pi; fi++) {
              var si = fr[fi], ki = 1;
              Ir === 1 && (ki = si.length), Yt.writeVarint(Pt(1, ki));
              for (var Ni = Ir === 3 ? si.length - 1 : si.length, Li = 0; Li < Ni; Li++) {
                Li === 1 && Ir !== 1 && Yt.writeVarint(Pt(2, Ni - 1));
                var Wi = si[Li].x - Lr, Bi = si[Li].y - qr;
                Yt.writeVarint(Nt(Wi)), Yt.writeVarint(Nt(Bi)), Lr += Wi, qr += Bi;
              }
              Ir === 3 && Yt.writeVarint(Pt(7, 1));
            }
          }
          function Zt(jt, Yt) {
            var fr = typeof jt;
            fr === "string" ? Yt.writeStringField(1, jt) : fr === "boolean" ? Yt.writeBooleanField(7, jt) : fr === "number" && (jt % 1 != 0 ? Yt.writeDoubleField(3, jt) : jt < 0 ? Yt.writeSVarintField(6, jt) : Yt.writeVarintField(5, jt));
          }
          return ct.exports = Ne, ct.exports.fromVectorTileJs = Ne, ct.exports.fromGeojsonVt = function(jt, Yt) {
            Yt = Yt || {};
            var fr = {};
            for (var Ir in jt) fr[Ir] = new Ce(jt[Ir].features, Yt), fr[Ir].name = Ir, fr[Ir].version = Yt.version, fr[Ir].extent = Yt.extent;
            return Ne({ layers: fr });
          }, ct.exports.GeoJSONWrapper = Ce, ct.exports;
        }(), Oe = r.e9(wt);
        const Ct = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: ($t) => $t }, Xt = Math.fround || (vt = new Float32Array(1), ($t) => (vt[0] = +$t, vt[0]));
        var vt;
        const Ye = 3, qe = 5, rt = 6;
        class it {
          constructor(Ce) {
            this.options = Object.assign(Object.create(Ct), Ce), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(Ce) {
            const { log: Ne, minZoom: Ke, maxZoom: ht } = this.options;
            Ne && console.time("total time");
            const ft = `prepare ${Ce.length} points`;
            Ne && console.time(ft), this.points = Ce;
            const Pt = [];
            for (let At = 0; At < Ce.length; At++) {
              const Zt = Ce[At];
              if (!Zt.geometry) continue;
              const [jt, Yt] = Zt.geometry.coordinates, fr = Xt(fe(jt)), Ir = Xt(We(Yt));
              Pt.push(fr, Ir, 1 / 0, At, -1, 1), this.options.reduce && Pt.push(0);
            }
            let Nt = this.trees[ht + 1] = this._createTree(Pt);
            Ne && console.timeEnd(ft);
            for (let At = ht; At >= Ke; At--) {
              const Zt = +Date.now();
              Nt = this.trees[At] = this._createTree(this._cluster(Nt, At)), Ne && console.log("z%d: %d clusters in %dms", At, Nt.numItems, +Date.now() - Zt);
            }
            return Ne && console.timeEnd("total time"), this;
          }
          getClusters(Ce, Ne) {
            let Ke = ((Ce[0] + 180) % 360 + 360) % 360 - 180;
            const ht = Math.max(-90, Math.min(90, Ce[1]));
            let ft = Ce[2] === 180 ? 180 : ((Ce[2] + 180) % 360 + 360) % 360 - 180;
            const Pt = Math.max(-90, Math.min(90, Ce[3]));
            if (Ce[2] - Ce[0] >= 360) Ke = -180, ft = 180;
            else if (Ke > ft) {
              const Yt = this.getClusters([Ke, ht, 180, Pt], Ne), fr = this.getClusters([-180, ht, ft, Pt], Ne);
              return Yt.concat(fr);
            }
            const Nt = this.trees[this._limitZoom(Ne)], At = Nt.range(fe(Ke), We(Pt), fe(ft), We(ht)), Zt = Nt.data, jt = [];
            for (const Yt of At) {
              const fr = this.stride * Yt;
              jt.push(Zt[fr + qe] > 1 ? Ae(Zt, fr, this.clusterProps) : this.points[Zt[fr + Ye]]);
            }
            return jt;
          }
          getChildren(Ce) {
            const Ne = this._getOriginId(Ce), Ke = this._getOriginZoom(Ce), ht = "No cluster with the specified id.", ft = this.trees[Ke];
            if (!ft) throw new Error(ht);
            const Pt = ft.data;
            if (Ne * this.stride >= Pt.length) throw new Error(ht);
            const Nt = this.options.radius / (this.options.extent * Math.pow(2, Ke - 1)), At = ft.within(Pt[Ne * this.stride], Pt[Ne * this.stride + 1], Nt), Zt = [];
            for (const jt of At) {
              const Yt = jt * this.stride;
              Pt[Yt + 4] === Ce && Zt.push(Pt[Yt + qe] > 1 ? Ae(Pt, Yt, this.clusterProps) : this.points[Pt[Yt + Ye]]);
            }
            if (Zt.length === 0) throw new Error(ht);
            return Zt;
          }
          getLeaves(Ce, Ne, Ke) {
            const ht = [];
            return this._appendLeaves(ht, Ce, Ne = Ne || 10, Ke = Ke || 0, 0), ht;
          }
          getTile(Ce, Ne, Ke) {
            const ht = this.trees[this._limitZoom(Ce)], ft = Math.pow(2, Ce), { extent: Pt, radius: Nt } = this.options, At = Nt / Pt, Zt = (Ke - At) / ft, jt = (Ke + 1 + At) / ft, Yt = { features: [] };
            return this._addTileFeatures(ht.range((Ne - At) / ft, Zt, (Ne + 1 + At) / ft, jt), ht.data, Ne, Ke, ft, Yt), Ne === 0 && this._addTileFeatures(ht.range(1 - At / ft, Zt, 1, jt), ht.data, ft, Ke, ft, Yt), Ne === ft - 1 && this._addTileFeatures(ht.range(0, Zt, At / ft, jt), ht.data, -1, Ke, ft, Yt), Yt.features.length ? Yt : null;
          }
          getClusterExpansionZoom(Ce) {
            let Ne = this._getOriginZoom(Ce) - 1;
            for (; Ne <= this.options.maxZoom; ) {
              const Ke = this.getChildren(Ce);
              if (Ne++, Ke.length !== 1) break;
              Ce = Ke[0].properties.cluster_id;
            }
            return Ne;
          }
          _appendLeaves(Ce, Ne, Ke, ht, ft) {
            const Pt = this.getChildren(Ne);
            for (const Nt of Pt) {
              const At = Nt.properties;
              if (At && At.cluster ? ft + At.point_count <= ht ? ft += At.point_count : ft = this._appendLeaves(Ce, At.cluster_id, Ke, ht, ft) : ft < ht ? ft++ : Ce.push(Nt), Ce.length === Ke) break;
            }
            return ft;
          }
          _createTree(Ce) {
            const Ne = new r.bE(Ce.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let Ke = 0; Ke < Ce.length; Ke += this.stride) Ne.add(Ce[Ke], Ce[Ke + 1]);
            return Ne.finish(), Ne.data = Ce, Ne;
          }
          _addTileFeatures(Ce, Ne, Ke, ht, ft, Pt) {
            for (const Nt of Ce) {
              const At = Nt * this.stride, Zt = Ne[At + qe] > 1;
              let jt, Yt, fr;
              if (Zt) jt = _e(Ne, At, this.clusterProps), Yt = Ne[At], fr = Ne[At + 1];
              else {
                const qr = this.points[Ne[At + Ye]];
                jt = qr.properties;
                const [pi, fi] = qr.geometry.coordinates;
                Yt = fe(pi), fr = We(fi);
              }
              const Ir = { type: 1, geometry: [[Math.round(this.options.extent * (Yt * ft - Ke)), Math.round(this.options.extent * (fr * ft - ht))]], tags: jt };
              let Lr;
              Lr = Zt || this.options.generateId ? Ne[At + Ye] : this.points[Ne[At + Ye]].id, Lr !== void 0 && (Ir.id = Lr), Pt.features.push(Ir);
            }
          }
          _limitZoom(Ce) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+Ce), this.options.maxZoom + 1));
          }
          _cluster(Ce, Ne) {
            const { radius: Ke, extent: ht, reduce: ft, minPoints: Pt } = this.options, Nt = Ke / (ht * Math.pow(2, Ne)), At = Ce.data, Zt = [], jt = this.stride;
            for (let Yt = 0; Yt < At.length; Yt += jt) {
              if (At[Yt + 2] <= Ne) continue;
              At[Yt + 2] = Ne;
              const fr = At[Yt], Ir = At[Yt + 1], Lr = Ce.within(At[Yt], At[Yt + 1], Nt), qr = At[Yt + qe];
              let pi = qr;
              for (const fi of Lr) {
                const si = fi * jt;
                At[si + 2] > Ne && (pi += At[si + qe]);
              }
              if (pi > qr && pi >= Pt) {
                let fi, si = fr * qr, ki = Ir * qr, Ni = -1;
                const Li = (Yt / jt << 5) + (Ne + 1) + this.points.length;
                for (const Wi of Lr) {
                  const Bi = Wi * jt;
                  if (At[Bi + 2] <= Ne) continue;
                  At[Bi + 2] = Ne;
                  const Gn = At[Bi + qe];
                  si += At[Bi] * Gn, ki += At[Bi + 1] * Gn, At[Bi + 4] = Li, ft && (fi || (fi = this._map(At, Yt, !0), Ni = this.clusterProps.length, this.clusterProps.push(fi)), ft(fi, this._map(At, Bi)));
                }
                At[Yt + 4] = Li, Zt.push(si / pi, ki / pi, 1 / 0, Li, -1, pi), ft && Zt.push(Ni);
              } else {
                for (let fi = 0; fi < jt; fi++) Zt.push(At[Yt + fi]);
                if (pi > 1) for (const fi of Lr) {
                  const si = fi * jt;
                  if (!(At[si + 2] <= Ne)) {
                    At[si + 2] = Ne;
                    for (let ki = 0; ki < jt; ki++) Zt.push(At[si + ki]);
                  }
                }
              }
            }
            return Zt;
          }
          _getOriginId(Ce) {
            return Ce - this.points.length >> 5;
          }
          _getOriginZoom(Ce) {
            return (Ce - this.points.length) % 32;
          }
          _map(Ce, Ne, Ke) {
            if (Ce[Ne + qe] > 1) {
              const Pt = this.clusterProps[Ce[Ne + rt]];
              return Ke ? Object.assign({}, Pt) : Pt;
            }
            const ht = this.points[Ce[Ne + Ye]].properties, ft = this.options.map(ht);
            return Ke && ft === ht ? Object.assign({}, ft) : ft;
          }
        }
        function Ae($t, Ce, Ne) {
          return { type: "Feature", id: $t[Ce + Ye], properties: _e($t, Ce, Ne), geometry: { type: "Point", coordinates: [(Ke = $t[Ce], 360 * (Ke - 0.5)), Pe($t[Ce + 1])] } };
          var Ke;
        }
        function _e($t, Ce, Ne) {
          const Ke = $t[Ce + qe], ht = Ke >= 1e4 ? `${Math.round(Ke / 1e3)}k` : Ke >= 1e3 ? Math.round(Ke / 100) / 10 + "k" : Ke, ft = $t[Ce + rt], Pt = ft === -1 ? {} : Object.assign({}, Ne[ft]);
          return Object.assign(Pt, { cluster: !0, cluster_id: $t[Ce + Ye], point_count: Ke, point_count_abbreviated: ht });
        }
        function fe($t) {
          return $t / 360 + 0.5;
        }
        function We($t) {
          const Ce = Math.sin($t * Math.PI / 180), Ne = 0.5 - 0.25 * Math.log((1 + Ce) / (1 - Ce)) / Math.PI;
          return Ne < 0 ? 0 : Ne > 1 ? 1 : Ne;
        }
        function Pe($t) {
          const Ce = (180 - 360 * $t) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(Ce)) / Math.PI - 90;
        }
        function he($t, Ce, Ne, Ke) {
          let ht = Ke;
          const ft = Ce + (Ne - Ce >> 1);
          let Pt, Nt = Ne - Ce;
          const At = $t[Ce], Zt = $t[Ce + 1], jt = $t[Ne], Yt = $t[Ne + 1];
          for (let fr = Ce + 3; fr < Ne; fr += 3) {
            const Ir = ie($t[fr], $t[fr + 1], At, Zt, jt, Yt);
            if (Ir > ht) Pt = fr, ht = Ir;
            else if (Ir === ht) {
              const Lr = Math.abs(fr - ft);
              Lr < Nt && (Pt = fr, Nt = Lr);
            }
          }
          ht > Ke && (Pt - Ce > 3 && he($t, Ce, Pt, Ke), $t[Pt + 2] = ht, Ne - Pt > 3 && he($t, Pt, Ne, Ke));
        }
        function ie($t, Ce, Ne, Ke, ht, ft) {
          let Pt = ht - Ne, Nt = ft - Ke;
          if (Pt !== 0 || Nt !== 0) {
            const At = (($t - Ne) * Pt + (Ce - Ke) * Nt) / (Pt * Pt + Nt * Nt);
            At > 1 ? (Ne = ht, Ke = ft) : At > 0 && (Ne += Pt * At, Ke += Nt * At);
          }
          return Pt = $t - Ne, Nt = Ce - Ke, Pt * Pt + Nt * Nt;
        }
        function Xe($t, Ce, Ne, Ke) {
          const ht = { id: $t ?? null, type: Ce, geometry: Ne, tags: Ke, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (Ce === "Point" || Ce === "MultiPoint" || Ce === "LineString") bt(ht, Ne);
          else if (Ce === "Polygon") bt(ht, Ne[0]);
          else if (Ce === "MultiLineString") for (const ft of Ne) bt(ht, ft);
          else if (Ce === "MultiPolygon") for (const ft of Ne) bt(ht, ft[0]);
          return ht;
        }
        function bt($t, Ce) {
          for (let Ne = 0; Ne < Ce.length; Ne += 3) $t.minX = Math.min($t.minX, Ce[Ne]), $t.minY = Math.min($t.minY, Ce[Ne + 1]), $t.maxX = Math.max($t.maxX, Ce[Ne]), $t.maxY = Math.max($t.maxY, Ce[Ne + 1]);
        }
        function Wt($t, Ce, Ne, Ke) {
          if (!Ce.geometry) return;
          const ht = Ce.geometry.coordinates;
          if (ht && ht.length === 0) return;
          const ft = Ce.geometry.type, Pt = Math.pow(Ne.tolerance / ((1 << Ne.maxZoom) * Ne.extent), 2);
          let Nt = [], At = Ce.id;
          if (Ne.promoteId ? At = Ce.properties[Ne.promoteId] : Ne.generateId && (At = Ke || 0), ft === "Point") Qt(ht, Nt);
          else if (ft === "MultiPoint") for (const Zt of ht) Qt(Zt, Nt);
          else if (ft === "LineString") Sr(ht, Nt, Pt, !1);
          else if (ft === "MultiLineString") {
            if (Ne.lineMetrics) {
              for (const Zt of ht) Nt = [], Sr(Zt, Nt, Pt, !1), $t.push(Xe(At, "LineString", Nt, Ce.properties));
              return;
            }
            Fr(ht, Nt, Pt, !1);
          } else if (ft === "Polygon") Fr(ht, Nt, Pt, !0);
          else {
            if (ft !== "MultiPolygon") {
              if (ft === "GeometryCollection") {
                for (const Zt of Ce.geometry.geometries) Wt($t, { id: At, geometry: Zt, properties: Ce.properties }, Ne, Ke);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const Zt of ht) {
              const jt = [];
              Fr(Zt, jt, Pt, !0), Nt.push(jt);
            }
          }
          $t.push(Xe(At, ft, Nt, Ce.properties));
        }
        function Qt($t, Ce) {
          Ce.push(kr($t[0]), Ur($t[1]), 0);
        }
        function Sr($t, Ce, Ne, Ke) {
          let ht, ft, Pt = 0;
          for (let At = 0; At < $t.length; At++) {
            const Zt = kr($t[At][0]), jt = Ur($t[At][1]);
            Ce.push(Zt, jt, 0), At > 0 && (Pt += Ke ? (ht * jt - Zt * ft) / 2 : Math.sqrt(Math.pow(Zt - ht, 2) + Math.pow(jt - ft, 2))), ht = Zt, ft = jt;
          }
          const Nt = Ce.length - 3;
          Ce[2] = 1, he(Ce, 0, Nt, Ne), Ce[Nt + 2] = 1, Ce.size = Math.abs(Pt), Ce.start = 0, Ce.end = Ce.size;
        }
        function Fr($t, Ce, Ne, Ke) {
          for (let ht = 0; ht < $t.length; ht++) {
            const ft = [];
            Sr($t[ht], ft, Ne, Ke), Ce.push(ft);
          }
        }
        function kr($t) {
          return $t / 360 + 0.5;
        }
        function Ur($t) {
          const Ce = Math.sin($t * Math.PI / 180), Ne = 0.5 - 0.25 * Math.log((1 + Ce) / (1 - Ce)) / Math.PI;
          return Ne < 0 ? 0 : Ne > 1 ? 1 : Ne;
        }
        function Rr($t, Ce, Ne, Ke, ht, ft, Pt, Nt) {
          if (Ke /= Ce, ft >= (Ne /= Ce) && Pt < Ke) return $t;
          if (Pt < Ne || ft >= Ke) return null;
          const At = [];
          for (const Zt of $t) {
            const jt = Zt.geometry;
            let Yt = Zt.type;
            const fr = ht === 0 ? Zt.minX : Zt.minY, Ir = ht === 0 ? Zt.maxX : Zt.maxY;
            if (fr >= Ne && Ir < Ke) {
              At.push(Zt);
              continue;
            }
            if (Ir < Ne || fr >= Ke) continue;
            let Lr = [];
            if (Yt === "Point" || Yt === "MultiPoint") Pr(jt, Lr, Ne, Ke, ht);
            else if (Yt === "LineString") hi(jt, Lr, Ne, Ke, ht, !1, Nt.lineMetrics);
            else if (Yt === "MultiLineString") Te(jt, Lr, Ne, Ke, ht, !1);
            else if (Yt === "Polygon") Te(jt, Lr, Ne, Ke, ht, !0);
            else if (Yt === "MultiPolygon") for (const qr of jt) {
              const pi = [];
              Te(qr, pi, Ne, Ke, ht, !0), pi.length && Lr.push(pi);
            }
            if (Lr.length) {
              if (Nt.lineMetrics && Yt === "LineString") {
                for (const qr of Lr) At.push(Xe(Zt.id, Yt, qr, Zt.tags));
                continue;
              }
              Yt !== "LineString" && Yt !== "MultiLineString" || (Lr.length === 1 ? (Yt = "LineString", Lr = Lr[0]) : Yt = "MultiLineString"), Yt !== "Point" && Yt !== "MultiPoint" || (Yt = Lr.length === 3 ? "Point" : "MultiPoint"), At.push(Xe(Zt.id, Yt, Lr, Zt.tags));
            }
          }
          return At.length ? At : null;
        }
        function Pr($t, Ce, Ne, Ke, ht) {
          for (let ft = 0; ft < $t.length; ft += 3) {
            const Pt = $t[ft + ht];
            Pt >= Ne && Pt <= Ke && Tt(Ce, $t[ft], $t[ft + 1], $t[ft + 2]);
          }
        }
        function hi($t, Ce, Ne, Ke, ht, ft, Pt) {
          let Nt = Vr($t);
          const At = ht === 0 ? Gt : pr;
          let Zt, jt, Yt = $t.start;
          for (let pi = 0; pi < $t.length - 3; pi += 3) {
            const fi = $t[pi], si = $t[pi + 1], ki = $t[pi + 2], Ni = $t[pi + 3], Li = $t[pi + 4], Wi = ht === 0 ? fi : si, Bi = ht === 0 ? Ni : Li;
            let Gn = !1;
            Pt && (Zt = Math.sqrt(Math.pow(fi - Ni, 2) + Math.pow(si - Li, 2))), Wi < Ne ? Bi > Ne && (jt = At(Nt, fi, si, Ni, Li, Ne), Pt && (Nt.start = Yt + Zt * jt)) : Wi > Ke ? Bi < Ke && (jt = At(Nt, fi, si, Ni, Li, Ke), Pt && (Nt.start = Yt + Zt * jt)) : Tt(Nt, fi, si, ki), Bi < Ne && Wi >= Ne && (jt = At(Nt, fi, si, Ni, Li, Ne), Gn = !0), Bi > Ke && Wi <= Ke && (jt = At(Nt, fi, si, Ni, Li, Ke), Gn = !0), !ft && Gn && (Pt && (Nt.end = Yt + Zt * jt), Ce.push(Nt), Nt = Vr($t)), Pt && (Yt += Zt);
          }
          let fr = $t.length - 3;
          const Ir = $t[fr], Lr = $t[fr + 1], qr = ht === 0 ? Ir : Lr;
          qr >= Ne && qr <= Ke && Tt(Nt, Ir, Lr, $t[fr + 2]), fr = Nt.length - 3, ft && fr >= 3 && (Nt[fr] !== Nt[0] || Nt[fr + 1] !== Nt[1]) && Tt(Nt, Nt[0], Nt[1], Nt[2]), Nt.length && Ce.push(Nt);
        }
        function Vr($t) {
          const Ce = [];
          return Ce.size = $t.size, Ce.start = $t.start, Ce.end = $t.end, Ce;
        }
        function Te($t, Ce, Ne, Ke, ht, ft) {
          for (const Pt of $t) hi(Pt, Ce, Ne, Ke, ht, ft, !1);
        }
        function Tt($t, Ce, Ne, Ke) {
          $t.push(Ce, Ne, Ke);
        }
        function Gt($t, Ce, Ne, Ke, ht, ft) {
          const Pt = (ft - Ce) / (Ke - Ce);
          return Tt($t, ft, Ne + (ht - Ne) * Pt, 1), Pt;
        }
        function pr($t, Ce, Ne, Ke, ht, ft) {
          const Pt = (ft - Ne) / (ht - Ne);
          return Tt($t, Ce + (Ke - Ce) * Pt, ft, 1), Pt;
        }
        function kt($t, Ce) {
          const Ne = [];
          for (let Ke = 0; Ke < $t.length; Ke++) {
            const ht = $t[Ke], ft = ht.type;
            let Pt;
            if (ft === "Point" || ft === "MultiPoint" || ft === "LineString") Pt = tr(ht.geometry, Ce);
            else if (ft === "MultiLineString" || ft === "Polygon") {
              Pt = [];
              for (const Nt of ht.geometry) Pt.push(tr(Nt, Ce));
            } else if (ft === "MultiPolygon") {
              Pt = [];
              for (const Nt of ht.geometry) {
                const At = [];
                for (const Zt of Nt) At.push(tr(Zt, Ce));
                Pt.push(At);
              }
            }
            Ne.push(Xe(ht.id, ft, Pt, ht.tags));
          }
          return Ne;
        }
        function tr($t, Ce) {
          const Ne = [];
          Ne.size = $t.size, $t.start !== void 0 && (Ne.start = $t.start, Ne.end = $t.end);
          for (let Ke = 0; Ke < $t.length; Ke += 3) Ne.push($t[Ke] + Ce, $t[Ke + 1], $t[Ke + 2]);
          return Ne;
        }
        function Je($t, Ce) {
          if ($t.transformed) return $t;
          const Ne = 1 << $t.z, Ke = $t.x, ht = $t.y;
          for (const ft of $t.features) {
            const Pt = ft.geometry, Nt = ft.type;
            if (ft.geometry = [], Nt === 1) for (let At = 0; At < Pt.length; At += 2) ft.geometry.push(wr(Pt[At], Pt[At + 1], Ce, Ne, Ke, ht));
            else for (let At = 0; At < Pt.length; At++) {
              const Zt = [];
              for (let jt = 0; jt < Pt[At].length; jt += 2) Zt.push(wr(Pt[At][jt], Pt[At][jt + 1], Ce, Ne, Ke, ht));
              ft.geometry.push(Zt);
            }
          }
          return $t.transformed = !0, $t;
        }
        function wr($t, Ce, Ne, Ke, ht, ft) {
          return [Math.round(Ne * ($t * Ke - ht)), Math.round(Ne * (Ce * Ke - ft))];
        }
        function ni($t, Ce, Ne, Ke, ht) {
          const ft = Ce === ht.maxZoom ? 0 : ht.tolerance / ((1 << Ce) * ht.extent), Pt = { features: [], numPoints: 0, numSimplified: 0, numFeatures: $t.length, source: null, x: Ne, y: Ke, z: Ce, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const Nt of $t) Z(Pt, Nt, ft, ht);
          return Pt;
        }
        function Z($t, Ce, Ne, Ke) {
          const ht = Ce.geometry, ft = Ce.type, Pt = [];
          if ($t.minX = Math.min($t.minX, Ce.minX), $t.minY = Math.min($t.minY, Ce.minY), $t.maxX = Math.max($t.maxX, Ce.maxX), $t.maxY = Math.max($t.maxY, Ce.maxY), ft === "Point" || ft === "MultiPoint") for (let Nt = 0; Nt < ht.length; Nt += 3) Pt.push(ht[Nt], ht[Nt + 1]), $t.numPoints++, $t.numSimplified++;
          else if (ft === "LineString") Dt(Pt, ht, $t, Ne, !1, !1);
          else if (ft === "MultiLineString" || ft === "Polygon") for (let Nt = 0; Nt < ht.length; Nt++) Dt(Pt, ht[Nt], $t, Ne, ft === "Polygon", Nt === 0);
          else if (ft === "MultiPolygon") for (let Nt = 0; Nt < ht.length; Nt++) {
            const At = ht[Nt];
            for (let Zt = 0; Zt < At.length; Zt++) Dt(Pt, At[Zt], $t, Ne, !0, Zt === 0);
          }
          if (Pt.length) {
            let Nt = Ce.tags || null;
            if (ft === "LineString" && Ke.lineMetrics) {
              Nt = {};
              for (const Zt in Ce.tags) Nt[Zt] = Ce.tags[Zt];
              Nt.mapbox_clip_start = ht.start / ht.size, Nt.mapbox_clip_end = ht.end / ht.size;
            }
            const At = { geometry: Pt, type: ft === "Polygon" || ft === "MultiPolygon" ? 3 : ft === "LineString" || ft === "MultiLineString" ? 2 : 1, tags: Nt };
            Ce.id !== null && (At.id = Ce.id), $t.features.push(At);
          }
        }
        function Dt($t, Ce, Ne, Ke, ht, ft) {
          const Pt = Ke * Ke;
          if (Ke > 0 && Ce.size < (ht ? Pt : Ke)) return void (Ne.numPoints += Ce.length / 3);
          const Nt = [];
          for (let At = 0; At < Ce.length; At += 3) (Ke === 0 || Ce[At + 2] > Pt) && (Ne.numSimplified++, Nt.push(Ce[At], Ce[At + 1])), Ne.numPoints++;
          ht && function(At, Zt) {
            let jt = 0;
            for (let Yt = 0, fr = At.length, Ir = fr - 2; Yt < fr; Ir = Yt, Yt += 2) jt += (At[Yt] - At[Ir]) * (At[Yt + 1] + At[Ir + 1]);
            if (jt > 0 === Zt) for (let Yt = 0, fr = At.length; Yt < fr / 2; Yt += 2) {
              const Ir = At[Yt], Lr = At[Yt + 1];
              At[Yt] = At[fr - 2 - Yt], At[Yt + 1] = At[fr - 1 - Yt], At[fr - 2 - Yt] = Ir, At[fr - 1 - Yt] = Lr;
            }
          }(Nt, ft), $t.push(Nt);
        }
        const er = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
        class we {
          constructor(Ce, Ne) {
            const Ke = (Ne = this.options = function(ft, Pt) {
              for (const Nt in Pt) ft[Nt] = Pt[Nt];
              return ft;
            }(Object.create(er), Ne)).debug;
            if (Ke && console.time("preprocess data"), Ne.maxZoom < 0 || Ne.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (Ne.promoteId && Ne.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let ht = function(ft, Pt) {
              const Nt = [];
              if (ft.type === "FeatureCollection") for (let At = 0; At < ft.features.length; At++) Wt(Nt, ft.features[At], Pt, At);
              else Wt(Nt, ft.type === "Feature" ? ft : { geometry: ft }, Pt);
              return Nt;
            }(Ce, Ne);
            this.tiles = {}, this.tileCoords = [], Ke && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", Ne.indexMaxZoom, Ne.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), ht = function(ft, Pt) {
              const Nt = Pt.buffer / Pt.extent;
              let At = ft;
              const Zt = Rr(ft, 1, -1 - Nt, Nt, 0, -1, 2, Pt), jt = Rr(ft, 1, 1 - Nt, 2 + Nt, 0, -1, 2, Pt);
              return (Zt || jt) && (At = Rr(ft, 1, -Nt, 1 + Nt, 0, -1, 2, Pt) || [], Zt && (At = kt(Zt, 1).concat(At)), jt && (At = At.concat(kt(jt, -1)))), At;
            }(ht, Ne), ht.length && this.splitTile(ht, 0, 0, 0), Ke && (ht.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(Ce, Ne, Ke, ht, ft, Pt, Nt) {
            const At = [Ce, Ne, Ke, ht], Zt = this.options, jt = Zt.debug;
            for (; At.length; ) {
              ht = At.pop(), Ke = At.pop(), Ne = At.pop(), Ce = At.pop();
              const Yt = 1 << Ne, fr = yt(Ne, Ke, ht);
              let Ir = this.tiles[fr];
              if (!Ir && (jt > 1 && console.time("creation"), Ir = this.tiles[fr] = ni(Ce, Ne, Ke, ht, Zt), this.tileCoords.push({ z: Ne, x: Ke, y: ht }), jt)) {
                jt > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", Ne, Ke, ht, Ir.numFeatures, Ir.numPoints, Ir.numSimplified), console.timeEnd("creation"));
                const Gn = `z${Ne}`;
                this.stats[Gn] = (this.stats[Gn] || 0) + 1, this.total++;
              }
              if (Ir.source = Ce, ft == null) {
                if (Ne === Zt.indexMaxZoom || Ir.numPoints <= Zt.indexMaxPoints) continue;
              } else {
                if (Ne === Zt.maxZoom || Ne === ft) continue;
                if (ft != null) {
                  const Gn = ft - Ne;
                  if (Ke !== Pt >> Gn || ht !== Nt >> Gn) continue;
                }
              }
              if (Ir.source = null, Ce.length === 0) continue;
              jt > 1 && console.time("clipping");
              const Lr = 0.5 * Zt.buffer / Zt.extent, qr = 0.5 - Lr, pi = 0.5 + Lr, fi = 1 + Lr;
              let si = null, ki = null, Ni = null, Li = null, Wi = Rr(Ce, Yt, Ke - Lr, Ke + pi, 0, Ir.minX, Ir.maxX, Zt), Bi = Rr(Ce, Yt, Ke + qr, Ke + fi, 0, Ir.minX, Ir.maxX, Zt);
              Ce = null, Wi && (si = Rr(Wi, Yt, ht - Lr, ht + pi, 1, Ir.minY, Ir.maxY, Zt), ki = Rr(Wi, Yt, ht + qr, ht + fi, 1, Ir.minY, Ir.maxY, Zt), Wi = null), Bi && (Ni = Rr(Bi, Yt, ht - Lr, ht + pi, 1, Ir.minY, Ir.maxY, Zt), Li = Rr(Bi, Yt, ht + qr, ht + fi, 1, Ir.minY, Ir.maxY, Zt), Bi = null), jt > 1 && console.timeEnd("clipping"), At.push(si || [], Ne + 1, 2 * Ke, 2 * ht), At.push(ki || [], Ne + 1, 2 * Ke, 2 * ht + 1), At.push(Ni || [], Ne + 1, 2 * Ke + 1, 2 * ht), At.push(Li || [], Ne + 1, 2 * Ke + 1, 2 * ht + 1);
            }
          }
          getTile(Ce, Ne, Ke) {
            Ce = +Ce, Ne = +Ne, Ke = +Ke;
            const ht = this.options, { extent: ft, debug: Pt } = ht;
            if (Ce < 0 || Ce > 24) return null;
            const Nt = 1 << Ce, At = yt(Ce, Ne = Ne + Nt & Nt - 1, Ke);
            if (this.tiles[At]) return Je(this.tiles[At], ft);
            Pt > 1 && console.log("drilling down to z%d-%d-%d", Ce, Ne, Ke);
            let Zt, jt = Ce, Yt = Ne, fr = Ke;
            for (; !Zt && jt > 0; ) jt--, Yt >>= 1, fr >>= 1, Zt = this.tiles[yt(jt, Yt, fr)];
            return Zt && Zt.source ? (Pt > 1 && (console.log("found parent tile z%d-%d-%d", jt, Yt, fr), console.time("drilling down")), this.splitTile(Zt.source, jt, Yt, fr, Ce, Ne, Ke), Pt > 1 && console.timeEnd("drilling down"), this.tiles[At] ? Je(this.tiles[At], ft) : null) : null;
          }
        }
        function yt($t, Ce, Ne) {
          return 32 * ((1 << $t) * Ne + Ce) + $t;
        }
        function ar($t, Ce) {
          const Ne = $t.tileID.canonical;
          if (!this._geoJSONIndex) return void Ce(null, null);
          const Ke = this._geoJSONIndex.getTile(Ne.z, Ne.x, Ne.y);
          if (!Ke) return void Ce(null, null);
          const ht = new ce(Ke.features);
          let ft = Oe(ht);
          ft.byteOffset === 0 && ft.byteLength === ft.buffer.byteLength || (ft = new Uint8Array(ft)), Ce(null, { vectorTile: ht, rawData: ft.buffer });
        }
        class Or extends q {
          constructor(Ce, Ne, Ke, ht, ft, Pt) {
            super(Ce, Ne, Ke, ht, ar, Pt), ft && (this.loadGeoJSON = ft), this._dynamicIndex = new xe();
          }
          loadData(Ce, Ne) {
            const Ke = Ce && Ce.request, ht = Ke && Ke.collectResourceTiming;
            this.loadGeoJSON(Ce, (ft, Pt) => {
              if (ft || !Pt) return Ne(ft);
              if (typeof Pt != "object") return Ne(new Error(`Input data given to '${Ce.source}' is not a valid GeoJSON object.`));
              {
                try {
                  if (Ce.filter) {
                    const At = r.U(Ce.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                    if (At.result === "error") throw new Error(At.value.map((Zt) => `${Zt.key}: ${Zt.message}`).join(", "));
                    Pt.features = Pt.features.filter((Zt) => At.value.evaluate({ zoom: 0 }, Zt));
                  }
                  Ce.dynamic ? (Pt.type === "Feature" && (Pt = { type: "FeatureCollection", features: [Pt] }), Ce.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(Pt.features, this.loaded), Ce.cluster && (Pt.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = Ce.cluster ? new it(function({ superclusterOptions: At, clusterProperties: Zt }) {
                    if (!Zt || !At) return At;
                    const jt = {}, Yt = {}, fr = { accumulated: null, zoom: 0 }, Ir = { properties: null }, Lr = Object.keys(Zt);
                    for (const qr of Lr) {
                      const [pi, fi] = Zt[qr], si = r.U(fi), ki = r.U(typeof pi == "string" ? [pi, ["accumulated"], ["get", qr]] : pi);
                      jt[qr] = si.value, Yt[qr] = ki.value;
                    }
                    return At.map = (qr) => {
                      Ir.properties = qr;
                      const pi = {};
                      for (const fi of Lr) pi[fi] = jt[fi].evaluate(fr, Ir);
                      return pi;
                    }, At.reduce = (qr, pi) => {
                      Ir.properties = pi;
                      for (const fi of Lr) fr.accumulated = qr[fi], qr[fi] = Yt[fi].evaluate(fr, Ir);
                    }, At;
                  }(Ce)).load(Pt.features) : Ce.dynamic ? this._dynamicIndex : function(At, Zt) {
                    return new we(At, Zt);
                  }(Pt, Ce.geojsonVtOptions);
                } catch (At) {
                  return Ne(At);
                }
                const Nt = {};
                if (ht) {
                  const At = F(Ke);
                  At && (Nt.resourceTiming = {}, Nt.resourceTiming[Ce.source] = JSON.parse(JSON.stringify(At)));
                }
                Ne(null, Nt);
              }
            });
          }
          reloadTile(Ce, Ne) {
            const Ke = this.loaded;
            return Ke && Ke[Ce.uid] ? Ce.partial ? Ne(null, void 0) : super.reloadTile(Ce, Ne) : this.loadTile(Ce, Ne);
          }
          loadGeoJSON(Ce, Ne) {
            if (Ce.request) r.n(Ce.request, Ne);
            else {
              if (typeof Ce.data != "string") return Ne(new Error(`Input data given to '${Ce.source}' is not a valid GeoJSON object.`));
              try {
                return Ne(null, JSON.parse(Ce.data));
              } catch {
                return Ne(new Error(`Input data given to '${Ce.source}' is not a valid GeoJSON object.`));
              }
            }
          }
          getClusterExpansionZoom(Ce, Ne) {
            try {
              Ne(null, this._geoJSONIndex.getClusterExpansionZoom(Ce.clusterId));
            } catch (Ke) {
              Ne(Ke);
            }
          }
          getClusterChildren(Ce, Ne) {
            try {
              Ne(null, this._geoJSONIndex.getChildren(Ce.clusterId));
            } catch (Ke) {
              Ne(Ke);
            }
          }
          getClusterLeaves(Ce, Ne) {
            try {
              Ne(null, this._geoJSONIndex.getLeaves(Ce.clusterId, Ce.limit, Ce.offset));
            } catch (Ke) {
              Ne(Ke);
            }
          }
        }
        class Dr {
          constructor(Ce, Ne) {
            this.tileID = new r.aG(Ce.tileID.overscaledZ, Ce.tileID.wrap, Ce.tileID.canonical.z, Ce.tileID.canonical.x, Ce.tileID.canonical.y), this.tileZoom = Ce.tileZoom, this.uid = Ce.uid, this.zoom = Ce.zoom, this.canonical = Ce.tileID.canonical, this.pixelRatio = Ce.pixelRatio, this.tileSize = Ce.tileSize, this.source = Ce.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = Ce.projection, this.brightness = Ne;
          }
          parse(Ce, Ne, Ke, ht) {
            this.status = "parsing";
            const ft = new r.aG(Ke.tileID.overscaledZ, Ke.tileID.wrap, Ke.tileID.canonical.z, Ke.tileID.canonical.x, Ke.tileID.canonical.y), Pt = [], Nt = Ne.familiesBySource[Ke.source], At = new r.d$(ft, Ke.promoteId);
            return At.bucketLayerIDs = [], At.is3DTile = !0, r.ea(Ce).then((Zt) => {
              if (!Zt) return ht(new Error("Could not parse tile"));
              const jt = r.eb(Zt, 1 / r.cc(Ke.tileID.canonical)), Yt = Zt.json.extensionsUsed && Zt.json.extensionsUsed.includes("MAPBOX_mesh_features") || Zt.json.asset.extras && Zt.json.asset.extras.MAPBOX_mesh_features, fr = Zt.json.extensionsUsed && Zt.json.extensionsUsed.includes("EXT_meshopt_compression"), Ir = new r.a8(this.zoom, { brightness: this.brightness });
              for (const Lr in Nt) for (const qr of Nt[Lr]) {
                const pi = qr[0];
                At.bucketLayerIDs.push(qr.map((si) => r.aC(si.id, si.scope))), pi.recalculate(Ir, []);
                const fi = new r.ec(qr, jt, ft, Yt, fr, this.brightness, At);
                Yt || (fi.needsUpload = !0), Pt.push(fi), fi.evaluate(pi);
              }
              this.status = "done", ht(null, { buckets: Pt, featureIndex: At, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: null });
            }).catch((Zt) => ht(new Error(Zt.message)));
          }
        }
        class Kr {
          constructor(Ce, Ne, Ke, ht, ft, Pt) {
            this.actor = Ce, this.layerIndex = Ne, this.availableImages = Ke, this.brightness = Pt, this.loading = {}, this.loaded = {};
          }
          loadTile(Ce, Ne) {
            const Ke = Ce.uid, ht = this.loading[Ke] = new Dr(Ce, this.brightness);
            r.bi(Ce.request, (ft, Pt) => {
              const Nt = !this.loading[Ke];
              return delete this.loading[Ke], Nt || ft ? (ht.status = "done", Nt || (this.loaded[Ke] = ht), Ne(ft)) : Pt && Pt.byteLength !== 0 ? void ht.parse(Pt, this.layerIndex, Ce, (At, Zt) => {
                ht.status = "done", this.loaded = this.loaded || {}, this.loaded[Ke] = ht, At || !Zt ? Ne(At) : Ne(null, Zt);
              }) : (ht.status = "done", this.loaded[Ke] = ht, Ne());
            });
          }
          reloadTile(Ce, Ne) {
            const Ke = this.loaded, ht = Ce.uid;
            if (Ke && Ke[ht]) {
              const ft = Ke[ht];
              ft.projection = Ce.projection, ft.brightness = Ce.brightness;
              const Pt = (Nt, At) => {
                ft.reloadCallback && (delete ft.reloadCallback, this.loadTile(Ce, Ne)), Ne(Nt, At);
              };
              ft.status === "parsing" ? ft.reloadCallback = Pt : ft.status === "done" && this.loadTile(Ce, Ne);
            }
          }
          abortTile(Ce, Ne) {
            const Ke = Ce.uid;
            this.loading[Ke] && delete this.loading[Ke], Ne();
          }
          removeTile(Ce, Ne) {
            const Ke = this.loaded, ht = Ce.uid;
            Ke && Ke[ht] && delete Ke[ht], Ne();
          }
        }
        class di {
          constructor(Ce) {
            this.self = Ce, this.actor = new r.ed(Ce, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new r.I(), this.projections = {}, this.defaultProjection = r.bP({ name: "mercator" }), this.workerSourceTypes = { vector: q, geojson: Or, "batched-model": Kr }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (Ne, Ke) => {
              if (this.workerSourceTypes[Ne]) throw new Error(`Worker source with name "${Ne}" already registered.`);
              this.workerSourceTypes[Ne] = Ke;
            }, this.self.registerRTLTextPlugin = (Ne) => {
              if (r.ee.isParsed()) throw new Error("RTL text plugin already registered.");
              r.ee.applyArabicShaping = Ne.applyArabicShaping, r.ee.processBidirectionalText = Ne.processBidirectionalText, r.ee.processStyledBidirectionalText = Ne.processStyledBidirectionalText;
            };
          }
          clearCaches(Ce, Ne, Ke) {
            delete this.layerIndexes[Ce], delete this.availableImages[Ce], delete this.workerSources[Ce], delete this.demWorkerSources[Ce], delete this.rasterArrayWorkerSource, Ke();
          }
          checkIfReady(Ce, Ne, Ke) {
            Ke();
          }
          setReferrer(Ce, Ne) {
            this.referrer = Ne;
          }
          spriteLoaded(Ce, { scope: Ne, isLoaded: Ke }) {
            if (this.isSpriteLoaded[Ce] || (this.isSpriteLoaded[Ce] = {}), this.isSpriteLoaded[Ce][Ne] = Ke, this.workerSources[Ce] && this.workerSources[Ce][Ne]) for (const ht in this.workerSources[Ce][Ne]) {
              const ft = this.workerSources[Ce][Ne][ht];
              for (const Pt in ft) {
                const Nt = ft[Pt];
                Nt instanceof q && (Nt.isSpriteLoaded = Ke, Nt.fire(new r.z("isSpriteLoaded")));
              }
            }
          }
          setImages(Ce, { scope: Ne, images: Ke }, ht) {
            if (this.availableImages[Ce] || (this.availableImages[Ce] = {}), this.availableImages[Ce][Ne] = Ke, this.workerSources[Ce] && this.workerSources[Ce][Ne]) {
              for (const ft in this.workerSources[Ce][Ne]) {
                const Pt = this.workerSources[Ce][Ne][ft];
                for (const Nt in Pt) Pt[Nt].availableImages = Ke;
              }
              ht();
            } else ht();
          }
          setProjection(Ce, Ne) {
            this.projections[Ce] = r.bP(Ne);
          }
          setBrightness(Ce, Ne, Ke) {
            this.brightness = Ne, Ke();
          }
          setLayers(Ce, Ne, Ke) {
            this.getLayerIndex(Ce, Ne.scope).replace(Ne.layers, Ne.options), Ke();
          }
          updateLayers(Ce, Ne, Ke) {
            this.getLayerIndex(Ce, Ne.scope).update(Ne.layers, Ne.removedIds, Ne.options), Ke();
          }
          loadTile(Ce, Ne, Ke) {
            Ne.projection = this.projections[Ce] || this.defaultProjection, this.getWorkerSource(Ce, Ne.type, Ne.source, Ne.scope).loadTile(Ne, Ke);
          }
          loadDEMTile(Ce, Ne, Ke) {
            this.getDEMWorkerSource(Ce, Ne.source, Ne.scope).loadTile(Ne, Ke);
          }
          decodeRasterArray(Ce, Ne, Ke) {
            this.getRasterArrayWorkerSource().decodeRasterArray(Ne, Ke);
          }
          reloadTile(Ce, Ne, Ke) {
            Ne.projection = this.projections[Ce] || this.defaultProjection, this.getWorkerSource(Ce, Ne.type, Ne.source, Ne.scope).reloadTile(Ne, Ke);
          }
          abortTile(Ce, Ne, Ke) {
            this.getWorkerSource(Ce, Ne.type, Ne.source, Ne.scope).abortTile(Ne, Ke);
          }
          removeTile(Ce, Ne, Ke) {
            this.getWorkerSource(Ce, Ne.type, Ne.source, Ne.scope).removeTile(Ne, Ke);
          }
          removeSource(Ce, Ne, Ke) {
            if (!(this.workerSources[Ce] && this.workerSources[Ce][Ne.scope] && this.workerSources[Ce][Ne.scope][Ne.type] && this.workerSources[Ce][Ne.scope][Ne.type][Ne.source])) return;
            const ht = this.workerSources[Ce][Ne.scope][Ne.type][Ne.source];
            delete this.workerSources[Ce][Ne.scope][Ne.type][Ne.source], ht.removeSource !== void 0 ? ht.removeSource(Ne, Ke) : Ke();
          }
          loadWorkerSource(Ce, Ne, Ke) {
            try {
              this.self.importScripts(Ne.url), Ke();
            } catch (ht) {
              Ke(ht.toString());
            }
          }
          syncRTLPluginState(Ce, Ne, Ke) {
            try {
              r.ee.setState(Ne);
              const ht = r.ee.getPluginURL();
              if (r.ee.isLoaded() && !r.ee.isParsed() && ht != null) {
                this.self.importScripts(ht);
                const ft = r.ee.isParsed();
                Ke(ft ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${ht}`), ft);
              }
            } catch (ht) {
              Ke(ht.toString());
            }
          }
          setDracoUrl(Ce, Ne) {
            this.dracoUrl = Ne;
          }
          getAvailableImages(Ce, Ne) {
            this.availableImages[Ce] || (this.availableImages[Ce] = {});
            let Ke = this.availableImages[Ce][Ne];
            return Ke || (Ke = []), Ke;
          }
          getLayerIndex(Ce, Ne) {
            this.layerIndexes[Ce] || (this.layerIndexes[Ce] = {});
            let Ke = this.layerIndexes[Ce][Ne];
            return Ke || (Ke = this.layerIndexes[Ce][Ne] = new M(), Ke.scope = Ne), Ke;
          }
          getWorkerSource(Ce, Ne, Ke, ht) {
            return this.workerSources[Ce] || (this.workerSources[Ce] = {}), this.workerSources[Ce][ht] || (this.workerSources[Ce][ht] = {}), this.workerSources[Ce][ht][Ne] || (this.workerSources[Ce][ht][Ne] = {}), this.isSpriteLoaded[Ce] || (this.isSpriteLoaded[Ce] = {}), this.workerSources[Ce][ht][Ne][Ke] || (this.workerSources[Ce][ht][Ne][Ke] = new this.workerSourceTypes[Ne]({ send: (ft, Pt, Nt, At, Zt, jt) => {
              this.actor.send(ft, Pt, Nt, Ce, Zt, jt);
            }, scheduler: this.actor.scheduler }, this.getLayerIndex(Ce, ht), this.getAvailableImages(Ce, ht), this.isSpriteLoaded[Ce][ht], void 0, this.brightness)), this.workerSources[Ce][ht][Ne][Ke];
          }
          rasterizeImages(Ce, Ne, Ke) {
            const { imageTasks: ht, scope: ft } = Ne, Pt = {};
            for (const Nt in ht) {
              const { image: At, imageIdWithOptions: Zt } = ht[Nt];
              Pt[Nt] = this.imageRasterizer.rasterize(Zt, At, ft, Ce);
            }
            Ke(void 0, Pt);
          }
          removeRasterizedImages(Ce, Ne, Ke) {
            const { imageIds: ht, scope: ft } = Ne;
            this.imageRasterizer.removeImagesFromCacheByIds(ht, ft, Ce), Ke();
          }
          getDEMWorkerSource(Ce, Ne, Ke) {
            return this.demWorkerSources[Ce] || (this.demWorkerSources[Ce] = {}), this.demWorkerSources[Ce][Ke] || (this.demWorkerSources[Ce][Ke] = {}), this.demWorkerSources[Ce][Ke][Ne] || (this.demWorkerSources[Ce][Ke][Ne] = new Y()), this.demWorkerSources[Ce][Ke][Ne];
          }
          getRasterArrayWorkerSource() {
            return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new re()), this.rasterArrayWorkerSource;
          }
          enforceCacheSizeLimit(Ce, Ne) {
            r.ef(Ne);
          }
          getWorkerPerformanceMetrics(Ce, Ne, Ke) {
            Ke(void 0, void 0);
          }
        }
        return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope && (self.worker = new di(self)), di;
      }), $(["./shared"], function(r) {
        var F = "3.10.0";
        const H = { create: "create", load: "load", fullLoad: "fullLoad" }, P = { mark(l) {
          performance.mark(l);
        }, measure(l, t, n) {
          performance.measure(l, t, n);
        } };
        function M(l) {
          const t = l.name.split("?")[0];
          return r.a(t) && t.includes("mapbox-gl.js") ? "javascript" : r.a(t) && t.includes("mapbox-gl.css") ? "css" : r.b(t) ? "fontRange" : r.c(t) ? "sprite" : r.i(t) ? "style" : r.d(t) ? "tilejson" : "other";
        }
        var E, x = {}, m = function() {
          if (E) return x;
          function l(u) {
            return !t(u);
          }
          function t(u) {
            return typeof window > "u" || typeof document > "u" ? "not a browser" : function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
              var _, v, L = new Blob([""], { type: "text/javascript" }), G = URL.createObjectURL(L);
              try {
                v = new Worker(G), _ = !0;
              } catch {
                _ = !1;
              }
              return v && v.terminate(), URL.revokeObjectURL(G), _;
            }() ? function() {
              var _ = document.createElement("canvas");
              _.width = _.height = 1;
              var v = _.getContext("2d");
              if (!v) return !1;
              var L = v.getImageData(0, 0, 1, 1);
              return L && L.width === _.width;
            }() ? (n[d = u && u.failIfMajorPerformanceCaveat] === void 0 && (n[d] = function(_) {
              var v, L = function(G) {
                var X = document.createElement("canvas"), K = Object.create(l.webGLContextAttributes);
                return K.failIfMajorPerformanceCaveat = G, X.getContext("webgl2", K);
              }(_);
              if (!L) return !1;
              try {
                v = L.createShader(L.VERTEX_SHADER);
              } catch {
                return !1;
              }
              return !(!v || L.isContextLost()) && (L.shaderSource(v, "void main() {}"), L.compileShader(v), L.getShaderParameter(v, L.COMPILE_STATUS) === !0);
            }(d)), n[d] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
            var d;
          }
          E = 1, x.supported = l, x.notSupportedReason = t;
          var n = {};
          return l.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 }, x;
        }();
        function I(l, t, n) {
          const u = document.createElement(l);
          return t != null && (u.className = t), n && n.appendChild(u), u;
        }
        function z(l, t, n) {
          const u = document.createElementNS("http://www.w3.org/2000/svg", l);
          for (const d of Object.keys(t)) u.setAttributeNS(null, d, String(t[d]));
          return n && n.appendChild(u), u;
        }
        const w = typeof document < "u" ? document.documentElement && document.documentElement.style : null, C = w && w.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect";
        let b;
        function B() {
          w && C && (b = w[C], w[C] = "none");
        }
        function N() {
          w && C && (w[C] = b);
        }
        function U(l) {
          l.preventDefault(), l.stopPropagation(), window.removeEventListener("click", U, !0);
        }
        function V() {
          window.addEventListener("click", U, !0), window.setTimeout(() => {
            window.removeEventListener("click", U, !0);
          }, 0);
        }
        function W(l, t) {
          const n = l.getBoundingClientRect();
          return re(l, n, t);
        }
        function q(l, t) {
          const n = l.getBoundingClientRect(), u = [];
          for (let d = 0; d < t.length; d++) u.push(re(l, n, t[d]));
          return u;
        }
        function Y(l) {
          return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && l.button === 2 && l.ctrlKey ? 0 : l.button;
        }
        function re(l, t, n) {
          const u = l.offsetWidth === t.width ? 1 : l.offsetWidth / t.width;
          return new r.P((n.clientX - t.left) * u, (n.clientY - t.top) * u);
        }
        const se = "01", ve = "NO_ACCESS_TOKEN";
        class ce {
          constructor(t, n, u) {
            this._transformRequestFn = t, this._customAccessToken = n, this._silenceAuthErrors = !!u, this._createSkuToken();
          }
          _createSkuToken() {
            const t = function() {
              let n = "";
              for (let u = 0; u < 10; u++) n += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
              return { token: ["1", se, n].join(""), tokenExpiresAt: Date.now() + 432e5 };
            }();
            this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;
          }
          _isSkuTokenExpired() {
            return Date.now() > this._skuTokenExpiresAt;
          }
          transformRequest(t, n) {
            return this._transformRequestFn && this._transformRequestFn(t, n) || { url: t };
          }
          normalizeStyleURL(t, n) {
            if (!r.f(t)) return t;
            const u = Me(t);
            return u.params.push(`sdk=js-${F}`), u.path = `/styles/v1${u.path}`, this._makeAPIURL(u, this._customAccessToken || n);
          }
          normalizeGlyphsURL(t, n) {
            if (!r.f(t)) return t;
            const u = Me(t);
            return u.path = `/fonts/v1${u.path}`, this._makeAPIURL(u, this._customAccessToken || n);
          }
          normalizeModelURL(t, n) {
            if (!r.f(t)) return t;
            const u = Me(t);
            return u.path = `/models/v1${u.path}`, this._makeAPIURL(u, this._customAccessToken || n);
          }
          normalizeSourceURL(t, n, u, d) {
            if (!r.f(t)) return t;
            const _ = Me(t);
            return _.path = `/v4/${_.authority}.json`, _.params.push("secure"), u && _.params.push(`language=${u}`), d && _.params.push(`worldview=${d}`), this._makeAPIURL(_, this._customAccessToken || n);
          }
          normalizeIconsetURL(t, n) {
            const u = Me(t);
            return r.f(t) ? (u.path = `/styles/v1${u.path}/iconset.pbf`, this._makeAPIURL(u, this._customAccessToken || n)) : xe(u);
          }
          normalizeSpriteURL(t, n, u, d) {
            const _ = Me(t);
            return r.f(t) ? (_.path = `/styles/v1${_.path}/sprite${n}${u}`, this._makeAPIURL(_, this._customAccessToken || d)) : (_.path += `${n}${u}`, xe(_));
          }
          normalizeTileURL(t, n, u) {
            if (this._isSkuTokenExpired() && this._createSkuToken(), t && !r.f(t)) return t;
            const d = Me(t);
            d.path = d.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${n || u && d.authority !== "raster" && u === 512 ? "@2x" : ""}${r.m.supported ? ".webp" : "$1"}`), d.authority === "raster" ? d.path = `/${r.e.RASTER_URL_PREFIX}${d.path}` : d.authority === "rasterarrays" ? d.path = `/${r.e.RASTERARRAYS_URL_PREFIX}${d.path}` : d.authority === "3dtiles" ? d.path = `/${r.e.TILES3D_URL_PREFIX}${d.path}` : (d.path = d.path.replace(/^.+\/v4\//, "/"), d.path = `/${r.e.TILE_URL_VERSION}${d.path}`);
            const _ = this._customAccessToken || function(v) {
              for (const L of v) {
                const G = L.match(/^access_token=(.*)$/);
                if (G) return G[1];
              }
              return null;
            }(d.params) || r.e.ACCESS_TOKEN;
            return r.e.REQUIRE_ACCESS_TOKEN && _ && this._skuToken && d.params.push(`sku=${this._skuToken}`), this._makeAPIURL(d, _);
          }
          canonicalizeTileURL(t, n) {
            const u = Me(t);
            if (!u.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !u.path.match(/\.[\w]+$/)) return t;
            let d = "mapbox://";
            u.path.match(/^\/raster\/v1\//) ? d += `raster/${u.path.replace(`/${r.e.RASTER_URL_PREFIX}/`, "")}` : u.path.match(/^\/rasterarrays\/v1\//) ? d += `rasterarrays/${u.path.replace(`/${r.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : d += `tiles/${u.path.replace(`/${r.e.TILE_URL_VERSION}/`, "")}`;
            let _ = u.params;
            return n && (_ = _.filter((v) => !v.match(/^access_token=/))), _.length && (d += `?${_.join("&")}`), d;
          }
          canonicalizeTileset(t, n) {
            const u = !!n && r.f(n), d = [];
            for (const _ of t.tiles || []) r.h(_) ? d.push(this.canonicalizeTileURL(_, u)) : d.push(_);
            return d;
          }
          _makeAPIURL(t, n) {
            const u = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", d = Me(r.e.API_URL);
            if (t.protocol = d.protocol, t.authority = d.authority, t.protocol === "http") {
              const _ = t.params.indexOf("secure");
              _ >= 0 && t.params.splice(_, 1);
            }
            if (d.path !== "/" && (t.path = `${d.path}${t.path}`), !r.e.REQUIRE_ACCESS_TOKEN) return xe(t);
            if (n = n || r.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
              if (!n) throw new Error(`An API access token is required to use Mapbox GL. ${u}`);
              if (n[0] === "s") throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${u}`);
            }
            return t.params = t.params.filter((_) => _.indexOf("access_token") === -1), t.params.push(`access_token=${n || ""}`), xe(t);
          }
        }
        const be = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function Me(l) {
          const t = l.match(be);
          if (!t) throw new Error("Unable to parse URL object");
          return { protocol: t[1], authority: t[2], path: t[3] || "/", params: t[4] ? t[4].split("&") : [] };
        }
        function xe(l) {
          const t = l.params.length ? `?${l.params.join("&")}` : "";
          return `${l.protocol}://${l.authority}${l.path}${t}`;
        }
        const le = "mapbox.eventData";
        function de(l) {
          if (!l) return null;
          const t = l.split(".");
          if (!t || t.length !== 3) return null;
          try {
            return JSON.parse(r.j(t[1]));
          } catch {
            return null;
          }
        }
        class De {
          constructor(t) {
            this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
          }
          getStorageKey(t) {
            const n = de(r.e.ACCESS_TOKEN);
            let u = "";
            return u = n && n.u ? r.k(n.u) : r.e.ACCESS_TOKEN || "", t ? `${le}.${t}:${u}` : `${le}:${u}`;
          }
          fetchEventData() {
            const t = r.s("localStorage"), n = this.getStorageKey(), u = this.getStorageKey("uuid");
            if (t) try {
              const d = localStorage.getItem(n);
              d && (this.eventData = JSON.parse(d));
              const _ = localStorage.getItem(u);
              _ && (this.anonId = _);
            } catch {
              r.w("Unable to read from LocalStorage");
            }
          }
          saveEventData() {
            const t = r.s("localStorage"), n = this.getStorageKey(), u = this.getStorageKey("uuid"), d = this.anonId;
            if (t && d) try {
              localStorage.setItem(u, d), Object.keys(this.eventData).length >= 1 && localStorage.setItem(n, JSON.stringify(this.eventData));
            } catch {
              r.w("Unable to write to LocalStorage");
            }
          }
          processRequests(t) {
          }
          postEvent(t, n, u, d) {
            if (!r.e.EVENTS_URL) return;
            const _ = Me(r.e.EVENTS_URL);
            _.params.push(`access_token=${d || r.e.ACCESS_TOKEN || ""}`);
            const v = { event: this.type, created: new Date(t).toISOString() }, L = n ? r.l(v, n) : v, G = { url: xe(_), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([L]) };
            this.pendingRequest = r.p(G, (X) => {
              this.pendingRequest = null, u(X), this.saveEventData(), this.processRequests(d);
            });
          }
          queueRequest(t, n) {
            this.queue.push(t), this.processRequests(n);
          }
        }
        const ze = new class extends De {
          constructor(l) {
            super("appUserTurnstile"), this._customAccessToken = l;
          }
          postTurnstileEvent(l, t) {
            r.e.EVENTS_URL && r.e.ACCESS_TOKEN && Array.isArray(l) && l.some((n) => r.f(n) || r.h(n)) && this.queueRequest(Date.now(), t);
          }
          processRequests(l) {
            if (this.pendingRequest || this.queue.length === 0) return;
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            const t = de(r.e.ACCESS_TOKEN), n = t ? t.u : r.e.ACCESS_TOKEN;
            let u = n !== this.eventData.tokenU;
            r.v(this.anonId) || (this.anonId = r.u(), u = !0);
            const d = this.queue.shift();
            if (this.eventData.lastSuccess) {
              const _ = new Date(this.eventData.lastSuccess), v = new Date(d), L = (d - this.eventData.lastSuccess) / 864e5;
              u = u || L >= 1 || L < -1 || _.getDate() !== v.getDate();
            } else u = !0;
            u ? this.postEvent(d, { sdkIdentifier: "mapbox-gl-js", sdkVersion: F, skuId: se, "enabled.telemetry": !1, userId: this.anonId }, (_) => {
              _ || (this.eventData.lastSuccess = d, this.eventData.tokenU = n);
            }, l) : this.processRequests();
          }
        }(), Ze = ze.postTurnstileEvent.bind(ze), Ue = new class extends De {
          constructor() {
            super("map.load"), this.success = {}, this.skuToken = "";
          }
          postMapLoadEvent(l, t, n, u) {
            this.skuToken = t, this.errorCb = u, r.e.EVENTS_URL && (n || r.e.ACCESS_TOKEN ? this.queueRequest({ id: l, timestamp: Date.now() }, n) : this.errorCb(new Error(ve)));
          }
          processRequests(l) {
            if (this.pendingRequest || this.queue.length === 0) return;
            const { id: t, timestamp: n } = this.queue.shift();
            t && this.success[t] || (this.anonId || this.fetchEventData(), r.v(this.anonId) || (this.anonId = r.u()), this.postEvent(n, { sdkIdentifier: "mapbox-gl-js", sdkVersion: F, skuId: se, skuToken: this.skuToken, userId: this.anonId }, (u) => {
              u ? this.errorCb(u) : t && (this.success[t] = !0);
            }, l));
          }
          remove() {
            this.errorCb = null;
          }
        }(), Ie = Ue.postMapLoadEvent.bind(Ue), je = new class extends De {
          constructor() {
            super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
          }
          getMapInstanceId(l) {
            let t = this.mapInstanceIdMap.get(l);
            return t || (t = r.u(), this.mapInstanceIdMap.set(l, t)), t;
          }
          getEventId(l) {
            const t = this.eventIdPerMapInstanceMap.get(l) || 0;
            return this.eventIdPerMapInstanceMap.set(l, t + 1), t;
          }
          postStyleLoadEvent(l, t) {
            const { map: n, style: u, importedStyles: d } = t;
            if (!r.e.EVENTS_URL || !l && !r.e.ACCESS_TOKEN) return;
            const _ = this.getMapInstanceId(n), v = { mapInstanceId: _, eventId: this.getEventId(_), style: u };
            d.length && (v.importedStyles = d), this.queueRequest({ timestamp: Date.now(), payload: v }, l);
          }
          processRequests(l) {
            if (this.pendingRequest || this.queue.length === 0) return;
            const { timestamp: t, payload: n } = this.queue.shift();
            this.postEvent(t, n, () => {
            }, l);
          }
        }(), Fe = je.postStyleLoadEvent.bind(je), $e = new class extends De {
          constructor() {
            super("gljs.performance");
          }
          postPerformanceEvent(l, t) {
            r.e.EVENTS_URL && (l || r.e.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: t }, l);
          }
          processRequests(l) {
            if (this.pendingRequest || this.queue.length === 0) return;
            const { timestamp: t, performanceData: n } = this.queue.shift(), u = function(d) {
              const _ = performance.getEntriesByType("resource"), v = performance.getEntriesByType("mark"), L = function(pe) {
                const Be = {};
                if (pe) {
                  for (const Re in pe) if (Re !== "other") for (const Ge of pe[Re]) {
                    const Ve = `${Re}ResolveRangeMin`, et = `${Re}ResolveRangeMax`, ut = `${Re}RequestCount`, st = `${Re}RequestCachedCount`;
                    Be[Ve] = Math.min(Be[Ve] || 1 / 0, Ge.startTime), Be[et] = Math.max(Be[et] || -1 / 0, Ge.responseEnd);
                    const xt = (mt) => {
                      Be[mt] === void 0 && (Be[mt] = 0), ++Be[mt];
                    };
                    Ge.transferSize !== void 0 && Ge.transferSize === 0 && xt(st), xt(ut);
                  }
                }
                return Be;
              }(function(pe, Be) {
                const Re = {};
                if (pe) for (const Ge of pe) {
                  const Ve = Be(Ge);
                  Re[Ve] === void 0 && (Re[Ve] = []), Re[Ve].push(Ge);
                }
                return Re;
              }(_, M)), G = window.devicePixelRatio, X = navigator.connection || navigator.mozConnection || navigator.webkitConnection, K = X ? X.effectiveType : void 0, ae = { counters: [], metadata: [], attributes: [] }, oe = (pe, Be, Re) => {
                Re != null && pe.push({ name: Be, value: Re.toString() });
              };
              for (const pe in L) oe(ae.counters, pe, L[pe]);
              if (d.interactionRange[0] !== 1 / 0 && d.interactionRange[1] !== -1 / 0 && (oe(ae.counters, "interactionRangeMin", d.interactionRange[0]), oe(ae.counters, "interactionRangeMax", d.interactionRange[1])), v) for (const pe of Object.keys(H)) {
                const Be = H[pe], Re = v.find((Ge) => Ge.name === Be);
                Re && oe(ae.counters, Be, Re.startTime);
              }
              return oe(ae.counters, "visibilityHidden", d.visibilityHidden), oe(ae.attributes, "style", function(pe) {
                if (pe) for (const Be of pe) {
                  const Re = Be.name.split("?")[0];
                  if (r.i(Re)) {
                    const Ge = Re.split("/").slice(-2);
                    if (Ge.length === 2) return `mapbox://styles/${Ge[0]}/${Ge[1]}`;
                  }
                }
              }(_)), oe(ae.attributes, "terrainEnabled", d.terrainEnabled ? "true" : "false"), oe(ae.attributes, "fogEnabled", d.fogEnabled ? "true" : "false"), oe(ae.attributes, "projection", d.projection), oe(ae.attributes, "zoom", d.zoom), oe(ae.metadata, "devicePixelRatio", G), oe(ae.metadata, "connectionEffectiveType", K), oe(ae.metadata, "navigatorUserAgent", navigator.userAgent), oe(ae.metadata, "screenWidth", window.screen.width), oe(ae.metadata, "screenHeight", window.screen.height), oe(ae.metadata, "windowWidth", window.innerWidth), oe(ae.metadata, "windowHeight", window.innerHeight), oe(ae.metadata, "mapWidth", d.width / G), oe(ae.metadata, "mapHeight", d.height / G), oe(ae.metadata, "webglRenderer", d.renderer), oe(ae.metadata, "webglVendor", d.vendor), oe(ae.metadata, "sdkVersion", F), oe(ae.metadata, "sdkIdentifier", "mapbox-gl-js"), ae;
            }(n);
            for (const d of u.metadata) ;
            for (const d of u.counters) ;
            for (const d of u.attributes) ;
            this.postEvent(t, u, () => {
            }, l);
          }
        }(), ct = $e.postPerformanceEvent.bind($e), wt = new class extends De {
          constructor() {
            super("map.auth"), this.success = {}, this.skuToken = "";
          }
          getSession(l, t, n, u) {
            if (!r.e.API_URL || !r.e.SESSION_PATH) return;
            const d = Me(r.e.API_URL + r.e.SESSION_PATH);
            d.params.push(`sku=${t || ""}`), d.params.push(`access_token=${u || r.e.ACCESS_TOKEN || ""}`);
            const _ = { url: xe(d), headers: { "Content-Type": "text/plain" } };
            this.pendingRequest = r.g(_, (v) => {
              this.pendingRequest = null, n(v), this.saveEventData(), this.processRequests(u);
            });
          }
          getSessionAPI(l, t, n, u) {
            this.skuToken = t, this.errorCb = u, r.e.SESSION_PATH && r.e.API_URL && (n || r.e.ACCESS_TOKEN ? this.queueRequest({ id: l, timestamp: Date.now() }, n) : this.errorCb(new Error(ve)));
          }
          processRequests(l) {
            if (this.pendingRequest || this.queue.length === 0) return;
            const { id: t, timestamp: n } = this.queue.shift();
            t && this.success[t] || this.getSession(n, this.skuToken, (u) => {
              u ? this.errorCb(u) : t && (this.success[t] = !0);
            }, l);
          }
          remove() {
            this.errorCb = null;
          }
        }(), Oe = wt.getSessionAPI.bind(wt), Ct = /* @__PURE__ */ new Set();
        function Xt(l, t) {
          t ? Ct.add(l) : Ct.delete(l);
        }
        class vt {
          constructor() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = /* @__PURE__ */ new Set();
          }
          isDirty() {
            return this._changed;
          }
          setDirty() {
            this._changed = !0;
          }
          getUpdatedSourceCaches() {
            return this._updatedSourceCaches;
          }
          updateSourceCache(t, n) {
            this._updatedSourceCaches[t] = n, this.setDirty();
          }
          discardSourceCacheUpdate(t) {
            delete this._updatedSourceCaches[t];
          }
          updateLayer(t) {
            const n = t.scope;
            this._updatedLayers[n] = this._updatedLayers[n] || /* @__PURE__ */ new Set(), this._updatedLayers[n].add(t.id), this.setDirty();
          }
          removeLayer(t) {
            const n = t.scope;
            this._removedLayers[n] = this._removedLayers[n] || {}, this._updatedLayers[n] = this._updatedLayers[n] || /* @__PURE__ */ new Set(), this._removedLayers[n][t.id] = t, this._updatedLayers[n].delete(t.id), this._updatedPaintProps.delete(t.fqid), this.setDirty();
          }
          getRemovedLayer(t) {
            return this._removedLayers[t.scope] ? this._removedLayers[t.scope][t.id] : null;
          }
          discardLayerRemoval(t) {
            this._removedLayers[t.scope] && delete this._removedLayers[t.scope][t.id];
          }
          getLayerUpdatesByScope() {
            const t = {};
            for (const n in this._updatedLayers) t[n] = t[n] || {}, t[n].updatedIds = Array.from(this._updatedLayers[n].values());
            for (const n in this._removedLayers) t[n] = t[n] || {}, t[n].removedIds = Object.keys(this._removedLayers[n]);
            return t;
          }
          getUpdatedPaintProperties() {
            return this._updatedPaintProps;
          }
          updatePaintProperties(t) {
            this._updatedPaintProps.add(t.fqid), this.setDirty();
          }
          getUpdatedImages() {
            return Array.from(this._updatedImages.values());
          }
          updateImage(t) {
            this._updatedImages.add(t), this.setDirty();
          }
          resetUpdatedImages() {
            this._updatedImages.clear();
          }
          reset() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
          }
        }
        function Ye(l) {
          const { userImage: t } = l;
          return !!(t && t.render && t.render()) && (l.data.replace(new Uint8Array(t.data.buffer)), !0);
        }
        class qe extends r.E {
          constructor(t) {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = !0, this.spriteFormat = t, t !== "raster" && r.t() && (this.imageRasterizerDispatcher = new r.D(r.x(), this, "Image Rasterizer Worker", 1));
          }
          get imageRasterizer() {
            return this._imageRasterizer || (this._imageRasterizer = new r.I()), this._imageRasterizer;
          }
          createScope(t) {
            this.images[t] = {}, this.loaded[t] = !1, this.updatedImages[t] = {}, this.patterns[t] = {}, this.callbackDispatchedThisFrame[t] = {}, this.atlasImage[t] = new r.r({ width: 1, height: 1 });
          }
          isLoaded() {
            for (const t in this.loaded) if (!this.loaded[t]) return !1;
            return !0;
          }
          setLoaded(t, n) {
            if (this.loaded[n] !== t && (this.loaded[n] = t, t)) {
              for (const { ids: u, callback: d } of this.requestors) this._notify(u, n, d);
              this.requestors = [];
            }
          }
          hasImage(t, n) {
            return !!this.getImage(t, n);
          }
          getImage(t, n) {
            return this.images[n][t];
          }
          addImage(t, n, u) {
            this._validate(t, u) && (this.images[n][t] = u);
          }
          _validate(t, n) {
            let u = !0;
            return this._validateStretch(n.stretchX, n.data && n.data.width) || (this.fire(new r.y(new Error(`Image "${t}" has invalid "stretchX" value`))), u = !1), this._validateStretch(n.stretchY, n.data && n.data.height) || (this.fire(new r.y(new Error(`Image "${t}" has invalid "stretchY" value`))), u = !1), this._validateContent(n.content, n) || (this.fire(new r.y(new Error(`Image "${t}" has invalid "content" value`))), u = !1), u;
          }
          _validateStretch(t, n) {
            if (!t) return !0;
            let u = 0;
            for (const d of t) {
              if (d[0] < u || d[1] < d[0] || n < d[1]) return !1;
              u = d[1];
            }
            return !0;
          }
          _validateContent(t, n) {
            return t ? t.length !== 4 || !n.usvg && (t[0] < 0 || n.data.width < t[0] || t[1] < 0 || n.data.height < t[1] || t[2] < 0 || n.data.width < t[2] || t[3] < 0 || n.data.height < t[3]) ? !1 : !(t[2] < t[0] || t[3] < t[1]) : !0;
          }
          updateImage(t, n, u) {
            u.version = this.images[n][t].version + 1, this.images[n][t] = u, this.updatedImages[n][t] = !0, this.removeFromImageRasterizerCache(t, n);
          }
          removeFromImageRasterizerCache(t, n) {
            this.spriteFormat !== "raster" && (r.t() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", { imageIds: [t], scope: n }) : this.imageRasterizer.removeImagesFromCacheByIds([t], n));
          }
          removeImage(t, n) {
            const u = this.images[n][t];
            delete this.images[n][t], delete this.patterns[n][t], this.removeFromImageRasterizerCache(t, n), u.userImage && u.userImage.onRemove && u.userImage.onRemove();
          }
          listImages(t) {
            return Object.keys(this.images[t]);
          }
          getImages(t, n, u) {
            let d = !0;
            const _ = !!this.loaded[n];
            if (!_) for (const v of t) this.images[n][v] || (d = !1);
            _ || d ? this._notify(t, n, u) : this.requestors.push({ ids: t, scope: n, callback: u });
          }
          rasterizeImages({ scope: t, imageTasks: n }, u) {
            const d = {};
            for (const _ in n) {
              const v = n[_], L = this.getImage(v.id, t);
              L && (d[_] = { image: L, imageIdWithOptions: v });
            }
            r.t() ? this.imageRasterizerDispatcher.getActor().send("rasterizeImages", { imageTasks: d, scope: t }, u) : this.rasterizeImagesInMainThread({ imageTasks: d, scope: t }, u);
          }
          rasterizeImagesInMainThread(t, n) {
            const { imageTasks: u, scope: d } = t, _ = {};
            for (const v in u) {
              const { image: L, imageIdWithOptions: G } = u[v];
              _[v] = this.imageRasterizer.rasterize(G, L, d, "");
            }
            n(void 0, _);
          }
          getUpdatedImages(t) {
            return this.updatedImages[t];
          }
          _notify(t, n, u) {
            const d = {};
            for (const _ of t) {
              this.images[n][_] || this.fire(new r.z("styleimagemissing", { id: _ }));
              const v = this.images[n][_];
              v ? d[_] = { data: v.usvg ? null : v.data.clone(), pixelRatio: v.pixelRatio, sdf: v.sdf, usvg: v.usvg, version: v.version, stretchX: v.stretchX, stretchY: v.stretchY, content: v.content, hasRenderCallback: !!(v.userImage && v.userImage.render) } : r.w(`Image "${_}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            u(null, d);
          }
          getPixelSize(t) {
            const { width: n, height: u } = this.atlasImage[t];
            return { width: n, height: u };
          }
          getPattern(t, n, u) {
            const d = this.patterns[n][t], _ = this.getImage(t, n);
            if (!_) return null;
            if (d && d.position.version === _.version) return d.position;
            if (d) d.position.version = _.version;
            else {
              _.usvg && !_.data && (_.data = this.imageRasterizer.rasterize(r.A.from(t).getPrimary(), _, n, ""));
              const v = { w: _.data.width + 2 * r.B, h: _.data.height + 2 * r.B, x: 0, y: 0 }, L = new r.C(v, _, r.B);
              this.patterns[n][t] = { bin: v, position: L };
            }
            return this._updatePatternAtlas(n, u), this.patterns[n][t].position;
          }
          bind(t, n) {
            const u = t.gl;
            let d = this.atlasTexture[n];
            d ? this.dirty && (d.update(this.atlasImage[n]), this.dirty = !1) : (d = new r.T(t, this.atlasImage[n], u.RGBA8), this.atlasTexture[n] = d), d.bind(u.LINEAR, u.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas(t, n) {
            const u = [];
            for (const L in this.patterns[t]) u.push(this.patterns[t][L].bin);
            const { w: d, h: _ } = r.F(u), v = this.atlasImage[t];
            v.resize({ width: d || 1, height: _ || 1 });
            for (const L in this.patterns[t]) {
              const { bin: G, position: X } = this.patterns[t][L];
              let K = X.padding;
              const ae = G.x + K, oe = G.y + K, pe = this.images[t][L].data, Be = pe.width, Re = pe.height;
              K = K > 1 ? K - 1 : K, r.r.copy(pe, v, { x: 0, y: 0 }, { x: ae, y: oe }, { width: Be, height: Re }, n), r.r.copy(pe, v, { x: 0, y: Re - K }, { x: ae, y: oe - K }, { width: Be, height: K }, n), r.r.copy(pe, v, { x: 0, y: 0 }, { x: ae, y: oe + Re }, { width: Be, height: K }, n), r.r.copy(pe, v, { x: Be - K, y: 0 }, { x: ae - K, y: oe }, { width: K, height: Re }, n), r.r.copy(pe, v, { x: 0, y: 0 }, { x: ae + Be, y: oe }, { width: K, height: Re }, n), r.r.copy(pe, v, { x: Be - K, y: Re - K }, { x: ae - K, y: oe - K }, { width: K, height: K }, n), r.r.copy(pe, v, { x: 0, y: Re - K }, { x: ae + Be, y: oe - K }, { width: K, height: K }, n), r.r.copy(pe, v, { x: 0, y: 0 }, { x: ae + Be, y: oe + Re }, { width: K, height: K }, n), r.r.copy(pe, v, { x: Be - K, y: 0 }, { x: ae - K, y: oe + Re }, { width: K, height: K }, n);
            }
            this.dirty = !0;
          }
          beginFrame() {
            for (const t in this.images) this.callbackDispatchedThisFrame[t] = {};
          }
          dispatchRenderCallbacks(t, n) {
            for (const u of t) {
              if (this.callbackDispatchedThisFrame[n][u]) continue;
              this.callbackDispatchedThisFrame[n][u] = !0;
              const d = this.images[n][u];
              Ye(d) && this.updateImage(u, n, d);
            }
          }
        }
        function rt(l) {
          const t = l.key, n = l.value, u = l.valueSpec || {}, d = l.objectElementValidators || {}, _ = l.style, v = l.styleSpec;
          let L = [];
          const G = r.H(n);
          if (G !== "object") return [new r.V(t, n, `object expected, ${G} found`)];
          for (const X in n) {
            const K = X.split(".")[0];
            let ae;
            d[K] ? ae = d[K] : u[K] ? ae = Tt : d["*"] ? ae = d["*"] : u["*"] && (ae = Tt), ae ? L = L.concat(ae({ key: (t && `${t}.`) + X, value: n[X], valueSpec: u[K] || u["*"], style: _, styleSpec: v, object: n, objectKey: X }, n)) : L.push(new r.G(t, n[X], `unknown property "${X}"`));
          }
          for (const X in u) d[X] || u[X].required && u[X].default === void 0 && n[X] === void 0 && L.push(new r.V(t, n, `missing required property "${X}"`));
          return L;
        }
        function it(l) {
          const t = l.value, n = l.valueSpec, u = l.style, d = l.styleSpec, _ = l.key, v = l.arrayElementValidator || Tt;
          if (r.H(t) !== "array") return [new r.V(_, t, `array expected, ${r.H(t)} found`)];
          if (n.length && t.length !== n.length) return [new r.V(_, t, `array length ${n.length} expected, length ${t.length} found`)];
          if (n["min-length"] && t.length < n["min-length"]) return [new r.V(_, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
          let L = { type: n.value, values: n.values, minimum: n.minimum, maximum: n.maximum, function: void 0 };
          d.$version < 7 && (L.function = n.function), r.H(n.value) === "object" && (L = n.value);
          let G = [];
          for (let X = 0; X < t.length; X++) G = G.concat(v({ array: t, arrayIndex: X, value: t[X], valueSpec: L, style: u, styleSpec: d, key: `${_}[${X}]` }, !0));
          return G;
        }
        function Ae(l) {
          const t = l.key, n = l.value, u = l.valueSpec;
          let d = r.H(n);
          if (d === "number" && n != n && (d = "NaN"), d !== "number") return [new r.V(t, n, `number expected, ${d} found`)];
          if ("minimum" in u) {
            let _ = u.minimum;
            if (r.H(u.minimum) === "array" && (_ = u.minimum[l.arrayIndex]), n < _) return [new r.V(t, n, `${n} is less than the minimum value ${_}`)];
          }
          if ("maximum" in u) {
            let _ = u.maximum;
            if (r.H(u.maximum) === "array" && (_ = u.maximum[l.arrayIndex]), n > _) return [new r.V(t, n, `${n} is greater than the maximum value ${_}`)];
          }
          return [];
        }
        function _e(l) {
          const t = l.valueSpec, n = r.K(l.value.type);
          let u, d, _, v = {};
          const L = n !== "categorical" && l.value.property === void 0, G = !L, X = r.H(l.value.stops) === "array" && r.H(l.value.stops[0]) === "array" && r.H(l.value.stops[0][0]) === "object", K = rt({ key: l.key, value: l.value, valueSpec: l.styleSpec.function, style: l.style, styleSpec: l.styleSpec, objectElementValidators: { stops: function(pe) {
            if (n === "identity") return [new r.V(pe.key, pe.value, 'identity function may not have a "stops" property')];
            let Be = [];
            const Re = pe.value;
            return Be = Be.concat(it({ key: pe.key, value: Re, valueSpec: pe.valueSpec, style: pe.style, styleSpec: pe.styleSpec, arrayElementValidator: ae })), r.H(Re) === "array" && Re.length === 0 && Be.push(new r.V(pe.key, Re, "array must have at least one stop")), Be;
          }, default: function(pe) {
            return Tt({ key: pe.key, value: pe.value, valueSpec: t, style: pe.style, styleSpec: pe.styleSpec });
          } } });
          return n === "identity" && L && K.push(new r.V(l.key, l.value, 'missing required property "property"')), n === "identity" || l.value.stops || K.push(new r.V(l.key, l.value, 'missing required property "stops"')), n === "exponential" && l.valueSpec.expression && !r.L(l.valueSpec) && K.push(new r.V(l.key, l.value, "exponential functions not supported")), l.styleSpec.$version >= 8 && (G && !r.M(l.valueSpec) ? K.push(new r.V(l.key, l.value, "property functions not supported")) : L && !r.N(l.valueSpec) && K.push(new r.V(l.key, l.value, "zoom functions not supported"))), n !== "categorical" && !X || l.value.property !== void 0 || K.push(new r.V(l.key, l.value, '"property" property is required')), K;
          function ae(pe) {
            let Be = [];
            const Re = pe.value, Ge = pe.key;
            if (r.H(Re) !== "array") return [new r.V(Ge, Re, `array expected, ${r.H(Re)} found`)];
            if (Re.length !== 2) return [new r.V(Ge, Re, `array length 2 expected, length ${Re.length} found`)];
            if (X) {
              if (r.H(Re[0]) !== "object") return [new r.V(Ge, Re, `object expected, ${r.H(Re[0])} found`)];
              if (Re[0].zoom === void 0) return [new r.V(Ge, Re, "object stop key must have zoom")];
              if (Re[0].value === void 0) return [new r.V(Ge, Re, "object stop key must have value")];
              const Ve = r.K(Re[0].zoom);
              if (typeof Ve != "number") return [new r.V(Ge, Re[0].zoom, "stop zoom values must be numbers")];
              if (_ && _ > Ve) return [new r.V(Ge, Re[0].zoom, "stop zoom values must appear in ascending order")];
              Ve !== _ && (_ = Ve, d = void 0, v = {}), Be = Be.concat(rt({ key: `${Ge}[0]`, value: Re[0], valueSpec: { zoom: {} }, style: pe.style, styleSpec: pe.styleSpec, objectElementValidators: { zoom: Ae, value: oe } }));
            } else Be = Be.concat(oe({ key: `${Ge}[0]`, value: Re[0], valueSpec: {}, style: pe.style, styleSpec: pe.styleSpec }, Re));
            return r.O(r.Q(Re[1])) ? Be.concat([new r.V(`${Ge}[1]`, Re[1], "expressions are not allowed in function stops.")]) : Be.concat(Tt({ key: `${Ge}[1]`, value: Re[1], valueSpec: t, style: pe.style, styleSpec: pe.styleSpec }));
          }
          function oe(pe, Be) {
            const Re = r.H(pe.value), Ge = r.K(pe.value), Ve = pe.value !== null ? pe.value : Be;
            if (u) {
              if (Re !== u) return [new r.V(pe.key, Ve, `${Re} stop domain type must match previous stop domain type ${u}`)];
            } else u = Re;
            if (Re !== "number" && Re !== "string" && Re !== "boolean" && typeof Ge != "number" && typeof Ge != "string" && typeof Ge != "boolean") return [new r.V(pe.key, Ve, "stop domain value must be a number, string, or boolean")];
            if (Re !== "number" && n !== "categorical") {
              let et = `number expected, ${Re} found`;
              return r.M(t) && n === void 0 && (et += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new r.V(pe.key, Ve, et)];
            }
            return n !== "categorical" || Re !== "number" || typeof Ge == "number" && isFinite(Ge) && Math.floor(Ge) === Ge ? n !== "categorical" && Re === "number" && typeof Ge == "number" && typeof d == "number" && d !== void 0 && Ge < d ? [new r.V(pe.key, Ve, "stop domain values must appear in ascending order")] : (d = Ge, n === "categorical" && Ge in v ? [new r.V(pe.key, Ve, "stop domain values must be unique")] : (v[Ge] = !0, [])) : [new r.V(pe.key, Ve, `integer expected, found ${String(Ge)}`)];
          }
        }
        function fe(l) {
          const t = (l.expressionContext === "property" ? r.S : r.U)(r.Q(l.value), l.valueSpec);
          if (t.result === "error") return t.value.map((u) => new r.V(`${l.key}${u.key}`, l.value, u.message));
          const n = t.value.expression || t.value._styleExpression.expression;
          if (l.expressionContext === "property" && l.propertyKey === "text-font" && !n.outputDefined()) return [new r.V(l.key, l.value, `Invalid data expression for "${l.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (l.expressionContext === "property" && l.propertyType === "layout" && !r.W(n)) return [new r.V(l.key, l.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (l.expressionContext === "filter") return We(n, l);
          if (l.expressionContext && l.expressionContext.indexOf("cluster") === 0) {
            if (!r.X(n, ["zoom", "feature-state"])) return [new r.V(l.key, l.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (l.expressionContext === "cluster-initial" && !r.Y(n)) return [new r.V(l.key, l.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function We(l, t) {
          const n = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
          if (t.valueSpec && t.valueSpec.expression) for (const d of t.valueSpec.expression.parameters) n.delete(d);
          if (n.size === 0) return [];
          const u = [];
          return l instanceof r.Z && n.has(l.name) ? [new r.V(t.key, t.value, `["${l.name}"] expression is not supported in a filter for a ${t.object.type} layer with id: ${t.object.id}`)] : (l.eachChild((d) => {
            u.push(...We(d, t));
          }), u);
        }
        function Pe(l) {
          const t = l.key, n = l.value, u = l.valueSpec, d = [];
          return Array.isArray(u.values) ? u.values.indexOf(r.K(n)) === -1 && d.push(new r.V(t, n, `expected one of [${u.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(u.values).indexOf(r.K(n)) === -1 && d.push(new r.V(t, n, `expected one of [${Object.keys(u.values).join(", ")}], ${JSON.stringify(n)} found`)), d;
        }
        function he(l) {
          return r.$(r.Q(l.value)) ? fe(r.J({}, l, { expressionContext: "filter", valueSpec: l.styleSpec[`filter_${l.layerType || "fill"}`] })) : ie(l);
        }
        function ie(l) {
          const t = l.value, n = l.key;
          if (r.H(t) !== "array") return [new r.V(n, t, `array expected, ${r.H(t)} found`)];
          const u = l.styleSpec;
          let d, _ = [];
          if (t.length < 1) return [new r.V(n, t, "filter array must have at least 1 element")];
          switch (_ = _.concat(Pe({ key: `${n}[0]`, value: t[0], valueSpec: u.filter_operator, style: l.style, styleSpec: l.styleSpec })), r.K(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && r.K(t[1]) === "$type" && _.push(new r.V(n, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && _.push(new r.V(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (d = r.H(t[1]), d !== "string" && _.push(new r.V(`${n}[1]`, t[1], `string expected, ${d} found`)));
              for (let v = 2; v < t.length; v++) d = r.H(t[v]), r.K(t[1]) === "$type" ? _ = _.concat(Pe({ key: `${n}[${v}]`, value: t[v], valueSpec: u.geometry_type, style: l.style, styleSpec: l.styleSpec })) : d !== "string" && d !== "number" && d !== "boolean" && _.push(new r.V(`${n}[${v}]`, t[v], `string, number, or boolean expected, ${d} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let v = 1; v < t.length; v++) _ = _.concat(ie({ key: `${n}[${v}]`, value: t[v], style: l.style, styleSpec: l.styleSpec }));
              break;
            case "has":
            case "!has":
              d = r.H(t[1]), t.length !== 2 ? _.push(new r.V(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : d !== "string" && _.push(new r.V(`${n}[1]`, t[1], `string expected, ${d} found`));
          }
          return _;
        }
        function Xe(l, t) {
          const n = l.key, u = l.style, d = l.layer, _ = l.styleSpec, v = l.value, L = l.objectKey, G = _[`${t}_${l.layerType}`];
          if (!G) return [];
          const X = L.match(/^(.*)-use-theme$/);
          if (t === "paint" && X && G[X[1]]) return r.O(v) ? [].concat(Tt({ key: l.key, value: v, valueSpec: { type: "string", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, style: u, styleSpec: _, expressionContext: "property", propertyType: t, propertyKey: L })) : Tt({ key: n, value: v, valueSpec: { type: "string" }, style: u, styleSpec: _ });
          const K = L.match(/^(.*)-transition$/);
          if (t === "paint" && K && G[K[1]] && G[K[1]].transition) return Tt({ key: n, value: v, valueSpec: _.transition, style: u, styleSpec: _ });
          const ae = l.valueSpec || G[L];
          if (!ae) return [new r.G(n, v, `unknown property "${L}"`)];
          let oe;
          if (r.H(v) === "string" && r.M(ae) && !ae.tokens && (oe = /^{([^}]+)}$/.exec(v))) {
            const Be = `\`{ "type": "identity", "property": ${oe ? JSON.stringify(oe[1]) : '"_"'} }\``;
            return [new r.V(n, v, `"${L}" does not support interpolation syntax
Use an identity property function instead: ${Be}.`)];
          }
          const pe = [];
          if (l.layerType === "symbol") L !== "text-field" || !u || u.glyphs || u.imports || pe.push(new r.V(n, v, 'use of "text-field" requires a style "glyphs" property')), L === "text-font" && r.a0(r.Q(v)) && r.K(v.type) === "identity" && pe.push(new r.V(n, v, '"text-font" does not support identity functions'));
          else if (l.layerType === "model" && t === "paint" && d && d.layout && d.layout.hasOwnProperty("model-id") && r.M(ae) && (r.a1(ae) || r.N(ae))) {
            const Be = r.S(r.Q(v), ae), Re = Be.value.expression || Be.value._styleExpression.expression;
            Re && !r.X(Re, ["measure-light"]) && (L === "model-emissive-strength" && r.Y(Re) && r.W(Re) || pe.push(new r.V(n, v, `${L} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
          }
          return pe.concat(Tt({ key: l.key, value: v, valueSpec: ae, style: u, styleSpec: _, expressionContext: "property", propertyType: t, propertyKey: L }));
        }
        function bt(l) {
          return Xe(l, "paint");
        }
        function Wt(l) {
          return Xe(l, "layout");
        }
        function Qt(l) {
          let t = [];
          const n = l.value, u = l.key, d = l.style, _ = l.styleSpec;
          n.type || n.ref || t.push(new r.V(u, n, 'either "type" or "ref" is required'));
          let v = r.K(n.type);
          const L = r.K(n.ref);
          if (n.id) {
            const G = r.K(n.id);
            for (let X = 0; X < l.arrayIndex; X++) {
              const K = d.layers[X];
              r.K(K.id) === G && t.push(new r.V(u, n.id, `duplicate layer id "${n.id}", previously used at line ${K.id.__line__}`));
            }
          }
          if ("ref" in n) {
            let G;
            ["type", "source", "source-layer", "filter", "layout"].forEach((X) => {
              X in n && t.push(new r.V(u, n[X], `"${X}" is prohibited for ref layers`));
            }), d.layers.forEach((X) => {
              r.K(X.id) === L && (G = X);
            }), G ? G.ref ? t.push(new r.V(u, n.ref, "ref cannot reference another ref layer")) : v = r.K(G.type) : typeof L == "string" && t.push(new r.V(u, n.ref, `ref layer "${L}" not found`));
          } else if (v !== "background" && v !== "sky" && v !== "slot") if (n.source) {
            const G = d.sources && d.sources[n.source], X = G && r.K(G.type);
            G ? X === "vector" && v === "raster" ? t.push(new r.V(u, n.source, `layer "${n.id}" requires a raster source`)) : X === "raster" && v !== "raster" ? t.push(new r.V(u, n.source, `layer "${n.id}" requires a vector source`)) : X !== "vector" || n["source-layer"] ? X === "raster-dem" && v !== "hillshade" ? t.push(new r.V(u, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : X !== "raster-array" || ["raster", "raster-particle"].includes(v) ? v !== "line" || !n.paint || !n.paint["line-gradient"] && !n.paint["line-trim-offset"] || X === "geojson" && G.lineMetrics ? v === "raster-particle" && X !== "raster-array" && t.push(new r.V(u, n.source, `layer "${n.id}" requires a 'raster-array' source.`)) : t.push(new r.V(u, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new r.V(u, n.source, "raster-array source can only be used with layer type 'raster'.")) : t.push(new r.V(u, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new r.V(u, n.source, `source "${n.source}" not found`));
          } else t.push(new r.V(u, n, 'missing required property "source"'));
          return t = t.concat(rt({ key: u, value: n, valueSpec: _.layer, style: l.style, styleSpec: l.styleSpec, objectElementValidators: { "*": () => [], type: () => Tt({ key: `${u}.type`, value: n.type, valueSpec: _.layer.type, style: l.style, styleSpec: l.styleSpec, object: n, objectKey: "type" }), filter: (G) => he(r.J({ layerType: v }, G)), layout: (G) => rt({ layer: n, key: G.key, value: G.value, valueSpec: {}, style: G.style, styleSpec: G.styleSpec, objectElementValidators: { "*": (X) => Wt(r.J({ layerType: v }, X)) } }), paint: (G) => rt({ layer: n, key: G.key, value: G.value, valueSpec: {}, style: G.style, styleSpec: G.styleSpec, objectElementValidators: { "*": (X) => bt(r.J({ layerType: v, layer: n }, X)) } }) } })), t;
        }
        function Sr(l) {
          const t = l.value, n = l.key, u = r.H(t);
          return u !== "string" ? [new r.V(n, t, `string expected, ${u} found`)] : [];
        }
        const Fr = { promoteId: function l({ key: t, value: n }) {
          if (r.H(n) === "string") return Sr({ key: t, value: n });
          if (Array.isArray(n)) {
            const u = [], d = r.Q(n), _ = r.U(d);
            return _.result === "error" && _.value.forEach((v) => {
              u.push(new r.V(`${t}${v.key}`, null, `${v.message}`));
            }), r.X(_.value.expression, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]) || u.push(new r.V(`${t}`, null, "promoteId expression should be only feature dependent")), u;
          }
          {
            const u = [];
            for (const d in n) u.push(...l({ key: `${t}.${d}`, value: n[d] }));
            return u;
          }
        } };
        function kr(l) {
          const t = l.value, n = l.key, u = l.styleSpec, d = l.style;
          if (!t.type) return [new r.V(n, t, '"type" is required')];
          const _ = r.K(t.type);
          let v = [];
          switch (["vector", "raster", "raster-dem", "raster-array"].includes(_) && (t.url || t.tiles || v.push(new r.G(n, t, 'Either "url" or "tiles" is required.'))), _) {
            case "vector":
            case "raster":
            case "raster-dem":
            case "raster-array":
              return v = v.concat(rt({ key: n, value: t, valueSpec: u[`source_${_.replace("-", "_")}`], style: l.style, styleSpec: u, objectElementValidators: Fr })), v;
            case "geojson":
              if (v = rt({ key: n, value: t, valueSpec: u.source_geojson, style: d, styleSpec: u, objectElementValidators: Fr }), t.cluster) for (const L in t.clusterProperties) {
                const [G, X] = t.clusterProperties[L], K = typeof G == "string" ? [G, ["accumulated"], ["get", L]] : G;
                v.push(...fe({ key: `${n}.${L}.map`, value: X, expressionContext: "cluster-map" })), v.push(...fe({ key: `${n}.${L}.reduce`, value: K, expressionContext: "cluster-reduce" }));
              }
              return v;
            case "video":
              return rt({ key: n, value: t, valueSpec: u.source_video, style: d, styleSpec: u });
            case "image":
              return rt({ key: n, value: t, valueSpec: u.source_image, style: d, styleSpec: u });
            case "canvas":
              return [new r.V(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return Pe({ key: `${n}.type`, value: t.type, valueSpec: { values: Ur(u) }, style: d, styleSpec: u });
          }
        }
        function Ur(l) {
          return l.source.reduce((t, n) => {
            const u = l[n];
            return u.type.type === "enum" && (t = t.concat(Object.keys(u.type.values))), t;
          }, []);
        }
        function Rr(l) {
          const t = l.value, n = l.styleSpec, u = n.light, d = l.style;
          let _ = [];
          const v = r.H(t);
          if (t === void 0) return _;
          if (v !== "object") return _ = _.concat([new r.V("light", t, `object expected, ${v} found`)]), _;
          for (const L in t) {
            const G = L.match(/^(.*)-transition$/), X = L.match(/^(.*)-use-theme$/);
            _ = _.concat(X && u[X[1]] ? Tt({ key: L, value: t[L], valueSpec: { type: "string" }, style: d, styleSpec: n }) : G && u[G[1]] && u[G[1]].transition ? Tt({ key: L, value: t[L], valueSpec: n.transition, style: d, styleSpec: n }) : u[L] ? Tt({ key: L, value: t[L], valueSpec: u[L], style: d, styleSpec: n }) : [new r.V(L, t[L], `unknown property "${L}"`)]);
          }
          return _;
        }
        function Pr(l) {
          const t = l.value;
          let n = [];
          if (!t) return n;
          const u = r.H(t);
          if (u !== "object") return n = n.concat([new r.V("light-3d", t, `object expected, ${u} found`)]), n;
          const d = l.styleSpec, _ = d["light-3d"], v = l.key, L = l.style, G = l.style.lights;
          for (const ae of ["type", "id"]) if (!(ae in t)) return n = n.concat([new r.V("light-3d", t, `missing property ${ae} on light`)]), n;
          if (t.type && G) for (let ae = 0; ae < l.arrayIndex; ae++) {
            const oe = r.K(t.type), pe = G[ae];
            r.K(pe.type) === oe && n.push(new r.V(v, t.id, `duplicate light type "${t.type}", previously defined at line ${pe.id.__line__}`));
          }
          const X = `properties_light_${t.type}`;
          if (!(X in d)) return n = n.concat([new r.V("light-3d", t, `Invalid light type ${t.type}`)]), n;
          const K = d[X];
          for (const ae in t) if (ae === "properties") {
            const oe = t[ae], pe = r.H(oe);
            if (pe !== "object") return n = n.concat([new r.V("properties", oe, `object expected, ${pe} found`)]), n;
            for (const Be in oe) n = n.concat(K[Be] ? Tt({ key: Be, value: oe[Be], valueSpec: K[Be], style: L, styleSpec: d }) : [new r.G(l.key, oe[Be], `unknown property "${Be}"`)]);
          } else {
            const oe = ae.match(/^(.*)-transition$/), pe = ae.match(/^(.*)-use-theme$/);
            n = n.concat(pe && _[pe[1]] ? Tt({ key: ae, value: t[ae], valueSpec: { type: "string" }, style: L, styleSpec: d }) : oe && _[oe[1]] && _[oe[1]].transition ? Tt({ key: ae, value: t[ae], valueSpec: d.transition, style: L, styleSpec: d }) : _[ae] ? Tt({ key: ae, value: t[ae], valueSpec: _[ae], style: L, styleSpec: d }) : [new r.G(ae, t[ae], `unknown property "${ae}"`)]);
          }
          return n;
        }
        function hi(l) {
          const t = l.value, n = l.key, u = l.style, d = l.styleSpec, _ = d.terrain;
          let v = [];
          const L = r.H(t);
          if (t === void 0 || L === "null") return v;
          if (L !== "object") return v = v.concat([new r.V("terrain", t, `object expected, ${L} found`)]), v;
          for (const G in t) {
            const X = G.match(/^(.*)-transition$/), K = G.match(/^(.*)-use-theme$/);
            v = v.concat(K && _[K[1]] ? Tt({ key: G, value: t[G], valueSpec: { type: "string" }, style: u, styleSpec: d }) : X && _[X[1]] && _[X[1]].transition ? Tt({ key: G, value: t[G], valueSpec: d.transition, style: u, styleSpec: d }) : _[G] ? Tt({ key: G, value: t[G], valueSpec: _[G], style: u, styleSpec: d }) : [new r.G(G, t[G], `unknown property "${G}"`)]);
          }
          if (t.source) {
            const G = u.sources && u.sources[t.source], X = G && r.K(G.type);
            G ? X !== "raster-dem" && v.push(new r.V(n, t.source, `terrain cannot be used with a source of type ${String(X)}, it only be used with a "raster-dem" source type`)) : v.push(new r.V(n, t.source, `source "${t.source}" not found`));
          } else v.push(new r.V(n, t, 'terrain is missing required property "source"'));
          return v;
        }
        function Vr(l) {
          const t = l.value, n = l.style, u = l.styleSpec, d = u.fog;
          let _ = [];
          const v = r.H(t);
          if (t === void 0) return _;
          if (v !== "object") return _ = _.concat([new r.V("fog", t, `object expected, ${v} found`)]), _;
          for (const L in t) {
            const G = L.match(/^(.*)-transition$/), X = L.match(/^(.*)-use-theme$/);
            _ = _.concat(X && d[X[1]] ? Tt({ key: L, value: t[L], valueSpec: { type: "string" }, style: n, styleSpec: u }) : G && d[G[1]] && d[G[1]].transition ? Tt({ key: L, value: t[L], valueSpec: u.transition, style: n, styleSpec: u }) : d[L] ? Tt({ key: L, value: t[L], valueSpec: d[L], style: n, styleSpec: u }) : [new r.G(L, t[L], `unknown property "${L}"`)]);
          }
          return _;
        }
        const Te = { "*": () => [], array: it, boolean: function(l) {
          const t = l.value, n = l.key, u = r.H(t);
          return u !== "boolean" ? [new r.V(n, t, `boolean expected, ${u} found`)] : [];
        }, number: Ae, color: function(l) {
          const t = l.key, n = l.value, u = r.H(n);
          return u !== "string" ? [new r.V(t, n, `color expected, ${u} found`)] : r._.parseCSSColor(n) === null ? [new r.V(t, n, `color expected, "${n}" found`)] : [];
        }, enum: Pe, filter: he, function: _e, layer: Qt, object: rt, source: kr, model: r.a2, light: Rr, "light-3d": Pr, terrain: hi, fog: Vr, string: Sr, formatted: function(l) {
          return Sr(l).length === 0 ? [] : fe(l);
        }, resolvedImage: function(l) {
          return Sr(l).length === 0 ? [] : fe(l);
        }, projection: function(l) {
          const t = l.value, n = l.styleSpec, u = n.projection, d = l.style;
          let _ = [];
          const v = r.H(t);
          if (v === "object") for (const L in t) _ = _.concat(Tt({ key: L, value: t[L], valueSpec: u[L], style: d, styleSpec: n }));
          else v !== "string" && (_ = _.concat([new r.V("projection", t, `object or string expected, ${v} found`)]));
          return _;
        }, import: function(l) {
          const { value: t, styleSpec: n } = l, { data: u, ...d } = t;
          Object.defineProperty(d, "__line__", { value: t.__line__, enumerable: !1 });
          let _ = rt(r.J({}, l, { value: d, valueSpec: n.import }));
          return r.K(d.id) === "" && _.push(new r.V(`${l.key}.id`, d, "import id can't be an empty string")), u && (_ = _.concat(pr(u, n, { key: `${l.key}.data` }))), _;
        } };
        function Tt(l, t = !1) {
          const n = l.value, u = l.valueSpec, d = l.styleSpec;
          if (u.expression && r.a0(r.K(n))) return _e(l);
          if (u.expression && r.O(r.Q(n))) return fe(l);
          if (u.type && Te[u.type]) {
            const _ = Te[u.type](l);
            return t === !0 && _.length > 0 && r.H(l.value) === "array" ? fe(l) : _;
          }
          return rt(r.J({}, l, { valueSpec: u.type ? d[u.type] : u }));
        }
        function Gt(l) {
          const t = l.value, n = l.key, u = Sr(l);
          return u.length || (t.indexOf("{fontstack}") === -1 && u.push(new r.V(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && u.push(new r.V(n, t, '"glyphs" url must include a "{range}" token'))), u;
        }
        function pr(l, t = r.a3, n = {}) {
          return Tt({ key: n.key || "", value: l, valueSpec: t.$root, styleSpec: t, style: l, objectElementValidators: { glyphs: Gt, "*": () => [] } });
        }
        function kt(l, t = r.a3) {
          return Kr(pr(l, t));
        }
        const tr = (l) => Kr(kr(l)), Je = (l) => Kr(Rr(l)), wr = (l) => Kr(Pr(l)), ni = (l) => Kr(hi(l)), Z = (l) => Kr(Vr(l)), Dt = (l) => Kr(function(t) {
          const n = t.value, u = t.style, d = t.styleSpec, _ = d.snow;
          let v = [];
          const L = r.H(n);
          if (n === void 0) return v;
          if (L !== "object") return v = v.concat([new r.V("snow", n, `object expected, ${L} found`)]), v;
          for (const G in n) {
            const X = G.match(/^(.*)-transition$/);
            v = v.concat(X && _[X[1]] && _[X[1]].transition ? Tt({ key: G, value: n[G], valueSpec: d.transition, style: u, styleSpec: d }) : _[G] ? Tt({ key: G, value: n[G], valueSpec: _[G], style: u, styleSpec: d }) : [new r.G(G, n[G], `unknown property "${G}"`)]);
          }
          return v;
        }(l)), er = (l) => Kr(function(t) {
          const n = t.value, u = t.style, d = t.styleSpec, _ = d.rain;
          let v = [];
          const L = r.H(n);
          if (n === void 0) return v;
          if (L !== "object") return v = v.concat([new r.V("rain", n, `object expected, ${L} found`)]), v;
          for (const G in n) {
            const X = G.match(/^(.*)-transition$/);
            v = v.concat(X && _[X[1]] && _[X[1]].transition ? Tt({ key: G, value: n[G], valueSpec: d.transition, style: u, styleSpec: d }) : _[G] ? Tt({ key: G, value: n[G], valueSpec: _[G], style: u, styleSpec: d }) : [new r.G(G, n[G], `unknown property "${G}"`)]);
          }
          return v;
        }(l)), we = (l) => Kr(Qt(l)), yt = (l) => Kr(he(l)), ar = (l) => Kr(bt(l)), Or = (l) => Kr(Wt(l)), Dr = (l) => Kr(r.a2(l));
        function Kr(l) {
          return l.slice().sort((t, n) => t.line && n.line ? t.line - n.line : 0);
        }
        function di(l, t) {
          let n = !1;
          if (t && t.length) for (const u of t) u instanceof r.G ? r.w(u.message) : (l.fire(new r.y(new Error(u.message))), n = !0);
          return n;
        }
        let $t;
        class Ce extends r.E {
          constructor(t, n = "flat") {
            super(), this._transitionable = new r.a4($t || ($t = new r.a5({ anchor: new r.a6(r.a3.light.anchor), position: new r.a7(r.a3.light.position), color: new r.a6(r.a3.light.color), intensity: new r.a6(r.a3.light.intensity) }))), this.setLight(t, n), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t, n, u = {}) {
            this._validate(Je, t, u) || (this._transitionable.setTransitionOrValue(t), this.id = n);
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, n, u) {
            return (!u || u.validate !== !1) && di(this, t.call(kt, r.l({ value: n, style: { glyphs: !0, sprite: !0 }, styleSpec: r.a3 })));
          }
        }
        let Ne = class extends r.E {
          constructor(l, t, n, u) {
            super(), this.scope = n, this._transitionable = new r.a4(new r.a5({ source: new r.a6(r.a3.terrain.source), exaggeration: new r.a6(r.a3.terrain.exaggeration) }), n, u), this._transitionable.setTransitionOrValue(l, u), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = t;
          }
          get() {
            return this._transitionable.serialize();
          }
          set(l, t) {
            this._transitionable.setTransitionOrValue(l, t);
          }
          updateTransitions(l) {
            this._transitioning = this._transitionable.transitioned(l, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(l) {
            this.properties = this._transitioning.possiblyEvaluate(l);
          }
          getExaggeration(l) {
            return this._transitioning.possiblyEvaluate(new r.a8(l)).get("exaggeration");
          }
          getAttenuationRange() {
            if (!this.isZoomDependent()) return null;
            const l = this._transitionable._values.exaggeration;
            if (!l) return null;
            const t = l.value.expression;
            if (!t) return null;
            let n = -1, u = -1, d = 1;
            for (const _ of t.zoomStops) d = t.evaluate(new r.a8(_)), d > 0.01 ? (n = _, u = -1) : u = _;
            return d < 0.01 && n > 0 && u > n ? [n, u] : null;
          }
          isZoomDependent() {
            const l = this._transitionable._values.exaggeration;
            return l != null && l.value != null && l.value.expression != null && l.value.expression instanceof r.a9;
          }
        };
        const Ke = 45, ht = 65, ft = 0.05;
        function Pt(l, t, n, u) {
          const d = r.ac(Ke, ht, n), [_, v] = Nt(l, u);
          let L = 1 - Math.min(1, Math.exp((t - _) / (v - _) * -6));
          return L *= L * L, L = Math.min(1, 1.00747 * L), L * d * l.alpha;
        }
        function Nt(l, t) {
          const n = 0.5 / Math.tan(0.5 * t);
          return [l.range[0] + n, l.range[1] + n];
        }
        function At(l, t, n, u, d) {
          const _ = r.ab.vec3.transformMat4([], [t, n, u], d.mercatorFogMatrix);
          return Pt(l, r.ab.vec3.length(_), d.pitch, d._fov);
        }
        function Zt(l, t, n, u, d, _, v) {
          const L = [[n, u, 0], [d, u, 0], [d, _, 0], [n, _, 0]];
          let G = Number.MAX_VALUE, X = -Number.MAX_VALUE;
          for (const K of L) {
            const ae = r.ab.vec3.transformMat4([], K, t), oe = r.ab.vec3.length(ae);
            G = Math.min(G, oe), X = Math.max(X, oe);
          }
          return [Pt(l, G, v.pitch, v._fov), Pt(l, X, v.pitch, v._fov)];
        }
        class jt extends r.E {
          constructor(t, n, u, d) {
            super();
            const _ = new r.a5({ range: new r.a6(r.a3.fog.range), color: new r.a6(r.a3.fog.color), "color-use-theme": new r.a6({ type: "string", "property-type": "data-constant", default: "default" }), "high-color": new r.a6(r.a3.fog["high-color"]), "high-color-use-theme": new r.a6({ type: "string", "property-type": "data-constant", default: "default" }), "space-color": new r.a6(r.a3.fog["space-color"]), "space-color-use-theme": new r.a6({ type: "string", "property-type": "data-constant", default: "default" }), "horizon-blend": new r.a6(r.a3.fog["horizon-blend"]), "star-intensity": new r.a6(r.a3.fog["star-intensity"]), "vertical-range": new r.a6(r.a3.fog["vertical-range"]) });
            this._transitionable = new r.a4(_, u, new Map(d)), this.set(t, d), this._transitioning = this._transitionable.untransitioned(), this._transform = n, this.properties = new r.ad(_), this.scope = u;
          }
          get state() {
            const t = this._transform, n = t.projection.name === "globe", u = r.ae(t.zoom), d = this.properties.get("range"), _ = [0.5, 3];
            return { range: n ? [r.af(_[0], d[0], u), r.af(_[1], d[1], u)] : d, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t, n, u = {}) {
            if (this._validate(Z, t, u)) return;
            const d = r.l({}, t);
            for (const _ of Object.keys(r.a3.fog)) d[_] === void 0 && (d[_] = r.a3.fog[_].default);
            this._options = d, this._transitionable.setTransitionOrValue(this._options, n);
          }
          getOpacity(t) {
            if (!this._transform.projection.supportsFog) return 0;
            const n = this.properties && this.properties.get("color") || 1;
            return (this._transform.projection.name === "globe" ? 1 : r.ac(Ke, ht, t)) * n.a;
          }
          getOpacityAtLatLng(t, n) {
            return this._transform.projection.supportsFog ? function(u, d, _) {
              const v = r.aa.fromLngLat(d), L = _.elevation ? _.elevation.getAtPointOrZero(v) : 0;
              return At(u, v.x, v.y, L, _);
            }(this.state, t, n) : 0;
          }
          getOpacityForTile(t) {
            if (!this._transform.projection.supportsFog) return [1, 1];
            const n = this._transform.calculateFogTileMatrix(t.toUnwrapped());
            return Zt(this.state, n, 0, 0, r.ag, r.ag, this._transform);
          }
          getOpacityForBounds(t, n, u, d, _) {
            return this._transform.projection.supportsFog ? Zt(this.state, t, n, u, d, _, this._transform) : [1, 1];
          }
          getFovAdjustedRange(t) {
            return this._transform.projection.supportsFog ? Nt(this.state, t) : [0, 1];
          }
          isVisibleOnFrustum(t) {
            if (!this._transform.projection.supportsFog) return !1;
            const n = [4, 5, 6, 7];
            for (const u of n) {
              const d = t.points[u];
              let _;
              if (d[2] >= 0) _ = d;
              else {
                const v = t.points[u - 4];
                _ = r.ah(v, d, v[2] / (v[2] - d[2]));
              }
              if (At(this.state, _[0], _[1], 0, this._transform) >= ft) return !0;
            }
            return !1;
          }
          updateConfig(t) {
            this._transitionable.setTransitionOrValue(this._options, new Map(t));
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, n, u) {
            return (!u || u.validate !== !1) && di(this, t.call(kt, r.l({ value: n, style: { glyphs: !0, sprite: !0 }, styleSpec: r.a3 })));
          }
        }
        let Yt, fr, Ir, Lr, qr = class extends r.E {
          constructor(l, t, n, u) {
            super();
            const d = Yt || (Yt = new r.a5({ density: new r.a6(r.a3.snow.density), intensity: new r.a6(r.a3.snow.intensity), color: new r.a6(r.a3.snow.color), opacity: new r.a6(r.a3.snow.opacity), vignette: new r.a6(r.a3.snow.vignette), "vignette-color": new r.a6(r.a3.snow["vignette-color"]), "center-thinning": new r.a6(r.a3.snow["center-thinning"]), direction: new r.a6(r.a3.snow.direction), "flake-size": new r.a6(r.a3.snow["flake-size"]) }));
            this._transitionable = new r.a4(d, n, new Map(u)), this.set(l, u), this._transitioning = this._transitionable.untransitioned(), this.properties = new r.ad(d), this.scope = n;
          }
          get state() {
            const l = this.properties.get("opacity"), t = this.properties.get("color"), n = this.properties.get("direction"), u = r.ai(n[0]), d = -Math.max(r.ai(n[1]), 0.01), _ = [Math.cos(u) * Math.cos(d), Math.sin(u) * Math.cos(d), Math.sin(d)], v = this.properties.get("vignette"), L = this.properties.get("vignette-color");
            return L.a = v, { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new r.aj(t.r, t.g, t.b, t.a * l), direction: _, centerThinning: this.properties.get("center-thinning"), flakeSize: this.properties.get("flake-size"), vignetteColor: L };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(l, t, n = {}) {
            if (this._validate(Dt, l, n)) return;
            const u = r.l({}, l);
            for (const d of Object.keys(r.a3.snow)) u[d] === void 0 && (u[d] = r.a3.snow[d].default);
            this._options = u, this._transitionable.setTransitionOrValue(this._options, t);
          }
          updateConfig(l) {
            this._transitionable.setTransitionOrValue(this._options, new Map(l));
          }
          updateTransitions(l) {
            this._transitioning = this._transitionable.transitioned(l, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(l) {
            this.properties = this._transitioning.possiblyEvaluate(l);
          }
          _validate(l, t, n) {
            return (!n || n.validate !== !1) && di(this, l.call(kt, r.l({ value: t, style: { glyphs: !0, sprite: !0 }, styleSpec: r.a3 })));
          }
        }, pi = class extends r.E {
          constructor(l, t, n, u) {
            super();
            const d = fr || (fr = new r.a5({ density: new r.a6(r.a3.rain.density), intensity: new r.a6(r.a3.rain.intensity), color: new r.a6(r.a3.rain.color), opacity: new r.a6(r.a3.rain.opacity), vignette: new r.a6(r.a3.rain.vignette), "vignette-color": new r.a6(r.a3.rain["vignette-color"]), "center-thinning": new r.a6(r.a3.rain["center-thinning"]), direction: new r.a6(r.a3.rain.direction), "droplet-size": new r.a6(r.a3.rain["droplet-size"]), "distortion-strength": new r.a6(r.a3.rain["distortion-strength"]) }));
            this._transitionable = new r.a4(d, n, new Map(u)), this.set(l, u), this._transitioning = this._transitionable.untransitioned(), this.properties = new r.ad(d), this.scope = n;
          }
          get state() {
            const l = this.properties.get("opacity"), t = this.properties.get("color"), n = this.properties.get("direction"), u = r.ai(n[0]), d = -Math.max(r.ai(n[1]), 0.01), _ = [Math.cos(u) * Math.cos(d), Math.sin(u) * Math.cos(d), Math.sin(d)], v = this.properties.get("vignette-color");
            return v.a = this.properties.get("vignette"), { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new r.aj(t.r, t.g, t.b, t.a * l), direction: _, centerThinning: this.properties.get("center-thinning"), dropletSize: this.properties.get("droplet-size"), distortionStrength: this.properties.get("distortion-strength"), vignetteColor: v };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(l, t, n = {}) {
            if (this._validate(er, l, n)) return;
            const u = r.l({}, l);
            for (const d of Object.keys(r.a3.rain)) u[d] === void 0 && (u[d] = r.a3.rain[d].default);
            this._options = u, this._transitionable.setTransitionOrValue(this._options, t);
          }
          updateConfig(l) {
            this._transitionable.setTransitionOrValue(this._options, new Map(l));
          }
          updateTransitions(l) {
            this._transitioning = this._transitionable.transitioned(l, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(l) {
            this.properties = this._transitioning.possiblyEvaluate(l);
          }
          _validate(l, t, n) {
            return (!n || n.validate !== !1) && di(this, l.call(kt, r.l({ value: t, style: { glyphs: !0, sprite: !0 }, styleSpec: r.a3 })));
          }
        };
        class fi extends r.E {
          constructor(t, n, u, d) {
            super(), this.scope = u, this._options = t, this.properties = new r.ad(n), this._transitionable = new r.a4(n, u, new Map(d)), this._transitionable.setTransitionOrValue(t.properties), this._transitioning = this._transitionable.untransitioned();
          }
          updateConfig(t) {
            this._transitionable.setTransitionOrValue(this._options.properties, new Map(t));
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          get() {
            return this._options.properties = this._transitionable.serialize(), this._options;
          }
          set(t, n) {
            this._options = t, this._transitionable.setTransitionOrValue(t.properties, n);
          }
          shadowsEnabled() {
            return !!this.properties && this.properties.get("cast-shadows") === !0;
          }
        }
        class si {
          constructor(t, n, u, d) {
            this.screenBounds = t, this.cameraPoint = n, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = u, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, d);
          }
          static createFromScreenPoints(t, n) {
            let u, d;
            if (t instanceof r.P || typeof t[0] == "number") {
              const _ = r.P.convert(t);
              u = [_], d = n.isPointAboveHorizon(_);
            } else {
              const _ = r.P.convert(t[0]), v = r.P.convert(t[1]);
              u = [_, v], d = r.al(_, v).every((L) => n.isPointAboveHorizon(L));
            }
            return new si(u, n.getCameraPoint(), d, n);
          }
          isPointQuery() {
            return this.screenBounds.length === 1;
          }
          bufferedScreenGeometry(t) {
            return r.al(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], t);
          }
          bufferedCameraGeometry(t) {
            const n = this.screenBounds[0], u = this.screenBounds.length === 1 ? this.screenBounds[0].add(new r.P(1, 1)) : this.screenBounds[1], d = r.al(n, u, 0, !1);
            return this.cameraPoint.y > u.y && (this.cameraPoint.x > n.x && this.cameraPoint.x < u.x ? d.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= u.x ? d[2] = this.cameraPoint : this.cameraPoint.x <= n.x && (d[3] = this.cameraPoint)), r.am(d, t);
          }
          bufferedCameraGeometryGlobe(t) {
            const n = this.screenBounds[0], u = this.screenBounds.length === 1 ? this.screenBounds[0].add(new r.P(1, 1)) : this.screenBounds[1], d = r.al(n, u, t), _ = this.cameraPoint.clone();
            switch (3 * ((_.y > n.y) + (_.y > u.y)) + ((_.x > n.x) + (_.x > u.x))) {
              case 0:
                d[0] = _, d[4] = _.clone();
                break;
              case 1:
                d.splice(1, 0, _);
                break;
              case 2:
                d[1] = _;
                break;
              case 3:
                d.splice(4, 0, _);
                break;
              case 5:
                d.splice(2, 0, _);
                break;
              case 6:
                d[3] = _;
                break;
              case 7:
                d.splice(3, 0, _);
                break;
              case 8:
                d[2] = _;
            }
            return d;
          }
          containsTile(t, n, u, d = 0) {
            const _ = t.queryPadding / n._pixelsPerMercatorPixel + 1, v = u ? this._bufferedCameraMercator(_, n) : this._bufferedScreenMercator(_, n);
            let L = t.tileID.wrap + (v.unwrapped ? d : 0);
            const G = v.polygon.map((Ge) => r.an(t.tileTransform, Ge, L));
            if (!r.ao(G, 0, 0, r.ag, r.ag)) return;
            L = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? d : 0);
            const X = this.screenGeometryMercator.polygon.map((Ge) => r.ap(t.tileTransform, Ge, L)), K = X.map((Ge) => new r.P(Ge[0], Ge[1])), ae = n.getFreeCameraOptions().position || new r.aa(0, 0, 0), oe = r.ap(t.tileTransform, ae, L), pe = X.map((Ge) => {
              const Ve = r.ab.vec3.sub(Ge, Ge, oe);
              return r.ab.vec3.normalize(Ve, Ve), new r.aq(oe, Ve);
            }), Be = r.ar(t, 1, n.zoom) * n._pixelsPerMercatorPixel;
            return { queryGeometry: this, tilespaceGeometry: K, tilespaceRays: pe, bufferedTilespaceGeometry: G, bufferedTilespaceBounds: (Re = r.as(G), Re.min.x = r.aw(Re.min.x, 0, r.ag), Re.min.y = r.aw(Re.min.y, 0, r.ag), Re.max.x = r.aw(Re.max.x, 0, r.ag), Re.max.y = r.aw(Re.max.y, 0, r.ag), Re), tile: t, tileID: t.tileID, pixelToTileUnitsFactor: Be };
            var Re;
          }
          _bufferedScreenMercator(t, n) {
            const u = Li(t);
            if (this._screenRaycastCache[u]) return this._screenRaycastCache[u];
            {
              let d;
              return d = n.projection.name === "globe" ? this._projectAndResample(this.bufferedScreenGeometry(t), n) : { polygon: this.bufferedScreenGeometry(t).map((_) => n.pointCoordinate3D(_)), unwrapped: !0 }, this._screenRaycastCache[u] = d, d;
            }
          }
          _bufferedCameraMercator(t, n) {
            const u = Li(t);
            if (this._cameraRaycastCache[u]) return this._cameraRaycastCache[u];
            {
              let d;
              return d = n.projection.name === "globe" ? this._projectAndResample(this.bufferedCameraGeometryGlobe(t), n) : { polygon: this.bufferedCameraGeometry(t).map((_) => n.pointCoordinate3D(_)), unwrapped: !0 }, this._cameraRaycastCache[u] = d, d;
            }
          }
          _projectAndResample(t, n) {
            const u = function(_, v) {
              const L = r.ab.mat4.multiply([], v.pixelMatrix, v.globeMatrix), G = [0, -r.ax, 0, 1], X = [0, r.ax, 0, 1], K = [0, 0, 0, 1];
              r.ab.vec4.transformMat4(G, G, L), r.ab.vec4.transformMat4(X, X, L), r.ab.vec4.transformMat4(K, K, L);
              const ae = new r.P(G[0] / G[3], G[1] / G[3]), oe = new r.P(X[0] / X[3], X[1] / X[3]), pe = r.au(_, ae) && G[3] < K[3], Be = r.au(_, oe) && X[3] < K[3];
              if (!pe && !Be) return null;
              const Re = function(_t, dt, gt) {
                for (let Rt = 1; Rt < _t.length; Rt++) {
                  const Jt = Ni(dt.pointCoordinate3D(_t[Rt - 1]).x), Vt = Ni(dt.pointCoordinate3D(_t[Rt]).x);
                  if (gt < 0) {
                    if (Jt < Vt) return { idx: Rt, t: -Jt / (Vt - 1 - Jt) };
                  } else if (Vt < Jt) return { idx: Rt, t: (1 - Jt) / (Vt + 1 - Jt) };
                }
                return null;
              }(_, v, pe ? -1 : 1);
              if (!Re) return null;
              const { idx: Ge, t: Ve } = Re;
              let et = Ge > 1 ? ki(_.slice(0, Ge), v) : [], ut = Ge < _.length ? ki(_.slice(Ge), v) : [];
              et = et.map((_t) => new r.P(Ni(_t.x), _t.y)), ut = ut.map((_t) => new r.P(Ni(_t.x), _t.y));
              const st = [...et];
              st.length === 0 && st.push(ut[ut.length - 1]);
              const xt = r.af(st[st.length - 1].y, (ut.length === 0 ? et[0] : ut[0]).y, Ve);
              let mt;
              return mt = pe ? [new r.P(0, xt), new r.P(0, 0), new r.P(1, 0), new r.P(1, xt)] : [new r.P(1, xt), new r.P(1, 1), new r.P(0, 1), new r.P(0, xt)], st.push(...mt), ut.length === 0 ? st.push(et[0]) : st.push(...ut), { polygon: st.map((_t) => new r.aa(_t.x, _t.y)), unwrapped: !1 };
            }(t, n);
            if (u) return u;
            const d = function(_, v) {
              let L = !1, G = -1 / 0, X = 0;
              for (let ae = 0; ae < _.length - 1; ae++) _[ae].x > G && (G = _[ae].x, X = ae);
              for (let ae = 0; ae < _.length - 1; ae++) {
                const oe = (X + ae) % (_.length - 1), pe = _[oe], Be = _[oe + 1];
                Math.abs(pe.x - Be.x) > 0.5 && (pe.x < Be.x ? (pe.x += 1, oe === 0 && (_[_.length - 1].x += 1)) : (Be.x += 1, oe + 1 === _.length - 1 && (_[0].x += 1)), L = !0);
              }
              const K = r.at(v.center.lng);
              return L && K < Math.abs(K - 1) && _.forEach((ae) => {
                ae.x -= 1;
              }), { polygon: _, unwrapped: L };
            }(ki(t, n).map((_) => new r.P(Ni(_.x), _.y)), n);
            return { polygon: d.polygon.map((_) => new r.aa(_.x, _.y)), unwrapped: d.unwrapped };
          }
        }
        function ki(l, t) {
          return r.av(l, (n) => {
            const u = t.pointCoordinate3D(n);
            n.x = u.x, n.y = u.y;
          }, 1 / 256);
        }
        function Ni(l) {
          return l < 0 ? 1 + l % 1 : l % 1;
        }
        function Li(l) {
          return 100 * l | 0;
        }
        function Wi(l, t, n, u, d) {
          const _ = function(L, G) {
            if (L) return d(L);
            if (G) {
              if (l.url && G.tiles && l.tiles && delete l.tiles, G.variants) {
                if (!Array.isArray(G.variants)) return d(new Error("variants must be an array"));
                for (const K of G.variants) {
                  if (K == null || typeof K != "object" || K.constructor !== Object) return d(new Error("variant must be an object"));
                  if (!Array.isArray(K.capabilities)) return d(new Error("capabilities must be an array"));
                  if (K.capabilities.length === 1 && K.capabilities[0] === "meshopt") {
                    G = r.l(G, K);
                    break;
                  }
                }
              }
              const X = r.ay(r.l({}, G, l), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding", "vector_layers", "raster_layers", "worldview_options", "worldview_default", "worldview"]);
              X.tiles = t.canonicalizeTileset(X, l.url), d(null, X);
            }
          }, v = function(L, G, X) {
            if (!L) return null;
            if (!G && !X) return L;
            X = X || L.worldview_default;
            const K = Object.values(L.language || {});
            if (K.length === 0) return null;
            const ae = Object.values(L.worldview || {});
            if (ae.length === 0) return null;
            const oe = K.every((Be) => Be === G), pe = ae.every((Be) => Be === X);
            return oe && pe ? L : G in (L.language_options || {}) || X in (L.worldview_options || {}) ? null : L.language_options && L.worldview_options ? L : null;
          }(l.data, n, u);
          return v ? r.q.frame(() => _(null, v)) : l.url ? r.n(t.transformRequest(t.normalizeSourceURL(l.url, null, n, u), r.R.Source), _) : r.q.frame(() => {
            const { data: L, ...G } = l;
            _(null, G);
          });
        }
        class Bi {
          constructor(t, n, u) {
            this.bounds = r.az.convert(this.validateBounds(t)), this.minzoom = n || 0, this.maxzoom = u || 24;
          }
          validateBounds(t) {
            return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];
          }
          contains(t) {
            const n = Math.pow(2, t.z), u = Math.floor(r.at(this.bounds.getWest()) * n), d = Math.floor(r.aA(this.bounds.getNorth()) * n), _ = Math.ceil(r.at(this.bounds.getEast()) * n), v = Math.ceil(r.aA(this.bounds.getSouth()) * n);
            return t.x >= u && t.x < _ && t.y >= d && t.y < v;
          }
        }
        class Gn extends r.E {
          constructor(t, n, u, d) {
            if (super(), this.id = t, this.dispatcher = u, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, r.l(this, r.ay(n, ["url", "scheme", "tileSize", "promoteId"])), this._options = r.l({ type: "vector" }, n), this._collectResourceTiming = !!n.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(d), this._tileWorkers = {}, this._deduped = new r.aB();
          }
          load(t) {
            this._loaded = !1, this.fire(new r.z("dataloading", { dataType: "source" }));
            const n = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, u = this.map.getWorldview();
            this._tileJSONRequest = Wi(this._options, this.map._requestManager, n, u, (d, _) => {
              if (this._tileJSONRequest = null, this._loaded = !0, d) n && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${n}`), u && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${u}`), this.fire(new r.y(d));
              else if (_) {
                if (r.l(this, _), this.hasWorldviews = !!_.worldview_options, _.worldview_default && (this.worldviewDefault = _.worldview_default), _.vector_layers) {
                  this.vectorLayers = _.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = /* @__PURE__ */ new Set();
                  for (const v of _.vector_layers) this.vectorLayerIds.push(v.id), _.worldview && _.worldview[v.source] && this.localizableLayerIds.add(v.id);
                }
                _.bounds && (this.tileBounds = new Bi(_.bounds, this.minzoom, this.maxzoom)), Ze(_.tiles, this.map._requestManager._customAccessToken), this.fire(new r.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new r.z("data", { dataType: "source", sourceDataType: "content" }));
              }
              t && t(d);
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const t = r.aC(this.id, this.scope);
            this.load(() => this.map.style.clearSource(t));
          }
          setTiles(t) {
            return this._options.tiles = t, this.reload(), this;
          }
          setUrl(t) {
            return this.url = t, this._options.url = t, this.reload(), this;
          }
          onRemove(t) {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return r.l({}, this._options);
          }
          loadTile(t, n) {
            const u = t.tileID.canonical.url(this.tiles, this.scheme), d = this.map._requestManager.normalizeTileURL(u), _ = this.map._requestManager.transformRequest(d, r.R.Tile), v = this.map.style ? this.map.style.getLut(this.scope) : null, L = v ? { image: v.image.clone() } : null, G = { request: _, data: void 0, uid: t.uid, tileID: t.tileID, tileZoom: t.tileZoom, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, lut: L, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: r.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t.isExtraShadowCaster, tessellationStep: this.map._tessellationStep, scaleFactor: this.map.getScaleFactor() };
            if (this.hasWorldviews && r.f(u) && (G.worldview = this.map.getWorldview() || this.worldviewDefault, G.localizableLayerIds = this.localizableLayerIds), G.request.collectResourceTiming = this._collectResourceTiming, t.actor && t.state !== "expired") t.state === "loading" ? t.reloadCallback = n : t.request = t.actor.send("reloadTile", G, X.bind(this));
            else if (t.actor = this._tileWorkers[d] = this._tileWorkers[d] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send("loadTile", G, X.bind(this), void 0, !0);
            else {
              const K = r.aD.call({ deduped: this._deduped }, G, (ae, oe) => {
                ae || !oe ? X.call(this, ae) : (G.data = { cacheControl: oe.cacheControl, expires: oe.expires, rawData: oe.rawData.slice(0) }, t.actor && t.actor.send("loadTile", G, X.bind(this), void 0, !0));
              }, !0);
              t.request = { cancel: K };
            }
            function X(K, ae) {
              return delete t.request, t.aborted ? n(null) : K && K.status !== 404 ? n(K) : (ae && ae.resourceTiming && (t.resourceTiming = ae.resourceTiming), this.map._refreshExpiredTiles && ae && t.setExpiryData(ae), t.loadVectorData(ae, this.map.painter), r.aE(this.dispatcher), n(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));
            }
          }
          abortTile(t) {
            t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send("abortTile", { uid: t.uid, type: this.type, source: this.id, scope: this.scope });
          }
          unloadTile(t, n) {
            t.actor && t.actor.send("removeTile", { uid: t.uid, type: this.type, source: this.id, scope: this.scope }), t.destroy();
          }
          hasTransition() {
            return !1;
          }
          afterUpdate() {
            this._tileWorkers = {};
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class sa extends r.E {
          constructor(t, n, u, d) {
            super(), this.id = t, this.dispatcher = u, this.setEventedParent(d), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = r.l({ type: "raster" }, n), r.l(this, r.ay(n, ["url", "scheme", "tileSize"]));
          }
          load(t) {
            this._loaded = !1, this.fire(new r.z("dataloading", { dataType: "source" })), this._tileJSONRequest = Wi(this._options, this.map._requestManager, null, null, (n, u) => {
              this._tileJSONRequest = null, this._loaded = !0, n ? this.fire(new r.y(n)) : u && (r.l(this, u), u.raster_layers && (this.rasterLayers = u.raster_layers, this.rasterLayerIds = this.rasterLayers.map((d) => d.id)), u.bounds && (this.tileBounds = new Bi(u.bounds, this.minzoom, this.maxzoom)), Ze(u.tiles), this.fire(new r.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new r.z("data", { dataType: "source", sourceDataType: "content" }))), t && t(n);
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const t = r.aC(this.id, this.scope);
            this.load(() => this.map.style.clearSource(t));
          }
          setTiles(t) {
            return this._options.tiles = t, this.reload(), this;
          }
          setUrl(t) {
            return this.url = t, this._options.url = t, this.reload(), this;
          }
          onRemove(t) {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return r.l({}, this._options);
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          loadTile(t, n) {
            const u = r.q.devicePixelRatio >= 2, d = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), u, this.tileSize);
            t.request = r.o(this.map._requestManager.transformRequest(d, r.R.Tile), (_, v, L, G) => (delete t.request, t.aborted ? (t.state = "unloaded", n(null)) : _ ? (t.state = "errored", n(_)) : v ? (this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: L, expires: G }), t.setTexture(v, this.map.painter), t.state = "loaded", r.aE(this.dispatcher), void n(null)) : n(null)));
          }
          abortTile(t, n) {
            t.request && (t.request.cancel(), delete t.request), n && n();
          }
          unloadTile(t, n) {
            t.texture && t.texture instanceof r.T ? (t.destroy(!0), t.texture && t.texture instanceof r.T && this.map.painter.saveTileTexture(t.texture)) : t.destroy(), n && n();
          }
          hasTransition() {
            return !1;
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class Yn extends sa {
          constructor(t, n, u, d) {
            super(t, n, u, d), this.type = "raster-array", this.maxzoom = 22, this._options = r.l({ type: "raster-array" }, n);
          }
          triggerRepaint(t) {
            const n = this.map.painter._terrain, u = this.map.style.getSourceCache(this.id);
            n && n.enabled && u && n._clearRenderCacheForTile(u.id, t.tileID), this.map.triggerRepaint();
          }
          loadTile(t, n) {
            const u = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), d = this.map._requestManager.transformRequest(u, r.R.Tile);
            t.requestParams = d, t.actor || (t.actor = this.dispatcher.getActor()), t.request = t.fetchHeader(void 0, (_, v, L, G) => {
              if (delete t.request, t.aborted) return t.state = "unloaded", n(null);
              if (_)
                return _.code === 20 ? void 0 : (t.state = "errored", n(_));
              this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: L, expires: G }), t.state = "empty", n(null);
            });
          }
          unloadTile(t, n) {
            const u = t.texture;
            u && u instanceof r.T ? (t.destroy(!0), this.map.painter.saveTileTexture(u)) : (t.destroy(), t.flushQueues(), t._isHeaderLoaded = !1, delete t._mrt, delete t.textureDescriptor), t.fbo && (t.fbo.destroy(), delete t.fbo), delete t.request, delete t.requestParams, delete t.neighboringTiles, t.state = "unloaded";
          }
          prepareTile(t, n, u) {
            t._isHeaderLoaded && (t.state !== "empty" && (t.state = "reloading"), t.fetchBand(n, u, (d, _) => {
              if (d) return t.state = "errored", this.fire(new r.y(d)), void this.triggerRepaint(t);
              _ && (t.setTexture(_, this.map.painter), t.state = "loaded", this.triggerRepaint(t));
            }));
          }
          getInitialBand(t) {
            if (!this.rasterLayers) return 0;
            const n = this.rasterLayers.find(({ id: _ }) => _ === t), u = n && n.fields, d = u && u.bands && u.bands;
            return d ? d[0] : 0;
          }
          getTextureDescriptor(t, n, u) {
            if (!t) return;
            const d = n.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
            if (!d) return;
            let _ = null;
            n instanceof r.aH ? _ = n.paint.get("raster-array-band") : n instanceof r.aI && (_ = n.paint.get("raster-particle-array-band"));
            const v = _ || this.getInitialBand(d);
            if (v != null) if (t.textureDescriptor) {
              if (!t.updateNeeded(d, v) || u) return Object.assign({}, t.textureDescriptor, { texture: t.texture });
            } else this.prepareTile(t, d, v);
          }
        }
        const ea = { vector: Gn, raster: sa, "raster-dem": class extends sa {
          constructor(l, t, n, u) {
            super(l, t, n, u), this.type = "raster-dem", this.maxzoom = 22, this._options = r.l({ type: "raster-dem" }, t), this.encoding = t.encoding || "mapbox";
          }
          loadTile(l, t) {
            const n = this.map._requestManager.normalizeTileURL(l.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
            function u(d, _) {
              d && (l.state = "errored", t(d)), _ && (l.dem = _, l.dem.onDeserialize(), l.needsHillshadePrepare = !0, l.needsDEMTextureUpload = !0, l.state = "loaded", t(null));
            }
            l.request = r.o(this.map._requestManager.transformRequest(n, r.R.Tile), (function(d, _, v, L) {
              if (delete l.request, l.aborted) l.state = "unloaded", t(null);
              else if (d) l.state = "errored", t(d);
              else if (_) {
                this.map._refreshExpiredTiles && l.setExpiryData({ cacheControl: v, expires: L });
                const G = ImageBitmap && _ instanceof ImageBitmap && r.t(), X = 1 - (_.width - r.aF(_.width)) / 2;
                X < 1 || l.neighboringTiles || (l.neighboringTiles = this._getNeighboringTiles(l.tileID));
                const K = G ? _ : r.q.getImageData(_, X), ae = { uid: l.uid, coord: l.tileID, source: this.id, scope: this.scope, rawImageData: K, encoding: this.encoding, padding: X };
                l.actor && l.state !== "expired" || (l.actor = this.dispatcher.getActor(), l.actor.send("loadDEMTile", ae, u.bind(this), void 0, !0));
              }
            }).bind(this));
          }
          _getNeighboringTiles(l) {
            const t = l.canonical, n = Math.pow(2, t.z), u = (t.x - 1 + n) % n, d = t.x === 0 ? l.wrap - 1 : l.wrap, _ = (t.x + 1 + n) % n, v = t.x + 1 === n ? l.wrap + 1 : l.wrap, L = {};
            return L[new r.aG(l.overscaledZ, d, t.z, u, t.y).key] = { backfilled: !1 }, L[new r.aG(l.overscaledZ, v, t.z, _, t.y).key] = { backfilled: !1 }, t.y > 0 && (L[new r.aG(l.overscaledZ, d, t.z, u, t.y - 1).key] = { backfilled: !1 }, L[new r.aG(l.overscaledZ, l.wrap, t.z, t.x, t.y - 1).key] = { backfilled: !1 }, L[new r.aG(l.overscaledZ, v, t.z, _, t.y - 1).key] = { backfilled: !1 }), t.y + 1 < n && (L[new r.aG(l.overscaledZ, d, t.z, u, t.y + 1).key] = { backfilled: !1 }, L[new r.aG(l.overscaledZ, l.wrap, t.z, t.x, t.y + 1).key] = { backfilled: !1 }, L[new r.aG(l.overscaledZ, v, t.z, _, t.y + 1).key] = { backfilled: !1 }), L;
          }
        }, "raster-array": Yn, geojson: class extends r.E {
          constructor(l, t, n, u) {
            super(), this.id = l, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = n.getActor(), this.setEventedParent(u), this._data = t.data, this._options = r.l({}, t), this._collectResourceTiming = t.collectResourceTiming, t.maxzoom !== void 0 && (this.maxzoom = t.maxzoom), t.minzoom !== void 0 && (this.minzoom = t.minzoom), t.type && (this.type = t.type), t.attribution && (this.attribution = t.attribution), this.promoteId = t.promoteId;
            const d = r.ag / this.tileSize;
            this.workerOptions = r.l({ source: this.id, scope: this.scope, cluster: t.cluster || !1, geojsonVtOptions: { buffer: (t.buffer !== void 0 ? t.buffer : 128) * d, tolerance: (t.tolerance !== void 0 ? t.tolerance : 0.375) * d, extent: r.ag, maxZoom: this.maxzoom, lineMetrics: t.lineMetrics || !1, generateId: t.generateId || !1 }, superclusterOptions: { maxZoom: t.clusterMaxZoom !== void 0 ? t.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, t.clusterMinPoints || 2), extent: r.ag, radius: (t.clusterRadius !== void 0 ? t.clusterRadius : 50) * d, log: !1, generateId: t.generateId || !1 }, clusterProperties: t.clusterProperties, filter: t.filter, dynamic: t.dynamic }, t.workerOptions);
          }
          onAdd(l) {
            this.map = l, this.setData(this._data);
          }
          setData(l) {
            return this._data = l, this._updateWorkerData(), this;
          }
          updateData(l) {
            if (!this._options.dynamic) return this.fire(new r.y(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
            if (typeof l != "string" && (l.type === "Feature" && (l = { type: "FeatureCollection", features: [l] }), l.type !== "FeatureCollection")) return this.fire(new r.y(new Error("Data to update should be a feature or a feature collection.")));
            if (this._coalesce && typeof l != "string" && typeof this._data != "string" && this._data.type === "FeatureCollection") {
              const t = /* @__PURE__ */ new Map();
              for (const n of this._data.features) t.set(n.id, n);
              for (const n of l.features) t.set(n.id, n);
              this._data.features = [...t.values()];
            } else this._data = l;
            return this._updateWorkerData(!0), this;
          }
          getClusterExpansionZoom(l, t) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: l, source: this.id, scope: this.scope }, t), this;
          }
          getClusterChildren(l, t) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: l, source: this.id, scope: this.scope }, t), this;
          }
          getClusterLeaves(l, t, n, u) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: l, limit: t, offset: n }, u), this;
          }
          _updateWorkerData(l = !1) {
            if (this._pendingLoad) return void (this._coalesce = !0);
            this.fire(new r.z("dataloading", { dataType: "source" })), this._loaded = !1;
            const t = r.l({ append: l }, this.workerOptions);
            t.scope = this.scope;
            const n = this._data;
            typeof n == "string" ? (t.request = this.map._requestManager.transformRequest(r.q.resolveURL(n), r.R.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(n), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, (u, d) => {
              if (this._loaded = !0, this._pendingLoad = null, u) this.fire(new r.y(u));
              else {
                const _ = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                this._collectResourceTiming && d && d.resourceTiming && d.resourceTiming[this.id] && (_.resourceTiming = d.resourceTiming[this.id]), l && (this._partialReload = !0), this.fire(new r.z("data", _)), this._partialReload = !1, this._metadataFired = !0;
              }
              this._coalesce && (this._updateWorkerData(l), this._coalesce = !1);
            });
          }
          loaded() {
            return this._loaded;
          }
          reload() {
            const l = r.aC(this.id, this.scope);
            this.map.style.clearSource(l), this._updateWorkerData();
          }
          loadTile(l, t) {
            const n = l.actor ? "reloadTile" : "loadTile";
            l.actor = this.actor;
            const u = this.map.style ? this.map.style.getLut(this.scope) : null, d = u ? { image: u.image.clone() } : null, _ = this._partialReload, v = { type: this.type, uid: l.uid, tileID: l.tileID, tileZoom: l.tileZoom, zoom: l.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, lut: d, scope: this.scope, pixelRatio: r.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0, scaleFactor: this.map.getScaleFactor(), partial: _ };
            l.request = this.actor.send(n, v, (L, G) => _ && !G ? (l.state = "loaded", t(null)) : (delete l.request, l.destroy(), l.aborted ? t(null) : L ? t(L) : (l.loadVectorData(G, this.map.painter, n === "reloadTile"), t(null))), void 0, n === "loadTile");
          }
          abortTile(l) {
            l.request && (l.request.cancel(), delete l.request), l.aborted = !0;
          }
          unloadTile(l, t) {
            this.actor.send("removeTile", { uid: l.uid, type: this.type, source: this.id, scope: this.scope }), l.destroy();
          }
          onRemove(l) {
            this._pendingLoad && this._pendingLoad.cancel();
          }
          serialize() {
            return r.l({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return !1;
          }
        }, video: class extends r.aJ {
          constructor(l, t, n, u) {
            super(l, t, n, u), this.roundZoom = !0, this.type = "video", this.options = t;
          }
          load() {
            this._loaded = !1;
            const l = this.options;
            this.urls = [];
            for (const t of l.urls) this.urls.push(this.map._requestManager.transformRequest(t, r.R.Source).url);
            r.aK(this.urls, (t, n) => {
              this._loaded = !0, t ? this.fire(new r.y(t)) : n && (this.video = n, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(l) {
            if (this.video) {
              const t = this.video.seekable;
              l < t.start(0) || l > t.end(0) ? this.fire(new r.y(new r.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${t.start(0)} and ${t.end(0)}-second mark.`))) : this.video.currentTime = l;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(l) {
            this.map || (this.map = l, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const l = this.map.painter.context, t = l.gl;
            this.texture ? this.video.paused || (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, t.RGBA, t.UNSIGNED_BYTE, this.video)) : (this.texture = new r.T(l, this.video, t.RGBA8), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(l);
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }, image: r.aJ, model: class extends r.E {
          constructor(l, t, n, u) {
            super(), this.id = l, this.type = "model", this.models = [], this._loaded = !1, this._options = t;
          }
          load() {
            const l = [];
            for (const t in this._options.models) {
              const n = this._options.models[t], u = r.aM(this.map._requestManager.transformRequest(n.uri, r.R.Model).url).then((d) => {
                if (!d) return;
                const _ = r.aN(d), v = new r.aO(t, n.position, n.orientation, _);
                v.computeBoundsAndApplyParent(), this.models.push(v);
              }).catch((d) => {
                this.fire(new r.y(new Error(`Could not load model ${t} from ${n.uri}: ${d.message}`)));
              });
              l.push(u);
            }
            return Promise.allSettled(l).then(() => {
              this._loaded = !0, this.fire(new r.z("data", { dataType: "source", sourceDataType: "metadata" }));
            }).catch((t) => {
              this.fire(new r.y(new Error(`Could not load models: ${t.message}`)));
            });
          }
          onAdd(l) {
            this.map = l, this.load();
          }
          hasTransition() {
            return !1;
          }
          loaded() {
            return this._loaded;
          }
          getModels() {
            return this.models;
          }
          loadTile(l, t) {
          }
          serialize() {
            return { type: "model" };
          }
        }, "batched-model": class extends r.E {
          constructor(l, t, n, u) {
            super(), this.type = "batched-model", this.id = l, this.tileSize = 512, this._options = t, this.tiles = this._options.tiles, this.maxzoom = t.maxzoom || 19, this.minzoom = t.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = n, this.reparseOverscaled = !1, this.scheme = "xyz", this._loaded = !1, this.setEventedParent(u);
          }
          onAdd(l) {
            this.map = l, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const l = r.aC(this.id, this.scope);
            this.load(() => this.map.style.clearSource(l));
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          load(l) {
            this._loaded = !1, this.fire(new r.z("dataloading", { dataType: "source" }));
            const t = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, n = this.map.getWorldview();
            this._tileJSONRequest = Wi(this._options, this.map._requestManager, t, n, (u, d) => {
              this._tileJSONRequest = null, this._loaded = !0, u ? (t && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t}`), n && n.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${n}`), this.fire(new r.y(u))) : d && (r.l(this, d), d.bounds && (this.tileBounds = new Bi(d.bounds, this.minzoom, this.maxzoom)), Ze(d.tiles, this.map._requestManager._customAccessToken), this.fire(new r.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new r.z("data", { dataType: "source", sourceDataType: "content" }))), l && l(u);
            });
          }
          hasTransition() {
            return !1;
          }
          hasTile(l) {
            return !this.tileBounds || this.tileBounds.contains(l.canonical);
          }
          loaded() {
            return this._loaded;
          }
          loadTile(l, t) {
            const n = this.map._requestManager.normalizeTileURL(l.tileID.canonical.url(this.tiles, this.scheme)), u = { request: this.map._requestManager.transformRequest(n, r.R.Tile), data: void 0, uid: l.uid, tileID: l.tileID, tileZoom: l.tileZoom, zoom: l.tileID.overscaledZ, tileSize: this.tileSize * l.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: l.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, lut: null, maxZoom: null, promoteId: null, pixelRatio: null, scaleFactor: null };
            if (l.actor && l.state !== "expired") if (l.state === "loading") l.reloadCallback = t;
            else {
              if (l.buckets) {
                const _ = Object.values(l.buckets);
                for (const v of _) v.dirty = !0;
                return void (l.state = "loaded");
              }
              l.request = l.actor.send("reloadTile", u, d.bind(this));
            }
            else l.actor = this.dispatcher.getActor(), l.request = l.actor.send("loadTile", u, d.bind(this), void 0, !0);
            function d(_, v) {
              return l.aborted ? t(null) : _ && _.status !== 404 ? t(_) : (this.map._refreshExpiredTiles && v && l.setExpiryData(v), l.loadModelData(v, this.map.painter), l.state = "loaded", void t(null));
            }
          }
          serialize() {
            return r.l({}, this._options);
          }
        }, canvas: class extends r.aJ {
          constructor(l, t, n, u) {
            super(l, t, n, u), t.coordinates ? Array.isArray(t.coordinates) && t.coordinates.length === 4 && !t.coordinates.some((d) => !Array.isArray(d) || d.length !== 2 || d.some((_) => typeof _ != "number")) || this.fire(new r.y(new r.V(`sources.${l}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new r.y(new r.V(`sources.${l}`, null, 'missing required property "coordinates"'))), t.animate && typeof t.animate != "boolean" && this.fire(new r.y(new r.V(`sources.${l}`, null, 'optional "animate" property must be a boolean value'))), t.canvas ? typeof t.canvas == "string" || t.canvas instanceof HTMLCanvasElement || this.fire(new r.y(new r.V(`sources.${l}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new r.y(new r.V(`sources.${l}`, null, 'missing required property "canvas"'))), this.options = t, this.animate = t.animate === void 0 || t.animate;
          }
          load() {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new r.y(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(l) {
            this.map = l, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove(l) {
            this.pause();
          }
          prepare() {
            let l = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, l = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, l = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const t = this.map.painter.context;
            this.texture ? !l && !this._playing || this.texture instanceof r.aL || this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new r.T(t, this.canvas, t.gl.RGBA8, { premultiply: !0 }), this._prepareData(t);
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const l of [this.canvas.width, this.canvas.height]) if (isNaN(l) || l <= 0) return !0;
            return !1;
          }
        }, custom: class extends r.E {
          constructor(l, t, n, u) {
            super(), this.id = l, this.type = "custom", this._dataType = "raster", this._dispatcher = n, this._implementation = t, this.setEventedParent(u), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new r.y(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new r.y(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new Bi(this._implementation.bounds, this.minzoom, this.maxzoom)), t.update = this._update.bind(this), t.clearTiles = this._clearTiles.bind(this), t.coveringTiles = this._coveringTiles.bind(this), r.l(this, r.ay(t, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
          }
          serialize() {
            return r.ay(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
          }
          load() {
            this._loaded = !0, this.fire(new r.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new r.z("data", { dataType: "source", sourceDataType: "content" }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(l) {
            this.map = l, this._loaded = !1, this.fire(new r.z("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(l), this.load();
          }
          onRemove(l) {
            this._implementation.onRemove && this._implementation.onRemove(l);
          }
          hasTile(l) {
            if (this._implementation.hasTile) {
              const { x: t, y: n, z: u } = l.canonical;
              return this._implementation.hasTile({ x: t, y: n, z: u });
            }
            return !this.tileBounds || this.tileBounds.contains(l.canonical);
          }
          loadTile(l, t) {
            const { x: n, y: u, z: d } = l.tileID.canonical, _ = new AbortController();
            l.request = Promise.resolve(this._implementation.loadTile({ x: n, y: u, z: d }, { signal: _.signal })).then((function(v) {
              return delete l.request, l.aborted ? (l.state = "unloaded", t(null)) : v === void 0 ? (l.state = "errored", t(null)) : v === null ? (this.loadTileData(l, { width: this.tileSize, height: this.tileSize, data: null }), l.state = "loaded", t(null)) : function(L) {
                return L instanceof ImageData || L instanceof HTMLCanvasElement || L instanceof ImageBitmap || L instanceof HTMLImageElement;
              }(v) ? (this.loadTileData(l, v), l.state = "loaded", void t(null)) : (l.state = "errored", t(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
            }).bind(this)).catch((v) => {
              v.code !== 20 && (l.state = "errored", t(v));
            }), l.request.cancel = () => _.abort();
          }
          loadTileData(l, t) {
            l.setTexture(t, this.map.painter);
          }
          unloadTile(l, t) {
            if (l.texture && l.texture instanceof r.T ? (l.destroy(!0), l.texture && l.texture instanceof r.T && this.map.painter.saveTileTexture(l.texture)) : l.destroy(), this._implementation.unloadTile) {
              const { x: n, y: u, z: d } = l.tileID.canonical;
              this._implementation.unloadTile({ x: n, y: u, z: d });
            }
            t && t();
          }
          abortTile(l, t) {
            l.request && l.request.cancel && (l.request.cancel(), delete l.request), t && t();
          }
          hasTransition() {
            return !1;
          }
          _coveringTiles() {
            return this.map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((l) => ({ x: l.canonical.x, y: l.canonical.y, z: l.canonical.z }));
          }
          _clearTiles() {
            const l = r.aC(this.id, this.scope);
            this.map.style.clearSource(l);
          }
          _update() {
            this.fire(new r.z("data", { dataType: "source", sourceDataType: "content" }));
          }
        } }, Pa = function(l, t, n, u) {
          const d = new ea[t.type](l, t, n, u);
          if (d.id !== l) throw new Error(`Expected Source id to be ${l} instead of ${d.id}`);
          return r.aP(["load", "abort", "unload", "serialize", "prepare"], d), d;
        };
        function Fs(l, t, n = "") {
          return `${n}:${t.id || ""}:${t.layer.id}:${function(u) {
            if ("layerId" in u) return `layer:${u.layerId}`;
            {
              const { featuresetId: d, importId: _ } = u;
              return `featureset:${d}${_ ? `:import:${_}` : ""}`;
            }
          }(l.target)}`;
        }
        function wo(l, t, n, u = "") {
          if (l.uniqueFeatureID) {
            const d = Fs(l, t, u);
            if (n.has(d)) return !0;
            n.add(d);
          }
          return !1;
        }
        function fs(l, t, n, u, d = !1) {
          const _ = t.sourceCache.transform, v = t.sourceCache.tilesIn(l, t.has3DLayers, d);
          v.sort(Th);
          const L = [];
          for (const G of v) {
            const X = G.tile.queryRenderedFeatures(t, G, n, u, _, d);
            Object.keys(X).length && L.push({ wrappedTileID: G.tile.tileID.wrapped().key, queryResults: X });
          }
          return L.length === 0 ? {} : function(G) {
            const X = {}, K = {};
            for (const ae of G) {
              const oe = ae.queryResults, pe = ae.wrappedTileID, Be = K[pe] = K[pe] || {};
              for (const Re in oe) {
                const Ge = oe[Re], Ve = Be[Re] = Be[Re] || {}, et = X[Re] = X[Re] || [];
                for (const ut of Ge) Ve[ut.featureIndex] || (Ve[ut.featureIndex] = !0, et.push(ut));
              }
            }
            return X;
          }(L);
        }
        function ou(l, t, n, u, d) {
          const _ = {}, v = u.queryRenderedSymbols(l), L = [];
          for (const G of Object.keys(v).map(Number)) L.push(d[G]);
          L.sort(Th);
          for (const G of L) {
            const X = G.featureIndex.lookupSymbolFeatures(v[G.bucketInstanceId], G.bucketIndex, G.sourceLayerIndex, t, n);
            for (const K in X) {
              const ae = _[K] = _[K] || [], oe = X[K];
              oe.sort((pe, Be) => {
                const Re = G.featureSortOrder;
                if (Re) {
                  const Ge = Re.indexOf(pe.featureIndex);
                  return Re.indexOf(Be.featureIndex) - Ge;
                }
                return Be.featureIndex - pe.featureIndex;
              });
              for (const pe of oe) ae.push(pe);
            }
          }
          return _;
        }
        function mf(l, t) {
          const n = l.getRenderableIds().map((_) => l.getTileByID(_)), u = [], d = {};
          for (let _ = 0; _ < n.length; _++) {
            const v = n[_], L = v.tileID.canonical.key;
            d[L] || (d[L] = !0, v.querySourceFeatures(u, t));
          }
          return u;
        }
        function Th(l, t) {
          const n = l.tileID, u = t.tileID;
          return n.overscaledZ - u.overscaledZ || n.canonical.y - u.canonical.y || n.wrap - u.wrap || n.canonical.x - u.canonical.x;
        }
        function Vu(l, t) {
          const n = {};
          if (!t) return n;
          for (const u of l) {
            const d = u.layerIds.map((_) => t.getLayer(_)).filter(Boolean);
            if (d.length !== 0) {
              u.layers = d, u.stateDependentLayerIds && (u.stateDependentLayers = u.stateDependentLayerIds.map((_) => d.filter((v) => v.id === _)[0]));
              for (const _ of d) n[_.fqid] = u;
            }
          }
          return n;
        }
        const Sa = 32, lo = 33, uo = new Uint16Array(8184);
        for (let l = 0; l < 2046; l++) {
          let t = l + 2, n = 0, u = 0, d = 0, _ = 0, v = 0, L = 0;
          for (1 & t ? d = _ = v = Sa : n = u = L = Sa; (t >>= 1) > 1; ) {
            const X = n + d >> 1, K = u + _ >> 1;
            1 & t ? (d = n, _ = u, n = v, u = L) : (n = d, u = _, d = v, _ = L), v = X, L = K;
          }
          const G = 4 * l;
          uo[G + 0] = n, uo[G + 1] = u, uo[G + 2] = d, uo[G + 3] = _;
        }
        const Wo = new Uint16Array(2178), co = new Uint8Array(1089), on = new Uint16Array(1089);
        function Gu(l) {
          return l === 0 ? -0.03125 : l === 32 ? 0.03125 : 0;
        }
        const Cc = { type: 2, extent: r.ag, loadGeometry: () => [[new r.P(0, 0), new r.P(r.ag + 1, 0), new r.P(r.ag + 1, r.ag + 1), new r.P(0, r.ag + 1), new r.P(0, 0)]] };
        class Zo {
          constructor(t, n, u, d, _) {
            this.tileID = t, this.uid = r.aV(), this.uses = 0, this.tileSize = n, this.tileZoom = u, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = _, d && d.style && (this._lastUpdatedBrightness = d.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", d && d.transform && (this.projection = d.transform.projection);
          }
          registerFadeDuration(t) {
            const n = t + this.timeAdded;
            n < r.q.now() || this.fadeEndTime && n < this.fadeEndTime || (this.fadeEndTime = n);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          get tileTransform() {
            return this._tileTransform || (this._tileTransform = r.aQ(this.tileID.canonical, this.projection)), this._tileTransform;
          }
          loadVectorData(t, n, u) {
            if (this.unloadVectorData(), this.state = "loaded", t) {
              t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = Vu(t.buckets, n.style), this.hasSymbolBuckets = !1;
              for (const d in this.buckets) {
                const _ = this.buckets[d];
                if (_ instanceof r.aX) {
                  if (this.hasSymbolBuckets = !0, !u) break;
                  _.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const d in this.buckets) {
                const _ = this.buckets[d];
                if (_ instanceof r.aX && _.hasRTLText) {
                  this.hasRTLText = !0, r.aY();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const d in this.buckets) {
                const _ = this.buckets[d], v = n.style.getOwnLayer(d);
                if (!v) continue;
                const L = v.queryRadius(_);
                this.queryPadding = Math.max(this.queryPadding, L);
              }
              t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas), this._lastUpdatedBrightness = t.brightness;
            } else this.collisionBoxArray = new r.aW();
          }
          unloadVectorData() {
            if (this.hasData()) {
              for (const t in this.buckets) this.buckets[t].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
            }
          }
          loadModelData(t, n, u) {
            t && (t.resourceTiming && (this.resourceTiming = t.resourceTiming), this.buckets = Object.assign({}, this.buckets, Vu(t.buckets, n.style)), t.featureIndex && (this.latestFeatureIndex = t.featureIndex));
          }
          getBucket(t) {
            return this.buckets[t.fqid];
          }
          upload(t) {
            for (const d in this.buckets) {
              const _ = this.buckets[d];
              _.uploadPending() && _.upload(t);
            }
            const n = t.gl, u = this.imageAtlas;
            if (u && !u.uploaded) {
              const d = !!Object.keys(u.patternPositions).length;
              this.imageAtlasTexture = new r.T(t, u.image, n.RGBA8, { useMipmap: d }), this.imageAtlas.uploaded = !0;
            }
            this.glyphAtlasImage && (this.glyphAtlasTexture = new r.T(t, this.glyphAtlasImage, n.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new r.T(t, this.lineAtlas.image, n.R8), this.lineAtlas.uploaded = !0);
          }
          prepare(t, n, u) {
            if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture, u), !n || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
            const d = n.style.getBrightness();
            (this._lastUpdatedBrightness || d) && (this._lastUpdatedBrightness && d && Math.abs(this._lastUpdatedBrightness - d) < 1e-3 || (this.updateBuckets(n, this._lastUpdatedBrightness !== d), this._lastUpdatedBrightness = d));
          }
          queryRenderedFeatures(t, n, u, d, _, v) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};
            const L = function(G, X) {
              const K = r.ab.mat4.fromScaling([], [0.5 * G.width, 0.5 * -G.height, 1]);
              return r.ab.mat4.translate(K, K, [1, -1, 0]), r.ab.mat4.multiply(K, K, G.calculateProjMatrix(X.toUnwrapped())), Float32Array.from(K);
            }(_, this.tileID);
            return this.latestFeatureIndex.query(t, { tilespaceGeometry: n, pixelPosMatrix: L, transform: d, availableImages: u, tileTransform: this.tileTransform });
          }
          querySourceFeatures(t, n) {
            const u = this.latestFeatureIndex;
            if (!u || !u.rawTileData) return;
            const d = u.loadVTLayers(), _ = n ? n.sourceLayer : "", v = d._geojsonTileLayer || d[_];
            if (!v) return;
            const L = r.aZ(n && n.filter), { z: G, x: X, y: K } = this.tileID.canonical, ae = { z: G, x: X, y: K };
            for (let oe = 0; oe < v.length; oe++) {
              const pe = v.feature(oe);
              if (L.needGeometry) {
                const Ge = r.a_(pe, !0);
                if (!L.filter(new r.a8(this.tileID.overscaledZ), Ge, this.tileID.canonical)) continue;
              } else if (!L.filter(new r.a8(this.tileID.overscaledZ), pe)) continue;
              const Be = u.getId(pe, _), Re = new r.a$(pe, G, X, K, Be);
              Re.tile = ae, t.push(Re);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t) {
            const n = this.expirationTime;
            if (t.cacheControl) {
              const u = r.b0(t.cacheControl);
              u["max-age"] && (this.expirationTime = Date.now() + 1e3 * u["max-age"]);
            } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
            if (this.expirationTime) {
              const u = Date.now();
              let d = !1;
              if (this.expirationTime > u) d = !1;
              else if (n) if (this.expirationTime < n) d = !0;
              else {
                const _ = this.expirationTime - n;
                _ ? this.expirationTime = u + Math.max(_, 3e4) : d = !0;
              }
              else d = !0;
              d ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          refreshFeatureState(t) {
            this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && t && this.updateBuckets(t);
          }
          updateBuckets(t, n) {
            if (!this.latestFeatureIndex || !t.style) return;
            const u = this.latestFeatureIndex.loadVTLayers(), d = t.style.listImages(), _ = t.style.getBrightness();
            for (const v in this.buckets) {
              if (!t.style.hasLayer(v)) continue;
              const L = this.buckets[v], G = L.layers[0], X = G.sourceLayer || "_geojsonTileLayer", K = u[X], ae = t.style.getLayerSourceCache(G);
              let oe = {};
              ae && (oe = ae._state.getState(X, void 0));
              const pe = this.imageAtlas && this.imageAtlas.patternPositions || {}, Be = Object.keys(oe).length > 0 && !n;
              Be && !L.stateDependentLayers.length && !n || L.update(oe, K, d, pe, Be ? L.stateDependentLayers : L.layers, n, _), (L instanceof r.b1 || L instanceof r.b2) && t._terrain && t._terrain.enabled && ae && L.programConfigurations.needsUpload && t._terrain._clearRenderCacheForTile(ae.id, this.tileID);
              const Re = t && t.style && t.style.getOwnLayer(v);
              Re && (this.queryPadding = Math.max(this.queryPadding, Re.queryRadius(L)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < r.q.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t) {
            this.symbolFadeHoldUntil = r.q.now() + t;
          }
          setTexture(t, n) {
            const u = n.context, d = u.gl;
            this.texture = this.texture || n.getTileTexture(t.width), this.texture && this.texture instanceof r.T ? this.texture.update(t) : (this.texture = new r.T(u, t, d.RGBA8, { useMipmap: !0 }), this.texture.bind(d.LINEAR, d.CLAMP_TO_EDGE));
          }
          setDependencies(t, n) {
            const u = {};
            for (const d of n) u[d] = !0;
            this.dependencies[t] = u;
          }
          hasDependency(t, n) {
            for (const u of t) {
              const d = this.dependencies[u];
              if (d) {
                for (const _ of n) if (d[_]) return !0;
              }
            }
            return !1;
          }
          clearQueryDebugViz() {
          }
          _makeDebugTileBoundsBuffers(t, n) {
            if (!n || n.name === "mercator" || this._tileDebugBuffer) return;
            const u = r.b3(Cc, this.tileID.canonical, this.tileTransform)[0], d = new r.b4(), _ = new r.b5();
            for (let v = 0; v < u.length; v++) {
              const { x: L, y: G } = u[v];
              d.emplaceBack(L, G), _.emplaceBack(v);
            }
            _.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(_), this._tileDebugBuffer = t.createVertexBuffer(d, r.b6.members), this._tileDebugSegments = r.b7.simpleSegment(0, 0, d.length, _.length);
          }
          _makeTileBoundsBuffers(t, n) {
            if (this._tileBoundsBuffer || !n || n.name === "mercator") return;
            const u = r.b3(Cc, this.tileID.canonical, this.tileTransform)[0];
            let d, _;
            if (this.isRaster) {
              const v = function(L, G) {
                const X = r.aQ(L, G), K = Math.pow(2, L.z);
                for (let Ge = 0; Ge < lo; Ge++) for (let Ve = 0; Ve < lo; Ve++) {
                  const et = r.aR((L.x + (Ve + Gu(Ve)) / Sa) / K), ut = r.aS((L.y + (Ge + Gu(Ge)) / Sa) / K), st = G.project(et, ut), xt = Ge * lo + Ve;
                  Wo[2 * xt + 0] = Math.round((st.x * X.scale - X.x) * r.ag), Wo[2 * xt + 1] = Math.round((st.y * X.scale - X.y) * r.ag);
                }
                co.fill(0), on.fill(0);
                for (let Ge = 2045; Ge >= 0; Ge--) {
                  const Ve = 4 * Ge, et = uo[Ve + 0], ut = uo[Ve + 1], st = uo[Ve + 2], xt = uo[Ve + 3], mt = et + st >> 1, _t = ut + xt >> 1, dt = mt + _t - ut, gt = _t + et - mt, Rt = ut * lo + et, Jt = xt * lo + st, Vt = _t * lo + mt, or = Math.hypot((Wo[2 * Rt + 0] + Wo[2 * Jt + 0]) / 2 - Wo[2 * Vt + 0], (Wo[2 * Rt + 1] + Wo[2 * Jt + 1]) / 2 - Wo[2 * Vt + 1]) >= 16;
                  co[Vt] = co[Vt] || (or ? 1 : 0), Ge < 1022 && (co[Vt] = co[Vt] || co[(ut + gt >> 1) * lo + (et + dt >> 1)] || co[(xt + gt >> 1) * lo + (st + dt >> 1)]);
                }
                const ae = new r.aT(), oe = new r.aU();
                let pe = 0;
                function Be(Ge, Ve) {
                  const et = Ve * lo + Ge;
                  return on[et] === 0 && (ae.emplaceBack(Wo[2 * et + 0], Wo[2 * et + 1], Ge * r.ag / Sa, Ve * r.ag / Sa), on[et] = ++pe), on[et] - 1;
                }
                function Re(Ge, Ve, et, ut, st, xt) {
                  const mt = Ge + et >> 1, _t = Ve + ut >> 1;
                  if (Math.abs(Ge - st) + Math.abs(Ve - xt) > 1 && co[_t * lo + mt]) Re(st, xt, Ge, Ve, mt, _t), Re(et, ut, st, xt, mt, _t);
                  else {
                    const dt = Be(Ge, Ve), gt = Be(et, ut), Rt = Be(st, xt);
                    oe.emplaceBack(dt, gt, Rt);
                  }
                }
                return Re(0, 0, Sa, Sa, Sa, 0), Re(Sa, Sa, 0, 0, 0, Sa), { vertices: ae, indices: oe };
              }(this.tileID.canonical, n);
              d = v.vertices, _ = v.indices;
            } else {
              d = new r.aT(), _ = new r.aU();
              for (const { x: L, y: G } of u) d.emplaceBack(L, G, 0, 0);
              const v = r.b8(d.int16, void 0, 4);
              for (let L = 0; L < v.length; L += 3) _.emplaceBack(v[L], v[L + 1], v[L + 2]);
            }
            this._tileBoundsBuffer = t.createVertexBuffer(d, r.b9.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(_), this._tileBoundsSegments = r.b7.simpleSegment(0, 0, d.length, _.length);
          }
          _makeGlobeTileDebugBuffers(t, n) {
            const u = n.projection;
            if (!u || u.name !== "globe" || n.freezeTileCoverage) return;
            const d = this.tileID.canonical, _ = r.ba(d, n), v = r.bb(_), L = r.ae(n.zoom);
            let G;
            L > 0 && (G = r.ab.mat4.invert(new Float64Array(16), n.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, d, n, v, G, L), this._makeGlobeTileDebugTextBuffer(t, d, n, v, G, L);
          }
          _globePoint(t, n, u, d, _, v, L) {
            let G = r.bc(t, n, u);
            if (v) {
              const X = 1 << u.z, K = r.at(d.center.lng), ae = r.aA(d.center.lat), oe = (u.x + 0.5) / X - K;
              let pe = 0;
              oe > 0.5 ? pe = -1 : oe < -0.5 && (pe = 1);
              let Be = (t / r.ag + u.x) / X + pe, Re = (n / r.ag + u.y) / X;
              Be = (Be - K) * d._pixelsPerMercatorPixel + K, Re = (Re - ae) * d._pixelsPerMercatorPixel + ae;
              const Ge = [Be * d.worldSize, Re * d.worldSize, 0];
              r.ab.vec3.transformMat4(Ge, Ge, v), G = r.bd(G, Ge, L);
            }
            return r.ab.vec3.transformMat4(G, G, _);
          }
          _makeGlobeTileDebugBorderBuffer(t, n, u, d, _, v) {
            const L = new r.b4(), G = new r.b5(), X = new r.be(), K = (oe, pe, Be, Re, Ge) => {
              const Ve = (Be - oe) / (Ge - 1), et = (Re - pe) / (Ge - 1), ut = L.length;
              for (let st = 0; st < Ge; st++) {
                const xt = oe + st * Ve, mt = pe + st * et;
                L.emplaceBack(xt, mt);
                const _t = this._globePoint(xt, mt, n, u, d, _, v);
                X.emplaceBack(_t[0], _t[1], _t[2]), G.emplaceBack(ut + st);
              }
            }, ae = r.ag;
            K(0, 0, ae, 0, 16), K(ae, 0, ae, ae, 16), K(ae, ae, 0, ae, 16), K(0, ae, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(G), this._tileDebugBuffer = t.createVertexBuffer(L, r.b6.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(X, r.bf.members), this._tileDebugSegments = r.b7.simpleSegment(0, 0, L.length, G.length);
          }
          _makeGlobeTileDebugTextBuffer(t, n, u, d, _, v) {
            const L = r.ag / 4, G = new r.b4(), X = new r.aU(), K = new r.be(), ae = 25;
            X.reserve(32), G.reserve(ae), K.reserve(ae);
            const oe = (pe, Be) => ae * pe + Be;
            for (let pe = 0; pe < ae; pe++) {
              const Be = pe * L;
              for (let Re = 0; Re < ae; Re++) {
                const Ge = Re * L;
                G.emplaceBack(Ge, Be);
                const Ve = this._globePoint(Ge, Be, n, u, d, _, v);
                K.emplaceBack(Ve[0], Ve[1], Ve[2]);
              }
            }
            for (let pe = 0; pe < 4; pe++) for (let Be = 0; Be < 4; Be++) {
              const Re = oe(pe, Be), Ge = oe(pe, Be + 1), Ve = oe(pe + 1, Be), et = oe(pe + 1, Be + 1);
              X.emplaceBack(Re, Ge, Ve), X.emplaceBack(Ve, Ge, et);
            }
            this._tileDebugTextIndexBuffer = t.createIndexBuffer(X), this._tileDebugTextBuffer = t.createVertexBuffer(G, r.b6.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(K, r.bf.members), this._tileDebugTextSegments = r.b7.simpleSegment(0, 0, ae, 32);
          }
          destroy(t = !1) {
            for (const n in this.buckets) this.buckets[n].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t && this.texture && this.texture instanceof r.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        r.bg.setPbf(r.bh);
        class ds extends Zo {
          constructor(t, n, u, d, _) {
            super(t, n, u, d, _), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = !1;
          }
          setTexture(t, n) {
            const u = n.context, d = u.gl;
            this.texture = this.texture || n.getTileTexture(t.width), this.texture && this.texture instanceof r.T ? this.texture.update(t, { premultiply: !1 }) : this.texture = new r.T(u, t, d.RGBA8, { premultiply: !1 });
          }
          flushQueues() {
            for (; this._workQueue.length; ) this._workQueue.pop()();
            for (; this._fetchQueue.length; ) this._fetchQueue.pop()();
          }
          fetchHeader(t = 16384, n) {
            const u = this._mrt = new r.bg(30), d = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t - 1) } });
            return this.entireBuffer = null, this.request = r.bi(d, (_, v, L, G) => {
              if (_) n(_);
              else try {
                const X = u.getHeaderLength(v);
                if (X > t) return void (this.request = this.fetchHeader(X, n));
                u.parseHeader(v), this._isHeaderLoaded = !0;
                let K = 0;
                for (const ae of Object.values(u.layers)) K = Math.max(K, ae.dataIndex[ae.dataIndex.length - 1].last_byte);
                v.byteLength >= K && (this.entireBuffer = v), n(null, this.entireBuffer || v, L, G);
              } catch (X) {
                n(X);
              }
            }), this.request;
          }
          fetchBand(t, n, u) {
            const d = this._mrt;
            if (!this._isHeaderLoaded || !d) return void u(new Error("Tile header is not ready"));
            const _ = this.actor;
            if (!_) return void u(new Error("Can't fetch tile band without an actor"));
            let v;
            const L = (ae, oe) => {
              v.complete(ae, oe), ae ? u(ae) : (this.updateTextureDescriptor(t, n), u(null, this.textureDescriptor && this.textureDescriptor.img));
            }, G = (ae, oe) => {
              if (ae) return u(ae);
              const pe = _.send("decodeRasterArray", { buffer: oe, task: v }, L, void 0, !0);
              this._workQueue.push(() => {
                pe && pe.cancel(), v.cancel();
              });
            }, X = d.getLayer(t);
            if (!X) return void u(new Error(`Unknown sourceLayer "${t}"`));
            if (X.hasDataForBand(n)) return this.updateTextureDescriptor(t, n), void u(null, this.textureDescriptor ? this.textureDescriptor.img : null);
            const K = X.getDataRange([n]);
            if (v = d.createDecodingTask(K), !v || v.tasks.length) if (this.flushQueues(), this.entireBuffer) G(null, this.entireBuffer.slice(K.firstByte, K.lastByte + 1));
            else {
              const ae = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${K.firstByte}-${K.lastByte}` } }), oe = r.bi(ae, G);
              this._fetchQueue.push(() => {
                oe.cancel(), v.cancel();
              });
            }
            else u(null);
          }
          updateNeeded(t, n) {
            return (!this.textureDescriptor || this.textureDescriptor.band !== n || this.textureDescriptor.layer !== t) && this.state !== "errored";
          }
          updateTextureDescriptor(t, n) {
            if (!this._mrt) return;
            const u = this._mrt.getLayer(t);
            if (!u || !u.hasBand(n) || !u.hasDataForBand(n)) return;
            const { bytes: d, tileSize: _, buffer: v, offset: L, scale: G } = u.getBandView(n), X = _ + 2 * v, K = { data: d, width: X, height: X }, ae = this.texture;
            ae && ae instanceof r.T && ae.update(K, { premultiply: !1 }), this.textureDescriptor = { layer: t, band: n, img: K, buffer: v, offset: L, tileSize: _, format: u.pixelFormat, mix: [G, 256 * G, 65536 * G, 16777216 * G] };
          }
        }
        class Mh {
          constructor(t, n) {
            this.max = t, this.onRemove = n, this.reset();
          }
          reset() {
            for (const t in this.data) for (const n of this.data[t]) n.timeout && clearTimeout(n.timeout), this.onRemove(n.value);
            return this.data = {}, this.order = [], this;
          }
          add(t, n, u) {
            const d = t.wrapped().key;
            this.data[d] === void 0 && (this.data[d] = []);
            const _ = { value: n, timeout: void 0 };
            if (u !== void 0 && (_.timeout = setTimeout(() => {
              this.remove(t, _);
            }, u)), this.data[d].push(_), this.order.push(d), this.order.length > this.max) {
              const v = this._getAndRemoveByKey(this.order[0]);
              v && this.onRemove(v);
            }
            return this;
          }
          has(t) {
            return t.wrapped().key in this.data;
          }
          getAndRemove(t) {
            return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
          }
          _getAndRemoveByKey(t) {
            const n = this.data[t].shift();
            return n.timeout && clearTimeout(n.timeout), this.data[t].length === 0 && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), n.value;
          }
          getByKey(t) {
            const n = this.data[t];
            return n ? n[0].value : null;
          }
          get(t) {
            return this.has(t) ? this.data[t.wrapped().key][0].value : null;
          }
          remove(t, n) {
            if (!this.has(t)) return this;
            const u = t.wrapped().key, d = n === void 0 ? 0 : this.data[u].indexOf(n), _ = this.data[u][d];
            return this.data[u].splice(d, 1), _.timeout && clearTimeout(_.timeout), this.data[u].length === 0 && delete this.data[u], this.onRemove(_.value), this.order.splice(this.order.indexOf(u), 1), this;
          }
          setMaxSize(t) {
            for (this.max = t; this.order.length > this.max; ) {
              const n = this._getAndRemoveByKey(this.order[0]);
              n && this.onRemove(n);
            }
            return this;
          }
          filter(t) {
            const n = [];
            for (const u in this.data) for (const d of this.data[u]) t(d.value) || n.push(d);
            for (const u of n) this.remove(u.value.tileID, u);
          }
        }
        class Pc {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t, n, u) {
            const d = String(n);
            if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][d] = this.stateChanges[t][d] || {}, r.l(this.stateChanges[t][d], u), this.deletedStates[t] === null) {
              this.deletedStates[t] = {};
              for (const _ in this.state[t]) _ !== d && (this.deletedStates[t][_] = null);
            } else if (this.deletedStates[t] && this.deletedStates[t][d] === null) {
              this.deletedStates[t][d] = {};
              for (const _ in this.state[t][d]) u[_] || (this.deletedStates[t][d][_] = null);
            } else for (const _ in u) this.deletedStates[t] && this.deletedStates[t][d] && this.deletedStates[t][d][_] === null && delete this.deletedStates[t][d][_];
          }
          removeFeatureState(t, n, u) {
            if (this.deletedStates[t] === null) return;
            const d = String(n);
            if (this.deletedStates[t] = this.deletedStates[t] || {}, u && n !== void 0) this.deletedStates[t][d] !== null && (this.deletedStates[t][d] = this.deletedStates[t][d] || {}, this.deletedStates[t][d][u] = null);
            else if (n !== void 0) if (this.stateChanges[t] && this.stateChanges[t][d]) for (u in this.deletedStates[t][d] = {}, this.stateChanges[t][d]) this.deletedStates[t][d][u] = null;
            else this.deletedStates[t][d] = null;
            else this.deletedStates[t] = null;
          }
          getState(t, n) {
            const u = this.state[t] || {}, d = this.stateChanges[t] || {}, _ = this.deletedStates[t];
            if (_ === null) return {};
            if (n !== void 0) {
              const L = String(n), G = r.l({}, u[L], d[L]);
              if (_) {
                const X = _[n];
                if (X === null) return {};
                for (const K in X) delete G[K];
              }
              return G;
            }
            const v = r.l({}, u, d);
            if (_) for (const L in _) delete v[L];
            return v;
          }
          initializeTileState(t, n) {
            t.refreshFeatureState(n);
          }
          coalesceChanges(t, n) {
            const u = {};
            for (const d in this.stateChanges) {
              this.state[d] = this.state[d] || {};
              const _ = {};
              for (const v in this.stateChanges[d]) this.state[d][v] || (this.state[d][v] = {}), r.l(this.state[d][v], this.stateChanges[d][v]), _[v] = this.state[d][v];
              u[d] = _;
            }
            for (const d in this.deletedStates) {
              this.state[d] = this.state[d] || {};
              const _ = {};
              if (this.deletedStates[d] === null) for (const v in this.state[d]) _[v] = {}, this.state[d][v] = {};
              else for (const v in this.deletedStates[d]) {
                if (this.deletedStates[d][v] === null) this.state[d][v] = {};
                else if (this.state[d][v]) for (const L of Object.keys(this.deletedStates[d][v])) delete this.state[d][v][L];
                _[v] = this.state[d][v];
              }
              u[d] = u[d] || {}, r.l(u[d], _);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(u).length !== 0) for (const d in t) t[d].refreshFeatureState(n);
          }
        }
        class Xa extends r.E {
          constructor(t, n, u) {
            super(), this.id = t, this._onlySymbols = u, n.on("data", (d) => {
              d.dataType === "source" && d.sourceDataType === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && d.dataType === "source" && d.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform));
            }), n.on("error", () => {
              this._sourceErrored = !0;
            }), this._source = n, this._tiles = {}, this._cache = new Mh(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = n.minTileCacheSize, this._maxTileCacheSize = n.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Pc(), this._isRaster = this._source.type === "raster" || this._source.type === "raster-dem" || this._source.type === "raster-array" || this._source.type === "custom" && this._source._dataType === "raster";
          }
          onAdd(t) {
            this.map = t, this._minTileCacheSize = this._minTileCacheSize === void 0 && t ? t._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = this._maxTileCacheSize === void 0 && t ? t._maxTileCacheSize : this._maxTileCacheSize;
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            for (const t in this._tiles) {
              const n = this._tiles[t];
              if (n.state !== "loaded" && n.state !== "errored") return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const t = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);
          }
          _loadTile(t, n) {
            return t.isSymbolTile = this._onlySymbols, t.isExtraShadowCaster = this._shadowCasterTiles[t.tileID.key], this._source.loadTile(t, n);
          }
          _unloadTile(t) {
            if (this._source.unloadTile) return this._source.unloadTile(t);
          }
          _abortTile(t) {
            if (this._source.abortTile) return this._source.abortTile(t);
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const n in this._tiles) {
              const u = this._tiles[n];
              u.upload(t), u.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
            }
          }
          getIds() {
            return r.bj(this._tiles).map((t) => t.tileID).sort(Xi).map((t) => t.key);
          }
          getRenderableIds(t, n) {
            const u = [];
            for (const d in this._tiles) this._isIdRenderable(+d, t, n) && u.push(this._tiles[d]);
            return t ? u.sort((d, _) => {
              const v = d.tileID, L = _.tileID, G = new r.P(v.canonical.x, v.canonical.y)._rotate(this.transform.angle), X = new r.P(L.canonical.x, L.canonical.y)._rotate(this.transform.angle);
              return v.overscaledZ - L.overscaledZ || X.y - G.y || X.x - G.x;
            }).map((d) => d.tileID.key) : u.map((d) => d.tileID).sort(Xi).map((d) => d.key);
          }
          hasRenderableParent(t) {
            const n = this.findLoadedParent(t, 0);
            return !!n && this._isIdRenderable(n.tileID.key);
          }
          _isIdRenderable(t, n, u) {
            return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (n || !this._tiles[t].holdingForFade()) && (u || !this._shadowCasterTiles[t]);
          }
          reload() {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const t in this._tiles) this._tiles[t].state !== "errored" && this._reloadTile(+t, "reloading");
            }
          }
          _reloadTile(t, n) {
            const u = this._tiles[t];
            u && (u.state !== "loading" && (u.state = n), this._loadTile(u, this._tileLoaded.bind(this, u, t, n)));
          }
          _tileLoaded(t, n, u, d) {
            if (d) if (t.state = "errored", d.status !== 404) this._source.fire(new r.y(d, { tile: t }));
            else {
              if (this._source.fire(new r.z("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id, tile: t })), !(t.tileID.key in this._loadedParentTiles)) return;
              if (this._source.type === "raster-dem" && this.usedForTerrain && this.map.painter.terrain) {
                const _ = this.map.painter.terrain;
                this.update(this.transform, _.getScaledDemTileSize(), !0), _.resetTileLookupCache(this.id);
              } else this.update(this.transform);
            }
            else t.timeAdded = r.q.now(), u === "expired" && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(n, t), this._source.type === "raster-dem" && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new r.z("data", { dataType: "source", tile: t, coord: t.tileID, sourceCacheId: this.id }));
          }
          _backfillDEM(t) {
            const n = this.getRenderableIds();
            for (let d = 0; d < n.length; d++) {
              const _ = n[d];
              if (t.neighboringTiles && t.neighboringTiles[_]) {
                const v = this.getTileByID(_);
                u(t, v), u(v, t);
              }
            }
            function u(d, _) {
              if (!d.dem || d.dem.borderReady) return;
              d.needsHillshadePrepare = !0, d.needsDEMTextureUpload = !0;
              let v = _.tileID.canonical.x - d.tileID.canonical.x;
              const L = _.tileID.canonical.y - d.tileID.canonical.y, G = Math.pow(2, d.tileID.canonical.z), X = _.tileID.key;
              v === 0 && L === 0 || Math.abs(L) > 1 || (Math.abs(v) > 1 && (Math.abs(v + G) === 1 ? v += G : Math.abs(v - G) === 1 && (v -= G)), _.dem && d.dem && (d.dem.backfillBorder(_.dem, v, L), d.neighboringTiles && d.neighboringTiles[X] && (d.neighboringTiles[X].backfilled = !0)));
            }
          }
          getTile(t) {
            return this.getTileByID(t.key);
          }
          getTileByID(t) {
            return this._tiles[t];
          }
          _retainLoadedChildren(t, n, u, d) {
            for (const _ in this._tiles) {
              let v = this._tiles[_];
              if (d[_] || !v.hasData() || v.tileID.overscaledZ <= n || v.tileID.overscaledZ > u) continue;
              let L = v.tileID;
              for (; v && v.tileID.overscaledZ > n + 1; ) {
                const X = v.tileID.scaledTo(v.tileID.overscaledZ - 1);
                v = this._tiles[X.key], v && v.hasData() && (L = X);
              }
              let G = L;
              for (; G.overscaledZ > n; ) if (G = G.scaledTo(G.overscaledZ - 1), t[G.key]) {
                d[L.key] = L;
                break;
              }
            }
          }
          findLoadedParent(t, n) {
            if (t.key in this._loadedParentTiles) {
              const u = this._loadedParentTiles[t.key];
              return u && u.tileID.overscaledZ >= n ? u : null;
            }
            for (let u = t.overscaledZ - 1; u >= n; u--) {
              const d = t.scaledTo(u), _ = this._getLoadedTile(d);
              if (_) return _;
            }
          }
          _getLoadedTile(t) {
            const n = this._tiles[t.key];
            return n && n.hasData() ? n : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key);
          }
          updateCacheSize(t, n) {
            n = n || this._source.tileSize;
            const u = Math.ceil(t.width / n) + 1, d = Math.ceil(t.height / n) + 1, _ = Math.floor(u * d * 5), v = typeof this._minTileCacheSize == "number" ? Math.max(this._minTileCacheSize, _) : _, L = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, v) : v;
            this._cache.setMaxSize(L);
          }
          handleWrapJump(t) {
            const n = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
            if (this._prevLng = t, n) {
              const u = {};
              for (const d in this._tiles) {
                const _ = this._tiles[d];
                _.tileID = _.tileID.unwrapTo(_.tileID.wrap + n), u[_.tileID.key] = _;
              }
              this._tiles = u;
              for (const d in this._timers) clearTimeout(this._timers[d]), delete this._timers[d];
              for (const d in this._tiles) this._setTileReloadTimer(+d, this._tiles[d]);
            }
          }
          update(t, n, u, d) {
            if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage || this.usedForTerrain && !u) return;
            this.updateCacheSize(t, n), this.transform.projection.name !== "globe" && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
            const _ = this._source.type === "batched-model";
            let v, L = this._source.maxzoom;
            const G = this.map && this.map.painter ? this.map.painter._terrain : null;
            if (G && G.sourceCache === this && G.attenuationRange()) {
              const ae = G.attenuationRange()[0], oe = Math.floor(ae) - Math.log2(G.getDemUpscale());
              L > oe && (L = oe);
            }
            if (this.used || this.usedForTerrain) {
              if (this._source.tileID) v = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((ae) => new r.aG(ae.canonical.z, ae.wrap, ae.canonical.z, ae.canonical.x, ae.canonical.y));
              else if (this.tileCoverLift !== 0) {
                const ae = t.clone();
                ae.tileCoverLift = this.tileCoverLift, v = ae.coveringTiles({ tileSize: n || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: L, roundZoom: this._source.roundZoom && !u, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: _ }), this._source.minzoom <= 1 && t.projection.name === "globe" && (v.push(new r.aG(1, 0, 1, 0, 0)), v.push(new r.aG(1, 0, 1, 1, 0)), v.push(new r.aG(1, 0, 1, 0, 1)), v.push(new r.aG(1, 0, 1, 1, 1)));
              } else if (v = t.coveringTiles({ tileSize: n || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: L, roundZoom: this._source.roundZoom && !u, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: _ }), this._source.hasTile) {
                const ae = this._source.hasTile.bind(this._source);
                v = v.filter((oe) => ae(oe));
              }
            } else v = [];
            if (v.length > 0 && this.castsShadows && d && this.transform.projection.name !== "globe" && !this.usedForTerrain && !qo(this._source.type)) {
              const ae = t.coveringZoomLevel({ tileSize: n || this._source.tileSize, roundZoom: this._source.roundZoom && !u }), oe = Math.min(ae, this._source.maxzoom);
              if (_) {
                const pe = t.extendTileCover(v, oe);
                for (const Be of pe) v.push(Be);
              } else {
                const pe = t.extendTileCover(v, oe, d);
                for (const Be of pe) this._shadowCasterTiles[Be.key] = !0, v.push(Be);
              }
            }
            const X = this._updateRetainedTiles(v);
            if (qo(this._source.type) && v.length !== 0) {
              const ae = {}, oe = {}, pe = Object.keys(X);
              for (const Re of pe) {
                const Ge = X[Re], Ve = this._tiles[Re];
                if (!Ve || Ve.fadeEndTime && Ve.fadeEndTime <= r.q.now()) continue;
                const et = this.findLoadedParent(Ge, Math.max(Ge.overscaledZ - Xa.maxOverzooming, this._source.minzoom));
                et && (this._addTile(et.tileID), ae[et.tileID.key] = et.tileID), oe[Re] = Ge;
              }
              const Be = v[v.length - 1].overscaledZ;
              for (const Re in this._tiles) {
                const Ge = this._tiles[Re];
                if (X[Re] || !Ge.hasData()) continue;
                let Ve = Ge.tileID;
                for (; Ve.overscaledZ > Be; ) {
                  Ve = Ve.scaledTo(Ve.overscaledZ - 1);
                  const et = this._tiles[Ve.key];
                  if (et && et.hasData() && oe[Ve.key]) {
                    X[Re] = Ge.tileID;
                    break;
                  }
                }
              }
              for (const Re in ae) X[Re] || (this._coveredTiles[Re] = !0, X[Re] = ae[Re]);
            }
            for (const ae in X) this._tiles[ae].clearFadeHold();
            const K = r.bk(this._tiles, X);
            for (const ae of K) {
              const oe = this._tiles[ae];
              oe.hasSymbolBuckets && !oe.holdingForFade() ? oe.setHoldDuration(this.map._fadeDuration) : oe.hasSymbolBuckets && !oe.symbolFadeFinished() || this._removeTile(+ae);
            }
            this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
          }
          releaseSymbolFadeTiles() {
            for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(+t);
          }
          _updateRetainedTiles(t) {
            const n = {};
            if (t.length === 0) return n;
            const u = {}, d = t.reduce((X, K) => Math.min(X, K.overscaledZ), 1 / 0), _ = t[0].overscaledZ, v = Math.max(_ - Xa.maxOverzooming, this._source.minzoom), L = Math.max(_ + Xa.maxUnderzooming, this._source.minzoom), G = {};
            for (const X of t) {
              const K = this._addTile(X);
              n[X.key] = X, K.hasData() || d < this._source.maxzoom && (G[X.key] = X);
            }
            this._retainLoadedChildren(G, d, L, n);
            for (const X of t) {
              let K = this._tiles[X.key];
              if (K.hasData()) continue;
              if (X.canonical.z >= this._source.maxzoom) {
                const oe = X.children(this._source.maxzoom)[0], pe = this.getTile(oe);
                if (pe && pe.hasData()) {
                  n[oe.key] = oe;
                  continue;
                }
              } else {
                const oe = X.children(this._source.maxzoom);
                if (n[oe[0].key] && n[oe[1].key] && n[oe[2].key] && n[oe[3].key]) continue;
              }
              let ae = K.wasRequested();
              for (let oe = X.overscaledZ - 1; oe >= v; --oe) {
                const pe = X.scaledTo(oe);
                if (u[pe.key] || (u[pe.key] = !0, K = this.getTile(pe), !K && ae && (K = this._addTile(pe)), K && (n[pe.key] = pe, ae = K.wasRequested(), K.hasData()))) break;
              }
            }
            return n;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t in this._tiles) {
              const n = [];
              let u, d = this._tiles[t].tileID;
              for (; d.overscaledZ > 0; ) {
                if (d.key in this._loadedParentTiles) {
                  u = this._loadedParentTiles[d.key];
                  break;
                }
                n.push(d.key);
                const _ = d.scaledTo(d.overscaledZ - 1);
                if (u = this._getLoadedTile(_), u) break;
                d = _;
              }
              for (const _ of n) this._loadedParentTiles[_] = u;
            }
          }
          _addTile(t) {
            let n = this._tiles[t.key];
            if (n) return n.isExtraShadowCaster !== !0 || this._shadowCasterTiles[t.key] || this._reloadTile(t.key, "reloading"), n;
            n = this._cache.getAndRemove(t), n && (this._setTileReloadTimer(t.key, n), n.tileID = t, this._state.initializeTileState(n, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, n)));
            const u = !!n;
            if (!u) {
              const d = this.map ? this.map.painter : null, _ = this._source.tileSize * t.overscaleFactor();
              n = this._source.type === "raster-array" ? new ds(t, _, this.transform.tileZoom, d, this._isRaster) : new Zo(t, _, this.transform.tileZoom, d, this._isRaster), this._loadTile(n, this._tileLoaded.bind(this, n, t.key, n.state));
            }
            return n ? (n.uses++, this._tiles[t.key] = n, u || this._source.fire(new r.z("dataloading", { tile: n, coord: n.tileID, dataType: "source" })), n) : null;
          }
          _setTileReloadTimer(t, n) {
            t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
            const u = n.getExpiryTimeout();
            u && (this._timers[t] = setTimeout(() => {
              this._reloadTile(t, "expired"), delete this._timers[t];
            }, u));
          }
          _removeTile(t) {
            const n = this._tiles[t];
            n && (n.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), n.uses > 0 || (n.hasData() && n.state !== "reloading" || n.state === "empty" ? this._cache.add(n.tileID, n, n.getExpiryTimeout()) : (n.aborted = !0, this._abortTile(n), this._unloadTile(n))));
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const t in this._tiles) this._removeTile(+t);
            this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
          }
          tilesIn(t, n, u) {
            const d = [], _ = this.transform;
            if (!_) return d;
            const v = _.projection.name === "globe", L = r.at(_.center.lng);
            for (const G in this._tiles) {
              const X = this._tiles[G];
              if (u && X.clearQueryDebugViz(), X.holdingForFade()) continue;
              let K;
              if (v) {
                const ae = X.tileID.canonical;
                if (ae.z === 0) {
                  const oe = [Math.abs(r.aw(L, ...li(ae, -1)) - L), Math.abs(r.aw(L, ...li(ae, 1)) - L)];
                  K = [0, 2 * oe.indexOf(Math.min(...oe)) - 1];
                } else {
                  const oe = [Math.abs(r.aw(L, ...li(ae, -1)) - L), Math.abs(r.aw(L, ...li(ae, 0)) - L), Math.abs(r.aw(L, ...li(ae, 1)) - L)];
                  K = [oe.indexOf(Math.min(...oe)) - 1];
                }
              } else K = [0];
              for (const ae of K) {
                const oe = t.containsTile(X, _, n, ae);
                oe && d.push(oe);
              }
            }
            return d;
          }
          getShadowCasterCoordinates() {
            return this._getRenderableCoordinates(!1, !0);
          }
          getVisibleCoordinates(t) {
            return this._getRenderableCoordinates(t);
          }
          _getRenderableCoordinates(t, n) {
            const u = this.getRenderableIds(t, n).map((_) => this._tiles[_].tileID), d = this.transform.projection.name === "globe";
            for (const _ of u) _.projMatrix = this.transform.calculateProjMatrix(_.toUnwrapped()), _.expandedProjMatrix = d ? this.transform.calculateProjMatrix(_.toUnwrapped(), !1, !0) : _.projMatrix;
            return u;
          }
          sortCoordinatesByDistance(t) {
            const n = t.slice(), u = this.transform._camera.position, d = this.transform._camera.forward(), _ = {};
            for (const v of n) {
              const L = 1 / (1 << v.canonical.z);
              _[v.key] = ((v.canonical.x + 0.5) * L + v.wrap - u[0]) * d[0] + ((v.canonical.y + 0.5) * L - u[1]) * d[1] - u[2] * d[2];
            }
            return n.sort((v, L) => _[v.key] - _[L.key]), n;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (qo(this._source.type)) for (const t in this._tiles) {
              const n = this._tiles[t];
              if (n.fadeEndTime !== void 0 && n.fadeEndTime >= r.q.now()) return !0;
            }
            return !1;
          }
          setFeatureState(t, n, u) {
            this._state.updateState(t = t || "_geojsonTileLayer", n, u);
          }
          removeFeatureState(t, n, u) {
            this._state.removeFeatureState(t = t || "_geojsonTileLayer", n, u);
          }
          getFeatureState(t, n) {
            return this._state.getState(t = t || "_geojsonTileLayer", n);
          }
          setDependencies(t, n, u) {
            const d = this._tiles[t];
            d && d.setDependencies(n, u);
          }
          reloadTilesForDependencies(t, n) {
            for (const u in this._tiles) this._tiles[u].hasDependency(t, n) && this._reloadTile(+u, "reloading");
            this._cache.filter((u) => !u.hasDependency(t, n));
          }
          _preloadTiles(t, n) {
            if (!this._sourceLoaded) {
              const G = () => {
                this._sourceLoaded && (this._source.off("data", G), this._preloadTiles(t, n));
              };
              return void this._source.on("data", G);
            }
            const u = /* @__PURE__ */ new Map(), d = Array.isArray(t) ? t : [t], _ = this.map.painter.terrain, v = this.usedForTerrain && _ ? _.getScaledDemTileSize() : this._source.tileSize;
            for (const G of d) {
              const X = G.coveringTiles({ tileSize: v, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
              for (const K of X) u.set(K.key, K);
              this.usedForTerrain && G.updateElevation(!1);
            }
            const L = Array.from(u.values());
            r.bl(L, (G, X) => {
              const K = new Zo(G, this._source.tileSize * G.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
              this._loadTile(K, (ae) => {
                this._source.type === "raster-dem" && K.dem && this._backfillDEM(K), X(ae, K);
              });
            }, n);
          }
        }
        function Xi(l, t) {
          const n = Math.abs(2 * l.wrap) - +(l.wrap < 0), u = Math.abs(2 * t.wrap) - +(t.wrap < 0);
          return l.overscaledZ - t.overscaledZ || u - n || t.canonical.y - l.canonical.y || t.canonical.x - l.canonical.x;
        }
        function qo(l) {
          return l === "raster" || l === "image" || l === "video" || l === "custom";
        }
        function li(l, t) {
          const n = 1 << l.z;
          return [l.x / n + t, (l.x + 1) / n + t];
        }
        Xa.maxOverzooming = 10, Xa.maxUnderzooming = 3;
        class ps {
          constructor(t) {
            this.style = t, this.layersGotHidden = !1, this.layers = [];
          }
          processLayersChanged() {
            this.layers = [];
            const t = !1, n = !1;
            for (const u in this.style._mergedLayers) {
              const d = this.style._mergedLayers[u];
              if (d.type === "fill-extrusion") this.layers.push({ layer: d, visible: t, visibilityChanged: n });
              else if (d.type === "model") {
                const _ = this.style.getLayerSource(d);
                _ && _.type === "batched-model" && this.layers.push({ layer: d, visible: t, visibilityChanged: n });
              }
            }
          }
          onNewFrame(t) {
            this.layersGotHidden = !1;
            for (const n of this.layers) {
              const u = n.layer;
              let d = !1;
              u.type === "fill-extrusion" ? d = !u.isHidden(t) && u.paint.get("fill-extrusion-opacity") > 0 : u.type === "model" && (d = !u.isHidden(t) && u.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !d && n.visible, n.visible = d;
            }
          }
          updateZOffset(t, n) {
            this.currentBuildingBuckets = [];
            for (const d of this.layers) {
              const _ = d.layer, v = this.style.getLayerSourceCache(_);
              let L = 1;
              _.type === "fill-extrusion" && (L = d.visible ? _.paint.get("fill-extrusion-vertical-scale") : 0);
              let G = v ? v.getTile(n) : null;
              if (!G && v && n.canonical.z > v.getSource().minzoom) {
                let X = n.scaledTo(Math.min(v.getSource().maxzoom, n.overscaledZ - 1));
                for (; X.overscaledZ >= v.getSource().minzoom && (G = v.getTile(X), !G && X.overscaledZ !== 0); ) X = X.scaledTo(X.overscaledZ - 1);
              }
              this.currentBuildingBuckets.push({ bucket: G ? G.getBucket(_) : null, tileID: G ? G.tileID : n, verticalScale: L });
            }
            t.hasAnyZOffset = !1;
            let u = !1;
            for (let d = 0; d < t.symbolInstances.length; d++) {
              const _ = t.symbolInstances.get(d), v = _.zOffset, L = this._getHeightAtTileOffset(n, _.tileAnchorX, _.tileAnchorY);
              _.zOffset = L !== Number.NEGATIVE_INFINITY ? L : v, u || v === _.zOffset || (u = !0), t.hasAnyZOffset || _.zOffset === 0 || (t.hasAnyZOffset = !0);
            }
            u && (t.zOffsetBuffersNeedUpload = !0, t.zOffsetSortDirty = !0);
          }
          _mapCoordToOverlappingTile(t, n, u, d) {
            let _ = n, v = u;
            if (t.canonical.z !== d.canonical.z) {
              const L = d.canonical, G = 1 / (1 << t.canonical.z - L.z);
              _ = (n + t.canonical.x * r.ag) * G - L.x * r.ag | 0, v = (u + t.canonical.y * r.ag) * G - L.y * r.ag | 0;
            }
            return { tileX: _, tileY: v };
          }
          _getHeightAtTileOffset(t, n, u) {
            let d, _;
            for (let v = 0; v < this.layers.length; ++v) {
              if (this.layers[v].layer.type !== "fill-extrusion") continue;
              const { bucket: L, tileID: G, verticalScale: X } = this.currentBuildingBuckets[v];
              if (!L) continue;
              const { tileX: K, tileY: ae } = this._mapCoordToOverlappingTile(t, n, u, G), oe = L.getHeightAtTileCoord(K, ae);
              oe && oe.height !== void 0 && (oe.hidden ? d = oe.height : _ = Math.max(oe.height * X, _ || 0));
            }
            if (_ !== void 0) return _;
            for (let v = 0; v < this.layers.length; ++v) {
              const L = this.layers[v];
              if (L.layer.type !== "model" || !L.visible) continue;
              const { bucket: G, tileID: X } = this.currentBuildingBuckets[v];
              if (!G) continue;
              const { tileX: K, tileY: ae } = this._mapCoordToOverlappingTile(t, n, u, X), oe = G.getHeightAtTileCoord(K, ae);
              if (oe && !oe.hidden) return oe.height === void 0 && d !== void 0 ? Math.min(oe.maxHeight, d) * oe.verticalScale : oe.height ? oe.height * oe.verticalScale : Number.NEGATIVE_INFINITY;
            }
            return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
          }
        }
        function Ns(l, t) {
          const n = {};
          for (const u in l) u !== "ref" && (n[u] = l[u]);
          return r.bm.forEach((u) => {
            u in t && (n[u] = t[u]);
          }), n;
        }
        function Us(l) {
          l = l.slice();
          const t = /* @__PURE__ */ Object.create(null);
          for (let n = 0; n < l.length; n++) t[l[n].id] = l[n];
          for (let n = 0; n < l.length; n++) "ref" in l[n] && (l[n] = Ns(l[n], t[l[n].ref]));
          return l;
        }
        const Mi = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setSnow: "setSnow", setRain: "setRain", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport" };
        function Rc(l, t, n) {
          n.push({ command: Mi.addSource, args: [l, t[l]] });
        }
        function js(l, t, n) {
          t.push({ command: Mi.removeSource, args: [l] }), n[l] = !0;
        }
        function Xr(l, t, n, u) {
          js(l, n, u), Rc(l, t, n);
        }
        function nn(l, t, n) {
          let u;
          for (u in l[n]) if (l[n].hasOwnProperty(u) && u !== "data" && !r.bn(l[n][u], t[n][u])) return !1;
          for (u in t[n]) if (t[n].hasOwnProperty(u) && u !== "data" && !r.bn(l[n][u], t[n][u])) return !1;
          return !0;
        }
        function Zi(l, t, n, u, d, _) {
          let v;
          for (v in t = t || {}, l = l || {}) l.hasOwnProperty(v) && (r.bn(l[v], t[v]) || n.push({ command: _, args: [u, v, t[v], d] }));
          for (v in t) t.hasOwnProperty(v) && !l.hasOwnProperty(v) && (r.bn(l[v], t[v]) || n.push({ command: _, args: [u, v, t[v], d] }));
        }
        function la(l) {
          return l.id;
        }
        function $o(l, t) {
          return l[t.id] = t, l;
        }
        class Ji {
          constructor(t, n) {
            this.reset(t, n);
          }
          reset(t, n) {
            this.points = t || [], this._distances = [0];
            for (let u = 1; u < this.points.length; u++) this._distances[u] = this._distances[u - 1] + this.points[u].dist(this.points[u - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(n || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t) {
            if (this.points.length === 1) return this.points[0];
            t = r.aw(t, 0, 1);
            let n = 1, u = this._distances[n];
            const d = t * this.paddedLength + this.padding;
            for (; u < d && n < this._distances.length; ) u = this._distances[++n];
            const _ = n - 1, v = this._distances[_], L = u - v, G = L > 0 ? (d - v) / L : 0;
            return this.points[_].mult(1 - G).add(this.points[n].mult(G));
          }
        }
        class ms {
          constructor(t, n, u) {
            const d = this.boxCells = [], _ = this.circleCells = [];
            this.xCellCount = Math.ceil(t / u), this.yCellCount = Math.ceil(n / u);
            for (let v = 0; v < this.xCellCount * this.yCellCount; v++) d.push([]), _.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = n, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / n, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t, n, u, d, _) {
            this._forEachCell(n, u, d, _, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(n), this.bboxes.push(u), this.bboxes.push(d), this.bboxes.push(_);
          }
          insertCircle(t, n, u, d) {
            this._forEachCell(n - d, u - d, n + d, u + d, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(n), this.circles.push(u), this.circles.push(d);
          }
          _insertBoxCell(t, n, u, d, _, v) {
            this.boxCells[_].push(v);
          }
          _insertCircleCell(t, n, u, d, _, v) {
            this.circleCells[_].push(v);
          }
          _query(t, n, u, d, _, v) {
            if (u < 0 || t > this.width || d < 0 || n > this.height) return !_ && [];
            const L = [];
            if (t <= 0 && n <= 0 && this.width <= u && this.height <= d) {
              if (_) return !0;
              for (let G = 0; G < this.boxKeys.length; G++) L.push({ key: this.boxKeys[G], x1: this.bboxes[4 * G], y1: this.bboxes[4 * G + 1], x2: this.bboxes[4 * G + 2], y2: this.bboxes[4 * G + 3] });
              for (let G = 0; G < this.circleKeys.length; G++) {
                const X = this.circles[3 * G], K = this.circles[3 * G + 1], ae = this.circles[3 * G + 2];
                L.push({ key: this.circleKeys[G], x1: X - ae, y1: K - ae, x2: X + ae, y2: K + ae });
              }
              return v ? L.filter(v) : L;
            }
            return this._forEachCell(t, n, u, d, this._queryCell, L, { hitTest: _, seenUids: { box: {}, circle: {} } }, v), _ ? L.length > 0 : L;
          }
          _queryCircle(t, n, u, d, _) {
            const v = t - u, L = t + u, G = n - u, X = n + u;
            if (L < 0 || v > this.width || X < 0 || G > this.height) return !d && [];
            const K = [];
            return this._forEachCell(v, G, L, X, this._queryCellCircle, K, { hitTest: d, circle: { x: t, y: n, radius: u }, seenUids: { box: {}, circle: {} } }, _), d ? K.length > 0 : K;
          }
          query(t, n, u, d, _) {
            return this._query(t, n, u, d, !1, _);
          }
          hitTest(t, n, u, d, _) {
            return this._query(t, n, u, d, !0, _);
          }
          hitTestCircle(t, n, u, d) {
            return this._queryCircle(t, n, u, !0, d);
          }
          _queryCell(t, n, u, d, _, v, L, G) {
            const X = L.seenUids, K = this.boxCells[_];
            if (K !== null) {
              const oe = this.bboxes;
              for (const pe of K) if (!X.box[pe]) {
                X.box[pe] = !0;
                const Be = 4 * pe;
                if (t <= oe[Be + 2] && n <= oe[Be + 3] && u >= oe[Be + 0] && d >= oe[Be + 1] && (!G || G(this.boxKeys[pe]))) {
                  if (L.hitTest) return v.push(!0), !0;
                  v.push({ key: this.boxKeys[pe], x1: oe[Be], y1: oe[Be + 1], x2: oe[Be + 2], y2: oe[Be + 3] });
                }
              }
            }
            const ae = this.circleCells[_];
            if (ae !== null) {
              const oe = this.circles;
              for (const pe of ae) if (!X.circle[pe]) {
                X.circle[pe] = !0;
                const Be = 3 * pe;
                if (this._circleAndRectCollide(oe[Be], oe[Be + 1], oe[Be + 2], t, n, u, d) && (!G || G(this.circleKeys[pe]))) {
                  if (L.hitTest) return v.push(!0), !0;
                  {
                    const Re = oe[Be], Ge = oe[Be + 1], Ve = oe[Be + 2];
                    v.push({ key: this.circleKeys[pe], x1: Re - Ve, y1: Ge - Ve, x2: Re + Ve, y2: Ge + Ve });
                  }
                }
              }
            }
          }
          _queryCellCircle(t, n, u, d, _, v, L, G) {
            const X = L.circle, K = L.seenUids, ae = this.boxCells[_];
            if (ae !== null) {
              const pe = this.bboxes;
              for (const Be of ae) if (!K.box[Be]) {
                K.box[Be] = !0;
                const Re = 4 * Be;
                if (this._circleAndRectCollide(X.x, X.y, X.radius, pe[Re + 0], pe[Re + 1], pe[Re + 2], pe[Re + 3]) && (!G || G(this.boxKeys[Be]))) return v.push(!0), !0;
              }
            }
            const oe = this.circleCells[_];
            if (oe !== null) {
              const pe = this.circles;
              for (const Be of oe) if (!K.circle[Be]) {
                K.circle[Be] = !0;
                const Re = 3 * Be;
                if (this._circlesCollide(pe[Re], pe[Re + 1], pe[Re + 2], X.x, X.y, X.radius) && (!G || G(this.circleKeys[Be]))) return v.push(!0), !0;
              }
            }
          }
          _forEachCell(t, n, u, d, _, v, L, G) {
            const X = this._convertToXCellCoord(t), K = this._convertToYCellCoord(n), ae = this._convertToXCellCoord(u), oe = this._convertToYCellCoord(d);
            for (let pe = X; pe <= ae; pe++) for (let Be = K; Be <= oe; Be++) if (_.call(this, t, n, u, d, this.xCellCount * Be + pe, v, L, G)) return;
          }
          _convertToXCellCoord(t) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));
          }
          _convertToYCellCoord(t) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));
          }
          _circlesCollide(t, n, u, d, _, v) {
            const L = d - t, G = _ - n, X = u + v;
            return X * X > L * L + G * G;
          }
          _circleAndRectCollide(t, n, u, d, _, v, L) {
            const G = (v - d) / 2, X = Math.abs(t - (d + G));
            if (X > G + u) return !1;
            const K = (L - _) / 2, ae = Math.abs(n - (_ + K));
            if (ae > K + u) return !1;
            if (X <= G || ae <= K) return !0;
            const oe = X - G, pe = ae - K;
            return oe * oe + pe * pe <= u * u;
          }
        }
        const Ya = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, Xo = Math.tan(85 * Math.PI / 180);
        function Kn(l, t, n, u, d, _, v) {
          const L = r.ab.mat4.create();
          if (n) if (_.name === "globe") {
            const G = r.bo(d, t);
            r.ab.mat4.multiply(L, L, G);
          } else {
            const G = r.ab.mat2.invert([], v);
            L[0] = G[0], L[1] = G[1], L[4] = G[2], L[5] = G[3], u || r.ab.mat4.rotateZ(L, L, d.angle);
          }
          else r.ab.mat4.multiply(L, d.labelPlaneMatrix, l);
          return L;
        }
        function zn(l, t, n, u, d, _, v) {
          const L = Kn(l, t, n, u, d, _, v);
          return _.name === "globe" && n || (L[2] = L[6] = L[10] = L[14] = 0), L;
        }
        function Ah(l, t, n, u, d, _, v) {
          if (n) {
            if (_.name === "globe") {
              const L = Kn(l, t, n, u, d, _, v);
              return r.ab.mat4.invert(L, L), r.ab.mat4.multiply(L, l, L), L;
            }
            {
              const L = r.ab.mat4.clone(l), G = r.ab.mat4.identity([]);
              return G[0] = v[0], G[1] = v[1], G[4] = v[2], G[5] = v[3], r.ab.mat4.multiply(L, L, G), u || r.ab.mat4.rotateZ(L, L, -d.angle), L;
            }
          }
          return d.glCoordMatrix;
        }
        function Ta(l, t, n, u) {
          const d = [l, t, n, 1];
          n ? r.ab.vec4.transformMat4(d, d, u) : Hn(d, d, u);
          const _ = d[3];
          return d[0] /= _, d[1] /= _, d[2] /= _, d;
        }
        function gl(l, t) {
          return Math.min(0.5 + l / t * 0.5, 1.5);
        }
        function yl(l, t) {
          const n = l[0] / l[3], u = l[1] / l[3];
          return n >= -t[0] && n <= t[0] && u >= -t[1] && u <= t[1];
        }
        function Hu(l, t, n, u, d, _, v, L, G, X) {
          const K = n.transform, ae = u ? l.textSizeData : l.iconSizeData, oe = r.bp(ae, n.transform.zoom), pe = K.projection.name === "globe", Be = [256 / n.width * 2 + 1, 256 / n.height * 2 + 1], Re = u ? l.text.dynamicLayoutVertexArray : l.icon.dynamicLayoutVertexArray;
          Re.clear();
          let Ge = null;
          pe && (Ge = u ? l.text.globeExtVertexArray : l.icon.globeExtVertexArray);
          const Ve = l.lineVertexArray, et = u ? l.text.placedSymbolArray : l.icon.placedSymbolArray, ut = n.transform.width / n.transform.height;
          let st, xt = !1;
          for (let mt = 0; mt < et.length; mt++) {
            const _t = et.get(mt), { numGlyphs: dt, writingMode: gt } = _t;
            if (gt !== r.bq.vertical || xt || st === r.bq.horizontal || (xt = !0), st = gt, (_t.hidden || gt === r.bq.vertical) && !xt) {
              An(dt, Re);
              continue;
            }
            xt = !1;
            const Rt = new r.P(_t.tileAnchorX, _t.tileAnchorY);
            let { x: Jt, y: Vt, z: or } = K.projection.projectTilePoint(Rt.x, Rt.y, X.canonical);
            if (G) {
              const [hr, br, Cr] = G(Rt);
              Jt += hr, Vt += br, or += Cr;
            }
            const sr = [Jt, Vt, or, 1];
            if (r.ab.vec4.transformMat4(sr, sr, t), !yl(sr, Be)) {
              An(dt, Re);
              continue;
            }
            const Bt = sr[3], rr = gl(n.transform.getCameraToCenterDistance(K.projection), Bt), gr = r.br(ae, oe, _t), Ut = v ? gr / rr : gr * rr, dr = Ta(Jt, Vt, or, d);
            if (dr[3] <= 0) {
              An(dt, Re);
              continue;
            }
            let ir = {};
            const Tr = v ? null : G, mr = ho(_t, Ut, !1, L, t, d, _, l.glyphOffsetArray, Ve, Re, Ge, dr, Rt, ir, ut, Tr, K.projection, X, v);
            xt = mr.useVertical, Tr && mr.needsFlipping && (ir = {}), (mr.notEnoughRoom || xt || mr.needsFlipping && ho(_t, Ut, !0, L, t, d, _, l.glyphOffsetArray, Ve, Re, Ge, dr, Rt, ir, ut, Tr, K.projection, X, v).notEnoughRoom) && An(dt, Re);
          }
          u ? (l.text.dynamicLayoutVertexBuffer.updateData(Re), Ge && l.text.globeExtVertexBuffer && l.text.globeExtVertexBuffer.updateData(Ge)) : (l.icon.dynamicLayoutVertexBuffer.updateData(Re), Ge && l.icon.globeExtVertexBuffer && l.icon.globeExtVertexBuffer.updateData(Ge));
        }
        function Eo(l, t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re) {
          const { lineStartIndex: Ge, glyphStartIndex: Ve, segment: et } = L, ut = Ve + L.numGlyphs, st = Ge + L.lineLength, xt = t.getoffsetX(Ve), mt = t.getoffsetX(ut - 1), _t = So(l * xt, n, u, d, _, v, et, Ge, st, G, X, K, ae, oe, !0, pe, Be, Re);
          if (!_t) return null;
          const dt = So(l * mt, n, u, d, _, v, et, Ge, st, G, X, K, ae, oe, !0, pe, Be, Re);
          return dt ? { first: _t, last: dt } : null;
        }
        function pa(l, t, n, u) {
          return l === r.bq.horizontal && Math.abs(u) > Math.abs(n) ? { useVertical: !0 } : l === r.bq.vertical ? u > 0 ? { needsFlipping: !0 } : null : t !== Ya.unknown && function(d, _) {
            return d === 0 || Math.abs(_ / d) > Xo;
          }(n, u) ? t === Ya.flipRequired ? { needsFlipping: !0 } : null : n < 0 ? { needsFlipping: !0 } : null;
        }
        function ho(l, t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re, Ge, Ve, et) {
          const ut = t / 24, st = l.lineOffsetX * ut, xt = l.lineOffsetY * ut, { lineStartIndex: mt, glyphStartIndex: _t, numGlyphs: dt, segment: gt, writingMode: Rt, flipState: Jt } = l, Vt = mt + l.lineLength, or = (sr) => {
            if (K) {
              const [Ut, dr, ir] = sr.up, Tr = X.length;
              r.bs(K, Tr + 0, Ut, dr, ir), r.bs(K, Tr + 1, Ut, dr, ir), r.bs(K, Tr + 2, Ut, dr, ir), r.bs(K, Tr + 3, Ut, dr, ir);
            }
            const [Bt, rr, gr] = sr.point;
            r.bt(X, Bt, rr, gr, sr.angle);
          };
          if (dt > 1) {
            const sr = Eo(ut, L, st, xt, n, ae, oe, l, G, _, pe, Re, !1, Ge, Ve, et);
            if (!sr) return { notEnoughRoom: !0 };
            if (u && !n) {
              let [Bt, rr, gr] = sr.first.point, [Ut, dr, ir] = sr.last.point;
              [Bt, rr] = Ta(Bt, rr, gr, v), [Ut, dr] = Ta(Ut, dr, ir, v);
              const Tr = pa(Rt, Jt, (Ut - Bt) * Be, dr - rr);
              if (l.flipState = Tr && Tr.needsFlipping ? Ya.flipRequired : Ya.flipNotRequired, Tr) return Tr;
            }
            or(sr.first);
            for (let Bt = _t + 1; Bt < _t + dt - 1; Bt++) {
              const rr = So(ut * L.getoffsetX(Bt), st, xt, n, ae, oe, gt, mt, Vt, G, _, pe, Re, !1, !1, Ge, Ve, et);
              if (!rr) return X.length -= 4 * (Bt - _t), { notEnoughRoom: !0 };
              or(rr);
            }
            or(sr.last);
          } else {
            if (u && !n) {
              const Bt = Ta(oe.x, oe.y, 0, d), rr = mt + gt + 1, gr = new r.P(G.getx(rr), G.gety(rr)), Ut = Ta(gr.x, gr.y, 0, d), dr = Ut[3] > 0 ? Ut : su(oe, gr, Bt, 1, d, void 0, Ge, Ve.canonical), ir = pa(Rt, Jt, (dr[0] - Bt[0]) * Be, dr[1] - Bt[1]);
              if (l.flipState = ir && ir.needsFlipping ? Ya.flipRequired : Ya.flipNotRequired, ir) return ir;
            }
            const sr = So(ut * L.getoffsetX(_t), st, xt, n, ae, oe, gt, mt, Vt, G, _, pe, Re, !1, !1, Ge, Ve, et);
            if (!sr) return { notEnoughRoom: !0 };
            or(sr);
          }
          return {};
        }
        function ma(l, t, n, u, d) {
          const { x: _, y: v, z: L } = u.projectTilePoint(l.x, l.y, t);
          if (!d) return Ta(_, v, L, n);
          const [G, X, K] = d(l);
          return Ta(_ + G, v + X, L + K, n);
        }
        function su(l, t, n, u, d, _, v, L) {
          const G = ma(l.sub(t)._unit()._add(l), L, d, v, _);
          return r.ab.vec3.sub(G, n, G), r.ab.vec3.normalize(G, G), r.ab.vec3.scaleAndAdd(G, n, G, u);
        }
        function So(l, t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re, Ge, Ve) {
          const et = u ? l - t : l + t;
          let ut = et > 0 ? 1 : -1, st = 0;
          u && (ut *= -1, st = Math.PI), ut < 0 && (st += Math.PI);
          let xt = L + v + (ut > 0 ? 0 : 1) | 0, mt = d, _t = d, dt = 0, gt = 0;
          const Rt = Math.abs(et), Jt = [], Vt = [];
          let or = _, sr = or;
          const Bt = () => su(sr, or, _t, Rt - dt + 1, K, oe, Re, Ge.canonical);
          for (; dt + gt <= Rt; ) {
            if (xt += ut, xt < L || xt >= G) return null;
            if (_t = mt, sr = or, Jt.push(_t), pe && Vt.push(sr), or = new r.P(X.getx(xt), X.gety(xt)), mt = ae[xt], !mt) {
              const br = ma(or, Ge.canonical, K, Re, oe);
              mt = br[3] > 0 ? ae[xt] = br : Bt();
            }
            dt += gt, gt = r.ab.vec3.distance(_t, mt);
          }
          Be && oe && (ae[xt] && (mt = Bt(), gt = r.ab.vec3.distance(_t, mt)), ae[xt] = mt);
          const rr = (Rt - dt) / gt, gr = or.sub(sr)._mult(rr)._add(sr), Ut = r.ab.vec3.sub([], mt, _t), dr = r.ab.vec3.scaleAndAdd([], _t, Ut, rr);
          let ir = [0, 0, 1], Tr = Ut[0], mr = Ut[1];
          if (Ve && (ir = Re.upVector(Ge.canonical, gr.x, gr.y), ir[0] !== 0 || ir[1] !== 0 || ir[2] !== 1)) {
            const br = [ir[2], 0, -ir[0]], Cr = r.ab.vec3.cross([], ir, br);
            r.ab.vec3.normalize(br, br), r.ab.vec3.normalize(Cr, Cr), Tr = r.ab.vec3.dot(Ut, br), mr = r.ab.vec3.dot(Ut, Cr);
          }
          if (n) {
            const br = r.ab.vec3.cross([], ir, Ut);
            r.ab.vec3.normalize(br, br), r.ab.vec3.scaleAndAdd(dr, dr, br, n * ut);
          }
          const hr = st + Math.atan2(mr, Tr);
          return Jt.push(dr), pe && Vt.push(gr), { point: dr, angle: hr, path: Jt, tilePath: Vt, up: ir };
        }
        function An(l, t) {
          const n = t.length, u = n + 4 * l;
          t.resize(u), t.float32.fill(-1 / 0, 4 * n, 4 * u);
        }
        function Hn(l, t, n) {
          const u = t[0], d = t[1];
          return l[0] = n[0] * u + n[4] * d + n[12], l[1] = n[1] * u + n[5] * d + n[13], l[3] = n[3] * u + n[7] * d + n[15], l;
        }
        const Wn = 100;
        class On {
          constructor(t, n, u = new ms(t.width + 200, t.height + 200, 25), d = new ms(t.width + 200, t.height + 200, 25)) {
            this.transform = t, this.grid = u, this.ignoredGrid = d, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + Wn, this.screenBottomBoundary = t.height + Wn, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.fogState = n;
          }
          placeCollisionBox(t, n, u, d, _, v, L, G) {
            let X = u.projectedAnchorX, K = u.projectedAnchorY, ae = u.projectedAnchorZ;
            const oe = u.elevation, pe = u.tileID, Be = t.getProjection();
            if (oe && pe) {
              const [mt, _t, dt] = Be.upVector(pe.canonical, u.tileAnchorX, u.tileAnchorY), gt = Be.upVectorScale(pe.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
              X += mt * oe * gt, K += _t * oe * gt, ae += dt * oe * gt;
            }
            const Re = this.projectAndGetPerspectiveRatio(L, X, K, ae, u.tileID, Be.name === "globe" || !!oe || this.transform.pitch > 0, Be), Ge = v * Re.perspectiveRatio, Ve = (u.x1 * n + d.x - u.padding) * Ge + Re.point.x, et = (u.y1 * n + d.y - u.padding) * Ge + Re.point.y, ut = (u.x2 * n + d.x + u.padding) * Ge + Re.point.x, st = (u.y2 * n + d.y + u.padding) * Ge + Re.point.y, xt = Re.perspectiveRatio <= 0.55 || Re.occluded;
            return !this.isInsideGrid(Ve, et, ut, st) || !_ && this.grid.hitTest(Ve, et, ut, st, G) || xt ? { box: [], offscreen: !1, occluded: Re.occluded } : { box: [Ve, et, ut, st], offscreen: this.isOffscreen(Ve, et, ut, st), occluded: !1 };
          }
          placeCollisionCircles(t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re) {
            const Ge = [], Ve = this.transform.elevation, et = t.getProjection(), ut = Ve ? Ve.getAtTileOffsetFunc(Re, this.transform.center.lat, this.transform.worldSize, et) : null, st = new r.P(u.tileAnchorX, u.tileAnchorY);
            let { x: xt, y: mt, z: _t } = et.projectTilePoint(st.x, st.y, Re.canonical);
            if (ut) {
              const [gr, Ut, dr] = ut(st);
              xt += gr, mt += Ut, _t += dr;
            }
            const dt = et.name === "globe", gt = this.projectAndGetPerspectiveRatio(L, xt, mt, _t, Re, dt || !!Ve || this.transform.pitch > 0, et), { perspectiveRatio: Rt } = gt, Jt = (ae ? v / Rt : v * Rt) / r.bw, Vt = Ta(xt, mt, _t, G), or = gt.signedDistanceFromCamera > 0 ? Eo(Jt, _, u.lineOffsetX * Jt, u.lineOffsetY * Jt, !1, Vt, st, u, d, G, {}, Ve && !ae ? ut : null, ae && !!Ve, et, Re, ae) : null;
            let sr = !1, Bt = !1, rr = !0;
            if (or && !gt.occluded) {
              const gr = 0.5 * pe * Rt + Be, Ut = new r.P(-100, -100), dr = new r.P(this.screenRightBoundary, this.screenBottomBoundary), ir = new Ji(), { first: Tr, last: mr } = or, hr = Tr.path.length;
              let br = [];
              for (let Zr = hr - 1; Zr >= 1; Zr--) br.push(Tr.path[Zr]);
              for (let Zr = 1; Zr < mr.path.length; Zr++) br.push(mr.path[Zr]);
              const Cr = 2.5 * gr;
              X && (br = br.map(([Zr, mi, ii], oi) => (ut && !dt && (ii = ut(oi < hr - 1 ? Tr.tilePath[hr - 1 - oi] : mr.tilePath[oi - hr + 2])[2]), Ta(Zr, mi, ii, X))), br.some((Zr) => Zr[3] <= 0) && (br = []));
              let Hr = [];
              if (br.length > 0) {
                let Zr = 1 / 0, mi = -1 / 0, ii = 1 / 0, oi = -1 / 0;
                for (const yi of br) Zr = Math.min(Zr, yi[0]), ii = Math.min(ii, yi[1]), mi = Math.max(mi, yi[0]), oi = Math.max(oi, yi[1]);
                mi >= Ut.x && Zr <= dr.x && oi >= Ut.y && ii <= dr.y && (Hr = [br.map((yi) => new r.P(yi[0], yi[1]))], (Zr < Ut.x || mi > dr.x || ii < Ut.y || oi > dr.y) && (Hr = r.bu(Hr, Ut.x, Ut.y, dr.x, dr.y)));
              }
              for (const Zr of Hr) {
                ir.reset(Zr, 0.25 * gr);
                let mi = 0;
                mi = ir.length <= 0.5 * gr ? 1 : Math.ceil(ir.paddedLength / Cr) + 1;
                for (let ii = 0; ii < mi; ii++) {
                  const oi = ii / Math.max(mi - 1, 1), yi = ir.lerp(oi), Ui = yi.x + Wn, tn = yi.y + Wn;
                  Ge.push(Ui, tn, gr, 0);
                  const bn = Ui - gr, $i = tn - gr, xi = Ui + gr, Di = tn + gr;
                  if (rr = rr && this.isOffscreen(bn, $i, xi, Di), Bt = Bt || this.isInsideGrid(bn, $i, xi, Di), !n && this.grid.hitTestCircle(Ui, tn, gr, oe) && (sr = !0, !K)) return { circles: [], offscreen: !1, collisionDetected: sr, occluded: !1 };
                }
              }
            }
            return { circles: !K && sr || !Bt ? [] : Ge, offscreen: rr, collisionDetected: sr, occluded: gt.occluded };
          }
          queryRenderedSymbols(t) {
            if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const n = [];
            let u = 1 / 0, d = 1 / 0, _ = -1 / 0, v = -1 / 0;
            for (const K of t) {
              const ae = new r.P(K.x + Wn, K.y + Wn);
              u = Math.min(u, ae.x), d = Math.min(d, ae.y), _ = Math.max(_, ae.x), v = Math.max(v, ae.y), n.push(ae);
            }
            const L = this.grid.query(u, d, _, v).concat(this.ignoredGrid.query(u, d, _, v)), G = {}, X = {};
            for (const K of L) {
              const ae = K.key;
              if (G[ae.bucketInstanceId] === void 0 && (G[ae.bucketInstanceId] = {}), G[ae.bucketInstanceId][ae.featureIndex]) continue;
              const oe = [new r.P(K.x1, K.y1), new r.P(K.x2, K.y1), new r.P(K.x2, K.y2), new r.P(K.x1, K.y2)];
              r.bv(n, oe) && (G[ae.bucketInstanceId][ae.featureIndex] = !0, X[ae.bucketInstanceId] === void 0 && (X[ae.bucketInstanceId] = []), X[ae.bucketInstanceId].push(ae.featureIndex));
            }
            return X;
          }
          insertCollisionBox(t, n, u, d, _) {
            (n ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: u, featureIndex: d, collisionGroupID: _ }, t[0], t[1], t[2], t[3]);
          }
          insertCollisionCircles(t, n, u, d, _) {
            const v = n ? this.ignoredGrid : this.grid, L = { bucketInstanceId: u, featureIndex: d, collisionGroupID: _ };
            for (let G = 0; G < t.length; G += 4) v.insertCircle(L, t[G], t[G + 1], t[G + 2]);
          }
          projectAndGetPerspectiveRatio(t, n, u, d, _, v, L) {
            const G = [n, u, d, 1];
            let X = !1;
            d || this.transform.pitch > 0 ? (r.ab.vec4.transformMat4(G, G, t), this.fogState && _ && L.name !== "globe" && (X = function(oe, pe, Be, Re, Ge, Ve) {
              const et = Ve.calculateFogTileMatrix(Ge), ut = [pe, Be, Re];
              return r.ab.vec3.transformMat4(ut, ut, et), Pt(oe, r.ab.vec3.length(ut), Ve.pitch, Ve._fov);
            }(this.fogState, n, u, d, _.toUnwrapped(), this.transform) > 0.9)) : Hn(G, G, t);
            const K = G[3];
            return { point: new r.P((G[0] / K + 1) / 2 * this.transform.width + Wn, (-G[1] / K + 1) / 2 * this.transform.height + Wn), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(L) / K * 0.5, 1.5), signedDistanceFromCamera: K, occluded: v && G[2] > K || X };
          }
          isOffscreen(t, n, u, d) {
            return u < Wn || t >= this.screenRightBoundary || d < Wn || n > this.screenBottomBoundary;
          }
          isInsideGrid(t, n, u, d) {
            return u >= 0 && t < this.gridRightBoundary && d >= 0 && n < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t = r.ab.mat4.identity([]);
            return r.ab.mat4.translate(t, t, [-100, -100, 0]), t;
          }
        }
        function _s(l, t, n) {
          const u = t.createTileMatrix(l, l.worldSize, n.toUnwrapped());
          return r.ab.mat4.multiply(new Float32Array(16), l.projMatrix, u);
        }
        function zo(l, t, n) {
          if (t.projection.name === n.projection.name) return l.projMatrix;
          const u = n.clone();
          return u.setProjection(t.projection), _s(u, t.getProjection(), l);
        }
        function gs(l, t, n) {
          return t.name === n.projection.name ? l.projMatrix : _s(n, t, l);
        }
        class vl {
          constructor(t, n, u, d) {
            this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? n : -n))) : d && u ? 1 : 0, this.placed = u;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class Ba {
          constructor(t, n, u, d, _, v = !1) {
            this.text = new vl(t ? t.text : null, n, u, _), this.icon = new vl(t ? t.icon : null, n, d, _), this.clipped = v;
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class lu {
          constructor(t, n, u, d = !1) {
            this.text = t, this.icon = n, this.skipFade = u, this.clipped = d;
          }
        }
        class Yo {
          constructor() {
            this.invProjMatrix = r.ab.mat4.create(), this.viewportMatrix = r.ab.mat4.create(), this.circles = [];
          }
        }
        class ad {
          constructor(t, n, u, d, _) {
            this.bucketInstanceId = t, this.featureIndex = n, this.sourceLayerIndex = u, this.bucketIndex = d, this.tileID = _;
          }
        }
        class Ih {
          constructor(t) {
            this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[t]) {
              const n = ++this.maxGroupID;
              this.collisionGroups[t] = { ID: n, predicate: (u) => u.collisionGroupID === n };
            }
            return this.collisionGroups[t];
          }
        }
        function Fa(l, t, n, u, d) {
          const { horizontalAlign: _, verticalAlign: v } = r.bD(l), L = -(_ - 0.5) * t, G = -(v - 0.5) * n, X = r.bC(l, u);
          return new r.P(L + X[0] * d, G + X[1] * d);
        }
        function Wu(l, t, n, u, d) {
          const _ = new r.P(l, t);
          return n && _._rotate(u ? d : -d), _;
        }
        class Lc {
          constructor(t, n, u, d, _, v) {
            this.transform = t.clone(), this.projection = t.projection.name, this.collisionIndex = new On(this.transform, _), this.buildingIndex = v, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = n, this.retainedQueryData = {}, this.collisionGroups = new Ih(u), this.collisionCircleArrays = {}, this.prevPlacement = d, d && (d.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(t, n, u, d, _ = 1) {
            const v = u.getBucket(n), L = u.latestFeatureIndex;
            if (!v || !L || n.fqid !== v.layerIds[0]) return;
            const G = v.layers[0].layout, X = v.layers[0].paint, K = u.collisionBoxArray, ae = Math.pow(2, this.transform.zoom - u.tileID.overscaledZ), oe = u.tileSize / r.ag, pe = u.tileID.toUnwrapped();
            this.transform.setProjection(v.projection);
            const Be = (Re = u.tileID, Ge = v.getProjection(), Ve = this.transform, Ge.name === this.projection ? Ve.calculateProjMatrix(Re.toUnwrapped()) : _s(Ve, Ge, Re));
            var Re, Ge, Ve;
            const et = G.get("text-pitch-alignment") === "map", ut = G.get("text-rotation-alignment") === "map";
            n.compileFilter(n.options);
            const st = n.dynamicFilter(), xt = n.dynamicFilterNeedsFeature(), mt = this.transform.calculatePixelsToTileUnitsMatrix(u), _t = zn(Be, u.tileID.canonical, et, ut, this.transform, v.getProjection(), mt);
            let dt = null;
            if (et) {
              const gr = Ah(Be, u.tileID.canonical, et, ut, this.transform, v.getProjection(), mt);
              dt = r.ab.mat4.multiply([], this.transform.labelPlaneMatrix, gr);
            }
            let gt = null;
            st && u.latestFeatureIndex && (gt = { unwrappedTileID: pe, dynamicFilter: st, dynamicFilterNeedsFeature: xt }), this.retainedQueryData[v.bucketInstanceId] = new ad(v.bucketInstanceId, L, v.sourceLayerIndex, v.index, u.tileID);
            const [Rt, Jt] = v.layers[0].layout.get("text-size-scale-range"), Vt = r.aw(_, Rt, Jt), [or, sr] = G.get("icon-size-scale-range"), Bt = r.aw(_, or, sr), rr = { bucket: v, layout: G, paint: X, posMatrix: Be, textLabelPlaneMatrix: _t, labelToScreenMatrix: dt, clippingData: gt, scale: ae, textPixelRatio: oe, holdingForFade: u.holdingForFade(), collisionBoxArray: K, partiallyEvaluatedTextSize: r.bp(v.textSizeData, this.transform.zoom, Vt), partiallyEvaluatedIconSize: r.bp(v.iconSizeData, this.transform.zoom, Bt), collisionGroup: this.collisionGroups.get(v.sourceID), latestFeatureIndex: u.latestFeatureIndex };
            if (d) for (const gr of v.sortKeyRanges) {
              const { sortKey: Ut, symbolInstanceStart: dr, symbolInstanceEnd: ir } = gr;
              t.push({ sortKey: Ut, symbolInstanceStart: dr, symbolInstanceEnd: ir, parameters: rr });
            }
            else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: v.symbolInstances.length, parameters: rr });
          }
          attemptAnchorPlacement(t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re, Ge, Ve, et) {
            const { textOffset0: ut, textOffset1: st, crossTileID: xt } = oe, mt = [ut, st], _t = Fa(t, u, d, mt, _), dt = this.collisionIndex.placeCollisionBox(Be, _, n, Wu(_t.x, _t.y, v, L, this.transform.angle), ae, G, X, K.predicate);
            if (Ge) {
              const gt = Be.getSymbolInstanceIconSize(et, this.transform.zoom, oe.placedIconSymbolIndex);
              if (this.collisionIndex.placeCollisionBox(Be, gt, Ge, Wu(_t.x, _t.y, v, L, this.transform.angle), ae, G, X, K.predicate).box.length === 0) return;
            }
            if (dt.box.length > 0) {
              let gt;
              return this.prevPlacement && this.prevPlacement.variableOffsets[xt] && this.prevPlacement.placements[xt] && this.prevPlacement.placements[xt].text && (gt = this.prevPlacement.variableOffsets[xt].anchor), this.variableOffsets[xt] = { textOffset: mt, width: u, height: d, anchor: t, textScale: _, prevAnchor: gt }, this.markUsedJustification(Be, t, oe, Re), Be.allowVerticalPlacement && (this.markUsedOrientation(Be, Re, oe), this.placedOrientations[xt] = Re), { shift: _t, placedGlyphBoxes: dt };
            }
          }
          placeLayerBucketPart(t, n, u, d, _ = 1) {
            const { bucket: v, layout: L, paint: G, posMatrix: X, textLabelPlaneMatrix: K, labelToScreenMatrix: ae, clippingData: oe, textPixelRatio: pe, holdingForFade: Be, collisionBoxArray: Re, partiallyEvaluatedTextSize: Ge, partiallyEvaluatedIconSize: Ve, collisionGroup: et, latestFeatureIndex: ut } = t.parameters, st = L.get("text-optional"), xt = L.get("icon-optional"), mt = L.get("text-allow-overlap"), _t = L.get("icon-allow-overlap"), dt = L.get("text-rotation-alignment") === "map", gt = L.get("text-pitch-alignment") === "map", Rt = L.get("symbol-z-elevate"), Jt = G.get("symbol-z-offset"), Vt = L.get("symbol-elevation-reference") === "sea", [or, sr] = L.get("text-size-scale-range"), [Bt, rr] = L.get("icon-size-scale-range"), gr = r.aw(_, or, sr), Ut = r.aw(_, Bt, rr);
            this.transform.setProjection(v.projection);
            let dr = mt && (_t || !v.hasIconData() || xt), ir = _t && (mt || !v.hasTextData() || st);
            const Tr = !Jt.isConstant();
            !v.collisionArrays && Re && v.deserializeCollisionBoxes(Re), u && d && v.updateCollisionDebugBuffers(this.transform.zoom, Re, gr, Ut);
            const mr = (hr, br, Cr) => {
              const { crossTileID: Hr, numVerticalGlyphVertices: Zr } = hr;
              let mi = null;
              if (oe && oe.dynamicFilterNeedsFeature || Tr) {
                const hn = this.retainedQueryData[v.bucketInstanceId];
                mi = ut.loadFeature({ featureIndex: hr.featureIndex, bucketIndex: hn.bucketIndex, sourceLayerIndex: hn.sourceLayerIndex, layoutVertexArrayOffset: 0 });
              }
              if (oe && !(0, oe.dynamicFilter)({ zoom: this.transform.zoom, pitch: this.transform.pitch }, mi, this.retainedQueryData[v.bucketInstanceId].tileID.canonical, new r.P(hr.tileAnchorX, hr.tileAnchorY), this.transform.calculateDistanceTileData(oe.unwrappedTileID))) return this.placements[Hr] = new lu(!1, !1, !1, !0), void n.add(Hr);
              const ii = Jt.evaluate(mi, {});
              if (n.has(Hr)) return;
              if (Be) return void (this.placements[Hr] = new lu(!1, !1, !1));
              let oi = !1, yi = !1, Ui = !0, tn = !1, bn = !1, $i = null, xi = { box: null, offscreen: null, occluded: null }, Di = { box: null, offscreen: null, occluded: null }, Yr = null, Fi = null, Ki = null, Qi = 0, Mn = 0, Pn = 0;
              Cr.textFeatureIndex ? Qi = Cr.textFeatureIndex : hr.useRuntimeCollisionCircles && (Qi = hr.featureIndex), Cr.verticalTextFeatureIndex && (Mn = Cr.verticalTextFeatureIndex);
              const Zn = (hn) => {
                hn.tileID = this.retainedQueryData[v.bucketInstanceId].tileID;
                const ln = this.transform.elevation;
                hn.elevation = Vt ? ii : ii + (ln ? ln.getAtTileOffset(hn.tileID, hn.tileAnchorX, hn.tileAnchorY) : 0), hn.elevation += hr.zOffset;
              }, jn = Cr.textBox;
              if (jn) {
                Zn(jn);
                const hn = (Vi) => {
                  let Rn = r.bq.horizontal;
                  if (v.allowVerticalPlacement && !Vi && this.prevPlacement) {
                    const ia = this.prevPlacement.placedOrientations[Hr];
                    ia && (this.placedOrientations[Hr] = ia, Rn = ia, this.markUsedOrientation(v, Rn, hr));
                  }
                  return Rn;
                }, ln = (Vi, Rn) => {
                  if (v.allowVerticalPlacement && Zr > 0 && Cr.verticalTextBox) {
                    for (const ia of v.writingModes) if (ia === r.bq.vertical ? (xi = Rn(), Di = xi) : xi = Vi(), xi && xi.box && xi.box.length) break;
                  } else xi = Vi();
                };
                if (L.get("text-variable-anchor")) {
                  let Vi = L.get("text-variable-anchor");
                  if (this.prevPlacement && this.prevPlacement.variableOffsets[Hr]) {
                    const fn = this.prevPlacement.variableOffsets[Hr];
                    Vi.indexOf(fn.anchor) > 0 && (Vi = Vi.filter((wa) => wa !== fn.anchor), Vi.unshift(fn.anchor));
                  }
                  const Rn = (fn, wa, xo) => {
                    const fa = v.getSymbolInstanceTextSize(Ge, hr, this.transform.zoom, br), Wa = (fn.x2 - fn.x1) * fa + 2 * fn.padding, Za = (fn.y2 - fn.y1) * fa + 2 * fn.padding, bo = hr.hasIconTextFit && !_t ? wa : null;
                    bo && Zn(bo);
                    let mn = { box: [], offscreen: !1, occluded: !1 };
                    const Yl = mt ? 2 * Vi.length : Vi.length;
                    for (let Vo = 0; Vo < Yl; ++Vo) {
                      const Kl = this.attemptAnchorPlacement(Vi[Vo % Vi.length], fn, Wa, Za, fa, dt, gt, pe, X, et, Vo >= Vi.length, hr, br, v, xo, bo, Ge, Ve);
                      if (Kl && (mn = Kl.placedGlyphBoxes, mn && mn.box && mn.box.length)) {
                        oi = !0, $i = Kl.shift;
                        break;
                      }
                    }
                    return mn;
                  };
                  ln(() => Rn(jn, Cr.iconBox, r.bq.horizontal), () => {
                    const fn = Cr.verticalTextBox;
                    return fn && Zn(fn), v.allowVerticalPlacement && !(xi && xi.box && xi.box.length) && Zr > 0 && fn ? Rn(fn, Cr.verticalIconBox, r.bq.vertical) : { box: null, offscreen: null, occluded: null };
                  }), xi && (oi = xi.box, Ui = xi.offscreen, tn = xi.occluded);
                  const ia = hn(!(!xi || !xi.box));
                  if (!oi && this.prevPlacement) {
                    const fn = this.prevPlacement.variableOffsets[Hr];
                    fn && (this.variableOffsets[Hr] = fn, this.markUsedJustification(v, fn.anchor, hr, ia));
                  }
                } else {
                  const Vi = (Rn, ia) => {
                    const fn = v.getSymbolInstanceTextSize(Ge, hr, this.transform.zoom, br, _), wa = this.collisionIndex.placeCollisionBox(v, fn, Rn, new r.P(0, 0), mt, pe, X, et.predicate);
                    return wa && wa.box && wa.box.length && (this.markUsedOrientation(v, ia, hr), this.placedOrientations[Hr] = ia), wa;
                  };
                  ln(() => Vi(jn, r.bq.horizontal), () => {
                    const Rn = Cr.verticalTextBox;
                    return v.allowVerticalPlacement && Zr > 0 && Rn ? (Zn(Rn), Vi(Rn, r.bq.vertical)) : { box: null, offscreen: null, occluded: null };
                  }), hn(!!(xi && xi.box && xi.box.length));
                }
              }
              if (Yr = xi, oi = Yr && Yr.box && Yr.box.length > 0, Ui = Yr && Yr.offscreen, tn = Yr && Yr.occluded, hr.useRuntimeCollisionCircles) {
                const hn = v.text.placedSymbolArray.get(hr.centerJustifiedTextSymbolIndex >= 0 ? hr.centerJustifiedTextSymbolIndex : hr.verticalPlacedTextSymbolIndex), ln = r.br(v.textSizeData, Ge, hn), Vi = L.get("text-padding");
                Fi = this.collisionIndex.placeCollisionCircles(v, mt, hn, v.lineVertexArray, v.glyphOffsetArray, ln, X, K, ae, u, gt, et.predicate, hr.collisionCircleDiameter * ln / r.bw, Vi, this.retainedQueryData[v.bucketInstanceId].tileID), oi = mt || Fi.circles.length > 0 && !Fi.collisionDetected, Ui = Ui && Fi.offscreen, tn = Fi.occluded;
              }
              if (Cr.iconFeatureIndex && (Pn = Cr.iconFeatureIndex), Cr.iconBox) {
                const hn = (ln) => {
                  Zn(ln);
                  const Vi = hr.hasIconTextFit && $i ? Wu($i.x, $i.y, dt, gt, this.transform.angle) : new r.P(0, 0), Rn = v.getSymbolInstanceIconSize(Ve, this.transform.zoom, hr.placedIconSymbolIndex);
                  return this.collisionIndex.placeCollisionBox(v, Rn, ln, Vi, _t, pe, X, et.predicate);
                };
                Di && Di.box && Di.box.length && Cr.verticalIconBox ? (Ki = hn(Cr.verticalIconBox), yi = Ki.box.length > 0) : (Ki = hn(Cr.iconBox), yi = Ki.box.length > 0), Ui = Ui && Ki.offscreen, bn = Ki.occluded;
              }
              const ya = st || hr.numHorizontalGlyphVertices === 0 && Zr === 0, va = xt || hr.numIconVertices === 0;
              if (ya || va ? va ? ya || (yi = yi && oi) : oi = yi && oi : yi = oi = yi && oi, oi && Yr && Yr.box && this.collisionIndex.insertCollisionBox(Yr.box, L.get("text-ignore-placement"), v.bucketInstanceId, Di && Di.box && Mn ? Mn : Qi, et.ID), yi && Ki && this.collisionIndex.insertCollisionBox(Ki.box, L.get("icon-ignore-placement"), v.bucketInstanceId, Pn, et.ID), Fi && (oi && this.collisionIndex.insertCollisionCircles(Fi.circles, L.get("text-ignore-placement"), v.bucketInstanceId, Qi, et.ID), u)) {
                const hn = v.bucketInstanceId;
                let ln = this.collisionCircleArrays[hn];
                ln === void 0 && (ln = this.collisionCircleArrays[hn] = new Yo());
                for (let Vi = 0; Vi < Fi.circles.length; Vi += 4) ln.circles.push(Fi.circles[Vi + 0]), ln.circles.push(Fi.circles[Vi + 1]), ln.circles.push(Fi.circles[Vi + 2]), ln.circles.push(Fi.collisionDetected ? 1 : 0);
              }
              const pn = v.projection.name !== "globe";
              dr = dr && (pn || !tn), ir = ir && (pn || !bn), this.placements[Hr] = new lu(oi || dr, yi || ir, Ui || v.justReloaded), n.add(Hr);
            };
            if (Rt && this.buildingIndex && (this.buildingIndex.updateZOffset(v, this.retainedQueryData[v.bucketInstanceId].tileID), v.updateZOffset()), v.sortFeaturesByY) {
              const hr = v.getSortedSymbolIndexes(this.transform.angle);
              for (let br = hr.length - 1; br >= 0; --br) {
                const Cr = hr[br];
                mr(v.symbolInstances.get(Cr), Cr, v.collisionArrays[Cr]);
              }
              v.hasAnyZOffset && r.w(`${v.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
            } else if (v.hasAnyZOffset) {
              const hr = v.getSortedIndexesByZOffset();
              for (let br = 0; br < hr.length; ++br) {
                const Cr = hr[br];
                mr(v.symbolInstances.get(Cr), Cr, v.collisionArrays[Cr]);
              }
            } else for (let hr = t.symbolInstanceStart; hr < t.symbolInstanceEnd; hr++) mr(v.symbolInstances.get(hr), hr, v.collisionArrays[hr]);
            if (u && v.bucketInstanceId in this.collisionCircleArrays) {
              const hr = this.collisionCircleArrays[v.bucketInstanceId];
              r.ab.mat4.invert(hr.invProjMatrix, X), hr.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            v.justReloaded = !1;
          }
          markUsedJustification(t, n, u, d) {
            const { leftJustifiedTextSymbolIndex: _, centerJustifiedTextSymbolIndex: v, rightJustifiedTextSymbolIndex: L, verticalPlacedTextSymbolIndex: G, crossTileID: X } = u, K = r.bB(n), ae = d === r.bq.vertical ? G : K === "left" ? _ : K === "center" ? v : K === "right" ? L : -1;
            _ >= 0 && (t.text.placedSymbolArray.get(_).crossTileID = ae >= 0 && _ !== ae ? 0 : X), v >= 0 && (t.text.placedSymbolArray.get(v).crossTileID = ae >= 0 && v !== ae ? 0 : X), L >= 0 && (t.text.placedSymbolArray.get(L).crossTileID = ae >= 0 && L !== ae ? 0 : X), G >= 0 && (t.text.placedSymbolArray.get(G).crossTileID = ae >= 0 && G !== ae ? 0 : X);
          }
          markUsedOrientation(t, n, u) {
            const d = n === r.bq.horizontal || n === r.bq.horizontalOnly ? n : 0, _ = n === r.bq.vertical ? n : 0, { leftJustifiedTextSymbolIndex: v, centerJustifiedTextSymbolIndex: L, rightJustifiedTextSymbolIndex: G, verticalPlacedTextSymbolIndex: X } = u, K = t.text.placedSymbolArray;
            v >= 0 && (K.get(v).placedOrientation = d), L >= 0 && (K.get(L).placedOrientation = d), G >= 0 && (K.get(G).placedOrientation = d), X >= 0 && (K.get(X).placedOrientation = _);
          }
          commit(t) {
            this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const n = this.prevPlacement;
            let u = !1;
            this.prevZoomAdjustment = n ? n.zoomAdjustment(this.transform.zoom) : 0;
            const d = n ? n.symbolFadeChange(t) : 1, _ = n ? n.opacities : {}, v = n ? n.variableOffsets : {}, L = n ? n.placedOrientations : {};
            for (const G in this.placements) {
              const X = this.placements[G], K = _[G];
              K ? (this.opacities[G] = new Ba(K, d, X.text, X.icon, null, X.clipped), u = u || X.text !== K.text.placed || X.icon !== K.icon.placed) : (this.opacities[G] = new Ba(null, d, X.text, X.icon, X.skipFade, X.clipped), u = u || X.text || X.icon);
            }
            for (const G in _) {
              const X = _[G];
              if (!this.opacities[G]) {
                const K = new Ba(X, d, !1, !1);
                K.isHidden() || (this.opacities[G] = K, u = u || X.text.placed || X.icon.placed);
              }
            }
            for (const G in v) this.variableOffsets[G] || !this.opacities[G] || this.opacities[G].isHidden() || (this.variableOffsets[G] = v[G]);
            for (const G in L) this.placedOrientations[G] || !this.opacities[G] || this.opacities[G].isHidden() || (this.placedOrientations[G] = L[G]);
            u ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = n ? n.lastPlacementChangeTime : t);
          }
          updateLayerOpacities(t, n, u, d) {
            const _ = /* @__PURE__ */ new Set();
            for (const v of n) {
              const L = v.getBucket(t);
              L && v.latestFeatureIndex && t.fqid === L.layerIds[0] && (this.updateBucketOpacities(L, _, v, v.collisionBoxArray, u, d, v.tileID, t.scope), L.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(L, v.tileID), L.updateZOffset()));
            }
          }
          updateBucketOpacities(t, n, u, d, _, v, L, G) {
            t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
            const X = t.layers[0].layout, K = t.layers[0].paint, ae = !!t.layers[0].dynamicFilter(), oe = new Ba(null, 0, !1, !1, !0), pe = X.get("text-allow-overlap"), Be = X.get("icon-allow-overlap"), Re = X.get("text-variable-anchor"), Ge = X.get("text-rotation-alignment") === "map", Ve = X.get("text-pitch-alignment") === "map", et = K.get("symbol-z-offset"), ut = X.get("symbol-elevation-reference") === "sea", st = !et.isConstant(), xt = new Ba(null, 0, pe && (Be || !t.hasIconData() || X.get("icon-optional")), Be && (pe || !t.hasTextData() || X.get("text-optional")), !0);
            !t.collisionArrays && d && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(d);
            const mt = (dt, gt, Rt) => {
              for (let Jt = 0; Jt < gt / 4; Jt++) dt.opacityVertexArray.emplaceBack(Rt);
            };
            let _t = 0;
            v && t.updateReplacement(L, v);
            for (let dt = 0; dt < t.symbolInstances.length; dt++) {
              const gt = t.symbolInstances.get(dt), { numHorizontalGlyphVertices: Rt, numVerticalGlyphVertices: Jt, crossTileID: Vt, numIconVertices: or, tileAnchorX: sr, tileAnchorY: Bt } = gt;
              let rr = null;
              const gr = this.retainedQueryData[t.bucketInstanceId];
              st && gt && gr && (rr = u.latestFeatureIndex.loadFeature({ featureIndex: gt.featureIndex, bucketIndex: gr.bucketIndex, sourceLayerIndex: gr.sourceLayerIndex, layoutVertexArrayOffset: 0 }));
              const Ut = et.evaluate(rr, {}), dr = n.has(Vt);
              let ir = this.opacities[Vt];
              dr ? ir = oe : ir || (ir = xt, this.opacities[Vt] = ir), n.add(Vt);
              const Tr = Rt > 0 || Jt > 0, mr = or > 0, hr = this.placedOrientations[Vt], br = hr === r.bq.vertical, Cr = hr === r.bq.horizontal || hr === r.bq.horizontalOnly;
              !Tr && !mr || ir.isHidden() || _t++;
              let Hr = !1;
              if ((Tr || mr) && v) for (const Zr of t.activeReplacements) {
                if (r.bx(Zr, _, r.by.Symbol, G) || Zr.min.x > sr || sr > Zr.max.x || Zr.min.y > Bt || Bt > Zr.max.y) continue;
                const mi = r.bz(sr, Bt, L.canonical, Zr.footprintTileId.canonical);
                if (Hr = r.bA(mi, Zr.footprint), Hr) break;
              }
              if (Tr) {
                const Zr = Hr ? Oo : Ch(ir.text);
                mt(t.text, Rt, br ? Oo : Zr), mt(t.text, Jt, Cr ? Oo : Zr);
                const mi = ir.text.isHidden(), { leftJustifiedTextSymbolIndex: ii, centerJustifiedTextSymbolIndex: oi, rightJustifiedTextSymbolIndex: yi, verticalPlacedTextSymbolIndex: Ui } = gt, tn = t.text.placedSymbolArray, bn = mi || br ? 1 : 0;
                ii >= 0 && (tn.get(ii).hidden = bn), oi >= 0 && (tn.get(oi).hidden = bn), yi >= 0 && (tn.get(yi).hidden = bn), Ui >= 0 && (tn.get(Ui).hidden = mi || Cr ? 1 : 0);
                const $i = this.variableOffsets[Vt];
                $i && this.markUsedJustification(t, $i.anchor, gt, hr);
                const xi = this.placedOrientations[Vt];
                xi && (this.markUsedJustification(t, "left", gt, xi), this.markUsedOrientation(t, xi, gt));
              }
              if (mr) {
                const Zr = Hr ? Oo : Ch(ir.icon), { placedIconSymbolIndex: mi, verticalPlacedIconSymbolIndex: ii } = gt, oi = t.icon.placedSymbolArray, yi = ir.icon.isHidden() ? 1 : 0;
                mi >= 0 && (mt(t.icon, or, br ? Oo : Zr), oi.get(mi).hidden = yi), ii >= 0 && (mt(t.icon, gt.numVerticalIconVertices, Cr ? Oo : Zr), oi.get(ii).hidden = yi);
              }
              if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
                const Zr = t.collisionArrays[dt];
                if (Zr) {
                  let mi = new r.P(0, 0), ii = !0;
                  if (Zr.textBox || Zr.verticalTextBox) {
                    if (Re) {
                      const yi = this.variableOffsets[Vt];
                      yi ? (mi = Fa(yi.anchor, yi.width, yi.height, yi.textOffset, yi.textScale), Ge && mi._rotate(Ve ? this.transform.angle : -this.transform.angle)) : ii = !1;
                    }
                    ae && (ii = !ir.clipped), Zr.textBox && Zu(t.textCollisionBox.collisionVertexArray, ir.text.placed, !ii || br, Ut, ut, mi.x, mi.y), Zr.verticalTextBox && Zu(t.textCollisionBox.collisionVertexArray, ir.text.placed, !ii || Cr, Ut, ut, mi.x, mi.y);
                  }
                  const oi = ii && !!(!Cr && Zr.verticalIconBox);
                  Zr.iconBox && Zu(t.iconCollisionBox.collisionVertexArray, ir.icon.placed, oi, Ut, ut, gt.hasIconTextFit ? mi.x : 0, gt.hasIconTextFit ? mi.y : 0), Zr.verticalIconBox && Zu(t.iconCollisionBox.collisionVertexArray, ir.icon.placed, !oi, Ut, ut, gt.hasIconTextFit ? mi.x : 0, gt.hasIconTextFit ? mi.y : 0);
                }
              }
            }
            if (t.fullyClipped = _t === 0, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {
              const dt = this.collisionCircleArrays[t.bucketInstanceId];
              t.placementInvProjMatrix = dt.invProjMatrix, t.placementViewportMatrix = dt.viewportMatrix, t.collisionCircleArray = dt.circles, delete this.collisionCircleArrays[t.bucketInstanceId];
            }
          }
          symbolFadeChange(t) {
            return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t) {
            return Math.max(0, (this.transform.zoom - t) / 1.5);
          }
          hasTransitions(t) {
            return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t, n) {
            const u = this.zoomAtLastRecencyCheck === n ? 1 - this.zoomAdjustment(n) : 1;
            return this.zoomAtLastRecencyCheck = n, this.commitTime + this.fadeDuration * u > t;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function Zu(l, t, n, u, d, _, v) {
          l.emplaceBack(t ? 1 : 0, n ? 1 : 0, _ || 0, v || 0, u, d ? 1 : 0), l.emplaceBack(t ? 1 : 0, n ? 1 : 0, _ || 0, v || 0, u, d ? 1 : 0), l.emplaceBack(t ? 1 : 0, n ? 1 : 0, _ || 0, v || 0, u, d ? 1 : 0), l.emplaceBack(t ? 1 : 0, n ? 1 : 0, _ || 0, v || 0, u, d ? 1 : 0);
        }
        const qu = Math.pow(2, 25), od = Math.pow(2, 24), sd = Math.pow(2, 17), uu = Math.pow(2, 16), $u = Math.pow(2, 9), ld = Math.pow(2, 8), cu = Math.pow(2, 1);
        function Ch(l) {
          if (l.opacity === 0 && !l.placed) return 0;
          if (l.opacity === 1 && l.placed) return 4294967295;
          const t = l.placed ? 1 : 0, n = Math.floor(127 * l.opacity);
          return n * qu + t * od + n * sd + t * uu + n * $u + t * ld + n * cu + t;
        }
        const Oo = 0;
        class Vs {
          constructor(t) {
            this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && t.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
          }
          continuePlacement(t, n, u, d, _, v) {
            const L = this._bucketParts;
            for (; this._currentTileIndex < t.length; ) if (n.getBucketParts(L, d, t[this._currentTileIndex], this._sortAcrossTiles, v), this._currentTileIndex++, _()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, L.sort((G, X) => G.sortKey - X.sortKey)); this._currentPartIndex < L.length; ) {
              const G = L[this._currentPartIndex];
              if (n.placeLayerBucketPart(G, this._seenCrossTileIDs, u, G.symbolInstanceStart === 0, v), this._currentPartIndex++, _()) return !0;
            }
            return !1;
          }
        }
        class ud {
          constructor(t, n, u, d, _, v, L, G, X) {
            this.placement = new Lc(t, _, v, L, G, X), this._currentPlacementIndex = n.length - 1, this._forceFullPlacement = u, this._showCollisionBoxes = d, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t, n, u, d, _) {
            const v = r.q.now(), L = () => {
              const G = r.q.now() - v;
              return !this._forceFullPlacement && G > 2;
            };
            for (; this._currentPlacementIndex >= 0; ) {
              const G = n[t[this._currentPlacementIndex]], X = this.placement.collisionIndex.transform.zoom;
              if (G.type === "symbol" && (!G.minzoom || G.minzoom <= X) && (!G.maxzoom || G.maxzoom > X)) {
                const K = G, ae = K.layout.get("symbol-z-elevate"), oe = K.layout.get("symbol-sort-key").constantOr(1) !== void 0, pe = K.layout.get("symbol-z-order"), Be = pe === "viewport-y" || pe === "auto" && !(pe !== "viewport-y" && oe), Re = K.layout.get("text-allow-overlap") || K.layout.get("icon-allow-overlap") || K.layout.get("text-ignore-placement") || K.layout.get("icon-ignore-placement"), Ge = Be && Re, Ve = this._inProgressLayer = this._inProgressLayer || new Vs(K), et = r.aC(G.source, G.scope);
                if (Ve.continuePlacement(ae || Ge ? d[et] : u[et], this.placement, this._showCollisionBoxes, G, L, _)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(t) {
            return this.placement.commit(t), this.placement;
          }
        }
        const Ph = 512 / r.ag / 2;
        class _f {
          constructor(t, n, u) {
            this.tileID = t, this.bucketInstanceId = u, this.index = new r.bE(n.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
            const d = t.canonical.x * r.ag, _ = t.canonical.y * r.ag;
            for (let v = 0; v < n.length; v++) {
              const { key: L, crossTileID: G, tileAnchorX: X, tileAnchorY: K } = n.get(v), ae = Math.floor((d + X) * Ph), oe = Math.floor((_ + K) * Ph);
              this.index.add(ae, oe), this.keys.push(L), this.crossTileIDs.push(G);
            }
            this.index.finish();
          }
          findMatches(t, n, u) {
            const d = this.tileID.canonical.z < n.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - n.canonical.z), _ = Ph / Math.pow(2, n.canonical.z - this.tileID.canonical.z), v = n.canonical.x * r.ag, L = n.canonical.y * r.ag;
            for (let G = 0; G < t.length; G++) {
              const X = t.get(G);
              if (X.crossTileID) continue;
              const { key: K, tileAnchorX: ae, tileAnchorY: oe } = X, pe = Math.floor((v + ae) * _), Be = Math.floor((L + oe) * _), Re = this.index.range(pe - d, Be - d, pe + d, Be + d);
              for (const Ge of Re) {
                const Ve = this.crossTileIDs[Ge];
                if (this.keys[Ge] === K && !u.has(Ve)) {
                  u.add(Ve), X.crossTileID = Ve;
                  break;
                }
              }
            }
          }
        }
        class gf {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class cd {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t) {
            const n = Math.round((t - this.lng) / 360);
            if (n !== 0) for (const u in this.indexes) {
              const d = this.indexes[u], _ = {};
              for (const v in d) {
                const L = d[v];
                L.tileID = L.tileID.unwrapTo(L.tileID.wrap + n), _[L.tileID.key] = L;
              }
              this.indexes[u] = _;
            }
            this.lng = t;
          }
          addBucket(t, n, u) {
            if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
              if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === n.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
            }
            for (let _ = 0; _ < n.symbolInstances.length; _++) n.symbolInstances.get(_).crossTileID = 0;
            this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = /* @__PURE__ */ new Set());
            const d = this.usedCrossTileIDs[t.overscaledZ];
            for (const _ in this.indexes) {
              const v = this.indexes[_];
              if (Number(_) > t.overscaledZ) for (const L in v) {
                const G = v[L];
                G.tileID.isChildOf(t) && G.findMatches(n.symbolInstances, t, d);
              }
              else {
                const L = v[t.scaledTo(Number(_)).key];
                L && L.findMatches(n.symbolInstances, t, d);
              }
            }
            for (let _ = 0; _ < n.symbolInstances.length; _++) {
              const v = n.symbolInstances.get(_);
              v.crossTileID || (v.crossTileID = u.generate(), d.add(v.crossTileID));
            }
            return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new _f(t, n.symbolInstances, n.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(t, n) {
            for (const u of n.crossTileIDs) this.usedCrossTileIDs[t].delete(u);
          }
          removeStaleBuckets(t) {
            let n = !1;
            for (const u in this.indexes) {
              const d = this.indexes[u];
              for (const _ in d) t[d[_].bucketInstanceId] || (this.removeBucketCrossTileIDs(u, d[_]), delete d[_], n = !0);
            }
            return n;
          }
        }
        class Rh {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new gf(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t, n, u, d) {
            let _ = this.layerIndexes[t.fqid];
            _ === void 0 && (_ = this.layerIndexes[t.fqid] = new cd());
            let v = !1;
            const L = {};
            d.name !== "globe" && _.handleWrapJump(u);
            for (const G of n) {
              const X = G.getBucket(t);
              X && t.fqid === X.layerIds[0] && (X.bucketInstanceId || (X.bucketInstanceId = ++this.maxBucketInstanceId), _.addBucket(G.tileID, X, this.crossTileIDs) && (v = !0), L[X.bucketInstanceId] = !0);
            }
            return _.removeStaleBuckets(L) && (v = !0), v;
          }
          pruneUnusedLayers(t) {
            const n = {};
            t.forEach((u) => {
              n[u] = !0;
            });
            for (const u in this.layerIndexes) n[u] || delete this.layerIndexes[u];
          }
        }
        const xl = 771;
        class zi {
          constructor(t, n, u, d) {
            this.blendFunction = t, this.blendColor = n, this.mask = u, this.blendEquation = d;
          }
        }
        zi.Replace = [1, 0, 1, 0], zi.disabled = new zi(zi.Replace, r.aj.transparent, [!1, !1, !1, !1]), zi.unblended = new zi(zi.Replace, r.aj.transparent, [!0, !0, !0, !0]), zi.alphaBlended = new zi([1, xl, 1, xl], r.aj.transparent, [!0, !0, !0, !0]), zi.alphaBlendedNonPremultiplied = new zi([770, xl, 770, xl], r.aj.transparent, [!0, !0, !0, !0]), zi.multiply = new zi([774, 0, 774, 0], r.aj.transparent, [!0, !0, !0, !0]);
        class ui {
          constructor(t, n, u) {
            this.func = t, this.mask = n, this.range = u;
          }
        }
        ui.ReadOnly = !1, ui.ReadWrite = !0, ui.disabled = new ui(519, ui.ReadOnly, [0, 1]);
        const Dc = 7680;
        class _i {
          constructor(t, n, u, d, _, v) {
            this.test = t, this.ref = n, this.mask = u, this.fail = d, this.depthFail = _, this.pass = v;
          }
        }
        _i.disabled = new _i({ func: 519, mask: 0 }, 0, 0, Dc, Dc, Dc);
        const Ko = 1029, kc = 2305;
        class vi {
          constructor(t, n, u) {
            this.enable = t, this.mode = n, this.frontFace = u;
          }
        }
        function bl(l, t) {
          const n = r.bG(l, 3);
          r.ab.mat4.fromQuat(l, t), r.bI(l, 3, n);
        }
        function Gs(l, t) {
          const n = r.ab.quat.identity([]);
          return r.ab.quat.rotateZ(n, n, -t), r.ab.quat.rotateX(n, n, -l), n;
        }
        function zc(l, t) {
          const n = [l[0], l[1], 0], u = [t[0], t[1], 0];
          if (r.ab.vec3.length(n) >= 1e-15) {
            const v = r.ab.vec3.normalize([], n);
            r.ab.vec3.scale(u, v, r.ab.vec3.dot(u, v)), t[0] = u[0], t[1] = u[1];
          }
          const d = r.ab.vec3.cross([], t, l);
          if (r.ab.vec3.len(d) < 1e-15) return null;
          const _ = Math.atan2(-d[1], d[0]);
          return Gs(Math.atan2(Math.sqrt(l[0] * l[0] + l[1] * l[1]), -l[2]), _);
        }
        vi.disabled = new vi(!1, Ko, kc), vi.backCCW = new vi(!0, Ko, kc), vi.backCW = new vi(!0, Ko, 2304), vi.frontCW = new vi(!0, 1028, 2304), vi.frontCCW = new vi(!0, 1028, kc);
        class Xu {
          constructor(t, n) {
            this.position = t, this.orientation = n;
          }
          get position() {
            return this._position;
          }
          set position(t) {
            if (t) {
              const n = t instanceof r.aa ? t : new r.aa(t[0], t[1], t[2]);
              this._renderWorldCopies && (n.x = r.bF(n.x, 0, 1)), this._position = n;
            } else this._position = null;
          }
          lookAtPoint(t, n) {
            if (this.orientation = null, !this.position) return;
            const u = this.position, d = this._elevation ? this._elevation.getAtPointOrZero(r.aa.fromLngLat(t)) : 0, _ = r.aa.fromLngLat(t, d), v = [_.x - u.x, _.y - u.y, _.z - u.z];
            n || (n = [0, 0, 1]), n[2] = Math.abs(n[2]), this.orientation = zc(v, n);
          }
          setPitchBearing(t, n) {
            this.orientation = Gs(r.ai(t), r.ai(-n));
          }
        }
        class ua {
          constructor(t, n) {
            this._transform = r.ab.mat4.identity([]), this.orientation = n, this.position = t;
          }
          get mercatorPosition() {
            const t = this.position;
            return new r.aa(t[0], t[1], t[2]);
          }
          get position() {
            const t = r.bG(this._transform, 3);
            return [t[0], t[1], t[2]];
          }
          set position(t) {
            var n;
            t && r.bI(this._transform, 3, [(n = t)[0], n[1], n[2], 1]);
          }
          get orientation() {
            return this._orientation;
          }
          set orientation(t) {
            this._orientation = t || r.ab.quat.identity([]), t && bl(this._transform, this._orientation);
          }
          getPitchBearing() {
            const t = this.forward(), n = this.right();
            return { bearing: Math.atan2(-n[1], n[0]), pitch: Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]) };
          }
          setPitchBearing(t, n) {
            this._orientation = Gs(t, n), bl(this._transform, this._orientation);
          }
          forward() {
            const t = r.bG(this._transform, 2);
            return [-t[0], -t[1], -t[2]];
          }
          up() {
            const t = r.bG(this._transform, 1);
            return [-t[0], -t[1], -t[2]];
          }
          right() {
            const t = r.bG(this._transform, 0);
            return [t[0], t[1], t[2]];
          }
          getCameraToWorld(t, n) {
            const u = new Float64Array(16);
            return r.ab.mat4.invert(u, this.getWorldToCamera(t, n)), u;
          }
          getCameraToWorldMercator() {
            return this._transform;
          }
          getWorldToCameraPosition(t, n, u) {
            const d = this.position;
            r.ab.vec3.scale(d, d, -t);
            const _ = new Float64Array(16);
            return r.ab.mat4.fromScaling(_, [u, u, u]), r.ab.mat4.translate(_, _, d), _[10] *= n, _;
          }
          getWorldToCamera(t, n) {
            const u = new Float64Array(16), d = new Float64Array(4), _ = this.position;
            return r.ab.quat.conjugate(d, this._orientation), r.ab.vec3.scale(_, _, -t), r.ab.mat4.fromQuat(u, d), r.ab.mat4.translate(u, u, _), u[1] *= -1, u[5] *= -1, u[9] *= -1, u[13] *= -1, u[8] *= n, u[9] *= n, u[10] *= n, u[11] *= n, u;
          }
          getCameraToClipPerspective(t, n, u, d) {
            const _ = new Float64Array(16);
            return r.ab.mat4.perspective(_, t, n, u, d), _;
          }
          getCameraToClipOrthographic(t, n, u, d, _, v) {
            const L = new Float64Array(16);
            return r.ab.mat4.ortho(L, t, n, u, d, _, v), L;
          }
          getDistanceToElevation(t, n = !1) {
            const u = t === 0 ? 0 : r.bH(t, n ? r.aS(this.position[1]) : this.position[1]), d = this.forward();
            return (u - this.position[2]) / d[2];
          }
          clone() {
            return new ua([...this.position], [...this.orientation]);
          }
        }
        const xa = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, LUT: 10, ShadowMap0: 11 };
        class Br {
          constructor(t = 0, n = 0, u = 0, d = 0) {
            if (isNaN(t) || t < 0 || isNaN(n) || n < 0 || isNaN(u) || u < 0 || isNaN(d) || d < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t, this.bottom = n, this.left = u, this.right = d;
          }
          interpolate(t, n, u) {
            return n.top != null && t.top != null && (this.top = r.af(t.top, n.top, u)), n.bottom != null && t.bottom != null && (this.bottom = r.af(t.bottom, n.bottom, u)), n.left != null && t.left != null && (this.left = r.af(t.left, n.left, u)), n.right != null && t.right != null && (this.right = r.af(t.right, n.right, u)), this;
          }
          getCenter(t, n) {
            const u = r.aw((this.left + t - this.right) / 2, 0, t), d = r.aw((this.top + n - this.bottom) / 2, 0, n);
            return new r.P(u, d);
          }
          equals(t) {
            return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;
          }
          clone() {
            return new Br(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        const Lh = (l, t, n) => (1 - n) * l + n * t, Yu = (l) => l * l * l * l * l;
        class hu {
          constructor(t, n, u, d, _, v, L) {
            this.tileSize = 512, this._renderWorldCopies = _ === void 0 || _, this._minZoom = t || 0, this._maxZoom = n || 22, this._minPitch = u ?? 0, this._maxPitch = d ?? 60, this.setProjection(v), this.setMaxBounds(L), this.width = 0, this.height = 0, this._center = new r.bO(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new Br(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new ua(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = !1;
          }
          clone() {
            const t = new hu(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
            return t._elevation = this._elevation, t._centerAltitude = this._centerAltitude, t._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, t.tileSize = this.tileSize, t.mercatorFromTransition = this.mercatorFromTransition, t.width = this.width, t.height = this.height, t.cameraElevationReference = this.cameraElevationReference, t._center = this._center, t._setZoom(this.zoom), t._seaLevelZoom = this._seaLevelZoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._nearZ = this._nearZ, t._farZ = this._farZ, t._averageElevation = this._averageElevation, t._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, t._unmodified = this._unmodified, t._edgeInsets = this._edgeInsets.clone(), t._camera = this._camera.clone(), t._calcMatrices(), t.freezeTileCoverage = this.freezeTileCoverage, t.frustumCorners = this.frustumCorners, t;
          }
          get isOrthographic() {
            return this.projection.name !== "globe" && this._orthographicProjectionAtLowPitch && this.pitch < 15;
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(t) {
            this._elevation !== t && (this._elevation = t, this._updateCameraOnTerrain(), this._calcMatrices());
          }
          get depthOcclusionForSymbolsAndCircles() {
            return this.projection.name !== "globe" && !this.isOrthographic;
          }
          updateElevation(t, n = !1) {
            const u = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
            (this._seaLevelZoom == null || u) && this._updateCameraOnTerrain(), (t || u) && this._constrainCamera(n), this._calcMatrices();
          }
          getProjection() {
            return r.ay(this.projection, ["name", "center", "parallels"]);
          }
          setProjection(t) {
            this.projectionOptions = t || { name: "mercator" };
            const n = this.projection ? this.getProjection() : void 0;
            this.projection = r.bP(this.projectionOptions);
            const u = this.getProjection(), d = !r.bn(n, u);
            return d && this._calcMatrices(), this.mercatorFromTransition = !1, d;
          }
          setOrthographicProjectionAtLowPitch(t) {
            return this._orthographicProjectionAtLowPitch !== t && (this._orthographicProjectionAtLowPitch = t, this._calcMatrices(), !0);
          }
          setMercatorFromTransition() {
            const t = this.projection.name;
            this.mercatorFromTransition = !0, this.projectionOptions = { name: "mercator" }, this.projection = r.bP({ name: "mercator" });
            const n = t !== this.projection.name;
            return n && this._calcMatrices(), n;
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(t) {
            this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(t) {
            this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(t) {
            this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(t) {
            this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies && this.projection.supportsWorldCopies === !0;
          }
          set renderWorldCopies(t) {
            t === void 0 ? t = !0 : t === null && (t = !1), this._renderWorldCopies = t;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get cameraWorldSizeForFog() {
            const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
          }
          get cameraWorldSize() {
            const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
          }
          get pixelsPerMeter() {
            return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
          }
          get cameraPixelsPerMeter() {
            return r.bH(1, this.center.lat) * this.cameraWorldSizeForFog;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new r.P(this.width, this.height);
          }
          get bearing() {
            return r.bF(this.rotation, -180, 180);
          }
          set bearing(t) {
            this.rotation = t;
          }
          get rotation() {
            return -this.angle / Math.PI * 180;
          }
          set rotation(t) {
            const n = -t * Math.PI / 180;
            this.angle !== n && (this._unmodified = !1, this.angle = n, this._calcMatrices(), this.rotationMatrix = r.ab.mat2.create(), r.ab.mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t) {
            const n = r.aw(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== n && (this._unmodified = !1, this._pitch = n, this._calcMatrices());
          }
          get aspect() {
            return this.width / this.height;
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          get fovX() {
            return this._fov;
          }
          get fovY() {
            const t = 1 / Math.tan(0.5 * this.fovX);
            return 2 * Math.atan(1 / this.aspect / t);
          }
          set fov(t) {
            t = Math.max(0.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = r.ai(t), this._calcMatrices());
          }
          get averageElevation() {
            return this._averageElevation;
          }
          set averageElevation(t) {
            this._averageElevation = t, this._calcFogMatrices(), this._distanceTileDataCache = {};
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(t) {
            const n = Math.min(Math.max(t, this.minZoom), this.maxZoom);
            this._zoom !== n && (this._unmodified = !1, this._setZoom(n), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
          }
          _setZoom(t) {
            this._zoom = t, this.scale = this.zoomScale(t), this.tileZoom = Math.floor(t), this.zoomFraction = t - this.tileZoom;
          }
          get tileCoverLift() {
            return this._tileCoverLift;
          }
          set tileCoverLift(t) {
            this._tileCoverLift !== t && (this._tileCoverLift = t);
          }
          _updateCameraOnTerrain() {
            const t = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, n = this.elevation && t === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
            if (!this._elevation || t === Number.NEGATIVE_INFINITY && (!n || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
            const u = this._elevation;
            n || this._centerAltitude && this._centerAltitudeValidForExaggeration && u.exaggeration() && this._centerAltitudeValidForExaggeration !== u.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * u.exaggeration(), this._centerAltitudeValidForExaggeration = u.exaggeration()) : (this._centerAltitude = t || 0, this._centerAltitudeValidForExaggeration = u.exaggeration()), this._updateSeaLevelZoom();
          }
          _updateSeaLevelZoom() {
            this._centerAltitudeValidForExaggeration !== void 0 && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
          }
          sampleAverageElevation() {
            if (!this._elevation) return 0;
            const t = this._elevation, n = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], u = this.horizonLineFromTop();
            let d = 0, _ = 0;
            for (let v = 0; v < n.length; v++) {
              const L = new r.P(n[v][0] * this.width, u + n[v][1] * (this.height - u)), G = t.pointCoordinate(L);
              if (!G) continue;
              const X = 1 / Math.hypot(G[0] - this._camera.position[0], G[1] - this._camera.position[1]);
              d += G[3] * X, _ += X;
            }
            return _ === 0 ? NaN : d / _;
          }
          get center() {
            return this._center;
          }
          set center(t) {
            t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
          }
          _updateZoomFromElevation() {
            if (this._seaLevelZoom == null || !this._elevation) return;
            const t = this._seaLevelZoom, n = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), u = this.pixelsPerMeter / this.worldSize * n, d = this._mercatorZfromZoom(t), _ = this._mercatorZfromZoom(this._maxZoom), v = Math.max(d - u, _);
            this._setZoom(this._zoomFromMercatorZ(v));
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(t) {
            this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());
          }
          computeZoomRelativeTo(t) {
            const n = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));
            let u;
            u = t.z < this._camera.position[2] ? [n.x, n.y, n.z] : [t.x, t.y, t.z];
            const d = r.ab.vec3.length(r.ab.vec3.sub([], this._camera.position, u));
            return r.aw(this._zoomFromMercatorZ(d), this._minZoom, this._maxZoom);
          }
          setFreeCameraOptions(t) {
            if (!this.height || !t.position && !t.orientation) return;
            this._updateCameraState();
            let n = !1;
            if (t.orientation && !r.ab.quat.exactEquals(t.orientation, this._camera.orientation) && (n = this._setCameraOrientation(t.orientation)), t.position) {
              const u = [t.position.x, t.position.y, t.position.z];
              r.ab.vec3.exactEquals(u, this._camera.position) || (this._setCameraPosition(u), n = !0);
            }
            n && (this._updateStateFromCamera(), this.recenterOnTerrain());
          }
          getFreeCameraOptions() {
            this._updateCameraState();
            const t = this._camera.position, n = new Xu();
            return n.position = new r.aa(t[0], t[1], t[2]), n.orientation = this._camera.orientation, n._elevation = this.elevation, n._renderWorldCopies = this.renderWorldCopies, n;
          }
          _setCameraOrientation(t) {
            if (!r.ab.quat.length(t)) return !1;
            r.ab.quat.normalize(t, t);
            const n = r.ab.vec3.transformQuat([], [0, 0, -1], t), u = r.ab.vec3.transformQuat([], [0, -1, 0], t);
            if (u[2] < 0) return !1;
            const d = zc(n, u);
            return !!d && (this._camera.orientation = d, !0);
          }
          _setCameraPosition(t) {
            const n = this.zoomScale(this.minZoom) * this.tileSize, u = this.zoomScale(this.maxZoom) * this.tileSize, d = this.cameraToCenterDistance;
            t[2] = r.aw(t[2], d / u, d / n), this._camera.position = t;
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          get fovAboveCenter() {
            return this._fov * (0.5 + this.centerOffset.y / this.height);
          }
          isPaddingEqual(t) {
            return this._edgeInsets.equals(t);
          }
          interpolatePadding(t, n, u) {
            this._unmodified = !1, this._edgeInsets.interpolate(t, n, u), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(t) {
            const n = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
            return Math.max(0, n);
          }
          getVisibleUnwrappedCoordinates(t) {
            const n = [new r.bQ(0, t)];
            if (this.renderWorldCopies) {
              const u = this.pointCoordinate(new r.P(0, 0)), d = this.pointCoordinate(new r.P(this.width, 0)), _ = this.pointCoordinate(new r.P(this.width, this.height)), v = this.pointCoordinate(new r.P(0, this.height)), L = Math.floor(Math.min(u.x, d.x, _.x, v.x)), G = Math.floor(Math.max(u.x, d.x, _.x, v.x)), X = 1;
              for (let K = L - X; K <= G + X; K++) K !== 0 && n.push(new r.bQ(K, t));
            }
            return n;
          }
          isLODDisabled(t) {
            return (!t || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
          }
          extendTileCover(t, n, u) {
            let d = [];
            const _ = u !== void 0, v = !_;
            if (v && this.zoom < n || _ && u[0] === 0 && u[1] === 0) return d;
            const L = /* @__PURE__ */ new Set(), G = (K, ae, oe, pe, Be) => {
              const Re = r.c5(ae, K, oe, pe, Be);
              L.has(Re) || (d.push(new r.aG(K, ae, oe, pe, Be)), L.add(Re));
            };
            for (let K = 0; K < t.length; K++) {
              const ae = t[K];
              if (v && ae.canonical.z !== n) continue;
              const oe = ae.canonical, pe = ae.overscaledZ, Be = ae.wrap, Re = 1 << oe.z, Ge = oe.x + 1 < Re, Ve = oe.x > 0, et = oe.y + 1 < Re, ut = oe.y > 0, st = ae.wrap - (Ve ? 0 : 1), xt = ae.wrap + (Ge ? 0 : 1), mt = Ve ? oe.x - 1 : Re - 1, _t = Ge ? oe.x + 1 : 0;
              if (_) u[0] < 0 ? (G(pe, xt, oe.z, _t, oe.y), u[1] < 0 && et && (G(pe, Be, oe.z, oe.x, oe.y + 1), G(pe, xt, oe.z, _t, oe.y + 1)), u[1] > 0 && ut && (G(pe, Be, oe.z, oe.x, oe.y - 1), G(pe, xt, oe.z, _t, oe.y - 1))) : u[0] > 0 ? (G(pe, st, oe.z, mt, oe.y), u[1] < 0 && et && (G(pe, Be, oe.z, oe.x, oe.y + 1), G(pe, st, oe.z, mt, oe.y + 1)), u[1] > 0 && ut && (G(pe, Be, oe.z, oe.x, oe.y - 1), G(pe, st, oe.z, mt, oe.y - 1))) : u[1] < 0 && et ? G(pe, Be, oe.z, oe.x, oe.y + 1) : ut && G(pe, Be, oe.z, oe.x, oe.y - 1);
              else {
                const dt = ae.visibleQuadrants;
                1 & dt && (G(pe, st, oe.z, mt, oe.y), ut && (G(pe, Be, oe.z, oe.x, oe.y - 1), G(pe, st, oe.z, mt, oe.y - 1))), 2 & dt && (G(pe, xt, oe.z, _t, oe.y), ut && (G(pe, Be, oe.z, oe.x, oe.y - 1), G(pe, xt, oe.z, _t, oe.y - 1))), 4 & dt && (G(pe, st, oe.z, mt, oe.y), et && (G(pe, Be, oe.z, oe.x, oe.y + 1), G(pe, st, oe.z, mt, oe.y + 1))), 8 & dt && (G(pe, xt, oe.z, _t, oe.y), et && (G(pe, Be, oe.z, oe.x, oe.y + 1), G(pe, xt, oe.z, _t, oe.y + 1)));
              }
            }
            const X = [];
            for (const K of d) d.some((ae) => K.isChildOf(ae)) || X.push(K);
            if (d = X.filter((K) => !t.some((ae) => !!(K.overscaledZ < n && ae.isChildOf(K)) || K.equals(ae) || K.isChildOf(ae))), v) {
              const K = 1 << n, ae = this.projection.name === "globe" ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), oe = [K * ae.x, K * ae.y], pe = 4, Be = pe * pe;
              d = d.filter((Re) => {
                const Ge = Re.canonical.x + 0.5 - oe[0], Ve = Re.canonical.y + 0.5 - oe[1];
                return Ge * Ge + Ve * Ve < Be;
              });
            }
            return d;
          }
          coveringTiles(t) {
            let n = this.coveringZoomLevel(t);
            const u = n, d = this.elevation && this.elevation.exaggeration(), _ = d && !t.isTerrainDEM, v = this.projection.name === "mercator";
            if (t.minzoom !== void 0 && n < t.minzoom) return [];
            t.maxzoom !== void 0 && n > t.maxzoom && (n = t.maxzoom);
            const L = this.locationCoordinate(this.center), G = this.center.lat, X = 1 << n, K = [X * L.x, X * L.y, 0], ae = this.projection.name === "globe", oe = !ae, pe = r.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, n, oe), Be = ae ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), Re = X * r.bH(1, this.center.lat), Ge = this._camera.position[2] / r.bH(1, this.center.lat), Ve = [X * Be.x, X * Be.y, Ge * (oe ? 1 : Re)], et = ae || d, ut = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : 0.502), st = this.isLODDisabled(!0) ? n : 0;
            let xt;
            if (this._elevation && t.isTerrainDEM) xt = 1e4 * this._elevation.exaggeration();
            else if (this._elevation) {
              const Ut = this._elevation.getMinMaxForVisibleTiles();
              xt = Ut ? Ut.max : this._centerAltitude;
            } else xt = this._centerAltitude;
            const mt = t.isTerrainDEM ? -xt : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, _t = this.projection.isReprojectedInTileSpace ? r.bS(this) : 1, dt = (Ut) => {
              const ir = new r.aa(Ut.x + 25e-6, Ut.y, Ut.z), Tr = new r.aa(Ut.x, Ut.y + 25e-6, Ut.z), mr = Ut.toLngLat(), hr = ir.toLngLat(), br = Tr.toLngLat(), Cr = this.locationCoordinate(mr), Hr = this.locationCoordinate(hr), Zr = this.locationCoordinate(br), mi = Math.hypot(Hr.x - Cr.x, Hr.y - Cr.y), ii = Math.hypot(Zr.x - Cr.x, Zr.y - Cr.y);
              return Math.sqrt(mi * ii) * _t / 25e-6;
            }, gt = (Ut) => {
              const dr = xt, ir = mt;
              return { aabb: r.bV(this, X, 0, 0, 0, Ut, ir, dr, this.projection), zoom: 0, x: 0, y: 0, minZ: ir, maxZ: dr, wrap: Ut, fullyVisible: !1 };
            }, Rt = [];
            let Jt = [];
            const Vt = n, or = t.reparseOverscaled ? u : n, sr = (Ge - this._centerAltitude) * Re, Bt = (Ut) => {
              if (!this._elevation || !Ut.tileID || !v) return;
              const dr = this._elevation.getMinMaxForTile(Ut.tileID), ir = Ut.aabb;
              dr ? (ir.min[2] = dr.min, ir.max[2] = dr.max, ir.center[2] = (ir.min[2] + ir.max[2]) / 2) : (Ut.shouldSplit = gr(Ut), Ut.shouldSplit || (ir.min[2] = ir.max[2] = ir.center[2] = this._centerAltitude));
            }, rr = (Ut, dr) => {
              if (0.707 * dr < Ut) return 1;
              const ir = dr / Ut;
              return ir / (1.4144271570014144 + (Math.pow(1.1, ir - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
            }, gr = (Ut) => {
              if (Ut.zoom < st) return !0;
              if (Ut.zoom === Vt) return !1;
              if (Ut.shouldSplit != null) return Ut.shouldSplit;
              const dr = Ut.aabb.distanceX(Ve), ir = Ut.aabb.distanceY(Ve);
              let Tr = sr, mr = 1;
              if (ae) {
                Tr = Ut.aabb.distanceZ(Ve);
                const ii = Math.pow(2, Ut.zoom), oi = r.aS((Ut.y + 1) / ii), yi = r.aS(Ut.y / ii), Ui = Math.min(Math.max(G, oi), yi), tn = r.c9(Ui) / r.c9(G);
                if (mr = Ui === G ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, tn / this._mercatorScaleRatio), this.zoom <= r.c6 && Ut.zoom === Vt - 1 && tn >= 0.9) return !0;
              } else if (_ && (Tr = Ut.aabb.distanceZ(Ve) * Re), this.projection.isReprojectedInTileSpace && u <= 5) {
                const ii = Math.pow(2, Ut.zoom), oi = dt(new r.aa((Ut.x + 0.5) / ii, (Ut.y + 0.5) / ii));
                mr = oi > 0.85 ? 1 : oi;
              }
              if (!v) {
                const ii = Math.sqrt(dr * dr + ir * ir + Tr * Tr);
                let oi = (1 << Vt - Ut.zoom) * ut * mr;
                return oi *= rr(Math.max(Tr, sr), ii), ii < oi;
              }
              let hr = Number.MAX_VALUE, br = 0;
              const Cr = Ut.aabb.getCorners(), Hr = [];
              for (const ii of Cr) {
                r.ab.vec3.sub(Hr, ii, Ve), ae || (_ ? Hr[2] *= Re : Hr[2] = sr);
                const oi = r.ab.vec3.dot(Hr, this._camera.forward());
                oi < hr && (hr = oi, br = Math.abs(Hr[2]));
              }
              let Zr = (1 << Vt - Ut.zoom) * ut * mr;
              if (Zr *= rr(Math.max(br, sr), hr), hr < Zr) return !0;
              const mi = Ut.aabb.closestPoint(K);
              return mi[0] === K[0] && mi[1] === K[1];
            };
            if (this.renderWorldCopies) for (let Ut = 1; Ut <= 3; Ut++) Rt.push(gt(-Ut)), Rt.push(gt(Ut));
            for (Rt.push(gt(0)); Rt.length > 0; ) {
              const Ut = Rt.pop(), dr = Ut.x, ir = Ut.y;
              let Tr = Ut.fullyVisible;
              const mr = () => this.projection.name === "globe" && (Ut.y === 0 || Ut.y === (1 << Ut.zoom) - 1);
              if (!Tr) {
                let hr = et ? Ut.aabb.intersects(pe) : Ut.aabb.intersectsFlat(pe);
                if (hr === 0 && mr()) {
                  const br = new r.bT(Ut.zoom, dr, ir);
                  hr = r.bU(this, X, br, !0).intersects(pe);
                }
                if (hr === 0) continue;
                Tr = hr === 2;
              }
              if (Ut.zoom !== Vt && gr(Ut)) for (let hr = 0; hr < 4; hr++) {
                const br = (dr << 1) + hr % 2, Cr = (ir << 1) + (hr >> 1), Hr = { aabb: v ? Ut.aabb.quadrant(hr) : r.bV(this, X, Ut.zoom + 1, br, Cr, Ut.wrap, Ut.minZ, Ut.maxZ, this.projection), zoom: Ut.zoom + 1, x: br, y: Cr, wrap: Ut.wrap, fullyVisible: Tr, tileID: void 0, shouldSplit: void 0, minZ: Ut.minZ, maxZ: Ut.maxZ };
                _ && !ae && (Hr.tileID = new r.aG(Ut.zoom + 1 === Vt ? or : Ut.zoom + 1, Ut.wrap, Ut.zoom + 1, br, Cr), Bt(Hr)), Rt.push(Hr);
              }
              else {
                const hr = Ut.zoom === Vt ? or : Ut.zoom;
                if (t.minzoom && t.minzoom > hr) continue;
                let br = 0;
                if (!Tr) {
                  let mi = et ? Ut.aabb.intersectsPrecise(pe) : Ut.aabb.intersectsPreciseFlat(pe);
                  if (mi === 0 && mr()) {
                    const ii = new r.bT(Ut.zoom, dr, ir);
                    mi = r.bU(this, X, ii, !0).intersectsPrecise(pe);
                  }
                  if (mi === 0) continue;
                  if (t.calculateQuadrantVisibility) if (pe.containsPoint(Ut.aabb.center)) br = 15;
                  else for (let ii = 0; ii < 4; ii++) Ut.aabb.quadrant(ii).intersects(pe) !== 0 && (br |= 1 << ii);
                }
                const Cr = K[0] - (0.5 + dr + (Ut.wrap << Ut.zoom)) * (1 << n - Ut.zoom), Hr = K[1] - 0.5 - ir, Zr = Ut.tileID ? Ut.tileID : new r.aG(hr, Ut.wrap, Ut.zoom, dr, ir);
                t.calculateQuadrantVisibility && (Zr.visibleQuadrants = br), Jt.push({ tileID: Zr, distanceSq: Cr * Cr + Hr * Hr });
              }
            }
            if (this.fogCullDistSq) {
              const Ut = this.fogCullDistSq, dr = this.horizonLineFromTop();
              Jt = Jt.filter((ir) => {
                const Tr = [0, 0, 0, 1], mr = [r.ag, r.ag, 0, 1], hr = this.calculateFogTileMatrix(ir.tileID.toUnwrapped());
                r.ab.vec4.transformMat4(Tr, Tr, hr), r.ab.vec4.transformMat4(mr, mr, hr);
                const br = r.ab.vec4.min([], Tr, mr), Cr = r.ab.vec4.max([], Tr, mr), Hr = r.bW(br, Cr);
                if (Hr === 0) return !0;
                let Zr = !1;
                const mi = this._elevation;
                if (mi && Hr > Ut && dr !== 0) {
                  const ii = this.calculateProjMatrix(ir.tileID.toUnwrapped());
                  let oi;
                  t.isTerrainDEM || (oi = mi.getMinMaxForTile(ir.tileID)), oi || (oi = { min: mt, max: xt });
                  const yi = r.c7(this.rotation), Ui = [yi[0] * r.ag, yi[1] * r.ag, oi.max];
                  r.ab.vec3.transformMat4(Ui, Ui, ii), Zr = (1 - Ui[1]) * this.height * 0.5 < dr;
                }
                return Hr < Ut || Zr;
              });
            }
            return Jt.sort((Ut, dr) => Ut.distanceSq - dr.distanceSq).map((Ut) => Ut.tileID);
          }
          resize(t, n) {
            this.width = t, this.height = n, this.pixelsToGLUnits = [2 / t, -2 / n], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(t) {
            return Math.pow(2, t);
          }
          scaleZoom(t) {
            return Math.log(t) / Math.LN2;
          }
          project(t) {
            const n = r.aw(t.lat, -r.bX, r.bX), u = this.projection.project(t.lng, n);
            return new r.P(u.x * this.worldSize, u.y * this.worldSize);
          }
          unproject(t) {
            return this.projection.unproject(t.x / this.worldSize, t.y / this.worldSize);
          }
          get point() {
            return this.project(this.center);
          }
          get pointMerc() {
            return this.point._div(this.worldSize);
          }
          get pixelsPerMeterRatio() {
            return this.pixelsPerMeter / r.bH(1, this.center.lat) / this.worldSize;
          }
          setLocationAtPoint(t, n) {
            let u, d;
            const _ = this.centerPoint;
            if (this.projection.name === "globe") {
              const L = this.worldSize;
              u = (n.x - _.x) / L, d = (n.y - _.y) / L;
            } else {
              const L = this.pointCoordinate(n), G = this.pointCoordinate(_);
              u = L.x - G.x, d = L.y - G.y;
            }
            const v = this.locationCoordinate(t);
            this.setLocation(new r.aa(v.x - u, v.y - d));
          }
          setLocation(t) {
            this.center = this.coordinateLocation(t), this.projection.wrap && (this.center = this.center.wrap());
          }
          locationPoint(t) {
            return this.projection.locationPoint(this, t);
          }
          locationPoint3D(t) {
            return this.projection.locationPoint(this, t, !0);
          }
          pointLocation(t) {
            return this.coordinateLocation(this.pointCoordinate(t));
          }
          pointLocation3D(t) {
            return this.coordinateLocation(this.pointCoordinate3D(t));
          }
          locationCoordinate(t, n) {
            const u = n ? r.bH(n, t.lat) : void 0, d = this.projection.project(t.lng, t.lat);
            return new r.aa(d.x, d.y, u);
          }
          coordinateLocation(t) {
            return this.projection.unproject(t.x, t.y);
          }
          pointRayIntersection(t, n) {
            const u = n ?? this._centerAltitude, d = [t.x, t.y, 0, 1], _ = [t.x, t.y, 1, 1];
            r.ab.vec4.transformMat4(d, d, this.pixelMatrixInverse), r.ab.vec4.transformMat4(_, _, this.pixelMatrixInverse);
            const v = _[3];
            r.ab.vec4.scale(d, d, 1 / d[3]), r.ab.vec4.scale(_, _, 1 / v);
            const L = d[2], G = _[2];
            return { p0: d, p1: _, t: L === G ? 0 : (u - L) / (G - L) };
          }
          screenPointToMercatorRay(t) {
            const n = [t.x, t.y, 0, 1], u = [t.x, t.y, 1, 1];
            return r.ab.vec4.transformMat4(n, n, this.pixelMatrixInverse), r.ab.vec4.transformMat4(u, u, this.pixelMatrixInverse), r.ab.vec4.scale(n, n, 1 / n[3]), r.ab.vec4.scale(u, u, 1 / u[3]), n[2] = r.bH(n[2], this._center.lat) * this.worldSize, u[2] = r.bH(u[2], this._center.lat) * this.worldSize, r.ab.vec4.scale(n, n, 1 / this.worldSize), r.ab.vec4.scale(u, u, 1 / this.worldSize), new r.aq([n[0], n[1], n[2]], r.ab.vec3.normalize([], r.ab.vec3.sub([], u, n)));
          }
          rayIntersectionCoordinate(t) {
            const { p0: n, p1: u, t: d } = t, _ = r.bH(n[2], this._center.lat), v = r.bH(u[2], this._center.lat);
            return new r.aa(r.af(n[0], u[0], d) / this.worldSize, r.af(n[1], u[1], d) / this.worldSize, r.af(_, v, d));
          }
          pointCoordinate(t, n = this._centerAltitude) {
            return this.projection.pointCoordinate(this, t.x, t.y, n);
          }
          pointCoordinate3D(t) {
            if (!this.elevation) return this.pointCoordinate(t);
            let n = this.projection.pointCoordinate3D(this, t.x, t.y);
            if (n) return new r.aa(n[0], n[1], n[2]);
            let u = 0, d = this.horizonLineFromTop();
            if (t.y > d) return this.pointCoordinate(t);
            const _ = 0.02 * d, v = t.clone();
            for (let L = 0; L < 10 && d - u > _; L++) {
              v.y = r.af(u, d, 0.66);
              const G = this.projection.pointCoordinate3D(this, v.x, v.y);
              G ? (d = v.y, n = G) : u = v.y;
            }
            return n ? new r.aa(n[0], n[1], n[2]) : this.pointCoordinate(t);
          }
          isPointAboveHorizon(t) {
            return this.projection.isPointAboveHorizon(this, t);
          }
          isPointOnSurface(t) {
            if (t.y < 0 || t.y > this.height || t.x < 0 || t.x > this.width) return !1;
            if (this.elevation || this.zoom >= r.bY) return !this.isPointAboveHorizon(t);
            const n = this.pointCoordinate(t);
            return n.y >= 0 && n.y <= 1;
          }
          _coordinatePoint(t, n) {
            const u = n && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude, d = [t.x * this.worldSize, t.y * this.worldSize, u + t.toAltitude(), 1];
            return r.ab.vec4.transformMat4(d, d, this.pixelMatrix), d[3] > 0 ? new r.P(d[0] / d[3], d[1] / d[3]) : new r.P(Number.MAX_VALUE, Number.MAX_VALUE);
          }
          _getBoundsNonRectangular() {
            const { top: t, left: n } = this._edgeInsets, u = this.height - this._edgeInsets.bottom, d = this.width - this._edgeInsets.right, _ = this.pointLocation3D(new r.P(n, t)), v = this.pointLocation3D(new r.P(d, t)), L = this.pointLocation3D(new r.P(d, u)), G = this.pointLocation3D(new r.P(n, u));
            let X = Math.min(_.lng, v.lng, L.lng, G.lng), K = Math.max(_.lng, v.lng, L.lng, G.lng), ae = Math.min(_.lat, v.lat, L.lat, G.lat), oe = Math.max(_.lat, v.lat, L.lat, G.lat);
            const pe = Math.pow(2, -this.zoom) / 16 * 270, Be = this.projection.name === "globe" ? 1 : 4, Re = (Ge, Ve, et, ut, st) => {
              const xt = (Ge + et) / 2, mt = (Ve + ut) / 2, _t = new r.P(xt, mt), { lng: dt, lat: gt } = this.pointLocation3D(_t), Rt = Math.max(0, X - dt, ae - gt, dt - K, gt - oe);
              X = Math.min(X, dt), K = Math.max(K, dt), ae = Math.min(ae, gt), oe = Math.max(oe, gt), (st < Be || Rt > pe) && (Re(Ge, Ve, xt, mt, st + 1), Re(xt, mt, et, ut, st + 1));
            };
            if (Re(n, t, d, t, 1), Re(d, t, d, u, 1), Re(d, u, n, u, 1), Re(n, u, n, t, 1), this.projection.name === "globe") {
              const [Ge, Ve] = r.bZ(this);
              Ge ? (oe = 90, K = 180, X = -180) : Ve && (ae = -90, K = 180, X = -180);
            }
            return new r.az(new r.bO(X, ae), new r.bO(K, oe));
          }
          _getBoundsRectangular(t, n) {
            const { top: u, left: d } = this._edgeInsets, _ = this.height - this._edgeInsets.bottom, v = this.width - this._edgeInsets.right, L = new r.P(d, u), G = new r.P(v, u), X = new r.P(v, _), K = new r.P(d, _);
            let ae = this.pointCoordinate(L, t), oe = this.pointCoordinate(G, t);
            const pe = this.pointCoordinate(X, n), Be = this.pointCoordinate(K, n), Re = (Ge, Ve) => (Ve.y - Ge.y) / (Ve.x - Ge.x);
            return ae.y > 1 && oe.y >= 0 ? ae = new r.aa((1 - Be.y) / Re(Be, ae) + Be.x, 1) : ae.y < 0 && oe.y <= 1 && (ae = new r.aa(-Be.y / Re(Be, ae) + Be.x, 0)), oe.y > 1 && ae.y >= 0 ? oe = new r.aa((1 - pe.y) / Re(pe, oe) + pe.x, 1) : oe.y < 0 && ae.y <= 1 && (oe = new r.aa(-pe.y / Re(pe, oe) + pe.x, 0)), new r.az().extend(this.coordinateLocation(ae)).extend(this.coordinateLocation(oe)).extend(this.coordinateLocation(Be)).extend(this.coordinateLocation(pe));
          }
          _getBoundsRectangularTerrain() {
            const t = this.elevation;
            if (!t.visibleDemTiles.length || t.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
            const n = t.visibleDemTiles.reduce((u, d) => {
              if (d.dem) {
                const _ = d.dem.tree;
                u.min = Math.min(u.min, _.minimums[0]), u.max = Math.max(u.max, _.maximums[0]);
              }
              return u;
            }, { min: Number.MAX_VALUE, max: 0 });
            return this._getBoundsRectangular(n.min * t.exaggeration(), n.max * t.exaggeration());
          }
          getBounds() {
            return this.projection.name === "mercator" || this.projection.name === "equirectangular" ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
          }
          horizonLineFromTop(t = !0) {
            const n = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, u = this.height / 2 - n * (1 - this._horizonShift);
            return t ? Math.max(0, u) : u;
          }
          getMaxBounds() {
            return this.maxBounds;
          }
          setMaxBounds(t) {
            this.maxBounds = t, this.minLat = -r.bX, this.maxLat = r.bX, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = r.at(this.minLng) * this.tileSize, this.worldMaxX = r.at(this.maxLng) * this.tileSize, this.worldMinY = r.aA(this.maxLat) * this.tileSize, this.worldMaxY = r.aA(this.minLat) * this.tileSize, this._constrain();
          }
          calculatePosMatrix(t, n) {
            return this.projection.createTileMatrix(this, n, t);
          }
          calculateDistanceTileData(t) {
            const n = t.key, u = this._distanceTileDataCache;
            if (u[n]) return u[n];
            const d = t.canonical, _ = 1 / this.height, v = this.cameraWorldSize, L = v / this.zoomScale(d.z), G = (d.x + Math.pow(2, d.z) * t.wrap) * L, X = d.y * L, K = this.point;
            K.x *= v / this.worldSize, K.y *= v / this.worldSize;
            const ae = this.angle, oe = Math.sin(-ae), pe = -Math.cos(-ae);
            return u[n] = { bearing: [oe, pe], center: [(K.x - G) * _, (K.y - X) * _], scale: L / r.ag * _ }, u[n];
          }
          calculateFogTileMatrix(t) {
            const n = t.key, u = this._fogTileMatrixCache;
            if (u[n]) return u[n];
            const d = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);
            return r.ab.mat4.multiply(d, this.worldToFogMatrix, d), u[n] = new Float32Array(d), u[n];
          }
          calculateProjMatrix(t, n = !1, u = !1) {
            const d = t.key;
            let _;
            if (_ = u ? this._expandedProjMatrixCache : n ? this._alignedProjMatrixCache : this._projMatrixCache, _[d]) return _[d];
            const v = this.calculatePosMatrix(t, this.worldSize);
            let L;
            return L = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : u ? this.expandedFarZProjMatrix : n ? this.alignedProjMatrix : this.projMatrix, r.ab.mat4.multiply(v, L, v), _[d] = new Float32Array(v), _[d];
          }
          calculatePixelsToTileUnitsMatrix(t) {
            const n = t.tileID.key, u = this._pixelsToTileUnitsCache;
            if (u[n]) return u[n];
            const d = r.b_(t, this);
            return u[n] = d, u[n];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          globeToMercatorMatrix() {
            if (this.projection.name === "globe") {
              const t = 1 / this.worldSize, n = r.ab.mat4.fromScaling([], [t, t, t]);
              return r.ab.mat4.multiply(n, n, this.globeMatrix), n;
            }
          }
          recenterOnTerrain() {
            if (!this._elevation || this.projection.name === "globe") return;
            const t = this._elevation;
            this._updateCameraState();
            const n = r.bH(1, this._center.lat) * this.worldSize, u = this._computeCameraPosition(n), d = this._camera.forward(), _ = r.bH(1, this._center.lat);
            u[2] /= _, d[2] /= _, r.ab.vec3.normalize(d, d);
            const v = t.raycast(u, d, t.exaggeration());
            if (v) {
              const L = r.ab.vec3.scaleAndAdd([], u, d, v), G = new r.aa(L[0], L[1], r.bH(L[2], r.aS(L[1]))), X = (G.z + r.ab.vec3.length([G.x - u[0], G.y - u[1], G.z - u[2] * _])) * this._pixelsPerMercatorPixel;
              this._seaLevelZoom = this._zoomFromMercatorZ(X), this._centerAltitude = G.toAltitude(), this._center = this.coordinateLocation(G), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
            }
          }
          _constrainCamera(t = !1) {
            if (!this._elevation) return;
            const n = this._elevation, u = r.bH(1, this._center.lat) * this.worldSize, d = this._computeCameraPosition(u), _ = n.getAtPointOrZero(new r.aa(...d)), v = this.pixelsPerMeter / this.worldSize * _, L = this._minimumHeightOverTerrain(), G = d[2] - v;
            if (G <= L) if (G < 0 || t) {
              const X = this.locationCoordinate(this._center, this._centerAltitude), K = [d[0], d[1], X.z - d[2]], ae = r.ab.vec3.length(K);
              K[2] -= (L - G) / this._pixelsPerMercatorPixel;
              const oe = r.ab.vec3.length(K);
              if (oe === 0) return;
              r.ab.vec3.scale(K, K, ae / oe * this._pixelsPerMercatorPixel), this._camera.position = [d[0], d[1], X.z * this._pixelsPerMercatorPixel - K[2]], this._updateStateFromCamera();
            } else this._isCameraConstrained = !0;
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining) return;
            this._constraining = !0;
            const t = this.projection.name === "globe" || this.mercatorFromTransition;
            if (this.projection.isReprojectedInTileSpace || t) {
              const oe = this.center;
              return oe.lat = r.aw(oe.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (oe.lng = r.aw(oe.lng, this.minLng, this.maxLng)), this.center = oe, void (this._constraining = !1);
            }
            const n = this._unmodified, { x: u, y: d } = this.point;
            let _ = 0, v = u, L = d;
            const G = this.width / 2, X = this.height / 2, K = this.worldMinY * this.scale, ae = this.worldMaxY * this.scale;
            if (d - X < K && (L = K + X), d + X > ae && (L = ae - X), ae - K < this.height && (_ = Math.max(_, this.height / (ae - K)), L = (ae + K) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
              const oe = this.worldMinX * this.scale, pe = this.worldMaxX * this.scale, Be = this.worldSize / 2 - (oe + pe) / 2;
              v = (u + Be + this.worldSize) % this.worldSize - Be, v - G < oe && (v = oe + G), v + G > pe && (v = pe - G), pe - oe < this.width && (_ = Math.max(_, this.width / (pe - oe)), v = (pe + oe) / 2);
            }
            v === u && L === d || (this.center = this.unproject(new r.P(v, L))), _ && (this.zoom += this.scaleZoom(_)), this._constrainCamera(), this._unmodified = n, this._constraining = !1;
          }
          _minZoomForBounds() {
            let t = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
            return this.maxBounds && (t = Math.max(t, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), t;
          }
          _maxCameraBoundsDistance() {
            return this._mercatorZfromZoom(this._minZoomForBounds());
          }
          _calcMatrices() {
            if (!this.height) return;
            const t = this.centerOffset, n = this.projection.name === "globe", u = this.pixelsPerMeter;
            this.projection.name === "globe" && (this._mercatorScaleRatio = r.bH(1, this.center.lat) / r.bH(1, r.c8));
            const d = r.b$(this.projection, this.zoom, this.width, this.height, 1024);
            this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, d), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
            const _ = this.projection.zAxisUnit === "meters" ? u : 1, v = this._camera.getWorldToCamera(this.worldSize, _);
            let L;
            const G = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
            if (G[8] = 2 * -t.x / this.width, G[9] = 2 * t.y / this.height, this.isOrthographic) {
              let gt = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), Rt = gt * this.aspect, Jt = -Rt, Vt = -gt;
              Rt -= t.x, Jt -= t.x, gt += t.y, Vt += t.y, L = this._camera.getCameraToClipOrthographic(Jt, Rt, Vt, gt, this._nearZ, this._farZ), ((or, sr, Bt, rr) => {
                for (let gr = 0; gr < 16; gr++) or[gr] = Lh(sr[gr], Bt[gr], rr);
              })(L, L, G, Yu(this.pitch >= 15 ? 1 : this.pitch / 15));
            } else L = G;
            const X = r.ab.mat4.mul([], G, v);
            let K = r.ab.mat4.mul([], L, v);
            if (this.projection.isReprojectedInTileSpace) {
              const gt = this.locationCoordinate(this.center), Rt = r.ab.mat4.identity([]);
              r.ab.mat4.translate(Rt, Rt, [gt.x * this.worldSize, gt.y * this.worldSize, 0]), r.ab.mat4.multiply(Rt, Rt, r.c0(this)), r.ab.mat4.translate(Rt, Rt, [-gt.x * this.worldSize, -gt.y * this.worldSize, 0]), r.ab.mat4.multiply(K, K, Rt), r.ab.mat4.multiply(X, X, Rt), this.inverseAdjustmentMatrix = r.c1(this);
            } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
            if (this.mercatorMatrix = r.ab.mat4.scale([], K, [this.worldSize, this.worldSize, this.worldSize / _, 1]), this.projMatrix = K, this.invProjMatrix = r.ab.mat4.invert(new Float64Array(16), this.projMatrix), n) {
              const gt = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
              gt[8] = 2 * -t.x / this.width, gt[9] = 2 * t.y / this.height, this.expandedFarZProjMatrix = r.ab.mat4.mul([], gt, v);
            } else this.expandedFarZProjMatrix = this.projMatrix;
            const ae = r.ab.mat4.invert([], L);
            this.frustumCorners = r.c2.fromInvProjectionMatrix(ae, this.horizonLineFromTop(), this.height), this.cameraFrustum = r.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !n);
            const oe = new Float32Array(16);
            r.ab.mat4.identity(oe), r.ab.mat4.scale(oe, oe, [1, -1, 1]), r.ab.mat4.rotateX(oe, oe, this._pitch), r.ab.mat4.rotateZ(oe, oe, this.angle);
            const pe = r.ab.mat4.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
            this.starsProjMatrix = r.ab.mat4.clone(pe);
            const Be = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
            pe[8] = 2 * -t.x / this.width, pe[9] = 2 * (t.y + Be) / this.height, this.skyboxMatrix = r.ab.mat4.multiply(oe, pe, oe);
            const Re = this.point, Ge = Re.x, Ve = Re.y, et = this.width % 2 / 2, ut = this.height % 2 / 2, st = Math.cos(this.angle), xt = Math.sin(this.angle), mt = Ge - Math.round(Ge) + st * et + xt * ut, _t = Ve - Math.round(Ve) + st * ut + xt * et, dt = new Float64Array(K);
            if (r.ab.mat4.translate(dt, dt, [mt > 0.5 ? mt - 1 : mt, _t > 0.5 ? _t - 1 : _t, 0]), this.alignedProjMatrix = dt, K = r.ab.mat4.create(), r.ab.mat4.scale(K, K, [this.width / 2, -this.height / 2, 1]), r.ab.mat4.translate(K, K, [1, -1, 0]), this.labelPlaneMatrix = K, K = r.ab.mat4.create(), r.ab.mat4.scale(K, K, [1, -1, 1]), r.ab.mat4.translate(K, K, [-1, -1, 0]), r.ab.mat4.scale(K, K, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = K, this.pixelMatrix = r.ab.mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, X), this._calcFogMatrices(), this._distanceTileDataCache = {}, K = r.ab.mat4.invert(new Float64Array(16), this.pixelMatrix), !K) throw new Error("failed to invert matrix");
            if (this.pixelMatrixInverse = K, this.projection.name === "globe" || this.mercatorFromTransition) {
              this.globeMatrix = r.c3(this);
              const gt = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
              this.globeCenterInViewSpace = r.ab.vec3.transformMat4(gt, gt, v), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
            } else this.globeMatrix = K;
            this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
          }
          _calcFogMatrices() {
            this._fogTileMatrixCache = {};
            const t = this.cameraWorldSizeForFog, n = this.cameraPixelsPerMeter, u = this._camera.position, d = 1 / this.height / this._pixelsPerMercatorPixel, _ = [t, t, n];
            r.ab.vec3.scale(_, _, d), r.ab.vec3.scale(u, u, -1), r.ab.vec3.multiply(u, u, _);
            const v = r.ab.mat4.create();
            r.ab.mat4.translate(v, v, u), r.ab.mat4.scale(v, v, _), this.mercatorFogMatrix = v, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, n, d);
          }
          _computeCameraPosition(t) {
            const n = (t = t || this.pixelsPerMeter) / this.pixelsPerMeter, u = this._camera.forward(), d = this.point, _ = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * n - t / this.worldSize * this._centerAltitude;
            return [d.x / this.worldSize - u[0] * _, d.y / this.worldSize - u[1] * _, t / this.worldSize * this._centerAltitude - u[2] * _];
          }
          _updateCameraState() {
            this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
          }
          _translateCameraConstrained(t) {
            const n = this._maxCameraBoundsDistance() * Math.cos(this._pitch), u = this._camera.position[2], d = t[2];
            let _ = 1;
            this.projection.wrap && (this.center = this.center.wrap()), d > 0 && (_ = Math.min((n - u) / d, 1)), this._camera.position = r.ab.vec3.scaleAndAdd([], this._camera.position, t, _), this._updateStateFromCamera();
          }
          _updateStateFromCamera() {
            const t = this._camera.position, n = this._camera.forward(), { pitch: u, bearing: d } = this._camera.getPitchBearing(), _ = r.bH(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, v = this._mercatorZfromZoom(this._maxZoom) * Math.cos(r.ai(this._maxPitch)), L = Math.max((t[2] - _) / Math.cos(u), v), G = this._zoomFromMercatorZ(L);
            r.ab.vec3.scaleAndAdd(t, t, n, L), this._pitch = r.aw(u, r.ai(this.minPitch), r.ai(this.maxPitch)), this.angle = r.bF(d, -Math.PI, Math.PI), this._setZoom(r.aw(G, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new r.aa(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
          }
          _worldSizeFromZoom(t) {
            return Math.pow(2, t) * this.tileSize;
          }
          _mercatorZfromZoom(t) {
            return this.cameraToCenterDistance / this._worldSizeFromZoom(t);
          }
          _minimumHeightOverTerrain() {
            const t = Math.min(this._seaLevelZoom != null ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
            return this._mercatorZfromZoom(t);
          }
          _zoomFromMercatorZ(t) {
            return this.scaleZoom(this.cameraToCenterDistance / (t * this.tileSize));
          }
          zoomFromMercatorZAdjusted(t) {
            let n = 0, u = r.bY, d = 0, _ = 1 / 0;
            for (; u - n > 1e-6 && u > n; ) {
              const v = n + 0.5 * (u - n), L = this.tileSize * Math.pow(2, v), G = this.getCameraToCenterDistance(this.projection, v, L), X = this.scaleZoom(G / (t * this.tileSize)), K = Math.abs(v - X);
              K < _ && (_ = K, d = v), v < X ? n = v : u = v;
            }
            return d;
          }
          _terrainEnabled() {
            return !(!this._elevation || !this.projection.supportsTerrain && (r.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
          }
          anyCornerOffEdge(t, n) {
            const u = Math.min(t.x, n.x), d = Math.max(t.x, n.x), _ = Math.min(t.y, n.y), v = Math.max(t.y, n.y);
            if (_ < this.horizonLineFromTop(!1)) return !0;
            if (this.projection.name !== "mercator") return !1;
            const L = [new r.P(u, _), new r.P(d, v), new r.P(u, v), new r.P(d, _)], G = this.renderWorldCopies ? -3 : 0, X = this.renderWorldCopies ? 4 : 1;
            for (const K of L) {
              const ae = this.pointRayIntersection(K);
              if (ae.t < 0) return !0;
              const oe = this.rayIntersectionCoordinate(ae);
              if (oe.x < G || oe.y < 0 || oe.x > X || oe.y > 1) return !0;
            }
            return !1;
          }
          isHorizonVisible() {
            return this.pitch + r.c4(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new r.P(0, 0), new r.P(this.width, this.height));
          }
          zoomDeltaToMovement(t, n) {
            const u = r.ab.vec3.length(r.ab.vec3.sub([], this._camera.position, t)), d = this._zoomFromMercatorZ(u) + n;
            return u - this._mercatorZfromZoom(d);
          }
          getCameraPoint() {
            if (this.projection.name === "globe") {
              const t = function([n, u, d], _) {
                const v = [n, u, d, 1];
                r.ab.vec4.transformMat4(v, v, _);
                const L = v[3] = Math.max(v[3], 1e-6);
                return v[0] /= L, v[1] /= L, v[2] /= L, v;
              }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
              return new r.P(t[0], t[1]);
            }
            {
              const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new r.P(0, t));
            }
          }
          getCameraToCenterDistance(t, n = this.zoom, u = this.worldSize) {
            const d = r.b$(t, n, this.width, this.height, 1024), _ = t.pixelSpaceConversion(this.center.lat, u, d);
            let v = 0.5 / Math.tan(0.5 * this._fov) * this.height * _;
            return this.isOrthographic && (v = Lh(1, v, Yu(this.pitch >= 15 ? 1 : this.pitch / 15))), v;
          }
          getWorldToCameraMatrix() {
            const t = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === "meters" ? this.pixelsPerMeter : 1);
            return this.projection.name === "globe" && r.ab.mat4.multiply(t, t, this.globeMatrix), t;
          }
          getFrustum(t) {
            return r.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t, this.projection.zAxisUnit === "meters");
          }
        }
        const To = (l, t) => {
          if (t > 0 && l.terrain && r.w("Cutoff is currently disabled on terrain"), t <= 0 || l.terrain) return { shouldRenderCutoff: !1, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
          const n = l.transform, u = Math.max(Math.abs(n._zoom - (l.minCutoffZoom - 1)), 1), d = n.isLODDisabled(!1) ? r.ac(60, 45, n.pitch) : r.ac(30, 15, n.pitch), _ = n._farZ - n._nearZ, v = t * n.height, L = ((1 - (G = d)) * n.cameraToCenterDistance + G * (n._farZ + v)) * u;
          var G;
          return { shouldRenderCutoff: d < 1, uniformValues: { u_cutoff_params: [n._nearZ, n._farZ, (L - n._nearZ) / _, (L - v - n._nearZ) / _] } };
        }, qn = { cascadeCount: 2, normalOffset: 3, shadowMapResolution: 2048 };
        class ys {
          constructor(t, n) {
            this.aabb = t, this.lastCascade = n;
          }
        }
        class fu {
          add(t, n) {
            const u = this.receivers[t.key];
            u !== void 0 ? (u.aabb.min[0] = Math.min(u.aabb.min[0], n.min[0]), u.aabb.min[1] = Math.min(u.aabb.min[1], n.min[1]), u.aabb.min[2] = Math.min(u.aabb.min[2], n.min[2]), u.aabb.max[0] = Math.max(u.aabb.max[0], n.max[0]), u.aabb.max[1] = Math.max(u.aabb.max[1], n.max[1]), u.aabb.max[2] = Math.max(u.aabb.max[2], n.max[2])) : this.receivers[t.key] = new ys(n, null);
          }
          clear() {
            this.receivers = {};
          }
          get(t) {
            return this.receivers[t.key];
          }
          computeRequiredCascades(t, n, u) {
            const d = r.cd.fromPoints(t.points);
            let _ = 0;
            for (const v in this.receivers) {
              const L = this.receivers[v];
              if (!L || !d.intersectsAabb(L.aabb)) continue;
              L.aabb.min = d.closestPoint(L.aabb.min), L.aabb.max = d.closestPoint(L.aabb.max);
              const G = L.aabb.getCorners();
              for (let X = 0; X < u.length; X++) {
                let K = !0;
                for (const ae of G) {
                  const oe = [ae[0] * n, ae[1] * n, ae[2]];
                  if (r.ab.vec3.transformMat4(oe, oe, u[X].matrix), oe[0] < -1 || oe[0] > 1 || oe[1] < -1 || oe[1] > 1) {
                    K = !1;
                    break;
                  }
                }
                if (L.lastCascade = X, _ = Math.max(_, X), K) break;
              }
            }
            return _ + 1;
          }
        }
        class wl {
          constructor(t) {
            this.painter = t, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new fu(), this._depthMode = new ui(t.context.gl.LEQUAL, ui.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = !1, this.useNormalOffset = !1, t.tp.registerParameter(this, ["Shadows"], "_forceDisable", { label: "forceDisable" }, () => {
              this.painter.style.map.triggerRepaint();
            }), t.tp.registerParameter(qn, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), t.tp.registerParameter(qn, ["Shadows"], "normalOffset", { min: 0, max: 10, step: 0.05 }), t.tp.registerParameter(qn, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 }), t.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", { readonly: !0, label: "numCascadesToRender" });
          }
          destroy() {
            for (const t of this._cascades) t.texture.destroy(), t.framebuffer.destroy();
            this._cascades = [];
          }
          updateShadowParameters(t, n) {
            const u = this.painter;
            if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !n || !n.properties) return;
            const d = n.properties.get("shadow-intensity");
            if (!n.shadowsEnabled() || d <= 0 || (this._shadowLayerCount = u.style.order.reduce((Be, Re) => {
              const Ge = u.style._mergedLayers[Re];
              return Be + (Ge.hasShadowPass() && !Ge.isHidden(t.zoom) ? 1 : 0);
            }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled)) return;
            const _ = u.context, v = qn.shadowMapResolution, L = qn.shadowMapResolution;
            if (this._cascades.length === 0 || qn.shadowMapResolution !== this._cascades[0].texture.size[0]) {
              this._cascades = [];
              for (let Be = 0; Be < qn.cascadeCount; ++Be) {
                const Re = u._shadowMapDebug, Ge = _.gl, Ve = _.createFramebuffer(v, L, Re, "texture"), et = new r.T(_, { width: v, height: L, data: null }, Ge.DEPTH_COMPONENT16);
                if (Ve.depthAttachment.set(et.texture), Re) {
                  const ut = new r.T(_, { width: v, height: L, data: null }, Ge.RGBA8);
                  Ve.colorAttachment.set(ut.texture);
                }
                this._cascades.push({ framebuffer: Ve, texture: et, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new r.bR(), scale: 0 });
              }
            }
            this.shadowDirection = vs(n);
            let G = 0;
            if (t.elevation) {
              const Be = t.elevation, Re = [1e4, -1e4];
              Be.visibleDemTiles.filter((Ge) => Ge.dem).forEach((Ge) => {
                const Ve = Ge.dem.tree;
                Re[0] = Math.min(Re[0], Ve.minimums[0]), Re[1] = Math.max(Re[1], Ve.maximums[0]);
              }), Re[0] !== 1e4 && (G = (Re[1] - Re[0]) * Be.exaggeration());
            }
            const X = 1.5 * t.cameraToCenterDistance, K = 3 * X, ae = new Float64Array(16);
            for (let Be = 0; Be < this._cascades.length; ++Be) {
              const Re = this._cascades[Be];
              let Ge = t.height / 50, Ve = 1;
              qn.cascadeCount === 1 ? Ve = K : Be === 0 ? Ve = X : (Ge = X, Ve = K);
              const [et, ut] = yf(t, this.shadowDirection, Ge, Ve, qn.shadowMapResolution, G);
              Re.scale = t.scale, Re.matrix = et, Re.boundingSphereRadius = ut, r.ab.mat4.invert(ae, Re.matrix), Re.frustum = r.bR.fromInvProjectionMatrix(ae, 1, 0, !0), Re.far = Ve;
            }
            const oe = this._cascades.length - 1;
            this._uniformValues.u_fade_range = [0.75 * this._cascades[oe].far, this._cascades[oe].far], this._uniformValues.u_shadow_intensity = d, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / qn.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = qn.shadowMapResolution, this._uniformValues.u_shadowmap_0 = xa.ShadowMap0, this._uniformValues.u_shadowmap_1 = xa.ShadowMap0 + 1, this._groundShadowTiles = u.transform.coveringTiles({ tileSize: 512, renderWorldCopies: !0 });
            const pe = u.transform.elevation;
            for (const Be of this._groundShadowTiles) {
              let Re = { min: 0, max: 0 };
              if (pe) {
                const Ge = pe.getMinMaxForTile(Be);
                Ge && (Re = Ge);
              }
              this.addShadowReceiver(Be.toUnwrapped(), Re.min, Re.max);
            }
          }
          get enabled() {
            return this._enabled && !this._forceDisable;
          }
          set enabled(t) {
            this._enabled = t;
          }
          drawShadowPass(t, n) {
            if (!this.enabled) return;
            const u = this.painter, d = u.context;
            this._numCascadesToRender = this._receivers.computeRequiredCascades(u.transform.getFrustum(0), u.transform.worldSize, this._cascades), d.viewport.set([0, 0, qn.shadowMapResolution, qn.shadowMapResolution]);
            for (let _ = 0; _ < this._numCascadesToRender; ++_) {
              u.currentShadowCascade = _, d.bindFramebuffer.set(this._cascades[_].framebuffer.framebuffer), d.clear({ color: r.aj.white, depth: 1 });
              for (const v of t.order) {
                const L = t._mergedLayers[v];
                if (!L.hasShadowPass() || L.isHidden(u.transform.zoom)) continue;
                const G = t.getLayerSourceCache(L), X = G ? n[G.id] : void 0;
                (L.type === "model" || X && X.length) && u.renderLayer(u, G, L, X);
              }
            }
            u.currentShadowCascade = 0;
          }
          drawGroundShadows() {
            if (!this.enabled) return;
            const t = this.painter, n = t.style, u = t.context, d = n.directionalLight, _ = n.ambientLight;
            if (!d || !_) return;
            const v = [], L = To(t, t.longestCutoffRange);
            L.shouldRenderCutoff && v.push("RENDER_CUTOFF"), v.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && v.push("NORMAL_OFFSET");
            const G = Ku(n, d, _), X = new ui(u.gl.LEQUAL, ui.ReadOnly, t.depthRangeFor3D);
            for (const K of this._groundShadowTiles) {
              const ae = K.toUnwrapped(), oe = t.isTileAffectedByFog(K), pe = t.getOrCreateProgram("groundShadow", { defines: v, overrideFog: oe });
              this.setupShadows(ae, pe), t.uploadCommonUniforms(u, pe, ae, null, L);
              const Be = { u_matrix: t.transform.calculateProjMatrix(ae), u_ground_shadow_factor: G };
              pe.draw(t, u.gl.TRIANGLES, X, _i.disabled, zi.multiply, vi.disabled, Be, "ground_shadow", t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments, {}, t.transform.zoom, null, null);
            }
          }
          getShadowPassColorMode() {
            return this.painter._shadowMapDebug ? zi.unblended : zi.disabled;
          }
          getShadowPassDepthMode() {
            return this._depthMode;
          }
          getShadowCastingLayerCount() {
            return this._shadowLayerCount;
          }
          calculateShadowPassMatrixFromTile(t) {
            const n = this.painter.transform, u = n.calculatePosMatrix(t, n.worldSize);
            return r.ab.mat4.multiply(u, this._cascades[this.painter.currentShadowCascade].matrix, u), Float32Array.from(u);
          }
          calculateShadowPassMatrixFromMatrix(t) {
            return r.ab.mat4.multiply(t, this._cascades[this.painter.currentShadowCascade].matrix, t), Float32Array.from(t);
          }
          setupShadows(t, n, u, d = 0) {
            if (!this.enabled) return;
            const _ = this.painter.transform, v = this.painter.context, L = v.gl, G = this._uniformValues, X = new Float64Array(16), K = _.calculatePosMatrix(t, _.worldSize);
            for (let ae = 0; ae < this._cascades.length; ae++) r.ab.mat4.multiply(X, this._cascades[ae].matrix, K), G[ae === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(X), v.activeTexture.set(L.TEXTURE0 + xa.ShadowMap0 + ae), this._cascades[ae].texture.bind(L.NEAREST, L.CLAMP_TO_EDGE);
            if (this.useNormalOffset = !!u, this.useNormalOffset) {
              const ae = r.cc(t.canonical), oe = 2 / _.tileSize * r.ag / qn.shadowMapResolution, pe = oe * this._cascades[0].boundingSphereRadius, Be = oe * this._cascades[this._cascades.length - 1].boundingSphereRadius, Re = (u === "vector-tile" ? 1 : 3) / Math.pow(2, d - t.canonical.z - (1 - _.zoom + Math.floor(_.zoom)));
              G.u_shadow_normal_offset = [ae, pe * Re, Be * Re], G.u_shadow_bias = [6e-5, 12e-4, 0.012];
            } else G.u_shadow_bias = [36e-5, 12e-4, 0.012];
            n.setShadowUniformValues(v, G);
          }
          setupShadowsFromMatrix(t, n, u = !1) {
            if (!this.enabled) return;
            const d = this.painter.context, _ = d.gl, v = this._uniformValues, L = new Float64Array(16);
            for (let G = 0; G < qn.cascadeCount; G++) r.ab.mat4.multiply(L, this._cascades[G].matrix, t), v[G === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(L), d.activeTexture.set(_.TEXTURE0 + xa.ShadowMap0 + G), this._cascades[G].texture.bind(_.NEAREST, _.CLAMP_TO_EDGE);
            if (this.useNormalOffset = u, u) {
              const G = qn.normalOffset;
              v.u_shadow_normal_offset = [1, G, G], v.u_shadow_bias = [6e-5, 12e-4, 0.012];
            } else v.u_shadow_bias = [36e-5, 12e-4, 0.012];
            n.setShadowUniformValues(d, v);
          }
          getShadowUniformValues() {
            return this._uniformValues;
          }
          getCurrentCascadeFrustum() {
            return this._cascades[this.painter.currentShadowCascade].frustum;
          }
          computeSimplifiedTileShadowVolume(t, n, u, d) {
            if (d[2] >= 0) return {};
            const _ = function(G, X, K) {
              const ae = K / (1 << G.canonical.z);
              return new r.cd([G.canonical.x * ae + G.wrap * K, G.canonical.y * ae + G.wrap * K, 0], [(G.canonical.x + 1) * ae + G.wrap * K, (G.canonical.y + 1) * ae + G.wrap * K, X]);
            }(t, n, u).getCorners(), v = n / -d[2];
            d[0] < 0 ? (r.ab.vec3.add(_[0], _[0], [d[0] * v, 0, 0]), r.ab.vec3.add(_[3], _[3], [d[0] * v, 0, 0])) : d[0] > 0 && (r.ab.vec3.add(_[1], _[1], [d[0] * v, 0, 0]), r.ab.vec3.add(_[2], _[2], [d[0] * v, 0, 0])), d[1] < 0 ? (r.ab.vec3.add(_[0], _[0], [0, d[1] * v, 0]), r.ab.vec3.add(_[1], _[1], [0, d[1] * v, 0])) : d[1] > 0 && (r.ab.vec3.add(_[2], _[2], [0, d[1] * v, 0]), r.ab.vec3.add(_[3], _[3], [0, d[1] * v, 0]));
            const L = {};
            return L.vertices = _, L.planes = [Hs(_[1], _[0], _[4]), Hs(_[2], _[1], _[5]), Hs(_[3], _[2], _[6]), Hs(_[0], _[3], _[7])], L;
          }
          addShadowReceiver(t, n, u) {
            this._receivers.add(t, r.cd.fromTileIdAndHeight(t, n, u));
          }
          getMaxCascadeForTile(t) {
            const n = this._receivers.get(t);
            return n && n.lastCascade ? n.lastCascade : 0;
          }
        }
        function Hs(l, t, n) {
          const u = r.ab.vec3.sub([], n, t), d = r.ab.vec3.sub([], l, t), _ = r.ab.vec3.cross([], u, d), v = r.ab.vec3.length(_);
          return v === 0 ? [0, 0, 1, 0] : (r.ab.vec3.scale(_, _, 1 / v), [_[0], _[1], _[2], -r.ab.vec3.dot(_, t)]);
        }
        function vs(l) {
          const t = l.properties.get("direction"), n = r.cb(t.x, t.y, t.z);
          n[2] = r.aw(n[2], 0, 75);
          const u = r.ce([n[0], n[1], n[2]]);
          return r.ab.vec3.fromValues(u.x, u.y, u.z);
        }
        function Ku(l, t, n) {
          const u = t.properties.get("color-use-theme") === "none", d = t.properties.get("color"), _ = t.properties.get("intensity"), v = t.properties.get("direction"), L = [v.x, v.y, v.z], G = n.properties.get("color-use-theme") === "none", X = n.properties.get("color"), K = n.properties.get("intensity"), ae = Math.max(r.ab.vec3.dot([0, 0, 1], L), 0), oe = [0, 0, 0];
          r.ab.vec3.scale(oe, X.toRenderColor(G ? null : l.getLut(t.scope)).toArray01Linear().slice(0, 3), K);
          const pe = [0, 0, 0];
          return r.ab.vec3.scale(pe, d.toRenderColor(u ? null : l.getLut(n.scope)).toArray01Linear().slice(0, 3), ae * _), r.cf([oe[0] > 0 ? oe[0] / (oe[0] + pe[0]) : 0, oe[1] > 0 ? oe[1] / (oe[1] + pe[1]) : 0, oe[2] > 0 ? oe[2] / (oe[2] + pe[2]) : 0]);
        }
        function yf(l, t, n, u, d, _) {
          const v = l.zoom, L = l.scale, G = l.worldSize, X = 1 / G, K = l.aspect, ae = Math.sqrt(1 + K * K) * Math.tan(0.5 * l.fovX), oe = ae * ae, pe = u - n, Be = u + n;
          let Re, Ge;
          oe > pe / Be ? (Re = u, Ge = u * ae) : (Re = 0.5 * Be * (1 + oe), Ge = 0.5 * Math.sqrt(pe * pe + 2 * (u * u + n * n) * oe + Be * Be * oe * oe));
          const Ve = l.projection.pixelsPerMeter(l.center.lat, G), et = l._camera.getCameraToWorldMercator(), ut = [0, 0, -Re * X];
          r.ab.vec3.transformMat4(ut, ut, et);
          let st = Ge * X;
          const xt = l._edgeInsets;
          if (!(xt.left === 0 && xt.top === 0 && xt.right === 0 && xt.bottom === 0 || xt.left === xt.right && xt.top === xt.bottom)) {
            const Tr = l._camera.getWorldToCamera(l.worldSize, l.projection.zAxisUnit === "meters" ? Ve : 1), mr = l._camera.getCameraToClipPerspective(l._fov, l.width / l.height, n, u);
            mr[8] = 2 * -l.centerOffset.x / l.width, mr[9] = 2 * l.centerOffset.y / l.height;
            const hr = new Float64Array(16);
            r.ab.mat4.mul(hr, mr, Tr);
            const br = new Float64Array(16);
            r.ab.mat4.invert(br, hr);
            const Cr = r.bR.fromInvProjectionMatrix(br, G, v, !0);
            for (const Hr of Cr.points) {
              const Zr = ((mt = Hr)[0] /= L, mt[1] /= L, mt[2] = r.bH(mt[2], l._center.lat), mt);
              st = Math.max(st, r.ab.vec3.len(r.ab.vec3.subtract([], ut, Zr)));
            }
          }
          var mt;
          st *= d / (d - 1);
          const _t = Math.acos(t[2]), dt = Math.atan2(-t[0], -t[1]), gt = new ua();
          gt.position = ut, gt.setPitchBearing(_t, dt);
          const Rt = gt.getWorldToCamera(G, Ve), Jt = st * G, Vt = Math.min(l._mercatorZfromZoom(17) * G * -2, -2 * Jt), or = gt.getCameraToClipOrthographic(-Jt, Jt, -Jt, Jt, Vt, (Jt + _ * Ve) / t[2]), sr = new Float64Array(16);
          r.ab.mat4.multiply(sr, or, Rt);
          const Bt = r.ab.vec3.fromValues(Math.floor(1e6 * ut[0]) / 1e6 * G, Math.floor(1e6 * ut[1]) / 1e6 * G, 0), rr = 0.5 * d, gr = [0, 0, 0];
          r.ab.vec3.transformMat4(gr, Bt, sr), r.ab.vec3.scale(gr, gr, rr);
          const Ut = [Math.floor(gr[0]), Math.floor(gr[1]), Math.floor(gr[2])], dr = [0, 0, 0];
          r.ab.vec3.sub(dr, gr, Ut), r.ab.vec3.scale(dr, dr, -1 / rr);
          const ir = new Float64Array(16);
          return r.ab.mat4.identity(ir), r.ab.mat4.translate(ir, ir, dr), r.ab.mat4.multiply(sr, ir, sr), [sr, Jt];
        }
        class Oc extends r.E {
          constructor(t) {
            super(), this.requestManager = t, this.models = { "": {} }, this.modelUris = { "": {} }, this.numModelsLoading = {};
          }
          loadModel(t, n) {
            return r.aM(this.requestManager.transformRequest(n, r.R.Model).url).then((u) => {
              if (!u) return;
              const d = r.aN(u), _ = new r.aO(t, void 0, void 0, d);
              return _.computeBoundsAndApplyParent(), _;
            }).catch((u) => {
              if (u && u.status === 404) return null;
              this.fire(new r.y(new Error(`Could not load model ${t} from ${n}: ${u.message}`)));
            });
          }
          load(t, n, u = { keepNumReferences: !1 }) {
            this.models[n] || (this.models[n] = {});
            const d = Object.keys(t);
            this.numModelsLoading[n] = (this.numModelsLoading[n] || 0) + d.length;
            const _ = [];
            for (const v of d) _.push(this.loadModel(v, t[v]));
            Promise.allSettled(_).then((v) => {
              for (let L = 0; L < v.length; L++) {
                const { status: G, value: X } = v[L];
                if (G === "fulfilled" && X) {
                  const K = this.models[n][d[L]];
                  this.models[n][d[L]] = { model: X, numReferences: u.keepNumReferences && K ? K.numReferences : 1 };
                }
              }
              this.numModelsLoading[n] -= d.length, this.fire(new r.z("data", { dataType: "style" }));
            }).catch((v) => {
              this.fire(new r.y(new Error(`Could not load models: ${v.message}`)));
            });
          }
          isLoaded() {
            for (const t in this.numModelsLoading) if (this.numModelsLoading[t] > 0) return !1;
            return !0;
          }
          hasModel(t, n) {
            return !!this.getModel(t, n);
          }
          getModel(t, n) {
            return this.models[n] || (this.models[n] = {}), this.models[n][t] ? this.models[n][t].model : void 0;
          }
          addModel(t, n, u) {
            this.models[u] || (this.models[u] = {}), this.modelUris[u] || (this.modelUris[u] = {}), this.hasModel(t, u) && this.models[u][t].numReferences++, this.modelUris[u][t] = this.requestManager.normalizeModelURL(n), this.load({ [t]: this.modelUris[u][t] }, u);
          }
          addModels(t, n) {
            this.models[n] || (this.models[n] = {}), this.modelUris[n] || (this.modelUris[n] = {});
            const u = this.modelUris[n];
            for (const d in t) this.models[n][d] = {}, u[d] = this.requestManager.normalizeModelURL(t[d]);
            this.load(u, n, { keepNumReferences: !0 });
          }
          reloadModels(t) {
            this.load(this.modelUris[t], t);
          }
          addModelsFromBucket(t, n) {
            this.models[n] || (this.models[n] = {}), this.modelUris[n] || (this.modelUris[n] = {});
            const u = {};
            for (const d of t) this.hasModel(d, n) ? this.models[n][d].numReferences++ : (this.modelUris[n][d] = this.requestManager.normalizeModelURL(d), u[d] = this.modelUris[n][d]);
            this.load(u, n);
          }
          removeModel(t, n) {
            if (this.models[n] && this.models[n][t] && (this.models[n][t].numReferences--, this.models[n][t].numReferences === 0)) {
              const u = this.models[n][t].model;
              delete this.models[n][t], delete this.modelUris[n][t], u.destroy();
            }
          }
          listModels(t) {
            return this.models[t] || (this.models[t] = {}), Object.keys(this.models[t]);
          }
          upload(t, n) {
            this.models[n] || (this.models[n] = {});
            for (const u in this.models[n]) this.models[n][u].model && this.models[n][u].model.upload(t.context);
          }
        }
        const vf = new r.a5({ data: new r.a6(r.a3.colorTheme.data) }), xf = { "mbx-indoor-active-floorplans": { default: ["literal", []] }, "mbx-indoor-underground": { default: ["literal", !1] }, "mbx-indoor-loaded-levels": { default: ["literal", []] }, "mbx-indoor-level-height": { default: ["literal", {}] }, "mbx-indoor-level-base": { default: ["literal", {}] }, "mbx-indoor-level-selected": { default: ["literal", {}] }, "mbx-indoor-level-overlapped": { default: ["literal", {}] } };
        function Dh(l) {
          return l = l || {}, Object.assign(l, xf);
        }
        class kh extends r.E {
          constructor(t) {
            super(), this.mergeFloors = !0, this._scope = void 0, this._queryFeatureSetId = void 0, this._buildingEntryFeatureSetId = void 0, this._selectedFloorplan = void 0, this._indoorData = void 0, this._selectedLevel = void 0, this._floorplanStates = {}, r.aP(["_onLoad", "_onMove", "_checkFloorplanVisible"], this), this._map = t, this._checkFloorplanVisible(!0), this._map.on("load", this._onLoad), this._map.on("move", this._onMove);
          }
          destroy() {
            this._map.indoor.off("load", this._onLoad), this._map.indoor.off("move", this._onMove), this._map = void 0;
          }
          _onLoad() {
            this._map.style.forEachFragmentStyle((t) => {
              t.stylesheet.indoor && (this._queryFeatureSetId ? this.fire(new r.y(new Error("Multiple indoor map styles detected, simultaneous usage is not allowed currently."))) : (this._queryFeatureSetId = t.stylesheet.indoor.floorplanFeaturesetId, this._buildingEntryFeatureSetId = t.stylesheet.indoor.buildingFeaturesetId, this._scope = t.scope));
            }), this._queryFeatureSetId && this._buildingEntryFeatureSetId && this._map.addInteraction("mbx-indoor-buildingclick", { type: "click", target: { featuresetId: this._buildingEntryFeatureSetId, importId: this._scope }, handler: (t) => (t.feature && t.feature.properties.floorplan && this.selectFloorplan(t.feature.properties.floorplan), !0) }), this._checkFloorplanVisible(!0);
          }
          _onMove() {
            this._checkFloorplanVisible(!1);
          }
          _checkFloorplanVisible(t) {
            if (!this._queryFeatureSetId || !this._map.isStyleLoaded() || this._map.transform.zoom < 13) return;
            this._indoorData && !function(v, L) {
              const [G, X] = v, { center: K, radius: ae } = L, [oe, pe] = K, Be = Math.abs(G - oe);
              return Math.sqrt((Be > 180 ? 360 - Be : Be) ** 2 + (X - pe) ** 2) <= ae;
            }([this._map.getCenter().lng, this._map.getCenter().lat], this._indoorData.circumCircle) && (this._indoorData = void 0, this._selectedFloorplan = void 0, this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", ["literal", []]), this.fire(new r.z("floorplangone")));
            const n = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, u = new r.P(this._map.transform.width / 2, this._map.transform.height / 2), d = [new r.P(0, 0), new r.P(this._map.transform.width, this._map.transform.height)], _ = this._map.queryRenderedFeatures(t ? d : u, n);
            _.length > 0 && (this._selectedFloorplan && _[0].properties.id === this._selectedFloorplan.properties.id || (this._selectedFloorplan = _[0], this._floorplanSelected(!1)));
          }
          _floorplanSelected(t) {
            this._indoorData = JSON.parse(this._selectedFloorplan.properties["indoor-data"]), this._indoorData.id = this._selectedFloorplan.properties.id, this._indoorData.circumCircle = function(_) {
              const [[v, L], [G, X]] = _, K = (G - v + 360) % 360, ae = K > 180 ? 360 - K : K;
              return { center: [(v + ae / 2 + 360) % 360, (L + X) / 2], radius: Math.sqrt(ae ** 2 + (X - L) ** 2) / 2 };
            }(this._indoorData.extent), this._floorplanStates[this._indoorData.id] || (this._floorplanStates[this._indoorData.id] = {});
            const n = this._floorplanStates[this._indoorData.id].selectedBuilding, u = this._floorplanStates[this._indoorData.id].selectedLevel;
            let d;
            if (this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", this._indoorData.floorplanIDs), this._selectedLevel) for (const _ of this._indoorData.levels) _.id === this._selectedLevel.id && (d = _.id);
            if (this.fire(new r.z("floorplanselected", { buildings: this._indoorData.buildings, levels: this._indoorData.levels, selectedLevelId: d })), n) {
              const _ = this._indoorData.buildings.find((v) => v.id === n);
              this._buildingSelected(_, !1);
            } else this._indoorData.buildings.length > 0 && this._buildingSelected(this._indoorData.buildings[0], !1);
            if (u) {
              const _ = this._indoorData.levels.find((v) => v.id === u);
              this._updateLevels(_, t);
            } else t && this._indoorData["default-levels"].length > 0 && this.selectLevel(this._indoorData["default-levels"][0]);
          }
          _buildingSelected(t, n) {
            n && t && t.extent && this._map.fitBounds(t.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), this._floorplanStates[this._indoorData.id].selectedBuilding = t ? t.id : void 0;
            const u = this._indoorData.levels.filter((d) => t.levels.includes(d.id));
            this.fire(new r.z("buildingselected", { buildingId: t.id, levels: u }));
          }
          _levelSelected(t) {
            if (t === "overview") this._updateLevels(void 0, !0);
            else {
              const n = this._indoorData.levels.find((u) => u.id === t);
              this._updateLevels(n, !0);
            }
            this.fire(new r.z("levelselected", { levelId: t === "overview" ? void 0 : t }));
          }
          _updateLevels(t, n) {
            if (!t) return this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", []]), this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._floorplanStates[this._indoorData.id].selectedLevel = void 0, void (n && this._indoorData.extent && this._map.fitBounds(this._indoorData.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }));
            function u(X) {
              const K = X.indexOf("/floor/");
              if (K === -1) return X;
              const ae = K + 7, oe = X.indexOf("/", ae);
              return oe === -1 ? X.slice(ae) : X.slice(ae, oe);
            }
            this._selectedLevel = t, this._floorplanStates[this._indoorData.id].selectedLevel = t ? t.id : void 0;
            const d = [], _ = {}, v = {}, L = {}, G = {};
            for (const X of this._indoorData.levels) if (d.push(X.id), _[X.id] = X.height, v[X.id] = X.base, t) {
              if (this.mergeFloors) {
                const K = u(t.id), ae = u(X.id);
                L[X.id] = ae === K ? "true" : "false";
              } else L[X.id] = X.id === t.id ? "true" : "false";
              G[X.id] = X.base < t.base ? "true" : "false";
            } else G[X.id] = !0;
            if (this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", d]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-height", ["literal", _]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-base", ["literal", v]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", ["literal", L]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-overlapped", ["literal", G]), t && (this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !!t.isUnderground), n && t.extent)) {
              const X = this._map.cameraForBounds(t.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), K = this._map.getZoom(), ae = X.zoom ? Math.abs(K - X.zoom) : 0;
              this._map.fitBounds(t.extent, ae >= 1 ? { pitch: this._map.getPitch(), bearing: this._map.getBearing() } : { pitch: this._map.getPitch(), bearing: this._map.getBearing(), zoom: K });
            }
          }
          selectFloorplan(t) {
            const n = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, u = [new r.P(0, 0), new r.P(this._map.transform.width, this._map.transform.height)], d = this._map.queryRenderedFeatures(u, n);
            if (d.length > 0) {
              for (const _ of d) if (JSON.parse(_.properties["indoor-data"]).floorplanIDs.includes(t)) {
                this._selectedFloorplan = _, this._floorplanSelected(!0);
                break;
              }
            }
          }
          selectBuilding(t) {
            const n = this._indoorData.buildings.find((u) => u.id === t);
            this._buildingSelected(n, !0);
          }
          selectLevel(t) {
            this._levelSelected(t);
          }
        }
        function hd(l) {
          if (!l.metadata || !l.metadata.content_area) return;
          const t = r.q.devicePixelRatio, { left: n, top: u, width: d, height: _ } = l.metadata.content_area, v = n * t, L = u * t;
          return [v, L, v + d * t, L + _ * t];
        }
        function bf(l) {
          if (l) return l.map(([t, n]) => [t * r.q.devicePixelRatio, n * r.q.devicePixelRatio]);
        }
        const Ma = (l, t) => di(l, t && t.filter((n) => n.identifier !== "source.canvas")), Ju = r.ay(Mi, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setSnow", "setRain", "setProjection", "setCamera", "addImport", "removeImport", "updateImport"]), zh = r.ay(Mi, ["setCenter", "setZoom", "setBearing", "setPitch"]), Bc = /* @__PURE__ */ new Set(["background", "sky", "slot", "custom"]), du = { version: 8, layers: [], sources: {} }, Oh = { duration: 300, delay: 0 };
        class Ka extends r.E {
          constructor(t, n = {}) {
            super(), this.map = t, this.scope = n.scope || "", this.globalId = null, this.fragments = [], this.importDepth = n.importDepth || 0, this.importsCache = n.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = n.resolvedImports || /* @__PURE__ */ new Set(), this.transition = r.l({}, Oh), this._buildingIndex = new ps(this), this.crossTileSymbolIndex = new Rh(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = n.styleChanges || new vt(), this.dispatcher = n.dispatcher ? n.dispatcher : new r.D(r.ci(), this), n.imageManager ? this.imageManager = n.imageManager : (this.imageManager = new qe(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = n.glyphManager ? n.glyphManager : new r.cj(t._requestManager, n.localFontFamily ? r.ck.all : n.localIdeographFontFamily ? r.ck.ideographs : r.ck.none, n.localFontFamily || n.localIdeographFontFamily), n.modelManager ? this.modelManager = n.modelManager : (this.modelManager = new Oc(t._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._order = [], this._markersNeedUpdate = !1, this.options = n.configOptions ? n.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = n.configDependentLayers ? n.configDependentLayers : /* @__PURE__ */ new Set(), this._config = n.config, this._styleColorTheme = { lut: null, lutLoading: !1, lutLoadingCorrelationID: 0, colorTheme: null, colorThemeOverride: n.colorThemeOverride }, this._styleColorThemeForScope = {}, this._initialConfig = n.initialConfig, this.dispatcher.broadcast("setReferrer", r.cl());
            const u = this;
            this._rtlTextPluginCallback = Ka.registerForPluginStateChange((d) => {
              u.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: d.pluginStatus, pluginURL: d.pluginURL }, (_, v) => {
                if (r.cm(_), v && v.every((L) => L)) for (const L in u._sourceCaches) {
                  const G = u._sourceCaches[L], X = G.getSource().type;
                  X !== "vector" && X !== "geojson" || G.reload();
                }
              });
            }), this.on("data", (d) => {
              if (d.dataType !== "source" || d.sourceDataType !== "metadata") return;
              const _ = this.getOwnSource(d.sourceId);
              if (_ && _.vectorLayerIds) for (const v in this._layers) {
                const L = this._layers[v];
                L.source === _.id && this._validateLayer(L);
              }
            });
          }
          load(t) {
            return t ? (typeof t == "string" ? this.loadURL(t) : this.loadJSON(t), this) : this;
          }
          _getGlobalId(t) {
            if (!t) return null;
            if (typeof t == "string") {
              if (r.f(t)) return t;
              const n = r.cn(t);
              if (!n.startsWith("http")) try {
                return new URL(n, location.href).toString();
              } catch {
                return n;
              }
              return n;
            }
            return `json://${r.co(JSON.stringify(t))}`;
          }
          _diffStyle(t, n, u) {
            this.globalId = this._getGlobalId(t);
            const d = (_, v) => {
              try {
                v(null, this.setState(_, u));
              } catch (L) {
                v(L, !1);
              }
            };
            if (typeof t == "string") {
              const _ = this.map._requestManager.normalizeStyleURL(t), v = this.map._requestManager.transformRequest(_, r.R.Style);
              r.n(v, (L, G) => {
                L ? this.fire(new r.y(L)) : G && d(G, n);
              });
            } else typeof t == "object" && d(t, n);
          }
          loadURL(t, n = {}) {
            this.fire(new r.z("dataloading", { dataType: "style" }));
            const u = typeof n.validate == "boolean" ? n.validate : !r.f(t);
            this.globalId = this._getGlobalId(t), t = this.map._requestManager.normalizeStyleURL(t, n.accessToken), this.resolvedImports.add(t);
            const d = this.importsCache.get(t);
            if (d) return this._load(d, u);
            const _ = this.map._requestManager.transformRequest(t, r.R.Style);
            this._request = r.n(_, (v, L) => {
              if (this._request = null, v) this.fire(new r.y(v));
              else if (L) return this.importsCache.set(t, L), this._load(L, u);
            });
          }
          loadJSON(t, n = {}) {
            this.fire(new r.z("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t), this._request = r.q.frame(() => {
              this._request = null, this._load(t, n.validate !== !1);
            });
          }
          loadEmpty() {
            this.fire(new r.z("dataloading", { dataType: "style" })), this._load(du, !1);
          }
          _loadImports(t, n, u) {
            if (this.importDepth >= 4) return r.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
            const d = [];
            for (const _ of t) {
              const v = this._createFragmentStyle(_), L = new Promise((K) => {
                v.once("style.import.load", K), v.once("error", K);
              }).then(() => this.mergeAll());
              if (d.push(L), this.resolvedImports.has(_.url)) {
                v.loadEmpty();
                continue;
              }
              const G = _.data || this.importsCache.get(_.url);
              G ? (v.loadJSON(G, { validate: n }), this._isInternalStyle(G) && (v.globalId = null)) : _.url ? v.loadURL(_.url, { validate: n }) : v.loadEmpty();
              const X = { style: v, id: _.id, config: _.config };
              if (u) {
                const K = this.fragments.findIndex(({ id: ae }) => ae === u);
                this.fragments = this.fragments.slice(0, K).concat(X).concat(this.fragments.slice(K));
              } else this.fragments.push(X);
            }
            return Promise.allSettled(d);
          }
          getImportGlobalIds(t = this, n = /* @__PURE__ */ new Set()) {
            for (const u of t.fragments) u.style.globalId && n.add(u.style.globalId), this.getImportGlobalIds(u.style, n);
            return [...n.values()];
          }
          _createFragmentStyle(t) {
            const n = this.scope ? r.aC(t.id, this.scope) : t.id;
            let u;
            const d = this._initialConfig && this._initialConfig[n];
            (t.config || d) && (u = r.l({}, t.config, d));
            const _ = new Ka(this.map, { scope: n, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: u, configOptions: this.options, colorThemeOverride: t["color-theme"], configDependentLayers: this._configDependentLayers });
            return _.setEventedParent(this.map, { style: _ }), _;
          }
          _reloadImports() {
            this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
          }
          _isInternalStyle(t) {
            return this.isRootStyle() && (t.fragment || !!t.schema && t.fragment !== !1);
          }
          _load(t, n) {
            const u = t.indoor ? Dh(t.schema) : t.schema;
            if (this._isInternalStyle(t)) {
              const v = r.l({}, du, { imports: [{ id: "basemap", data: t, url: "" }] });
              return void this._load(v, n);
            }
            if (this.updateConfig(this._config, u), n && Ma(this, kt(t))) return;
            this._loaded = !0, this.stylesheet = r.cp(t);
            const d = () => {
              for (const X in t.sources) this.addSource(X, t.sources[X], { validate: !1, isInitialLoad: !0 });
              t.sprite ? this._loadIconset(t.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 })), this.glyphManager.setURL(t.glyphs, this.scope);
              const v = Us(this.stylesheet.layers);
              if (this._order = v.map((X) => X.id), this.stylesheet.light && r.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) if (this.stylesheet.lights.length === 1 && this.stylesheet.lights[0].type === "flat") {
                const X = this.stylesheet.lights[0];
                this.light = new Ce(X.properties, X.id);
              } else this.setLights(this.stylesheet.lights);
              this.light || (this.light = new Ce(this.stylesheet.light)), this._layers = {};
              for (const X of v) {
                const K = r.cu(X, this.scope, this._styleColorTheme.lut, this.options);
                K.configDependencies.size !== 0 && this._configDependentLayers.add(K.fqid), K.setEventedParent(this, { layer: { id: K.id } }), this._layers[K.id] = K;
                const ae = this.getOwnLayerSourceCache(K), oe = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                ae && K.canCastShadows() && oe && (ae.castsShadows = !0);
              }
              this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
              const L = this.stylesheet.terrain;
              L && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(L, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new r.z("data", { dataType: "style" }));
              const G = this.isRootStyle();
              t.imports ? this._loadImports(t.imports, n).then(() => {
                this._reloadImports(), this.fire(new r.z(G ? "style.load" : "style.import.load"));
              }) : (this._reloadImports(), this.fire(new r.z(G ? "style.load" : "style.import.load")));
            };
            this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
            const _ = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
            if (_) {
              const v = this._evaluateColorThemeData(_);
              this._loadColorTheme(v).then(() => {
                d();
              }).catch((L) => {
                r.w(`Couldn't load color theme from the stylesheet: ${L}`), d();
              });
            } else this._styleColorTheme.lut = null, d();
          }
          isRootStyle() {
            return this.importDepth === 0;
          }
          mergeAll() {
            let t, n, u, d, _, v, L, G, X, K;
            const ae = {};
            this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((oe) => {
              if (oe.stylesheet) {
                if (oe.light != null && (t = oe.light), oe.stylesheet.lights) for (const pe of oe.stylesheet.lights) pe.type === "ambient" && oe.ambientLight != null && (n = oe.ambientLight), pe.type === "directional" && oe.directionalLight != null && (u = oe.directionalLight);
                d = this._prioritizeTerrain(d, oe.terrain, oe.stylesheet.terrain), oe.stylesheet.fog && oe.fog != null && (_ = oe.fog), oe.stylesheet.snow && oe.snow != null && (v = oe.snow), oe.stylesheet.rain && oe.rain != null && (L = oe.rain), oe.stylesheet.camera != null && (K = oe.stylesheet.camera), oe.stylesheet.projection != null && (G = oe.stylesheet.projection), oe.stylesheet.transition != null && (X = oe.stylesheet.transition), ae[oe.scope] = oe._styleColorTheme;
              }
            }), this.light = t, this.ambientLight = n, this.directionalLight = u, this.fog = _, this.snow = v, this.rain = L, this._styleColorThemeForScope = ae, d === null ? delete this.terrain : this.terrain = d, this.camera = K || { "camera-projection": "perspective" }, this.projection = G || { name: "mercator" }, this.transition = r.l({}, Oh, X), this.mergeSources(), this.mergeLayers();
          }
          forEachFragmentStyle(t) {
            const n = (u) => {
              for (const d of u.fragments) n(d.style);
              t(u);
            };
            n(this);
          }
          _prioritizeTerrain(t, n, u) {
            const d = t && t.drapeRenderMode === 0;
            return u === null ? n && n.drapeRenderMode === 0 ? n : d ? t : null : n != null && (!t || d || n && n.drapeRenderMode === 1) ? n : t;
          }
          mergeTerrain() {
            let t;
            this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((n) => {
              t = this._prioritizeTerrain(t, n.terrain, n.stylesheet.terrain);
            }), t === null ? delete this.terrain : this.terrain = t;
          }
          mergeProjection() {
            let t;
            this.forEachFragmentStyle((n) => {
              n.stylesheet.projection != null && (t = n.stylesheet.projection);
            }), this.projection = t || { name: "mercator" };
          }
          mergeSources() {
            const t = {}, n = {}, u = {};
            this.forEachFragmentStyle((d) => {
              for (const _ in d._sourceCaches) {
                const v = r.aC(_, d.scope);
                t[v] = d._sourceCaches[_];
              }
              for (const _ in d._otherSourceCaches) {
                const v = r.aC(_, d.scope);
                n[v] = d._otherSourceCaches[_];
              }
              for (const _ in d._symbolSourceCaches) {
                const v = r.aC(_, d.scope);
                u[v] = d._symbolSourceCaches[_];
              }
            }), this._mergedSourceCaches = t, this._mergedOtherSourceCaches = n, this._mergedSymbolSourceCaches = u;
          }
          mergeLayers() {
            const t = {}, n = [], u = {};
            this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle((_) => {
              for (const v of _._order) {
                const L = _._layers[v];
                if (L.type === "slot") {
                  const G = r.cq(v);
                  if (t[G]) continue;
                  t[G] = [];
                }
                L.slot && t[L.slot] ? t[L.slot].push(L) : n.push(L);
              }
            }), this._mergedOrder = [];
            const d = (_ = []) => {
              for (const v of _) if (v.type === "slot") {
                const L = r.cq(v.id);
                t[L] && d(t[L]), this._mergedSlots.push(L);
              } else {
                const L = r.aC(v.id, v.scope);
                this._mergedOrder.push(L), u[L] = v, v.is3D() && (this._has3DLayers = !0), v.type === "circle" && (this._hasCircleLayers = !0), v.type === "symbol" && (this._hasSymbolLayers = !0), v.type === "clip" && (this._clipLayerPresent = !0);
              }
            };
            d(n), this._mergedOrder.sort((_, v) => {
              const L = u[_], G = u[v];
              return L.hasInitialOcclusionOpacityProperties ? G.is3D() ? 1 : 0 : L.is3D() && G.hasInitialOcclusionOpacityProperties ? -1 : 0;
            }), this._mergedLayers = u, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
          }
          terrainSetForDrapingOnly() {
            return !!this.terrain && this.terrain.drapeRenderMode === 0;
          }
          getCamera() {
            return this.stylesheet.camera;
          }
          setCamera(t) {
            return this.stylesheet.camera = r.l({}, this.stylesheet.camera, t), this.camera = this.stylesheet.camera, this;
          }
          _evaluateColorThemeData(t) {
            return t.data ? function(n, u, d) {
              const _ = r.l({}, u);
              for (const L of Object.keys(r.a3.colorTheme)) _[L] === void 0 && (_[L] = r.a3.colorTheme[L].default);
              const v = new r.a4(vf, n, new Map(d));
              return v.setTransitionOrValue(_, d), v.untransitioned().possiblyEvaluate(new r.a8(0));
            }(this.scope, t, this.options).get("data") : null;
          }
          _loadColorTheme(t) {
            this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;
            const n = this._styleColorTheme.lutLoadingCorrelationID;
            return new Promise((u, d) => {
              const _ = "data:image/png;base64,";
              if (!t || t.length === 0) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void u();
              let v = t;
              v.startsWith(_) || (v = _ + v);
              const L = "mapbox-reserved-lut", G = new Image();
              G.src = v, G.onerror = () => {
                this._styleColorTheme.lutLoading = !1, d(new Error("Failed to load image data"));
              }, G.onload = () => {
                if (this._styleColorTheme.lutLoadingCorrelationID !== n) return void u();
                this._styleColorTheme.lutLoading = !1;
                const { width: X, height: K, data: ae } = r.q.getImageData(G);
                if (K > 32) return void d(new Error("The height of the image must be less than or equal to 32 pixels."));
                if (X !== K * K) return void d(new Error("The width of the image must be equal to the height squared."));
                this.getImage(L) && this.removeImage(L), this.addImage(L, { data: new r.r({ width: X, height: K }, ae), pixelRatio: 1, sdf: !1, usvg: !1, version: 0 });
                const oe = this.imageManager.getImage(L, this.scope);
                oe ? (this._styleColorTheme.lut = { image: oe.data, data: t }, u()) : d(new Error("Missing LUT image."));
              };
            });
          }
          getLut(t) {
            const n = this._styleColorThemeForScope[t];
            return n ? n.lut : null;
          }
          setProjection(t) {
            t ? this.stylesheet.projection = t : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
          }
          applyProjectionUpdate() {
            this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
          }
          _updateMapProjection() {
            this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
          }
          _loadSprite(t) {
            this._spriteRequest = function(n, u, d) {
              let _, v, L;
              const G = r.q.devicePixelRatio > 1 ? "@2x" : "";
              let X = r.n(u.transformRequest(u.normalizeSpriteURL(n, G, ".json"), r.R.SpriteJSON), (oe, pe) => {
                X = null, L || (L = oe, _ = pe, ae());
              }), K = r.o(u.transformRequest(u.normalizeSpriteURL(n, G, ".png"), r.R.SpriteImage), (oe, pe) => {
                K = null, L || (L = oe, v = pe, ae());
              });
              function ae() {
                if (L) d(L);
                else if (_ && v) {
                  const oe = r.q.getImageData(v), pe = {};
                  for (const Be in _) {
                    const { width: Re, height: Ge, x: Ve, y: et, sdf: ut, pixelRatio: st, stretchX: xt, stretchY: mt, content: _t } = _[Be], dt = new r.r({ width: Re, height: Ge });
                    r.r.copy(oe, dt, { x: Ve, y: et }, { x: 0, y: 0 }, { width: Re, height: Ge }, null), pe[Be] = { data: dt, pixelRatio: st, sdf: ut, stretchX: xt, stretchY: mt, content: _t, usvg: !1 };
                  }
                  d(null, pe);
                }
              }
              return { cancel() {
                X && (X.cancel(), X = null), K && (K.cancel(), K = null);
              } };
            }(t, this.map._requestManager, (n, u) => {
              if (this._spriteRequest = null, n) this.fire(new r.y(n));
              else if (u) for (const d in u) this.imageManager.addImage(d, this.scope, u[d]);
              this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 }), this.fire(new r.z("data", { dataType: "style" }));
            });
          }
          _loadIconset(t) {
            if (!r.f(t) && this.map._spriteFormat !== "icon_set" || this.map._spriteFormat === "raster") return void this._loadSprite(t);
            const n = this.map._spriteFormat === "auto";
            var u, d;
            this._spriteRequest = (d = (_, v) => {
              if (this._spriteRequest = null, _) n ? this._loadSprite(t) : this.fire(new r.y(_));
              else if (v) for (const L in v) this.imageManager.addImage(L, this.scope, v[L]);
              this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 }), this.fire(new r.z("data", { dataType: "style" }));
            }, r.bi((u = this.map._requestManager).transformRequest(u.normalizeIconsetURL(t), r.R.Iconset), (_, v) => {
              if (_) return void d(_);
              const L = {}, G = r.cg(new r.bh(v));
              for (const X of G.icons) {
                const K = { version: 1, pixelRatio: r.q.devicePixelRatio, content: hd(X), stretchX: X.metadata ? bf(X.metadata.stretch_x_areas) : void 0, stretchY: X.metadata ? bf(X.metadata.stretch_y_areas) : void 0, sdf: !1, usvg: !0, icon: X };
                L[X.name] = K;
              }
              d(null, L);
            }));
          }
          _validateLayer(t) {
            const n = this.getOwnSource(t.source);
            if (!n) return;
            const u = t.sourceLayer;
            u && (n.type === "geojson" || n.vectorLayerIds && n.vectorLayerIds.indexOf(u) === -1) && this.fire(new r.y(new Error(`Source layer "${u}" does not exist on source "${n.id}" as specified by style layer "${t.id}"`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;
            for (const t in this._sourceCaches) if (!this._sourceCaches[t].loaded()) return !1;
            if (!this.imageManager.isLoaded() || !this.modelManager.isLoaded() || this._styleColorTheme.lutLoading) return !1;
            for (const { style: t } of this.fragments) if (!t.loaded()) return !1;
            return !0;
          }
          _serializeImports() {
            if (this.stylesheet.imports) return this.stylesheet.imports.map((t, n) => {
              const u = this.fragments[n];
              return u && u.style && (t.data = u.style.serialize()), t;
            });
          }
          _serializeSources() {
            const t = {};
            for (const n in this._sourceCaches) {
              const u = this._sourceCaches[n].getSource();
              t[u.id] || (t[u.id] = u.serialize());
            }
            return t;
          }
          _serializeLayers(t) {
            const n = [];
            for (const u of t) {
              const d = this._layers[u];
              d && d.type !== "custom" && n.push(d.serialize());
            }
            return n;
          }
          hasLightTransitions() {
            return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
          }
          hasFogTransition() {
            return !!this.fog && this.fog.hasTransition();
          }
          hasSnowTransition() {
            return !!this.snow && this.snow.hasTransition();
          }
          hasRainTransition() {
            return !!this.rain && this.rain.hasTransition();
          }
          hasTransitions() {
            if (this.hasLightTransitions() || this.hasFogTransition() || this.hasSnowTransition() || this.hasRainTransition()) return !0;
            for (const t in this._sourceCaches) if (this._sourceCaches[t].hasTransition()) return !0;
            for (const t in this._layers) if (this._layers[t].hasTransition()) return !0;
            return !1;
          }
          get order() {
            return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
          }
          _getOrder(t) {
            return t ? this.order : this._mergedOrder;
          }
          isLayerDraped(t) {
            return !!this.terrain && t.isDraped(this.getLayerSourceCache(t));
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading");
          }
          _checkLayer(t) {
            const n = this.getOwnLayer(t);
            if (n) return n;
            this.fire(new r.y(new Error(`The layer '${t}' does not exist in the map's style.`)));
          }
          _checkSource(t) {
            const n = this.getOwnSource(t);
            if (n) return n;
            this.fire(new r.y(new Error(`The source '${t}' does not exist in the map's style.`)));
          }
          precompilePrograms(t, n) {
            const u = this.map.painter;
            if (u) for (let d = t.minzoom || 0; d < (t.maxzoom || 25.5); d++) {
              const _ = t.getProgramIds();
              if (_) for (const v of _) {
                const L = t.getDefaultProgramParams(v, n.zoom, this._styleColorTheme.lut);
                L && (u.style = this, this.fog && (u._fogVisible = !0, L.overrideFog = !0, u.getOrCreateProgram(v, L)), u._fogVisible = !1, L.overrideFog = !1, u.getOrCreateProgram(v, L), (this.stylesheet.terrain || this.stylesheet.projection && this.stylesheet.projection.name === "globe") && (L.overrideRtt = !0, u.getOrCreateProgram(v, L)));
              }
            }
          }
          update(t) {
            if (!this._loaded) return;
            this.ambientLight && this.ambientLight.recalculate(t), this.directionalLight && this.directionalLight.recalculate(t);
            const n = this.calculateLightsBrightness();
            t.brightness = n || 0, n !== this._brightness && (this._brightness = n, this.dispatcher.broadcast("setBrightness", n));
            const u = this._changes.isDirty();
            let d = !1;
            if (this._changes.isDirty()) {
              const v = this._changes.getLayerUpdatesByScope();
              for (const L in v) {
                const { updatedIds: G, removedIds: X } = v[L];
                (G || X) && (this._updateWorkerLayers(L, G, X), d = !0);
              }
              this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t), this.light && this.light.updateTransitions(t), this.ambientLight && this.ambientLight.updateTransitions(t), this.directionalLight && this.directionalLight.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this.snow && this.snow.updateTransitions(t), this.rain && this.rain.updateTransitions(t), this._changes.reset();
            }
            const _ = {};
            for (const v in this._mergedSourceCaches) {
              const L = this._mergedSourceCaches[v];
              _[v] = L.used, L.used = !1, L.tileCoverLift = 0;
            }
            for (const v of this._mergedOrder) {
              const L = this._mergedLayers[v];
              if (L.recalculate(t, this._availableImages), !L.isHidden(t.zoom)) {
                const G = this.getLayerSourceCache(L);
                G && (G.used = !0, G.tileCoverLift = Math.max(G.tileCoverLift, L.tileCoverLift()));
              }
              !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(() => {
                this.precompilePrograms(L, t);
              }) : this.precompilePrograms(L, t));
            }
            this._shouldPrecompile && (this._precompileDone = !0), this.terrain && d && this.mergeLayers();
            for (const v in _) {
              const L = this._mergedSourceCaches[v];
              _[v] !== L.used && L.getSource().fire(new r.z("data", { sourceDataType: "visibility", dataType: "source", sourceId: L.getSource().id }));
            }
            this.light && this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.snow && this.snow.recalculate(t), this.rain && this.rain.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), u && this.fire(new r.z("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const t = this._changes.getUpdatedImages();
            if (t.length) {
              for (const n in this._sourceCaches) this._sourceCaches[n].reloadTilesForDependencies(["icons", "patterns"], t);
              this._changes.resetUpdatedImages();
            }
          }
          _updateWorkerLayers(t, n, u) {
            const d = this.getFragmentStyle(t);
            d && this.dispatcher.broadcast("updateLayers", { layers: n ? d._serializeLayers(n) : [], scope: t, removedIds: u || [], options: d.options });
          }
          setState(t, n) {
            if (this._checkLoaded(), Ma(this, kt(t))) return !1;
            (t = r.cp(t)).layers = Us(t.layers);
            const u = function(v, L) {
              if (!v) return [{ command: Mi.setStyle, args: [L] }];
              let G = [];
              try {
                if (!r.bn(v.version, L.version)) return [{ command: Mi.setStyle, args: [L] }];
                if (r.bn(v.center, L.center) || G.push({ command: Mi.setCenter, args: [L.center] }), r.bn(v.zoom, L.zoom) || G.push({ command: Mi.setZoom, args: [L.zoom] }), r.bn(v.bearing, L.bearing) || G.push({ command: Mi.setBearing, args: [L.bearing] }), r.bn(v.pitch, L.pitch) || G.push({ command: Mi.setPitch, args: [L.pitch] }), r.bn(v.sprite, L.sprite) || G.push({ command: Mi.setSprite, args: [L.sprite] }), r.bn(v.glyphs, L.glyphs) || G.push({ command: Mi.setGlyphs, args: [L.glyphs] }), r.bn(v.imports, L.imports) || function(pe = [], Be = [], Re) {
                  Be = Be || [];
                  const Ge = (pe = pe || []).map(la), Ve = Be.map(la), et = pe.reduce($o, {}), ut = Be.reduce($o, {}), st = Ge.slice();
                  let xt, mt, _t, dt;
                  for (xt = 0, mt = 0; xt < Ge.length; xt++) _t = Ge[xt], ut.hasOwnProperty(_t) ? mt++ : (Re.push({ command: Mi.removeImport, args: [_t] }), st.splice(st.indexOf(_t, mt), 1));
                  for (xt = 0, mt = 0; xt < Ve.length; xt++) _t = Ve[Ve.length - 1 - xt], st[st.length - 1 - xt] !== _t && (et.hasOwnProperty(_t) ? (Re.push({ command: Mi.removeImport, args: [_t] }), st.splice(st.lastIndexOf(_t, st.length - mt), 1)) : mt++, dt = st[st.length - xt], Re.push({ command: Mi.addImport, args: [ut[_t], dt] }), st.splice(st.length - xt, 0, _t));
                  for (const gt of Be) {
                    const Rt = et[gt.id];
                    Rt && !r.bn(Rt, gt) && Re.push({ command: Mi.updateImport, args: [gt.id, gt] });
                  }
                }(v.imports, L.imports, G), r.bn(v.transition, L.transition) || G.push({ command: Mi.setTransition, args: [L.transition] }), r.bn(v.light, L.light) || G.push({ command: Mi.setLight, args: [L.light] }), r.bn(v.fog, L.fog) || G.push({ command: Mi.setFog, args: [L.fog] }), r.bn(v.snow, L.snow) || G.push({ command: Mi.setSnow, args: [L.snow] }), r.bn(v.rain, L.rain) || G.push({ command: Mi.setRain, args: [L.rain] }), r.bn(v.projection, L.projection) || G.push({ command: Mi.setProjection, args: [L.projection] }), r.bn(v.lights, L.lights) || G.push({ command: Mi.setLights, args: [L.lights] }), r.bn(v.camera, L.camera) || G.push({ command: Mi.setCamera, args: [L.camera] }), !r.bn(v["color-theme"], L["color-theme"])) return [{ command: Mi.setStyle, args: [L] }];
                const X = {}, K = [];
                (function(pe, Be, Re, Ge) {
                  let Ve;
                  for (Ve in Be = Be || {}, pe = pe || {}) pe.hasOwnProperty(Ve) && (Be.hasOwnProperty(Ve) || js(Ve, Re, Ge));
                  for (Ve in Be) {
                    if (!Be.hasOwnProperty(Ve)) continue;
                    const et = Be[Ve];
                    pe.hasOwnProperty(Ve) ? r.bn(pe[Ve], et) || (pe[Ve].type === "geojson" && et.type === "geojson" && nn(pe, Be, Ve) ? Re.push({ command: Mi.setGeoJSONSourceData, args: [Ve, et.data] }) : Xr(Ve, Be, Re, Ge)) : Rc(Ve, Be, Re);
                  }
                })(v.sources, L.sources, K, X);
                const ae = [];
                v.layers && v.layers.forEach((pe) => {
                  pe.source && X[pe.source] ? G.push({ command: Mi.removeLayer, args: [pe.id] }) : ae.push(pe);
                });
                let oe = v.terrain;
                oe && X[oe.source] && (G.push({ command: Mi.setTerrain, args: [void 0] }), oe = void 0), G = G.concat(K), r.bn(oe, L.terrain) || G.push({ command: Mi.setTerrain, args: [L.terrain] }), function(pe, Be, Re) {
                  Be = Be || [];
                  const Ge = (pe = pe || []).map(la), Ve = Be.map(la), et = pe.reduce($o, {}), ut = Be.reduce($o, {}), st = Ge.slice(), xt = /* @__PURE__ */ Object.create(null);
                  let mt, _t, dt, gt, Rt, Jt, Vt;
                  for (mt = 0, _t = 0; mt < Ge.length; mt++) dt = Ge[mt], ut.hasOwnProperty(dt) ? _t++ : (Re.push({ command: Mi.removeLayer, args: [dt] }), st.splice(st.indexOf(dt, _t), 1));
                  for (mt = 0, _t = 0; mt < Ve.length; mt++) dt = Ve[Ve.length - 1 - mt], st[st.length - 1 - mt] !== dt && (et.hasOwnProperty(dt) ? (Re.push({ command: Mi.removeLayer, args: [dt] }), st.splice(st.lastIndexOf(dt, st.length - _t), 1)) : _t++, Jt = st[st.length - mt], Re.push({ command: Mi.addLayer, args: [ut[dt], Jt] }), st.splice(st.length - mt, 0, dt), xt[dt] = !0);
                  for (mt = 0; mt < Ve.length; mt++) if (dt = Ve[mt], gt = et[dt], Rt = ut[dt], !xt[dt] && !r.bn(gt, Rt)) if (r.bn(gt.source, Rt.source) && r.bn(gt["source-layer"], Rt["source-layer"]) && r.bn(gt.type, Rt.type)) {
                    for (Vt in Zi(gt.layout, Rt.layout, Re, dt, null, Mi.setLayoutProperty), Zi(gt.paint, Rt.paint, Re, dt, null, Mi.setPaintProperty), r.bn(gt.slot, Rt.slot) || Re.push({ command: Mi.setSlot, args: [dt, Rt.slot] }), r.bn(gt.filter, Rt.filter) || Re.push({ command: Mi.setFilter, args: [dt, Rt.filter] }), r.bn(gt.minzoom, Rt.minzoom) && r.bn(gt.maxzoom, Rt.maxzoom) || Re.push({ command: Mi.setLayerZoomRange, args: [dt, Rt.minzoom, Rt.maxzoom] }), gt) gt.hasOwnProperty(Vt) && Vt !== "layout" && Vt !== "paint" && Vt !== "filter" && Vt !== "metadata" && Vt !== "minzoom" && Vt !== "maxzoom" && Vt !== "slot" && (Vt.indexOf("paint.") === 0 ? Zi(gt[Vt], Rt[Vt], Re, dt, Vt.slice(6), Mi.setPaintProperty) : r.bn(gt[Vt], Rt[Vt]) || Re.push({ command: Mi.setLayerProperty, args: [dt, Vt, Rt[Vt]] }));
                    for (Vt in Rt) Rt.hasOwnProperty(Vt) && !gt.hasOwnProperty(Vt) && Vt !== "layout" && Vt !== "paint" && Vt !== "filter" && Vt !== "metadata" && Vt !== "minzoom" && Vt !== "maxzoom" && Vt !== "slot" && (Vt.indexOf("paint.") === 0 ? Zi(gt[Vt], Rt[Vt], Re, dt, Vt.slice(6), Mi.setPaintProperty) : r.bn(gt[Vt], Rt[Vt]) || Re.push({ command: Mi.setLayerProperty, args: [dt, Vt, Rt[Vt]] }));
                  } else Re.push({ command: Mi.removeLayer, args: [dt] }), Jt = st[st.lastIndexOf(dt) + 1], Re.push({ command: Mi.addLayer, args: [Rt, Jt] });
                }(ae, L.layers, G);
              } catch (X) {
                console.warn("Unable to compute style diff:", X), G = [{ command: Mi.setStyle, args: [L] }];
              }
              return G;
            }(this.serialize(), t).filter((v) => !(v.command in zh));
            if (u.length === 0) return !1;
            const d = u.filter((v) => !(v.command in Ju));
            if (d.length > 0) throw new Error(`Unimplemented: ${d.map((v) => v.command).join(", ")}.`);
            const _ = [];
            return u.forEach((v) => {
              _.push(this[v.command].apply(this, v.args));
            }), n && Promise.all(_).then(n), this.stylesheet = t, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), !0;
          }
          addImage(t, n) {
            return this.getImage(t) ? this.fire(new r.y(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t, this.scope, n), this._afterImageUpdated(t), this);
          }
          updateImage(t, n, u = !1) {
            this.imageManager.updateImage(t, this.scope, n), u && this._afterImageUpdated(t);
          }
          getImage(t) {
            return this.imageManager.getImage(t, this.scope);
          }
          removeImage(t) {
            return this.getImage(t) ? (this.imageManager.removeImage(t, this.scope), this._afterImageUpdated(t), this) : this.fire(new r.y(new Error("No image with this name exists.")));
          }
          _afterImageUpdated(t) {
            this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.fire(new r.z("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this._availableImages.slice();
          }
          addModel(t, n, u = {}) {
            return this._checkLoaded(), this._validate(Dr, `models.${t}`, n, null, u) || (this.modelManager.addModel(t, n, this.scope), this._changes.setDirty()), this;
          }
          hasModel(t) {
            return this.modelManager.hasModel(t, this.scope);
          }
          removeModel(t) {
            return this.hasModel(t) ? (this.modelManager.removeModel(t, this.scope), this) : this.fire(new r.y(new Error("No model with this ID exists.")));
          }
          listModels() {
            return this._checkLoaded(), this.modelManager.listModels(this.scope);
          }
          addSource(t, n, u = {}) {
            if (this._checkLoaded(), this.getOwnSource(t) !== void 0) throw new Error(`There is already a source with ID "${t}".`);
            if (!n.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(n).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(n.type) >= 0 && this._validate(tr, `sources.${t}`, n, null, u)) return;
            this.map && this.map._collectResourceTiming && (n.collectResourceTiming = !0);
            const d = Pa(t, n, this.dispatcher, this);
            d.scope = this.scope, d.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(d.id), source: d.serialize(), sourceId: d.id }));
            const _ = (v) => {
              const L = (v ? "symbol:" : "other:") + d.id, G = r.aC(L, this.scope), X = this._sourceCaches[L] = new Xa(G, d, v);
              (v ? this._symbolSourceCaches : this._otherSourceCaches)[d.id] = X, X.onAdd(this.map);
            };
            _(!1), n.type !== "vector" && n.type !== "geojson" || _(!0), d.onAdd && d.onAdd(this.map), u.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
          }
          removeSource(t) {
            this._checkLoaded();
            const n = this.getOwnSource(t);
            if (!n) throw new Error("There is no source with this ID");
            for (const d in this._layers) if (this._layers[d].source === t) return this.fire(new r.y(new Error(`Source "${t}" cannot be removed while layer "${d}" is using it.`)));
            if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t) return this.fire(new r.y(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));
            const u = this.getOwnSourceCaches(t);
            for (const d of u) {
              const _ = r.cq(d.id);
              delete this._sourceCaches[_], this._changes.discardSourceCacheUpdate(d.id), d.fire(new r.z("data", { sourceDataType: "metadata", dataType: "source", sourceId: d.getSource().id })), d.setEventedParent(null), d.clearTiles();
            }
            return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], this.mergeSources(), n.setEventedParent(null), n.onRemove && n.onRemove(this.map), this._changes.setDirty(), this;
          }
          setGeoJSONSourceData(t, n) {
            this._checkLoaded(), this.getOwnSource(t).setData(n), this._changes.setDirty();
          }
          getOwnSource(t) {
            const n = this.getOwnSourceCache(t);
            return n && n.getSource();
          }
          getOwnSources() {
            const t = [];
            for (const n in this._otherSourceCaches) {
              const u = this.getOwnSourceCache(n);
              u && t.push(u.getSource());
            }
            return t;
          }
          areTilesLoaded() {
            const t = this._mergedSourceCaches;
            for (const n in t) {
              const u = t[n]._tiles;
              for (const d in u) {
                const _ = u[d];
                if (_.state !== "loaded" && _.state !== "errored") return !1;
              }
            }
            return !0;
          }
          setLights(t) {
            if (this._checkLoaded(), !t) return delete this.ambientLight, void delete this.directionalLight;
            const n = this._getTransitionParameters();
            for (const d of t) {
              if (this._validate(wr, "lights", d)) return;
              switch (d.type) {
                case "ambient":
                  if (this.ambientLight) {
                    const _ = this.ambientLight;
                    _.set(d), _.updateTransitions(n);
                  } else this.ambientLight = new fi(d, Ir || (Ir = new r.a5({ color: new r.a6(r.a3.properties_light_ambient.color), "color-use-theme": new r.a6({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new r.a6(r.a3.properties_light_ambient.intensity) })), this.scope, this.options);
                  break;
                case "directional":
                  if (this.directionalLight) {
                    const _ = this.directionalLight;
                    _.set(d), _.updateTransitions(n);
                  } else this.directionalLight = new fi(d, Lr || (Lr = new r.a5({ direction: new r.ak(r.a3.properties_light_directional.direction), color: new r.a6(r.a3.properties_light_directional.color), "color-use-theme": new r.a6({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new r.a6(r.a3.properties_light_directional.intensity), "cast-shadows": new r.a6(r.a3.properties_light_directional["cast-shadows"]), "shadow-quality": new r.a6(r.a3.properties_light_directional["shadow-quality"]), "shadow-intensity": new r.a6(r.a3.properties_light_directional["shadow-intensity"]) })), this.scope, this.options);
              }
            }
            const u = new r.a8(this.z || 0, n);
            this.ambientLight && this.ambientLight.recalculate(u), this.directionalLight && this.directionalLight.recalculate(u), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
          }
          calculateLightsBrightness() {
            const t = this.directionalLight, n = this.ambientLight;
            if (!t || !n) return;
            const u = (oe) => 0.2126 * (oe[0] <= 0.03928 ? oe[0] / 12.92 : Math.pow((oe[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (oe[1] <= 0.03928 ? oe[1] / 12.92 : Math.pow((oe[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (oe[2] <= 0.03928 ? oe[2] / 12.92 : Math.pow((oe[2] + 0.055) / 1.055, 2.4)), d = t.properties.get("color").toRenderColor(null).toArray01(), _ = t.properties.get("intensity"), v = t.properties.get("direction"), L = 1 - r.cb(v.x, v.y, v.z)[2] / 90, G = u(d) * _ * L, X = n.properties.get("color").toRenderColor(null).toArray01(), K = n.properties.get("intensity"), ae = u(X) * K;
            return Number(((G + ae) / 2).toFixed(6));
          }
          getBrightness() {
            return this._brightness;
          }
          getLights() {
            if (!this.enable3dLights()) return null;
            const t = [];
            return this.directionalLight && t.push(this.directionalLight.get()), this.ambientLight && t.push(this.ambientLight.get()), t;
          }
          enable3dLights() {
            return !!this.ambientLight && !!this.directionalLight;
          }
          getFragmentStyle(t) {
            if (!t) return this;
            if (r.cr(t)) {
              const n = r.cs(t), u = this.fragments.find(({ id: _ }) => _ === n);
              if (!u) throw new Error(`Style import '${t}' not found`);
              const d = r.cq(t);
              return u.style.getFragmentStyle(d);
            }
            {
              const n = this.fragments.find(({ id: u }) => u === t);
              return n ? n.style : void 0;
            }
          }
          setFeaturesetSelectors(t) {
            if (!t) return;
            const n = {}, u = (d, _ = "") => `${d}::${_}`;
            this._featuresetSelectors = {};
            for (const d in t) {
              const _ = this._featuresetSelectors[d] = [];
              for (const v of t[d].selectors) {
                if (v.featureNamespace) {
                  const G = this.getOwnLayer(v.layer);
                  if (!G) {
                    r.w(`Layer is undefined for selector: ${v.layer}`);
                    continue;
                  }
                  const X = u(G.source, G.sourceLayer);
                  if (X in n && n[X] !== v.featureNamespace) {
                    r.w(`"featureNamespace ${v.featureNamespace} of featureset ${d}'s selector is not associated to the same source, skip this selector`);
                    continue;
                  }
                  n[X] = v.featureNamespace;
                }
                let L;
                if (v.properties) for (const G in v.properties) {
                  const X = r.U(v.properties[G]);
                  X.result === "success" && (L = L || {}, L[G] = X.value);
                }
                _.push({ layerId: v.layer, namespace: v.featureNamespace, properties: L, uniqueFeatureID: v._uniqueFeatureID });
              }
            }
          }
          getFeaturesetDescriptors(t) {
            const n = this.getFragmentStyle(t);
            if (!n || !n.stylesheet.featuresets) return [];
            const u = [];
            for (const d in n.stylesheet.featuresets) u.push({ featuresetId: d, importId: n.scope ? n.scope : void 0 });
            return u;
          }
          getFeaturesetLayers(t, n) {
            const u = this.getFragmentStyle(n), d = u.stylesheet.featuresets;
            if (!d || !d[t]) return this.fire(new r.y(new Error(`The featureset '${t}' does not exist in the map's style and cannot be queried.`))), [];
            const _ = [];
            for (const v of d[t].selectors) {
              const L = u.getOwnLayer(v.layer);
              L && _.push(L);
            }
            return _;
          }
          getConfigProperty(t, n) {
            const u = this.getFragmentStyle(t);
            if (!u) return null;
            const d = r.aC(n, u.scope), _ = u.options.get(d), v = _ ? _.value || _.default : null;
            return v ? v.serialize() : null;
          }
          setConfigProperty(t, n, u) {
            const d = this.getFragmentStyle(t);
            if (!d) return;
            const _ = d.stylesheet.indoor ? Dh(d.stylesheet.schema) : d.stylesheet.schema;
            if (!_ || !_[n]) return;
            const v = r.U(u);
            if (v.result !== "success") return void Ma(this, v.value);
            const L = v.value.expression, G = r.aC(n, d.scope), X = d.options.get(G);
            if (!X) return;
            let K;
            const { minValue: ae, maxValue: oe, stepValue: pe, type: Be, values: Re } = _[n], Ge = r.U(_[n].default);
            Ge.result === "success" && (K = Ge.value.expression), K ? (this.options.set(G, Object.assign({}, X, { value: L, default: K, minValue: ae, maxValue: oe, stepValue: pe, type: Be, values: Re })), this.updateConfigDependencies(n)) : this.fire(new r.y(new Error(`No schema defined for the config option "${n}" in the "${t}" fragment.`)));
          }
          getConfig(t) {
            const n = this.getFragmentStyle(t);
            if (!n) return null;
            const u = n.stylesheet.schema;
            if (!u) return null;
            const d = {};
            for (const _ in u) {
              const v = r.aC(_, n.scope), L = n.options.get(v), G = L ? L.value || L.default : null;
              d[_] = G ? G.serialize() : null;
            }
            return d;
          }
          setConfig(t, n) {
            const u = this.getFragmentStyle(t);
            u && (u.updateConfig(n, u.stylesheet.schema), this.updateConfigDependencies());
          }
          getSchema(t) {
            const n = this.getFragmentStyle(t);
            return n ? n.stylesheet.schema : null;
          }
          setSchema(t, n) {
            const u = this.getFragmentStyle(t);
            u && (u.stylesheet.schema = n, u.updateConfig(u._config, n), this.updateConfigDependencies());
          }
          updateConfig(t, n) {
            if (this._config = t, t || n) if (n) for (const u in n) {
              let d, _;
              const v = r.U(n[u].default);
              if (v.result === "success" && (d = v.value.expression), t && t[u] !== void 0) {
                const oe = r.U(t[u]);
                oe.result === "success" && (_ = oe.value.expression);
              }
              const { minValue: L, maxValue: G, stepValue: X, type: K, values: ae } = n[u];
              if (d) {
                const oe = r.aC(u, this.scope);
                this.options.set(oe, { default: d, value: _, minValue: L, maxValue: G, stepValue: X, type: K, values: ae });
              } else this.fire(new r.y(new Error(`No schema defined for config option "${u}".`)));
            }
            else this.fire(new r.y(new Error("Attempting to set config for a style without schema.")));
          }
          updateConfigDependencies(t) {
            for (const n of this._configDependentLayers) {
              const u = this.getLayer(n);
              if (u) {
                if (t && !u.configDependencies.has(t)) continue;
                u.possiblyEvaluateVisibility(), this._updateLayer(u);
              }
            }
            this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle((n) => {
              const u = n._styleColorTheme.colorThemeOverride ? n._styleColorTheme.colorThemeOverride : n._styleColorTheme.colorTheme;
              if (u) {
                const d = n._evaluateColorThemeData(u);
                (!n._styleColorTheme.lut && d !== "" || n._styleColorTheme.lut && d !== n._styleColorTheme.lut.data) && n.setColorTheme(u);
              }
            }), this._changes.setDirty();
          }
          addLayer(t, n, u = {}) {
            this._checkLoaded();
            const d = t.id;
            if (this._layers[d]) return void this.fire(new r.y(new Error(`Layer with id "${d}" already exists on this map`)));
            let _;
            if (t.type === "custom") {
              if (Ma(this, r.ct(t))) return;
              _ = r.cu(t, this.scope, this._styleColorTheme.lut, this.options);
            } else {
              if (typeof t.source == "object" && (this.addSource(d, t.source), t = r.cp(t), t = r.l(t, { source: d })), this._validate(we, `layers.${d}`, t, { arrayIndex: -1 }, u)) return;
              _ = r.cu(t, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(_), _.setEventedParent(this, { layer: { id: d } });
            }
            _.configDependencies.size !== 0 && this._configDependentLayers.add(_.fqid);
            let v = this._order.length;
            if (n) {
              const K = this._order.indexOf(n);
              if (K === -1) return void this.fire(new r.y(new Error(`Layer with id "${n}" does not exist on this map.`)));
              _.slot === this._layers[n].slot ? v = K : r.w(`Layer with id "${n}" has a different slot. Layers can only be rearranged within the same slot.`);
            }
            this._order.splice(v, 0, d), this._layerOrderChanged = !0, this._layers[d] = _;
            const L = this.getOwnLayerSourceCache(_), G = !!this.directionalLight && this.directionalLight.shadowsEnabled();
            L && _.canCastShadows() && G && (L.castsShadows = !0);
            const X = this._changes.getRemovedLayer(_);
            if (X && _.source && L && _.type !== "custom") {
              this._changes.discardLayerRemoval(_);
              const K = r.aC(_.source, _.scope);
              X.type !== _.type ? this._changes.updateSourceCache(K, "clear") : (this._changes.updateSourceCache(K, "reload"), L.pause());
            }
            this._updateLayer(_), _.onAdd && _.onAdd(this.map), _.scope = this.scope, this.mergeLayers();
          }
          moveLayer(t, n) {
            this._checkLoaded();
            const u = this._checkLayer(t);
            if (!u || t === n) return;
            const d = this._order.indexOf(t);
            this._order.splice(d, 1);
            let _ = this._order.length;
            if (n) {
              const v = this._order.indexOf(n);
              if (v === -1) return void this.fire(new r.y(new Error(`Layer with id "${n}" does not exist on this map.`)));
              u.slot === this._layers[n].slot ? _ = v : r.w(`Layer with id "${n}" has a different slot. Layers can only be rearranged within the same slot.`);
            }
            this._order.splice(_, 0, t), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers();
          }
          removeLayer(t) {
            this._checkLoaded();
            const n = this._checkLayer(t);
            if (!n) return;
            n.setEventedParent(null);
            const u = this._order.indexOf(t);
            this._order.splice(u, 1), delete this._layers[t], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(n.fqid), this._changes.removeLayer(n);
            const d = this.getOwnLayerSourceCache(n);
            if (d && d.castsShadows) {
              let _ = !1;
              for (const v in this._layers) if (this._layers[v].source === n.source && this._layers[v].canCastShadows()) {
                _ = !0;
                break;
              }
              d.castsShadows = _;
            }
            n.onRemove && n.onRemove(this.map), this.mergeLayers();
          }
          getOwnLayer(t) {
            return this._layers[t];
          }
          hasLayer(t) {
            return t in this._mergedLayers;
          }
          hasLayerType(t) {
            for (const n in this._layers) if (this._layers[n].type === t) return !0;
            return !1;
          }
          setLayerZoomRange(t, n, u) {
            this._checkLoaded();
            const d = this._checkLayer(t);
            d && (d.minzoom === n && d.maxzoom === u || (n != null && (d.minzoom = n), u != null && (d.maxzoom = u), this._updateLayer(d)));
          }
          getSlots() {
            return this._checkLoaded(), this._mergedSlots;
          }
          setSlot(t, n) {
            this._checkLoaded();
            const u = this._checkLayer(t);
            u && u.slot !== n && (u.slot = n, this._updateLayer(u));
          }
          setFilter(t, n, u = {}) {
            this._checkLoaded();
            const d = this._checkLayer(t);
            if (d && !r.bn(d.filter, n)) return n == null ? (d.filter = void 0, void this._updateLayer(d)) : void (this._validate(yt, `layers.${d.id}.filter`, n, { layerType: d.type }, u) || (d.filter = r.cp(n), this._updateLayer(d)));
          }
          getFilter(t) {
            const n = this._checkLayer(t);
            if (n) return r.cp(n.filter);
          }
          setLayoutProperty(t, n, u, d = {}) {
            this._checkLoaded();
            const _ = this._checkLayer(t);
            if (_ && !r.bn(_.getLayoutProperty(n), u)) {
              if (u != null && (!d || d.validate !== !1) && Ma(_, Or.call(kt, { key: `layers.${t}.layout.${n}`, layerType: _.type, objectKey: n, value: u, styleSpec: r.a3, style: { glyphs: !0, sprite: !0 } }))) return;
              _.setLayoutProperty(n, u), _.configDependencies.size !== 0 && this._configDependentLayers.add(_.fqid), this._updateLayer(_);
            }
          }
          getLayoutProperty(t, n) {
            const u = this._checkLayer(t);
            if (u) return u.getLayoutProperty(n);
          }
          setPaintProperty(t, n, u, d = {}) {
            this._checkLoaded();
            const _ = this._checkLayer(t);
            if (!_ || r.bn(_.getPaintProperty(n), u) || u != null && (!d || d.validate !== !1) && Ma(_, ar.call(kt, { key: `layers.${t}.paint.${n}`, layerType: _.type, objectKey: n, value: u, styleSpec: r.a3 }))) return;
            const v = _.setPaintProperty(n, u);
            _.configDependencies.size !== 0 && this._configDependentLayers.add(_.fqid), v && this._updateLayer(_), this._changes.updatePaintProperties(_);
          }
          getPaintProperty(t, n) {
            const u = this._checkLayer(t);
            if (u) return u.getPaintProperty(n);
          }
          setFeatureState(t, n) {
            if (this._checkLoaded(), "target" in t) {
              if ("featuresetId" in t.target) {
                const { featuresetId: G, importId: X } = t.target, K = this.getFragmentStyle(X), ae = K.getFeaturesetLayers(G);
                for (const { source: oe, sourceLayer: pe } of ae) K.setFeatureState({ id: t.id, source: oe, sourceLayer: pe }, n);
              } else if ("layerId" in t.target) {
                const { layerId: G } = t.target, X = this.getLayer(G);
                this.setFeatureState({ id: t.id, source: X.source, sourceLayer: X.sourceLayer }, n);
              }
              return;
            }
            const u = t.source, d = t.sourceLayer, _ = this._checkSource(u);
            if (!_) return;
            const v = _.type;
            if (v === "geojson" && d) return void this.fire(new r.y(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
            if (v === "vector" && !d) return void this.fire(new r.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
            t.id === void 0 && this.fire(new r.y(new Error("The feature id parameter must be provided.")));
            const L = this.getOwnSourceCaches(u);
            for (const G of L) G.setFeatureState(d, t.id, n);
          }
          removeFeatureState(t, n) {
            if (this._checkLoaded(), "target" in t) {
              if ("featuresetId" in t.target) {
                const { featuresetId: G, importId: X } = t.target, K = this.getFragmentStyle(X), ae = K.getFeaturesetLayers(G);
                for (const { source: oe, sourceLayer: pe } of ae) K.removeFeatureState({ id: t.id, source: oe, sourceLayer: pe }, n);
              } else if ("layerId" in t.target) {
                const { layerId: G } = t.target, X = this.getLayer(G);
                this.removeFeatureState({ id: t.id, source: X.source, sourceLayer: X.sourceLayer }, n);
              }
              return;
            }
            const u = t.source, d = this._checkSource(u);
            if (!d) return;
            const _ = d.type, v = _ === "vector" ? t.sourceLayer : void 0;
            if (_ === "vector" && !v) return void this.fire(new r.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
            if (n && typeof t.id != "string" && typeof t.id != "number") return void this.fire(new r.y(new Error("A feature id is required to remove its specific state property.")));
            const L = this.getOwnSourceCaches(u);
            for (const G of L) G.removeFeatureState(v, t.id, n);
          }
          getFeatureState(t) {
            if (this._checkLoaded(), "target" in t) {
              let _;
              if ("featuresetId" in t.target) {
                const { featuresetId: v, importId: L } = t.target, G = this.getFragmentStyle(L), X = G.getFeaturesetLayers(v);
                for (const { source: K, sourceLayer: ae } of X) {
                  const oe = G.getFeatureState({ id: t.id, source: K, sourceLayer: ae });
                  if (oe && !_) _ = oe;
                  else if (!r.bn(_, oe)) return void this.fire(new r.y(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
                }
              } else if ("layerId" in t.target) {
                const { layerId: v } = t.target, L = this.getLayer(v);
                _ = this.getFeatureState({ id: t.id, source: L.source, sourceLayer: L.sourceLayer });
              }
              return _;
            }
            const n = t.source, u = t.sourceLayer, d = this._checkSource(n);
            if (d) {
              if (d.type !== "vector" || u) return t.id === void 0 && this.fire(new r.y(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(n)[0].getFeatureState(u, t.id);
              this.fire(new r.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
          }
          setTransition(t) {
            return this.stylesheet.transition = r.l({}, this.stylesheet.transition, t), this.transition = this.stylesheet.transition, this;
          }
          getTransition() {
            return r.l({}, this.stylesheet.transition);
          }
          serialize() {
            this._checkLoaded();
            const t = this.getTerrain(), n = t && this.terrain && this.terrain.scope === this.scope ? t : this.stylesheet.terrain;
            return r.cv({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: n, fog: this.stylesheet.fog, snow: this.stylesheet.snow, rain: this.stylesheet.rain, center: this.stylesheet.center, "color-theme": this.stylesheet["color-theme"], zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (u) => u !== void 0);
          }
          _updateFilteredLayers(t) {
            for (const n of Object.values(this._mergedLayers)) t(n) && this._updateLayer(n);
          }
          _updateLayer(t) {
            this._changes.updateLayer(t);
            const n = this.getLayerSourceCache(t), u = r.aC(t.source, t.scope), d = this._changes.getUpdatedSourceCaches();
            t.source && !d[u] && n && n.getSource().type !== "raster" && (this._changes.updateSourceCache(u, "reload"), n.pause()), t.invalidateCompiledFilter();
          }
          _flattenAndSortRenderedFeatures(t) {
            const n = (L) => this._mergedLayers[L].is3D(), u = this.order, d = {}, _ = [];
            for (let L = u.length - 1; L >= 0; L--) {
              const G = u[L];
              if (n(G)) {
                d[G] = L;
                for (const X of t) {
                  const K = X[G];
                  if (K) for (const ae of K) _.push(ae);
                }
              }
            }
            _.sort((L, G) => G.intersectionZ - L.intersectionZ);
            const v = [];
            for (let L = u.length - 1; L >= 0; L--) {
              const G = u[L];
              if (n(G)) for (let X = _.length - 1; X >= 0; X--) {
                const K = _[X].feature;
                if (K.layer && d[K.layer.id] < L) break;
                v.push(K), _.pop();
              }
              else for (const X of t) {
                const K = X[G];
                if (K) for (const ae of K) v.push(ae.feature);
              }
            }
            return v;
          }
          queryRenderedFeatures(t, n, u) {
            let d;
            n && !Array.isArray(n) && n.filter && (this._validate(yt, "queryRenderedFeatures.filter", n.filter, null, n), d = r.aZ(n.filter));
            const _ = {}, v = (K) => {
              if (Bc.has(K.type)) return;
              const ae = this.getOwnLayerSourceCache(K), oe = _[ae.id] = _[ae.id] || { sourceCache: ae, layers: {}, has3DLayers: !1 };
              K.is3D() && (oe.has3DLayers = !0), oe.layers[K.fqid] = oe.layers[K.fqid] || { styleLayer: K, targets: [] }, oe.layers[K.fqid].targets.push({ filter: d });
            };
            if (n && n.layers) {
              if (!Array.isArray(n.layers)) return this.fire(new r.y(new Error("parameters.layers must be an Array."))), [];
              for (const K of n.layers) {
                const ae = this._layers[K];
                if (!ae) return this.fire(new r.y(new Error(`The layer '${K}' does not exist in the map's style and cannot be queried for features.`))), [];
                v(ae);
              }
            } else for (const K in this._layers) v(this._layers[K]);
            const L = this._queryRenderedFeatures(t, _, u), G = this._flattenAndSortRenderedFeatures(L), X = [];
            for (const K of G) r.cs(K.layer.id) === this.scope && X.push(K);
            return X;
          }
          queryRenderedFeatureset(t, n, u) {
            let d;
            n && !Array.isArray(n) && n.filter && (this._validate(yt, "queryRenderedFeatures.filter", n.filter, null, n), d = r.aZ(n.filter));
            const _ = "mock", v = [];
            if (n && n.target) v.push(Object.assign({}, n, { targetId: _, filter: d }));
            else {
              const K = this.getFeaturesetDescriptors();
              for (const ae of K) v.push({ targetId: _, filter: d, target: ae });
              for (const { style: ae } of this.fragments) {
                const oe = ae.getFeaturesetDescriptors();
                for (const pe of oe) v.push({ targetId: _, filter: d, target: pe });
              }
            }
            const L = this.queryRenderedTargets(t, v, u), G = [], X = /* @__PURE__ */ new Set();
            for (const K of L) for (const ae of K.variants[_]) wo(ae, K, X) || G.push(new r.cw(K, ae));
            return G;
          }
          queryRenderedTargets(t, n, u) {
            const d = {}, _ = (L, G, X, K) => {
              const ae = d[G.id] = d[G.id] || { sourceCache: G, layers: {}, has3DLayers: !1 };
              if (ae.layers[L.fqid] = ae.layers[L.fqid] || { styleLayer: L, targets: [] }, L.is3D() && (ae.has3DLayers = !0), !K) return X.uniqueFeatureID = !1, void ae.layers[L.fqid].targets.push(X);
              ae.layers[L.fqid].targets.push(Object.assign({}, X, { namespace: K.namespace, properties: K.properties, uniqueFeatureID: K.uniqueFeatureID }));
            };
            for (const L of n) if ("featuresetId" in L.target) {
              const { featuresetId: G, importId: X } = L.target, K = this.getFragmentStyle(X);
              if (!K || !K._featuresetSelectors) continue;
              const ae = K._featuresetSelectors[G];
              if (!ae) {
                this.fire(new r.y(new Error(`The featureset '${G}' does not exist in the map's style and cannot be queried for features.`)));
                continue;
              }
              for (const oe of ae) {
                const pe = K.getOwnLayer(oe.layerId);
                pe && !Bc.has(pe.type) && _(pe, K.getOwnLayerSourceCache(pe), L, oe);
              }
            } else if ("layerId" in L.target) {
              const { layerId: G } = L.target, X = this.getLayer(G);
              if (!X || Bc.has(X.type)) continue;
              _(X, this.getLayerSourceCache(X), L);
            }
            const v = this._queryRenderedFeatures(t, d, u);
            return this._flattenAndSortRenderedFeatures(v);
          }
          _queryRenderedFeatures(t, n, u) {
            const d = [], _ = !!this.map._showQueryGeometry, v = si.createFromScreenPoints(t, u);
            for (const L in n) {
              const G = fs(v, n[L], this._availableImages, u, _);
              Object.keys(G).length && d.push(G);
            }
            if (this.placement) for (const L in n) {
              if (!n[L].sourceCache._onlySymbols) continue;
              const G = ou(v.screenGeometry, n[L], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData);
              Object.keys(G).length && d.push(G);
            }
            return d;
          }
          querySourceFeatures(t, n) {
            const u = n && n.filter;
            u && this._validate(yt, "querySourceFeatures.filter", u, null, n);
            let d = [];
            const _ = this.getOwnSourceCaches(t);
            for (const v of _) d = d.concat(mf(v, n));
            return d;
          }
          addSourceType(t, n, u) {
            return Ka.getSourceType(t) ? u(new Error(`A source type called "${t}" already exists.`)) : (Ka.setSourceType(t, n), n.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t, url: n.workerSourceURL }, u) : u(null, null));
          }
          getFlatLight() {
            return this.light.getLight();
          }
          setFlatLight(t, n, u = {}) {
            this._checkLoaded();
            const d = this.light.getLight();
            let _ = !1;
            for (const L in t) if (!r.bn(t[L], d[L])) {
              _ = !0;
              break;
            }
            if (!_) return;
            const v = this._getTransitionParameters();
            this.light.setLight(t, n, u), this.light.updateTransitions(v);
          }
          getTerrain() {
            return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null;
          }
          setTerrainForDraping() {
            this.setTerrain({ source: "", exaggeration: 0 }, 0);
          }
          checkCanvasFingerprintNoise() {
            this.disableElevatedTerrain === void 0 && (this.disableElevatedTerrain = r.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && r.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
          }
          setTerrain(t, n = 1) {
            if (this._checkLoaded(), !t) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), n === 0 && delete this.terrain, t === null ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
            this.checkCanvasFingerprintNoise();
            let u = t;
            const d = t.source == null;
            if (n === 1) {
              if (this.disableElevatedTerrain) return;
              if (typeof u.source == "object") {
                const L = "terrain-dem-src";
                this.addSource(L, u.source), u = r.cp(u), u = r.l(u, { source: L });
              }
              const _ = r.l({}, u), v = {};
              if (this.terrain && d) {
                _.source = this.terrain.get().source;
                const L = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                L && (v.style = L.serialize());
              }
              if (this._validate(ni, "terrain", _, v)) return;
            }
            if (!this.terrain || this.terrain.scope !== this.scope && !d || this.terrain && n !== this.terrain.drapeRenderMode) {
              if (!u) return;
              this._createTerrain(u, n), this.fire(new r.z("data", { dataType: "style" }));
            } else {
              const _ = this.terrain, v = _.get();
              for (const L of Object.keys(r.a3.terrain)) !u.hasOwnProperty(L) && r.a3.terrain[L].default && (u[L] = r.a3.terrain[L].default);
              for (const L in t) if (!r.bn(t[L], v[L])) {
                _.set(t, this.options), this.stylesheet.terrain = t;
                const G = this._getTransitionParameters({ duration: 0 });
                _.updateTransitions(G), this.fire(new r.z("data", { dataType: "style" }));
                break;
              }
            }
            this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
          }
          _createFog(t) {
            const n = this.fog = new jt(t, this.map.transform, this.scope, this.options);
            this.stylesheet.fog = n.get();
            const u = this._getTransitionParameters({ duration: 0 });
            n.updateTransitions(u);
          }
          _createSnow(t) {
            const n = this.snow = new qr(t, this.map.transform, this.scope, this.options);
            this.stylesheet.snow = n.get();
            const u = this._getTransitionParameters({ duration: 0 });
            n.updateTransitions(u);
          }
          _createRain(t) {
            const n = this.rain = new pi(t, this.map.transform, this.scope, this.options);
            this.stylesheet.rain = n.get();
            const u = this._getTransitionParameters({ duration: 0 });
            n.updateTransitions(u);
          }
          _updateMarkersOpacity() {
            this.map._markers.length !== 0 && this.map._requestDomTask(() => {
              for (const t of this.map._markers) t._evaluateOpacity();
            });
          }
          getFog() {
            return this.fog ? this.fog.get() : null;
          }
          setFog(t) {
            if (this._checkLoaded(), !t) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
            if (this.fog) {
              const n = this.fog;
              if (!r.bn(n.get(), t)) {
                n.set(t, this.options), this.stylesheet.fog = n.get();
                const u = this._getTransitionParameters({ duration: 0 });
                n.updateTransitions(u);
              }
            } else this._createFog(t);
            this._markersNeedUpdate = !0;
          }
          getSnow() {
            return this.snow ? this.snow.get() : null;
          }
          setSnow(t) {
            if (this._checkLoaded(), !t) return delete this.snow, void delete this.stylesheet.snow;
            if (this.snow) {
              const n = this.snow;
              if (!r.bn(n.get(), t)) {
                n.set(t, this.options), this.stylesheet.snow = n.get();
                const u = this._getTransitionParameters({ duration: 0 });
                n.updateTransitions(u);
              }
            } else this._createSnow(t);
            this._markersNeedUpdate = !0;
          }
          getRain() {
            return this.rain ? this.rain.get() : null;
          }
          setRain(t) {
            if (this._checkLoaded(), !t) return delete this.rain, void delete this.stylesheet.rain;
            if (this.rain) {
              const n = this.rain;
              if (!r.bn(n.get(), t)) {
                n.set(t, this.options), this.stylesheet.rain = n.get();
                const u = this._getTransitionParameters({ duration: 0 });
                n.updateTransitions(u);
              }
            } else this._createRain(t);
            this._markersNeedUpdate = !0;
          }
          _reloadColorTheme() {
            const t = () => {
              for (const d in this._layers) this._layers[d].lut = this._styleColorTheme.lut;
              for (const d in this._sourceCaches) this._sourceCaches[d].clearTiles();
            }, n = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
            if (!n) return this._styleColorTheme.lut = null, void t();
            const u = this._evaluateColorThemeData(n);
            this._loadColorTheme(u).then(() => {
              this.fire(new r.z("colorthemeset")), t();
            }).catch((d) => {
              r.w(`Couldn't set color theme: ${d}`);
            });
          }
          setColorTheme(t) {
            this._checkLoaded(), this._styleColorTheme.colorThemeOverride && r.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t, this._reloadColorTheme();
          }
          setImportColorTheme(t, n) {
            const u = this.getFragmentStyle(t);
            u && (u._styleColorTheme.colorThemeOverride = n, u._reloadColorTheme());
          }
          _getTransitionParameters(t) {
            return { now: r.q.now(), transition: r.l(this.transition, t) };
          }
          updateDrapeFirstLayers() {
            if (!this.terrain) return;
            const t = [], n = [];
            for (const u of this._mergedOrder) this.isLayerDraped(this._mergedLayers[u]) ? t.push(u) : n.push(u);
            this._drapedFirstOrder = [], this._drapedFirstOrder.push(...t), this._drapedFirstOrder.push(...n);
          }
          _createTerrain(t, n) {
            const u = this.terrain = new Ne(t, n, this.scope, this.options);
            n === 1 && (this.stylesheet.terrain = t), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
            const d = this._getTransitionParameters({ duration: 0 });
            u.updateTransitions(d);
          }
          _force3DLayerUpdate() {
            for (const t in this._layers) {
              const n = this._layers[t];
              n.type === "fill-extrusion" && this._updateLayer(n);
            }
          }
          _forceSymbolLayerUpdate() {
            for (const t in this._layers) {
              const n = this._layers[t];
              n.type === "symbol" && this._updateLayer(n);
            }
          }
          _validate(t, n, u, d, _ = {}) {
            if (_ && _.validate === !1) return !1;
            const v = r.l({}, this.serialize());
            return Ma(this, t.call(kt, r.l({ key: n, style: v, value: u, styleSpec: r.a3 }, d)));
          }
          _remove() {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), r.cx.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const t in this._mergedLayers) this._mergedLayers[t].setEventedParent(null);
            for (const t in this._mergedSourceCaches) this._mergedSourceCaches[t].clearTiles(), this._mergedSourceCaches[t].setEventedParent(null);
            this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
          }
          clearSource(t) {
            const n = this.getSourceCaches(t);
            for (const u of n) u.clearTiles();
          }
          clearSources() {
            for (const t in this._mergedSourceCaches) this._mergedSourceCaches[t].clearTiles();
          }
          reloadSource(t) {
            const n = this.getSourceCaches(t);
            for (const u of n) u.resume(), u.reload();
          }
          reloadSources() {
            for (const t of this.getSources()) t.reload && t.reload();
          }
          reloadModels() {
            this.modelManager.reloadModels(""), this.forEachFragmentStyle((t) => {
              t.modelManager.reloadModels(t.scope);
            });
          }
          updateSources(t) {
            let n;
            this.directionalLight && (n = vs(this.directionalLight));
            for (const u in this._mergedSourceCaches) this._mergedSourceCaches[u].update(t, void 0, void 0, n);
          }
          _generateCollisionBoxes() {
            for (const t in this._sourceCaches) {
              const n = this._sourceCaches[t];
              n.resume(), n.reload();
            }
          }
          _updatePlacement(t, n, u, d, _, v, L = !1) {
            let G = !1, X = !1;
            const K = {}, ae = {};
            for (const oe of this._mergedOrder) {
              const pe = this._mergedLayers[oe];
              if (pe.type !== "symbol") continue;
              const Be = r.aC(pe.source, pe.scope);
              let Re = K[Be];
              if (!Re) {
                const Ve = this.getLayerSourceCache(pe);
                if (!Ve) continue;
                const et = Ve.getRenderableIds(!0).map((ut) => Ve.getTileByID(ut));
                ae[Be] = et.slice(), Re = K[Be] = et.sort((ut, st) => st.tileID.overscaledZ - ut.tileID.overscaledZ || (ut.tileID.isLessThan(st.tileID) ? -1 : 1));
              }
              const Ge = this.crossTileSymbolIndex.addLayer(pe, Re, n.center.lng, n.projection);
              G = G || Ge;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), L = L || this._layerOrderChanged || d === 0, this._layerOrderChanged && this.fire(new r.z("neworder")), (L || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(r.q.now(), n.zoom)) && (this.pauseablePlacement = new ud(n, this._mergedOrder, L, u, d, _, this.placement, this.fog && n.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, K, ae, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(r.q.now()), X = !0), G && this.pauseablePlacement.placement.setStale()), X || G) {
              this._buildingIndex.onNewFrame(n.zoom);
              for (let oe = 0; oe < this._mergedOrder.length; oe++) {
                const pe = this._mergedLayers[this._mergedOrder[oe]];
                if (pe.type !== "symbol") continue;
                const Be = this.isLayerClipped(pe);
                this.placement.updateLayerOpacities(pe, K[r.aC(pe.source, pe.scope)], oe, Be ? v : null);
              }
            }
            return { needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(r.q.now()) };
          }
          _releaseSymbolFadeTiles() {
            for (const t in this._sourceCaches) this._sourceCaches[t].releaseSymbolFadeTiles();
          }
          addImport(t, n) {
            this._checkLoaded();
            const u = this.stylesheet.imports = this.stylesheet.imports || [];
            if (u.findIndex(({ id: _ }) => _ === t.id) !== -1) return void this.fire(new r.y(new Error(`Import with id '${t.id}' already exists in the map's style.`)));
            if (!n) return u.push(t), this._loadImports([t], !0);
            const d = u.findIndex(({ id: _ }) => _ === n);
            return d === -1 && this.fire(new r.y(new Error(`Import with id "${n}" does not exist on this map.`))), this.stylesheet.imports = u.slice(0, d).concat(t).concat(u.slice(d)), this._loadImports([t], !0, n);
          }
          updateImport(t, n) {
            this._checkLoaded();
            const u = this.stylesheet.imports || [], d = this.getImportIndex(t);
            return d === -1 ? this : typeof n == "string" ? (this.setImportUrl(t, n), this) : (n.url && n.url !== u[d].url && this.setImportUrl(t, n.url), r.bn(n.config, u[d].config) || this.setImportConfig(t, n.config, n.data.schema), r.bn(n.data, u[d].data) || this.setImportData(t, n.data), this);
          }
          moveImport(t, n) {
            this._checkLoaded();
            let u = this.stylesheet.imports || [];
            const d = this.getImportIndex(t);
            if (d === -1) return this;
            const _ = this.getImportIndex(n);
            if (_ === -1) return this;
            const v = u[d], L = this.fragments[d];
            return u = u.filter(({ id: G }) => G !== t), this.fragments = this.fragments.filter(({ id: G }) => G !== t), this.stylesheet.imports = u.slice(0, _).concat(v).concat(u.slice(_)), this.fragments = this.fragments.slice(0, _).concat(L).concat(this.fragments.slice(_)), this.mergeLayers(), this;
          }
          setImportUrl(t, n) {
            this._checkLoaded();
            const u = this.stylesheet.imports || [], d = this.getImportIndex(t);
            if (d === -1) return this;
            u[d].url = n;
            const _ = this.fragments[d];
            return _.style = this._createFragmentStyle(u[d]), _.style.on("style.import.load", () => this.mergeAll()), _.style.loadURL(n), this;
          }
          setImportData(t, n) {
            this._checkLoaded();
            const u = this.getImportIndex(t), d = this.stylesheet.imports || [];
            return u === -1 ? this : n ? (this.fragments[u].style.setState(n), this._reloadImports(), this) : (delete d[u].data, this.setImportUrl(t, d[u].url));
          }
          setImportConfig(t, n, u) {
            this._checkLoaded();
            const d = this.getImportIndex(t), _ = this.stylesheet.imports || [];
            if (d === -1) return this;
            n ? _[d].config = n : delete _[d].config;
            const v = this.fragments[d];
            u && v.style.stylesheet && (v.style.stylesheet.schema = u);
            const L = v.style.stylesheet && v.style.stylesheet.schema;
            return v.config = n, v.style.updateConfig(n, L), this.updateConfigDependencies(), this;
          }
          removeImport(t) {
            this._checkLoaded();
            const n = this.stylesheet.imports || [], u = this.getImportIndex(t);
            u !== -1 && (n.splice(u, 1), this.fragments[u].style._remove(), this.fragments.splice(u, 1), this._reloadImports());
          }
          getImportIndex(t) {
            const n = (this.stylesheet.imports || []).findIndex((u) => u.id === t);
            return n === -1 && this.fire(new r.y(new Error(`Import '${t}' does not exist in the map's style and cannot be updated.`))), n;
          }
          getLayer(t) {
            return this._mergedLayers[t];
          }
          getSources() {
            const t = [];
            for (const n in this._mergedOtherSourceCaches) {
              const u = this._mergedOtherSourceCaches[n];
              u && t.push(u.getSource());
            }
            return t;
          }
          getSource(t, n) {
            const u = this.getSourceCache(t, n);
            return u && u.getSource();
          }
          getLayerSource(t) {
            const n = this.getLayerSourceCache(t);
            return n && n.getSource();
          }
          getSourceCache(t, n) {
            const u = r.aC(t, n);
            return this._mergedOtherSourceCaches[u];
          }
          getLayerSourceCache(t) {
            const n = r.aC(t.source, t.scope);
            return t.type === "symbol" ? this._mergedSymbolSourceCaches[n] : this._mergedOtherSourceCaches[n];
          }
          getSourceCaches(t) {
            if (t == null) return Object.values(this._mergedSourceCaches);
            const n = [];
            return this._mergedOtherSourceCaches[t] && n.push(this._mergedOtherSourceCaches[t]), this._mergedSymbolSourceCaches[t] && n.push(this._mergedSymbolSourceCaches[t]), n;
          }
          updateSourceCaches() {
            const t = this._changes.getUpdatedSourceCaches();
            for (const n in t) {
              const u = t[n];
              u === "reload" ? this.reloadSource(n) : u === "clear" && this.clearSource(n);
            }
          }
          updateLayers(t) {
            const n = this._changes.getUpdatedPaintProperties();
            for (const u of n) {
              const d = this.getLayer(u);
              d && d.updateTransitions(t);
            }
          }
          getImages(t, n, u) {
            this.imageManager.getImages(n.icons, n.scope, u), this._updateTilesForChangedImages();
            const d = (_) => {
              _ && _.setDependencies(n.tileID.key, n.type, n.icons);
            };
            d(this._otherSourceCaches[n.source]), d(this._symbolSourceCaches[n.source]);
          }
          rasterizeImages(t, n, u) {
            this.imageManager.rasterizeImages(n, u);
          }
          getGlyphs(t, n, u) {
            this.glyphManager.getGlyphs(n.stacks, n.scope, u);
          }
          getResource(t, n, u) {
            return r.cy(n, u);
          }
          getOwnSourceCache(t) {
            return this._otherSourceCaches[t];
          }
          getOwnLayerSourceCache(t) {
            return t.type === "symbol" ? this._symbolSourceCaches[t.source] : this._otherSourceCaches[t.source];
          }
          getOwnSourceCaches(t) {
            const n = [];
            return this._otherSourceCaches[t] && n.push(this._otherSourceCaches[t]), this._symbolSourceCaches[t] && n.push(this._symbolSourceCaches[t]), n;
          }
          _isSourceCacheLoaded(t) {
            const n = this.getOwnSourceCaches(t);
            return n.length === 0 ? (this.fire(new r.y(new Error(`There is no source with ID '${t}'`))), !1) : n.every((u) => u.loaded());
          }
          has3DLayers() {
            return this._has3DLayers;
          }
          hasSymbolLayers() {
            return this._hasSymbolLayers;
          }
          hasCircleLayers() {
            return this._hasCircleLayers;
          }
          isLayerClipped(t, n) {
            if (!this._clipLayerPresent && t.type !== "fill-extrusion") return !1;
            const u = t.type === "fill-extrusion" && t.sourceLayer === "building";
            if (t.is3D()) {
              if (u || n && n.type === "batched-model" || t.type === "model") return !0;
            } else if (t.type === "symbol") return !0;
            return !1;
          }
          _clearWorkerCaches() {
            this.dispatcher.broadcast("clearCaches");
          }
          destroy() {
            this._clearWorkerCaches(), this.fragments.forEach((t) => {
              t.style._remove();
            }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
          }
        }
        Ka.getSourceType = function(l) {
          return ea[l];
        }, Ka.setSourceType = function(l, t) {
          ea[l] = t;
        }, Ka.registerForPluginStateChange = r.ch;
        var Fc = `
#define EPSILON 0.0000001
#define PI 3.141592653589793
#ifdef RENDER_CUTOFF
float cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}
#endif`, Qu = `
out vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
#ifdef INDICATOR_CUTOUT
uniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;
#endif
vec4 applyCutout(vec4 color,float height) {
#ifdef INDICATOR_CUTOUT
float verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);
#else
return color;
#endif
}
#ifdef DEBUG_WIREFRAME
#define HANDLE_WIREFRAME_DEBUG \\
glFragColor=vec4(0.7,0.0,0.0,0.7); \\
gl_FragDepth=gl_FragCoord.z-0.0001;
#else
#define HANDLE_WIREFRAME_DEBUG
#endif
#ifdef RENDER_CUTOFF
uniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;
#endif
vec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}`, xs = `
#define EXTENT 8192.0
#define RAD_TO_DEG 180.0/PI
#define DEG_TO_RAD PI/180.0
#define GLOBE_RADIUS EXTENT/PI/2.0
float wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}
#ifdef PROJECTION_GLOBE_VIEW
vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {
#ifndef PROJECTED_POS_ON_VIEWPORT
float tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;
#else
return vec3(0.0);
#endif
}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(
unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}
#ifdef RENDER_CUTOFF
uniform vec4 u_cutoff_params;out float v_cutoff_opacity;
#endif
const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)
{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}`, Jo = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", Ws = `
#define ELEVATION_SCALE 7.0
#define ELEVATION_OFFSET 450.0
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(
mix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}
#else
vec3 elevationVector(vec2 pos) { return vec3(0,0,1); }
#endif
#ifdef TERRAIN
uniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}float prevElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}
#ifdef TERRAIN_VERTEX_MORPHING
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}
#else
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
return currentElevation(apos);}
#endif
vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}
#else
float elevation(vec2 pos) { return 0.0; }
#endif
#ifdef DEPTH_OCCLUSION
uniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;
#ifdef DEPTH_D24
float unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}
#else
highp float unpack_depth_rgba(vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;
#ifdef DEPTH_D24
float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);
#else
float depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));
#endif
return coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;
#ifdef DEPTH_D24
highp vec4 depth=vec4(
texture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r
);depth=unpack_depth4(depth);
#else
highp vec4 depth=vec4(
unpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))
);
#endif
return depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));
#endif
res+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}
#else
bool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }
#endif//DEPTH_OCCLUSION`, ec = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}
#endif`, Zs = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}
#endif`, bs = `#ifdef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)
);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)
);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}
#endif`, Qo = `#ifdef RASTER_ARRAY
uniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}
#endif
uniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}`, El = `#ifdef RENDER_SHADOWS
uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}
#endif//RENDER_SHADOWS`, qs = `#ifdef RENDER_SHADOWS
#ifdef DEPTH_TEXTURE
uniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;
#else
uniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;
#endif
uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_1,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_0,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;
#ifdef TEXTURE_GATHER
highp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));
#else
highp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(
shadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)
);
#endif
vec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {
#ifdef SHADOWS_SINGLE_CASCADE
light_view_pos0.xyz/=light_view_pos0.w;vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);
#else
light_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));
#endif
}highp float calculate_shadow_bias(float NDotL) {
#ifdef NORMAL_OFFSET
return 0.5*u_shadow_bias.x;
#else
return 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));
#endif
}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)
{highp vec2 biasUV=vec2(
pos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}
#endif`;
        const es = [];
        $s(Fc, es), $s(xs, es), $s(Qu, es);
        const Sl = { "_prelude_fog.vertex.glsl": ec, "_prelude_terrain.vertex.glsl": Ws, "_prelude_shadow.vertex.glsl": El, "_prelude_fog.fragment.glsl": Zs, "_prelude_shadow.fragment.glsl": qs, "_prelude_lighting.glsl": `
#ifdef LIGHTING_3D_MODE
uniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}
#endif//LIGHTING_3D_MODE`, "_prelude_raster_array.glsl": bs, "_prelude_raster_particle.glsl": Qo }, pu = {};
        Oi("", Ws), Oi(Zs, ec), Oi(qs, El), Oi(bs, ""), Oi(Qo, "");
        const tc = Oi(Qu, xs), mu = Fc;
        var Tl = { background: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec4 u_color;uniform float u_opacity;
#ifdef LIGHTING_3D_MODE
in vec4 v_color;
#endif
void main() {vec4 out_color;
#ifdef LIGHTING_3D_MODE
out_color=v_color;
#else
out_color=u_color;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_lighting.glsl"
in vec2 a_pos;uniform mat4 u_matrix;
#ifdef LIGHTING_3D_MODE
uniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), backgroundPattern: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), circle: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
uniform float u_emissive_strength;void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? 
smoothstep(0.0,-antialiased_blur,1.0-extrude_length) : 
smoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(
antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)
);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_apply_premultiplied(out_color,v_fog_pos);
#endif
glFragColor=out_color*(v_visibility*opacity_t);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define NUM_VISIBILITY_RINGS 2
#define INV_SQRT2 0.70710678
#define ELEVATION_BIAS 0.0001
#define NUM_SAMPLES_PER_RING 16
uniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
#ifdef ELEVATED_ROADS
in float a_circle_z_offset;
#endif
out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
vec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {
#if defined(TERRAIN)
return elevation(pos)+ELEVATION_BIAS;
#else
return 0.0;
#endif
}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);
#ifdef PITCH_WITH_MAP
#ifdef PROJECTION_GLOBE_VIEW
return u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );
#else
return u_matrix*( world_center+vec4(sample_offset,0,0) );
#endif
#else
return projected_center+vec4(sample_offset,0,0);
#endif
}float get_sample_step() {
#ifdef PITCH_WITH_MAP
return 2.0*PI/float(NUM_SAMPLES_PER_RING);
#else
return PI/float(NUM_SAMPLES_PER_RING);
#endif
}void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);
#else 
surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);
#endif
#ifdef ELEVATED_ROADS
world_center.z+=a_circle_z_offset+ELEVATION_BIAS;
#endif
vec4 projected_center=u_matrix*world_center;float view_scale=0.0;
#ifdef PITCH_WITH_MAP
#ifdef SCALE_WITH_MAP
view_scale=1.0;
#else
view_scale=projected_center.w/u_camera_to_center_distance;
#endif
#else
#ifdef SCALE_WITH_MAP
view_scale=u_camera_to_center_distance;
#else
view_scale=projected_center.w;
#endif
#endif
gl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;
#ifdef TERRAIN
float step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;
#ifdef PITCH_WITH_MAP
float cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;
#else
occlusion_world_center=world_center;occlusion_projected_center=projected_center;
#endif
for(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);
#else
visibility=1.0;
#endif
#ifdef PROJECTION_GLOBE_VIEW
visibility=1.0;
#endif
v_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);
#ifdef FOG
v_fog_pos=fog_position(world_center.xyz);
#endif
}`), clippingMask: Oi("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Oi(`#include "_prelude_fog.fragment.glsl"
uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);
#ifdef FOG
if (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#else
pos=vec3(tilePos+extrude,elevation(tilePos));
#endif
gl_Position=u_matrix*vec4(pos,1);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), heatmapTexture: Oi(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(0.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Oi("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", `#include "_prelude_terrain.vertex.glsl"
in vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}`), collisionCircle: Oi("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", `in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(
mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}`), debug: Oi("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", `#include "_prelude_terrain.vertex.glsl"
in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;
#endif
out vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
gl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);
#else
gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);
#endif
}`), fill: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
vec4 out_color=color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=opacity;
#ifdef INDICATOR_CUTOUT
if (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=z_offset;
#endif
}`), fillOutline: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillOutlinePattern: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
in highp vec2 v_pos;in highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;out highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillPattern: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillExtrusion: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec4 v_color;in vec4 v_flat;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;
#endif
uniform lowp float u_opacity;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec2 v_ao;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
in vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
in highp vec3 v_normal;
#endif
uniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
in float v_flood_radius;in float v_has_floodlight;
#endif
in float v_height;
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float emissive_strength
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
vec3 normal=normalize(v_normal);
#endif
float z;vec4 color=v_color;
#ifdef ZERO_ROOF_RADIUS
z=float(normal.z > 0.00001);
#ifdef LIGHTING_3D_MODE
normal=mix(normal,vec3(0.0,0.0,1.0),z);
#else
color=mix(v_color,v_roof_color,z);
#endif
#endif
float h=max(0.0,v_height);float ao_shade=1.0;
#ifdef FAUX_AO
float intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;
#ifdef ZERO_ROOF_RADIUS
concave*=(1.0-z);
#endif
float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
color.rgb*=mix(ao_shade,1.0,v_has_floodlight);
#else
color.rgb*=ao_shade;
#endif
#else
color.rgb*=ao_shade;
#endif
#endif
#ifdef LIGHTING_3D_MODE
float flood_radiance=0.0;
#ifdef FLOOD_LIGHT
flood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;
#endif
#ifdef RENDER_SHADOWS
#ifdef FLOOD_LIGHT
float ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);
#else
float shadowed_lighting_factor;
#ifdef RENDER_CUTOFF
shadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}
#else
shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);
#endif
color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);
#endif
#else
color.rgb=apply_lighting(color.rgb,normal);
#ifdef FLOOD_LIGHT
color.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);
#endif
#endif
color.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));
#endif
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,h);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
uniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
out vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
out highp vec3 v_normal;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec2 v_ao;
#endif
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
out float v_flood_radius;out float v_has_floodlight;
#endif
out float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define highp float flood_light_wall_radius
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize highp float flood_light_wall_radius
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp float emissive_strength
base*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
v_normal=normal;
#endif
base=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
h=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float cutoff=1.0;vec3 scaled_pos=pos;
#ifdef RENDER_CUTOFF
vec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=pos;vec3 shd_pos1=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);
#endif
float NdotL=0.0;float colorvalue=0.0;
#ifndef LIGHTING_3D_MODE
colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#endif
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
float is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;
#endif
v_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);
#else
v_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
float roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), fillExtrusionDepth: Oi(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp vec4 color
out highp float v_depth;void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp vec4 color
base*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
pos=vec3(pos_nx.xy,t > 0.0 ? height : base);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}`), fillExtrusionPattern: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
in vec3 v_normal;
#endif
in highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define highp float pixel_ratio
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize highp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;
#else
out_color=out_color*v_lighting;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,height);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
out highp vec2 v_pos;out vec4 v_lighting;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
out vec3 v_normal;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define highp float pixel_ratio
#pragma mapbox: define highp float line_width
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize highp float pixel_ratio
#pragma mapbox: initialize highp float line_width
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=z;vec3 p;float c_ele;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);
#else
p=vec3(pos_nx.xy,z);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0
? pos_nx.xy
: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_normal=normal;
#else
v_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;
#endif 
#ifdef FOG
v_fog_pos=fog_position(p);
#endif
}`), groundShadow: Oi(`#include "_prelude_shadow.fragment.glsl"
precision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#ifdef FOG
in float v_fog_opacity;
#endif
void main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);
#ifdef RENDER_CUTOFF
shadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));
#endif
#ifdef FOG
shadow=mix(shadow,vec3(1.0),v_fog_opacity);
#endif
#ifdef INDICATOR_CUTOUT
shadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);
#endif
glFragColor=vec4(shadow,1.0);}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;
#ifdef FOG
out float v_fog_opacity;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);
#ifdef FOG
v_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);
#endif
}`), fillExtrusionGroundEffect: Oi(`uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;
#ifdef SDF_SUBPASS
in highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}
#ifdef FOG
in highp float v_fog;
#endif
#endif
void main() {
#ifdef CLEAR_SUBPASS
vec4 color=vec4(1.0);
#ifdef CLEAR_FROM_TEXTURE
color=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));
#endif
glFragColor=color;
#else
#ifdef SDF_SUBPASS
highp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;
#ifdef FOG
fog=v_fog;
#endif
#ifdef RENDER_CUTOFF
fog*=v_cutoff_opacity;
#endif
glFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));
#else
vec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);
#ifdef OVERDRAW_INSPECTOR
color=vec4(1.0);
#endif
glFragColor=color;
#endif
HANDLE_WIREFRAME_DEBUG;
#endif
}`, `#include "_prelude_fog.vertex.glsl"
in highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;
#ifdef SDF_SUBPASS
out highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;
#ifdef FOG
out highp float v_fog;
#endif
#endif
uniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;
#pragma mapbox: define highp float flood_light_ground_radius
const float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {
#pragma mapbox: initialize highp float flood_light_ground_radius
vec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;
#ifdef SDF_SUBPASS
v_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);
#ifdef FOG
v_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);
#endif
#endif
float hidden_by_landmark=0.0;
#ifdef HAS_CENTROID
hidden_by_landmark=a_hidden_by_landmark;
#endif
float isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
}`), hillshadePrepare: Oi(`precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(
(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)
)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(
deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef LIGHTING_3D_MODE
glFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);
#endif
#ifdef FOG
glFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), line: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform sampler2D u_dash_image;in vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform sampler2D u_gradient_image;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
float linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);
#ifdef RENDER_LINE_DASH
float sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);
#endif
highp vec4 out_color;
#ifdef RENDER_LINE_GRADIENT
out_color=texture(u_gradient_image,v_uv.xy);
#else
out_color=color;
#endif
float trim_alpha=1.0;
#ifdef RENDER_LINE_TRIM_OFFSET
highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}
#endif
if (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}
#ifdef RENDER_LINE_BORDER
float edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
out_color.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=(alpha*opacity);
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define EXTRUDE_SCALE 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)
in vec3 a_z_offset_width;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
in highp vec3 a_packed;
#endif
#ifdef RENDER_LINE_DASH
in float a_linesofar;
#endif
uniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform float u_image_height;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;
#ifdef VARIABLE_LINE_WIDTH
float left=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);halfwidth=(u_width_scale*(left==1.0 ? a_z_offset_width.y : a_z_offset_width.z))/2.0;
#else
halfwidth=(u_width_scale*width)/2.0;
#endif
offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
highp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];
#ifdef RENDER_LINE_GRADIENT
highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);
#else
v_uv=vec3(a_uv_x,0.0,line_progress);
#endif
#endif
#ifdef RENDER_LINE_DASH
float scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);
#endif
v_width2=vec2(outset,inset);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`), linePattern: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec3 v_uv;
#endif
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef LINE_JOIN_NONE
in vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
uniform float u_emissive_strength;
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define mediump float pixel_ratio
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize mediump float pixel_ratio
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);
#ifdef RENDER_LINE_TRIM_OFFSET
highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}
#endif
#ifdef LINE_JOIN_NONE
highp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}
#endif
#ifdef LIGHTING_3D_MODE
color=apply_lighting_with_emission_ground(color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
color.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,v_z_offset);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
in vec3 a_z_offset_width;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec3 a_packed;
#endif
in highp float a_linesofar;
#ifdef LINE_JOIN_NONE
in highp vec3 a_pattern_data;out vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
out highp vec3 v_uv;
#endif
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
#pragma mapbox: define mediump float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define mediump float floorwidth
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define mediump float pixel_ratio
void main() {
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
#pragma mapbox: initialize mediump float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize mediump float floorwidth
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize mediump float pixel_ratio
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
highp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);
#ifdef LINE_JOIN_NONE
v_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`), raster: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_raster_array.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
in float v_split_fade;
#endif
uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;
#ifndef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;
#endif
#ifdef RASTER_COLOR
uniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;
#endif
void main() {vec4 color0,color1,color;vec2 value;
#ifdef RASTER_COLOR
#ifdef RASTER_ARRAY
#ifdef RASTER_ARRAY_LINEAR
value=mix(
raTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#else
value=mix(
raTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#endif
if (value.y > 0.0) value.x/=value.y;
#else
color=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);
#endif
color=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;
#else
color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);
#endif
color.a*=u_opacity;
#ifdef GLOBE_POLES
color.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);
#endif
vec3 rgb=color.rgb;rgb=vec3(
dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef PROJECTION_GLOBE_VIEW
glFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));
#endif
#ifdef RENDER_CUTOFF
glFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;in vec2 a_texture_pos;
#endif
out vec2 v_pos0;out vec2 v_pos1;out float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
out float v_split_fade;
#endif
void main() {vec2 uv;
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);
#endif
#else
float w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    
v_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;
#ifdef RENDER_CUTOFF
v_depth=gl_Position.z;
#endif
}`), rasterParticle: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
uv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), rasterParticleDraw: Oi("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", `#include "_prelude_raster_particle.glsl"
in float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(
mod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}`), rasterParticleTexture: Oi("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: Oi(`#include "_prelude_raster_particle.glsl"
uniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(
linearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)
);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}`, "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbol: Oi(`#include "_prelude_lighting.glsl"
#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;
#ifdef ICON_TRANSITION
uniform float u_icon_transition;
#endif
#ifdef COLOR_ADJUSTMENT
uniform mat4 u_color_adj_mat;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
in vec2 v_tex_a;
#ifdef ICON_TRANSITION
in vec2 v_tex_b;
#endif
in float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
in float is_sdf;in vec2 v_tex_a_icon;
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
vec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];
#ifdef RENDER_TEXT_AND_SYMBOL
if (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
return;}
#endif
#ifdef RENDER_SDF
float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;
#else
#ifdef ICON_TRANSITION
vec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);
#else
out_color=texture(u_texture,v_tex_a);
#endif
#ifdef COLOR_ADJUSTMENT
out_color=u_color_adj_mat*out_color;
#endif
#endif
out_color*=opacity*fade_opacity;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,emissive_strength);
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
in vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;
#ifdef Z_OFFSET
in float a_auto_z_offset;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_globe_anchor;in vec3 a_globe_normal;
#endif
#ifdef ICON_TRANSITION
in vec2 a_texb;
#endif
#ifdef OCCLUSION_QUERIES
in float a_occlusion_query_opacity;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
out vec2 v_tex_a;
#ifdef ICON_TRANSITION
out vec2 v_tex_b;
#endif
out float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
out float is_sdf;out vec2 v_tex_a_icon;
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
#pragma mapbox: define lowp float occlusion_opacity
#pragma mapbox: define lowp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
#pragma mapbox: initialize lowp float occlusion_opacity
#pragma mapbox: initialize lowp float z_offset
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);
#ifdef Z_OFFSET
e+=a_auto_z_offset;
#endif
vec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;
#else
offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;
#endif
vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
#ifdef PROJECTED_POS_ON_VIEWPORT
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);
#else
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    
#endif
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
#ifdef Z_OFFSET
z+=u_pitch_with_map ? a_auto_z_offset+(u_elevation_from_sea ? z_offset : z_offset) : 0.0;
#else
z+=u_pitch_with_map ? (u_elevation_from_sea ? z_offset : z_offset) : 0.0;
#endif
float occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));
#ifdef DEPTH_OCCLUSION
float depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;
#endif
#ifdef OCCLUSION_QUERIES
float occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;
#endif
float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);
#endif
float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;
#ifdef RENDER_TEXT_AND_SYMBOL
is_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;
#endif
#ifdef ICON_TRANSITION
v_tex_b=a_texb/u_texsize;
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=e;
#endif
}`), terrainRaster: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;in vec2 v_pos0;
#ifdef FOG
in float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#endif
uniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;
#ifdef LIGHTING_3D_MODE
const vec3 normal=vec3(0.0,0.0,1.0);
#ifdef RENDER_SHADOWS
float cutoffOpacity=1.0;
#ifdef RENDER_CUTOFF
cutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);
#endif
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
vec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;
#else
float lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));
#endif
#else
float lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;
#endif
#endif
#else
color=image_color;
#endif
#ifdef FOG
#ifdef ZERO_EXAGGERATION
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#else
color=fog_dither(fog_apply_from_vert(color,v_fog_opacity));
#endif
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;
#ifdef FOG
out float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;
#endif
void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);
#ifdef FOG
#ifdef ZERO_EXAGGERATION
v_fog_pos=fog_position(decodedPos);
#else
v_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));
#endif
#endif
#ifdef RENDER_SHADOWS
vec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);
#endif
}`), terrainDepth: Oi("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}`), skybox: Oi(`#include "_prelude_fog.fragment.glsl"
in lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(
cos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;
#ifdef FOG
sky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);
#endif
sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, Jo), skyboxGradient: Oi(`#include "_prelude_fog.fragment.glsl"
in highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));
#ifdef FOG
color.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;
#endif
color*=u_opacity;glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, Jo), skyboxCapture: Oi(`
in highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;
#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)
#define BETA_M                  vec3(21e-6,21e-6,21e-6)
#define MIE_G                   0.76
#define DENSITY_HEIGHT_SCALE_R  8000.0
#define DENSITY_HEIGHT_SCALE_M  1200.0
#define PLANET_RADIUS           6360e3
#define ATMOSPHERE_RADIUS       6420e3
#define SAMPLE_STEPS            10
#define DENSITY_STEPS           4
float ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}`, "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;
#ifndef FOG
uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;
#endif
void main() {vec4 color;
#ifdef CUSTOM_ANTIALIASING
highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
raster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);
#else
raster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;
#else
color=apply_lighting_ground(color);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;
#endif
out vec2 v_pos0;void main() {
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;vec2 uv=a_uv;
#else
float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);
#endif
v_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;
#ifdef GLOBE_POLES
vec3 up_vector=globe_derived_up_vector;
#else
vec3 up_vector=elevationVector(tile_pos);
#endif
float height=elevation(tile_pos);globe_pos+=up_vector*height;
#ifndef GLOBE_POLES
globe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;
#endif
#ifdef GLOBE_POLES
vec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);
#else
vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);
#endif
gl_Position=u_proj_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
}`), globeAtmosphere: Oi(`#include "_prelude_fog.fragment.glsl"
uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;
#ifdef PROJECTION_GLOBE_VIEW
globe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {
#ifdef ALPHA_PASS
glFragColor=vec4(0,0,0,0);return;
#else
#ifdef NATIVE
glFragColor=vec4(1,1,1,1);
#else
glFragColor=vec4(0,0,0,1);
#endif
return;
#endif
}
#endif
highp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?
0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;
#ifdef PROJECTION_GLOBE_VIEW
highp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?
PI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);
#else
horizon_angle=horizon_angle_mercator;
#endif
horizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;
#ifdef ALPHA_PASS
float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);
#else
vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);
#endif
}`, `in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(
mix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}`), model: Oi(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;
#endif
#ifdef OCCLUSION_TEXTURE_TRANSFORM
uniform vec4 u_occlusionTextureTransform;
#endif
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#ifdef HAS_ATTRIBUTE_a_pbr
in lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;
#endif
#ifdef HAS_TEXTURE_u_baseColorTexture
uniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;
#endif
#ifdef HAS_TEXTURE_u_metallicRoughnessTexture
uniform sampler2D u_metallicRoughnessTexture;
#endif
#ifdef HAS_TEXTURE_u_occlusionTexture
uniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;
#endif
#ifdef HAS_TEXTURE_u_normalTexture
uniform sampler2D u_normalTexture;
#endif
#ifdef HAS_TEXTURE_u_emissionTexture
uniform sampler2D u_emissionTexture;
#endif
#ifdef APPLY_LUT_ON_GPU
uniform highp sampler3D u_lutTexture;
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
in highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;
#ifdef DEPTH_D24
highp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}
#else
highp float unpack_depth_rgba(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depthTexture,coord).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));
#endif
return v_depth > depth+0.0005;}
#endif
#define saturate(_x) clamp(_x,0.,1.)
vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)
{
#ifdef LIGHTING_3D_MODE
vec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));
#endif
return apply_lighting(albedo,transformed_normal,lighting_factor);
#else
vec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;
#endif
}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;
#ifdef HAS_ATTRIBUTE_a_color_3f
albedo*=vec4(color_3f,1.0);
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#else
#ifdef HAS_ATTRIBUTE_a_color_4f
albedo*=color_4f;
#endif
#endif
#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)
vec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}
#ifdef UNPREMULT_TEXTURE_IN_SHADER
if(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;
#endif
if(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}
#endif
vec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);
#ifdef APPLY_LUT_ON_GPU
color=applyLUT(u_lutTexture,color);
#endif
return color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {
#ifdef HAS_TEXTURE_u_normalTexture
highp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;
#else
return mat3(1.0);
#endif
}highp vec3 getNormal(){highp vec3 n;
#ifdef HAS_ATTRIBUTE_a_normal_3f
n=normalize(normal_3f);
#else
highp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;
#endif
#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
vec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);
#endif
return n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;
#ifdef HAS_ATTRIBUTE_a_pbr
mat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;
#endif
#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) 
vec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;
#endif
const float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)
{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)
{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)
{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)
{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)
{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)
{
#ifdef LIGHTING_3D_MODE
return mat.diffuseColor;
#else
return mat.diffuseColor/PI;
#endif
}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)
{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)
{vec3 env_light=vec3(0.65,0.65,0.65);
#ifdef LIGHTING_3D_MODE
float ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;
#endif
vec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)
{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=NdotL;
#endif
vec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;
#if !defined(LIGHTING_3D_MODE)
const vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);
#endif
color*=intensityFactor;return color;}void main() {
#ifdef TERRAIN_FRAGMENT_OCCLUSION
if (isOccluded()) {discard;}
#endif
vec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;
#ifdef LIGHTING_3D_MODE
lightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;
#endif
vec4 finalColor;
#ifdef DIFFUSE_SHADED
vec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);
#ifdef HAS_TEXTURE_u_occlusionTexture
float ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;
#endif
finalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;
#else
Material mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;
#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
#ifdef OCCLUSION_TEXTURE_TRANSFORM
vec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;
#else
vec2 uv=uv_2f;
#endif
ao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;
#endif
vec4 emissive=u_emissiveFactor;
#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
emissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);
#endif
#ifdef APPLY_LUT_ON_GPU
float emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;
#endif
color+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;
#ifdef HAS_ATTRIBUTE_a_pbr
float resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;
#ifdef APPLY_LUT_ON_GPU
color_mix=applyLUT(u_lutTexture,color_mix);
#endif
color=mix(color,color_mix,min(1.0,resEmission));
#ifdef HAS_ATTRIBUTE_a_color_4f
float distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);
#endif
#endif
vec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);
#endif
#ifdef FOG
finalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));
#endif
#ifdef RENDER_CUTOFF
finalColor*=v_cutoff_opacity;
#endif
#ifdef INDICATOR_CUTOUT
finalColor=applyCutout(finalColor,v_position_height.w);
#endif
glFragColor=finalColor;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec3 a_pos_3f;
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr
#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength
uniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_normal_matrix;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;
#endif
out vec4 v_position_height;out lowp vec4 v_color_mix;
#ifdef TERRAIN_FRAGMENT_OCCLUSION
out highp float v_depth;
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
out lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;
#endif
vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute-custom highp vec4 pbr
#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength
highp mat4 normal_matrix;
#ifdef INSTANCED_ARRAYS
normal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
normal_matrix=u_normal_matrix;
#endif
vec3 local_pos;mat3 rs;
#ifdef MODEL_POSITION_ON_GPU
vec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;
#else
local_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);
#endif
v_position_height.w=a_pos_3f.z;
#ifdef HAS_ATTRIBUTE_a_pbr
vec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;
#endif
#ifdef FOG
v_fog_pos=fog_position(local_pos);
#endif
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
float x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);
#else
normal_3f=vec3(normal_matrix*vec4(normal_3f,0));
#endif
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#ifdef HAS_ATTRIBUTE_a_color_4f
v_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);
#endif
#endif
#ifdef RENDER_SHADOWS
vec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);
#ifdef NORMAL_OFFSET
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
vec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#else
vec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#endif
#endif
#endif
v_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;
#endif
}`), modelDepth: Oi(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;
#ifdef MODEL_POSITION_ON_GPU
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_instance;
#endif
uniform highp mat4 u_node_matrix;
#endif
void main() {
#ifdef MODEL_POSITION_ON_GPU
highp mat4 instance;
#ifdef INSTANCED_ARRAYS
instance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
instance=u_instance;
#endif
vec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);
#else
gl_Position=u_matrix*vec4(a_pos_3f,1);
#endif
v_depth=gl_Position.z/gl_Position.w;}`), stars: Oi(`in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)
{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}`, `
in vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}`), snowParticle: Oi("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; 
uniform float u_horizontalOscillationRate; 
uniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}`), rainParticle: Oi("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity; 
uniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; 
pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}`), vignette: Oi("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"), occlusion: Oi("uniform vec4 u_color;void main() {glFragColor=u_color;}", `#include "_prelude_terrain.vertex.glsl"
in highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;
#ifdef TERRAIN
float e=elevation(world_pos.xy);world_pos.z+=e;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}`) };
        function $s(l, t) {
          const n = l.replace(/\s*\/\/[^\n]*\n/g, `
`).split(`
`);
          for (let u of n) if (u = u.trim(), u[0] === "#" && u.includes("if") && !u.includes("endif")) {
            u = u.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const d = u.split(" ");
            for (const _ of d) t.includes(_) || t.push(_);
          }
        }
        function Oi(l, t) {
          const n = /#include\s+"([^"]+)"/g, u = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
          let d = t.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
          d && (d = d.map((X) => {
            const K = X.split(" ");
            return K[K.length - 1];
          }), d = [...new Set(d)]);
          const _ = {}, v = [], L = [];
          if (l = l.replace(n, (X, K) => (L.push(K), "")), (t = t.replace(n, (X, K) => (v.push(K), ""))).includes("flat out")) return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
          let G = [...es];
          $s(l, G), $s(t, G);
          for (const X of [...v, ...L]) Sl[X] || console.error(`Undefined include: ${X}`), pu[X] || (pu[X] = [], $s(Sl[X], pu[X])), G = [...G, ...pu[X]];
          return { fragmentSource: l = l.replace(u, (X, K, ae, oe, pe) => (_[pe] = !0, K === "define" ? `
#ifndef HAS_UNIFORM_u_${pe}
in ${ae} ${oe} ${pe};
#else
uniform ${ae} ${oe} u_${pe};
#endif
` : K === "initialize" ? `
#ifdef HAS_UNIFORM_u_${pe}
    ${ae} ${oe} ${pe} = u_${pe};
#endif
` : K === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${pe}
    in ${ae} ${oe} ${pe};
#endif
` : K === "initialize-attribute" ? "" : void 0)), vertexSource: t = t.replace(u, (X, K, ae, oe, pe) => {
            const Be = oe === "float" ? "vec2" : oe, Re = pe.match(/color/) ? "color" : Be;
            return K === "define-attribute-vertex-shader-only" ? `
#ifdef HAS_ATTRIBUTE_a_${pe}
in ${ae} ${oe} a_${pe};
#endif
` : _[pe] ? K === "define" ? `
#ifndef HAS_UNIFORM_u_${pe}
uniform lowp float u_${pe}_t;
in ${ae} ${Be} a_${pe};
out ${ae} ${oe} ${pe};
#else
uniform ${ae} ${oe} u_${pe};
#endif
` : K === "initialize" ? Re === "vec4" ? `
#ifndef HAS_UNIFORM_u_${pe}
    ${pe} = a_${pe};
#else
    ${ae} ${oe} ${pe} = u_${pe};
#endif
` : `
#ifndef HAS_UNIFORM_u_${pe}
    ${pe} = unpack_mix_${Re}(a_${pe}, u_${pe}_t);
#else
    ${ae} ${oe} ${pe} = u_${pe};
#endif
` : K === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${pe}
    in ${ae} ${oe} a_${pe};
    out ${ae} ${oe} ${pe};
#endif
` : K === "initialize-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${pe}
    ${pe} = a_${pe};
#endif
` : void 0 : K === "define" ? `
#ifndef HAS_UNIFORM_u_${pe}
uniform lowp float u_${pe}_t;
in ${ae} ${Be} a_${pe};
#else
uniform ${ae} ${oe} u_${pe};
#endif
` : K === "define-instanced" ? Re === "mat4" ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${pe}0;
in vec4 a_${pe}1;
in vec4 a_${pe}2;
in vec4 a_${pe}3;
#else
uniform ${ae} ${oe} u_${pe};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${ae} ${Be} a_${pe};
#else
uniform ${ae} ${oe} u_${pe};
#endif
` : K === "initialize-attribute-custom" ? `
#ifdef HAS_ATTRIBUTE_a_${pe}
    ${ae} ${oe} ${pe} = a_${pe};
#endif
` : Re === "vec4" ? `
#ifndef HAS_UNIFORM_u_${pe}
    ${ae} ${oe} ${pe} = a_${pe};
#else
    ${ae} ${oe} ${pe} = u_${pe};
#endif
` : `
#ifndef HAS_UNIFORM_u_${pe}
    ${ae} ${oe} ${pe} = unpack_mix_${Re}(a_${pe}, u_${pe}_t);
#else
    ${ae} ${oe} ${pe} = u_${pe};
#endif
`;
          }), staticAttributes: d, usedDefines: G, vertexIncludes: v, fragmentIncludes: L };
        }
        class Nc {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
          }
          bind(t, n, u, d, _, v, L, G) {
            this.context = t;
            let X = this.boundPaintVertexBuffers.length !== d.length;
            for (let ae = 0; !X && ae < d.length; ae++) this.boundPaintVertexBuffers[ae] !== d[ae] && (X = !0);
            let K = this.boundDynamicVertexBuffers.length !== L.length;
            for (let ae = 0; !K && ae < L.length; ae++) this.boundDynamicVertexBuffers[ae] !== L[ae] && (K = !0);
            if (!this.vao || this.boundProgram !== n || this.boundLayoutVertexBuffer !== u || X || K || this.boundIndexBuffer !== _ || this.boundVertexOffset !== v) this.freshBind(n, u, d, _, v, L, G);
            else {
              t.bindVertexArrayOES.set(this.vao);
              for (const ae of L) ae && (ae.bind(), G && ae.instanceCount && ae.setVertexAttribDivisor(t.gl, n, G));
              _ && _.dynamicDraw && _.bind();
            }
          }
          freshBind(t, n, u, d, _, v, L) {
            const G = t.numAttributes, X = this.context, K = X.gl;
            this.vao && this.destroy(), this.vao = X.gl.createVertexArray(), X.bindVertexArrayOES.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = n, this.boundPaintVertexBuffers = u, this.boundIndexBuffer = d, this.boundVertexOffset = _, this.boundDynamicVertexBuffers = v, n.enableAttributes(K, t), n.bind(), n.setVertexAttribPointers(K, t, _);
            for (const ae of u) ae.enableAttributes(K, t), ae.bind(), ae.setVertexAttribPointers(K, t, _);
            for (const ae of v) ae && (ae.enableAttributes(K, t), ae.bind(), ae.setVertexAttribPointers(K, t, _), L && ae.instanceCount && ae.setVertexAttribDivisor(K, t, L));
            d && d.bind(), X.currentNumAttributes = G;
          }
          destroy() {
            this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        function Xs(l, t) {
          const n = Math.pow(2, t.canonical.z), u = t.canonical.y;
          return [new r.aa(0, u / n).toLngLat().lat, new r.aa(0, (u + 1) / n).toLngLat().lat];
        }
        function wf(l, t, n, u, d, _, v) {
          const L = l.context, G = L.gl, X = n.hillshadeFBO;
          if (!X) return;
          l.prepareDrawTile();
          const K = l.isTileAffectedByFog(t), ae = l.getOrCreateProgram("hillshade", { overrideFog: K });
          L.activeTexture.set(G.TEXTURE0), G.bindTexture(G.TEXTURE_2D, X.colorAttachment.get());
          const oe = ((Ge, Ve, et, ut) => {
            const st = et.paint.get("hillshade-shadow-color"), xt = et.paint.get("hillshade-shadow-color-use-theme").constantOr("default") === "none", mt = et.paint.get("hillshade-highlight-color"), _t = et.paint.get("hillshade-highlight-color-use-theme").constantOr("default") === "none", dt = et.paint.get("hillshade-accent-color"), gt = et.paint.get("hillshade-accent-color-use-theme").constantOr("default") === "none", Rt = et.paint.get("hillshade-emissive-strength");
            let Jt = r.ai(et.paint.get("hillshade-illumination-direction"));
            if (et.paint.get("hillshade-illumination-anchor") === "viewport") Jt -= Ge.transform.angle;
            else if (Ge.style && Ge.style.enable3dLights() && Ge.style.directionalLight) {
              const or = Ge.style.directionalLight.properties.get("direction"), sr = r.cb(or.x, or.y, or.z);
              Jt = r.ai(sr[1]);
            }
            const Vt = !Ge.options.moving;
            return { u_matrix: ut || Ge.transform.calculateProjMatrix(Ve.tileID.toUnwrapped(), Vt), u_image: 0, u_latrange: Xs(0, Ve.tileID), u_light: [et.paint.get("hillshade-exaggeration"), Jt], u_shadow: st.toRenderColor(xt ? null : et.lut), u_highlight: mt.toRenderColor(_t ? null : et.lut), u_emissive_strength: Rt, u_accent: dt.toRenderColor(gt ? null : et.lut) };
          })(l, n, u, l.terrain ? t.projMatrix : null);
          l.uploadCommonUniforms(L, ae, t.toUnwrapped());
          const { tileBoundsBuffer: pe, tileBoundsIndexBuffer: Be, tileBoundsSegments: Re } = l.getTileBoundsBuffers(n);
          ae.draw(l, G.TRIANGLES, d, _, v, vi.disabled, oe, u.id, pe, Be, Re);
        }
        function Ef(l, t, n) {
          if (!t.needsDEMTextureUpload) return;
          const u = l.context, d = u.gl;
          u.pixelStoreUnpackPremultiplyAlpha.set(!1), t.demTexture = t.demTexture || l.getTileTexture(n.stride);
          const _ = n.getPixels();
          t.demTexture ? t.demTexture.update(_, { premultiply: !1 }) : t.demTexture = new r.T(u, _, d.R32F, { premultiply: !1 }), t.needsDEMTextureUpload = !1;
        }
        function rc(l, t, n) {
          const u = l.context, d = u.gl;
          if (!t.dem) return;
          const _ = t.dem;
          if (u.activeTexture.set(d.TEXTURE1), Ef(l, t, _), !t.demTexture) return;
          t.demTexture.bind(d.NEAREST, d.CLAMP_TO_EDGE);
          const v = _.dim;
          u.activeTexture.set(d.TEXTURE0);
          let L = t.hillshadeFBO;
          if (!L) {
            const oe = new r.T(u, { width: v, height: v, data: null }, d.RGBA8);
            oe.bind(d.LINEAR, d.CLAMP_TO_EDGE), L = t.hillshadeFBO = u.createFramebuffer(v, v, !0, "renderbuffer"), L.colorAttachment.set(oe.texture);
          }
          u.bindFramebuffer.set(L.framebuffer), u.viewport.set([0, 0, v, v]);
          const { tileBoundsBuffer: G, tileBoundsIndexBuffer: X, tileBoundsSegments: K } = l.getMercatorTileBoundsBuffers(), ae = [];
          l.linearFloatFilteringSupported() && ae.push("TERRAIN_DEM_FLOAT_FORMAT"), l.getOrCreateProgram("hillshadePrepare", { defines: ae }).draw(l, d.TRIANGLES, ui.disabled, _i.disabled, zi.unblended, vi.disabled, ((oe, pe) => {
            const Be = pe.stride, Re = r.ab.mat4.create();
            return r.ab.mat4.ortho(Re, 0, r.ag, -r.ag, 0, 0, 1), r.ab.mat4.translate(Re, Re, [0, -r.ag, 0]), { u_matrix: Re, u_image: 1, u_dimension: [Be, Be], u_zoom: oe.overscaledZ };
          })(t.tileID, _), n.id, G, X, K), t.needsHillshadePrepare = !1;
        }
        class yn {
          constructor(t) {
            this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(t) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Uc extends yn {
          getDefault() {
            return r.aj.transparent;
          }
          set(t) {
            const n = this.current;
            (t.r !== n.r || t.g !== n.g || t.b !== n.b || t.a !== n.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
          }
        }
        class jc extends yn {
          getDefault() {
            return 1;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);
          }
        }
        class Ln extends yn {
          getDefault() {
            return 0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);
          }
        }
        class ic extends yn {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(t) {
            const n = this.current;
            (t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || t[3] !== n[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
          }
        }
        class nc extends yn {
          getDefault() {
            return !0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);
          }
        }
        class _u extends yn {
          getDefault() {
            return 255;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);
          }
        }
        class Sf extends yn {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t) {
            const n = this.current;
            (t.func !== n.func || t.ref !== n.ref || t.mask !== n.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);
          }
        }
        class Ml extends yn {
          getDefault() {
            const t = this.gl;
            return [t.KEEP, t.KEEP, t.KEEP];
          }
          set(t) {
            const n = this.current;
            (t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);
          }
        }
        class ws extends yn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            t ? n.enable(n.STENCIL_TEST) : n.disable(n.STENCIL_TEST), this.current = t, this.dirty = !1;
          }
        }
        class ac extends yn {
          getDefault() {
            return [0, 1];
          }
          set(t) {
            const n = this.current;
            (t[0] !== n[0] || t[1] !== n[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);
          }
        }
        class _a extends yn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            t ? n.enable(n.DEPTH_TEST) : n.disable(n.DEPTH_TEST), this.current = t, this.dirty = !1;
          }
        }
        class Vc extends yn {
          getDefault() {
            return this.gl.LESS;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);
          }
        }
        class Gc extends yn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            t ? n.enable(n.BLEND) : n.disable(n.BLEND), this.current = t, this.dirty = !1;
          }
        }
        class Hc extends yn {
          getDefault() {
            const t = this.gl;
            return [t.ONE, t.ZERO, t.ONE, t.ZERO];
          }
          set(t) {
            const n = this.current;
            (t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || t[3] !== n[3] || this.dirty) && (this.gl.blendFuncSeparate(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
          }
        }
        class Wc extends yn {
          getDefault() {
            return r.aj.transparent;
          }
          set(t) {
            const n = this.current;
            (t.r !== n.r || t.g !== n.g || t.b !== n.b || t.a !== n.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
          }
        }
        class gu extends yn {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.blendEquationSeparate(t, t), this.current = t, this.dirty = !1);
          }
        }
        class Al extends yn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            t ? n.enable(n.CULL_FACE) : n.disable(n.CULL_FACE), this.current = t, this.dirty = !1;
          }
        }
        class oc extends yn {
          getDefault() {
            return this.gl.BACK;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);
          }
        }
        class sc extends yn {
          getDefault() {
            return this.gl.CCW;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);
          }
        }
        let yu = class extends yn {
          getDefault() {
            return null;
          }
          set(l) {
            (l !== this.current || this.dirty) && (this.gl.useProgram(l), this.current = l, this.dirty = !1);
          }
        };
        class Zc extends yn {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);
          }
        }
        class Tf extends yn {
          getDefault() {
            const t = this.gl;
            return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
          }
          set(t) {
            const n = this.current;
            (t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || t[3] !== n[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
          }
        }
        class Il extends yn {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindFramebuffer(n.FRAMEBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class fd extends yn {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindRenderbuffer(n.RENDERBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class dd extends yn {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindTexture(n.TEXTURE_2D, t), this.current = t, this.dirty = !1;
          }
        }
        class Bh extends yn {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindBuffer(n.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class Ys extends yn {
          getDefault() {
            return null;
          }
          set(t) {
            const n = this.gl;
            n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class Mf extends yn {
          getDefault() {
            return null;
          }
          set(t) {
            this.gl && (t !== this.current || this.dirty) && (this.gl.bindVertexArray(t), this.current = t, this.dirty = !1);
          }
        }
        class vu extends yn {
          getDefault() {
            return 4;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;
          }
        }
        class Mo extends yn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;
          }
        }
        class Cl extends yn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;
          }
        }
        class Ao extends yn {
          constructor(t, n) {
            super(t), this.context = t, this.parent = n;
          }
          getDefault() {
            return null;
          }
        }
        class Ks extends Ao {
          setDirty() {
            this.dirty = !0;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
          }
        }
        class Fh extends Ao {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferRenderbuffer(n.FRAMEBUFFER, this.attachment(), n.RENDERBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class Af extends Ao {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferTexture2D(n.FRAMEBUFFER, this.attachment(), n.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
          }
        }
        class Js extends Fh {
          attachment() {
            return this.gl.DEPTH_STENCIL_ATTACHMENT;
          }
        }
        const Pl = (l, t, n) => ({ u_matrix: l, u_image0: 0, u_skirt_height: t, u_ground_shadow_factor: n }), fo = (l, t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re) => ({ u_proj_matrix: Float32Array.from(l), u_globe_matrix: t, u_normalize_matrix: Float32Array.from(u), u_merc_matrix: n, u_zoom_transition: d, u_merc_center: _, u_image0: 0, u_frustum_tl: v, u_frustum_tr: L, u_frustum_br: G, u_frustum_bl: X, u_globe_pos: K, u_globe_radius: ae, u_viewport: oe, u_grid_matrix: Re ? Float32Array.from(Re) : new Float32Array(9), u_skirt_height: pe, u_far_z_cutoff: Be });
        function xu(l, t) {
          return l != null && t != null && !(!l.hasData() || !t.hasData()) && l.demTexture != null && t.demTexture != null && l.tileID.key !== t.tileID.key;
        }
        const Na = new class {
          constructor() {
            this.operations = {};
          }
          newMorphing(l, t, n, u, d) {
            if (l in this.operations) {
              const _ = this.operations[l];
              _.to.tileID.key !== n.tileID.key && (_.queued = n);
            } else this.operations[l] = { startTime: u, phase: 0, duration: d, from: t, to: n, queued: null };
          }
          getMorphValuesForProxy(l) {
            if (!(l in this.operations)) return null;
            const t = this.operations[l];
            return { from: t.from, to: t.to, phase: t.phase };
          }
          update(l) {
            for (const t in this.operations) {
              const n = this.operations[t];
              for (n.phase = (l - n.startTime) / n.duration; n.phase >= 1 || !this._validOp(n); ) if (!this._nextOp(n, l)) {
                delete this.operations[t];
                break;
              }
            }
          }
          _nextOp(l, t) {
            return !!l.queued && (l.from = l.to, l.to = l.queued, l.queued = null, l.phase = 0, l.startTime = t, !0);
          }
          _validOp(l) {
            return l.from.hasData() && l.to.hasData();
          }
        }(), Es = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
        function Io(l, t, n) {
          if (t === 0) return 0;
          const u = t < 1 && n === 514 ? 0.25 / t : 1;
          return 6 * Math.pow(1.5, 22 - l) * Math.max(t, 1) * u;
        }
        function Bn(l, t) {
          const n = 1 << l.z;
          return !t && (l.x === 0 || l.x === n - 1) || l.y === 0 || l.y === n - 1;
        }
        const Tn = (l) => ({ u_matrix: l });
        function Co(l, t, n, u, d) {
          if (d > 0) {
            const _ = r.q.now(), v = (_ - l.timeAdded) / d, L = t ? (_ - t.timeAdded) / d : -1, G = n.getSource(), X = u.coveringZoomLevel({ tileSize: G.tileSize, roundZoom: G.roundZoom }), K = !t || Math.abs(t.tileID.overscaledZ - X) > Math.abs(l.tileID.overscaledZ - X), ae = K && l.refreshedUponExpiration ? 1 : r.aw(K ? v : 1 - L, 0, 1);
            return l.refreshedUponExpiration && v >= 1 && (l.refreshedUponExpiration = !1), t ? { opacity: 1, mix: 1 - ae } : { opacity: ae, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        class ba extends Xa {
          constructor(t) {
            const n = { type: "raster-dem", maxzoom: t.transform.maxZoom }, u = new r.D(r.ci(), null), d = Pa("mock-dem", n, u, t.style);
            super("mock-dem", d, !1), d.setEventedParent(this), this._sourceLoaded = !0;
          }
          _loadTile(t, n) {
            t.state = "loaded", n(null);
          }
        }
        class Ja extends Xa {
          constructor(t) {
            const n = Pa("proxy", { type: "geojson", maxzoom: t.transform.maxZoom }, new r.D(r.ci(), null), t.style);
            super("proxy", n, !1), n.setEventedParent(this), this.map = this.getSource().map = t, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
          update(t, n, u) {
            if (t.freezeTileCoverage) return;
            this.transform = t;
            const d = t.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((_, v) => {
              if (_[v.key] = "", !this._tiles[v.key]) {
                const L = new Zo(v, this._source.tileSize * v.overscaleFactor(), t.tileZoom);
                L.state = "loaded", this._tiles[v.key] = L;
              }
              return _;
            }, {});
            for (const _ in this._tiles) _ in d || (this.freeFBO(_), this._tiles[_].unloadVectorData(), delete this._tiles[_]);
          }
          freeFBO(t) {
            const n = this.proxyCachedFBO[t];
            if (n !== void 0) {
              const u = Object.values(n);
              this.renderCachePool.push(...u), delete this.proxyCachedFBO[t];
            }
          }
          deallocRenderCache() {
            this.renderCache.forEach((t) => t.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
        }
        class Ss extends r.aG {
          constructor(t, n, u) {
            super(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y), this.proxyTileKey = n, this.projMatrix = u;
          }
        }
        class Bo extends r.cJ {
          constructor(t, n) {
            super(), this._debugParams = { sortTilesHiZFirst: !0, disableRenderCache: !1 }, t.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
              this._style.map.triggerRepaint();
            }), t.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
              this._style.map.triggerRepaint();
            }), t.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
              this.invalidateRenderCache = !0, this._style.map.triggerRepaint();
            }), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
            const [u, d, _] = function(G) {
              const X = new r.b4(), K = new r.aU(), ae = 131;
              X.reserve(17161), K.reserve(33800);
              const oe = r.ag / 128, pe = r.ag + oe / 2, Be = pe + oe;
              for (let Ge = -oe; Ge < Be; Ge += oe) for (let Ve = -oe; Ve < Be; Ve += oe) {
                const et = Ve < 0 || Ve > pe || Ge < 0 || Ge > pe ? 24575 : 0, ut = r.aw(Math.round(Ve), 0, r.ag), st = r.aw(Math.round(Ge), 0, r.ag);
                X.emplaceBack(ut + et, st);
              }
              const Re = (Ge, Ve) => {
                const et = Ve * ae + Ge;
                K.emplaceBack(et + 1, et, et + ae), K.emplaceBack(et + ae, et + ae + 1, et + 1);
              };
              for (let Ge = 1; Ge < 129; Ge++) for (let Ve = 1; Ve < 129; Ve++) Re(Ve, Ge);
              return [0, 129].forEach((Ge) => {
                for (let Ve = 0; Ve < 130; Ve++) Re(Ve, Ge), Re(Ge, Ve);
              }), [X, K, 32768];
            }(), v = t.context;
            this.gridBuffer = v.createVertexBuffer(u, r.b6.members), this.gridIndexBuffer = v.createIndexBuffer(d), this.gridSegments = r.b7.simpleSegment(0, 0, u.length, d.length), this.gridNoSkirtSegments = r.b7.simpleSegment(0, 0, u.length, _), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Ja(n.map), this.orthoMatrix = r.ab.mat4.create(), r.ab.mat4.ortho(this.orthoMatrix, this.painter.transform.projection.name === "globe" ? 0.015 : 0, r.ag, 0, r.ag, 0, 1);
            const L = v.gl;
            this._overlapStencilMode = new _i({ func: L.GEQUAL, mask: 255 }, 0, 255, L.KEEP, L.KEEP, L.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = n, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new ba(n.map), this._pendingGroundEffectLayers = [];
          }
          set style(t) {
            t.on("data", this._onStyleDataEvent.bind(this)), this._style = t, this._style.map.on("moveend", () => {
              this._clearLineLayersFromRenderCache();
            });
          }
          update(t, n, u) {
            if (t && t.terrain) {
              this._style !== t && (this.style = t, this._evaluationZoom = void 0);
              const d = t.terrain.properties, _ = t.terrain.drapeRenderMode === 0, v = t.terrain.isZoomDependent();
              this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = r.q.now();
              const L = t.terrain && t.terrain.scope, G = d.get("source"), X = _ ? this._mockSourceCache : t.getSourceCache(G, L);
              if (!X) return void r.w(`Couldn't find terrain source "${G}".`);
              if (this.sourceCache = X, this._attenuationRange = t.terrain.getAttenuationRange(), this._exaggeration = v ? this.calculateExaggeration(n) : d.get("exaggeration"), !n.projection.requiresDraping && v && this._exaggeration === 0) return void this._disable();
              this.enabled = !0;
              const K = () => {
                this.sourceCache.used && r.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                const ae = this.getScaledDemTileSize();
                this.sourceCache.update(n, ae, !0), this.resetTileLookupCache(this.sourceCache.id);
              };
              this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, K(), this._initializing = !0), K(), n.updateElevation(!0, u), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(n), this._emptyDEMTextureDirty = !0, this._previousZoom = n.zoom;
            } else this._disable();
          }
          calculateExaggeration(t) {
            if (this._attenuationRange && t.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t.zoom);
            const n = this._previousCameraAltitude, u = t.getFreeCameraOptions().position.z / t.pixelsPerMeter * t.worldSize;
            this._previousCameraAltitude = u;
            const d = n != null ? u - n : Number.MAX_VALUE;
            if (Math.abs(d) < 2) return this._exaggeration;
            const _ = t.zoom, v = this._style.terrain;
            if (!this._previousUpdateTimestamp) return v.getExaggeration(_);
            let L = _ - this._previousZoom;
            const G = this._previousUpdateTimestamp;
            let X = _;
            this._evaluationZoom != null && (X = this._evaluationZoom, Math.abs(_ - X) > 0.5 && (L = 0.5 * (_ - X + L)), L * d < 0 && (X += L)), this._evaluationZoom = X;
            const K = v.getExaggeration(X), ae = K === v.getExaggeration(Math.max(0, X - 0.1));
            if (ae && Math.abs(K - this._exaggeration) < 0.01) return K;
            let oe = Math.min(0.1, 375e-5 * (this._updateTimestamp - G));
            return (ae || K < 0.1 || Math.abs(L) < 1e-4) && (oe = Math.min(0.2, 4 * oe)), r.af(this._exaggeration, K, oe);
          }
          resetTileLookupCache(t) {
            this._findCoveringTileCache[t] = {};
          }
          attenuationRange() {
            return this._attenuationRange;
          }
          getDemUpscale() {
            return this.proxySourceCache.getSource().tileSize / 128;
          }
          getScaledDemTileSize() {
            return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
          }
          _onStyleDataEvent(t) {
            t.coord && t.dataType === "source" ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord) : t.dataType === "style" && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
          }
          _disable() {
            if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const t in this._style._mergedSourceCaches) this._style._mergedSourceCaches[t].usedForTerrain = !1;
          }
          destroy() {
            this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((t) => t.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
          }
          _source() {
            return this.enabled ? this.sourceCache : null;
          }
          isUsingMockSource() {
            return this.sourceCache === this._mockSourceCache;
          }
          exaggeration() {
            return this.enabled ? this._exaggeration : 0;
          }
          get visibleDemTiles() {
            return this._visibleDemTiles;
          }
          get drapeBufferSize() {
            const t = 2 * this.proxySourceCache.getSource().tileSize;
            return [t, t];
          }
          set useVertexMorphing(t) {
            this._useVertexMorphing = t;
          }
          updateTileBinding(t) {
            if (!this.enabled) return;
            this.prevTerrainTileForTile = this.terrainTileForTile;
            const n = this.proxySourceCache, u = this.painter.transform;
            this._initializing && (this._initializing = u._centerAltitude === 0 && this.getAtPointOrZero(r.aa.fromLngLat(u.center), -1) === -1, this._emptyDEMTextureDirty = !this._initializing);
            const d = this.proxyCoords = n.getIds().map((G) => {
              const X = n.getTileByID(G).tileID;
              return X.projMatrix = u.calculateProjMatrix(X.toUnwrapped()), X;
            });
            (function(G, X) {
              const K = X.transform.pointCoordinate(X.transform.getCameraPoint()), ae = new r.P(K.x, K.y);
              G.sort((oe, pe) => {
                if (pe.overscaledZ - oe.overscaledZ) return pe.overscaledZ - oe.overscaledZ;
                const Be = new r.P(oe.canonical.x + (1 << oe.canonical.z) * oe.wrap, oe.canonical.y), Re = new r.P(pe.canonical.x + (1 << pe.canonical.z) * pe.wrap, pe.canonical.y), Ge = ae.mult(1 << oe.canonical.z);
                return Ge.x -= 0.5, Ge.y -= 0.5, Ge.distSqr(Be) - Ge.distSqr(Re);
              });
            })(d, this.painter);
            const _ = this.proxyToSource || {};
            this.proxyToSource = {}, d.forEach((G) => {
              this.proxyToSource[G.key] = {};
            }), this.terrainTileForTile = {};
            const v = this._style._mergedSourceCaches;
            for (const G in v) {
              const X = v[G];
              if (!X.used || (X !== this.sourceCache && this.resetTileLookupCache(X.id), this._setupProxiedCoordsForOrtho(X, t[G], _), X.usedForTerrain)) continue;
              const K = t[G];
              X.getSource().reparseOverscaled && this._assignTerrainTiles(K);
            }
            this.proxiedCoords[n.id] = d.map((G) => new Ss(G, G.key, this.orthoMatrix)), this._assignTerrainTiles(d), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(_), this.renderingToTexture = !1;
            const L = {};
            this._visibleDemTiles = [];
            for (const G of this.proxyCoords) {
              const X = this.terrainTileForTile[G.key];
              if (!X) continue;
              const K = X.tileID.key;
              K in L || (this._visibleDemTiles.push(X), L[K] = K);
            }
          }
          _assignTerrainTiles(t) {
            this._initializing || t.forEach((n) => {
              if (this.terrainTileForTile[n.key]) return;
              const u = this._findTileCoveringTileID(n, this.sourceCache);
              u && (this.terrainTileForTile[n.key] = u);
            });
          }
          _prepareDEMTextures() {
            const t = this.painter.context, n = t.gl;
            for (const u in this.terrainTileForTile) {
              const d = this.terrainTileForTile[u], _ = d.dem;
              !_ || d.demTexture && !d.needsDEMTextureUpload || (t.activeTexture.set(n.TEXTURE1), Ef(this.painter, d, _));
            }
          }
          _prepareDemTileUniforms(t, n, u, d) {
            if (!n || n.demTexture == null) return !1;
            const _ = t.tileID.canonical, v = Math.pow(2, n.tileID.canonical.z - _.z), L = d || "";
            return u[`u_dem_tl${L}`] = [_.x * v % 1, _.y * v % 1], u[`u_dem_scale${L}`] = v, !0;
          }
          get emptyDEMTexture() {
            return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
          }
          _getLoadedAreaMinimum() {
            if (!this.enabled) return 0;
            let t = 0;
            const n = this._visibleDemTiles.reduce((u, d) => {
              if (!d.dem) return u;
              const _ = d.dem.tree.minimums[0];
              return _ > 0 && t++, u + _;
            }, 0);
            return t ? n / t : 0;
          }
          _updateEmptyDEMTexture() {
            const t = this.painter.context, n = t.gl;
            t.activeTexture.set(n.TEXTURE2);
            const u = this._getLoadedAreaMinimum(), d = new r.cK({ width: 1, height: 1 }, new Float32Array([u]));
            this._emptyDEMTextureDirty = !1;
            let _ = this._emptyDEMTexture;
            return _ ? _.update(d, { premultiply: !1 }) : _ = this._emptyDEMTexture = new r.T(t, d, n.R32F, { premultiply: !1 }), _;
          }
          setupElevationDraw(t, n, u) {
            const d = this.painter.context, _ = d.gl, v = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 };
            v.u_exaggeration = this.exaggeration();
            let L = null, G = null, X = 1;
            if (u && u.morphing && this._useVertexMorphing) {
              const pe = u.morphing.srcDemTile, Be = u.morphing.dstDemTile;
              X = u.morphing.phase, pe && Be && (this._prepareDemTileUniforms(t, pe, v, "_prev") && (G = pe), this._prepareDemTileUniforms(t, Be, v) && (L = Be));
            }
            const K = (pe) => pe && pe.demTexture && this.painter.linearFloatFilteringSupported() ? _.LINEAR : _.NEAREST;
            let ae = null;
            var oe;
            if (this.enabled ? G && L ? (ae = L.demTexture, d.activeTexture.set(_.TEXTURE4), G.demTexture.bind(K(G), _.CLAMP_TO_EDGE), v.u_dem_lerp = X) : (L = this.terrainTileForTile[t.tileID.key], ae = this._prepareDemTileUniforms(t, L, v) ? L.demTexture : this.emptyDEMTexture) : ae = this.emptyDEMTexture, d.activeTexture.set(_.TEXTURE2), ae && (v.u_dem_size = (oe = ae).size[0] === 1 ? 1 : oe.size[0] - 2, ae.bind(K(L), _.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(u && u.useDepthForOcclusion, n, v), u && u.useMeterToDem && L) {
              const pe = (1 << L.tileID.canonical.z) * r.bH(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
              v.u_meter_to_dem = pe;
            }
            if (u && u.labelPlaneMatrixInv && (v.u_label_plane_matrix_inv = u.labelPlaneMatrixInv), n.setTerrainUniformValues(d, v), this.painter.transform.projection.name === "globe") {
              const pe = this.globeUniformValues(this.painter.transform, t.tileID.canonical, u && u.useDenormalizedUpVectorScale);
              n.setGlobeUniformValues(d, pe);
            }
          }
          globeUniformValues(t, n, u) {
            const d = t.projection;
            return { u_tile_tl_up: d.upVector(n, 0, 0), u_tile_tr_up: d.upVector(n, r.ag, 0), u_tile_br_up: d.upVector(n, r.ag, r.ag), u_tile_bl_up: d.upVector(n, 0, r.ag), u_tile_up_scale: u ? r.cL(1) : d.upVectorScale(n, t.center.lat, t.worldSize).metersToTile };
          }
          renderToBackBuffer(t) {
            const n = this.painter, u = this.painter.context;
            t.length !== 0 && (u.bindFramebuffer.set(null), u.viewport.set([0, 0, n.width, n.height]), n.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(d, _, v, L, G) {
              if (d.transform.projection.name === "globe") (function(X, K, ae, oe, pe) {
                const Be = X.context, Re = Be.gl;
                let Ge, Ve;
                const et = X.transform, ut = r.cC(X, Be, et), st = (or, sr) => {
                  if (Ve === sr) return;
                  const Bt = [Es[sr], "PROJECTION_GLOBE_VIEW"];
                  ut && Bt.push("CUSTOM_ANTIALIASING");
                  const rr = X.isTileAffectedByFog(or);
                  Ge = X.getOrCreateProgram("globeRaster", { defines: Bt, overrideFog: rr }), Ve = sr;
                }, xt = X.colorModeForRenderPass(), mt = new ui(Re.LEQUAL, ui.ReadWrite, X.depthRangeFor3D);
                Na.update(pe);
                const _t = r.cD(et), dt = [r.at(et.center.lng), r.aA(et.center.lat)], gt = X.globeSharedBuffers, Rt = [et.width * r.q.devicePixelRatio, et.height * r.q.devicePixelRatio], Jt = Float32Array.from(et.globeMatrix), Vt = { useDenormalizedUpVectorScale: !0 };
                {
                  const or = X.transform, sr = Io(or.zoom, K.exaggeration(), K.sourceCache._source.tileSize);
                  Ve = -1;
                  const Bt = Re.TRIANGLES;
                  for (const rr of oe) {
                    const gr = ae.getTile(rr), Ut = _i.disabled, dr = K.prevTerrainTileForTile[rr.key], ir = K.terrainTileForTile[rr.key];
                    xu(dr, ir) && Na.newMorphing(rr.key, dr, ir, pe, 250), Be.activeTexture.set(Re.TEXTURE0), gr.texture && gr.texture.bind(Re.LINEAR, Re.CLAMP_TO_EDGE);
                    const Tr = Na.getMorphValuesForProxy(rr.key), mr = Tr ? 1 : 0;
                    Tr && r.J(Vt, { morphing: { srcDemTile: Tr.from, dstDemTile: Tr.to, phase: r.cB(Tr.phase) } });
                    const hr = r.cE(rr.canonical), br = r.cF(hr.getCenter().lat), Cr = r.cG(rr.canonical, hr, br, or.worldSize / or._pixelsPerMercatorPixel), Hr = r.bb(r.cH(rr.canonical)), Zr = fo(or.expandedFarZProjMatrix, Jt, _t, Hr, r.ae(or.zoom), dt, or.frustumCorners.TL, or.frustumCorners.TR, or.frustumCorners.BR, or.frustumCorners.BL, or.globeCenterInViewSpace, or.globeRadius, Rt, sr, or._farZ, Cr);
                    if (st(rr, mr), Ge && (K.setupElevationDraw(gr, Ge, Vt), X.uploadCommonUniforms(Be, Ge, rr.toUnwrapped()), gt)) {
                      const [mi, ii, oi] = gt.getGridBuffers(br, sr !== 0);
                      Ge.draw(X, Bt, mt, Ut, xt, vi.backCCW, Zr, "globe_raster", mi, ii, oi);
                    }
                  }
                }
                if (gt && (X.renderDefaultNorthPole || X.renderDefaultSouthPole)) {
                  const or = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  ut && or.push("CUSTOM_ANTIALIASING"), Ge = X.getOrCreateProgram("globeRaster", { defines: or });
                  for (const sr of oe) {
                    const { x: Bt, y: rr, z: gr } = sr.canonical, Ut = rr === 0, dr = rr === (1 << gr) - 1, [ir, Tr, mr, hr] = gt.getPoleBuffers(gr, !1);
                    if (hr && (Ut || dr)) {
                      const br = ae.getTile(sr);
                      Be.activeTexture.set(Re.TEXTURE0), br.texture && br.texture.bind(Re.LINEAR, Re.CLAMP_TO_EDGE);
                      let Cr = r.cI(gr, Bt, et);
                      const Hr = r.bb(r.cH(sr.canonical)), Zr = (mi, ii) => mi.draw(X, Re.TRIANGLES, mt, _i.disabled, xt, vi.disabled, fo(et.expandedFarZProjMatrix, Cr, Cr, Hr, 0, dt, et.frustumCorners.TL, et.frustumCorners.TR, et.frustumCorners.BR, et.frustumCorners.BL, et.globeCenterInViewSpace, et.globeRadius, Rt, 0, et._farZ), "globe_pole_raster", ii, mr, hr);
                      K.setupElevationDraw(br, Ge, Vt), X.uploadCommonUniforms(Be, Ge, sr.toUnwrapped()), Ut && X.renderDefaultNorthPole && Zr(Ge, ir), dr && X.renderDefaultSouthPole && (Cr = r.ab.mat4.scale(r.ab.mat4.create(), Cr, [1, -1, 1]), Zr(Ge, Tr));
                    }
                  }
                }
              })(d, _, v, L, G);
              else {
                const X = d.context, K = X.gl;
                let ae, oe;
                const pe = d.shadowRenderer, Be = To(d, d.longestCutoffRange), Re = (xt) => {
                  if (oe === xt) return;
                  const mt = [];
                  mt.push(Es[xt]), Be.shouldRenderCutoff && mt.push("RENDER_CUTOFF"), pe && (mt.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), pe.useNormalOffset && mt.push("NORMAL_OFFSET")), ae = d.getOrCreateProgram("terrainRaster", { defines: mt }), oe = xt;
                }, Ge = d.colorModeForRenderPass(), Ve = new ui(K.LEQUAL, ui.ReadWrite, d.depthRangeFor3D);
                Na.update(G);
                const et = d.transform, ut = Io(et.zoom, _.exaggeration(), _.sourceCache._source.tileSize);
                let st = [0, 0, 0];
                if (pe) {
                  const xt = d.style.directionalLight, mt = d.style.ambientLight;
                  xt && mt && (st = Ku(d.style, xt, mt));
                }
                {
                  oe = -1;
                  const xt = K.TRIANGLES, [mt, _t] = [_.gridIndexBuffer, _.gridSegments];
                  for (const dt of L) {
                    const gt = v.getTile(dt), Rt = _i.disabled, Jt = _.prevTerrainTileForTile[dt.key], Vt = _.terrainTileForTile[dt.key];
                    xu(Jt, Vt) && Na.newMorphing(dt.key, Jt, Vt, G, 250), X.activeTexture.set(K.TEXTURE0), gt.texture && gt.texture.bind(K.LINEAR, K.CLAMP_TO_EDGE);
                    const or = Na.getMorphValuesForProxy(dt.key), sr = or ? 1 : 0;
                    let Bt;
                    or && (Bt = { morphing: { srcDemTile: or.from, dstDemTile: or.to, phase: r.cB(or.phase) } });
                    const rr = Pl(dt.projMatrix, Bn(dt.canonical, et.renderWorldCopies) ? ut / 10 : ut, st);
                    if (Re(sr), !ae) continue;
                    _.setupElevationDraw(gt, ae, Bt);
                    const gr = dt.toUnwrapped();
                    pe && pe.setupShadows(gr, ae), d.uploadCommonUniforms(X, ae, gr, null, Be), ae.draw(d, xt, Ve, Rt, Ge, vi.backCCW, rr, "terrain_raster", _.gridBuffer, mt, _t);
                  }
                }
              }
            }(n, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, n.gpuTimingDeferredRenderEnd(), t.splice(0, t.length));
          }
          renderBatch(t) {
            if (this._drapedRenderBatches.length === 0) return t + 1;
            this.renderingToTexture = !0;
            const n = this.painter, u = this.painter.context, d = this.proxySourceCache, _ = this.proxiedCoords[d.id], v = this._drapedRenderBatches.shift(), L = n.style.order, G = [];
            let X = 0;
            for (const K of _) {
              const ae = d.getTileByID(K.proxyTileKey), oe = d.proxyCachedFBO[K.key] ? d.proxyCachedFBO[K.key][t] : void 0, pe = oe !== void 0 ? d.renderCache[oe] : this.pool[X++], Be = oe !== void 0;
              if (ae.texture = pe.tex, Be && !pe.dirty) {
                G.push(ae.tileID);
                continue;
              }
              let Re;
              u.bindFramebuffer.set(pe.fb.framebuffer), this.renderedToTile = !1, pe.dirty && (u.clear({ color: r.aj.transparent, stencil: 0 }), pe.dirty = !1);
              for (let Ge = v.start; Ge <= v.end; ++Ge) {
                const Ve = n.style._mergedLayers[L[Ge]];
                if (Ve.isHidden(n.transform.zoom)) continue;
                const et = n.style.getLayerSourceCache(Ve), ut = et ? this.proxyToSource[K.key][et.id] : [K];
                if (!ut) continue;
                const st = ut;
                u.viewport.set([0, 0, pe.fb.width, pe.fb.height]), Re !== (et ? et.id : null) && (this._setupStencil(pe, ut, Ve, et), Re = et ? et.id : null), n.renderLayer(n, et, Ve, st);
              }
              if (this._drapedRenderBatches.length === 0) for (const Ge of this._pendingGroundEffectLayers) {
                const Ve = n.style._mergedLayers[L[Ge]];
                if (Ve.isHidden(n.transform.zoom)) continue;
                const et = n.style.getLayerSourceCache(Ve), ut = et ? this.proxyToSource[K.key][et.id] : [K];
                if (!ut) continue;
                const st = ut;
                u.viewport.set([0, 0, pe.fb.width, pe.fb.height]), Re !== (et ? et.id : null) && (this._setupStencil(pe, ut, Ve, et), Re = et ? et.id : null), n.renderLayer(n, et, Ve, st);
              }
              this.renderedToTile ? (pe.dirty = !0, G.push(ae.tileID)) : Be || --X, X === 5 && (X = 0, this.renderToBackBuffer(G));
            }
            return this.renderToBackBuffer(G), this.renderingToTexture = !1, u.bindFramebuffer.set(null), u.viewport.set([0, 0, n.width, n.height]), v.end + 1;
          }
          postRender() {
          }
          isLayerOrderingCorrect(t) {
            const n = t.order.length;
            let u = -1, d = n;
            for (let _ = 0; _ < n; ++_) this._style.isLayerDraped(t._mergedLayers[t.order[_]]) ? u = Math.max(u, _) : d = Math.min(d, _);
            return d > u;
          }
          getMinElevationBelowMSL() {
            let t = 0;
            return this._visibleDemTiles.filter((n) => n.dem).forEach((n) => {
              t = Math.min(t, n.dem.tree.minimums[0]);
            }), t === 0 ? t : (t - 30) * this._exaggeration;
          }
          raycast(t, n, u) {
            if (!this._visibleDemTiles) return null;
            const d = this._visibleDemTiles.filter((_) => _.dem).map((_) => {
              const v = _.tileID, L = 1 << v.overscaledZ, { x: G, y: X } = v.canonical, K = G / L, ae = (G + 1) / L, oe = X / L, pe = (X + 1) / L;
              return { minx: K, miny: oe, maxx: ae, maxy: pe, t: _.dem.tree.raycastRoot(K, oe, ae, pe, t, n, u), tile: _ };
            });
            d.sort((_, v) => (_.t !== null ? _.t : Number.MAX_VALUE) - (v.t !== null ? v.t : Number.MAX_VALUE));
            for (const _ of d) {
              if (_.t == null) return null;
              const v = _.tile.dem.tree.raycast(_.minx, _.miny, _.maxx, _.maxy, t, n, u);
              if (v != null) return v;
            }
            return null;
          }
          _createFBO() {
            const t = this.painter.context, n = t.gl, u = this.drapeBufferSize;
            t.activeTexture.set(n.TEXTURE0);
            const d = new r.T(t, { width: u[0], height: u[1], data: null }, n.RGBA8);
            d.bind(n.LINEAR, n.CLAMP_TO_EDGE);
            const _ = t.createFramebuffer(u[0], u[1], !0, null);
            return _.colorAttachment.set(d.texture), _.depthAttachment = new Js(t, _.framebuffer), this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, u[0], u[1]), this._stencilRef = 0, _.depthAttachment.set(this._sharedDepthStencil), t.clear({ stencil: 0 })) : _.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && n.texParameterf(n.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), { fb: _, tex: d, dirty: !1 };
          }
          _initFBOPool() {
            for (; this.pool.length < Math.min(5, this.proxyCoords.length); ) this.pool.push(this._createFBO());
          }
          _shouldDisableRenderCache() {
            if (this._debugParams.disableRenderCache || this._style.hasLightTransitions()) return !0;
            for (const t in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t].hasTransition()) return !0;
            return this._style.order.some((t) => {
              const n = this._style._mergedLayers[t], u = n.isHidden(this.painter.transform.zoom);
              return n.type === "hillshade" || n.type === "custom" ? !u && n.shouldRedrape() : !u && n.hasTransition();
            });
          }
          _clearLineLayersFromRenderCache() {
            let t = !1;
            for (const u of this._style.getSources()) if (u instanceof Gn) {
              t = !0;
              break;
            }
            if (!t) return;
            const n = {};
            for (let u = 0; u < this._style.order.length; ++u) {
              const d = this._style._mergedLayers[this._style.order[u]], _ = this._style.getLayerSourceCache(d);
              if (_ && !n[_.id] && !d.isHidden(this.painter.transform.zoom) && d.type === "line" && d.widthExpression() instanceof r.a9) {
                n[_.id] = !0;
                for (const v of this.proxyCoords) {
                  const L = this.proxyToSource[v.key][_.id];
                  if (L) for (const G of L) this._clearRenderCacheForTile(_.id, G);
                }
              }
            }
          }
          _clearRasterLayersFromRenderCache() {
            let t = !1;
            for (const u in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[u]._source instanceof sa) {
              t = !0;
              break;
            }
            if (!t) return;
            const n = {};
            for (let u = 0; u < this._style.order.length; ++u) {
              const d = this._style._mergedLayers[this._style.order[u]], _ = this._style.getLayerSourceCache(d);
              if (!_ || n[_.id] || d.isHidden(this.painter.transform.zoom) || d.type !== "raster") continue;
              const v = d.paint.get("raster-fade-duration");
              for (const L of this.proxyCoords) {
                const G = this.proxyToSource[L.key][_.id];
                if (G) for (const X of G) {
                  const K = Co(_.getTile(X), _.findLoadedParent(X, 0), _, this.painter.transform, v);
                  (K.opacity !== 1 || K.mix !== 0) && this._clearRenderCacheForTile(_.id, X);
                }
              }
            }
          }
          _setupDrapedRenderBatches() {
            this._style.updateDrapeFirstLayers();
            const t = this._style.order, n = t.length;
            if (n === 0) return;
            const u = [];
            this._pendingGroundEffectLayers = [];
            let d, _ = 0, v = this._style._mergedLayers[t[_]];
            for (; !this._style.isLayerDraped(v) && v.isHidden(this.painter.transform.zoom) && ++_ < n; ) v = this._style._mergedLayers[t[_]];
            for (; _ < n; ++_) {
              const L = this._style._mergedLayers[t[_]];
              L.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(L) ? d === void 0 && (d = _) : (L.type === "fill-extrusion" && this._pendingGroundEffectLayers.push(_), d !== void 0 && (u.push({ start: d, end: _ - 1 }), d = void 0)));
            }
            if (d !== void 0 && u.push({ start: d, end: _ - 1 }), u.length !== 0) {
              const L = u[u.length - 1];
              this._pendingGroundEffectLayers.every((G) => G > L.end) || r.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
            }
            this._drapedRenderBatches = u;
          }
          _setupRenderCache(t) {
            const n = this.proxySourceCache;
            if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
              if (this.invalidateRenderCache = !1, n.renderCache.length > n.renderCachePool.length) {
                const v = Object.values(n.proxyCachedFBO);
                n.proxyCachedFBO = {};
                for (let L = 0; L < v.length; ++L) {
                  const G = Object.values(v[L]);
                  n.renderCachePool.push(...G);
                }
              }
              return;
            }
            this._clearRasterLayersFromRenderCache();
            const u = this.proxyCoords, d = this._tilesDirty;
            for (let v = u.length - 1; v >= 0; v--) {
              const L = u[v];
              if (n.getTileByID(L.key), n.proxyCachedFBO[L.key] !== void 0) {
                const G = t[L.key], X = this.proxyToSource[L.key];
                let K = 0;
                for (const ae in X) {
                  const oe = X[ae], pe = G[ae];
                  if (!pe || pe.length !== oe.length || oe.some((Be, Re) => Be !== pe[Re] || d[ae] && d[ae].hasOwnProperty(Be.key))) {
                    K = -1;
                    break;
                  }
                  ++K;
                }
                for (const ae in n.proxyCachedFBO[L.key]) n.renderCache[n.proxyCachedFBO[L.key][ae]].dirty = K < 0 || K !== Object.values(G).length;
              }
            }
            const _ = [...this._drapedRenderBatches];
            _.sort((v, L) => L.end - L.start - (v.end - v.start));
            for (const v of _) for (const L of u) {
              if (n.proxyCachedFBO[L.key]) continue;
              let G = n.renderCachePool.pop();
              G === void 0 && n.renderCache.length < 50 && (G = n.renderCache.length, n.renderCache.push(this._createFBO())), G !== void 0 && (n.proxyCachedFBO[L.key] = {}, n.proxyCachedFBO[L.key][v.start] = G, n.renderCache[G].dirty = !0);
            }
            this._tilesDirty = {};
          }
          _setupStencil(t, n, u, d) {
            if (!d || !this._sourceTilesOverlap[d.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
            const _ = this.painter.context, v = _.gl;
            if (n.length <= 1) return void (this._overlapStencilType = !1);
            let L;
            if (u.isTileClipped()) L = n.length, this._overlapStencilMode.test = { func: v.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
            else {
              if (!(n[0].overscaledZ > n[n.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
              L = 1, this._overlapStencilMode.test = { func: v.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
            }
            this._stencilRef + L > 255 && (_.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += L, this._overlapStencilMode.ref = this._stencilRef, u.isTileClipped() && this._renderTileClippingMasks(n, this._overlapStencilMode.ref);
          }
          clipOrMaskOverlapStencilType() {
            return this._overlapStencilType === "Clip" || this._overlapStencilType === "Mask";
          }
          stencilModeForRTTOverlap(t) {
            return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : _i.disabled;
          }
          _renderTileClippingMasks(t, n) {
            const u = this.painter, d = this.painter.context, _ = d.gl;
            u._tileClippingMaskIDs = {}, d.setColorMode(zi.disabled), d.setDepthMode(ui.disabled);
            const v = u.getOrCreateProgram("clippingMask");
            for (const L of t) {
              const G = u._tileClippingMaskIDs[L.key] = --n;
              v.draw(u, _.TRIANGLES, ui.disabled, new _i({ func: _.ALWAYS, mask: 0 }, G, 255, _.KEEP, _.KEEP, _.REPLACE), zi.disabled, vi.disabled, Tn(L.projMatrix), "$clipping", u.tileExtentBuffer, u.quadTriangleIndexBuffer, u.tileExtentSegments);
            }
          }
          pointCoordinate(t) {
            const n = this.painter.transform;
            if (t.x < 0 || t.x > n.width || t.y < 0 || t.y > n.height) return null;
            const u = [t.x, t.y, 1, 1];
            r.ab.vec4.transformMat4(u, u, n.pixelMatrixInverse), r.ab.vec4.scale(u, u, 1 / u[3]), u[0] /= n.worldSize, u[1] /= n.worldSize;
            const d = n._camera.position, _ = r.bH(1, n.center.lat), v = [d[0], d[1], d[2] / _, 0], L = r.ab.vec3.subtract([], u.slice(0, 3), v);
            r.ab.vec3.normalize(L, L);
            const G = this.raycast(v, L, this._exaggeration);
            return G !== null && G ? (r.ab.vec3.scaleAndAdd(v, v, L, G), v[3] = v[2], v[2] *= _, v) : null;
          }
          _setupProxiedCoordsForOrtho(t, n, u) {
            if (t.getSource() instanceof r.aJ) return this._setupProxiedCoordsForImageSource(t, n, u);
            this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};
            const d = this.proxiedCoords[t.id] = [], _ = this.proxyCoords;
            for (let G = 0; G < _.length; G++) {
              const X = _[G], K = this._findTileCoveringTileID(X, t);
              if (K) {
                const ae = this._createProxiedId(X, K, u[X.key] && u[X.key][t.id]);
                d.push(ae), this.proxyToSource[X.key][t.id] = [ae];
              }
            }
            let v = !1;
            const L = /* @__PURE__ */ new Set();
            for (let G = 0; G < n.length; G++) {
              const X = t.getTile(n[G]);
              if (!X || !X.hasData()) continue;
              const K = this._findTileCoveringTileID(X.tileID, this.proxySourceCache);
              if (K && K.tileID.canonical.z !== X.tileID.canonical.z) {
                const ae = this.proxyToSource[K.tileID.key][t.id], oe = this._createProxiedId(K.tileID, X, u[K.tileID.key] && u[K.tileID.key][t.id]);
                ae ? ae.splice(ae.length - 1, 0, oe) : this.proxyToSource[K.tileID.key][t.id] = [oe];
                const pe = this.proxyToSource[K.tileID.key][t.id];
                L.has(pe) || L.add(pe), d.push(oe), v = !0;
              }
            }
            if (this._sourceTilesOverlap[t.id] = v, v && this._debugParams.sortTilesHiZFirst) for (const G of L) G.sort((X, K) => K.overscaledZ - X.overscaledZ);
          }
          _setupProxiedCoordsForImageSource(t, n, u) {
            if (!t.getSource().loaded()) return;
            const d = this.proxiedCoords[t.id] = [], _ = this.proxyCoords, v = t.getSource(), L = v.tileID;
            if (!L) return;
            const G = new r.P(L.x, L.y)._div(1 << L.z), X = v.coordinates.map(r.aa.fromLngLat).reduce((ae, oe) => (ae.min.x = Math.min(ae.min.x, oe.x - G.x), ae.min.y = Math.min(ae.min.y, oe.y - G.y), ae.max.x = Math.max(ae.max.x, oe.x - G.x), ae.max.y = Math.max(ae.max.y, oe.y - G.y), ae), { min: new r.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new r.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), K = (ae, oe) => {
              const pe = ae.wrap + ae.canonical.x / (1 << ae.canonical.z), Be = ae.canonical.y / (1 << ae.canonical.z), Re = r.ag / (1 << ae.canonical.z), Ge = oe.wrap + oe.canonical.x / (1 << oe.canonical.z), Ve = oe.canonical.y / (1 << oe.canonical.z);
              return pe + Re < Ge + X.min.x || pe > Ge + X.max.x || Be + Re < Ve + X.min.y || Be > Ve + X.max.y;
            };
            for (let ae = 0; ae < _.length; ae++) {
              const oe = _[ae];
              for (let pe = 0; pe < n.length; pe++) {
                const Be = t.getTile(n[pe]);
                if (!Be || !Be.hasData() || K(oe, Be.tileID)) continue;
                const Re = this._createProxiedId(oe, Be, u[oe.key] && u[oe.key][t.id]), Ge = this.proxyToSource[oe.key][t.id];
                Ge ? Ge.push(Re) : this.proxyToSource[oe.key][t.id] = [Re], d.push(Re);
              }
            }
          }
          _createProxiedId(t, n, u) {
            let d = this.orthoMatrix;
            if (u) {
              const _ = u.find((v) => v.key === n.tileID.key);
              if (_) return _;
            }
            if (n.tileID.key !== t.key) {
              const _ = t.canonical.z - n.tileID.canonical.z;
              let v, L, G;
              d = r.ab.mat4.create();
              const X = n.tileID.wrap - t.wrap << t.overscaledZ;
              _ > 0 ? (v = r.ag >> _, L = v * ((n.tileID.canonical.x << _) - t.canonical.x + X), G = v * ((n.tileID.canonical.y << _) - t.canonical.y)) : (v = r.ag << -_, L = r.ag * (n.tileID.canonical.x - (t.canonical.x + X << -_)), G = r.ag * (n.tileID.canonical.y - (t.canonical.y << -_))), r.ab.mat4.ortho(d, 0, v, 0, v, 0, 1), r.ab.mat4.translate(d, d, [L, G, 0]);
            }
            return new Ss(n.tileID, t.key, d);
          }
          _findTileCoveringTileID(t, n) {
            let u = n.getTile(t);
            if (u && u.hasData()) return u;
            const d = this._findCoveringTileCache[n.id], _ = d[t.key];
            if (u = _ ? n.getTileByID(_) : null, u && u.hasData() || _ === null) return u;
            let v = u ? u.tileID : t, L = v.overscaledZ;
            const G = n.getSource().minzoom, X = [];
            if (!_) {
              const ae = n.getSource().maxzoom;
              if (t.canonical.z >= ae) {
                const oe = t.canonical.z - ae;
                n.getSource().reparseOverscaled ? (L = Math.max(t.canonical.z + 2, n.transform.tileZoom), v = new r.aG(L, t.wrap, ae, t.canonical.x >> oe, t.canonical.y >> oe)) : oe !== 0 && (L = ae, v = new r.aG(L, t.wrap, ae, t.canonical.x >> oe, t.canonical.y >> oe));
              }
              v.key !== t.key && (X.push(v.key), u = n.getTile(v));
            }
            const K = (ae) => {
              X.forEach((oe) => {
                d[oe] = ae;
              }), X.length = 0;
            };
            for (L -= 1; L >= G && (!u || !u.hasData()); L--) {
              u && K(u.tileID.key);
              const ae = v.calculateScaledKey(L);
              if (u = n.getTileByID(ae), u && u.hasData()) break;
              const oe = d[ae];
              if (oe === null) break;
              oe === void 0 ? X.push(ae) : u = n.getTileByID(oe);
            }
            return K(u ? u.tileID.key : null), u && u.hasData() ? u : null;
          }
          findDEMTileFor(t) {
            return this.enabled ? this._findTileCoveringTileID(t, this.sourceCache) : null;
          }
          prepareDrawTile() {
            this.renderedToTile = !0;
          }
          _clearRenderCacheForTile(t, n) {
            let u = this._tilesDirty[t];
            u || (u = this._tilesDirty[t] = {}), u[n.key] = !0;
          }
        }
        function Qa(l, t, n) {
          const u = function(L, G, X) {
            const K = r.ab.vec3.dot(G, L), ae = r.ab.vec3.dot(X, [0.2126, 0.7152, 0.0722]), oe = (Be, Re, Ge) => (1 - Ge) * Be + Ge * Re, pe = oe(1 - 0.3 * Math.min(ae, 1), 1, Math.min(K + 1, 1));
            return oe(0.92, 1, Math.asin(r.aw(G[2], -1, 1)) / Math.PI + 0.5) * pe;
          }(l, [0, 0, 1], t), d = [0, 0, 0];
          r.ab.vec3.scale(d, n.slice(0, 3), u);
          const _ = [0, 0, 0];
          r.ab.vec3.scale(_, t.slice(0, 3), l[2]);
          const v = [0, 0, 0];
          return r.ab.vec3.add(v, d, _), r.cf(v);
        }
        const qc = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], Nh = ["stars", "rainParticle", "snowParticle", "fillExtrusion", "fillExtrusionGroundEffect", "model", "symbol"];
        class Uh {
          static cacheKey(t, n, u, d) {
            let _ = `${n}${d ? d.cacheKey : ""}`;
            for (const v of u) t.usedDefines.includes(v) && (_ += `/${v}`);
            return _;
          }
          constructor(t, n, u, d, _, v) {
            const L = t.gl;
            this.program = L.createProgram(), this.configuration = d, this.name = n, this.fixedDefines = [...v];
            const G = d ? d.getBinderAttributes() : [], X = (u.staticAttributes || []).concat(G);
            let K = d ? d.defines() : [];
            K = K.concat(v.map((Ge) => `#define ${Ge}`));
            const ae = `#version 300 es
`;
            let oe = ae + K.concat("precision mediump float;", mu, tc.fragmentSource).join(`
`);
            for (const Ge of u.fragmentIncludes) oe += `
${Sl[Ge]}`;
            oe += `
${u.fragmentSource}`;
            let pe = ae + K.concat("precision highp float;", mu, tc.vertexSource).join(`
`);
            for (const Ge of u.vertexIncludes) pe += `
${Sl[Ge]}`;
            this.forceManualRenderingForInstanceIDShaders = t.forceManualRenderingForInstanceIDShaders && u.vertexSource.indexOf("gl_InstanceID") !== -1, this.forceManualRenderingForInstanceIDShaders && (pe += `
uniform int u_instanceID;
`), pe += `
${u.vertexSource}`, this.forceManualRenderingForInstanceIDShaders && (pe = pe.replaceAll("gl_InstanceID", "u_instanceID"));
            const Be = L.createShader(L.FRAGMENT_SHADER);
            if (L.isContextLost()) return void (this.failedToCreate = !0);
            L.shaderSource(Be, oe), L.compileShader(Be), L.attachShader(this.program, Be);
            const Re = L.createShader(L.VERTEX_SHADER);
            if (L.isContextLost()) this.failedToCreate = !0;
            else {
              L.shaderSource(Re, pe), L.compileShader(Re), L.attachShader(this.program, Re), this.attributes = {}, this.numAttributes = X.length;
              for (let Ge = 0; Ge < this.numAttributes; Ge++) if (X[Ge]) {
                const Ve = X[Ge].startsWith("a_") ? X[Ge] : `a_${X[Ge]}`;
                L.bindAttribLocation(this.program, Ge, Ve), this.attributes[Ve] = Ge;
              }
              L.linkProgram(this.program), L.deleteShader(Re), L.deleteShader(Be), this.fixedUniforms = _(t), this.binderUniforms = d ? d.getUniforms(t) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = ((Ge) => ({ u_instanceID: new r.bN(Ge) }))(t)), (v.includes("TERRAIN") || n.indexOf("symbol") !== -1 || n.indexOf("circle") !== -1) && (this.terrainUniforms = ((Ge) => ({ u_dem: new r.bN(Ge), u_dem_prev: new r.bN(Ge), u_dem_tl: new r.bK(Ge), u_dem_scale: new r.bM(Ge), u_dem_tl_prev: new r.bK(Ge), u_dem_scale_prev: new r.bM(Ge), u_dem_size: new r.bM(Ge), u_dem_lerp: new r.bM(Ge), u_exaggeration: new r.bM(Ge), u_depth: new r.bN(Ge), u_depth_size_inv: new r.bK(Ge), u_depth_range_unpack: new r.bK(Ge), u_occluder_half_size: new r.bM(Ge), u_occlusion_depth_offset: new r.bM(Ge), u_meter_to_dem: new r.bM(Ge), u_label_plane_matrix_inv: new r.bJ(Ge) }))(t)), v.includes("GLOBE") && (this.globeUniforms = ((Ge) => ({ u_tile_tl_up: new r.bL(Ge), u_tile_tr_up: new r.bL(Ge), u_tile_br_up: new r.bL(Ge), u_tile_bl_up: new r.bL(Ge), u_tile_up_scale: new r.bM(Ge) }))(t)), v.includes("FOG") && (this.fogUniforms = ((Ge) => ({ u_fog_matrix: new r.bJ(Ge), u_fog_range: new r.bK(Ge), u_fog_color: new r.ca(Ge), u_fog_horizon_blend: new r.bM(Ge), u_fog_vertical_limit: new r.bK(Ge), u_fog_temporal_offset: new r.bM(Ge), u_frustum_tl: new r.bL(Ge), u_frustum_tr: new r.bL(Ge), u_frustum_br: new r.bL(Ge), u_frustum_bl: new r.bL(Ge), u_globe_pos: new r.bL(Ge), u_globe_radius: new r.bM(Ge), u_globe_transition: new r.bM(Ge), u_is_globe: new r.bN(Ge), u_viewport: new r.bK(Ge) }))(t)), v.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((Ge) => ({ u_cutoff_params: new r.ca(Ge) }))(t)), v.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((Ge) => ({ u_lighting_ambient_color: new r.bL(Ge), u_lighting_directional_dir: new r.bL(Ge), u_lighting_directional_color: new r.bL(Ge), u_ground_radiance: new r.bL(Ge) }))(t)), v.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((Ge) => ({ u_light_matrix_0: new r.bJ(Ge), u_light_matrix_1: new r.bJ(Ge), u_fade_range: new r.bK(Ge), u_shadow_normal_offset: new r.bL(Ge), u_shadow_intensity: new r.bM(Ge), u_shadow_texel_size: new r.bM(Ge), u_shadow_map_resolution: new r.bM(Ge), u_shadow_direction: new r.bL(Ge), u_shadow_bias: new r.bL(Ge), u_shadowmap_0: new r.bN(Ge), u_shadowmap_1: new r.bN(Ge) }))(t));
            }
          }
          setTerrainUniformValues(t, n) {
            if (!this.terrainUniforms) return;
            const u = this.terrainUniforms;
            if (!this.failedToCreate) {
              t.program.set(this.program);
              for (const d in n) u[d] && u[d].set(this.program, d, n[d]);
            }
          }
          setGlobeUniformValues(t, n) {
            if (!this.globeUniforms) return;
            const u = this.globeUniforms;
            if (!this.failedToCreate) {
              t.program.set(this.program);
              for (const d in n) u[d] && u[d].set(this.program, d, n[d]);
            }
          }
          setFogUniformValues(t, n) {
            if (!this.fogUniforms) return;
            const u = this.fogUniforms;
            if (!this.failedToCreate) {
              t.program.set(this.program);
              for (const d in n) u[d].set(this.program, d, n[d]);
            }
          }
          setCutoffUniformValues(t, n) {
            if (!this.cutoffUniforms) return;
            const u = this.cutoffUniforms;
            if (!this.failedToCreate) {
              t.program.set(this.program);
              for (const d in n) u[d].set(this.program, d, n[d]);
            }
          }
          setLightsUniformValues(t, n) {
            if (!this.lightsUniforms) return;
            const u = this.lightsUniforms;
            if (!this.failedToCreate) {
              t.program.set(this.program);
              for (const d in n) u[d].set(this.program, d, n[d]);
            }
          }
          setShadowUniformValues(t, n) {
            if (this.failedToCreate || !this.shadowUniforms) return;
            const u = this.shadowUniforms;
            t.program.set(this.program);
            for (const d in n) u[d].set(this.program, d, n[d]);
          }
          _drawDebugWireframe(t, n, u, d, _, v, L, G, X, K) {
            const ae = t.options.wireframe;
            if (ae.terrain === !1 && ae.layers2D === !1 && ae.layers3D === !1) return;
            const oe = t.context;
            if (!(!(!ae.terrain || this.name !== "terrainRaster" && this.name !== "globeRaster") || !(!ae.layers2D || t._terrain && t._terrain.renderingToTexture || !qc.includes(this.name)) || !(!ae.layers3D || !Nh.includes(this.name)))) return;
            const pe = oe.gl, Be = t.wireframeDebugCache.getLinesFromTrianglesBuffer(t.frameCounter, _, oe);
            if (!Be) return;
            const Re = [...this.fixedDefines];
            Re.push("DEBUG_WIREFRAME");
            const Ge = t.getOrCreateProgram(this.name, { config: this.configuration, defines: Re });
            oe.program.set(Ge.program);
            const Ve = (st, xt, mt) => {
              if (xt[st] && mt[st]) for (const _t in xt[st]) mt[st][_t] && mt[st][_t].set(mt.program, _t, xt[st][_t].current);
            };
            X && X.setUniforms(Ge.program, oe, Ge.binderUniforms, L, { zoom: G }), Ve("fixedUniforms", this, Ge), Ve("terrainUniforms", this, Ge), Ve("globeUniforms", this, Ge), Ve("fogUniforms", this, Ge), Ve("lightsUniforms", this, Ge), Ve("shadowUniforms", this, Ge), Be.bind(), oe.setColorMode(new zi([pe.ONE, pe.ONE_MINUS_SRC_ALPHA, pe.ZERO, pe.ONE], r.aj.transparent, [!0, !0, !0, !1])), oe.setDepthMode(new ui(n.func === pe.LESS ? pe.LEQUAL : n.func, ui.ReadOnly, n.range)), oe.setStencilMode(_i.disabled);
            const et = 3 * v.primitiveLength * 2, ut = 3 * v.primitiveOffset * 2 * 2;
            if (this.forceManualRenderingForInstanceIDShaders) {
              const st = K || 1;
              for (let xt = 0; xt < st; ++xt) Ge.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", xt), pe.drawElements(pe.LINES, et, pe.UNSIGNED_SHORT, ut);
            } else K && K > 1 ? pe.drawElementsInstanced(pe.LINES, et, pe.UNSIGNED_SHORT, ut, K) : pe.drawElements(pe.LINES, et, pe.UNSIGNED_SHORT, ut);
            _.bind(), oe.program.set(this.program), oe.setDepthMode(n), oe.setStencilMode(u), oe.setColorMode(d);
          }
          checkUniforms(t, n, u) {
            if (this.fixedDefines.includes(n)) {
              for (const d of Object.keys(u)) if (!u[d].initialized) throw new Error(`Program '${this.name}', from draw '${t}': uniform ${d} not set but required by ${n} being defined`);
            }
          }
          draw(t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re, Ge) {
            const Ve = t.context, et = Ve.gl;
            if (this.failedToCreate) return;
            Ve.program.set(this.program), Ve.setDepthMode(u), Ve.setStencilMode(d), Ve.setColorMode(_), Ve.setCullFace(v);
            for (const xt of Object.keys(this.fixedUniforms)) this.fixedUniforms[xt].set(this.program, xt, L[xt]);
            Be && Be.setUniforms(this.program, Ve, this.binderUniforms, oe, { zoom: pe });
            const ut = { [et.POINTS]: 1, [et.LINES]: 2, [et.TRIANGLES]: 3, [et.LINE_STRIP]: 1 }[n];
            this.checkUniforms(G, "RENDER_SHADOWS", this.shadowUniforms);
            const st = Ge && Ge > 0 ? 1 : void 0;
            for (const xt of ae.get()) {
              const mt = xt.vaos || (xt.vaos = {});
              if ((mt[G] || (mt[G] = new Nc())).bind(Ve, this, X, Be ? Be.getPaintVertexBuffers() : [], K, xt.vertexOffset, Re || [], st), this.forceManualRenderingForInstanceIDShaders) {
                const _t = Ge || 1;
                for (let dt = 0; dt < _t; ++dt) this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", dt), K ? et.drawElements(n, xt.primitiveLength * ut, et.UNSIGNED_SHORT, xt.primitiveOffset * ut * 2) : et.drawArrays(n, xt.vertexOffset, xt.vertexLength);
              } else Ge && Ge > 1 ? et.drawElementsInstanced(n, xt.primitiveLength * ut, et.UNSIGNED_SHORT, xt.primitiveOffset * ut * 2, Ge) : K ? et.drawElements(n, xt.primitiveLength * ut, et.UNSIGNED_SHORT, xt.primitiveOffset * ut * 2) : et.drawArrays(n, xt.vertexOffset, xt.vertexLength);
              n === et.TRIANGLES && K && this._drawDebugWireframe(t, u, d, _, K, xt, oe, pe, Be, Ge);
            }
          }
        }
        function Rl(l, t) {
          const n = Math.pow(2, t.tileID.overscaledZ), u = t.tileSize * Math.pow(2, l.transform.tileZoom) / n, d = u * (t.tileID.canonical.x + t.tileID.wrap * n), _ = u * t.tileID.canonical.y;
          return { u_image: 0, u_texsize: t.imageAtlasTexture ? t.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / r.ar(t, 1, l.transform.tileZoom), u_pixel_coord_upper: [d >> 16, _ >> 16], u_pixel_coord_lower: [65535 & d, 65535 & _] };
        }
        const Ll = { terrain: 0, flat: 1 }, eo = r.ab.mat4.create(), Dl = (l, t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re, Ge, Ve) => {
          const et = t.style.light, ut = et.properties.get("position"), st = [ut.x, ut.y, ut.z], xt = r.ab.mat3.create();
          et.properties.get("anchor") === "viewport" && (r.ab.mat3.fromRotation(xt, -t.transform.angle), r.ab.vec3.transformMat3(st, st, xt));
          const mt = et.properties.get("color"), _t = t.transform, dt = { u_matrix: l, u_lightpos: st, u_lightintensity: et.properties.get("intensity"), u_lightcolor: [mt.r, mt.g, mt.b], u_vertical_gradient: +n, u_opacity: u, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: eo, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_height_type: Ll[X], u_base_type: Ll[K], u_ao: d, u_edge_radius: _, u_width_scale: v, u_flood_light_color: Be, u_vertical_scale: Re, u_flood_light_intensity: Ge, u_ground_shadow_factor: Ve };
          return _t.projection.name === "globe" && (dt.u_tile_id = [L.canonical.x, L.canonical.y, 1 << L.canonical.z], dt.u_zoom_transition = ae, dt.u_inv_rot_matrix = pe, dt.u_merc_center = oe, dt.u_up_dir = _t.projection.upVector(new r.bT(0, 0, 0), oe[0] * r.ag, oe[1] * r.ag), dt.u_height_lift = G), dt;
        }, kl = (l, t, n, u, d, _) => ({ u_matrix: l, u_edge_radius: t, u_width_scale: n, u_vertical_scale: u, u_height_type: Ll[d], u_base_type: Ll[_] }), jh = (l, t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re, Ge) => {
          const Ve = Dl(l, t, n, u, d, _, v, L, X, K, ae, oe, pe, Be, Re, Ge, 1, [0, 0, 0]), et = { u_height_factor: -Math.pow(2, L.overscaledZ) / G.tileSize / 8 };
          return r.l(Ve, Rl(t, G), et);
        }, lc = (l, t) => ({ u_matrix: l, u_emissive_strength: t }), Po = (l, t, n, u) => r.l(lc(l, t), Rl(n, u)), Qs = (l, t, n) => ({ u_matrix: l, u_world: n, u_emissive_strength: t }), zl = (l, t, n, u, d) => r.l(Po(l, t, n, u), { u_world: d }), $c = (l, t, n, u) => {
          const d = r.ag / n.tileSize;
          return { u_matrix: l, u_camera_to_center_distance: t.getCameraToCenterDistance(u), u_extrude_scale: [t.pixelsToGLUnits[0] / d, t.pixelsToGLUnits[1] / d] };
        }, ts = (l, t, n = 1) => ({ u_matrix: l, u_color: t.toRenderColor(null), u_overlay: 0, u_overlay_scale: n }), Ua = r.ab.mat4.create(), Gr = (l, t, n, u, d, _, v) => {
          const L = l.transform, G = L.projection.name === "globe", X = G ? r.cN(L.zoom, t.canonical) * L._pixelsPerMercatorPixel : r.ar(n, 1, _), K = { u_matrix: t.projMatrix, u_extrude_scale: X, u_intensity: v, u_inv_rot_matrix: Ua, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (G) {
            K.u_inv_rot_matrix = u, K.u_merc_center = d, K.u_tile_id = [t.canonical.x, t.canonical.y, 1 << t.canonical.z], K.u_zoom_transition = r.ae(L.zoom);
            const ae = d[0] * r.ag, oe = d[1] * r.ag;
            K.u_up_dir = L.projection.upVector(new r.bT(0, 0, 0), ae, oe);
          }
          return K;
        };
        function Ts(l, [t, n, u, d], [_, v]) {
          if (_ === v) return [0, 0, 0, 0];
          const L = 255 * (l - 1) / (l * (v - _));
          return [t * L, n * L, u * L, d * L];
        }
        function Fo(l, t, [n, u]) {
          return n === u ? 0 : 0.5 / l + (t - n) * (l - 1) / (l * (u - n));
        }
        const Ra = (l, t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re, Ge, Ve, et, ut, st) => ({ u_matrix: l, u_normalize_matrix: t, u_globe_matrix: n, u_merc_matrix: u, u_grid_matrix: d, u_tl_parent: _, u_scale_parent: X, u_fade_t: K.mix, u_opacity: K.opacity * ae.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: ae.paint.get("raster-brightness-min"), u_brightness_high: ae.paint.get("raster-brightness-max"), u_saturation_factor: r.cO(ae.paint.get("raster-saturation")), u_contrast_factor: r.cP(ae.paint.get("raster-contrast")), u_spin_weights: po(ae.paint.get("raster-hue-rotate")), u_perspective_transform: oe, u_raster_elevation: pe, u_zoom_transition: v, u_merc_center: L, u_cutoff_params: G, u_colorization_mix: Ts(r.cQ, Re, Ve), u_colorization_offset: Fo(r.cQ, Ge, Ve), u_color_ramp: Be, u_texture_offset: [ut / (et + 2 * ut), et / (et + 2 * ut)], u_texture_res: [et + 2 * ut, et + 2 * ut], u_emissive_strength: st });
        function po(l) {
          l *= Math.PI / 180;
          const t = Math.sin(l), n = Math.cos(l);
          return [(2 * n + 1) / 3, (-Math.sqrt(3) * t - n + 1) / 3, (Math.sqrt(3) * t - n + 1) / 3];
        }
        const ri = 0.05, uc = (l, t, n, u, d, _, v, L, G, X, K, ae) => ({ u_matrix: l, u_normalize_matrix: t, u_globe_matrix: n, u_merc_matrix: u, u_grid_matrix: d, u_tl_parent: _, u_scale_parent: X, u_fade_t: K.mix, u_opacity: K.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: ae, u_zoom_transition: v, u_merc_center: L, u_cutoff_params: G }), Vh = (l, t, n, u, d, _, v, L, G, X) => ({ u_particle_texture: l, u_particle_texture_side_len: t, u_tile_offset: n, u_velocity: u, u_color_ramp: _, u_velocity_res: d, u_max_speed: v, u_uv_offset: L, u_data_scale: [255 * G[0], 255 * G[1]], u_data_offset: X, u_particle_pos_scale: 1.1, u_particle_pos_offset: [ri, ri] }), mo = (l, t, n, u, d, _, v, L, G, X) => ({ u_particle_texture: l, u_particle_texture_side_len: t, u_velocity: n, u_velocity_res: u, u_max_speed: d, u_speed_factor: _, u_reset_rate: v, u_rand_seed: Math.random(), u_uv_offset: L, u_data_scale: [255 * G[0], 255 * G[1]], u_data_offset: X, u_particle_pos_scale: 1.1, u_particle_pos_offset: [ri, ri] }), La = r.ab.mat4.create(), Fn = (l, t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re, Ge, Ve, et, ut, st, xt) => {
          const mt = d.transform, _t = { u_is_size_zoom_constant: +(l === "constant" || l === "source"), u_is_size_feature_constant: +(l === "constant" || l === "camera"), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: mt.getCameraToCenterDistance(et), u_rotate_symbol: +n, u_aspect_ratio: mt.width / mt.height, u_fade_change: d.options.fadeDuration ? d.symbolFadeChange : 1, u_matrix: _, u_label_plane_matrix: v, u_coord_matrix: L, u_is_text: +X, u_elevation_from_sea: G ? 1 : 0, u_pitch_with_map: +u, u_texsize: K, u_texsize_icon: ae, u_texture: 0, u_texture_icon: 1, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: La, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: La, u_up_vector: [0, -1, 0], u_color_adj_mat: ut, u_icon_transition: st || 0, u_gamma_scale: u ? d.transform.getCameraToCenterDistance(et) * Math.cos(d.terrain ? 0 : d.transform._pitch) : 1, u_device_pixel_ratio: r.q.devicePixelRatio, u_is_halo: +oe, u_scale_factor: xt || 1 };
          return et.name === "globe" && (_t.u_tile_id = [pe.canonical.x, pe.canonical.y, 1 << pe.canonical.z], _t.u_zoom_transition = Be, _t.u_inv_rot_matrix = Ge, _t.u_merc_center = Re, _t.u_camera_forward = mt._camera.forward(), _t.u_ecef_origin = r.cR(mt.globeMatrix, pe.toUnwrapped()), _t.u_tile_matrix = Float32Array.from(mt.globeMatrix), _t.u_up_vector = Ve), _t;
        }, _o = (l, t, n, u) => ({ u_matrix: l, u_emissive_strength: t, u_opacity: n, u_color: u }), Gh = (l, t, n, u, d, _, v, L, G) => r.l(function(X, K, ae, oe, pe, Be) {
          const { width: Re, height: Ge } = oe.imageManager.getPixelSize(K), Ve = Math.pow(2, Be.tileID.overscaledZ), et = Be.tileSize * Math.pow(2, oe.transform.tileZoom) / Ve, ut = et * (Be.tileID.canonical.x + Be.tileID.wrap * Ve), st = et * Be.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl: ae.tl, u_pattern_br: ae.br, u_texsize: [Re, Ge], u_pattern_size: ae.displaySize, u_pattern_units_to_pixels: pe ? [oe.transform.width, -1 * oe.transform.height] : [1 / r.ar(Be, 1, oe.transform.tileZoom), 1 / r.ar(Be, 1, oe.transform.tileZoom)], u_pixel_coord_upper: [ut >> 16, st >> 16], u_pixel_coord_lower: [65535 & ut, 65535 & st] };
        }(0, _, v, u, L, G), { u_matrix: l, u_emissive_strength: t, u_opacity: n }), Xc = new Float32Array(r.ab.mat4.identity([])), Ol = (l, t, n, u, d, _, v, L, G, X, K, ae, oe, pe = [0, 0, 0], Be) => {
          const Re = d.style.light, Ge = Re.properties.get("position"), Ve = [-Ge.x, -Ge.y, Ge.z], et = r.ab.mat3.create();
          Re.properties.get("anchor") === "viewport" && (r.ab.mat3.fromRotation(et, -d.transform.angle), r.ab.vec3.transformMat3(Ve, Ve, et));
          const ut = K.alphaMode === "MASK", st = Re.properties.get("color").toRenderColor(null), xt = oe.paint.get("model-ambient-occlusion-intensity"), mt = oe.paint.get("model-color").constantOr(r.aj.white).toRenderColor(null), _t = oe.paint.get("model-color-mix-intensity").constantOr(0);
          return { u_matrix: l, u_lighting_matrix: t, u_normal_matrix: n, u_node_matrix: u || Xc, u_lightpos: Ve, u_lightintensity: Re.properties.get("intensity"), u_lightcolor: [st.r, st.g, st.b], u_camera_pos: pe, u_opacity: _, u_baseTextureIsAlpha: 0, u_alphaMask: +ut, u_alphaCutoff: K.alphaCutoff, u_baseColorFactor: [v.r, v.g, v.b, v.a], u_emissiveFactor: [L[0], L[1], L[2], 1], u_metallicFactor: G, u_roughnessFactor: X, u_baseColorTexture: xa.BaseColor, u_metallicRoughnessTexture: xa.MetallicRoughness, u_normalTexture: xa.Normal, u_occlusionTexture: xa.Occlusion, u_emissionTexture: xa.Emission, u_lutTexture: xa.LUT, u_color_mix: [mt.r, mt.g, mt.b, _t], u_aoIntensity: xt, u_emissive_strength: ae, u_occlusionTextureTransform: Be || [0, 0, 0, 0] };
        }, bu = (l, t = Xc, n = Xc) => ({ u_matrix: l, u_instance: t, u_node_matrix: n }), Yc = { fillExtrusion: (l) => ({ u_matrix: new r.bJ(l), u_lightpos: new r.bL(l), u_lightintensity: new r.bM(l), u_lightcolor: new r.bL(l), u_vertical_gradient: new r.bM(l), u_opacity: new r.bM(l), u_edge_radius: new r.bM(l), u_width_scale: new r.bM(l), u_ao: new r.bK(l), u_height_type: new r.bN(l), u_base_type: new r.bN(l), u_tile_id: new r.bL(l), u_zoom_transition: new r.bM(l), u_inv_rot_matrix: new r.bJ(l), u_merc_center: new r.bK(l), u_up_dir: new r.bL(l), u_height_lift: new r.bM(l), u_flood_light_color: new r.bL(l), u_vertical_scale: new r.bM(l), u_flood_light_intensity: new r.bM(l), u_ground_shadow_factor: new r.bL(l) }), fillExtrusionDepth: (l) => ({ u_matrix: new r.bJ(l), u_edge_radius: new r.bM(l), u_width_scale: new r.bM(l), u_vertical_scale: new r.bM(l), u_height_type: new r.bN(l), u_base_type: new r.bN(l) }), fillExtrusionPattern: (l) => ({ u_matrix: new r.bJ(l), u_lightpos: new r.bL(l), u_lightintensity: new r.bM(l), u_lightcolor: new r.bL(l), u_vertical_gradient: new r.bM(l), u_height_factor: new r.bM(l), u_edge_radius: new r.bM(l), u_width_scale: new r.bM(l), u_ao: new r.bK(l), u_height_type: new r.bN(l), u_base_type: new r.bN(l), u_tile_id: new r.bL(l), u_zoom_transition: new r.bM(l), u_inv_rot_matrix: new r.bJ(l), u_merc_center: new r.bK(l), u_up_dir: new r.bL(l), u_height_lift: new r.bM(l), u_image: new r.bN(l), u_texsize: new r.bK(l), u_pixel_coord_upper: new r.bK(l), u_pixel_coord_lower: new r.bK(l), u_tile_units_to_pixels: new r.bM(l), u_opacity: new r.bM(l) }), fillExtrusionGroundEffect: (l) => ({ u_matrix: new r.bJ(l), u_opacity: new r.bM(l), u_ao_pass: new r.bM(l), u_meter_to_tile: new r.bM(l), u_ao: new r.bK(l), u_flood_light_intensity: new r.bM(l), u_flood_light_color: new r.bL(l), u_attenuation: new r.bM(l), u_edge_radius: new r.bM(l), u_fb: new r.bN(l), u_fb_size: new r.bM(l), u_dynamic_offset: new r.bM(l) }), fill: (l) => ({ u_matrix: new r.bJ(l), u_emissive_strength: new r.bM(l) }), fillPattern: (l) => ({ u_matrix: new r.bJ(l), u_emissive_strength: new r.bM(l), u_image: new r.bN(l), u_texsize: new r.bK(l), u_pixel_coord_upper: new r.bK(l), u_pixel_coord_lower: new r.bK(l), u_tile_units_to_pixels: new r.bM(l) }), fillOutline: (l) => ({ u_matrix: new r.bJ(l), u_emissive_strength: new r.bM(l), u_world: new r.bK(l) }), fillOutlinePattern: (l) => ({ u_matrix: new r.bJ(l), u_emissive_strength: new r.bM(l), u_world: new r.bK(l), u_image: new r.bN(l), u_texsize: new r.bK(l), u_pixel_coord_upper: new r.bK(l), u_pixel_coord_lower: new r.bK(l), u_tile_units_to_pixels: new r.bM(l) }), circle: r.cS, collisionBox: (l) => ({ u_matrix: new r.bJ(l), u_camera_to_center_distance: new r.bM(l), u_extrude_scale: new r.bK(l) }), collisionCircle: (l) => ({ u_matrix: new r.bJ(l), u_inv_matrix: new r.bJ(l), u_camera_to_center_distance: new r.bM(l), u_viewport_size: new r.bK(l) }), debug: (l) => ({ u_color: new r.cz(l), u_matrix: new r.bJ(l), u_overlay: new r.bN(l), u_overlay_scale: new r.bM(l) }), clippingMask: (l) => ({ u_matrix: new r.bJ(l) }), heatmap: (l) => ({ u_extrude_scale: new r.bM(l), u_intensity: new r.bM(l), u_matrix: new r.bJ(l), u_inv_rot_matrix: new r.bJ(l), u_merc_center: new r.bK(l), u_tile_id: new r.bL(l), u_zoom_transition: new r.bM(l), u_up_dir: new r.bL(l) }), heatmapTexture: (l) => ({ u_image: new r.bN(l), u_color_ramp: new r.bN(l), u_opacity: new r.bM(l) }), hillshade: (l) => ({ u_matrix: new r.bJ(l), u_image: new r.bN(l), u_latrange: new r.bK(l), u_light: new r.bK(l), u_shadow: new r.cz(l), u_highlight: new r.cz(l), u_emissive_strength: new r.bM(l), u_accent: new r.cz(l) }), hillshadePrepare: (l) => ({ u_matrix: new r.bJ(l), u_image: new r.bN(l), u_dimension: new r.bK(l), u_zoom: new r.bM(l) }), line: r.cT, linePattern: r.cU, raster: (l) => ({ u_matrix: new r.bJ(l), u_normalize_matrix: new r.bJ(l), u_globe_matrix: new r.bJ(l), u_merc_matrix: new r.bJ(l), u_grid_matrix: new r.cA(l), u_tl_parent: new r.bK(l), u_scale_parent: new r.bM(l), u_fade_t: new r.bM(l), u_opacity: new r.bM(l), u_image0: new r.bN(l), u_image1: new r.bN(l), u_brightness_low: new r.bM(l), u_brightness_high: new r.bM(l), u_saturation_factor: new r.bM(l), u_contrast_factor: new r.bM(l), u_spin_weights: new r.bL(l), u_perspective_transform: new r.bK(l), u_raster_elevation: new r.bM(l), u_zoom_transition: new r.bM(l), u_merc_center: new r.bK(l), u_cutoff_params: new r.ca(l), u_colorization_mix: new r.ca(l), u_colorization_offset: new r.bM(l), u_color_ramp: new r.bN(l), u_texture_offset: new r.bK(l), u_texture_res: new r.bK(l), u_emissive_strength: new r.bM(l) }), rasterParticle: (l) => ({ u_matrix: new r.bJ(l), u_normalize_matrix: new r.bJ(l), u_globe_matrix: new r.bJ(l), u_merc_matrix: new r.bJ(l), u_grid_matrix: new r.cA(l), u_tl_parent: new r.bK(l), u_scale_parent: new r.bM(l), u_fade_t: new r.bM(l), u_opacity: new r.bM(l), u_image0: new r.bN(l), u_image1: new r.bN(l), u_raster_elevation: new r.bM(l), u_zoom_transition: new r.bM(l), u_merc_center: new r.bK(l), u_cutoff_params: new r.ca(l) }), rasterParticleTexture: (l) => ({ u_texture: new r.bN(l), u_opacity: new r.bM(l) }), rasterParticleDraw: (l) => ({ u_particle_texture: new r.bN(l), u_particle_texture_side_len: new r.bM(l), u_tile_offset: new r.bK(l), u_velocity: new r.bN(l), u_color_ramp: new r.bN(l), u_velocity_res: new r.bK(l), u_max_speed: new r.bM(l), u_uv_offset: new r.bK(l), u_data_scale: new r.bK(l), u_data_offset: new r.bM(l), u_particle_pos_scale: new r.bM(l), u_particle_pos_offset: new r.bK(l) }), rasterParticleUpdate: (l) => ({ u_particle_texture: new r.bN(l), u_particle_texture_side_len: new r.bM(l), u_velocity: new r.bN(l), u_velocity_res: new r.bK(l), u_max_speed: new r.bM(l), u_speed_factor: new r.bM(l), u_reset_rate: new r.bM(l), u_rand_seed: new r.bM(l), u_uv_offset: new r.bK(l), u_data_scale: new r.bK(l), u_data_offset: new r.bM(l), u_particle_pos_scale: new r.bM(l), u_particle_pos_offset: new r.bK(l) }), symbol: (l) => ({ u_is_size_zoom_constant: new r.bN(l), u_is_size_feature_constant: new r.bN(l), u_size_t: new r.bM(l), u_size: new r.bM(l), u_camera_to_center_distance: new r.bM(l), u_rotate_symbol: new r.bN(l), u_aspect_ratio: new r.bM(l), u_fade_change: new r.bM(l), u_matrix: new r.bJ(l), u_label_plane_matrix: new r.bJ(l), u_coord_matrix: new r.bJ(l), u_is_text: new r.bN(l), u_elevation_from_sea: new r.bN(l), u_pitch_with_map: new r.bN(l), u_texsize: new r.bK(l), u_texsize_icon: new r.bK(l), u_texture: new r.bN(l), u_texture_icon: new r.bN(l), u_gamma_scale: new r.bM(l), u_device_pixel_ratio: new r.bM(l), u_tile_id: new r.bL(l), u_zoom_transition: new r.bM(l), u_inv_rot_matrix: new r.bJ(l), u_merc_center: new r.bK(l), u_camera_forward: new r.bL(l), u_tile_matrix: new r.bJ(l), u_up_vector: new r.bL(l), u_ecef_origin: new r.bL(l), u_is_halo: new r.bN(l), u_icon_transition: new r.bM(l), u_color_adj_mat: new r.bJ(l), u_scale_factor: new r.bM(l) }), background: (l) => ({ u_matrix: new r.bJ(l), u_emissive_strength: new r.bM(l), u_opacity: new r.bM(l), u_color: new r.cz(l) }), backgroundPattern: (l) => ({ u_matrix: new r.bJ(l), u_emissive_strength: new r.bM(l), u_opacity: new r.bM(l), u_image: new r.bN(l), u_pattern_tl: new r.bK(l), u_pattern_br: new r.bK(l), u_texsize: new r.bK(l), u_pattern_size: new r.bK(l), u_pixel_coord_upper: new r.bK(l), u_pixel_coord_lower: new r.bK(l), u_pattern_units_to_pixels: new r.bK(l) }), terrainRaster: (l) => ({ u_matrix: new r.bJ(l), u_image0: new r.bN(l), u_skirt_height: new r.bM(l), u_ground_shadow_factor: new r.bL(l) }), skybox: (l) => ({ u_matrix: new r.bJ(l), u_sun_direction: new r.bL(l), u_cubemap: new r.bN(l), u_opacity: new r.bM(l), u_temporal_offset: new r.bM(l) }), skyboxGradient: (l) => ({ u_matrix: new r.bJ(l), u_color_ramp: new r.bN(l), u_center_direction: new r.bL(l), u_radius: new r.bM(l), u_opacity: new r.bM(l), u_temporal_offset: new r.bM(l) }), skyboxCapture: (l) => ({ u_matrix_3f: new r.cA(l), u_sun_direction: new r.bL(l), u_sun_intensity: new r.bM(l), u_color_tint_r: new r.ca(l), u_color_tint_m: new r.ca(l), u_luminance: new r.bM(l) }), globeRaster: (l) => ({ u_proj_matrix: new r.bJ(l), u_globe_matrix: new r.bJ(l), u_normalize_matrix: new r.bJ(l), u_merc_matrix: new r.bJ(l), u_zoom_transition: new r.bM(l), u_merc_center: new r.bK(l), u_image0: new r.bN(l), u_grid_matrix: new r.cA(l), u_skirt_height: new r.bM(l), u_far_z_cutoff: new r.bM(l), u_frustum_tl: new r.bL(l), u_frustum_tr: new r.bL(l), u_frustum_br: new r.bL(l), u_frustum_bl: new r.bL(l), u_globe_pos: new r.bL(l), u_globe_radius: new r.bM(l), u_viewport: new r.bK(l) }), globeAtmosphere: (l) => ({ u_frustum_tl: new r.bL(l), u_frustum_tr: new r.bL(l), u_frustum_br: new r.bL(l), u_frustum_bl: new r.bL(l), u_horizon: new r.bM(l), u_transition: new r.bM(l), u_fadeout_range: new r.bM(l), u_color: new r.ca(l), u_high_color: new r.ca(l), u_space_color: new r.ca(l), u_temporal_offset: new r.bM(l), u_horizon_angle: new r.bM(l) }), model: (l) => ({ u_matrix: new r.bJ(l), u_lighting_matrix: new r.bJ(l), u_normal_matrix: new r.bJ(l), u_node_matrix: new r.bJ(l), u_lightpos: new r.bL(l), u_lightintensity: new r.bM(l), u_lightcolor: new r.bL(l), u_camera_pos: new r.bL(l), u_opacity: new r.bM(l), u_baseColorFactor: new r.ca(l), u_emissiveFactor: new r.ca(l), u_metallicFactor: new r.bM(l), u_roughnessFactor: new r.bM(l), u_baseTextureIsAlpha: new r.bN(l), u_alphaMask: new r.bN(l), u_alphaCutoff: new r.bM(l), u_baseColorTexture: new r.bN(l), u_metallicRoughnessTexture: new r.bN(l), u_normalTexture: new r.bN(l), u_occlusionTexture: new r.bN(l), u_emissionTexture: new r.bN(l), u_lutTexture: new r.bN(l), u_color_mix: new r.ca(l), u_aoIntensity: new r.bM(l), u_emissive_strength: new r.bM(l), u_occlusionTextureTransform: new r.ca(l) }), modelDepth: (l) => ({ u_matrix: new r.bJ(l), u_instance: new r.bJ(l), u_node_matrix: new r.bJ(l) }), groundShadow: (l) => ({ u_matrix: new r.bJ(l), u_ground_shadow_factor: new r.bL(l) }), stars: (l) => ({ u_matrix: new r.bJ(l), u_up: new r.bL(l), u_right: new r.bL(l), u_intensity_multiplier: new r.bM(l) }), snowParticle: (l) => ({ u_modelview: new r.bJ(l), u_projection: new r.bJ(l), u_time: new r.bM(l), u_cam_pos: new r.bL(l), u_velocityConeAperture: new r.bM(l), u_velocity: new r.bM(l), u_horizontalOscillationRadius: new r.bM(l), u_horizontalOscillationRate: new r.bM(l), u_boxSize: new r.bM(l), u_billboardSize: new r.bM(l), u_simpleShapeParameters: new r.bK(l), u_screenSize: new r.bK(l), u_thinningCenterPos: new r.bK(l), u_thinningShape: new r.bL(l), u_thinningAffectedRatio: new r.bM(l), u_thinningParticleOffset: new r.bM(l), u_particleColor: new r.ca(l), u_direction: new r.bL(l) }), rainParticle: (l) => ({ u_modelview: new r.bJ(l), u_projection: new r.bJ(l), u_time: new r.bM(l), u_cam_pos: new r.bL(l), u_texScreen: new r.bN(l), u_velocityConeAperture: new r.bM(l), u_velocity: new r.bM(l), u_boxSize: new r.bM(l), u_rainDropletSize: new r.bK(l), u_distortionStrength: new r.bM(l), u_rainDirection: new r.bL(l), u_color: new r.ca(l), u_screenSize: new r.bK(l), u_thinningCenterPos: new r.bK(l), u_thinningShape: new r.bL(l), u_thinningAffectedRatio: new r.bM(l), u_thinningParticleOffset: new r.bM(l), u_shapeDirectionalPower: new r.bM(l), u_shapeNormalPower: new r.bM(l), u_mode: new r.bM(l) }), vignette: (l) => ({ u_vignetteShape: new r.bL(l), u_vignetteColor: new r.ca(l) }), occlusion: (l) => ({ u_matrix: new r.bJ(l), u_anchorPos: new r.bL(l), u_screenSizePx: new r.bK(l), u_occluderSizePx: new r.bK(l), u_color: new r.ca(l) }) };
        class go {
          constructor(t, n, u, d) {
            this.id = go.uniqueIdxCounter, go.uniqueIdxCounter++, this.context = t;
            const _ = t.gl;
            this.buffer = _.createBuffer(), this.dynamicDraw = !!u, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), _.bufferData(_.ELEMENT_ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || d || n.destroy();
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t) {
            this.id = go.uniqueIdxCounter, go.uniqueIdxCounter++;
            const n = this.context.gl;
            this.context.unbindVAO(), this.bind(), n.bufferSubData(n.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        go.uniqueIdxCounter = 0;
        const ja = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class yo {
          constructor(t, n, u, d, _, v) {
            this.length = n.length, this.attributes = u, this.itemSize = n.bytesPerElement, this.dynamicDraw = d, this.instanceCount = v, this.context = t;
            const L = t.gl;
            this.buffer = L.createBuffer(), t.bindVertexBuffer.set(this.buffer), L.bufferData(L.ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? L.DYNAMIC_DRAW : L.STATIC_DRAW), this.dynamicDraw || _ || n.destroy();
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t) {
            const n = this.context.gl;
            this.bind(), n.bufferSubData(n.ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          enableAttributes(t, n) {
            for (let u = 0; u < this.attributes.length; u++) {
              const d = n.attributes[this.attributes[u].name];
              d !== void 0 && t.enableVertexAttribArray(d);
            }
          }
          setVertexAttribPointers(t, n, u) {
            for (let d = 0; d < this.attributes.length; d++) {
              const _ = this.attributes[d], v = n.attributes[_.name];
              v !== void 0 && t.vertexAttribPointer(v, _.components, t[ja[_.type]], !1, this.itemSize, _.offset + this.itemSize * (u || 0));
            }
          }
          setVertexAttribDivisor(t, n, u) {
            for (let d = 0; d < this.attributes.length; d++) {
              const _ = n.attributes[this.attributes[d].name];
              _ !== void 0 && this.instanceCount && this.instanceCount > 0 && t.vertexAttribDivisor(_, u);
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class cc {
          constructor(t, n, u, d, _) {
            this.context = t, this.width = n, this.height = u;
            const v = this.framebuffer = t.gl.createFramebuffer();
            d && (this.colorAttachment = new Ks(t, v)), _ && (this.depthAttachmentType = _, this.depthAttachment = _ === "renderbuffer" ? new Fh(t, v) : new Af(t, v));
          }
          destroy() {
            const t = this.context.gl;
            if (this.colorAttachment) {
              const n = this.colorAttachment.get();
              n && t.deleteTexture(n);
            }
            if (this.depthAttachment && this.depthAttachmentType) if (this.depthAttachmentType === "renderbuffer") {
              const n = this.depthAttachment.get();
              n && t.deleteRenderbuffer(n);
            } else {
              const n = this.depthAttachment.get();
              n && t.deleteTexture(n);
            }
            t.deleteFramebuffer(this.framebuffer);
          }
        }
        class Hh {
          constructor(t, n) {
            this.gl = t, this.clearColor = new Uc(this), this.clearDepth = new jc(this), this.clearStencil = new Ln(this), this.colorMask = new ic(this), this.depthMask = new nc(this), this.stencilMask = new _u(this), this.stencilFunc = new Sf(this), this.stencilOp = new Ml(this), this.stencilTest = new ws(this), this.depthRange = new ac(this), this.depthTest = new _a(this), this.depthFunc = new Vc(this), this.blend = new Gc(this), this.blendFunc = new Hc(this), this.blendColor = new Wc(this), this.blendEquation = new gu(this), this.cullFace = new Al(this), this.cullFaceSide = new oc(this), this.frontFace = new sc(this), this.program = new yu(this), this.activeTexture = new Zc(this), this.viewport = new Tf(this), this.bindFramebuffer = new Il(this), this.bindRenderbuffer = new fd(this), this.bindTexture = new dd(this), this.bindVertexBuffer = new Bh(this), this.bindElementBuffer = new Ys(this), this.bindVertexArrayOES = new Mf(this), this.pixelStoreUnpack = new vu(this), this.pixelStoreUnpackPremultiplyAlpha = new Mo(this), this.pixelStoreUnpackFlipY = new Cl(this), this.options = n ? Object.assign({}, n) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = t.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = t.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = t.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = n && !!n.forceManualRenderingForInstanceIDShaders || this.renderer && this.renderer.indexOf("PowerVR") !== -1, this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = t.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.maxPointSize = t.getParameter(t.ALIASED_POINT_SIZE_RANGE)[1];
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(t, n, u) {
            return new go(this, t, n, u);
          }
          createVertexBuffer(t, n, u, d, _) {
            return new yo(this, t, n, u, d, _);
          }
          createRenderbuffer(t, n, u) {
            const d = this.gl, _ = d.createRenderbuffer();
            return this.bindRenderbuffer.set(_), d.renderbufferStorage(d.RENDERBUFFER, t, n, u), this.bindRenderbuffer.set(null), _;
          }
          createFramebuffer(t, n, u, d) {
            return new cc(this, t, n, u, d);
          }
          clear({ color: t, depth: n, stencil: u, colorMask: d }) {
            const _ = this.gl;
            let v = 0;
            t && (v |= _.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set(d || [!0, !0, !0, !0])), n !== void 0 && (v |= _.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(n), this.depthMask.set(!0)), u !== void 0 && (v |= _.STENCIL_BUFFER_BIT, this.clearStencil.set(u), this.stencilMask.set(255)), _.clear(v);
          }
          setCullFace(t) {
            t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));
          }
          setDepthMode(t) {
            t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);
          }
          setStencilMode(t) {
            t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(t) {
            r.bn(t.blendFunction, zi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor), t.blendEquation ? this.blendEquation.set(t.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t.mask);
          }
          unbindVAO() {
            this.bindVertexArrayOES.set(null);
          }
        }
        let rs;
        function Bl(l, t, n, u, d, _, v) {
          const L = l.context, G = L.gl, X = l.transform, K = l.getOrCreateProgram("collisionBox"), ae = [];
          let oe = 0, pe = 0;
          for (let st = 0; st < u.length; st++) {
            const xt = u[st], mt = t.getTile(xt), _t = mt.getBucket(n);
            if (!_t) continue;
            const dt = zo(xt, _t, X);
            let gt = dt;
            d[0] === 0 && d[1] === 0 || (gt = l.translatePosMatrix(dt, mt, d, _));
            const Rt = v ? _t.textCollisionBox : _t.iconCollisionBox, Jt = _t.collisionCircleArray;
            if (Jt.length > 0) {
              const Vt = r.ab.mat4.create(), or = gt;
              r.ab.mat4.mul(Vt, _t.placementInvProjMatrix, X.glCoordMatrix), r.ab.mat4.mul(Vt, Vt, _t.placementViewportMatrix), ae.push({ circleArray: Jt, circleOffset: pe, transform: or, invTransform: Vt, projection: _t.getProjection() }), oe += Jt.length / 4, pe = oe;
            }
            Rt && (l.terrain && l.terrain.setupElevationDraw(mt, K), K.draw(l, G.LINES, ui.disabled, _i.disabled, l.colorModeForRenderPass(), vi.disabled, $c(gt, X, mt, _t.getProjection()), n.id, Rt.layoutVertexBuffer, Rt.indexBuffer, Rt.segments, null, X.zoom, null, [Rt.collisionVertexBuffer, Rt.collisionVertexBufferExt]));
          }
          if (!v || !ae.length) return;
          const Be = l.getOrCreateProgram("collisionCircle"), Re = new r.cV();
          Re.resize(4 * oe), Re._trim();
          let Ge = 0;
          for (const st of ae) for (let xt = 0; xt < st.circleArray.length / 4; xt++) {
            const mt = 4 * xt, _t = st.circleArray[mt + 0], dt = st.circleArray[mt + 1], gt = st.circleArray[mt + 2], Rt = st.circleArray[mt + 3];
            Re.emplace(Ge++, _t, dt, gt, Rt, 0), Re.emplace(Ge++, _t, dt, gt, Rt, 1), Re.emplace(Ge++, _t, dt, gt, Rt, 2), Re.emplace(Ge++, _t, dt, gt, Rt, 3);
          }
          (!rs || rs.length < 2 * oe) && (rs = function(st) {
            const xt = 2 * st, mt = new r.aU();
            mt.resize(xt), mt._trim();
            for (let _t = 0; _t < xt; _t++) {
              const dt = 6 * _t;
              mt.uint16[dt + 0] = 4 * _t + 0, mt.uint16[dt + 1] = 4 * _t + 1, mt.uint16[dt + 2] = 4 * _t + 2, mt.uint16[dt + 3] = 4 * _t + 2, mt.uint16[dt + 4] = 4 * _t + 3, mt.uint16[dt + 5] = 4 * _t + 0;
            }
            return mt;
          }(oe));
          const Ve = L.createIndexBuffer(rs, !0), et = L.createVertexBuffer(Re, r.cW.members, !0);
          for (const st of ae) {
            const xt = { u_matrix: st.transform, u_inv_matrix: st.invTransform, u_camera_to_center_distance: (ut = X).getCameraToCenterDistance(st.projection), u_viewport_size: [ut.width, ut.height] };
            Be.draw(l, G.TRIANGLES, ui.disabled, _i.disabled, l.colorModeForRenderPass(), vi.disabled, xt, n.id, et, Ve, r.b7.simpleSegment(0, 2 * st.circleOffset, st.circleArray.length, st.circleArray.length / 2), null, X.zoom);
          }
          var ut;
          et.destroy(), Ve.destroy();
        }
        const wu = r.ab.mat4.create();
        function to(l) {
          const t = l._camera.getWorldToCamera(l.worldSize, 1), n = r.ab.mat4.multiply([], t, l.globeMatrix);
          r.ab.mat4.invert(n, n);
          const u = [0, 0, 0], d = [0, 1, 0, 0];
          return r.ab.vec4.transformMat4(d, d, n), u[0] = d[0], u[1] = d[1], u[2] = d[2], r.ab.vec3.normalize(u, u), u;
        }
        function sn({ width: l, height: t, anchor: n, textOffset: u, textScale: d }, _) {
          const { horizontalAlign: v, verticalAlign: L } = r.bD(n), G = -(v - 0.5) * l, X = -(L - 0.5) * t, K = r.bC(n, u);
          return new r.P((G / d + K[0]) * _, (X / d + K[1]) * _);
        }
        function hc(l, t, n, u, d, _, v, L, G, X, K) {
          const ae = l.text.placedSymbolArray, oe = l.text.dynamicLayoutVertexArray, pe = l.icon.dynamicLayoutVertexArray, Be = {}, Re = l.getProjection(), Ge = gs(L, Re, _), Ve = _.elevation, et = Re.upVectorScale(L.canonical, _.center.lat, _.worldSize).metersToTile;
          oe.clear();
          for (let ut = 0; ut < ae.length; ut++) {
            const st = ae.get(ut), { tileAnchorX: xt, tileAnchorY: mt, numGlyphs: _t } = st, dt = st.hidden || !st.crossTileID || l.allowVerticalPlacement && !st.placedOrientation ? null : u[st.crossTileID];
            if (dt) {
              let gt = 0, Rt = 0, Jt = 0;
              if (Ve) {
                const ir = Ve ? Ve.getAtTileOffset(L, xt, mt) : 0, [Tr, mr, hr] = Re.upVector(L.canonical, xt, mt);
                gt = ir * Tr * et, Rt = ir * mr * et, Jt = ir * hr * et;
              }
              let [Vt, or, sr, Bt] = Ta(st.projectedAnchorX + gt, st.projectedAnchorY + Rt, st.projectedAnchorZ + Jt, n ? Ge : v);
              const rr = gl(_.getCameraToCenterDistance(Re), Bt);
              let gr = d.evaluateSizeForFeature(l.textSizeData, X, st) * rr / r.bw;
              n && (gr *= l.tilePixelRatio / G);
              const Ut = sn(dt, gr);
              n ? ({ x: Vt, y: or, z: sr } = Re.projectTilePoint(xt + Ut.x, mt + Ut.y, L.canonical), [Vt, or, sr] = Ta(Vt + gt, or + Rt, sr + Jt, v)) : (t && Ut._rotate(-_.angle), Vt += Ut.x, or += Ut.y, sr = 0);
              const dr = l.allowVerticalPlacement && st.placedOrientation === r.bq.vertical ? Math.PI / 2 : 0;
              for (let ir = 0; ir < _t; ir++) r.bt(oe, Vt, or, sr, dr);
              K && st.associatedIconIndex >= 0 && (Be[st.associatedIconIndex] = { x: Vt, y: or, z: sr, angle: dr });
            } else An(_t, oe);
          }
          if (K) {
            pe.clear();
            const ut = l.icon.placedSymbolArray;
            for (let st = 0; st < ut.length; st++) {
              const xt = ut.get(st), { numGlyphs: mt } = xt, _t = Be[st];
              if (xt.hidden || !_t) An(mt, pe);
              else {
                const { x: dt, y: gt, z: Rt, angle: Jt } = _t;
                for (let Vt = 0; Vt < mt; Vt++) r.bt(pe, dt, gt, Rt, Jt);
              }
            }
            l.icon.dynamicLayoutVertexBuffer.updateData(pe);
          }
          l.text.dynamicLayoutVertexBuffer.updateData(oe);
        }
        function el(l, t, n, u, d, _, v = {}) {
          const L = n.paint.get("icon-translate"), G = n.paint.get("text-translate"), X = n.paint.get("icon-translate-anchor"), K = n.paint.get("text-translate-anchor"), ae = n.layout.get("icon-rotation-alignment"), oe = n.layout.get("text-rotation-alignment"), pe = n.layout.get("icon-pitch-alignment"), Be = n.layout.get("text-pitch-alignment"), Re = n.layout.get("icon-keep-upright"), Ge = n.layout.get("text-keep-upright"), Ve = n.paint.get("icon-color-saturation"), et = n.paint.get("icon-color-contrast"), ut = n.paint.get("icon-color-brightness-min"), st = n.paint.get("icon-color-brightness-max"), xt = n.layout.get("symbol-elevation-reference") === "sea", mt = l.context, _t = mt.gl, dt = l.transform, gt = ae === "map", Rt = oe === "map", Jt = pe === "map", Vt = Be === "map", or = n.layout.get("symbol-sort-key").constantOr(1) !== void 0;
          let sr = !1;
          const Bt = l.depthModeForSublayer(0, ui.ReadOnly), rr = [r.at(dt.center.lng), r.aA(dt.center.lat)], gr = n.layout.get("text-variable-anchor"), Ut = dt.projection.name === "globe", dr = [], ir = [0, -1, 0];
          for (const Tr of u) {
            const mr = t.getTile(Tr), hr = mr.getBucket(n);
            if (!hr || hr.projection.name === "mercator" && Ut || hr.fullyClipped) continue;
            const br = hr.projection.name === "globe", Cr = br ? r.ae(dt.zoom) : 0, Hr = gs(Tr, hr.getProjection(), dt), Zr = dt.calculatePixelsToTileUnitsMatrix(mr), mi = gr && hr.hasTextData(), ii = hr.hasIconTextFit() && mi && hr.hasIconData(), oi = hr.getProjection().createInversionMatrix(dt, Tr.canonical), yi = (Ki) => {
              dt.depthOcclusionForSymbolsAndCircles && (n.hasInitialOcclusionOpacityProperties || l.terrain) && (Ki.push("DEPTH_D24"), Ki.push("DEPTH_OCCLUSION"));
            }, Ui = () => {
              const Ki = gt && n.layout.get("symbol-placement") !== "point", Qi = [];
              yi(Qi);
              const Mn = Ki || ii, Pn = n.paint.get("icon-image-cross-fade").constantOr(0);
              l.terrainRenderModeElevated() && Jt && Qi.push("PITCH_WITH_MAP_TERRAIN"), br && (Qi.push("PROJECTION_GLOBE_VIEW"), Mn && Qi.push("PROJECTED_POS_ON_VIEWPORT")), Pn > 0 && Qi.push("ICON_TRANSITION"), hr.icon.zOffsetVertexBuffer && Qi.push("Z_OFFSET"), Ve === 0 && et === 0 && ut === 0 && st === 1 || Qi.push("COLOR_ADJUSTMENT"), hr.sdfIcons && Qi.push("RENDER_SDF");
              const Zn = hr.icon.programConfigurations.get(n.id), jn = l.getOrCreateProgram("symbol", { config: Zn, defines: Qi }), ya = mr.imageAtlasTexture ? mr.imageAtlasTexture.size : [0, 0], va = hr.iconSizeData, pn = r.bp(va, dt.zoom), hn = Jt || dt.pitch !== 0, ln = Kn(Hr, mr.tileID.canonical, Jt, gt, dt, hr.getProjection(), Zr), Vi = Ah(Hr, mr.tileID.canonical, Jt, gt, dt, hr.getProjection(), Zr), Rn = l.translatePosMatrix(Vi, mr, L, X, !0), ia = l.translatePosMatrix(Hr, mr, L, X), fn = Mn ? wu : ln, wa = gt && !Jt && !Ki;
              let xo = ir;
              !Ut && !dt.mercatorFromTransition || gt || (xo = to(dt));
              const fa = br ? xo : ir, Wa = n.getColorAdjustmentMatrix(Ve, et, ut, st), Za = Fn(va.kind, pn, wa, Jt, l, ia, fn, Rn, xt, !1, ya, [0, 0], !0, Tr, Cr, rr, oi, fa, hr.getProjection(), Wa, Pn), bo = mr.imageAtlasTexture ? mr.imageAtlasTexture : null, mn = n.layout.get("icon-size").constantOr(0) !== 1 || hr.iconsNeedLinear, Yl = hr.sdfIcons || l.options.rotating || l.options.zooming || mn || hn ? _t.LINEAR : _t.NEAREST, Vo = hr.sdfIcons && n.paint.get("icon-halo-width").constantOr(1) !== 0, Kl = l.terrain && Jt && Ki ? r.ab.mat4.invert(r.ab.mat4.create(), ln) : wu;
              if (Ki && hr.icon) {
                const Bu = dt.elevation, Tc = Bu ? Bu.getAtTileOffsetFunc(Tr, dt.center.lat, dt.worldSize, hr.getProjection()) : null, dh = zn(Hr, mr.tileID.canonical, Jt, gt, dt, hr.getProjection(), Zr);
                Hu(hr, Hr, l, !1, dh, Vi, Jt, Re, Tc, Tr);
              }
              return { program: jn, buffers: hr.icon, uniformValues: Za, atlasTexture: bo, atlasTextureIcon: null, atlasInterpolation: Yl, atlasInterpolationIcon: null, isSDF: hr.sdfIcons, hasHalo: Vo, tile: mr, labelPlaneMatrixInv: Kl };
            }, tn = () => {
              const Ki = Rt && n.layout.get("symbol-placement") !== "point", Qi = [], Mn = Ki || gr || ii;
              l.terrainRenderModeElevated() && Vt && Qi.push("PITCH_WITH_MAP_TERRAIN"), br && (Qi.push("PROJECTION_GLOBE_VIEW"), Mn && Qi.push("PROJECTED_POS_ON_VIEWPORT")), hr.text.zOffsetVertexBuffer && Qi.push("Z_OFFSET"), hr.iconsInText && Qi.push("RENDER_TEXT_AND_SYMBOL"), Qi.push("RENDER_SDF"), yi(Qi);
              const Pn = hr.text.programConfigurations.get(n.id), Zn = l.getOrCreateProgram("symbol", { config: Pn, defines: Qi });
              let jn, ya = [0, 0], va = null;
              const pn = hr.textSizeData;
              hr.iconsInText && (ya = mr.imageAtlasTexture ? mr.imageAtlasTexture.size : [0, 0], va = mr.imageAtlasTexture ? mr.imageAtlasTexture : null, jn = Vt || dt.pitch !== 0 || l.options.rotating || l.options.zooming || pn.kind === "composite" || pn.kind === "camera" ? _t.LINEAR : _t.NEAREST);
              const hn = mr.glyphAtlasTexture ? mr.glyphAtlasTexture.size : [0, 0], ln = n.layout.get("text-size-scale-range"), Vi = r.aw(l.scaleFactor, ln[0], ln[1]), Rn = r.bp(pn, dt.zoom, Vi), ia = Kn(Hr, mr.tileID.canonical, Vt, Rt, dt, hr.getProjection(), Zr), fn = Ah(Hr, mr.tileID.canonical, Vt, Rt, dt, hr.getProjection(), Zr), wa = l.translatePosMatrix(fn, mr, G, K, !0), xo = l.translatePosMatrix(Hr, mr, G, K), fa = Mn ? wu : ia, Wa = Rt && !Vt && !Ki;
              let Za = ir;
              !Ut && !dt.mercatorFromTransition || Rt || (Za = to(dt));
              const bo = Fn(pn.kind, Rn, Wa, Vt, l, xo, fa, wa, xt, !0, hn, ya, !0, Tr, Cr, rr, oi, br ? Za : ir, hr.getProjection(), null, null, Vi), mn = mr.glyphAtlasTexture ? mr.glyphAtlasTexture : null, Yl = _t.LINEAR, Vo = n.paint.get("text-halo-width").constantOr(1) !== 0, Kl = l.terrain && Vt && Ki ? r.ab.mat4.invert(r.ab.mat4.create(), ia) : wu;
              if (Ki && hr.text) {
                const Bu = dt.elevation, Tc = Bu ? Bu.getAtTileOffsetFunc(Tr, dt.center.lat, dt.worldSize, hr.getProjection()) : null, dh = zn(Hr, mr.tileID.canonical, Vt, Rt, dt, hr.getProjection(), Zr);
                Hu(hr, Hr, l, !0, dh, fn, Vt, Ge, Tc, Tr);
              }
              return { program: Zn, buffers: hr.text, uniformValues: bo, atlasTexture: mn, atlasTextureIcon: va, atlasInterpolation: Yl, atlasInterpolationIcon: jn, isSDF: !0, hasHalo: Vo, tile: mr, labelPlaneMatrixInv: Kl };
            }, bn = hr.icon.segments.get().length, $i = hr.text.segments.get().length, xi = bn && !v.onlyText ? Ui() : null, Di = $i && !v.onlyIcons ? tn() : null, Yr = n.paint.get("icon-opacity").constantOr(1), Fi = n.paint.get("text-opacity").constantOr(1);
            if (or && hr.canOverlap) {
              sr = !0;
              const Ki = Yr && !v.onlyText ? hr.icon.segments.get() : [], Qi = Fi && !v.onlyIcons ? hr.text.segments.get() : [];
              for (const Mn of Ki) dr.push({ segments: new r.b7([Mn]), sortKey: Mn.sortKey, state: xi });
              for (const Mn of Qi) dr.push({ segments: new r.b7([Mn]), sortKey: Mn.sortKey, state: Di });
            } else v.onlyText || dr.push({ segments: Yr ? hr.icon.segments : new r.b7([]), sortKey: 0, state: xi }), v.onlyIcons || dr.push({ segments: Fi ? hr.text.segments : new r.b7([]), sortKey: 0, state: Di });
          }
          sr && dr.sort((Tr, mr) => Tr.sortKey - mr.sortKey);
          for (const Tr of dr) {
            const mr = Tr.state;
            if (mr) if (l.terrain ? l.terrain.setupElevationDraw(mr.tile, mr.program, { useDepthForOcclusion: dt.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: mr.labelPlaneMatrixInv }) : l.setupDepthForOcclusion(dt.depthOcclusionForSymbolsAndCircles, mr.program), mt.activeTexture.set(_t.TEXTURE0), mr.atlasTexture && mr.atlasTexture.bind(mr.atlasInterpolation, _t.CLAMP_TO_EDGE, !0), mr.atlasTextureIcon && (mt.activeTexture.set(_t.TEXTURE1), mr.atlasTextureIcon && mr.atlasTextureIcon.bind(mr.atlasInterpolationIcon, _t.CLAMP_TO_EDGE, !0)), l.uploadCommonLightUniforms(l.context, mr.program), mr.hasHalo) {
              const hr = mr.uniformValues;
              hr.u_is_halo = 1, Fl(mr.buffers, Tr.segments, n, l, mr.program, Bt, d, _, hr, 2), hr.u_is_halo = 0;
            } else {
              if (mr.isSDF) {
                const hr = mr.uniformValues;
                mr.hasHalo && (hr.u_is_halo = 1, Fl(mr.buffers, Tr.segments, n, l, mr.program, Bt, d, _, hr, 1)), hr.u_is_halo = 0;
              }
              Fl(mr.buffers, Tr.segments, n, l, mr.program, Bt, d, _, mr.uniformValues, 1);
            }
          }
        }
        function Fl(l, t, n, u, d, _, v, L, G, X) {
          const K = [l.dynamicLayoutVertexBuffer, l.opacityVertexBuffer, l.iconTransitioningVertexBuffer, l.globeExtVertexBuffer, l.zOffsetVertexBuffer];
          d.draw(u, u.context.gl.TRIANGLES, _, v, L, vi.disabled, G, n.id, l.layoutVertexBuffer, l.indexBuffer, t, n.paint, u.transform.zoom, l.programConfigurations.get(n.id), K, X);
        }
        function tl(l, t, n, u, d, _, v) {
          const L = l.context.gl, G = n.paint.get("fill-pattern"), X = n.is3D(), K = X ? l.stencilModeFor3D() : _i.disabled, ae = G && G.constantOr(1);
          let oe, pe, Be, Re, Ge;
          v ? (pe = ae && !n.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", oe = L.LINES) : (pe = ae ? "fillPattern" : "fill", oe = L.TRIANGLES);
          for (const Ve of u) {
            const et = t.getTile(Ve);
            if (ae && !et.patternsLoaded()) continue;
            const ut = et.getBucket(n);
            if (!ut) continue;
            l.prepareDrawTile();
            const st = ut.programConfigurations.get(n.id), xt = l.isTileAffectedByFog(Ve), mt = l.getOrCreateProgram(pe, { config: st, overrideFog: xt });
            ae && (l.context.activeTexture.set(L.TEXTURE0), et.imageAtlasTexture && et.imageAtlasTexture.bind(L.LINEAR, L.CLAMP_TO_EDGE), st.updatePaintBuffers());
            const _t = G.constantOr(null);
            if (_t && et.imageAtlas) {
              const Rt = et.imageAtlas, Jt = r.A.from(_t).getPrimary().scaleSelf(r.q.devicePixelRatio).serialize(), Vt = Rt.patternPositions[Jt];
              Vt && st.setConstantPatternPositions(Vt);
            }
            const dt = l.translatePosMatrix(Ve.projMatrix, et, n.paint.get("fill-translate"), n.paint.get("fill-translate-anchor")), gt = n.paint.get("fill-emissive-strength");
            if (v) {
              Re = ut.indexBuffer2, Ge = ut.segments2;
              const Rt = l.terrain && l.terrain.renderingToTexture ? l.terrain.drapeBufferSize : [L.drawingBufferWidth, L.drawingBufferHeight];
              Be = pe === "fillOutlinePattern" && ae ? zl(dt, gt, l, et, Rt) : Qs(dt, gt, Rt);
            } else Re = ut.indexBuffer, Ge = ut.segments, Be = ae ? Po(dt, gt, l, et) : lc(dt, gt);
            l.uploadCommonUniforms(l.context, mt, Ve.toUnwrapped()), mt.draw(l, oe, d, X ? K : l.stencilModeForClipping(Ve), _, vi.disabled, Be, n.id, ut.layoutVertexBuffer, Re, Ge, n.paint, l.transform.zoom, st, void 0);
          }
        }
        function Nl(l, t, n, u, d, _, v, L) {
          n.resetLayerRenderingStats(l);
          const G = l.context, X = G.gl, K = l.transform, ae = n.paint.get("fill-extrusion-pattern"), oe = ae.constantOr(1), pe = n.paint.get("fill-extrusion-opacity"), Be = l.style.enable3dLights(), Re = n.paint.get(Be && !oe ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), Ge = [n.paint.get("fill-extrusion-ambient-occlusion-intensity"), Re], Ve = n.layout.get("fill-extrusion-edge-radius"), et = Ve > 0 && !n.paint.get("fill-extrusion-rounded-roof"), ut = et ? 0 : Ve, st = K.projection.name === "globe" ? r.d3() : 0, xt = K.projection.name === "globe", mt = xt ? r.ae(K.zoom) : 0, _t = [r.at(K.center.lng), r.aA(K.center.lat)], dt = n.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none", gt = n.paint.get("fill-extrusion-flood-light-color").toRenderColor(dt ? null : n.lut).toArray01().slice(0, 3), Rt = n.paint.get("fill-extrusion-flood-light-intensity"), Jt = n.paint.get("fill-extrusion-vertical-scale"), Vt = n.paint.get("fill-extrusion-line-width").constantOr(1) !== 0, or = n.paint.get("fill-extrusion-height-alignment"), sr = n.paint.get("fill-extrusion-base-alignment"), Bt = To(l, n.paint.get("fill-extrusion-cutoff-fade-range")), rr = [];
          let gr;
          xt && rr.push("PROJECTION_GLOBE_VIEW"), Ge[0] > 0 && rr.push("FAUX_AO"), et && rr.push("ZERO_ROOF_RADIUS"), L && rr.push("HAS_CENTROID"), Rt > 0 && rr.push("FLOOD_LIGHT"), Bt.shouldRenderCutoff && rr.push("RENDER_CUTOFF"), Vt && rr.push("RENDER_WALL_MODE");
          const Ut = l.renderPass === "shadow", dr = l.shadowRenderer, ir = Ut && !!dr;
          l.shadowRenderer && (l.shadowRenderer.useNormalOffset = !0);
          let Tr = [0, 0, 0];
          if (dr) {
            const br = l.style.directionalLight, Cr = l.style.ambientLight;
            br && Cr && (Tr = Ku(l.style, br, Cr)), Ut || (rr.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), dr.useNormalOffset && rr.push("NORMAL_OFFSET")), gr = rr.concat(["SHADOWS_SINGLE_CASCADE"]);
          }
          const mr = ir ? "fillExtrusionDepth" : oe ? "fillExtrusionPattern" : "fillExtrusion", hr = n.getLayerRenderingStats();
          for (const br of u) {
            const Cr = t.getTile(br), Hr = Cr.getBucket(n);
            if (!Hr || Hr.projection.name !== K.projection.name) continue;
            let Zr = !1;
            dr && (Zr = dr.getMaxCascadeForTile(br.toUnwrapped()) === 0);
            const mi = l.isTileAffectedByFog(br), ii = Hr.programConfigurations.get(n.id), oi = l.getOrCreateProgram(mr, { config: ii, defines: Zr ? gr : rr, overrideFog: mi });
            if (l.terrain && l.terrain.setupElevationDraw(Cr, oi, { useMeterToDem: !0 }), !Hr.centroidVertexBuffer) {
              const Di = oi.attributes.a_centroid_pos;
              Di !== void 0 && X.vertexAttrib2f(Di, 0, 0);
            }
            !Ut && dr && dr.setupShadows(Cr.tileID.toUnwrapped(), oi, "vector-tile", Cr.tileID.overscaledZ), oe && (l.context.activeTexture.set(X.TEXTURE0), Cr.imageAtlasTexture && Cr.imageAtlasTexture.bind(X.LINEAR, X.CLAMP_TO_EDGE), ii.updatePaintBuffers());
            const yi = ae.constantOr(null);
            if (yi && Cr.imageAtlas) {
              const Di = Cr.imageAtlas, Yr = r.A.from(yi).getPrimary().scaleSelf(r.q.devicePixelRatio), Fi = Di.patternPositions[Yr.serialize()];
              Fi && ii.setConstantPatternPositions(Fi);
            }
            const Ui = n.paint.get("fill-extrusion-vertical-gradient"), tn = 1 / Hr.tileToMeter;
            let bn;
            if (Ut && dr) {
              if (Ro(Cr.tileID, Hr, l)) continue;
              const Di = dr.calculateShadowPassMatrixFromTile(Cr.tileID.toUnwrapped());
              bn = kl(Di, ut, tn, Jt, or, sr);
            } else {
              const Di = l.translatePosMatrix(br.expandedProjMatrix, Cr, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor")), Yr = K.projection.createInversionMatrix(K, br.canonical);
              bn = oe ? jh(Di, l, Ui, pe, Ge, ut, tn, br, Cr, st, or, sr, mt, _t, Yr, gt, Jt) : Dl(Di, l, Ui, pe, Ge, ut, tn, br, st, or, sr, mt, _t, Yr, gt, Jt, Rt, Tr);
            }
            l.uploadCommonUniforms(G, oi, br.toUnwrapped(), null, Bt);
            let $i = Hr.segments;
            if (K.projection.name === "mercator" && !Ut && ($i = Hr.getVisibleSegments(Cr.tileID, l.terrain, l.transform.getFrustum(0)), !$i.get().length)) continue;
            if (hr) if (Ut) for (const Di of $i.get()) hr.numRenderedVerticesInShadowPass += Di.primitiveLength;
            else for (const Di of $i.get()) hr.numRenderedVerticesInTransparentPass += Di.primitiveLength;
            const xi = [];
            (l.terrain || L) && xi.push(Hr.centroidVertexBuffer), xt && xi.push(Hr.layoutVertexExtBuffer), Vt && xi.push(Hr.wallVertexBuffer), oi.draw(l, G.gl.TRIANGLES, d, _, v, vi.backCCW, bn, n.id, Hr.layoutVertexBuffer, Hr.indexBuffer, $i, n.paint, l.transform.zoom, ii, xi);
          }
          l.shadowRenderer && (l.shadowRenderer.useNormalOffset = !1);
        }
        function rl(l, t, n, u, d, _, v, L, G, X, K, ae, oe, pe, Be, Re, Ge, Ve, et) {
          const ut = l.context, st = ut.gl, xt = l.transform, mt = l.transform.zoom, _t = [], dt = To(l, n.paint.get("fill-extrusion-cutoff-fade-range"));
          X === "clear" ? (_t.push("CLEAR_SUBPASS"), et && (_t.push("CLEAR_FROM_TEXTURE"), ut.activeTexture.set(st.TEXTURE0), et.bind(st.LINEAR, st.CLAMP_TO_EDGE))) : X === "sdf" && _t.push("SDF_SUBPASS"), Ge && _t.push("HAS_CENTROID"), dt.shouldRenderCutoff && _t.push("RENDER_CUTOFF");
          const gt = n.layout.get("fill-extrusion-edge-radius"), Rt = (Jt, Vt, or, sr, Bt) => {
            const rr = Vt.programConfigurations.get(n.id), gr = l.isTileAffectedByFog(Jt), Ut = l.getOrCreateProgram("fillExtrusionGroundEffect", { config: rr, defines: _t, overrideFog: gr }), dr = /* @__PURE__ */ ((Tr, mr, hr, br, Cr, Hr, Zr, mi, ii, oi, yi) => ({ u_matrix: mr, u_opacity: hr, u_ao_pass: br ? 1 : 0, u_meter_to_tile: Cr, u_ao: Hr, u_flood_light_intensity: Zr, u_flood_light_color: mi, u_attenuation: ii, u_edge_radius: oi, u_fb: 0, u_fb_size: yi, u_dynamic_offset: 1 }))(0, sr, K, G, Bt, [ae, oe * Bt], pe, Be, Re, mt >= 17 ? 0 : gt * Bt, et ? et.size[0] : 0), ir = [];
            Ge && ir.push(Vt.hiddenByLandmarkVertexBuffer), l.uploadCommonUniforms(ut, Ut, Jt.toUnwrapped(), null, dt), Ut.draw(l, ut.gl.TRIANGLES, d, _, v, L, dr, n.id, Vt.vertexBuffer, Vt.indexBuffer, or, n.paint, mt, rr, ir);
          };
          for (const Jt of u) {
            const Vt = t.getTile(Jt), or = Vt.getBucket(n);
            if (!or || or.projection.name !== xt.projection.name || !or.groundEffect || or.groundEffect && !or.groundEffect.hasData()) continue;
            const sr = or.groundEffect, Bt = 1 / or.tileToMeter;
            {
              const rr = l.translatePosMatrix(Jt.projMatrix, Vt, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor")), gr = sr.getDefaultSegment();
              Rt(Jt, sr, gr, rr, Bt);
            }
            if (Ve) for (let rr = 0; rr < 4; rr++) {
              const gr = r.d4[rr](Jt), Ut = t.getTile(gr);
              if (!Ut) continue;
              const dr = Ut.getBucket(n);
              if (!dr || dr.projection.name !== xt.projection.name || !dr.groundEffect || dr.groundEffect && !dr.groundEffect.hasData()) continue;
              const ir = dr.groundEffect;
              let Tr, mr;
              rr === 0 ? (Tr = [-r.ag, 0, 0], mr = 1) : rr === 1 ? (Tr = [r.ag, 0, 0], mr = 0) : rr === 2 ? (Tr = [0, -r.ag, 0], mr = 3) : (Tr = [0, r.ag, 0], mr = 2);
              const hr = ir.regionSegments[mr];
              if (!hr) continue;
              const br = new Float32Array(16);
              r.ab.mat4.translate(br, Jt.projMatrix, Tr), Rt(Jt, ir, hr, l.translatePosMatrix(br, Vt, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor")), Bt);
            }
          }
        }
        function il(l, t, n, u, d, _, v) {
          u.centroidVertexArray.length === 0 && u.createCentroidsBuffer();
          const L = _ ? _.findDEMTileFor(n) : null;
          if (!(L && L.dem || v)) return;
          _ && L && L.dem && u.selfDEMTileTimestamp !== L.dem._timestamp && (u.borderDoneWithNeighborZ = [-1, -1, -1, -1], u.selfDEMTileTimestamp = L.dem._timestamp);
          const G = (Ve) => new r.P(Math.ceil((Ve + r.d7) * r.d8), 0), X = (Ve) => {
            const et = t.getSource().minzoom, ut = (xt) => {
              const mt = t.getTileByID(xt);
              if (mt && mt.hasData()) return mt.getBucket(d);
            }, st = [0, -1, 1];
            for (const xt of st) {
              if (Ve.overscaledZ + xt < et) continue;
              const mt = ut(Ve.calculateScaledKey(Ve.overscaledZ + xt));
              if (mt) return mt;
            }
          }, K = [0, 0, 0], ae = (Ve, et) => (K[0] = Math.min(Ve.min.y, et.min.y), K[1] = Math.max(Ve.max.y, et.max.y), K[2] = r.ag - et.min.x > Ve.max.x ? et.min.x - r.ag : Ve.max.x, K), oe = (Ve, et) => (K[0] = Math.min(Ve.min.x, et.min.x), K[1] = Math.max(Ve.max.x, et.max.x), K[2] = r.ag - et.min.y > Ve.max.y ? et.min.y - r.ag : Ve.max.y, K), pe = [(Ve, et) => ae(Ve, et), (Ve, et) => ae(et, Ve), (Ve, et) => oe(Ve, et), (Ve, et) => oe(et, Ve)], Be = (Ve, et, ut, st, xt, mt, _t) => {
            if (!_) return 0;
            const dt = [[mt ? ut : Ve, mt ? Ve : ut, 0], [mt ? ut : et, mt ? et : ut, 0]], gt = _t < 0 ? r.ag + _t : _t, Rt = [mt ? gt : (Ve + et) / 2, mt ? (Ve + et) / 2 : gt, 0];
            return ut === 0 && _t < 0 || ut !== 0 && _t > 0 ? _.getForTilePoints(xt, [Rt], !0, st) : dt.push(Rt), _.getForTilePoints(n, dt, !0, L), Math.max(dt[0][2], dt[1][2], Rt[2]) / _.exaggeration();
          };
          for (let Ve = 0; Ve < 4; Ve++) {
            const et = u.borderFeatureIndices[Ve];
            if (et.length === 0) continue;
            const ut = r.d4[Ve](n), st = X(ut);
            if (!(st && st instanceof r.d5)) continue;
            const xt = _ ? _.findDEMTileFor(ut) : null;
            if (!(xt && xt.dem || v) || (_ && xt && xt.dem && u.borderDEMTileTimestamp[Ve] !== xt.dem._timestamp && (u.borderDoneWithNeighborZ[Ve] = -1, u.borderDEMTileTimestamp[Ve] = xt.dem._timestamp), u.borderDoneWithNeighborZ[Ve] === st.canonical.z)) continue;
            st.centroidVertexArray.length === 0 && st.createCentroidsBuffer();
            const mt = (Ve < 2 ? 1 : 5) - Ve, _t = st.borderDoneWithNeighborZ[mt] !== u.canonical.z, dt = st.borderFeatureIndices[mt];
            let gt = 0;
            if (u.canonical.z !== st.canonical.z) {
              for (const Rt of et) u.showCentroid(u.featuresOnBorder[Rt]);
              if (_t) for (const Rt of dt) st.showCentroid(st.featuresOnBorder[Rt]);
              u.borderDoneWithNeighborZ[Ve] = st.canonical.z, st.borderDoneWithNeighborZ[mt] = u.canonical.z;
            }
            for (const Rt of et) {
              const Jt = u.featuresOnBorder[Rt], Vt = u.centroidData[Jt.centroidDataIndex], or = Jt.borders[Ve];
              let sr;
              for (; gt < dt.length; ) {
                sr = st.featuresOnBorder[dt[gt]];
                const Bt = sr.borders[mt];
                if (Bt[1] > or[0] + 3 || Bt[0] > or[0] - 3) break;
                st.showCentroid(sr), gt++;
              }
              if (sr && gt < dt.length) {
                const Bt = gt;
                let rr = 0;
                for (; !(sr.borders[mt][0] > or[1] - 3) && (rr++, ++gt !== dt.length); ) sr = st.featuresOnBorder[dt[gt]];
                sr = st.featuresOnBorder[dt[Bt]];
                let gr = !1;
                if (rr >= 1) {
                  const ir = sr.borders[mt];
                  Math.abs(or[0] - ir[0]) < 3 && Math.abs(or[1] - ir[1]) < 3 && (rr = 1, gr = !0, gt = Bt + 1);
                } else if (rr === 0) {
                  u.showCentroid(Jt);
                  continue;
                }
                const Ut = st.centroidData[sr.centroidDataIndex];
                v && gr && (((Re = Vt).flags | (Ge = Ut).flags) & r.d6 ? (Re.flags |= r.d6, Ge.flags |= r.d6) : (Re.flags &= ~r.d6, Ge.flags &= ~r.d6));
                const dr = Jt.intersectsCount() > 1 || sr.intersectsCount() > 1;
                if (rr > 1) gt = Bt, Vt.centroidXY = Ut.centroidXY = new r.P(0, 0);
                else if (xt && xt.dem && !dr) {
                  const ir = pe[Ve](Vt, Ut), Tr = Ve % 2 ? r.ag - 1 : 0, mr = Be(ir[0], Math.min(r.ag - 1, ir[1]), Tr, xt, ut, Ve < 2, ir[2]);
                  Vt.centroidXY = Ut.centroidXY = G(mr);
                } else dr ? Vt.centroidXY = Ut.centroidXY = new r.P(0, 0) : (Vt.centroidXY = u.encodeBorderCentroid(Jt), Ut.centroidXY = st.encodeBorderCentroid(sr));
                u.writeCentroidToBuffer(Vt), st.writeCentroidToBuffer(Ut);
              } else u.showCentroid(Jt);
            }
            u.borderDoneWithNeighborZ[Ve] = st.canonical.z, st.borderDoneWithNeighborZ[mt] = u.canonical.z;
          }
          var Re, Ge;
          (u.needsCentroidUpdate || !u.centroidVertexBuffer && u.centroidVertexArray.length !== 0) && u.uploadCentroid(l);
        }
        const nl = [1, 0, 0], Mr = [0, 1, 0], Nr = [0, 0, 1];
        function Ro(l, t, n) {
          const u = n.transform, d = n.shadowRenderer;
          if (!d) return !0;
          const _ = l.toUnwrapped(), v = u.tileSize * d._cascades[n.currentShadowCascade].scale;
          let L = t.maxHeight;
          if (u.elevation) {
            const Re = u.elevation.getMinMaxForTile(l);
            Re && (L += Re.max);
          }
          const G = [...d.shadowDirection];
          G[2] = -G[2];
          const X = d.computeSimplifiedTileShadowVolume(_, L, v, G);
          if (!X) return !1;
          const K = [nl, Mr, Nr, G, [G[0], 0, G[2]], [0, G[1], G[2]]], ae = u.projection.name === "globe", oe = u.scaleZoom(v), pe = r.bR.fromInvProjectionMatrix(u.invProjMatrix, u.worldSize, oe, !ae), Be = d.getCurrentCascadeFrustum();
          return pe.intersectsPrecise(X.vertices, X.planes, K) === 0 || Be.intersectsPrecise(X.vertices, X.planes, K) === 0;
        }
        function vn(l) {
          return [l[0] * r.d9, l[1] * r.d9, l[2] * r.d9, 0];
        }
        function Kt(l, t, n, u, d, _, v, L, G) {
          const X = u.getSource(), K = n.globeSharedBuffers;
          if (!K) return;
          let ae, oe, pe;
          if (t && (ae = u.getTile(t)), X instanceof r.aJ ? (oe = X.texture, pe = r.cI(0, 0, n.transform)) : ae && t && (oe = ae.texture, pe = r.cI(t.canonical.z, t.canonical.x, n.transform)), !oe || !pe) return;
          l || (pe = r.ab.mat4.scale(r.ab.mat4.create(), pe, [1, -1, 1]));
          const Be = n.context, Re = Be.gl, Ge = d.paint.get("raster-resampling") === "nearest" ? Re.NEAREST : Re.LINEAR, Ve = n.colorModeForDrapableLayerRenderPass(_), et = v.defines;
          et.push("GLOBE_POLES");
          const ut = new ui(Re.LEQUAL, ui.ReadWrite, n.depthRangeFor3D), st = Float32Array.from(n.transform.expandedFarZProjMatrix), xt = Float32Array.from(r.bb(r.cH(new r.bT(0, 0, 0))));
          n.terrain && n.terrain.prepareDrawTile(), Be.activeTexture.set(Re.TEXTURE0), oe.bind(Ge, Re.CLAMP_TO_EDGE), Be.activeTexture.set(Re.TEXTURE1), oe.bind(Ge, Re.CLAMP_TO_EDGE), oe.useMipmap && Be.extTextureFilterAnisotropic && n.transform.pitch > 20 && Re.texParameterf(Re.TEXTURE_2D, Be.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Be.extTextureFilterAnisotropicMax);
          const [mt, _t, dt, gt] = t ? K.getPoleBuffers(t.canonical.z, !1) : K.getPoleBuffers(0, !0), Rt = d.paint.get("raster-elevation");
          let Jt;
          l ? (Jt = mt, n.renderDefaultNorthPole = Rt !== 0) : (Jt = _t, n.renderDefaultSouthPole = Rt !== 0);
          const Vt = vn(v.mix), or = ((Bt, rr, gr, Ut, dr, ir, Tr, mr, hr, br, Cr, Hr, Zr) => Ra(Bt, rr, gr, new Float32Array(16), new Float32Array(9), [0, 0], Ut, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, ir, [0, 0], mr, 2, br, Cr, Hr, 1, 0, Zr))(st, xt, pe, r.ae(n.transform.zoom), 0, d, 0, Rt, 0, Vt, v.offset, v.range, _), sr = n.getOrCreateProgram("raster", { defines: et });
          n.uploadCommonUniforms(Be, sr, null), sr.draw(n, Re.TRIANGLES, ut, G, Ve, L, or, d.id, Jt, dt, gt);
        }
        function is(l) {
          const t = l._nearZ, n = l.projection.farthestPixelDistance(l), u = n - t, d = 0.2 * l.height, _ = t + d;
          return [t, n, (_ - d - t) / u, (_ - t) / u];
        }
        function No(l, t, n, u) {
          if (l) return t instanceof Yn && l instanceof ds ? t.getTextureDescriptor(l, n, !0) : { texture: l.texture, mix: vn(u.mix), offset: u.offset, buffer: 0, tileSize: 1 };
        }
        var fc = r.da([{ name: "a_index", type: "Int16", components: 1 }]);
        class Wh {
          constructor(t, n, u, d) {
            const _ = { width: u[0], height: u[1], data: null }, v = t.gl;
            this.targetColorTexture = new r.T(t, _, v.RGBA8, { useMipmap: !1 }), this.backgroundColorTexture = new r.T(t, _, v.RGBA8, { useMipmap: !1 }), this.context = t, this.updateParticleTexture(n, d), this.lastInvalidatedAt = 0;
          }
          updateParticleTexture(t, n) {
            if (this.particleTextureDimension === n.width) return;
            (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
            const u = this.context.gl, d = n.width * n.height;
            this.particleTexture0 = new r.T(this.context, n, u.RGBA8, { premultiply: !1, useMipmap: !1 }), this.particleTexture1 = new r.T(this.context, n, u.RGBA8, { premultiply: !1, useMipmap: !1 });
            const _ = new r.db();
            _.reserve(d);
            for (let v = 0; v < d; v++) _.emplaceBack(v);
            this.particleIndexBuffer = this.context.createVertexBuffer(_, fc.members, !0), this.particleSegment = r.b7.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = n.width;
          }
          update(t) {
            return !(this.lastInvalidatedAt < t && (this.lastInvalidatedAt = r.q.now(), 1));
          }
          destroy() {
            this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
          }
        }
        function ns(l, t, n) {
          if (!l) return null;
          const u = t.getTextureDescriptor(l, n, !0);
          if (!u) return null;
          let { texture: d, mix: _, offset: v, tileSize: L, buffer: G, format: X } = u;
          if (!d || !X) return null;
          let K = !1;
          return X === "uint32" && (K = !0, _[3] = 0, _ = Ts(r.dc, _, [0, n.paint.get("raster-particle-max-speed")]), v = Fo(r.dc, v, [0, n.paint.get("raster-particle-max-speed")])), { texture: d, textureOffset: [G / (L + 2 * G), L / (L + 2 * G)], tileSize: L, scalarData: K, scale: _, offset: v, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[X]] };
        }
        function Ms(l) {
          const t = l._nearZ, n = l.projection.farthestPixelDistance(l), u = n - t, d = 0.2 * l.height, _ = t + d;
          return [t, n, (_ - d - t) / u, (_ - t) / u];
        }
        const As = new r.aj(1, 0, 0, 1), If = new r.aj(0, 1, 0, 1), Kc = new r.aj(0, 0, 1, 1), Zh = new r.aj(1, 0, 1, 1), al = new r.aj(0, 1, 1, 1);
        function Aa(l, t, n, u, d, _, v) {
          const L = l.context, G = l.transform, X = L.gl, K = G.projection.name === "globe", ae = K ? ["PROJECTION_GLOBE_VIEW"] : [];
          let oe = r.ab.mat4.clone(n.projMatrix);
          if (K && r.ae(G.zoom) > 0) {
            const Vt = r.ba(n.canonical, G), or = r.dd(Vt);
            oe = r.ab.mat4.multiply(new Float32Array(16), G.globeMatrix, or), r.ab.mat4.multiply(oe, G.projMatrix, oe);
          }
          const pe = r.ab.mat4.create();
          pe[12] += 2 * d / (r.q.devicePixelRatio * G.width), pe[13] += 2 * _ / (r.q.devicePixelRatio * G.height), r.ab.mat4.multiply(oe, pe, oe);
          const Be = l.getOrCreateProgram("debug", { defines: ae }), Re = t.getTileByID(n.key);
          l.terrain && l.terrain.setupElevationDraw(Re, Be);
          const Ge = ui.disabled, Ve = _i.disabled, et = l.colorModeForRenderPass(), ut = "$debug";
          L.activeTexture.set(X.TEXTURE0), l.emptyTexture.bind(X.LINEAR, X.CLAMP_TO_EDGE), K ? Re._makeGlobeTileDebugBuffers(l.context, G) : Re._makeDebugTileBoundsBuffers(l.context, G.projection);
          const st = Re._tileDebugBuffer || l.debugBuffer, xt = Re._tileDebugIndexBuffer || l.debugIndexBuffer, mt = Re._tileDebugSegments || l.debugSegments;
          if (Be.draw(l, X.LINE_STRIP, Ge, Ve, et, vi.disabled, ts(oe, u), ut, st, xt, mt, null, null, null, [Re._globeTileDebugBorderBuffer]), v) {
            const Vt = Re.latestRawTileData, or = Math.floor((Vt && Vt.byteLength || 0) / 1024);
            let sr = n.canonical.toString();
            n.overscaledZ !== n.canonical.z && (sr += ` => ${n.overscaledZ}`), sr += ` ${Re.state}`, sr += ` ${or}kb`, function(Bt, rr) {
              Bt.initDebugOverlayCanvas();
              const gr = Bt.debugOverlayCanvas, Ut = Bt.context.gl, dr = Bt.debugOverlayCanvas.getContext("2d");
              dr.clearRect(0, 0, gr.width, gr.height), dr.shadowColor = "white", dr.shadowBlur = 2, dr.lineWidth = 1.5, dr.strokeStyle = "white", dr.textBaseline = "top", dr.font = "bold 36px Open Sans, sans-serif", dr.fillText(rr, 5, 5), dr.strokeText(rr, 5, 5), Bt.debugOverlayTexture.update(gr), Bt.debugOverlayTexture.bind(Ut.LINEAR, Ut.CLAMP_TO_EDGE);
            }(l, sr);
          }
          const _t = t.getTile(n).tileSize, dt = 512 / Math.min(_t, 512) * (n.overscaledZ / G.zoom) * 0.5, gt = Re._tileDebugTextBuffer || l.debugBuffer, Rt = Re._tileDebugTextIndexBuffer || l.quadTriangleIndexBuffer, Jt = Re._tileDebugTextSegments || l.debugSegments;
          Be.draw(l, X.TRIANGLES, Ge, Ve, zi.alphaBlended, vi.disabled, ts(oe, r.aj.transparent, dt), ut, gt, Rt, Jt, null, null, null, [Re._globeTileDebugTextBuffer]);
        }
        function Ul(l, t, n, u) {
          vo(l, 0, t + n / 2, l.transform.width, n, u);
        }
        function jl(l, t, n, u) {
          vo(l, t - n / 2, 0, n, l.transform.height, u);
        }
        function vo(l, t, n, u, d, _) {
          const v = l.context, L = v.gl;
          L.enable(L.SCISSOR_TEST), L.scissor(t * r.q.devicePixelRatio, n * r.q.devicePixelRatio, u * r.q.devicePixelRatio, d * r.q.devicePixelRatio), v.clear({ color: _ }), L.disable(L.SCISSOR_TEST);
        }
        const Eu = r.da([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Va } = Eu;
        function as(l, t, n, u) {
          l.emplaceBack(t, n, u);
        }
        class Jc {
          constructor(t) {
            this.vertexArray = new r.de(), this.indices = new r.aU(), as(this.vertexArray, -1, -1, 1), as(this.vertexArray, 1, -1, 1), as(this.vertexArray, -1, 1, 1), as(this.vertexArray, 1, 1, 1), as(this.vertexArray, -1, -1, -1), as(this.vertexArray, 1, -1, -1), as(this.vertexArray, -1, 1, -1), as(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, Va), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = r.b7.simpleSegment(0, 0, 36, 12);
          }
        }
        function rn(l, t, n, u, d, _) {
          const v = l.context.gl, L = t.paint.get("sky-atmosphere-color"), G = t.paint.get("sky-atmosphere-halo-color"), X = t.paint.get("sky-atmosphere-sun-intensity"), K = ((ae, oe, pe, Be, Re) => ({ u_matrix_3f: ae, u_sun_direction: oe, u_sun_intensity: pe, u_color_tint_r: [Be.r, Be.g, Be.b, Be.a], u_color_tint_m: [Re.r, Re.g, Re.b, Re.a], u_luminance: 5e-5 }))(r.ab.mat3.fromMat4(r.ab.mat3.create(), u), d, X, L, G);
          v.framebufferTexture2D(v.FRAMEBUFFER, v.COLOR_ATTACHMENT0, v.TEXTURE_CUBE_MAP_POSITIVE_X + _, t.skyboxTexture, 0), n.draw(l, v.TRIANGLES, ui.disabled, _i.disabled, zi.unblended, vi.frontCW, K, "skyboxCapture", t.skyboxGeometry.vertexBuffer, t.skyboxGeometry.indexBuffer, t.skyboxGeometry.segment);
        }
        const Qc = r.da([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
        class Vl {
          constructor(t) {
            const n = new r.df();
            n.emplaceBack(-1, 1, 1, 0, 0), n.emplaceBack(1, 1, 1, 1, 0), n.emplaceBack(1, -1, 1, 1, 1), n.emplaceBack(-1, -1, 1, 0, 1);
            const u = new r.aU();
            u.emplaceBack(0, 1, 2), u.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(n, Qc.members), this.indexBuffer = t.createIndexBuffer(u), this.segments = r.b7.simpleSegment(0, 0, 4, 2);
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
          }
        }
        const dn = r.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
        class Yi {
          constructor() {
            this.starsCount = 16e3, this.sizeMultiplier = 0.15, this.sizeRange = 100, this.intensityRange = 200;
          }
        }
        class eh {
          constructor(t) {
            this.colorModeAlphaBlendedWriteRGB = new zi([1, xl, 1, xl], r.aj.transparent, [!0, !0, !0, !1]), this.colorModeWriteAlpha = new zi([1, 0, 1, 0], r.aj.transparent, [!1, !1, !1, !0]), this.params = new Yi(), this.updateNeeded = !0, t.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }, () => {
              this.updateNeeded = !0;
            }), t.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: 0.01, max: 2, step: 0.01 }), t.tp.registerParameter(this.params, ["Stars"], "sizeRange", { min: 0, max: 200, step: 1 }, () => {
              this.updateNeeded = !0;
            }), t.tp.registerParameter(this.params, ["Stars"], "intensityRange", { min: 0, max: 200, step: 1 }, () => {
              this.updateNeeded = !0;
            });
          }
          update(t) {
            const n = t.context;
            if (!this.atmosphereBuffer || this.updateNeeded) {
              this.updateNeeded = !1, this.atmosphereBuffer = new Vl(n);
              const u = this.params.sizeRange, d = this.params.intensityRange, _ = function(K) {
                const ae = r.di(30), oe = [];
                for (let pe = 0; pe < K; ++pe) {
                  const Be = 2 * Math.PI * ae(), Re = Math.acos(1 - 2 * ae()) - 0.5 * Math.PI;
                  oe.push(r.ab.vec3.fromValues(Math.cos(Re) * Math.cos(Be), Math.cos(Re) * Math.sin(Be), Math.sin(Re)));
                }
                return oe;
              }(this.params.starsCount), v = r.di(300), L = new r.dg(), G = new r.aU();
              let X = 0;
              for (let K = 0; K < _.length; ++K) {
                const ae = r.ab.vec3.scale([], _[K], 200), oe = Math.max(0, 1 + 0.01 * u * (1 * v() - 0.5)), pe = Math.max(0, 1 + 0.01 * d * (1 * v() - 0.5));
                L.emplaceBack(ae[0], ae[1], ae[2], -1, -1, oe, pe), L.emplaceBack(ae[0], ae[1], ae[2], 1, -1, oe, pe), L.emplaceBack(ae[0], ae[1], ae[2], 1, 1, oe, pe), L.emplaceBack(ae[0], ae[1], ae[2], -1, 1, oe, pe), G.emplaceBack(X + 0, X + 1, X + 2), G.emplaceBack(X + 0, X + 2, X + 3), X += 4;
              }
              this.starsVx = n.createVertexBuffer(L, dn.members), this.starsIdx = n.createIndexBuffer(G), this.starsSegments = r.b7.simpleSegment(0, 0, L.length, G.length);
            }
          }
          destroy() {
            this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
          }
          drawAtmosphereGlow(t, n) {
            const u = t.context, d = u.gl, _ = t.transform, v = new ui(d.LEQUAL, ui.ReadOnly, [0, 1]), L = r.ae(_.zoom), G = t.style.getLut(n.scope), X = n.properties.get("color-use-theme") === "none", K = n.properties.get("color").toRenderColor(X ? null : G).toArray01(), ae = n.properties.get("high-color-use-theme") === "none", oe = n.properties.get("high-color").toRenderColor(ae ? null : G).toArray01(), pe = n.properties.get("space-color-use-theme") === "none", Be = n.properties.get("space-color").toRenderColor(pe ? null : G).toArray01PremultipliedAlpha(), Re = 5e-4, Ge = r.dh(n.properties.get("horizon-blend"), 0, 1, Re, 0.25), Ve = r.cC(t, u, _) && Ge === Re ? _.worldSize / (2 * Math.PI * 1.025) - 1 : _.globeRadius, et = t.frameCounter / 1e3 % 1, ut = r.ab.vec3.length(_.globeCenterInViewSpace), st = Math.sqrt(Math.pow(ut, 2) - Math.pow(Ve, 2)), xt = Math.acos(st / ut), mt = (_t) => {
              const dt = _.projection.name === "globe" ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
              _t && dt.push("ALPHA_PASS");
              const gt = t.getOrCreateProgram("globeAtmosphere", { defines: dt }), Rt = /* @__PURE__ */ ((Vt, or, sr, Bt, rr, gr, Ut, dr, ir, Tr, mr, hr) => ({ u_frustum_tl: Vt, u_frustum_tr: or, u_frustum_br: sr, u_frustum_bl: Bt, u_horizon: rr, u_transition: gr, u_fadeout_range: Ut, u_color: dr, u_high_color: ir, u_space_color: Tr, u_temporal_offset: mr, u_horizon_angle: hr }))(_.frustumCorners.TL, _.frustumCorners.TR, _.frustumCorners.BR, _.frustumCorners.BL, _.frustumCorners.horizon, L, Ge, K, oe, Be, et, xt);
              t.uploadCommonUniforms(u, gt);
              const Jt = this.atmosphereBuffer;
              Jt && gt.draw(t, d.TRIANGLES, v, _i.disabled, _t ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, vi.backCW, Rt, _t ? "atmosphere_glow_alpha" : "atmosphere_glow", Jt.vertexBuffer, Jt.indexBuffer, Jt.segments);
            };
            mt(!1), mt(!0);
          }
          drawStars(t, n) {
            const u = r.aw(n.properties.get("star-intensity"), 0, 1);
            if (u === 0) return;
            const d = t.context, _ = d.gl, v = t.transform, L = t.getOrCreateProgram("stars"), G = r.ab.quat.identity([]);
            r.ab.quat.rotateX(G, G, -v._pitch), r.ab.quat.rotateZ(G, G, -v.angle), r.ab.quat.rotateX(G, G, r.ai(v._center.lat)), r.ab.quat.rotateY(G, G, -r.ai(v._center.lng));
            const X = r.ab.mat4.fromQuat(new Float32Array(16), G), K = r.ab.mat4.multiply([], v.starsProjMatrix, X), ae = r.ab.mat3.fromMat4([], X), oe = r.ab.mat3.invert([], ae), pe = [0, 1, 0];
            r.ab.vec3.transformMat3(pe, pe, oe), r.ab.vec3.scale(pe, pe, this.params.sizeMultiplier);
            const Be = [1, 0, 0];
            r.ab.vec3.transformMat3(Be, Be, oe), r.ab.vec3.scale(Be, Be, this.params.sizeMultiplier);
            const Re = (Ge = pe, Ve = Be, et = u, { u_matrix: Float32Array.from(K), u_up: Ge, u_right: Ve, u_intensity_multiplier: et });
            var Ge, Ve, et;
            t.uploadCommonUniforms(d, L), this.starsVx && this.starsIdx && L.draw(t, _.TRIANGLES, ui.disabled, _i.disabled, this.colorModeAlphaBlendedWriteRGB, vi.disabled, Re, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
          }
        }
        function Ga(l, t) {
          const n = [...l], u = t.cameraWorldSizeForFog / t.worldSize, d = r.ab.mat4.identity([]);
          return r.ab.mat4.scale(d, d, [u, u, 1]), r.ab.mat4.multiply(n, d, n), r.ab.mat4.multiply(n, t.worldToFogMatrix, n), n;
        }
        function In(l, t, n, u, d) {
          const _ = n.material, v = u.context, { baseColorTexture: L, metallicRoughnessTexture: G } = _.pbrMetallicRoughness, { normalTexture: X, occlusionTexture: K, emissionTexture: ae } = _;
          function oe(Be, Re, Ge) {
            if (Be && (l.push(Re), v.activeTexture.set(v.gl.TEXTURE0 + Ge), Be.gfxTexture)) {
              const { minFilter: Ve, magFilter: et, wrapS: ut, wrapT: st } = Be.sampler;
              Be.gfxTexture.bindExtraParam(Ve, et, ut, st);
            }
          }
          oe(L, "HAS_TEXTURE_u_baseColorTexture", xa.BaseColor), oe(G, "HAS_TEXTURE_u_metallicRoughnessTexture", xa.MetallicRoughness), oe(X, "HAS_TEXTURE_u_normalTexture", xa.Normal), oe(K, "HAS_TEXTURE_u_occlusionTexture", xa.Occlusion), oe(ae, "HAS_TEXTURE_u_emissionTexture", xa.Emission), d && (d.texture || (d.texture = new r.dk(u.context, d.image, [d.image.height, d.image.height, d.image.height], v.gl.RGBA8)), v.activeTexture.set(v.gl.TEXTURE0 + xa.LUT), d.texture && d.texture.bind(v.gl.LINEAR, v.gl.CLAMP_TO_EDGE), l.push("APPLY_LUT_ON_GPU")), n.texcoordBuffer && (l.push("HAS_ATTRIBUTE_a_uv_2f"), t.push(n.texcoordBuffer)), n.colorBuffer && (l.push(n.colorBuffer.itemSize === 12 ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), t.push(n.colorBuffer)), n.normalBuffer && (l.push("HAS_ATTRIBUTE_a_normal_3f"), t.push(n.normalBuffer)), n.pbrBuffer && (l.push("HAS_ATTRIBUTE_a_pbr"), l.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), t.push(n.pbrBuffer)), _.alphaMode !== "OPAQUE" && _.alphaMode !== "MASK" || l.push("UNPREMULT_TEXTURE_IN_SHADER"), _.defined || l.push("DIFFUSE_SHADED");
          const pe = u.shadowRenderer;
          pe && (l.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), pe.useNormalOffset && l.push("NORMAL_OFFSET"));
        }
        function Dn(l, t, n, u, d, _) {
          const v = n.paint.get("model-opacity").constantOr(1), L = t.context, G = new ui(t.context.gl.LEQUAL, ui.ReadWrite, t.depthRangeFor3D), X = t.transform, K = l.mesh, ae = K.material, oe = ae.pbrMetallicRoughness, pe = t.style.fog;
          let Be;
          Be = t.transform.projection.zAxisUnit === "pixels" ? [...l.nodeModelMatrix] : r.ab.mat4.multiply([], u.zScaleMatrix, l.nodeModelMatrix), r.ab.mat4.multiply(Be, u.negCameraPosMatrix, Be);
          const Re = r.ab.mat4.invert([], Be);
          r.ab.mat4.transpose(Re, Re);
          const Ge = n.paint.get("model-color-use-theme").constantOr("default") === "none", Ve = n.paint.get("model-emissive-strength").constantOr(0), et = Ol(new Float32Array(l.worldViewProjection), new Float32Array(Be), new Float32Array(Re), null, t, v, oe.baseColorFactor.toRenderColor(null), ae.emissiveFactor, oe.metallicFactor, oe.roughnessFactor, ae, Ve, n), ut = { defines: [] }, st = [], xt = t.shadowRenderer;
          xt && (xt.useNormalOffset = !1), In(ut.defines, st, K, t, Ge ? null : n.lut);
          let mt = null;
          if (pe) {
            const gt = Ga(l.nodeModelMatrix, t.transform);
            if (mt = new Float32Array(gt), X.projection.name !== "globe") {
              const Rt = K.aabb.min, Jt = K.aabb.max, [Vt, or] = pe.getOpacityForBounds(gt, Rt[0], Rt[1], Jt[0], Jt[1]);
              ut.overrideFog = Vt >= ft || or >= ft;
            }
          }
          const _t = To(t, n.paint.get("model-cutoff-fade-range"));
          _t.shouldRenderCutoff && ut.defines.push("RENDER_CUTOFF");
          const dt = t.getOrCreateProgram("model", ut);
          t.uploadCommonUniforms(L, dt, null, mt, _t), t.renderPass !== "shadow" && xt && xt.setupShadowsFromMatrix(l.nodeModelMatrix, dt), dt.draw(t, L.gl.TRIANGLES, G, d, _, K.material.doubleSided ? vi.disabled : vi.backCCW, et, n.id, K.vertexBuffer, K.indexBuffer, K.segments, n.paint, t.transform.zoom, void 0, st);
        }
        function ta(l, t, n, u, d, _, v) {
          let L;
          L = l.projection.name === "globe" ? r.dl(n, l) : [...n], r.ab.mat4.multiply(L, L, t.matrix);
          const G = r.ab.mat4.multiply([], u, L);
          if (t.meshes) for (const X of t.meshes) {
            if (X.material.alphaMode !== "BLEND") {
              v.push({ mesh: X, depth: 0, modelIndex: d, worldViewProjection: G, nodeModelMatrix: L });
              continue;
            }
            const K = r.ab.vec3.transformMat4([], X.centroid, G);
            !l.isOrthographic && K[2] <= 0 || _.push({ mesh: X, depth: K[2], modelIndex: d, worldViewProjection: G, nodeModelMatrix: L });
          }
          if (t.children) for (const X of t.children) ta(l, X, n, u, d, _, v);
        }
        function ol(l, t, n, u) {
          const d = n.shadowRenderer;
          if (!d) return;
          const _ = d.getShadowPassDepthMode(), v = d.getShadowPassColorMode(), L = d.calculateShadowPassMatrixFromMatrix(t), G = bu(L);
          n.getOrCreateProgram("modelDepth", { defines: n._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(n, n.context.gl.TRIANGLES, _, _i.disabled, v, vi.backCCW, G, u.id, l.vertexBuffer, l.indexBuffer, l.segments, u.paint, n.transform.zoom, void 0, void 0);
        }
        function ro(l, t, n) {
          const u = t.updateZoomBasedPaintProperties(), d = function(_, v, L) {
            let G, X, K, ae = _.terrain ? _.terrain.exaggeration() : 0;
            if (_.terrain && ae > 0) {
              const oe = _.terrain, pe = oe.findDEMTileFor(L);
              pe && pe.dem ? G = r.dn.create(oe, L, pe) : ae = 0;
            }
            if (ae === 0 && (v.terrainElevationMin = 0, v.terrainElevationMax = 0), ae === v.validForExaggeration && (ae === 0 || G && G._demTile && G._demTile.tileID === v.validForDEMTile.id && G._dem._timestamp === v.validForDEMTile.timestamp)) return !1;
            for (const oe in v.instancesPerModel) {
              const pe = v.instancesPerModel[oe];
              for (let Be = 0; Be < pe.instancedDataArray.length; ++Be) {
                const Re = (G ? ae * G.getElevationAt(0 | pe.instancedDataArray.float32[16 * Be], 0 | pe.instancedDataArray.float32[16 * Be + 1], !0, !0) : 0) + pe.instancesEvaluatedElevation[Be];
                pe.instancedDataArray.float32[16 * Be + 6] = Re, X = X ? Math.min(v.terrainElevationMin, Re) : Re, K = K ? Math.max(v.terrainElevationMax, Re) : Re;
              }
            }
            return v.terrainElevationMin = X || 0, v.terrainElevationMax = K || 0, v.validForExaggeration = ae, v.validForDEMTile = G && G._demTile ? { id: G._demTile.tileID, timestamp: G._dem._timestamp } : { id: void 0, timestamp: 0 }, !0;
          }(l, t, n);
          (u || d) && (t.uploaded = !1, t.upload(l.context));
        }
        const ra = { shadowUniformsInitialized: !1, useSingleShadowCascade: !1, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new r.cd([0, 0, 0], [r.ag, r.ag, 0]) };
        function th(l, t) {
          const n = 1 << l.canonical.z, u = t.getFreeCameraOptions().position, d = t.elevation, _ = l.canonical.x / n, v = (l.canonical.x + 1) / n, L = l.canonical.y / n, G = (l.canonical.y + 1) / n;
          let X = t._centerAltitude;
          if (d) {
            const pe = d.getMinMaxForTile(l);
            pe && pe.max > X && (X = pe.max);
          }
          const K = r.aw(u.x, _, v) - u.x, ae = r.aw(u.y, L, G) - u.y, oe = r.bH(X, t.center.lat) - u.z;
          return t._zoomFromMercatorZ(Math.sqrt(K * K + ae * ae + oe * oe));
        }
        function ca(l, t, n, u, d, _, v) {
          const L = l.context, G = l.renderPass === "shadow", X = l.shadowRenderer, K = G && X ? X.getShadowPassDepthMode() : new ui(L.gl.LEQUAL, ui.ReadWrite, l.depthRangeFor3D), ae = l.isTileAffectedByFog(_);
          if (n.meshes) for (const oe of n.meshes) {
            const pe = ["MODEL_POSITION_ON_GPU"], Be = [];
            let Re, Ge, Ve;
            u.instancedDataArray.length > 20 && pe.push("INSTANCED_ARRAYS");
            const et = To(l, t.paint.get("model-cutoff-fade-range"));
            if (et.shouldRenderCutoff && pe.push("RENDER_CUTOFF"), G && X) Re = l.getOrCreateProgram("modelDepth", { defines: pe }), Ge = bu(v.shadowTileMatrix, v.shadowTileMatrix, Float32Array.from(n.matrix)), Ve = X.getShadowPassColorMode();
            else {
              In(pe, Be, oe, l, t.paint.get("model-color-use-theme").constantOr("default") === "none" ? null : t.lut), Re = l.getOrCreateProgram("model", { defines: pe, overrideFog: ae });
              const st = oe.material, xt = st.pbrMetallicRoughness, mt = t.paint.get("model-opacity").constantOr(1), _t = t.paint.get("model-emissive-strength").constantOr(0);
              Ge = Ol(_.expandedProjMatrix, Float32Array.from(n.matrix), new Float32Array(16), null, l, mt, xt.baseColorFactor.toRenderColor(null), st.emissiveFactor, xt.metallicFactor, xt.roughnessFactor, st, _t, t, d), X && (v.shadowUniformsInitialized ? Re.setShadowUniformValues(L, X.getShadowUniformValues()) : (X.setupShadows(_.toUnwrapped(), Re, "model-tile", _.overscaledZ), v.shadowUniformsInitialized = !0)), Ve = et.shouldRenderCutoff || mt < 1 || st.alphaMode !== "OPAQUE" ? zi.alphaBlended : zi.unblended;
            }
            l.uploadCommonUniforms(L, Re, _.toUnwrapped(), null, et);
            const ut = oe.material.doubleSided ? vi.disabled : vi.backCCW;
            if (u.instancedDataArray.length > 20) Be.push(u.instancedDataBuffer), Re.draw(l, L.gl.TRIANGLES, K, _i.disabled, Ve, ut, Ge, t.id, oe.vertexBuffer, oe.indexBuffer, oe.segments, t.paint, l.transform.zoom, void 0, Be, u.instancedDataArray.length);
            else {
              const st = G ? "u_instance" : "u_normal_matrix";
              for (let xt = 0; xt < u.instancedDataArray.length; ++xt) Ge[st] = new Float32Array(u.instancedDataArray.arrayBuffer, 64 * xt, 16), Re.draw(l, L.gl.TRIANGLES, K, _i.disabled, Ve, ut, Ge, t.id, oe.vertexBuffer, oe.indexBuffer, oe.segments, t.paint, l.transform.zoom, void 0, Be);
            }
          }
          if (n.children) for (const oe of n.children) ca(l, t, oe, u, d, _, v);
        }
        const dc = [1, -1, 1];
        function pc(l, t, n, u) {
          if (!n.modelManager) return !0;
          const d = n.modelManager;
          if (!n.shadowRenderer) return !0;
          const _ = n.shadowRenderer, v = t.aabb;
          let L = !0, G = l.maxHeight;
          if (G === 0) {
            let K = 0;
            for (const ae in l.instancesPerModel) {
              const oe = d.getModel(ae, u);
              oe ? K = Math.max(K, Math.max(Math.max(oe.aabb.max[0], oe.aabb.max[1]), oe.aabb.max[2])) : L = !1;
            }
            G = l.maxScale * K * 1.41 + l.maxVerticalOffset, L && (l.maxHeight = G);
          }
          v.max[2] = G, v.min[2] += l.terrainElevationMin, v.max[2] += l.terrainElevationMax, r.ab.vec3.transformMat4(v.min, v.min, t.tileMatrix), r.ab.vec3.transformMat4(v.max, v.max, t.tileMatrix);
          const X = v.intersects(_.getCurrentCascadeFrustum());
          return n.currentShadowCascade === 0 && (l.isInsideFirstShadowMapFrustum = X === 2), X === 0;
        }
        function Is(l, t) {
          const n = l.uniformValues.u_cutoff_params[0], u = l.uniformValues.u_cutoff_params[1], d = l.uniformValues.u_cutoff_params[2], _ = l.uniformValues.u_cutoff_params[3];
          return u === n || _ === d ? 1 : r.aw(((t - n) / (u - n) - d) / (_ - d), 0, 1);
        }
        function Lo(l, t, n, u) {
          if (t.pitch < 20) return 1;
          const d = t.getWorldToCameraMatrix();
          r.ab.mat4.multiply(d, d, l);
          const _ = r.ab.vec4.fromValues(n.min[0], n.min[1], n.min[2], 1);
          let v = r.ab.vec4.transformMat4(r.ab.vec4.create(), _, d), L = v, G = v;
          _[1] = n.max[1], v = r.ab.vec4.transformMat4(r.ab.vec4.create(), _, d), L = v[1] < L[1] ? v : L, G = v[1] > G[1] ? v : G, _[0] = n.max[0], v = r.ab.vec4.transformMat4(r.ab.vec4.create(), _, d), L = v[1] < L[1] ? v : L, G = v[1] > G[1] ? v : G, _[1] = n.min[1], v = r.ab.vec4.transformMat4(r.ab.vec4.create(), _, d), L = v[1] < L[1] ? v : L, G = v[1] > G[1] ? v : G;
          const X = r.aw(u[0], 0, 1), K = 100 * t.pixelsPerMeter * r.aw(u[1], 0, 1), ae = r.aw(u[2], 0, 1), oe = r.ab.vec4.lerp(r.ab.vec4.create(), L, G, X), pe = Math.tan(0.5 * t.fovX), Be = -oe[2] * pe;
          if (K === 0) return oe[1] < -Math.abs(Be) ? ae : 1;
          const Re = (-Math.abs(Be) - oe[1]) / K, Ge = (et, ut, st) => (1 - st) * et + st * ut, Ve = r.aw(Ge(1, ae, Re), ae, 1);
          return Ge(1, Ve, r.aw((t.pitch - 20) / 20, 0, 1));
        }
        class ga {
        }
        class Gl {
          constructor() {
            this._storage = /* @__PURE__ */ new Map();
          }
          getLinesFromTrianglesBuffer(t, n, u) {
            {
              const ae = this._storage.get(n.id);
              if (ae) return ae.lastUsedFrameIdx = t, ae.buf;
            }
            const d = u.gl, _ = d.getBufferParameter(d.ELEMENT_ARRAY_BUFFER, d.BUFFER_SIZE), v = new ArrayBuffer(_), L = new Int16Array(v);
            d.getBufferSubData(d.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(v));
            const G = new r.dq();
            for (let ae = 0; ae < _ / 2; ae += 3) {
              const oe = L[ae], pe = L[ae + 1], Be = L[ae + 2];
              G.emplaceBack(oe, pe), G.emplaceBack(pe, Be), G.emplaceBack(Be, oe);
            }
            const X = u.bindVertexArrayOES.current, K = new ga();
            return K.buf = new go(u, G), K.lastUsedFrameIdx = t, this._storage.set(n.id, K), u.bindVertexArrayOES.set(X), K.buf;
          }
          update(t) {
            for (const [n, u] of this._storage) t - u.lastUsedFrameIdx > 30 && (u.buf.destroy(), this._storage.delete(n));
          }
          destroy() {
            for (const [t, n] of this._storage) n.buf.destroy(), this._storage.delete(t);
          }
        }
        class Su {
          constructor(t) {
            this.occluderSize = 30, this.depthOffset = -1e-4, t.registerParameter(this, ["Occlusion"], "occluderSize", { min: 1, max: 100, step: 1 }), t.registerParameter(this, ["Occlusion"], "depthOffset", { min: -0.05, max: 0, step: 1e-5 });
          }
        }
        const mc = r.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_rainParticleData", components: 4 }]);
        class rh {
          registerParameter() {
          }
          registerButton() {
          }
          registerBinding() {
          }
          refreshUI() {
          }
        }
        class ha {
          constructor(t, n) {
            this.revealStart = 11, this.revealRange = 2, t.registerParameter(this, [...n, "Reveal"], "revealStart", { min: 0, max: 17, step: 0.05 }), t.registerParameter(this, [...n, "Reveal"], "revealRange", { min: 0.1, max: 5.1, step: 0.05 });
          }
        }
        const ih = r.da([{ type: "Float32", name: "a_pos_2f", components: 2 }]);
        class nh {
          destroy() {
            this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();
          }
          draw(t, n) {
            const u = t.getOrCreateProgram("vignette");
            if (!this.vignetteVx || !this.vignetteIdx) {
              const v = new r.dr(), L = new r.aU();
              v.emplaceBack(-1, -1), v.emplaceBack(1, -1), v.emplaceBack(1, 1), v.emplaceBack(-1, 1), L.emplaceBack(0, 1, 2), L.emplaceBack(0, 2, 3), this.vignetteVx = t.context.createVertexBuffer(v, ih.members), this.vignetteIdx = t.context.createIndexBuffer(L);
            }
            const d = r.b7.simpleSegment(0, 0, 4, 6);
            if (this.vignetteVx && this.vignetteIdx) {
              t.uploadCommonUniforms(t.context, u);
              const v = { u_vignetteShape: (_ = { vignetteShape: [n.start, n.range, Math.pow(10, n.fadePower)], vignetteColor: [n.color.r, n.color.g, n.color.b, n.color.a * n.strength] }).vignetteShape, u_vignetteColor: _.vignetteColor };
              u.draw(t, t.context.gl.TRIANGLES, ui.disabled, _i.disabled, zi.alphaBlended, vi.disabled, v, "vignette", this.vignetteVx, this.vignetteIdx, d, {});
            }
            var _;
          }
        }
        class Tu {
          constructor() {
            this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
          }
          update(t, n) {
            const u = t.getFreeCameraOptions().position, d = u.toAltitude(), _ = u.toLngLat(), v = r.ai(_.lng), L = r.ai(_.lat), G = t.pixelsPerMeter / n, X = v * r.ds, K = r.ds * Math.log(Math.tan(Math.PI / 4 + L / 2));
            if (this._offsetXPrev === void 0) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
            else {
              const ae = -this._offsetYPrev + K, oe = -this._elevationPrev + d;
              this._accumulatedOffsetX += (-this._offsetXPrev + X) * G, this._accumulatedOffsetY += ae * G, this._accumulatedElevation += oe * G, this._offsetXPrev = X, this._offsetYPrev = K, this._elevationPrev = d;
            }
          }
          getPosition() {
            return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation];
          }
        }
        function Cs(l, t) {
          return [-(l[0] - Math.floor(l[0] / t) * t), -(l[1] - Math.floor(l[1] / t) * t), -(l[2] - Math.floor(l[2] / t) * t)];
        }
        function _c(l) {
          const t = r.di(1323123451230), n = [];
          for (let u = 0; u < l; ++u) {
            const d = 2 * t() - 1, _ = 2 * t() - 1, v = 2 * t() - 1;
            n.push(r.ab.vec3.fromValues(d, _, v));
          }
          return n;
        }
        function Uo(l, t, n, u, d) {
          const _ = r.aw((d - n) / (u - n), 0, 1);
          return (1 - _) * l + _ * t;
        }
        class sl {
          constructor(t) {
            this._movement = new Tu(), this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new nh(), this._ppmScaleFactor = t;
          }
          destroy() {
            this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();
          }
          updateOnRender(t, n) {
            const u = t.transform;
            this._movement.update(u, this._ppmScaleFactor);
            const d = u.starsProjMatrix, _ = r.ab.quat.identity([]);
            r.ab.quat.rotateX(_, _, r.ai(90) - u._pitch), r.ab.quat.rotateZ(_, _, -u.angle);
            const v = r.ab.mat4.fromQuat(new Float32Array(16), _), L = r.ab.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), G = r.ab.mat4.transpose([], L), X = r.ab.mat4.multiply([], G, v), K = Date.now() / 1e3;
            return this._accumulatedTimeFromStart += (K - this._prevTime) * n, this._prevTime = K, { projectionMatrix: d, modelviewMatrix: X };
          }
        }
        class Hl extends sl {
          constructor(t) {
            super(4.25), this._params = { overrideStyleParameters: !1, intensity: 0.5, timeFactor: 1, velocityConeAperture: 0, velocity: 300, boxSize: 2500, dropletSizeX: 1, dropletSizeYScale: 10, distortionStrength: 70, screenThinning: { intensity: 0.57, start: 0.46, range: 1.17, fadePower: 0.17, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 0.66, g: 0.68, b: 0.74, a: 0.7 }, direction: { x: -50, y: -35 }, shapeDirPower: 2, shapeNormalPower: 1 }, this._revealParams = new ha(t.tp, ["Precipitation", "Rain"]), this._vignetteParams = { strength: 1, start: 0.7, range: 1, fadePower: 0.4, color: { r: 0.27, g: 0.27, b: 0.27, a: 1 } }, this.particlesCount = 16e3;
          }
          update(t) {
            const n = t.context;
            if (!this.particlesVx) {
              const u = _c(this.particlesCount), d = new r.dt(), _ = new r.aU();
              let v = 0;
              const L = r.di(1323123451230);
              for (let G = 0; G < u.length; ++G) {
                const X = u[G], K = [2 * L() - 1, L(), L(), L()];
                d.emplaceBack(X[0], X[1], X[2], -1, -1, ...K), d.emplaceBack(X[0], X[1], X[2], 1, -1, ...K), d.emplaceBack(X[0], X[1], X[2], 1, 1, ...K), d.emplaceBack(X[0], X[1], X[2], -1, 1, ...K), _.emplaceBack(v + 0, v + 1, v + 2), _.emplaceBack(v + 0, v + 2, v + 3), v += 4;
              }
              this.particlesVx = n.createVertexBuffer(d, mc.members), this.particlesIdx = n.createIndexBuffer(_);
            }
          }
          draw(t) {
            if (!this._params.overrideStyleParameters && !t.style.rain) return;
            const n = this._params.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, u = t.transform.zoom;
            if (n.revealStart > u) return;
            const d = Uo(0, 1, n.revealStart, n.revealStart + n.revealRange, u);
            if (!this.particlesVx || !this.particlesIdx) return;
            const _ = structuredClone(this._params);
            let v = [-_.direction.x, _.direction.y, -100];
            r.ab.vec3.normalize(v, v);
            const L = structuredClone(this._vignetteParams);
            L.strength *= d, _.overrideStyleParameters || (_.intensity = t.style.rain.state.density, _.timeFactor = t.style.rain.state.intensity, _.color = structuredClone(t.style.rain.state.color), v = structuredClone(t.style.rain.state.direction), _.screenThinning.intensity = t.style.rain.state.centerThinning, _.dropletSizeX = t.style.rain.state.dropletSize[0], _.dropletSizeYScale = t.style.rain.state.dropletSize[1] / t.style.rain.state.dropletSize[0], _.distortionStrength = 100 * t.style.rain.state.distortionStrength, L.strength = 1, L.color = structuredClone(t.style.rain.state.vignetteColor));
            const G = this.updateOnRender(t, _.timeFactor), X = t.context, K = X.gl, ae = t.transform;
            this.screenTexture && this.screenTexture.size[0] === t.width && this.screenTexture.size[1] === t.height || (this.screenTexture = new r.T(X, { width: t.width, height: t.height, data: null }, K.RGBA8)), _.distortionStrength > 0 && (X.activeTexture.set(K.TEXTURE0), this.screenTexture.bind(K.LINEAR, K.CLAMP_TO_EDGE), K.copyTexSubImage2D(K.TEXTURE_2D, 0, 0, 0, 0, 0, t.width, t.height));
            const oe = t.getOrCreateProgram("rainParticle");
            t.uploadCommonUniforms(X, oe), X.activeTexture.set(K.TEXTURE0), this.screenTexture.bind(K.LINEAR, K.CLAMP_TO_EDGE);
            const pe = [_.color.r, _.color.g, _.color.b, _.color.a], Be = (Re, Ge) => {
              const Ve = Cs(this._movement.getPosition(), Re), et = _.dropletSizeX, ut = _.dropletSizeX * _.dropletSizeYScale, st = t.width / 2, xt = t.height / 2, mt = Uo(0, _.screenThinning.start, 0, 1, _.screenThinning.intensity), _t = Uo(1e-3, _.screenThinning.range, 0, 1, _.screenThinning.intensity), dt = Uo(0, _.screenThinning.particleOffset, 0, 1, _.screenThinning.intensity), gt = (Rt = { modelview: G.modelviewMatrix, projection: G.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: Ve, velocityConeAperture: _.velocityConeAperture, velocity: _.velocity, boxSize: Re, rainDropletSize: [et, ut], distortionStrength: _.distortionStrength, rainDirection: v, color: pe, screenSize: [ae.width, ae.height], thinningCenterPos: [st, xt], thinningShape: [mt, _t, Math.pow(10, _.screenThinning.fadePower)], thinningAffectedRatio: _.screenThinning.affectedRatio, thinningParticleOffset: dt, shapeDirectionalPower: _.shapeDirPower, shapeNormalPower: _.shapeNormalPower, mode: Ge ? 0 : 1 }, { u_modelview: Float32Array.from(Rt.modelview), u_projection: Float32Array.from(Rt.projection), u_time: Rt.time, u_cam_pos: Rt.camPos, u_texScreen: 0, u_velocityConeAperture: Rt.velocityConeAperture, u_velocity: Rt.velocity, u_boxSize: Rt.boxSize, u_rainDropletSize: Rt.rainDropletSize, u_distortionStrength: Rt.distortionStrength, u_rainDirection: Rt.rainDirection, u_color: Rt.color, u_screenSize: Rt.screenSize, u_thinningCenterPos: Rt.thinningCenterPos, u_thinningShape: Rt.thinningShape, u_thinningAffectedRatio: Rt.thinningAffectedRatio, u_thinningParticleOffset: Rt.thinningParticleOffset, u_shapeDirectionalPower: Rt.shapeDirectionalPower, u_shapeNormalPower: Rt.shapeNormalPower, u_mode: Rt.mode });
              var Rt;
              const Jt = Math.round(_.intensity * this.particlesCount), Vt = r.b7.simpleSegment(0, 0, 4 * Jt, 2 * Jt);
              oe.draw(t, K.TRIANGLES, ui.disabled, _i.disabled, zi.alphaBlended, vi.disabled, gt, "rain_particles", this.particlesVx, this.particlesIdx, Vt, {});
            };
            _.distortionStrength > 0 && Be(_.boxSize, !0), Be(_.boxSize, !1), this._vignette.draw(t, L);
          }
        }
        const Mu = r.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_snowParticleData", components: 4 }, { type: "Float32", name: "a_snowParticleDataHorizontalOscillation", components: 2 }]);
        class Au extends sl {
          constructor(t) {
            super(2.25), this._params = { overrideStyleParameters: !1, intensity: 0.85, timeFactor: 0.75, velocityConeAperture: 70, velocity: 40, horizontalOscillationRadius: 4, horizontalOscillationRate: 1.5, boxSize: 2e3, billboardSize: 2, shapeFadeStart: 0.27, shapeFadePower: 0.21, screenThinning: { intensity: 0.4, start: 0.15, range: 1.4, fadePower: 0.24, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 1, g: 1, b: 1, a: 1 }, direction: { x: -50, y: -35 } }, this._revealParams = new ha(t.tp, ["Precipitation", "Snow"]), this._vignetteParams = { strength: 0.3, start: 0.78, range: 0.46, fadePower: 0.2, color: { r: 1, g: 1, b: 1, a: 1 } }, this.particlesCount = 16e3;
          }
          update(t) {
            const n = t.context;
            if (!this.particlesVx) {
              const u = _c(this.particlesCount), d = new r.du(), _ = new r.aU();
              let v = 0;
              const L = r.di(1323123451230);
              for (let G = 0; G < u.length; ++G) {
                const X = u[G], K = L(), ae = L(), oe = L(), pe = [G / u.length, K, ae, oe], Be = [L(), L()];
                d.emplaceBack(X[0], X[1], X[2], -1, -1, ...pe, ...Be), d.emplaceBack(X[0], X[1], X[2], 1, -1, ...pe, ...Be), d.emplaceBack(X[0], X[1], X[2], 1, 1, ...pe, ...Be), d.emplaceBack(X[0], X[1], X[2], -1, 1, ...pe, ...Be), _.emplaceBack(v + 0, v + 1, v + 2), _.emplaceBack(v + 0, v + 2, v + 3), v += 4;
              }
              this.particlesVx = n.createVertexBuffer(d, Mu.members), this.particlesIdx = n.createIndexBuffer(_);
            }
          }
          draw(t) {
            if (!this._params.overrideStyleParameters && !t.style.snow) return;
            const n = structuredClone(this._params);
            let u = [-n.direction.x, n.direction.y, -100];
            r.ab.vec3.normalize(u, u);
            const d = structuredClone(this._vignetteParams), _ = n.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, v = t.transform.zoom;
            if (_.revealStart > v) return;
            const L = Uo(0, 1, _.revealStart, _.revealStart + _.revealRange, v);
            d.strength *= L, n.overrideStyleParameters || (n.intensity = t.style.snow.state.density, n.timeFactor = t.style.snow.state.intensity, n.color = structuredClone(t.style.snow.state.color), u = structuredClone(t.style.snow.state.direction), n.screenThinning.intensity = t.style.snow.state.centerThinning, n.billboardSize = 2.79 * t.style.snow.state.flakeSize, d.strength = 1, d.color = structuredClone(t.style.snow.state.vignetteColor));
            const G = this.updateOnRender(t, n.timeFactor);
            if (!this.particlesVx || !this.particlesIdx) return;
            const X = t.context, K = X.gl, ae = t.transform, oe = t.getOrCreateProgram("snowParticle");
            t.uploadCommonUniforms(X, oe), ((pe, Be, Re) => {
              const Ge = Cs(this._movement.getPosition(), pe), Ve = ae.width / 2, et = ae.height / 2, ut = Uo(0, Re.screenThinning.start, 0, 1, Re.screenThinning.intensity), st = Uo(1e-3, Re.screenThinning.range, 0, 1, Re.screenThinning.intensity), xt = Uo(0, Re.screenThinning.particleOffset, 0, 1, Re.screenThinning.intensity), mt = (_t = { modelview: G.modelviewMatrix, projection: G.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: Ge, velocityConeAperture: Re.velocityConeAperture, velocity: Re.velocity, horizontalOscillationRadius: Re.horizontalOscillationRadius, horizontalOscillationRate: Re.horizontalOscillationRate, boxSize: pe, billboardSize: 1 * Re.billboardSize, simpleShapeParameters: [Re.shapeFadeStart, Re.shapeFadePower], screenSize: [ae.width, ae.height], thinningCenterPos: [Ve, et], thinningShape: [ut, st, Math.pow(10, Re.screenThinning.fadePower)], thinningAffectedRatio: Re.screenThinning.affectedRatio, thinningParticleOffset: xt, color: [Re.color.r, Re.color.g, Re.color.b, Re.color.a], direction: u }, { u_modelview: Float32Array.from(_t.modelview), u_projection: Float32Array.from(_t.projection), u_time: _t.time, u_cam_pos: _t.camPos, u_velocityConeAperture: _t.velocityConeAperture, u_velocity: _t.velocity, u_horizontalOscillationRadius: _t.horizontalOscillationRadius, u_horizontalOscillationRate: _t.horizontalOscillationRate, u_boxSize: _t.boxSize, u_billboardSize: _t.billboardSize, u_simpleShapeParameters: _t.simpleShapeParameters, u_screenSize: _t.screenSize, u_thinningCenterPos: _t.thinningCenterPos, u_thinningShape: _t.thinningShape, u_thinningAffectedRatio: _t.thinningAffectedRatio, u_thinningParticleOffset: _t.thinningParticleOffset, u_particleColor: _t.color, u_direction: _t.direction });
              var _t;
              const dt = Math.round(Re.intensity * this.particlesCount), gt = r.b7.simpleSegment(0, 0, 4 * dt, 2 * dt);
              this.particlesVx && this.particlesIdx && oe.draw(t, K.TRIANGLES, ui.disabled, _i.disabled, zi.alphaBlended, vi.disabled, mt, "snow_particles", this.particlesVx, this.particlesIdx, gt, {});
            })(n.boxSize, 0, n), this._vignette.draw(t, d);
          }
        }
        const Iu = { symbol: function(l, t, n, u, d) {
          if (l.renderPass !== "translucent") return;
          const _ = _i.disabled, v = l.colorModeForRenderPass(), L = n.layout.get("text-variable-anchor"), G = n.layout.get("text-size-scale-range"), X = r.aw(l.scaleFactor, G[0], G[1]);
          L && function(oe, pe, Be, Re, Ge, Ve, et, ut) {
            const st = pe.transform, xt = Ge === "map", mt = Ve === "map";
            for (const _t of oe) {
              const dt = Re.getTile(_t), gt = dt.getBucket(Be);
              if (!gt || !gt.text || !gt.text.segments.get().length) continue;
              const Rt = r.bp(gt.textSizeData, st.zoom, ut), Jt = gs(_t, gt.getProjection(), st), Vt = st.calculatePixelsToTileUnitsMatrix(dt), or = Kn(Jt, dt.tileID.canonical, mt, xt, st, gt.getProjection(), Vt), sr = gt.hasIconTextFit() && gt.hasIconData();
              if (Rt) {
                const Bt = Math.pow(2, st.zoom - dt.tileID.overscaledZ);
                hc(gt, xt, mt, et, r.cX, st, or, _t, Bt, Rt, sr);
              }
            }
          }(u, l, n, t, n.layout.get("text-rotation-alignment"), n.layout.get("text-pitch-alignment"), d, X);
          const K = n.paint.get("icon-opacity").constantOr(1) !== 0, ae = n.paint.get("text-opacity").constantOr(1) !== 0;
          n.layout.get("symbol-sort-key").constantOr(1) !== void 0 && (K || ae) ? el(l, t, n, u, _, v) : (K && el(l, t, n, u, _, v, { onlyIcons: !0 }), ae && el(l, t, n, u, _, v, { onlyText: !0 })), t.map.showCollisionBoxes && (Bl(l, t, n, u, n.paint.get("text-translate"), n.paint.get("text-translate-anchor"), !0), Bl(l, t, n, u, n.paint.get("icon-translate"), n.paint.get("icon-translate-anchor"), !1));
        }, circle: function(l, t, n, u) {
          if (l.renderPass !== "translucent") return;
          const d = n.paint.get("circle-opacity"), _ = n.paint.get("circle-stroke-width"), v = n.paint.get("circle-stroke-opacity"), L = n.layout.get("circle-sort-key").constantOr(1) !== void 0, G = n.paint.get("circle-emissive-strength");
          if (d.constantOr(1) === 0 && (_.constantOr(1) === 0 || v.constantOr(1) === 0)) return;
          const X = l.context, K = X.gl, ae = l.transform, oe = l.depthModeForSublayer(0, ui.ReadOnly), pe = _i.disabled, Be = l.colorModeForDrapableLayerRenderPass(G), Re = ae.projection.name === "globe", Ge = [r.at(ae.center.lng), r.aA(ae.center.lat)], Ve = [];
          for (let ut = 0; ut < u.length; ut++) {
            const st = u[ut], xt = t.getTile(st), mt = xt.getBucket(n);
            if (!mt || mt.projection.name !== ae.projection.name) continue;
            const _t = mt.programConfigurations.get(n.id), dt = r.cY(n), gt = l.isTileAffectedByFog(st);
            Re && dt.push("PROJECTION_GLOBE_VIEW"), dt.push("DEPTH_D24"), l.terrain && ae.depthOcclusionForSymbolsAndCircles && dt.push("DEPTH_OCCLUSION");
            const Rt = l.getOrCreateProgram("circle", { config: _t, defines: dt, overrideFog: gt }), Jt = mt.layoutVertexBuffer, Vt = mt.globeExtVertexBuffer, or = mt.indexBuffer, sr = ae.projection.createInversionMatrix(ae, st.canonical), Bt = { programConfiguration: _t, program: Rt, layoutVertexBuffer: Jt, globeExtVertexBuffer: Vt, indexBuffer: or, uniformValues: r.cZ(l, st, xt, sr, Ge, n), tile: xt };
            if (L) {
              const rr = mt.segments.get();
              for (const gr of rr) Ve.push({ segments: new r.b7([gr]), sortKey: gr.sortKey, state: Bt });
            } else Ve.push({ segments: mt.segments, sortKey: 0, state: Bt });
          }
          L && Ve.sort((ut, st) => ut.sortKey - st.sortKey);
          const et = { useDepthForOcclusion: ae.depthOcclusionForSymbolsAndCircles };
          for (const ut of Ve) {
            const { programConfiguration: st, program: xt, layoutVertexBuffer: mt, globeExtVertexBuffer: _t, indexBuffer: dt, uniformValues: gt, tile: Rt } = ut.state, Jt = ut.segments;
            l.terrain && l.terrain.setupElevationDraw(Rt, xt, et), l.uploadCommonUniforms(X, xt, Rt.tileID.toUnwrapped()), xt.draw(l, K.TRIANGLES, oe, pe, Be, vi.disabled, gt, n.id, mt, dt, Jt, n.paint, ae.zoom, st, [_t]);
          }
        }, heatmap: function(l, t, n, u) {
          if (n.paint.get("heatmap-opacity") !== 0) if (l.renderPass === "offscreen") {
            const d = l.context, _ = d.gl, v = _i.disabled, L = new zi([_.ONE, _.ONE, _.ONE, _.ONE], r.aj.transparent, [!0, !0, !0, !0]);
            (function(pe, Be, Re, Ge) {
              const Ve = pe.gl, et = Be.width * Ge, ut = Be.height * Ge;
              pe.activeTexture.set(Ve.TEXTURE1), pe.viewport.set([0, 0, et, ut]);
              let st = Re.heatmapFbo;
              if (!st || st && (st.width !== et || st.height !== ut)) {
                st && st.destroy();
                const xt = Ve.createTexture();
                Ve.bindTexture(Ve.TEXTURE_2D, xt), Ve.texParameteri(Ve.TEXTURE_2D, Ve.TEXTURE_WRAP_S, Ve.CLAMP_TO_EDGE), Ve.texParameteri(Ve.TEXTURE_2D, Ve.TEXTURE_WRAP_T, Ve.CLAMP_TO_EDGE), Ve.texParameteri(Ve.TEXTURE_2D, Ve.TEXTURE_MIN_FILTER, Ve.LINEAR), Ve.texParameteri(Ve.TEXTURE_2D, Ve.TEXTURE_MAG_FILTER, Ve.LINEAR), st = Re.heatmapFbo = pe.createFramebuffer(et, ut, !0, null), function(mt, _t, dt, gt, Rt, Jt) {
                  const Vt = mt.gl;
                  Vt.texImage2D(Vt.TEXTURE_2D, 0, mt.extRenderToTextureHalfFloat ? Vt.RGBA16F : Vt.RGBA, Rt, Jt, 0, Vt.RGBA, mt.extRenderToTextureHalfFloat ? Vt.HALF_FLOAT : Vt.UNSIGNED_BYTE, null), gt.colorAttachment.set(dt);
                }(pe, 0, xt, st, et, ut);
              } else Ve.bindTexture(Ve.TEXTURE_2D, st.colorAttachment.get()), pe.bindFramebuffer.set(st.framebuffer);
            })(d, l, n, l.transform.projection.name === "globe" ? 0.5 : 0.25), d.clear({ color: r.aj.transparent });
            const G = l.transform, X = G.projection.name === "globe", K = X ? ["PROJECTION_GLOBE_VIEW"] : [], ae = X ? vi.frontCCW : vi.disabled, oe = [r.at(G.center.lng), r.aA(G.center.lat)];
            for (let pe = 0; pe < u.length; pe++) {
              const Be = u[pe];
              if (t.hasRenderableParent(Be)) continue;
              const Re = t.getTile(Be), Ge = Re.getBucket(n);
              if (!Ge || Ge.projection.name !== G.projection.name) continue;
              const Ve = l.isTileAffectedByFog(Be), et = Ge.programConfigurations.get(n.id), ut = l.getOrCreateProgram("heatmap", { config: et, defines: K, overrideFog: Ve }), { zoom: st } = l.transform;
              l.terrain && l.terrain.setupElevationDraw(Re, ut), l.uploadCommonUniforms(d, ut, Be.toUnwrapped());
              const xt = G.projection.createInversionMatrix(G, Be.canonical);
              ut.draw(l, _.TRIANGLES, ui.disabled, v, L, ae, Gr(l, Be, Re, xt, oe, st, n.paint.get("heatmap-intensity")), n.id, Ge.layoutVertexBuffer, Ge.indexBuffer, Ge.segments, n.paint, l.transform.zoom, et, X ? [Ge.globeExtVertexBuffer] : null);
            }
            d.viewport.set([0, 0, l.width, l.height]);
          } else l.renderPass === "translucent" && (l.context.setColorMode(l.colorModeForRenderPass()), function(d, _) {
            const v = d.context, L = v.gl, G = _.heatmapFbo;
            if (!G) return;
            v.activeTexture.set(L.TEXTURE0), L.bindTexture(L.TEXTURE_2D, G.colorAttachment.get()), v.activeTexture.set(L.TEXTURE1);
            let X = _.colorRampTexture;
            X || (X = _.colorRampTexture = new r.T(v, _.colorRamp, L.RGBA8)), X.bind(L.LINEAR, L.CLAMP_TO_EDGE), d.getOrCreateProgram("heatmapTexture").draw(d, L.TRIANGLES, ui.disabled, _i.disabled, d.colorModeForRenderPass(), vi.disabled, ((K, ae, oe, pe) => ({ u_image: 0, u_color_ramp: 1, u_opacity: ae.paint.get("heatmap-opacity") }))(0, _), _.id, d.viewportBuffer, d.quadTriangleIndexBuffer, d.viewportSegments, _.paint, d.transform.zoom);
          }(l, n));
        }, line: function(l, t, n, u) {
          if (l.renderPass !== "translucent") return;
          const d = n.paint.get("line-opacity"), _ = n.paint.get("line-width");
          if (d.constantOr(1) === 0 || _.constantOr(1) === 0) return;
          const v = n.paint.get("line-emissive-strength"), L = n.paint.get("line-occlusion-opacity"), G = n.layout.get("line-elevation-reference"), X = n.layout.get("line-width-unit") === "meters", K = G === "sea", ae = l.context, oe = ae.gl;
          if (n.hasElevatedBuckets && l.transform.projection.name === "globe") return;
          const pe = n.layout.get("line-cross-slope"), Be = pe !== void 0, Re = pe < 1, Ge = l.colorModeForDrapableLayerRenderPass(v), Ve = l.terrain && l.terrain.renderingToTexture, et = Ve ? 1 : r.q.devicePixelRatio, ut = n.paint.get("line-dasharray"), st = ut.constantOr(1), xt = n.layout.get("line-cap"), mt = ut.constantOr(null), _t = xt.constantOr(null), dt = n.paint.get("line-pattern"), gt = dt.constantOr(1), Rt = dt.constantOr(null), Jt = n.paint.get("line-opacity").constantOr(1);
          let Vt = !gt && Jt !== 1 || l.depthOcclusion && L > 0 && L < 1;
          const or = n.paint.get("line-gradient"), sr = gt ? "linePattern" : "line", Bt = r.c_(n);
          let rr;
          if (Ve && l.terrain && l.terrain.clipOrMaskOverlapStencilType() && (Vt = !1), L !== 0 && l.depthOcclusion) {
            const Ut = n.paint._values["line-opacity"];
            Ut && Ut.value && Ut.value.kind === "constant" ? rr = Ut.value : r.w(`Occlusion opacity for layer ${n.id} is supported only when line-opacity isn't data-driven.`);
          }
          _.value.kind !== "constant" && _.value.isLineProgressConstant === !1 && Bt.push("VARIABLE_LINE_WIDTH");
          const gr = (Ut, dr, ir, Tr, mr) => {
            for (const hr of Ut) {
              const br = t.getTile(hr);
              if (gt && !br.patternsLoaded()) continue;
              const Cr = br.getBucket(n);
              if (!Cr || Cr.hasZOffset && !mr || !Cr.hasZOffset && mr) continue;
              l.prepareDrawTile();
              const Hr = Cr.programConfigurations.get(n.id), Zr = l.isTileAffectedByFog(hr), mi = l.getOrCreateProgram(sr, { config: Hr, defines: dr, overrideFog: Zr, overrideRtt: !mr && void 0 });
              if (Rt && br.imageAtlas) {
                const xi = r.A.from(Rt).getPrimary().scaleSelf(et).serialize(), Di = br.imageAtlas.patternPositions[xi];
                Di && Hr.setConstantPatternPositions(Di);
              }
              if (!gt && mt && _t && br.lineAtlas) {
                const xi = br.lineAtlas.getDash(mt, _t);
                xi && Hr.setConstantPatternPositions(xi);
              }
              let [ii, oi] = n.paint.get("line-trim-offset");
              (_t === "round" || _t === "square") && ii !== oi && (ii === 0 && (ii -= 1), oi === 1 && (oi += 1));
              const yi = Ve ? hr.projMatrix : null, Ui = X ? 1 / Cr.tileToMeter / r.ar(br, 1, l.transform.zoom) : 1, tn = X ? 1 / Cr.tileToMeter / r.ar(br, 1, Math.floor(l.transform.zoom)) : 1, bn = gt ? r.c$(l, br, n, yi, et, Ui, tn, [ii, oi]) : r.d0(l, br, n, yi, Cr.lineClipsArray.length, et, Ui, tn, [ii, oi]);
              if (or) {
                const xi = Cr.gradients[n.id];
                let Di = xi.texture;
                if (n.gradientVersion !== xi.version) {
                  let Yr = 256;
                  if (n.stepInterpolant) {
                    const Fi = t.getSource().maxzoom, Ki = hr.canonical.z === Fi ? Math.ceil(1 << l.transform.maxZoom - hr.canonical.z) : 1;
                    Yr = r.aw(r.d1(Cr.maxLineLength / r.ag * 1024 * Ki), 256, ae.maxTextureSize);
                  }
                  xi.gradient = r.d2({ expression: n.gradientExpression(), evaluationKey: "lineProgress", resolution: Yr, image: xi.gradient || void 0, clips: Cr.lineClipsArray }), xi.texture ? xi.texture.update(xi.gradient) : xi.texture = new r.T(ae, xi.gradient, oe.RGBA8), xi.version = n.gradientVersion, Di = xi.texture;
                }
                ae.activeTexture.set(oe.TEXTURE1), Di.bind(n.stepInterpolant ? oe.NEAREST : oe.LINEAR, oe.CLAMP_TO_EDGE);
              }
              st && (ae.activeTexture.set(oe.TEXTURE0), br.lineAtlasTexture && br.lineAtlasTexture.bind(oe.LINEAR, oe.REPEAT), Hr.updatePaintBuffers()), gt && (ae.activeTexture.set(oe.TEXTURE0), br.imageAtlasTexture && br.imageAtlasTexture.bind(oe.LINEAR, oe.CLAMP_TO_EDGE), Hr.updatePaintBuffers()), mr && !K && l.terrain.setupElevationDraw(br, mi), l.uploadCommonUniforms(ae, mi, hr.toUnwrapped());
              const $i = (xi) => {
                rr != null && (rr.value = Jt * L), mi.draw(l, oe.TRIANGLES, ir, xi, Ge, vi.disabled, bn, n.id, Cr.layoutVertexBuffer, Cr.indexBuffer, Cr.segments, n.paint, l.transform.zoom, Hr, [Cr.layoutVertexBuffer2, Cr.patternVertexBuffer, Cr.zOffsetVertexBuffer]), rr != null && (rr.value = Jt);
              };
              if (Vt && !mr) {
                const xi = l.stencilModeForClipping(hr).ref;
                xi === 0 && Ve && ae.clear({ stencil: 0 });
                const Di = { func: oe.EQUAL, mask: 255 };
                bn.u_alpha_discard_threshold = 0.8, $i(new _i(Di, xi, 255, oe.KEEP, oe.KEEP, oe.INVERT)), bn.u_alpha_discard_threshold = 0, $i(new _i(Di, xi, 255, oe.KEEP, oe.KEEP, oe.KEEP));
              } else Vt && mr && (bn.u_alpha_discard_threshold = 1e-3), $i(mr ? Tr : l.stencilModeForClipping(hr));
            }
          };
          if (n.hasNonElevatedBuckets) {
            const Ut = !Ve && l.terrain;
            L !== 0 && Ut ? r.w(`Occlusion opacity for layer ${n.id} is supported on terrain only if the layer has line-z-offset enabled.`) : Ut ? r.w(`Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${n.id}.`) : gr(u, Bt, l.depthModeForSublayer(0, ui.ReadOnly), _i.disabled, !1);
          }
          if (n.hasElevatedBuckets) {
            Bt.push("ELEVATED"), Be && Bt.push(Re ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), K && Bt.push("ELEVATION_REFERENCE_SEA");
            const Ut = Vt ? l.stencilModeFor3D() : _i.disabled, dr = new ui(l.depthOcclusion ? oe.GREATER : oe.LEQUAL, ui.ReadOnly, l.depthRangeFor3D);
            l.forceTerrainMode = !0, gr(u, Bt, dr, Ut, !0), l.forceTerrainMode = !1;
          }
          Vt && (l.resetStencilClippingMasks(), Ve && ae.clear({ stencil: 0 })), L === 0 || l.depthOcclusion || Ve || l.layersWithOcclusionOpacity.push(l.currentLayer);
        }, fill: function(l, t, n, u) {
          const d = n.paint.get("fill-color"), _ = n.paint.get("fill-opacity"), v = n.is3D(), L = new ui(l.context.gl.LEQUAL, ui.ReadWrite, l.depthRangeFor3D);
          if (_.constantOr(1) === 0) return;
          const G = n.paint.get("fill-emissive-strength"), X = l.colorModeForDrapableLayerRenderPass(G), K = n.paint.get("fill-pattern"), ae = l.opaquePassEnabledForLayer() && !K.constantOr(1) && d.constantOr(r.aj.transparent).a === 1 && _.constantOr(0) === 1 ? "opaque" : "translucent";
          if (l.renderPass === ae) {
            const oe = v ? L : l.depthModeForSublayer(1, l.renderPass === "opaque" ? ui.ReadWrite : ui.ReadOnly);
            tl(l, t, n, u, oe, X, !1);
          }
          if (!v && l.renderPass === "translucent" && n.paint.get("fill-antialias")) {
            const oe = v ? L : l.depthModeForSublayer(n.getPaintProperty("fill-outline-color") ? 2 : 0, ui.ReadOnly);
            tl(l, t, n, u, oe, X, !0);
          }
        }, "fill-extrusion": function(l, t, n, u) {
          const d = n.paint.get("fill-extrusion-opacity"), _ = l.context, v = _.gl, L = l.terrain, G = L && L.renderingToTexture;
          if (d === 0) return;
          const X = l.conflationActive && l.style.isLayerClipped(n, t.getSource()), K = l.style.order.indexOf(n.fqid);
          if (X && function(ae, oe, pe, Be, Re) {
            for (const Ge of Be) {
              const Ve = oe.getTile(Ge).getBucket(pe);
              Ve && (Ve.updateReplacement(Ge, ae.replacementSource, Re), Ve.uploadCentroid(ae.context));
            }
          }(l, t, n, u, K), L || X) for (const ae of u) {
            const oe = t.getTile(ae).getBucket(n);
            oe && il(l.context, t, ae, oe, n, L, X);
          }
          if (l.renderPass === "shadow" && l.shadowRenderer) {
            const ae = l.shadowRenderer;
            if (L && d < 0.65 && n._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof r.a9) return;
            const oe = ae.getShadowPassDepthMode(), pe = ae.getShadowPassColorMode();
            Nl(l, t, n, u, oe, _i.disabled, pe, X);
          } else if (l.renderPass === "translucent") {
            const ae = !n.paint.get("fill-extrusion-pattern").constantOr(1), oe = n.paint.get("fill-extrusion-color").constantOr(r.aj.white);
            if (!G && oe.a !== 0) {
              const pe = new ui(l.context.gl.LEQUAL, ui.ReadWrite, l.depthRangeFor3D);
              d === 1 && ae ? Nl(l, t, n, u, pe, _i.disabled, zi.unblended, X) : (Nl(l, t, n, u, pe, _i.disabled, zi.disabled, X), Nl(l, t, n, u, pe, l.stencilModeFor3D(), l.colorModeForRenderPass(), X), l.resetStencilClippingMasks());
            }
            if (l.style.enable3dLights() && ae && (!L && l.transform.projection.name !== "globe" || G)) {
              const pe = n.paint.get("fill-extrusion-opacity"), Be = n.paint.get("fill-extrusion-ambient-occlusion-intensity"), Re = n.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), Ge = n.paint.get("fill-extrusion-flood-light-intensity"), Ve = n.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none", et = n.paint.get("fill-extrusion-flood-light-color").toRenderColor(Ve ? null : n.lut).toArray01().slice(0, 3), ut = Be > 0 && Re > 0, st = Ge > 0, xt = (_t, dt, gt) => (1 - gt) * _t + gt * dt, mt = (_t) => {
                const dt = l.depthModeForSublayer(1, ui.ReadOnly, v.LEQUAL, !0), gt = n.paint.get(_t ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), Rt = xt(0.1, 3, gt), Jt = l._showOverdrawInspector;
                if (!Jt) {
                  const Vt = new _i({ func: v.ALWAYS, mask: 255 }, 255, 255, v.KEEP, v.KEEP, v.REPLACE), or = new zi([v.ONE, v.ONE, v.ONE, v.ONE], r.aj.transparent, [!1, !1, !1, !0], v.MIN);
                  rl(l, t, n, u, dt, Vt, or, vi.disabled, _t, "sdf", pe, Be, Re, Ge, et, Rt, X, !1);
                }
                {
                  const Vt = Jt ? _i.disabled : new _i({ func: v.EQUAL, mask: 255 }, 255, 255, v.KEEP, v.DECR, v.DECR), or = Jt ? l.colorModeForRenderPass() : new zi([v.ONE_MINUS_DST_ALPHA, v.DST_ALPHA, v.ONE, v.ONE], r.aj.transparent, [!0, !0, !0, !0]);
                  rl(l, t, n, u, dt, Vt, or, vi.disabled, _t, "color", pe, Be, Re, Ge, et, Rt, X, !1);
                }
              };
              if (G) {
                const _t = (dt, gt, Rt) => {
                  const Jt = l.depthModeForSublayer(1, ui.ReadOnly, v.LEQUAL, !1), Vt = n.paint.get(dt ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), or = xt(0.1, 3, Vt);
                  {
                    const sr = new zi([v.ONE, v.ONE, v.ONE, v.ONE], r.aj.transparent, [!1, !1, !1, !0]);
                    rl(l, t, n, u, Jt, _i.disabled, sr, vi.disabled, dt, "clear", pe, Be, Re, Ge, et, or, X, gt);
                  }
                  {
                    const sr = new _i({ func: v.ALWAYS, mask: 255 }, 255, 255, v.KEEP, v.KEEP, v.REPLACE), Bt = new zi([v.ONE, v.ONE, v.ONE, v.ONE], r.aj.transparent, [!1, !1, !1, !0], v.MIN);
                    rl(l, t, n, u, Jt, sr, Bt, vi.disabled, dt, "sdf", pe, Be, Re, Ge, et, or, X, gt);
                  }
                  {
                    const sr = dt ? v.ZERO : v.ONE_MINUS_DST_ALPHA, Bt = new _i({ func: v.EQUAL, mask: 255 }, 255, 255, v.KEEP, v.DECR, v.DECR), rr = new zi([sr, v.DST_ALPHA, v.ONE_MINUS_DST_ALPHA, v.ZERO], r.aj.transparent, [!0, !0, !0, !0]);
                    rl(l, t, n, u, Jt, Bt, rr, vi.disabled, dt, "color", pe, Be, Re, Ge, et, or, X, gt);
                  }
                  {
                    const sr = new zi([v.ONE, v.ONE, v.ONE, dt ? v.ZERO : v.ONE], r.aj.transparent, [!1, !1, !1, !0], dt ? v.FUNC_ADD : v.MAX);
                    rl(l, t, n, u, Jt, _i.disabled, sr, vi.disabled, dt, "clear", pe, Be, Re, Ge, et, or, X, gt, Rt);
                  }
                };
                if (ut || st) {
                  let dt;
                  if (l.prepareDrawTile(), L) {
                    const gt = L.drapeBufferSize[0], Rt = L.drapeBufferSize[1];
                    dt = L.framebufferCopyTexture, dt && (!dt || dt.size[0] === gt && dt.size[1] === Rt) || (dt && dt.destroy(), dt = L.framebufferCopyTexture = new r.T(_, new r.r({ width: gt, height: Rt }), v.RGBA8)), dt.bind(v.LINEAR, v.CLAMP_TO_EDGE), v.copyTexSubImage2D(v.TEXTURE_2D, 0, 0, 0, 0, 0, gt, Rt);
                  }
                  ut && _t(!0, !1, dt), st && _t(!1, !0, dt);
                }
              } else ut && mt(!0), st && mt(!1), (ut || st) && l.resetStencilClippingMasks();
            }
          }
        }, hillshade: function(l, t, n, u) {
          if (l.renderPass !== "offscreen" && l.renderPass !== "translucent" || l.style.disableElevatedTerrain) return;
          const d = l.context, _ = l.terrain && l.terrain.renderingToTexture, [v, L] = l.renderPass !== "translucent" || _ ? [{}, u] : l.stencilConfigForOverlap(u);
          for (const G of L) {
            const X = t.getTile(G);
            if (X.needsHillshadePrepare && l.renderPass === "offscreen") rc(l, X, n);
            else if (l.renderPass === "translucent") {
              const K = l.depthModeForSublayer(0, ui.ReadOnly), ae = n.paint.get("hillshade-emissive-strength"), oe = l.colorModeForDrapableLayerRenderPass(ae), pe = _ && l.terrain ? l.terrain.stencilModeForRTTOverlap(G) : v[G.overscaledZ];
              wf(l, G, X, n, K, pe, oe);
            }
          }
          d.viewport.set([0, 0, l.width, l.height]), l.resetStencilClippingMasks();
        }, raster: function(l, t, n, u, d, _) {
          if (l.renderPass !== "translucent" || n.paint.get("raster-opacity") === 0) return;
          const v = l.transform.projection.name === "globe", L = n.paint.get("raster-elevation") !== 0, G = L && v;
          if (l.renderElevatedRasterBackface && !G) return;
          const X = l.context, K = X.gl, ae = t.getSource(), oe = function(mt, _t, dt, gt) {
            const Rt = _t.paint.get("raster-color"), Jt = mt.type === "raster-array", Vt = [], or = _t.paint.get("raster-resampling"), sr = _t.paint.get("raster-color-mix");
            let Bt = _t.paint.get("raster-color-range");
            const rr = [sr[0], sr[1], sr[2], 0], gr = sr[3];
            let Ut = or === "nearest" ? gt.NEAREST : gt.LINEAR;
            if (Jt && (Vt.push("RASTER_ARRAY"), Rt || Vt.push("RASTER_COLOR"), or === "linear" && Vt.push("RASTER_ARRAY_LINEAR"), Ut = gt.NEAREST, !Bt && mt.rasterLayers)) {
              const dr = mt.rasterLayers.find(({ id: ir }) => ir === _t.sourceLayer);
              dr && dr.fields && dr.fields.range && (Bt = dr.fields.range);
            }
            if (Bt = Bt || [0, 1], Rt) {
              Vt.push("RASTER_COLOR"), dt.activeTexture.set(gt.TEXTURE2), _t.updateColorRamp(Bt);
              let dr = _t.colorRampTexture;
              dr || (dr = _t.colorRampTexture = new r.T(dt, _t.colorRamp, gt.RGBA8)), dr.bind(gt.LINEAR, gt.CLAMP_TO_EDGE);
            }
            return { mix: rr, range: Bt, offset: gr, defines: Vt, resampling: Ut };
          }(ae, n, X, K);
          if (ae instanceof r.aJ && !u.length && !v) return;
          const pe = n.paint.get("raster-emissive-strength"), Be = l.colorModeForDrapableLayerRenderPass(pe), Re = l.terrain && l.terrain.renderingToTexture, Ge = !l.options.moving, Ve = n.paint.get("raster-resampling") === "nearest" ? K.NEAREST : K.LINEAR;
          if (ae instanceof r.aJ && !u.length && (ae.onNorthPole || ae.onSouthPole)) {
            const mt = L ? l.stencilModeFor3D() : _i.disabled;
            return void Kt(!!ae.onNorthPole, null, l, t, n, pe, oe, vi.disabled, mt);
          }
          if (!u.length) return;
          const [et, ut] = ae instanceof r.aJ || Re ? [{}, u] : l.stencilConfigForOverlap(u), st = ut[ut.length - 1].overscaledZ;
          G && oe.defines.push("PROJECTION_GLOBE_VIEW"), L && oe.defines.push("RENDER_CUTOFF");
          const xt = (mt, _t, dt) => {
            for (const gt of mt) {
              const Rt = gt.toUnwrapped(), Jt = t.getTile(gt);
              if (Re && (!Jt || !Jt.hasData())) continue;
              X.activeTexture.set(K.TEXTURE0);
              const Vt = No(Jt, ae, n, oe);
              if (!Vt || !Vt.texture) continue;
              const { texture: or, mix: sr, offset: Bt, tileSize: rr, buffer: gr } = Vt;
              let Ut, dr;
              Re ? (Ut = ui.disabled, dr = gt.projMatrix) : L ? (Ut = new ui(K.LEQUAL, ui.ReadWrite, l.depthRangeFor3D), dr = v ? Float32Array.from(l.transform.expandedFarZProjMatrix) : l.transform.calculateProjMatrix(Rt, Ge)) : (Ut = l.depthModeForSublayer(gt.overscaledZ - st, n.paint.get("raster-opacity") === 1 ? ui.ReadWrite : ui.ReadOnly, K.LESS), dr = l.transform.calculateProjMatrix(Rt, Ge));
              const ir = l.terrain && Re ? l.terrain.stencilModeForRTTOverlap(gt) : et[gt.overscaledZ], Tr = _ ? 0 : n.paint.get("raster-fade-duration");
              Jt.registerFadeDuration(Tr);
              const mr = t.findLoadedParent(gt, 0), hr = Co(Jt, mr, t, l.transform, Tr);
              let br, Cr;
              l.terrain && l.terrain.prepareDrawTile(), X.activeTexture.set(K.TEXTURE0), or.bind(Ve, K.CLAMP_TO_EDGE), X.activeTexture.set(K.TEXTURE1), mr ? (mr.texture && mr.texture.bind(Ve, K.CLAMP_TO_EDGE), br = Math.pow(2, mr.tileID.overscaledZ - Jt.tileID.overscaledZ), Cr = [Jt.tileID.canonical.x * br % 1, Jt.tileID.canonical.y * br % 1]) : or.bind(Ve, K.CLAMP_TO_EDGE), or.useMipmap && X.extTextureFilterAnisotropic && l.transform.pitch > 20 && K.texParameterf(K.TEXTURE_2D, X.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, X.extTextureFilterAnisotropicMax);
              const Hr = l.transform;
              let Zr;
              const mi = L ? is(Hr) : [0, 0, 0, 0];
              let ii, oi, yi, Ui, tn, bn = 0;
              if (G && ae instanceof r.aJ && ae.coordinates.length > 3) ii = Float32Array.from(r.bb(r.cH(new r.bT(0, 0, 0)))), oi = Float32Array.from(Hr.globeMatrix), yi = Float32Array.from(r.cD(Hr)), Ui = [r.at(Hr.center.lng), r.aA(Hr.center.lat)], Zr = ae.elevatedGlobePerspectiveTransform, tn = ae.elevatedGlobeGridMatrix || new Float32Array(9);
              else if (G) {
                const Yr = r.cE(gt.canonical);
                bn = r.cF(Yr.getCenter().lat), ii = Float32Array.from(r.bb(r.cH(gt.canonical))), oi = Float32Array.from(Hr.globeMatrix), yi = Float32Array.from(r.cD(Hr)), Ui = [r.at(Hr.center.lng), r.aA(Hr.center.lat)], Zr = [0, 0], tn = Float32Array.from(r.cG(gt.canonical, Yr, bn, Hr.worldSize / Hr._pixelsPerMercatorPixel));
              } else Zr = ae instanceof r.aJ ? ae.perspectiveTransform : [0, 0], ii = new Float32Array(16), oi = new Float32Array(9), yi = new Float32Array(16), Ui = [0, 0], tn = new Float32Array(9);
              const $i = Ra(dr, ii, oi, yi, tn, Cr || [0, 0], r.ae(l.transform.zoom), Ui, mi, br || 1, hr, n, Zr, L ? n.paint.get("raster-elevation") : 0, 2, sr, Bt, oe.range, rr, gr, pe), xi = l.isTileAffectedByFog(gt), Di = l.getOrCreateProgram("raster", { defines: oe.defines, overrideFog: xi });
              if (l.uploadCommonUniforms(X, Di, Rt), ae instanceof r.aJ) {
                const Yr = ae.elevatedGlobeVertexBuffer, Fi = ae.elevatedGlobeIndexBuffer;
                if (Re || !v) ae.boundsBuffer && ae.boundsSegments && Di.draw(l, K.TRIANGLES, Ut, _i.disabled, Be, vi.disabled, $i, n.id, ae.boundsBuffer, l.quadTriangleIndexBuffer, ae.boundsSegments);
                else if (Yr && Fi) {
                  const Ki = Hr.zoom <= r.c6 ? ae.elevatedGlobeSegments : ae.getSegmentsForLongitude(Hr.center.lng);
                  Ki && Di.draw(l, K.TRIANGLES, Ut, _i.disabled, Be, _t, $i, n.id, Yr, Fi, Ki);
                }
              } else if (G) {
                Ut = new ui(K.LEQUAL, ui.ReadOnly, l.depthRangeFor3D);
                const Yr = l.globeSharedBuffers;
                if (Yr) {
                  const [Fi, Ki, Qi] = Yr.getGridBuffers(bn, !1);
                  Di.draw(l, K.TRIANGLES, Ut, dt || ir, l.colorModeForRenderPass(), _t, $i, n.id, Fi, Ki, Qi);
                }
              } else {
                const { tileBoundsBuffer: Yr, tileBoundsIndexBuffer: Fi, tileBoundsSegments: Ki } = l.getTileBoundsBuffers(Jt);
                Di.draw(l, K.TRIANGLES, Ut, ir, Be, vi.disabled, $i, n.id, Yr, Fi, Ki);
              }
            }
            if (!(ae instanceof r.aJ) && G) for (const gt of mt) {
              const Rt = gt.canonical.y === (1 << gt.canonical.z) - 1;
              gt.canonical.y === 0 && Kt(!0, gt, l, t, n, pe, oe, _t, dt || _i.disabled), Rt && Kt(!1, gt, l, t, n, pe, oe, _t === vi.frontCW ? vi.backCW : vi.frontCW, dt || _i.disabled);
            }
          };
          G ? xt(ut, l.renderElevatedRasterBackface ? vi.backCW : vi.frontCW, l.stencilModeFor3D()) : xt(ut, vi.disabled, void 0), l.resetStencilClippingMasks();
        }, "raster-particle": function(l, t, n, u, d, _) {
          l.renderPass === "offscreen" && function(v, L, G, X) {
            if (!X.length) return;
            const K = v.context, ae = K.gl, oe = L.getSource();
            if (!(oe instanceof Yn)) return;
            const pe = Math.ceil(Math.sqrt(G.paint.get("raster-particle-count")));
            let Be = G.particlePositionRGBAImage;
            if (!Be || Be.width !== pe) {
              const ut = function(st) {
                const xt = st * st, mt = new Uint8Array(4 * xt), _t = function(gt) {
                  return gt |= 0, gt = Math.imul(2747636419 ^ gt, 2654435769), gt = Math.imul(gt ^ gt >>> 16, 2654435769), ((gt = Math.imul(gt ^ gt >>> 16, 2654435769)) >>> 0) / 4294967296;
                }, dt = 1 / 1.1;
                for (let gt = 0; gt < xt; gt++) {
                  const Rt = dt * (_t(2 * gt + 0) + ri), Jt = dt * (_t(2 * gt + 1) + ri), Vt = 255 * Rt % 1, or = 255 * Jt % 1, sr = Vt, Bt = Jt - or / 255, rr = or;
                  mt[4 * gt + 0] = 255 * (Rt - Vt / 255), mt[4 * gt + 1] = 255 * sr, mt[4 * gt + 2] = 255 * Bt, mt[4 * gt + 3] = 255 * rr;
                }
                return mt;
              }(pe);
              Be = G.particlePositionRGBAImage = new r.r({ width: pe, height: pe }, ut);
            }
            let Re = G.particleFramebuffer;
            Re ? Re.width !== pe && (Re.destroy(), Re = G.particleFramebuffer = K.createFramebuffer(pe, pe, !0, null)) : Re = G.particleFramebuffer = K.createFramebuffer(pe, pe, !0, null);
            const Ge = [];
            for (const ut of X) {
              const st = L.getTile(ut);
              if (!(st instanceof ds)) continue;
              const xt = ns(st, oe, G);
              if (!xt) continue;
              const mt = [st.tileSize, st.tileSize];
              let _t = G.tileFramebuffer;
              _t || (_t = G.tileFramebuffer = K.createFramebuffer(mt[0], mt[1], !0, null));
              let dt = st.rasterParticleState;
              dt || (dt = st.rasterParticleState = new Wh(K, ut, mt, Be));
              const gt = dt.update(G.lastInvalidatedAt);
              dt.particleTextureDimension !== pe && dt.updateParticleTexture(ut, Be);
              const Rt = dt.targetColorTexture;
              dt.targetColorTexture = dt.backgroundColorTexture, dt.backgroundColorTexture = Rt;
              const Jt = dt.particleTexture0;
              dt.particleTexture0 = dt.particleTexture1, dt.particleTexture1 = Jt, Ge.push([ut, xt, dt, gt]);
            }
            if (Ge.length === 0) return;
            const Ve = r.q.now(), et = G.previousDrawTimestamp ? 1e-3 * (Ve - G.previousDrawTimestamp) : 0.0167;
            if (G.previousDrawTimestamp = Ve, G.hasColorMap()) {
              K.activeTexture.set(ae.TEXTURE0 + 2);
              let ut = G.colorRampTexture;
              ut || (ut = G.colorRampTexture = new r.T(K, G.colorRamp, ae.RGBA8)), ut.bind(ae.LINEAR, ae.CLAMP_TO_EDGE);
            }
            K.bindFramebuffer.set(G.tileFramebuffer.framebuffer), function(ut, st, xt) {
              const mt = ut.context, _t = mt.gl, dt = st.tileFramebuffer;
              mt.activeTexture.set(_t.TEXTURE0);
              const gt = { u_texture: 0, u_opacity: 1.05 * (Jt = st.paint.get("raster-particle-fade-opacity-factor")) / (Jt + 0.05) }, Rt = ut.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: !1 });
              var Jt;
              for (const Vt of xt) {
                const [, , or, sr] = Vt;
                dt.colorAttachment.set(or.targetColorTexture.texture), mt.viewport.set([0, 0, dt.width, dt.height]), mt.clear({ color: r.aj.transparent }), sr && (or.backgroundColorTexture.bind(_t.NEAREST, _t.CLAMP_TO_EDGE), Rt.draw(ut, _t.TRIANGLES, ui.disabled, _i.disabled, zi.alphaBlended, vi.disabled, gt, st.id, ut.viewportBuffer, ut.quadTriangleIndexBuffer, ut.viewportSegments));
              }
            }(v, G, Ge), function(ut, st, xt, mt) {
              const _t = ut.context, dt = _t.gl, gt = xt.tileFramebuffer, Rt = ut.transform.projection.name === "globe", Jt = xt.paint.get("raster-particle-max-speed");
              for (const Vt of mt) {
                const [or, sr, Bt] = Vt;
                _t.activeTexture.set(dt.TEXTURE0 + 0), sr.texture.bind(dt.LINEAR, dt.CLAMP_TO_EDGE), gt.colorAttachment.set(Bt.targetColorTexture.texture);
                const rr = ut.getOrCreateProgram("rasterParticleDraw", { defines: sr.defines, overrideFog: !1 });
                _t.activeTexture.set(dt.TEXTURE0 + 1);
                const gr = sr.scalarData ? [] : [0, 1, 2, 3].map((ir) => r.d4[ir](or));
                gr.push(or);
                const Ut = or.canonical.x, dr = or.canonical.y;
                for (const ir of gr) {
                  const Tr = st.getTile(Rt ? ir.wrapped() : ir);
                  if (!Tr) continue;
                  const mr = Tr.rasterParticleState;
                  if (!mr) continue;
                  const hr = ir.canonical.x + (1 << ir.canonical.z) * (ir.wrap - or.wrap), br = ir.canonical.y;
                  mr.particleTexture0.bind(dt.NEAREST, dt.CLAMP_TO_EDGE);
                  const Cr = Vh(1, mr.particleTexture0.size[0], [hr - Ut, br - dr], 0, sr.texture.size, 2, Jt, sr.textureOffset, sr.scale, sr.offset);
                  rr.draw(ut, dt.POINTS, ui.disabled, _i.disabled, zi.alphaBlended, vi.disabled, Cr, xt.id, mr.particleIndexBuffer, void 0, mr.particleSegment);
                }
              }
            }(v, L, G, Ge), K.bindFramebuffer.set(G.particleFramebuffer.framebuffer), function(ut, st, xt, mt) {
              const _t = ut.context, dt = _t.gl, gt = st.paint.get("raster-particle-max-speed"), Rt = mt * st.paint.get("raster-particle-speed-factor") * 0.15, Jt = function(or) {
                return Math.pow(or, 6);
              }(0.01 + 1 * st.paint.get("raster-particle-reset-rate-factor")), Vt = st.particleFramebuffer;
              _t.viewport.set([0, 0, Vt.width, Vt.height]);
              for (const or of xt) {
                const [, sr, Bt] = or;
                _t.activeTexture.set(dt.TEXTURE0 + 0), sr.texture.bind(dt.LINEAR, dt.CLAMP_TO_EDGE), _t.activeTexture.set(dt.TEXTURE0 + 1);
                const rr = Bt.particleTexture0;
                rr.bind(dt.NEAREST, dt.CLAMP_TO_EDGE);
                const gr = mo(1, rr.size[0], 0, sr.texture.size, gt, Rt, Jt, sr.textureOffset, sr.scale, sr.offset);
                Vt.colorAttachment.set(Bt.particleTexture1.texture), _t.clear({ color: r.aj.transparent }), ut.getOrCreateProgram("rasterParticleUpdate", { defines: sr.defines }).draw(ut, dt.TRIANGLES, ui.disabled, _i.disabled, zi.unblended, vi.disabled, gr, st.id, ut.viewportBuffer, ut.quadTriangleIndexBuffer, ut.viewportSegments);
              }
            }(v, G, Ge, et);
          }(l, t, n, u), l.renderPass === "translucent" && (function(v, L, G, X, K) {
            const ae = v.context, oe = ae.gl, pe = L.getSource().tileSize, Be = 5 * (1 - r.ac(r.bY, r.bY + 1, v.transform.zoom)) * pe + G.paint.get("raster-particle-elevation"), Re = !v.options.moving, Ge = v.transform.projection.name === "globe";
            if (!X.length) return;
            const [Ve, et] = v.stencilConfigForOverlap(X), ut = [];
            Ge && ut.push("PROJECTION_GLOBE_VIEW");
            const st = v.stencilModeFor3D();
            for (const xt of et) {
              const mt = xt.toUnwrapped(), _t = L.getTile(xt);
              if (!_t.rasterParticleState) continue;
              const dt = _t.rasterParticleState, gt = 100;
              _t.registerFadeDuration(gt);
              const Rt = L.findLoadedParent(xt, 0), Jt = Co(_t, Rt, L, v.transform, gt);
              let Vt, or;
              v.terrain && v.terrain.prepareDrawTile(), ae.activeTexture.set(oe.TEXTURE0), dt.targetColorTexture.bind(oe.LINEAR, oe.CLAMP_TO_EDGE), ae.activeTexture.set(oe.TEXTURE1), Rt && Rt.rasterParticleState ? (Rt.rasterParticleState.targetColorTexture.bind(oe.LINEAR, oe.CLAMP_TO_EDGE), Vt = Math.pow(2, Rt.tileID.overscaledZ - _t.tileID.overscaledZ), or = [_t.tileID.canonical.x * Vt % 1, _t.tileID.canonical.y * Vt % 1]) : dt.targetColorTexture.bind(oe.LINEAR, oe.CLAMP_TO_EDGE);
              const sr = Ge ? Float32Array.from(v.transform.expandedFarZProjMatrix) : v.transform.calculateProjMatrix(mt, Re), Bt = v.transform, rr = Ms(Bt), gr = r.cE(xt.canonical), Ut = r.cF(gr.getCenter().lat);
              let dr, ir, Tr, mr, hr;
              Ge ? (dr = Float32Array.from(r.bb(r.cH(xt.canonical))), ir = Float32Array.from(Bt.globeMatrix), Tr = Float32Array.from(r.cD(Bt)), mr = [r.at(Bt.center.lng), r.aA(Bt.center.lat)], hr = Float32Array.from(r.cG(xt.canonical, gr, Ut, Bt.worldSize / Bt._pixelsPerMercatorPixel))) : (dr = new Float32Array(16), ir = new Float32Array(9), Tr = new Float32Array(16), mr = [0, 0], hr = new Float32Array(9));
              const br = uc(sr, dr, ir, Tr, hr, or || [0, 0], r.ae(v.transform.zoom), mr, rr, Vt || 1, Jt, Be), Cr = v.isTileAffectedByFog(xt), Hr = v.getOrCreateProgram("rasterParticle", { defines: ut, overrideFog: Cr });
              if (v.uploadCommonUniforms(ae, Hr, mt), Ge) {
                const Zr = new ui(oe.LEQUAL, ui.ReadOnly, v.depthRangeFor3D), mi = 0, ii = v.globeSharedBuffers;
                if (ii) {
                  const [oi, yi, Ui] = ii.getGridBuffers(Ut, mi !== 0);
                  Hr.draw(v, oe.TRIANGLES, Zr, st, zi.alphaBlended, v.renderElevatedRasterBackface ? vi.frontCCW : vi.backCCW, br, G.id, oi, yi, Ui);
                }
              } else {
                const Zr = v.depthModeForSublayer(0, ui.ReadOnly), mi = Ve[xt.overscaledZ], { tileBoundsBuffer: ii, tileBoundsIndexBuffer: oi, tileBoundsSegments: yi } = v.getTileBoundsBuffers(_t);
                Hr.draw(v, oe.TRIANGLES, Zr, mi, zi.alphaBlended, vi.disabled, br, G.id, ii, oi, yi);
              }
            }
            v.resetStencilClippingMasks();
          }(l, t, n, u), l.style.map.triggerRepaint());
        }, background: function(l, t, n, u) {
          const d = n.paint.get("background-color"), _ = n.paint.get("background-color-use-theme").constantOr("default") === "none", v = n.paint.get("background-opacity"), L = n.paint.get("background-emissive-strength"), G = n.paint.get("background-pitch-alignment") === "viewport";
          if (v === 0) return;
          const X = l.context, K = X.gl, ae = l.transform, oe = ae.tileSize, pe = n.paint.get("background-pattern");
          let Be;
          if (pe !== void 0 && (pe === null || (Be = l.imageManager.getPattern(pe.toString(), n.scope, l.style.getLut(n.scope)), !Be)))
            return;
          const Re = !pe && d.a === 1 && v === 1 && l.opaquePassEnabledForLayer() ? "opaque" : "translucent";
          if (l.renderPass !== Re) return;
          const Ge = _i.disabled, Ve = l.depthModeForSublayer(0, Re === "opaque" ? ui.ReadWrite : ui.ReadOnly), et = l.colorModeForDrapableLayerRenderPass(L), ut = pe ? "backgroundPattern" : "background";
          let st, xt = u;
          if (xt || (st = l.getBackgroundTiles(), xt = Object.values(st).map((mt) => mt.tileID)), pe && (X.activeTexture.set(K.TEXTURE0), l.imageManager.bind(l.context, n.scope)), G) {
            const mt = l.getOrCreateProgram(ut, { overrideFog: !1, overrideRtt: !0 }), _t = new Float32Array(r.ab.mat4.identity([])), dt = new r.aG(0, 0, 0, 0, 0), gt = pe ? Gh(_t, L, v, l, 0, n.scope, Be, G, { tileID: dt, tileSize: oe }) : _o(_t, L, v, d.toRenderColor(_ ? null : n.lut));
            mt.draw(l, K.TRIANGLES, Ve, Ge, et, vi.disabled, gt, n.id, l.viewportBuffer, l.quadTriangleIndexBuffer, l.viewportSegments);
          } else for (const mt of xt) {
            const _t = l.isTileAffectedByFog(mt), dt = l.getOrCreateProgram(ut, { overrideFog: _t }), gt = mt.toUnwrapped(), Rt = u ? mt.projMatrix : l.transform.calculateProjMatrix(gt);
            l.prepareDrawTile();
            const Jt = t ? t.getTile(mt) : st ? st[mt.key] : new Zo(mt, oe, ae.zoom, l), Vt = pe ? Gh(Rt, L, v, l, 0, n.scope, Be, G, { tileID: mt, tileSize: oe }) : _o(Rt, L, v, d.toRenderColor(_ ? null : n.lut));
            l.uploadCommonUniforms(X, dt, gt);
            const { tileBoundsBuffer: or, tileBoundsIndexBuffer: sr, tileBoundsSegments: Bt } = l.getTileBoundsBuffers(Jt);
            dt.draw(l, K.TRIANGLES, Ve, Ge, et, vi.disabled, Vt, n.id, or, sr, Bt);
          }
        }, sky: function(l, t, n) {
          const u = l._atmosphere ? r.ae(l.transform.zoom) : 1, d = n.paint.get("sky-opacity") * u;
          if (d === 0) return;
          const _ = l.context, v = n.paint.get("sky-type"), L = new ui(_.gl.LEQUAL, ui.ReadOnly, [0, 1]), G = l.frameCounter / 1e3 % 1;
          v === "atmosphere" ? l.renderPass === "offscreen" ? n.needsSkyboxCapture(l) && (function(X, K, ae, oe) {
            const pe = X.context, Be = pe.gl;
            let Re = K.skyboxFbo;
            if (!Re) {
              Re = K.skyboxFbo = pe.createFramebuffer(32, 32, !0, null), K.skyboxGeometry = new Jc(pe), K.skyboxTexture = pe.gl.createTexture(), Be.bindTexture(Be.TEXTURE_CUBE_MAP, K.skyboxTexture), Be.texParameteri(Be.TEXTURE_CUBE_MAP, Be.TEXTURE_WRAP_S, Be.CLAMP_TO_EDGE), Be.texParameteri(Be.TEXTURE_CUBE_MAP, Be.TEXTURE_WRAP_T, Be.CLAMP_TO_EDGE), Be.texParameteri(Be.TEXTURE_CUBE_MAP, Be.TEXTURE_MIN_FILTER, Be.LINEAR), Be.texParameteri(Be.TEXTURE_CUBE_MAP, Be.TEXTURE_MAG_FILTER, Be.LINEAR);
              for (let ut = 0; ut < 6; ++ut) Be.texImage2D(Be.TEXTURE_CUBE_MAP_POSITIVE_X + ut, 0, Be.RGBA, 32, 32, 0, Be.RGBA, Be.UNSIGNED_BYTE, null);
            }
            pe.bindFramebuffer.set(Re.framebuffer), pe.viewport.set([0, 0, 32, 32]);
            const Ge = K.getCenter(X, !0), Ve = X.getOrCreateProgram("skyboxCapture"), et = new Float64Array(16);
            r.ab.mat4.identity(et), r.ab.mat4.rotateY(et, et, 0.5 * -Math.PI), rn(X, K, Ve, et, Ge, 0), r.ab.mat4.identity(et), r.ab.mat4.rotateY(et, et, 0.5 * Math.PI), rn(X, K, Ve, et, Ge, 1), r.ab.mat4.identity(et), r.ab.mat4.rotateX(et, et, 0.5 * -Math.PI), rn(X, K, Ve, et, Ge, 2), r.ab.mat4.identity(et), r.ab.mat4.rotateX(et, et, 0.5 * Math.PI), rn(X, K, Ve, et, Ge, 3), r.ab.mat4.identity(et), rn(X, K, Ve, et, Ge, 4), r.ab.mat4.identity(et), r.ab.mat4.rotateY(et, et, Math.PI), rn(X, K, Ve, et, Ge, 5), pe.viewport.set([0, 0, X.width, X.height]);
          }(l, n), n.markSkyboxValid(l)) : l.renderPass === "sky" && function(X, K, ae, oe, pe) {
            const Be = X.context, Re = Be.gl, Ge = X.transform, Ve = X.getOrCreateProgram("skybox");
            Be.activeTexture.set(Re.TEXTURE0), Re.bindTexture(Re.TEXTURE_CUBE_MAP, K.skyboxTexture);
            const et = /* @__PURE__ */ ((ut, st, xt, mt, _t) => ({ u_matrix: ut, u_sun_direction: st, u_cubemap: 0, u_opacity: mt, u_temporal_offset: _t }))(Ge.skyboxMatrix, K.getCenter(X, !1), 0, oe, pe);
            X.uploadCommonUniforms(Be, Ve), Ve.draw(X, Re.TRIANGLES, ae, _i.disabled, X.colorModeForRenderPass(), vi.backCW, et, "skybox", K.skyboxGeometry.vertexBuffer, K.skyboxGeometry.indexBuffer, K.skyboxGeometry.segment);
          }(l, n, L, d, G) : v === "gradient" && l.renderPass === "sky" && function(X, K, ae, oe, pe) {
            const Be = X.context, Re = Be.gl, Ge = X.transform, Ve = X.getOrCreateProgram("skyboxGradient");
            K.skyboxGeometry || (K.skyboxGeometry = new Jc(Be)), Be.activeTexture.set(Re.TEXTURE0);
            let et = K.colorRampTexture;
            et || (et = K.colorRampTexture = new r.T(Be, K.colorRamp, Re.RGBA8)), et.bind(Re.LINEAR, Re.CLAMP_TO_EDGE);
            const ut = ((st, xt, mt, _t, dt) => ({ u_matrix: st, u_color_ramp: 0, u_center_direction: xt, u_radius: r.ai(mt), u_opacity: _t, u_temporal_offset: dt }))(Ge.skyboxMatrix, K.getCenter(X, !1), K.paint.get("sky-gradient-radius"), oe, pe);
            X.uploadCommonUniforms(Be, Ve), Ve.draw(X, Re.TRIANGLES, ae, _i.disabled, X.colorModeForRenderPass(), vi.backCW, ut, "skyboxGradient", K.skyboxGeometry.vertexBuffer, K.skyboxGeometry.indexBuffer, K.skyboxGeometry.segment);
          }(l, n, L, d, G);
        }, debug: function(l, t, n, u, d, _) {
          for (let v = 0; v < n.length; v++) if (d) {
            const X = new r.aj(u.r * 0.8, u.g * 0.8, u.b * 0.8, 1);
            Aa(l, t, n[v], u, -1, -1, _), Aa(l, t, n[v], u, -1, 1, _), Aa(l, t, n[v], u, 1, 1, _), Aa(l, t, n[v], u, 1, -1, _), Aa(l, t, n[v], X, 0, 0, _);
          } else Aa(l, t, n[v], u, 0, 0, _);
        }, custom: function(l, t, n, u) {
          const d = l.context, _ = n.implementation;
          if (!l.transform.projection.unsupportedLayers || !l.transform.projection.unsupportedLayers.includes("custom") || l.terrain && (l.terrain.renderingToTexture || l.renderPass === "offscreen") && n.isDraped(t)) {
            if (l.renderPass === "offscreen") {
              const v = _.prerender;
              if (v) {
                if (l.setCustomLayerDefaults(), d.setColorMode(l.colorModeForRenderPass()), l.transform.projection.name === "globe") {
                  const L = l.transform.pointMerc;
                  v.call(_, d.gl, l.transform.customLayerMatrix(), l.transform.getProjection(), l.transform.globeToMercatorMatrix(), r.ae(l.transform.zoom), [L.x, L.y], l.transform.pixelsPerMeterRatio);
                } else v.call(_, d.gl, l.transform.customLayerMatrix());
                d.setDirty(), l.setBaseState();
              }
            } else if (l.renderPass === "translucent") {
              if (l.terrain && l.terrain.renderingToTexture) {
                const L = _.renderToTile;
                if (L) {
                  const G = u[0].canonical, X = new r.aa(G.x + u[0].wrap * (1 << G.z), G.y, G.z);
                  d.setDepthMode(ui.disabled), d.setStencilMode(_i.disabled), d.setColorMode(l.colorModeForRenderPass()), l.setCustomLayerDefaults(), L.call(_, d.gl, X), d.setDirty(), l.setBaseState();
                }
                return;
              }
              l.setCustomLayerDefaults(), d.setColorMode(l.colorModeForRenderPass()), d.setStencilMode(_i.disabled);
              const v = _.renderingMode === "3d" ? new ui(l.context.gl.LEQUAL, ui.ReadWrite, l.depthRangeFor3D) : l.depthModeForSublayer(0, ui.ReadOnly);
              if (d.setDepthMode(v), l.transform.projection.name === "globe") {
                const L = l.transform.pointMerc;
                _.render(d.gl, l.transform.customLayerMatrix(), l.transform.getProjection(), l.transform.globeToMercatorMatrix(), r.ae(l.transform.zoom), [L.x, L.y], l.transform.pixelsPerMeterRatio);
              } else _.render(d.gl, l.transform.customLayerMatrix());
              d.setDirty(), l.setBaseState(), d.bindFramebuffer.set(null);
            }
          } else r.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
        }, model: function(l, t, n, u) {
          if (l.renderPass === "opaque") return;
          const d = n.paint.get("model-opacity").constantOr(1);
          if (d === 0) return;
          const _ = n.paint.get("model-cast-shadows");
          if (l.renderPass === "shadow" && (!_ || l.terrain && d < 0.65 && n._transitionablePaint._values["model-opacity"].value.expression instanceof r.a9))
            return;
          const v = l.shadowRenderer, L = n.paint.get("model-receive-shadows");
          v && (v.useNormalOffset = !0, L || (v.enabled = !1));
          const G = () => {
            v && (v.useNormalOffset = !0, L || (v.enabled = !0));
          }, X = t.getSource();
          if (l.renderPass === "light-beam" && X.type !== "batched-model") return;
          if (X.type === "vector" || X.type === "geojson") return function(Ve, et, ut, st, xt) {
            const mt = Ve.transform;
            if (mt.projection.name !== "mercator") return void r.w(`Drawing 3D models for ${mt.projection.name} projection is not yet implemented`);
            const _t = mt.getFreeCameraOptions().position;
            if (!Ve.modelManager) return;
            const dt = Ve.modelManager;
            ut.modelManager = dt;
            const gt = Ve.shadowRenderer;
            if (!ut._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
            const Rt = ut._unevaluatedLayout._values["model-id"], Jt = Object.assign({}, ut.layout.get("model-id").parameters), Vt = Ve.style.order.indexOf(ut.fqid);
            for (const or of st) {
              const sr = et.getTile(or).getBucket(ut);
              if (!sr || sr.projection.name !== mt.projection.name) continue;
              const Bt = sr.getModelUris();
              Bt && !sr.modelsRequested && (dt.addModelsFromBucket(Bt, xt), sr.modelsRequested = !0);
              const rr = th(or, mt);
              Jt.zoom = rr;
              const gr = Rt.possiblyEvaluate(Jt);
              if (ro(Ve, sr, or), ra.shadowUniformsInitialized = !1, ra.useSingleShadowCascade = !!gt && gt.getMaxCascadeForTile(or.toUnwrapped()) === 0, Ve.renderPass === "shadow" && gt) {
                if (Ve.currentShadowCascade === 1 && sr.isInsideFirstShadowMapFrustum) continue;
                const ir = mt.calculatePosMatrix(or.toUnwrapped(), mt.worldSize);
                if (ra.tileMatrix.set(ir), ra.shadowTileMatrix = Float32Array.from(gt.calculateShadowPassMatrixFromMatrix(ir)), ra.aabb.min.fill(0), ra.aabb.max[0] = ra.aabb.max[1] = r.ag, ra.aabb.max[2] = 0, pc(sr, ra, Ve, ut.scope)) continue;
              }
              const Ut = 1 << or.canonical.z, dr = [((_t.x - or.wrap) * Ut - or.canonical.x) * r.ag, (_t.y * Ut - or.canonical.y) * r.ag, _t.z * Ut * r.ag];
              Ve.conflationActive && Object.keys(sr.instancesPerModel).length > 0 && Ve.style.isLayerClipped(ut, et.getSource()) && sr.updateReplacement(or, Ve.replacementSource, Vt, xt) && (sr.uploaded = !1, sr.upload(Ve.context));
              for (let ir in sr.instancesPerModel) {
                const Tr = sr.instancesPerModel[ir];
                Tr.features.length > 0 && (ir = gr.evaluate(Tr.features[0].feature, {}));
                const mr = dt.getModel(ir, xt);
                if (mr && mr.uploaded) for (const hr of mr.nodes) ca(Ve, ut, hr, Tr, dr, or, ra);
              }
            }
          }(l, t, n, u, X.type === "vector" ? n.scope : ""), void G();
          if (!X.loaded()) return;
          if (X.type === "batched-model") return function(Ve, et, ut, st) {
            ut.resetLayerRenderingStats(Ve);
            const xt = Ve.context, mt = Ve.transform, _t = Ve.style.fog, dt = Ve.shadowRenderer;
            if (mt.projection.name !== "mercator") return void r.w(`Drawing 3D landmark models for ${mt.projection.name} projection is not yet implemented`);
            const gt = Ve.transform.getFreeCameraOptions().position, Rt = r.ab.vec3.scale([], [gt.x, gt.y, gt.z], Ve.transform.worldSize), Jt = r.ab.vec3.negate([], Rt), Vt = r.ab.mat4.identity([]), or = r.dj(mt.center.lat, mt.zoom), sr = r.ab.mat4.fromScaling([], [1, 1, 1 / or]);
            r.ab.mat4.translate(Vt, Vt, Jt);
            const Bt = ut.paint.get("model-opacity").constantOr(1), rr = new ui(xt.gl.LEQUAL, ui.ReadWrite, Ve.depthRangeFor3D), gr = new ui(xt.gl.LEQUAL, ui.ReadOnly, Ve.depthRangeFor3D), Ut = new r.cd([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), dr = Ve.renderPass === "shadow", ir = dr && dt ? dt.getCurrentCascadeFrustum() : mt.getFrustum(mt.scaleZoom(mt.worldSize)), Tr = ut.paint.get("model-front-cutoff"), mr = Tr[2] < 1, hr = To(Ve, ut.paint.get("model-cutoff-fade-range")), br = ut.getLayerRenderingStats();
            (function(Cr, Hr, Zr, mi) {
              const ii = Cr.terrain ? Cr.terrain.exaggeration() : 0, oi = Cr.transform.zoom;
              for (const yi of mi) {
                const Ui = Hr.getTile(yi).getBucket(Zr);
                Ui && (Cr.conflationActive && Ui.updateReplacement(yi, Cr.replacementSource), Ui.evaluateScale(Cr, Zr), Cr.terrain && ii > 0 && Ui.elevationUpdate(Cr.terrain, ii, yi, Zr.source), Ui.needsReEvaluation(Cr, oi, Zr) && Ui.evaluate(Zr));
              }
            })(Ve, et, ut, st), function() {
              let Cr, Hr, Zr;
              mr ? (Cr = st.length - 1, Hr = -1, Zr = -1) : (Cr = 0, Hr = st.length, Zr = 1);
              const mi = new Float64Array(16), ii = r.ab.vec3.create(), oi = new r.P(0, 0);
              for (let yi = Cr; yi !== Hr; yi += Zr) {
                const Ui = st[yi], tn = et.getTile(Ui).getBucket(ut);
                if (!tn || !tn.uploaded) continue;
                let bn = !1;
                dt && (bn = dt.getMaxCascadeForTile(Ui.toUnwrapped()) === 0);
                const $i = mt.calculatePosMatrix(Ui.toUnwrapped(), mt.worldSize), xi = tn.modelTraits;
                !dr && mr && (r.ab.mat4.invert(mi, $i), r.ab.vec3.transformMat4(ii, Rt, mi), oi.x = ii[0], oi.y = ii[1]);
                const Di = [];
                for (const Yr of tn.getNodesInfo()) {
                  if (Yr.hiddenByReplacement || !Yr.node.meshes) continue;
                  const Fi = Yr.node;
                  let Ki = 0;
                  Ve.terrain && Fi.elevation && (Ki = Fi.elevation * Ve.terrain.exaggeration());
                  const Qi = (() => {
                    const Vi = Yr.aabb;
                    return Ut.min = [...Vi.min], Ut.max = [...Vi.max], Ut.min[2] += Ki, Ut.max[2] += Ki, r.ab.vec3.transformMat4(Ut.min, Ut.min, $i), r.ab.vec3.transformMat4(Ut.max, Ut.max, $i), Ut;
                  })(), Mn = Yr.evaluatedScale;
                  if (Mn[0] <= 1 && Mn[1] <= 1 && Mn[2] <= 1 && Qi.intersects(ir) === 0) continue;
                  if (!dr && mr) {
                    const Vi = 0.16666666666666666;
                    Yr.cameraCollisionOpacity = Rt[0] > Qi.min[0] && Rt[0] < Qi.max[0] && Rt[1] > Qi.min[1] && Rt[1] < Qi.max[1] && Rt[2] * or < Qi.max[2] && Fi.footprint && r.bA(oi, Fi.footprint) ? Math.max(Yr.cameraCollisionOpacity - Vi, 0) : Math.min(1, Yr.cameraCollisionOpacity + Vi);
                  }
                  const Pn = [...$i], Zn = Fi.anchor ? Fi.anchor[0] : 0, jn = Fi.anchor ? Fi.anchor[1] : 0;
                  r.ab.mat4.translate(Pn, Pn, [Zn * (Mn[0] - 1), jn * (Mn[1] - 1), Ki]), r.ab.vec3.exactEquals(Mn, r.dm) || r.ab.mat4.scale(Pn, Pn, Mn);
                  const ya = r.ab.mat4.multiply([], Pn, Fi.matrix), va = r.ab.mat4.multiply([], mt.expandedFarZProjMatrix, ya), pn = r.ab.mat4.multiply([], mt.expandedFarZProjMatrix, Pn), hn = r.ab.vec4.transformMat4([], [Zn, jn, Ki, 1], va)[2];
                  Fi.hidden = !1;
                  let ln = Bt;
                  dr || (mr && (ln *= Yr.cameraCollisionOpacity, ln *= Lo(Pn, mt, Yr.aabb, Tr)), ln *= Is(hr, hn)), ln !== 0 ? Di.push({ nodeInfo: Yr, depth: hn, opacity: ln, wvpForNode: va, wvpForTile: pn, nodeModelMatrix: ya, tileModelMatrix: Pn }) : Fi.hidden = !0;
                }
                dr || Di.sort((Yr, Fi) => !mr || Yr.opacity === 1 && Fi.opacity === 1 ? Yr.depth < Fi.depth ? -1 : 1 : Yr.opacity === 1 ? -1 : Fi.opacity === 1 ? 1 : Yr.depth > Fi.depth ? -1 : 1);
                for (const Yr of Di) {
                  const Fi = Yr.nodeInfo, Ki = Fi.node;
                  let Qi = r.ab.mat4.multiply([], sr, Yr.tileModelMatrix);
                  r.ab.mat4.multiply(Qi, Vt, Qi);
                  const Mn = r.ab.mat4.invert([], Qi);
                  r.ab.mat4.transpose(Mn, Mn), r.ab.mat4.scale(Mn, Mn, dc), Qi = r.ab.mat4.multiply(Qi, Qi, Ki.matrix);
                  const Pn = Ve.renderPass === "light-beam", Zn = ut.paint.get("model-color-use-theme").constantOr("default") === "none", jn = xi & r.dp.HasMapboxMeshFeatures, ya = jn ? 0 : Fi.evaluatedRMEA[0][2];
                  for (let va = 0; va < Ki.meshes.length; ++va) {
                    const pn = Ki.meshes[va], hn = va === Ki.lightMeshIndex;
                    let ln = Yr.wvpForNode;
                    if (hn) {
                      if (!Pn && !Ve.terrain && Ve.shadowRenderer) {
                        Ve.currentLayer < Ve.firstLightBeamLayer && (Ve.firstLightBeamLayer = Ve.currentLayer);
                        continue;
                      }
                      ln = Yr.wvpForTile;
                    } else if (Pn) continue;
                    const Vi = { defines: [] }, Rn = [];
                    if (!dr && dt && (dt.useNormalOffset = !!pn.normalBuffer), In(Vi.defines, Rn, pn, Ve, Zn ? null : ut.lut), jn || Vi.defines.push("DIFFUSE_SHADED"), bn && Vi.defines.push("SHADOWS_SINGLE_CASCADE"), br && (dr ? br.numRenderedVerticesInShadowPass += pn.vertexArray.length : br.numRenderedVerticesInTransparentPass += pn.vertexArray.length), dr) {
                      ol(pn, Yr.nodeModelMatrix, Ve, ut);
                      continue;
                    }
                    let ia = null;
                    if (_t) {
                      const Za = Ga(Yr.nodeModelMatrix, Ve.transform);
                      if (ia = new Float32Array(Za), mt.projection.name !== "globe") {
                        const bo = pn.aabb.min, mn = pn.aabb.max, [Yl, Vo] = _t.getOpacityForBounds(Za, bo[0], bo[1], mn[0], mn[1]);
                        Vi.overrideFog = Yl >= ft || Vo >= ft;
                      }
                    }
                    const fn = pn.material;
                    let wa;
                    fn.occlusionTexture && fn.occlusionTexture.offsetScale && (wa = fn.occlusionTexture.offsetScale, Vi.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                    const xo = Ve.getOrCreateProgram("model", Vi);
                    !dr && dt && dt.setupShadowsFromMatrix(Yr.tileModelMatrix, xo, dt.useNormalOffset), Ve.uploadCommonUniforms(xt, xo, null, ia);
                    const fa = fn.pbrMetallicRoughness;
                    fa.metallicFactor = 0.9, fa.roughnessFactor = 0.5;
                    const Wa = Ol(new Float32Array(ln), new Float32Array(Qi), new Float32Array(Mn), new Float32Array(Ki.matrix), Ve, Yr.opacity, fa.baseColorFactor.toRenderColor(null), fn.emissiveFactor, fa.metallicFactor, fa.roughnessFactor, fn, ya, ut, [0, 0, 0], wa);
                    !hn && (Fi.hasTranslucentParts || Yr.opacity < 1) && xo.draw(Ve, xt.gl.TRIANGLES, rr, _i.disabled, zi.disabled, vi.backCCW, Wa, ut.id, pn.vertexBuffer, pn.indexBuffer, pn.segments, ut.paint, Ve.transform.zoom, void 0, Rn), xo.draw(Ve, xt.gl.TRIANGLES, hn ? gr : rr, _i.disabled, hn || Yr.opacity < 1 || Fi.hasTranslucentParts ? zi.alphaBlended : zi.unblended, vi.backCCW, Wa, ut.id, pn.vertexBuffer, pn.indexBuffer, pn.segments, ut.paint, Ve.transform.zoom, void 0, Rn);
                  }
                }
              }
            }();
          }(l, t, n, u), void G();
          if (X.type !== "model") return;
          const K = X.getModels(), ae = [], oe = l.transform.getFreeCameraOptions().position, pe = r.ab.vec3.scale([], [oe.x, oe.y, oe.z], l.transform.worldSize);
          r.ab.vec3.negate(pe, pe);
          const Be = [], Re = [];
          let Ge = 0;
          for (const Ve of K) {
            const et = n.paint.get("model-rotation").constantOr(null), ut = n.paint.get("model-scale").constantOr(null), st = n.paint.get("model-translation").constantOr(null);
            Ve.computeModelMatrix(l, et, ut, st, !0, !0, !1);
            const xt = r.ab.mat4.identity([]), mt = r.dj(Ve.position.lat, l.transform.zoom), _t = r.ab.mat4.fromScaling([], [1, 1, 1 / mt]);
            r.ab.mat4.translate(xt, xt, pe), ae.push({ zScaleMatrix: _t, negCameraPosMatrix: xt });
            for (const dt of Ve.nodes) ta(l.transform, dt, Ve.matrix, l.transform.expandedFarZProjMatrix, Ge, Be, Re);
            Ge++;
          }
          if (Be.sort((Ve, et) => et.depth - Ve.depth), l.renderPass !== "shadow") {
            if (d === 1) for (const Ve of Re) Dn(Ve, l, n, ae[Ve.modelIndex], _i.disabled, l.colorModeForRenderPass());
            else {
              for (const Ve of Re) Dn(Ve, l, n, ae[Ve.modelIndex], _i.disabled, zi.disabled);
              for (const Ve of Re) Dn(Ve, l, n, ae[Ve.modelIndex], l.stencilModeFor3D(), l.colorModeForRenderPass());
              l.resetStencilClippingMasks();
            }
            for (const Ve of Be) Dn(Ve, l, n, ae[Ve.modelIndex], _i.disabled, l.colorModeForRenderPass());
            G();
          } else {
            for (const Ve of Re) ol(Ve.mesh, Ve.nodeModelMatrix, l, n);
            for (const Ve of Be) ol(Ve.mesh, Ve.nodeModelMatrix, l, n);
            G();
          }
        } }, Wl = { line: function(l, t, n) {
          if (l.hasElevatedBuckets = !1, l.hasNonElevatedBuckets = !1, l._unevaluatedLayout.getValue("line-elevation-reference") !== void 0 || l._unevaluatedLayout.getValue("line-z-offset") !== void 0) {
            if (t) {
              const u = t.getVisibleCoordinates();
              for (const d of u) {
                const _ = t.getTile(d).getBucket(l);
                if (_ && (_.hasZOffset ? l.hasElevatedBuckets = !0 : l.hasNonElevatedBuckets = !0, l.hasElevatedBuckets && l.hasNonElevatedBuckets)) break;
              }
            }
          } else l.hasNonElevatedBuckets = !0;
        }, model: function(l, t, n) {
          const u = t.getSource();
          if (!u.loaded()) return;
          if (u.type === "vector" || u.type === "geojson") return void (n.modelManager && n.modelManager.upload(n, u.type === "vector" ? l.scope : ""));
          if (u.type === "batched-model" || u.type !== "model") return;
          const d = u.getModels();
          for (const _ of d) _.upload(n.context);
        }, raster: function(l, t, n) {
          const u = t.getSource();
          if (!(u instanceof Yn && u.loaded())) return;
          const d = l.sourceLayer || u.rasterLayerIds && u.rasterLayerIds[0];
          if (!d) return;
          const _ = l.paint.get("raster-array-band") || u.getInitialBand(d);
          if (_ == null) return;
          const v = t.getIds().map((L) => t.getTileByID(L));
          for (const L of v) L.updateNeeded(d, _) && u.prepareTile(L, d, _);
        }, "raster-particle": function(l, t, n) {
          const u = t.getSource();
          if (!(u instanceof Yn && u.loaded())) return;
          const d = l.sourceLayer || u.rasterLayerIds && u.rasterLayerIds[0];
          if (!d) return;
          const _ = l.paint.get("raster-particle-array-band") || u.getInitialBand(d);
          if (_ == null) return;
          const v = t.getIds().map((L) => t.getTileByID(L));
          for (const L of v) L.updateNeeded(d, _) && u.prepareTile(L, d, _);
        } };
        class ah {
          constructor(t, n, u, d, _) {
            this.context = new Hh(t, n), this.transform = u, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = _, this._timeStamp = r.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = { forceEnablePrecipitation: !1, showTerrainProxyTiles: !1, fpsWindow: 30, continousRedraw: !1, enabledLayers: {} };
            const v = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
            for (const G of v) this._debugParams.enabledLayers[G] = !0;
            _.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
              this.style.map.triggerRepaint();
            }), _.registerParameter(this._debugParams, ["Precipitation"], "forceEnablePrecipitation"), _.registerParameter(this._debugParams, ["FPS"], "fpsWindow", { min: 1, max: 100, step: 1 }), _.registerBinding(this._debugParams, ["FPS"], "continousRedraw", { readonly: !0, label: "continuous redraw" }), _.registerBinding(this, ["FPS"], "_averageFPS", { readonly: !0, label: "value" }), _.registerBinding(this, ["FPS"], "_averageFPS", { readonly: !0, label: "graph", view: "graph", min: 0, max: 200 });
            for (const G of v) _.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], G);
            this.occlusionParams = new Su(_), this.setup(), this.numSublayers = Xa.maxUnderzooming + Xa.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new r.dv(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new wl(this), this._wireframeDebugCache = new Gl(), this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];
            const L = new r.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0));
            this.emptyDepthTexture = new r.T(this.context, L, t.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = d;
          }
          updateTerrain(t, n) {
            const u = !!t && !!t.terrain && this.transform.projection.supportsTerrain;
            if (!(u || this._terrain && this._terrain.enabled)) return;
            this._terrain || (this._terrain = new Bo(this, t));
            const d = this._terrain;
            this.transform.elevation = u ? d : null, d.update(t, this.transform, n), this.transform.elevation && !d.enabled && (this.transform.elevation = null);
          }
          _updateFog(t) {
            const n = t.fog;
            if (!n || this.transform.projection.name === "globe" || n.getOpacity(this.transform.pitch) < 1 || n.properties.get("horizon-blend") < 0.03) return void (this.transform.fogCullDistSq = null);
            const [u, d] = n.getFovAdjustedRange(this.transform._fov);
            if (u > d) return void (this.transform.fogCullDistSq = null);
            const _ = u + 0.78 * (d - u);
            this.transform.fogCullDistSq = _ * _;
          }
          get terrain() {
            return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
          }
          get forceTerrainMode() {
            return this._forceTerrainMode;
          }
          set forceTerrainMode(t) {
            t && !this._terrain && (this._terrain = new Bo(this, this.style)), this._forceTerrainMode = t;
          }
          get shadowRenderer() {
            return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
          }
          get wireframeDebugCache() {
            return this._wireframeDebugCache;
          }
          resize(t, n) {
            if (this.width = t * r.q.devicePixelRatio, this.height = n * r.q.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const u of this.style.order) this.style._mergedLayers[u].resize();
          }
          setup() {
            const t = this.context, n = new r.b4();
            n.emplaceBack(0, 0), n.emplaceBack(r.ag, 0), n.emplaceBack(0, r.ag), n.emplaceBack(r.ag, r.ag), this.tileExtentBuffer = t.createVertexBuffer(n, r.b6.members), this.tileExtentSegments = r.b7.simpleSegment(0, 0, 4, 2);
            const u = new r.b4();
            u.emplaceBack(0, 0), u.emplaceBack(r.ag, 0), u.emplaceBack(0, r.ag), u.emplaceBack(r.ag, r.ag), this.debugBuffer = t.createVertexBuffer(u, r.b6.members), this.debugSegments = r.b7.simpleSegment(0, 0, 4, 5);
            const d = new r.b4();
            d.emplaceBack(-1, -1), d.emplaceBack(1, -1), d.emplaceBack(-1, 1), d.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(d, r.b6.members), this.viewportSegments = r.b7.simpleSegment(0, 0, 4, 2);
            const _ = new r.aT();
            _.emplaceBack(0, 0, 0, 0), _.emplaceBack(r.ag, 0, r.ag, 0), _.emplaceBack(0, r.ag, 0, r.ag), _.emplaceBack(r.ag, r.ag, r.ag, r.ag), this.mercatorBoundsBuffer = t.createVertexBuffer(_, r.b9.members), this.mercatorBoundsSegments = r.b7.simpleSegment(0, 0, 4, 2);
            const v = new r.aU();
            v.emplaceBack(0, 1, 2), v.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(v);
            const L = new r.b5();
            for (const X of [0, 1, 3, 2, 0]) L.emplaceBack(X);
            this.debugIndexBuffer = t.createIndexBuffer(L), this.emptyTexture = new r.T(t, new r.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA8), this.identityMat = r.ab.mat4.create();
            const G = this.context.gl;
            this.stencilClearMode = new _i({ func: G.ALWAYS, mask: 0 }, 0, 255, G.ZERO, G.ZERO, G.ZERO), this.loadTimeStamps.push(performance.now());
          }
          getMercatorTileBoundsBuffers() {
            return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
          }
          getTileBoundsBuffers(t) {
            return t._makeTileBoundsBuffers(this.context, this.transform.projection), t._tileBoundsBuffer ? { tileBoundsBuffer: t._tileBoundsBuffer, tileBoundsIndexBuffer: t._tileBoundsIndexBuffer, tileBoundsSegments: t._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
          }
          clearStencil() {
            const t = this.context.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, t.TRIANGLES, ui.disabled, this.stencilClearMode, zi.disabled, vi.disabled, Tn(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          resetStencilClippingMasks() {
            this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
          }
          _renderTileClippingMasks(t, n, u) {
            if (!n || this.currentStencilSource === n.id || !t.isTileClipped() || !u || u.length === 0) return;
            if (this._tileClippingMaskIDs && !this.terrain) {
              let L = !1;
              for (const G of u) if (this._tileClippingMaskIDs[G.key] === void 0) {
                L = !0;
                break;
              }
              if (!L) return;
            }
            this.currentStencilSource = n.id;
            const d = this.context, _ = d.gl;
            this.nextStencilID + u.length > 256 && this.clearStencil(), d.setColorMode(zi.disabled), d.setDepthMode(ui.disabled);
            const v = this.getOrCreateProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const L of u) {
              const G = n.getTile(L), X = this._tileClippingMaskIDs[L.key] = this.nextStencilID++, { tileBoundsBuffer: K, tileBoundsIndexBuffer: ae, tileBoundsSegments: oe } = this.getTileBoundsBuffers(G);
              v.draw(this, _.TRIANGLES, ui.disabled, new _i({ func: _.ALWAYS, mask: 0 }, X, 255, _.KEEP, _.KEEP, _.REPLACE), zi.disabled, vi.disabled, Tn(L.projMatrix), "$clipping", K, ae, oe);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t = this.nextStencilID++, n = this.context.gl;
            return new _i({ func: n.NOTEQUAL, mask: 255 }, t, 255, n.KEEP, n.KEEP, n.REPLACE);
          }
          stencilModeForClipping(t) {
            if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t);
            const n = this.context.gl;
            return new _i({ func: n.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, n.KEEP, n.KEEP, n.REPLACE);
          }
          stencilConfigForOverlap(t) {
            const n = this.context.gl, u = t.sort((v, L) => L.overscaledZ - v.overscaledZ), d = u[u.length - 1].overscaledZ, _ = u[0].overscaledZ - d + 1;
            if (_ > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + _ > 256 && this.clearStencil();
              const v = {};
              for (let L = 0; L < _; L++) v[L + d] = new _i({ func: n.GEQUAL, mask: 255 }, L + this.nextStencilID, 255, n.KEEP, n.KEEP, n.REPLACE);
              return this.nextStencilID += _, [v, u];
            }
            return [{ [d]: _i.disabled }, u];
          }
          colorModeForRenderPass() {
            const t = this.context.gl;
            return this._showOverdrawInspector ? new zi([t.CONSTANT_COLOR, t.ONE, t.CONSTANT_COLOR, t.ONE], new r.aj(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? zi.unblended : zi.alphaBlended;
          }
          colorModeForDrapableLayerRenderPass(t) {
            const n = this.context.gl;
            return this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture && this.renderPass === "translucent" ? new zi([n.ONE, n.ONE_MINUS_SRC_ALPHA, n.CONSTANT_ALPHA, n.ONE_MINUS_SRC_ALPHA], new r.aj(0, 0, 0, t === void 0 ? 0 : t), [!0, !0, !0, !0]) : this.colorModeForRenderPass();
          }
          depthModeForSublayer(t, n, u, d = !1) {
            if (this.depthOcclusion) return new ui(this.context.gl.GREATER, ui.ReadOnly, this.depthRangeFor3D);
            if (!this.opaquePassEnabledForLayer() && !d) return ui.disabled;
            const _ = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
            return new ui(u || this.context.gl.LEQUAL, n, [_, _]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          blitDepth() {
            const t = this.context.gl, n = Math.ceil(this.width), u = Math.ceil(this.height), d = this.context.bindFramebuffer.get(), _ = t.getParameter(t.TEXTURE_BINDING_2D);
            this.depthFBO && this.depthFBO.width === n && this.depthFBO.height === u || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), n !== 0 && u !== 0 && (this.depthFBO = new cc(this.context, n, u, !1, "texture"), this.depthTexture = new r.T(this.context, { width: n, height: u, data: null }, t.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(d), t.bindTexture(t.TEXTURE_2D, _), this.depthFBO && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t.blitFramebuffer(0, 0, n, u, 0, 0, n, u, t.DEPTH_BUFFER_BIT, t.NEAREST), t.bindFramebuffer(t.FRAMEBUFFER, this.context.bindFramebuffer.current));
          }
          updateAverageFPS() {
            this._fpsHistory.push(this._dt === 0 ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((t, n) => t + n / this._fpsHistory.length, 0));
          }
          render(t, n) {
            const u = r.q.now();
            this._dt = u - this._timeStamp, this._timeStamp = u, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t.map.repaint, this.style = t, this.options = n;
            const d = this.style._mergedLayers, _ = !(!this.terrain || !this.terrain.enabled), v = () => this.style._getOrder(_).filter((Bt) => {
              const rr = d[Bt];
              return !(rr.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[rr.type];
            });
            let L = v(), G = !1, X = !1;
            for (const Bt of L) {
              const rr = d[Bt];
              rr.type === "circle" && (G = !0), rr.type === "symbol" && (rr.hasInitialOcclusionOpacityProperties ? X = !0 : G = !0);
            }
            let K = L.map((Bt) => d[Bt]);
            const ae = this.style._mergedSourceCaches;
            this.imageManager = t.imageManager, this.modelManager = t.modelManager, this.symbolFadeChange = t.placement.symbolFadeChange(r.q.now()), this.imageManager.beginFrame();
            let oe = 0, pe = !1;
            for (const Bt in ae) {
              const rr = ae[Bt];
              rr.used && (rr.prepare(this.context), rr.getSource().usedInConflation && ++oe);
            }
            let Be = !1;
            for (const Bt of K) Bt.isHidden(this.transform.zoom) || (Bt.type === "clip" && (Be = !0), this.prepareLayer(Bt));
            const Re = {}, Ge = {}, Ve = {}, et = {}, ut = {};
            for (const Bt in ae) {
              const rr = ae[Bt];
              Re[Bt] = rr.getVisibleCoordinates(), Ge[Bt] = Re[Bt].slice().reverse(), Ve[Bt] = rr.getVisibleCoordinates(!0).reverse(), et[Bt] = rr.getShadowCasterCoordinates(), ut[Bt] = rr.sortCoordinatesByDistance(Re[Bt]);
            }
            const st = (Bt) => {
              const rr = this.style.getLayerSourceCache(Bt);
              return rr && rr.used ? rr.getSource() : null;
            };
            if (oe || Be || this._clippingActiveLastFrame) {
              const Bt = [], rr = [];
              let gr = 0;
              for (const Ut of K) this.isSourceForClippingOrConflation(Ut, st(Ut)) && (Bt.push(Ut), rr.push(gr)), gr++;
              if (Be || Bt.length > 1 || this._clippingActiveLastFrame) {
                Be = !1;
                const Ut = [];
                for (let dr = 0; dr < Bt.length; dr++) {
                  const ir = Bt[dr], Tr = rr[dr], mr = this.style.getLayerSourceCache(ir);
                  if (!mr || !mr.used || !mr.getSource().usedInConflation && ir.type !== "clip") continue;
                  let hr = r.dx, br = r.by.None;
                  const Cr = [];
                  let Hr = !0;
                  if (ir.type === "clip") {
                    hr = Tr;
                    for (const Zr of ir.layout.get("clip-layer-types")) br |= Zr === "model" ? r.by.Model : Zr === "symbol" ? r.by.Symbol : r.by.FillExtrusion;
                    for (const Zr of ir.layout.get("clip-layer-scope")) Cr.push(Zr);
                    ir.isHidden(this.transform.zoom) ? Hr = !1 : Be = !0;
                  }
                  Hr && Ut.push({ layer: ir.fqid, cache: mr, order: hr, clipMask: br, clipScope: Cr });
                }
                this.replacementSource.setSources(Ut), pe = !0;
              }
            }
            this._clippingActiveLastFrame = Be, pe || this.replacementSource.clear(), this.conflationActive = pe, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
            for (let Bt = 0; Bt < K.length; Bt++) {
              const rr = K[Bt], gr = rr.cutoffRange();
              if (this.longestCutoffRange = Math.max(gr, this.longestCutoffRange), gr > 0) {
                const Ut = st(rr);
                Ut && (this.minCutoffZoom = Math.max(Ut.minzoom, this.minCutoffZoom)), rr.minzoom && (this.minCutoffZoom = Math.max(rr.minzoom, this.minCutoffZoom));
              }
              rr.is3D() && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = Bt), this._lastOcclusionLayer = Bt);
            }
            const xt = this.style && this.style.fog;
            xt ? (this._fogVisible = xt.getOpacity(this.transform.pitch) !== 0, this._fogVisible && this.transform.projection.name !== "globe" && (this._fogVisible = xt.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(Ve), this.opaquePassCutoff = 0, L = v(), K = L.map((Bt) => d[Bt]));
            const mt = this._shadowRenderer;
            if (mt) {
              mt.updateShadowParameters(this.transform, this.style.directionalLight);
              for (const Bt in ae) for (const rr of Re[Bt]) {
                let gr = { min: 0, max: 0 };
                this.terrain && (gr = this.terrain.getMinMaxForTile(rr) || gr), mt.addShadowReceiver(rr.toUnwrapped(), gr.min, gr.max);
              }
            }
            this.transform.projection.name !== "globe" || this.globeSharedBuffers || (this.globeSharedBuffers = new r.dw(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new eh(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
            const _t = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), dt = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
            if (_t && !this._snow && (this._snow = new Au(this)), !_t && this._snow && (this._snow.destroy(), delete this._snow), dt && !this._rain && (this._rain = new Hl(this)), !dt && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), !Ct.has(this.context.gl)) return;
            this.renderPass = "offscreen";
            for (const Bt of K) {
              const rr = t.getLayerSourceCache(Bt);
              if (!Bt.hasOffscreenPass() || Bt.isHidden(this.transform.zoom)) continue;
              const gr = rr ? Ge[rr.id] : void 0;
              (Bt.type === "custom" || Bt.type === "raster" || Bt.type === "raster-particle" || Bt.isSky() || gr && gr.length) && this.renderLayer(this, rr, Bt, gr);
            }
            this.depthRangeFor3D = [0, 1 - (K.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, et)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
            const gt = this.transform.projection.name === "globe" || this.transform.isHorizonVisible(), Rt = (() => {
              if (n.showOverdrawInspector) return r.aj.black;
              const Bt = this.style.fog;
              if (Bt && this.transform.projection.supportsFog) {
                const rr = this.style.getLut(Bt.scope);
                if (!gt) {
                  const gr = Bt.properties.get("color-use-theme") === "none", Ut = Bt.properties.get("color").toRenderColor(gr ? null : rr).toArray01();
                  return new r.aj(...Ut);
                }
                if (gt) {
                  const gr = Bt.properties.get("space-color-use-theme") === "none", Ut = Bt.properties.get("space-color").toRenderColor(gr ? null : rr).toArray01();
                  return new r.aj(...Ut);
                }
              }
              return r.aj.transparent;
            })();
            if (this.context.clear({ color: Rt, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = n.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && gt && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for (this.currentLayer = L.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const Bt = K[this.currentLayer], rr = t.getLayerSourceCache(Bt);
              if (Bt.isSky()) continue;
              const gr = rr ? (Bt.is3D() ? ut : Ge)[rr.id] : void 0;
              this._renderTileClippingMasks(Bt, rr, gr), this.renderLayer(this, rr, Bt, gr);
            }
            if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && gt && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || r.ae(this.transform.zoom) > 0) && (this.transform.projection.name === "globe" || this.transform.isHorizonVisible())) for (this.currentLayer = 0; this.currentLayer < L.length; this.currentLayer++) {
              const Bt = K[this.currentLayer], rr = t.getLayerSourceCache(Bt);
              Bt.isSky() && this.renderLayer(this, rr, Bt, rr ? Ge[rr.id] : void 0);
            }
            function Jt(Bt, rr) {
              let gr;
              return rr && (gr = (Bt.type === "symbol" ? Ve : Bt.is3D() ? ut : Ge)[rr.id]), gr;
            }
            if (this.renderPass = "translucent", this.transform.projection.name === "globe") {
              for (this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < L.length; ) {
                const Bt = K[this.currentLayer];
                if (Bt.type === "raster" || Bt.type === "raster-particle") {
                  const rr = t.getLayerSourceCache(Bt);
                  this.renderLayer(this, rr, Bt, Jt(Bt, rr));
                }
                ++this.currentLayer;
              }
              this.renderElevatedRasterBackface = !1;
            }
            this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
            let Vt = 0;
            mt && (Vt = mt.getShadowCastingLayerCount());
            let or = !1, sr = -1;
            for (let Bt = 0; Bt < L.length; ++Bt) {
              const rr = K[Bt];
              rr.isHidden(this.transform.zoom) || rr.is3D() && (sr = Bt);
            }
            for (X && sr === -1 && (G = !0); this.currentLayer < L.length; ) {
              const Bt = K[this.currentLayer], rr = t.getLayerSourceCache(Bt);
              if (Bt.isSky()) ++this.currentLayer;
              else if (this.terrain && this.style.isLayerDraped(Bt)) {
                if (Bt.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
              } else {
                if (G && !or && this.terrain && !this.transform.isOrthographic && (or = !0, this.blitDepth()), X && sr !== -1 && this.currentLayer === sr + 1 && !this.transform.isOrthographic && this.blitDepth(), Bt.is3D() || this.terrain || this._renderTileClippingMasks(Bt, rr, rr ? Re[rr.id] : void 0), this.renderLayer(this, rr, Bt, Jt(Bt, rr)), !this.terrain && mt && Vt > 0 && Bt.hasShadowPass() && --Vt == 0 && (mt.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                  const gr = this.currentLayer;
                  for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= gr; this.currentLayer++) {
                    const Ut = K[this.currentLayer];
                    if (!Ut.hasLightBeamPass()) continue;
                    const dr = t.getLayerSourceCache(Ut);
                    this.renderLayer(this, dr, Ut, dr ? Ge[dr.id] : void 0);
                  }
                  this.currentLayer = gr, this.renderPass = "translucent";
                }
                if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                  const gr = this.currentLayer;
                  this.depthOcclusion = !0;
                  for (const Ut of this.layersWithOcclusionOpacity) {
                    this.currentLayer = Ut;
                    const dr = K[this.currentLayer], ir = t.getLayerSourceCache(dr), Tr = ir ? Ge[ir.id] : void 0;
                    dr.is3D() || this.terrain || this._renderTileClippingMasks(dr, ir, ir ? Re[ir.id] : void 0), this.renderLayer(this, ir, dr, Tr);
                  }
                  this.depthOcclusion = !1, this.currentLayer = gr, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
                }
                ++this.currentLayer;
              }
            }
            if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
              let Bt = null;
              K.forEach((rr) => {
                const gr = t.getLayerSourceCache(rr);
                gr && !rr.isHidden(this.transform.zoom) && gr.getVisibleCoordinates().length && (!Bt || Bt.getSource().maxzoom < gr.getSource().maxzoom) && (Bt = gr);
              }), Bt && this.options.showTileBoundaries && Iu.debug(this, Bt, Bt.getVisibleCoordinates(), r.aj.red, !1, this.options.showParseStatus);
            }
            this.terrain && this._debugParams.showTerrainProxyTiles && Iu.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new r.aj(1, 0.8, 0.1, 1), !0, this.options.showParseStatus), this.options.showPadding && function(Bt) {
              const rr = Bt.transform.padding;
              Ul(Bt, Bt.transform.height - (rr.top || 0), 3, As), Ul(Bt, rr.bottom || 0, 3, If), jl(Bt, rr.left || 0, 3, Kc), jl(Bt, Bt.transform.width - (rr.right || 0), 3, Zh);
              const gr = Bt.transform.centerPoint;
              (function(Ut, dr, ir, Tr) {
                vo(Ut, dr - 1, ir - 10, 2, 20, Tr), vo(Ut, dr - 10, ir - 1, 20, 2, Tr);
              })(Bt, gr.x, Bt.transform.height - gr.y, al);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), pe || (this.conflationActive = !1);
          }
          prepareLayer(t) {
            this.gpuTimingStart(t);
            const { unsupportedLayers: n } = this.transform.projection, u = !n || !n.includes(t.type);
            if (Wl[t.type] && (u || this.terrain && t.type === "custom")) {
              const d = this.style.getLayerSourceCache(t);
              Wl[t.type](t, d, this);
            }
            this.gpuTimingEnd();
          }
          renderLayer(t, n, u, d) {
            u.isHidden(this.transform.zoom) || (u.type === "background" || u.type === "sky" || u.type === "custom" || u.type === "model" || u.type === "raster" || u.type === "raster-particle" || d && d.length) && (this.id = u.id, this.gpuTimingStart(u), t.transform.projection.unsupportedLayers && t.transform.projection.unsupportedLayers.includes(u.type) && (!t.terrain || u.type !== "custom") || u.type === "clip" || Iu[u.type](t, n, u, d, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
          }
          gpuTimingStart(t) {
            if (!this.options.gpuTiming) return;
            const n = this.context.extTimerQuery, u = this.context.gl;
            let d = this.gpuTimers[t.id];
            d || (d = this.gpuTimers[t.id] = { calls: 0, cpuTime: 0, query: u.createQuery() }), d.calls++, u.beginQuery(n.TIME_ELAPSED_EXT, d.query);
          }
          gpuTimingDeferredRenderStart() {
            if (this.options.gpuTimingDeferredRender) {
              const t = this.context.extTimerQuery, n = this.context.gl, u = n.createQuery();
              this.deferredRenderGpuTimeQueries.push(u), n.beginQuery(t.TIME_ELAPSED_EXT, u);
            }
          }
          gpuTimingDeferredRenderEnd() {
            this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
          }
          gpuTimingEnd() {
            this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
          }
          collectGpuTimers() {
            const t = this.gpuTimers;
            return this.gpuTimers = {}, t;
          }
          collectDeferredRenderGpuQueries() {
            const t = this.deferredRenderGpuTimeQueries;
            return this.deferredRenderGpuTimeQueries = [], t;
          }
          queryGpuTimers(t) {
            const n = {};
            for (const u in t) {
              const d = t[u], _ = this.context.extTimerQuery, v = _.getQueryParameter(d.query, this.context.gl.QUERY_RESULT) / 1e6;
              _.deleteQueryEXT(d.query), n[u] = v;
            }
            return n;
          }
          queryGpuTimeDeferredRender(t) {
            if (!this.options.gpuTimingDeferredRender) return 0;
            const n = this.context.gl;
            let u = 0;
            for (const d of t) u += n.getQueryParameter(d, n.QUERY_RESULT) / 1e6, n.deleteQuery(d);
            return u;
          }
          translatePosMatrix(t, n, u, d, _) {
            if (!u[0] && !u[1]) return t;
            const v = _ ? d === "map" ? this.transform.angle : 0 : d === "viewport" ? -this.transform.angle : 0;
            if (v) {
              const X = Math.sin(v), K = Math.cos(v);
              u = [u[0] * K - u[1] * X, u[0] * X + u[1] * K];
            }
            const L = [_ ? u[0] : r.ar(n, u[0], this.transform.zoom), _ ? u[1] : r.ar(n, u[1], this.transform.zoom), 0], G = new Float32Array(16);
            return r.ab.mat4.translate(G, t, L), G;
          }
          saveTileTexture(t) {
            const n = t.size[0], u = this._tileTextures[n];
            u ? u.push(t) : this._tileTextures[n] = [t];
          }
          getTileTexture(t) {
            const n = this._tileTextures[t];
            return n && n.length > 0 ? n.pop() : null;
          }
          terrainRenderModeElevated() {
            return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
          }
          linearFloatFilteringSupported() {
            return this.context.extTextureFloatLinear != null;
          }
          currentGlobalDefines(t, n, u) {
            const d = u === void 0 ? this.terrain && this.terrain.renderingToTexture : u, _ = [];
            return this.style && this.style.enable3dLights() && (t === "globeRaster" || t === "terrainRaster" ? (_.push("LIGHTING_3D_MODE"), _.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : d || _.push("LIGHTING_3D_MODE")), this.renderPass === "shadow" && (this._shadowMapDebug || _.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (_.push("TERRAIN"), this.linearFloatFilteringSupported() && _.push("TERRAIN_DEM_FLOAT_FORMAT")), this.transform.projection.name === "globe" && _.push("GLOBE"), !this._fogVisible || d || n !== void 0 && !n || _.push("FOG", "FOG_DITHERING"), d && _.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && _.push("OVERDRAW_INSPECTOR"), _;
          }
          getOrCreateProgram(t, n) {
            this.cache = this.cache || {};
            const u = n && n.defines || [], d = n && n.config, _ = this.currentGlobalDefines(t, n && n.overrideFog, n && n.overrideRtt).concat(u), v = Uh.cacheKey(Tl[t], t, _, d);
            return this.cache[v] || (this.cache[v] = new Uh(this.context, t, Tl[t], d, Yc[t], _)), this.cache[v];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new r.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
          }
          destroy() {
            this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
          }
          prepareDrawTile() {
            this.terrain && this.terrain.prepareDrawTile();
          }
          uploadCommonLightUniforms(t, n) {
            if (this.style.enable3dLights()) {
              const u = this.style.directionalLight, d = this.style.ambientLight;
              if (u && d) {
                const _ = ((v, L, G) => {
                  const X = v.properties.get("direction"), K = v.properties.get("color-use-theme") === "none", ae = v.properties.get("color").toRenderColor(K ? null : G.getLut(v.scope)).toArray01(), oe = v.properties.get("intensity"), pe = L.properties.get("color-use-theme") === "none", Be = L.properties.get("color").toRenderColor(pe ? null : G.getLut(L.scope)).toArray01(), Re = L.properties.get("intensity"), Ge = [X.x, X.y, X.z], Ve = r.cM(Be, Re), et = r.cM(ae, oe);
                  return { u_lighting_ambient_color: Ve, u_lighting_directional_dir: Ge, u_lighting_directional_color: et, u_ground_radiance: Qa(Ge, et, Ve) };
                })(u, d, this.style);
                n.setLightsUniformValues(t, _);
              }
            }
          }
          uploadCommonUniforms(t, n, u, d, _) {
            if (this.uploadCommonLightUniforms(t, n), this.terrain && this.terrain.renderingToTexture) return;
            const v = this.style.fog;
            if (v) {
              const L = v.getOpacity(this.transform.pitch), G = ((X, K, ae, oe, pe, Be, Re, Ge, Ve, et, ut, st) => {
                const xt = X.transform, mt = K.properties.get("color-use-theme") === "none", _t = K.properties.get("color").toRenderColor(mt ? null : X.style.getLut(K.scope)).toArray01();
                _t[3] = oe;
                const dt = X.frameCounter / 1e3 % 1, [gt, Rt] = K.properties.get("vertical-range");
                return { u_fog_matrix: ae ? xt.calculateFogTileMatrix(ae) : st || X.identityMat, u_fog_range: K.getFovAdjustedRange(xt._fov), u_fog_color: _t, u_fog_horizon_blend: K.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(gt, Rt), Rt], u_fog_temporal_offset: dt, u_frustum_tl: pe, u_frustum_tr: Be, u_frustum_br: Re, u_frustum_bl: Ge, u_globe_pos: Ve, u_globe_radius: et, u_viewport: ut, u_globe_transition: r.ae(xt.zoom), u_is_globe: +(xt.projection.name === "globe") };
              })(this, v, u, L, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * r.q.devicePixelRatio, this.transform.height * r.q.devicePixelRatio], d);
              n.setFogUniformValues(t, G);
            }
            _ && n.setCutoffUniformValues(t, _.uniformValues);
          }
          setTileLoadedFlag(t) {
            this.tileLoaded = t;
          }
          saveCanvasCopy() {
            const t = this.canvasCopy();
            t && (this.frameCopies.push(t), this.tileLoaded = !1);
          }
          canvasCopy() {
            const t = this.context.gl, n = t.createTexture();
            return t.bindTexture(t.TEXTURE_2D, n), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, 0, 0, t.drawingBufferWidth, t.drawingBufferHeight, 0), n;
          }
          getCanvasCopiesAndTimestamps() {
            return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
          }
          averageElevationNeedsEasing() {
            if (!this.transform._elevation) return !1;
            const t = this.style && this.style.fog;
            return !!t && t.getOpacity(this.transform.pitch) !== 0;
          }
          getBackgroundTiles() {
            const t = this._backgroundTiles, n = this._backgroundTiles = {}, u = this.transform.coveringTiles({ tileSize: 512 });
            for (const d of u) n[d.key] = t[d.key] || new Zo(d, 512, this.transform.tileZoom, this);
            return n;
          }
          clearBackgroundTiles() {
            this._backgroundTiles = {};
          }
          isSourceForClippingOrConflation(t, n) {
            return !(!t.is3D() || t.type !== "clip" && (t.minzoom && t.minzoom > this.transform.zoom || (this.style._clipLayerPresent || t.sourceLayer !== "building") && (!n || n.type !== "batched-model")));
          }
          isTileAffectedByFog(t) {
            if (!this.style || !this.style.fog) return !1;
            if (this.transform.projection.name === "globe") return !0;
            let n = this._cachedTileFogOpacities[t.key];
            return n || (this._cachedTileFogOpacities[t.key] = n = this.style.fog.getOpacityForTile(t)), n[0] >= ft || n[1] >= ft;
          }
          setupDepthForOcclusion(t, n, u) {
            const d = this.context, _ = d.gl, v = !!u;
            var L;
            u || (u = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 }), d.activeTexture.set(_.TEXTURE3), t && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(_.NEAREST, _.CLAMP_TO_EDGE), u.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], u.u_depth_range_unpack = [2 / ((L = this.depthRangeFor3D)[1] - L[0]), -1 - 2 * L[0] / (L[1] - L[0])], u.u_occluder_half_size = 0.5 * this.occlusionParams.occluderSize, u.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(_.NEAREST, _.CLAMP_TO_EDGE), d.activeTexture.set(_.TEXTURE0), v || n.setTerrainUniformValues(d, u);
          }
        }
        function gc(l, t) {
          let n = !1, u = null;
          const d = () => {
            u = null, n && (l(), u = setTimeout(d, t), n = !1);
          };
          return () => (n = !0, u || d(), u);
        }
        class qh {
          constructor(t) {
            this._hashName = t && encodeURIComponent(t), r.aP(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = gc(this._updateHashUnthrottled.bind(this), 300);
          }
          addTo(t) {
            return this._map = t, window.addEventListener("hashchange", this._onHashChange, !1), t.on("moveend", this._updateHash), this;
          }
          remove() {
            return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
          }
          getHashString() {
            const t = this._map;
            if (!t) return "";
            const n = oh(t);
            if (this._hashName) {
              const u = this._hashName;
              let d = !1;
              const _ = location.hash.slice(1).split("&").map((v) => {
                const L = v.split("=")[0];
                return L === u ? (d = !0, `${L}=${n}`) : v;
              }).filter((v) => v);
              return d || _.push(`${u}=${n}`), `#${_.join("&")}`;
            }
            return `#${n}`;
          }
          _getCurrentHash() {
            const t = location.hash.replace("#", "");
            if (this._hashName) {
              let n;
              return t.split("&").map((u) => u.split("=")).forEach((u) => {
                u[0] === this._hashName && (n = u);
              }), (n && n[1] || "").split("/");
            }
            return t.split("/");
          }
          _onHashChange() {
            const t = this._map;
            if (!t) return !1;
            const n = this._getCurrentHash();
            if (n.length >= 3 && !n.some((u) => isNaN(u))) {
              const u = t.dragRotate.isEnabled() && t.touchZoomRotate.isEnabled() ? +(n[3] || 0) : t.getBearing();
              return t.jumpTo({ center: [+n[2], +n[1]], zoom: +n[0], bearing: u, pitch: +(n[4] || 0) }), !0;
            }
            return !1;
          }
          _updateHashUnthrottled() {
            history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
          }
        }
        function oh(l, t) {
          const n = l.getCenter(), u = Math.round(100 * l.getZoom()) / 100, d = Math.ceil((u * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), _ = Math.pow(10, d), v = Math.round(n.lng * _) / _, L = Math.round(n.lat * _) / _, G = l.getBearing(), X = l.getPitch();
          let K = t ? `/${v}/${L}/${u}` : `${u}/${L}/${v}`;
          return (G || X) && (K += "/" + Math.round(10 * G) / 10), X && (K += `/${Math.round(X)}`), K;
        }
        const Zl = { linearity: 0.3, easing: r.dy(0, 0, 0.3, 1) }, $h = r.l({ deceleration: 2500, maxSpeed: 1400 }, Zl), Xh = r.l({ deceleration: 20, maxSpeed: 1400 }, Zl), Yh = r.l({ deceleration: 1e3, maxSpeed: 360 }, Zl), Cf = r.l({ deceleration: 1e3, maxSpeed: 90 }, Zl);
        class Kh {
          constructor(t) {
            this._map = t, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: r.q.now(), settings: t });
          }
          _drainInertiaBuffer() {
            const t = this._inertiaBuffer, n = r.q.now();
            for (; t.length > 0 && n - t[0].time > 160; ) t.shift();
          }
          _onMoveEnd(t) {
            if (this._map._prefersReducedMotion() || (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)) return;
            const n = { zoom: 0, bearing: 0, pitch: 0, pan: new r.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: _ } of this._inertiaBuffer) n.zoom += _.zoomDelta || 0, n.bearing += _.bearingDelta || 0, n.pitch += _.pitchDelta || 0, _.panDelta && n.pan._add(_.panDelta), _.around && (n.around = _.around), _.pinchAround && (n.pinchAround = _.pinchAround);
            const u = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, d = {};
            if (n.pan.mag()) {
              const _ = vc(n.pan.mag(), u, r.l({}, $h, t || {}));
              d.offset = n.pan.mult(_.amount / n.pan.mag()), d.center = this._map.transform.center, yc(d, _);
            }
            if (n.zoom) {
              const _ = vc(n.zoom, u, Xh);
              d.zoom = this._map.transform.zoom + _.amount, yc(d, _);
            }
            if (n.bearing) {
              const _ = vc(n.bearing, u, Yh);
              d.bearing = this._map.transform.bearing + r.aw(_.amount, -179, 179), yc(d, _);
            }
            if (n.pitch) {
              const _ = vc(n.pitch, u, Cf);
              d.pitch = this._map.transform.pitch + _.amount, yc(d, _);
            }
            if (d.zoom || d.bearing) {
              const _ = n.pinchAround === void 0 ? n.around : n.pinchAround;
              d.around = _ ? this._map.unproject(_) : this._map.getCenter();
            }
            return this.clear(), d.noMoveStart = !0, d;
          }
        }
        function yc(l, t) {
          (!l.duration || l.duration < t.duration) && (l.duration = t.duration, l.easing = t.easing);
        }
        function vc(l, t, n) {
          const { maxSpeed: u, linearity: d, deceleration: _ } = n, v = r.aw(l * d / (t / 1e3), -u, u), L = Math.abs(v) / (_ * d);
          return { easing: n.easing, duration: 1e3 * L, amount: v * (L / 2) };
        }
        class Ha extends r.z {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, n, u, d = {}) {
            const _ = W(n.getCanvasContainer(), u), v = n.unproject(_);
            super(t, r.l({ point: _, lngLat: v, originalEvent: u }, d)), this._defaultPrevented = !1, this.target = n;
          }
        }
        class Cu extends r.z {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, n, u) {
            const d = t === "touchend" ? u.changedTouches : u.touches, _ = q(n.getCanvasContainer(), d), v = _.map((G) => n.unproject(G)), L = _.reduce((G, X, K, ae) => G.add(X.div(ae.length)), new r.P(0, 0));
            super(t, { points: _, point: L, lngLats: v, lngLat: n.unproject(L), originalEvent: u }), this._defaultPrevented = !1;
          }
        }
        class Jh extends r.z {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, n) {
            super("wheel", { originalEvent: n }), this._defaultPrevented = !1;
          }
        }
        class sh {
          constructor(t, n) {
            this._map = t, this._clickTolerance = n.clickTolerance;
          }
          reset() {
            this._mousedownPos = void 0;
          }
          wheel(t) {
            return this._firePreventable(new Jh(this._map, t));
          }
          mousedown(t, n) {
            return this._mousedownPos = n, this._firePreventable(new Ha(t.type, this._map, t));
          }
          mouseup(t) {
            this._map.fire(new Ha(t.type, this._map, t));
          }
          preclick(t) {
            const n = r.l({}, t);
            n.type = "preclick", this._map.fire(new Ha(n.type, this._map, n));
          }
          click(t, n) {
            this._mousedownPos && this._mousedownPos.dist(n) >= this._clickTolerance || (this.preclick(t), this._map.fire(new Ha(t.type, this._map, t)));
          }
          dblclick(t) {
            return this._firePreventable(new Ha(t.type, this._map, t));
          }
          mouseover(t) {
            this._map.fire(new Ha(t.type, this._map, t));
          }
          mouseout(t) {
            this._map.fire(new Ha(t.type, this._map, t));
          }
          touchstart(t) {
            return this._firePreventable(new Cu(t.type, this._map, t));
          }
          touchmove(t) {
            this._map.fire(new Cu(t.type, this._map, t));
          }
          touchend(t) {
            this._map.fire(new Cu(t.type, this._map, t));
          }
          touchcancel(t) {
            this._map.fire(new Cu(t.type, this._map, t));
          }
          _firePreventable(t) {
            if (this._map.fire(t), t.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class pd {
          constructor(t) {
            this._map = t;
          }
          reset() {
            this._delayContextMenu = !1, this._contextMenuEvent = void 0;
          }
          mousemove(t) {
            this._map.fire(new Ha(t.type, this._map, t));
          }
          mousedown() {
            this._delayContextMenu = !0;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Ha("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t) {
            this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new Ha(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Nn {
          constructor(t, n) {
            this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = n.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(t, n) {
            this.isEnabled() && t.shiftKey && t.button === 0 && (B(), this._startPos = this._lastPos = n, this._active = !0);
          }
          mousemoveWindow(t, n) {
            if (!this._active) return;
            const u = n, d = this._startPos, _ = this._lastPos;
            if (!d || !_ || _.equals(u) || !this._box && u.dist(d) < this._clickTolerance) return;
            this._lastPos = u, this._box || (this._box = I("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t));
            const v = Math.min(d.x, u.x), L = Math.max(d.x, u.x), G = Math.min(d.y, u.y), X = Math.max(d.y, u.y);
            this._map._requestDomTask(() => {
              this._box && (this._box.style.transform = `translate(${v}px,${G}px)`, this._box.style.width = L - v + "px", this._box.style.height = X - G + "px");
            });
          }
          mouseupWindow(t, n) {
            if (!this._active) return;
            const u = this._startPos, d = n;
            if (u && t.button === 0) {
              if (this.reset(), V(), u.x !== d.x || u.y !== d.y) return this._map.fire(new r.z("boxzoomend", { originalEvent: t })), { cameraAnimation: (_) => _.fitScreenCoordinates(u, d, this._map.getBearing(), { linear: !1 }) };
              this._fireEvent("boxzoomcancel", t);
            }
          }
          keydown(t) {
            this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t));
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), N(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t, n) {
            return this._map.fire(new r.z(t, { originalEvent: n }));
          }
        }
        function lh(l, t) {
          const n = {};
          for (let u = 0; u < l.length; u++) n[l[u].identifier] = t[u];
          return n;
        }
        class jo {
          constructor(t) {
            this.reset(), this.numTouches = t.numTouches;
          }
          reset() {
            this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
          }
          touchstart(t, n, u) {
            (this.centroid || u.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === 0 && (this.startTime = t.timeStamp), u.length === this.numTouches && (this.centroid = function(d) {
              const _ = new r.P(0, 0);
              for (const v of d) _._add(v);
              return _.div(d.length);
            }(n), this.touches = lh(u, n)));
          }
          touchmove(t, n, u) {
            if (this.aborted || !this.centroid) return;
            const d = lh(u, n);
            for (const _ in this.touches) {
              const v = d[_];
              (!v || v.dist(this.touches[_]) > 30) && (this.aborted = !0);
            }
          }
          touchend(t, n, u) {
            if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), u.length === 0) {
              const d = !this.aborted && this.centroid;
              if (this.reset(), d) return d;
            }
          }
        }
        class xc {
          constructor(t) {
            this.singleTap = new jo(t), this.numTaps = t.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
          }
          touchstart(t, n, u) {
            this.singleTap.touchstart(t, n, u);
          }
          touchmove(t, n, u) {
            this.singleTap.touchmove(t, n, u);
          }
          touchend(t, n, u) {
            const d = this.singleTap.touchend(t, n, u);
            if (d) {
              const _ = t.timeStamp - this.lastTime < 500, v = !this.lastTap || this.lastTap.dist(d) < 30;
              if (_ && v || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = d, this.count === this.numTaps) return this.reset(), d;
            }
          }
        }
        class ll {
          constructor() {
            this._zoomIn = new xc({ numTouches: 1, numTaps: 2 }), this._zoomOut = new xc({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t, n, u) {
            this._zoomIn.touchstart(t, n, u), this._zoomOut.touchstart(t, n, u);
          }
          touchmove(t, n, u) {
            this._zoomIn.touchmove(t, n, u), this._zoomOut.touchmove(t, n, u);
          }
          touchend(t, n, u) {
            const d = this._zoomIn.touchend(t, n, u), _ = this._zoomOut.touchend(t, n, u);
            return d ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (v) => v.easeTo({ duration: 300, zoom: v.getZoom() + 1, around: v.unproject(d) }, { originalEvent: t }) }) : _ ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (v) => v.easeTo({ duration: 300, zoom: v.getZoom() - 1, around: v.unproject(_) }, { originalEvent: t }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        const Qh = { 0: 1, 2: 2 };
        class Pu {
          constructor(t) {
            this.reset(), this._clickTolerance = t.clickTolerance || 1;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
          }
          _correctButton(t, n) {
            return !1;
          }
          _move(t, n) {
            return {};
          }
          mousedown(t, n) {
            if (this._lastPoint) return;
            const u = Y(t);
            this._correctButton(t, u) && (this._lastPoint = n, this._eventButton = u);
          }
          mousemoveWindow(t, n) {
            const u = this._lastPoint;
            if (u) {
              if (t.preventDefault(), this._eventButton != null && function(d, _) {
                const v = Qh[_];
                return d.buttons === void 0 || (d.buttons & v) !== v;
              }(t, this._eventButton)) this.reset();
              else if (this._moved || !(n.dist(u) < this._clickTolerance)) return this._moved = !0, this._lastPoint = n, this._move(u, n);
            }
          }
          mouseupWindow(t) {
            this._lastPoint && Y(t) === this._eventButton && (this._moved && V(), this.reset());
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class bc extends Pu {
          mousedown(t, n) {
            super.mousedown(t, n), this._lastPoint && (this._active = !0);
          }
          _correctButton(t, n) {
            return n === 0 && !t.ctrlKey;
          }
          _move(t, n) {
            return { around: n, panDelta: n.sub(t) };
          }
        }
        class Do extends Pu {
          _correctButton(t, n) {
            return n === 0 && t.ctrlKey || n === 2;
          }
          _move(t, n) {
            const u = 0.8 * (n.x - t.x);
            if (u) return this._active = !0, { bearingDelta: u };
          }
          contextmenu(t) {
            t.preventDefault();
          }
        }
        class os extends Pu {
          _correctButton(t, n) {
            return n === 0 && t.ctrlKey || n === 2;
          }
          _move(t, n) {
            const u = -0.5 * (n.y - t.y);
            if (u) return this._active = !0, { pitchDelta: u };
          }
          contextmenu(t) {
            t.preventDefault();
          }
        }
        class kn {
          constructor(t, n) {
            this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = n.clickTolerance || 1, this.reset(), r.aP(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new r.P(0, 0);
          }
          touchstart(t, n, u) {
            return this._calculateTransform(t, n, u);
          }
          touchmove(t, n, u) {
            if (this._active && !(u.length < this._minTouches)) {
              if (this._map._cooperativeGestures && !this._map.isMoving()) {
                if (u.length === 1 && !r.dz()) return void this._showTouchPanBlockerAlert();
                this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              return t.cancelable && t.preventDefault(), this._calculateTransform(t, n, u);
            }
          }
          touchend(t, n, u) {
            this._calculateTransform(t, n, u), this._active && u.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t, n, u) {
            u.length > 0 && (this._active = !0);
            const d = lh(u, n), _ = new r.P(0, 0), v = new r.P(0, 0);
            let L = 0;
            for (const X in d) {
              const K = d[X], ae = this._touches[X];
              ae && (_._add(K), v._add(K.sub(ae)), L++, d[X] = K);
            }
            if (this._touches = d, L < this._minTouches || !v.mag()) return;
            const G = v.div(L);
            return this._sum._add(G), this._sum.mag() < this._clickTolerance ? void 0 : { around: _.div(L), panDelta: G };
          }
          enable() {
            this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
          }
          disable() {
            this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          _addTouchPanBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = I("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showTouchPanBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
            }, 500);
          }
        }
        class io {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, this._firstTwoTouches = void 0;
          }
          _start(t) {
          }
          _move(t, n, u) {
            return {};
          }
          touchstart(t, n, u) {
            this._firstTwoTouches || u.length < 2 || (this._firstTwoTouches = [u[0].identifier, u[1].identifier], this._start([n[0], n[1]]));
          }
          touchmove(t, n, u) {
            const d = this._firstTwoTouches;
            if (!d) return;
            t.preventDefault();
            const [_, v] = d, L = Ru(u, n, _), G = Ru(u, n, v);
            if (!L || !G) return;
            const X = this._aroundCenter ? null : L.add(G).div(2);
            return this._move([L, G], X, t);
          }
          touchend(t, n, u) {
            if (!this._firstTwoTouches) return;
            const [d, _] = this._firstTwoTouches, v = Ru(u, n, d), L = Ru(u, n, _);
            v && L || (this._active && V(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t) {
            this._enabled = !0, this._aroundCenter = !!t && t.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function Ru(l, t, n) {
          for (let u = 0; u < l.length; u++) if (l[u].identifier === n) return t[u];
        }
        function Lu(l, t) {
          return Math.log(l / t) / Math.LN2;
        }
        class ef extends io {
          reset() {
            super.reset(), this._distance = 0, this._startDistance = 0;
          }
          _start(t) {
            this._startDistance = this._distance = t[0].dist(t[1]);
          }
          _move(t, n) {
            const u = this._distance;
            if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(Lu(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: Lu(this._distance, u), pinchAround: n };
          }
        }
        function tf(l, t) {
          return 180 * l.angleWith(t) / Math.PI;
        }
        class Du extends io {
          reset() {
            super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
          }
          _start(t) {
            this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);
          }
          _move(t, n) {
            const u = this._vector;
            if (this._vector = t[0].sub(t[1]), u && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, { bearingDelta: tf(this._vector, u), pinchAround: n };
          }
          _isBelowThreshold(t) {
            this._minDiameter = Math.min(this._minDiameter, t.mag());
            const n = 25 / (Math.PI * this._minDiameter) * 360, u = this._startVector;
            if (!u) return !1;
            const d = tf(t, u);
            return Math.abs(d) < n;
          }
        }
        function uh(l) {
          return Math.abs(l.y) > Math.abs(l.x);
        }
        class md extends io {
          constructor(t) {
            super(), this._map = t;
          }
          reset() {
            super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
          }
          _start(t) {
            this._lastPoints = t, uh(t[0].sub(t[1])) && (this._valid = !1);
          }
          _move(t, n, u) {
            const d = this._lastPoints;
            if (!d) return;
            const _ = t[0].sub(d[0]), v = t[1].sub(d[1]);
            return this._map._cooperativeGestures && !r.dz() && u.touches.length < 3 || (this._valid = this.gestureBeginsVertically(_, v, u.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, { pitchDelta: (_.y + v.y) / 2 * -0.5 });
          }
          gestureBeginsVertically(t, n, u) {
            if (this._valid !== void 0) return this._valid;
            const d = t.mag() >= 2, _ = n.mag() >= 2;
            if (!d && !_) return;
            if (!d || !_) return this._firstMove == null && (this._firstMove = u), u - this._firstMove < 100 && void 0;
            const v = t.y > 0 == n.y > 0;
            return uh(t) && uh(n) && v;
          }
        }
        const Da = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class Ia {
          constructor() {
            const t = Da;
            this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = !1;
          }
          keydown(t) {
            if (t.altKey || t.ctrlKey || t.metaKey) return;
            let n = 0, u = 0, d = 0, _ = 0, v = 0;
            switch (t.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                n = 1;
                break;
              case 189:
              case 109:
              case 173:
                n = -1;
                break;
              case 37:
                t.shiftKey ? u = -1 : (t.preventDefault(), _ = -1);
                break;
              case 39:
                t.shiftKey ? u = 1 : (t.preventDefault(), _ = 1);
                break;
              case 38:
                t.shiftKey ? d = 1 : (t.preventDefault(), v = -1);
                break;
              case 40:
                t.shiftKey ? d = -1 : (t.preventDefault(), v = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (u = 0, d = 0), { cameraAnimation: (L) => {
              const G = L.getZoom();
              L.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ul, zoom: n ? Math.round(G) + n * (t.shiftKey ? 2 : 1) : G, bearing: L.getBearing() + u * this._bearingStep, pitch: L.getPitch() + d * this._pitchStep, offset: [-_ * this._panStep, -v * this._panStep], center: L.getCenter() }, { originalEvent: t });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function ul(l) {
          return l * (2 - l);
        }
        const cl = 4.000244140625, ss = 1 / 450;
        class ko {
          constructor(t, n) {
            this._map = t, this._el = t.getCanvasContainer(), this._handler = n, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = ss, r.aP(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
          }
          setZoomRate(t) {
            this._defaultZoomRate = t;
          }
          setWheelZoomRate(t) {
            this._wheelZoomRate = t;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!t && t.around === "center", this._map._cooperativeGestures && this._addScrollZoomBlocker());
          }
          disable() {
            this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
          }
          wheel(t) {
            if (!this.isEnabled()) return;
            if (this._map._cooperativeGestures) {
              if (!(t.ctrlKey || t.metaKey || this.isZooming() || r.dz())) return void this._showBlockerAlert();
              this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            let n = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
            const u = r.q.now(), d = u - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = u, n !== 0 && n % cl == 0 ? this._type = "wheel" : n !== 0 && Math.abs(n) < 4 ? this._type = "trackpad" : d > 400 ? (this._type = null, this._lastValue = n, this._timeout = window.setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(d * n) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, n += this._lastValue)), t.shiftKey && n && (n /= 4), this._type && (this._lastWheelEvent = t, this._delta -= n, this._active || this._start(t)), t.preventDefault();
          }
          _onTimeout(t) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t);
          }
          _start(t) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const n = W(this._el, t);
            this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : n, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const t = this._map.transform;
            this._type === "wheel" && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
            const n = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;
            if (this._delta !== 0) {
              const X = this._type === "wheel" && Math.abs(this._delta) > cl ? this._wheelZoomRate : this._defaultZoomRate;
              let K = 2 / (1 + Math.exp(-Math.abs(this._delta * X)));
              this._delta < 0 && K !== 0 && (K = 1 / K);
              const ae = n(), oe = Math.pow(2, ae), pe = typeof this._targetZoom == "number" ? t.zoomScale(this._targetZoom) : oe;
              this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(pe * K))), this._type === "wheel" && (this._startZoom = ae, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
            }
            const u = typeof this._targetZoom == "number" ? this._targetZoom : n(), d = this._startZoom, _ = this._easing;
            let v, L = !1;
            if (this._type === "wheel" && d && _) {
              const X = Math.min((r.q.now() - this._lastWheelEventTime) / 200, 1), K = _(X);
              v = r.af(d, u, K), X < 1 ? this._frameId || (this._frameId = !0) : L = !0;
            } else v = u, L = !0;
            this._active = !0, L && (this._active = !1, this._finishTimeout = window.setTimeout(() => {
              this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200));
            let G = v - n();
            return G * this._lastDelta < 0 && (G = 0), { noInertia: !0, needsRenderFrame: !L, zoomDelta: G, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t) {
            let n = r.dA;
            if (this._prevEase) {
              const u = this._prevEase, d = (r.q.now() - u.start) / u.duration, _ = u.easing(d + 0.01) - u.easing(d), v = 0.27 / Math.sqrt(_ * _ + 1e-4) * 0.01, L = Math.sqrt(0.0729 - v * v);
              n = r.dy(v, L, 0.25, 1);
            }
            return this._prevEase = { start: r.q.now(), duration: t, easing: n }, n;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = !1;
          }
          _addScrollZoomBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = I("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
            }, 200);
          }
        }
        class Ps {
          constructor(t, n) {
            this._clickZoom = t, this._tapZoom = n;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Rs {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1;
          }
          blur() {
            this.reset();
          }
          dblclick(t, n) {
            return t.preventDefault(), { cameraAnimation: (u) => {
              u.easeTo({ duration: 300, zoom: u.getZoom() + (t.shiftKey ? -1 : 1), around: u.unproject(n) }, { originalEvent: t });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Ls {
          constructor() {
            this._tap = new xc({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
          }
          touchstart(t, n, u) {
            this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? u.length > 0 && (this._swipePoint = n[0], this._swipeTouch = u[0].identifier) : this._tap.touchstart(t, n, u));
          }
          touchmove(t, n, u) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (u[0].identifier !== this._swipeTouch) return;
                const d = n[0], _ = d.y - this._swipePoint.y;
                return this._swipePoint = d, t.preventDefault(), this._active = !0, { zoomDelta: _ / 128 };
              }
            } else this._tap.touchmove(t, n, u);
          }
          touchend(t, n, u) {
            this._tapTime ? this._swipePoint && u.length === 0 && this.reset() : this._tap.touchend(t, n, u) && (this._tapTime = t.timeStamp);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class rf {
          constructor(t, n, u) {
            this._el = t, this._mousePan = n, this._touchPan = u;
          }
          enable(t) {
            this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Pf {
          constructor(t, n, u) {
            this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = n, this._mousePitch = u;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class Rf {
          constructor(t, n, u, d) {
            this._el = t, this._touchZoom = n, this._touchRotate = u, this._tapDragZoom = d, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(t) {
            this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const ku = (l) => l.zoom || l.drag || l.pitch || l.rotate;
        class ch extends r.z {
        }
        class Ca {
          constructor() {
            this.constants = [1, 1, 0.01], this.radius = 0;
          }
          setup(t, n) {
            const u = r.ab.vec3.sub([], n, t);
            this.radius = r.ab.vec3.length(u[2] < 0 ? r.ab.vec3.div([], u, this.constants) : [u[0], u[1], 0]);
          }
          projectRay(t) {
            r.ab.vec3.div(t, t, this.constants), r.ab.vec3.normalize(t, t), r.ab.vec3.mul(t, t, this.constants);
            const n = r.ab.vec3.scale([], t, this.radius);
            if (n[2] > 0) {
              const u = r.ab.vec3.scale([], [0, 0, 1], r.ab.vec3.dot(n, [0, 0, 1])), d = r.ab.vec3.scale([], r.ab.vec3.normalize([], [n[0], n[1], 0]), this.radius), _ = r.ab.vec3.add([], n, r.ab.vec3.scale([], r.ab.vec3.sub([], r.ab.vec3.add([], d, u), n), 2));
              n[0] = _[0], n[1] = _[1];
            }
            return n;
          }
        }
        function hl(l) {
          return l.panDelta && l.panDelta.mag() || l.zoomDelta || l.bearingDelta || l.pitchDelta;
        }
        class wc {
          constructor(t, n) {
            this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Kh(t), this._bearingSnap = n.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Ca(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(n), r.aP(["handleEvent", "handleWindowEvent"], this);
            const u = this._el;
            this._listeners = [[u, "touchstart", { passive: !0 }], [u, "touchmove", { passive: !1 }], [u, "touchend", void 0], [u, "touchcancel", void 0], [u, "mousedown", void 0], [u, "mousemove", void 0], [u, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [u, "mouseover", void 0], [u, "mouseout", void 0], [u, "dblclick", void 0], [u, "click", void 0], [u, "keydown", { capture: !1 }], [u, "keyup", void 0], [u, "wheel", { passive: !1 }], [u, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [d, _, v] of this._listeners) {
              const L = d === document ? this.handleWindowEvent : this.handleEvent;
              d.addEventListener(_, L, v);
            }
          }
          destroy() {
            for (const [t, n, u] of this._listeners) {
              const d = t === document ? this.handleWindowEvent : this.handleEvent;
              t.removeEventListener(n, d, u);
            }
          }
          _addDefaultHandlers(t) {
            const n = this._map, u = n.getCanvasContainer();
            this._add("mapEvent", new sh(n, t));
            const d = n.boxZoom = new Nn(n, t);
            this._add("boxZoom", d);
            const _ = new ll(), v = new Rs();
            n.doubleClickZoom = new Ps(v, _), this._add("tapZoom", _), this._add("clickZoom", v);
            const L = new Ls();
            this._add("tapDragZoom", L);
            const G = n.touchPitch = new md(n);
            this._add("touchPitch", G);
            const X = new Do(t), K = new os(t);
            n.dragRotate = new Pf(t, X, K), this._add("mouseRotate", X, ["mousePitch"]), this._add("mousePitch", K, ["mouseRotate"]);
            const ae = new bc(t), oe = new kn(n, t);
            n.dragPan = new rf(u, ae, oe), this._add("mousePan", ae), this._add("touchPan", oe, ["touchZoom", "touchRotate"]);
            const pe = new Du(), Be = new ef();
            n.touchZoomRotate = new Rf(u, Be, pe, L), this._add("touchRotate", pe, ["touchPan", "touchZoom"]), this._add("touchZoom", Be, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new pd(n));
            const Re = n.scrollZoom = new ko(n, this);
            this._add("scrollZoom", Re, ["mousePan"]);
            const Ge = n.keyboard = new Ia();
            this._add("keyboard", Ge);
            for (const Ve of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) t.interactive && t[Ve] && n[Ve].enable(t[Ve]);
          }
          _add(t, n, u) {
            this._handlers.push({ handlerName: t, handler: n, allowed: u }), this._handlersById[t] = n;
          }
          stop(t) {
            if (!this._updatingCamera) {
              for (const { handler: n } of this._handlers) n.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [], this._originalZoom = void 0;
            }
          }
          isActive() {
            for (const { handler: t } of this._handlers) if (t.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!ku(this._eventsInProgress) || this.isZooming();
          }
          _isDragging() {
            return !!this._eventsInProgress.drag;
          }
          _blockedByActive(t, n, u) {
            for (const d in t) if (d !== u && (!n || n.indexOf(d) < 0)) return !0;
            return !1;
          }
          handleWindowEvent(t) {
            this.handleEvent(t, `${t.type}Window`);
          }
          _getMapTouches(t) {
            const n = [];
            for (const u of t) this._el.contains(u.target) && n.push(u);
            return n;
          }
          handleEvent(t, n) {
            this._updatingCamera = !0;
            const u = t.type === "renderFrame", d = u ? void 0 : t, _ = { needsRenderFrame: !1 }, v = {}, L = {}, G = t.touches ? this._getMapTouches(t.touches) : void 0, X = G ? q(this._el, G) : u ? void 0 : W(this._el, t);
            for (const { handlerName: oe, handler: pe, allowed: Be } of this._handlers) {
              if (!pe.isEnabled()) continue;
              let Re;
              this._blockedByActive(L, Be, oe) ? pe.reset() : pe[n || t.type] && (Re = pe[n || t.type](t, X, G), this.mergeHandlerResult(_, v, Re, oe, d), Re && Re.needsRenderFrame && this._triggerRenderFrame()), (Re || pe.isActive()) && (L[oe] = pe);
            }
            const K = {};
            for (const oe in this._previousActiveHandlers) L[oe] || (K[oe] = d);
            this._previousActiveHandlers = L, (Object.keys(K).length || hl(_)) && (this._changes.push([_, v, K]), this._triggerRenderFrame()), (Object.keys(L).length || hl(_)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: ae } = _;
            ae && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], ae(this._map));
          }
          mergeHandlerResult(t, n, u, d, _) {
            if (!u) return;
            r.l(t, u);
            const v = { handlerName: d, originalEvent: u.originalEvent || _ };
            u.zoomDelta !== void 0 && (n.zoom = v), u.panDelta !== void 0 && (n.drag = v), u.pitchDelta !== void 0 && (n.pitch = v), u.bearingDelta !== void 0 && (n.rotate = v);
          }
          _applyChanges() {
            const t = {}, n = {}, u = {};
            for (const [d, _, v] of this._changes) d.panDelta && (t.panDelta = (t.panDelta || new r.P(0, 0))._add(d.panDelta)), d.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + d.zoomDelta), d.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + d.bearingDelta), d.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + d.pitchDelta), d.around !== void 0 && (t.around = d.around), d.aroundCoord !== void 0 && (t.aroundCoord = d.aroundCoord), d.pinchAround !== void 0 && (t.pinchAround = d.pinchAround), d.noInertia && (t.noInertia = d.noInertia), r.l(n, _), r.l(u, v);
            this._updateMapTransform(t, n, u), this._changes = [];
          }
          _updateMapTransform(t, n, u) {
            const d = this._map, _ = d.transform, v = (et) => [et.x, et.y, et.z];
            if (((et) => {
              const ut = this._eventsInProgress.drag;
              return ut && !this._handlersById[ut.handlerName].isActive();
            })() && !hl(t)) {
              const et = _.zoom;
              _.cameraElevationReference = "sea", this._originalZoom != null && _._orthographicProjectionAtLowPitch && _.projection.name !== "globe" && _.pitch === 0 ? (_.cameraElevationReference = "ground", _.zoom = this._originalZoom) : (_.recenterOnTerrain(), _.cameraElevationReference = "ground"), et !== _.zoom && this._map._update(!0);
            }
            if (_._isCameraConstrained && d._stop(!0), !hl(t)) return void this._fireEvents(n, u, !0);
            let { panDelta: L, zoomDelta: G, bearingDelta: X, pitchDelta: K, around: ae, aroundCoord: oe, pinchAround: pe } = t;
            _._isCameraConstrained && (G > 0 && (G = 0), _._isCameraConstrained = !1), pe !== void 0 && (ae = pe), (G || ((et) => n[et] && !this._eventsInProgress[et])("drag")) && ae && (this._dragOrigin = v(_.pointCoordinate3D(ae)), this._originalZoom = _.zoom, this._trackingEllipsoid.setup(_._camera.position, this._dragOrigin)), _.cameraElevationReference = "sea", d._stop(!0), ae = ae || d.transform.centerPoint, X && (_.bearing += X), K && (_.pitch += K), _._updateCameraState();
            const Be = [0, 0, 0];
            if (L) if (_.projection.name === "mercator") {
              const et = this._trackingEllipsoid.projectRay(_.screenPointToMercatorRay(ae).dir), ut = this._trackingEllipsoid.projectRay(_.screenPointToMercatorRay(ae.sub(L)).dir);
              Be[0] = ut[0] - et[0], Be[1] = ut[1] - et[1];
            } else {
              const et = _.pointCoordinate(ae);
              if (_.projection.name === "globe") {
                L = L.rotate(-_.angle);
                const ut = _._pixelsPerMercatorPixel / _.worldSize;
                Be[0] = -L.x * r.dB(r.aS(et.y)) * ut, Be[1] = -L.y * r.dB(_.center.lat) * ut;
              } else {
                const ut = _.pointCoordinate(ae.sub(L));
                et && ut && (Be[0] = ut.x - et.x, Be[1] = ut.y - et.y);
              }
            }
            const Re = _.zoom, Ge = [0, 0, 0];
            if (G) {
              const et = v(oe || _.pointCoordinate3D(ae)), ut = { dir: r.ab.vec3.normalize([], r.ab.vec3.sub([], et, _._camera.position)) };
              if (ut.dir[2] < 0) {
                const st = _.zoomDeltaToMovement(et, G);
                r.ab.vec3.scale(Ge, ut.dir, st);
              }
            }
            const Ve = r.ab.vec3.add(Be, Be, Ge);
            _._translateCameraConstrained(Ve), G && Math.abs(_.zoom - Re) > 1e-4 && _.recenterOnTerrain(), _.cameraElevationReference = "ground", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(n, u, !0);
          }
          _fireEvents(t, n, u) {
            const d = ku(this._eventsInProgress), _ = ku(t), v = {};
            for (const K in t) {
              const { originalEvent: ae } = t[K];
              this._eventsInProgress[K] || (v[`${K}start`] = ae), this._eventsInProgress[K] = t[K];
            }
            !d && _ && this._fireEvent("movestart", _.originalEvent);
            for (const K in v) this._fireEvent(K, v[K]);
            _ && this._fireEvent("move", _.originalEvent);
            for (const K in t) {
              const { originalEvent: ae } = t[K];
              this._fireEvent(K, ae);
            }
            const L = {};
            let G;
            for (const K in this._eventsInProgress) {
              const { handlerName: ae, originalEvent: oe } = this._eventsInProgress[K];
              this._handlersById[ae].isActive() || (delete this._eventsInProgress[K], G = n[ae] || oe, L[`${K}end`] = G);
            }
            for (const K in L) this._fireEvent(K, L[K]);
            const X = ku(this._eventsInProgress);
            if (u && (d || _) && !X) {
              this._updatingCamera = !0;
              const K = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), ae = (oe) => oe !== 0 && -this._bearingSnap < oe && oe < this._bearingSnap;
              K ? (ae(K.bearing || this._map.getBearing()) && (K.bearing = 0), this._map.easeTo(K, { originalEvent: G })) : (this._map.fire(new r.z("moveend", { originalEvent: G })), ae(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
            }
          }
          _fireEvent(t, n) {
            this._map.fire(new r.z(t, n ? { originalEvent: n } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t) => {
              this._frameId = void 0, this.handleEvent(new ch("renderFrame", { timeStamp: t })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        const Lf = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class ql extends r.E {
          constructor(t, n) {
            super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = n.bearingSnap, this._respectPrefersReducedMotion = n.respectPrefersReducedMotion !== !1, r.aP(["_renderFrameCallback"], this);
          }
          getCenter() {
            return new r.bO(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t, n) {
            return this.jumpTo({ center: t }, n);
          }
          panBy(t, n, u) {
            return t = r.P.convert(t).mult(-1), this.panTo(this.transform.center, r.l({ offset: t }, n), u);
          }
          panTo(t, n, u) {
            return this.easeTo(r.l({ center: t }, n), u);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t, n) {
            return this.jumpTo({ zoom: t }, n), this;
          }
          zoomTo(t, n, u) {
            return this.easeTo(r.l({ zoom: t }, n), u);
          }
          zoomIn(t, n) {
            return this.zoomTo(this.getZoom() + 1, t, n), this;
          }
          zoomOut(t, n) {
            return this.zoomTo(this.getZoom() - 1, t, n), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t, n) {
            return this.jumpTo({ bearing: t }, n), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t, n) {
            return this.jumpTo({ padding: t }, n), this;
          }
          rotateTo(t, n, u) {
            return this.easeTo(r.l({ bearing: t }, n), u);
          }
          resetNorth(t, n) {
            return this.rotateTo(0, r.l({ duration: 1e3 }, t), n), this;
          }
          resetNorthPitch(t, n) {
            return this.easeTo(r.l({ bearing: 0, pitch: 0, duration: 1e3 }, t), n), this;
          }
          snapToNorth(t, n) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, n) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t, n) {
            return this.jumpTo({ pitch: t }, n), this;
          }
          cameraForBounds(t, n) {
            t = r.az.convert(t);
            const u = n && n.bearing || 0, d = n && n.pitch || 0, _ = t.getNorthWest(), v = t.getSouthEast();
            return this._cameraForBounds(this.transform, _, v, u, d, n);
          }
          _extendPadding(t) {
            const n = { top: 0, right: 0, bottom: 0, left: 0 };
            return t == null ? r.l({}, n, this.transform.padding) : typeof t == "number" ? { top: t, bottom: t, right: t, left: t } : r.l({}, n, t);
          }
          _extendCameraOptions(t) {
            return (t = r.l({ offset: [0, 0], maxZoom: this.transform.maxZoom }, t)).padding = this._extendPadding(t.padding), t;
          }
          _minimumAABBFrustumDistance(t, n) {
            const u = n.max[0] - n.min[0], d = n.max[1] - n.min[1];
            return u / d > t.aspect ? u / (2 * Math.tan(0.5 * t.fovX) * t.aspect) : d / (2 * Math.tan(0.5 * t.fovY) * t.aspect);
          }
          _cameraForBoundsOnGlobe(t, n, u, d, _, v) {
            const L = t.clone(), G = this._extendCameraOptions(v);
            L.bearing = d, L.pitch = _;
            const X = r.bO.convert(n), K = r.bO.convert(u), ae = 0.5 * (X.lat + K.lat), oe = 0.5 * (X.lng + K.lng), pe = r.dC(ae, oe), Be = r.ab.vec3.normalize([], pe), Re = r.ab.vec3.normalize([], r.ab.vec3.cross([], Be, [0, 1, 0])), Ge = r.ab.vec3.cross([], Re, Be), Ve = [Re[0], Re[1], Re[2], 0, Ge[0], Ge[1], Ge[2], 0, Be[0], Be[1], Be[2], 0, 0, 0, 0, 1], et = [pe, r.dC(X.lat, X.lng), r.dC(K.lat, X.lng), r.dC(K.lat, K.lng), r.dC(X.lat, K.lng), r.dC(ae, X.lng), r.dC(ae, K.lng), r.dC(X.lat, oe), r.dC(K.lat, oe)];
            let ut = r.cd.fromPoints(et.map((ir) => [r.ab.vec3.dot(Re, ir), r.ab.vec3.dot(Ge, ir), r.ab.vec3.dot(Be, ir)]));
            const st = r.ab.vec3.transformMat4([], ut.center, Ve);
            r.ab.vec3.squaredLength(st) === 0 && r.ab.vec3.set(st, 0, 0, 1), r.ab.vec3.normalize(st, st), r.ab.vec3.scale(st, st, r.ax), L.center = r.dD(st);
            const xt = L.getWorldToCameraMatrix(), mt = r.ab.mat4.invert(new Float64Array(16), xt);
            ut = r.cd.applyTransform(ut, r.ab.mat4.multiply([], xt, Ve));
            const _t = this._extendAABB(ut, L, G, d);
            if (!_t) return void r.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            ut = _t, r.ab.vec3.transformMat4(st, st, xt);
            const dt = 0.5 * (ut.max[2] - ut.min[2]), gt = this._minimumAABBFrustumDistance(L, ut), Rt = r.ab.vec3.scale([], [0, 0, 1], dt), Jt = r.ab.vec3.add(Rt, st, Rt), Vt = gt + (L.pitch === 0 ? 0 : r.ab.vec3.distance(st, Jt)), or = L.globeCenterInViewSpace, sr = r.ab.vec3.sub([], st, [or[0], or[1], or[2]]);
            r.ab.vec3.normalize(sr, sr), r.ab.vec3.scale(sr, sr, Vt);
            const Bt = r.ab.vec3.add([], st, sr);
            r.ab.vec3.transformMat4(Bt, Bt, mt);
            const rr = r.ds / r.ax, gr = r.ab.vec3.length(Bt), Ut = r.bH(Math.max(gr * rr - r.ds, Number.EPSILON), 0), dr = Math.min(L.zoomFromMercatorZAdjusted(Ut), G.maxZoom);
            return dr > 0.5 * (r.c6 + r.bY) ? (L.setProjection({ name: "mercator" }), L.zoom = dr, this._cameraForBounds(L, n, u, d, _, v)) : { center: L.center, zoom: dr, bearing: d, pitch: _ };
          }
          _extendAABB(t, n, u, d) {
            const _ = 0.5 * ((u.padding.left || 0) + (u.padding.right || 0)), v = 0.5 * ((u.padding.top || 0) + (u.padding.bottom || 0)), L = v, G = _, X = _, K = v, ae = n.width - (G + X), oe = n.height - (L + K), pe = r.ab.vec3.sub([], t.max, t.min), Be = Math.min(ae / pe[0], oe / pe[1]), Re = Math.min(n.scaleZoom(n.scale * Be), u.maxZoom);
            if (isNaN(Re)) return null;
            const Ge = n.scale / n.zoomScale(Re), Ve = new r.cd([t.min[0] - G * Ge, t.min[1] - K * Ge, t.min[2]], [t.max[0] + X * Ge, t.max[1] + L * Ge, t.max[2]]), et = (typeof u.offset.x == "number" && typeof u.offset.y == "number" ? new r.P(u.offset.x, u.offset.y) : r.P.convert(u.offset)).rotate(-r.ai(d));
            return Ve.center[0] -= et.x * Ge, Ve.center[1] += et.y * Ge, Ve;
          }
          queryTerrainElevation(t, n) {
            const u = this.transform.elevation;
            return u ? (n = r.l({}, { exaggerated: !0 }, n), u.getAtPoint(r.aa.fromLngLat(t), null, n.exaggerated)) : null;
          }
          _cameraForBounds(t, n, u, d, _, v) {
            if (t.projection.name === "globe") return this._cameraForBoundsOnGlobe(t, n, u, d, _, v);
            const L = t.clone(), G = this._extendCameraOptions(v);
            L.bearing = d, L.pitch = _;
            const X = r.bO.convert(n), K = r.bO.convert(u), ae = new r.bO(X.lng, K.lat), oe = new r.bO(K.lng, X.lat), pe = L.project(X), Be = L.project(K), Re = this.queryTerrainElevation(X), Ge = this.queryTerrainElevation(K), Ve = this.queryTerrainElevation(ae), et = this.queryTerrainElevation(oe), ut = [[pe.x, pe.y, Math.min(Re || 0, Ge || 0, Ve || 0, et || 0)], [Be.x, Be.y, Math.max(Re || 0, Ge || 0, Ve || 0, et || 0)]];
            let st = r.cd.fromPoints(ut);
            const xt = L.getWorldToCameraMatrix(), mt = r.ab.mat4.invert(new Float64Array(16), xt);
            st = r.cd.applyTransform(st, xt);
            const _t = this._extendAABB(st, L, G, d);
            if (!_t) return void r.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            st = _t;
            const dt = 0.5 * r.ab.vec3.sub([], st.max, st.min)[2], gt = this._minimumAABBFrustumDistance(L, st), Rt = [0, 0, 1, 0];
            r.ab.vec4.transformMat4(Rt, Rt, xt), r.ab.vec4.normalize(Rt, Rt);
            const Jt = r.ab.vec3.scale([], Rt, gt + dt), Vt = r.ab.vec3.add([], st.center, Jt);
            r.ab.vec3.transformMat4(st.center, st.center, mt), r.ab.vec3.transformMat4(Vt, Vt, mt);
            const or = L.unproject(new r.P(st.center[0], st.center[1])), sr = r.dE(L.projection, or), Bt = Math.pow(2, sr), rr = Math.min(L._zoomFromMercatorZ(Vt[2] * L.pixelsPerMeter * Bt / L.worldSize), G.maxZoom);
            return L.mercatorFromTransition && rr < 0.5 * (r.c6 + r.bY) ? (L.setProjection({ name: "globe" }), L.zoom = rr, this._cameraForBounds(L, n, u, d, _, v)) : { center: or, zoom: rr, bearing: d, pitch: _ };
          }
          fitBounds(t, n, u) {
            const d = this.cameraForBounds(t, n);
            return this._fitInternal(d, n, u);
          }
          fitScreenCoordinates(t, n, u, d, _) {
            const v = r.P.convert(t), L = r.P.convert(n), G = new r.P(Math.min(v.x, L.x), Math.min(v.y, L.y)), X = new r.P(Math.max(v.x, L.x), Math.max(v.y, L.y));
            if (this.transform.projection.name === "mercator" && this.transform.anyCornerOffEdge(v, L)) return this;
            const K = this.transform.pointLocation3D(G), ae = this.transform.pointLocation3D(X), oe = this.transform.pointLocation3D(new r.P(G.x, X.y)), pe = this.transform.pointLocation3D(new r.P(X.x, G.y)), Be = [Math.min(K.lng, ae.lng, oe.lng, pe.lng), Math.min(K.lat, ae.lat, oe.lat, pe.lat)], Re = [Math.max(K.lng, ae.lng, oe.lng, pe.lng), Math.max(K.lat, ae.lat, oe.lat, pe.lat)], Ge = d && d.pitch ? d.pitch : this.getPitch(), Ve = this._cameraForBounds(this.transform, Be, Re, u, Ge, d);
            return this._fitInternal(Ve, d, _);
          }
          _fitInternal(t, n, u) {
            return t ? (n = r.l(t, n)).linear ? this.easeTo(n, u) : this.flyTo(n, u) : this;
          }
          jumpTo(t, n) {
            this.stop();
            const u = t.preloadOnly ? this.transform.clone() : this.transform;
            let d = !1, _ = !1, v = !1;
            "zoom" in t && u.zoom !== +t.zoom && (d = !0, u.zoom = +t.zoom), t.center !== void 0 && (u.center = r.bO.convert(t.center)), "bearing" in t && u.bearing !== +t.bearing && (_ = !0, u.bearing = +t.bearing), "pitch" in t && u.pitch !== +t.pitch && (v = !0, u.pitch = +t.pitch);
            const L = typeof t.padding == "number" ? this._extendPadding(t.padding) : t.padding;
            if (t.padding != null && !u.isPaddingEqual(L)) if (t.retainPadding === !1) {
              const G = u.clone();
              G.padding = L, u.setLocationAtPoint(u.center, G.centerPoint);
            } else u.padding = L;
            return t.preloadOnly ? (this._preloadTiles(u), this) : (this.fire(new r.z("movestart", n)).fire(new r.z("move", n)), d && this.fire(new r.z("zoomstart", n)).fire(new r.z("zoom", n)).fire(new r.z("zoomend", n)), _ && this.fire(new r.z("rotatestart", n)).fire(new r.z("rotate", n)).fire(new r.z("rotateend", n)), v && this.fire(new r.z("pitchstart", n)).fire(new r.z("pitch", n)).fire(new r.z("pitchend", n)), this.fire(new r.z("moveend", n)));
          }
          getFreeCameraOptions() {
            return this.transform.projection.supportsFreeCamera || r.w(Lf), this.transform.getFreeCameraOptions();
          }
          setFreeCameraOptions(t, n) {
            const u = this.transform;
            if (!u.projection.supportsFreeCamera) return r.w(Lf), this;
            this.stop();
            const d = u.zoom, _ = u.pitch, v = u.bearing;
            u.setFreeCameraOptions(t);
            const L = d !== u.zoom, G = _ !== u.pitch, X = v !== u.bearing;
            return this.fire(new r.z("movestart", n)).fire(new r.z("move", n)), L && this.fire(new r.z("zoomstart", n)).fire(new r.z("zoom", n)).fire(new r.z("zoomend", n)), X && this.fire(new r.z("rotatestart", n)).fire(new r.z("rotate", n)).fire(new r.z("rotateend", n)), G && this.fire(new r.z("pitchstart", n)).fire(new r.z("pitch", n)).fire(new r.z("pitchend", n)), this.fire(new r.z("moveend", n)), this;
          }
          easeTo(t, n) {
            this._stop(!1, t.easeId), ((t = r.l({ offset: [0, 0], duration: 500, easing: r.dA }, t)).animate === !1 || this._prefersReducedMotion(t)) && (t.duration = 0);
            const u = this.transform, d = this.getZoom(), _ = this.getBearing(), v = this.getPitch(), L = this.getPadding(), G = "zoom" in t ? +t.zoom : d, X = "bearing" in t ? this._normalizeBearing(t.bearing, _) : _, K = "pitch" in t ? +t.pitch : v, ae = this._extendPadding(t.padding), oe = r.P.convert(t.offset);
            let pe, Be, Re;
            if (u.projection.name === "globe") {
              const Rt = r.aa.fromLngLat(u.center), Jt = oe.rotate(-u.angle);
              Rt.x += Jt.x / u.worldSize, Rt.y += Jt.y / u.worldSize;
              const Vt = Rt.toLngLat(), or = r.bO.convert(t.center || Vt);
              this._normalizeCenter(or), pe = u.centerPoint.add(Jt), Be = new r.P(Rt.x, Rt.y).mult(u.worldSize), Re = new r.P(r.at(or.lng), r.aA(or.lat)).mult(u.worldSize).sub(Be);
            } else {
              pe = u.centerPoint.add(oe);
              const Rt = u.pointLocation(pe), Jt = r.bO.convert(t.center || Rt);
              this._normalizeCenter(Jt), Be = u.project(Rt), Re = u.project(Jt).sub(Be);
            }
            const Ge = u.zoomScale(G - d);
            let Ve, et;
            t.around && (Ve = r.bO.convert(t.around), et = u.locationPoint(Ve));
            const ut = this._zooming || G !== d, st = this._rotating || _ !== X, xt = this._pitching || K !== v, mt = !u.isPaddingEqual(ae), _t = t.retainPadding === !1 ? u.clone() : u, dt = (Rt) => (Jt) => {
              if (ut && (Rt.zoom = r.af(d, G, Jt)), st && (Rt.bearing = r.af(_, X, Jt)), xt && (Rt.pitch = r.af(v, K, Jt)), mt && (_t.interpolatePadding(L, ae, Jt), pe = _t.centerPoint.add(oe)), Ve) Rt.setLocationAtPoint(Ve, et);
              else {
                const Vt = Rt.zoomScale(Rt.zoom - d), or = G > d ? Math.min(2, Ge) : Math.max(0.5, Ge), sr = Math.pow(or, 1 - Jt), Bt = Rt.unproject(Be.add(Re.mult(Jt * sr)).mult(Vt));
                Rt.setLocationAtPoint(Rt.renderWorldCopies ? Bt.wrap() : Bt, pe);
              }
              return t.preloadOnly || this._fireMoveEvents(n), Rt;
            };
            if (t.preloadOnly) {
              const Rt = this._emulate(dt, t.duration, u);
              return this._preloadTiles(Rt), this;
            }
            const gt = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = ut, this._rotating = st, this._pitching = xt, this._padding = mt, this._easeId = t.easeId, this._prepareEase(n, t.noMoveStart, gt), this._ease(dt(u), (Rt) => {
              u.cameraElevationReference === "sea" && u.recenterOnTerrain(), this._afterEase(n, Rt);
            }, t), this;
          }
          _prepareEase(t, n, u = {}) {
            this._moving = !0, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && this.transform.pitch === 0 && this.transform.projection.name !== "globe" && (this.transform.cameraElevationReference = "ground"), n || u.moving || this.fire(new r.z("movestart", t)), this._zooming && !u.zooming && this.fire(new r.z("zoomstart", t)), this._rotating && !u.rotating && this.fire(new r.z("rotatestart", t)), this._pitching && !u.pitching && this.fire(new r.z("pitchstart", t));
          }
          _fireMoveEvents(t) {
            this.fire(new r.z("move", t)), this._zooming && this.fire(new r.z("zoom", t)), this._rotating && this.fire(new r.z("rotate", t)), this._pitching && this.fire(new r.z("pitch", t));
          }
          _afterEase(t, n) {
            if (this._easeId && n && this._easeId === n) return;
            this._easeId = void 0, this.transform.cameraElevationReference = "ground";
            const u = this._zooming, d = this._rotating, _ = this._pitching;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, u && this.fire(new r.z("zoomend", t)), d && this.fire(new r.z("rotateend", t)), _ && this.fire(new r.z("pitchend", t)), this.fire(new r.z("moveend", t));
          }
          flyTo(t, n) {
            if (this._prefersReducedMotion(t)) {
              const ir = r.ay(t, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
              return this.jumpTo(ir, n);
            }
            this.stop(), t = r.l({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: r.dA }, t);
            const u = this.transform, d = this.getZoom(), _ = this.getBearing(), v = this.getPitch(), L = this.getPadding(), G = "zoom" in t ? r.aw(+t.zoom, u.minZoom, u.maxZoom) : d, X = "bearing" in t ? this._normalizeBearing(t.bearing, _) : _, K = "pitch" in t ? +t.pitch : v, ae = this._extendPadding(t.padding), oe = u.zoomScale(G - d), pe = r.P.convert(t.offset);
            let Be = u.centerPoint.add(pe);
            const Re = u.pointLocation(Be), Ge = r.bO.convert(t.center || Re);
            this._normalizeCenter(Ge);
            const Ve = u.project(Re), et = u.project(Ge).sub(Ve);
            let ut = t.curve;
            const st = Math.max(u.width, u.height), xt = st / oe, mt = et.mag();
            if ("minZoom" in t) {
              const ir = r.aw(Math.min(t.minZoom, d, G), u.minZoom, u.maxZoom), Tr = st / u.zoomScale(ir - d);
              ut = Math.sqrt(Tr / mt * 2);
            }
            const _t = ut * ut;
            function dt(ir) {
              const Tr = (xt * xt - st * st + (ir ? -1 : 1) * _t * _t * mt * mt) / (2 * (ir ? xt : st) * _t * mt);
              return Math.log(Math.sqrt(Tr * Tr + 1) - Tr);
            }
            function gt(ir) {
              return (Math.exp(ir) - Math.exp(-ir)) / 2;
            }
            function Rt(ir) {
              return (Math.exp(ir) + Math.exp(-ir)) / 2;
            }
            const Jt = dt(0);
            let Vt = function(ir) {
              return Rt(Jt) / Rt(Jt + ut * ir);
            }, or = function(ir) {
              return st * ((Rt(Jt) * (gt(Tr = Jt + ut * ir) / Rt(Tr)) - gt(Jt)) / _t) / mt;
              var Tr;
            }, sr = (dt(1) - Jt) / ut;
            if (Math.abs(mt) < 1e-6 || !isFinite(sr)) {
              if (Math.abs(st - xt) < 1e-6) return this.easeTo(t, n);
              const ir = xt < st ? -1 : 1;
              sr = Math.abs(Math.log(xt / st)) / ut, or = function() {
                return 0;
              }, Vt = function(Tr) {
                return Math.exp(ir * ut * Tr);
              };
            }
            t.duration = "duration" in t ? +t.duration : 1e3 * sr / ("screenSpeed" in t ? +t.screenSpeed / ut : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);
            const Bt = _ !== X, rr = K !== v, gr = !u.isPaddingEqual(ae), Ut = t.retainPadding === !1 ? u.clone() : u, dr = (ir) => (Tr) => {
              const mr = Tr * sr, hr = 1 / Vt(mr);
              ir.zoom = Tr === 1 ? G : d + ir.scaleZoom(hr), Bt && (ir.bearing = r.af(_, X, Tr)), rr && (ir.pitch = r.af(v, K, Tr)), gr && (Ut.interpolatePadding(L, ae, Tr), Be = Ut.centerPoint.add(pe));
              const br = Tr === 1 ? Ge : ir.unproject(Ve.add(et.mult(or(mr))).mult(hr));
              return ir.setLocationAtPoint(ir.renderWorldCopies ? br.wrap() : br, Be), ir._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(n), ir;
            };
            if (t.preloadOnly) {
              const ir = this._emulate(dr, t.duration, u);
              return this._preloadTiles(ir), this;
            }
            return this._zooming = !0, this._rotating = Bt, this._pitching = rr, this._padding = gr, this._prepareEase(n, !1), this._ease(dr(u), () => this._afterEase(n), t), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _requestRenderFrame(t) {
          }
          _cancelRenderFrame(t) {
          }
          _stop(t, n) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
              const u = this._onEaseEnd;
              this._onEaseEnd = void 0, u.call(this, n);
            }
            if (!t) {
              const u = this.handlers;
              u && u.stop(!1);
            }
            return this;
          }
          _ease(t, n, u) {
            u.animate === !1 || u.duration === 0 ? (t(1), n()) : (this._easeStart = r.q.now(), this._easeOptions = u, this._onEaseFrame = t, this._onEaseEnd = n, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _renderFrameCallback() {
            const t = Math.min((r.q.now() - this._easeStart) / this._easeOptions.duration, 1), n = this._onEaseFrame;
            n && n(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }
          _normalizeBearing(t, n) {
            t = r.bF(t, -180, 180);
            const u = Math.abs(t - n);
            return Math.abs(t - 360 - n) < u && (t -= 360), Math.abs(t + 360 - n) < u && (t += 360), t;
          }
          _normalizeCenter(t) {
            const n = this.transform;
            if (n.maxBounds || n.projection.name !== "globe" && !n.renderWorldCopies) return;
            const u = t.lng - n.center.lng;
            t.lng += u > 180 ? -360 : u < -180 ? 360 : 0;
          }
          _prefersReducedMotion(t) {
            return this._respectPrefersReducedMotion && r.q.prefersReducedMotion && !(t && t.essential);
          }
          _emulate(t, n, u) {
            const d = Math.ceil(15 * n / 1e3), _ = [], v = t(u.clone());
            for (let L = 0; L <= d; L++) {
              const G = v(L / d);
              _.push(G.clone());
            }
            return _;
          }
          _preloadTiles(t, n) {
          }
        }
        class zu {
          constructor(t = {}) {
            this.options = t, r.aP(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t) {
            const n = this.options && this.options.compact, u = t._getUIString("AttributionControl.ToggleAttribution");
            this._map = t, this._container = I("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = I("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", u);
            const d = I("span", "mapboxgl-ctrl-icon", this._compactButton);
            return d.setAttribute("aria-hidden", "true"), d.setAttribute("title", u), this._innerContainer = I("div", "mapboxgl-ctrl-attrib-inner", this._container), n && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), n === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
          }
          _toggleAttribution() {
            this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
          }
          _updateEditLink() {
            let t = this._editLink;
            t || (t = this._editLink = this._container.querySelector(".mapbox-improve-map"));
            const n = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || r.e.ACCESS_TOKEN }];
            if (t) {
              const u = n.reduce((d, _, v) => (_.value && (d += `${_.key}=${_.value}${v < n.length - 1 ? "&" : ""}`), d), "?");
              t.href = `${r.e.FEEDBACK_URL}/${u}#${oh(this._map, !0)}`, t.rel = "noopener nofollow";
            }
          }
          _updateData(t) {
            !t || t.sourceDataType !== "metadata" && t.sourceDataType !== "visibility" && t.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let t = [];
            if (this._map.style.stylesheet) {
              const d = this._map.style.stylesheet;
              this.styleOwner = d.owner, this.styleId = d.id;
            }
            const n = this._map.style._mergedSourceCaches;
            for (const d in n) {
              const _ = n[d];
              if (_.used) {
                const v = _.getSource();
                v.attribution && t.indexOf(v.attribution) < 0 && t.push(v.attribution);
              }
            }
            t.sort((d, _) => d.length - _.length), t = t.filter((d, _) => {
              for (let v = _ + 1; v < t.length; v++) if (t[v].indexOf(d) >= 0) return !1;
              return !0;
            }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = [...this.options.customAttribution, ...t] : t.unshift(this.options.customAttribution));
            const u = t.join(" | ");
            u !== this._attribHTML && (this._attribHTML = u, t.length ? (this._innerContainer.innerHTML = u, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
          _updateCompact() {
            this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
          }
        }
        class no {
          constructor() {
            r.aP(["_updateLogo", "_updateCompact"], this);
          }
          onAdd(t) {
            this._map = t, this._container = I("div", "mapboxgl-ctrl");
            const n = I("a", "mapboxgl-ctrl-logo");
            return n.target = "_blank", n.rel = "noopener nofollow", n.href = "https://www.mapbox.com/", n.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), n.setAttribute("rel", "noopener nofollow"), this._container.appendChild(n), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _updateLogo(t) {
            t && t.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
          }
          _logoRequired() {
            if (!this._map.style) return !0;
            const t = this._map.style._sourceCaches;
            if (Object.entries(t).length === 0) return !0;
            for (const n in t) {
              const u = t[n].getSource();
              if (u.hasOwnProperty("mapbox_logo") && !u.mapbox_logo) return !1;
            }
            return !0;
          }
          _updateCompact() {
            const t = this._container.children;
            if (t.length) {
              const n = t[0];
              this._map.getCanvasContainer().offsetWidth < 250 ? n.classList.add("mapboxgl-compact") : n.classList.remove("mapboxgl-compact");
            }
          }
        }
        class ka {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(t) {
            const n = ++this._id;
            return this._queue.push({ callback: t, id: n, cancelled: !1 }), n;
          }
          remove(t) {
            const n = this._currentlyRunning, u = n ? this._queue.concat(n) : this._queue;
            for (const d of u) if (d.id === t) return void (d.cancelled = !0);
          }
          run(t = 0) {
            const n = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const u of n) if (!u.cancelled && (u.callback(t), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        class ao {
          constructor(t) {
            this.jumpTo(t);
          }
          getValue(t) {
            if (t <= this._startTime) return this._start;
            if (t >= this._endTime) return this._end;
            const n = r.cB((t - this._startTime) / (this._endTime - this._startTime));
            return this._start * (1 - n) + this._end * n;
          }
          isEasing(t) {
            return t >= this._startTime && t <= this._endTime;
          }
          jumpTo(t) {
            this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = t, this._end = t;
          }
          easeTo(t, n, u) {
            this._start = this.getValue(n), this._end = t, this._startTime = n, this._endTime = n + u;
          }
        }
        const $l = { "AttributionControl.ToggleAttribution": "Toggle attribution", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox homepage", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" };
        class fl extends r.z {
          constructor(t, n, u, d) {
            const { point: _, lngLat: v, originalEvent: L, target: G } = t;
            super(t.type, { point: _, lngLat: v, originalEvent: L, target: G }), this.preventDefault = () => {
              t.preventDefault();
            }, this.id = n, this.interaction = u, this.feature = d;
          }
        }
        class Ec {
          constructor(t) {
            this.map = t, this.interactionsByType = /* @__PURE__ */ new Map(), this.delegatedInteractions = /* @__PURE__ */ new Map(), this.typeById = /* @__PURE__ */ new Map(), this.filters = /* @__PURE__ */ new Map(), this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = /* @__PURE__ */ new Map(), this.prevHoveredFeatures = /* @__PURE__ */ new Map();
          }
          add(t, n) {
            if (this.typeById.has(t)) throw new Error(`Interaction id "${t}" already exists.`);
            const u = n.filter;
            let d = n.type;
            u && this.filters.set(t, r.aZ(u)), d === "mouseover" && (d = "mouseenter"), d === "mouseout" && (d = "mouseleave");
            const _ = this.interactionsByType.get(d) || /* @__PURE__ */ new Map();
            d === "mouseenter" || d === "mouseleave" ? (this.delegatedInteractions.size === 0 && (this.map.on("mousemove", this.handleMove), this.map.on("mouseout", this.handleOut)), this.delegatedInteractions.set(t, n)) : _.size === 0 && this.map.on(d, this.handleType), _.size === 0 && this.interactionsByType.set(d, _), _.set(t, n), this.typeById.set(t, d);
          }
          get(t) {
            const n = this.typeById.get(t);
            if (!n) return;
            const u = this.interactionsByType.get(n);
            return u ? u.get(t) : void 0;
          }
          remove(t) {
            const n = this.typeById.get(t);
            if (!n) return;
            this.typeById.delete(t), this.filters.delete(t);
            const u = this.interactionsByType.get(n);
            u && (u.delete(t), n === "mouseenter" || n === "mouseleave" ? (this.delegatedInteractions.delete(t), this.delegatedInteractions.size === 0 && (this.map.off("mousemove", this.handleMove), this.map.off("mouseout", this.handleOut))) : u.size === 0 && this.map.off(n, this.handleType));
          }
          queryTargets(t, n) {
            const u = [];
            for (const [d, _] of n) _.target && u.push({ targetId: d, target: _.target, filter: this.filters.get(d) });
            return this.map.style.queryRenderedTargets(t, u, this.map.transform);
          }
          handleMove(t) {
            this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = /* @__PURE__ */ new Map();
            const n = this.queryTargets(t.point, Array.from(this.delegatedInteractions).reverse());
            n.length && (t.type = "mouseenter", this.handleType(t, n));
            const u = /* @__PURE__ */ new Map();
            for (const [d, { feature: _ }] of this.prevHoveredFeatures) this.hoveredFeatures.has(d) || u.set(_.id, _);
            u.size && (t.type = "mouseleave", this.handleType(t, Array.from(u.values())));
          }
          handleOut(t) {
            const n = Array.from(this.hoveredFeatures.values()).map(({ feature: u }) => u);
            n.length && (t.type = "mouseleave", this.handleType(t, n)), this.hoveredFeatures.clear();
          }
          handleType(t, n) {
            const u = Array.from(this.interactionsByType.get(t.type)).reverse(), d = !!n;
            n = n || this.queryTargets(t.point, u);
            const _ = t.type === "mouseenter";
            let v = !1;
            const L = /* @__PURE__ */ new Set();
            for (const G of n) {
              for (const [X, K] of u) {
                if (!K.target) continue;
                const ae = G.variants ? G.variants[X] : null;
                if (ae) {
                  for (const oe of ae) {
                    if (wo(oe, G, L, X)) continue;
                    const pe = new r.cw(G, oe), Be = Fs(oe, G, X);
                    d && (pe.state = this.map.getFeatureState(pe));
                    const Re = _ ? this.prevHoveredFeatures.get(Be) : null, Ge = new fl(t, X, K, pe), Ve = Re ? Re.stop : K.handler(Ge);
                    if (_ && this.hoveredFeatures.set(Be, { feature: G, stop: Ve }), Ve !== !1) {
                      v = !0;
                      break;
                    }
                  }
                  if (v) break;
                }
              }
              if (v) break;
            }
            if (!v) for (const [G, X] of u) {
              const { handler: K, target: ae } = X;
              if (!ae && K(new fl(t, G, X, null)) !== !1) break;
            }
          }
        }
        function qi(l, t) {
          if (Array.isArray(l) && Array.isArray(t)) {
            const n = new Set(l), u = new Set(t);
            return n.size === u.size && l.every((d) => u.has(d));
          }
          return r.bn(l, t);
        }
        const Ds = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, performanceMetricsCollection: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, antialias: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: !0, crossSourceCollisions: !0, collectResourceTiming: !1, testMode: !1, precompilePrograms: !0, scaleFactor: 1, spriteFormat: "auto" }, Sc = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
        class za {
          constructor(t, n, u = !1) {
            this._clickTolerance = 10, this.element = n, this.mouseRotate = new Do({ clickTolerance: t.dragRotate._mouseRotate._clickTolerance }), this.map = t, u && (this.mousePitch = new os({ clickTolerance: t.dragRotate._mousePitch._clickTolerance })), r.aP(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), n.addEventListener("mousedown", this.mousedown), n.addEventListener("touchstart", this.touchstart, { passive: !1 }), n.addEventListener("touchmove", this.touchmove), n.addEventListener("touchend", this.touchend), n.addEventListener("touchcancel", this.reset);
          }
          down(t, n) {
            this.mouseRotate.mousedown(t, n), this.mousePitch && this.mousePitch.mousedown(t, n), B();
          }
          move(t, n) {
            const u = this.map, d = this.mouseRotate.mousemoveWindow(t, n), _ = d && d.bearingDelta;
            if (_ && u.setBearing(u.getBearing() + _), this.mousePitch) {
              const v = this.mousePitch.mousemoveWindow(t, n), L = v && v.pitchDelta;
              L && u.setPitch(u.getPitch() + L);
            }
          }
          off() {
            const t = this.element;
            t.removeEventListener("mousedown", this.mousedown), t.removeEventListener("touchstart", this.touchstart, { passive: !1 }), t.removeEventListener("touchmove", this.touchmove), t.removeEventListener("touchend", this.touchend), t.removeEventListener("touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            N(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
          }
          mousedown(t) {
            this.down(r.l({}, t, { ctrlKey: !0, preventDefault: () => t.preventDefault() }), W(this.element, t)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
          }
          mousemove(t) {
            this.move(t, W(this.element, t));
          }
          mouseup(t) {
            this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp();
          }
          touchstart(t) {
            t.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = q(this.element, t.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: () => t.preventDefault() }, this._startPos));
          }
          touchmove(t) {
            t.targetTouches.length !== 1 ? this.reset() : (this._lastPos = q(this.element, t.targetTouches)[0], this.move({ preventDefault: () => t.preventDefault() }, this._lastPos));
          }
          touchend(t) {
            t.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }
          reset() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }
        }
        function hh(l, t, n) {
          if (l = new r.bO(l.lng, l.lat), t) {
            const u = new r.bO(l.lng - 360, l.lat), d = new r.bO(l.lng + 360, l.lat), _ = 360 * Math.ceil(Math.abs(l.lng - n.center.lng) / 360), v = n.locationPoint(l).distSqr(t), L = t.x < 0 || t.y < 0 || t.x > n.width || t.y > n.height;
            n.locationPoint(u).distSqr(t) < v && (L || Math.abs(u.lng - n.center.lng) < _) ? l = u : n.locationPoint(d).distSqr(t) < v && (L || Math.abs(d.lng - n.center.lng) < _) && (l = d);
          }
          for (; Math.abs(l.lng - n.center.lng) > 180; ) {
            const u = n.locationPoint(l);
            if (u.x >= 0 && u.y >= 0 && u.x <= n.width && u.y <= n.height) break;
            l.lng > n.center.lng ? l.lng -= 360 : l.lng += 360;
          }
          return l;
        }
        const ls = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        class oo extends r.E {
          constructor(t, n) {
            if (super(), (t instanceof HTMLElement || n) && (t = r.l({ element: t }, n)), r.aP(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment || "auto", this._updateMoving = () => this._update(!0), this._occludedOpacity = t && t.occludedOpacity || 0.2, t && t.element) this._element = t.element, this._offset = r.P.convert(t && t.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = I("div");
              const _ = 41, v = 27, L = z("svg", { display: "block", height: _ * this._scale + "px", width: v * this._scale + "px", viewBox: `0 0 ${v} ${_}` }, this._element), G = z("radialGradient", { id: "shadowGradient" }, z("defs", {}, L));
              z("stop", { offset: "10%", "stop-opacity": 0.4 }, G), z("stop", { offset: "100%", "stop-opacity": 0.05 }, G), z("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, L), z("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, L), z("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, L), z("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, L), this._offset = r.P.convert(t && t.offset || [0, -14]);
            }
            this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (_) => {
              _.preventDefault();
            }), this._element.addEventListener("mousedown", (_) => {
              _.preventDefault();
            });
            const u = this._element.classList;
            for (const _ in ls) u.remove(`mapboxgl-marker-anchor-${_}`);
            u.add(`mapboxgl-marker-anchor-${this._anchor}`);
            const d = t && t.className ? t.className.trim().split(/\s+/) : [];
            u.add(...d), this._popup = null;
          }
          addTo(t) {
            return t === this._map || (this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._updateMoving), t.on("moveend", this._update), t.on("remove", this._clearFadeTimer), t._addMarker(this), this.setDraggable(this._draggable), this._update(), t.on("click", this._onMapClick)), this;
          }
          remove() {
            const t = this._map;
            return t && (t.off("click", this._onMapClick), t.off("move", this._updateMoving), t.off("moveend", this._update), t.off("mousedown", this._addDragHandler), t.off("touchstart", this._addDragHandler), t.off("mouseup", this._onUp), t.off("touchend", this._onUp), t.off("mousemove", this._onMove), t.off("touchmove", this._onMove), t.off("remove", this._clearFadeTimer), t._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t) {
            return this._lngLat = r.bO.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
              if (!("offset" in t.options)) {
                const d = Math.sqrt(Math.pow(13.5, 2) / 2);
                t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [d, -1 * (38.1 - 13.5 + d)], "bottom-right": [-d, -1 * (38.1 - 13.5 + d)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = t, t._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
            }
            return this;
          }
          _onKeyPress(t) {
            const n = t.code, u = t.charCode || t.keyCode;
            n !== "Space" && n !== "Enter" && u !== 32 && u !== 13 || this.togglePopup();
          }
          _onMapClick(t) {
            const n = t.originalEvent.target, u = this._element;
            this._popup && (n === u || u.contains(n)) && this.togglePopup();
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t = this._popup;
            return t ? (t.isOpen() ? (t.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (t.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
          }
          _behindTerrain() {
            const t = this._map, n = this._pos;
            if (!t || !n) return !1;
            const u = t.unproject(n), d = t.getFreeCameraOptions();
            if (!d.position) return !1;
            const _ = d.position.toLngLat();
            return _.distanceTo(u) < 0.9 * _.distanceTo(this._lngLat);
          }
          _evaluateOpacity() {
            const t = this._map;
            if (!t) return;
            const n = this._pos;
            if (!n || n.x < 0 || n.x > t.transform.width || n.y < 0 || n.y > t.transform.height) return void this._clearFadeTimer();
            const u = t.unproject(n);
            let d;
            t._showingGlobe() && r.dH(t.transform, this._lngLat) ? d = 0 : (d = 1 - t._queryFogOpacity(u), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (d *= this._occludedOpacity)), this._element.style.opacity = `${d}`, this._element.style.pointerEvents = d > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(d), this._fadeTimer = null;
          }
          _clearFadeTimer() {
            this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
          }
          _updateDOM() {
            const t = this._pos;
            if (!t || !this._map) return;
            const n = this._offset.mult(this._scale);
            this._element.style.transform = `
            translate(${t.x}px,${t.y}px)
            ${ls[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${n.x}px,${n.y}px)
        `;
          }
          _calculateXYTransform() {
            const t = this._pos, n = this._map, u = this.getPitchAlignment();
            if (!n || !t || u !== "map") return "";
            if (!n._showingGlobe()) {
              const G = n.getPitch();
              return G ? `rotateX(${G}deg)` : "";
            }
            const d = r.c4(r.dI(n.transform, this._lngLat)), _ = t.sub(r.dJ(n.transform)), v = Math.abs(_.x) + Math.abs(_.y);
            if (v === 0) return "";
            const L = d / v;
            return `rotateX(${-_.y * L}deg) rotateY(${_.x * L}deg)`;
          }
          _calculateZTransform() {
            const t = this._pos, n = this._map;
            if (!n || !t) return "";
            let u = 0;
            const d = this.getRotationAlignment();
            if (d === "map") if (n._showingGlobe()) {
              const _ = n.project(new r.bO(this._lngLat.lng, this._lngLat.lat + 1e-3)), v = n.project(new r.bO(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(_);
              u = r.c4(Math.atan2(v.y, v.x)) - 90;
            } else u = -n.getBearing();
            else if (d === "horizon") {
              const _ = r.ac(4, 6, n.getZoom()), v = r.dJ(n.transform);
              v.y += _ * n.transform.height;
              const L = t.sub(v), G = r.c4(Math.atan2(L.y, L.x));
              u = (G > 90 ? G - 270 : G + 90) * (1 - _);
            }
            return u += this._rotation, u ? `rotateZ(${u}deg)` : "";
          }
          _update(t) {
            cancelAnimationFrame(this._updateFrameId);
            const n = this._map;
            n && (n.transform.renderWorldCopies && (this._lngLat = hh(this._lngLat, this._pos, n.transform)), this._pos = n.project(this._lngLat), t === !0 ? this._updateFrameId = requestAnimationFrame(() => {
              this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
            }) : this._pos = this._pos.round(), n._requestDomTask(() => {
              this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (n._showingGlobe() || n.getTerrain() || n.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
            }));
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t) {
            return this._offset = r.P.convert(t), this._update(), this;
          }
          addClassName(t) {
            return this._element.classList.add(t), this;
          }
          removeClassName(t) {
            return this._element.classList.remove(t), this;
          }
          toggleClassName(t) {
            return this._element.classList.toggle(t);
          }
          _onMove(t) {
            const n = this._map;
            if (!n) return;
            const u = this._pointerdownPos, d = this._positionDelta;
            if (u && d) {
              if (!this._isDragging) {
                const _ = this._clickTolerance || n._clickTolerance;
                if (t.point.dist(u) < _) return;
                this._isDragging = !0;
              }
              this._pos = t.point.sub(d), this._lngLat = n.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new r.z("dragstart"))), this.fire(new r.z("drag"));
            }
          }
          _onUp() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
            const t = this._map;
            t && (t.off("mousemove", this._onMove), t.off("touchmove", this._onMove)), this._state === "active" && this.fire(new r.z("dragend")), this._state = "inactive";
          }
          _addDragHandler(t) {
            const n = this._map, u = this._pos;
            n && u && this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(u), this._pointerdownPos = t.point, this._state = "pending", n.on("mousemove", this._onMove), n.on("touchmove", this._onMove), n.once("mouseup", this._onUp), n.once("touchend", this._onUp));
          }
          setDraggable(t) {
            this._draggable = !!t;
            const n = this._map;
            return n && (t ? (n.on("mousedown", this._addDragHandler), n.on("touchstart", this._addDragHandler)) : (n.off("mousedown", this._addDragHandler), n.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t) {
            return this._rotation = t || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t) {
            return this._rotationAlignment = t || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment === "auto" || this._rotationAlignment === "horizon" && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
          }
          setPitchAlignment(t) {
            return this._pitchAlignment = t || "auto", this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment === "auto" ? this.getRotationAlignment() : this._pitchAlignment;
          }
          setOccludedOpacity(t) {
            return this._occludedOpacity = t || 0.2, this._update(), this;
          }
          getOccludedOpacity() {
            return this._occludedOpacity;
          }
        }
        const xn = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0, showUserHeading: !1 }, so = { maxWidth: 100, unit: "metric" }, ci = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, Xl = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, Cn = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function fh(l = new r.P(0, 0), t = "bottom") {
          if (typeof l == "number") {
            const n = Math.round(Math.sqrt(0.5 * Math.pow(l, 2)));
            switch (t) {
              case "top":
                return new r.P(0, l);
              case "top-left":
                return new r.P(n, n);
              case "top-right":
                return new r.P(-n, n);
              case "bottom":
                return new r.P(0, -l);
              case "bottom-left":
                return new r.P(n, -n);
              case "bottom-right":
                return new r.P(-n, -n);
              case "left":
                return new r.P(l, 0);
              case "right":
                return new r.P(-l, 0);
            }
            return new r.P(0, 0);
          }
          return l instanceof r.P || Array.isArray(l) ? r.P.convert(l) : r.P.convert(l[t] || [0, 0]);
        }
        return { version: F, supported: m.supported, setRTLTextPlugin: r.dK, getRTLTextPluginStatus: r.dL, Map: class extends ql {
          constructor(l) {
            P.mark(H.create);
            const t = l;
            if ((l = r.l({}, Ds, l)).minZoom != null && l.maxZoom != null && l.minZoom > l.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (l.minPitch != null && l.maxPitch != null && l.minPitch > l.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (l.minPitch != null && l.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (l.maxPitch != null && l.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (l.antialias && r.dF(window) && (l.antialias = !1, r.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new hu(l.minZoom, l.maxZoom, l.minPitch, l.maxPitch, l.renderWorldCopies), l), this._repaint = !!l.repaint, this._interactive = l.interactive, this._minTileCacheSize = l.minTileCacheSize, this._maxTileCacheSize = l.maxTileCacheSize, this._failIfMajorPerformanceCaveat = l.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = l.preserveDrawingBuffer, this._antialias = l.antialias, this._trackResize = l.trackResize, this._bearingSnap = l.bearingSnap, this._refreshExpiredTiles = l.refreshExpiredTiles, this._fadeDuration = l.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = l.crossSourceCollisions, this._collectResourceTiming = l.collectResourceTiming, this._language = this._parseLanguage(l.language), this._worldview = l.worldview, this._renderTaskQueue = new ka(), this._domRenderTaskQueue = new ka(), this._controls = [], this._markers = [], this._popups = [], this._mapId = r.aV(), this._locale = r.l({}, $l, l.locale), this._clickTolerance = l.clickTolerance, this._cooperativeGestures = l.cooperativeGestures, this._performanceMetricsCollection = l.performanceMetricsCollection, this._tessellationStep = l.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = l.precompilePrograms, this._scaleFactorChanged = !1, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new ao(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = l.scaleFactor, this._requestManager = new ce(l.transformRequest, l.accessToken, l.testMode), this._silenceAuthErrors = !!l.testMode, this._contextCreateOptions = l.contextCreateOptions ? Object.assign({}, l.contextCreateOptions) : {}, typeof l.container == "string") {
              const n = document.getElementById(l.container);
              if (!n) throw new Error(`Container '${l.container.toString()}' not found.`);
              this._container = n;
            } else {
              if (!(l.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = l.container;
            }
            if (this._container.childNodes.length > 0 && r.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), l.maxBounds && this.setMaxBounds(l.maxBounds), this._spriteFormat = l.spriteFormat, r.aP(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp || (this._tp = new rh()), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", { noSave: !0 }), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", { noSave: !0 }, () => {
              this._update();
            }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._tp.registerParameter(this, ["Scaling"], "_scaleFactor", { min: 0.1, max: 10, step: 0.1 }, () => {
              this.setScaleFactor(this._scaleFactor);
            }), this._setupPainter(), this.painter === void 0) throw new Error("Failed to initialize WebGL.");
            if (this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, !1), window.addEventListener("resize", this._onWindowResize, !1), window.addEventListener("orientationchange", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener("visibilitychange", this._onVisibilityChange, !1), this.handlers = new wc(this, l), this._localFontFamily = l.localFontFamily, this._localIdeographFontFamily = l.localIdeographFontFamily, (l.style || !l.testMode) && this.setStyle(l.style || r.e.DEFAULT_STYLE, { config: l.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), l.projection && this.setProjection(l.projection), this.indoor = new kh(this), l.hash && (this._hash = new qh(typeof l.hash == "string" && l.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
              t.center == null && t.zoom == null || (this.transform._unmodified = !1), this.jumpTo({ center: l.center, zoom: l.zoom, bearing: l.bearing, pitch: l.pitch });
              const n = l.bounds;
              n && (this.resize(), this.fitBounds(n, r.l({}, l.fitBoundsOptions, { duration: 0 })));
            }
            this.resize(), l.attributionControl && this.addControl(new zu({ customAttribution: l.customAttribution })), this._logoControl = new no(), this.addControl(this._logoControl, l.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
            }), this.on("data", (n) => {
              this._update(n.dataType === "style"), this.fire(new r.z(`${n.dataType}data`, n));
            }), this.on("dataloading", (n) => {
              this.fire(new r.z(`${n.dataType}dataloading`, n));
            }), this._interactions = new Ec(this);
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(l, t) {
            if (t === void 0 && (t = l.getDefaultPosition ? l.getDefaultPosition() : "top-right"), !l || !l.onAdd) return this.fire(new r.y(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const n = l.onAdd(this);
            this._controls.push(l);
            const u = this._controlPositions[t];
            return t.indexOf("bottom") !== -1 ? u.insertBefore(n, u.firstChild) : u.appendChild(n), this;
          }
          removeControl(l) {
            if (!l || !l.onRemove) return this.fire(new r.y(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const t = this._controls.indexOf(l);
            return t > -1 && this._controls.splice(t, 1), l.onRemove(this), this;
          }
          hasControl(l) {
            return this._controls.indexOf(l) > -1;
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          resize(l) {
            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
            const t = !this._moving;
            return t && this.fire(new r.z("movestart", l)).fire(new r.z("move", l)), this.fire(new r.z("resize", l)), t && this.fire(new r.z("moveend", l)), this;
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds() || null;
          }
          setMaxBounds(l) {
            return this.transform.setMaxBounds(r.az.convert(l)), this._update();
          }
          setMinZoom(l) {
            if ((l = l ?? -2) >= -2 && l <= this.transform.maxZoom) return this.transform.minZoom = l, this._update(), this.getZoom() < l ? this.setZoom(l) : this.fire(new r.z("zoomstart")).fire(new r.z("zoom")).fire(new r.z("zoomend")), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(l) {
            if ((l = l ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = l, this._update(), this.getZoom() > l ? this.setZoom(l) : this.fire(new r.z("zoomstart")).fire(new r.z("zoom")).fire(new r.z("zoomend")), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(l) {
            if ((l = l ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (l >= 0 && l <= this.transform.maxPitch) return this.transform.minPitch = l, this._update(), this.getPitch() < l ? this.setPitch(l) : this.fire(new r.z("pitchstart")).fire(new r.z("pitch")).fire(new r.z("pitchend")), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(l) {
            if ((l = l ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (l >= this.transform.minPitch) return this.transform.maxPitch = l, this._update(), this.getPitch() > l ? this.setPitch(l) : this.fire(new r.z("pitchstart")).fire(new r.z("pitch")).fire(new r.z("pitchend")), this;
            throw new Error("maxPitch must be greater than or equal to minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getScaleFactor() {
            return this._scaleFactor;
          }
          setScaleFactor(l) {
            return this._scaleFactor = l, this.painter.scaleFactor = l, this._tp.refreshUI(), this._scaleFactorChanged = !0, this.style._updateFilteredLayers((t) => t.type === "symbol"), this._update(!0), this;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(l) {
            return this.transform.renderWorldCopies = l, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
          }
          getLanguage() {
            return this._language;
          }
          _parseLanguage(l) {
            return l === "auto" ? navigator.language : Array.isArray(l) ? l.length === 0 ? void 0 : l.map((t) => t === "auto" ? navigator.language : t) : l;
          }
          setLanguage(l) {
            const t = this._parseLanguage(l);
            if (!this.style || t === this._language) return this;
            this._language = t, this.style.reloadSources();
            for (const n of this._controls) n._setLanguage && n._setLanguage(this._language);
            return this;
          }
          getWorldview() {
            return this._worldview;
          }
          setWorldview(l) {
            return this.style && l !== this._worldview ? (this._worldview = l, this.style.reloadSources(), this) : this;
          }
          getProjection() {
            return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
          }
          _showingGlobe() {
            return this.transform.projection.name === "globe";
          }
          setProjection(l) {
            return this._lazyInitEmptyStyle(), l ? typeof l == "string" && (l = { name: l }) : l = null, this._useExplicitProjection = !!l, this._prioritizeAndUpdateProjection(l, this.style.projection);
          }
          _updateProjectionTransition() {
            if (this.getProjection().name !== "globe") return;
            const l = this.transform, t = l.projection.name;
            let n;
            t === "globe" && l.zoom >= r.bY ? (l.setMercatorFromTransition(), n = !0) : t === "mercator" && l.zoom < r.bY && (l.setProjection({ name: "globe" }), n = !0), n && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
          }
          _prioritizeAndUpdateProjection(l, t) {
            return this._updateProjection(l || t || { name: "mercator" });
          }
          _updateProjection(l) {
            let t;
            return t = l.name === "globe" && this.transform.zoom >= r.bY ? this.transform.setMercatorFromTransition() : this.transform.setProjection(l), this.style.applyProjectionUpdate(), t && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;
          }
          project(l) {
            return this.transform.locationPoint3D(r.bO.convert(l));
          }
          unproject(l) {
            return this.transform.pointLocation3D(r.P.convert(l));
          }
          isMoving() {
            return this._moving || this.handlers && this.handlers.isMoving() || !1;
          }
          isZooming() {
            return this._zooming || this.handlers && this.handlers.isZooming() || !1;
          }
          isRotating() {
            return this._rotating || this.handlers && this.handlers.isRotating() || !1;
          }
          _isDragging() {
            return this.handlers && this.handlers._isDragging() || !1;
          }
          _createDelegatedListener(l, t, n) {
            const u = (d) => {
              let _ = [];
              if (Array.isArray(t)) {
                const v = t.filter((L) => this.getLayer(L));
                _ = v.length ? this.queryRenderedFeatures(d, { layers: v }) : [];
              } else _ = this.queryRenderedFeatures(d, { target: t });
              return _;
            };
            if (l === "mouseenter" || l === "mouseover") {
              let d = !1;
              return { listener: n, targets: t, delegates: { mousemove: (v) => {
                const L = u(v.point);
                L.length ? d || (d = !0, n.call(this, new Ha(l, this, v.originalEvent, { features: L }))) : d = !1;
              }, mouseout: () => {
                d = !1;
              } } };
            }
            if (l === "mouseleave" || l === "mouseout") {
              let d = !1;
              return { listener: n, targets: t, delegates: { mousemove: (L) => {
                u(L.point).length ? d = !0 : d && (d = !1, n.call(this, new Ha(l, this, L.originalEvent)));
              }, mouseout: (L) => {
                d && (d = !1, n.call(this, new Ha(l, this, L.originalEvent)));
              } } };
            }
            {
              const d = (_) => {
                const v = u(_.point);
                v.length && (_.features = v, n.call(this, _), delete _.features);
              };
              return { listener: n, targets: t, delegates: { [l]: d } };
            }
          }
          on(l, t, n) {
            if (typeof t == "function" || n === void 0) return super.on(l, t);
            if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t)) return this;
            const u = this._createDelegatedListener(l, t, n);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[l] = this._delegatedListeners[l] || [], this._delegatedListeners[l].push(u);
            for (const d in u.delegates) this.on(d, u.delegates[d]);
            return this;
          }
          once(l, t, n) {
            if (typeof t == "function" || n === void 0) return super.once(l, t);
            if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t)) return this;
            const u = this._createDelegatedListener(l, t, n);
            for (const d in u.delegates) this.once(d, u.delegates[d]);
            return this;
          }
          off(l, t, n) {
            if (typeof t == "function" || n === void 0) return super.off(l, t);
            if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t)) return this;
            const u = this._delegatedListeners ? this._delegatedListeners[l] : void 0;
            return u && ((d) => {
              for (let _ = 0; _ < d.length; _++) {
                const v = d[_];
                if (v.listener === n && qi(v.targets, t)) {
                  for (const L in v.delegates) this.off(L, v.delegates[L]);
                  return d.splice(_, 1), this;
                }
              }
            })(u), this;
          }
          queryRenderedFeatures(l, t) {
            if (!this.style) return [];
            if (l === void 0 || l instanceof r.P || Array.isArray(l) || t !== void 0 || (t = l, l = void 0), l = l || [[0, 0], [this.transform.width, this.transform.height]], !t) {
              const _ = this.style.queryRenderedFeatures(l, void 0, this.transform), v = this.style.queryRenderedFeatureset(l, void 0, this.transform);
              return _.concat(v);
            }
            let n = !0;
            if (t.target && (n = this._isTargetValid(t.target), n && !t.layers)) return this.style.queryRenderedFeatureset(l, t, this.transform);
            let u = !0;
            if (t.layers && Array.isArray(t.layers)) {
              for (const _ of t.layers) if (!this._isValidId(_)) {
                u = !1;
                break;
              }
              if (u && !t.target) return this.style.queryRenderedFeatures(l, t, this.transform);
            }
            let d = [];
            return u && (d = d.concat(this.style.queryRenderedFeatures(l, t, this.transform))), n && (d = d.concat(this.style.queryRenderedFeatureset(l, t, this.transform))), d;
          }
          querySourceFeatures(l, t) {
            return !l || typeof l == "string" && !this._isValidId(l) ? [] : this.style.querySourceFeatures(l, t);
          }
          isPointOnSurface(l) {
            const { name: t } = this.transform.projection;
            return t !== "globe" && t !== "mercator" && r.w(`${t} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(r.P.convert(l));
          }
          addInteraction(l, t) {
            return this._interactions.add(l, t), this;
          }
          removeInteraction(l) {
            return this._interactions.remove(l), this;
          }
          setStyle(l, t) {
            return t = r.l({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, t), this.style && l && t.diff !== !1 && t.localFontFamily === this._localFontFamily && t.localIdeographFontFamily === this._localIdeographFontFamily && !t.config ? (this.style._diffStyle(l, (n, u) => {
              n ? (r.w(`Unable to perform style diff: ${String(n.message || n.error || n)}. Rebuilding the style from scratch.`), this._updateStyle(l, t)) : u && this._update(!0);
            }, () => {
              this._postStyleLoadEvent();
            }), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._localFontFamily = t.localFontFamily, this._updateStyle(l, t));
          }
          _getUIString(l) {
            const t = this._locale[l];
            if (t == null) throw new Error(`Missing UI string '${l}'`);
            return t;
          }
          _updateStyle(l, t) {
            if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), l) {
              const n = r.l({}, t);
              t && t.config && (n.initialConfig = t.config, delete n.config), this.style = new Ka(this, n).load(l), this.style.setEventedParent(this, { style: this.style });
            }
            return this._updateTerrain(), this;
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Ka(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : (r.w("There is no style added to the map."), !1);
          }
          _isValidId(l) {
            return l == null ? (this.fire(new r.y(new Error("IDs can't be empty."))), !1) : !r.cr(l) || (this.fire(new r.y(new Error(`IDs can't contain special symbols: "${l}".`))), !1);
          }
          _isTargetValid(l) {
            return "featuresetId" in l ? this._isValidId("importId" in l ? l.importId : l.featuresetId) : "layerId" in l && this._isValidId(l.layerId);
          }
          _areTargetsValid(l) {
            if (Array.isArray(l)) {
              for (const t of l) if (!this._isValidId(t)) return !1;
              return !0;
            }
            return this._isTargetValid(l);
          }
          addSource(l, t) {
            return this._isValidId(l) ? (this._lazyInitEmptyStyle(), this.style.addSource(l, t), this._update(!0)) : this;
          }
          isSourceLoaded(l) {
            return !!this._isValidId(l) && !!this.style && this.style._isSourceCacheLoaded(l);
          }
          areTilesLoaded() {
            return this.style.areTilesLoaded();
          }
          addSourceType(l, t, n) {
            this._lazyInitEmptyStyle(), this.style.addSourceType(l, t, n);
          }
          removeSource(l) {
            return this._isValidId(l) ? (this.style.removeSource(l), this._updateTerrain(), this._update(!0)) : this;
          }
          getSource(l) {
            return this._isValidId(l) ? this.style.getOwnSource(l) : null;
          }
          addImage(l, t, { pixelRatio: n = 1, sdf: u = !1, stretchX: d, stretchY: _, content: v } = {}) {
            if (this._lazyInitEmptyStyle(), t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap) {
              const { width: L, height: G, data: X } = r.q.getImageData(t);
              this.style.addImage(l, { data: new r.r({ width: L, height: G }, X), pixelRatio: n, stretchX: d, stretchY: _, content: v, sdf: u, version: 0, usvg: !1 });
            } else if (t.width === void 0 || t.height === void 0) this.fire(new r.y(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            else {
              const { width: L, height: G } = t, X = t;
              this.style.addImage(l, { data: new r.r({ width: L, height: G }, new Uint8Array(X.data)), pixelRatio: n, stretchX: d, stretchY: _, content: v, sdf: u, usvg: !1, version: 0, userImage: X }), X.onAdd && X.onAdd(this, l);
            }
          }
          updateImage(l, t) {
            this._lazyInitEmptyStyle();
            const n = this.style.getImage(l);
            if (!n) return void this.fire(new r.y(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const u = t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap ? r.q.getImageData(t) : t, { width: d, height: _, data: v } = u;
            if (d === void 0 || _ === void 0) return void this.fire(new r.y(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (d !== (n.usvg ? n.icon.usvg_tree.width : n.data.width) || _ !== (n.usvg ? n.icon.usvg_tree.height : n.data.height)) return void this.fire(new r.y(new Error(`The width and height of the updated image (${d}, ${_})
                must be that same as the previous version of the image
                (${n.data.width}, ${n.data.height})`)));
            const L = !(t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap);
            let G = !1;
            n.usvg ? (n.data = new r.r({ width: d, height: _ }, new Uint8Array(v)), n.usvg = !1, n.icon = void 0, G = !0) : n.data.replace(v, L), this.style.updateImage(l, n, G);
          }
          hasImage(l) {
            return l ? !!this.style && !!this.style.getImage(l) : (this.fire(new r.y(new Error("Missing required image id"))), !1);
          }
          removeImage(l) {
            this.style.removeImage(l);
          }
          loadImage(l, t) {
            r.o(this._requestManager.transformRequest(l, r.R.Image), (n, u) => {
              t(n, u instanceof HTMLImageElement ? r.q.getImageData(u) : u);
            });
          }
          listImages() {
            return this.style.listImages();
          }
          addModel(l, t) {
            this._lazyInitEmptyStyle(), this.style.addModel(l, t);
          }
          hasModel(l) {
            return l ? this.style.hasModel(l) : (this.fire(new r.y(new Error("Missing required model id"))), !1);
          }
          removeModel(l) {
            this.style.removeModel(l);
          }
          listModels() {
            return this.style.listModels();
          }
          addLayer(l, t) {
            return this._isValidId(l.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(l, t), this._update(!0)) : this;
          }
          getSlot(l) {
            const t = this.getLayer(l);
            return t && t.slot || null;
          }
          setSlot(l, t) {
            return this.style.setSlot(l, t), this.style.mergeLayers(), this._update(!0);
          }
          addImport(l, t) {
            return this.style.addImport(l, t), this;
          }
          updateImport(l, t) {
            return typeof t != "string" && t.id !== l ? (this.removeImport(l), this.addImport(t)) : (this.style.updateImport(l, t), this._update(!0));
          }
          removeImport(l) {
            return this.style.removeImport(l), this;
          }
          moveImport(l, t) {
            return this.style.moveImport(l, t), this._update(!0);
          }
          moveLayer(l, t) {
            return this._isValidId(l) ? (this.style.moveLayer(l, t), this._update(!0)) : this;
          }
          removeLayer(l) {
            return this._isValidId(l) ? (this.style.removeLayer(l), this._update(!0)) : this;
          }
          getLayer(l) {
            if (!this._isValidId(l)) return null;
            const t = this.style.getOwnLayer(l);
            return t ? t.type === "custom" ? t.implementation : t.serialize() : void 0;
          }
          getSlots() {
            return this.style.getSlots();
          }
          setLayerZoomRange(l, t, n) {
            return this._isValidId(l) ? (this.style.setLayerZoomRange(l, t, n), this._update(!0)) : this;
          }
          setFilter(l, t, n = {}) {
            return this._isValidId(l) ? (this.style.setFilter(l, t, n), this._update(!0)) : this;
          }
          getFilter(l) {
            return this._isValidId(l) ? this.style.getFilter(l) : null;
          }
          setPaintProperty(l, t, n, u = {}) {
            return this._isValidId(l) ? (this.style.setPaintProperty(l, t, n, u), this._update(!0)) : this;
          }
          getPaintProperty(l, t) {
            return this._isValidId(l) ? this.style.getPaintProperty(l, t) : null;
          }
          setLayoutProperty(l, t, n, u = {}) {
            return this._isValidId(l) ? (this.style.setLayoutProperty(l, t, n, u), this._update(!0)) : this;
          }
          getLayoutProperty(l, t) {
            return this._isValidId(l) ? this.style.getLayoutProperty(l, t) : null;
          }
          getSchema(l) {
            return this.style.getSchema(l);
          }
          setSchema(l, t) {
            return this.style.setSchema(l, t), this._update(!0);
          }
          getConfig(l) {
            return this.style.getConfig(l);
          }
          setConfig(l, t) {
            return this.style.setConfig(l, t), this._update(!0);
          }
          getConfigProperty(l, t) {
            return this.style.getConfigProperty(l, t);
          }
          setConfigProperty(l, t, n) {
            return this.style.setConfigProperty(l, t, n), this._update(!0);
          }
          getFeaturesetDescriptors(l) {
            return this.style.getFeaturesetDescriptors(l);
          }
          setLights(l) {
            if (this._lazyInitEmptyStyle(), l && l.length === 1 && l[0].type === "flat") {
              const t = l[0];
              t.properties ? this.style.setFlatLight(t.properties, t.id, {}) : this.style.setFlatLight({}, "flat");
            } else this.style.setLights(l), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
            return this._update(!0);
          }
          getLights() {
            const l = this.style.getLights() || [];
            return l.length === 0 && l.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), l;
          }
          setLight(l, t = {}) {
            return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: l }]);
          }
          getLight() {
            return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
          }
          setTerrain(l) {
            return this._lazyInitEmptyStyle(), !l && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(l), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
          }
          getTerrain() {
            return this.style ? this.style.getTerrain() : null;
          }
          setFog(l) {
            return this._lazyInitEmptyStyle(), this.style.setFog(l), this._update(!0);
          }
          getFog() {
            return this.style ? this.style.getFog() : null;
          }
          setSnow(l) {
            return this._lazyInitEmptyStyle(), this.style.setSnow(l), this._update(!0);
          }
          getSnow() {
            return this.style ? this.style.getSnow() : null;
          }
          setRain(l) {
            return this._lazyInitEmptyStyle(), this.style.setRain(l), this._update(!0);
          }
          getRain() {
            return this.style ? this.style.getRain() : null;
          }
          setColorTheme(l) {
            return this._lazyInitEmptyStyle(), this.style.setColorTheme(l), this._update(!0);
          }
          setImportColorTheme(l, t) {
            return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(l, t), this._update(!0);
          }
          setCamera(l) {
            return this.style.setCamera(l), this._triggerCameraUpdate(l);
          }
          _triggerCameraUpdate(l) {
            return this._update(this.transform.setOrthographicProjectionAtLowPitch(l["camera-projection"] === "orthographic"));
          }
          getCamera() {
            return this.style.camera;
          }
          _queryFogOpacity(l) {
            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(r.bO.convert(l), this.transform) : 0;
          }
          setFeatureState(l, t) {
            return l.source && !this._isValidId(l.source) ? this : (this.style.setFeatureState(l, t), this._update());
          }
          removeFeatureState(l, t) {
            return l.source && !this._isValidId(l.source) ? this : (this.style.removeFeatureState(l, t), this._update());
          }
          getFeatureState(l) {
            return l.source && !this._isValidId(l.source) ? null : this.style.getFeatureState(l);
          }
          _updateContainerDimensions() {
            if (!this._container) return;
            const l = this._container.getBoundingClientRect().width || 400, t = this._container.getBoundingClientRect().height || 300;
            let n, u, d, _ = this._container;
            for (; _ && (!u || !d); ) {
              const v = window.getComputedStyle(_).transform;
              v && v !== "none" && (n = v.match(/matrix.*\((.+)\)/)[1].split(", "), n[0] && n[0] !== "0" && n[0] !== "1" && (u = n[0]), n[3] && n[3] !== "0" && n[3] !== "1" && (d = n[3])), _ = _.parentElement;
            }
            this._containerWidth = u ? Math.abs(l / u) : l, this._containerHeight = d ? Math.abs(t / d) : t;
          }
          _detectMissingCSS() {
            window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && r.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
          }
          _setupContainer() {
            const l = this._container;
            l.classList.add("mapboxgl-map"), (this._missingCSSCanary = I("div", "mapboxgl-canary", l)).style.visibility = "hidden", this._detectMissingCSS();
            const t = this._canvasContainer = I("div", "mapboxgl-canvas-container", l);
            this._canvas = I("canvas", "mapboxgl-canvas", t), this._interactive && (t.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
            const n = this._controlContainer = I("div", "mapboxgl-control-container", l), u = this._controlPositions = {};
            ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach((d) => {
              u[d] = I("div", `mapboxgl-ctrl-${d}`, n);
            }), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(l, t) {
            const n = r.q.devicePixelRatio || 1;
            this._canvas.width = n * Math.ceil(l), this._canvas.height = n * Math.ceil(t), this._canvas.style.width = `${l}px`, this._canvas.style.height = `${t}px`;
          }
          _addMarker(l) {
            this._markers.push(l);
          }
          _removeMarker(l) {
            const t = this._markers.indexOf(l);
            t !== -1 && this._markers.splice(t, 1);
          }
          _addPopup(l) {
            this._popups.push(l);
          }
          _removePopup(l) {
            const t = this._popups.indexOf(l);
            t !== -1 && this._popups.splice(t, 1);
          }
          _setupPainter() {
            const l = r.l({}, m.supported.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), t = this._canvas.getContext("webgl2", l);
            t ? (Xt(t, !0), this.painter = new ah(t, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp), this.on("data", (n) => {
              n.dataType === "source" && this.painter.setTileLoadedFlag(!0);
            }), r.m.testSupport(t)) : this.fire(new r.y(new Error("Failed to initialize WebGL")));
          }
          _contextLost(l) {
            l.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new r.z("webglcontextlost", { originalEvent: l }));
          }
          _contextRestored(l) {
            this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style.reloadModels(), this.style.clearSources(), this._update(), this.fire(new r.z("webglcontextrestored", { originalEvent: l }));
          }
          _onMapScroll(l) {
            if (l.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }
          idle() {
            return !this.isMoving() && this.loaded();
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          frameReady() {
            return this.loaded() && !this._placementDirty;
          }
          _update(l) {
            return this.style ? (this._styleDirty = this._styleDirty || l, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(l) {
            return this._update(), this._renderTaskQueue.add(l);
          }
          _cancelRenderFrame(l) {
            this._renderTaskQueue.remove(l);
          }
          _requestDomTask(l) {
            !this.loaded() || this.loaded() && !this.isMoving() ? l() : this._domRenderTaskQueue.add(l);
          }
          _render(l) {
            let t;
            this.fire(new r.z("renderstart")), ++this._frameId;
            const n = this.painter.context.extTimerQuery, u = r.q.now(), d = this.painter.context.gl;
            if (this.listens("gpu-timing-frame") && (t = d.createQuery(), d.beginQuery(n.TIME_ELAPSED_EXT, t)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(l), this._domRenderTaskQueue.run(l), this._removed) return;
            this._updateProjectionTransition();
            const _ = this._isInitialLoad ? 0 : this._fadeDuration;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const X = this.transform.zoom, K = this.transform.pitch, ae = r.q.now(), oe = new r.a8(X, { now: ae, fadeDuration: _, pitch: K, transition: this.style.transition });
              this.style.update(oe);
            }
            this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
            let v = !1;
            this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), v = this._updateAverageElevation(u), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : v = this._updateAverageElevation(u);
            const L = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, _, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);
            if (this._scaleFactorChanged && (this._scaleFactorChanged = !1), L && (this._placementDirty = L.needsRerender), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: _, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new r.z("render")), this.loaded() && !this._loaded && (this._loaded = !0, P.mark(H.load), this.fire(new r.z("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), t) {
              const X = r.q.now() - u;
              d.endQuery(n.TIME_ELAPSED_EXT), setTimeout(() => {
                const K = d.getQueryParameter(t, d.QUERY_RESULT) / 1e6;
                d.deleteQuery(t), this.fire(new r.z("gpu-timing-frame", { cpuTime: X, gpuTime: K }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              const X = this.painter.collectGpuTimers();
              setTimeout(() => {
                const K = this.painter.queryGpuTimers(X);
                this.fire(new r.z("gpu-timing-layer", { layerTimes: K }));
              }, 50);
            }
            if (this.listens("gpu-timing-deferred-render")) {
              const X = this.painter.collectDeferredRenderGpuQueries();
              setTimeout(() => {
                const K = this.painter.queryGpuTimeDeferredRender(X);
                this.fire(new r.z("gpu-timing-deferred-render", { gpuTime: K }));
              }, 50);
            }
            const G = this._sourcesDirty || this._styleDirty || this._placementDirty || v;
            if (G || this._repaint) this.triggerRepaint();
            else {
              const X = this.idle();
              if (X && (v = this._updateAverageElevation(u, !0)), v) this.triggerRepaint();
              else if (this._triggerFrame(!1), X && (this.fire(new r.z("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                const K = this._calculateSpeedIndex();
                this.fire(new r.z("speedindexcompleted", { speedIndex: K })), this.speedIndexTiming = !1;
              }
            }
            !this._loaded || this._fullyLoaded || G || (this._fullyLoaded = !0, P.mark(H.fullLoad), this._performanceMetricsCollection && ct(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
          }
          _forceMarkerAndPopupUpdate(l) {
            for (const t of this._markers) l && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();
            for (const t of this._popups) !l || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update();
          }
          _updateAverageElevation(l, t = !1) {
            const n = (d) => (this.transform.averageElevation = d, this._update(!1), !0);
            if (!this.painter.averageElevationNeedsEasing()) return this.transform.averageElevation !== 0 && n(0);
            const u = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
            if (u || (t || l - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(l)) {
              const d = this.transform.averageElevation;
              let _ = this.transform.sampleAverageElevation();
              this.transform.elevation != null && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(_) ? _ = 0 : this._averageElevationLastSampledAt = l;
              const v = Math.abs(d - _);
              if (v > 1) {
                if (this._isInitialLoad || u) return this._averageElevation.jumpTo(_), n(_);
                this._averageElevation.easeTo(_, l, 300);
              } else if (v > 1e-4) return this._averageElevation.jumpTo(_), n(_);
            }
            return !!this._averageElevation.isEasing(l) && n(this._averageElevation.getValue(l));
          }
          _authenticate() {
            Oe(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (l) => {
              if (l && (l.message === ve || l.status === 401)) {
                const t = this.painter.context.gl;
                Xt(t, !1), this._logoControl instanceof no && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new r.y(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
              }
            }), Ie(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
            });
          }
          _postStyleLoadEvent() {
            this.style.globalId && Fe(this._requestManager._customAccessToken, { map: this, skuToken: this._requestManager._skuToken, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() });
          }
          _updateTerrain() {
            const l = this._isDragging();
            this.painter.updateTerrain(this.style, l);
          }
          _calculateSpeedIndex() {
            const l = this.painter.canvasCopy(), t = this.painter.getCanvasCopiesAndTimestamps();
            t.timeStamps.push(performance.now());
            const n = this.painter.context.gl, u = n.createFramebuffer();
            function d(_) {
              n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, _, 0);
              const v = new Uint8Array(n.drawingBufferWidth * n.drawingBufferHeight * 4);
              return n.readPixels(0, 0, n.drawingBufferWidth, n.drawingBufferHeight, n.RGBA, n.UNSIGNED_BYTE, v), v;
            }
            return n.bindFramebuffer(n.FRAMEBUFFER, u), this._canvasPixelComparison(d(l), t.canvasCopies.map(d), t.timeStamps);
          }
          _canvasPixelComparison(l, t, n) {
            let u = n[1] - n[0];
            const d = l.length / 4;
            for (let _ = 0; _ < t.length; _++) {
              const v = t[_];
              let L = 0;
              for (let G = 0; G < v.length; G += 4) v[G] === l[G] && v[G + 1] === l[G + 1] && v[G + 2] === l[G + 2] && v[G + 3] === l[G + 3] && (L += 1);
              u += (n[_ + 2] - n[_ + 1]) * (1 - L / d);
            }
            return u;
          }
          remove() {
            this._hash && this._hash.remove();
            for (const t of this._controls) t.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, !1), window.removeEventListener("orientationchange", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener("online", this._onWindowOnline, !1), window.removeEventListener("visibilitychange", this._onVisibilityChange, !1);
            const l = this.painter.context.gl.getExtension("WEBGL_lose_context");
            l && l.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), Ct.delete(this.painter.context.gl), wt.remove(), Ue.remove(), this._removed = !0, this.fire(new r.z("remove"));
          }
          triggerRepaint() {
            this._triggerFrame(!0);
          }
          _triggerFrame(l) {
            this._renderNextFrame = this._renderNextFrame || l, this.style && !this._frame && (this._frame = r.q.frame((t) => {
              const n = !!this._renderNextFrame;
              this._frame = null, this._renderNextFrame = null, n && this._render(t);
            }));
          }
          _preloadTiles(l) {
            const t = this.style ? this.style.getSourceCaches() : [];
            return r.bl(t, (n, u) => n._preloadTiles(l, u), () => {
              this.triggerRepaint();
            }), this;
          }
          _onWindowOnline() {
            this._update();
          }
          _onWindowResize(l) {
            this._trackResize && this.resize({ originalEvent: l })._update();
          }
          _onVisibilityChange() {
            document.visibilityState === "hidden" && this._visibilityHidden++;
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(l) {
            this._showTileBoundaries !== l && (this._showTileBoundaries = l, this._tp.refreshUI(), this._update());
          }
          get showParseStatus() {
            return !!this._showParseStatus;
          }
          set showParseStatus(l) {
            this._showParseStatus !== l && (this._showParseStatus = l, this._tp.refreshUI(), this._update());
          }
          get showTerrainWireframe() {
            return !!this._showTerrainWireframe;
          }
          set showTerrainWireframe(l) {
            this._showTerrainWireframe !== l && (this._showTerrainWireframe = l, this._tp.refreshUI(), this._update());
          }
          get showLayers2DWireframe() {
            return !!this._showLayers2DWireframe;
          }
          set showLayers2DWireframe(l) {
            this._showLayers2DWireframe !== l && (this._showLayers2DWireframe = l, this._tp.refreshUI(), this._update());
          }
          get showLayers3DWireframe() {
            return !!this._showLayers3DWireframe;
          }
          set showLayers3DWireframe(l) {
            this._showLayers3DWireframe !== l && (this._showLayers3DWireframe = l, this._tp.refreshUI(), this._update());
          }
          get speedIndexTiming() {
            return !!this._speedIndexTiming;
          }
          set speedIndexTiming(l) {
            this._speedIndexTiming !== l && (this._speedIndexTiming = l, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(l) {
            this._showPadding !== l && (this._showPadding = l, this._tp.refreshUI(), this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(l) {
            this._showCollisionBoxes !== l && (this._showCollisionBoxes = l, this._tp.refreshUI(), l ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(l) {
            this._showOverdrawInspector !== l && (this._showOverdrawInspector = l, this._tp.refreshUI(), this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(l) {
            this._repaint !== l && (this._repaint = l, this._tp.refreshUI(), this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(l) {
            this._vertices = l, this._update();
          }
          get showTileAABBs() {
            return !!this._showTileAABBs;
          }
          set showTileAABBs(l) {
            this._showTileAABBs !== l && (this._showTileAABBs = l, this._tp.refreshUI(), l && this._update());
          }
          _setCacheLimits(l, t) {
            r.dG(l, t);
          }
          get version() {
            return F;
          }
        }, NavigationControl: class {
          constructor(l = {}) {
            this.options = r.l({}, Sc, l), this._container = I("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this.options.showZoom && (r.aP(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (t) => {
              this._map && this._map.zoomIn({}, { originalEvent: t });
            }), I("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (t) => {
              this._map && this._map.zoomOut({}, { originalEvent: t });
            }), I("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (r.aP(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (t) => {
              const n = this._map;
              n && (this.options.visualizePitch ? n.resetNorthPitch({}, { originalEvent: t }) : n.resetNorth({}, { originalEvent: t }));
            }), this._compassIcon = I("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          _updateZoomButtons() {
            const l = this._map;
            if (!l) return;
            const t = l.getZoom(), n = t === l.getMaxZoom(), u = t === l.getMinZoom();
            this._zoomInButton.disabled = n, this._zoomOutButton.disabled = u, this._zoomInButton.setAttribute("aria-disabled", n.toString()), this._zoomOutButton.setAttribute("aria-disabled", u.toString());
          }
          _rotateCompassArrow() {
            const l = this._map;
            if (!l) return;
            const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(l.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${l.transform.pitch}deg) rotateZ(${l.transform.angle * (180 / Math.PI)}deg)` : `rotate(${l.transform.angle * (180 / Math.PI)}deg)`;
            l._requestDomTask(() => {
              this._compassIcon && (this._compassIcon.style.transform = t);
            });
          }
          onAdd(l) {
            return this._map = l, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), l.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && l.on("pitch", this._rotateCompassArrow), l.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new za(l, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            const l = this._map;
            l && (this._container.remove(), this.options.showZoom && l.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && l.off("pitch", this._rotateCompassArrow), l.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
          }
          _createButton(l, t) {
            const n = I("button", l, this._container);
            return n.type = "button", n.addEventListener("click", t), n;
          }
          _setButtonTitle(l, t) {
            if (!this._map) return;
            const n = this._map._getUIString(`NavigationControl.${t}`);
            l.setAttribute("aria-label", n), l.firstElementChild && l.firstElementChild.setAttribute("title", n);
          }
        }, GeolocateControl: class extends r.E {
          constructor(l = {}) {
            super();
            const t = navigator.geolocation;
            this.options = r.l({ geolocation: t }, xn, l), r.aP(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = gc(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
          }
          onAdd(l) {
            return this._map = l, this._container = I("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
          }
          _checkGeolocationSupport(l) {
            const t = (n = !!this.options.geolocation) => {
              this._supportsGeolocation = n, l(n);
            };
            this._supportsGeolocation !== void 0 ? l(this._supportsGeolocation) : navigator.permissions !== void 0 ? navigator.permissions.query({ name: "geolocation" }).then((n) => t(n.state !== "denied")).catch(() => t()) : t();
          }
          _isOutOfMapMaxBounds(l) {
            const t = this._map.getMaxBounds(), n = l.coords;
            return !!t && (n.longitude < t.getWest() || n.longitude > t.getEast() || n.latitude < t.getSouth() || n.latitude > t.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }
          _onSuccess(l) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(l)) return this._setErrorState(), this.fire(new r.z("outofmaxbounds", l)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = l, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(l), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(l), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new r.z("geolocate", l)), this._finish();
            }
          }
          _updateCamera(l) {
            const t = new r.bO(l.coords.longitude, l.coords.latitude), n = l.coords.accuracy, u = this._map.getBearing(), d = r.l({ bearing: u }, this.options.fitBoundsOptions);
            this._map.fitBounds(t.toBounds(n), d, { geolocateSource: !0 });
          }
          _updateMarker(l) {
            if (l) {
              const t = new r.bO(l.coords.longitude, l.coords.latitude);
              this._accuracyCircleMarker.setLngLat(t).addTo(this._map), this._userLocationDotMarker.setLngLat(t).addTo(this._map), this._accuracy = l.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }
          _updateCircleRadius() {
            const l = this._map.transform, t = r.bH(1, l._center.lat) * l.worldSize, n = Math.ceil(2 * this._accuracy * t);
            this._circleElement.style.width = `${n}px`, this._circleElement.style.height = `${n}px`;
          }
          _onZoom() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }
          _updateMarkerRotation() {
            this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
          }
          _onError(l) {
            if (this._map) {
              if (this.options.trackUserLocation) if (l.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (l.code === 3 && this._noTimeout) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new r.z("error", l)), this._finish();
            }
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }
          _setupUI(l) {
            if (this._map !== void 0) {
              if (this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this._geolocateButton = I("button", "mapboxgl-ctrl-geolocate", this._container), I("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", l === !1) {
                r.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
              } else {
                const t = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = I("div", "mapboxgl-user-location"), this._dotElement.appendChild(I("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(I("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new oo({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = I("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new oo({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (t) => {
                t.geolocateSource || this._watchState !== "ACTIVE_LOCK" || t.originalEvent && t.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new r.z("trackuserlocationend")));
              });
            }
          }
          _onDeviceOrientation(l) {
            this._userLocationDotMarker && (l.webkitCompassHeading ? this._heading = l.webkitCompassHeading : l.absolute === !0 && (this._heading = -1 * l.alpha), this._updateMarkerRotationThrottled());
          }
          trigger() {
            if (!this._setup) return r.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new r.z("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new r.z("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new r.z("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let l;
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (l = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = !0) : (l = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, l), this.options.showUserHeading && this._addDeviceOrientationListener();
              }
            } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
            return !0;
          }
          _addDeviceOrientationListener() {
            const l = () => {
              "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
            };
            typeof DeviceMotionEvent < "u" && typeof DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then((t) => {
              t === "granted" && l();
            }).catch(console.error) : l();
          }
          _clearWatch() {
            this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, AttributionControl: zu, ScaleControl: class {
          constructor(l = {}) {
            this.options = r.l({}, so, l), this._isNumberFormatSupported = function() {
              try {
                return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), !0;
              } catch {
                return !1;
              }
            }(), r.aP(["_update", "_setScale", "setUnit"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _update() {
            const l = this.options.maxWidth || 100, t = this._map, n = t._containerHeight / 2, u = t._containerWidth / 2 - l / 2, d = t.unproject([u, n]), _ = t.unproject([u + l, n]), v = d.distanceTo(_);
            if (this.options.unit === "imperial") {
              const L = 3.2808 * v;
              L > 5280 ? this._setScale(l, L / 5280, "mile") : this._setScale(l, L, "foot");
            } else this.options.unit === "nautical" ? this._setScale(l, v / 1852, "nautical-mile") : v >= 1e3 ? this._setScale(l, v / 1e3, "kilometer") : this._setScale(l, v, "meter");
          }
          _setScale(l, t, n) {
            this._map._requestDomTask(() => {
              const u = function(_) {
                const v = Math.pow(10, `${Math.floor(_)}`.length - 1);
                let L = _ / v;
                return L = L >= 10 ? 10 : L >= 5 ? 5 : L >= 3 ? 3 : L >= 2 ? 2 : L >= 1 ? 1 : function(G) {
                  const X = Math.pow(10, Math.ceil(-Math.log(G) / Math.LN10));
                  return Math.round(G * X) / X;
                }(L), v * L;
              }(t), d = u / t;
              this._container.innerHTML = this._isNumberFormatSupported && n !== "nautical-mile" ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: n }).format(u) : `${u}&nbsp;${ci[n]}`, this._container.style.width = l * d + "px";
            });
          }
          onAdd(l) {
            return this._map = l, this._language = l.getLanguage(), this._container = I("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", l.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("move", this._update), this._map = void 0;
          }
          _setLanguage(l) {
            this._language = l, this._update();
          }
          setUnit(l) {
            this.options.unit = l, this._update();
          }
        }, FullscreenControl: class {
          constructor(l = {}) {
            this._fullscreen = !1, l && l.container && (l.container instanceof HTMLElement ? this._container = l.container : r.w("Full screen control 'container' must be a DOM element.")), r.aP(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
          }
          onAdd(l) {
            return this._map = l, this._container || (this._container = this._map.getContainer()), this._controlContainer = I("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", r.w("This device does not support fullscreen mode.")), this._controlContainer;
          }
          onRemove() {
            this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
          }
          _setupUI() {
            const l = this._fullscreenButton = I("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
            I("span", "mapboxgl-ctrl-icon", l).setAttribute("aria-hidden", "true"), l.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            const l = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", l), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", l);
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }
          _onClickFullscreen() {
            this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          }
        }, Popup: class extends r.E {
          constructor(l) {
            super(), this.options = r.l(Object.create(Xl), l), r.aP(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(l && l.className ? l.className.trim().split(/\s+/) : []);
          }
          addTo(l) {
            return this._map && this.remove(), this._map = l, this.options.closeOnClick && l.on("preclick", this._onClose), this.options.closeOnMove && l.on("move", this._onClose), l.on("remove", this.remove), this._update(), l._addPopup(this), this._focusFirstElement(), this._trackPointer ? (l.on("mousemove", this._onMouseEvent), l.on("mouseup", this._onMouseEvent), l._canvasContainer.classList.add("mapboxgl-track-pointer")) : l.on("move", this._update), this.fire(new r.z("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
            const l = this._map;
            return l && (l.off("move", this._update), l.off("move", this._onClose), l.off("preclick", this._onClose), l.off("click", this._onClose), l.off("remove", this.remove), l.off("mousemove", this._onMouseEvent), l.off("mouseup", this._onMouseEvent), l.off("drag", this._onMouseEvent), l._canvasContainer && l._canvasContainer.classList.remove("mapboxgl-track-pointer"), l._removePopup(this), this._map = void 0), this.fire(new r.z("close")), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(l) {
            this._lngLat = r.bO.convert(l), this._pos = null, this._trackPointer = !1, this._update();
            const t = this._map;
            return t && (t.on("move", this._update), t.off("mousemove", this._onMouseEvent), t._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }
          trackPointer() {
            this._trackPointer = !0, this._pos = null, this._update();
            const l = this._map;
            return l && (l.off("move", this._update), l.on("mousemove", this._onMouseEvent), l.on("drag", this._onMouseEvent), l._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(l) {
            return this.setDOMContent(document.createTextNode(l));
          }
          setHTML(l) {
            const t = document.createDocumentFragment(), n = document.createElement("body");
            let u;
            for (n.innerHTML = l; u = n.firstChild, u; ) t.appendChild(u);
            return this.setDOMContent(t);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(l) {
            return this.options.maxWidth = l, this._update(), this;
          }
          setDOMContent(l) {
            let t = this._content;
            if (t) for (; t.hasChildNodes(); ) t.firstChild && t.removeChild(t.firstChild);
            else t = this._content = I("div", "mapboxgl-popup-content", this._container || void 0);
            if (t.appendChild(l), this.options.closeButton) {
              const n = this._closeButton = I("button", "mapboxgl-popup-close-button", t);
              n.type = "button", n.setAttribute("aria-label", "Close popup"), n.innerHTML = '<span aria-hidden="true">&#215;</span>', n.addEventListener("click", this._onClose);
            }
            return this._update(), this._focusFirstElement(), this;
          }
          addClassName(l) {
            return this._classList.add(l), this._updateClassList(), this;
          }
          removeClassName(l) {
            return this._classList.delete(l), this._updateClassList(), this;
          }
          setOffset(l) {
            return this.options.offset = l, this._update(), this;
          }
          toggleClassName(l) {
            let t;
            return this._classList.delete(l) ? t = !1 : (this._classList.add(l), t = !0), this._updateClassList(), t;
          }
          _onMouseEvent(l) {
            this._update(l.point);
          }
          _getAnchor(l) {
            if (this.options.anchor) return this.options.anchor;
            const t = this._map, n = this._container, u = this._pos;
            if (!t || !n || !u) return "bottom";
            const d = n.offsetWidth, _ = n.offsetHeight, v = u.x < d / 2, L = u.x > t.transform.width - d / 2;
            if (u.y + l < _) return v ? "top-left" : L ? "top-right" : "top";
            if (u.y > t.transform.height - _) {
              if (v) return "bottom-left";
              if (L) return "bottom-right";
            }
            return v ? "left" : L ? "right" : "bottom";
          }
          _updateClassList() {
            const l = this._container;
            if (!l) return;
            const t = [...this._classList];
            t.push("mapboxgl-popup"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push("mapboxgl-popup-track-pointer"), l.className = t.join(" ");
          }
          _update(l) {
            const t = this._map, n = this._content;
            if (!t || !this._lngLat && !this._trackPointer || !n) return;
            let u = this._container;
            if (u || (u = this._container = I("div", "mapboxgl-popup", t.getContainer()), this._tip = I("div", "mapboxgl-popup-tip", u), u.appendChild(n)), this.options.maxWidth && u.style.maxWidth !== this.options.maxWidth && (u.style.maxWidth = this.options.maxWidth), t.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = hh(this._lngLat, this._pos, t.transform)), !this._trackPointer || l) {
              const d = this._pos = this._trackPointer && l instanceof r.P ? l : t.project(this._lngLat), _ = fh(this.options.offset), v = this._anchor = this._getAnchor(_.y), L = fh(this.options.offset, v), G = d.add(L).round();
              t._requestDomTask(() => {
                this._container && v && (this._container.style.transform = `${ls[v]} translate(${G.x}px,${G.y}px)`);
              });
            }
            if (!this._marker && t._showingGlobe()) {
              const d = r.dH(t.transform, this._lngLat) ? 0 : 1;
              this._setOpacity(d);
            }
            this._updateClassList();
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const l = this._container.querySelector(Cn);
            l && l.focus();
          }
          _onClose() {
            this.remove();
          }
          _setOpacity(l) {
            this._container && (this._container.style.opacity = `${l}`), this._content && (this._content.style.pointerEvents = l ? "auto" : "none");
          }
        }, Marker: oo, Style: Ka, LngLat: r.bO, LngLatBounds: r.az, Point: r.P, MercatorCoordinate: r.aa, FreeCameraOptions: Xu, Evented: r.E, config: r.e, prewarm: r.dM, clearPrewarmedResources: r.dN, get accessToken() {
          return r.e.ACCESS_TOKEN;
        }, set accessToken(l) {
          r.e.ACCESS_TOKEN = l;
        }, get baseApiUrl() {
          return r.e.API_URL;
        }, set baseApiUrl(l) {
          r.e.API_URL = l;
        }, get workerCount() {
          return r.dO.workerCount;
        }, set workerCount(l) {
          r.dO.workerCount = l;
        }, get maxParallelImageRequests() {
          return r.e.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(l) {
          r.e.MAX_PARALLEL_IMAGE_REQUESTS = l;
        }, clearStorage(l) {
          r.dP(l);
        }, get workerUrl() {
          return r.dQ.workerUrl;
        }, set workerUrl(l) {
          r.dQ.workerUrl = l;
        }, get workerClass() {
          return r.dQ.workerClass;
        }, set workerClass(l) {
          r.dQ.workerClass = l;
        }, get workerParams() {
          return r.dQ.workerParams;
        }, set workerParams(l) {
          r.dQ.workerParams = l;
        }, get dracoUrl() {
          return r.dR();
        }, set dracoUrl(l) {
          r.dS(l);
        }, get meshoptUrl() {
          return r.dT();
        }, set meshoptUrl(l) {
          r.dU(l);
        }, setNow: r.q.setNow, restoreNow: r.q.restoreNow };
      });
      var Q = Ee;
      return Q;
    });
  }(jp)), jp.exports;
}
var Mb = Tb();
const P_ = /* @__PURE__ */ Hp(Mb), Ab = ({ map: Qe, setPreviewContent: Mt, setPreviewType: pt, setShowBackgroundSelector: te, cf: Ee, setCustomFields: $ }) => {
  const Q = () => {
    window.devicePixelRatio = 2;
    const r = 300, F = document.createElement("div");
    F.style.width = `${r}px`, F.style.height = `${r}px`, F.style.position = "absolute", F.style.visibility = "hidden", document.body.appendChild(F);
    const H = new P_.Map({
      container: F,
      style: Qe.current.getStyle(),
      center: Qe.current.getCenter(),
      zoom: Qe.current.getZoom(),
      bearing: Qe.current.getBearing(),
      pitch: Qe.current.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      width: r,
      height: r
    });
    H.once("idle", () => {
      const P = H.getCanvas(), M = document.createElement("canvas");
      M.width = r, M.height = r;
      const E = M.getContext("2d"), x = (P.width - r) / 2, m = (P.height - r) / 2;
      E.drawImage(P, x, m, r, r, 0, 0, r, r);
      const I = M.toDataURL("image/jpeg", 1);
      Mt(I), pt("image"), $(Ee), te(!1), H.remove(), document.body.removeChild(F);
    });
  };
  return /* @__PURE__ */ gi.jsx("div", { className: "map-snapshot", children: /* @__PURE__ */ gi.jsx("div", { className: "confirm-button", onClick: Q, children: Ee.name }) });
}, R_ = ({ renderInMap: Qe, onMarkerChange: Mt, selectedType: pt, metalType: te }) => {
  var H;
  const $ = Wp().filter((P) => {
    var M;
    return P.field_type === "custom" && ((M = P.slug) == null ? void 0 : M.includes("capture-"));
  }), Q = {
    heart: /* @__PURE__ */ gi.jsx("path", { d: "M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" }),
    pin: /* @__PURE__ */ gi.jsx("path", { d: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" }),
    stone: /* @__PURE__ */ gi.jsx("path", { d: "M12 2L2 8.5L12 15L22 8.5L12 2ZM12 17L2 10.5L12 22L22 10.5L12 17Z" })
  }, r = {
    heart: "#323232",
    pin: `var(--metal-border-${te})`,
    stone: "#000000"
  };
  if (Qe)
    return pt !== "none" ? /* @__PURE__ */ gi.jsx("div", { className: "icon-marker", style: { color: r[pt] }, children: /* @__PURE__ */ gi.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "currentColor", children: Q[pt] }) }) : null;
  const F = (H = $[0]) == null ? void 0 : H.options.marker;
  return /* @__PURE__ */ gi.jsxs("div", { className: "marker-selector", children: [
    /* @__PURE__ */ gi.jsx("label", { className: "marker-label", children: "Marker style:" }),
    /* @__PURE__ */ gi.jsx("div", { className: "marker-swatches", children: F.map((P) => /* @__PURE__ */ gi.jsxs("label", { className: "marker-swatch", children: [
      /* @__PURE__ */ gi.jsx(
        "input",
        {
          type: "radio",
          name: "marker-type",
          value: P.value,
          checked: pt === P.value,
          onChange: (M) => Mt(M.target.value)
        }
      ),
      /* @__PURE__ */ gi.jsxs("span", { children: [
        P.value !== "none" && /* @__PURE__ */ gi.jsx(
          "svg",
          {
            width: "16",
            height: "16",
            viewBox: "0 0 24 24",
            fill: "currentColor",
            style: { color: r[P.value] },
            children: Q[P.value]
          }
        ),
        P.label
      ] })
    ] }, P.value)) })
  ] });
};
function Np(Qe) {
  throw new Error('Could not dynamically require "' + Qe + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var d_ = { exports: {} }, Qy;
function wv() {
  return Qy || (Qy = 1, function(Qe, Mt) {
    if ((typeof pt > "u" || !pt) && typeof self < "u") var pt = self;
    (function(te) {
      Qe.exports = te();
    })(function() {
      return (/* @__PURE__ */ function() {
        function te(Ee, $, Q) {
          function r(P, M) {
            if (!$[P]) {
              if (!Ee[P]) {
                var E = typeof Np == "function" && Np;
                if (!M && E) return E(P, !0);
                if (F) return F(P, !0);
                var x = new Error("Cannot find module '" + P + "'");
                throw x.code = "MODULE_NOT_FOUND", x;
              }
              var m = $[P] = { exports: {} };
              Ee[P][0].call(m.exports, function(I) {
                var z = Ee[P][1][I];
                return r(z || I);
              }, m, m.exports, te, Ee, $, Q);
            }
            return $[P].exports;
          }
          for (var F = typeof Np == "function" && Np, H = 0; H < Q.length; H++) r(Q[H]);
          return r;
        }
        return te;
      }())({ 1: [function(te, Ee, $) {
        function Q(r) {
          if (Array.isArray(r)) return r;
        }
        Ee.exports = Q;
      }, {}], 2: [function(te, Ee, $) {
        function Q(r) {
          if (Array.isArray(r)) {
            for (var F = 0, H = new Array(r.length); F < r.length; F++)
              H[F] = r[F];
            return H;
          }
        }
        Ee.exports = Q;
      }, {}], 3: [function(te, Ee, $) {
        function Q(r) {
          if (r === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return r;
        }
        Ee.exports = Q;
      }, {}], 4: [function(te, Ee, $) {
        function Q(r, F) {
          if (!(r instanceof F))
            throw new TypeError("Cannot call a class as a function");
        }
        Ee.exports = Q;
      }, {}], 5: [function(te, Ee, $) {
        var Q = te("./setPrototypeOf");
        function r() {
          if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
          if (typeof Proxy == "function") return !0;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), !0;
          } catch {
            return !1;
          }
        }
        function F(H, P, M) {
          return r() ? Ee.exports = F = Reflect.construct : Ee.exports = F = function(x, m, I) {
            var z = [null];
            z.push.apply(z, m);
            var w = Function.bind.apply(x, z), C = new w();
            return I && Q(C, I.prototype), C;
          }, F.apply(null, arguments);
        }
        Ee.exports = F;
      }, { "./setPrototypeOf": 18 }], 6: [function(te, Ee, $) {
        function Q(F, H) {
          for (var P = 0; P < H.length; P++) {
            var M = H[P];
            M.enumerable = M.enumerable || !1, M.configurable = !0, "value" in M && (M.writable = !0), Object.defineProperty(F, M.key, M);
          }
        }
        function r(F, H, P) {
          return H && Q(F.prototype, H), P && Q(F, P), F;
        }
        Ee.exports = r;
      }, {}], 7: [function(te, Ee, $) {
        function Q(r, F, H) {
          return F in r ? Object.defineProperty(r, F, {
            value: H,
            enumerable: !0,
            configurable: !0,
            writable: !0
          }) : r[F] = H, r;
        }
        Ee.exports = Q;
      }, {}], 8: [function(te, Ee, $) {
        function Q() {
          return Ee.exports = Q = Object.assign || function(r) {
            for (var F = 1; F < arguments.length; F++) {
              var H = arguments[F];
              for (var P in H)
                Object.prototype.hasOwnProperty.call(H, P) && (r[P] = H[P]);
            }
            return r;
          }, Q.apply(this, arguments);
        }
        Ee.exports = Q;
      }, {}], 9: [function(te, Ee, $) {
        function Q(r) {
          return Ee.exports = Q = Object.setPrototypeOf ? Object.getPrototypeOf : function(H) {
            return H.__proto__ || Object.getPrototypeOf(H);
          }, Q(r);
        }
        Ee.exports = Q;
      }, {}], 10: [function(te, Ee, $) {
        var Q = te("./setPrototypeOf");
        function r(F, H) {
          if (typeof H != "function" && H !== null)
            throw new TypeError("Super expression must either be null or a function");
          F.prototype = Object.create(H && H.prototype, {
            constructor: {
              value: F,
              writable: !0,
              configurable: !0
            }
          }), H && Q(F, H);
        }
        Ee.exports = r;
      }, { "./setPrototypeOf": 18 }], 11: [function(te, Ee, $) {
        function Q(r) {
          return r && r.__esModule ? r : {
            default: r
          };
        }
        Ee.exports = Q;
      }, {}], 12: [function(te, Ee, $) {
        var Q = te("../helpers/typeof");
        function r() {
          if (typeof WeakMap != "function") return null;
          var H = /* @__PURE__ */ new WeakMap();
          return r = function() {
            return H;
          }, H;
        }
        function F(H) {
          if (H && H.__esModule)
            return H;
          if (H === null || Q(H) !== "object" && typeof H != "function")
            return {
              default: H
            };
          var P = r();
          if (P && P.has(H))
            return P.get(H);
          var M = {}, E = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var x in H)
            if (Object.prototype.hasOwnProperty.call(H, x)) {
              var m = E ? Object.getOwnPropertyDescriptor(H, x) : null;
              m && (m.get || m.set) ? Object.defineProperty(M, x, m) : M[x] = H[x];
            }
          return M.default = H, P && P.set(H, M), M;
        }
        Ee.exports = F;
      }, { "../helpers/typeof": 21 }], 13: [function(te, Ee, $) {
        function Q(r) {
          if (Symbol.iterator in Object(r) || Object.prototype.toString.call(r) === "[object Arguments]") return Array.from(r);
        }
        Ee.exports = Q;
      }, {}], 14: [function(te, Ee, $) {
        function Q(r, F) {
          if (Symbol.iterator in Object(r) || Object.prototype.toString.call(r) === "[object Arguments]") {
            var H = [], P = !0, M = !1, E = void 0;
            try {
              for (var x = r[Symbol.iterator](), m; !(P = (m = x.next()).done) && (H.push(m.value), !(F && H.length === F)); P = !0)
                ;
            } catch (I) {
              M = !0, E = I;
            } finally {
              try {
                !P && x.return != null && x.return();
              } finally {
                if (M) throw E;
              }
            }
            return H;
          }
        }
        Ee.exports = Q;
      }, {}], 15: [function(te, Ee, $) {
        function Q() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
        Ee.exports = Q;
      }, {}], 16: [function(te, Ee, $) {
        function Q() {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }
        Ee.exports = Q;
      }, {}], 17: [function(te, Ee, $) {
        var Q = te("../helpers/typeof"), r = te("./assertThisInitialized");
        function F(H, P) {
          return P && (Q(P) === "object" || typeof P == "function") ? P : r(H);
        }
        Ee.exports = F;
      }, { "../helpers/typeof": 21, "./assertThisInitialized": 3 }], 18: [function(te, Ee, $) {
        function Q(r, F) {
          return Ee.exports = Q = Object.setPrototypeOf || function(P, M) {
            return P.__proto__ = M, P;
          }, Q(r, F);
        }
        Ee.exports = Q;
      }, {}], 19: [function(te, Ee, $) {
        var Q = te("./arrayWithHoles"), r = te("./iterableToArrayLimit"), F = te("./nonIterableRest");
        function H(P, M) {
          return Q(P) || r(P, M) || F();
        }
        Ee.exports = H;
      }, { "./arrayWithHoles": 1, "./iterableToArrayLimit": 14, "./nonIterableRest": 15 }], 20: [function(te, Ee, $) {
        var Q = te("./arrayWithoutHoles"), r = te("./iterableToArray"), F = te("./nonIterableSpread");
        function H(P) {
          return Q(P) || r(P) || F();
        }
        Ee.exports = H;
      }, { "./arrayWithoutHoles": 2, "./iterableToArray": 13, "./nonIterableSpread": 16 }], 21: [function(te, Ee, $) {
        function Q(F) {
          return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Q = function(P) {
            return typeof P;
          } : Q = function(P) {
            return P && typeof Symbol == "function" && P.constructor === Symbol && P !== Symbol.prototype ? "symbol" : typeof P;
          }, Q(F);
        }
        function r(F) {
          return typeof Symbol == "function" && Q(Symbol.iterator) === "symbol" ? Ee.exports = r = function(P) {
            return Q(P);
          } : Ee.exports = r = function(P) {
            return P && typeof Symbol == "function" && P.constructor === Symbol && P !== Symbol.prototype ? "symbol" : Q(P);
          }, r(F);
        }
        Ee.exports = r;
      }, {}], 22: [function(te, Ee, $) {
        Ee.exports = te("regenerator-runtime");
      }, { "regenerator-runtime": 153 }], 23: [function(te, Ee, $) {
        var Q = te("./src/converter");
        function r(F, H) {
          var P = new Q(F, H);
          return function(M) {
            return P.convert(M);
          };
        }
        r.BIN = "01", r.OCT = "01234567", r.DEC = "0123456789", r.HEX = "0123456789abcdef", Ee.exports = r;
      }, { "./src/converter": 24 }], 24: [function(te, Ee, $) {
        function Q(r, F) {
          if (!r || !F || !r.length || !F.length)
            throw new Error("Bad alphabet");
          this.srcAlphabet = r, this.dstAlphabet = F;
        }
        Q.prototype.convert = function(r) {
          var F, H, P, M = {}, E = this.srcAlphabet.length, x = this.dstAlphabet.length, m = r.length, I = typeof r == "string" ? "" : [];
          if (!this.isValid(r))
            throw new Error('Number "' + r + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
          if (this.srcAlphabet === this.dstAlphabet)
            return r;
          for (F = 0; F < m; F++)
            M[F] = this.srcAlphabet.indexOf(r[F]);
          do {
            for (H = 0, P = 0, F = 0; F < m; F++)
              H = H * E + M[F], H >= x ? (M[P++] = parseInt(H / x, 10), H = H % x) : P > 0 && (M[P++] = 0);
            m = P, I = this.dstAlphabet.slice(H, H + 1).concat(I);
          } while (P !== 0);
          return I;
        }, Q.prototype.isValid = function(r) {
          for (var F = 0; F < r.length; ++F)
            if (this.srcAlphabet.indexOf(r[F]) === -1)
              return !1;
          return !0;
        }, Ee.exports = Q;
      }, {}], 25: [function(te, Ee, $) {
        (function(Q) {
          var r = te("object-assign");
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
           * @license  MIT
           */
          function F(xe, le) {
            if (xe === le)
              return 0;
            for (var de = xe.length, De = le.length, ze = 0, Ze = Math.min(de, De); ze < Ze; ++ze)
              if (xe[ze] !== le[ze]) {
                de = xe[ze], De = le[ze];
                break;
              }
            return de < De ? -1 : De < de ? 1 : 0;
          }
          function H(xe) {
            return Q.Buffer && typeof Q.Buffer.isBuffer == "function" ? Q.Buffer.isBuffer(xe) : !!(xe != null && xe._isBuffer);
          }
          var P = te("util/"), M = Object.prototype.hasOwnProperty, E = Array.prototype.slice, x = function() {
            return (function() {
            }).name === "foo";
          }();
          function m(xe) {
            return Object.prototype.toString.call(xe);
          }
          function I(xe) {
            return H(xe) || typeof Q.ArrayBuffer != "function" ? !1 : typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(xe) : xe ? !!(xe instanceof DataView || xe.buffer && xe.buffer instanceof ArrayBuffer) : !1;
          }
          var z = Ee.exports = V, w = /\s*function\s+([^\(\s]*)\s*/;
          function C(xe) {
            if (P.isFunction(xe)) {
              if (x)
                return xe.name;
              var le = xe.toString(), de = le.match(w);
              return de && de[1];
            }
          }
          z.AssertionError = function(le) {
            this.name = "AssertionError", this.actual = le.actual, this.expected = le.expected, this.operator = le.operator, le.message ? (this.message = le.message, this.generatedMessage = !1) : (this.message = N(this), this.generatedMessage = !0);
            var de = le.stackStartFunction || U;
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, de);
            else {
              var De = new Error();
              if (De.stack) {
                var ze = De.stack, Ze = C(de), Ue = ze.indexOf(`
` + Ze);
                if (Ue >= 0) {
                  var Ie = ze.indexOf(`
`, Ue + 1);
                  ze = ze.substring(Ie + 1);
                }
                this.stack = ze;
              }
            }
          }, P.inherits(z.AssertionError, Error);
          function b(xe, le) {
            return typeof xe == "string" ? xe.length < le ? xe : xe.slice(0, le) : xe;
          }
          function B(xe) {
            if (x || !P.isFunction(xe))
              return P.inspect(xe);
            var le = C(xe), de = le ? ": " + le : "";
            return "[Function" + de + "]";
          }
          function N(xe) {
            return b(B(xe.actual), 128) + " " + xe.operator + " " + b(B(xe.expected), 128);
          }
          function U(xe, le, de, De, ze) {
            throw new z.AssertionError({
              message: de,
              actual: xe,
              expected: le,
              operator: De,
              stackStartFunction: ze
            });
          }
          z.fail = U;
          function V(xe, le) {
            xe || U(xe, !0, le, "==", z.ok);
          }
          z.ok = V, z.equal = function(le, de, De) {
            le != de && U(le, de, De, "==", z.equal);
          }, z.notEqual = function(le, de, De) {
            le == de && U(le, de, De, "!=", z.notEqual);
          }, z.deepEqual = function(le, de, De) {
            W(le, de, !1) || U(le, de, De, "deepEqual", z.deepEqual);
          }, z.deepStrictEqual = function(le, de, De) {
            W(le, de, !0) || U(le, de, De, "deepStrictEqual", z.deepStrictEqual);
          };
          function W(xe, le, de, De) {
            if (xe === le)
              return !0;
            if (H(xe) && H(le))
              return F(xe, le) === 0;
            if (P.isDate(xe) && P.isDate(le))
              return xe.getTime() === le.getTime();
            if (P.isRegExp(xe) && P.isRegExp(le))
              return xe.source === le.source && xe.global === le.global && xe.multiline === le.multiline && xe.lastIndex === le.lastIndex && xe.ignoreCase === le.ignoreCase;
            if ((xe === null || typeof xe != "object") && (le === null || typeof le != "object"))
              return de ? xe === le : xe == le;
            if (I(xe) && I(le) && m(xe) === m(le) && !(xe instanceof Float32Array || xe instanceof Float64Array))
              return F(
                new Uint8Array(xe.buffer),
                new Uint8Array(le.buffer)
              ) === 0;
            if (H(xe) !== H(le))
              return !1;
            De = De || { actual: [], expected: [] };
            var ze = De.actual.indexOf(xe);
            return ze !== -1 && ze === De.expected.indexOf(le) ? !0 : (De.actual.push(xe), De.expected.push(le), Y(xe, le, de, De));
          }
          function q(xe) {
            return Object.prototype.toString.call(xe) == "[object Arguments]";
          }
          function Y(xe, le, de, De) {
            if (xe == null || le === null || le === void 0)
              return !1;
            if (P.isPrimitive(xe) || P.isPrimitive(le))
              return xe === le;
            if (de && Object.getPrototypeOf(xe) !== Object.getPrototypeOf(le))
              return !1;
            var ze = q(xe), Ze = q(le);
            if (ze && !Ze || !ze && Ze)
              return !1;
            if (ze)
              return xe = E.call(xe), le = E.call(le), W(xe, le, de);
            var Ue = Me(xe), Ie = Me(le), je, Fe;
            if (Ue.length !== Ie.length)
              return !1;
            for (Ue.sort(), Ie.sort(), Fe = Ue.length - 1; Fe >= 0; Fe--)
              if (Ue[Fe] !== Ie[Fe])
                return !1;
            for (Fe = Ue.length - 1; Fe >= 0; Fe--)
              if (je = Ue[Fe], !W(xe[je], le[je], de, De))
                return !1;
            return !0;
          }
          z.notDeepEqual = function(le, de, De) {
            W(le, de, !1) && U(le, de, De, "notDeepEqual", z.notDeepEqual);
          }, z.notDeepStrictEqual = re;
          function re(xe, le, de) {
            W(xe, le, !0) && U(xe, le, de, "notDeepStrictEqual", re);
          }
          z.strictEqual = function(le, de, De) {
            le !== de && U(le, de, De, "===", z.strictEqual);
          }, z.notStrictEqual = function(le, de, De) {
            le === de && U(le, de, De, "!==", z.notStrictEqual);
          };
          function se(xe, le) {
            if (!xe || !le)
              return !1;
            if (Object.prototype.toString.call(le) == "[object RegExp]")
              return le.test(xe);
            try {
              if (xe instanceof le)
                return !0;
            } catch {
            }
            return Error.isPrototypeOf(le) ? !1 : le.call({}, xe) === !0;
          }
          function ve(xe) {
            var le;
            try {
              xe();
            } catch (de) {
              le = de;
            }
            return le;
          }
          function ce(xe, le, de, De) {
            var ze;
            if (typeof le != "function")
              throw new TypeError('"block" argument must be a function');
            typeof de == "string" && (De = de, de = null), ze = ve(le), De = (de && de.name ? " (" + de.name + ")." : ".") + (De ? " " + De : "."), xe && !ze && U(ze, de, "Missing expected exception" + De);
            var Ze = typeof De == "string", Ue = !xe && P.isError(ze), Ie = !xe && ze && !de;
            if ((Ue && Ze && se(ze, de) || Ie) && U(ze, de, "Got unwanted exception" + De), xe && ze && de && !se(ze, de) || !xe && ze)
              throw ze;
          }
          z.throws = function(xe, le, de) {
            ce(!0, xe, le, de);
          }, z.doesNotThrow = function(xe, le, de) {
            ce(!1, xe, le, de);
          }, z.ifError = function(xe) {
            if (xe) throw xe;
          };
          function be(xe, le) {
            xe || U(xe, !0, le, "==", be);
          }
          z.strict = r(be, z, {
            equal: z.strictEqual,
            deepEqual: z.deepStrictEqual,
            notEqual: z.notStrictEqual,
            notDeepEqual: z.notDeepStrictEqual
          }), z.strict.strict = z.strict;
          var Me = Object.keys || function(xe) {
            var le = [];
            for (var de in xe)
              M.call(xe, de) && le.push(de);
            return le;
          };
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {});
      }, { "object-assign": 84, "util/": 28 }], 26: [function(te, Ee, $) {
        typeof Object.create == "function" ? Ee.exports = function(r, F) {
          r.super_ = F, r.prototype = Object.create(F.prototype, {
            constructor: {
              value: r,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : Ee.exports = function(r, F) {
          r.super_ = F;
          var H = function() {
          };
          H.prototype = F.prototype, r.prototype = new H(), r.prototype.constructor = r;
        };
      }, {}], 27: [function(te, Ee, $) {
        Ee.exports = function(r) {
          return r && typeof r == "object" && typeof r.copy == "function" && typeof r.fill == "function" && typeof r.readUInt8 == "function";
        };
      }, {}], 28: [function(te, Ee, $) {
        (function(Q, r) {
          var F = /%[sdj%]/g;
          $.format = function(Ie) {
            if (!Y(Ie)) {
              for (var je = [], Fe = 0; Fe < arguments.length; Fe++)
                je.push(M(arguments[Fe]));
              return je.join(" ");
            }
            for (var Fe = 1, $e = arguments, ct = $e.length, wt = String(Ie).replace(F, function(Ct) {
              if (Ct === "%%") return "%";
              if (Fe >= ct) return Ct;
              switch (Ct) {
                case "%s":
                  return String($e[Fe++]);
                case "%d":
                  return Number($e[Fe++]);
                case "%j":
                  try {
                    return JSON.stringify($e[Fe++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return Ct;
              }
            }), Oe = $e[Fe]; Fe < ct; Oe = $e[++Fe])
              V(Oe) || !ce(Oe) ? wt += " " + Oe : wt += " " + M(Oe);
            return wt;
          }, $.deprecate = function(Ie, je) {
            if (se(r.process))
              return function() {
                return $.deprecate(Ie, je).apply(this, arguments);
              };
            if (Q.noDeprecation === !0)
              return Ie;
            var Fe = !1;
            function $e() {
              if (!Fe) {
                if (Q.throwDeprecation)
                  throw new Error(je);
                Q.traceDeprecation ? console.trace(je) : console.error(je), Fe = !0;
              }
              return Ie.apply(this, arguments);
            }
            return $e;
          };
          var H = {}, P;
          $.debuglog = function(Ie) {
            if (se(P) && (P = Q.env.NODE_DEBUG || ""), Ie = Ie.toUpperCase(), !H[Ie])
              if (new RegExp("\\b" + Ie + "\\b", "i").test(P)) {
                var je = Q.pid;
                H[Ie] = function() {
                  var Fe = $.format.apply($, arguments);
                  console.error("%s %d: %s", Ie, je, Fe);
                };
              } else
                H[Ie] = function() {
                };
            return H[Ie];
          };
          function M(Ie, je) {
            var Fe = {
              seen: [],
              stylize: x
            };
            return arguments.length >= 3 && (Fe.depth = arguments[2]), arguments.length >= 4 && (Fe.colors = arguments[3]), U(je) ? Fe.showHidden = je : je && $._extend(Fe, je), se(Fe.showHidden) && (Fe.showHidden = !1), se(Fe.depth) && (Fe.depth = 2), se(Fe.colors) && (Fe.colors = !1), se(Fe.customInspect) && (Fe.customInspect = !0), Fe.colors && (Fe.stylize = E), I(Fe, Ie, Fe.depth);
          }
          $.inspect = M, M.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, M.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function E(Ie, je) {
            var Fe = M.styles[je];
            return Fe ? "\x1B[" + M.colors[Fe][0] + "m" + Ie + "\x1B[" + M.colors[Fe][1] + "m" : Ie;
          }
          function x(Ie, je) {
            return Ie;
          }
          function m(Ie) {
            var je = {};
            return Ie.forEach(function(Fe, $e) {
              je[Fe] = !0;
            }), je;
          }
          function I(Ie, je, Fe) {
            if (Ie.customInspect && je && xe(je.inspect) && // Filter out the util module, it's inspect function is special
            je.inspect !== $.inspect && // Also filter out any prototype objects using the circular check.
            !(je.constructor && je.constructor.prototype === je)) {
              var $e = je.inspect(Fe, Ie);
              return Y($e) || ($e = I(Ie, $e, Fe)), $e;
            }
            var ct = z(Ie, je);
            if (ct)
              return ct;
            var wt = Object.keys(je), Oe = m(wt);
            if (Ie.showHidden && (wt = Object.getOwnPropertyNames(je)), Me(je) && (wt.indexOf("message") >= 0 || wt.indexOf("description") >= 0))
              return w(je);
            if (wt.length === 0) {
              if (xe(je)) {
                var Ct = je.name ? ": " + je.name : "";
                return Ie.stylize("[Function" + Ct + "]", "special");
              }
              if (ve(je))
                return Ie.stylize(RegExp.prototype.toString.call(je), "regexp");
              if (be(je))
                return Ie.stylize(Date.prototype.toString.call(je), "date");
              if (Me(je))
                return w(je);
            }
            var Xt = "", vt = !1, Ye = ["{", "}"];
            if (N(je) && (vt = !0, Ye = ["[", "]"]), xe(je)) {
              var qe = je.name ? ": " + je.name : "";
              Xt = " [Function" + qe + "]";
            }
            if (ve(je) && (Xt = " " + RegExp.prototype.toString.call(je)), be(je) && (Xt = " " + Date.prototype.toUTCString.call(je)), Me(je) && (Xt = " " + w(je)), wt.length === 0 && (!vt || je.length == 0))
              return Ye[0] + Xt + Ye[1];
            if (Fe < 0)
              return ve(je) ? Ie.stylize(RegExp.prototype.toString.call(je), "regexp") : Ie.stylize("[Object]", "special");
            Ie.seen.push(je);
            var rt;
            return vt ? rt = C(Ie, je, Fe, Oe, wt) : rt = wt.map(function(it) {
              return b(Ie, je, Fe, Oe, it, vt);
            }), Ie.seen.pop(), B(rt, Xt, Ye);
          }
          function z(Ie, je) {
            if (se(je))
              return Ie.stylize("undefined", "undefined");
            if (Y(je)) {
              var Fe = "'" + JSON.stringify(je).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return Ie.stylize(Fe, "string");
            }
            if (q(je))
              return Ie.stylize("" + je, "number");
            if (U(je))
              return Ie.stylize("" + je, "boolean");
            if (V(je))
              return Ie.stylize("null", "null");
          }
          function w(Ie) {
            return "[" + Error.prototype.toString.call(Ie) + "]";
          }
          function C(Ie, je, Fe, $e, ct) {
            for (var wt = [], Oe = 0, Ct = je.length; Oe < Ct; ++Oe)
              Ue(je, String(Oe)) ? wt.push(b(
                Ie,
                je,
                Fe,
                $e,
                String(Oe),
                !0
              )) : wt.push("");
            return ct.forEach(function(Xt) {
              Xt.match(/^\d+$/) || wt.push(b(
                Ie,
                je,
                Fe,
                $e,
                Xt,
                !0
              ));
            }), wt;
          }
          function b(Ie, je, Fe, $e, ct, wt) {
            var Oe, Ct, Xt;
            if (Xt = Object.getOwnPropertyDescriptor(je, ct) || { value: je[ct] }, Xt.get ? Xt.set ? Ct = Ie.stylize("[Getter/Setter]", "special") : Ct = Ie.stylize("[Getter]", "special") : Xt.set && (Ct = Ie.stylize("[Setter]", "special")), Ue($e, ct) || (Oe = "[" + ct + "]"), Ct || (Ie.seen.indexOf(Xt.value) < 0 ? (V(Fe) ? Ct = I(Ie, Xt.value, null) : Ct = I(Ie, Xt.value, Fe - 1), Ct.indexOf(`
`) > -1 && (wt ? Ct = Ct.split(`
`).map(function(vt) {
              return "  " + vt;
            }).join(`
`).substr(2) : Ct = `
` + Ct.split(`
`).map(function(vt) {
              return "   " + vt;
            }).join(`
`))) : Ct = Ie.stylize("[Circular]", "special")), se(Oe)) {
              if (wt && ct.match(/^\d+$/))
                return Ct;
              Oe = JSON.stringify("" + ct), Oe.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Oe = Oe.substr(1, Oe.length - 2), Oe = Ie.stylize(Oe, "name")) : (Oe = Oe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Oe = Ie.stylize(Oe, "string"));
            }
            return Oe + ": " + Ct;
          }
          function B(Ie, je, Fe) {
            var $e = Ie.reduce(function(ct, wt) {
              return wt.indexOf(`
`) >= 0, ct + wt.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return $e > 60 ? Fe[0] + (je === "" ? "" : je + `
 `) + " " + Ie.join(`,
  `) + " " + Fe[1] : Fe[0] + je + " " + Ie.join(", ") + " " + Fe[1];
          }
          function N(Ie) {
            return Array.isArray(Ie);
          }
          $.isArray = N;
          function U(Ie) {
            return typeof Ie == "boolean";
          }
          $.isBoolean = U;
          function V(Ie) {
            return Ie === null;
          }
          $.isNull = V;
          function W(Ie) {
            return Ie == null;
          }
          $.isNullOrUndefined = W;
          function q(Ie) {
            return typeof Ie == "number";
          }
          $.isNumber = q;
          function Y(Ie) {
            return typeof Ie == "string";
          }
          $.isString = Y;
          function re(Ie) {
            return typeof Ie == "symbol";
          }
          $.isSymbol = re;
          function se(Ie) {
            return Ie === void 0;
          }
          $.isUndefined = se;
          function ve(Ie) {
            return ce(Ie) && de(Ie) === "[object RegExp]";
          }
          $.isRegExp = ve;
          function ce(Ie) {
            return typeof Ie == "object" && Ie !== null;
          }
          $.isObject = ce;
          function be(Ie) {
            return ce(Ie) && de(Ie) === "[object Date]";
          }
          $.isDate = be;
          function Me(Ie) {
            return ce(Ie) && (de(Ie) === "[object Error]" || Ie instanceof Error);
          }
          $.isError = Me;
          function xe(Ie) {
            return typeof Ie == "function";
          }
          $.isFunction = xe;
          function le(Ie) {
            return Ie === null || typeof Ie == "boolean" || typeof Ie == "number" || typeof Ie == "string" || typeof Ie == "symbol" || // ES6 symbol
            typeof Ie > "u";
          }
          $.isPrimitive = le, $.isBuffer = te("./support/isBuffer");
          function de(Ie) {
            return Object.prototype.toString.call(Ie);
          }
          function De(Ie) {
            return Ie < 10 ? "0" + Ie.toString(10) : Ie.toString(10);
          }
          var ze = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function Ze() {
            var Ie = /* @__PURE__ */ new Date(), je = [
              De(Ie.getHours()),
              De(Ie.getMinutes()),
              De(Ie.getSeconds())
            ].join(":");
            return [Ie.getDate(), ze[Ie.getMonth()], je].join(" ");
          }
          $.log = function() {
            console.log("%s - %s", Ze(), $.format.apply($, arguments));
          }, $.inherits = te("inherits"), $._extend = function(Ie, je) {
            if (!je || !ce(je)) return Ie;
            for (var Fe = Object.keys(je), $e = Fe.length; $e--; )
              Ie[Fe[$e]] = je[Fe[$e]];
            return Ie;
          };
          function Ue(Ie, je) {
            return Object.prototype.hasOwnProperty.call(Ie, je);
          }
        }).call(this, te("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {});
      }, { "./support/isBuffer": 27, _process: 133, inherits: 26 }], 29: [function(te, Ee, $) {
        $.byteLength = x, $.toByteArray = I, $.fromByteArray = C;
        for (var Q = [], r = [], F = typeof Uint8Array < "u" ? Uint8Array : Array, H = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", P = 0, M = H.length; P < M; ++P)
          Q[P] = H[P], r[H.charCodeAt(P)] = P;
        r[45] = 62, r[95] = 63;
        function E(b) {
          var B = b.length;
          if (B % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var N = b.indexOf("=");
          N === -1 && (N = B);
          var U = N === B ? 0 : 4 - N % 4;
          return [N, U];
        }
        function x(b) {
          var B = E(b), N = B[0], U = B[1];
          return (N + U) * 3 / 4 - U;
        }
        function m(b, B, N) {
          return (B + N) * 3 / 4 - N;
        }
        function I(b) {
          var B, N = E(b), U = N[0], V = N[1], W = new F(m(b, U, V)), q = 0, Y = V > 0 ? U - 4 : U, re;
          for (re = 0; re < Y; re += 4)
            B = r[b.charCodeAt(re)] << 18 | r[b.charCodeAt(re + 1)] << 12 | r[b.charCodeAt(re + 2)] << 6 | r[b.charCodeAt(re + 3)], W[q++] = B >> 16 & 255, W[q++] = B >> 8 & 255, W[q++] = B & 255;
          return V === 2 && (B = r[b.charCodeAt(re)] << 2 | r[b.charCodeAt(re + 1)] >> 4, W[q++] = B & 255), V === 1 && (B = r[b.charCodeAt(re)] << 10 | r[b.charCodeAt(re + 1)] << 4 | r[b.charCodeAt(re + 2)] >> 2, W[q++] = B >> 8 & 255, W[q++] = B & 255), W;
        }
        function z(b) {
          return Q[b >> 18 & 63] + Q[b >> 12 & 63] + Q[b >> 6 & 63] + Q[b & 63];
        }
        function w(b, B, N) {
          for (var U, V = [], W = B; W < N; W += 3)
            U = (b[W] << 16 & 16711680) + (b[W + 1] << 8 & 65280) + (b[W + 2] & 255), V.push(z(U));
          return V.join("");
        }
        function C(b) {
          for (var B, N = b.length, U = N % 3, V = [], W = 16383, q = 0, Y = N - U; q < Y; q += W)
            V.push(w(
              b,
              q,
              q + W > Y ? Y : q + W
            ));
          return U === 1 ? (B = b[N - 1], V.push(
            Q[B >> 2] + Q[B << 4 & 63] + "=="
          )) : U === 2 && (B = (b[N - 2] << 8) + b[N - 1], V.push(
            Q[B >> 10] + Q[B >> 4 & 63] + Q[B << 2 & 63] + "="
          )), V.join("");
        }
      }, {}], 30: [function(te, Ee, $) {
        var Q = te("./lib/encoder"), r = te("./lib/decoder");
        Ee.exports = {
          encode: Q,
          decode: r
        };
      }, { "./lib/decoder": 31, "./lib/encoder": 32 }], 31: [function(te, Ee, $) {
        (function(Q) {
          function r(F, H) {
            if (this.pos = 0, this.buffer = F, this.is_with_alpha = !!H, this.bottom_up = !0, this.flag = this.buffer.toString("utf-8", 0, this.pos += 2), this.flag != "BM") throw new Error("Invalid BMP File");
            this.parseHeader(), this.parseRGBA();
          }
          r.prototype.parseHeader = function() {
            if (this.fileSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.reserved = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.offset = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.headerSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.width = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.height = this.buffer.readInt32LE(this.pos), this.pos += 4, this.planes = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.bitPP = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.compress = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.rawSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.hr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.vr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.colors = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.importantColors = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
              var F = this.colors === 0 ? 1 << this.bitPP : this.colors;
              this.palette = new Array(F);
              for (var H = 0; H < F; H++) {
                var P = this.buffer.readUInt8(this.pos++), M = this.buffer.readUInt8(this.pos++), E = this.buffer.readUInt8(this.pos++), x = this.buffer.readUInt8(this.pos++);
                this.palette[H] = {
                  red: E,
                  green: M,
                  blue: P,
                  quad: x
                };
              }
            }
            this.height < 0 && (this.height *= -1, this.bottom_up = !1);
          }, r.prototype.parseRGBA = function() {
            var F = "bit" + this.bitPP, H = this.width * this.height * 4;
            this.data = new Q(H), this[F]();
          }, r.prototype.bit1 = function() {
            for (var F = Math.ceil(this.width / 8), H = F % 4, P = this.height >= 0 ? this.height - 1 : -this.height, P = this.height - 1; P >= 0; P--) {
              for (var M = this.bottom_up ? P : this.height - 1 - P, E = 0; E < F; E++)
                for (var x = this.buffer.readUInt8(this.pos++), m = M * this.width * 4 + E * 8 * 4, I = 0; I < 8 && E * 8 + I < this.width; I++) {
                  var z = this.palette[x >> 7 - I & 1];
                  this.data[m + I * 4] = 0, this.data[m + I * 4 + 1] = z.blue, this.data[m + I * 4 + 2] = z.green, this.data[m + I * 4 + 3] = z.red;
                }
              H != 0 && (this.pos += 4 - H);
            }
          }, r.prototype.bit4 = function() {
            if (this.compress == 2) {
              let V = function(W) {
                var q = this.palette[W];
                this.data[F] = 0, this.data[F + 1] = q.blue, this.data[F + 2] = q.green, this.data[F + 3] = q.red, F += 4;
              };
              this.data.fill(255);
              for (var F = 0, H = this.bottom_up ? this.height - 1 : 0, P = !1; F < this.data.length; ) {
                var M = this.buffer.readUInt8(this.pos++), E = this.buffer.readUInt8(this.pos++);
                if (M == 0)
                  if (E == 0) {
                    this.bottom_up ? H-- : H++, F = H * this.width * 4, P = !1;
                    continue;
                  } else {
                    if (E == 1)
                      break;
                    if (E == 2) {
                      var x = this.buffer.readUInt8(this.pos++), m = this.buffer.readUInt8(this.pos++);
                      this.bottom_up ? H -= m : H += m, F += m * this.width * 4 + x * 4;
                    } else {
                      for (var I = this.buffer.readUInt8(this.pos++), z = 0; z < E; z++)
                        P ? V.call(this, I & 15) : V.call(this, (I & 240) >> 4), z & 1 && z + 1 < E && (I = this.buffer.readUInt8(this.pos++)), P = !P;
                      (E + 1 >> 1 & 1) == 1 && this.pos++;
                    }
                  }
                else
                  for (var z = 0; z < M; z++)
                    P ? V.call(this, E & 15) : V.call(this, (E & 240) >> 4), P = !P;
              }
            } else
              for (var w = Math.ceil(this.width / 2), C = w % 4, m = this.height - 1; m >= 0; m--) {
                for (var b = this.bottom_up ? m : this.height - 1 - m, x = 0; x < w; x++) {
                  var E = this.buffer.readUInt8(this.pos++), F = b * this.width * 4 + x * 2 * 4, B = E >> 4, N = E & 15, U = this.palette[B];
                  if (this.data[F] = 0, this.data[F + 1] = U.blue, this.data[F + 2] = U.green, this.data[F + 3] = U.red, x * 2 + 1 >= this.width) break;
                  U = this.palette[N], this.data[F + 4] = 0, this.data[F + 4 + 1] = U.blue, this.data[F + 4 + 2] = U.green, this.data[F + 4 + 3] = U.red;
                }
                C != 0 && (this.pos += 4 - C);
              }
          }, r.prototype.bit8 = function() {
            if (this.compress == 1) {
              let b = function(B) {
                var N = this.palette[B];
                this.data[F] = 0, this.data[F + 1] = N.blue, this.data[F + 2] = N.green, this.data[F + 3] = N.red, F += 4;
              };
              this.data.fill(255);
              for (var F = 0, H = this.bottom_up ? this.height - 1 : 0; F < this.data.length; ) {
                var P = this.buffer.readUInt8(this.pos++), M = this.buffer.readUInt8(this.pos++);
                if (P == 0)
                  if (M == 0) {
                    this.bottom_up ? H-- : H++, F = H * this.width * 4;
                    continue;
                  } else {
                    if (M == 1)
                      break;
                    if (M == 2) {
                      var E = this.buffer.readUInt8(this.pos++), x = this.buffer.readUInt8(this.pos++);
                      this.bottom_up ? H -= x : H += x, F += x * this.width * 4 + E * 4;
                    } else {
                      for (var m = 0; m < M; m++) {
                        var I = this.buffer.readUInt8(this.pos++);
                        b.call(this, I);
                      }
                      M & !0 && this.pos++;
                    }
                  }
                else
                  for (var m = 0; m < P; m++)
                    b.call(this, M);
              }
            } else
              for (var z = this.width % 4, x = this.height - 1; x >= 0; x--) {
                for (var w = this.bottom_up ? x : this.height - 1 - x, E = 0; E < this.width; E++) {
                  var M = this.buffer.readUInt8(this.pos++), F = w * this.width * 4 + E * 4;
                  if (M < this.palette.length) {
                    var C = this.palette[M];
                    this.data[F] = 0, this.data[F + 1] = C.blue, this.data[F + 2] = C.green, this.data[F + 3] = C.red;
                  } else
                    this.data[F] = 0, this.data[F + 1] = 255, this.data[F + 2] = 255, this.data[F + 3] = 255;
                }
                z != 0 && (this.pos += 4 - z);
              }
          }, r.prototype.bit15 = function() {
            for (var F = this.width % 3, H = parseInt("11111", 2), P = H, M = this.height - 1; M >= 0; M--) {
              for (var E = this.bottom_up ? M : this.height - 1 - M, x = 0; x < this.width; x++) {
                var m = this.buffer.readUInt16LE(this.pos);
                this.pos += 2;
                var I = (m & P) / P * 255 | 0, z = (m >> 5 & P) / P * 255 | 0, w = (m >> 10 & P) / P * 255 | 0, C = m >> 15 ? 255 : 0, b = E * this.width * 4 + x * 4;
                this.data[b] = C, this.data[b + 1] = I, this.data[b + 2] = z, this.data[b + 3] = w;
              }
              this.pos += F;
            }
          }, r.prototype.bit16 = function() {
            var F = this.width % 2 * 2;
            this.maskRed = 31744, this.maskGreen = 992, this.maskBlue = 31, this.mask0 = 0, this.compress == 3 && (this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4);
            for (var H = [0, 0, 0], P = 0; P < 16; P++)
              this.maskRed >> P & 1 && H[0]++, this.maskGreen >> P & 1 && H[1]++, this.maskBlue >> P & 1 && H[2]++;
            H[1] += H[0], H[2] += H[1], H[0] = 8 - H[0], H[1] -= 8, H[2] -= 8;
            for (var M = this.height - 1; M >= 0; M--) {
              for (var E = this.bottom_up ? M : this.height - 1 - M, x = 0; x < this.width; x++) {
                var m = this.buffer.readUInt16LE(this.pos);
                this.pos += 2;
                var I = (m & this.maskBlue) << H[0], z = (m & this.maskGreen) >> H[1], w = (m & this.maskRed) >> H[2], C = E * this.width * 4 + x * 4;
                this.data[C] = 0, this.data[C + 1] = I, this.data[C + 2] = z, this.data[C + 3] = w;
              }
              this.pos += F;
            }
          }, r.prototype.bit24 = function() {
            for (var F = this.height - 1; F >= 0; F--) {
              for (var H = this.bottom_up ? F : this.height - 1 - F, P = 0; P < this.width; P++) {
                var M = this.buffer.readUInt8(this.pos++), E = this.buffer.readUInt8(this.pos++), x = this.buffer.readUInt8(this.pos++), m = H * this.width * 4 + P * 4;
                this.data[m] = 0, this.data[m + 1] = M, this.data[m + 2] = E, this.data[m + 3] = x;
              }
              this.pos += this.width % 4;
            }
          }, r.prototype.bit32 = function() {
            if (this.compress == 3) {
              this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4;
              for (var F = this.height - 1; F >= 0; F--)
                for (var H = this.bottom_up ? F : this.height - 1 - F, P = 0; P < this.width; P++) {
                  var M = this.buffer.readUInt8(this.pos++), E = this.buffer.readUInt8(this.pos++), x = this.buffer.readUInt8(this.pos++), m = this.buffer.readUInt8(this.pos++), I = H * this.width * 4 + P * 4;
                  this.data[I] = M, this.data[I + 1] = E, this.data[I + 2] = x, this.data[I + 3] = m;
                }
            } else
              for (var F = this.height - 1; F >= 0; F--)
                for (var H = this.bottom_up ? F : this.height - 1 - F, P = 0; P < this.width; P++) {
                  var E = this.buffer.readUInt8(this.pos++), x = this.buffer.readUInt8(this.pos++), m = this.buffer.readUInt8(this.pos++), M = this.buffer.readUInt8(this.pos++), I = H * this.width * 4 + P * 4;
                  this.data[I] = M, this.data[I + 1] = E, this.data[I + 2] = x, this.data[I + 3] = m;
                }
          }, r.prototype.getData = function() {
            return this.data;
          }, Ee.exports = function(F) {
            var H = new r(F);
            return H;
          };
        }).call(this, te("buffer").Buffer);
      }, { buffer: 48 }], 32: [function(te, Ee, $) {
        (function(Q) {
          function r(F) {
            this.buffer = F.data, this.width = F.width, this.height = F.height, this.extraBytes = this.width % 4, this.rgbSize = this.height * (3 * this.width + this.extraBytes), this.headerInfoSize = 40, this.data = [], this.flag = "BM", this.reserved = 0, this.offset = 54, this.fileSize = this.rgbSize + this.offset, this.planes = 1, this.bitPP = 24, this.compress = 0, this.hr = 0, this.vr = 0, this.colors = 0, this.importantColors = 0;
          }
          r.prototype.encode = function() {
            var F = new Q(this.offset + this.rgbSize);
            this.pos = 0, F.write(this.flag, this.pos, 2), this.pos += 2, F.writeUInt32LE(this.fileSize, this.pos), this.pos += 4, F.writeUInt32LE(this.reserved, this.pos), this.pos += 4, F.writeUInt32LE(this.offset, this.pos), this.pos += 4, F.writeUInt32LE(this.headerInfoSize, this.pos), this.pos += 4, F.writeUInt32LE(this.width, this.pos), this.pos += 4, F.writeInt32LE(-this.height, this.pos), this.pos += 4, F.writeUInt16LE(this.planes, this.pos), this.pos += 2, F.writeUInt16LE(this.bitPP, this.pos), this.pos += 2, F.writeUInt32LE(this.compress, this.pos), this.pos += 4, F.writeUInt32LE(this.rgbSize, this.pos), this.pos += 4, F.writeUInt32LE(this.hr, this.pos), this.pos += 4, F.writeUInt32LE(this.vr, this.pos), this.pos += 4, F.writeUInt32LE(this.colors, this.pos), this.pos += 4, F.writeUInt32LE(this.importantColors, this.pos), this.pos += 4;
            for (var H = 0, P = 3 * this.width + this.extraBytes, M = 0; M < this.height; M++) {
              for (var E = 0; E < this.width; E++) {
                var x = this.pos + M * P + E * 3;
                H++, F[x] = this.buffer[H++], F[x + 1] = this.buffer[H++], F[x + 2] = this.buffer[H++];
              }
              if (this.extraBytes > 0) {
                var m = this.pos + M * P + this.width * 3;
                F.fill(0, m, m + this.extraBytes);
              }
            }
            return F;
          }, Ee.exports = function(F, H) {
            var P = new r(F), M = P.encode();
            return {
              data: M,
              width: F.width,
              height: F.height
            };
          };
        }).call(this, te("buffer").Buffer);
      }, { buffer: 48 }], 33: [function(te, Ee, $) {
      }, {}], 34: [function(te, Ee, $) {
        (function(Q, r) {
          var F = te("assert"), H = te("pako/lib/zlib/zstream"), P = te("pako/lib/zlib/deflate.js"), M = te("pako/lib/zlib/inflate.js"), E = te("pako/lib/zlib/constants");
          for (var x in E)
            $[x] = E[x];
          $.NONE = 0, $.DEFLATE = 1, $.INFLATE = 2, $.GZIP = 3, $.GUNZIP = 4, $.DEFLATERAW = 5, $.INFLATERAW = 6, $.UNZIP = 7;
          var m = 31, I = 139;
          function z(w) {
            if (typeof w != "number" || w < $.DEFLATE || w > $.UNZIP)
              throw new TypeError("Bad argument");
            this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = w, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
          }
          z.prototype.close = function() {
            if (this.write_in_progress) {
              this.pending_close = !0;
              return;
            }
            this.pending_close = !1, F(this.init_done, "close before init"), F(this.mode <= $.UNZIP), this.mode === $.DEFLATE || this.mode === $.GZIP || this.mode === $.DEFLATERAW ? P.deflateEnd(this.strm) : (this.mode === $.INFLATE || this.mode === $.GUNZIP || this.mode === $.INFLATERAW || this.mode === $.UNZIP) && M.inflateEnd(this.strm), this.mode = $.NONE, this.dictionary = null;
          }, z.prototype.write = function(w, C, b, B, N, U, V) {
            return this._write(!0, w, C, b, B, N, U, V);
          }, z.prototype.writeSync = function(w, C, b, B, N, U, V) {
            return this._write(!1, w, C, b, B, N, U, V);
          }, z.prototype._write = function(w, C, b, B, N, U, V, W) {
            if (F.equal(arguments.length, 8), F(this.init_done, "write before init"), F(this.mode !== $.NONE, "already finalized"), F.equal(!1, this.write_in_progress, "write already in progress"), F.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, F.equal(!1, C === void 0, "must provide flush value"), this.write_in_progress = !0, C !== $.Z_NO_FLUSH && C !== $.Z_PARTIAL_FLUSH && C !== $.Z_SYNC_FLUSH && C !== $.Z_FULL_FLUSH && C !== $.Z_FINISH && C !== $.Z_BLOCK)
              throw new Error("Invalid flush value");
            if (b == null && (b = r.alloc(0), N = 0, B = 0), this.strm.avail_in = N, this.strm.input = b, this.strm.next_in = B, this.strm.avail_out = W, this.strm.output = U, this.strm.next_out = V, this.flush = C, !w)
              return this._process(), this._checkError() ? this._afterSync() : void 0;
            var q = this;
            return Q.nextTick(function() {
              q._process(), q._after();
            }), this;
          }, z.prototype._afterSync = function() {
            var w = this.strm.avail_out, C = this.strm.avail_in;
            return this.write_in_progress = !1, [C, w];
          }, z.prototype._process = function() {
            var w = null;
            switch (this.mode) {
              case $.DEFLATE:
              case $.GZIP:
              case $.DEFLATERAW:
                this.err = P.deflate(this.strm, this.flush);
                break;
              case $.UNZIP:
                switch (this.strm.avail_in > 0 && (w = this.strm.next_in), this.gzip_id_bytes_read) {
                  case 0:
                    if (w === null)
                      break;
                    if (this.strm.input[w] === m) {
                      if (this.gzip_id_bytes_read = 1, w++, this.strm.avail_in === 1)
                        break;
                    } else {
                      this.mode = $.INFLATE;
                      break;
                    }
                  // fallthrough
                  case 1:
                    if (w === null)
                      break;
                    this.strm.input[w] === I ? (this.gzip_id_bytes_read = 2, this.mode = $.GUNZIP) : this.mode = $.INFLATE;
                    break;
                  default:
                    throw new Error("invalid number of gzip magic number bytes read");
                }
              // fallthrough
              case $.INFLATE:
              case $.GUNZIP:
              case $.INFLATERAW:
                for (this.err = M.inflate(
                  this.strm,
                  this.flush
                  // If data was encoded with dictionary
                ), this.err === $.Z_NEED_DICT && this.dictionary && (this.err = M.inflateSetDictionary(this.strm, this.dictionary), this.err === $.Z_OK ? this.err = M.inflate(this.strm, this.flush) : this.err === $.Z_DATA_ERROR && (this.err = $.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === $.GUNZIP && this.err === $.Z_STREAM_END && this.strm.next_in[0] !== 0; )
                  this.reset(), this.err = M.inflate(this.strm, this.flush);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
          }, z.prototype._checkError = function() {
            switch (this.err) {
              case $.Z_OK:
              case $.Z_BUF_ERROR:
                if (this.strm.avail_out !== 0 && this.flush === $.Z_FINISH)
                  return this._error("unexpected end of file"), !1;
                break;
              case $.Z_STREAM_END:
                break;
              case $.Z_NEED_DICT:
                return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
              default:
                return this._error("Zlib error"), !1;
            }
            return !0;
          }, z.prototype._after = function() {
            if (this._checkError()) {
              var w = this.strm.avail_out, C = this.strm.avail_in;
              this.write_in_progress = !1, this.callback(C, w), this.pending_close && this.close();
            }
          }, z.prototype._error = function(w) {
            this.strm.msg && (w = this.strm.msg), this.onerror(
              w,
              this.err
              // no hope of rescue.
            ), this.write_in_progress = !1, this.pending_close && this.close();
          }, z.prototype.init = function(w, C, b, B, N) {
            F(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), F(w >= 8 && w <= 15, "invalid windowBits"), F(C >= -1 && C <= 9, "invalid compression level"), F(b >= 1 && b <= 9, "invalid memlevel"), F(B === $.Z_FILTERED || B === $.Z_HUFFMAN_ONLY || B === $.Z_RLE || B === $.Z_FIXED || B === $.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(C, w, b, B, N), this._setDictionary();
          }, z.prototype.params = function() {
            throw new Error("deflateParams Not supported");
          }, z.prototype.reset = function() {
            this._reset(), this._setDictionary();
          }, z.prototype._init = function(w, C, b, B, N) {
            switch (this.level = w, this.windowBits = C, this.memLevel = b, this.strategy = B, this.flush = $.Z_NO_FLUSH, this.err = $.Z_OK, (this.mode === $.GZIP || this.mode === $.GUNZIP) && (this.windowBits += 16), this.mode === $.UNZIP && (this.windowBits += 32), (this.mode === $.DEFLATERAW || this.mode === $.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new H(), this.mode) {
              case $.DEFLATE:
              case $.GZIP:
              case $.DEFLATERAW:
                this.err = P.deflateInit2(this.strm, this.level, $.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                break;
              case $.INFLATE:
              case $.GUNZIP:
              case $.INFLATERAW:
              case $.UNZIP:
                this.err = M.inflateInit2(this.strm, this.windowBits);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
            this.err !== $.Z_OK && this._error("Init error"), this.dictionary = N, this.write_in_progress = !1, this.init_done = !0;
          }, z.prototype._setDictionary = function() {
            if (this.dictionary != null) {
              switch (this.err = $.Z_OK, this.mode) {
                case $.DEFLATE:
                case $.DEFLATERAW:
                  this.err = P.deflateSetDictionary(this.strm, this.dictionary);
                  break;
              }
              this.err !== $.Z_OK && this._error("Failed to set dictionary");
            }
          }, z.prototype._reset = function() {
            switch (this.err = $.Z_OK, this.mode) {
              case $.DEFLATE:
              case $.DEFLATERAW:
              case $.GZIP:
                this.err = P.deflateReset(this.strm);
                break;
              case $.INFLATE:
              case $.INFLATERAW:
              case $.GUNZIP:
                this.err = M.inflateReset(this.strm);
                break;
            }
            this.err !== $.Z_OK && this._error("Failed to reset stream");
          }, $.Zlib = z;
        }).call(this, te("_process"), te("buffer").Buffer);
      }, { _process: 133, assert: 25, buffer: 48, "pako/lib/zlib/constants": 38, "pako/lib/zlib/deflate.js": 40, "pako/lib/zlib/inflate.js": 42, "pako/lib/zlib/zstream": 46 }], 35: [function(te, Ee, $) {
        (function(Q) {
          var r = te("buffer").Buffer, F = te("stream").Transform, H = te("./binding"), P = te("util"), M = te("assert").ok, E = te("buffer").kMaxLength, x = "Cannot create final Buffer. It would be larger than 0x" + E.toString(16) + " bytes";
          H.Z_MIN_WINDOWBITS = 8, H.Z_MAX_WINDOWBITS = 15, H.Z_DEFAULT_WINDOWBITS = 15, H.Z_MIN_CHUNK = 64, H.Z_MAX_CHUNK = 1 / 0, H.Z_DEFAULT_CHUNK = 16 * 1024, H.Z_MIN_MEMLEVEL = 1, H.Z_MAX_MEMLEVEL = 9, H.Z_DEFAULT_MEMLEVEL = 8, H.Z_MIN_LEVEL = -1, H.Z_MAX_LEVEL = 9, H.Z_DEFAULT_LEVEL = H.Z_DEFAULT_COMPRESSION;
          for (var m = Object.keys(H), I = 0; I < m.length; I++) {
            var z = m[I];
            z.match(/^Z/) && Object.defineProperty($, z, {
              enumerable: !0,
              value: H[z],
              writable: !1
            });
          }
          for (var w = {
            Z_OK: H.Z_OK,
            Z_STREAM_END: H.Z_STREAM_END,
            Z_NEED_DICT: H.Z_NEED_DICT,
            Z_ERRNO: H.Z_ERRNO,
            Z_STREAM_ERROR: H.Z_STREAM_ERROR,
            Z_DATA_ERROR: H.Z_DATA_ERROR,
            Z_MEM_ERROR: H.Z_MEM_ERROR,
            Z_BUF_ERROR: H.Z_BUF_ERROR,
            Z_VERSION_ERROR: H.Z_VERSION_ERROR
          }, C = Object.keys(w), b = 0; b < C.length; b++) {
            var B = C[b];
            w[w[B]] = B;
          }
          Object.defineProperty($, "codes", {
            enumerable: !0,
            value: Object.freeze(w),
            writable: !1
          }), $.Deflate = V, $.Inflate = W, $.Gzip = q, $.Gunzip = Y, $.DeflateRaw = re, $.InflateRaw = se, $.Unzip = ve, $.createDeflate = function(le) {
            return new V(le);
          }, $.createInflate = function(le) {
            return new W(le);
          }, $.createDeflateRaw = function(le) {
            return new re(le);
          }, $.createInflateRaw = function(le) {
            return new se(le);
          }, $.createGzip = function(le) {
            return new q(le);
          }, $.createGunzip = function(le) {
            return new Y(le);
          }, $.createUnzip = function(le) {
            return new ve(le);
          }, $.deflate = function(le, de, De) {
            return typeof de == "function" && (De = de, de = {}), N(new V(de), le, De);
          }, $.deflateSync = function(le, de) {
            return U(new V(de), le);
          }, $.gzip = function(le, de, De) {
            return typeof de == "function" && (De = de, de = {}), N(new q(de), le, De);
          }, $.gzipSync = function(le, de) {
            return U(new q(de), le);
          }, $.deflateRaw = function(le, de, De) {
            return typeof de == "function" && (De = de, de = {}), N(new re(de), le, De);
          }, $.deflateRawSync = function(le, de) {
            return U(new re(de), le);
          }, $.unzip = function(le, de, De) {
            return typeof de == "function" && (De = de, de = {}), N(new ve(de), le, De);
          }, $.unzipSync = function(le, de) {
            return U(new ve(de), le);
          }, $.inflate = function(le, de, De) {
            return typeof de == "function" && (De = de, de = {}), N(new W(de), le, De);
          }, $.inflateSync = function(le, de) {
            return U(new W(de), le);
          }, $.gunzip = function(le, de, De) {
            return typeof de == "function" && (De = de, de = {}), N(new Y(de), le, De);
          }, $.gunzipSync = function(le, de) {
            return U(new Y(de), le);
          }, $.inflateRaw = function(le, de, De) {
            return typeof de == "function" && (De = de, de = {}), N(new se(de), le, De);
          }, $.inflateRawSync = function(le, de) {
            return U(new se(de), le);
          };
          function N(le, de, De) {
            var ze = [], Ze = 0;
            le.on("error", Ie), le.on("end", je), le.end(de), Ue();
            function Ue() {
              for (var Fe; (Fe = le.read()) !== null; )
                ze.push(Fe), Ze += Fe.length;
              le.once("readable", Ue);
            }
            function Ie(Fe) {
              le.removeListener("end", je), le.removeListener("readable", Ue), De(Fe);
            }
            function je() {
              var Fe, $e = null;
              Ze >= E ? $e = new RangeError(x) : Fe = r.concat(ze, Ze), ze = [], le.close(), De($e, Fe);
            }
          }
          function U(le, de) {
            if (typeof de == "string" && (de = r.from(de)), !r.isBuffer(de)) throw new TypeError("Not a string or buffer");
            var De = le._finishFlushFlag;
            return le._processChunk(de, De);
          }
          function V(le) {
            if (!(this instanceof V)) return new V(le);
            be.call(this, le, H.DEFLATE);
          }
          function W(le) {
            if (!(this instanceof W)) return new W(le);
            be.call(this, le, H.INFLATE);
          }
          function q(le) {
            if (!(this instanceof q)) return new q(le);
            be.call(this, le, H.GZIP);
          }
          function Y(le) {
            if (!(this instanceof Y)) return new Y(le);
            be.call(this, le, H.GUNZIP);
          }
          function re(le) {
            if (!(this instanceof re)) return new re(le);
            be.call(this, le, H.DEFLATERAW);
          }
          function se(le) {
            if (!(this instanceof se)) return new se(le);
            be.call(this, le, H.INFLATERAW);
          }
          function ve(le) {
            if (!(this instanceof ve)) return new ve(le);
            be.call(this, le, H.UNZIP);
          }
          function ce(le) {
            return le === H.Z_NO_FLUSH || le === H.Z_PARTIAL_FLUSH || le === H.Z_SYNC_FLUSH || le === H.Z_FULL_FLUSH || le === H.Z_FINISH || le === H.Z_BLOCK;
          }
          function be(le, de) {
            var De = this;
            if (this._opts = le = le || {}, this._chunkSize = le.chunkSize || $.Z_DEFAULT_CHUNK, F.call(this, le), le.flush && !ce(le.flush))
              throw new Error("Invalid flush flag: " + le.flush);
            if (le.finishFlush && !ce(le.finishFlush))
              throw new Error("Invalid flush flag: " + le.finishFlush);
            if (this._flushFlag = le.flush || H.Z_NO_FLUSH, this._finishFlushFlag = typeof le.finishFlush < "u" ? le.finishFlush : H.Z_FINISH, le.chunkSize && (le.chunkSize < $.Z_MIN_CHUNK || le.chunkSize > $.Z_MAX_CHUNK))
              throw new Error("Invalid chunk size: " + le.chunkSize);
            if (le.windowBits && (le.windowBits < $.Z_MIN_WINDOWBITS || le.windowBits > $.Z_MAX_WINDOWBITS))
              throw new Error("Invalid windowBits: " + le.windowBits);
            if (le.level && (le.level < $.Z_MIN_LEVEL || le.level > $.Z_MAX_LEVEL))
              throw new Error("Invalid compression level: " + le.level);
            if (le.memLevel && (le.memLevel < $.Z_MIN_MEMLEVEL || le.memLevel > $.Z_MAX_MEMLEVEL))
              throw new Error("Invalid memLevel: " + le.memLevel);
            if (le.strategy && le.strategy != $.Z_FILTERED && le.strategy != $.Z_HUFFMAN_ONLY && le.strategy != $.Z_RLE && le.strategy != $.Z_FIXED && le.strategy != $.Z_DEFAULT_STRATEGY)
              throw new Error("Invalid strategy: " + le.strategy);
            if (le.dictionary && !r.isBuffer(le.dictionary))
              throw new Error("Invalid dictionary: it should be a Buffer instance");
            this._handle = new H.Zlib(de);
            var ze = this;
            this._hadError = !1, this._handle.onerror = function(Ie, je) {
              Me(ze), ze._hadError = !0;
              var Fe = new Error(Ie);
              Fe.errno = je, Fe.code = $.codes[je], ze.emit("error", Fe);
            };
            var Ze = $.Z_DEFAULT_COMPRESSION;
            typeof le.level == "number" && (Ze = le.level);
            var Ue = $.Z_DEFAULT_STRATEGY;
            typeof le.strategy == "number" && (Ue = le.strategy), this._handle.init(le.windowBits || $.Z_DEFAULT_WINDOWBITS, Ze, le.memLevel || $.Z_DEFAULT_MEMLEVEL, Ue, le.dictionary), this._buffer = r.allocUnsafe(this._chunkSize), this._offset = 0, this._level = Ze, this._strategy = Ue, this.once("end", this.close), Object.defineProperty(this, "_closed", {
              get: function() {
                return !De._handle;
              },
              configurable: !0,
              enumerable: !0
            });
          }
          P.inherits(be, F), be.prototype.params = function(le, de, De) {
            if (le < $.Z_MIN_LEVEL || le > $.Z_MAX_LEVEL)
              throw new RangeError("Invalid compression level: " + le);
            if (de != $.Z_FILTERED && de != $.Z_HUFFMAN_ONLY && de != $.Z_RLE && de != $.Z_FIXED && de != $.Z_DEFAULT_STRATEGY)
              throw new TypeError("Invalid strategy: " + de);
            if (this._level !== le || this._strategy !== de) {
              var ze = this;
              this.flush(H.Z_SYNC_FLUSH, function() {
                M(ze._handle, "zlib binding closed"), ze._handle.params(le, de), ze._hadError || (ze._level = le, ze._strategy = de, De && De());
              });
            } else
              Q.nextTick(De);
          }, be.prototype.reset = function() {
            return M(this._handle, "zlib binding closed"), this._handle.reset();
          }, be.prototype._flush = function(le) {
            this._transform(r.alloc(0), "", le);
          }, be.prototype.flush = function(le, de) {
            var De = this, ze = this._writableState;
            (typeof le == "function" || le === void 0 && !de) && (de = le, le = H.Z_FULL_FLUSH), ze.ended ? de && Q.nextTick(de) : ze.ending ? de && this.once("end", de) : ze.needDrain ? de && this.once("drain", function() {
              return De.flush(le, de);
            }) : (this._flushFlag = le, this.write(r.alloc(0), "", de));
          }, be.prototype.close = function(le) {
            Me(this, le), Q.nextTick(xe, this);
          };
          function Me(le, de) {
            de && Q.nextTick(de), le._handle && (le._handle.close(), le._handle = null);
          }
          function xe(le) {
            le.emit("close");
          }
          be.prototype._transform = function(le, de, De) {
            var ze, Ze = this._writableState, Ue = Ze.ending || Ze.ended, Ie = Ue && (!le || Ze.length === le.length);
            if (le !== null && !r.isBuffer(le)) return De(new Error("invalid input"));
            if (!this._handle) return De(new Error("zlib binding closed"));
            Ie ? ze = this._finishFlushFlag : (ze = this._flushFlag, le.length >= Ze.length && (this._flushFlag = this._opts.flush || H.Z_NO_FLUSH)), this._processChunk(le, ze, De);
          }, be.prototype._processChunk = function(le, de, De) {
            var ze = le && le.length, Ze = this._chunkSize - this._offset, Ue = 0, Ie = this, je = typeof De == "function";
            if (!je) {
              var Fe = [], $e = 0, ct;
              this.on("error", function(vt) {
                ct = vt;
              }), M(this._handle, "zlib binding closed");
              do
                var wt = this._handle.writeSync(
                  de,
                  le,
                  // in
                  Ue,
                  // in_off
                  ze,
                  // in_len
                  this._buffer,
                  // out
                  this._offset,
                  //out_off
                  Ze
                );
              while (!this._hadError && Xt(wt[0], wt[1]));
              if (this._hadError)
                throw ct;
              if ($e >= E)
                throw Me(this), new RangeError(x);
              var Oe = r.concat(Fe, $e);
              return Me(this), Oe;
            }
            M(this._handle, "zlib binding closed");
            var Ct = this._handle.write(
              de,
              le,
              // in
              Ue,
              // in_off
              ze,
              // in_len
              this._buffer,
              // out
              this._offset,
              //out_off
              Ze
            );
            Ct.buffer = le, Ct.callback = Xt;
            function Xt(vt, Ye) {
              if (this && (this.buffer = null, this.callback = null), !Ie._hadError) {
                var qe = Ze - Ye;
                if (M(qe >= 0, "have should not go down"), qe > 0) {
                  var rt = Ie._buffer.slice(Ie._offset, Ie._offset + qe);
                  Ie._offset += qe, je ? Ie.push(rt) : (Fe.push(rt), $e += rt.length);
                }
                if ((Ye === 0 || Ie._offset >= Ie._chunkSize) && (Ze = Ie._chunkSize, Ie._offset = 0, Ie._buffer = r.allocUnsafe(Ie._chunkSize)), Ye === 0) {
                  if (Ue += ze - vt, ze = vt, !je) return !0;
                  var it = Ie._handle.write(de, le, Ue, ze, Ie._buffer, Ie._offset, Ie._chunkSize);
                  it.callback = Xt, it.buffer = le;
                  return;
                }
                if (!je) return !1;
                De();
              }
            }
          }, P.inherits(V, be), P.inherits(W, be), P.inherits(q, be), P.inherits(Y, be), P.inherits(re, be), P.inherits(se, be), P.inherits(ve, be);
        }).call(this, te("_process"));
      }, { "./binding": 34, _process: 133, assert: 25, buffer: 48, stream: 155, util: 186 }], 36: [function(te, Ee, $) {
        var Q = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        function r(P, M) {
          return Object.prototype.hasOwnProperty.call(P, M);
        }
        $.assign = function(P) {
          for (var M = Array.prototype.slice.call(arguments, 1); M.length; ) {
            var E = M.shift();
            if (E) {
              if (typeof E != "object")
                throw new TypeError(E + "must be non-object");
              for (var x in E)
                r(E, x) && (P[x] = E[x]);
            }
          }
          return P;
        }, $.shrinkBuf = function(P, M) {
          return P.length === M ? P : P.subarray ? P.subarray(0, M) : (P.length = M, P);
        };
        var F = {
          arraySet: function(P, M, E, x, m) {
            if (M.subarray && P.subarray) {
              P.set(M.subarray(E, E + x), m);
              return;
            }
            for (var I = 0; I < x; I++)
              P[m + I] = M[E + I];
          },
          // Join array of chunks to single array.
          flattenChunks: function(P) {
            var M, E, x, m, I, z;
            for (x = 0, M = 0, E = P.length; M < E; M++)
              x += P[M].length;
            for (z = new Uint8Array(x), m = 0, M = 0, E = P.length; M < E; M++)
              I = P[M], z.set(I, m), m += I.length;
            return z;
          }
        }, H = {
          arraySet: function(P, M, E, x, m) {
            for (var I = 0; I < x; I++)
              P[m + I] = M[E + I];
          },
          // Join array of chunks to single array.
          flattenChunks: function(P) {
            return [].concat.apply([], P);
          }
        };
        $.setTyped = function(P) {
          P ? ($.Buf8 = Uint8Array, $.Buf16 = Uint16Array, $.Buf32 = Int32Array, $.assign($, F)) : ($.Buf8 = Array, $.Buf16 = Array, $.Buf32 = Array, $.assign($, H));
        }, $.setTyped(Q);
      }, {}], 37: [function(te, Ee, $) {
        function Q(r, F, H, P) {
          for (var M = r & 65535 | 0, E = r >>> 16 & 65535 | 0, x = 0; H !== 0; ) {
            x = H > 2e3 ? 2e3 : H, H -= x;
            do
              M = M + F[P++] | 0, E = E + M | 0;
            while (--x);
            M %= 65521, E %= 65521;
          }
          return M | E << 16 | 0;
        }
        Ee.exports = Q;
      }, {}], 38: [function(te, Ee, $) {
        Ee.exports = {
          /* Allowed flush values; see deflate() and inflate() below for details */
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          /* Return codes for the compression/decompression functions. Negative values
          * are errors, positive values are used for special but normal events.
          */
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          //Z_MEM_ERROR:     -4,
          Z_BUF_ERROR: -5,
          //Z_VERSION_ERROR: -6,
          /* compression levels */
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          /* Possible values of the data_type field (though see inflate()) */
          Z_BINARY: 0,
          Z_TEXT: 1,
          //Z_ASCII:                1, // = Z_TEXT (deprecated)
          Z_UNKNOWN: 2,
          /* The deflate compression method */
          Z_DEFLATED: 8
          //Z_NULL:                 null // Use -1 or null inline, depending on var type
        };
      }, {}], 39: [function(te, Ee, $) {
        function Q() {
          for (var H, P = [], M = 0; M < 256; M++) {
            H = M;
            for (var E = 0; E < 8; E++)
              H = H & 1 ? 3988292384 ^ H >>> 1 : H >>> 1;
            P[M] = H;
          }
          return P;
        }
        var r = Q();
        function F(H, P, M, E) {
          var x = r, m = E + M;
          H ^= -1;
          for (var I = E; I < m; I++)
            H = H >>> 8 ^ x[(H ^ P[I]) & 255];
          return H ^ -1;
        }
        Ee.exports = F;
      }, {}], 40: [function(te, Ee, $) {
        var Q = te("../utils/common"), r = te("./trees"), F = te("./adler32"), H = te("./crc32"), P = te("./messages"), M = 0, E = 1, x = 3, m = 4, I = 5, z = 0, w = 1, C = -2, b = -3, B = -5, N = -1, U = 1, V = 2, W = 3, q = 4, Y = 0, re = 2, se = 8, ve = 9, ce = 15, be = 8, Me = 29, xe = 256, le = xe + 1 + Me, de = 30, De = 19, ze = 2 * le + 1, Ze = 15, Ue = 3, Ie = 258, je = Ie + Ue + 1, Fe = 32, $e = 42, ct = 69, wt = 73, Oe = 91, Ct = 103, Xt = 113, vt = 666, Ye = 1, qe = 2, rt = 3, it = 4, Ae = 3;
        function _e(Z, Dt) {
          return Z.msg = P[Dt], Dt;
        }
        function fe(Z) {
          return (Z << 1) - (Z > 4 ? 9 : 0);
        }
        function We(Z) {
          for (var Dt = Z.length; --Dt >= 0; )
            Z[Dt] = 0;
        }
        function Pe(Z) {
          var Dt = Z.state, er = Dt.pending;
          er > Z.avail_out && (er = Z.avail_out), er !== 0 && (Q.arraySet(Z.output, Dt.pending_buf, Dt.pending_out, er, Z.next_out), Z.next_out += er, Dt.pending_out += er, Z.total_out += er, Z.avail_out -= er, Dt.pending -= er, Dt.pending === 0 && (Dt.pending_out = 0));
        }
        function he(Z, Dt) {
          r._tr_flush_block(Z, Z.block_start >= 0 ? Z.block_start : -1, Z.strstart - Z.block_start, Dt), Z.block_start = Z.strstart, Pe(Z.strm);
        }
        function ie(Z, Dt) {
          Z.pending_buf[Z.pending++] = Dt;
        }
        function Xe(Z, Dt) {
          Z.pending_buf[Z.pending++] = Dt >>> 8 & 255, Z.pending_buf[Z.pending++] = Dt & 255;
        }
        function bt(Z, Dt, er, we) {
          var yt = Z.avail_in;
          return yt > we && (yt = we), yt === 0 ? 0 : (Z.avail_in -= yt, Q.arraySet(Dt, Z.input, Z.next_in, yt, er), Z.state.wrap === 1 ? Z.adler = F(Z.adler, Dt, yt, er) : Z.state.wrap === 2 && (Z.adler = H(Z.adler, Dt, yt, er)), Z.next_in += yt, Z.total_in += yt, yt);
        }
        function Wt(Z, Dt) {
          var er = Z.max_chain_length, we = Z.strstart, yt, ar, Or = Z.prev_length, Dr = Z.nice_match, Kr = Z.strstart > Z.w_size - je ? Z.strstart - (Z.w_size - je) : 0, di = Z.window, $t = Z.w_mask, Ce = Z.prev, Ne = Z.strstart + Ie, Ke = di[we + Or - 1], ht = di[we + Or];
          Z.prev_length >= Z.good_match && (er >>= 2), Dr > Z.lookahead && (Dr = Z.lookahead);
          do
            if (yt = Dt, !(di[yt + Or] !== ht || di[yt + Or - 1] !== Ke || di[yt] !== di[we] || di[++yt] !== di[we + 1])) {
              we += 2, yt++;
              do
                ;
              while (di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && we < Ne);
              if (ar = Ie - (Ne - we), we = Ne - Ie, ar > Or) {
                if (Z.match_start = Dt, Or = ar, ar >= Dr)
                  break;
                Ke = di[we + Or - 1], ht = di[we + Or];
              }
            }
          while ((Dt = Ce[Dt & $t]) > Kr && --er !== 0);
          return Or <= Z.lookahead ? Or : Z.lookahead;
        }
        function Qt(Z) {
          var Dt = Z.w_size, er, we, yt, ar, Or;
          do {
            if (ar = Z.window_size - Z.lookahead - Z.strstart, Z.strstart >= Dt + (Dt - je)) {
              Q.arraySet(Z.window, Z.window, Dt, Dt, 0), Z.match_start -= Dt, Z.strstart -= Dt, Z.block_start -= Dt, we = Z.hash_size, er = we;
              do
                yt = Z.head[--er], Z.head[er] = yt >= Dt ? yt - Dt : 0;
              while (--we);
              we = Dt, er = we;
              do
                yt = Z.prev[--er], Z.prev[er] = yt >= Dt ? yt - Dt : 0;
              while (--we);
              ar += Dt;
            }
            if (Z.strm.avail_in === 0)
              break;
            if (we = bt(Z.strm, Z.window, Z.strstart + Z.lookahead, ar), Z.lookahead += we, Z.lookahead + Z.insert >= Ue)
              for (Or = Z.strstart - Z.insert, Z.ins_h = Z.window[Or], Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Or + 1]) & Z.hash_mask; Z.insert && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Or + Ue - 1]) & Z.hash_mask, Z.prev[Or & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Or, Or++, Z.insert--, !(Z.lookahead + Z.insert < Ue)); )
                ;
          } while (Z.lookahead < je && Z.strm.avail_in !== 0);
        }
        function Sr(Z, Dt) {
          var er = 65535;
          for (er > Z.pending_buf_size - 5 && (er = Z.pending_buf_size - 5); ; ) {
            if (Z.lookahead <= 1) {
              if (Qt(Z), Z.lookahead === 0 && Dt === M)
                return Ye;
              if (Z.lookahead === 0)
                break;
            }
            Z.strstart += Z.lookahead, Z.lookahead = 0;
            var we = Z.block_start + er;
            if ((Z.strstart === 0 || Z.strstart >= we) && (Z.lookahead = Z.strstart - we, Z.strstart = we, he(Z, !1), Z.strm.avail_out === 0) || Z.strstart - Z.block_start >= Z.w_size - je && (he(Z, !1), Z.strm.avail_out === 0))
              return Ye;
          }
          return Z.insert = 0, Dt === m ? (he(Z, !0), Z.strm.avail_out === 0 ? rt : it) : (Z.strstart > Z.block_start && (he(Z, !1), Z.strm.avail_out === 0), Ye);
        }
        function Fr(Z, Dt) {
          for (var er, we; ; ) {
            if (Z.lookahead < je) {
              if (Qt(Z), Z.lookahead < je && Dt === M)
                return Ye;
              if (Z.lookahead === 0)
                break;
            }
            if (er = 0, Z.lookahead >= Ue && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + Ue - 1]) & Z.hash_mask, er = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart), er !== 0 && Z.strstart - er <= Z.w_size - je && (Z.match_length = Wt(Z, er)), Z.match_length >= Ue)
              if (we = r._tr_tally(Z, Z.strstart - Z.match_start, Z.match_length - Ue), Z.lookahead -= Z.match_length, Z.match_length <= Z.max_lazy_match && Z.lookahead >= Ue) {
                Z.match_length--;
                do
                  Z.strstart++, Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + Ue - 1]) & Z.hash_mask, er = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart;
                while (--Z.match_length !== 0);
                Z.strstart++;
              } else
                Z.strstart += Z.match_length, Z.match_length = 0, Z.ins_h = Z.window[Z.strstart], Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + 1]) & Z.hash_mask;
            else
              we = r._tr_tally(Z, 0, Z.window[Z.strstart]), Z.lookahead--, Z.strstart++;
            if (we && (he(Z, !1), Z.strm.avail_out === 0))
              return Ye;
          }
          return Z.insert = Z.strstart < Ue - 1 ? Z.strstart : Ue - 1, Dt === m ? (he(Z, !0), Z.strm.avail_out === 0 ? rt : it) : Z.last_lit && (he(Z, !1), Z.strm.avail_out === 0) ? Ye : qe;
        }
        function kr(Z, Dt) {
          for (var er, we, yt; ; ) {
            if (Z.lookahead < je) {
              if (Qt(Z), Z.lookahead < je && Dt === M)
                return Ye;
              if (Z.lookahead === 0)
                break;
            }
            if (er = 0, Z.lookahead >= Ue && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + Ue - 1]) & Z.hash_mask, er = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart), Z.prev_length = Z.match_length, Z.prev_match = Z.match_start, Z.match_length = Ue - 1, er !== 0 && Z.prev_length < Z.max_lazy_match && Z.strstart - er <= Z.w_size - je && (Z.match_length = Wt(Z, er), Z.match_length <= 5 && (Z.strategy === U || Z.match_length === Ue && Z.strstart - Z.match_start > 4096) && (Z.match_length = Ue - 1)), Z.prev_length >= Ue && Z.match_length <= Z.prev_length) {
              yt = Z.strstart + Z.lookahead - Ue, we = r._tr_tally(Z, Z.strstart - 1 - Z.prev_match, Z.prev_length - Ue), Z.lookahead -= Z.prev_length - 1, Z.prev_length -= 2;
              do
                ++Z.strstart <= yt && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + Ue - 1]) & Z.hash_mask, er = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart);
              while (--Z.prev_length !== 0);
              if (Z.match_available = 0, Z.match_length = Ue - 1, Z.strstart++, we && (he(Z, !1), Z.strm.avail_out === 0))
                return Ye;
            } else if (Z.match_available) {
              if (we = r._tr_tally(Z, 0, Z.window[Z.strstart - 1]), we && he(Z, !1), Z.strstart++, Z.lookahead--, Z.strm.avail_out === 0)
                return Ye;
            } else
              Z.match_available = 1, Z.strstart++, Z.lookahead--;
          }
          return Z.match_available && (we = r._tr_tally(Z, 0, Z.window[Z.strstart - 1]), Z.match_available = 0), Z.insert = Z.strstart < Ue - 1 ? Z.strstart : Ue - 1, Dt === m ? (he(Z, !0), Z.strm.avail_out === 0 ? rt : it) : Z.last_lit && (he(Z, !1), Z.strm.avail_out === 0) ? Ye : qe;
        }
        function Ur(Z, Dt) {
          for (var er, we, yt, ar, Or = Z.window; ; ) {
            if (Z.lookahead <= Ie) {
              if (Qt(Z), Z.lookahead <= Ie && Dt === M)
                return Ye;
              if (Z.lookahead === 0)
                break;
            }
            if (Z.match_length = 0, Z.lookahead >= Ue && Z.strstart > 0 && (yt = Z.strstart - 1, we = Or[yt], we === Or[++yt] && we === Or[++yt] && we === Or[++yt])) {
              ar = Z.strstart + Ie;
              do
                ;
              while (we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && yt < ar);
              Z.match_length = Ie - (ar - yt), Z.match_length > Z.lookahead && (Z.match_length = Z.lookahead);
            }
            if (Z.match_length >= Ue ? (er = r._tr_tally(Z, 1, Z.match_length - Ue), Z.lookahead -= Z.match_length, Z.strstart += Z.match_length, Z.match_length = 0) : (er = r._tr_tally(Z, 0, Z.window[Z.strstart]), Z.lookahead--, Z.strstart++), er && (he(Z, !1), Z.strm.avail_out === 0))
              return Ye;
          }
          return Z.insert = 0, Dt === m ? (he(Z, !0), Z.strm.avail_out === 0 ? rt : it) : Z.last_lit && (he(Z, !1), Z.strm.avail_out === 0) ? Ye : qe;
        }
        function Rr(Z, Dt) {
          for (var er; ; ) {
            if (Z.lookahead === 0 && (Qt(Z), Z.lookahead === 0)) {
              if (Dt === M)
                return Ye;
              break;
            }
            if (Z.match_length = 0, er = r._tr_tally(Z, 0, Z.window[Z.strstart]), Z.lookahead--, Z.strstart++, er && (he(Z, !1), Z.strm.avail_out === 0))
              return Ye;
          }
          return Z.insert = 0, Dt === m ? (he(Z, !0), Z.strm.avail_out === 0 ? rt : it) : Z.last_lit && (he(Z, !1), Z.strm.avail_out === 0) ? Ye : qe;
        }
        function Pr(Z, Dt, er, we, yt) {
          this.good_length = Z, this.max_lazy = Dt, this.nice_length = er, this.max_chain = we, this.func = yt;
        }
        var hi;
        hi = [
          /*      good lazy nice chain */
          new Pr(0, 0, 0, 0, Sr),
          /* 0 store only */
          new Pr(4, 4, 8, 4, Fr),
          /* 1 max speed, no lazy matches */
          new Pr(4, 5, 16, 8, Fr),
          /* 2 */
          new Pr(4, 6, 32, 32, Fr),
          /* 3 */
          new Pr(4, 4, 16, 16, kr),
          /* 4 lazy matches */
          new Pr(8, 16, 32, 32, kr),
          /* 5 */
          new Pr(8, 16, 128, 128, kr),
          /* 6 */
          new Pr(8, 32, 128, 256, kr),
          /* 7 */
          new Pr(32, 128, 258, 1024, kr),
          /* 8 */
          new Pr(32, 258, 258, 4096, kr)
          /* 9 max compression */
        ];
        function Vr(Z) {
          Z.window_size = 2 * Z.w_size, We(Z.head), Z.max_lazy_match = hi[Z.level].max_lazy, Z.good_match = hi[Z.level].good_length, Z.nice_match = hi[Z.level].nice_length, Z.max_chain_length = hi[Z.level].max_chain, Z.strstart = 0, Z.block_start = 0, Z.lookahead = 0, Z.insert = 0, Z.match_length = Z.prev_length = Ue - 1, Z.match_available = 0, Z.ins_h = 0;
        }
        function Te() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = se, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Q.Buf16(ze * 2), this.dyn_dtree = new Q.Buf16((2 * de + 1) * 2), this.bl_tree = new Q.Buf16((2 * De + 1) * 2), We(this.dyn_ltree), We(this.dyn_dtree), We(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Q.Buf16(Ze + 1), this.heap = new Q.Buf16(2 * le + 1), We(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Q.Buf16(2 * le + 1), We(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function Tt(Z) {
          var Dt;
          return !Z || !Z.state ? _e(Z, C) : (Z.total_in = Z.total_out = 0, Z.data_type = re, Dt = Z.state, Dt.pending = 0, Dt.pending_out = 0, Dt.wrap < 0 && (Dt.wrap = -Dt.wrap), Dt.status = Dt.wrap ? $e : Xt, Z.adler = Dt.wrap === 2 ? 0 : 1, Dt.last_flush = M, r._tr_init(Dt), z);
        }
        function Gt(Z) {
          var Dt = Tt(Z);
          return Dt === z && Vr(Z.state), Dt;
        }
        function pr(Z, Dt) {
          return !Z || !Z.state || Z.state.wrap !== 2 ? C : (Z.state.gzhead = Dt, z);
        }
        function kt(Z, Dt, er, we, yt, ar) {
          if (!Z)
            return C;
          var Or = 1;
          if (Dt === N && (Dt = 6), we < 0 ? (Or = 0, we = -we) : we > 15 && (Or = 2, we -= 16), yt < 1 || yt > ve || er !== se || we < 8 || we > 15 || Dt < 0 || Dt > 9 || ar < 0 || ar > q)
            return _e(Z, C);
          we === 8 && (we = 9);
          var Dr = new Te();
          return Z.state = Dr, Dr.strm = Z, Dr.wrap = Or, Dr.gzhead = null, Dr.w_bits = we, Dr.w_size = 1 << Dr.w_bits, Dr.w_mask = Dr.w_size - 1, Dr.hash_bits = yt + 7, Dr.hash_size = 1 << Dr.hash_bits, Dr.hash_mask = Dr.hash_size - 1, Dr.hash_shift = ~~((Dr.hash_bits + Ue - 1) / Ue), Dr.window = new Q.Buf8(Dr.w_size * 2), Dr.head = new Q.Buf16(Dr.hash_size), Dr.prev = new Q.Buf16(Dr.w_size), Dr.lit_bufsize = 1 << yt + 6, Dr.pending_buf_size = Dr.lit_bufsize * 4, Dr.pending_buf = new Q.Buf8(Dr.pending_buf_size), Dr.d_buf = 1 * Dr.lit_bufsize, Dr.l_buf = 3 * Dr.lit_bufsize, Dr.level = Dt, Dr.strategy = ar, Dr.method = er, Gt(Z);
        }
        function tr(Z, Dt) {
          return kt(Z, Dt, se, ce, be, Y);
        }
        function Je(Z, Dt) {
          var er, we, yt, ar;
          if (!Z || !Z.state || Dt > I || Dt < 0)
            return Z ? _e(Z, C) : C;
          if (we = Z.state, !Z.output || !Z.input && Z.avail_in !== 0 || we.status === vt && Dt !== m)
            return _e(Z, Z.avail_out === 0 ? B : C);
          if (we.strm = Z, er = we.last_flush, we.last_flush = Dt, we.status === $e)
            if (we.wrap === 2)
              Z.adler = 0, ie(we, 31), ie(we, 139), ie(we, 8), we.gzhead ? (ie(
                we,
                (we.gzhead.text ? 1 : 0) + (we.gzhead.hcrc ? 2 : 0) + (we.gzhead.extra ? 4 : 0) + (we.gzhead.name ? 8 : 0) + (we.gzhead.comment ? 16 : 0)
              ), ie(we, we.gzhead.time & 255), ie(we, we.gzhead.time >> 8 & 255), ie(we, we.gzhead.time >> 16 & 255), ie(we, we.gzhead.time >> 24 & 255), ie(we, we.level === 9 ? 2 : we.strategy >= V || we.level < 2 ? 4 : 0), ie(we, we.gzhead.os & 255), we.gzhead.extra && we.gzhead.extra.length && (ie(we, we.gzhead.extra.length & 255), ie(we, we.gzhead.extra.length >> 8 & 255)), we.gzhead.hcrc && (Z.adler = H(Z.adler, we.pending_buf, we.pending, 0)), we.gzindex = 0, we.status = ct) : (ie(we, 0), ie(we, 0), ie(we, 0), ie(we, 0), ie(we, 0), ie(we, we.level === 9 ? 2 : we.strategy >= V || we.level < 2 ? 4 : 0), ie(we, Ae), we.status = Xt);
            else {
              var Or = se + (we.w_bits - 8 << 4) << 8, Dr = -1;
              we.strategy >= V || we.level < 2 ? Dr = 0 : we.level < 6 ? Dr = 1 : we.level === 6 ? Dr = 2 : Dr = 3, Or |= Dr << 6, we.strstart !== 0 && (Or |= Fe), Or += 31 - Or % 31, we.status = Xt, Xe(we, Or), we.strstart !== 0 && (Xe(we, Z.adler >>> 16), Xe(we, Z.adler & 65535)), Z.adler = 1;
            }
          if (we.status === ct)
            if (we.gzhead.extra) {
              for (yt = we.pending; we.gzindex < (we.gzhead.extra.length & 65535) && !(we.pending === we.pending_buf_size && (we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), Pe(Z), yt = we.pending, we.pending === we.pending_buf_size)); )
                ie(we, we.gzhead.extra[we.gzindex] & 255), we.gzindex++;
              we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), we.gzindex === we.gzhead.extra.length && (we.gzindex = 0, we.status = wt);
            } else
              we.status = wt;
          if (we.status === wt)
            if (we.gzhead.name) {
              yt = we.pending;
              do {
                if (we.pending === we.pending_buf_size && (we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), Pe(Z), yt = we.pending, we.pending === we.pending_buf_size)) {
                  ar = 1;
                  break;
                }
                we.gzindex < we.gzhead.name.length ? ar = we.gzhead.name.charCodeAt(we.gzindex++) & 255 : ar = 0, ie(we, ar);
              } while (ar !== 0);
              we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), ar === 0 && (we.gzindex = 0, we.status = Oe);
            } else
              we.status = Oe;
          if (we.status === Oe)
            if (we.gzhead.comment) {
              yt = we.pending;
              do {
                if (we.pending === we.pending_buf_size && (we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), Pe(Z), yt = we.pending, we.pending === we.pending_buf_size)) {
                  ar = 1;
                  break;
                }
                we.gzindex < we.gzhead.comment.length ? ar = we.gzhead.comment.charCodeAt(we.gzindex++) & 255 : ar = 0, ie(we, ar);
              } while (ar !== 0);
              we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), ar === 0 && (we.status = Ct);
            } else
              we.status = Ct;
          if (we.status === Ct && (we.gzhead.hcrc ? (we.pending + 2 > we.pending_buf_size && Pe(Z), we.pending + 2 <= we.pending_buf_size && (ie(we, Z.adler & 255), ie(we, Z.adler >> 8 & 255), Z.adler = 0, we.status = Xt)) : we.status = Xt), we.pending !== 0) {
            if (Pe(Z), Z.avail_out === 0)
              return we.last_flush = -1, z;
          } else if (Z.avail_in === 0 && fe(Dt) <= fe(er) && Dt !== m)
            return _e(Z, B);
          if (we.status === vt && Z.avail_in !== 0)
            return _e(Z, B);
          if (Z.avail_in !== 0 || we.lookahead !== 0 || Dt !== M && we.status !== vt) {
            var Kr = we.strategy === V ? Rr(we, Dt) : we.strategy === W ? Ur(we, Dt) : hi[we.level].func(we, Dt);
            if ((Kr === rt || Kr === it) && (we.status = vt), Kr === Ye || Kr === rt)
              return Z.avail_out === 0 && (we.last_flush = -1), z;
            if (Kr === qe && (Dt === E ? r._tr_align(we) : Dt !== I && (r._tr_stored_block(we, 0, 0, !1), Dt === x && (We(we.head), we.lookahead === 0 && (we.strstart = 0, we.block_start = 0, we.insert = 0))), Pe(Z), Z.avail_out === 0))
              return we.last_flush = -1, z;
          }
          return Dt !== m ? z : we.wrap <= 0 ? w : (we.wrap === 2 ? (ie(we, Z.adler & 255), ie(we, Z.adler >> 8 & 255), ie(we, Z.adler >> 16 & 255), ie(we, Z.adler >> 24 & 255), ie(we, Z.total_in & 255), ie(we, Z.total_in >> 8 & 255), ie(we, Z.total_in >> 16 & 255), ie(we, Z.total_in >> 24 & 255)) : (Xe(we, Z.adler >>> 16), Xe(we, Z.adler & 65535)), Pe(Z), we.wrap > 0 && (we.wrap = -we.wrap), we.pending !== 0 ? z : w);
        }
        function wr(Z) {
          var Dt;
          return !Z || !Z.state ? C : (Dt = Z.state.status, Dt !== $e && Dt !== ct && Dt !== wt && Dt !== Oe && Dt !== Ct && Dt !== Xt && Dt !== vt ? _e(Z, C) : (Z.state = null, Dt === Xt ? _e(Z, b) : z));
        }
        function ni(Z, Dt) {
          var er = Dt.length, we, yt, ar, Or, Dr, Kr, di, $t;
          if (!Z || !Z.state || (we = Z.state, Or = we.wrap, Or === 2 || Or === 1 && we.status !== $e || we.lookahead))
            return C;
          for (Or === 1 && (Z.adler = F(Z.adler, Dt, er, 0)), we.wrap = 0, er >= we.w_size && (Or === 0 && (We(we.head), we.strstart = 0, we.block_start = 0, we.insert = 0), $t = new Q.Buf8(we.w_size), Q.arraySet($t, Dt, er - we.w_size, we.w_size, 0), Dt = $t, er = we.w_size), Dr = Z.avail_in, Kr = Z.next_in, di = Z.input, Z.avail_in = er, Z.next_in = 0, Z.input = Dt, Qt(we); we.lookahead >= Ue; ) {
            yt = we.strstart, ar = we.lookahead - (Ue - 1);
            do
              we.ins_h = (we.ins_h << we.hash_shift ^ we.window[yt + Ue - 1]) & we.hash_mask, we.prev[yt & we.w_mask] = we.head[we.ins_h], we.head[we.ins_h] = yt, yt++;
            while (--ar);
            we.strstart = yt, we.lookahead = Ue - 1, Qt(we);
          }
          return we.strstart += we.lookahead, we.block_start = we.strstart, we.insert = we.lookahead, we.lookahead = 0, we.match_length = we.prev_length = Ue - 1, we.match_available = 0, Z.next_in = Kr, Z.input = di, Z.avail_in = Dr, we.wrap = Or, z;
        }
        $.deflateInit = tr, $.deflateInit2 = kt, $.deflateReset = Gt, $.deflateResetKeep = Tt, $.deflateSetHeader = pr, $.deflate = Je, $.deflateEnd = wr, $.deflateSetDictionary = ni, $.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 36, "./adler32": 37, "./crc32": 39, "./messages": 44, "./trees": 45 }], 41: [function(te, Ee, $) {
        var Q = 30, r = 12;
        Ee.exports = function(H, P) {
          var M, E, x, m, I, z, w, C, b, B, N, U, V, W, q, Y, re, se, ve, ce, be, Me, xe, le, de;
          M = H.state, E = H.next_in, le = H.input, x = E + (H.avail_in - 5), m = H.next_out, de = H.output, I = m - (P - H.avail_out), z = m + (H.avail_out - 257), w = M.dmax, C = M.wsize, b = M.whave, B = M.wnext, N = M.window, U = M.hold, V = M.bits, W = M.lencode, q = M.distcode, Y = (1 << M.lenbits) - 1, re = (1 << M.distbits) - 1;
          e:
            do {
              V < 15 && (U += le[E++] << V, V += 8, U += le[E++] << V, V += 8), se = W[U & Y];
              t:
                for (; ; ) {
                  if (ve = se >>> 24, U >>>= ve, V -= ve, ve = se >>> 16 & 255, ve === 0)
                    de[m++] = se & 65535;
                  else if (ve & 16) {
                    ce = se & 65535, ve &= 15, ve && (V < ve && (U += le[E++] << V, V += 8), ce += U & (1 << ve) - 1, U >>>= ve, V -= ve), V < 15 && (U += le[E++] << V, V += 8, U += le[E++] << V, V += 8), se = q[U & re];
                    r:
                      for (; ; ) {
                        if (ve = se >>> 24, U >>>= ve, V -= ve, ve = se >>> 16 & 255, ve & 16) {
                          if (be = se & 65535, ve &= 15, V < ve && (U += le[E++] << V, V += 8, V < ve && (U += le[E++] << V, V += 8)), be += U & (1 << ve) - 1, be > w) {
                            H.msg = "invalid distance too far back", M.mode = Q;
                            break e;
                          }
                          if (U >>>= ve, V -= ve, ve = m - I, be > ve) {
                            if (ve = be - ve, ve > b && M.sane) {
                              H.msg = "invalid distance too far back", M.mode = Q;
                              break e;
                            }
                            if (Me = 0, xe = N, B === 0) {
                              if (Me += C - ve, ve < ce) {
                                ce -= ve;
                                do
                                  de[m++] = N[Me++];
                                while (--ve);
                                Me = m - be, xe = de;
                              }
                            } else if (B < ve) {
                              if (Me += C + B - ve, ve -= B, ve < ce) {
                                ce -= ve;
                                do
                                  de[m++] = N[Me++];
                                while (--ve);
                                if (Me = 0, B < ce) {
                                  ve = B, ce -= ve;
                                  do
                                    de[m++] = N[Me++];
                                  while (--ve);
                                  Me = m - be, xe = de;
                                }
                              }
                            } else if (Me += B - ve, ve < ce) {
                              ce -= ve;
                              do
                                de[m++] = N[Me++];
                              while (--ve);
                              Me = m - be, xe = de;
                            }
                            for (; ce > 2; )
                              de[m++] = xe[Me++], de[m++] = xe[Me++], de[m++] = xe[Me++], ce -= 3;
                            ce && (de[m++] = xe[Me++], ce > 1 && (de[m++] = xe[Me++]));
                          } else {
                            Me = m - be;
                            do
                              de[m++] = de[Me++], de[m++] = de[Me++], de[m++] = de[Me++], ce -= 3;
                            while (ce > 2);
                            ce && (de[m++] = de[Me++], ce > 1 && (de[m++] = de[Me++]));
                          }
                        } else if (ve & 64) {
                          H.msg = "invalid distance code", M.mode = Q;
                          break e;
                        } else {
                          se = q[(se & 65535) + (U & (1 << ve) - 1)];
                          continue r;
                        }
                        break;
                      }
                  } else if (ve & 64)
                    if (ve & 32) {
                      M.mode = r;
                      break e;
                    } else {
                      H.msg = "invalid literal/length code", M.mode = Q;
                      break e;
                    }
                  else {
                    se = W[(se & 65535) + (U & (1 << ve) - 1)];
                    continue t;
                  }
                  break;
                }
            } while (E < x && m < z);
          ce = V >> 3, E -= ce, V -= ce << 3, U &= (1 << V) - 1, H.next_in = E, H.next_out = m, H.avail_in = E < x ? 5 + (x - E) : 5 - (E - x), H.avail_out = m < z ? 257 + (z - m) : 257 - (m - z), M.hold = U, M.bits = V;
        };
      }, {}], 42: [function(te, Ee, $) {
        var Q = te("../utils/common"), r = te("./adler32"), F = te("./crc32"), H = te("./inffast"), P = te("./inftrees"), M = 0, E = 1, x = 2, m = 4, I = 5, z = 6, w = 0, C = 1, b = 2, B = -2, N = -3, U = -4, V = -5, W = 8, q = 1, Y = 2, re = 3, se = 4, ve = 5, ce = 6, be = 7, Me = 8, xe = 9, le = 10, de = 11, De = 12, ze = 13, Ze = 14, Ue = 15, Ie = 16, je = 17, Fe = 18, $e = 19, ct = 20, wt = 21, Oe = 22, Ct = 23, Xt = 24, vt = 25, Ye = 26, qe = 27, rt = 28, it = 29, Ae = 30, _e = 31, fe = 32, We = 852, Pe = 592, he = 15, ie = he;
        function Xe(kt) {
          return (kt >>> 24 & 255) + (kt >>> 8 & 65280) + ((kt & 65280) << 8) + ((kt & 255) << 24);
        }
        function bt() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Q.Buf16(320), this.work = new Q.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function Wt(kt) {
          var tr;
          return !kt || !kt.state ? B : (tr = kt.state, kt.total_in = kt.total_out = tr.total = 0, kt.msg = "", tr.wrap && (kt.adler = tr.wrap & 1), tr.mode = q, tr.last = 0, tr.havedict = 0, tr.dmax = 32768, tr.head = null, tr.hold = 0, tr.bits = 0, tr.lencode = tr.lendyn = new Q.Buf32(We), tr.distcode = tr.distdyn = new Q.Buf32(Pe), tr.sane = 1, tr.back = -1, w);
        }
        function Qt(kt) {
          var tr;
          return !kt || !kt.state ? B : (tr = kt.state, tr.wsize = 0, tr.whave = 0, tr.wnext = 0, Wt(kt));
        }
        function Sr(kt, tr) {
          var Je, wr;
          return !kt || !kt.state || (wr = kt.state, tr < 0 ? (Je = 0, tr = -tr) : (Je = (tr >> 4) + 1, tr < 48 && (tr &= 15)), tr && (tr < 8 || tr > 15)) ? B : (wr.window !== null && wr.wbits !== tr && (wr.window = null), wr.wrap = Je, wr.wbits = tr, Qt(kt));
        }
        function Fr(kt, tr) {
          var Je, wr;
          return kt ? (wr = new bt(), kt.state = wr, wr.window = null, Je = Sr(kt, tr), Je !== w && (kt.state = null), Je) : B;
        }
        function kr(kt) {
          return Fr(kt, ie);
        }
        var Ur = !0, Rr, Pr;
        function hi(kt) {
          if (Ur) {
            var tr;
            for (Rr = new Q.Buf32(512), Pr = new Q.Buf32(32), tr = 0; tr < 144; )
              kt.lens[tr++] = 8;
            for (; tr < 256; )
              kt.lens[tr++] = 9;
            for (; tr < 280; )
              kt.lens[tr++] = 7;
            for (; tr < 288; )
              kt.lens[tr++] = 8;
            for (P(E, kt.lens, 0, 288, Rr, 0, kt.work, { bits: 9 }), tr = 0; tr < 32; )
              kt.lens[tr++] = 5;
            P(x, kt.lens, 0, 32, Pr, 0, kt.work, { bits: 5 }), Ur = !1;
          }
          kt.lencode = Rr, kt.lenbits = 9, kt.distcode = Pr, kt.distbits = 5;
        }
        function Vr(kt, tr, Je, wr) {
          var ni, Z = kt.state;
          return Z.window === null && (Z.wsize = 1 << Z.wbits, Z.wnext = 0, Z.whave = 0, Z.window = new Q.Buf8(Z.wsize)), wr >= Z.wsize ? (Q.arraySet(Z.window, tr, Je - Z.wsize, Z.wsize, 0), Z.wnext = 0, Z.whave = Z.wsize) : (ni = Z.wsize - Z.wnext, ni > wr && (ni = wr), Q.arraySet(Z.window, tr, Je - wr, ni, Z.wnext), wr -= ni, wr ? (Q.arraySet(Z.window, tr, Je - wr, wr, 0), Z.wnext = wr, Z.whave = Z.wsize) : (Z.wnext += ni, Z.wnext === Z.wsize && (Z.wnext = 0), Z.whave < Z.wsize && (Z.whave += ni))), 0;
        }
        function Te(kt, tr) {
          var Je, wr, ni, Z, Dt, er, we, yt, ar, Or, Dr, Kr, di, $t, Ce = 0, Ne, Ke, ht, ft, Pt, Nt, At, Zt, jt = new Q.Buf8(4), Yt, fr, Ir = (
            /* permutation of code lengths */
            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
          );
          if (!kt || !kt.state || !kt.output || !kt.input && kt.avail_in !== 0)
            return B;
          Je = kt.state, Je.mode === De && (Je.mode = ze), Dt = kt.next_out, ni = kt.output, we = kt.avail_out, Z = kt.next_in, wr = kt.input, er = kt.avail_in, yt = Je.hold, ar = Je.bits, Or = er, Dr = we, Zt = w;
          e:
            for (; ; )
              switch (Je.mode) {
                case q:
                  if (Je.wrap === 0) {
                    Je.mode = ze;
                    break;
                  }
                  for (; ar < 16; ) {
                    if (er === 0)
                      break e;
                    er--, yt += wr[Z++] << ar, ar += 8;
                  }
                  if (Je.wrap & 2 && yt === 35615) {
                    Je.check = 0, jt[0] = yt & 255, jt[1] = yt >>> 8 & 255, Je.check = F(Je.check, jt, 2, 0), yt = 0, ar = 0, Je.mode = Y;
                    break;
                  }
                  if (Je.flags = 0, Je.head && (Je.head.done = !1), !(Je.wrap & 1) || /* check if zlib header allowed */
                  (((yt & 255) << 8) + (yt >> 8)) % 31) {
                    kt.msg = "incorrect header check", Je.mode = Ae;
                    break;
                  }
                  if ((yt & 15) !== W) {
                    kt.msg = "unknown compression method", Je.mode = Ae;
                    break;
                  }
                  if (yt >>>= 4, ar -= 4, At = (yt & 15) + 8, Je.wbits === 0)
                    Je.wbits = At;
                  else if (At > Je.wbits) {
                    kt.msg = "invalid window size", Je.mode = Ae;
                    break;
                  }
                  Je.dmax = 1 << At, kt.adler = Je.check = 1, Je.mode = yt & 512 ? le : De, yt = 0, ar = 0;
                  break;
                case Y:
                  for (; ar < 16; ) {
                    if (er === 0)
                      break e;
                    er--, yt += wr[Z++] << ar, ar += 8;
                  }
                  if (Je.flags = yt, (Je.flags & 255) !== W) {
                    kt.msg = "unknown compression method", Je.mode = Ae;
                    break;
                  }
                  if (Je.flags & 57344) {
                    kt.msg = "unknown header flags set", Je.mode = Ae;
                    break;
                  }
                  Je.head && (Je.head.text = yt >> 8 & 1), Je.flags & 512 && (jt[0] = yt & 255, jt[1] = yt >>> 8 & 255, Je.check = F(Je.check, jt, 2, 0)), yt = 0, ar = 0, Je.mode = re;
                /* falls through */
                case re:
                  for (; ar < 32; ) {
                    if (er === 0)
                      break e;
                    er--, yt += wr[Z++] << ar, ar += 8;
                  }
                  Je.head && (Je.head.time = yt), Je.flags & 512 && (jt[0] = yt & 255, jt[1] = yt >>> 8 & 255, jt[2] = yt >>> 16 & 255, jt[3] = yt >>> 24 & 255, Je.check = F(Je.check, jt, 4, 0)), yt = 0, ar = 0, Je.mode = se;
                /* falls through */
                case se:
                  for (; ar < 16; ) {
                    if (er === 0)
                      break e;
                    er--, yt += wr[Z++] << ar, ar += 8;
                  }
                  Je.head && (Je.head.xflags = yt & 255, Je.head.os = yt >> 8), Je.flags & 512 && (jt[0] = yt & 255, jt[1] = yt >>> 8 & 255, Je.check = F(Je.check, jt, 2, 0)), yt = 0, ar = 0, Je.mode = ve;
                /* falls through */
                case ve:
                  if (Je.flags & 1024) {
                    for (; ar < 16; ) {
                      if (er === 0)
                        break e;
                      er--, yt += wr[Z++] << ar, ar += 8;
                    }
                    Je.length = yt, Je.head && (Je.head.extra_len = yt), Je.flags & 512 && (jt[0] = yt & 255, jt[1] = yt >>> 8 & 255, Je.check = F(Je.check, jt, 2, 0)), yt = 0, ar = 0;
                  } else Je.head && (Je.head.extra = null);
                  Je.mode = ce;
                /* falls through */
                case ce:
                  if (Je.flags & 1024 && (Kr = Je.length, Kr > er && (Kr = er), Kr && (Je.head && (At = Je.head.extra_len - Je.length, Je.head.extra || (Je.head.extra = new Array(Je.head.extra_len)), Q.arraySet(
                    Je.head.extra,
                    wr,
                    Z,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    Kr,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    At
                  )), Je.flags & 512 && (Je.check = F(Je.check, wr, Kr, Z)), er -= Kr, Z += Kr, Je.length -= Kr), Je.length))
                    break e;
                  Je.length = 0, Je.mode = be;
                /* falls through */
                case be:
                  if (Je.flags & 2048) {
                    if (er === 0)
                      break e;
                    Kr = 0;
                    do
                      At = wr[Z + Kr++], Je.head && At && Je.length < 65536 && (Je.head.name += String.fromCharCode(At));
                    while (At && Kr < er);
                    if (Je.flags & 512 && (Je.check = F(Je.check, wr, Kr, Z)), er -= Kr, Z += Kr, At)
                      break e;
                  } else Je.head && (Je.head.name = null);
                  Je.length = 0, Je.mode = Me;
                /* falls through */
                case Me:
                  if (Je.flags & 4096) {
                    if (er === 0)
                      break e;
                    Kr = 0;
                    do
                      At = wr[Z + Kr++], Je.head && At && Je.length < 65536 && (Je.head.comment += String.fromCharCode(At));
                    while (At && Kr < er);
                    if (Je.flags & 512 && (Je.check = F(Je.check, wr, Kr, Z)), er -= Kr, Z += Kr, At)
                      break e;
                  } else Je.head && (Je.head.comment = null);
                  Je.mode = xe;
                /* falls through */
                case xe:
                  if (Je.flags & 512) {
                    for (; ar < 16; ) {
                      if (er === 0)
                        break e;
                      er--, yt += wr[Z++] << ar, ar += 8;
                    }
                    if (yt !== (Je.check & 65535)) {
                      kt.msg = "header crc mismatch", Je.mode = Ae;
                      break;
                    }
                    yt = 0, ar = 0;
                  }
                  Je.head && (Je.head.hcrc = Je.flags >> 9 & 1, Je.head.done = !0), kt.adler = Je.check = 0, Je.mode = De;
                  break;
                case le:
                  for (; ar < 32; ) {
                    if (er === 0)
                      break e;
                    er--, yt += wr[Z++] << ar, ar += 8;
                  }
                  kt.adler = Je.check = Xe(yt), yt = 0, ar = 0, Je.mode = de;
                /* falls through */
                case de:
                  if (Je.havedict === 0)
                    return kt.next_out = Dt, kt.avail_out = we, kt.next_in = Z, kt.avail_in = er, Je.hold = yt, Je.bits = ar, b;
                  kt.adler = Je.check = 1, Je.mode = De;
                /* falls through */
                case De:
                  if (tr === I || tr === z)
                    break e;
                /* falls through */
                case ze:
                  if (Je.last) {
                    yt >>>= ar & 7, ar -= ar & 7, Je.mode = qe;
                    break;
                  }
                  for (; ar < 3; ) {
                    if (er === 0)
                      break e;
                    er--, yt += wr[Z++] << ar, ar += 8;
                  }
                  switch (Je.last = yt & 1, yt >>>= 1, ar -= 1, yt & 3) {
                    case 0:
                      Je.mode = Ze;
                      break;
                    case 1:
                      if (hi(Je), Je.mode = ct, tr === z) {
                        yt >>>= 2, ar -= 2;
                        break e;
                      }
                      break;
                    case 2:
                      Je.mode = je;
                      break;
                    case 3:
                      kt.msg = "invalid block type", Je.mode = Ae;
                  }
                  yt >>>= 2, ar -= 2;
                  break;
                case Ze:
                  for (yt >>>= ar & 7, ar -= ar & 7; ar < 32; ) {
                    if (er === 0)
                      break e;
                    er--, yt += wr[Z++] << ar, ar += 8;
                  }
                  if ((yt & 65535) !== (yt >>> 16 ^ 65535)) {
                    kt.msg = "invalid stored block lengths", Je.mode = Ae;
                    break;
                  }
                  if (Je.length = yt & 65535, yt = 0, ar = 0, Je.mode = Ue, tr === z)
                    break e;
                /* falls through */
                case Ue:
                  Je.mode = Ie;
                /* falls through */
                case Ie:
                  if (Kr = Je.length, Kr) {
                    if (Kr > er && (Kr = er), Kr > we && (Kr = we), Kr === 0)
                      break e;
                    Q.arraySet(ni, wr, Z, Kr, Dt), er -= Kr, Z += Kr, we -= Kr, Dt += Kr, Je.length -= Kr;
                    break;
                  }
                  Je.mode = De;
                  break;
                case je:
                  for (; ar < 14; ) {
                    if (er === 0)
                      break e;
                    er--, yt += wr[Z++] << ar, ar += 8;
                  }
                  if (Je.nlen = (yt & 31) + 257, yt >>>= 5, ar -= 5, Je.ndist = (yt & 31) + 1, yt >>>= 5, ar -= 5, Je.ncode = (yt & 15) + 4, yt >>>= 4, ar -= 4, Je.nlen > 286 || Je.ndist > 30) {
                    kt.msg = "too many length or distance symbols", Je.mode = Ae;
                    break;
                  }
                  Je.have = 0, Je.mode = Fe;
                /* falls through */
                case Fe:
                  for (; Je.have < Je.ncode; ) {
                    for (; ar < 3; ) {
                      if (er === 0)
                        break e;
                      er--, yt += wr[Z++] << ar, ar += 8;
                    }
                    Je.lens[Ir[Je.have++]] = yt & 7, yt >>>= 3, ar -= 3;
                  }
                  for (; Je.have < 19; )
                    Je.lens[Ir[Je.have++]] = 0;
                  if (Je.lencode = Je.lendyn, Je.lenbits = 7, Yt = { bits: Je.lenbits }, Zt = P(M, Je.lens, 0, 19, Je.lencode, 0, Je.work, Yt), Je.lenbits = Yt.bits, Zt) {
                    kt.msg = "invalid code lengths set", Je.mode = Ae;
                    break;
                  }
                  Je.have = 0, Je.mode = $e;
                /* falls through */
                case $e:
                  for (; Je.have < Je.nlen + Je.ndist; ) {
                    for (; Ce = Je.lencode[yt & (1 << Je.lenbits) - 1], Ne = Ce >>> 24, Ke = Ce >>> 16 & 255, ht = Ce & 65535, !(Ne <= ar); ) {
                      if (er === 0)
                        break e;
                      er--, yt += wr[Z++] << ar, ar += 8;
                    }
                    if (ht < 16)
                      yt >>>= Ne, ar -= Ne, Je.lens[Je.have++] = ht;
                    else {
                      if (ht === 16) {
                        for (fr = Ne + 2; ar < fr; ) {
                          if (er === 0)
                            break e;
                          er--, yt += wr[Z++] << ar, ar += 8;
                        }
                        if (yt >>>= Ne, ar -= Ne, Je.have === 0) {
                          kt.msg = "invalid bit length repeat", Je.mode = Ae;
                          break;
                        }
                        At = Je.lens[Je.have - 1], Kr = 3 + (yt & 3), yt >>>= 2, ar -= 2;
                      } else if (ht === 17) {
                        for (fr = Ne + 3; ar < fr; ) {
                          if (er === 0)
                            break e;
                          er--, yt += wr[Z++] << ar, ar += 8;
                        }
                        yt >>>= Ne, ar -= Ne, At = 0, Kr = 3 + (yt & 7), yt >>>= 3, ar -= 3;
                      } else {
                        for (fr = Ne + 7; ar < fr; ) {
                          if (er === 0)
                            break e;
                          er--, yt += wr[Z++] << ar, ar += 8;
                        }
                        yt >>>= Ne, ar -= Ne, At = 0, Kr = 11 + (yt & 127), yt >>>= 7, ar -= 7;
                      }
                      if (Je.have + Kr > Je.nlen + Je.ndist) {
                        kt.msg = "invalid bit length repeat", Je.mode = Ae;
                        break;
                      }
                      for (; Kr--; )
                        Je.lens[Je.have++] = At;
                    }
                  }
                  if (Je.mode === Ae)
                    break;
                  if (Je.lens[256] === 0) {
                    kt.msg = "invalid code -- missing end-of-block", Je.mode = Ae;
                    break;
                  }
                  if (Je.lenbits = 9, Yt = { bits: Je.lenbits }, Zt = P(E, Je.lens, 0, Je.nlen, Je.lencode, 0, Je.work, Yt), Je.lenbits = Yt.bits, Zt) {
                    kt.msg = "invalid literal/lengths set", Je.mode = Ae;
                    break;
                  }
                  if (Je.distbits = 6, Je.distcode = Je.distdyn, Yt = { bits: Je.distbits }, Zt = P(x, Je.lens, Je.nlen, Je.ndist, Je.distcode, 0, Je.work, Yt), Je.distbits = Yt.bits, Zt) {
                    kt.msg = "invalid distances set", Je.mode = Ae;
                    break;
                  }
                  if (Je.mode = ct, tr === z)
                    break e;
                /* falls through */
                case ct:
                  Je.mode = wt;
                /* falls through */
                case wt:
                  if (er >= 6 && we >= 258) {
                    kt.next_out = Dt, kt.avail_out = we, kt.next_in = Z, kt.avail_in = er, Je.hold = yt, Je.bits = ar, H(kt, Dr), Dt = kt.next_out, ni = kt.output, we = kt.avail_out, Z = kt.next_in, wr = kt.input, er = kt.avail_in, yt = Je.hold, ar = Je.bits, Je.mode === De && (Je.back = -1);
                    break;
                  }
                  for (Je.back = 0; Ce = Je.lencode[yt & (1 << Je.lenbits) - 1], Ne = Ce >>> 24, Ke = Ce >>> 16 & 255, ht = Ce & 65535, !(Ne <= ar); ) {
                    if (er === 0)
                      break e;
                    er--, yt += wr[Z++] << ar, ar += 8;
                  }
                  if (Ke && !(Ke & 240)) {
                    for (ft = Ne, Pt = Ke, Nt = ht; Ce = Je.lencode[Nt + ((yt & (1 << ft + Pt) - 1) >> ft)], Ne = Ce >>> 24, Ke = Ce >>> 16 & 255, ht = Ce & 65535, !(ft + Ne <= ar); ) {
                      if (er === 0)
                        break e;
                      er--, yt += wr[Z++] << ar, ar += 8;
                    }
                    yt >>>= ft, ar -= ft, Je.back += ft;
                  }
                  if (yt >>>= Ne, ar -= Ne, Je.back += Ne, Je.length = ht, Ke === 0) {
                    Je.mode = Ye;
                    break;
                  }
                  if (Ke & 32) {
                    Je.back = -1, Je.mode = De;
                    break;
                  }
                  if (Ke & 64) {
                    kt.msg = "invalid literal/length code", Je.mode = Ae;
                    break;
                  }
                  Je.extra = Ke & 15, Je.mode = Oe;
                /* falls through */
                case Oe:
                  if (Je.extra) {
                    for (fr = Je.extra; ar < fr; ) {
                      if (er === 0)
                        break e;
                      er--, yt += wr[Z++] << ar, ar += 8;
                    }
                    Je.length += yt & (1 << Je.extra) - 1, yt >>>= Je.extra, ar -= Je.extra, Je.back += Je.extra;
                  }
                  Je.was = Je.length, Je.mode = Ct;
                /* falls through */
                case Ct:
                  for (; Ce = Je.distcode[yt & (1 << Je.distbits) - 1], Ne = Ce >>> 24, Ke = Ce >>> 16 & 255, ht = Ce & 65535, !(Ne <= ar); ) {
                    if (er === 0)
                      break e;
                    er--, yt += wr[Z++] << ar, ar += 8;
                  }
                  if (!(Ke & 240)) {
                    for (ft = Ne, Pt = Ke, Nt = ht; Ce = Je.distcode[Nt + ((yt & (1 << ft + Pt) - 1) >> ft)], Ne = Ce >>> 24, Ke = Ce >>> 16 & 255, ht = Ce & 65535, !(ft + Ne <= ar); ) {
                      if (er === 0)
                        break e;
                      er--, yt += wr[Z++] << ar, ar += 8;
                    }
                    yt >>>= ft, ar -= ft, Je.back += ft;
                  }
                  if (yt >>>= Ne, ar -= Ne, Je.back += Ne, Ke & 64) {
                    kt.msg = "invalid distance code", Je.mode = Ae;
                    break;
                  }
                  Je.offset = ht, Je.extra = Ke & 15, Je.mode = Xt;
                /* falls through */
                case Xt:
                  if (Je.extra) {
                    for (fr = Je.extra; ar < fr; ) {
                      if (er === 0)
                        break e;
                      er--, yt += wr[Z++] << ar, ar += 8;
                    }
                    Je.offset += yt & (1 << Je.extra) - 1, yt >>>= Je.extra, ar -= Je.extra, Je.back += Je.extra;
                  }
                  if (Je.offset > Je.dmax) {
                    kt.msg = "invalid distance too far back", Je.mode = Ae;
                    break;
                  }
                  Je.mode = vt;
                /* falls through */
                case vt:
                  if (we === 0)
                    break e;
                  if (Kr = Dr - we, Je.offset > Kr) {
                    if (Kr = Je.offset - Kr, Kr > Je.whave && Je.sane) {
                      kt.msg = "invalid distance too far back", Je.mode = Ae;
                      break;
                    }
                    Kr > Je.wnext ? (Kr -= Je.wnext, di = Je.wsize - Kr) : di = Je.wnext - Kr, Kr > Je.length && (Kr = Je.length), $t = Je.window;
                  } else
                    $t = ni, di = Dt - Je.offset, Kr = Je.length;
                  Kr > we && (Kr = we), we -= Kr, Je.length -= Kr;
                  do
                    ni[Dt++] = $t[di++];
                  while (--Kr);
                  Je.length === 0 && (Je.mode = wt);
                  break;
                case Ye:
                  if (we === 0)
                    break e;
                  ni[Dt++] = Je.length, we--, Je.mode = wt;
                  break;
                case qe:
                  if (Je.wrap) {
                    for (; ar < 32; ) {
                      if (er === 0)
                        break e;
                      er--, yt |= wr[Z++] << ar, ar += 8;
                    }
                    if (Dr -= we, kt.total_out += Dr, Je.total += Dr, Dr && (kt.adler = Je.check = /*UPDATE(state.check, put - _out, _out);*/
                    Je.flags ? F(Je.check, ni, Dr, Dt - Dr) : r(Je.check, ni, Dr, Dt - Dr)), Dr = we, (Je.flags ? yt : Xe(yt)) !== Je.check) {
                      kt.msg = "incorrect data check", Je.mode = Ae;
                      break;
                    }
                    yt = 0, ar = 0;
                  }
                  Je.mode = rt;
                /* falls through */
                case rt:
                  if (Je.wrap && Je.flags) {
                    for (; ar < 32; ) {
                      if (er === 0)
                        break e;
                      er--, yt += wr[Z++] << ar, ar += 8;
                    }
                    if (yt !== (Je.total & 4294967295)) {
                      kt.msg = "incorrect length check", Je.mode = Ae;
                      break;
                    }
                    yt = 0, ar = 0;
                  }
                  Je.mode = it;
                /* falls through */
                case it:
                  Zt = C;
                  break e;
                case Ae:
                  Zt = N;
                  break e;
                case _e:
                  return U;
                case fe:
                /* falls through */
                default:
                  return B;
              }
          return kt.next_out = Dt, kt.avail_out = we, kt.next_in = Z, kt.avail_in = er, Je.hold = yt, Je.bits = ar, (Je.wsize || Dr !== kt.avail_out && Je.mode < Ae && (Je.mode < qe || tr !== m)) && Vr(kt, kt.output, kt.next_out, Dr - kt.avail_out), Or -= kt.avail_in, Dr -= kt.avail_out, kt.total_in += Or, kt.total_out += Dr, Je.total += Dr, Je.wrap && Dr && (kt.adler = Je.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          Je.flags ? F(Je.check, ni, Dr, kt.next_out - Dr) : r(Je.check, ni, Dr, kt.next_out - Dr)), kt.data_type = Je.bits + (Je.last ? 64 : 0) + (Je.mode === De ? 128 : 0) + (Je.mode === ct || Je.mode === Ue ? 256 : 0), (Or === 0 && Dr === 0 || tr === m) && Zt === w && (Zt = V), Zt;
        }
        function Tt(kt) {
          if (!kt || !kt.state)
            return B;
          var tr = kt.state;
          return tr.window && (tr.window = null), kt.state = null, w;
        }
        function Gt(kt, tr) {
          var Je;
          return !kt || !kt.state || (Je = kt.state, !(Je.wrap & 2)) ? B : (Je.head = tr, tr.done = !1, w);
        }
        function pr(kt, tr) {
          var Je = tr.length, wr, ni, Z;
          return !kt || !kt.state || (wr = kt.state, wr.wrap !== 0 && wr.mode !== de) ? B : wr.mode === de && (ni = 1, ni = r(ni, tr, Je, 0), ni !== wr.check) ? N : (Z = Vr(kt, tr, Je, Je), Z ? (wr.mode = _e, U) : (wr.havedict = 1, w));
        }
        $.inflateReset = Qt, $.inflateReset2 = Sr, $.inflateResetKeep = Wt, $.inflateInit = kr, $.inflateInit2 = Fr, $.inflate = Te, $.inflateEnd = Tt, $.inflateGetHeader = Gt, $.inflateSetDictionary = pr, $.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 36, "./adler32": 37, "./crc32": 39, "./inffast": 41, "./inftrees": 43 }], 43: [function(te, Ee, $) {
        var Q = te("../utils/common"), r = 15, F = 852, H = 592, P = 0, M = 1, E = 2, x = [
          /* Length codes 257..285 base */
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ], m = [
          /* Length codes 257..285 extra */
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ], I = [
          /* Distance codes 0..29 base */
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ], z = [
          /* Distance codes 0..29 extra */
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ];
        Ee.exports = function(C, b, B, N, U, V, W, q) {
          var Y = q.bits, re = 0, se = 0, ve = 0, ce = 0, be = 0, Me = 0, xe = 0, le = 0, de = 0, De = 0, ze, Ze, Ue, Ie, je, Fe = null, $e = 0, ct, wt = new Q.Buf16(r + 1), Oe = new Q.Buf16(r + 1), Ct = null, Xt = 0, vt, Ye, qe;
          for (re = 0; re <= r; re++)
            wt[re] = 0;
          for (se = 0; se < N; se++)
            wt[b[B + se]]++;
          for (be = Y, ce = r; ce >= 1 && wt[ce] === 0; ce--)
            ;
          if (be > ce && (be = ce), ce === 0)
            return U[V++] = 1 << 24 | 64 << 16 | 0, U[V++] = 1 << 24 | 64 << 16 | 0, q.bits = 1, 0;
          for (ve = 1; ve < ce && wt[ve] === 0; ve++)
            ;
          for (be < ve && (be = ve), le = 1, re = 1; re <= r; re++)
            if (le <<= 1, le -= wt[re], le < 0)
              return -1;
          if (le > 0 && (C === P || ce !== 1))
            return -1;
          for (Oe[1] = 0, re = 1; re < r; re++)
            Oe[re + 1] = Oe[re] + wt[re];
          for (se = 0; se < N; se++)
            b[B + se] !== 0 && (W[Oe[b[B + se]]++] = se);
          if (C === P ? (Fe = Ct = W, ct = 19) : C === M ? (Fe = x, $e -= 257, Ct = m, Xt -= 257, ct = 256) : (Fe = I, Ct = z, ct = -1), De = 0, se = 0, re = ve, je = V, Me = be, xe = 0, Ue = -1, de = 1 << be, Ie = de - 1, C === M && de > F || C === E && de > H)
            return 1;
          for (; ; ) {
            vt = re - xe, W[se] < ct ? (Ye = 0, qe = W[se]) : W[se] > ct ? (Ye = Ct[Xt + W[se]], qe = Fe[$e + W[se]]) : (Ye = 96, qe = 0), ze = 1 << re - xe, Ze = 1 << Me, ve = Ze;
            do
              Ze -= ze, U[je + (De >> xe) + Ze] = vt << 24 | Ye << 16 | qe | 0;
            while (Ze !== 0);
            for (ze = 1 << re - 1; De & ze; )
              ze >>= 1;
            if (ze !== 0 ? (De &= ze - 1, De += ze) : De = 0, se++, --wt[re] === 0) {
              if (re === ce)
                break;
              re = b[B + W[se]];
            }
            if (re > be && (De & Ie) !== Ue) {
              for (xe === 0 && (xe = be), je += ve, Me = re - xe, le = 1 << Me; Me + xe < ce && (le -= wt[Me + xe], !(le <= 0)); )
                Me++, le <<= 1;
              if (de += 1 << Me, C === M && de > F || C === E && de > H)
                return 1;
              Ue = De & Ie, U[Ue] = be << 24 | Me << 16 | je - V | 0;
            }
          }
          return De !== 0 && (U[je + De] = re - xe << 24 | 64 << 16 | 0), q.bits = be, 0;
        };
      }, { "../utils/common": 36 }], 44: [function(te, Ee, $) {
        Ee.exports = {
          2: "need dictionary",
          /* Z_NEED_DICT       2  */
          1: "stream end",
          /* Z_STREAM_END      1  */
          0: "",
          /* Z_OK              0  */
          "-1": "file error",
          /* Z_ERRNO         (-1) */
          "-2": "stream error",
          /* Z_STREAM_ERROR  (-2) */
          "-3": "data error",
          /* Z_DATA_ERROR    (-3) */
          "-4": "insufficient memory",
          /* Z_MEM_ERROR     (-4) */
          "-5": "buffer error",
          /* Z_BUF_ERROR     (-5) */
          "-6": "incompatible version"
          /* Z_VERSION_ERROR (-6) */
        };
      }, {}], 45: [function(te, Ee, $) {
        var Q = te("../utils/common"), r = 4, F = 0, H = 1, P = 2;
        function M(Te) {
          for (var Tt = Te.length; --Tt >= 0; )
            Te[Tt] = 0;
        }
        var E = 0, x = 1, m = 2, I = 3, z = 258, w = 29, C = 256, b = C + 1 + w, B = 30, N = 19, U = 2 * b + 1, V = 15, W = 16, q = 7, Y = 256, re = 16, se = 17, ve = 18, ce = (
          /* extra bits for each length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
        ), be = (
          /* extra bits for each distance code */
          [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
        ), Me = (
          /* extra bits for each bit length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
        ), xe = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], le = 512, de = new Array((b + 2) * 2);
        M(de);
        var De = new Array(B * 2);
        M(De);
        var ze = new Array(le);
        M(ze);
        var Ze = new Array(z - I + 1);
        M(Ze);
        var Ue = new Array(w);
        M(Ue);
        var Ie = new Array(B);
        M(Ie);
        function je(Te, Tt, Gt, pr, kt) {
          this.static_tree = Te, this.extra_bits = Tt, this.extra_base = Gt, this.elems = pr, this.max_length = kt, this.has_stree = Te && Te.length;
        }
        var Fe, $e, ct;
        function wt(Te, Tt) {
          this.dyn_tree = Te, this.max_code = 0, this.stat_desc = Tt;
        }
        function Oe(Te) {
          return Te < 256 ? ze[Te] : ze[256 + (Te >>> 7)];
        }
        function Ct(Te, Tt) {
          Te.pending_buf[Te.pending++] = Tt & 255, Te.pending_buf[Te.pending++] = Tt >>> 8 & 255;
        }
        function Xt(Te, Tt, Gt) {
          Te.bi_valid > W - Gt ? (Te.bi_buf |= Tt << Te.bi_valid & 65535, Ct(Te, Te.bi_buf), Te.bi_buf = Tt >> W - Te.bi_valid, Te.bi_valid += Gt - W) : (Te.bi_buf |= Tt << Te.bi_valid & 65535, Te.bi_valid += Gt);
        }
        function vt(Te, Tt, Gt) {
          Xt(
            Te,
            Gt[Tt * 2],
            Gt[Tt * 2 + 1]
            /*.Len*/
          );
        }
        function Ye(Te, Tt) {
          var Gt = 0;
          do
            Gt |= Te & 1, Te >>>= 1, Gt <<= 1;
          while (--Tt > 0);
          return Gt >>> 1;
        }
        function qe(Te) {
          Te.bi_valid === 16 ? (Ct(Te, Te.bi_buf), Te.bi_buf = 0, Te.bi_valid = 0) : Te.bi_valid >= 8 && (Te.pending_buf[Te.pending++] = Te.bi_buf & 255, Te.bi_buf >>= 8, Te.bi_valid -= 8);
        }
        function rt(Te, Tt) {
          var Gt = Tt.dyn_tree, pr = Tt.max_code, kt = Tt.stat_desc.static_tree, tr = Tt.stat_desc.has_stree, Je = Tt.stat_desc.extra_bits, wr = Tt.stat_desc.extra_base, ni = Tt.stat_desc.max_length, Z, Dt, er, we, yt, ar, Or = 0;
          for (we = 0; we <= V; we++)
            Te.bl_count[we] = 0;
          for (Gt[Te.heap[Te.heap_max] * 2 + 1] = 0, Z = Te.heap_max + 1; Z < U; Z++)
            Dt = Te.heap[Z], we = Gt[Gt[Dt * 2 + 1] * 2 + 1] + 1, we > ni && (we = ni, Or++), Gt[Dt * 2 + 1] = we, !(Dt > pr) && (Te.bl_count[we]++, yt = 0, Dt >= wr && (yt = Je[Dt - wr]), ar = Gt[Dt * 2], Te.opt_len += ar * (we + yt), tr && (Te.static_len += ar * (kt[Dt * 2 + 1] + yt)));
          if (Or !== 0) {
            do {
              for (we = ni - 1; Te.bl_count[we] === 0; )
                we--;
              Te.bl_count[we]--, Te.bl_count[we + 1] += 2, Te.bl_count[ni]--, Or -= 2;
            } while (Or > 0);
            for (we = ni; we !== 0; we--)
              for (Dt = Te.bl_count[we]; Dt !== 0; )
                er = Te.heap[--Z], !(er > pr) && (Gt[er * 2 + 1] !== we && (Te.opt_len += (we - Gt[er * 2 + 1]) * Gt[er * 2], Gt[er * 2 + 1] = we), Dt--);
          }
        }
        function it(Te, Tt, Gt) {
          var pr = new Array(V + 1), kt = 0, tr, Je;
          for (tr = 1; tr <= V; tr++)
            pr[tr] = kt = kt + Gt[tr - 1] << 1;
          for (Je = 0; Je <= Tt; Je++) {
            var wr = Te[Je * 2 + 1];
            wr !== 0 && (Te[Je * 2] = Ye(pr[wr]++, wr));
          }
        }
        function Ae() {
          var Te, Tt, Gt, pr, kt, tr = new Array(V + 1);
          for (Gt = 0, pr = 0; pr < w - 1; pr++)
            for (Ue[pr] = Gt, Te = 0; Te < 1 << ce[pr]; Te++)
              Ze[Gt++] = pr;
          for (Ze[Gt - 1] = pr, kt = 0, pr = 0; pr < 16; pr++)
            for (Ie[pr] = kt, Te = 0; Te < 1 << be[pr]; Te++)
              ze[kt++] = pr;
          for (kt >>= 7; pr < B; pr++)
            for (Ie[pr] = kt << 7, Te = 0; Te < 1 << be[pr] - 7; Te++)
              ze[256 + kt++] = pr;
          for (Tt = 0; Tt <= V; Tt++)
            tr[Tt] = 0;
          for (Te = 0; Te <= 143; )
            de[Te * 2 + 1] = 8, Te++, tr[8]++;
          for (; Te <= 255; )
            de[Te * 2 + 1] = 9, Te++, tr[9]++;
          for (; Te <= 279; )
            de[Te * 2 + 1] = 7, Te++, tr[7]++;
          for (; Te <= 287; )
            de[Te * 2 + 1] = 8, Te++, tr[8]++;
          for (it(de, b + 1, tr), Te = 0; Te < B; Te++)
            De[Te * 2 + 1] = 5, De[Te * 2] = Ye(Te, 5);
          Fe = new je(de, ce, C + 1, b, V), $e = new je(De, be, 0, B, V), ct = new je(new Array(0), Me, 0, N, q);
        }
        function _e(Te) {
          var Tt;
          for (Tt = 0; Tt < b; Tt++)
            Te.dyn_ltree[Tt * 2] = 0;
          for (Tt = 0; Tt < B; Tt++)
            Te.dyn_dtree[Tt * 2] = 0;
          for (Tt = 0; Tt < N; Tt++)
            Te.bl_tree[Tt * 2] = 0;
          Te.dyn_ltree[Y * 2] = 1, Te.opt_len = Te.static_len = 0, Te.last_lit = Te.matches = 0;
        }
        function fe(Te) {
          Te.bi_valid > 8 ? Ct(Te, Te.bi_buf) : Te.bi_valid > 0 && (Te.pending_buf[Te.pending++] = Te.bi_buf), Te.bi_buf = 0, Te.bi_valid = 0;
        }
        function We(Te, Tt, Gt, pr) {
          fe(Te), Ct(Te, Gt), Ct(Te, ~Gt), Q.arraySet(Te.pending_buf, Te.window, Tt, Gt, Te.pending), Te.pending += Gt;
        }
        function Pe(Te, Tt, Gt, pr) {
          var kt = Tt * 2, tr = Gt * 2;
          return Te[kt] < Te[tr] || Te[kt] === Te[tr] && pr[Tt] <= pr[Gt];
        }
        function he(Te, Tt, Gt) {
          for (var pr = Te.heap[Gt], kt = Gt << 1; kt <= Te.heap_len && (kt < Te.heap_len && Pe(Tt, Te.heap[kt + 1], Te.heap[kt], Te.depth) && kt++, !Pe(Tt, pr, Te.heap[kt], Te.depth)); )
            Te.heap[Gt] = Te.heap[kt], Gt = kt, kt <<= 1;
          Te.heap[Gt] = pr;
        }
        function ie(Te, Tt, Gt) {
          var pr, kt, tr = 0, Je, wr;
          if (Te.last_lit !== 0)
            do
              pr = Te.pending_buf[Te.d_buf + tr * 2] << 8 | Te.pending_buf[Te.d_buf + tr * 2 + 1], kt = Te.pending_buf[Te.l_buf + tr], tr++, pr === 0 ? vt(Te, kt, Tt) : (Je = Ze[kt], vt(Te, Je + C + 1, Tt), wr = ce[Je], wr !== 0 && (kt -= Ue[Je], Xt(Te, kt, wr)), pr--, Je = Oe(pr), vt(Te, Je, Gt), wr = be[Je], wr !== 0 && (pr -= Ie[Je], Xt(Te, pr, wr)));
            while (tr < Te.last_lit);
          vt(Te, Y, Tt);
        }
        function Xe(Te, Tt) {
          var Gt = Tt.dyn_tree, pr = Tt.stat_desc.static_tree, kt = Tt.stat_desc.has_stree, tr = Tt.stat_desc.elems, Je, wr, ni = -1, Z;
          for (Te.heap_len = 0, Te.heap_max = U, Je = 0; Je < tr; Je++)
            Gt[Je * 2] !== 0 ? (Te.heap[++Te.heap_len] = ni = Je, Te.depth[Je] = 0) : Gt[Je * 2 + 1] = 0;
          for (; Te.heap_len < 2; )
            Z = Te.heap[++Te.heap_len] = ni < 2 ? ++ni : 0, Gt[Z * 2] = 1, Te.depth[Z] = 0, Te.opt_len--, kt && (Te.static_len -= pr[Z * 2 + 1]);
          for (Tt.max_code = ni, Je = Te.heap_len >> 1; Je >= 1; Je--)
            he(Te, Gt, Je);
          Z = tr;
          do
            Je = Te.heap[
              1
              /*SMALLEST*/
            ], Te.heap[
              1
              /*SMALLEST*/
            ] = Te.heap[Te.heap_len--], he(
              Te,
              Gt,
              1
              /*SMALLEST*/
            ), wr = Te.heap[
              1
              /*SMALLEST*/
            ], Te.heap[--Te.heap_max] = Je, Te.heap[--Te.heap_max] = wr, Gt[Z * 2] = Gt[Je * 2] + Gt[wr * 2], Te.depth[Z] = (Te.depth[Je] >= Te.depth[wr] ? Te.depth[Je] : Te.depth[wr]) + 1, Gt[Je * 2 + 1] = Gt[wr * 2 + 1] = Z, Te.heap[
              1
              /*SMALLEST*/
            ] = Z++, he(
              Te,
              Gt,
              1
              /*SMALLEST*/
            );
          while (Te.heap_len >= 2);
          Te.heap[--Te.heap_max] = Te.heap[
            1
            /*SMALLEST*/
          ], rt(Te, Tt), it(Gt, ni, Te.bl_count);
        }
        function bt(Te, Tt, Gt) {
          var pr, kt = -1, tr, Je = Tt[0 * 2 + 1], wr = 0, ni = 7, Z = 4;
          for (Je === 0 && (ni = 138, Z = 3), Tt[(Gt + 1) * 2 + 1] = 65535, pr = 0; pr <= Gt; pr++)
            tr = Je, Je = Tt[(pr + 1) * 2 + 1], !(++wr < ni && tr === Je) && (wr < Z ? Te.bl_tree[tr * 2] += wr : tr !== 0 ? (tr !== kt && Te.bl_tree[tr * 2]++, Te.bl_tree[re * 2]++) : wr <= 10 ? Te.bl_tree[se * 2]++ : Te.bl_tree[ve * 2]++, wr = 0, kt = tr, Je === 0 ? (ni = 138, Z = 3) : tr === Je ? (ni = 6, Z = 3) : (ni = 7, Z = 4));
        }
        function Wt(Te, Tt, Gt) {
          var pr, kt = -1, tr, Je = Tt[0 * 2 + 1], wr = 0, ni = 7, Z = 4;
          for (Je === 0 && (ni = 138, Z = 3), pr = 0; pr <= Gt; pr++)
            if (tr = Je, Je = Tt[(pr + 1) * 2 + 1], !(++wr < ni && tr === Je)) {
              if (wr < Z)
                do
                  vt(Te, tr, Te.bl_tree);
                while (--wr !== 0);
              else tr !== 0 ? (tr !== kt && (vt(Te, tr, Te.bl_tree), wr--), vt(Te, re, Te.bl_tree), Xt(Te, wr - 3, 2)) : wr <= 10 ? (vt(Te, se, Te.bl_tree), Xt(Te, wr - 3, 3)) : (vt(Te, ve, Te.bl_tree), Xt(Te, wr - 11, 7));
              wr = 0, kt = tr, Je === 0 ? (ni = 138, Z = 3) : tr === Je ? (ni = 6, Z = 3) : (ni = 7, Z = 4);
            }
        }
        function Qt(Te) {
          var Tt;
          for (bt(Te, Te.dyn_ltree, Te.l_desc.max_code), bt(Te, Te.dyn_dtree, Te.d_desc.max_code), Xe(Te, Te.bl_desc), Tt = N - 1; Tt >= 3 && Te.bl_tree[xe[Tt] * 2 + 1] === 0; Tt--)
            ;
          return Te.opt_len += 3 * (Tt + 1) + 5 + 5 + 4, Tt;
        }
        function Sr(Te, Tt, Gt, pr) {
          var kt;
          for (Xt(Te, Tt - 257, 5), Xt(Te, Gt - 1, 5), Xt(Te, pr - 4, 4), kt = 0; kt < pr; kt++)
            Xt(Te, Te.bl_tree[xe[kt] * 2 + 1], 3);
          Wt(Te, Te.dyn_ltree, Tt - 1), Wt(Te, Te.dyn_dtree, Gt - 1);
        }
        function Fr(Te) {
          var Tt = 4093624447, Gt;
          for (Gt = 0; Gt <= 31; Gt++, Tt >>>= 1)
            if (Tt & 1 && Te.dyn_ltree[Gt * 2] !== 0)
              return F;
          if (Te.dyn_ltree[9 * 2] !== 0 || Te.dyn_ltree[10 * 2] !== 0 || Te.dyn_ltree[13 * 2] !== 0)
            return H;
          for (Gt = 32; Gt < C; Gt++)
            if (Te.dyn_ltree[Gt * 2] !== 0)
              return H;
          return F;
        }
        var kr = !1;
        function Ur(Te) {
          kr || (Ae(), kr = !0), Te.l_desc = new wt(Te.dyn_ltree, Fe), Te.d_desc = new wt(Te.dyn_dtree, $e), Te.bl_desc = new wt(Te.bl_tree, ct), Te.bi_buf = 0, Te.bi_valid = 0, _e(Te);
        }
        function Rr(Te, Tt, Gt, pr) {
          Xt(Te, (E << 1) + (pr ? 1 : 0), 3), We(Te, Tt, Gt);
        }
        function Pr(Te) {
          Xt(Te, x << 1, 3), vt(Te, Y, de), qe(Te);
        }
        function hi(Te, Tt, Gt, pr) {
          var kt, tr, Je = 0;
          Te.level > 0 ? (Te.strm.data_type === P && (Te.strm.data_type = Fr(Te)), Xe(Te, Te.l_desc), Xe(Te, Te.d_desc), Je = Qt(Te), kt = Te.opt_len + 3 + 7 >>> 3, tr = Te.static_len + 3 + 7 >>> 3, tr <= kt && (kt = tr)) : kt = tr = Gt + 5, Gt + 4 <= kt && Tt !== -1 ? Rr(Te, Tt, Gt, pr) : Te.strategy === r || tr === kt ? (Xt(Te, (x << 1) + (pr ? 1 : 0), 3), ie(Te, de, De)) : (Xt(Te, (m << 1) + (pr ? 1 : 0), 3), Sr(Te, Te.l_desc.max_code + 1, Te.d_desc.max_code + 1, Je + 1), ie(Te, Te.dyn_ltree, Te.dyn_dtree)), _e(Te), pr && fe(Te);
        }
        function Vr(Te, Tt, Gt) {
          return Te.pending_buf[Te.d_buf + Te.last_lit * 2] = Tt >>> 8 & 255, Te.pending_buf[Te.d_buf + Te.last_lit * 2 + 1] = Tt & 255, Te.pending_buf[Te.l_buf + Te.last_lit] = Gt & 255, Te.last_lit++, Tt === 0 ? Te.dyn_ltree[Gt * 2]++ : (Te.matches++, Tt--, Te.dyn_ltree[(Ze[Gt] + C + 1) * 2]++, Te.dyn_dtree[Oe(Tt) * 2]++), Te.last_lit === Te.lit_bufsize - 1;
        }
        $._tr_init = Ur, $._tr_stored_block = Rr, $._tr_flush_block = hi, $._tr_tally = Vr, $._tr_align = Pr;
      }, { "../utils/common": 36 }], 46: [function(te, Ee, $) {
        function Q() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        }
        Ee.exports = Q;
      }, {}], 47: [function(te, Ee, $) {
        arguments[4][33][0].apply($, arguments);
      }, { dup: 33 }], 48: [function(te, Ee, $) {
        (function(x) {
          var r = te("base64-js"), F = te("ieee754"), H = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
          $.Buffer = x, $.SlowBuffer = V, $.INSPECT_MAX_BYTES = 50;
          var P = 2147483647;
          $.kMaxLength = P, x.TYPED_ARRAY_SUPPORT = M(), !x.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          );
          function M() {
            try {
              var Pe = new Uint8Array(1), he = { foo: function() {
                return 42;
              } };
              return Object.setPrototypeOf(he, Uint8Array.prototype), Object.setPrototypeOf(Pe, he), Pe.foo() === 42;
            } catch {
              return !1;
            }
          }
          Object.defineProperty(x.prototype, "parent", {
            enumerable: !0,
            get: function() {
              if (x.isBuffer(this))
                return this.buffer;
            }
          }), Object.defineProperty(x.prototype, "offset", {
            enumerable: !0,
            get: function() {
              if (x.isBuffer(this))
                return this.byteOffset;
            }
          });
          function E(Pe) {
            if (Pe > P)
              throw new RangeError('The value "' + Pe + '" is invalid for option "size"');
            var he = new Uint8Array(Pe);
            return Object.setPrototypeOf(he, x.prototype), he;
          }
          function x(Pe, he, ie) {
            if (typeof Pe == "number") {
              if (typeof he == "string")
                throw new TypeError(
                  'The "string" argument must be of type string. Received type number'
                );
              return w(Pe);
            }
            return m(Pe, he, ie);
          }
          typeof Symbol < "u" && Symbol.species != null && x[Symbol.species] === x && Object.defineProperty(x, Symbol.species, {
            value: null,
            configurable: !0,
            enumerable: !1,
            writable: !1
          }), x.poolSize = 8192;
          function m(Pe, he, ie) {
            if (typeof Pe == "string")
              return C(Pe, he);
            if (ArrayBuffer.isView(Pe))
              return b(Pe);
            if (Pe == null)
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Pe
              );
            if (_e(Pe, ArrayBuffer) || Pe && _e(Pe.buffer, ArrayBuffer))
              return B(Pe, he, ie);
            if (typeof Pe == "number")
              throw new TypeError(
                'The "value" argument must not be of type number. Received type number'
              );
            var Xe = Pe.valueOf && Pe.valueOf();
            if (Xe != null && Xe !== Pe)
              return x.from(Xe, he, ie);
            var bt = N(Pe);
            if (bt) return bt;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Pe[Symbol.toPrimitive] == "function")
              return x.from(
                Pe[Symbol.toPrimitive]("string"),
                he,
                ie
              );
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Pe
            );
          }
          x.from = function(Pe, he, ie) {
            return m(Pe, he, ie);
          }, Object.setPrototypeOf(x.prototype, Uint8Array.prototype), Object.setPrototypeOf(x, Uint8Array);
          function I(Pe) {
            if (typeof Pe != "number")
              throw new TypeError('"size" argument must be of type number');
            if (Pe < 0)
              throw new RangeError('The value "' + Pe + '" is invalid for option "size"');
          }
          function z(Pe, he, ie) {
            return I(Pe), Pe <= 0 ? E(Pe) : he !== void 0 ? typeof ie == "string" ? E(Pe).fill(he, ie) : E(Pe).fill(he) : E(Pe);
          }
          x.alloc = function(Pe, he, ie) {
            return z(Pe, he, ie);
          };
          function w(Pe) {
            return I(Pe), E(Pe < 0 ? 0 : U(Pe) | 0);
          }
          x.allocUnsafe = function(Pe) {
            return w(Pe);
          }, x.allocUnsafeSlow = function(Pe) {
            return w(Pe);
          };
          function C(Pe, he) {
            if ((typeof he != "string" || he === "") && (he = "utf8"), !x.isEncoding(he))
              throw new TypeError("Unknown encoding: " + he);
            var ie = W(Pe, he) | 0, Xe = E(ie), bt = Xe.write(Pe, he);
            return bt !== ie && (Xe = Xe.slice(0, bt)), Xe;
          }
          function b(Pe) {
            for (var he = Pe.length < 0 ? 0 : U(Pe.length) | 0, ie = E(he), Xe = 0; Xe < he; Xe += 1)
              ie[Xe] = Pe[Xe] & 255;
            return ie;
          }
          function B(Pe, he, ie) {
            if (he < 0 || Pe.byteLength < he)
              throw new RangeError('"offset" is outside of buffer bounds');
            if (Pe.byteLength < he + (ie || 0))
              throw new RangeError('"length" is outside of buffer bounds');
            var Xe;
            return he === void 0 && ie === void 0 ? Xe = new Uint8Array(Pe) : ie === void 0 ? Xe = new Uint8Array(Pe, he) : Xe = new Uint8Array(Pe, he, ie), Object.setPrototypeOf(Xe, x.prototype), Xe;
          }
          function N(Pe) {
            if (x.isBuffer(Pe)) {
              var he = U(Pe.length) | 0, ie = E(he);
              return ie.length === 0 || Pe.copy(ie, 0, 0, he), ie;
            }
            if (Pe.length !== void 0)
              return typeof Pe.length != "number" || fe(Pe.length) ? E(0) : b(Pe);
            if (Pe.type === "Buffer" && Array.isArray(Pe.data))
              return b(Pe.data);
          }
          function U(Pe) {
            if (Pe >= P)
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + P.toString(16) + " bytes");
            return Pe | 0;
          }
          function V(Pe) {
            return +Pe != Pe && (Pe = 0), x.alloc(+Pe);
          }
          x.isBuffer = function(he) {
            return he != null && he._isBuffer === !0 && he !== x.prototype;
          }, x.compare = function(he, ie) {
            if (_e(he, Uint8Array) && (he = x.from(he, he.offset, he.byteLength)), _e(ie, Uint8Array) && (ie = x.from(ie, ie.offset, ie.byteLength)), !x.isBuffer(he) || !x.isBuffer(ie))
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
              );
            if (he === ie) return 0;
            for (var Xe = he.length, bt = ie.length, Wt = 0, Qt = Math.min(Xe, bt); Wt < Qt; ++Wt)
              if (he[Wt] !== ie[Wt]) {
                Xe = he[Wt], bt = ie[Wt];
                break;
              }
            return Xe < bt ? -1 : bt < Xe ? 1 : 0;
          }, x.isEncoding = function(he) {
            switch (String(he).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, x.concat = function(he, ie) {
            if (!Array.isArray(he))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (he.length === 0)
              return x.alloc(0);
            var Xe;
            if (ie === void 0)
              for (ie = 0, Xe = 0; Xe < he.length; ++Xe)
                ie += he[Xe].length;
            var bt = x.allocUnsafe(ie), Wt = 0;
            for (Xe = 0; Xe < he.length; ++Xe) {
              var Qt = he[Xe];
              if (_e(Qt, Uint8Array) && (Qt = x.from(Qt)), !x.isBuffer(Qt))
                throw new TypeError('"list" argument must be an Array of Buffers');
              Qt.copy(bt, Wt), Wt += Qt.length;
            }
            return bt;
          };
          function W(Pe, he) {
            if (x.isBuffer(Pe))
              return Pe.length;
            if (ArrayBuffer.isView(Pe) || _e(Pe, ArrayBuffer))
              return Pe.byteLength;
            if (typeof Pe != "string")
              throw new TypeError(
                'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Pe
              );
            var ie = Pe.length, Xe = arguments.length > 2 && arguments[2] === !0;
            if (!Xe && ie === 0) return 0;
            for (var bt = !1; ; )
              switch (he) {
                case "ascii":
                case "latin1":
                case "binary":
                  return ie;
                case "utf8":
                case "utf-8":
                  return Ye(Pe).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ie * 2;
                case "hex":
                  return ie >>> 1;
                case "base64":
                  return it(Pe).length;
                default:
                  if (bt)
                    return Xe ? -1 : Ye(Pe).length;
                  he = ("" + he).toLowerCase(), bt = !0;
              }
          }
          x.byteLength = W;
          function q(Pe, he, ie) {
            var Xe = !1;
            if ((he === void 0 || he < 0) && (he = 0), he > this.length || ((ie === void 0 || ie > this.length) && (ie = this.length), ie <= 0) || (ie >>>= 0, he >>>= 0, ie <= he))
              return "";
            for (Pe || (Pe = "utf8"); ; )
              switch (Pe) {
                case "hex":
                  return je(this, he, ie);
                case "utf8":
                case "utf-8":
                  return De(this, he, ie);
                case "ascii":
                  return Ue(this, he, ie);
                case "latin1":
                case "binary":
                  return Ie(this, he, ie);
                case "base64":
                  return de(this, he, ie);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return Fe(this, he, ie);
                default:
                  if (Xe) throw new TypeError("Unknown encoding: " + Pe);
                  Pe = (Pe + "").toLowerCase(), Xe = !0;
              }
          }
          x.prototype._isBuffer = !0;
          function Y(Pe, he, ie) {
            var Xe = Pe[he];
            Pe[he] = Pe[ie], Pe[ie] = Xe;
          }
          x.prototype.swap16 = function() {
            var he = this.length;
            if (he % 2 !== 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var ie = 0; ie < he; ie += 2)
              Y(this, ie, ie + 1);
            return this;
          }, x.prototype.swap32 = function() {
            var he = this.length;
            if (he % 4 !== 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var ie = 0; ie < he; ie += 4)
              Y(this, ie, ie + 3), Y(this, ie + 1, ie + 2);
            return this;
          }, x.prototype.swap64 = function() {
            var he = this.length;
            if (he % 8 !== 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var ie = 0; ie < he; ie += 8)
              Y(this, ie, ie + 7), Y(this, ie + 1, ie + 6), Y(this, ie + 2, ie + 5), Y(this, ie + 3, ie + 4);
            return this;
          }, x.prototype.toString = function() {
            var he = this.length;
            return he === 0 ? "" : arguments.length === 0 ? De(this, 0, he) : q.apply(this, arguments);
          }, x.prototype.toLocaleString = x.prototype.toString, x.prototype.equals = function(he) {
            if (!x.isBuffer(he)) throw new TypeError("Argument must be a Buffer");
            return this === he ? !0 : x.compare(this, he) === 0;
          }, x.prototype.inspect = function() {
            var he = "", ie = $.INSPECT_MAX_BYTES;
            return he = this.toString("hex", 0, ie).replace(/(.{2})/g, "$1 ").trim(), this.length > ie && (he += " ... "), "<Buffer " + he + ">";
          }, H && (x.prototype[H] = x.prototype.inspect), x.prototype.compare = function(he, ie, Xe, bt, Wt) {
            if (_e(he, Uint8Array) && (he = x.from(he, he.offset, he.byteLength)), !x.isBuffer(he))
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof he
              );
            if (ie === void 0 && (ie = 0), Xe === void 0 && (Xe = he ? he.length : 0), bt === void 0 && (bt = 0), Wt === void 0 && (Wt = this.length), ie < 0 || Xe > he.length || bt < 0 || Wt > this.length)
              throw new RangeError("out of range index");
            if (bt >= Wt && ie >= Xe)
              return 0;
            if (bt >= Wt)
              return -1;
            if (ie >= Xe)
              return 1;
            if (ie >>>= 0, Xe >>>= 0, bt >>>= 0, Wt >>>= 0, this === he) return 0;
            for (var Qt = Wt - bt, Sr = Xe - ie, Fr = Math.min(Qt, Sr), kr = this.slice(bt, Wt), Ur = he.slice(ie, Xe), Rr = 0; Rr < Fr; ++Rr)
              if (kr[Rr] !== Ur[Rr]) {
                Qt = kr[Rr], Sr = Ur[Rr];
                break;
              }
            return Qt < Sr ? -1 : Sr < Qt ? 1 : 0;
          };
          function re(Pe, he, ie, Xe, bt) {
            if (Pe.length === 0) return -1;
            if (typeof ie == "string" ? (Xe = ie, ie = 0) : ie > 2147483647 ? ie = 2147483647 : ie < -2147483648 && (ie = -2147483648), ie = +ie, fe(ie) && (ie = bt ? 0 : Pe.length - 1), ie < 0 && (ie = Pe.length + ie), ie >= Pe.length) {
              if (bt) return -1;
              ie = Pe.length - 1;
            } else if (ie < 0)
              if (bt) ie = 0;
              else return -1;
            if (typeof he == "string" && (he = x.from(he, Xe)), x.isBuffer(he))
              return he.length === 0 ? -1 : se(Pe, he, ie, Xe, bt);
            if (typeof he == "number")
              return he = he & 255, typeof Uint8Array.prototype.indexOf == "function" ? bt ? Uint8Array.prototype.indexOf.call(Pe, he, ie) : Uint8Array.prototype.lastIndexOf.call(Pe, he, ie) : se(Pe, [he], ie, Xe, bt);
            throw new TypeError("val must be string, number or Buffer");
          }
          function se(Pe, he, ie, Xe, bt) {
            var Wt = 1, Qt = Pe.length, Sr = he.length;
            if (Xe !== void 0 && (Xe = String(Xe).toLowerCase(), Xe === "ucs2" || Xe === "ucs-2" || Xe === "utf16le" || Xe === "utf-16le")) {
              if (Pe.length < 2 || he.length < 2)
                return -1;
              Wt = 2, Qt /= 2, Sr /= 2, ie /= 2;
            }
            function Fr(hi, Vr) {
              return Wt === 1 ? hi[Vr] : hi.readUInt16BE(Vr * Wt);
            }
            var kr;
            if (bt) {
              var Ur = -1;
              for (kr = ie; kr < Qt; kr++)
                if (Fr(Pe, kr) === Fr(he, Ur === -1 ? 0 : kr - Ur)) {
                  if (Ur === -1 && (Ur = kr), kr - Ur + 1 === Sr) return Ur * Wt;
                } else
                  Ur !== -1 && (kr -= kr - Ur), Ur = -1;
            } else
              for (ie + Sr > Qt && (ie = Qt - Sr), kr = ie; kr >= 0; kr--) {
                for (var Rr = !0, Pr = 0; Pr < Sr; Pr++)
                  if (Fr(Pe, kr + Pr) !== Fr(he, Pr)) {
                    Rr = !1;
                    break;
                  }
                if (Rr) return kr;
              }
            return -1;
          }
          x.prototype.includes = function(he, ie, Xe) {
            return this.indexOf(he, ie, Xe) !== -1;
          }, x.prototype.indexOf = function(he, ie, Xe) {
            return re(this, he, ie, Xe, !0);
          }, x.prototype.lastIndexOf = function(he, ie, Xe) {
            return re(this, he, ie, Xe, !1);
          };
          function ve(Pe, he, ie, Xe) {
            ie = Number(ie) || 0;
            var bt = Pe.length - ie;
            Xe ? (Xe = Number(Xe), Xe > bt && (Xe = bt)) : Xe = bt;
            var Wt = he.length;
            Xe > Wt / 2 && (Xe = Wt / 2);
            for (var Qt = 0; Qt < Xe; ++Qt) {
              var Sr = parseInt(he.substr(Qt * 2, 2), 16);
              if (fe(Sr)) return Qt;
              Pe[ie + Qt] = Sr;
            }
            return Qt;
          }
          function ce(Pe, he, ie, Xe) {
            return Ae(Ye(he, Pe.length - ie), Pe, ie, Xe);
          }
          function be(Pe, he, ie, Xe) {
            return Ae(qe(he), Pe, ie, Xe);
          }
          function Me(Pe, he, ie, Xe) {
            return be(Pe, he, ie, Xe);
          }
          function xe(Pe, he, ie, Xe) {
            return Ae(it(he), Pe, ie, Xe);
          }
          function le(Pe, he, ie, Xe) {
            return Ae(rt(he, Pe.length - ie), Pe, ie, Xe);
          }
          x.prototype.write = function(he, ie, Xe, bt) {
            if (ie === void 0)
              bt = "utf8", Xe = this.length, ie = 0;
            else if (Xe === void 0 && typeof ie == "string")
              bt = ie, Xe = this.length, ie = 0;
            else if (isFinite(ie))
              ie = ie >>> 0, isFinite(Xe) ? (Xe = Xe >>> 0, bt === void 0 && (bt = "utf8")) : (bt = Xe, Xe = void 0);
            else
              throw new Error(
                "Buffer.write(string, encoding, offset[, length]) is no longer supported"
              );
            var Wt = this.length - ie;
            if ((Xe === void 0 || Xe > Wt) && (Xe = Wt), he.length > 0 && (Xe < 0 || ie < 0) || ie > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            bt || (bt = "utf8");
            for (var Qt = !1; ; )
              switch (bt) {
                case "hex":
                  return ve(this, he, ie, Xe);
                case "utf8":
                case "utf-8":
                  return ce(this, he, ie, Xe);
                case "ascii":
                  return be(this, he, ie, Xe);
                case "latin1":
                case "binary":
                  return Me(this, he, ie, Xe);
                case "base64":
                  return xe(this, he, ie, Xe);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return le(this, he, ie, Xe);
                default:
                  if (Qt) throw new TypeError("Unknown encoding: " + bt);
                  bt = ("" + bt).toLowerCase(), Qt = !0;
              }
          }, x.prototype.toJSON = function() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function de(Pe, he, ie) {
            return he === 0 && ie === Pe.length ? r.fromByteArray(Pe) : r.fromByteArray(Pe.slice(he, ie));
          }
          function De(Pe, he, ie) {
            ie = Math.min(Pe.length, ie);
            for (var Xe = [], bt = he; bt < ie; ) {
              var Wt = Pe[bt], Qt = null, Sr = Wt > 239 ? 4 : Wt > 223 ? 3 : Wt > 191 ? 2 : 1;
              if (bt + Sr <= ie) {
                var Fr, kr, Ur, Rr;
                switch (Sr) {
                  case 1:
                    Wt < 128 && (Qt = Wt);
                    break;
                  case 2:
                    Fr = Pe[bt + 1], (Fr & 192) === 128 && (Rr = (Wt & 31) << 6 | Fr & 63, Rr > 127 && (Qt = Rr));
                    break;
                  case 3:
                    Fr = Pe[bt + 1], kr = Pe[bt + 2], (Fr & 192) === 128 && (kr & 192) === 128 && (Rr = (Wt & 15) << 12 | (Fr & 63) << 6 | kr & 63, Rr > 2047 && (Rr < 55296 || Rr > 57343) && (Qt = Rr));
                    break;
                  case 4:
                    Fr = Pe[bt + 1], kr = Pe[bt + 2], Ur = Pe[bt + 3], (Fr & 192) === 128 && (kr & 192) === 128 && (Ur & 192) === 128 && (Rr = (Wt & 15) << 18 | (Fr & 63) << 12 | (kr & 63) << 6 | Ur & 63, Rr > 65535 && Rr < 1114112 && (Qt = Rr));
                }
              }
              Qt === null ? (Qt = 65533, Sr = 1) : Qt > 65535 && (Qt -= 65536, Xe.push(Qt >>> 10 & 1023 | 55296), Qt = 56320 | Qt & 1023), Xe.push(Qt), bt += Sr;
            }
            return Ze(Xe);
          }
          var ze = 4096;
          function Ze(Pe) {
            var he = Pe.length;
            if (he <= ze)
              return String.fromCharCode.apply(String, Pe);
            for (var ie = "", Xe = 0; Xe < he; )
              ie += String.fromCharCode.apply(
                String,
                Pe.slice(Xe, Xe += ze)
              );
            return ie;
          }
          function Ue(Pe, he, ie) {
            var Xe = "";
            ie = Math.min(Pe.length, ie);
            for (var bt = he; bt < ie; ++bt)
              Xe += String.fromCharCode(Pe[bt] & 127);
            return Xe;
          }
          function Ie(Pe, he, ie) {
            var Xe = "";
            ie = Math.min(Pe.length, ie);
            for (var bt = he; bt < ie; ++bt)
              Xe += String.fromCharCode(Pe[bt]);
            return Xe;
          }
          function je(Pe, he, ie) {
            var Xe = Pe.length;
            (!he || he < 0) && (he = 0), (!ie || ie < 0 || ie > Xe) && (ie = Xe);
            for (var bt = "", Wt = he; Wt < ie; ++Wt)
              bt += We[Pe[Wt]];
            return bt;
          }
          function Fe(Pe, he, ie) {
            for (var Xe = Pe.slice(he, ie), bt = "", Wt = 0; Wt < Xe.length; Wt += 2)
              bt += String.fromCharCode(Xe[Wt] + Xe[Wt + 1] * 256);
            return bt;
          }
          x.prototype.slice = function(he, ie) {
            var Xe = this.length;
            he = ~~he, ie = ie === void 0 ? Xe : ~~ie, he < 0 ? (he += Xe, he < 0 && (he = 0)) : he > Xe && (he = Xe), ie < 0 ? (ie += Xe, ie < 0 && (ie = 0)) : ie > Xe && (ie = Xe), ie < he && (ie = he);
            var bt = this.subarray(he, ie);
            return Object.setPrototypeOf(bt, x.prototype), bt;
          };
          function $e(Pe, he, ie) {
            if (Pe % 1 !== 0 || Pe < 0) throw new RangeError("offset is not uint");
            if (Pe + he > ie) throw new RangeError("Trying to access beyond buffer length");
          }
          x.prototype.readUIntLE = function(he, ie, Xe) {
            he = he >>> 0, ie = ie >>> 0, Xe || $e(he, ie, this.length);
            for (var bt = this[he], Wt = 1, Qt = 0; ++Qt < ie && (Wt *= 256); )
              bt += this[he + Qt] * Wt;
            return bt;
          }, x.prototype.readUIntBE = function(he, ie, Xe) {
            he = he >>> 0, ie = ie >>> 0, Xe || $e(he, ie, this.length);
            for (var bt = this[he + --ie], Wt = 1; ie > 0 && (Wt *= 256); )
              bt += this[he + --ie] * Wt;
            return bt;
          }, x.prototype.readUInt8 = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 1, this.length), this[he];
          }, x.prototype.readUInt16LE = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 2, this.length), this[he] | this[he + 1] << 8;
          }, x.prototype.readUInt16BE = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 2, this.length), this[he] << 8 | this[he + 1];
          }, x.prototype.readUInt32LE = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 4, this.length), (this[he] | this[he + 1] << 8 | this[he + 2] << 16) + this[he + 3] * 16777216;
          }, x.prototype.readUInt32BE = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 4, this.length), this[he] * 16777216 + (this[he + 1] << 16 | this[he + 2] << 8 | this[he + 3]);
          }, x.prototype.readIntLE = function(he, ie, Xe) {
            he = he >>> 0, ie = ie >>> 0, Xe || $e(he, ie, this.length);
            for (var bt = this[he], Wt = 1, Qt = 0; ++Qt < ie && (Wt *= 256); )
              bt += this[he + Qt] * Wt;
            return Wt *= 128, bt >= Wt && (bt -= Math.pow(2, 8 * ie)), bt;
          }, x.prototype.readIntBE = function(he, ie, Xe) {
            he = he >>> 0, ie = ie >>> 0, Xe || $e(he, ie, this.length);
            for (var bt = ie, Wt = 1, Qt = this[he + --bt]; bt > 0 && (Wt *= 256); )
              Qt += this[he + --bt] * Wt;
            return Wt *= 128, Qt >= Wt && (Qt -= Math.pow(2, 8 * ie)), Qt;
          }, x.prototype.readInt8 = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 1, this.length), this[he] & 128 ? (255 - this[he] + 1) * -1 : this[he];
          }, x.prototype.readInt16LE = function(he, ie) {
            he = he >>> 0, ie || $e(he, 2, this.length);
            var Xe = this[he] | this[he + 1] << 8;
            return Xe & 32768 ? Xe | 4294901760 : Xe;
          }, x.prototype.readInt16BE = function(he, ie) {
            he = he >>> 0, ie || $e(he, 2, this.length);
            var Xe = this[he + 1] | this[he] << 8;
            return Xe & 32768 ? Xe | 4294901760 : Xe;
          }, x.prototype.readInt32LE = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 4, this.length), this[he] | this[he + 1] << 8 | this[he + 2] << 16 | this[he + 3] << 24;
          }, x.prototype.readInt32BE = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 4, this.length), this[he] << 24 | this[he + 1] << 16 | this[he + 2] << 8 | this[he + 3];
          }, x.prototype.readFloatLE = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 4, this.length), F.read(this, he, !0, 23, 4);
          }, x.prototype.readFloatBE = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 4, this.length), F.read(this, he, !1, 23, 4);
          }, x.prototype.readDoubleLE = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 8, this.length), F.read(this, he, !0, 52, 8);
          }, x.prototype.readDoubleBE = function(he, ie) {
            return he = he >>> 0, ie || $e(he, 8, this.length), F.read(this, he, !1, 52, 8);
          };
          function ct(Pe, he, ie, Xe, bt, Wt) {
            if (!x.isBuffer(Pe)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (he > bt || he < Wt) throw new RangeError('"value" argument is out of bounds');
            if (ie + Xe > Pe.length) throw new RangeError("Index out of range");
          }
          x.prototype.writeUIntLE = function(he, ie, Xe, bt) {
            if (he = +he, ie = ie >>> 0, Xe = Xe >>> 0, !bt) {
              var Wt = Math.pow(2, 8 * Xe) - 1;
              ct(this, he, ie, Xe, Wt, 0);
            }
            var Qt = 1, Sr = 0;
            for (this[ie] = he & 255; ++Sr < Xe && (Qt *= 256); )
              this[ie + Sr] = he / Qt & 255;
            return ie + Xe;
          }, x.prototype.writeUIntBE = function(he, ie, Xe, bt) {
            if (he = +he, ie = ie >>> 0, Xe = Xe >>> 0, !bt) {
              var Wt = Math.pow(2, 8 * Xe) - 1;
              ct(this, he, ie, Xe, Wt, 0);
            }
            var Qt = Xe - 1, Sr = 1;
            for (this[ie + Qt] = he & 255; --Qt >= 0 && (Sr *= 256); )
              this[ie + Qt] = he / Sr & 255;
            return ie + Xe;
          }, x.prototype.writeUInt8 = function(he, ie, Xe) {
            return he = +he, ie = ie >>> 0, Xe || ct(this, he, ie, 1, 255, 0), this[ie] = he & 255, ie + 1;
          }, x.prototype.writeUInt16LE = function(he, ie, Xe) {
            return he = +he, ie = ie >>> 0, Xe || ct(this, he, ie, 2, 65535, 0), this[ie] = he & 255, this[ie + 1] = he >>> 8, ie + 2;
          }, x.prototype.writeUInt16BE = function(he, ie, Xe) {
            return he = +he, ie = ie >>> 0, Xe || ct(this, he, ie, 2, 65535, 0), this[ie] = he >>> 8, this[ie + 1] = he & 255, ie + 2;
          }, x.prototype.writeUInt32LE = function(he, ie, Xe) {
            return he = +he, ie = ie >>> 0, Xe || ct(this, he, ie, 4, 4294967295, 0), this[ie + 3] = he >>> 24, this[ie + 2] = he >>> 16, this[ie + 1] = he >>> 8, this[ie] = he & 255, ie + 4;
          }, x.prototype.writeUInt32BE = function(he, ie, Xe) {
            return he = +he, ie = ie >>> 0, Xe || ct(this, he, ie, 4, 4294967295, 0), this[ie] = he >>> 24, this[ie + 1] = he >>> 16, this[ie + 2] = he >>> 8, this[ie + 3] = he & 255, ie + 4;
          }, x.prototype.writeIntLE = function(he, ie, Xe, bt) {
            if (he = +he, ie = ie >>> 0, !bt) {
              var Wt = Math.pow(2, 8 * Xe - 1);
              ct(this, he, ie, Xe, Wt - 1, -Wt);
            }
            var Qt = 0, Sr = 1, Fr = 0;
            for (this[ie] = he & 255; ++Qt < Xe && (Sr *= 256); )
              he < 0 && Fr === 0 && this[ie + Qt - 1] !== 0 && (Fr = 1), this[ie + Qt] = (he / Sr >> 0) - Fr & 255;
            return ie + Xe;
          }, x.prototype.writeIntBE = function(he, ie, Xe, bt) {
            if (he = +he, ie = ie >>> 0, !bt) {
              var Wt = Math.pow(2, 8 * Xe - 1);
              ct(this, he, ie, Xe, Wt - 1, -Wt);
            }
            var Qt = Xe - 1, Sr = 1, Fr = 0;
            for (this[ie + Qt] = he & 255; --Qt >= 0 && (Sr *= 256); )
              he < 0 && Fr === 0 && this[ie + Qt + 1] !== 0 && (Fr = 1), this[ie + Qt] = (he / Sr >> 0) - Fr & 255;
            return ie + Xe;
          }, x.prototype.writeInt8 = function(he, ie, Xe) {
            return he = +he, ie = ie >>> 0, Xe || ct(this, he, ie, 1, 127, -128), he < 0 && (he = 255 + he + 1), this[ie] = he & 255, ie + 1;
          }, x.prototype.writeInt16LE = function(he, ie, Xe) {
            return he = +he, ie = ie >>> 0, Xe || ct(this, he, ie, 2, 32767, -32768), this[ie] = he & 255, this[ie + 1] = he >>> 8, ie + 2;
          }, x.prototype.writeInt16BE = function(he, ie, Xe) {
            return he = +he, ie = ie >>> 0, Xe || ct(this, he, ie, 2, 32767, -32768), this[ie] = he >>> 8, this[ie + 1] = he & 255, ie + 2;
          }, x.prototype.writeInt32LE = function(he, ie, Xe) {
            return he = +he, ie = ie >>> 0, Xe || ct(this, he, ie, 4, 2147483647, -2147483648), this[ie] = he & 255, this[ie + 1] = he >>> 8, this[ie + 2] = he >>> 16, this[ie + 3] = he >>> 24, ie + 4;
          }, x.prototype.writeInt32BE = function(he, ie, Xe) {
            return he = +he, ie = ie >>> 0, Xe || ct(this, he, ie, 4, 2147483647, -2147483648), he < 0 && (he = 4294967295 + he + 1), this[ie] = he >>> 24, this[ie + 1] = he >>> 16, this[ie + 2] = he >>> 8, this[ie + 3] = he & 255, ie + 4;
          };
          function wt(Pe, he, ie, Xe, bt, Wt) {
            if (ie + Xe > Pe.length) throw new RangeError("Index out of range");
            if (ie < 0) throw new RangeError("Index out of range");
          }
          function Oe(Pe, he, ie, Xe, bt) {
            return he = +he, ie = ie >>> 0, bt || wt(Pe, he, ie, 4), F.write(Pe, he, ie, Xe, 23, 4), ie + 4;
          }
          x.prototype.writeFloatLE = function(he, ie, Xe) {
            return Oe(this, he, ie, !0, Xe);
          }, x.prototype.writeFloatBE = function(he, ie, Xe) {
            return Oe(this, he, ie, !1, Xe);
          };
          function Ct(Pe, he, ie, Xe, bt) {
            return he = +he, ie = ie >>> 0, bt || wt(Pe, he, ie, 8), F.write(Pe, he, ie, Xe, 52, 8), ie + 8;
          }
          x.prototype.writeDoubleLE = function(he, ie, Xe) {
            return Ct(this, he, ie, !0, Xe);
          }, x.prototype.writeDoubleBE = function(he, ie, Xe) {
            return Ct(this, he, ie, !1, Xe);
          }, x.prototype.copy = function(he, ie, Xe, bt) {
            if (!x.isBuffer(he)) throw new TypeError("argument should be a Buffer");
            if (Xe || (Xe = 0), !bt && bt !== 0 && (bt = this.length), ie >= he.length && (ie = he.length), ie || (ie = 0), bt > 0 && bt < Xe && (bt = Xe), bt === Xe || he.length === 0 || this.length === 0) return 0;
            if (ie < 0)
              throw new RangeError("targetStart out of bounds");
            if (Xe < 0 || Xe >= this.length) throw new RangeError("Index out of range");
            if (bt < 0) throw new RangeError("sourceEnd out of bounds");
            bt > this.length && (bt = this.length), he.length - ie < bt - Xe && (bt = he.length - ie + Xe);
            var Wt = bt - Xe;
            if (this === he && typeof Uint8Array.prototype.copyWithin == "function")
              this.copyWithin(ie, Xe, bt);
            else if (this === he && Xe < ie && ie < bt)
              for (var Qt = Wt - 1; Qt >= 0; --Qt)
                he[Qt + ie] = this[Qt + Xe];
            else
              Uint8Array.prototype.set.call(
                he,
                this.subarray(Xe, bt),
                ie
              );
            return Wt;
          }, x.prototype.fill = function(he, ie, Xe, bt) {
            if (typeof he == "string") {
              if (typeof ie == "string" ? (bt = ie, ie = 0, Xe = this.length) : typeof Xe == "string" && (bt = Xe, Xe = this.length), bt !== void 0 && typeof bt != "string")
                throw new TypeError("encoding must be a string");
              if (typeof bt == "string" && !x.isEncoding(bt))
                throw new TypeError("Unknown encoding: " + bt);
              if (he.length === 1) {
                var Wt = he.charCodeAt(0);
                (bt === "utf8" && Wt < 128 || bt === "latin1") && (he = Wt);
              }
            } else typeof he == "number" ? he = he & 255 : typeof he == "boolean" && (he = Number(he));
            if (ie < 0 || this.length < ie || this.length < Xe)
              throw new RangeError("Out of range index");
            if (Xe <= ie)
              return this;
            ie = ie >>> 0, Xe = Xe === void 0 ? this.length : Xe >>> 0, he || (he = 0);
            var Qt;
            if (typeof he == "number")
              for (Qt = ie; Qt < Xe; ++Qt)
                this[Qt] = he;
            else {
              var Sr = x.isBuffer(he) ? he : x.from(he, bt), Fr = Sr.length;
              if (Fr === 0)
                throw new TypeError('The value "' + he + '" is invalid for argument "value"');
              for (Qt = 0; Qt < Xe - ie; ++Qt)
                this[Qt + ie] = Sr[Qt % Fr];
            }
            return this;
          };
          var Xt = /[^+/0-9A-Za-z-_]/g;
          function vt(Pe) {
            if (Pe = Pe.split("=")[0], Pe = Pe.trim().replace(Xt, ""), Pe.length < 2) return "";
            for (; Pe.length % 4 !== 0; )
              Pe = Pe + "=";
            return Pe;
          }
          function Ye(Pe, he) {
            he = he || 1 / 0;
            for (var ie, Xe = Pe.length, bt = null, Wt = [], Qt = 0; Qt < Xe; ++Qt) {
              if (ie = Pe.charCodeAt(Qt), ie > 55295 && ie < 57344) {
                if (!bt) {
                  if (ie > 56319) {
                    (he -= 3) > -1 && Wt.push(239, 191, 189);
                    continue;
                  } else if (Qt + 1 === Xe) {
                    (he -= 3) > -1 && Wt.push(239, 191, 189);
                    continue;
                  }
                  bt = ie;
                  continue;
                }
                if (ie < 56320) {
                  (he -= 3) > -1 && Wt.push(239, 191, 189), bt = ie;
                  continue;
                }
                ie = (bt - 55296 << 10 | ie - 56320) + 65536;
              } else bt && (he -= 3) > -1 && Wt.push(239, 191, 189);
              if (bt = null, ie < 128) {
                if ((he -= 1) < 0) break;
                Wt.push(ie);
              } else if (ie < 2048) {
                if ((he -= 2) < 0) break;
                Wt.push(
                  ie >> 6 | 192,
                  ie & 63 | 128
                );
              } else if (ie < 65536) {
                if ((he -= 3) < 0) break;
                Wt.push(
                  ie >> 12 | 224,
                  ie >> 6 & 63 | 128,
                  ie & 63 | 128
                );
              } else if (ie < 1114112) {
                if ((he -= 4) < 0) break;
                Wt.push(
                  ie >> 18 | 240,
                  ie >> 12 & 63 | 128,
                  ie >> 6 & 63 | 128,
                  ie & 63 | 128
                );
              } else
                throw new Error("Invalid code point");
            }
            return Wt;
          }
          function qe(Pe) {
            for (var he = [], ie = 0; ie < Pe.length; ++ie)
              he.push(Pe.charCodeAt(ie) & 255);
            return he;
          }
          function rt(Pe, he) {
            for (var ie, Xe, bt, Wt = [], Qt = 0; Qt < Pe.length && !((he -= 2) < 0); ++Qt)
              ie = Pe.charCodeAt(Qt), Xe = ie >> 8, bt = ie % 256, Wt.push(bt), Wt.push(Xe);
            return Wt;
          }
          function it(Pe) {
            return r.toByteArray(vt(Pe));
          }
          function Ae(Pe, he, ie, Xe) {
            for (var bt = 0; bt < Xe && !(bt + ie >= he.length || bt >= Pe.length); ++bt)
              he[bt + ie] = Pe[bt];
            return bt;
          }
          function _e(Pe, he) {
            return Pe instanceof he || Pe != null && Pe.constructor != null && Pe.constructor.name != null && Pe.constructor.name === he.name;
          }
          function fe(Pe) {
            return Pe !== Pe;
          }
          var We = function() {
            for (var Pe = "0123456789abcdef", he = new Array(256), ie = 0; ie < 16; ++ie)
              for (var Xe = ie * 16, bt = 0; bt < 16; ++bt)
                he[Xe + bt] = Pe[ie] + Pe[bt];
            return he;
          }();
        }).call(this, te("buffer").Buffer);
      }, { "base64-js": 29, buffer: 48, ieee754: 73 }], 49: [function(te, Ee, $) {
        var Q = te("buffer").Buffer;
        Ee.exports = function(r, F) {
          if (Q.isBuffer(r) && Q.isBuffer(F)) {
            if (typeof r.equals == "function") return r.equals(F);
            if (r.length !== F.length) return !1;
            for (var H = 0; H < r.length; H++)
              if (r[H] !== F[H]) return !1;
            return !0;
          }
        };
      }, { buffer: 48 }], 50: [function(te, Ee, $) {
        Ee.exports = {
          100: "Continue",
          101: "Switching Protocols",
          102: "Processing",
          200: "OK",
          201: "Created",
          202: "Accepted",
          203: "Non-Authoritative Information",
          204: "No Content",
          205: "Reset Content",
          206: "Partial Content",
          207: "Multi-Status",
          208: "Already Reported",
          226: "IM Used",
          300: "Multiple Choices",
          301: "Moved Permanently",
          302: "Found",
          303: "See Other",
          304: "Not Modified",
          305: "Use Proxy",
          307: "Temporary Redirect",
          308: "Permanent Redirect",
          400: "Bad Request",
          401: "Unauthorized",
          402: "Payment Required",
          403: "Forbidden",
          404: "Not Found",
          405: "Method Not Allowed",
          406: "Not Acceptable",
          407: "Proxy Authentication Required",
          408: "Request Timeout",
          409: "Conflict",
          410: "Gone",
          411: "Length Required",
          412: "Precondition Failed",
          413: "Payload Too Large",
          414: "URI Too Long",
          415: "Unsupported Media Type",
          416: "Range Not Satisfiable",
          417: "Expectation Failed",
          418: "I'm a teapot",
          421: "Misdirected Request",
          422: "Unprocessable Entity",
          423: "Locked",
          424: "Failed Dependency",
          425: "Unordered Collection",
          426: "Upgrade Required",
          428: "Precondition Required",
          429: "Too Many Requests",
          431: "Request Header Fields Too Large",
          451: "Unavailable For Legal Reasons",
          500: "Internal Server Error",
          501: "Not Implemented",
          502: "Bad Gateway",
          503: "Service Unavailable",
          504: "Gateway Timeout",
          505: "HTTP Version Not Supported",
          506: "Variant Also Negotiates",
          507: "Insufficient Storage",
          508: "Loop Detected",
          509: "Bandwidth Limit Exceeded",
          510: "Not Extended",
          511: "Network Authentication Required"
        };
      }, {}], 51: [function(te, Ee, $) {
        (function(Q) {
          function r(U) {
            return Array.isArray ? Array.isArray(U) : N(U) === "[object Array]";
          }
          $.isArray = r;
          function F(U) {
            return typeof U == "boolean";
          }
          $.isBoolean = F;
          function H(U) {
            return U === null;
          }
          $.isNull = H;
          function P(U) {
            return U == null;
          }
          $.isNullOrUndefined = P;
          function M(U) {
            return typeof U == "number";
          }
          $.isNumber = M;
          function E(U) {
            return typeof U == "string";
          }
          $.isString = E;
          function x(U) {
            return typeof U == "symbol";
          }
          $.isSymbol = x;
          function m(U) {
            return U === void 0;
          }
          $.isUndefined = m;
          function I(U) {
            return N(U) === "[object RegExp]";
          }
          $.isRegExp = I;
          function z(U) {
            return typeof U == "object" && U !== null;
          }
          $.isObject = z;
          function w(U) {
            return N(U) === "[object Date]";
          }
          $.isDate = w;
          function C(U) {
            return N(U) === "[object Error]" || U instanceof Error;
          }
          $.isError = C;
          function b(U) {
            return typeof U == "function";
          }
          $.isFunction = b;
          function B(U) {
            return U === null || typeof U == "boolean" || typeof U == "number" || typeof U == "string" || typeof U == "symbol" || // ES6 symbol
            typeof U > "u";
          }
          $.isPrimitive = B, $.isBuffer = Q.isBuffer;
          function N(U) {
            return Object.prototype.toString.call(U);
          }
        }).call(this, { isBuffer: te("../../is-buffer/index.js") });
      }, { "../../is-buffer/index.js": 76 }], 52: [function(te, Ee, $) {
        var Q = Object.create || re, r = Object.keys || se, F = Function.prototype.bind || ve;
        function H() {
          (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) && (this._events = Q(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }
        Ee.exports = H, H.EventEmitter = H, H.prototype._events = void 0, H.prototype._maxListeners = void 0;
        var P = 10, M;
        try {
          var E = {};
          Object.defineProperty && Object.defineProperty(E, "x", { value: 0 }), M = E.x === 0;
        } catch {
          M = !1;
        }
        M ? Object.defineProperty(H, "defaultMaxListeners", {
          enumerable: !0,
          get: function() {
            return P;
          },
          set: function(ce) {
            if (typeof ce != "number" || ce < 0 || ce !== ce)
              throw new TypeError('"defaultMaxListeners" must be a positive number');
            P = ce;
          }
        }) : H.defaultMaxListeners = P, H.prototype.setMaxListeners = function(be) {
          if (typeof be != "number" || be < 0 || isNaN(be))
            throw new TypeError('"n" argument must be a positive number');
          return this._maxListeners = be, this;
        };
        function x(ce) {
          return ce._maxListeners === void 0 ? H.defaultMaxListeners : ce._maxListeners;
        }
        H.prototype.getMaxListeners = function() {
          return x(this);
        };
        function m(ce, be, Me) {
          if (be)
            ce.call(Me);
          else
            for (var xe = ce.length, le = q(ce, xe), de = 0; de < xe; ++de)
              le[de].call(Me);
        }
        function I(ce, be, Me, xe) {
          if (be)
            ce.call(Me, xe);
          else
            for (var le = ce.length, de = q(ce, le), De = 0; De < le; ++De)
              de[De].call(Me, xe);
        }
        function z(ce, be, Me, xe, le) {
          if (be)
            ce.call(Me, xe, le);
          else
            for (var de = ce.length, De = q(ce, de), ze = 0; ze < de; ++ze)
              De[ze].call(Me, xe, le);
        }
        function w(ce, be, Me, xe, le, de) {
          if (be)
            ce.call(Me, xe, le, de);
          else
            for (var De = ce.length, ze = q(ce, De), Ze = 0; Ze < De; ++Ze)
              ze[Ze].call(Me, xe, le, de);
        }
        function C(ce, be, Me, xe) {
          if (be)
            ce.apply(Me, xe);
          else
            for (var le = ce.length, de = q(ce, le), De = 0; De < le; ++De)
              de[De].apply(Me, xe);
        }
        H.prototype.emit = function(be) {
          var Me, xe, le, de, De, ze, Ze = be === "error";
          if (ze = this._events, ze)
            Ze = Ze && ze.error == null;
          else if (!Ze)
            return !1;
          if (Ze) {
            if (arguments.length > 1 && (Me = arguments[1]), Me instanceof Error)
              throw Me;
            var Ue = new Error('Unhandled "error" event. (' + Me + ")");
            throw Ue.context = Me, Ue;
          }
          if (xe = ze[be], !xe)
            return !1;
          var Ie = typeof xe == "function";
          switch (le = arguments.length, le) {
            // fast cases
            case 1:
              m(xe, Ie, this);
              break;
            case 2:
              I(xe, Ie, this, arguments[1]);
              break;
            case 3:
              z(xe, Ie, this, arguments[1], arguments[2]);
              break;
            case 4:
              w(xe, Ie, this, arguments[1], arguments[2], arguments[3]);
              break;
            // slower
            default:
              for (de = new Array(le - 1), De = 1; De < le; De++)
                de[De - 1] = arguments[De];
              C(xe, Ie, this, de);
          }
          return !0;
        };
        function b(ce, be, Me, xe) {
          var le, de, De;
          if (typeof Me != "function")
            throw new TypeError('"listener" argument must be a function');
          if (de = ce._events, de ? (de.newListener && (ce.emit(
            "newListener",
            be,
            Me.listener ? Me.listener : Me
          ), de = ce._events), De = de[be]) : (de = ce._events = Q(null), ce._eventsCount = 0), !De)
            De = de[be] = Me, ++ce._eventsCount;
          else if (typeof De == "function" ? De = de[be] = xe ? [Me, De] : [De, Me] : xe ? De.unshift(Me) : De.push(Me), !De.warned && (le = x(ce), le && le > 0 && De.length > le)) {
            De.warned = !0;
            var ze = new Error("Possible EventEmitter memory leak detected. " + De.length + ' "' + String(be) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
            ze.name = "MaxListenersExceededWarning", ze.emitter = ce, ze.type = be, ze.count = De.length, typeof console == "object" && console.warn && console.warn("%s: %s", ze.name, ze.message);
          }
          return ce;
        }
        H.prototype.addListener = function(be, Me) {
          return b(this, be, Me, !1);
        }, H.prototype.on = H.prototype.addListener, H.prototype.prependListener = function(be, Me) {
          return b(this, be, Me, !0);
        };
        function B() {
          if (!this.fired)
            switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length) {
              case 0:
                return this.listener.call(this.target);
              case 1:
                return this.listener.call(this.target, arguments[0]);
              case 2:
                return this.listener.call(this.target, arguments[0], arguments[1]);
              case 3:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1],
                  arguments[2]
                );
              default:
                for (var ce = new Array(arguments.length), be = 0; be < ce.length; ++be)
                  ce[be] = arguments[be];
                this.listener.apply(this.target, ce);
            }
        }
        function N(ce, be, Me) {
          var xe = { fired: !1, wrapFn: void 0, target: ce, type: be, listener: Me }, le = F.call(B, xe);
          return le.listener = Me, xe.wrapFn = le, le;
        }
        H.prototype.once = function(be, Me) {
          if (typeof Me != "function")
            throw new TypeError('"listener" argument must be a function');
          return this.on(be, N(this, be, Me)), this;
        }, H.prototype.prependOnceListener = function(be, Me) {
          if (typeof Me != "function")
            throw new TypeError('"listener" argument must be a function');
          return this.prependListener(be, N(this, be, Me)), this;
        }, H.prototype.removeListener = function(be, Me) {
          var xe, le, de, De, ze;
          if (typeof Me != "function")
            throw new TypeError('"listener" argument must be a function');
          if (le = this._events, !le)
            return this;
          if (xe = le[be], !xe)
            return this;
          if (xe === Me || xe.listener === Me)
            --this._eventsCount === 0 ? this._events = Q(null) : (delete le[be], le.removeListener && this.emit("removeListener", be, xe.listener || Me));
          else if (typeof xe != "function") {
            for (de = -1, De = xe.length - 1; De >= 0; De--)
              if (xe[De] === Me || xe[De].listener === Me) {
                ze = xe[De].listener, de = De;
                break;
              }
            if (de < 0)
              return this;
            de === 0 ? xe.shift() : W(xe, de), xe.length === 1 && (le[be] = xe[0]), le.removeListener && this.emit("removeListener", be, ze || Me);
          }
          return this;
        }, H.prototype.removeAllListeners = function(be) {
          var Me, xe, le;
          if (xe = this._events, !xe)
            return this;
          if (!xe.removeListener)
            return arguments.length === 0 ? (this._events = Q(null), this._eventsCount = 0) : xe[be] && (--this._eventsCount === 0 ? this._events = Q(null) : delete xe[be]), this;
          if (arguments.length === 0) {
            var de = r(xe), De;
            for (le = 0; le < de.length; ++le)
              De = de[le], De !== "removeListener" && this.removeAllListeners(De);
            return this.removeAllListeners("removeListener"), this._events = Q(null), this._eventsCount = 0, this;
          }
          if (Me = xe[be], typeof Me == "function")
            this.removeListener(be, Me);
          else if (Me)
            for (le = Me.length - 1; le >= 0; le--)
              this.removeListener(be, Me[le]);
          return this;
        };
        function U(ce, be, Me) {
          var xe = ce._events;
          if (!xe)
            return [];
          var le = xe[be];
          return le ? typeof le == "function" ? Me ? [le.listener || le] : [le] : Me ? Y(le) : q(le, le.length) : [];
        }
        H.prototype.listeners = function(be) {
          return U(this, be, !0);
        }, H.prototype.rawListeners = function(be) {
          return U(this, be, !1);
        }, H.listenerCount = function(ce, be) {
          return typeof ce.listenerCount == "function" ? ce.listenerCount(be) : V.call(ce, be);
        }, H.prototype.listenerCount = V;
        function V(ce) {
          var be = this._events;
          if (be) {
            var Me = be[ce];
            if (typeof Me == "function")
              return 1;
            if (Me)
              return Me.length;
          }
          return 0;
        }
        H.prototype.eventNames = function() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };
        function W(ce, be) {
          for (var Me = be, xe = Me + 1, le = ce.length; xe < le; Me += 1, xe += 1)
            ce[Me] = ce[xe];
          ce.pop();
        }
        function q(ce, be) {
          for (var Me = new Array(be), xe = 0; xe < be; ++xe)
            Me[xe] = ce[xe];
          return Me;
        }
        function Y(ce) {
          for (var be = new Array(ce.length), Me = 0; Me < be.length; ++Me)
            be[Me] = ce[Me].listener || ce[Me];
          return be;
        }
        function re(ce) {
          var be = function() {
          };
          return be.prototype = ce, new be();
        }
        function se(ce) {
          for (var be in ce) Object.prototype.hasOwnProperty.call(ce, be);
          return be;
        }
        function ve(ce) {
          var be = this;
          return function() {
            return be.apply(ce, arguments);
          };
        }
      }, {}], 53: [function(te, Ee, $) {
        var Q = te("./lib/parser");
        function r() {
          return (0, eval)("this");
        }
        Ee.exports = {
          create: function(F, H) {
            if (H = H || r(), F instanceof H.ArrayBuffer) {
              var P = te("./lib/dom-bufferstream");
              return new Q(new P(F, 0, F.byteLength, !0, H));
            } else {
              var M = te("./lib/bufferstream");
              return new Q(new M(F, 0, F.length, !0));
            }
          }
        };
      }, { "./lib/bufferstream": 54, "./lib/dom-bufferstream": 56, "./lib/parser": 60 }], 54: [function(te, Ee, $) {
        function Q(r, F, H, P) {
          this.buffer = r, this.offset = F || 0, H = typeof H == "number" ? H : r.length, this.endPosition = this.offset + H, this.setBigEndian(P);
        }
        Q.prototype = {
          setBigEndian: function(r) {
            this.bigEndian = !!r;
          },
          nextUInt8: function() {
            var r = this.buffer.readUInt8(this.offset);
            return this.offset += 1, r;
          },
          nextInt8: function() {
            var r = this.buffer.readInt8(this.offset);
            return this.offset += 1, r;
          },
          nextUInt16: function() {
            var r = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
            return this.offset += 2, r;
          },
          nextUInt32: function() {
            var r = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
            return this.offset += 4, r;
          },
          nextInt16: function() {
            var r = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
            return this.offset += 2, r;
          },
          nextInt32: function() {
            var r = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
            return this.offset += 4, r;
          },
          nextFloat: function() {
            var r = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
            return this.offset += 4, r;
          },
          nextDouble: function() {
            var r = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
            return this.offset += 8, r;
          },
          nextBuffer: function(r) {
            var F = this.buffer.slice(this.offset, this.offset + r);
            return this.offset += r, F;
          },
          remainingLength: function() {
            return this.endPosition - this.offset;
          },
          nextString: function(r) {
            var F = this.buffer.toString("utf8", this.offset, this.offset + r);
            return this.offset += r, F;
          },
          mark: function() {
            var r = this;
            return {
              openWithOffset: function(F) {
                return F = (F || 0) + this.offset, new Q(r.buffer, F, r.endPosition - F, r.bigEndian);
              },
              offset: this.offset
            };
          },
          offsetFrom: function(r) {
            return this.offset - r.offset;
          },
          skip: function(r) {
            this.offset += r;
          },
          branch: function(r, F) {
            return F = typeof F == "number" ? F : this.endPosition - (this.offset + r), new Q(this.buffer, this.offset + r, F, this.bigEndian);
          }
        }, Ee.exports = Q;
      }, {}], 55: [function(te, Ee, $) {
        function Q(x) {
          return parseInt(x, 10);
        }
        var r = 3600, F = 60;
        function H(x, m) {
          x = x.map(Q), m = m.map(Q);
          var I = x[0], z = x[1] - 1, w = x[2], C = m[0], b = m[1], B = m[2], N = Date.UTC(I, z, w, C, b, B, 0), U = N / 1e3;
          return U;
        }
        function P(x) {
          var m = x.substr(0, 10).split("-"), I = x.substr(11, 8).split(":"), z = x.substr(19, 6), w = z.split(":").map(Q), C = w[0] * r + w[1] * F, b = H(m, I);
          if (b -= C, typeof b == "number" && !isNaN(b))
            return b;
        }
        function M(x) {
          var m = x.split(" "), I = m[0].split(":"), z = m[1].split(":"), w = H(I, z);
          if (typeof w == "number" && !isNaN(w))
            return w;
        }
        function E(x) {
          var m = x.length === 19 && x.charAt(4) === ":", I = x.length === 25 && x.charAt(10) === "T";
          if (I)
            return P(x);
          if (m)
            return M(x);
        }
        Ee.exports = {
          parseDateWithSpecFormat: M,
          parseDateWithTimezoneFormat: P,
          parseExifDate: E
        };
      }, {}], 56: [function(te, Ee, $) {
        function Q(r, F, H, P, M, E) {
          this.global = M, F = F || 0, H = H || r.byteLength - F, this.arrayBuffer = r.slice(F, F + H), this.view = new M.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength), this.setBigEndian(P), this.offset = 0, this.parentOffset = (E || 0) + F;
        }
        Q.prototype = {
          setBigEndian: function(r) {
            this.littleEndian = !r;
          },
          nextUInt8: function() {
            var r = this.view.getUint8(this.offset);
            return this.offset += 1, r;
          },
          nextInt8: function() {
            var r = this.view.getInt8(this.offset);
            return this.offset += 1, r;
          },
          nextUInt16: function() {
            var r = this.view.getUint16(this.offset, this.littleEndian);
            return this.offset += 2, r;
          },
          nextUInt32: function() {
            var r = this.view.getUint32(this.offset, this.littleEndian);
            return this.offset += 4, r;
          },
          nextInt16: function() {
            var r = this.view.getInt16(this.offset, this.littleEndian);
            return this.offset += 2, r;
          },
          nextInt32: function() {
            var r = this.view.getInt32(this.offset, this.littleEndian);
            return this.offset += 4, r;
          },
          nextFloat: function() {
            var r = this.view.getFloat32(this.offset, this.littleEndian);
            return this.offset += 4, r;
          },
          nextDouble: function() {
            var r = this.view.getFloat64(this.offset, this.littleEndian);
            return this.offset += 8, r;
          },
          nextBuffer: function(r) {
            var F = this.arrayBuffer.slice(this.offset, this.offset + r);
            return this.offset += r, F;
          },
          remainingLength: function() {
            return this.arrayBuffer.byteLength - this.offset;
          },
          nextString: function(r) {
            var F = this.arrayBuffer.slice(this.offset, this.offset + r);
            return F = String.fromCharCode.apply(null, new this.global.Uint8Array(F)), this.offset += r, F;
          },
          mark: function() {
            var r = this;
            return {
              openWithOffset: function(F) {
                return F = (F || 0) + this.offset, new Q(r.arrayBuffer, F, r.arrayBuffer.byteLength - F, !r.littleEndian, r.global, r.parentOffset);
              },
              offset: this.offset,
              getParentOffset: function() {
                return r.parentOffset;
              }
            };
          },
          offsetFrom: function(r) {
            return this.parentOffset + this.offset - (r.offset + r.getParentOffset());
          },
          skip: function(r) {
            this.offset += r;
          },
          branch: function(r, F) {
            return F = typeof F == "number" ? F : this.arrayBuffer.byteLength - (this.offset + r), new Q(this.arrayBuffer, this.offset + r, F, !this.littleEndian, this.global, this.parentOffset);
          }
        }, Ee.exports = Q;
      }, {}], 57: [function(te, Ee, $) {
        Ee.exports = {
          exif: {
            1: "InteropIndex",
            2: "InteropVersion",
            11: "ProcessingSoftware",
            254: "SubfileType",
            255: "OldSubfileType",
            256: "ImageWidth",
            257: "ImageHeight",
            258: "BitsPerSample",
            259: "Compression",
            262: "PhotometricInterpretation",
            263: "Thresholding",
            264: "CellWidth",
            265: "CellLength",
            266: "FillOrder",
            269: "DocumentName",
            270: "ImageDescription",
            271: "Make",
            272: "Model",
            273: "StripOffsets",
            274: "Orientation",
            277: "SamplesPerPixel",
            278: "RowsPerStrip",
            279: "StripByteCounts",
            280: "MinSampleValue",
            281: "MaxSampleValue",
            282: "XResolution",
            283: "YResolution",
            284: "PlanarConfiguration",
            285: "PageName",
            286: "XPosition",
            287: "YPosition",
            288: "FreeOffsets",
            289: "FreeByteCounts",
            290: "GrayResponseUnit",
            291: "GrayResponseCurve",
            292: "T4Options",
            293: "T6Options",
            296: "ResolutionUnit",
            297: "PageNumber",
            300: "ColorResponseUnit",
            301: "TransferFunction",
            305: "Software",
            306: "ModifyDate",
            315: "Artist",
            316: "HostComputer",
            317: "Predictor",
            318: "WhitePoint",
            319: "PrimaryChromaticities",
            320: "ColorMap",
            321: "HalftoneHints",
            322: "TileWidth",
            323: "TileLength",
            324: "TileOffsets",
            325: "TileByteCounts",
            326: "BadFaxLines",
            327: "CleanFaxData",
            328: "ConsecutiveBadFaxLines",
            330: "SubIFD",
            332: "InkSet",
            333: "InkNames",
            334: "NumberofInks",
            336: "DotRange",
            337: "TargetPrinter",
            338: "ExtraSamples",
            339: "SampleFormat",
            340: "SMinSampleValue",
            341: "SMaxSampleValue",
            342: "TransferRange",
            343: "ClipPath",
            344: "XClipPathUnits",
            345: "YClipPathUnits",
            346: "Indexed",
            347: "JPEGTables",
            351: "OPIProxy",
            400: "GlobalParametersIFD",
            401: "ProfileType",
            402: "FaxProfile",
            403: "CodingMethods",
            404: "VersionYear",
            405: "ModeNumber",
            433: "Decode",
            434: "DefaultImageColor",
            435: "T82Options",
            437: "JPEGTables",
            512: "JPEGProc",
            513: "ThumbnailOffset",
            514: "ThumbnailLength",
            515: "JPEGRestartInterval",
            517: "JPEGLosslessPredictors",
            518: "JPEGPointTransforms",
            519: "JPEGQTables",
            520: "JPEGDCTables",
            521: "JPEGACTables",
            529: "YCbCrCoefficients",
            530: "YCbCrSubSampling",
            531: "YCbCrPositioning",
            532: "ReferenceBlackWhite",
            559: "StripRowCounts",
            700: "ApplicationNotes",
            999: "USPTOMiscellaneous",
            4096: "RelatedImageFileFormat",
            4097: "RelatedImageWidth",
            4098: "RelatedImageHeight",
            18246: "Rating",
            18247: "XP_DIP_XML",
            18248: "StitchInfo",
            18249: "RatingPercent",
            32781: "ImageID",
            32931: "WangTag1",
            32932: "WangAnnotation",
            32933: "WangTag3",
            32934: "WangTag4",
            32995: "Matteing",
            32996: "DataType",
            32997: "ImageDepth",
            32998: "TileDepth",
            33405: "Model2",
            33421: "CFARepeatPatternDim",
            33422: "CFAPattern2",
            33423: "BatteryLevel",
            33424: "KodakIFD",
            33432: "Copyright",
            33434: "ExposureTime",
            33437: "FNumber",
            33445: "MDFileTag",
            33446: "MDScalePixel",
            33447: "MDColorTable",
            33448: "MDLabName",
            33449: "MDSampleInfo",
            33450: "MDPrepDate",
            33451: "MDPrepTime",
            33452: "MDFileUnits",
            33550: "PixelScale",
            33589: "AdventScale",
            33590: "AdventRevision",
            33628: "UIC1Tag",
            33629: "UIC2Tag",
            33630: "UIC3Tag",
            33631: "UIC4Tag",
            33723: "IPTC-NAA",
            33918: "IntergraphPacketData",
            33919: "IntergraphFlagRegisters",
            33920: "IntergraphMatrix",
            33921: "INGRReserved",
            33922: "ModelTiePoint",
            34016: "Site",
            34017: "ColorSequence",
            34018: "IT8Header",
            34019: "RasterPadding",
            34020: "BitsPerRunLength",
            34021: "BitsPerExtendedRunLength",
            34022: "ColorTable",
            34023: "ImageColorIndicator",
            34024: "BackgroundColorIndicator",
            34025: "ImageColorValue",
            34026: "BackgroundColorValue",
            34027: "PixelIntensityRange",
            34028: "TransparencyIndicator",
            34029: "ColorCharacterization",
            34030: "HCUsage",
            34031: "TrapIndicator",
            34032: "CMYKEquivalent",
            34118: "SEMInfo",
            34152: "AFCP_IPTC",
            34232: "PixelMagicJBIGOptions",
            34264: "ModelTransform",
            34306: "WB_GRGBLevels",
            34310: "LeafData",
            34377: "PhotoshopSettings",
            34665: "ExifOffset",
            34675: "ICC_Profile",
            34687: "TIFF_FXExtensions",
            34688: "MultiProfiles",
            34689: "SharedData",
            34690: "T88Options",
            34732: "ImageLayer",
            34735: "GeoTiffDirectory",
            34736: "GeoTiffDoubleParams",
            34737: "GeoTiffAsciiParams",
            34850: "ExposureProgram",
            34852: "SpectralSensitivity",
            34853: "GPSInfo",
            34855: "ISO",
            34856: "Opto-ElectricConvFactor",
            34857: "Interlace",
            34858: "TimeZoneOffset",
            34859: "SelfTimerMode",
            34864: "SensitivityType",
            34865: "StandardOutputSensitivity",
            34866: "RecommendedExposureIndex",
            34867: "ISOSpeed",
            34868: "ISOSpeedLatitudeyyy",
            34869: "ISOSpeedLatitudezzz",
            34908: "FaxRecvParams",
            34909: "FaxSubAddress",
            34910: "FaxRecvTime",
            34954: "LeafSubIFD",
            36864: "ExifVersion",
            36867: "DateTimeOriginal",
            36868: "CreateDate",
            37121: "ComponentsConfiguration",
            37122: "CompressedBitsPerPixel",
            37377: "ShutterSpeedValue",
            37378: "ApertureValue",
            37379: "BrightnessValue",
            37380: "ExposureCompensation",
            37381: "MaxApertureValue",
            37382: "SubjectDistance",
            37383: "MeteringMode",
            37384: "LightSource",
            37385: "Flash",
            37386: "FocalLength",
            37387: "FlashEnergy",
            37388: "SpatialFrequencyResponse",
            37389: "Noise",
            37390: "FocalPlaneXResolution",
            37391: "FocalPlaneYResolution",
            37392: "FocalPlaneResolutionUnit",
            37393: "ImageNumber",
            37394: "SecurityClassification",
            37395: "ImageHistory",
            37396: "SubjectArea",
            37397: "ExposureIndex",
            37398: "TIFF-EPStandardID",
            37399: "SensingMethod",
            37434: "CIP3DataFile",
            37435: "CIP3Sheet",
            37436: "CIP3Side",
            37439: "StoNits",
            37500: "MakerNote",
            37510: "UserComment",
            37520: "SubSecTime",
            37521: "SubSecTimeOriginal",
            37522: "SubSecTimeDigitized",
            37679: "MSDocumentText",
            37680: "MSPropertySetStorage",
            37681: "MSDocumentTextPosition",
            37724: "ImageSourceData",
            40091: "XPTitle",
            40092: "XPComment",
            40093: "XPAuthor",
            40094: "XPKeywords",
            40095: "XPSubject",
            40960: "FlashpixVersion",
            40961: "ColorSpace",
            40962: "ExifImageWidth",
            40963: "ExifImageHeight",
            40964: "RelatedSoundFile",
            40965: "InteropOffset",
            41483: "FlashEnergy",
            41484: "SpatialFrequencyResponse",
            41485: "Noise",
            41486: "FocalPlaneXResolution",
            41487: "FocalPlaneYResolution",
            41488: "FocalPlaneResolutionUnit",
            41489: "ImageNumber",
            41490: "SecurityClassification",
            41491: "ImageHistory",
            41492: "SubjectLocation",
            41493: "ExposureIndex",
            41494: "TIFF-EPStandardID",
            41495: "SensingMethod",
            41728: "FileSource",
            41729: "SceneType",
            41730: "CFAPattern",
            41985: "CustomRendered",
            41986: "ExposureMode",
            41987: "WhiteBalance",
            41988: "DigitalZoomRatio",
            41989: "FocalLengthIn35mmFormat",
            41990: "SceneCaptureType",
            41991: "GainControl",
            41992: "Contrast",
            41993: "Saturation",
            41994: "Sharpness",
            41995: "DeviceSettingDescription",
            41996: "SubjectDistanceRange",
            42016: "ImageUniqueID",
            42032: "OwnerName",
            42033: "SerialNumber",
            42034: "LensInfo",
            42035: "LensMake",
            42036: "LensModel",
            42037: "LensSerialNumber",
            42112: "GDALMetadata",
            42113: "GDALNoData",
            42240: "Gamma",
            44992: "ExpandSoftware",
            44993: "ExpandLens",
            44994: "ExpandFilm",
            44995: "ExpandFilterLens",
            44996: "ExpandScanner",
            44997: "ExpandFlashLamp",
            48129: "PixelFormat",
            48130: "Transformation",
            48131: "Uncompressed",
            48132: "ImageType",
            48256: "ImageWidth",
            48257: "ImageHeight",
            48258: "WidthResolution",
            48259: "HeightResolution",
            48320: "ImageOffset",
            48321: "ImageByteCount",
            48322: "AlphaOffset",
            48323: "AlphaByteCount",
            48324: "ImageDataDiscard",
            48325: "AlphaDataDiscard",
            50215: "OceScanjobDesc",
            50216: "OceApplicationSelector",
            50217: "OceIDNumber",
            50218: "OceImageLogic",
            50255: "Annotations",
            50341: "PrintIM",
            50560: "USPTOOriginalContentType",
            50706: "DNGVersion",
            50707: "DNGBackwardVersion",
            50708: "UniqueCameraModel",
            50709: "LocalizedCameraModel",
            50710: "CFAPlaneColor",
            50711: "CFALayout",
            50712: "LinearizationTable",
            50713: "BlackLevelRepeatDim",
            50714: "BlackLevel",
            50715: "BlackLevelDeltaH",
            50716: "BlackLevelDeltaV",
            50717: "WhiteLevel",
            50718: "DefaultScale",
            50719: "DefaultCropOrigin",
            50720: "DefaultCropSize",
            50721: "ColorMatrix1",
            50722: "ColorMatrix2",
            50723: "CameraCalibration1",
            50724: "CameraCalibration2",
            50725: "ReductionMatrix1",
            50726: "ReductionMatrix2",
            50727: "AnalogBalance",
            50728: "AsShotNeutral",
            50729: "AsShotWhiteXY",
            50730: "BaselineExposure",
            50731: "BaselineNoise",
            50732: "BaselineSharpness",
            50733: "BayerGreenSplit",
            50734: "LinearResponseLimit",
            50735: "CameraSerialNumber",
            50736: "DNGLensInfo",
            50737: "ChromaBlurRadius",
            50738: "AntiAliasStrength",
            50739: "ShadowScale",
            50740: "DNGPrivateData",
            50741: "MakerNoteSafety",
            50752: "RawImageSegmentation",
            50778: "CalibrationIlluminant1",
            50779: "CalibrationIlluminant2",
            50780: "BestQualityScale",
            50781: "RawDataUniqueID",
            50784: "AliasLayerMetadata",
            50827: "OriginalRawFileName",
            50828: "OriginalRawFileData",
            50829: "ActiveArea",
            50830: "MaskedAreas",
            50831: "AsShotICCProfile",
            50832: "AsShotPreProfileMatrix",
            50833: "CurrentICCProfile",
            50834: "CurrentPreProfileMatrix",
            50879: "ColorimetricReference",
            50898: "PanasonicTitle",
            50899: "PanasonicTitle2",
            50931: "CameraCalibrationSig",
            50932: "ProfileCalibrationSig",
            50933: "ProfileIFD",
            50934: "AsShotProfileName",
            50935: "NoiseReductionApplied",
            50936: "ProfileName",
            50937: "ProfileHueSatMapDims",
            50938: "ProfileHueSatMapData1",
            50939: "ProfileHueSatMapData2",
            50940: "ProfileToneCurve",
            50941: "ProfileEmbedPolicy",
            50942: "ProfileCopyright",
            50964: "ForwardMatrix1",
            50965: "ForwardMatrix2",
            50966: "PreviewApplicationName",
            50967: "PreviewApplicationVersion",
            50968: "PreviewSettingsName",
            50969: "PreviewSettingsDigest",
            50970: "PreviewColorSpace",
            50971: "PreviewDateTime",
            50972: "RawImageDigest",
            50973: "OriginalRawFileDigest",
            50974: "SubTileBlockSize",
            50975: "RowInterleaveFactor",
            50981: "ProfileLookTableDims",
            50982: "ProfileLookTableData",
            51008: "OpcodeList1",
            51009: "OpcodeList2",
            51022: "OpcodeList3",
            51041: "NoiseProfile",
            51043: "TimeCodes",
            51044: "FrameRate",
            51058: "TStop",
            51081: "ReelName",
            51089: "OriginalDefaultFinalSize",
            51090: "OriginalBestQualitySize",
            51091: "OriginalDefaultCropSize",
            51105: "CameraLabel",
            51107: "ProfileHueSatMapEncoding",
            51108: "ProfileLookTableEncoding",
            51109: "BaselineExposureOffset",
            51110: "DefaultBlackRender",
            51111: "NewRawImageDigest",
            51112: "RawToPreviewGain",
            51125: "DefaultUserCrop",
            59932: "Padding",
            59933: "OffsetSchema",
            65e3: "OwnerName",
            65001: "SerialNumber",
            65002: "Lens",
            65024: "KDC_IFD",
            65100: "RawFile",
            65101: "Converter",
            65102: "WhiteBalance",
            65105: "Exposure",
            65106: "Shadows",
            65107: "Brightness",
            65108: "Contrast",
            65109: "Saturation",
            65110: "Sharpness",
            65111: "Smoothness",
            65112: "MoireFilter"
          },
          gps: {
            0: "GPSVersionID",
            1: "GPSLatitudeRef",
            2: "GPSLatitude",
            3: "GPSLongitudeRef",
            4: "GPSLongitude",
            5: "GPSAltitudeRef",
            6: "GPSAltitude",
            7: "GPSTimeStamp",
            8: "GPSSatellites",
            9: "GPSStatus",
            10: "GPSMeasureMode",
            11: "GPSDOP",
            12: "GPSSpeedRef",
            13: "GPSSpeed",
            14: "GPSTrackRef",
            15: "GPSTrack",
            16: "GPSImgDirectionRef",
            17: "GPSImgDirection",
            18: "GPSMapDatum",
            19: "GPSDestLatitudeRef",
            20: "GPSDestLatitude",
            21: "GPSDestLongitudeRef",
            22: "GPSDestLongitude",
            23: "GPSDestBearingRef",
            24: "GPSDestBearing",
            25: "GPSDestDistanceRef",
            26: "GPSDestDistance",
            27: "GPSProcessingMethod",
            28: "GPSAreaInformation",
            29: "GPSDateStamp",
            30: "GPSDifferential",
            31: "GPSHPositioningError"
          }
        };
      }, {}], 58: [function(te, Ee, $) {
        function Q(M, E) {
          switch (M) {
            case 1:
              return E.nextUInt8();
            case 3:
              return E.nextUInt16();
            case 4:
              return E.nextUInt32();
            case 5:
              return [E.nextUInt32(), E.nextUInt32()];
            case 6:
              return E.nextInt8();
            case 8:
              return E.nextUInt16();
            case 9:
              return E.nextUInt32();
            case 10:
              return [E.nextInt32(), E.nextInt32()];
            case 11:
              return E.nextFloat();
            case 12:
              return E.nextDouble();
            default:
              throw new Error("Invalid format while decoding: " + M);
          }
        }
        function r(M) {
          switch (M) {
            case 1:
            case 2:
            case 6:
            case 7:
              return 1;
            case 3:
            case 8:
              return 2;
            case 4:
            case 9:
            case 11:
              return 4;
            case 5:
            case 10:
            case 12:
              return 8;
            default:
              return 0;
          }
        }
        function F(M, E) {
          var x = E.nextUInt16(), m = E.nextUInt16(), I = r(m), z = E.nextUInt32(), w = I * z, C, b;
          if (w > 4 && (E = M.openWithOffset(E.nextUInt32())), m === 2) {
            C = E.nextString(z);
            var B = C.indexOf("\0");
            B !== -1 && (C = C.substr(0, B));
          } else if (m === 7)
            C = E.nextBuffer(z);
          else if (m !== 0)
            for (C = [], b = 0; b < z; ++b)
              C.push(Q(m, E));
          return w < 4 && E.skip(4 - w), [x, C, m];
        }
        function H(M, E, x) {
          var m = E.nextUInt16(), I, z;
          for (z = 0; z < m; ++z)
            I = F(M, E), x(I[0], I[1], I[2]);
        }
        function P(M) {
          var E = M.nextString(6);
          if (E !== "Exif\0\0")
            throw new Error("Invalid EXIF header");
          var x = M.mark(), m = M.nextUInt16();
          if (m === 18761)
            M.setBigEndian(!1);
          else if (m === 19789)
            M.setBigEndian(!0);
          else
            throw new Error("Invalid TIFF header");
          if (M.nextUInt16() !== 42)
            throw new Error("Invalid TIFF data");
          return x;
        }
        Ee.exports = {
          IFD0: 1,
          IFD1: 2,
          GPSIFD: 3,
          SubIFD: 4,
          InteropIFD: 5,
          parseTags: function(M, E) {
            var x;
            try {
              x = P(M);
            } catch {
              return !1;
            }
            var m, I, z, w = x.openWithOffset(M.nextUInt32()), C = this.IFD0;
            H(x, w, function(q, Y, re) {
              switch (q) {
                case 34853:
                  I = Y[0];
                  break;
                case 34665:
                  m = Y[0];
                  break;
                default:
                  E(C, q, Y, re);
                  break;
              }
            });
            var b = w.nextUInt32();
            if (b !== 0) {
              var B = x.openWithOffset(b);
              H(x, B, E.bind(null, this.IFD1));
            }
            if (I) {
              var N = x.openWithOffset(I);
              H(x, N, E.bind(null, this.GPSIFD));
            }
            if (m) {
              var U = x.openWithOffset(m), V = this.InteropIFD;
              H(x, U, function(q, Y, re) {
                q === 40965 ? z = Y[0] : E(V, q, Y, re);
              });
            }
            if (z) {
              var W = x.openWithOffset(z);
              H(x, W, E.bind(null, this.InteropIFD));
            }
            return !0;
          }
        };
      }, {}], 59: [function(te, Ee, $) {
        Ee.exports = {
          parseSections: function(Q, r) {
            var F, H;
            for (Q.setBigEndian(!0); Q.remainingLength() > 0 && H !== 218; ) {
              if (Q.nextUInt8() !== 255)
                throw new Error("Invalid JPEG section offset");
              H = Q.nextUInt8(), H >= 208 && H <= 217 || H === 218 ? F = 0 : F = Q.nextUInt16() - 2, r(H, Q.branch(0, F)), Q.skip(F);
            }
          },
          //stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator
          getSizeFromSOFSection: function(Q) {
            return Q.skip(1), {
              height: Q.nextUInt16(),
              width: Q.nextUInt16()
            };
          },
          getSectionName: function(Q) {
            var r, F;
            switch (Q) {
              case 216:
                r = "SOI";
                break;
              case 196:
                r = "DHT";
                break;
              case 219:
                r = "DQT";
                break;
              case 221:
                r = "DRI";
                break;
              case 218:
                r = "SOS";
                break;
              case 254:
                r = "COM";
                break;
              case 217:
                r = "EOI";
                break;
              default:
                Q >= 224 && Q <= 239 ? (r = "APP", F = Q - 224) : Q >= 192 && Q <= 207 && Q !== 196 && Q !== 200 && Q !== 204 ? (r = "SOF", F = Q - 192) : Q >= 208 && Q <= 215 && (r = "RST", F = Q - 208);
                break;
            }
            var H = {
              name: r
            };
            return typeof F == "number" && (H.index = F), H;
          }
        };
      }, {}], 60: [function(te, Ee, $) {
        var Q = te("./jpeg"), r = te("./exif"), F = te("./simplify");
        function H(M, E, x, m, I, z, w) {
          this.startMarker = M, this.tags = E, this.imageSize = x, this.thumbnailOffset = m, this.thumbnailLength = I, this.thumbnailType = z, this.app1Offset = w;
        }
        H.prototype = {
          hasThumbnail: function(M) {
            return !this.thumbnailOffset || !this.thumbnailLength ? !1 : typeof M != "string" ? !0 : M.toLowerCase().trim() === "image/jpeg" ? this.thumbnailType === 6 : M.toLowerCase().trim() === "image/tiff" ? this.thumbnailType === 1 : !1;
          },
          getThumbnailOffset: function() {
            return this.app1Offset + 6 + this.thumbnailOffset;
          },
          getThumbnailLength: function() {
            return this.thumbnailLength;
          },
          getThumbnailBuffer: function() {
            return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
          },
          _getThumbnailStream: function() {
            return this.startMarker.openWithOffset(this.getThumbnailOffset());
          },
          getImageSize: function() {
            return this.imageSize;
          },
          getThumbnailSize: function() {
            var M = this._getThumbnailStream(), E;
            return Q.parseSections(M, function(x, m) {
              Q.getSectionName(x).name === "SOF" && (E = Q.getSizeFromSOFSection(m));
            }), E;
          }
        };
        function P(M) {
          this.stream = M, this.flags = {
            readBinaryTags: !1,
            resolveTagNames: !0,
            simplifyValues: !0,
            imageSize: !0,
            hidePointers: !0,
            returnTags: !0
          };
        }
        P.prototype = {
          enableBinaryFields: function(M) {
            return this.flags.readBinaryTags = !!M, this;
          },
          enablePointers: function(M) {
            return this.flags.hidePointers = !M, this;
          },
          enableTagNames: function(M) {
            return this.flags.resolveTagNames = !!M, this;
          },
          enableImageSize: function(M) {
            return this.flags.imageSize = !!M, this;
          },
          enableReturnTags: function(M) {
            return this.flags.returnTags = !!M, this;
          },
          enableSimpleValues: function(M) {
            return this.flags.simplifyValues = !!M, this;
          },
          parse: function() {
            var M = this.stream.mark(), E = M.openWithOffset(0), x = this.flags, m, I, z, w, C, b, B, N, U;
            return x.resolveTagNames && (B = te("./exif-tags")), x.resolveTagNames ? (m = {}, N = function(V) {
              return m[V.name];
            }, U = function(V, W) {
              m[V.name] = W;
            }) : (m = [], N = function(V) {
              var W;
              for (W = 0; W < m.length; ++W)
                if (m[W].type === V.type && m[W].section === V.section)
                  return m.value;
            }, U = function(V, W) {
              var q;
              for (q = 0; q < m.length; ++q)
                if (m[q].type === V.type && m[q].section === V.section) {
                  m.value = W;
                  return;
                }
            }), Q.parseSections(E, function(V, W) {
              var q, Y = W.offsetFrom(M);
              V === 225 ? (q = r.parseTags(W, function(re, se, ve, ce) {
                if (!(!x.readBinaryTags && ce === 7)) {
                  if (se === 513) {
                    if (z = ve[0], x.hidePointers)
                      return;
                  } else if (se === 514) {
                    if (w = ve[0], x.hidePointers)
                      return;
                  } else if (se === 259 && (C = ve[0], x.hidePointers))
                    return;
                  if (x.returnTags)
                    if (x.simplifyValues && (ve = F.simplifyValue(ve, ce)), x.resolveTagNames) {
                      var be = re === r.GPSIFD ? B.gps : B.exif, Me = be[se];
                      Me || (Me = B.exif[se]), m.hasOwnProperty(Me) || (m[Me] = ve);
                    } else
                      m.push({
                        section: re,
                        type: se,
                        value: ve
                      });
                }
              }), q && (b = Y)) : x.imageSize && Q.getSectionName(V).name === "SOF" && (I = Q.getSizeFromSOFSection(W));
            }), x.simplifyValues && (F.castDegreeValues(N, U), F.castDateValues(N, U)), new H(M, m, I, z, w, C, b);
          }
        }, Ee.exports = P;
      }, { "./exif": 58, "./exif-tags": 57, "./jpeg": 59, "./simplify": 61 }], 61: [function(te, Ee, $) {
        var Q = te("./exif"), r = te("./date"), F = [
          {
            section: Q.GPSIFD,
            type: 2,
            name: "GPSLatitude",
            refType: 1,
            refName: "GPSLatitudeRef",
            posVal: "N"
          },
          {
            section: Q.GPSIFD,
            type: 4,
            name: "GPSLongitude",
            refType: 3,
            refName: "GPSLongitudeRef",
            posVal: "E"
          }
        ], H = [
          {
            section: Q.SubIFD,
            type: 306,
            name: "ModifyDate"
          },
          {
            section: Q.SubIFD,
            type: 36867,
            name: "DateTimeOriginal"
          },
          {
            section: Q.SubIFD,
            type: 36868,
            name: "CreateDate"
          },
          {
            section: Q.SubIFD,
            type: 306,
            name: "ModifyDate"
          }
        ];
        Ee.exports = {
          castDegreeValues: function(P, M) {
            F.forEach(function(E) {
              var x = P(E);
              if (x) {
                var m = P({ section: E.section, type: E.refType, name: E.refName }), I = m === E.posVal ? 1 : -1, z = (x[0] + x[1] / 60 + x[2] / 3600) * I;
                M(E, z);
              }
            });
          },
          castDateValues: function(P, M) {
            H.forEach(function(E) {
              var x = P(E);
              if (x) {
                var m = r.parseExifDate(x);
                typeof m < "u" && M(E, m);
              }
            });
          },
          simplifyValue: function(P, M) {
            return Array.isArray(P) && (P = P.map(function(E) {
              return M === 10 || M === 5 ? E[0] / E[1] : E;
            }), P.length === 1 && (P = P[0])), P;
          }
        };
      }, { "./date": 55, "./exif": 58 }], 62: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireDefault"), r = Q(te("@babel/runtime/helpers/toConsumableArray")), F = function(x) {
          return (0, r.default)(x).map(function(m) {
            return m.charCodeAt(0);
          });
        }, H = F("META-INF/mozilla.rsa"), P = F("[Content_Types].xml"), M = F("_rels/.rels");
        Ee.exports = function(E) {
          var x = E instanceof Uint8Array ? E : new Uint8Array(E);
          if (!(x && x.length > 1))
            return null;
          var m = function(re, se) {
            se = Object.assign({
              offset: 0
            }, se);
            for (var ve = 0; ve < re.length; ve++)
              if (se.mask) {
                if (re[ve] !== (se.mask[ve] & x[ve + se.offset]))
                  return !1;
              } else if (re[ve] !== x[ve + se.offset])
                return !1;
            return !0;
          }, I = function(re, se) {
            return m(F(re), se);
          };
          if (m([255, 216, 255]))
            return {
              ext: "jpg",
              mime: "image/jpeg"
            };
          if (m([137, 80, 78, 71, 13, 10, 26, 10]))
            return {
              ext: "png",
              mime: "image/png"
            };
          if (m([71, 73, 70]))
            return {
              ext: "gif",
              mime: "image/gif"
            };
          if (m([87, 69, 66, 80], {
            offset: 8
          }))
            return {
              ext: "webp",
              mime: "image/webp"
            };
          if (m([70, 76, 73, 70]))
            return {
              ext: "flif",
              mime: "image/flif"
            };
          if ((m([73, 73, 42, 0]) || m([77, 77, 0, 42])) && m([67, 82], {
            offset: 8
          }))
            return {
              ext: "cr2",
              mime: "image/x-canon-cr2"
            };
          if (m([73, 73, 42, 0]) || m([77, 77, 0, 42]))
            return {
              ext: "tif",
              mime: "image/tiff"
            };
          if (m([66, 77]))
            return {
              ext: "bmp",
              mime: "image/bmp"
            };
          if (m([73, 73, 188]))
            return {
              ext: "jxr",
              mime: "image/vnd.ms-photo"
            };
          if (m([56, 66, 80, 83]))
            return {
              ext: "psd",
              mime: "image/vnd.adobe.photoshop"
            };
          if (m([80, 75, 3, 4])) {
            if (m([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], {
              offset: 30
            }))
              return {
                ext: "epub",
                mime: "application/epub+zip"
              };
            if (m(H, {
              offset: 30
            }))
              return {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
            if (I("mimetypeapplication/vnd.oasis.opendocument.text", {
              offset: 30
            }))
              return {
                ext: "odt",
                mime: "application/vnd.oasis.opendocument.text"
              };
            if (I("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", {
              offset: 30
            }))
              return {
                ext: "ods",
                mime: "application/vnd.oasis.opendocument.spreadsheet"
              };
            if (I("mimetypeapplication/vnd.oasis.opendocument.presentation", {
              offset: 30
            }))
              return {
                ext: "odp",
                mime: "application/vnd.oasis.opendocument.presentation"
              };
            var z = function(re) {
              var se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              return re.findIndex(function(ve, ce, be) {
                return ce >= se && be[ce] === 80 && be[ce + 1] === 75 && be[ce + 2] === 3 && be[ce + 3] === 4;
              });
            }, w = 0, C = !1, b = null;
            do {
              var B = w + 30;
              if (C || (C = m(P, {
                offset: B
              }) || m(M, {
                offset: B
              })), b || (I("word/", {
                offset: B
              }) ? b = {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
              } : I("ppt/", {
                offset: B
              }) ? b = {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
              } : I("xl/", {
                offset: B
              }) && (b = {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              })), C && b)
                return b;
              w = z(x, B);
            } while (w >= 0);
            if (b)
              return b;
          }
          if (m([80, 75]) && (x[2] === 3 || x[2] === 5 || x[2] === 7) && (x[3] === 4 || x[3] === 6 || x[3] === 8))
            return {
              ext: "zip",
              mime: "application/zip"
            };
          if (m([117, 115, 116, 97, 114], {
            offset: 257
          }))
            return {
              ext: "tar",
              mime: "application/x-tar"
            };
          if (m([82, 97, 114, 33, 26, 7]) && (x[6] === 0 || x[6] === 1))
            return {
              ext: "rar",
              mime: "application/x-rar-compressed"
            };
          if (m([31, 139, 8]))
            return {
              ext: "gz",
              mime: "application/gzip"
            };
          if (m([66, 90, 104]))
            return {
              ext: "bz2",
              mime: "application/x-bzip2"
            };
          if (m([55, 122, 188, 175, 39, 28]))
            return {
              ext: "7z",
              mime: "application/x-7z-compressed"
            };
          if (m([120, 1]))
            return {
              ext: "dmg",
              mime: "application/x-apple-diskimage"
            };
          if (m([51, 103, 112, 53]) || // 3gp5
          m([0, 0, 0]) && m([102, 116, 121, 112], {
            offset: 4
          }) && (m([109, 112, 52, 49], {
            offset: 8
          }) || // MP41
          m([109, 112, 52, 50], {
            offset: 8
          }) || // MP42
          m([105, 115, 111, 109], {
            offset: 8
          }) || // ISOM
          m([105, 115, 111, 50], {
            offset: 8
          }) || // ISO2
          m([109, 109, 112, 52], {
            offset: 8
          }) || // MMP4
          m([77, 52, 86], {
            offset: 8
          }) || // M4V
          m([100, 97, 115, 104], {
            offset: 8
          })))
            return {
              ext: "mp4",
              mime: "video/mp4"
            };
          if (m([77, 84, 104, 100]))
            return {
              ext: "mid",
              mime: "audio/midi"
            };
          if (m([26, 69, 223, 163])) {
            var N = x.subarray(4, 4100), U = N.findIndex(function(Y, re, se) {
              return se[re] === 66 && se[re + 1] === 130;
            });
            if (U !== -1) {
              var V = U + 3, W = function(re) {
                return (0, r.default)(re).every(function(se, ve) {
                  return N[V + ve] === se.charCodeAt(0);
                });
              };
              if (W("matroska"))
                return {
                  ext: "mkv",
                  mime: "video/x-matroska"
                };
              if (W("webm"))
                return {
                  ext: "webm",
                  mime: "video/webm"
                };
            }
          }
          if (m([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || m([102, 114, 101, 101], {
            offset: 4
          }) || m([102, 116, 121, 112, 113, 116, 32, 32], {
            offset: 4
          }) || m([109, 100, 97, 116], {
            offset: 4
          }) || // MJPEG
          m([119, 105, 100, 101], {
            offset: 4
          }))
            return {
              ext: "mov",
              mime: "video/quicktime"
            };
          if (m([82, 73, 70, 70])) {
            if (m([65, 86, 73], {
              offset: 8
            }))
              return {
                ext: "avi",
                mime: "video/vnd.avi"
              };
            if (m([87, 65, 86, 69], {
              offset: 8
            }))
              return {
                ext: "wav",
                mime: "audio/vnd.wave"
              };
            if (m([81, 76, 67, 77], {
              offset: 8
            }))
              return {
                ext: "qcp",
                mime: "audio/qcelp"
              };
          }
          if (m([48, 38, 178, 117, 142, 102, 207, 17, 166, 217]))
            return {
              ext: "wmv",
              mime: "video/x-ms-wmv"
            };
          if (m([0, 0, 1, 186]) || m([0, 0, 1, 179]))
            return {
              ext: "mpg",
              mime: "video/mpeg"
            };
          if (m([102, 116, 121, 112, 51, 103], {
            offset: 4
          }))
            return {
              ext: "3gp",
              mime: "video/3gpp"
            };
          for (var q = 0; q < 2 && q < x.length - 16; q++) {
            if (m([73, 68, 51], {
              offset: q
            }) || // ID3 header
            m([255, 226], {
              offset: q,
              mask: [255, 226]
            }))
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            if (m([255, 228], {
              offset: q,
              mask: [255, 228]
            }))
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            if (m([255, 248], {
              offset: q,
              mask: [255, 252]
            }))
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            if (m([255, 240], {
              offset: q,
              mask: [255, 252]
            }))
              return {
                ext: "mp4",
                mime: "audio/mpeg"
              };
          }
          if (m([102, 116, 121, 112, 77, 52, 65], {
            offset: 4
          }) || m([77, 52, 65, 32]))
            return {
              // MPEG-4 layer 3 (audio)
              ext: "m4a",
              mime: "audio/mp4"
              // RFC 4337
            };
          if (m([79, 112, 117, 115, 72, 101, 97, 100], {
            offset: 28
          }))
            return {
              ext: "opus",
              mime: "audio/opus"
            };
          if (m([79, 103, 103, 83]))
            return m([128, 116, 104, 101, 111, 114, 97], {
              offset: 28
            }) ? {
              ext: "ogv",
              mime: "video/ogg"
            } : m([1, 118, 105, 100, 101, 111, 0], {
              offset: 28
            }) ? {
              ext: "ogm",
              mime: "video/ogg"
            } : m([127, 70, 76, 65, 67], {
              offset: 28
            }) ? {
              ext: "oga",
              mime: "audio/ogg"
            } : m([83, 112, 101, 101, 120, 32, 32], {
              offset: 28
            }) ? {
              ext: "spx",
              mime: "audio/ogg"
            } : m([1, 118, 111, 114, 98, 105, 115], {
              offset: 28
            }) ? {
              ext: "ogg",
              mime: "audio/ogg"
            } : {
              ext: "ogx",
              mime: "application/ogg"
            };
          if (m([102, 76, 97, 67]))
            return {
              ext: "flac",
              mime: "audio/x-flac"
            };
          if (m([77, 65, 67, 32]))
            return {
              ext: "ape",
              mime: "audio/ape"
            };
          if (m([119, 118, 112, 107]))
            return {
              ext: "wv",
              mime: "audio/wavpack"
            };
          if (m([35, 33, 65, 77, 82, 10]))
            return {
              ext: "amr",
              mime: "audio/amr"
            };
          if (m([37, 80, 68, 70]))
            return {
              ext: "pdf",
              mime: "application/pdf"
            };
          if (m([77, 90]))
            return {
              ext: "exe",
              mime: "application/x-msdownload"
            };
          if ((x[0] === 67 || x[0] === 70) && m([87, 83], {
            offset: 1
          }))
            return {
              ext: "swf",
              mime: "application/x-shockwave-flash"
            };
          if (m([123, 92, 114, 116, 102]))
            return {
              ext: "rtf",
              mime: "application/rtf"
            };
          if (m([0, 97, 115, 109]))
            return {
              ext: "wasm",
              mime: "application/wasm"
            };
          if (m([119, 79, 70, 70]) && (m([0, 1, 0, 0], {
            offset: 4
          }) || m([79, 84, 84, 79], {
            offset: 4
          })))
            return {
              ext: "woff",
              mime: "font/woff"
            };
          if (m([119, 79, 70, 50]) && (m([0, 1, 0, 0], {
            offset: 4
          }) || m([79, 84, 84, 79], {
            offset: 4
          })))
            return {
              ext: "woff2",
              mime: "font/woff2"
            };
          if (m([76, 80], {
            offset: 34
          }) && (m([0, 0, 1], {
            offset: 8
          }) || m([1, 0, 2], {
            offset: 8
          }) || m([2, 0, 2], {
            offset: 8
          })))
            return {
              ext: "eot",
              mime: "application/vnd.ms-fontobject"
            };
          if (m([0, 1, 0, 0, 0]))
            return {
              ext: "ttf",
              mime: "font/ttf"
            };
          if (m([79, 84, 84, 79, 0]))
            return {
              ext: "otf",
              mime: "font/otf"
            };
          if (m([0, 0, 1, 0]))
            return {
              ext: "ico",
              mime: "image/x-icon"
            };
          if (m([0, 0, 2, 0]))
            return {
              ext: "cur",
              mime: "image/x-icon"
            };
          if (m([70, 76, 86, 1]))
            return {
              ext: "flv",
              mime: "video/x-flv"
            };
          if (m([37, 33]))
            return {
              ext: "ps",
              mime: "application/postscript"
            };
          if (m([253, 55, 122, 88, 90, 0]))
            return {
              ext: "xz",
              mime: "application/x-xz"
            };
          if (m([83, 81, 76, 105]))
            return {
              ext: "sqlite",
              mime: "application/x-sqlite3"
            };
          if (m([78, 69, 83, 26]))
            return {
              ext: "nes",
              mime: "application/x-nintendo-nes-rom"
            };
          if (m([67, 114, 50, 52]))
            return {
              ext: "crx",
              mime: "application/x-google-chrome-extension"
            };
          if (m([77, 83, 67, 70]) || m([73, 83, 99, 40]))
            return {
              ext: "cab",
              mime: "application/vnd.ms-cab-compressed"
            };
          if (m([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121]))
            return {
              ext: "deb",
              mime: "application/x-deb"
            };
          if (m([33, 60, 97, 114, 99, 104, 62]))
            return {
              ext: "ar",
              mime: "application/x-unix-archive"
            };
          if (m([237, 171, 238, 219]))
            return {
              ext: "rpm",
              mime: "application/x-rpm"
            };
          if (m([31, 160]) || m([31, 157]))
            return {
              ext: "Z",
              mime: "application/x-compress"
            };
          if (m([76, 90, 73, 80]))
            return {
              ext: "lz",
              mime: "application/x-lzip"
            };
          if (m([208, 207, 17, 224, 161, 177, 26, 225]))
            return {
              ext: "msi",
              mime: "application/x-msi"
            };
          if (m([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
            return {
              ext: "mxf",
              mime: "application/mxf"
            };
          if (m([71], {
            offset: 4
          }) && (m([71], {
            offset: 192
          }) || m([71], {
            offset: 196
          })))
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          if (m([66, 76, 69, 78, 68, 69, 82]))
            return {
              ext: "blend",
              mime: "application/x-blender"
            };
          if (m([66, 80, 71, 251]))
            return {
              ext: "bpg",
              mime: "image/bpg"
            };
          if (m([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
            if (m([106, 112, 50, 32], {
              offset: 20
            }))
              return {
                ext: "jp2",
                mime: "image/jp2"
              };
            if (m([106, 112, 120, 32], {
              offset: 20
            }))
              return {
                ext: "jpx",
                mime: "image/jpx"
              };
            if (m([106, 112, 109, 32], {
              offset: 20
            }))
              return {
                ext: "jpm",
                mime: "image/jpm"
              };
            if (m([109, 106, 112, 50], {
              offset: 20
            }))
              return {
                ext: "mj2",
                mime: "image/mj2"
              };
          }
          if (m([70, 79, 82, 77, 0]))
            return {
              ext: "aif",
              mime: "audio/aiff"
            };
          if (I("<?xml "))
            return {
              ext: "xml",
              mime: "application/xml"
            };
          if (m([66, 79, 79, 75, 77, 79, 66, 73], {
            offset: 60
          }))
            return {
              ext: "mobi",
              mime: "application/x-mobipocket-ebook"
            };
          if (m([102, 116, 121, 112], {
            offset: 4
          })) {
            if (m([109, 105, 102, 49], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heif"
              };
            if (m([109, 115, 102, 49], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heif-sequence"
              };
            if (m([104, 101, 105, 99], {
              offset: 8
            }) || m([104, 101, 105, 120], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heic"
              };
            if (m([104, 101, 118, 99], {
              offset: 8
            }) || m([104, 101, 118, 120], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heic-sequence"
              };
          }
          return m([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]) ? {
            ext: "ktx",
            mime: "image/ktx"
          } : null;
        };
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20 }], 63: [function(te, Ee, $) {
        var Q = te("is-callable"), r = Object.prototype.toString, F = Object.prototype.hasOwnProperty, H = function(m, I, z) {
          for (var w = 0, C = m.length; w < C; w++)
            F.call(m, w) && (z == null ? I(m[w], w, m) : I.call(z, m[w], w, m));
        }, P = function(m, I, z) {
          for (var w = 0, C = m.length; w < C; w++)
            z == null ? I(m.charAt(w), w, m) : I.call(z, m.charAt(w), w, m);
        }, M = function(m, I, z) {
          for (var w in m)
            F.call(m, w) && (z == null ? I(m[w], w, m) : I.call(z, m[w], w, m));
        }, E = function(m, I, z) {
          if (!Q(I))
            throw new TypeError("iterator must be a function");
          var w;
          arguments.length >= 3 && (w = z), r.call(m) === "[object Array]" ? H(m, I, w) : typeof m == "string" ? P(m, I, w) : M(m, I, w);
        };
        Ee.exports = E;
      }, { "is-callable": 77 }], 64: [function(te, Ee, $) {
        function Q(P, M, E, I) {
          var m = 0, I = I === void 0 ? {} : I, z = I.loop === void 0 ? null : I.loop, w = I.palette === void 0 ? null : I.palette;
          if (M <= 0 || E <= 0 || M > 65535 || E > 65535)
            throw new Error("Width/Height invalid.");
          function C(Y) {
            var re = Y.length;
            if (re < 2 || re > 256 || re & re - 1)
              throw new Error(
                "Invalid code/color length, must be power of 2 and 2 .. 256."
              );
            return re;
          }
          P[m++] = 71, P[m++] = 73, P[m++] = 70, P[m++] = 56, P[m++] = 57, P[m++] = 97;
          var b = 0, B = 0;
          if (w !== null) {
            for (var N = C(w); N >>= 1; ) ++b;
            if (N = 1 << b, --b, I.background !== void 0) {
              if (B = I.background, B >= N)
                throw new Error("Background index out of range.");
              if (B === 0)
                throw new Error("Background index explicitly passed as 0.");
            }
          }
          if (P[m++] = M & 255, P[m++] = M >> 8 & 255, P[m++] = E & 255, P[m++] = E >> 8 & 255, P[m++] = (w !== null ? 128 : 0) | // Global Color Table Flag.
          b, P[m++] = B, P[m++] = 0, w !== null)
            for (var U = 0, V = w.length; U < V; ++U) {
              var W = w[U];
              P[m++] = W >> 16 & 255, P[m++] = W >> 8 & 255, P[m++] = W & 255;
            }
          if (z !== null) {
            if (z < 0 || z > 65535)
              throw new Error("Loop count invalid.");
            P[m++] = 33, P[m++] = 255, P[m++] = 11, P[m++] = 78, P[m++] = 69, P[m++] = 84, P[m++] = 83, P[m++] = 67, P[m++] = 65, P[m++] = 80, P[m++] = 69, P[m++] = 50, P[m++] = 46, P[m++] = 48, P[m++] = 3, P[m++] = 1, P[m++] = z & 255, P[m++] = z >> 8 & 255, P[m++] = 0;
          }
          var q = !1;
          this.addFrame = function(Y, re, se, ve, ce, be) {
            if (q === !0 && (--m, q = !1), be = be === void 0 ? {} : be, Y < 0 || re < 0 || Y > 65535 || re > 65535)
              throw new Error("x/y invalid.");
            if (se <= 0 || ve <= 0 || se > 65535 || ve > 65535)
              throw new Error("Width/Height invalid.");
            if (ce.length < se * ve)
              throw new Error("Not enough pixels for the frame size.");
            var Me = !0, xe = be.palette;
            if (xe == null && (Me = !1, xe = w), xe == null)
              throw new Error("Must supply either a local or global palette.");
            for (var le = C(xe), de = 0; le >>= 1; ) ++de;
            le = 1 << de;
            var De = be.delay === void 0 ? 0 : be.delay, ze = be.disposal === void 0 ? 0 : be.disposal;
            if (ze < 0 || ze > 3)
              throw new Error("Disposal out of range.");
            var Ze = !1, Ue = 0;
            if (be.transparent !== void 0 && be.transparent !== null && (Ze = !0, Ue = be.transparent, Ue < 0 || Ue >= le))
              throw new Error("Transparent color index.");
            if ((ze !== 0 || Ze || De !== 0) && (P[m++] = 33, P[m++] = 249, P[m++] = 4, P[m++] = ze << 2 | (Ze === !0 ? 1 : 0), P[m++] = De & 255, P[m++] = De >> 8 & 255, P[m++] = Ue, P[m++] = 0), P[m++] = 44, P[m++] = Y & 255, P[m++] = Y >> 8 & 255, P[m++] = re & 255, P[m++] = re >> 8 & 255, P[m++] = se & 255, P[m++] = se >> 8 & 255, P[m++] = ve & 255, P[m++] = ve >> 8 & 255, P[m++] = Me === !0 ? 128 | de - 1 : 0, Me === !0)
              for (var Ie = 0, je = xe.length; Ie < je; ++Ie) {
                var Fe = xe[Ie];
                P[m++] = Fe >> 16 & 255, P[m++] = Fe >> 8 & 255, P[m++] = Fe & 255;
              }
            return m = r(
              P,
              m,
              de < 2 ? 2 : de,
              ce
            ), m;
          }, this.end = function() {
            return q === !1 && (P[m++] = 59, q = !0), m;
          }, this.getOutputBuffer = function() {
            return P;
          }, this.setOutputBuffer = function(Y) {
            P = Y;
          }, this.getOutputBufferPosition = function() {
            return m;
          }, this.setOutputBufferPosition = function(Y) {
            m = Y;
          };
        }
        function r(P, M, E, x) {
          P[M++] = E;
          var m = M++, I = 1 << E, z = I - 1, w = I + 1, C = w + 1, b = E + 1, B = 0, N = 0;
          function U(be) {
            for (; B >= be; )
              P[M++] = N & 255, N >>= 8, B -= 8, M === m + 256 && (P[m] = 255, m = M++);
          }
          function V(be) {
            N |= be << B, B += b, U(8);
          }
          var W = x[0] & z, q = {};
          V(I);
          for (var Y = 1, re = x.length; Y < re; ++Y) {
            var se = x[Y] & z, ve = W << 8 | se, ce = q[ve];
            if (ce === void 0) {
              for (N |= W << B, B += b; B >= 8; )
                P[M++] = N & 255, N >>= 8, B -= 8, M === m + 256 && (P[m] = 255, m = M++);
              C === 4096 ? (V(I), C = w + 1, b = E + 1, q = {}) : (C >= 1 << b && ++b, q[ve] = C++), W = se;
            } else
              W = ce;
          }
          return V(W), V(w), U(1), m + 1 === M ? P[m] = 0 : (P[m] = M - m - 1, P[M++] = 0), M;
        }
        function F(P) {
          var M = 0;
          if (P[M++] !== 71 || P[M++] !== 73 || P[M++] !== 70 || P[M++] !== 56 || (P[M++] + 1 & 253) !== 56 || P[M++] !== 97)
            throw new Error("Invalid GIF 87a/89a header.");
          var E = P[M++] | P[M++] << 8, x = P[M++] | P[M++] << 8, m = P[M++], I = m >> 7, z = m & 7, w = 1 << z + 1;
          P[M++], P[M++];
          var C = null, b = null;
          I && (C = M, b = w, M += w * 3);
          var B = !0, N = [], U = 0, V = null, W = 0, q = null;
          for (this.width = E, this.height = x; B && M < P.length; )
            switch (P[M++]) {
              case 33:
                switch (P[M++]) {
                  case 255:
                    if (P[M] !== 11 || // 21 FF already read, check block size.
                    // NETSCAPE2.0
                    P[M + 1] == 78 && P[M + 2] == 69 && P[M + 3] == 84 && P[M + 4] == 83 && P[M + 5] == 67 && P[M + 6] == 65 && P[M + 7] == 80 && P[M + 8] == 69 && P[M + 9] == 50 && P[M + 10] == 46 && P[M + 11] == 48 && // Sub-block
                    P[M + 12] == 3 && P[M + 13] == 1 && P[M + 16] == 0)
                      M += 14, q = P[M++] | P[M++] << 8, M++;
                    else
                      for (M += 12; ; ) {
                        var Y = P[M++];
                        if (!(Y >= 0)) throw Error("Invalid block size");
                        if (Y === 0) break;
                        M += Y;
                      }
                    break;
                  case 249:
                    if (P[M++] !== 4 || P[M + 4] !== 0)
                      throw new Error("Invalid graphics extension block.");
                    var re = P[M++];
                    U = P[M++] | P[M++] << 8, V = P[M++], re & 1 || (V = null), W = re >> 2 & 7, M++;
                    break;
                  case 254:
                    for (; ; ) {
                      var Y = P[M++];
                      if (!(Y >= 0)) throw Error("Invalid block size");
                      if (Y === 0) break;
                      M += Y;
                    }
                    break;
                  default:
                    throw new Error(
                      "Unknown graphic control label: 0x" + P[M - 1].toString(16)
                    );
                }
                break;
              case 44:
                var se = P[M++] | P[M++] << 8, ve = P[M++] | P[M++] << 8, ce = P[M++] | P[M++] << 8, be = P[M++] | P[M++] << 8, Me = P[M++], xe = Me >> 7, le = Me >> 6 & 1, de = Me & 7, De = 1 << de + 1, ze = C, Ze = b, Ue = !1;
                if (xe) {
                  var Ue = !0;
                  ze = M, Ze = De, M += De * 3;
                }
                var Ie = M;
                for (M++; ; ) {
                  var Y = P[M++];
                  if (!(Y >= 0)) throw Error("Invalid block size");
                  if (Y === 0) break;
                  M += Y;
                }
                N.push({
                  x: se,
                  y: ve,
                  width: ce,
                  height: be,
                  has_local_palette: Ue,
                  palette_offset: ze,
                  palette_size: Ze,
                  data_offset: Ie,
                  data_length: M - Ie,
                  transparent_index: V,
                  interlaced: !!le,
                  delay: U,
                  disposal: W
                });
                break;
              case 59:
                B = !1;
                break;
              default:
                throw new Error("Unknown gif block: 0x" + P[M - 1].toString(16));
            }
          this.numFrames = function() {
            return N.length;
          }, this.loopCount = function() {
            return q;
          }, this.frameInfo = function(je) {
            if (je < 0 || je >= N.length)
              throw new Error("Frame index out of range.");
            return N[je];
          }, this.decodeAndBlitFrameBGRA = function(je, Fe) {
            var $e = this.frameInfo(je), ct = $e.width * $e.height, wt = new Uint8Array(ct);
            H(
              P,
              $e.data_offset,
              wt,
              ct
            );
            var Oe = $e.palette_offset, Ct = $e.transparent_index;
            Ct === null && (Ct = 256);
            var Xt = $e.width, vt = E - Xt, Ye = Xt, qe = ($e.y * E + $e.x) * 4, rt = (($e.y + $e.height) * E + $e.x) * 4, it = qe, Ae = vt * 4;
            $e.interlaced === !0 && (Ae += E * 4 * 7);
            for (var _e = 8, fe = 0, We = wt.length; fe < We; ++fe) {
              var Pe = wt[fe];
              if (Ye === 0 && (it += Ae, Ye = Xt, it >= rt && (Ae = vt * 4 + E * 4 * (_e - 1), it = qe + (Xt + vt) * (_e << 1), _e >>= 1)), Pe === Ct)
                it += 4;
              else {
                var he = P[Oe + Pe * 3], ie = P[Oe + Pe * 3 + 1], Xe = P[Oe + Pe * 3 + 2];
                Fe[it++] = Xe, Fe[it++] = ie, Fe[it++] = he, Fe[it++] = 255;
              }
              --Ye;
            }
          }, this.decodeAndBlitFrameRGBA = function(je, Fe) {
            var $e = this.frameInfo(je), ct = $e.width * $e.height, wt = new Uint8Array(ct);
            H(
              P,
              $e.data_offset,
              wt,
              ct
            );
            var Oe = $e.palette_offset, Ct = $e.transparent_index;
            Ct === null && (Ct = 256);
            var Xt = $e.width, vt = E - Xt, Ye = Xt, qe = ($e.y * E + $e.x) * 4, rt = (($e.y + $e.height) * E + $e.x) * 4, it = qe, Ae = vt * 4;
            $e.interlaced === !0 && (Ae += E * 4 * 7);
            for (var _e = 8, fe = 0, We = wt.length; fe < We; ++fe) {
              var Pe = wt[fe];
              if (Ye === 0 && (it += Ae, Ye = Xt, it >= rt && (Ae = vt * 4 + E * 4 * (_e - 1), it = qe + (Xt + vt) * (_e << 1), _e >>= 1)), Pe === Ct)
                it += 4;
              else {
                var he = P[Oe + Pe * 3], ie = P[Oe + Pe * 3 + 1], Xe = P[Oe + Pe * 3 + 2];
                Fe[it++] = he, Fe[it++] = ie, Fe[it++] = Xe, Fe[it++] = 255;
              }
              --Ye;
            }
          };
        }
        function H(P, M, E, x) {
          for (var m = P[M++], I = 1 << m, z = I + 1, w = z + 1, C = m + 1, b = (1 << C) - 1, B = 0, N = 0, U = 0, V = P[M++], W = new Int32Array(4096), q = null; ; ) {
            for (; B < 16 && V !== 0; )
              N |= P[M++] << B, B += 8, V === 1 ? V = P[M++] : --V;
            if (B < C)
              break;
            var Y = N & b;
            if (N >>= C, B -= C, Y === I) {
              w = z + 1, C = m + 1, b = (1 << C) - 1, q = null;
              continue;
            } else if (Y === z)
              break;
            for (var re = Y < w ? Y : q, se = 0, ve = re; ve > I; )
              ve = W[ve] >> 8, ++se;
            var ce = ve, be = U + se + (re !== Y ? 1 : 0);
            if (be > x) {
              console.log("Warning, gif stream longer than expected.");
              return;
            }
            E[U++] = ce, U += se;
            var Me = U;
            for (re !== Y && (E[U++] = ce), ve = re; se--; )
              ve = W[ve], E[--Me] = ve & 255, ve >>= 8;
            q !== null && w < 4096 && (W[w++] = q << 8 | ce, w >= b + 1 && C < 12 && (++C, b = b << 1 | 1)), q = Y;
          }
          return U !== x && console.log("Warning, gif stream shorter than expected."), E;
        }
        try {
          $.GifWriter = Q, $.GifReader = F;
        } catch {
        }
      }, {}], 65: [function(te, Ee, $) {
        (function(Q) {
          class r {
            /**
             * BitmapImage is a class that hold an RGBA (red, green, blue, alpha) representation of an image. It's shape is borrowed from the Jimp package to make it easy to transfer GIF image frames into Jimp and Jimp images into GIF image frames. Each instance has a `bitmap` property having the following properties:
             * 
             * Property | Description
             * --- | ---
             * bitmap.width | width of image in pixels
             * bitmap.height | height of image in pixels
             * bitmap.data | a Buffer whose every four bytes represents a pixel, each sequential byte of a pixel corresponding to the red, green, blue, and alpha values of the pixel
             *
             * Its constructor supports the following signatures:
             *
             * * new BitmapImage(bitmap: { width: number, height: number, data: Buffer })
             * * new BitmapImage(bitmapImage: BitmapImage)
             * * new BitmapImage(width: number, height: number, buffer: Buffer)
             * * new BitmapImage(width: number, height: number, backgroundRGBA?: number)
             * 
             * When a `BitmapImage` is provided, the constructed `BitmapImage` is a deep clone of the provided one, so that each image's pixel data can subsequently be modified without affecting each other.
             *
             * `backgroundRGBA` is an optional parameter representing a pixel as a single number. In hex, the number is as follows: 0xRRGGBBAA, where RR is the red byte, GG the green byte, BB, the blue byte, and AA the alpha value. An AA of 0x00 is considered transparent, and all non-zero AA values are treated as opaque.
             */
            constructor(...H) {
              if (H.length === 0)
                throw new Error("constructor requires parameters");
              const P = H[0];
              if (P !== null && typeof P == "object")
                if (P instanceof r) {
                  const M = P.bitmap;
                  this.bitmap = {
                    width: M.width,
                    height: M.height,
                    data: new Q(M.width * M.height * 4)
                  }, M.data.copy(this.bitmap.data);
                } else if (P.width && P.height && P.data)
                  this.bitmap = P;
                else
                  throw new Error("unrecognized constructor parameters");
              else if (typeof P == "number" && typeof H[1] == "number") {
                const M = P, E = H[1], x = H[2];
                this.bitmap = { width: M, height: E }, Q.isBuffer(x) ? this.bitmap.data = x : (this.bitmap.data = new Q(M * E * 4), typeof x == "number" && this.fillRGBA(x));
              } else
                throw new Error("unrecognized constructor parameters");
            }
            /**
             * Copy a square portion of this image into another image. 
             * 
             * @param {BitmapImage} toImage Image into which to copy the square
             * @param {number} toX x-coord in toImage of upper-left corner of receiving square
             * @param {number} toY y-coord in toImage of upper-left corner of receiving square
             * @param {number} fromX x-coord in this image of upper-left corner of source square
             * @param {number} fromY y-coord in this image of upper-left corner of source square
             * @return {BitmapImage} The present image to allow for chaining.
             */
            blit(H, P, M, E, x, m, I) {
              if (E + m > this.bitmap.width)
                throw new Error("copy exceeds width of source bitmap");
              if (P + m > H.bitmap.width)
                throw new Error("copy exceeds width of target bitmap");
              if (x + I > this.bitmap.height)
                throw new Error("copy exceeds height of source bitmap");
              if (M + I > H.bitmap.height)
                throw new Erro("copy exceeds height of target bitmap");
              const z = this.bitmap.data, w = H.bitmap.data, C = this.bitmap.width * 4, b = H.bitmap.width * 4, B = m * 4;
              let N = x * C + E * 4, U = M * b + P * 4;
              for (; --I >= 0; )
                z.copy(w, U, N, N + B), N += C, U += b;
              return this;
            }
            /**
             * Fills the image with a single color.
             * 
             * @param {number} rgba Color with which to fill image, expressed as a singlenumber in the form 0xRRGGBBAA, where AA is 0x00 for transparent and any other value for opaque.
             * @return {BitmapImage} The present image to allow for chaining.
             */
            fillRGBA(H) {
              const P = this.bitmap.data, M = this.bitmap.height * 4;
              let E = 0;
              for (; E < M; )
                P.writeUInt32BE(H, E), E += 4;
              for (; E < P.length; )
                P.copy(P, E, 0, M), E += M;
              return this;
            }
            /**
             * Gets the RGBA number of the pixel at the given coordinate in the form 0xRRGGBBAA, where AA is the alpha value, with alpha 0x00 encoding to transparency in GIFs.
             * 
             * @param {number} x x-coord of pixel
             * @param {number} y y-coord of pixel
             * @return {number} RGBA of pixel in 0xRRGGBBAA form
             */
            getRGBA(H, P) {
              const M = (P * this.bitmap.width + H) * 4;
              return this.bitmap.data.readUInt32BE(M);
            }
            /**
             * Gets a set of all RGBA colors found within the image.
             * 
             * @return {Set} Set of all RGBA colors that the image contains.
             */
            getRGBASet() {
              const H = /* @__PURE__ */ new Set(), P = this.bitmap.data;
              for (let M = 0; M < P.length; M += 4)
                H.add(P.readUInt32BE(M, !0));
              return H;
            }
            /**
             * Converts the image to greyscale using inferred Adobe metrics.
             * 
             * @return {BitmapImage} The present image to allow for chaining.
             */
            greyscale() {
              const H = this.bitmap.data;
              return this.scan(0, 0, this.bitmap.width, this.bitmap.height, (P, M, E) => {
                const x = Math.round(
                  0.299 * H[E] + 0.587 * H[E + 1] + 0.114 * H[E + 2]
                );
                H[E] = x, H[E + 1] = x, H[E + 2] = x;
              }), this;
            }
            /**
             * Reframes the image as if placing a frame around the original image and replacing the original image with the newly framed image. When the new frame is strictly within the boundaries of the original image, this method crops the image. When any of the new boundaries exceed those of the original image, the `fillRGBA` must be provided to indicate the color with which to fill the extra space added to the image.
             * 
             * @param {number} xOffset The x-coord offset of the upper-left pixel of the desired image relative to the present image.
             * @param {number} yOffset The y-coord offset of the upper-left pixel of the desired image relative to the present image.
             * @param {number} width The width of the new image after reframing
             * @param {number} height The height of the new image after reframing
             * @param {number} fillRGBA The color with which to fill space added to the image as a result of the reframing, in 0xRRGGBBAA format, where AA is 0x00 to indicate transparent and a non-zero value to indicate opaque. This parameter is only required when the reframing exceeds the original boundaries (i.e. does not simply perform a crop).
             * @return {BitmapImage} The present image to allow for chaining.
             */
            reframe(H, P, M, E, x) {
              const m = H < 0 ? 0 : H, I = P < 0 ? 0 : P, z = M + m > this.bitmap.width ? this.bitmap.width - m : M, w = E + I > this.bitmap.height ? this.bitmap.height - I : E, C = H < 0 ? -H : 0, b = P < 0 ? -P : 0;
              let B;
              if (x === void 0) {
                if (m !== H || I != P || z !== M || w !== E)
                  throw new GifError("fillRGBA required for this reframing");
                B = new r(M, E);
              } else
                B = new r(M, E, x);
              return this.blit(B, C, b, m, I, z, w), this.bitmap = B.bitmap, this;
            }
            /**
             * Scales the image size up by an integer factor. Each pixel of the original image becomes a square of the same color in the new image having a size of `factor` x `factor` pixels.
             * 
             * @param {number} factor The factor by which to scale up the image. Must be an integer >= 1.
             * @return {BitmapImage} The present image to allow for chaining.
             */
            scale(H) {
              if (H === 1)
                return;
              if (!Number.isInteger(H) || H < 1)
                throw new Error("the scale must be an integer >= 1");
              const P = this.bitmap.width, M = this.bitmap.height, E = P * H * 4, x = this.bitmap.data, m = new Q(M * E * H);
              let I = 0, z, w = 0;
              for (let C = 0; C < M; ++C) {
                z = w;
                for (let b = 0; b < P; ++b) {
                  const B = x.readUInt32BE(I, !0);
                  for (let N = 0; N < H; ++N)
                    m.writeUInt32BE(B, w), w += 4;
                  I += 4;
                }
                for (let b = 1; b < H; ++b)
                  m.copy(m, w, z, w), w += E, z += E;
              }
              return this.bitmap = {
                width: P * H,
                height: M * H,
                data: m
              }, this;
            }
            /**
             * Scans all coordinates of the image, handing each in turn to the provided handler function.
             *
             * @param {function} scanHandler A function(x: number, y: number, bi: number) to be called for each pixel of the image with that pixel's x-coord, y-coord, and index into the `data` buffer. The function accesses the pixel at this coordinate by accessing the `this.data` at index `bi`.
             * @see scanAllIndexes
             */
            scanAllCoords(H) {
              const P = this.bitmap.width, M = this.bitmap.data.length;
              let E = 0, x = 0;
              for (let m = 0; m < M; m += 4)
                H(E, x, m), ++E === P && (E = 0, ++x);
            }
            /**
             * Scans all pixels of the image, handing the index of each in turn to the provided handler function. Runs a bit faster than `scanAllCoords()`, should the handler not need pixel coordinates.
             *
             * @param {function} scanHandler A function(bi: number) to be called for each pixel of the image with that pixel's index into the `data` buffer. The pixels is found at index 'bi' within `this.data`.
             * @see scanAllCoords
             */
            scanAllIndexes(H) {
              const P = this.bitmap.data.length;
              for (let M = 0; M < P; M += 4)
                H(M);
            }
          }
          Ee.exports = r;
        }).call(this, te("buffer").Buffer);
      }, { buffer: 48 }], 66: [function(te, Ee, $) {
        class Q {
          // width - width of GIF in pixels
          // height - height of GIF in pixels
          // loops - 0 = unending; (n > 0) = iterate n times
          // usesTransparency - whether any frames have transparent pixels
          // colorScope - scope of color tables in GIF
          // frames - array of frames
          // buffer - GIF-formatted data
          /**
           * Gif is a class representing an encoded GIF. It is intended to be a read-only representation of a byte-encoded GIF. Only encoders and decoders should be creating instances of this class.
           * 
           * Property | Description
           * --- | ---
           * width | width of the GIF at its widest
           * height | height of the GIF at its highest
           * loops | the number of times the GIF should loop before stopping; 0 => loop indefinately
           * usesTransparency | boolean indicating whether at least one frame contains at least one transparent pixel
           * colorScope | the scope of the color tables as encoded within the GIF; either Gif.GlobalColorsOnly (== 1) or Gif.LocalColorsOnly (== 2).
           * frames | a array of GifFrame instances, one for each frame of the GIF
           * buffer | a Buffer holding the encoding's byte data
           * 
           * Its constructor should only ever be called by the GIF encoder or decoder.
           *
           * @param {Buffer} buffer A Buffer containing the encoded bytes
           * @param {GifFrame[]} frames Array of frames found in the encoding
           * @param {object} spec Properties of the encoding as listed above
           */
          constructor(H, P, M) {
            this.width = M.width, this.height = M.height, this.loops = M.loops, this.usesTransparency = M.usesTransparency, this.colorScope = M.colorScope, this.frames = P, this.buffer = H;
          }
        }
        Q.GlobalColorsPreferred = 0, Q.GlobalColorsOnly = 1, Q.LocalColorsOnly = 2;
        class r extends Error {
          /**
           * GifError is a class representing a GIF-related error
           * 
           * @param {string|Error} messageOrError
           */
          constructor(H) {
            super(H), H instanceof Error && (this.stack = "Gif" + H.stack);
          }
        }
        $.Gif = Q, $.GifError = r;
      }, {}], 67: [function(te, Ee, $) {
        (function(Q, r) {
          const F = te("omggif"), { Gif: H, GifError: P } = te("./gif");
          let M;
          Q.nextTick(() => {
            M = te("./gifutil");
          });
          const { GifFrame: E } = te("./gifframe"), x = 200, m = 100;
          class I {
            // _transparentRGBA - RGB given to transparent pixels (alpha=0) on decode; defaults to null indicating 0x000000, which is fastest
            /**
             * GifCodec is a class that both encodes and decodes GIFs. It implements both the `encode()` method expected of an encoder and the `decode()` method expected of a decoder, and it wraps the `omggif` GIF encoder/decoder package. GifCodec serves as this library's default encoder and decoder, but it's possible to wrap other GIF encoders and decoders for use by `gifwrap` as well. GifCodec will not encode GIFs with interlacing.
             * 
             * Instances of this class are stateless and can be shared across multiple encodings and decodings.
             * 
             * Its constructor takes one option argument:
             * 
             * @param {object} options Optionally takes an objection whose only possible property is `transparentRGB`. Images are internally represented in RGBA format, where A is the alpha value of a pixel. When `transparentRGB` is provided, this RGB value (excluding alpha) is assigned to transparent pixels, which are also given alpha value 0x00. (All opaque pixels are given alpha value 0xFF). The RGB color of transparent pixels shouldn't matter for most applications. Defaults to 0x000000.
             */
            constructor(Y = {}) {
              this._transparentRGB = null, typeof Y.transparentRGB == "number" && Y.transparentRGB !== 0 && (this._transparentRGBA = Y.transparentRGB * 256), this._testInitialBufferSize = 0;
            }
            /**
             * Decodes a GIF from a Buffer to yield an instance of Gif. Transparent pixels of the GIF are given alpha values of 0x00, and opaque pixels are given alpha values of 0xFF. The RGB values of transparent pixels default to 0x000000 but can be overridden by the constructor's `transparentRGB` option.
             * 
             * @param {Buffer} buffer Bytes of an encoded GIF to decode.
             * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
             * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
             */
            decodeGif(Y) {
              try {
                let re;
                try {
                  re = new F.GifReader(Y);
                } catch (be) {
                  throw new P(be);
                }
                const se = re.numFrames(), ve = [], ce = {
                  width: re.width,
                  height: re.height,
                  loops: re.loopCount()
                };
                ce.usesTransparency = !1;
                for (let be = 0; be < se; ++be) {
                  const Me = this._decodeFrame(re, be, ce.usesTransparency);
                  ve.push(Me.frame), Me.usesTransparency && (ce.usesTransparency = !0);
                }
                return Promise.resolve(new H(Y, ve, ce));
              } catch (re) {
                return Promise.reject(re);
              }
            }
            /**
             * Encodes a GIF from provided frames. Each pixel having an alpha value of 0x00 renders as transparent within the encoding, while all pixels of non-zero alpha value render as opaque.
             * 
             * @param {GifFrame[]} frames Array of frames to encode
             * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely, and `colorScope` defaults to Gif.GlobalColorsPreferred.
             * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
             * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
             */
            encodeGif(Y, re = {}) {
              try {
                if (Y === null || Y.length === 0)
                  throw new P("there are no frames");
                const se = M.getMaxDimensions(Y);
                return re = Object.assign({}, re), re.width = se.maxWidth, re.height = se.maxHeight, re.loops = re.loops || 0, re.colorScope = re.colorScope || H.GlobalColorsPreferred, Promise.resolve(this._encodeGif(Y, re));
              } catch (se) {
                return Promise.reject(se);
              }
            }
            _decodeFrame(Y, re, se) {
              let ve, ce;
              try {
                if (ve = Y.frameInfo(re), ce = new r(Y.width * Y.height * 4), Y.decodeAndBlitFrameRGBA(re, ce), ve.width !== Y.width || ve.height !== Y.height) {
                  if (ve.y && (ce = ce.slice(ve.y * Y.width * 4)), Y.width > ve.width)
                    for (let xe = 0; xe < ve.height; ++xe)
                      ce.copy(
                        ce,
                        xe * ve.width * 4,
                        (ve.x + xe * Y.width) * 4,
                        (ve.x + xe * Y.width) * 4 + ve.width * 4
                      );
                  ce = ce.slice(0, ve.width * ve.height * 4);
                }
              } catch (xe) {
                throw new P(xe);
              }
              let be = !1;
              if (this._transparentRGBA === null) {
                if (!se)
                  for (let xe = 3; xe < ce.length; xe += 4)
                    ce[xe] === 0 && (be = !0, xe = ce.length);
              } else
                for (let xe = 3; xe < ce.length; xe += 4)
                  ce[xe] === 0 && (ce.writeUInt32BE(this._transparentRGBA, xe - 3), be = !0);
              return { frame: new E(ve.width, ve.height, ce, {
                xOffset: ve.x,
                yOffset: ve.y,
                disposalMethod: ve.disposal,
                interlaced: ve.interlaced,
                delayCentisecs: ve.delay
              }), usesTransparency: be };
            }
            _encodeGif(Y, re) {
              let se;
              if (re.colorScope === H.LocalColorsOnly)
                se = M.getColorInfo(Y, 0);
              else if (se = M.getColorInfo(Y, 256), !se.colors) {
                if (re.colorScope === H.GlobalColorsOnly)
                  throw new P(
                    "Too many color indexes for global color table"
                  );
                re.colorScope = H.LocalColorsOnly;
              }
              re.usesTransparency = se.usesTransparency;
              const ve = se.palettes;
              return re.colorScope === H.LocalColorsOnly ? b(Y, re, 2e3, ve) : C(Y, re, 2e3, se);
            }
            _getSizeEstimateGlobal(Y, re) {
              if (this._testInitialBufferSize > 0)
                return this._testInitialBufferSize;
              let se = x + 3 * 256;
              const ve = V(Y);
              return re.forEach((ce) => {
                se += N(ce, ve);
              }), se;
            }
            _getSizeEstimateLocal(Y, re) {
              if (this._testInitialBufferSize > 0)
                return this._testInitialBufferSize;
              let se = x;
              for (let ve = 0; ve < re.length; ++ve) {
                const ce = Y[ve], be = V(ce);
                se += N(re[ve], be);
              }
              return se;
            }
          }
          $.GifCodec = I;
          function z(q, Y) {
            const re = q.indexOf(Y);
            return re === -1 ? null : re;
          }
          function w(q, Y) {
            for (var re = 0, se = q.length - 1, ve; re <= se; )
              if (ve = Math.floor((re + se) / 2), q[ve] > Y)
                se = ve - 1;
              else if (q[ve] < Y)
                re = ve + 1;
              else
                return ve;
            return null;
          }
          function C(q, Y, re, se) {
            const ve = {
              colors: se.colors.slice(),
              usesTransparency: se.usesTransparency
            };
            B(ve);
            const ce = {
              palette: ve.colors,
              loop: Y.loops
            };
            let be = new r(re), Me;
            try {
              Me = new F.GifWriter(
                be,
                Y.width,
                Y.height,
                ce
              );
            } catch (xe) {
              throw new P(xe);
            }
            for (let xe = 0; xe < q.length; ++xe)
              be = W(Me, xe, q[xe], se, !1);
            return new H(be.slice(0, Me.end()), q, Y);
          }
          function b(q, Y, re, se) {
            const ve = {
              loop: Y.loops
            };
            let ce = new r(re), be;
            try {
              be = new F.GifWriter(
                ce,
                Y.width,
                Y.height,
                ve
              );
            } catch (Me) {
              throw new P(Me);
            }
            for (let Me = 0; Me < q.length; ++Me)
              ce = W(be, Me, q[Me], se[Me], !0);
            return new H(ce.slice(0, be.end()), q, Y);
          }
          function B(q) {
            const Y = q.colors;
            q.usesTransparency && Y.push(0);
            const re = Y.length;
            let se = 2;
            for (; re > se; )
              se <<= 1;
            Y.length = se, Y.fill(0, re);
          }
          function N(q, Y) {
            let re = q.bitmap.width * q.bitmap.height;
            return re = Math.ceil(re * Y / 8), re += Math.ceil(re / 255), m + re + 3 * 256;
          }
          function U(q, Y, re) {
            const se = re.colors, ve = se.length <= 8 ? (
              // guess at the break-even
              z
            ) : w, ce = Y.bitmap.data, be = new r(ce.length / 4);
            let Me = se.length, xe = 0, le = 0;
            for (; xe < ce.length; ) {
              if (ce[xe + 3] !== 0) {
                const de = ce.readUInt32BE(xe, !0) >> 8 & 16777215;
                be[le] = ve(se, de);
              } else
                be[le] = Me;
              xe += 4, ++le;
            }
            if (re.usesTransparency) {
              if (Me === 256)
                throw new P(`Frame ${q} already has 256 colorsand so can't use transparency`);
            } else
              Me = null;
            return { buffer: be, transparentIndex: Me };
          }
          function V(q) {
            let Y = q.indexCount, re = 0;
            for (--Y; Y; )
              ++re, Y >>= 1;
            return re > 0 ? re : 1;
          }
          function W(q, Y, re, se, ve) {
            if (re.interlaced)
              throw new P("writing interlaced GIFs is not supported");
            const ce = U(Y, re, se), be = {
              delay: re.delayCentisecs,
              disposal: re.disposalMethod,
              transparent: ce.transparentIndex
            };
            ve && (B(se), be.palette = se.colors);
            try {
              let Me = q.getOutputBuffer(), xe = q.getOutputBufferPosition(), le, de = !0;
              for (; de; )
                if (le = q.addFrame(
                  re.xOffset,
                  re.yOffset,
                  re.bitmap.width,
                  re.bitmap.height,
                  ce.buffer,
                  be
                ), de = !1, le >= Me.length - 1) {
                  const De = new r(Me.length * 1.5);
                  Me.copy(De), q.setOutputBuffer(De), q.setOutputBufferPosition(xe), Me = De, de = !0;
                }
              return Me;
            } catch (Me) {
              throw new P(Me);
            }
          }
        }).call(this, te("_process"), te("buffer").Buffer);
      }, { "./gif": 66, "./gifframe": 68, "./gifutil": 69, _process: 133, buffer: 48, omggif: 64 }], 68: [function(te, Ee, $) {
        const Q = te("./bitmapimage");
        te("./gif");
        class r extends Q {
          // xOffset - x offset of bitmap on GIF (defaults to 0)
          // yOffset - y offset of bitmap on GIF (defaults to 0)
          // disposalMethod - pixel disposal method when handling partial images
          // delayCentisecs - duration of frame in hundredths of a second
          // interlaced - whether the image is interlaced (defaults to false)
          /**
           * GifFrame is a class representing an image frame of a GIF. GIFs contain one or more instances of GifFrame.
           * 
           * Property | Description
           * --- | ---
           * xOffset | x-coord of position within GIF at which to render the image (defaults to 0)
           * yOffset | y-coord of position within GIF at which to render the image (defaults to 0)
           * disposalMethod | GIF disposal method; only relevant when the frames aren't all the same size (defaults to 2, disposing to background color)
           * delayCentisecs | duration of the frame in hundreths of a second
           * interlaced | boolean indicating whether the frame renders interlaced
           * 
           * Its constructor supports the following signatures:
           * 
           * * new GifFrame(bitmap: {width: number, height: number, data: Buffer}, options?)
           * * new GifFrame(bitmapImage: BitmapImage, options?)
           * * new GifFrame(width: number, height: number, buffer: Buffer, options?)
           * * new GifFrame(width: number, height: number, backgroundRGBA?: number, options?)
           * * new GifFrame(frame: GifFrame)
           * 
           * See the base class BitmapImage for a discussion of all parameters but `options` and `frame`. `options` is an optional argument providing initial values for the above-listed GifFrame properties. Each property within option is itself optional.
           * 
           * Provide a `frame` to the constructor to create a clone of the provided frame. The new frame includes a copy of the provided frame's pixel data so that each can subsequently be modified without affecting each other.
           */
          constructor(...H) {
            if (super(...H), H[0] instanceof r) {
              const P = H[0];
              this.xOffset = P.xOffset, this.yOffset = P.yOffset, this.disposalMethod = P.disposalMethod, this.delayCentisecs = P.delayCentisecs, this.interlaced = P.interlaced;
            } else {
              const P = H[H.length - 1];
              let M = {};
              typeof P == "object" && !(P instanceof Q) && (M = P), this.xOffset = M.xOffset || 0, this.yOffset = M.yOffset || 0, this.disposalMethod = M.disposalMethod !== void 0 ? M.disposalMethod : r.DisposeToBackgroundColor, this.delayCentisecs = M.delayCentisecs || 8, this.interlaced = M.interlaced || !1;
            }
          }
          /**
           * Get a summary of the colors found within the frame. The return value is an object of the following form:
           * 
           * Property | Description
           * --- | ---
           * colors | An array of all the opaque colors found within the frame. Each color is given as an RGB number of the form 0xRRGGBB. The array is sorted by increasing number. Will be an empty array when the image is completely transparent.
           * usesTransparency | boolean indicating whether there are any transparent pixels within the frame. A pixel is considered transparent if its alpha value is 0x00.
           * indexCount | The number of color indexes required to represent this palette of colors. It is equal to the number of opaque colors plus one if the image includes transparency.
           * 
           * @return {object} An object representing a color palette as described above.
           */
          getPalette() {
            const H = /* @__PURE__ */ new Set(), P = this.bitmap.data;
            let M = 0, E = !1;
            for (; M < P.length; ) {
              if (P[M + 3] === 0)
                E = !0;
              else {
                const z = P.readUInt32BE(M, !0) >> 8 & 16777215;
                H.add(z);
              }
              M += 4;
            }
            const x = new Array(H.size), m = H.values();
            for (M = 0; M < x.length; ++M)
              x[M] = m.next().value;
            x.sort((z, w) => z - w);
            let I = x.length;
            return E && ++I, { colors: x, usesTransparency: E, indexCount: I };
          }
        }
        r.DisposeToAnything = 0, r.DisposeNothing = 1, r.DisposeToBackgroundColor = 2, r.DisposeToPrevious = 3, $.GifFrame = r;
      }, { "./bitmapimage": 65, "./gif": 66 }], 69: [function(te, Ee, $) {
        (function(Q) {
          const r = te("fs"), F = te("image-q"), H = te("./bitmapimage"), { GifFrame: P } = te("./gifframe"), { GifError: M } = te("./gif"), { GifCodec: E } = te("./gifcodec"), x = [".jpg", ".jpeg", ".png", ".bmp"], m = new E();
          $.cloneFrames = function(C) {
            let b = [];
            return C.forEach((B) => {
              b.push(new P(B));
            }), b;
          }, $.getColorInfo = function(C, b) {
            let B = !1;
            const N = [];
            for (let Y = 0; Y < C.length; ++Y) {
              let re = C[Y].getPalette();
              if (re.usesTransparency && (B = !0), re.indexCount > 256)
                throw new M(`Frame ${Y} uses more than 256 color indexes`);
              N.push(re);
            }
            if (b === 0)
              return { usesTransparency: B, palettes: N };
            const U = /* @__PURE__ */ new Set();
            N.forEach((Y) => {
              Y.colors.forEach((re) => {
                U.add(re);
              });
            });
            let V = U.size;
            if (B && ++V, b && V > b)
              return { usesTransparency: B, palettes: N };
            const W = new Array(U.size), q = U.values();
            for (let Y = 0; Y < W.length; ++Y)
              W[Y] = q.next().value;
            return W.sort((Y, re) => Y - re), { colors: W, indexCount: V, usesTransparency: B, palettes: N };
          }, $.copyAsJimp = function(C, b) {
            return $.shareAsJimp(C, new H(b));
          }, $.getMaxDimensions = function(C) {
            let b = 0, B = 0;
            return C.forEach((N) => {
              const U = N.xOffset + N.bitmap.width;
              U > b && (b = U);
              const V = N.yOffset + N.bitmap.height;
              V > B && (B = V);
            }), { maxWidth: b, maxHeight: B };
          }, $.quantizeDekker = function(C, b, B) {
            b = b || 256, I(C, "NeuQuantFloat", b, 0, B);
          }, $.quantizeSorokin = function(C, b, B, N) {
            b = b || 256, B = B || "min-pop";
            let U;
            switch (B) {
              case "min-pop":
                U = 2;
                break;
              case "top-pop":
                U = 1;
                break;
              default:
                throw new Error(`Invalid quantizeSorokin histogram '${B}'`);
            }
            I(C, "RGBQuant", b, U, N);
          }, $.quantizeWu = function(C, b, B, N) {
            if (b = b || 256, B = B || 5, B < 1 || B > 8)
              throw new Error("Invalid quantization quality");
            I(C, "WuQuant", b, B, N);
          }, $.read = function(C, b) {
            return b = b || m, Q.isBuffer(C) ? b.decodeGif(C) : z(C).then((B) => b.decodeGif(B));
          }, $.shareAsJimp = function(C, b) {
            const B = new C(
              b.bitmap.width,
              b.bitmap.height,
              0
            );
            return B.bitmap.data = b.bitmap.data, B;
          }, $.write = function(C, b, B, N) {
            N = N || m;
            const U = C.match(/\.[a-zA-Z]+$/);
            if (U !== null && x.includes(U[0].toLowerCase()))
              throw new Error(`GIF '${C}' has an unexpected suffix`);
            return N.encodeGif(b, B).then((V) => w(C, V.buffer).then(() => V));
          };
          function I(C, b, B, N, U) {
            const V = Array.isArray(C) ? C : [C], W = [
              "FloydSteinberg",
              "FalseFloydSteinberg",
              "Stucki",
              "Atkinson",
              "Jarvis",
              "Burkes",
              "Sierra",
              "TwoSierra",
              "SierraLite"
            ];
            if (U) {
              if (W.indexOf(U.ditherAlgorithm) < 0)
                throw new Error(`Invalid ditherAlgorithm '${U.ditherAlgorithm}'`);
              U.serpentine === void 0 && (U.serpentine = !0), U.minimumColorDistanceToDither === void 0 && (U.minimumColorDistanceToDither = 0), U.calculateErrorLikeGIMP === void 0 && (U.calculateErrorLikeGIMP = !1);
            }
            const q = new F.distance.Euclidean(), Y = new F.palette[b](q, B, N);
            let re;
            U ? re = new F.image.ErrorDiffusionArray(
              q,
              F.image.ErrorDiffusionArrayKernel[U.ditherAlgorithm],
              U.serpentine,
              U.minimumColorDistanceToDither,
              U.calculateErrorLikeGIMP
            ) : re = new F.image.NearestColor(q);
            const se = [];
            V.forEach((ce) => {
              const be = ce.bitmap.data, Me = new ArrayBuffer(be.length), xe = new Uint32Array(Me);
              for (let de = 0, De = 0; de < be.length; de += 4, ++De)
                xe[De] = be.readUInt32LE(de, !0);
              const le = F.utils.PointContainer.fromUint32Array(
                xe,
                ce.bitmap.width,
                ce.bitmap.height
              );
              Y.sample(le), se.push(le);
            });
            const ve = Y.quantize();
            for (let ce = 0; ce < V.length; ++ce) {
              const be = V[ce].bitmap.data, xe = re.quantize(se[ce], ve).toUint32Array();
              for (let le = 0, de = 0; le < be.length; le += 4, ++de)
                be.writeUInt32LE(xe[de], le);
            }
          }
          function z(C) {
            return new Promise((b, B) => {
              r.readFile(C, (N, U) => N ? B(N) : b(U));
            });
          }
          function w(C, b) {
            return new Promise((B, N) => {
              r.writeFile(C, b, (U) => U ? N(U) : B());
            });
          }
        }).call(this, { isBuffer: te("../../is-buffer/index.js") });
      }, { "../../is-buffer/index.js": 76, "./bitmapimage": 65, "./gif": 66, "./gifcodec": 67, "./gifframe": 68, fs: 47, "image-q": 74 }], 70: [function(te, Ee, $) {
        const Q = te("./bitmapimage"), { Gif: r, GifError: F } = te("./gif"), { GifCodec: H } = te("./gifcodec"), { GifFrame: P } = te("./gifframe"), M = te("./gifutil");
        Ee.exports = {
          BitmapImage: Q,
          Gif: r,
          GifCodec: H,
          GifFrame: P,
          GifUtil: M,
          GifError: F
        };
      }, { "./bitmapimage": 65, "./gif": 66, "./gifcodec": 67, "./gifframe": 68, "./gifutil": 69 }], 71: [function(te, Ee, $) {
        (function(Q) {
          var r;
          typeof pt < "u" ? r = pt : typeof Q < "u" ? r = Q : typeof self < "u" ? r = self : r = {}, Ee.exports = r;
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {});
      }, {}], 72: [function(te, Ee, $) {
        var Q = te("http"), r = te("url"), F = Ee.exports;
        for (var H in Q)
          Q.hasOwnProperty(H) && (F[H] = Q[H]);
        F.request = function(M, E) {
          return M = P(M), Q.request.call(this, M, E);
        }, F.get = function(M, E) {
          return M = P(M), Q.get.call(this, M, E);
        };
        function P(M) {
          if (typeof M == "string" && (M = r.parse(M)), M.protocol || (M.protocol = "https:"), M.protocol !== "https:")
            throw new Error('Protocol "' + M.protocol + '" not supported. Expected "https:"');
          return M;
        }
      }, { http: 156, url: 180 }], 73: [function(te, Ee, $) {
        $.read = function(Q, r, F, H, P) {
          var M, E, x = P * 8 - H - 1, m = (1 << x) - 1, I = m >> 1, z = -7, w = F ? P - 1 : 0, C = F ? -1 : 1, b = Q[r + w];
          for (w += C, M = b & (1 << -z) - 1, b >>= -z, z += x; z > 0; M = M * 256 + Q[r + w], w += C, z -= 8)
            ;
          for (E = M & (1 << -z) - 1, M >>= -z, z += H; z > 0; E = E * 256 + Q[r + w], w += C, z -= 8)
            ;
          if (M === 0)
            M = 1 - I;
          else {
            if (M === m)
              return E ? NaN : (b ? -1 : 1) * (1 / 0);
            E = E + Math.pow(2, H), M = M - I;
          }
          return (b ? -1 : 1) * E * Math.pow(2, M - H);
        }, $.write = function(Q, r, F, H, P, M) {
          var E, x, m, I = M * 8 - P - 1, z = (1 << I) - 1, w = z >> 1, C = P === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, b = H ? 0 : M - 1, B = H ? 1 : -1, N = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
          for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (x = isNaN(r) ? 1 : 0, E = z) : (E = Math.floor(Math.log(r) / Math.LN2), r * (m = Math.pow(2, -E)) < 1 && (E--, m *= 2), E + w >= 1 ? r += C / m : r += C * Math.pow(2, 1 - w), r * m >= 2 && (E++, m /= 2), E + w >= z ? (x = 0, E = z) : E + w >= 1 ? (x = (r * m - 1) * Math.pow(2, P), E = E + w) : (x = r * Math.pow(2, w - 1) * Math.pow(2, P), E = 0)); P >= 8; Q[F + b] = x & 255, b += B, x /= 256, P -= 8)
            ;
          for (E = E << P | x, I += P; I > 0; Q[F + b] = E & 255, b += B, E /= 256, I -= 8)
            ;
          Q[F + b - B] |= N * 128;
        };
      }, {}], 74: [function(te, Ee, $) {
        (function(r, F) {
          typeof $ == "object" && typeof Ee == "object" ? Ee.exports = F() : typeof $ == "object" ? $.iq = F() : r.iq = F();
        })(this, function() {
          return (
            /******/
            function(Q) {
              var r = {};
              function F(H) {
                if (r[H])
                  return r[H].exports;
                var P = r[H] = {
                  /******/
                  exports: {},
                  /******/
                  id: H,
                  /******/
                  loaded: !1
                  /******/
                };
                return Q[H].call(P.exports, P, P.exports, F), P.loaded = !0, P.exports;
              }
              return F.m = Q, F.c = r, F.p = "", F(0);
            }([
              /* 0 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var H = F(1);
                r.constants = H;
                var P = F(3);
                r.conversion = P;
                var M = F(12);
                r.distance = M;
                var E = F(20);
                r.palette = E;
                var x = F(30);
                r.image = x;
                var m = F(35);
                r.quality = m;
                var I = F(37);
                r.utils = I;
              },
              /* 1 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * constants.ts - part of Image Quantization Library
                 */
                var H = F(2);
                r.bt709 = H;
              },
              /* 2 */
              /***/
              function(Q, r) {
                var F;
                (function(M) {
                  M[M.RED = 0.2126] = "RED", M[M.GREEN = 0.7152] = "GREEN", M[M.BLUE = 0.0722] = "BLUE", M[M.WHITE = 1] = "WHITE";
                })(F || (F = {})), r.Y = F;
                var H;
                (function(M) {
                  M[M.RED = 0.64] = "RED", M[M.GREEN = 0.3] = "GREEN", M[M.BLUE = 0.15] = "BLUE", M[M.WHITE = 0.3127] = "WHITE";
                })(H || (H = {})), r.x = H;
                var P;
                (function(M) {
                  M[M.RED = 0.33] = "RED", M[M.GREEN = 0.6] = "GREEN", M[M.BLUE = 0.06] = "BLUE", M[M.WHITE = 0.329] = "WHITE";
                })(P || (P = {})), r.y = P;
              },
              /* 3 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var H = F(4);
                r.rgb2xyz = H.rgb2xyz;
                var P = F(5);
                r.rgb2hsl = P.rgb2hsl;
                var M = F(7);
                r.rgb2lab = M.rgb2lab;
                var E = F(9);
                r.lab2xyz = E.lab2xyz;
                var x = F(10);
                r.lab2rgb = x.lab2rgb;
                var m = F(8);
                r.xyz2lab = m.xyz2lab;
                var I = F(11);
                r.xyz2rgb = I.xyz2rgb;
              },
              /* 4 */
              /***/
              function(Q, r) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgb2xyz.ts - part of Image Quantization Library
                 */
                function F(P) {
                  return P > 0.04045 ? Math.pow((P + 0.055) / 1.055, 2.4) : P / 12.92;
                }
                function H(P, M, E) {
                  return P = F(P / 255), M = F(M / 255), E = F(E / 255), {
                    x: P * 0.4124 + M * 0.3576 + E * 0.1805,
                    y: P * 0.2126 + M * 0.7152 + E * 0.0722,
                    z: P * 0.0193 + M * 0.1192 + E * 0.9505
                  };
                }
                r.rgb2xyz = H;
              },
              /* 5 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgb2hsl.ts - part of Image Quantization Library
                 */
                var H = F(6);
                function P(M, E, x) {
                  var m = H.min3(M, E, x), I = H.max3(M, E, x), z = I - m, w = (m + I) / 510, C = 0;
                  w > 0 && w < 1 && (C = z / (w < 0.5 ? I + m : 510 - I - m));
                  var b = 0;
                  return z > 0 && (I === M ? b = (E - x) / z : I === E ? b = 2 + (x - M) / z : b = 4 + (M - E) / z, b *= 60, b < 0 && (b += 360)), { h: b, s: C, l: w };
                }
                r.rgb2hsl = P;
              },
              /* 6 */
              /***/
              function(Q, r) {
                function F(I) {
                  return I * (Math.PI / 180);
                }
                r.degrees2radians = F;
                function H(I, z, w) {
                  var C = I;
                  return C < z && (C = z), C < w && (C = w), C;
                }
                r.max3 = H;
                function P(I, z, w) {
                  var C = I;
                  return C > z && (C = z), C > w && (C = w), C;
                }
                r.min3 = P;
                function M(I, z, w) {
                  return I > w && (I = w), I < z && (I = z), I | 0;
                }
                r.intInRange = M;
                function E(I) {
                  return I = Math.round(I), I > 255 ? I = 255 : I < 0 && (I = 0), I;
                }
                r.inRange0to255Rounded = E;
                function x(I) {
                  return I > 255 ? I = 255 : I < 0 && (I = 0), I;
                }
                r.inRange0to255 = x;
                function m(I, z) {
                  var w = typeof I[0], C;
                  if (w === "number" || w === "string") {
                    for (var b = /* @__PURE__ */ Object.create(null), B = 0, N = I.length; B < N; B++) {
                      var U = I[B];
                      b[U] || b[U] === 0 || (b[U] = B);
                    }
                    C = I.sort(function(W, q) {
                      return z(W, q) || b[W] - b[q];
                    });
                  } else {
                    var V = I.slice(0);
                    C = I.sort(function(W, q) {
                      return z(W, q) || V.indexOf(W) - V.indexOf(q);
                    });
                  }
                  return C;
                }
                r.stableSort = m;
              },
              /* 7 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgb2lab.ts - part of Image Quantization Library
                 */
                var H = F(4), P = F(8);
                function M(E, x, m) {
                  var I = H.rgb2xyz(E, x, m);
                  return P.xyz2lab(I.x, I.y, I.z);
                }
                r.rgb2lab = M;
              },
              /* 8 */
              /***/
              function(Q, r) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * xyz2lab.ts - part of Image Quantization Library
                 */
                var F = 0.95047, H = 1, P = 1.08883;
                function M(x) {
                  return x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
                }
                function E(x, m, I) {
                  if (x = M(x / F), m = M(m / H), I = M(I / P), 116 * m - 16 < 0)
                    throw new Error("xxx");
                  return {
                    L: Math.max(0, 116 * m - 16),
                    a: 500 * (x - m),
                    b: 200 * (m - I)
                  };
                }
                r.xyz2lab = E;
              },
              /* 9 */
              /***/
              function(Q, r) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * lab2xyz.ts - part of Image Quantization Library
                 */
                var F = 0.95047, H = 1, P = 1.08883;
                function M(x) {
                  return x > 0.206893034 ? Math.pow(x, 3) : (x - 16 / 116) / 7.787;
                }
                function E(x, m, I) {
                  var z = (x + 16) / 116, w = m / 500 + z, C = z - I / 200;
                  return {
                    x: F * M(w),
                    y: H * M(z),
                    z: P * M(C)
                  };
                }
                r.lab2xyz = E;
              },
              /* 10 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * lab2rgb.ts - part of Image Quantization Library
                 */
                var H = F(9), P = F(11);
                function M(E, x, m) {
                  var I = H.lab2xyz(E, x, m);
                  return P.xyz2rgb(I.x, I.y, I.z);
                }
                r.lab2rgb = M;
              },
              /* 11 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * xyz2rgb.ts - part of Image Quantization Library
                 */
                var H = F(6);
                function P(E) {
                  return E > 31308e-7 ? 1.055 * Math.pow(E, 1 / 2.4) - 0.055 : 12.92 * E;
                }
                function M(E, x, m) {
                  var I = P(E * 3.2406 + x * -1.5372 + m * -0.4986), z = P(E * -0.9689 + x * 1.8758 + m * 0.0415), w = P(E * 0.0557 + x * -0.204 + m * 1.057);
                  return {
                    r: H.inRange0to255Rounded(I * 255),
                    g: H.inRange0to255Rounded(z * 255),
                    b: H.inRange0to255Rounded(w * 255)
                  };
                }
                r.xyz2rgb = M;
              },
              /* 12 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var H = F(13);
                r.AbstractDistanceCalculator = H.AbstractDistanceCalculator;
                var P = F(14);
                r.CIE94Textiles = P.CIE94Textiles, r.CIE94GraphicArts = P.CIE94GraphicArts;
                var M = F(15);
                r.CIEDE2000 = M.CIEDE2000;
                var E = F(16);
                r.CMETRIC = E.CMETRIC;
                var x = F(17);
                r.AbstractEuclidean = x.AbstractEuclidean, r.Euclidean = x.Euclidean, r.EuclideanRgbQuantWOAlpha = x.EuclideanRgbQuantWOAlpha, r.EuclideanRgbQuantWithAlpha = x.EuclideanRgbQuantWithAlpha;
                var m = F(18);
                r.AbstractManhattan = m.AbstractManhattan, r.Manhattan = m.Manhattan, r.ManhattanSRGB = m.ManhattanSRGB, r.ManhattanNommyde = m.ManhattanNommyde;
                var I = F(19);
                r.PNGQUANT = I.PNGQUANT;
              },
              /* 13 */
              /***/
              function(Q, r) {
                var F = function() {
                  function H() {
                    this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
                  }
                  return H.prototype.setWhitePoint = function(P, M, E, x) {
                    this._whitePoint = {
                      r: P > 0 ? 255 / P : 0,
                      g: M > 0 ? 255 / M : 0,
                      b: E > 0 ? 255 / E : 0,
                      a: x > 0 ? 255 / x : 0
                    }, this._maxDistance = this.calculateRaw(P, M, E, x, 0, 0, 0, 0);
                  }, H.prototype.calculateNormalized = function(P, M) {
                    return this.calculateRaw(P.r, P.g, P.b, P.a, M.r, M.g, M.b, M.a) / this._maxDistance;
                  }, H.prototype._setDefaults = function() {
                  }, H;
                }();
                r.AbstractDistanceCalculator = F;
              },
              /* 14 */
              /***/
              function(Q, r, F) {
                var H = this && this.__extends || function(z, w) {
                  for (var C in w) w.hasOwnProperty(C) && (z[C] = w[C]);
                  function b() {
                    this.constructor = z;
                  }
                  z.prototype = w === null ? Object.create(w) : (b.prototype = w.prototype, new b());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * cie94.ts - part of Image Quantization Library
                 */
                var P = F(13), M = F(7), E = F(6), x = function(z) {
                  H(w, z);
                  function w() {
                    z.apply(this, arguments);
                  }
                  return w.prototype.calculateRaw = function(C, b, B, N, U, V, W, q) {
                    var Y = M.rgb2lab(E.inRange0to255(C * this._whitePoint.r), E.inRange0to255(b * this._whitePoint.g), E.inRange0to255(B * this._whitePoint.b)), re = M.rgb2lab(E.inRange0to255(U * this._whitePoint.r), E.inRange0to255(V * this._whitePoint.g), E.inRange0to255(W * this._whitePoint.b)), se = Y.L - re.L, ve = Y.a - re.a, ce = Y.b - re.b, be = Math.sqrt(Y.a * Y.a + Y.b * Y.b), Me = Math.sqrt(re.a * re.a + re.b * re.b), xe = be - Me, le = ve * ve + ce * ce - xe * xe;
                    le = le < 0 ? 0 : Math.sqrt(le);
                    var de = (q - N) * this._whitePoint.a * this._kA;
                    return Math.sqrt(Math.pow(se / this._Kl, 2) + Math.pow(xe / (1 + this._K1 * be), 2) + Math.pow(le / (1 + this._K2 * be), 2) + Math.pow(de, 2));
                  }, w;
                }(P.AbstractDistanceCalculator);
                r.AbstractCIE94 = x;
                var m = function(z) {
                  H(w, z);
                  function w() {
                    z.apply(this, arguments);
                  }
                  return w.prototype._setDefaults = function() {
                    this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 0.25 * 50 / 255;
                  }, w;
                }(x);
                r.CIE94Textiles = m;
                var I = function(z) {
                  H(w, z);
                  function w() {
                    z.apply(this, arguments);
                  }
                  return w.prototype._setDefaults = function() {
                    this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 0.25 * 100 / 255;
                  }, w;
                }(x);
                r.CIE94GraphicArts = I;
              },
              /* 15 */
              /***/
              function(Q, r, F) {
                var H = this && this.__extends || function(m, I) {
                  for (var z in I) I.hasOwnProperty(z) && (m[z] = I[z]);
                  function w() {
                    this.constructor = m;
                  }
                  m.prototype = I === null ? Object.create(I) : (w.prototype = I.prototype, new w());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * ciede2000.ts - part of Image Quantization Library
                 */
                var P = F(13), M = F(7), E = F(6), x = function(m) {
                  H(I, m);
                  function I() {
                    m.apply(this, arguments);
                  }
                  return I.prototype.calculateRaw = function(z, w, C, b, B, N, U, V) {
                    var W = M.rgb2lab(E.inRange0to255(z * this._whitePoint.r), E.inRange0to255(w * this._whitePoint.g), E.inRange0to255(C * this._whitePoint.b)), q = M.rgb2lab(E.inRange0to255(B * this._whitePoint.r), E.inRange0to255(N * this._whitePoint.g), E.inRange0to255(U * this._whitePoint.b)), Y = (V - b) * this._whitePoint.a * I._kA, re = this.calculateRawInLab(W, q);
                    return Math.sqrt(re + Y * Y);
                  }, I.prototype.calculateRawInLab = function(z, w) {
                    var C = z.L, b = z.a, B = z.b, N = w.L, U = w.a, V = w.b, W = Math.sqrt(b * b + B * B), q = Math.sqrt(U * U + V * V), Y = Math.pow((W + q) / 2, 7), re = 0.5 * (1 - Math.sqrt(Y / (Y + I._pow25to7))), se = (1 + re) * b, ve = (1 + re) * U, ce = Math.sqrt(se * se + B * B), be = Math.sqrt(ve * ve + V * V), Me = ce * be, xe = I._calculatehp(B, se), le = I._calculatehp(V, ve), de = Math.abs(xe - le), De = N - C, ze = be - ce, Ze = I._calculate_dHp(Me, de, le, xe), Ue = I._calculate_ahp(Me, de, xe, le), Ie = I._calculateT(Ue), je = (ce + be) / 2, Fe = Math.pow((C + N) / 2 - 50, 2), $e = 1 + 0.015 * Fe / Math.sqrt(20 + Fe), ct = 1 + 0.045 * je, wt = 1 + 0.015 * Ie * je, Oe = I._calculateRT(Ue, je), Ct = De / $e, Xt = ze / ct, vt = Ze / wt;
                    return Math.pow(Ct, 2) + Math.pow(Xt, 2) + Math.pow(vt, 2) + Oe * Xt * vt;
                  }, I._calculatehp = function(z, w) {
                    var C = Math.atan2(z, w);
                    return C >= 0 ? C : C + I._deg360InRad;
                  }, I._calculateRT = function(z, w) {
                    var C = Math.pow(w, 7), b = 2 * Math.sqrt(C / (C + I._pow25to7)), B = I._deg30InRad * Math.exp(-Math.pow((z - I._deg275InRad) / I._deg25InRad, 2));
                    return -Math.sin(2 * B) * b;
                  }, I._calculateT = function(z) {
                    return 1 - 0.17 * Math.cos(z - I._deg30InRad) + 0.24 * Math.cos(z * 2) + 0.32 * Math.cos(z * 3 + I._deg6InRad) - 0.2 * Math.cos(z * 4 - I._deg63InRad);
                  }, I._calculate_ahp = function(z, w, C, b) {
                    var B = C + b;
                    return z == 0 ? B : w <= I._deg180InRad ? B / 2 : B < I._deg360InRad ? (B + I._deg360InRad) / 2 : (B - I._deg360InRad) / 2;
                  }, I._calculate_dHp = function(z, w, C, b) {
                    var B;
                    return z == 0 ? B = 0 : w <= I._deg180InRad ? B = C - b : C <= b ? B = C - b + I._deg360InRad : B = C - b - I._deg360InRad, 2 * Math.sqrt(z) * Math.sin(B / 2);
                  }, I._kA = 0.25 * 100 / 255, I._pow25to7 = Math.pow(25, 7), I._deg360InRad = E.degrees2radians(360), I._deg180InRad = E.degrees2radians(180), I._deg30InRad = E.degrees2radians(30), I._deg6InRad = E.degrees2radians(6), I._deg63InRad = E.degrees2radians(63), I._deg275InRad = E.degrees2radians(275), I._deg25InRad = E.degrees2radians(25), I;
                }(P.AbstractDistanceCalculator);
                r.CIEDE2000 = x;
              },
              /* 16 */
              /***/
              function(Q, r, F) {
                var H = this && this.__extends || function(E, x) {
                  for (var m in x) x.hasOwnProperty(m) && (E[m] = x[m]);
                  function I() {
                    this.constructor = E;
                  }
                  E.prototype = x === null ? Object.create(x) : (I.prototype = x.prototype, new I());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * cmetric.ts - part of Image Quantization Library
                 */
                var P = F(13), M = function(E) {
                  H(x, E);
                  function x() {
                    E.apply(this, arguments);
                  }
                  return x.prototype.calculateRaw = function(m, I, z, w, C, b, B, N) {
                    var U = (m + C) / 2 * this._whitePoint.r, V = (m - C) * this._whitePoint.r, W = (I - b) * this._whitePoint.g, q = (z - B) * this._whitePoint.b, Y = ((512 + U) * V * V >> 8) + 4 * W * W + ((767 - U) * q * q >> 8), re = (N - w) * this._whitePoint.a;
                    return Math.sqrt(Y + re * re);
                  }, x;
                }(P.AbstractDistanceCalculator);
                r.CMETRIC = M;
              },
              /* 17 */
              /***/
              function(Q, r, F) {
                var H = this && this.__extends || function(z, w) {
                  for (var C in w) w.hasOwnProperty(C) && (z[C] = w[C]);
                  function b() {
                    this.constructor = z;
                  }
                  z.prototype = w === null ? Object.create(w) : (b.prototype = w.prototype, new b());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * euclidean.ts - part of Image Quantization Library
                 */
                var P = F(13), M = F(2), E = function(z) {
                  H(w, z);
                  function w() {
                    z.apply(this, arguments);
                  }
                  return w.prototype.calculateRaw = function(C, b, B, N, U, V, W, q) {
                    var Y = U - C, re = V - b, se = W - B, ve = q - N;
                    return Math.sqrt(this._kR * Y * Y + this._kG * re * re + this._kB * se * se + this._kA * ve * ve);
                  }, w;
                }(P.AbstractDistanceCalculator);
                r.AbstractEuclidean = E;
                var x = function(z) {
                  H(w, z);
                  function w() {
                    z.apply(this, arguments);
                  }
                  return w.prototype._setDefaults = function() {
                    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
                  }, w;
                }(E);
                r.Euclidean = x;
                var m = function(z) {
                  H(w, z);
                  function w() {
                    z.apply(this, arguments);
                  }
                  return w.prototype._setDefaults = function() {
                    this._kR = M.Y.RED, this._kG = M.Y.GREEN, this._kB = M.Y.BLUE, this._kA = 1;
                  }, w;
                }(E);
                r.EuclideanRgbQuantWithAlpha = m;
                var I = function(z) {
                  H(w, z);
                  function w() {
                    z.apply(this, arguments);
                  }
                  return w.prototype._setDefaults = function() {
                    this._kR = M.Y.RED, this._kG = M.Y.GREEN, this._kB = M.Y.BLUE, this._kA = 0;
                  }, w;
                }(E);
                r.EuclideanRgbQuantWOAlpha = I;
              },
              /* 18 */
              /***/
              function(Q, r, F) {
                var H = this && this.__extends || function(z, w) {
                  for (var C in w) w.hasOwnProperty(C) && (z[C] = w[C]);
                  function b() {
                    this.constructor = z;
                  }
                  z.prototype = w === null ? Object.create(w) : (b.prototype = w.prototype, new b());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * manhattanNeuQuant.ts - part of Image Quantization Library
                 */
                var P = F(13), M = F(2), E = function(z) {
                  H(w, z);
                  function w() {
                    z.apply(this, arguments);
                  }
                  return w.prototype.calculateRaw = function(C, b, B, N, U, V, W, q) {
                    var Y = U - C, re = V - b, se = W - B, ve = q - N;
                    return Y < 0 && (Y = 0 - Y), re < 0 && (re = 0 - re), se < 0 && (se = 0 - se), ve < 0 && (ve = 0 - ve), this._kR * Y + this._kG * re + this._kB * se + this._kA * ve;
                  }, w;
                }(P.AbstractDistanceCalculator);
                r.AbstractManhattan = E;
                var x = function(z) {
                  H(w, z);
                  function w() {
                    z.apply(this, arguments);
                  }
                  return w.prototype._setDefaults = function() {
                    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
                  }, w;
                }(E);
                r.Manhattan = x;
                var m = function(z) {
                  H(w, z);
                  function w() {
                    z.apply(this, arguments);
                  }
                  return w.prototype._setDefaults = function() {
                    this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
                  }, w;
                }(E);
                r.ManhattanNommyde = m;
                var I = function(z) {
                  H(w, z);
                  function w() {
                    z.apply(this, arguments);
                  }
                  return w.prototype._setDefaults = function() {
                    this._kR = M.Y.RED, this._kG = M.Y.GREEN, this._kB = M.Y.BLUE, this._kA = 1;
                  }, w;
                }(E);
                r.ManhattanSRGB = I;
              },
              /* 19 */
              /***/
              function(Q, r, F) {
                var H = this && this.__extends || function(E, x) {
                  for (var m in x) x.hasOwnProperty(m) && (E[m] = x[m]);
                  function I() {
                    this.constructor = E;
                  }
                  E.prototype = x === null ? Object.create(x) : (I.prototype = x.prototype, new I());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * pngQuant.ts - part of Image Quantization Library
                 */
                var P = F(13), M = function(E) {
                  H(x, E);
                  function x() {
                    E.apply(this, arguments);
                  }
                  return x.prototype.calculateRaw = function(m, I, z, w, C, b, B, N) {
                    var U = (N - w) * this._whitePoint.a;
                    return this._colordifference_ch(m * this._whitePoint.r, C * this._whitePoint.r, U) + this._colordifference_ch(I * this._whitePoint.g, b * this._whitePoint.g, U) + this._colordifference_ch(z * this._whitePoint.b, B * this._whitePoint.b, U);
                  }, x.prototype._colordifference_ch = function(m, I, z) {
                    var w = m - I, C = w + z;
                    return w * w + C * C;
                  }, x;
                }(P.AbstractDistanceCalculator);
                r.PNGQUANT = M;
              },
              /* 20 */
              /***/
              function(Q, r, F) {
                var H = F(21);
                r.NeuQuant = H.NeuQuant;
                var P = F(25);
                r.NeuQuantFloat = P.NeuQuantFloat;
                var M = F(26);
                r.RGBQuant = M.RGBQuant;
                var E = F(27);
                r.ColorHistogram = E.ColorHistogram;
                var x = F(29);
                r.WuQuant = x.WuQuant, r.WuColorCube = x.WuColorCube;
              },
              /* 21 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * neuquant.ts - part of Image Quantization Library
                 */
                var H = F(22), P = F(24), M = 3, E = function() {
                  function m(I) {
                    this.r = this.g = this.b = this.a = I;
                  }
                  return m.prototype.toPoint = function() {
                    return P.Point.createByRGBA(this.r >> M, this.g >> M, this.b >> M, this.a >> M);
                  }, m.prototype.subtract = function(I, z, w, C) {
                    this.r -= I | 0, this.g -= z | 0, this.b -= w | 0, this.a -= C | 0;
                  }, m;
                }(), x = function() {
                  function m(I, z) {
                    z === void 0 && (z = 256), this._distance = I, this._pointArray = [], this._sampleFactor = 1, this._networkSize = z, this._distance.setWhitePoint(255 << M, 255 << M, 255 << M, 255 << M);
                  }
                  return m.prototype.sample = function(I) {
                    this._pointArray = this._pointArray.concat(I.getPointArray());
                  }, m.prototype.quantize = function() {
                    return this._init(), this._learn(), this._buildPalette();
                  }, m.prototype._init = function() {
                    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
                    for (var I = 0; I < this._networkSize; I++)
                      this._network[I] = new E((I << M + 8) / this._networkSize | 0), this._freq[I] = m._initialBias / this._networkSize | 0, this._bias[I] = 0;
                  }, m.prototype._learn = function() {
                    var I = this._sampleFactor, z = this._pointArray.length;
                    z < m._minpicturebytes && (I = 1);
                    var w = 30 + (I - 1) / 3 | 0, C = z / I | 0, b = C / m._nCycles | 0, B = m._initAlpha, N = (this._networkSize >> 3) * m._radiusBias, U = N >> m._radiusBiasShift;
                    U <= 1 && (U = 0);
                    for (var V = 0; V < U; V++)
                      this._radPower[V] = B * ((U * U - V * V) * m._radBias / (U * U)) >>> 0;
                    var W;
                    z < m._minpicturebytes ? W = 1 : z % m._prime1 != 0 ? W = m._prime1 : z % m._prime2 != 0 ? W = m._prime2 : z % m._prime3 != 0 ? W = m._prime3 : W = m._prime4;
                    for (var V = 0, q = 0; V < C; ) {
                      var Y = this._pointArray[q], re = Y.b << M, se = Y.g << M, ve = Y.r << M, ce = Y.a << M, be = this._contest(re, se, ve, ce);
                      if (this._alterSingle(B, be, re, se, ve, ce), U !== 0 && this._alterNeighbour(U, be, re, se, ve, ce), q += W, q >= z && (q -= z), V++, b === 0 && (b = 1), V % b === 0) {
                        B -= B / w | 0, N -= N / m._radiusDecrease | 0, U = N >> m._radiusBiasShift, U <= 1 && (U = 0);
                        for (var Me = 0; Me < U; Me++)
                          this._radPower[Me] = B * ((U * U - Me * Me) * m._radBias / (U * U)) >>> 0;
                      }
                    }
                  }, m.prototype._buildPalette = function() {
                    var I = new H.Palette();
                    return this._network.forEach(function(z) {
                      I.add(z.toPoint());
                    }), I.sort(), I;
                  }, m.prototype._alterNeighbour = function(I, z, w, C, b, B) {
                    var N = z - I;
                    N < -1 && (N = -1);
                    var U = z + I;
                    U > this._networkSize && (U = this._networkSize);
                    for (var V = z + 1, W = z - 1, q = 1; V < U || W > N; ) {
                      var Y = this._radPower[q++] / m._alphaRadBias;
                      if (V < U) {
                        var re = this._network[V++];
                        re.subtract(Y * (re.r - b), Y * (re.g - C), Y * (re.b - w), Y * (re.a - B));
                      }
                      if (W > N) {
                        var re = this._network[W--];
                        re.subtract(Y * (re.r - b), Y * (re.g - C), Y * (re.b - w), Y * (re.a - B));
                      }
                    }
                  }, m.prototype._alterSingle = function(I, z, w, C, b, B) {
                    I /= m._initAlpha;
                    var N = this._network[z];
                    N.subtract(I * (N.r - b), I * (N.g - C), I * (N.b - w), I * (N.a - B));
                  }, m.prototype._contest = function(I, z, w, C) {
                    for (var b = 1020 << M, B = ~(1 << 31), N = B, U = -1, V = U, W = 0; W < this._networkSize; W++) {
                      var q = this._network[W], Y = this._distance.calculateNormalized(q, { r: w, g: z, b: I, a: C }) * b | 0;
                      Y < B && (B = Y, U = W);
                      var re = Y - (this._bias[W] >> m._initialBiasShift - M);
                      re < N && (N = re, V = W);
                      var se = this._freq[W] >> m._betaShift;
                      this._freq[W] -= se, this._bias[W] += se << m._gammaShift;
                    }
                    return this._freq[U] += m._beta, this._bias[U] -= m._betaGamma, V;
                  }, m._prime1 = 499, m._prime2 = 491, m._prime3 = 487, m._prime4 = 503, m._minpicturebytes = m._prime4, m._nCycles = 100, m._initialBiasShift = 16, m._initialBias = 1 << m._initialBiasShift, m._gammaShift = 10, m._betaShift = 10, m._beta = m._initialBias >> m._betaShift, m._betaGamma = m._initialBias << m._gammaShift - m._betaShift, m._radiusBiasShift = 6, m._radiusBias = 1 << m._radiusBiasShift, m._radiusDecrease = 30, m._alphaBiasShift = 10, m._initAlpha = 1 << m._alphaBiasShift, m._radBiasShift = 8, m._radBias = 1 << m._radBiasShift, m._alphaRadBiasShift = m._alphaBiasShift + m._radBiasShift, m._alphaRadBias = 1 << m._alphaRadBiasShift, m;
                }();
                r.NeuQuant = x;
              },
              /* 22 */
              /***/
              function(Q, r, F) {
                var H = F(23), P = F(5), M = 10;
                function E(m, I) {
                  for (var z = 360, w = z / I, C = w / 2, b = 1, B = w - C; b < I; b++, B += w)
                    if (m >= B && m < B + w)
                      return b;
                  return 0;
                }
                r.hueGroup = E;
                var x = function() {
                  function m() {
                    this._pointArray = [], this._i32idx = {}, this._pointContainer = new H.PointContainer(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
                  }
                  return m.prototype.add = function(I) {
                    this._pointArray.push(I), this._pointContainer.setWidth(this._pointArray.length);
                  }, m.prototype.has = function(I) {
                    for (var z = this._pointArray.length - 1; z >= 0; z--)
                      if (I.uint32 === this._pointArray[z].uint32)
                        return !0;
                    return !1;
                  }, m.prototype.getNearestColor = function(I, z) {
                    return this._pointArray[this.getNearestIndex(I, z) | 0];
                  }, m.prototype.getPointContainer = function() {
                    return this._pointContainer;
                  }, m.prototype._nearestPointFromCache = function(I) {
                    return typeof this._i32idx[I] == "number" ? this._i32idx[I] : -1;
                  }, m.prototype.getNearestIndex = function(I, z) {
                    var w = this._nearestPointFromCache("" + z.uint32);
                    if (w >= 0)
                      return w;
                    var C = Number.MAX_VALUE;
                    w = 0;
                    for (var b = 0, B = this._pointArray.length; b < B; b++) {
                      var N = this._pointArray[b], U = I.calculateRaw(z.r, z.g, z.b, z.a, N.r, N.g, N.b, N.a);
                      U < C && (C = U, w = b);
                    }
                    return this._i32idx[z.uint32] = w, w;
                  }, m.prototype.sort = function() {
                    this._i32idx = {}, this._pointArray.sort(function(I, z) {
                      var w = P.rgb2hsl(I.r, I.g, I.b), C = P.rgb2hsl(z.r, z.g, z.b), b = I.r === I.g && I.g === I.b ? 0 : 1 + E(w.h, M), B = z.r === z.g && z.g === z.b ? 0 : 1 + E(C.h, M), N = B - b;
                      if (N)
                        return -N;
                      var U = I.getLuminosity(!0), V = z.getLuminosity(!0);
                      if (V - U !== 0)
                        return V - U;
                      var W = (C.s * 100 | 0) - (w.s * 100 | 0);
                      return W ? -W : 0;
                    });
                  }, m;
                }();
                r.Palette = x;
              },
              /* 23 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * pointContainer.ts - part of Image Quantization Library
                 */
                var H = F(24), P = function() {
                  function M() {
                    this._width = 0, this._height = 0, this._pointArray = [];
                  }
                  return M.prototype.getWidth = function() {
                    return this._width;
                  }, M.prototype.getHeight = function() {
                    return this._height;
                  }, M.prototype.setWidth = function(E) {
                    this._width = E;
                  }, M.prototype.setHeight = function(E) {
                    this._height = E;
                  }, M.prototype.getPointArray = function() {
                    return this._pointArray;
                  }, M.prototype.clone = function() {
                    var E = new M();
                    E._width = this._width, E._height = this._height;
                    for (var x = 0, m = this._pointArray.length; x < m; x++)
                      E._pointArray[x] = H.Point.createByUint32(this._pointArray[x].uint32 | 0);
                    return E;
                  }, M.prototype.toUint32Array = function() {
                    for (var E = this._pointArray.length, x = new Uint32Array(E), m = 0; m < E; m++)
                      x[m] = this._pointArray[m].uint32;
                    return x;
                  }, M.prototype.toUint8Array = function() {
                    return new Uint8Array(this.toUint32Array().buffer);
                  }, M.fromHTMLImageElement = function(E) {
                    var x = E.naturalWidth, m = E.naturalHeight, I = document.createElement("canvas");
                    I.width = x, I.height = m;
                    var z = I.getContext("2d");
                    return z.drawImage(E, 0, 0, x, m, 0, 0, x, m), M.fromHTMLCanvasElement(I);
                  }, M.fromHTMLCanvasElement = function(E) {
                    var x = E.width, m = E.height, I = E.getContext("2d"), z = I.getImageData(0, 0, x, m);
                    return M.fromImageData(z);
                  }, M.fromNodeCanvas = function(E) {
                    return M.fromHTMLCanvasElement(E);
                  }, M.fromImageData = function(E) {
                    var x = E.width, m = E.height;
                    return M.fromCanvasPixelArray(E.data, x, m);
                  }, M.fromArray = function(E, x, m) {
                    var I = new Uint8Array(E);
                    return M.fromUint8Array(I, x, m);
                  }, M.fromCanvasPixelArray = function(E, x, m) {
                    return M.fromArray(E, x, m);
                  }, M.fromUint8Array = function(E, x, m) {
                    return M.fromUint32Array(new Uint32Array(E.buffer), x, m);
                  }, M.fromUint32Array = function(E, x, m) {
                    var I = new M();
                    I._width = x, I._height = m;
                    for (var z = 0, w = E.length; z < w; z++)
                      I._pointArray[z] = H.Point.createByUint32(E[z] | 0);
                    return I;
                  }, M;
                }();
                r.PointContainer = P;
              },
              /* 24 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * point.ts - part of Image Quantization Library
                 */
                var H = F(2), P = function() {
                  function M() {
                    this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
                  }
                  return M.createByQuadruplet = function(E) {
                    var x = new M();
                    return x.r = E[0] | 0, x.g = E[1] | 0, x.b = E[2] | 0, x.a = E[3] | 0, x._loadUINT32(), x._loadQuadruplet(), x;
                  }, M.createByRGBA = function(E, x, m, I) {
                    var z = new M();
                    return z.r = E | 0, z.g = x | 0, z.b = m | 0, z.a = I | 0, z._loadUINT32(), z._loadQuadruplet(), z;
                  }, M.createByUint32 = function(E) {
                    var x = new M();
                    return x.uint32 = E >>> 0, x._loadRGBA(), x._loadQuadruplet(), x;
                  }, M.prototype.from = function(E) {
                    this.r = E.r, this.g = E.g, this.b = E.b, this.a = E.a, this.uint32 = E.uint32, this.rgba[0] = E.r, this.rgba[1] = E.g, this.rgba[2] = E.b, this.rgba[3] = E.a;
                  }, M.prototype.getLuminosity = function(E) {
                    var x = this.r, m = this.g, I = this.b;
                    return E && (x = Math.min(255, 255 - this.a + this.a * x / 255), m = Math.min(255, 255 - this.a + this.a * m / 255), I = Math.min(255, 255 - this.a + this.a * I / 255)), x * H.Y.RED + m * H.Y.GREEN + I * H.Y.BLUE;
                  }, M.prototype._loadUINT32 = function() {
                    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
                  }, M.prototype._loadRGBA = function() {
                    this.r = this.uint32 & 255, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
                  }, M.prototype._loadQuadruplet = function() {
                    this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
                  }, M;
                }();
                r.Point = P;
              },
              /* 25 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * neuquant.ts - part of Image Quantization Library
                 */
                var H = F(22), P = F(24), M = 3, E = function() {
                  function m(I) {
                    this.r = this.g = this.b = this.a = I;
                  }
                  return m.prototype.toPoint = function() {
                    return P.Point.createByRGBA(this.r >> M, this.g >> M, this.b >> M, this.a >> M);
                  }, m.prototype.subtract = function(I, z, w, C) {
                    this.r -= I, this.g -= z, this.b -= w, this.a -= C;
                  }, m;
                }(), x = function() {
                  function m(I, z) {
                    z === void 0 && (z = 256), this._distance = I, this._pointArray = [], this._sampleFactor = 1, this._networkSize = z, this._distance.setWhitePoint(255 << M, 255 << M, 255 << M, 255 << M);
                  }
                  return m.prototype.sample = function(I) {
                    this._pointArray = this._pointArray.concat(I.getPointArray());
                  }, m.prototype.quantize = function() {
                    return this._init(), this._learn(), this._buildPalette();
                  }, m.prototype._init = function() {
                    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
                    for (var I = 0; I < this._networkSize; I++)
                      this._network[I] = new E((I << M + 8) / this._networkSize), this._freq[I] = m._initialBias / this._networkSize, this._bias[I] = 0;
                  }, m.prototype._learn = function() {
                    var I = this._sampleFactor, z = this._pointArray.length;
                    z < m._minpicturebytes && (I = 1);
                    var w = 30 + (I - 1) / 3, C = z / I, b = C / m._nCycles | 0, B = m._initAlpha, N = (this._networkSize >> 3) * m._radiusBias, U = N >> m._radiusBiasShift;
                    U <= 1 && (U = 0);
                    for (var V = 0; V < U; V++)
                      this._radPower[V] = B * ((U * U - V * V) * m._radBias / (U * U));
                    var W;
                    z < m._minpicturebytes ? W = 1 : z % m._prime1 != 0 ? W = m._prime1 : z % m._prime2 != 0 ? W = m._prime2 : z % m._prime3 != 0 ? W = m._prime3 : W = m._prime4;
                    for (var V = 0, q = 0; V < C; ) {
                      var Y = this._pointArray[q], re = Y.b << M, se = Y.g << M, ve = Y.r << M, ce = Y.a << M, be = this._contest(re, se, ve, ce);
                      if (this._alterSingle(B, be, re, se, ve, ce), U != 0 && this._alterNeighbour(U, be, re, se, ve, ce), q += W, q >= z && (q -= z), V++, b == 0 && (b = 1), V % b == 0) {
                        B -= B / w, N -= N / m._radiusDecrease, U = N >> m._radiusBiasShift, U <= 1 && (U = 0);
                        for (var Me = 0; Me < U; Me++)
                          this._radPower[Me] = B * ((U * U - Me * Me) * m._radBias / (U * U));
                      }
                    }
                  }, m.prototype._buildPalette = function() {
                    var I = new H.Palette();
                    return this._network.forEach(function(z) {
                      I.add(z.toPoint());
                    }), I.sort(), I;
                  }, m.prototype._alterNeighbour = function(I, z, w, C, b, B) {
                    var N = z - I;
                    N < -1 && (N = -1);
                    var U = z + I;
                    U > this._networkSize && (U = this._networkSize);
                    for (var V = z + 1, W = z - 1, q = 1; V < U || W > N; ) {
                      var Y = this._radPower[q++] / m._alphaRadBias;
                      if (V < U) {
                        var re = this._network[V++];
                        re.subtract(Y * (re.r - b), Y * (re.g - C), Y * (re.b - w), Y * (re.a - B));
                      }
                      if (W > N) {
                        var re = this._network[W--];
                        re.subtract(Y * (re.r - b), Y * (re.g - C), Y * (re.b - w), Y * (re.a - B));
                      }
                    }
                  }, m.prototype._alterSingle = function(I, z, w, C, b, B) {
                    I /= m._initAlpha;
                    var N = this._network[z];
                    N.subtract(I * (N.r - b), I * (N.g - C), I * (N.b - w), I * (N.a - B));
                  }, m.prototype._contest = function(I, z, w, C) {
                    for (var b = 1020 << M, B = ~(1 << 31), N = B, U = -1, V = U, W = 0; W < this._networkSize; W++) {
                      var q = this._network[W], Y = this._distance.calculateNormalized(q, { r: w, g: z, b: I, a: C }) * b;
                      Y < B && (B = Y, U = W);
                      var re = Y - (this._bias[W] >> m._initialBiasShift - M);
                      re < N && (N = re, V = W);
                      var se = this._freq[W] >> m._betaShift;
                      this._freq[W] -= se, this._bias[W] += se << m._gammaShift;
                    }
                    return this._freq[U] += m._beta, this._bias[U] -= m._betaGamma, V;
                  }, m._prime1 = 499, m._prime2 = 491, m._prime3 = 487, m._prime4 = 503, m._minpicturebytes = m._prime4, m._nCycles = 100, m._initialBiasShift = 16, m._initialBias = 1 << m._initialBiasShift, m._gammaShift = 10, m._betaShift = 10, m._beta = m._initialBias >> m._betaShift, m._betaGamma = m._initialBias << m._gammaShift - m._betaShift, m._radiusBiasShift = 6, m._radiusBias = 1 << m._radiusBiasShift, m._radiusDecrease = 30, m._alphaBiasShift = 10, m._initAlpha = 1 << m._alphaBiasShift, m._radBiasShift = 8, m._radBias = 1 << m._radBiasShift, m._alphaRadBiasShift = m._alphaBiasShift + m._radBiasShift, m._alphaRadBias = 1 << m._alphaRadBiasShift, m;
                }();
                r.NeuQuantFloat = x;
              },
              /* 26 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgbquant.ts - part of Image Quantization Library
                 */
                var H = F(22), P = F(24), M = F(27), E = F(6), x = /* @__PURE__ */ function() {
                  function I(z, w, C) {
                    this.index = z, this.color = w, this.distance = C;
                  }
                  return I;
                }(), m = function() {
                  function I(z, w, C) {
                    w === void 0 && (w = 256), C === void 0 && (C = 2), this._distance = z, this._colors = w, this._histogram = new M.ColorHistogram(C, w), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
                  }
                  return I.prototype.sample = function(z) {
                    this._histogram.sample(z);
                  }, I.prototype.quantize = function() {
                    var z = this._histogram.getImportanceSortedColorsIDXI32();
                    if (z.length === 0)
                      throw new Error("No colors in image");
                    var w = this._buildPalette(z);
                    return w.sort(), w;
                  }, I.prototype._buildPalette = function(z) {
                    for (var w = new H.Palette(), C = w.getPointContainer().getPointArray(), b = new Array(z.length), B = 0; B < z.length; B++)
                      C.push(P.Point.createByUint32(z[B])), b[B] = 1;
                    for (var N = C.length, U = [], V = N, W = this._initialDistance; V > this._colors; ) {
                      U.length = 0;
                      for (var B = 0; B < N; B++)
                        if (b[B] !== 0) {
                          for (var q = C[B], Y = B + 1; Y < N; Y++)
                            if (b[Y] !== 0) {
                              var re = C[Y], se = this._distance.calculateNormalized(q, re);
                              se < W && (U.push(new x(Y, re, se)), b[Y] = 0, V--);
                            }
                        }
                      W += V > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
                    }
                    if (V < this._colors) {
                      E.stableSort(U, function(xe, le) {
                        return le.distance - xe.distance;
                      });
                      for (var ve = 0; V < this._colors && ve < U.length; ) {
                        var ce = U[ve];
                        b[ce.index] = 1, V++, ve++;
                      }
                    }
                    for (var be = C.length, Me = be - 1; Me >= 0; Me--)
                      b[Me] === 0 && (Me !== be - 1 && (C[Me] = C[be - 1]), --be);
                    return C.length = be, w;
                  }, I;
                }();
                r.RGBQuant = m;
              },
              /* 27 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * colorHistogram.ts - part of Image Quantization Library
                 */
                var H = F(28), P = F(6), M = function() {
                  function E(x, m) {
                    this._method = x, this._minHueCols = m << 2, this._initColors = m << 2, this._hueStats = new H.HueStatistics(E._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
                  }
                  return E.prototype.sample = function(x) {
                    switch (this._method) {
                      case 1:
                        this._colorStats1D(x);
                        break;
                      case 2:
                        this._colorStats2D(x);
                        break;
                    }
                  }, E.prototype.getImportanceSortedColorsIDXI32 = function() {
                    var x = this, m = P.stableSort(Object.keys(this._histogram), function(N, U) {
                      return x._histogram[U] - x._histogram[N];
                    });
                    if (m.length === 0)
                      return [];
                    var I;
                    switch (this._method) {
                      case 1:
                        var z = Math.min(m.length, this._initColors), w = m[z - 1], C = this._histogram[w];
                        I = m.slice(0, z);
                        for (var b = z, B = m.length; b < B && this._histogram[m[b]] == C; )
                          I.push(m[b++]);
                        this._hueStats.injectIntoArray(I);
                        break;
                      case 2:
                        I = m;
                        break;
                      default:
                        throw new Error("Incorrect method");
                    }
                    return I.map(function(N) {
                      return +N;
                    });
                  }, E.prototype._colorStats1D = function(x) {
                    for (var m = this._histogram, I = x.getPointArray(), z = I.length, w = 0; w < z; w++) {
                      var C = I[w].uint32;
                      this._hueStats.check(C), C in m ? m[C]++ : m[C] = 1;
                    }
                  }, E.prototype._colorStats2D = function(x) {
                    var m = this, I = x.getWidth(), z = x.getHeight(), w = x.getPointArray(), C = E._boxSize[0], b = E._boxSize[1], B = C * b, N = this._makeBoxes(I, z, C, b), U = this._histogram;
                    N.forEach(function(V) {
                      var W = Math.round(V.w * V.h / B) * E._boxPixels;
                      W < 2 && (W = 2);
                      var q = {};
                      m._iterateBox(V, I, function(Y) {
                        var re = w[Y].uint32;
                        m._hueStats.check(re), re in U ? U[re]++ : re in q ? ++q[re] >= W && (U[re] = q[re]) : q[re] = 1;
                      });
                    }), this._hueStats.injectIntoDictionary(U);
                  }, E.prototype._iterateBox = function(x, m, I) {
                    var z = x, w = z.y * m + z.x, C = (z.y + z.h - 1) * m + (z.x + z.w - 1), b = m - z.w + 1, B = 0, N = w;
                    do
                      I.call(this, N), N += ++B % z.w == 0 ? b : 1;
                    while (N <= C);
                  }, E.prototype._makeBoxes = function(x, m, I, z) {
                    for (var w = x % I, C = m % z, b = x - w, B = m - C, N = [], U = 0; U < m; U += z)
                      for (var V = 0; V < x; V += I)
                        N.push({ x: V, y: U, w: V == b ? w : I, h: U == B ? C : z });
                    return N;
                  }, E._boxSize = [64, 64], E._boxPixels = 2, E._hueGroups = 10, E;
                }();
                r.ColorHistogram = M;
              },
              /* 28 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * hueStatistics.ts - part of Image Quantization Library
                 */
                var H = F(5), P = F(22), M = /* @__PURE__ */ function() {
                  function x() {
                    this.num = 0, this.cols = [];
                  }
                  return x;
                }(), E = function() {
                  function x(m, I) {
                    this._numGroups = m, this._minCols = I, this._stats = [];
                    for (var z = 0; z <= m; z++)
                      this._stats[z] = new M();
                    this._groupsFull = 0;
                  }
                  return x.prototype.check = function(m) {
                    this._groupsFull == this._numGroups + 1 && (this.check = function() {
                    });
                    var I = m & 255, z = m >>> 8 & 255, w = m >>> 16 & 255, C = I == z && z == w ? 0 : 1 + P.hueGroup(H.rgb2hsl(I, z, w).h, this._numGroups), b = this._stats[C], B = this._minCols;
                    b.num++, !(b.num > B) && (b.num == B && this._groupsFull++, b.num <= B && this._stats[C].cols.push(m));
                  }, x.prototype.injectIntoDictionary = function(m) {
                    for (var I = 0; I <= this._numGroups; I++)
                      this._stats[I].num <= this._minCols && this._stats[I].cols.forEach(function(z) {
                        m[z] ? m[z]++ : m[z] = 1;
                      });
                  }, x.prototype.injectIntoArray = function(m) {
                    for (var I = 0; I <= this._numGroups; I++)
                      this._stats[I].num <= this._minCols && this._stats[I].cols.forEach(function(z) {
                        m.indexOf(z) == -1 && m.push(z);
                      });
                  }, x;
                }();
                r.HueStatistics = E;
              },
              /* 29 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * wuQuant.ts - part of Image Quantization Library
                 */
                var H = F(22), P = F(24);
                function M(C) {
                  for (var b = [], B = 0; B < C; B++)
                    b[B] = 0;
                  return b;
                }
                function E(C, b, B, N) {
                  for (var U = new Array(C), V = 0; V < C; V++) {
                    U[V] = new Array(b);
                    for (var W = 0; W < b; W++) {
                      U[V][W] = new Array(B);
                      for (var q = 0; q < B; q++) {
                        U[V][W][q] = new Array(N);
                        for (var Y = 0; Y < N; Y++)
                          U[V][W][q][Y] = 0;
                      }
                    }
                  }
                  return U;
                }
                function x(C, b, B) {
                  for (var N = new Array(C), U = 0; U < C; U++) {
                    N[U] = new Array(b);
                    for (var V = 0; V < b; V++) {
                      N[U][V] = new Array(B);
                      for (var W = 0; W < B; W++)
                        N[U][V][W] = 0;
                    }
                  }
                  return N;
                }
                function m(C, b, B, N, U) {
                  for (var V = 0; V < b; V++) {
                    C[V] = [];
                    for (var W = 0; W < B; W++) {
                      C[V][W] = [];
                      for (var q = 0; q < N; q++)
                        C[V][W][q] = U;
                    }
                  }
                }
                function I(C, b, B) {
                  for (var N = 0; N < b; N++)
                    C[N] = B;
                }
                var z = /* @__PURE__ */ function() {
                  function C() {
                  }
                  return C;
                }();
                r.WuColorCube = z;
                var w = function() {
                  function C(b, B, N) {
                    B === void 0 && (B = 256), N === void 0 && (N = 5), this._distance = b, this._setQuality(N), this._initialize(B);
                  }
                  return C.prototype.sample = function(b) {
                    for (var B = b.getPointArray(), N = 0, U = B.length; N < U; N++)
                      this._addColor(B[N]);
                    this._pixels = this._pixels.concat(B);
                  }, C.prototype.quantize = function() {
                    this._preparePalette();
                    for (var b = new H.Palette(), B = 0; B < this._colors; B++)
                      if (this._sums[B] > 0) {
                        var N = this._sums[B], U = this._reds[B] / N, V = this._greens[B] / N, W = this._blues[B] / N, q = this._alphas[B] / N, Y = P.Point.createByRGBA(U | 0, V | 0, W | 0, q | 0);
                        b.add(Y);
                      }
                    return b.sort(), b;
                  }, C.prototype._preparePalette = function() {
                    this._calculateMoments();
                    for (var b = 0, B = M(this._colors), N = 1; N < this._colors; ++N) {
                      this._cut(this._cubes[b], this._cubes[N]) ? (B[b] = this._cubes[b].volume > 1 ? this._calculateVariance(this._cubes[b]) : 0, B[N] = this._cubes[N].volume > 1 ? this._calculateVariance(this._cubes[N]) : 0) : (B[b] = 0, N--), b = 0;
                      for (var U = B[0], V = 1; V <= N; ++V)
                        B[V] > U && (U = B[V], b = V);
                      if (U <= 0) {
                        this._colors = N + 1;
                        break;
                      }
                    }
                    for (var W = [], q = [], Y = [], re = [], se = 0; se < this._colors; ++se) {
                      var ve = C._volume(this._cubes[se], this._weights);
                      ve > 0 ? (W[se] = C._volume(this._cubes[se], this._momentsRed) / ve | 0, q[se] = C._volume(this._cubes[se], this._momentsGreen) / ve | 0, Y[se] = C._volume(this._cubes[se], this._momentsBlue) / ve | 0, re[se] = C._volume(this._cubes[se], this._momentsAlpha) / ve | 0) : (W[se] = 0, q[se] = 0, Y[se] = 0, re[se] = 0);
                    }
                    this._reds = M(this._colors + 1), this._greens = M(this._colors + 1), this._blues = M(this._colors + 1), this._alphas = M(this._colors + 1), this._sums = M(this._colors + 1);
                    for (var V = 0, ce = this._pixels.length; V < ce; V++) {
                      for (var be = this._pixels[V], Me = -1, xe = Me, le = Number.MAX_VALUE, de = 0; de < this._colors; de++) {
                        var De = W[de], ze = q[de], Ze = Y[de], Ue = re[de], Ie = this._distance.calculateRaw(De, ze, Ze, Ue, be.r, be.g, be.b, be.a);
                        Ie < le && (le = Ie, xe = de);
                      }
                      this._reds[xe] += be.r, this._greens[xe] += be.g, this._blues[xe] += be.b, this._alphas[xe] += be.a, this._sums[xe]++;
                    }
                  }, C.prototype._addColor = function(b) {
                    var B = 8 - this._significantBitsPerChannel, N = (b.r >> B) + 1, U = (b.g >> B) + 1, V = (b.b >> B) + 1, W = (b.a >> B) + 1;
                    this._weights[W][N][U][V]++, this._momentsRed[W][N][U][V] += b.r, this._momentsGreen[W][N][U][V] += b.g, this._momentsBlue[W][N][U][V] += b.b, this._momentsAlpha[W][N][U][V] += b.a, this._moments[W][N][U][V] += this._table[b.r] + this._table[b.g] + this._table[b.b] + this._table[b.a];
                  }, C.prototype._calculateMoments = function() {
                    for (var b = [], B = [], N = [], U = [], V = [], W = [], q = x(this._sideSize, this._sideSize, this._sideSize), Y = x(this._sideSize, this._sideSize, this._sideSize), re = x(this._sideSize, this._sideSize, this._sideSize), se = x(this._sideSize, this._sideSize, this._sideSize), ve = x(this._sideSize, this._sideSize, this._sideSize), ce = x(this._sideSize, this._sideSize, this._sideSize), be = 1; be <= this._alphaMaxSideIndex; ++be) {
                      m(q, this._sideSize, this._sideSize, this._sideSize, 0), m(Y, this._sideSize, this._sideSize, this._sideSize, 0), m(re, this._sideSize, this._sideSize, this._sideSize, 0), m(se, this._sideSize, this._sideSize, this._sideSize, 0), m(ve, this._sideSize, this._sideSize, this._sideSize, 0), m(ce, this._sideSize, this._sideSize, this._sideSize, 0);
                      for (var Me = 1; Me <= this._maxSideIndex; ++Me) {
                        I(b, this._sideSize, 0), I(B, this._sideSize, 0), I(N, this._sideSize, 0), I(U, this._sideSize, 0), I(V, this._sideSize, 0), I(W, this._sideSize, 0);
                        for (var xe = 1; xe <= this._maxSideIndex; ++xe)
                          for (var le = 0, de = 0, De = 0, ze = 0, Ze = 0, Ue = 0, Ie = 1; Ie <= this._maxSideIndex; ++Ie)
                            le += this._weights[be][Me][xe][Ie], de += this._momentsRed[be][Me][xe][Ie], De += this._momentsGreen[be][Me][xe][Ie], ze += this._momentsBlue[be][Me][xe][Ie], Ze += this._momentsAlpha[be][Me][xe][Ie], Ue += this._moments[be][Me][xe][Ie], b[Ie] += le, B[Ie] += de, N[Ie] += De, U[Ie] += ze, V[Ie] += Ze, W[Ie] += Ue, q[Me][xe][Ie] = q[Me - 1][xe][Ie] + b[Ie], Y[Me][xe][Ie] = Y[Me - 1][xe][Ie] + B[Ie], re[Me][xe][Ie] = re[Me - 1][xe][Ie] + N[Ie], se[Me][xe][Ie] = se[Me - 1][xe][Ie] + U[Ie], ve[Me][xe][Ie] = ve[Me - 1][xe][Ie] + V[Ie], ce[Me][xe][Ie] = ce[Me - 1][xe][Ie] + W[Ie], this._weights[be][Me][xe][Ie] = this._weights[be - 1][Me][xe][Ie] + q[Me][xe][Ie], this._momentsRed[be][Me][xe][Ie] = this._momentsRed[be - 1][Me][xe][Ie] + Y[Me][xe][Ie], this._momentsGreen[be][Me][xe][Ie] = this._momentsGreen[be - 1][Me][xe][Ie] + re[Me][xe][Ie], this._momentsBlue[be][Me][xe][Ie] = this._momentsBlue[be - 1][Me][xe][Ie] + se[Me][xe][Ie], this._momentsAlpha[be][Me][xe][Ie] = this._momentsAlpha[be - 1][Me][xe][Ie] + ve[Me][xe][Ie], this._moments[be][Me][xe][Ie] = this._moments[be - 1][Me][xe][Ie] + ce[Me][xe][Ie];
                      }
                    }
                  }, C._volumeFloat = function(b, B) {
                    return B[b.alphaMaximum][b.redMaximum][b.greenMaximum][b.blueMaximum] - B[b.alphaMaximum][b.redMaximum][b.greenMinimum][b.blueMaximum] - B[b.alphaMaximum][b.redMinimum][b.greenMaximum][b.blueMaximum] + B[b.alphaMaximum][b.redMinimum][b.greenMinimum][b.blueMaximum] - B[b.alphaMinimum][b.redMaximum][b.greenMaximum][b.blueMaximum] + B[b.alphaMinimum][b.redMaximum][b.greenMinimum][b.blueMaximum] + B[b.alphaMinimum][b.redMinimum][b.greenMaximum][b.blueMaximum] - B[b.alphaMinimum][b.redMinimum][b.greenMinimum][b.blueMaximum] - (B[b.alphaMaximum][b.redMaximum][b.greenMaximum][b.blueMinimum] - B[b.alphaMinimum][b.redMaximum][b.greenMaximum][b.blueMinimum] - B[b.alphaMaximum][b.redMaximum][b.greenMinimum][b.blueMinimum] + B[b.alphaMinimum][b.redMaximum][b.greenMinimum][b.blueMinimum] - B[b.alphaMaximum][b.redMinimum][b.greenMaximum][b.blueMinimum] + B[b.alphaMinimum][b.redMinimum][b.greenMaximum][b.blueMinimum] + B[b.alphaMaximum][b.redMinimum][b.greenMinimum][b.blueMinimum] - B[b.alphaMinimum][b.redMinimum][b.greenMinimum][b.blueMinimum]);
                  }, C._volume = function(b, B) {
                    return C._volumeFloat(b, B) | 0;
                  }, C._top = function(b, B, N, U) {
                    var V;
                    switch (B) {
                      case C.alpha:
                        V = U[N][b.redMaximum][b.greenMaximum][b.blueMaximum] - U[N][b.redMaximum][b.greenMinimum][b.blueMaximum] - U[N][b.redMinimum][b.greenMaximum][b.blueMaximum] + U[N][b.redMinimum][b.greenMinimum][b.blueMaximum] - (U[N][b.redMaximum][b.greenMaximum][b.blueMinimum] - U[N][b.redMaximum][b.greenMinimum][b.blueMinimum] - U[N][b.redMinimum][b.greenMaximum][b.blueMinimum] + U[N][b.redMinimum][b.greenMinimum][b.blueMinimum]);
                        break;
                      case C.red:
                        V = U[b.alphaMaximum][N][b.greenMaximum][b.blueMaximum] - U[b.alphaMaximum][N][b.greenMinimum][b.blueMaximum] - U[b.alphaMinimum][N][b.greenMaximum][b.blueMaximum] + U[b.alphaMinimum][N][b.greenMinimum][b.blueMaximum] - (U[b.alphaMaximum][N][b.greenMaximum][b.blueMinimum] - U[b.alphaMaximum][N][b.greenMinimum][b.blueMinimum] - U[b.alphaMinimum][N][b.greenMaximum][b.blueMinimum] + U[b.alphaMinimum][N][b.greenMinimum][b.blueMinimum]);
                        break;
                      case C.green:
                        V = U[b.alphaMaximum][b.redMaximum][N][b.blueMaximum] - U[b.alphaMaximum][b.redMinimum][N][b.blueMaximum] - U[b.alphaMinimum][b.redMaximum][N][b.blueMaximum] + U[b.alphaMinimum][b.redMinimum][N][b.blueMaximum] - (U[b.alphaMaximum][b.redMaximum][N][b.blueMinimum] - U[b.alphaMaximum][b.redMinimum][N][b.blueMinimum] - U[b.alphaMinimum][b.redMaximum][N][b.blueMinimum] + U[b.alphaMinimum][b.redMinimum][N][b.blueMinimum]);
                        break;
                      case C.blue:
                        V = U[b.alphaMaximum][b.redMaximum][b.greenMaximum][N] - U[b.alphaMaximum][b.redMaximum][b.greenMinimum][N] - U[b.alphaMaximum][b.redMinimum][b.greenMaximum][N] + U[b.alphaMaximum][b.redMinimum][b.greenMinimum][N] - (U[b.alphaMinimum][b.redMaximum][b.greenMaximum][N] - U[b.alphaMinimum][b.redMaximum][b.greenMinimum][N] - U[b.alphaMinimum][b.redMinimum][b.greenMaximum][N] + U[b.alphaMinimum][b.redMinimum][b.greenMinimum][N]);
                        break;
                      default:
                        throw new Error("impossible");
                    }
                    return V | 0;
                  }, C._bottom = function(b, B, N) {
                    switch (B) {
                      case C.alpha:
                        return -N[b.alphaMinimum][b.redMaximum][b.greenMaximum][b.blueMaximum] + N[b.alphaMinimum][b.redMaximum][b.greenMinimum][b.blueMaximum] + N[b.alphaMinimum][b.redMinimum][b.greenMaximum][b.blueMaximum] - N[b.alphaMinimum][b.redMinimum][b.greenMinimum][b.blueMaximum] - (-N[b.alphaMinimum][b.redMaximum][b.greenMaximum][b.blueMinimum] + N[b.alphaMinimum][b.redMaximum][b.greenMinimum][b.blueMinimum] + N[b.alphaMinimum][b.redMinimum][b.greenMaximum][b.blueMinimum] - N[b.alphaMinimum][b.redMinimum][b.greenMinimum][b.blueMinimum]);
                      case C.red:
                        return -N[b.alphaMaximum][b.redMinimum][b.greenMaximum][b.blueMaximum] + N[b.alphaMaximum][b.redMinimum][b.greenMinimum][b.blueMaximum] + N[b.alphaMinimum][b.redMinimum][b.greenMaximum][b.blueMaximum] - N[b.alphaMinimum][b.redMinimum][b.greenMinimum][b.blueMaximum] - (-N[b.alphaMaximum][b.redMinimum][b.greenMaximum][b.blueMinimum] + N[b.alphaMaximum][b.redMinimum][b.greenMinimum][b.blueMinimum] + N[b.alphaMinimum][b.redMinimum][b.greenMaximum][b.blueMinimum] - N[b.alphaMinimum][b.redMinimum][b.greenMinimum][b.blueMinimum]);
                      case C.green:
                        return -N[b.alphaMaximum][b.redMaximum][b.greenMinimum][b.blueMaximum] + N[b.alphaMaximum][b.redMinimum][b.greenMinimum][b.blueMaximum] + N[b.alphaMinimum][b.redMaximum][b.greenMinimum][b.blueMaximum] - N[b.alphaMinimum][b.redMinimum][b.greenMinimum][b.blueMaximum] - (-N[b.alphaMaximum][b.redMaximum][b.greenMinimum][b.blueMinimum] + N[b.alphaMaximum][b.redMinimum][b.greenMinimum][b.blueMinimum] + N[b.alphaMinimum][b.redMaximum][b.greenMinimum][b.blueMinimum] - N[b.alphaMinimum][b.redMinimum][b.greenMinimum][b.blueMinimum]);
                      case C.blue:
                        return -N[b.alphaMaximum][b.redMaximum][b.greenMaximum][b.blueMinimum] + N[b.alphaMaximum][b.redMaximum][b.greenMinimum][b.blueMinimum] + N[b.alphaMaximum][b.redMinimum][b.greenMaximum][b.blueMinimum] - N[b.alphaMaximum][b.redMinimum][b.greenMinimum][b.blueMinimum] - (-N[b.alphaMinimum][b.redMaximum][b.greenMaximum][b.blueMinimum] + N[b.alphaMinimum][b.redMaximum][b.greenMinimum][b.blueMinimum] + N[b.alphaMinimum][b.redMinimum][b.greenMaximum][b.blueMinimum] - N[b.alphaMinimum][b.redMinimum][b.greenMinimum][b.blueMinimum]);
                      default:
                        return 0;
                    }
                  }, C.prototype._calculateVariance = function(b) {
                    var B = C._volume(b, this._momentsRed), N = C._volume(b, this._momentsGreen), U = C._volume(b, this._momentsBlue), V = C._volume(b, this._momentsAlpha), W = C._volumeFloat(b, this._moments), q = C._volume(b, this._weights), Y = B * B + N * N + U * U + V * V;
                    return W - Y / q;
                  }, C.prototype._maximize = function(b, B, N, U, V, W, q, Y, re) {
                    for (var se = C._bottom(b, B, this._momentsRed) | 0, ve = C._bottom(b, B, this._momentsGreen) | 0, ce = C._bottom(b, B, this._momentsBlue) | 0, be = C._bottom(b, B, this._momentsAlpha) | 0, Me = C._bottom(b, B, this._weights) | 0, xe = 0, le = -1, de = N; de < U; ++de) {
                      var De = se + C._top(b, B, de, this._momentsRed), ze = ve + C._top(b, B, de, this._momentsGreen), Ze = ce + C._top(b, B, de, this._momentsBlue), Ue = be + C._top(b, B, de, this._momentsAlpha), Ie = Me + C._top(b, B, de, this._weights);
                      if (Ie != 0) {
                        var je = De * De + ze * ze + Ze * Ze + Ue * Ue, Fe = je / Ie;
                        De = V - De, ze = W - ze, Ze = q - Ze, Ue = Y - Ue, Ie = re - Ie, Ie != 0 && (je = De * De + ze * ze + Ze * Ze + Ue * Ue, Fe += je / Ie, Fe > xe && (xe = Fe, le = de));
                      }
                    }
                    return { max: xe, position: le };
                  }, C.prototype._cut = function(b, B) {
                    var N, U = C._volume(b, this._momentsRed), V = C._volume(b, this._momentsGreen), W = C._volume(b, this._momentsBlue), q = C._volume(b, this._momentsAlpha), Y = C._volume(b, this._weights), re = this._maximize(b, C.red, b.redMinimum + 1, b.redMaximum, U, V, W, q, Y), se = this._maximize(b, C.green, b.greenMinimum + 1, b.greenMaximum, U, V, W, q, Y), ve = this._maximize(b, C.blue, b.blueMinimum + 1, b.blueMaximum, U, V, W, q, Y), ce = this._maximize(b, C.alpha, b.alphaMinimum + 1, b.alphaMaximum, U, V, W, q, Y);
                    if (ce.max >= re.max && ce.max >= se.max && ce.max >= ve.max) {
                      if (N = C.alpha, ce.position < 0)
                        return !1;
                    } else
                      re.max >= ce.max && re.max >= se.max && re.max >= ve.max ? N = C.red : se.max >= ce.max && se.max >= re.max && se.max >= ve.max ? N = C.green : N = C.blue;
                    switch (B.redMaximum = b.redMaximum, B.greenMaximum = b.greenMaximum, B.blueMaximum = b.blueMaximum, B.alphaMaximum = b.alphaMaximum, N) {
                      case C.red:
                        B.redMinimum = b.redMaximum = re.position, B.greenMinimum = b.greenMinimum, B.blueMinimum = b.blueMinimum, B.alphaMinimum = b.alphaMinimum;
                        break;
                      case C.green:
                        B.greenMinimum = b.greenMaximum = se.position, B.redMinimum = b.redMinimum, B.blueMinimum = b.blueMinimum, B.alphaMinimum = b.alphaMinimum;
                        break;
                      case C.blue:
                        B.blueMinimum = b.blueMaximum = ve.position, B.redMinimum = b.redMinimum, B.greenMinimum = b.greenMinimum, B.alphaMinimum = b.alphaMinimum;
                        break;
                      case C.alpha:
                        B.alphaMinimum = b.alphaMaximum = ce.position, B.blueMinimum = b.blueMinimum, B.redMinimum = b.redMinimum, B.greenMinimum = b.greenMinimum;
                        break;
                    }
                    return b.volume = (b.redMaximum - b.redMinimum) * (b.greenMaximum - b.greenMinimum) * (b.blueMaximum - b.blueMinimum) * (b.alphaMaximum - b.alphaMinimum), B.volume = (B.redMaximum - B.redMinimum) * (B.greenMaximum - B.greenMinimum) * (B.blueMaximum - B.blueMinimum) * (B.alphaMaximum - B.alphaMinimum), !0;
                  }, C.prototype._initialize = function(b) {
                    this._colors = b, this._cubes = [];
                    for (var B = 0; B < b; B++)
                      this._cubes[B] = new z();
                    this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = E(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = E(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = E(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = E(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = E(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = E(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
                    for (var N = 0; N < 256; ++N)
                      this._table[N] = N * N;
                    this._pixels = [];
                  }, C.prototype._setQuality = function(b) {
                    b === void 0 && (b = 5), this._significantBitsPerChannel = b, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
                  }, C.alpha = 3, C.red = 2, C.green = 1, C.blue = 0, C;
                }();
                r.WuQuant = w;
              },
              /* 30 */
              /***/
              function(Q, r, F) {
                var H = F(31);
                r.NearestColor = H.NearestColor;
                var P = F(32);
                r.ErrorDiffusionArray = P.ErrorDiffusionArray, r.ErrorDiffusionArrayKernel = P.ErrorDiffusionArrayKernel;
                var M = F(33);
                r.ErrorDiffusionRiemersma = M.ErrorDiffusionRiemersma;
              },
              /* 31 */
              /***/
              function(Q, r) {
                var F = function() {
                  function H(P) {
                    this._distance = P;
                  }
                  return H.prototype.quantize = function(P, M) {
                    for (var E = P.getPointArray(), x = P.getWidth(), m = P.getHeight(), I = 0; I < m; I++)
                      for (var z = 0, w = I * x; z < x; z++, w++) {
                        var C = E[w];
                        C.from(M.getNearestColor(this._distance, C));
                      }
                    return P;
                  }, H;
                }();
                r.NearestColor = F;
              },
              /* 32 */
              /***/
              function(Q, r, F) {
                var H = F(24), P = F(6);
                (function(x) {
                  x[x.FloydSteinberg = 0] = "FloydSteinberg", x[x.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", x[x.Stucki = 2] = "Stucki", x[x.Atkinson = 3] = "Atkinson", x[x.Jarvis = 4] = "Jarvis", x[x.Burkes = 5] = "Burkes", x[x.Sierra = 6] = "Sierra", x[x.TwoSierra = 7] = "TwoSierra", x[x.SierraLite = 8] = "SierraLite";
                })(r.ErrorDiffusionArrayKernel || (r.ErrorDiffusionArrayKernel = {}));
                var M = r.ErrorDiffusionArrayKernel, E = function() {
                  function x(m, I, z, w, C) {
                    z === void 0 && (z = !0), w === void 0 && (w = 0), C === void 0 && (C = !1), this._setKernel(I), this._distance = m, this._minColorDistance = w, this._serpentine = z, this._calculateErrorLikeGIMP = C;
                  }
                  return x.prototype.quantize = function(m, I) {
                    for (var z = m.getPointArray(), w = new H.Point(), C = m.getWidth(), b = m.getHeight(), B = [], N = 1, U = 1, V = 0; V < this._kernel.length; V++) {
                      var W = this._kernel[V][2] + 1;
                      U < W && (U = W);
                    }
                    for (var V = 0; V < U; V++)
                      this._fillErrorLine(B[V] = [], C);
                    for (var q = 0; q < b; q++) {
                      this._serpentine && (N = N * -1);
                      var Y = q * C, re = N == 1 ? 0 : C - 1, se = N == 1 ? C : -1;
                      this._fillErrorLine(B[0], C), B.push(B.shift());
                      for (var ve = B[0], ce = re, be = Y + re; ce !== se; ce += N, be += N) {
                        var Me = z[be], xe = ve[ce];
                        w.from(Me);
                        var le = H.Point.createByRGBA(P.inRange0to255Rounded(Me.r + xe[0]), P.inRange0to255Rounded(Me.g + xe[1]), P.inRange0to255Rounded(Me.b + xe[2]), P.inRange0to255Rounded(Me.a + xe[3])), de = I.getNearestColor(this._distance, le);
                        if (Me.from(de), this._minColorDistance) {
                          var De = this._distance.calculateNormalized(Me, de);
                          if (De < this._minColorDistance)
                            continue;
                        }
                        var ze = void 0, Ze = void 0, Ue = void 0, Ie = void 0;
                        this._calculateErrorLikeGIMP ? (ze = le.r - de.r, Ze = le.g - de.g, Ue = le.b - de.b, Ie = le.a - de.a) : (ze = w.r - de.r, Ze = w.g - de.g, Ue = w.b - de.b, Ie = w.a - de.a);
                        for (var je = N == 1 ? 0 : this._kernel.length - 1, Fe = N == 1 ? this._kernel.length : -1, V = je; V !== Fe; V += N) {
                          var $e = this._kernel[V][1] * N, ct = this._kernel[V][2];
                          if ($e + ce >= 0 && $e + ce < C && ct + q >= 0 && ct + q < b) {
                            var wt = this._kernel[V][0], Oe = B[ct][$e + ce];
                            Oe[0] = Oe[0] + ze * wt, Oe[1] = Oe[1] + Ze * wt, Oe[2] = Oe[2] + Ue * wt, Oe[3] = Oe[3] + Ie * wt;
                          }
                        }
                      }
                    }
                    return m;
                  }, x.prototype._fillErrorLine = function(m, I) {
                    m.length > I && (m.length = I);
                    for (var z = m.length, w = 0; w < z; w++) {
                      var C = m[w];
                      C[0] = C[1] = C[2] = C[3] = 0;
                    }
                    for (var w = z; w < I; w++)
                      m[w] = [0, 0, 0, 0];
                  }, x.prototype._setKernel = function(m) {
                    switch (m) {
                      case M.FloydSteinberg:
                        this._kernel = [
                          [7 / 16, 1, 0],
                          [3 / 16, -1, 1],
                          [5 / 16, 0, 1],
                          [1 / 16, 1, 1]
                        ];
                        break;
                      case M.FalseFloydSteinberg:
                        this._kernel = [
                          [3 / 8, 1, 0],
                          [3 / 8, 0, 1],
                          [2 / 8, 1, 1]
                        ];
                        break;
                      case M.Stucki:
                        this._kernel = [
                          [8 / 42, 1, 0],
                          [4 / 42, 2, 0],
                          [2 / 42, -2, 1],
                          [4 / 42, -1, 1],
                          [8 / 42, 0, 1],
                          [4 / 42, 1, 1],
                          [2 / 42, 2, 1],
                          [1 / 42, -2, 2],
                          [2 / 42, -1, 2],
                          [4 / 42, 0, 2],
                          [2 / 42, 1, 2],
                          [1 / 42, 2, 2]
                        ];
                        break;
                      case M.Atkinson:
                        this._kernel = [
                          [1 / 8, 1, 0],
                          [1 / 8, 2, 0],
                          [1 / 8, -1, 1],
                          [1 / 8, 0, 1],
                          [1 / 8, 1, 1],
                          [1 / 8, 0, 2]
                        ];
                        break;
                      case M.Jarvis:
                        this._kernel = [
                          [7 / 48, 1, 0],
                          [5 / 48, 2, 0],
                          [3 / 48, -2, 1],
                          [5 / 48, -1, 1],
                          [7 / 48, 0, 1],
                          [5 / 48, 1, 1],
                          [3 / 48, 2, 1],
                          [1 / 48, -2, 2],
                          [3 / 48, -1, 2],
                          [5 / 48, 0, 2],
                          [3 / 48, 1, 2],
                          [1 / 48, 2, 2]
                        ];
                        break;
                      case M.Burkes:
                        this._kernel = [
                          [8 / 32, 1, 0],
                          [4 / 32, 2, 0],
                          [2 / 32, -2, 1],
                          [4 / 32, -1, 1],
                          [8 / 32, 0, 1],
                          [4 / 32, 1, 1],
                          [2 / 32, 2, 1]
                        ];
                        break;
                      case M.Sierra:
                        this._kernel = [
                          [5 / 32, 1, 0],
                          [3 / 32, 2, 0],
                          [2 / 32, -2, 1],
                          [4 / 32, -1, 1],
                          [5 / 32, 0, 1],
                          [4 / 32, 1, 1],
                          [2 / 32, 2, 1],
                          [2 / 32, -1, 2],
                          [3 / 32, 0, 2],
                          [2 / 32, 1, 2]
                        ];
                        break;
                      case M.TwoSierra:
                        this._kernel = [
                          [4 / 16, 1, 0],
                          [3 / 16, 2, 0],
                          [1 / 16, -2, 1],
                          [2 / 16, -1, 1],
                          [3 / 16, 0, 1],
                          [2 / 16, 1, 1],
                          [1 / 16, 2, 1]
                        ];
                        break;
                      case M.SierraLite:
                        this._kernel = [
                          [2 / 4, 1, 0],
                          [1 / 4, -1, 1],
                          [1 / 4, 0, 1]
                        ];
                        break;
                      default:
                        throw new Error("ErrorDiffusionArray: unknown kernel = " + m);
                    }
                  }, x;
                }();
                r.ErrorDiffusionArray = E;
              },
              /* 33 */
              /***/
              function(Q, r, F) {
                var H = F(34), P = F(24), M = F(6), E = function() {
                  function x(m, I, z) {
                    I === void 0 && (I = 16), z === void 0 && (z = 1), this._distance = m, this._errorPropagation = z, this._errorQueueSize = I, this._max = this._errorQueueSize, this._createWeights();
                  }
                  return x.prototype.quantize = function(m, I) {
                    for (var z = this, w = new H.HilbertCurveBase(), C = m.getPointArray(), b = m.getWidth(), B = m.getHeight(), N = [], U = 0, V = 0; V < this._errorQueueSize; V++)
                      N[V] = { r: 0, g: 0, b: 0, a: 0 };
                    return w.walk(b, B, function(W, q) {
                      for (var Y = C[W + q * b], re = Y.r, se = Y.g, ve = Y.b, ce = Y.a, be = 0; be < z._errorQueueSize; be++) {
                        var Me = z._weights[be], xe = N[(be + U) % z._errorQueueSize];
                        re += xe.r * Me, se += xe.g * Me, ve += xe.b * Me, ce += xe.a * Me;
                      }
                      var le = P.Point.createByRGBA(M.inRange0to255Rounded(re), M.inRange0to255Rounded(se), M.inRange0to255Rounded(ve), M.inRange0to255Rounded(ce)), de = I.getNearestColor(z._distance, le);
                      U = (U + 1) % z._errorQueueSize;
                      var De = (U + z._errorQueueSize - 1) % z._errorQueueSize;
                      N[De].r = Y.r - de.r, N[De].g = Y.g - de.g, N[De].b = Y.b - de.b, N[De].a = Y.a - de.a, Y.from(de);
                    }), m;
                  }, x.prototype._createWeights = function() {
                    this._weights = [];
                    for (var m = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1)), I = 0, z = 1; I < this._errorQueueSize; I++)
                      this._weights[I] = (z + 0.5 | 0) / this._max * this._errorPropagation, z *= m;
                  }, x;
                }();
                r.ErrorDiffusionRiemersma = E;
              },
              /* 34 */
              /***/
              function(Q, r) {
                var F;
                (function(P) {
                  P[P.NONE = 0] = "NONE", P[P.UP = 1] = "UP", P[P.LEFT = 2] = "LEFT", P[P.RIGHT = 3] = "RIGHT", P[P.DOWN = 4] = "DOWN";
                })(F || (F = {}));
                var H = function() {
                  function P() {
                  }
                  return P.prototype.walk = function(M, E, x) {
                    this._x = 0, this._y = 0, this._d = 0, this._width = M, this._height = E, this._callback = x;
                    var m = Math.max(M, E);
                    this._level = Math.log(m) / Math.log(2) + 1 | 0, this._walkHilbert(F.UP), this._visit(F.NONE);
                  }, P.prototype._walkHilbert = function(M) {
                    if (!(this._level < 1)) {
                      switch (this._level--, M) {
                        case F.LEFT:
                          this._walkHilbert(F.UP), this._visit(F.RIGHT), this._walkHilbert(F.LEFT), this._visit(F.DOWN), this._walkHilbert(F.LEFT), this._visit(F.LEFT), this._walkHilbert(F.DOWN);
                          break;
                        case F.RIGHT:
                          this._walkHilbert(F.DOWN), this._visit(F.LEFT), this._walkHilbert(F.RIGHT), this._visit(F.UP), this._walkHilbert(F.RIGHT), this._visit(F.RIGHT), this._walkHilbert(F.UP);
                          break;
                        case F.UP:
                          this._walkHilbert(F.LEFT), this._visit(F.DOWN), this._walkHilbert(F.UP), this._visit(F.RIGHT), this._walkHilbert(F.UP), this._visit(F.UP), this._walkHilbert(F.RIGHT);
                          break;
                        case F.DOWN:
                          this._walkHilbert(F.RIGHT), this._visit(F.UP), this._walkHilbert(F.DOWN), this._visit(F.LEFT), this._walkHilbert(F.DOWN), this._visit(F.DOWN), this._walkHilbert(F.LEFT);
                          break;
                      }
                      this._level++;
                    }
                  }, P.prototype._visit = function(M) {
                    switch (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height && (this._callback(this._x, this._y, this._d), this._d++), M) {
                      case F.LEFT:
                        this._x--;
                        break;
                      case F.RIGHT:
                        this._x++;
                        break;
                      case F.UP:
                        this._y--;
                        break;
                      case F.DOWN:
                        this._y++;
                        break;
                    }
                  }, P;
                }();
                r.HilbertCurveBase = H;
              },
              /* 35 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var H = F(36);
                r.SSIM = H.SSIM;
              },
              /* 36 */
              /***/
              function(Q, r, F) {
                var H = F(2), P = 0.01, M = 0.03, E = function() {
                  function x() {
                  }
                  return x.prototype.compare = function(m, I) {
                    if (m.getHeight() !== I.getHeight() || m.getWidth() !== I.getWidth())
                      throw new Error("Images have different sizes!");
                    var z = 8, w = (1 << z) - 1, C = Math.pow(P * w, 2), b = Math.pow(M * w, 2), B = 0, N = 0;
                    return this._iterate(m, I, function(U, V, W, q) {
                      for (var Y = 0, re = 0, se = 0, ve = 0; ve < U.length; ve++)
                        re += Math.pow(U[ve] - W, 2), se += Math.pow(V[ve] - q, 2), Y += (U[ve] - W) * (V[ve] - q);
                      var ce = U.length - 1;
                      re /= ce, se /= ce, Y /= ce;
                      var be = (2 * W * q + C) * (2 * Y + b), Me = (Math.pow(W, 2) + Math.pow(q, 2) + C) * (re + se + b), xe = be / Me;
                      N += xe, B++;
                    }), N / B;
                  }, x.prototype._iterate = function(m, I, z) {
                    for (var w = 8, C = m.getWidth(), b = m.getHeight(), B = 0; B < b; B += w)
                      for (var N = 0; N < C; N += w) {
                        var U = Math.min(w, C - N), V = Math.min(w, b - B), W = this._calculateLumaValuesForWindow(m, N, B, U, V), q = this._calculateLumaValuesForWindow(I, N, B, U, V), Y = this._calculateAverageLuma(W), re = this._calculateAverageLuma(q);
                        z(W, q, Y, re);
                      }
                  }, x.prototype._calculateLumaValuesForWindow = function(m, I, z, w, C) {
                    for (var b = m.getPointArray(), B = [], N = 0, U = z; U < z + C; U++)
                      for (var V = U * m.getWidth(), W = I; W < I + w; W++) {
                        var q = b[V + W];
                        B[N] = q.r * H.Y.RED + q.g * H.Y.GREEN + q.b * H.Y.BLUE, N++;
                      }
                    return B;
                  }, x.prototype._calculateAverageLuma = function(m) {
                    for (var I = 0, z = 0; z < m.length; z++)
                      I += m[z];
                    return I / m.length;
                  }, x;
                }();
                r.SSIM = E;
              },
              /* 37 */
              /***/
              function(Q, r, F) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var H = F(6);
                r.arithmetic = H;
                var P = F(28);
                r.HueStatistics = P.HueStatistics;
                var M = F(22);
                r.Palette = M.Palette;
                var E = F(24);
                r.Point = E.Point;
                var x = F(23);
                r.PointContainer = x.PointContainer;
              }
              /******/
            ])
          );
        });
      }, {}], 75: [function(te, Ee, $) {
        typeof Object.create == "function" ? Ee.exports = function(r, F) {
          F && (r.super_ = F, r.prototype = Object.create(F.prototype, {
            constructor: {
              value: r,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          }));
        } : Ee.exports = function(r, F) {
          if (F) {
            r.super_ = F;
            var H = function() {
            };
            H.prototype = F.prototype, r.prototype = new H(), r.prototype.constructor = r;
          }
        };
      }, {}], 76: [function(te, Ee, $) {
        /*!
         * Determine if an object is a Buffer
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */
        Ee.exports = function(F) {
          return F != null && (Q(F) || r(F) || !!F._isBuffer);
        };
        function Q(F) {
          return !!F.constructor && typeof F.constructor.isBuffer == "function" && F.constructor.isBuffer(F);
        }
        function r(F) {
          return typeof F.readFloatLE == "function" && typeof F.slice == "function" && Q(F.slice(0, 0));
        }
      }, {}], 77: [function(te, Ee, $) {
        var Q = Function.prototype.toString, r = /^\s*class\b/, F = function(I) {
          try {
            var z = Q.call(I);
            return r.test(z);
          } catch {
            return !1;
          }
        }, H = function(I) {
          try {
            return F(I) ? !1 : (Q.call(I), !0);
          } catch {
            return !1;
          }
        }, P = Object.prototype.toString, M = "[object Function]", E = "[object GeneratorFunction]", x = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
        Ee.exports = function(I) {
          if (!I || typeof I != "function" && typeof I != "object")
            return !1;
          if (typeof I == "function" && !I.prototype)
            return !0;
          if (x)
            return H(I);
          if (F(I))
            return !1;
          var z = P.call(I);
          return z === M || z === E;
        };
      }, {}], 78: [function(te, Ee, $) {
        Ee.exports = r;
        var Q = Object.prototype.toString;
        function r(F) {
          var H = Q.call(F);
          return H === "[object Function]" || typeof F == "function" && H !== "[object RegExp]" || typeof pt < "u" && // IE8 and below
          (F === pt.setTimeout || F === pt.alert || F === pt.confirm || F === pt.prompt);
        }
      }, {}], 79: [function(te, Ee, $) {
        var Q = {}.toString;
        Ee.exports = Array.isArray || function(r) {
          return Q.call(r) == "[object Array]";
        };
      }, {}], 80: [function(te, Ee, $) {
        var Q = te("./lib/encoder"), r = te("./lib/decoder");
        Ee.exports = {
          encode: Q,
          decode: r
        };
      }, { "./lib/decoder": 81, "./lib/encoder": 82 }], 81: [function(te, Ee, $) {
        (function(Q) {
          var r = function() {
            var P = new Int32Array([
              0,
              1,
              8,
              16,
              9,
              2,
              3,
              10,
              17,
              24,
              32,
              25,
              18,
              11,
              4,
              5,
              12,
              19,
              26,
              33,
              40,
              48,
              41,
              34,
              27,
              20,
              13,
              6,
              7,
              14,
              21,
              28,
              35,
              42,
              49,
              56,
              57,
              50,
              43,
              36,
              29,
              22,
              15,
              23,
              30,
              37,
              44,
              51,
              58,
              59,
              52,
              45,
              38,
              31,
              39,
              46,
              53,
              60,
              61,
              54,
              47,
              55,
              62,
              63
            ]), M = 4017, E = 799, x = 3406, m = 2276, I = 1567, z = 3784, w = 5793, C = 2896;
            function b() {
            }
            function B(re, se) {
              for (var ve = 0, ce = [], be, Me, xe = 16; xe > 0 && !re[xe - 1]; )
                xe--;
              ce.push({ children: [], index: 0 });
              var le = ce[0], de;
              for (be = 0; be < xe; be++) {
                for (Me = 0; Me < re[be]; Me++) {
                  for (le = ce.pop(), le.children[le.index] = se[ve]; le.index > 0; ) {
                    if (ce.length === 0)
                      throw new Error("Could not recreate Huffman Table");
                    le = ce.pop();
                  }
                  for (le.index++, ce.push(le); ce.length <= be; )
                    ce.push(de = { children: [], index: 0 }), le.children[le.index] = de.children, le = de;
                  ve++;
                }
                be + 1 < xe && (ce.push(de = { children: [], index: 0 }), le.children[le.index] = de.children, le = de);
              }
              return ce[0].children;
            }
            function N(re, se, ve, ce, be, Me, xe, le, de, De) {
              ve.precision, ve.samplesPerLine, ve.scanLines;
              var ze = ve.mcusPerLine, Ze = ve.progressive;
              ve.maxH, ve.maxV;
              var Ue = se, Ie = 0, je = 0;
              function Fe() {
                if (je > 0)
                  return je--, Ie >> je & 1;
                if (Ie = re[se++], Ie == 255) {
                  var Ur = re[se++];
                  if (Ur)
                    throw new Error("unexpected marker: " + (Ie << 8 | Ur).toString(16));
                }
                return je = 7, Ie >>> 7;
              }
              function $e(Ur) {
                for (var Rr = Ur, Pr; (Pr = Fe()) !== null; ) {
                  if (Rr = Rr[Pr], typeof Rr == "number")
                    return Rr;
                  if (typeof Rr != "object")
                    throw new Error("invalid huffman sequence");
                }
                return null;
              }
              function ct(Ur) {
                for (var Rr = 0; Ur > 0; ) {
                  var Pr = Fe();
                  if (Pr === null) return;
                  Rr = Rr << 1 | Pr, Ur--;
                }
                return Rr;
              }
              function wt(Ur) {
                var Rr = ct(Ur);
                return Rr >= 1 << Ur - 1 ? Rr : Rr + (-1 << Ur) + 1;
              }
              function Oe(Ur, Rr) {
                var Pr = $e(Ur.huffmanTableDC), hi = Pr === 0 ? 0 : wt(Pr);
                Rr[0] = Ur.pred += hi;
                for (var Vr = 1; Vr < 64; ) {
                  var Te = $e(Ur.huffmanTableAC), Tt = Te & 15, Gt = Te >> 4;
                  if (Tt === 0) {
                    if (Gt < 15)
                      break;
                    Vr += 16;
                    continue;
                  }
                  Vr += Gt;
                  var pr = P[Vr];
                  Rr[pr] = wt(Tt), Vr++;
                }
              }
              function Ct(Ur, Rr) {
                var Pr = $e(Ur.huffmanTableDC), hi = Pr === 0 ? 0 : wt(Pr) << de;
                Rr[0] = Ur.pred += hi;
              }
              function Xt(Ur, Rr) {
                Rr[0] |= Fe() << de;
              }
              var vt = 0;
              function Ye(Ur, Rr) {
                if (vt > 0) {
                  vt--;
                  return;
                }
                for (var Pr = Me, hi = xe; Pr <= hi; ) {
                  var Vr = $e(Ur.huffmanTableAC), Te = Vr & 15, Tt = Vr >> 4;
                  if (Te === 0) {
                    if (Tt < 15) {
                      vt = ct(Tt) + (1 << Tt) - 1;
                      break;
                    }
                    Pr += 16;
                    continue;
                  }
                  Pr += Tt;
                  var Gt = P[Pr];
                  Rr[Gt] = wt(Te) * (1 << de), Pr++;
                }
              }
              var qe = 0, rt;
              function it(Ur, Rr) {
                for (var Pr = Me, hi = xe, Vr = 0; Pr <= hi; ) {
                  var Te = P[Pr], Tt = Rr[Te] < 0 ? -1 : 1;
                  switch (qe) {
                    case 0:
                      var Gt = $e(Ur.huffmanTableAC), pr = Gt & 15, Vr = Gt >> 4;
                      if (pr === 0)
                        Vr < 15 ? (vt = ct(Vr) + (1 << Vr), qe = 4) : (Vr = 16, qe = 1);
                      else {
                        if (pr !== 1)
                          throw new Error("invalid ACn encoding");
                        rt = wt(pr), qe = Vr ? 2 : 3;
                      }
                      continue;
                    case 1:
                    // skipping r zero items
                    case 2:
                      Rr[Te] ? Rr[Te] += (Fe() << de) * Tt : (Vr--, Vr === 0 && (qe = qe == 2 ? 3 : 0));
                      break;
                    case 3:
                      Rr[Te] ? Rr[Te] += (Fe() << de) * Tt : (Rr[Te] = rt << de, qe = 0);
                      break;
                    case 4:
                      Rr[Te] && (Rr[Te] += (Fe() << de) * Tt);
                      break;
                  }
                  Pr++;
                }
                qe === 4 && (vt--, vt === 0 && (qe = 0));
              }
              function Ae(Ur, Rr, Pr, hi, Vr) {
                var Te = Pr / ze | 0, Tt = Pr % ze, Gt = Te * Ur.v + hi, pr = Tt * Ur.h + Vr;
                Ur.blocks[Gt] === void 0 && De.tolerantDecoding || Rr(Ur, Ur.blocks[Gt][pr]);
              }
              function _e(Ur, Rr, Pr) {
                var hi = Pr / Ur.blocksPerLine | 0, Vr = Pr % Ur.blocksPerLine;
                Ur.blocks[hi] === void 0 && De.tolerantDecoding || Rr(Ur, Ur.blocks[hi][Vr]);
              }
              var fe = ce.length, We, Pe, he, ie, Xe, bt;
              Ze ? Me === 0 ? bt = le === 0 ? Ct : Xt : bt = le === 0 ? Ye : it : bt = Oe;
              var Wt = 0, Qt, Sr;
              fe == 1 ? Sr = ce[0].blocksPerLine * ce[0].blocksPerColumn : Sr = ze * ve.mcusPerColumn, be || (be = Sr);
              for (var Fr, kr; Wt < Sr; ) {
                for (Pe = 0; Pe < fe; Pe++)
                  ce[Pe].pred = 0;
                if (vt = 0, fe == 1)
                  for (We = ce[0], Xe = 0; Xe < be; Xe++)
                    _e(We, bt, Wt), Wt++;
                else
                  for (Xe = 0; Xe < be; Xe++) {
                    for (Pe = 0; Pe < fe; Pe++)
                      for (We = ce[Pe], Fr = We.h, kr = We.v, he = 0; he < kr; he++)
                        for (ie = 0; ie < Fr; ie++)
                          Ae(We, bt, Wt, he, ie);
                    if (Wt++, Wt === Sr) break;
                  }
                if (Wt === Sr)
                  do {
                    if (re[se] === 255 && re[se + 1] !== 0)
                      break;
                    se += 1;
                  } while (se < re.length - 2);
                if (je = 0, Qt = re[se] << 8 | re[se + 1], Qt < 65280)
                  throw new Error("marker was not found");
                if (Qt >= 65488 && Qt <= 65495)
                  se += 2;
                else
                  break;
              }
              return se - Ue;
            }
            function U(re, se) {
              var ve = [], ce = se.blocksPerLine, be = se.blocksPerColumn, Me = ce << 3, xe = new Int32Array(64), le = new Uint8Array(64);
              function de(ct, wt, Oe) {
                var Ct = se.quantizationTable, Xt, vt, Ye, qe, rt, it, Ae, _e, fe, We = Oe, Pe;
                for (Pe = 0; Pe < 64; Pe++)
                  We[Pe] = ct[Pe] * Ct[Pe];
                for (Pe = 0; Pe < 8; ++Pe) {
                  var he = 8 * Pe;
                  if (We[1 + he] == 0 && We[2 + he] == 0 && We[3 + he] == 0 && We[4 + he] == 0 && We[5 + he] == 0 && We[6 + he] == 0 && We[7 + he] == 0) {
                    fe = w * We[0 + he] + 512 >> 10, We[0 + he] = fe, We[1 + he] = fe, We[2 + he] = fe, We[3 + he] = fe, We[4 + he] = fe, We[5 + he] = fe, We[6 + he] = fe, We[7 + he] = fe;
                    continue;
                  }
                  Xt = w * We[0 + he] + 128 >> 8, vt = w * We[4 + he] + 128 >> 8, Ye = We[2 + he], qe = We[6 + he], rt = C * (We[1 + he] - We[7 + he]) + 128 >> 8, _e = C * (We[1 + he] + We[7 + he]) + 128 >> 8, it = We[3 + he] << 4, Ae = We[5 + he] << 4, fe = Xt - vt + 1 >> 1, Xt = Xt + vt + 1 >> 1, vt = fe, fe = Ye * z + qe * I + 128 >> 8, Ye = Ye * I - qe * z + 128 >> 8, qe = fe, fe = rt - Ae + 1 >> 1, rt = rt + Ae + 1 >> 1, Ae = fe, fe = _e + it + 1 >> 1, it = _e - it + 1 >> 1, _e = fe, fe = Xt - qe + 1 >> 1, Xt = Xt + qe + 1 >> 1, qe = fe, fe = vt - Ye + 1 >> 1, vt = vt + Ye + 1 >> 1, Ye = fe, fe = rt * m + _e * x + 2048 >> 12, rt = rt * x - _e * m + 2048 >> 12, _e = fe, fe = it * E + Ae * M + 2048 >> 12, it = it * M - Ae * E + 2048 >> 12, Ae = fe, We[0 + he] = Xt + _e, We[7 + he] = Xt - _e, We[1 + he] = vt + Ae, We[6 + he] = vt - Ae, We[2 + he] = Ye + it, We[5 + he] = Ye - it, We[3 + he] = qe + rt, We[4 + he] = qe - rt;
                }
                for (Pe = 0; Pe < 8; ++Pe) {
                  var ie = Pe;
                  if (We[8 + ie] == 0 && We[16 + ie] == 0 && We[24 + ie] == 0 && We[32 + ie] == 0 && We[40 + ie] == 0 && We[48 + ie] == 0 && We[56 + ie] == 0) {
                    fe = w * Oe[Pe + 0] + 8192 >> 14, We[0 + ie] = fe, We[8 + ie] = fe, We[16 + ie] = fe, We[24 + ie] = fe, We[32 + ie] = fe, We[40 + ie] = fe, We[48 + ie] = fe, We[56 + ie] = fe;
                    continue;
                  }
                  Xt = w * We[0 + ie] + 2048 >> 12, vt = w * We[32 + ie] + 2048 >> 12, Ye = We[16 + ie], qe = We[48 + ie], rt = C * (We[8 + ie] - We[56 + ie]) + 2048 >> 12, _e = C * (We[8 + ie] + We[56 + ie]) + 2048 >> 12, it = We[24 + ie], Ae = We[40 + ie], fe = Xt - vt + 1 >> 1, Xt = Xt + vt + 1 >> 1, vt = fe, fe = Ye * z + qe * I + 2048 >> 12, Ye = Ye * I - qe * z + 2048 >> 12, qe = fe, fe = rt - Ae + 1 >> 1, rt = rt + Ae + 1 >> 1, Ae = fe, fe = _e + it + 1 >> 1, it = _e - it + 1 >> 1, _e = fe, fe = Xt - qe + 1 >> 1, Xt = Xt + qe + 1 >> 1, qe = fe, fe = vt - Ye + 1 >> 1, vt = vt + Ye + 1 >> 1, Ye = fe, fe = rt * m + _e * x + 2048 >> 12, rt = rt * x - _e * m + 2048 >> 12, _e = fe, fe = it * E + Ae * M + 2048 >> 12, it = it * M - Ae * E + 2048 >> 12, Ae = fe, We[0 + ie] = Xt + _e, We[56 + ie] = Xt - _e, We[8 + ie] = vt + Ae, We[48 + ie] = vt - Ae, We[16 + ie] = Ye + it, We[40 + ie] = Ye - it, We[24 + ie] = qe + rt, We[32 + ie] = qe - rt;
                }
                for (Pe = 0; Pe < 64; ++Pe) {
                  var Xe = 128 + (We[Pe] + 8 >> 4);
                  wt[Pe] = Xe < 0 ? 0 : Xe > 255 ? 255 : Xe;
                }
              }
              Y(Me * be * 8);
              for (var De, ze, Ze = 0; Ze < be; Ze++) {
                var Ue = Ze << 3;
                for (De = 0; De < 8; De++)
                  ve.push(new Uint8Array(Me));
                for (var Ie = 0; Ie < ce; Ie++) {
                  de(se.blocks[Ze][Ie], le, xe);
                  var je = 0, Fe = Ie << 3;
                  for (ze = 0; ze < 8; ze++) {
                    var $e = ve[Ue + ze];
                    for (De = 0; De < 8; De++)
                      $e[Fe + De] = le[je++];
                  }
                }
              }
              return ve;
            }
            function V(re) {
              return re < 0 ? 0 : re > 255 ? 255 : re;
            }
            b.prototype = {
              load: function(se) {
                var ve = new XMLHttpRequest();
                ve.open("GET", se, !0), ve.responseType = "arraybuffer", ve.onload = (function() {
                  var ce = new Uint8Array(ve.response || ve.mozResponseArrayBuffer);
                  this.parse(ce), this.onload && this.onload();
                }).bind(this), ve.send(null);
              },
              parse: function(se) {
                var ve = this.opts.maxResolutionInMP * 1e3 * 1e3, ce = 0;
                se.length;
                function be() {
                  var Vr = se[ce] << 8 | se[ce + 1];
                  return ce += 2, Vr;
                }
                function Me() {
                  var Vr = be(), Te = se.subarray(ce, ce + Vr - 2);
                  return ce += Te.length, Te;
                }
                function xe(Vr) {
                  var Te = 0, Tt = 0, Gt, pr;
                  for (pr in Vr.components)
                    Vr.components.hasOwnProperty(pr) && (Gt = Vr.components[pr], Te < Gt.h && (Te = Gt.h), Tt < Gt.v && (Tt = Gt.v));
                  var kt = Math.ceil(Vr.samplesPerLine / 8 / Te), tr = Math.ceil(Vr.scanLines / 8 / Tt);
                  for (pr in Vr.components)
                    if (Vr.components.hasOwnProperty(pr)) {
                      Gt = Vr.components[pr];
                      var Je = Math.ceil(Math.ceil(Vr.samplesPerLine / 8) * Gt.h / Te), wr = Math.ceil(Math.ceil(Vr.scanLines / 8) * Gt.v / Tt), ni = kt * Gt.h, Z = tr * Gt.v, Dt = Z * ni, er = [];
                      Y(Dt * 256);
                      for (var we = 0; we < Z; we++) {
                        for (var yt = [], ar = 0; ar < ni; ar++)
                          yt.push(new Int32Array(64));
                        er.push(yt);
                      }
                      Gt.blocksPerLine = Je, Gt.blocksPerColumn = wr, Gt.blocks = er;
                    }
                  Vr.maxH = Te, Vr.maxV = Tt, Vr.mcusPerLine = kt, Vr.mcusPerColumn = tr;
                }
                var le = null, de = null, De, ze, Ze = [], Ue = [], Ie = [], je = [], Fe = be();
                if (Fe != 65496)
                  throw new Error("SOI not found");
                for (Fe = be(); Fe != 65497; ) {
                  var $e, ct;
                  switch (Fe) {
                    case 65280:
                      break;
                    case 65504:
                    // APP0 (Application Specific)
                    case 65505:
                    // APP1
                    case 65506:
                    // APP2
                    case 65507:
                    // APP3
                    case 65508:
                    // APP4
                    case 65509:
                    // APP5
                    case 65510:
                    // APP6
                    case 65511:
                    // APP7
                    case 65512:
                    // APP8
                    case 65513:
                    // APP9
                    case 65514:
                    // APP10
                    case 65515:
                    // APP11
                    case 65516:
                    // APP12
                    case 65517:
                    // APP13
                    case 65518:
                    // APP14
                    case 65519:
                    // APP15
                    case 65534:
                      var wt = Me();
                      Fe === 65504 && wt[0] === 74 && wt[1] === 70 && wt[2] === 73 && wt[3] === 70 && wt[4] === 0 && (le = {
                        version: { major: wt[5], minor: wt[6] },
                        densityUnits: wt[7],
                        xDensity: wt[8] << 8 | wt[9],
                        yDensity: wt[10] << 8 | wt[11],
                        thumbWidth: wt[12],
                        thumbHeight: wt[13],
                        thumbData: wt.subarray(14, 14 + 3 * wt[12] * wt[13])
                      }), Fe === 65505 && wt[0] === 69 && wt[1] === 120 && wt[2] === 105 && wt[3] === 102 && wt[4] === 0 && (this.exifBuffer = wt.subarray(5, wt.length)), Fe === 65518 && wt[0] === 65 && wt[1] === 100 && wt[2] === 111 && wt[3] === 98 && wt[4] === 101 && wt[5] === 0 && (de = {
                        version: wt[6],
                        flags0: wt[7] << 8 | wt[8],
                        flags1: wt[9] << 8 | wt[10],
                        transformCode: wt[11]
                      });
                      break;
                    case 65499:
                      for (var Oe = be(), Ct = Oe + ce - 2; ce < Ct; ) {
                        var Xt = se[ce++];
                        Y(256);
                        var vt = new Int32Array(64);
                        if (Xt >> 4)
                          if (Xt >> 4 === 1)
                            for (ct = 0; ct < 64; ct++) {
                              var Ye = P[ct];
                              vt[Ye] = be();
                            }
                          else
                            throw new Error("DQT: invalid table spec");
                        else for (ct = 0; ct < 64; ct++) {
                          var Ye = P[ct];
                          vt[Ye] = se[ce++];
                        }
                        Ze[Xt & 15] = vt;
                      }
                      break;
                    case 65472:
                    // SOF0 (Start of Frame, Baseline DCT)
                    case 65473:
                    // SOF1 (Start of Frame, Extended DCT)
                    case 65474:
                      be(), De = {}, De.extended = Fe === 65473, De.progressive = Fe === 65474, De.precision = se[ce++], De.scanLines = be(), De.samplesPerLine = be(), De.components = {}, De.componentsOrder = [];
                      var qe = De.scanLines * De.samplesPerLine;
                      if (qe > ve) {
                        var rt = Math.ceil((qe - ve) / 1e6);
                        throw new Error(`maxResolutionInMP limit exceeded by ${rt}MP`);
                      }
                      var it = se[ce++], Ae;
                      for ($e = 0; $e < it; $e++) {
                        Ae = se[ce];
                        var _e = se[ce + 1] >> 4, fe = se[ce + 1] & 15, We = se[ce + 2];
                        De.componentsOrder.push(Ae), De.components[Ae] = {
                          h: _e,
                          v: fe,
                          quantizationIdx: We
                        }, ce += 3;
                      }
                      xe(De), Ue.push(De);
                      break;
                    case 65476:
                      var Pe = be();
                      for ($e = 2; $e < Pe; ) {
                        var he = se[ce++], ie = new Uint8Array(16), Xe = 0;
                        for (ct = 0; ct < 16; ct++, ce++)
                          Xe += ie[ct] = se[ce];
                        Y(16 + Xe);
                        var bt = new Uint8Array(Xe);
                        for (ct = 0; ct < Xe; ct++, ce++)
                          bt[ct] = se[ce];
                        $e += 17 + Xe, (he >> 4 ? Ie : je)[he & 15] = B(ie, bt);
                      }
                      break;
                    case 65501:
                      be(), ze = be();
                      break;
                    case 65498:
                      be();
                      var Wt = se[ce++], Qt = [], Sr;
                      for ($e = 0; $e < Wt; $e++) {
                        Sr = De.components[se[ce++]];
                        var Fr = se[ce++];
                        Sr.huffmanTableDC = je[Fr >> 4], Sr.huffmanTableAC = Ie[Fr & 15], Qt.push(Sr);
                      }
                      var kr = se[ce++], Ur = se[ce++], Rr = se[ce++], Pr = N(
                        se,
                        ce,
                        De,
                        Qt,
                        ze,
                        kr,
                        Ur,
                        Rr >> 4,
                        Rr & 15,
                        this.opts
                      );
                      ce += Pr;
                      break;
                    case 65535:
                      se[ce] !== 255 && ce--;
                      break;
                    default:
                      if (se[ce - 3] == 255 && se[ce - 2] >= 192 && se[ce - 2] <= 254) {
                        ce -= 3;
                        break;
                      }
                      throw new Error("unknown JPEG marker " + Fe.toString(16));
                  }
                  Fe = be();
                }
                if (Ue.length != 1)
                  throw new Error("only single frame JPEGs supported");
                for (var $e = 0; $e < Ue.length; $e++) {
                  var hi = Ue[$e].components;
                  for (var ct in hi)
                    hi[ct].quantizationTable = Ze[hi[ct].quantizationIdx], delete hi[ct].quantizationIdx;
                }
                this.width = De.samplesPerLine, this.height = De.scanLines, this.jfif = le, this.adobe = de, this.components = [];
                for (var $e = 0; $e < De.componentsOrder.length; $e++) {
                  var Sr = De.components[De.componentsOrder[$e]];
                  this.components.push({
                    lines: U(De, Sr),
                    scaleX: Sr.h / De.maxH,
                    scaleY: Sr.v / De.maxV
                  });
                }
              },
              getData: function(se, ve) {
                var ce = this.width / se, be = this.height / ve, Me, xe, le, de, De, ze, Ze, Ue, Ie, je, Fe = 0, $e, ct, wt, Oe, Ct, Xt, vt, Ye, qe, rt, it, Ae = se * ve * this.components.length;
                Y(Ae);
                var _e = new Uint8Array(Ae);
                switch (this.components.length) {
                  case 1:
                    for (Me = this.components[0], je = 0; je < ve; je++)
                      for (De = Me.lines[0 | je * Me.scaleY * be], Ie = 0; Ie < se; Ie++)
                        $e = De[0 | Ie * Me.scaleX * ce], _e[Fe++] = $e;
                    break;
                  case 2:
                    for (Me = this.components[0], xe = this.components[1], je = 0; je < ve; je++)
                      for (De = Me.lines[0 | je * Me.scaleY * be], ze = xe.lines[0 | je * xe.scaleY * be], Ie = 0; Ie < se; Ie++)
                        $e = De[0 | Ie * Me.scaleX * ce], _e[Fe++] = $e, $e = ze[0 | Ie * xe.scaleX * ce], _e[Fe++] = $e;
                    break;
                  case 3:
                    for (it = !0, this.adobe && this.adobe.transformCode ? it = !0 : typeof this.opts.colorTransform < "u" && (it = !!this.opts.colorTransform), Me = this.components[0], xe = this.components[1], le = this.components[2], je = 0; je < ve; je++)
                      for (De = Me.lines[0 | je * Me.scaleY * be], ze = xe.lines[0 | je * xe.scaleY * be], Ze = le.lines[0 | je * le.scaleY * be], Ie = 0; Ie < se; Ie++)
                        it ? ($e = De[0 | Ie * Me.scaleX * ce], ct = ze[0 | Ie * xe.scaleX * ce], wt = Ze[0 | Ie * le.scaleX * ce], Ye = V($e + 1.402 * (wt - 128)), qe = V($e - 0.3441363 * (ct - 128) - 0.71413636 * (wt - 128)), rt = V($e + 1.772 * (ct - 128))) : (Ye = De[0 | Ie * Me.scaleX * ce], qe = ze[0 | Ie * xe.scaleX * ce], rt = Ze[0 | Ie * le.scaleX * ce]), _e[Fe++] = Ye, _e[Fe++] = qe, _e[Fe++] = rt;
                    break;
                  case 4:
                    if (!this.adobe)
                      throw new Error("Unsupported color mode (4 components)");
                    for (it = !1, this.adobe && this.adobe.transformCode ? it = !0 : typeof this.opts.colorTransform < "u" && (it = !!this.opts.colorTransform), Me = this.components[0], xe = this.components[1], le = this.components[2], de = this.components[3], je = 0; je < ve; je++)
                      for (De = Me.lines[0 | je * Me.scaleY * be], ze = xe.lines[0 | je * xe.scaleY * be], Ze = le.lines[0 | je * le.scaleY * be], Ue = de.lines[0 | je * de.scaleY * be], Ie = 0; Ie < se; Ie++)
                        it ? ($e = De[0 | Ie * Me.scaleX * ce], ct = ze[0 | Ie * xe.scaleX * ce], wt = Ze[0 | Ie * le.scaleX * ce], Oe = Ue[0 | Ie * de.scaleX * ce], Ct = 255 - V($e + 1.402 * (wt - 128)), Xt = 255 - V($e - 0.3441363 * (ct - 128) - 0.71413636 * (wt - 128)), vt = 255 - V($e + 1.772 * (ct - 128))) : (Ct = De[0 | Ie * Me.scaleX * ce], Xt = ze[0 | Ie * xe.scaleX * ce], vt = Ze[0 | Ie * le.scaleX * ce], Oe = Ue[0 | Ie * de.scaleX * ce]), _e[Fe++] = 255 - Ct, _e[Fe++] = 255 - Xt, _e[Fe++] = 255 - vt, _e[Fe++] = 255 - Oe;
                    break;
                  default:
                    throw new Error("Unsupported color mode");
                }
                return _e;
              },
              copyToImageData: function(se, ve) {
                var ce = se.width, be = se.height, Me = se.data, xe = this.getData(ce, be), le = 0, de = 0, De, ze, Ze, Ue, Ie, je, Fe, $e, ct;
                switch (this.components.length) {
                  case 1:
                    for (ze = 0; ze < be; ze++)
                      for (De = 0; De < ce; De++)
                        Ze = xe[le++], Me[de++] = Ze, Me[de++] = Ze, Me[de++] = Ze, ve && (Me[de++] = 255);
                    break;
                  case 3:
                    for (ze = 0; ze < be; ze++)
                      for (De = 0; De < ce; De++)
                        Fe = xe[le++], $e = xe[le++], ct = xe[le++], Me[de++] = Fe, Me[de++] = $e, Me[de++] = ct, ve && (Me[de++] = 255);
                    break;
                  case 4:
                    for (ze = 0; ze < be; ze++)
                      for (De = 0; De < ce; De++)
                        Ie = xe[le++], je = xe[le++], Ze = xe[le++], Ue = xe[le++], Fe = 255 - V(Ie * (1 - Ue / 255) + Ue), $e = 255 - V(je * (1 - Ue / 255) + Ue), ct = 255 - V(Ze * (1 - Ue / 255) + Ue), Me[de++] = Fe, Me[de++] = $e, Me[de++] = ct, ve && (Me[de++] = 255);
                    break;
                  default:
                    throw new Error("Unsupported color mode");
                }
              }
            };
            var W = 0, q = 0;
            function Y(re = 0) {
              var se = W + re;
              if (se > q) {
                var ve = Math.ceil((se - q) / 1024 / 1024);
                throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${ve}MB`);
              }
              W = se;
            }
            return b.resetMaxMemoryUsage = function(re) {
              W = 0, q = re;
            }, b.getBytesAllocated = function() {
              return W;
            }, b.requestMemoryAllocation = Y, b;
          }();
          typeof Ee < "u" ? Ee.exports = F : typeof pt < "u" && (pt["jpeg-js"] = pt["jpeg-js"] || {}, pt["jpeg-js"].decode = F);
          function F(H, P = {}) {
            var M = {
              // "undefined" means "Choose whether to transform colors based on the image’s color model."
              colorTransform: void 0,
              useTArray: !1,
              formatAsRGBA: !0,
              tolerantDecoding: !0,
              maxResolutionInMP: 100,
              // Don't decode more than 100 megapixels
              maxMemoryUsageInMB: 512
              // Don't decode if memory footprint is more than 512MB
            }, E = { ...M, ...P }, x = new Uint8Array(H), m = new r();
            m.opts = E, r.resetMaxMemoryUsage(E.maxMemoryUsageInMB * 1024 * 1024), m.parse(x);
            var I = E.formatAsRGBA ? 4 : 3, z = m.width * m.height * I;
            try {
              r.requestMemoryAllocation(z);
              var w = {
                width: m.width,
                height: m.height,
                exifBuffer: m.exifBuffer,
                data: E.useTArray ? new Uint8Array(z) : new Q(z)
              };
            } catch (C) {
              throw C instanceof RangeError ? new Error("Could not allocate enough memory for the image. Required: " + z) : C;
            }
            return m.copyToImageData(w, E.formatAsRGBA), w;
          }
        }).call(this, te("buffer").Buffer);
      }, { buffer: 48 }], 82: [function(te, Ee, $) {
        (function(Q) {
          function r(H) {
            var P = Math.floor, M = new Array(64), E = new Array(64), x = new Array(64), m = new Array(64), I, z, w, C, b = new Array(65535), B = new Array(65535), N = new Array(64), U = new Array(64), V = [], W = 0, q = 7, Y = new Array(64), re = new Array(64), se = new Array(64), ve = new Array(256), ce = new Array(2048), be, Me = [
              0,
              1,
              5,
              6,
              14,
              15,
              27,
              28,
              2,
              4,
              7,
              13,
              16,
              26,
              29,
              42,
              3,
              8,
              12,
              17,
              25,
              30,
              41,
              43,
              9,
              11,
              18,
              24,
              31,
              40,
              44,
              53,
              10,
              19,
              23,
              32,
              39,
              45,
              52,
              54,
              20,
              22,
              33,
              38,
              46,
              51,
              55,
              60,
              21,
              34,
              37,
              47,
              50,
              56,
              59,
              61,
              35,
              36,
              48,
              49,
              57,
              58,
              62,
              63
            ], xe = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], le = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], de = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], De = [
              1,
              2,
              3,
              0,
              4,
              17,
              5,
              18,
              33,
              49,
              65,
              6,
              19,
              81,
              97,
              7,
              34,
              113,
              20,
              50,
              129,
              145,
              161,
              8,
              35,
              66,
              177,
              193,
              21,
              82,
              209,
              240,
              36,
              51,
              98,
              114,
              130,
              9,
              10,
              22,
              23,
              24,
              25,
              26,
              37,
              38,
              39,
              40,
              41,
              42,
              52,
              53,
              54,
              55,
              56,
              57,
              58,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              90,
              99,
              100,
              101,
              102,
              103,
              104,
              105,
              106,
              115,
              116,
              117,
              118,
              119,
              120,
              121,
              122,
              131,
              132,
              133,
              134,
              135,
              136,
              137,
              138,
              146,
              147,
              148,
              149,
              150,
              151,
              152,
              153,
              154,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              178,
              179,
              180,
              181,
              182,
              183,
              184,
              185,
              186,
              194,
              195,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              210,
              211,
              212,
              213,
              214,
              215,
              216,
              217,
              218,
              225,
              226,
              227,
              228,
              229,
              230,
              231,
              232,
              233,
              234,
              241,
              242,
              243,
              244,
              245,
              246,
              247,
              248,
              249,
              250
            ], ze = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], Ze = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Ue = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], Ie = [
              0,
              1,
              2,
              3,
              17,
              4,
              5,
              33,
              49,
              6,
              18,
              65,
              81,
              7,
              97,
              113,
              19,
              34,
              50,
              129,
              8,
              20,
              66,
              145,
              161,
              177,
              193,
              9,
              35,
              51,
              82,
              240,
              21,
              98,
              114,
              209,
              10,
              22,
              36,
              52,
              225,
              37,
              241,
              23,
              24,
              25,
              26,
              38,
              39,
              40,
              41,
              42,
              53,
              54,
              55,
              56,
              57,
              58,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              90,
              99,
              100,
              101,
              102,
              103,
              104,
              105,
              106,
              115,
              116,
              117,
              118,
              119,
              120,
              121,
              122,
              130,
              131,
              132,
              133,
              134,
              135,
              136,
              137,
              138,
              146,
              147,
              148,
              149,
              150,
              151,
              152,
              153,
              154,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              178,
              179,
              180,
              181,
              182,
              183,
              184,
              185,
              186,
              194,
              195,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              210,
              211,
              212,
              213,
              214,
              215,
              216,
              217,
              218,
              226,
              227,
              228,
              229,
              230,
              231,
              232,
              233,
              234,
              242,
              243,
              244,
              245,
              246,
              247,
              248,
              249,
              250
            ];
            function je(ie) {
              for (var Xe = [
                16,
                11,
                10,
                16,
                24,
                40,
                51,
                61,
                12,
                12,
                14,
                19,
                26,
                58,
                60,
                55,
                14,
                13,
                16,
                24,
                40,
                57,
                69,
                56,
                14,
                17,
                22,
                29,
                51,
                87,
                80,
                62,
                18,
                22,
                37,
                56,
                68,
                109,
                103,
                77,
                24,
                35,
                55,
                64,
                81,
                104,
                113,
                92,
                49,
                64,
                78,
                87,
                103,
                121,
                120,
                101,
                72,
                92,
                95,
                98,
                112,
                100,
                103,
                99
              ], bt = 0; bt < 64; bt++) {
                var Wt = P((Xe[bt] * ie + 50) / 100);
                Wt < 1 ? Wt = 1 : Wt > 255 && (Wt = 255), M[Me[bt]] = Wt;
              }
              for (var Qt = [
                17,
                18,
                24,
                47,
                99,
                99,
                99,
                99,
                18,
                21,
                26,
                66,
                99,
                99,
                99,
                99,
                24,
                26,
                56,
                99,
                99,
                99,
                99,
                99,
                47,
                66,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99
              ], Sr = 0; Sr < 64; Sr++) {
                var Fr = P((Qt[Sr] * ie + 50) / 100);
                Fr < 1 ? Fr = 1 : Fr > 255 && (Fr = 255), E[Me[Sr]] = Fr;
              }
              for (var kr = [
                1,
                1.387039845,
                1.306562965,
                1.175875602,
                1,
                0.785694958,
                0.5411961,
                0.275899379
              ], Ur = 0, Rr = 0; Rr < 8; Rr++)
                for (var Pr = 0; Pr < 8; Pr++)
                  x[Ur] = 1 / (M[Me[Ur]] * kr[Rr] * kr[Pr] * 8), m[Ur] = 1 / (E[Me[Ur]] * kr[Rr] * kr[Pr] * 8), Ur++;
            }
            function Fe(ie, Xe) {
              for (var bt = 0, Wt = 0, Qt = new Array(), Sr = 1; Sr <= 16; Sr++) {
                for (var Fr = 1; Fr <= ie[Sr]; Fr++)
                  Qt[Xe[Wt]] = [], Qt[Xe[Wt]][0] = bt, Qt[Xe[Wt]][1] = Sr, Wt++, bt++;
                bt *= 2;
              }
              return Qt;
            }
            function $e() {
              I = Fe(xe, le), z = Fe(ze, Ze), w = Fe(de, De), C = Fe(Ue, Ie);
            }
            function ct() {
              for (var ie = 1, Xe = 2, bt = 1; bt <= 15; bt++) {
                for (var Wt = ie; Wt < Xe; Wt++)
                  B[32767 + Wt] = bt, b[32767 + Wt] = [], b[32767 + Wt][1] = bt, b[32767 + Wt][0] = Wt;
                for (var Qt = -(Xe - 1); Qt <= -ie; Qt++)
                  B[32767 + Qt] = bt, b[32767 + Qt] = [], b[32767 + Qt][1] = bt, b[32767 + Qt][0] = Xe - 1 + Qt;
                ie <<= 1, Xe <<= 1;
              }
            }
            function wt() {
              for (var ie = 0; ie < 256; ie++)
                ce[ie] = 19595 * ie, ce[ie + 256 >> 0] = 38470 * ie, ce[ie + 512 >> 0] = 7471 * ie + 32768, ce[ie + 768 >> 0] = -11059 * ie, ce[ie + 1024 >> 0] = -21709 * ie, ce[ie + 1280 >> 0] = 32768 * ie + 8421375, ce[ie + 1536 >> 0] = -27439 * ie, ce[ie + 1792 >> 0] = -5329 * ie;
            }
            function Oe(ie) {
              for (var Xe = ie[0], bt = ie[1] - 1; bt >= 0; )
                Xe & 1 << bt && (W |= 1 << q), bt--, q--, q < 0 && (W == 255 ? (Ct(255), Ct(0)) : Ct(W), q = 7, W = 0);
            }
            function Ct(ie) {
              V.push(ie);
            }
            function Xt(ie) {
              Ct(ie >> 8 & 255), Ct(ie & 255);
            }
            function vt(ie, Xe) {
              var bt, Wt, Qt, Sr, Fr, kr, Ur, Rr, Pr = 0, hi, Vr = 8, Te = 64;
              for (hi = 0; hi < Vr; ++hi) {
                bt = ie[Pr], Wt = ie[Pr + 1], Qt = ie[Pr + 2], Sr = ie[Pr + 3], Fr = ie[Pr + 4], kr = ie[Pr + 5], Ur = ie[Pr + 6], Rr = ie[Pr + 7];
                var Tt = bt + Rr, Gt = bt - Rr, pr = Wt + Ur, kt = Wt - Ur, tr = Qt + kr, Je = Qt - kr, wr = Sr + Fr, ni = Sr - Fr, Z = Tt + wr, Dt = Tt - wr, er = pr + tr, we = pr - tr;
                ie[Pr] = Z + er, ie[Pr + 4] = Z - er;
                var yt = (we + Dt) * 0.707106781;
                ie[Pr + 2] = Dt + yt, ie[Pr + 6] = Dt - yt, Z = ni + Je, er = Je + kt, we = kt + Gt;
                var ar = (Z - we) * 0.382683433, Or = 0.5411961 * Z + ar, Dr = 1.306562965 * we + ar, Kr = er * 0.707106781, di = Gt + Kr, $t = Gt - Kr;
                ie[Pr + 5] = $t + Or, ie[Pr + 3] = $t - Or, ie[Pr + 1] = di + Dr, ie[Pr + 7] = di - Dr, Pr += 8;
              }
              for (Pr = 0, hi = 0; hi < Vr; ++hi) {
                bt = ie[Pr], Wt = ie[Pr + 8], Qt = ie[Pr + 16], Sr = ie[Pr + 24], Fr = ie[Pr + 32], kr = ie[Pr + 40], Ur = ie[Pr + 48], Rr = ie[Pr + 56];
                var Ce = bt + Rr, Ne = bt - Rr, Ke = Wt + Ur, ht = Wt - Ur, ft = Qt + kr, Pt = Qt - kr, Nt = Sr + Fr, At = Sr - Fr, Zt = Ce + Nt, jt = Ce - Nt, Yt = Ke + ft, fr = Ke - ft;
                ie[Pr] = Zt + Yt, ie[Pr + 32] = Zt - Yt;
                var Ir = (fr + jt) * 0.707106781;
                ie[Pr + 16] = jt + Ir, ie[Pr + 48] = jt - Ir, Zt = At + Pt, Yt = Pt + ht, fr = ht + Ne;
                var Lr = (Zt - fr) * 0.382683433, qr = 0.5411961 * Zt + Lr, pi = 1.306562965 * fr + Lr, fi = Yt * 0.707106781, si = Ne + fi, ki = Ne - fi;
                ie[Pr + 40] = ki + qr, ie[Pr + 24] = ki - qr, ie[Pr + 8] = si + pi, ie[Pr + 56] = si - pi, Pr++;
              }
              var Ni;
              for (hi = 0; hi < Te; ++hi)
                Ni = ie[hi] * Xe[hi], N[hi] = Ni > 0 ? Ni + 0.5 | 0 : Ni - 0.5 | 0;
              return N;
            }
            function Ye() {
              Xt(65504), Xt(16), Ct(74), Ct(70), Ct(73), Ct(70), Ct(0), Ct(1), Ct(1), Ct(0), Xt(1), Xt(1), Ct(0), Ct(0);
            }
            function qe(ie) {
              if (ie) {
                Xt(65505), ie[0] === 69 && ie[1] === 120 && ie[2] === 105 && ie[3] === 102 ? Xt(ie.length + 2) : (Xt(ie.length + 5 + 2), Ct(69), Ct(120), Ct(105), Ct(102), Ct(0));
                for (var Xe = 0; Xe < ie.length; Xe++)
                  Ct(ie[Xe]);
              }
            }
            function rt(ie, Xe) {
              Xt(65472), Xt(17), Ct(8), Xt(Xe), Xt(ie), Ct(3), Ct(1), Ct(17), Ct(0), Ct(2), Ct(17), Ct(1), Ct(3), Ct(17), Ct(1);
            }
            function it() {
              Xt(65499), Xt(132), Ct(0);
              for (var ie = 0; ie < 64; ie++)
                Ct(M[ie]);
              Ct(1);
              for (var Xe = 0; Xe < 64; Xe++)
                Ct(E[Xe]);
            }
            function Ae() {
              Xt(65476), Xt(418), Ct(0);
              for (var ie = 0; ie < 16; ie++)
                Ct(xe[ie + 1]);
              for (var Xe = 0; Xe <= 11; Xe++)
                Ct(le[Xe]);
              Ct(16);
              for (var bt = 0; bt < 16; bt++)
                Ct(de[bt + 1]);
              for (var Wt = 0; Wt <= 161; Wt++)
                Ct(De[Wt]);
              Ct(1);
              for (var Qt = 0; Qt < 16; Qt++)
                Ct(ze[Qt + 1]);
              for (var Sr = 0; Sr <= 11; Sr++)
                Ct(Ze[Sr]);
              Ct(17);
              for (var Fr = 0; Fr < 16; Fr++)
                Ct(Ue[Fr + 1]);
              for (var kr = 0; kr <= 161; kr++)
                Ct(Ie[kr]);
            }
            function _e() {
              Xt(65498), Xt(12), Ct(3), Ct(1), Ct(0), Ct(2), Ct(17), Ct(3), Ct(17), Ct(0), Ct(63), Ct(0);
            }
            function fe(ie, Xe, bt, Wt, Qt) {
              for (var Sr = Qt[0], Fr = Qt[240], kr, Ur = 16, Rr = 63, Pr = 64, hi = vt(ie, Xe), Vr = 0; Vr < Pr; ++Vr)
                U[Me[Vr]] = hi[Vr];
              var Te = U[0] - bt;
              bt = U[0], Te == 0 ? Oe(Wt[0]) : (kr = 32767 + Te, Oe(Wt[B[kr]]), Oe(b[kr]));
              for (var Tt = 63; Tt > 0 && U[Tt] == 0; Tt--)
                ;
              if (Tt == 0)
                return Oe(Sr), bt;
              for (var Gt = 1, pr; Gt <= Tt; ) {
                for (var kt = Gt; U[Gt] == 0 && Gt <= Tt; ++Gt)
                  ;
                var tr = Gt - kt;
                if (tr >= Ur) {
                  pr = tr >> 4;
                  for (var Je = 1; Je <= pr; ++Je)
                    Oe(Fr);
                  tr = tr & 15;
                }
                kr = 32767 + U[Gt], Oe(Qt[(tr << 4) + B[kr]]), Oe(b[kr]), Gt++;
              }
              return Tt != Rr && Oe(Sr), bt;
            }
            function We() {
              for (var ie = String.fromCharCode, Xe = 0; Xe < 256; Xe++)
                ve[Xe] = ie(Xe);
            }
            this.encode = function(ie, Xe) {
              (/* @__PURE__ */ new Date()).getTime(), Xe && Pe(Xe), V = new Array(), W = 0, q = 7, Xt(65496), Ye(), qe(ie.exifBuffer), it(), rt(ie.width, ie.height), Ae(), _e();
              var bt = 0, Wt = 0, Qt = 0;
              W = 0, q = 7, this.encode.displayName = "_encode_";
              for (var Sr = ie.data, Fr = ie.width, kr = ie.height, Ur = Fr * 4, Rr, Pr = 0, hi, Vr, Te, Tt, Gt, pr, kt, tr; Pr < kr; ) {
                for (Rr = 0; Rr < Ur; ) {
                  for (Tt = Ur * Pr + Rr, Gt = Tt, pr = -1, kt = 0, tr = 0; tr < 64; tr++)
                    kt = tr >> 3, pr = (tr & 7) * 4, Gt = Tt + kt * Ur + pr, Pr + kt >= kr && (Gt -= Ur * (Pr + 1 + kt - kr)), Rr + pr >= Ur && (Gt -= Rr + pr - Ur + 4), hi = Sr[Gt++], Vr = Sr[Gt++], Te = Sr[Gt++], Y[tr] = (ce[hi] + ce[Vr + 256 >> 0] + ce[Te + 512 >> 0] >> 16) - 128, re[tr] = (ce[hi + 768 >> 0] + ce[Vr + 1024 >> 0] + ce[Te + 1280 >> 0] >> 16) - 128, se[tr] = (ce[hi + 1280 >> 0] + ce[Vr + 1536 >> 0] + ce[Te + 1792 >> 0] >> 16) - 128;
                  bt = fe(Y, x, bt, I, w), Wt = fe(re, m, Wt, z, C), Qt = fe(se, m, Qt, z, C), Rr += 32;
                }
                Pr += 8;
              }
              if (q >= 0) {
                var Je = [];
                Je[1] = q + 1, Je[0] = (1 << q + 1) - 1, Oe(Je);
              }
              return Xt(65497), typeof Ee > "u" ? new Uint8Array(V) : new Q(V);
            };
            function Pe(ie) {
              if (ie <= 0 && (ie = 1), ie > 100 && (ie = 100), be != ie) {
                var Xe = 0;
                ie < 50 ? Xe = Math.floor(5e3 / ie) : Xe = Math.floor(200 - ie * 2), je(Xe), be = ie;
              }
            }
            function he() {
              var ie = (/* @__PURE__ */ new Date()).getTime();
              H || (H = 50), We(), $e(), ct(), wt(), Pe(H), (/* @__PURE__ */ new Date()).getTime() - ie;
            }
            he();
          }
          typeof Ee < "u" ? Ee.exports = F : typeof pt < "u" && (pt["jpeg-js"] = pt["jpeg-js"] || {}, pt["jpeg-js"].encode = F);
          function F(H, P) {
            typeof P > "u" && (P = 50);
            var M = new r(P), E = M.encode(H, P);
            return {
              data: E,
              width: H.width,
              height: H.height
            };
          }
        }).call(this, te("buffer").Buffer);
      }, { buffer: 48 }], 83: [function(te, Ee, $) {
        (function(Q) {
          var r = te("path"), F = te("fs"), H = parseInt("0777", 8);
          Ee.exports = P.mkdirp = P.mkdirP = P;
          function P(M, E, x, m) {
            typeof E == "function" ? (x = E, E = {}) : (!E || typeof E != "object") && (E = { mode: E });
            var I = E.mode, z = E.fs || F;
            I === void 0 && (I = H & ~Q.umask()), m || (m = null);
            var w = x || function() {
            };
            M = r.resolve(M), z.mkdir(M, I, function(C) {
              if (!C)
                return m = m || M, w(null, m);
              switch (C.code) {
                case "ENOENT":
                  P(r.dirname(M), E, function(b, B) {
                    b ? w(b, B) : P(M, E, w, B);
                  });
                  break;
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                  z.stat(M, function(b, B) {
                    b || !B.isDirectory() ? w(C, m) : w(null, m);
                  });
                  break;
              }
            });
          }
          P.sync = function M(E, x, m) {
            (!x || typeof x != "object") && (x = { mode: x });
            var I = x.mode, z = x.fs || F;
            I === void 0 && (I = H & ~Q.umask()), m || (m = null), E = r.resolve(E);
            try {
              z.mkdirSync(E, I), m = m || E;
            } catch (C) {
              switch (C.code) {
                case "ENOENT":
                  m = M(r.dirname(E), x, m), M(E, x, m);
                  break;
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                  var w;
                  try {
                    w = z.statSync(E);
                  } catch {
                    throw C;
                  }
                  if (!w.isDirectory()) throw C;
                  break;
              }
            }
            return m;
          };
        }).call(this, te("_process"));
      }, { _process: 133, fs: 47, path: 107 }], 84: [function(te, Ee, $) {
        var Q = Object.getOwnPropertySymbols, r = Object.prototype.hasOwnProperty, F = Object.prototype.propertyIsEnumerable;
        function H(M) {
          if (M == null)
            throw new TypeError("Object.assign cannot be called with null or undefined");
          return Object(M);
        }
        function P() {
          try {
            if (!Object.assign)
              return !1;
            var M = new String("abc");
            if (M[5] = "de", Object.getOwnPropertyNames(M)[0] === "5")
              return !1;
            for (var E = {}, x = 0; x < 10; x++)
              E["_" + String.fromCharCode(x)] = x;
            var m = Object.getOwnPropertyNames(E).map(function(z) {
              return E[z];
            });
            if (m.join("") !== "0123456789")
              return !1;
            var I = {};
            return "abcdefghijklmnopqrst".split("").forEach(function(z) {
              I[z] = z;
            }), Object.keys(Object.assign({}, I)).join("") === "abcdefghijklmnopqrst";
          } catch {
            return !1;
          }
        }
        Ee.exports = P() ? Object.assign : function(M, E) {
          for (var x, m = H(M), I, z = 1; z < arguments.length; z++) {
            x = Object(arguments[z]);
            for (var w in x)
              r.call(x, w) && (m[w] = x[w]);
            if (Q) {
              I = Q(x);
              for (var C = 0; C < I.length; C++)
                F.call(x, I[C]) && (m[I[C]] = x[I[C]]);
            }
          }
          return m;
        };
      }, {}], 85: [function(te, Ee, $) {
        arguments[4][64][0].apply($, arguments);
      }, { dup: 64 }], 86: [function(te, Ee, $) {
        var Q = te("./lib/utils/common").assign, r = te("./lib/deflate"), F = te("./lib/inflate"), H = te("./lib/zlib/constants"), P = {};
        Q(P, r, F, H), Ee.exports = P;
      }, { "./lib/deflate": 87, "./lib/inflate": 88, "./lib/utils/common": 89, "./lib/zlib/constants": 92 }], 87: [function(te, Ee, $) {
        var Q = te("./zlib/deflate"), r = te("./utils/common"), F = te("./utils/strings"), H = te("./zlib/messages"), P = te("./zlib/zstream"), M = Object.prototype.toString, E = 0, x = 4, m = 0, I = 1, z = 2, w = -1, C = 0, b = 8;
        function B(W) {
          if (!(this instanceof B)) return new B(W);
          this.options = r.assign({
            level: w,
            method: b,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: C,
            to: ""
          }, W || {});
          var q = this.options;
          q.raw && q.windowBits > 0 ? q.windowBits = -q.windowBits : q.gzip && q.windowBits > 0 && q.windowBits < 16 && (q.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new P(), this.strm.avail_out = 0;
          var Y = Q.deflateInit2(
            this.strm,
            q.level,
            q.method,
            q.windowBits,
            q.memLevel,
            q.strategy
          );
          if (Y !== m)
            throw new Error(H[Y]);
          if (q.header && Q.deflateSetHeader(this.strm, q.header), q.dictionary) {
            var re;
            if (typeof q.dictionary == "string" ? re = F.string2buf(q.dictionary) : M.call(q.dictionary) === "[object ArrayBuffer]" ? re = new Uint8Array(q.dictionary) : re = q.dictionary, Y = Q.deflateSetDictionary(this.strm, re), Y !== m)
              throw new Error(H[Y]);
            this._dict_set = !0;
          }
        }
        B.prototype.push = function(W, q) {
          var Y = this.strm, re = this.options.chunkSize, se, ve;
          if (this.ended)
            return !1;
          ve = q === ~~q ? q : q === !0 ? x : E, typeof W == "string" ? Y.input = F.string2buf(W) : M.call(W) === "[object ArrayBuffer]" ? Y.input = new Uint8Array(W) : Y.input = W, Y.next_in = 0, Y.avail_in = Y.input.length;
          do {
            if (Y.avail_out === 0 && (Y.output = new r.Buf8(re), Y.next_out = 0, Y.avail_out = re), se = Q.deflate(Y, ve), se !== I && se !== m)
              return this.onEnd(se), this.ended = !0, !1;
            (Y.avail_out === 0 || Y.avail_in === 0 && (ve === x || ve === z)) && (this.options.to === "string" ? this.onData(F.buf2binstring(r.shrinkBuf(Y.output, Y.next_out))) : this.onData(r.shrinkBuf(Y.output, Y.next_out)));
          } while ((Y.avail_in > 0 || Y.avail_out === 0) && se !== I);
          return ve === x ? (se = Q.deflateEnd(this.strm), this.onEnd(se), this.ended = !0, se === m) : (ve === z && (this.onEnd(m), Y.avail_out = 0), !0);
        }, B.prototype.onData = function(W) {
          this.chunks.push(W);
        }, B.prototype.onEnd = function(W) {
          W === m && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = W, this.msg = this.strm.msg;
        };
        function N(W, q) {
          var Y = new B(q);
          if (Y.push(W, !0), Y.err)
            throw Y.msg || H[Y.err];
          return Y.result;
        }
        function U(W, q) {
          return q = q || {}, q.raw = !0, N(W, q);
        }
        function V(W, q) {
          return q = q || {}, q.gzip = !0, N(W, q);
        }
        $.Deflate = B, $.deflate = N, $.deflateRaw = U, $.gzip = V;
      }, { "./utils/common": 89, "./utils/strings": 90, "./zlib/deflate": 94, "./zlib/messages": 99, "./zlib/zstream": 101 }], 88: [function(te, Ee, $) {
        var Q = te("./zlib/inflate"), r = te("./utils/common"), F = te("./utils/strings"), H = te("./zlib/constants"), P = te("./zlib/messages"), M = te("./zlib/zstream"), E = te("./zlib/gzheader"), x = Object.prototype.toString;
        function m(w) {
          if (!(this instanceof m)) return new m(w);
          this.options = r.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, w || {});
          var C = this.options;
          C.raw && C.windowBits >= 0 && C.windowBits < 16 && (C.windowBits = -C.windowBits, C.windowBits === 0 && (C.windowBits = -15)), C.windowBits >= 0 && C.windowBits < 16 && !(w && w.windowBits) && (C.windowBits += 32), C.windowBits > 15 && C.windowBits < 48 && (C.windowBits & 15 || (C.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new M(), this.strm.avail_out = 0;
          var b = Q.inflateInit2(
            this.strm,
            C.windowBits
          );
          if (b !== H.Z_OK)
            throw new Error(P[b]);
          this.header = new E(), Q.inflateGetHeader(this.strm, this.header);
        }
        m.prototype.push = function(w, C) {
          var b = this.strm, B = this.options.chunkSize, N = this.options.dictionary, U, V, W, q, Y, re, se = !1;
          if (this.ended)
            return !1;
          V = C === ~~C ? C : C === !0 ? H.Z_FINISH : H.Z_NO_FLUSH, typeof w == "string" ? b.input = F.binstring2buf(w) : x.call(w) === "[object ArrayBuffer]" ? b.input = new Uint8Array(w) : b.input = w, b.next_in = 0, b.avail_in = b.input.length;
          do {
            if (b.avail_out === 0 && (b.output = new r.Buf8(B), b.next_out = 0, b.avail_out = B), U = Q.inflate(b, H.Z_NO_FLUSH), U === H.Z_NEED_DICT && N && (typeof N == "string" ? re = F.string2buf(N) : x.call(N) === "[object ArrayBuffer]" ? re = new Uint8Array(N) : re = N, U = Q.inflateSetDictionary(this.strm, re)), U === H.Z_BUF_ERROR && se === !0 && (U = H.Z_OK, se = !1), U !== H.Z_STREAM_END && U !== H.Z_OK)
              return this.onEnd(U), this.ended = !0, !1;
            b.next_out && (b.avail_out === 0 || U === H.Z_STREAM_END || b.avail_in === 0 && (V === H.Z_FINISH || V === H.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (W = F.utf8border(b.output, b.next_out), q = b.next_out - W, Y = F.buf2string(b.output, W), b.next_out = q, b.avail_out = B - q, q && r.arraySet(b.output, b.output, W, q, 0), this.onData(Y)) : this.onData(r.shrinkBuf(b.output, b.next_out))), b.avail_in === 0 && b.avail_out === 0 && (se = !0);
          } while ((b.avail_in > 0 || b.avail_out === 0) && U !== H.Z_STREAM_END);
          return U === H.Z_STREAM_END && (V = H.Z_FINISH), V === H.Z_FINISH ? (U = Q.inflateEnd(this.strm), this.onEnd(U), this.ended = !0, U === H.Z_OK) : (V === H.Z_SYNC_FLUSH && (this.onEnd(H.Z_OK), b.avail_out = 0), !0);
        }, m.prototype.onData = function(w) {
          this.chunks.push(w);
        }, m.prototype.onEnd = function(w) {
          w === H.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = r.flattenChunks(this.chunks)), this.chunks = [], this.err = w, this.msg = this.strm.msg;
        };
        function I(w, C) {
          var b = new m(C);
          if (b.push(w, !0), b.err)
            throw b.msg || P[b.err];
          return b.result;
        }
        function z(w, C) {
          return C = C || {}, C.raw = !0, I(w, C);
        }
        $.Inflate = m, $.inflate = I, $.inflateRaw = z, $.ungzip = I;
      }, { "./utils/common": 89, "./utils/strings": 90, "./zlib/constants": 92, "./zlib/gzheader": 95, "./zlib/inflate": 97, "./zlib/messages": 99, "./zlib/zstream": 101 }], 89: [function(te, Ee, $) {
        arguments[4][36][0].apply($, arguments);
      }, { dup: 36 }], 90: [function(te, Ee, $) {
        var Q = te("./common"), r = !0, F = !0;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch {
          r = !1;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          F = !1;
        }
        for (var H = new Q.Buf8(256), P = 0; P < 256; P++)
          H[P] = P >= 252 ? 6 : P >= 248 ? 5 : P >= 240 ? 4 : P >= 224 ? 3 : P >= 192 ? 2 : 1;
        H[254] = H[254] = 1, $.string2buf = function(E) {
          var x, m, I, z, w, C = E.length, b = 0;
          for (z = 0; z < C; z++)
            m = E.charCodeAt(z), (m & 64512) === 55296 && z + 1 < C && (I = E.charCodeAt(z + 1), (I & 64512) === 56320 && (m = 65536 + (m - 55296 << 10) + (I - 56320), z++)), b += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
          for (x = new Q.Buf8(b), w = 0, z = 0; w < b; z++)
            m = E.charCodeAt(z), (m & 64512) === 55296 && z + 1 < C && (I = E.charCodeAt(z + 1), (I & 64512) === 56320 && (m = 65536 + (m - 55296 << 10) + (I - 56320), z++)), m < 128 ? x[w++] = m : m < 2048 ? (x[w++] = 192 | m >>> 6, x[w++] = 128 | m & 63) : m < 65536 ? (x[w++] = 224 | m >>> 12, x[w++] = 128 | m >>> 6 & 63, x[w++] = 128 | m & 63) : (x[w++] = 240 | m >>> 18, x[w++] = 128 | m >>> 12 & 63, x[w++] = 128 | m >>> 6 & 63, x[w++] = 128 | m & 63);
          return x;
        };
        function M(E, x) {
          if (x < 65537 && (E.subarray && F || !E.subarray && r))
            return String.fromCharCode.apply(null, Q.shrinkBuf(E, x));
          for (var m = "", I = 0; I < x; I++)
            m += String.fromCharCode(E[I]);
          return m;
        }
        $.buf2binstring = function(E) {
          return M(E, E.length);
        }, $.binstring2buf = function(E) {
          for (var x = new Q.Buf8(E.length), m = 0, I = x.length; m < I; m++)
            x[m] = E.charCodeAt(m);
          return x;
        }, $.buf2string = function(E, x) {
          var m, I, z, w, C = x || E.length, b = new Array(C * 2);
          for (I = 0, m = 0; m < C; ) {
            if (z = E[m++], z < 128) {
              b[I++] = z;
              continue;
            }
            if (w = H[z], w > 4) {
              b[I++] = 65533, m += w - 1;
              continue;
            }
            for (z &= w === 2 ? 31 : w === 3 ? 15 : 7; w > 1 && m < C; )
              z = z << 6 | E[m++] & 63, w--;
            if (w > 1) {
              b[I++] = 65533;
              continue;
            }
            z < 65536 ? b[I++] = z : (z -= 65536, b[I++] = 55296 | z >> 10 & 1023, b[I++] = 56320 | z & 1023);
          }
          return M(b, I);
        }, $.utf8border = function(E, x) {
          var m;
          for (x = x || E.length, x > E.length && (x = E.length), m = x - 1; m >= 0 && (E[m] & 192) === 128; )
            m--;
          return m < 0 || m === 0 ? x : m + H[E[m]] > x ? m : x;
        };
      }, { "./common": 89 }], 91: [function(te, Ee, $) {
        arguments[4][37][0].apply($, arguments);
      }, { dup: 37 }], 92: [function(te, Ee, $) {
        arguments[4][38][0].apply($, arguments);
      }, { dup: 38 }], 93: [function(te, Ee, $) {
        arguments[4][39][0].apply($, arguments);
      }, { dup: 39 }], 94: [function(te, Ee, $) {
        var Q = te("../utils/common"), r = te("./trees"), F = te("./adler32"), H = te("./crc32"), P = te("./messages"), M = 0, E = 1, x = 3, m = 4, I = 5, z = 0, w = 1, C = -2, b = -3, B = -5, N = -1, U = 1, V = 2, W = 3, q = 4, Y = 0, re = 2, se = 8, ve = 9, ce = 15, be = 8, Me = 29, xe = 256, le = xe + 1 + Me, de = 30, De = 19, ze = 2 * le + 1, Ze = 15, Ue = 3, Ie = 258, je = Ie + Ue + 1, Fe = 32, $e = 42, ct = 69, wt = 73, Oe = 91, Ct = 103, Xt = 113, vt = 666, Ye = 1, qe = 2, rt = 3, it = 4, Ae = 3;
        function _e(Z, Dt) {
          return Z.msg = P[Dt], Dt;
        }
        function fe(Z) {
          return (Z << 1) - (Z > 4 ? 9 : 0);
        }
        function We(Z) {
          for (var Dt = Z.length; --Dt >= 0; )
            Z[Dt] = 0;
        }
        function Pe(Z) {
          var Dt = Z.state, er = Dt.pending;
          er > Z.avail_out && (er = Z.avail_out), er !== 0 && (Q.arraySet(Z.output, Dt.pending_buf, Dt.pending_out, er, Z.next_out), Z.next_out += er, Dt.pending_out += er, Z.total_out += er, Z.avail_out -= er, Dt.pending -= er, Dt.pending === 0 && (Dt.pending_out = 0));
        }
        function he(Z, Dt) {
          r._tr_flush_block(Z, Z.block_start >= 0 ? Z.block_start : -1, Z.strstart - Z.block_start, Dt), Z.block_start = Z.strstart, Pe(Z.strm);
        }
        function ie(Z, Dt) {
          Z.pending_buf[Z.pending++] = Dt;
        }
        function Xe(Z, Dt) {
          Z.pending_buf[Z.pending++] = Dt >>> 8 & 255, Z.pending_buf[Z.pending++] = Dt & 255;
        }
        function bt(Z, Dt, er, we) {
          var yt = Z.avail_in;
          return yt > we && (yt = we), yt === 0 ? 0 : (Z.avail_in -= yt, Q.arraySet(Dt, Z.input, Z.next_in, yt, er), Z.state.wrap === 1 ? Z.adler = F(Z.adler, Dt, yt, er) : Z.state.wrap === 2 && (Z.adler = H(Z.adler, Dt, yt, er)), Z.next_in += yt, Z.total_in += yt, yt);
        }
        function Wt(Z, Dt) {
          var er = Z.max_chain_length, we = Z.strstart, yt, ar, Or = Z.prev_length, Dr = Z.nice_match, Kr = Z.strstart > Z.w_size - je ? Z.strstart - (Z.w_size - je) : 0, di = Z.window, $t = Z.w_mask, Ce = Z.prev, Ne = Z.strstart + Ie, Ke = di[we + Or - 1], ht = di[we + Or];
          Z.prev_length >= Z.good_match && (er >>= 2), Dr > Z.lookahead && (Dr = Z.lookahead);
          do
            if (yt = Dt, !(di[yt + Or] !== ht || di[yt + Or - 1] !== Ke || di[yt] !== di[we] || di[++yt] !== di[we + 1])) {
              we += 2, yt++;
              do
                ;
              while (di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && di[++we] === di[++yt] && we < Ne);
              if (ar = Ie - (Ne - we), we = Ne - Ie, ar > Or) {
                if (Z.match_start = Dt, Or = ar, ar >= Dr)
                  break;
                Ke = di[we + Or - 1], ht = di[we + Or];
              }
            }
          while ((Dt = Ce[Dt & $t]) > Kr && --er !== 0);
          return Or <= Z.lookahead ? Or : Z.lookahead;
        }
        function Qt(Z) {
          var Dt = Z.w_size, er, we, yt, ar, Or;
          do {
            if (ar = Z.window_size - Z.lookahead - Z.strstart, Z.strstart >= Dt + (Dt - je)) {
              Q.arraySet(Z.window, Z.window, Dt, Dt, 0), Z.match_start -= Dt, Z.strstart -= Dt, Z.block_start -= Dt, we = Z.hash_size, er = we;
              do
                yt = Z.head[--er], Z.head[er] = yt >= Dt ? yt - Dt : 0;
              while (--we);
              we = Dt, er = we;
              do
                yt = Z.prev[--er], Z.prev[er] = yt >= Dt ? yt - Dt : 0;
              while (--we);
              ar += Dt;
            }
            if (Z.strm.avail_in === 0)
              break;
            if (we = bt(Z.strm, Z.window, Z.strstart + Z.lookahead, ar), Z.lookahead += we, Z.lookahead + Z.insert >= Ue)
              for (Or = Z.strstart - Z.insert, Z.ins_h = Z.window[Or], Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Or + 1]) & Z.hash_mask; Z.insert && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Or + Ue - 1]) & Z.hash_mask, Z.prev[Or & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Or, Or++, Z.insert--, !(Z.lookahead + Z.insert < Ue)); )
                ;
          } while (Z.lookahead < je && Z.strm.avail_in !== 0);
        }
        function Sr(Z, Dt) {
          var er = 65535;
          for (er > Z.pending_buf_size - 5 && (er = Z.pending_buf_size - 5); ; ) {
            if (Z.lookahead <= 1) {
              if (Qt(Z), Z.lookahead === 0 && Dt === M)
                return Ye;
              if (Z.lookahead === 0)
                break;
            }
            Z.strstart += Z.lookahead, Z.lookahead = 0;
            var we = Z.block_start + er;
            if ((Z.strstart === 0 || Z.strstart >= we) && (Z.lookahead = Z.strstart - we, Z.strstart = we, he(Z, !1), Z.strm.avail_out === 0) || Z.strstart - Z.block_start >= Z.w_size - je && (he(Z, !1), Z.strm.avail_out === 0))
              return Ye;
          }
          return Z.insert = 0, Dt === m ? (he(Z, !0), Z.strm.avail_out === 0 ? rt : it) : (Z.strstart > Z.block_start && (he(Z, !1), Z.strm.avail_out === 0), Ye);
        }
        function Fr(Z, Dt) {
          for (var er, we; ; ) {
            if (Z.lookahead < je) {
              if (Qt(Z), Z.lookahead < je && Dt === M)
                return Ye;
              if (Z.lookahead === 0)
                break;
            }
            if (er = 0, Z.lookahead >= Ue && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + Ue - 1]) & Z.hash_mask, er = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart), er !== 0 && Z.strstart - er <= Z.w_size - je && (Z.match_length = Wt(Z, er)), Z.match_length >= Ue)
              if (we = r._tr_tally(Z, Z.strstart - Z.match_start, Z.match_length - Ue), Z.lookahead -= Z.match_length, Z.match_length <= Z.max_lazy_match && Z.lookahead >= Ue) {
                Z.match_length--;
                do
                  Z.strstart++, Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + Ue - 1]) & Z.hash_mask, er = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart;
                while (--Z.match_length !== 0);
                Z.strstart++;
              } else
                Z.strstart += Z.match_length, Z.match_length = 0, Z.ins_h = Z.window[Z.strstart], Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + 1]) & Z.hash_mask;
            else
              we = r._tr_tally(Z, 0, Z.window[Z.strstart]), Z.lookahead--, Z.strstart++;
            if (we && (he(Z, !1), Z.strm.avail_out === 0))
              return Ye;
          }
          return Z.insert = Z.strstart < Ue - 1 ? Z.strstart : Ue - 1, Dt === m ? (he(Z, !0), Z.strm.avail_out === 0 ? rt : it) : Z.last_lit && (he(Z, !1), Z.strm.avail_out === 0) ? Ye : qe;
        }
        function kr(Z, Dt) {
          for (var er, we, yt; ; ) {
            if (Z.lookahead < je) {
              if (Qt(Z), Z.lookahead < je && Dt === M)
                return Ye;
              if (Z.lookahead === 0)
                break;
            }
            if (er = 0, Z.lookahead >= Ue && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + Ue - 1]) & Z.hash_mask, er = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart), Z.prev_length = Z.match_length, Z.prev_match = Z.match_start, Z.match_length = Ue - 1, er !== 0 && Z.prev_length < Z.max_lazy_match && Z.strstart - er <= Z.w_size - je && (Z.match_length = Wt(Z, er), Z.match_length <= 5 && (Z.strategy === U || Z.match_length === Ue && Z.strstart - Z.match_start > 4096) && (Z.match_length = Ue - 1)), Z.prev_length >= Ue && Z.match_length <= Z.prev_length) {
              yt = Z.strstart + Z.lookahead - Ue, we = r._tr_tally(Z, Z.strstart - 1 - Z.prev_match, Z.prev_length - Ue), Z.lookahead -= Z.prev_length - 1, Z.prev_length -= 2;
              do
                ++Z.strstart <= yt && (Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[Z.strstart + Ue - 1]) & Z.hash_mask, er = Z.prev[Z.strstart & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = Z.strstart);
              while (--Z.prev_length !== 0);
              if (Z.match_available = 0, Z.match_length = Ue - 1, Z.strstart++, we && (he(Z, !1), Z.strm.avail_out === 0))
                return Ye;
            } else if (Z.match_available) {
              if (we = r._tr_tally(Z, 0, Z.window[Z.strstart - 1]), we && he(Z, !1), Z.strstart++, Z.lookahead--, Z.strm.avail_out === 0)
                return Ye;
            } else
              Z.match_available = 1, Z.strstart++, Z.lookahead--;
          }
          return Z.match_available && (we = r._tr_tally(Z, 0, Z.window[Z.strstart - 1]), Z.match_available = 0), Z.insert = Z.strstart < Ue - 1 ? Z.strstart : Ue - 1, Dt === m ? (he(Z, !0), Z.strm.avail_out === 0 ? rt : it) : Z.last_lit && (he(Z, !1), Z.strm.avail_out === 0) ? Ye : qe;
        }
        function Ur(Z, Dt) {
          for (var er, we, yt, ar, Or = Z.window; ; ) {
            if (Z.lookahead <= Ie) {
              if (Qt(Z), Z.lookahead <= Ie && Dt === M)
                return Ye;
              if (Z.lookahead === 0)
                break;
            }
            if (Z.match_length = 0, Z.lookahead >= Ue && Z.strstart > 0 && (yt = Z.strstart - 1, we = Or[yt], we === Or[++yt] && we === Or[++yt] && we === Or[++yt])) {
              ar = Z.strstart + Ie;
              do
                ;
              while (we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && we === Or[++yt] && yt < ar);
              Z.match_length = Ie - (ar - yt), Z.match_length > Z.lookahead && (Z.match_length = Z.lookahead);
            }
            if (Z.match_length >= Ue ? (er = r._tr_tally(Z, 1, Z.match_length - Ue), Z.lookahead -= Z.match_length, Z.strstart += Z.match_length, Z.match_length = 0) : (er = r._tr_tally(Z, 0, Z.window[Z.strstart]), Z.lookahead--, Z.strstart++), er && (he(Z, !1), Z.strm.avail_out === 0))
              return Ye;
          }
          return Z.insert = 0, Dt === m ? (he(Z, !0), Z.strm.avail_out === 0 ? rt : it) : Z.last_lit && (he(Z, !1), Z.strm.avail_out === 0) ? Ye : qe;
        }
        function Rr(Z, Dt) {
          for (var er; ; ) {
            if (Z.lookahead === 0 && (Qt(Z), Z.lookahead === 0)) {
              if (Dt === M)
                return Ye;
              break;
            }
            if (Z.match_length = 0, er = r._tr_tally(Z, 0, Z.window[Z.strstart]), Z.lookahead--, Z.strstart++, er && (he(Z, !1), Z.strm.avail_out === 0))
              return Ye;
          }
          return Z.insert = 0, Dt === m ? (he(Z, !0), Z.strm.avail_out === 0 ? rt : it) : Z.last_lit && (he(Z, !1), Z.strm.avail_out === 0) ? Ye : qe;
        }
        function Pr(Z, Dt, er, we, yt) {
          this.good_length = Z, this.max_lazy = Dt, this.nice_length = er, this.max_chain = we, this.func = yt;
        }
        var hi;
        hi = [
          /*      good lazy nice chain */
          new Pr(0, 0, 0, 0, Sr),
          /* 0 store only */
          new Pr(4, 4, 8, 4, Fr),
          /* 1 max speed, no lazy matches */
          new Pr(4, 5, 16, 8, Fr),
          /* 2 */
          new Pr(4, 6, 32, 32, Fr),
          /* 3 */
          new Pr(4, 4, 16, 16, kr),
          /* 4 lazy matches */
          new Pr(8, 16, 32, 32, kr),
          /* 5 */
          new Pr(8, 16, 128, 128, kr),
          /* 6 */
          new Pr(8, 32, 128, 256, kr),
          /* 7 */
          new Pr(32, 128, 258, 1024, kr),
          /* 8 */
          new Pr(32, 258, 258, 4096, kr)
          /* 9 max compression */
        ];
        function Vr(Z) {
          Z.window_size = 2 * Z.w_size, We(Z.head), Z.max_lazy_match = hi[Z.level].max_lazy, Z.good_match = hi[Z.level].good_length, Z.nice_match = hi[Z.level].nice_length, Z.max_chain_length = hi[Z.level].max_chain, Z.strstart = 0, Z.block_start = 0, Z.lookahead = 0, Z.insert = 0, Z.match_length = Z.prev_length = Ue - 1, Z.match_available = 0, Z.ins_h = 0;
        }
        function Te() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = se, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Q.Buf16(ze * 2), this.dyn_dtree = new Q.Buf16((2 * de + 1) * 2), this.bl_tree = new Q.Buf16((2 * De + 1) * 2), We(this.dyn_ltree), We(this.dyn_dtree), We(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Q.Buf16(Ze + 1), this.heap = new Q.Buf16(2 * le + 1), We(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Q.Buf16(2 * le + 1), We(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function Tt(Z) {
          var Dt;
          return !Z || !Z.state ? _e(Z, C) : (Z.total_in = Z.total_out = 0, Z.data_type = re, Dt = Z.state, Dt.pending = 0, Dt.pending_out = 0, Dt.wrap < 0 && (Dt.wrap = -Dt.wrap), Dt.status = Dt.wrap ? $e : Xt, Z.adler = Dt.wrap === 2 ? 0 : 1, Dt.last_flush = M, r._tr_init(Dt), z);
        }
        function Gt(Z) {
          var Dt = Tt(Z);
          return Dt === z && Vr(Z.state), Dt;
        }
        function pr(Z, Dt) {
          return !Z || !Z.state || Z.state.wrap !== 2 ? C : (Z.state.gzhead = Dt, z);
        }
        function kt(Z, Dt, er, we, yt, ar) {
          if (!Z)
            return C;
          var Or = 1;
          if (Dt === N && (Dt = 6), we < 0 ? (Or = 0, we = -we) : we > 15 && (Or = 2, we -= 16), yt < 1 || yt > ve || er !== se || we < 8 || we > 15 || Dt < 0 || Dt > 9 || ar < 0 || ar > q)
            return _e(Z, C);
          we === 8 && (we = 9);
          var Dr = new Te();
          return Z.state = Dr, Dr.strm = Z, Dr.wrap = Or, Dr.gzhead = null, Dr.w_bits = we, Dr.w_size = 1 << Dr.w_bits, Dr.w_mask = Dr.w_size - 1, Dr.hash_bits = yt + 7, Dr.hash_size = 1 << Dr.hash_bits, Dr.hash_mask = Dr.hash_size - 1, Dr.hash_shift = ~~((Dr.hash_bits + Ue - 1) / Ue), Dr.window = new Q.Buf8(Dr.w_size * 2), Dr.head = new Q.Buf16(Dr.hash_size), Dr.prev = new Q.Buf16(Dr.w_size), Dr.lit_bufsize = 1 << yt + 6, Dr.pending_buf_size = Dr.lit_bufsize * 4, Dr.pending_buf = new Q.Buf8(Dr.pending_buf_size), Dr.d_buf = 1 * Dr.lit_bufsize, Dr.l_buf = 3 * Dr.lit_bufsize, Dr.level = Dt, Dr.strategy = ar, Dr.method = er, Gt(Z);
        }
        function tr(Z, Dt) {
          return kt(Z, Dt, se, ce, be, Y);
        }
        function Je(Z, Dt) {
          var er, we, yt, ar;
          if (!Z || !Z.state || Dt > I || Dt < 0)
            return Z ? _e(Z, C) : C;
          if (we = Z.state, !Z.output || !Z.input && Z.avail_in !== 0 || we.status === vt && Dt !== m)
            return _e(Z, Z.avail_out === 0 ? B : C);
          if (we.strm = Z, er = we.last_flush, we.last_flush = Dt, we.status === $e)
            if (we.wrap === 2)
              Z.adler = 0, ie(we, 31), ie(we, 139), ie(we, 8), we.gzhead ? (ie(
                we,
                (we.gzhead.text ? 1 : 0) + (we.gzhead.hcrc ? 2 : 0) + (we.gzhead.extra ? 4 : 0) + (we.gzhead.name ? 8 : 0) + (we.gzhead.comment ? 16 : 0)
              ), ie(we, we.gzhead.time & 255), ie(we, we.gzhead.time >> 8 & 255), ie(we, we.gzhead.time >> 16 & 255), ie(we, we.gzhead.time >> 24 & 255), ie(we, we.level === 9 ? 2 : we.strategy >= V || we.level < 2 ? 4 : 0), ie(we, we.gzhead.os & 255), we.gzhead.extra && we.gzhead.extra.length && (ie(we, we.gzhead.extra.length & 255), ie(we, we.gzhead.extra.length >> 8 & 255)), we.gzhead.hcrc && (Z.adler = H(Z.adler, we.pending_buf, we.pending, 0)), we.gzindex = 0, we.status = ct) : (ie(we, 0), ie(we, 0), ie(we, 0), ie(we, 0), ie(we, 0), ie(we, we.level === 9 ? 2 : we.strategy >= V || we.level < 2 ? 4 : 0), ie(we, Ae), we.status = Xt);
            else {
              var Or = se + (we.w_bits - 8 << 4) << 8, Dr = -1;
              we.strategy >= V || we.level < 2 ? Dr = 0 : we.level < 6 ? Dr = 1 : we.level === 6 ? Dr = 2 : Dr = 3, Or |= Dr << 6, we.strstart !== 0 && (Or |= Fe), Or += 31 - Or % 31, we.status = Xt, Xe(we, Or), we.strstart !== 0 && (Xe(we, Z.adler >>> 16), Xe(we, Z.adler & 65535)), Z.adler = 1;
            }
          if (we.status === ct)
            if (we.gzhead.extra) {
              for (yt = we.pending; we.gzindex < (we.gzhead.extra.length & 65535) && !(we.pending === we.pending_buf_size && (we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), Pe(Z), yt = we.pending, we.pending === we.pending_buf_size)); )
                ie(we, we.gzhead.extra[we.gzindex] & 255), we.gzindex++;
              we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), we.gzindex === we.gzhead.extra.length && (we.gzindex = 0, we.status = wt);
            } else
              we.status = wt;
          if (we.status === wt)
            if (we.gzhead.name) {
              yt = we.pending;
              do {
                if (we.pending === we.pending_buf_size && (we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), Pe(Z), yt = we.pending, we.pending === we.pending_buf_size)) {
                  ar = 1;
                  break;
                }
                we.gzindex < we.gzhead.name.length ? ar = we.gzhead.name.charCodeAt(we.gzindex++) & 255 : ar = 0, ie(we, ar);
              } while (ar !== 0);
              we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), ar === 0 && (we.gzindex = 0, we.status = Oe);
            } else
              we.status = Oe;
          if (we.status === Oe)
            if (we.gzhead.comment) {
              yt = we.pending;
              do {
                if (we.pending === we.pending_buf_size && (we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), Pe(Z), yt = we.pending, we.pending === we.pending_buf_size)) {
                  ar = 1;
                  break;
                }
                we.gzindex < we.gzhead.comment.length ? ar = we.gzhead.comment.charCodeAt(we.gzindex++) & 255 : ar = 0, ie(we, ar);
              } while (ar !== 0);
              we.gzhead.hcrc && we.pending > yt && (Z.adler = H(Z.adler, we.pending_buf, we.pending - yt, yt)), ar === 0 && (we.status = Ct);
            } else
              we.status = Ct;
          if (we.status === Ct && (we.gzhead.hcrc ? (we.pending + 2 > we.pending_buf_size && Pe(Z), we.pending + 2 <= we.pending_buf_size && (ie(we, Z.adler & 255), ie(we, Z.adler >> 8 & 255), Z.adler = 0, we.status = Xt)) : we.status = Xt), we.pending !== 0) {
            if (Pe(Z), Z.avail_out === 0)
              return we.last_flush = -1, z;
          } else if (Z.avail_in === 0 && fe(Dt) <= fe(er) && Dt !== m)
            return _e(Z, B);
          if (we.status === vt && Z.avail_in !== 0)
            return _e(Z, B);
          if (Z.avail_in !== 0 || we.lookahead !== 0 || Dt !== M && we.status !== vt) {
            var Kr = we.strategy === V ? Rr(we, Dt) : we.strategy === W ? Ur(we, Dt) : hi[we.level].func(we, Dt);
            if ((Kr === rt || Kr === it) && (we.status = vt), Kr === Ye || Kr === rt)
              return Z.avail_out === 0 && (we.last_flush = -1), z;
            if (Kr === qe && (Dt === E ? r._tr_align(we) : Dt !== I && (r._tr_stored_block(we, 0, 0, !1), Dt === x && (We(we.head), we.lookahead === 0 && (we.strstart = 0, we.block_start = 0, we.insert = 0))), Pe(Z), Z.avail_out === 0))
              return we.last_flush = -1, z;
          }
          return Dt !== m ? z : we.wrap <= 0 ? w : (we.wrap === 2 ? (ie(we, Z.adler & 255), ie(we, Z.adler >> 8 & 255), ie(we, Z.adler >> 16 & 255), ie(we, Z.adler >> 24 & 255), ie(we, Z.total_in & 255), ie(we, Z.total_in >> 8 & 255), ie(we, Z.total_in >> 16 & 255), ie(we, Z.total_in >> 24 & 255)) : (Xe(we, Z.adler >>> 16), Xe(we, Z.adler & 65535)), Pe(Z), we.wrap > 0 && (we.wrap = -we.wrap), we.pending !== 0 ? z : w);
        }
        function wr(Z) {
          var Dt;
          return !Z || !Z.state ? C : (Dt = Z.state.status, Dt !== $e && Dt !== ct && Dt !== wt && Dt !== Oe && Dt !== Ct && Dt !== Xt && Dt !== vt ? _e(Z, C) : (Z.state = null, Dt === Xt ? _e(Z, b) : z));
        }
        function ni(Z, Dt) {
          var er = Dt.length, we, yt, ar, Or, Dr, Kr, di, $t;
          if (!Z || !Z.state || (we = Z.state, Or = we.wrap, Or === 2 || Or === 1 && we.status !== $e || we.lookahead))
            return C;
          for (Or === 1 && (Z.adler = F(Z.adler, Dt, er, 0)), we.wrap = 0, er >= we.w_size && (Or === 0 && (We(we.head), we.strstart = 0, we.block_start = 0, we.insert = 0), $t = new Q.Buf8(we.w_size), Q.arraySet($t, Dt, er - we.w_size, we.w_size, 0), Dt = $t, er = we.w_size), Dr = Z.avail_in, Kr = Z.next_in, di = Z.input, Z.avail_in = er, Z.next_in = 0, Z.input = Dt, Qt(we); we.lookahead >= Ue; ) {
            yt = we.strstart, ar = we.lookahead - (Ue - 1);
            do
              we.ins_h = (we.ins_h << we.hash_shift ^ we.window[yt + Ue - 1]) & we.hash_mask, we.prev[yt & we.w_mask] = we.head[we.ins_h], we.head[we.ins_h] = yt, yt++;
            while (--ar);
            we.strstart = yt, we.lookahead = Ue - 1, Qt(we);
          }
          return we.strstart += we.lookahead, we.block_start = we.strstart, we.insert = we.lookahead, we.lookahead = 0, we.match_length = we.prev_length = Ue - 1, we.match_available = 0, Z.next_in = Kr, Z.input = di, Z.avail_in = Dr, we.wrap = Or, z;
        }
        $.deflateInit = tr, $.deflateInit2 = kt, $.deflateReset = Gt, $.deflateResetKeep = Tt, $.deflateSetHeader = pr, $.deflate = Je, $.deflateEnd = wr, $.deflateSetDictionary = ni, $.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 89, "./adler32": 91, "./crc32": 93, "./messages": 99, "./trees": 100 }], 95: [function(te, Ee, $) {
        function Q() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
        }
        Ee.exports = Q;
      }, {}], 96: [function(te, Ee, $) {
        arguments[4][41][0].apply($, arguments);
      }, { dup: 41 }], 97: [function(te, Ee, $) {
        arguments[4][42][0].apply($, arguments);
      }, { "../utils/common": 89, "./adler32": 91, "./crc32": 93, "./inffast": 96, "./inftrees": 98, dup: 42 }], 98: [function(te, Ee, $) {
        arguments[4][43][0].apply($, arguments);
      }, { "../utils/common": 89, dup: 43 }], 99: [function(te, Ee, $) {
        arguments[4][44][0].apply($, arguments);
      }, { dup: 44 }], 100: [function(te, Ee, $) {
        var Q = te("../utils/common"), r = 4, F = 0, H = 1, P = 2;
        function M(Te) {
          for (var Tt = Te.length; --Tt >= 0; )
            Te[Tt] = 0;
        }
        var E = 0, x = 1, m = 2, I = 3, z = 258, w = 29, C = 256, b = C + 1 + w, B = 30, N = 19, U = 2 * b + 1, V = 15, W = 16, q = 7, Y = 256, re = 16, se = 17, ve = 18, ce = (
          /* extra bits for each length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
        ), be = (
          /* extra bits for each distance code */
          [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
        ), Me = (
          /* extra bits for each bit length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
        ), xe = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], le = 512, de = new Array((b + 2) * 2);
        M(de);
        var De = new Array(B * 2);
        M(De);
        var ze = new Array(le);
        M(ze);
        var Ze = new Array(z - I + 1);
        M(Ze);
        var Ue = new Array(w);
        M(Ue);
        var Ie = new Array(B);
        M(Ie);
        function je(Te, Tt, Gt, pr, kt) {
          this.static_tree = Te, this.extra_bits = Tt, this.extra_base = Gt, this.elems = pr, this.max_length = kt, this.has_stree = Te && Te.length;
        }
        var Fe, $e, ct;
        function wt(Te, Tt) {
          this.dyn_tree = Te, this.max_code = 0, this.stat_desc = Tt;
        }
        function Oe(Te) {
          return Te < 256 ? ze[Te] : ze[256 + (Te >>> 7)];
        }
        function Ct(Te, Tt) {
          Te.pending_buf[Te.pending++] = Tt & 255, Te.pending_buf[Te.pending++] = Tt >>> 8 & 255;
        }
        function Xt(Te, Tt, Gt) {
          Te.bi_valid > W - Gt ? (Te.bi_buf |= Tt << Te.bi_valid & 65535, Ct(Te, Te.bi_buf), Te.bi_buf = Tt >> W - Te.bi_valid, Te.bi_valid += Gt - W) : (Te.bi_buf |= Tt << Te.bi_valid & 65535, Te.bi_valid += Gt);
        }
        function vt(Te, Tt, Gt) {
          Xt(
            Te,
            Gt[Tt * 2],
            Gt[Tt * 2 + 1]
            /*.Len*/
          );
        }
        function Ye(Te, Tt) {
          var Gt = 0;
          do
            Gt |= Te & 1, Te >>>= 1, Gt <<= 1;
          while (--Tt > 0);
          return Gt >>> 1;
        }
        function qe(Te) {
          Te.bi_valid === 16 ? (Ct(Te, Te.bi_buf), Te.bi_buf = 0, Te.bi_valid = 0) : Te.bi_valid >= 8 && (Te.pending_buf[Te.pending++] = Te.bi_buf & 255, Te.bi_buf >>= 8, Te.bi_valid -= 8);
        }
        function rt(Te, Tt) {
          var Gt = Tt.dyn_tree, pr = Tt.max_code, kt = Tt.stat_desc.static_tree, tr = Tt.stat_desc.has_stree, Je = Tt.stat_desc.extra_bits, wr = Tt.stat_desc.extra_base, ni = Tt.stat_desc.max_length, Z, Dt, er, we, yt, ar, Or = 0;
          for (we = 0; we <= V; we++)
            Te.bl_count[we] = 0;
          for (Gt[Te.heap[Te.heap_max] * 2 + 1] = 0, Z = Te.heap_max + 1; Z < U; Z++)
            Dt = Te.heap[Z], we = Gt[Gt[Dt * 2 + 1] * 2 + 1] + 1, we > ni && (we = ni, Or++), Gt[Dt * 2 + 1] = we, !(Dt > pr) && (Te.bl_count[we]++, yt = 0, Dt >= wr && (yt = Je[Dt - wr]), ar = Gt[Dt * 2], Te.opt_len += ar * (we + yt), tr && (Te.static_len += ar * (kt[Dt * 2 + 1] + yt)));
          if (Or !== 0) {
            do {
              for (we = ni - 1; Te.bl_count[we] === 0; )
                we--;
              Te.bl_count[we]--, Te.bl_count[we + 1] += 2, Te.bl_count[ni]--, Or -= 2;
            } while (Or > 0);
            for (we = ni; we !== 0; we--)
              for (Dt = Te.bl_count[we]; Dt !== 0; )
                er = Te.heap[--Z], !(er > pr) && (Gt[er * 2 + 1] !== we && (Te.opt_len += (we - Gt[er * 2 + 1]) * Gt[er * 2], Gt[er * 2 + 1] = we), Dt--);
          }
        }
        function it(Te, Tt, Gt) {
          var pr = new Array(V + 1), kt = 0, tr, Je;
          for (tr = 1; tr <= V; tr++)
            pr[tr] = kt = kt + Gt[tr - 1] << 1;
          for (Je = 0; Je <= Tt; Je++) {
            var wr = Te[Je * 2 + 1];
            wr !== 0 && (Te[Je * 2] = Ye(pr[wr]++, wr));
          }
        }
        function Ae() {
          var Te, Tt, Gt, pr, kt, tr = new Array(V + 1);
          for (Gt = 0, pr = 0; pr < w - 1; pr++)
            for (Ue[pr] = Gt, Te = 0; Te < 1 << ce[pr]; Te++)
              Ze[Gt++] = pr;
          for (Ze[Gt - 1] = pr, kt = 0, pr = 0; pr < 16; pr++)
            for (Ie[pr] = kt, Te = 0; Te < 1 << be[pr]; Te++)
              ze[kt++] = pr;
          for (kt >>= 7; pr < B; pr++)
            for (Ie[pr] = kt << 7, Te = 0; Te < 1 << be[pr] - 7; Te++)
              ze[256 + kt++] = pr;
          for (Tt = 0; Tt <= V; Tt++)
            tr[Tt] = 0;
          for (Te = 0; Te <= 143; )
            de[Te * 2 + 1] = 8, Te++, tr[8]++;
          for (; Te <= 255; )
            de[Te * 2 + 1] = 9, Te++, tr[9]++;
          for (; Te <= 279; )
            de[Te * 2 + 1] = 7, Te++, tr[7]++;
          for (; Te <= 287; )
            de[Te * 2 + 1] = 8, Te++, tr[8]++;
          for (it(de, b + 1, tr), Te = 0; Te < B; Te++)
            De[Te * 2 + 1] = 5, De[Te * 2] = Ye(Te, 5);
          Fe = new je(de, ce, C + 1, b, V), $e = new je(De, be, 0, B, V), ct = new je(new Array(0), Me, 0, N, q);
        }
        function _e(Te) {
          var Tt;
          for (Tt = 0; Tt < b; Tt++)
            Te.dyn_ltree[Tt * 2] = 0;
          for (Tt = 0; Tt < B; Tt++)
            Te.dyn_dtree[Tt * 2] = 0;
          for (Tt = 0; Tt < N; Tt++)
            Te.bl_tree[Tt * 2] = 0;
          Te.dyn_ltree[Y * 2] = 1, Te.opt_len = Te.static_len = 0, Te.last_lit = Te.matches = 0;
        }
        function fe(Te) {
          Te.bi_valid > 8 ? Ct(Te, Te.bi_buf) : Te.bi_valid > 0 && (Te.pending_buf[Te.pending++] = Te.bi_buf), Te.bi_buf = 0, Te.bi_valid = 0;
        }
        function We(Te, Tt, Gt, pr) {
          fe(Te), Ct(Te, Gt), Ct(Te, ~Gt), Q.arraySet(Te.pending_buf, Te.window, Tt, Gt, Te.pending), Te.pending += Gt;
        }
        function Pe(Te, Tt, Gt, pr) {
          var kt = Tt * 2, tr = Gt * 2;
          return Te[kt] < Te[tr] || Te[kt] === Te[tr] && pr[Tt] <= pr[Gt];
        }
        function he(Te, Tt, Gt) {
          for (var pr = Te.heap[Gt], kt = Gt << 1; kt <= Te.heap_len && (kt < Te.heap_len && Pe(Tt, Te.heap[kt + 1], Te.heap[kt], Te.depth) && kt++, !Pe(Tt, pr, Te.heap[kt], Te.depth)); )
            Te.heap[Gt] = Te.heap[kt], Gt = kt, kt <<= 1;
          Te.heap[Gt] = pr;
        }
        function ie(Te, Tt, Gt) {
          var pr, kt, tr = 0, Je, wr;
          if (Te.last_lit !== 0)
            do
              pr = Te.pending_buf[Te.d_buf + tr * 2] << 8 | Te.pending_buf[Te.d_buf + tr * 2 + 1], kt = Te.pending_buf[Te.l_buf + tr], tr++, pr === 0 ? vt(Te, kt, Tt) : (Je = Ze[kt], vt(Te, Je + C + 1, Tt), wr = ce[Je], wr !== 0 && (kt -= Ue[Je], Xt(Te, kt, wr)), pr--, Je = Oe(pr), vt(Te, Je, Gt), wr = be[Je], wr !== 0 && (pr -= Ie[Je], Xt(Te, pr, wr)));
            while (tr < Te.last_lit);
          vt(Te, Y, Tt);
        }
        function Xe(Te, Tt) {
          var Gt = Tt.dyn_tree, pr = Tt.stat_desc.static_tree, kt = Tt.stat_desc.has_stree, tr = Tt.stat_desc.elems, Je, wr, ni = -1, Z;
          for (Te.heap_len = 0, Te.heap_max = U, Je = 0; Je < tr; Je++)
            Gt[Je * 2] !== 0 ? (Te.heap[++Te.heap_len] = ni = Je, Te.depth[Je] = 0) : Gt[Je * 2 + 1] = 0;
          for (; Te.heap_len < 2; )
            Z = Te.heap[++Te.heap_len] = ni < 2 ? ++ni : 0, Gt[Z * 2] = 1, Te.depth[Z] = 0, Te.opt_len--, kt && (Te.static_len -= pr[Z * 2 + 1]);
          for (Tt.max_code = ni, Je = Te.heap_len >> 1; Je >= 1; Je--)
            he(Te, Gt, Je);
          Z = tr;
          do
            Je = Te.heap[
              1
              /*SMALLEST*/
            ], Te.heap[
              1
              /*SMALLEST*/
            ] = Te.heap[Te.heap_len--], he(
              Te,
              Gt,
              1
              /*SMALLEST*/
            ), wr = Te.heap[
              1
              /*SMALLEST*/
            ], Te.heap[--Te.heap_max] = Je, Te.heap[--Te.heap_max] = wr, Gt[Z * 2] = Gt[Je * 2] + Gt[wr * 2], Te.depth[Z] = (Te.depth[Je] >= Te.depth[wr] ? Te.depth[Je] : Te.depth[wr]) + 1, Gt[Je * 2 + 1] = Gt[wr * 2 + 1] = Z, Te.heap[
              1
              /*SMALLEST*/
            ] = Z++, he(
              Te,
              Gt,
              1
              /*SMALLEST*/
            );
          while (Te.heap_len >= 2);
          Te.heap[--Te.heap_max] = Te.heap[
            1
            /*SMALLEST*/
          ], rt(Te, Tt), it(Gt, ni, Te.bl_count);
        }
        function bt(Te, Tt, Gt) {
          var pr, kt = -1, tr, Je = Tt[0 * 2 + 1], wr = 0, ni = 7, Z = 4;
          for (Je === 0 && (ni = 138, Z = 3), Tt[(Gt + 1) * 2 + 1] = 65535, pr = 0; pr <= Gt; pr++)
            tr = Je, Je = Tt[(pr + 1) * 2 + 1], !(++wr < ni && tr === Je) && (wr < Z ? Te.bl_tree[tr * 2] += wr : tr !== 0 ? (tr !== kt && Te.bl_tree[tr * 2]++, Te.bl_tree[re * 2]++) : wr <= 10 ? Te.bl_tree[se * 2]++ : Te.bl_tree[ve * 2]++, wr = 0, kt = tr, Je === 0 ? (ni = 138, Z = 3) : tr === Je ? (ni = 6, Z = 3) : (ni = 7, Z = 4));
        }
        function Wt(Te, Tt, Gt) {
          var pr, kt = -1, tr, Je = Tt[0 * 2 + 1], wr = 0, ni = 7, Z = 4;
          for (Je === 0 && (ni = 138, Z = 3), pr = 0; pr <= Gt; pr++)
            if (tr = Je, Je = Tt[(pr + 1) * 2 + 1], !(++wr < ni && tr === Je)) {
              if (wr < Z)
                do
                  vt(Te, tr, Te.bl_tree);
                while (--wr !== 0);
              else tr !== 0 ? (tr !== kt && (vt(Te, tr, Te.bl_tree), wr--), vt(Te, re, Te.bl_tree), Xt(Te, wr - 3, 2)) : wr <= 10 ? (vt(Te, se, Te.bl_tree), Xt(Te, wr - 3, 3)) : (vt(Te, ve, Te.bl_tree), Xt(Te, wr - 11, 7));
              wr = 0, kt = tr, Je === 0 ? (ni = 138, Z = 3) : tr === Je ? (ni = 6, Z = 3) : (ni = 7, Z = 4);
            }
        }
        function Qt(Te) {
          var Tt;
          for (bt(Te, Te.dyn_ltree, Te.l_desc.max_code), bt(Te, Te.dyn_dtree, Te.d_desc.max_code), Xe(Te, Te.bl_desc), Tt = N - 1; Tt >= 3 && Te.bl_tree[xe[Tt] * 2 + 1] === 0; Tt--)
            ;
          return Te.opt_len += 3 * (Tt + 1) + 5 + 5 + 4, Tt;
        }
        function Sr(Te, Tt, Gt, pr) {
          var kt;
          for (Xt(Te, Tt - 257, 5), Xt(Te, Gt - 1, 5), Xt(Te, pr - 4, 4), kt = 0; kt < pr; kt++)
            Xt(Te, Te.bl_tree[xe[kt] * 2 + 1], 3);
          Wt(Te, Te.dyn_ltree, Tt - 1), Wt(Te, Te.dyn_dtree, Gt - 1);
        }
        function Fr(Te) {
          var Tt = 4093624447, Gt;
          for (Gt = 0; Gt <= 31; Gt++, Tt >>>= 1)
            if (Tt & 1 && Te.dyn_ltree[Gt * 2] !== 0)
              return F;
          if (Te.dyn_ltree[9 * 2] !== 0 || Te.dyn_ltree[10 * 2] !== 0 || Te.dyn_ltree[13 * 2] !== 0)
            return H;
          for (Gt = 32; Gt < C; Gt++)
            if (Te.dyn_ltree[Gt * 2] !== 0)
              return H;
          return F;
        }
        var kr = !1;
        function Ur(Te) {
          kr || (Ae(), kr = !0), Te.l_desc = new wt(Te.dyn_ltree, Fe), Te.d_desc = new wt(Te.dyn_dtree, $e), Te.bl_desc = new wt(Te.bl_tree, ct), Te.bi_buf = 0, Te.bi_valid = 0, _e(Te);
        }
        function Rr(Te, Tt, Gt, pr) {
          Xt(Te, (E << 1) + (pr ? 1 : 0), 3), We(Te, Tt, Gt);
        }
        function Pr(Te) {
          Xt(Te, x << 1, 3), vt(Te, Y, de), qe(Te);
        }
        function hi(Te, Tt, Gt, pr) {
          var kt, tr, Je = 0;
          Te.level > 0 ? (Te.strm.data_type === P && (Te.strm.data_type = Fr(Te)), Xe(Te, Te.l_desc), Xe(Te, Te.d_desc), Je = Qt(Te), kt = Te.opt_len + 3 + 7 >>> 3, tr = Te.static_len + 3 + 7 >>> 3, tr <= kt && (kt = tr)) : kt = tr = Gt + 5, Gt + 4 <= kt && Tt !== -1 ? Rr(Te, Tt, Gt, pr) : Te.strategy === r || tr === kt ? (Xt(Te, (x << 1) + (pr ? 1 : 0), 3), ie(Te, de, De)) : (Xt(Te, (m << 1) + (pr ? 1 : 0), 3), Sr(Te, Te.l_desc.max_code + 1, Te.d_desc.max_code + 1, Je + 1), ie(Te, Te.dyn_ltree, Te.dyn_dtree)), _e(Te), pr && fe(Te);
        }
        function Vr(Te, Tt, Gt) {
          return Te.pending_buf[Te.d_buf + Te.last_lit * 2] = Tt >>> 8 & 255, Te.pending_buf[Te.d_buf + Te.last_lit * 2 + 1] = Tt & 255, Te.pending_buf[Te.l_buf + Te.last_lit] = Gt & 255, Te.last_lit++, Tt === 0 ? Te.dyn_ltree[Gt * 2]++ : (Te.matches++, Tt--, Te.dyn_ltree[(Ze[Gt] + C + 1) * 2]++, Te.dyn_dtree[Oe(Tt) * 2]++), Te.last_lit === Te.lit_bufsize - 1;
        }
        $._tr_init = Ur, $._tr_stored_block = Rr, $._tr_flush_block = hi, $._tr_tally = Vr, $._tr_align = Pr;
      }, { "../utils/common": 89 }], 101: [function(te, Ee, $) {
        arguments[4][46][0].apply($, arguments);
      }, { dup: 46 }], 102: [function(te, Ee, $) {
        Ee.exports = function(P) {
          if (!P)
            throw new Error("no data provided");
          P = P.toString().trim();
          var M = {
            pages: [],
            chars: [],
            kernings: []
          }, E = P.split(/\r\n?|\n/g);
          if (E.length === 0)
            throw new Error("no data in BMFont file");
          for (var x = 0; x < E.length; x++) {
            var m = Q(E[x], x);
            if (m)
              if (m.key === "page") {
                if (typeof m.data.id != "number")
                  throw new Error("malformed file at line " + x + " -- needs page id=N");
                if (typeof m.data.file != "string")
                  throw new Error("malformed file at line " + x + ' -- needs page file="path"');
                M.pages[m.data.id] = m.data.file;
              } else m.key === "chars" || m.key === "kernings" || (m.key === "char" ? M.chars.push(m.data) : m.key === "kerning" ? M.kernings.push(m.data) : M[m.key] = m.data);
          }
          return M;
        };
        function Q(H, P) {
          if (H = H.replace(/\t+/g, " ").trim(), !H)
            return null;
          var M = H.indexOf(" ");
          if (M === -1)
            throw new Error("no named row at line " + P);
          var E = H.substring(0, M);
          H = H.substring(M + 1), H = H.replace(/letter=[\'\"]\S+[\'\"]/gi, ""), H = H.split("="), H = H.map(function(w) {
            return w.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
          });
          for (var x = [], m = 0; m < H.length; m++) {
            var I = H[m];
            m === 0 ? x.push({
              key: I[0],
              data: ""
            }) : m === H.length - 1 ? x[x.length - 1].data = r(I[0]) : (x[x.length - 1].data = r(I[0]), x.push({
              key: I[1],
              data: ""
            }));
          }
          var z = {
            key: E,
            data: {}
          };
          return x.forEach(function(w) {
            z.data[w.key] = w.data;
          }), z;
        }
        function r(H) {
          return !H || H.length === 0 ? "" : H.indexOf('"') === 0 || H.indexOf("'") === 0 ? H.substring(1, H.length - 1) : H.indexOf(",") !== -1 ? F(H) : parseInt(H, 10);
        }
        function F(H) {
          return H.split(",").map(function(P) {
            return parseInt(P, 10);
          });
        }
      }, {}], 103: [function(te, Ee, $) {
        var Q = [66, 77, 70];
        Ee.exports = function(z) {
          if (z.length < 6)
            throw new Error("invalid buffer length for BMFont");
          var w = Q.every(function(U, V) {
            return z.readUInt8(V) === U;
          });
          if (!w)
            throw new Error("BMFont missing BMF byte header");
          var C = 3, b = z.readUInt8(C++);
          if (b > 3)
            throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
          for (var B = { kernings: [], chars: [] }, N = 0; N < 5; N++)
            C += r(B, z, C);
          return B;
        };
        function r(I, z, w) {
          if (w > z.length - 1)
            return 0;
          var C = z.readUInt8(w++), b = z.readInt32LE(w);
          switch (w += 4, C) {
            case 1:
              I.info = F(z, w);
              break;
            case 2:
              I.common = H(z, w);
              break;
            case 3:
              I.pages = P(z, w, b);
              break;
            case 4:
              I.chars = M(z, w, b);
              break;
            case 5:
              I.kernings = E(z, w, b);
              break;
          }
          return 5 + b;
        }
        function F(I, z) {
          var w = {};
          w.size = I.readInt16LE(z);
          var C = I.readUInt8(z + 2);
          return w.smooth = C >> 7 & 1, w.unicode = C >> 6 & 1, w.italic = C >> 5 & 1, w.bold = C >> 4 & 1, C >> 3 & 1 && (w.fixedHeight = 1), w.charset = I.readUInt8(z + 3) || "", w.stretchH = I.readUInt16LE(z + 4), w.aa = I.readUInt8(z + 6), w.padding = [
            I.readInt8(z + 7),
            I.readInt8(z + 8),
            I.readInt8(z + 9),
            I.readInt8(z + 10)
          ], w.spacing = [
            I.readInt8(z + 11),
            I.readInt8(z + 12)
          ], w.outline = I.readUInt8(z + 13), w.face = m(I, z + 14), w;
        }
        function H(I, z) {
          var w = {};
          return w.lineHeight = I.readUInt16LE(z), w.base = I.readUInt16LE(z + 2), w.scaleW = I.readUInt16LE(z + 4), w.scaleH = I.readUInt16LE(z + 6), w.pages = I.readUInt16LE(z + 8), I.readUInt8(z + 10), w.packed = 0, w.alphaChnl = I.readUInt8(z + 11), w.redChnl = I.readUInt8(z + 12), w.greenChnl = I.readUInt8(z + 13), w.blueChnl = I.readUInt8(z + 14), w;
        }
        function P(I, z, w) {
          for (var C = [], b = x(I, z), B = b.length + 1, N = w / B, U = 0; U < N; U++)
            C[U] = I.slice(z, z + b.length).toString("utf8"), z += B;
          return C;
        }
        function M(I, z, w) {
          for (var C = [], b = w / 20, B = 0; B < b; B++) {
            var N = {}, U = B * 20;
            N.id = I.readUInt32LE(z + 0 + U), N.x = I.readUInt16LE(z + 4 + U), N.y = I.readUInt16LE(z + 6 + U), N.width = I.readUInt16LE(z + 8 + U), N.height = I.readUInt16LE(z + 10 + U), N.xoffset = I.readInt16LE(z + 12 + U), N.yoffset = I.readInt16LE(z + 14 + U), N.xadvance = I.readInt16LE(z + 16 + U), N.page = I.readUInt8(z + 18 + U), N.chnl = I.readUInt8(z + 19 + U), C[B] = N;
          }
          return C;
        }
        function E(I, z, w) {
          for (var C = [], b = w / 10, B = 0; B < b; B++) {
            var N = {}, U = B * 10;
            N.first = I.readUInt32LE(z + 0 + U), N.second = I.readUInt32LE(z + 4 + U), N.amount = I.readInt16LE(z + 8 + U), C[B] = N;
          }
          return C;
        }
        function x(I, z) {
          for (var w = z; w < I.length && I[w] !== 0; w++)
            ;
          return I.slice(z, w);
        }
        function m(I, z) {
          return x(I, z).toString("utf8");
        }
      }, {}], 104: [function(te, Ee, $) {
        var Q = te("./parse-attribs"), r = te("xml-parse-from-string"), F = {
          scaleh: "scaleH",
          scalew: "scaleW",
          stretchh: "stretchH",
          lineheight: "lineHeight",
          alphachnl: "alphaChnl",
          redchnl: "redChnl",
          greenchnl: "greenChnl",
          bluechnl: "blueChnl"
        };
        Ee.exports = function(x) {
          x = x.toString();
          var m = r(x), I = {
            pages: [],
            chars: [],
            kernings: []
          };
          ["info", "common"].forEach(function(U) {
            var V = m.getElementsByTagName(U)[0];
            V && (I[U] = Q(H(V)));
          });
          var z = m.getElementsByTagName("pages")[0];
          if (!z)
            throw new Error("malformed file -- no <pages> element");
          for (var w = z.getElementsByTagName("page"), C = 0; C < w.length; C++) {
            var b = w[C], B = parseInt(b.getAttribute("id"), 10), N = b.getAttribute("file");
            if (isNaN(B))
              throw new Error('malformed file -- page "id" attribute is NaN');
            if (!N)
              throw new Error('malformed file -- needs page "file" attribute');
            I.pages[parseInt(B, 10)] = N;
          }
          return ["chars", "kernings"].forEach(function(U) {
            var V = m.getElementsByTagName(U)[0];
            if (V)
              for (var W = U.substring(0, U.length - 1), q = V.getElementsByTagName(W), Y = 0; Y < q.length; Y++) {
                var re = q[Y];
                I[U].push(Q(H(re)));
              }
          }), I;
        };
        function H(E) {
          var x = P(E);
          return x.reduce(function(m, I) {
            var z = M(I.nodeName);
            return m[z] = I.nodeValue, m;
          }, {});
        }
        function P(E) {
          for (var x = [], m = 0; m < E.attributes.length; m++)
            x.push(E.attributes[m]);
          return x;
        }
        function M(E) {
          return F[E.toLowerCase()] || E;
        }
      }, { "./parse-attribs": 105, "xml-parse-from-string": 188 }], 105: [function(te, Ee, $) {
        var Q = "chasrset";
        Ee.exports = function(H) {
          Q in H && (H.charset = H[Q], delete H[Q]);
          for (var P in H)
            P === "face" || P === "charset" || (P === "padding" || P === "spacing" ? H[P] = r(H[P]) : H[P] = parseInt(H[P], 10));
          return H;
        };
        function r(F) {
          return F.split(",").map(function(H) {
            return parseInt(H, 10);
          });
        }
      }, {}], 106: [function(te, Ee, $) {
        var Q = te("trim"), r = te("for-each"), F = function(H) {
          return Object.prototype.toString.call(H) === "[object Array]";
        };
        Ee.exports = function(H) {
          if (!H)
            return {};
          var P = {};
          return r(
            Q(H).split(`
`),
            function(M) {
              var E = M.indexOf(":"), x = Q(M.slice(0, E)).toLowerCase(), m = Q(M.slice(E + 1));
              typeof P[x] > "u" ? P[x] = m : F(P[x]) ? P[x].push(m) : P[x] = [P[x], m];
            }
          ), P;
        };
      }, { "for-each": 63, trim: 179 }], 107: [function(te, Ee, $) {
        (function(Q) {
          function r(M, E) {
            for (var x = 0, m = M.length - 1; m >= 0; m--) {
              var I = M[m];
              I === "." ? M.splice(m, 1) : I === ".." ? (M.splice(m, 1), x++) : x && (M.splice(m, 1), x--);
            }
            if (E)
              for (; x--; x)
                M.unshift("..");
            return M;
          }
          $.resolve = function() {
            for (var M = "", E = !1, x = arguments.length - 1; x >= -1 && !E; x--) {
              var m = x >= 0 ? arguments[x] : Q.cwd();
              if (typeof m != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              if (!m)
                continue;
              M = m + "/" + M, E = m.charAt(0) === "/";
            }
            return M = r(H(M.split("/"), function(I) {
              return !!I;
            }), !E).join("/"), (E ? "/" : "") + M || ".";
          }, $.normalize = function(M) {
            var E = $.isAbsolute(M), x = P(M, -1) === "/";
            return M = r(H(M.split("/"), function(m) {
              return !!m;
            }), !E).join("/"), !M && !E && (M = "."), M && x && (M += "/"), (E ? "/" : "") + M;
          }, $.isAbsolute = function(M) {
            return M.charAt(0) === "/";
          }, $.join = function() {
            var M = Array.prototype.slice.call(arguments, 0);
            return $.normalize(H(M, function(E, x) {
              if (typeof E != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return E;
            }).join("/"));
          }, $.relative = function(M, E) {
            M = $.resolve(M).substr(1), E = $.resolve(E).substr(1);
            function x(B) {
              for (var N = 0; N < B.length && B[N] === ""; N++)
                ;
              for (var U = B.length - 1; U >= 0 && B[U] === ""; U--)
                ;
              return N > U ? [] : B.slice(N, U - N + 1);
            }
            for (var m = x(M.split("/")), I = x(E.split("/")), z = Math.min(m.length, I.length), w = z, C = 0; C < z; C++)
              if (m[C] !== I[C]) {
                w = C;
                break;
              }
            for (var b = [], C = w; C < m.length; C++)
              b.push("..");
            return b = b.concat(I.slice(w)), b.join("/");
          }, $.sep = "/", $.delimiter = ":", $.dirname = function(M) {
            if (typeof M != "string" && (M = M + ""), M.length === 0) return ".";
            for (var E = M.charCodeAt(0), x = E === 47, m = -1, I = !0, z = M.length - 1; z >= 1; --z)
              if (E = M.charCodeAt(z), E === 47) {
                if (!I) {
                  m = z;
                  break;
                }
              } else
                I = !1;
            return m === -1 ? x ? "/" : "." : x && m === 1 ? "/" : M.slice(0, m);
          };
          function F(M) {
            typeof M != "string" && (M = M + "");
            var E = 0, x = -1, m = !0, I;
            for (I = M.length - 1; I >= 0; --I)
              if (M.charCodeAt(I) === 47) {
                if (!m) {
                  E = I + 1;
                  break;
                }
              } else x === -1 && (m = !1, x = I + 1);
            return x === -1 ? "" : M.slice(E, x);
          }
          $.basename = function(M, E) {
            var x = F(M);
            return E && x.substr(-1 * E.length) === E && (x = x.substr(0, x.length - E.length)), x;
          }, $.extname = function(M) {
            typeof M != "string" && (M = M + "");
            for (var E = -1, x = 0, m = -1, I = !0, z = 0, w = M.length - 1; w >= 0; --w) {
              var C = M.charCodeAt(w);
              if (C === 47) {
                if (!I) {
                  x = w + 1;
                  break;
                }
                continue;
              }
              m === -1 && (I = !1, m = w + 1), C === 46 ? E === -1 ? E = w : z !== 1 && (z = 1) : E !== -1 && (z = -1);
            }
            return E === -1 || m === -1 || // We saw a non-dot character immediately before the dot
            z === 0 || // The (right-most) trimmed path component is exactly '..'
            z === 1 && E === m - 1 && E === x + 1 ? "" : M.slice(E, m);
          };
          function H(M, E) {
            if (M.filter) return M.filter(E);
            for (var x = [], m = 0; m < M.length; m++)
              E(M[m], m, M) && x.push(M[m]);
            return x;
          }
          var P = "ab".substr(-1) === "b" ? function(M, E, x) {
            return M.substr(E, x);
          } : function(M, E, x) {
            return E < 0 && (E = M.length + E), M.substr(E, x);
          };
        }).call(this, te("_process"));
      }, { _process: 133 }], 108: [function(te, Ee, $) {
        (function(Q) {
          var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(I) {
            return typeof I;
          } : function(I) {
            return I && typeof Symbol == "function" && I.constructor === Symbol && I !== Symbol.prototype ? "symbol" : typeof I;
          }, F = te("http"), H = te("https"), P = te("url"), M = te("querystring"), E = te("zlib"), x = te("util"), m = function(z, w) {
            if (typeof z != "string" && !z.hasOwnProperty("url"))
              throw new Error("Missing url option from options for request method.");
            var C = (typeof z > "u" ? "undefined" : r(z)) === "object" ? P.parse(z.url) : P.parse(z), b = { hostname: C.hostname, port: C.port || (C.protocol.toLowerCase() === "http:" ? 80 : 443), path: C.path, method: "GET", headers: {}, auth: C.auth || null, parse: "none", stream: !1 };
            if ((typeof z > "u" ? "undefined" : r(z)) === "object" && (b = Object.assign(b, z)), b.port = Number(b.port), b.hasOwnProperty("timeout") && delete b.timeout, b.compressed === !0 && (b.headers["accept-encoding"] = "gzip, deflate"), z.hasOwnProperty("form")) {
              if (r(z.form) !== "object")
                throw new Error("phin 'form' option must be of type Object if present.");
              var B = M.stringify(z.form);
              b.headers["Content-Type"] = "application/x-www-form-urlencoded", b.headers["Content-Length"] = Q.byteLength(B), z.data = B;
            }
            var N = void 0, U = function(Y) {
              var re = Y;
              b.compressed === !0 && (Y.headers["content-encoding"] === "gzip" ? re = Y.pipe(E.createGunzip()) : Y.headers["content-encoding"] === "deflate" && (re = Y.pipe(E.createInflate()))), b.stream === !0 ? (Y.stream = re, w(null, Y)) : (Y.body = new Q([]), re.on("data", function(se) {
                Y.body = Q.concat([Y.body, se]);
              }), re.on("end", function() {
                if (w) {
                  if (b.parse === "json")
                    try {
                      Y.body = JSON.parse(Y.body.toString());
                    } catch {
                      w("Invalid JSON received.", Y);
                      return;
                    }
                  w(null, Y);
                }
              }));
            };
            switch (C.protocol.toLowerCase()) {
              case "http:":
                N = F.request(b, U);
                break;
              case "https:":
                N = H.request(b, U);
                break;
              default:
                w && w(new Error("Invalid / unknown URL protocol. Expected HTTP or HTTPS."), null);
                return;
            }
            if (typeof z.timeout == "number" && N.setTimeout(z.timeout, function() {
              N.abort(), w(new Error("Timeout has been reached."), null), w = null;
            }), N.on("error", function(q) {
              w && w(q, null);
            }), z.hasOwnProperty("data")) {
              var V = z.data;
              if (!(z.data instanceof Q) && r(z.data) === "object") {
                var W = b.headers["content-type"] || b.headers["Content-Type"];
                if (W === "application/x-www-form-urlencoded")
                  V = M.stringify(z.data);
                else
                  try {
                    V = JSON.stringify(z.data);
                  } catch {
                    w(new Error("Couldn't stringify object. (Likely due to a circular reference.)"), null);
                  }
              }
              N.write(V);
            }
            N.end();
          };
          m.promisified = function(I, z) {
            return new Promise(function(w, C) {
              m(I, function(b, B) {
                b ? C(b) : w(B);
              });
            });
          }, x.promisify && (m[x.promisify.custom] = m.promisified), Ee.exports = m;
        }).call(this, te("buffer").Buffer);
      }, { buffer: 48, http: 156, https: 72, querystring: 137, url: 180, util: 186, zlib: 35 }], 109: [function(te, Ee, $) {
        Ee.exports = Q;
        function Q(I, z, w, C, b, B) {
          B || (B = {});
          for (var N = B.threshold === void 0 ? 0.1 : B.threshold, U = 35215 * N * N, V = 0, W = 0; W < b; W++)
            for (var q = 0; q < C; q++) {
              var Y = (W * C + q) * 4, re = F(I, z, Y, Y);
              if (re > U)
                !B.includeAA && (r(I, q, W, C, b, z) || r(z, q, W, C, b, I)) ? w && x(w, Y, 255, 255, 0) : (w && x(w, Y, 255, 0, 0), V++);
              else if (w) {
                var se = E(m(I, Y), 0.1);
                x(w, Y, se, se, se);
              }
            }
          return V;
        }
        function r(I, z, w, C, b, B) {
          for (var N = Math.max(z - 1, 0), U = Math.max(w - 1, 0), V = Math.min(z + 1, C - 1), W = Math.min(w + 1, b - 1), q = (w * C + z) * 4, Y = 0, re = 0, se = 0, ve = 0, ce = 0, be, Me, xe, le, de = N; de <= V; de++)
            for (var De = U; De <= W; De++)
              if (!(de === z && De === w)) {
                var ze = F(I, I, q, (De * C + de) * 4, !0);
                if (ze === 0 ? Y++ : ze < 0 ? se++ : ze > 0 && re++, Y > 2) return !1;
                B && (ze < ve && (ve = ze, be = de, Me = De), ze > ce && (ce = ze, xe = de, le = De));
              }
          return B ? se === 0 || re === 0 ? !1 : !r(I, be, Me, C, b) && !r(B, be, Me, C, b) || !r(I, xe, le, C, b) && !r(B, xe, le, C, b) : !0;
        }
        function F(I, z, w, C, b) {
          var B = I[w + 3] / 255, N = z[C + 3] / 255, U = E(I[w + 0], B), V = E(I[w + 1], B), W = E(I[w + 2], B), q = E(z[C + 0], N), Y = E(z[C + 1], N), re = E(z[C + 2], N), se = H(U, V, W) - H(q, Y, re);
          if (b) return se;
          var ve = P(U, V, W) - P(q, Y, re), ce = M(U, V, W) - M(q, Y, re);
          return 0.5053 * se * se + 0.299 * ve * ve + 0.1957 * ce * ce;
        }
        function H(I, z, w) {
          return I * 0.29889531 + z * 0.58662247 + w * 0.11448223;
        }
        function P(I, z, w) {
          return I * 0.59597799 - z * 0.2741761 - w * 0.32180189;
        }
        function M(I, z, w) {
          return I * 0.21147017 - z * 0.52261711 + w * 0.31114694;
        }
        function E(I, z) {
          return 255 + (I - 255) * z;
        }
        function x(I, z, w, C, b) {
          I[z + 0] = w, I[z + 1] = C, I[z + 2] = b, I[z + 3] = 255;
        }
        function m(I, z) {
          var w = I[z + 3] / 255, C = E(I[z + 0], w), b = E(I[z + 1], w), B = E(I[z + 2], w);
          return H(C, b, B);
        }
      }, {}], 110: [function(te, Ee, $) {
        (function(Q) {
          var r = te("./interlace"), F = {
            1: {
              // L
              0: 0,
              1: 0,
              2: 0,
              3: 255
            },
            2: {
              // LA
              0: 0,
              1: 0,
              2: 0,
              3: 1
            },
            3: {
              // RGB
              0: 0,
              1: 1,
              2: 2,
              3: 255
            },
            4: {
              // RGBA
              0: 0,
              1: 1,
              2: 2,
              3: 3
            }
          };
          function H(E, x) {
            var m = [], I = 0;
            function z() {
              if (I === E.length)
                throw new Error("Ran out of data");
              var w = E[I];
              I++;
              var C, b, B, N, U, V, W, q;
              switch (x) {
                default:
                  throw new Error("unrecognised depth");
                case 16:
                  W = E[I], I++, m.push((w << 8) + W);
                  break;
                case 4:
                  W = w & 15, q = w >> 4, m.push(q, W);
                  break;
                case 2:
                  U = w & 3, V = w >> 2 & 3, W = w >> 4 & 3, q = w >> 6 & 3, m.push(q, W, V, U);
                  break;
                case 1:
                  C = w & 1, b = w >> 1 & 1, B = w >> 2 & 1, N = w >> 3 & 1, U = w >> 4 & 1, V = w >> 5 & 1, W = w >> 6 & 1, q = w >> 7 & 1, m.push(q, W, V, U, N, B, b, C);
                  break;
              }
            }
            return {
              get: function(w) {
                for (; m.length < w; )
                  z();
                var C = m.slice(0, w);
                return m = m.slice(w), C;
              },
              resetAfterLine: function() {
                m.length = 0;
              },
              end: function() {
                if (I !== E.length)
                  throw new Error("extra data found");
              }
            };
          }
          function P(E, x, m, I, z, w) {
            for (var C = E.width, b = E.height, B = E.index, N = 0; N < b; N++)
              for (var U = 0; U < C; U++) {
                for (var V = m(U, N, B), W = 0; W < 4; W++) {
                  var q = F[I][W];
                  if (q === 255)
                    x[V + W] = 255;
                  else {
                    var Y = q + w;
                    if (Y === z.length)
                      throw new Error("Ran out of data");
                    x[V + W] = z[Y];
                  }
                }
                w += I;
              }
            return w;
          }
          function M(E, x, m, I, z, w) {
            for (var C = E.width, b = E.height, B = E.index, N = 0; N < b; N++) {
              for (var U = 0; U < C; U++)
                for (var V = z.get(I), W = m(U, N, B), q = 0; q < 4; q++) {
                  var Y = F[I][q];
                  x[W + q] = Y !== 255 ? V[Y] : w;
                }
              z.resetAfterLine();
            }
          }
          $.dataToBitMap = function(E, x) {
            var m = x.width, I = x.height, z = x.depth, w = x.bpp, C = x.interlace;
            if (z !== 8)
              var b = H(E, z);
            var B;
            z <= 8 ? B = new Q(m * I * 4) : B = new Uint16Array(m * I * 4);
            var N = Math.pow(2, z) - 1, U = 0, V, W;
            if (C)
              V = r.getImagePasses(m, I), W = r.getInterlaceIterator(m, I);
            else {
              var q = 0;
              W = function() {
                var re = q;
                return q += 4, re;
              }, V = [{ width: m, height: I }];
            }
            for (var Y = 0; Y < V.length; Y++)
              z === 8 ? U = P(V[Y], B, W, w, E, U) : M(V[Y], B, W, w, b, N);
            if (z === 8) {
              if (U !== E.length)
                throw new Error("extra data found");
            } else
              b.end();
            return B;
          };
        }).call(this, te("buffer").Buffer);
      }, { "./interlace": 120, buffer: 48 }], 111: [function(te, Ee, $) {
        (function(Q) {
          var r = te("./constants");
          Ee.exports = function(F, H, P, M) {
            var E = [r.COLORTYPE_COLOR_ALPHA, r.COLORTYPE_ALPHA].indexOf(M.colorType) !== -1;
            if (M.colorType === M.inputColorType) {
              var x = function() {
                var re = new ArrayBuffer(2);
                return new DataView(re).setInt16(
                  0,
                  256,
                  !0
                  /* littleEndian */
                ), new Int16Array(re)[0] !== 256;
              }();
              if (M.bitDepth === 8 || M.bitDepth === 16 && x)
                return F;
            }
            var m = M.bitDepth !== 16 ? F : new Uint16Array(F.buffer), I = 255, z = r.COLORTYPE_TO_BPP_MAP[M.inputColorType];
            z == 4 && !M.inputHasAlpha && (z = 3);
            var w = r.COLORTYPE_TO_BPP_MAP[M.colorType];
            M.bitDepth === 16 && (I = 65535, w *= 2);
            var C = new Q(H * P * w), b = 0, B = 0, N = M.bgColor || {};
            N.red === void 0 && (N.red = I), N.green === void 0 && (N.green = I), N.blue === void 0 && (N.blue = I);
            function U(re, se) {
              var ve, ce, be, Me = I;
              switch (M.inputColorType) {
                case r.COLORTYPE_COLOR_ALPHA:
                  Me = re[se + 3], ve = re[se], ce = re[se + 1], be = re[se + 2];
                  break;
                case r.COLORTYPE_COLOR:
                  ve = re[se], ce = re[se + 1], be = re[se + 2];
                  break;
                case r.COLORTYPE_ALPHA:
                  Me = re[se + 1], ve = re[se], ce = ve, be = ve;
                  break;
                case r.COLORTYPE_GRAYSCALE:
                  ve = re[se], ce = ve, be = ve;
                  break;
                default:
                  throw new Error("input color type:" + M.inputColorType + " is not supported at present");
              }
              return M.inputHasAlpha && (E || (Me /= I, ve = Math.min(Math.max(Math.round((1 - Me) * N.red + Me * ve), 0), I), ce = Math.min(Math.max(Math.round((1 - Me) * N.green + Me * ce), 0), I), be = Math.min(Math.max(Math.round((1 - Me) * N.blue + Me * be), 0), I))), { red: ve, green: ce, blue: be, alpha: Me };
            }
            for (var V = 0; V < P; V++)
              for (var W = 0; W < H; W++) {
                var q = U(m, b);
                switch (M.colorType) {
                  case r.COLORTYPE_COLOR_ALPHA:
                  case r.COLORTYPE_COLOR:
                    M.bitDepth === 8 ? (C[B] = q.red, C[B + 1] = q.green, C[B + 2] = q.blue, E && (C[B + 3] = q.alpha)) : (C.writeUInt16BE(q.red, B), C.writeUInt16BE(q.green, B + 2), C.writeUInt16BE(q.blue, B + 4), E && C.writeUInt16BE(q.alpha, B + 6));
                    break;
                  case r.COLORTYPE_ALPHA:
                  case r.COLORTYPE_GRAYSCALE:
                    var Y = (q.red + q.green + q.blue) / 3;
                    M.bitDepth === 8 ? (C[B] = Y, E && (C[B + 1] = q.alpha)) : (C.writeUInt16BE(Y, B), E && C.writeUInt16BE(q.alpha, B + 2));
                    break;
                }
                b += z, B += w;
              }
            return C;
          };
        }).call(this, te("buffer").Buffer);
      }, { "./constants": 113, buffer: 48 }], 112: [function(te, Ee, $) {
        (function(Q, r) {
          var F = te("util"), H = te("stream"), P = Ee.exports = function() {
            H.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = !1, this._encoding = "utf8", this.writable = !0;
          };
          F.inherits(P, H), P.prototype.read = function(M, E) {
            this._reads.push({
              length: Math.abs(M),
              // if length < 0 then at most this length
              allowLess: M < 0,
              func: E
            }), Q.nextTick((function() {
              this._process(), this._paused && this._reads.length > 0 && (this._paused = !1, this.emit("drain"));
            }).bind(this));
          }, P.prototype.write = function(M, E) {
            if (!this.writable)
              return this.emit("error", new Error("Stream not writable")), !1;
            var x;
            return r.isBuffer(M) ? x = M : x = new r(M, E || this._encoding), this._buffers.push(x), this._buffered += x.length, this._process(), this._reads && this._reads.length === 0 && (this._paused = !0), this.writable && !this._paused;
          }, P.prototype.end = function(M, E) {
            M && this.write(M, E), this.writable = !1, this._buffers && (this._buffers.length === 0 ? this._end() : (this._buffers.push(null), this._process()));
          }, P.prototype.destroySoon = P.prototype.end, P.prototype._end = function() {
            this._reads.length > 0 && this.emit(
              "error",
              new Error("There are some read requests waiting on finished stream")
            ), this.destroy();
          }, P.prototype.destroy = function() {
            this._buffers && (this.writable = !1, this._reads = null, this._buffers = null, this.emit("close"));
          }, P.prototype._processReadAllowingLess = function(M) {
            this._reads.shift();
            var E = this._buffers[0];
            E.length > M.length ? (this._buffered -= M.length, this._buffers[0] = E.slice(M.length), M.func.call(this, E.slice(0, M.length))) : (this._buffered -= E.length, this._buffers.shift(), M.func.call(this, E));
          }, P.prototype._processRead = function(M) {
            this._reads.shift();
            for (var E = 0, x = 0, m = new r(M.length); E < M.length; ) {
              var I = this._buffers[x++], z = Math.min(I.length, M.length - E);
              I.copy(m, E, 0, z), E += z, z !== I.length && (this._buffers[--x] = I.slice(z));
            }
            x > 0 && this._buffers.splice(0, x), this._buffered -= M.length, M.func.call(this, m);
          }, P.prototype._process = function() {
            try {
              for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
                var M = this._reads[0];
                if (M.allowLess)
                  this._processReadAllowingLess(M);
                else if (this._buffered >= M.length)
                  this._processRead(M);
                else
                  break;
              }
              this._buffers && this._buffers.length > 0 && this._buffers[0] === null && this._end();
            } catch (E) {
              this.emit("error", E);
            }
          };
        }).call(this, te("_process"), te("buffer").Buffer);
      }, { _process: 133, buffer: 48, stream: 155, util: 186 }], 113: [function(te, Ee, $) {
        Ee.exports = {
          PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
          TYPE_IHDR: 1229472850,
          TYPE_IEND: 1229278788,
          TYPE_IDAT: 1229209940,
          TYPE_PLTE: 1347179589,
          TYPE_tRNS: 1951551059,
          // eslint-disable-line camelcase
          TYPE_gAMA: 1732332865,
          // eslint-disable-line camelcase
          // color-type bits
          COLORTYPE_GRAYSCALE: 0,
          COLORTYPE_PALETTE: 1,
          COLORTYPE_COLOR: 2,
          COLORTYPE_ALPHA: 4,
          // e.g. grayscale and alpha
          // color-type combinations
          COLORTYPE_PALETTE_COLOR: 3,
          COLORTYPE_COLOR_ALPHA: 6,
          COLORTYPE_TO_BPP_MAP: {
            0: 1,
            2: 3,
            3: 1,
            4: 2,
            6: 4
          },
          GAMMA_DIVISION: 1e5
        };
      }, {}], 114: [function(te, Ee, $) {
        var Q = [];
        (function() {
          for (var F = 0; F < 256; F++) {
            for (var H = F, P = 0; P < 8; P++)
              H & 1 ? H = 3988292384 ^ H >>> 1 : H = H >>> 1;
            Q[F] = H;
          }
        })();
        var r = Ee.exports = function() {
          this._crc = -1;
        };
        r.prototype.write = function(F) {
          for (var H = 0; H < F.length; H++)
            this._crc = Q[(this._crc ^ F[H]) & 255] ^ this._crc >>> 8;
          return !0;
        }, r.prototype.crc32 = function() {
          return this._crc ^ -1;
        }, r.crc32 = function(F) {
          for (var H = -1, P = 0; P < F.length; P++)
            H = Q[(H ^ F[P]) & 255] ^ H >>> 8;
          return H ^ -1;
        };
      }, {}], 115: [function(te, Ee, $) {
        (function(Q) {
          var r = te("./paeth-predictor");
          function F(B, N, U, V, W) {
            for (var q = 0; q < U; q++)
              V[W + q] = B[N + q];
          }
          function H(B, N, U) {
            for (var V = 0, W = N + U, q = N; q < W; q++)
              V += Math.abs(B[q]);
            return V;
          }
          function P(B, N, U, V, W, q) {
            for (var Y = 0; Y < U; Y++) {
              var re = Y >= q ? B[N + Y - q] : 0, se = B[N + Y] - re;
              V[W + Y] = se;
            }
          }
          function M(B, N, U, V) {
            for (var W = 0, q = 0; q < U; q++) {
              var Y = q >= V ? B[N + q - V] : 0, re = B[N + q] - Y;
              W += Math.abs(re);
            }
            return W;
          }
          function E(B, N, U, V, W) {
            for (var q = 0; q < U; q++) {
              var Y = N > 0 ? B[N + q - U] : 0, re = B[N + q] - Y;
              V[W + q] = re;
            }
          }
          function x(B, N, U) {
            for (var V = 0, W = N + U, q = N; q < W; q++) {
              var Y = N > 0 ? B[q - U] : 0, re = B[q] - Y;
              V += Math.abs(re);
            }
            return V;
          }
          function m(B, N, U, V, W, q) {
            for (var Y = 0; Y < U; Y++) {
              var re = Y >= q ? B[N + Y - q] : 0, se = N > 0 ? B[N + Y - U] : 0, ve = B[N + Y] - (re + se >> 1);
              V[W + Y] = ve;
            }
          }
          function I(B, N, U, V) {
            for (var W = 0, q = 0; q < U; q++) {
              var Y = q >= V ? B[N + q - V] : 0, re = N > 0 ? B[N + q - U] : 0, se = B[N + q] - (Y + re >> 1);
              W += Math.abs(se);
            }
            return W;
          }
          function z(B, N, U, V, W, q) {
            for (var Y = 0; Y < U; Y++) {
              var re = Y >= q ? B[N + Y - q] : 0, se = N > 0 ? B[N + Y - U] : 0, ve = N > 0 && Y >= q ? B[N + Y - (U + q)] : 0, ce = B[N + Y] - r(re, se, ve);
              V[W + Y] = ce;
            }
          }
          function w(B, N, U, V) {
            for (var W = 0, q = 0; q < U; q++) {
              var Y = q >= V ? B[N + q - V] : 0, re = N > 0 ? B[N + q - U] : 0, se = N > 0 && q >= V ? B[N + q - (U + V)] : 0, ve = B[N + q] - r(Y, re, se);
              W += Math.abs(ve);
            }
            return W;
          }
          var C = {
            0: F,
            1: P,
            2: E,
            3: m,
            4: z
          }, b = {
            0: H,
            1: M,
            2: x,
            3: I,
            4: w
          };
          Ee.exports = function(B, N, U, V, W) {
            var q;
            if (!("filterType" in V) || V.filterType === -1)
              q = [0, 1, 2, 3, 4];
            else if (typeof V.filterType == "number")
              q = [V.filterType];
            else
              throw new Error("unrecognised filter types");
            V.bitDepth === 16 && (W *= 2);
            for (var Y = N * W, re = 0, se = 0, ve = new Q((Y + 1) * U), ce = q[0], be = 0; be < U; be++) {
              if (q.length > 1)
                for (var Me = 1 / 0, xe = 0; xe < q.length; xe++) {
                  var le = b[q[xe]](B, se, Y, W);
                  le < Me && (ce = q[xe], Me = le);
                }
              ve[re] = ce, re++, C[ce](B, se, Y, ve, re, W), re += Y, se += Y;
            }
            return ve;
          };
        }).call(this, te("buffer").Buffer);
      }, { "./paeth-predictor": 124, buffer: 48 }], 116: [function(te, Ee, $) {
        (function(Q) {
          var r = te("util"), F = te("./chunkstream"), H = te("./filter-parse"), P = Ee.exports = function(M) {
            F.call(this);
            var E = [], x = this;
            this._filter = new H(M, {
              read: this.read.bind(this),
              write: function(m) {
                E.push(m);
              },
              complete: function() {
                x.emit("complete", Q.concat(E));
              }
            }), this._filter.start();
          };
          r.inherits(P, F);
        }).call(this, te("buffer").Buffer);
      }, { "./chunkstream": 112, "./filter-parse": 118, buffer: 48, util: 186 }], 117: [function(te, Ee, $) {
        (function(Q) {
          var r = te("./sync-reader"), F = te("./filter-parse");
          $.process = function(H, P) {
            var M = [], E = new r(H), x = new F(P, {
              read: E.read.bind(E),
              write: function(m) {
                M.push(m);
              },
              complete: function() {
              }
            });
            return x.start(), E.process(), Q.concat(M);
          };
        }).call(this, te("buffer").Buffer);
      }, { "./filter-parse": 118, "./sync-reader": 131, buffer: 48 }], 118: [function(te, Ee, $) {
        (function(Q) {
          var r = te("./interlace"), F = te("./paeth-predictor");
          function H(M, E, x) {
            var m = M * E;
            return x !== 8 && (m = Math.ceil(m / (8 / x))), m;
          }
          var P = Ee.exports = function(M, E) {
            var x = M.width, m = M.height, I = M.interlace, z = M.bpp, w = M.depth;
            if (this.read = E.read, this.write = E.write, this.complete = E.complete, this._imageIndex = 0, this._images = [], I)
              for (var C = r.getImagePasses(x, m), b = 0; b < C.length; b++)
                this._images.push({
                  byteWidth: H(C[b].width, z, w),
                  height: C[b].height,
                  lineIndex: 0
                });
            else
              this._images.push({
                byteWidth: H(x, z, w),
                height: m,
                lineIndex: 0
              });
            w === 8 ? this._xComparison = z : w === 16 ? this._xComparison = z * 2 : this._xComparison = 1;
          };
          P.prototype.start = function() {
            this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
          }, P.prototype._unFilterType1 = function(M, E, x) {
            for (var m = this._xComparison, I = m - 1, z = 0; z < x; z++) {
              var w = M[1 + z], C = z > I ? E[z - m] : 0;
              E[z] = w + C;
            }
          }, P.prototype._unFilterType2 = function(M, E, x) {
            for (var m = this._lastLine, I = 0; I < x; I++) {
              var z = M[1 + I], w = m ? m[I] : 0;
              E[I] = z + w;
            }
          }, P.prototype._unFilterType3 = function(M, E, x) {
            for (var m = this._xComparison, I = m - 1, z = this._lastLine, w = 0; w < x; w++) {
              var C = M[1 + w], b = z ? z[w] : 0, B = w > I ? E[w - m] : 0, N = Math.floor((B + b) / 2);
              E[w] = C + N;
            }
          }, P.prototype._unFilterType4 = function(M, E, x) {
            for (var m = this._xComparison, I = m - 1, z = this._lastLine, w = 0; w < x; w++) {
              var C = M[1 + w], b = z ? z[w] : 0, B = w > I ? E[w - m] : 0, N = w > I && z ? z[w - m] : 0, U = F(B, b, N);
              E[w] = C + U;
            }
          }, P.prototype._reverseFilterLine = function(M) {
            var E = M[0], x, m = this._images[this._imageIndex], I = m.byteWidth;
            if (E === 0)
              x = M.slice(1, I + 1);
            else
              switch (x = new Q(I), E) {
                case 1:
                  this._unFilterType1(M, x, I);
                  break;
                case 2:
                  this._unFilterType2(M, x, I);
                  break;
                case 3:
                  this._unFilterType3(M, x, I);
                  break;
                case 4:
                  this._unFilterType4(M, x, I);
                  break;
                default:
                  throw new Error("Unrecognised filter type - " + E);
              }
            this.write(x), m.lineIndex++, m.lineIndex >= m.height ? (this._lastLine = null, this._imageIndex++, m = this._images[this._imageIndex]) : this._lastLine = x, m ? this.read(m.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
          };
        }).call(this, te("buffer").Buffer);
      }, { "./interlace": 120, "./paeth-predictor": 124, buffer: 48 }], 119: [function(te, Ee, $) {
        (function(Q) {
          function r(P, M, E, x, m) {
            for (var I = 0, z = 0; z < x; z++)
              for (var w = 0; w < E; w++) {
                var C = m[P[I]];
                if (!C)
                  throw new Error("index " + P[I] + " not in palette");
                for (var b = 0; b < 4; b++)
                  M[I + b] = C[b];
                I += 4;
              }
          }
          function F(P, M, E, x, m) {
            for (var I = 0, z = 0; z < x; z++)
              for (var w = 0; w < E; w++) {
                var C = !1;
                if (m.length === 1 ? m[0] === P[I] && (C = !0) : m[0] === P[I] && m[1] === P[I + 1] && m[2] === P[I + 2] && (C = !0), C)
                  for (var b = 0; b < 4; b++)
                    M[I + b] = 0;
                I += 4;
              }
          }
          function H(P, M, E, x, m) {
            for (var I = 255, z = Math.pow(2, m) - 1, w = 0, C = 0; C < x; C++)
              for (var b = 0; b < E; b++) {
                for (var B = 0; B < 4; B++)
                  M[w + B] = Math.floor(P[w + B] * I / z + 0.5);
                w += 4;
              }
          }
          Ee.exports = function(P, M) {
            var E = M.depth, x = M.width, m = M.height, I = M.colorType, z = M.transColor, w = M.palette, C = P;
            return I === 3 ? r(P, C, x, m, w) : (z && F(P, C, x, m, z), E !== 8 && (E === 16 && (C = new Q(x * m * 4)), H(P, C, x, m, E))), C;
          };
        }).call(this, te("buffer").Buffer);
      }, { buffer: 48 }], 120: [function(te, Ee, $) {
        var Q = [
          {
            // pass 1 - 1px
            x: [0],
            y: [0]
          },
          {
            // pass 2 - 1px
            x: [4],
            y: [0]
          },
          {
            // pass 3 - 2px
            x: [0, 4],
            y: [4]
          },
          {
            // pass 4 - 4px
            x: [2, 6],
            y: [0, 4]
          },
          {
            // pass 5 - 8px
            x: [0, 2, 4, 6],
            y: [2, 6]
          },
          {
            // pass 6 - 16px
            x: [1, 3, 5, 7],
            y: [0, 2, 4, 6]
          },
          {
            // pass 7 - 32px
            x: [0, 1, 2, 3, 4, 5, 6, 7],
            y: [1, 3, 5, 7]
          }
        ];
        $.getImagePasses = function(r, F) {
          for (var H = [], P = r % 8, M = F % 8, E = (r - P) / 8, x = (F - M) / 8, m = 0; m < Q.length; m++) {
            for (var I = Q[m], z = E * I.x.length, w = x * I.y.length, C = 0; C < I.x.length && I.x[C] < P; C++)
              z++;
            for (C = 0; C < I.y.length && I.y[C] < M; C++)
              w++;
            z > 0 && w > 0 && H.push({ width: z, height: w, index: m });
          }
          return H;
        }, $.getInterlaceIterator = function(r) {
          return function(F, H, P) {
            var M = F % Q[P].x.length, E = (F - M) / Q[P].x.length * 8 + Q[P].x[M], x = H % Q[P].y.length, m = (H - x) / Q[P].y.length * 8 + Q[P].y[x];
            return E * 4 + m * r * 4;
          };
        };
      }, {}], 121: [function(te, Ee, $) {
        (function(Q) {
          var r = te("util"), F = te("stream"), H = te("./constants"), P = te("./packer"), M = Ee.exports = function(E) {
            F.call(this);
            var x = E || {};
            this._packer = new P(x), this._deflate = this._packer.createDeflate(), this.readable = !0;
          };
          r.inherits(M, F), M.prototype.pack = function(E, x, m, I) {
            this.emit("data", new Q(H.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(x, m)), I && this.emit("data", this._packer.packGAMA(I));
            var z = this._packer.filterData(E, x, m);
            this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", (function(w) {
              this.emit("data", this._packer.packIDAT(w));
            }).bind(this)), this._deflate.on("end", (function() {
              this.emit("data", this._packer.packIEND()), this.emit("end");
            }).bind(this)), this._deflate.end(z);
          };
        }).call(this, te("buffer").Buffer);
      }, { "./constants": 113, "./packer": 123, buffer: 48, stream: 155, util: 186 }], 122: [function(te, Ee, $) {
        (function(Q) {
          var r = !0, F = te("zlib");
          F.deflateSync || (r = !1);
          var H = te("./constants"), P = te("./packer");
          Ee.exports = function(M, E) {
            if (!r)
              throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            var x = E || {}, m = new P(x), I = [];
            I.push(new Q(H.PNG_SIGNATURE)), I.push(m.packIHDR(M.width, M.height)), M.gamma && I.push(m.packGAMA(M.gamma));
            var z = m.filterData(M.data, M.width, M.height), w = F.deflateSync(z, m.getDeflateOptions());
            if (z = null, !w || !w.length)
              throw new Error("bad png - invalid compressed data response");
            return I.push(m.packIDAT(w)), I.push(m.packIEND()), Q.concat(I);
          };
        }).call(this, te("buffer").Buffer);
      }, { "./constants": 113, "./packer": 123, buffer: 48, zlib: 35 }], 123: [function(te, Ee, $) {
        (function(Q) {
          var r = te("./constants"), F = te("./crc"), H = te("./bitpacker"), P = te("./filter-pack"), M = te("zlib"), E = Ee.exports = function(x) {
            if (this._options = x, x.deflateChunkSize = x.deflateChunkSize || 32 * 1024, x.deflateLevel = x.deflateLevel != null ? x.deflateLevel : 9, x.deflateStrategy = x.deflateStrategy != null ? x.deflateStrategy : 3, x.inputHasAlpha = x.inputHasAlpha != null ? x.inputHasAlpha : !0, x.deflateFactory = x.deflateFactory || M.createDeflate, x.bitDepth = x.bitDepth || 8, x.colorType = typeof x.colorType == "number" ? x.colorType : r.COLORTYPE_COLOR_ALPHA, x.inputColorType = typeof x.inputColorType == "number" ? x.inputColorType : r.COLORTYPE_COLOR_ALPHA, [
              r.COLORTYPE_GRAYSCALE,
              r.COLORTYPE_COLOR,
              r.COLORTYPE_COLOR_ALPHA,
              r.COLORTYPE_ALPHA
            ].indexOf(x.colorType) === -1)
              throw new Error("option color type:" + x.colorType + " is not supported at present");
            if ([
              r.COLORTYPE_GRAYSCALE,
              r.COLORTYPE_COLOR,
              r.COLORTYPE_COLOR_ALPHA,
              r.COLORTYPE_ALPHA
            ].indexOf(x.inputColorType) === -1)
              throw new Error("option input color type:" + x.inputColorType + " is not supported at present");
            if (x.bitDepth !== 8 && x.bitDepth !== 16)
              throw new Error("option bit depth:" + x.bitDepth + " is not supported at present");
          };
          E.prototype.getDeflateOptions = function() {
            return {
              chunkSize: this._options.deflateChunkSize,
              level: this._options.deflateLevel,
              strategy: this._options.deflateStrategy
            };
          }, E.prototype.createDeflate = function() {
            return this._options.deflateFactory(this.getDeflateOptions());
          }, E.prototype.filterData = function(x, m, I) {
            var z = H(x, m, I, this._options), w = r.COLORTYPE_TO_BPP_MAP[this._options.colorType], C = P(z, m, I, this._options, w);
            return C;
          }, E.prototype._packChunk = function(x, m) {
            var I = m ? m.length : 0, z = new Q(I + 12);
            return z.writeUInt32BE(I, 0), z.writeUInt32BE(x, 4), m && m.copy(z, 8), z.writeInt32BE(F.crc32(z.slice(4, z.length - 4)), z.length - 4), z;
          }, E.prototype.packGAMA = function(x) {
            var m = new Q(4);
            return m.writeUInt32BE(Math.floor(x * r.GAMMA_DIVISION), 0), this._packChunk(r.TYPE_gAMA, m);
          }, E.prototype.packIHDR = function(x, m) {
            var I = new Q(13);
            return I.writeUInt32BE(x, 0), I.writeUInt32BE(m, 4), I[8] = this._options.bitDepth, I[9] = this._options.colorType, I[10] = 0, I[11] = 0, I[12] = 0, this._packChunk(r.TYPE_IHDR, I);
          }, E.prototype.packIDAT = function(x) {
            return this._packChunk(r.TYPE_IDAT, x);
          }, E.prototype.packIEND = function() {
            return this._packChunk(r.TYPE_IEND, null);
          };
        }).call(this, te("buffer").Buffer);
      }, { "./bitpacker": 111, "./constants": 113, "./crc": 114, "./filter-pack": 115, buffer: 48, zlib: 35 }], 124: [function(te, Ee, $) {
        Ee.exports = function(r, F, H) {
          var P = r + F - H, M = Math.abs(P - r), E = Math.abs(P - F), x = Math.abs(P - H);
          return M <= E && M <= x ? r : E <= x ? F : H;
        };
      }, {}], 125: [function(te, Ee, $) {
        var Q = te("util"), r = te("zlib"), F = te("./chunkstream"), H = te("./filter-parse-async"), P = te("./parser"), M = te("./bitmapper"), E = te("./format-normaliser"), x = Ee.exports = function(m) {
          F.call(this), this._parser = new P(m, {
            read: this.read.bind(this),
            error: this._handleError.bind(this),
            metadata: this._handleMetaData.bind(this),
            gamma: this.emit.bind(this, "gamma"),
            palette: this._handlePalette.bind(this),
            transColor: this._handleTransColor.bind(this),
            finished: this._finished.bind(this),
            inflateData: this._inflateData.bind(this)
          }), this._options = m, this.writable = !0, this._parser.start();
        };
        Q.inherits(x, F), x.prototype._handleError = function(m) {
          this.emit("error", m), this.writable = !1, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
          })), this.errord = !0;
        }, x.prototype._inflateData = function(m) {
          if (!this._inflate)
            if (this._bitmapInfo.interlace)
              this._inflate = r.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
            else {
              var I = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1, z = I * this._bitmapInfo.height, w = Math.max(z, r.Z_MIN_CHUNK);
              this._inflate = r.createInflate({ chunkSize: w });
              var C = z, b = this.emit.bind(this, "error");
              this._inflate.on("error", function(N) {
                C && b(N);
              }), this._filter.on("complete", this._complete.bind(this));
              var B = this._filter.write.bind(this._filter);
              this._inflate.on("data", function(N) {
                C && (N.length > C && (N = N.slice(0, C)), C -= N.length, B(N));
              }), this._inflate.on("end", this._filter.end.bind(this._filter));
            }
          this._inflate.write(m);
        }, x.prototype._handleMetaData = function(m) {
          this.emit("metadata", m), this._bitmapInfo = Object.create(m), this._filter = new H(this._bitmapInfo);
        }, x.prototype._handleTransColor = function(m) {
          this._bitmapInfo.transColor = m;
        }, x.prototype._handlePalette = function(m) {
          this._bitmapInfo.palette = m;
        }, x.prototype._finished = function() {
          this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"), this.destroySoon());
        }, x.prototype._complete = function(m) {
          if (!this.errord) {
            try {
              var I = M.dataToBitMap(m, this._bitmapInfo), z = E(I, this._bitmapInfo);
              I = null;
            } catch (w) {
              this._handleError(w);
              return;
            }
            this.emit("parsed", z);
          }
        };
      }, { "./bitmapper": 110, "./chunkstream": 112, "./filter-parse-async": 116, "./format-normaliser": 119, "./parser": 127, util: 186, zlib: 35 }], 126: [function(te, Ee, $) {
        (function(Q) {
          var r = !0, F = te("zlib"), H = te("./sync-inflate");
          F.deflateSync || (r = !1);
          var P = te("./sync-reader"), M = te("./filter-parse-sync"), E = te("./parser"), x = te("./bitmapper"), m = te("./format-normaliser");
          Ee.exports = function(I, z) {
            if (!r)
              throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            var w;
            function C(De) {
              w = De;
            }
            var b;
            function B(De) {
              b = De;
            }
            function N(De) {
              b.transColor = De;
            }
            function U(De) {
              b.palette = De;
            }
            var V;
            function W(De) {
              V = De;
            }
            var q = [];
            function Y(De) {
              q.push(De);
            }
            var re = new P(I), se = new E(z, {
              read: re.read.bind(re),
              error: C,
              metadata: B,
              gamma: W,
              palette: U,
              transColor: N,
              inflateData: Y
            });
            if (se.start(), re.process(), w)
              throw w;
            var ve = Q.concat(q);
            q.length = 0;
            var ce;
            if (b.interlace)
              ce = F.inflateSync(ve);
            else {
              var be = (b.width * b.bpp * b.depth + 7 >> 3) + 1, Me = be * b.height;
              ce = H(ve, { chunkSize: Me, maxLength: Me });
            }
            if (ve = null, !ce || !ce.length)
              throw new Error("bad png - invalid inflate data response");
            var xe = M.process(ce, b);
            ve = null;
            var le = x.dataToBitMap(xe, b);
            xe = null;
            var de = m(le, b);
            return b.data = de, b.gamma = V || 0, b;
          };
        }).call(this, te("buffer").Buffer);
      }, { "./bitmapper": 110, "./filter-parse-sync": 117, "./format-normaliser": 119, "./parser": 127, "./sync-inflate": 130, "./sync-reader": 131, buffer: 48, zlib: 35 }], 127: [function(te, Ee, $) {
        (function(Q) {
          var r = te("./constants"), F = te("./crc"), H = Ee.exports = function(P, M) {
            this._options = P, P.checkCRC = P.checkCRC !== !1, this._hasIHDR = !1, this._hasIEND = !1, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[r.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[r.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[r.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[r.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[r.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[r.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = M.read, this.error = M.error, this.metadata = M.metadata, this.gamma = M.gamma, this.transColor = M.transColor, this.palette = M.palette, this.parsed = M.parsed, this.inflateData = M.inflateData, this.finished = M.finished;
          };
          H.prototype.start = function() {
            this.read(
              r.PNG_SIGNATURE.length,
              this._parseSignature.bind(this)
            );
          }, H.prototype._parseSignature = function(P) {
            for (var M = r.PNG_SIGNATURE, E = 0; E < M.length; E++)
              if (P[E] !== M[E]) {
                this.error(new Error("Invalid file signature"));
                return;
              }
            this.read(8, this._parseChunkBegin.bind(this));
          }, H.prototype._parseChunkBegin = function(P) {
            for (var M = P.readUInt32BE(0), E = P.readUInt32BE(4), x = "", m = 4; m < 8; m++)
              x += String.fromCharCode(P[m]);
            var I = !!(P[4] & 32);
            if (!this._hasIHDR && E !== r.TYPE_IHDR) {
              this.error(new Error("Expected IHDR on beggining"));
              return;
            }
            if (this._crc = new F(), this._crc.write(new Q(x)), this._chunks[E])
              return this._chunks[E](M);
            if (!I) {
              this.error(new Error("Unsupported critical chunk type " + x));
              return;
            }
            this.read(M + 4, this._skipChunk.bind(this));
          }, H.prototype._skipChunk = function() {
            this.read(8, this._parseChunkBegin.bind(this));
          }, H.prototype._handleChunkEnd = function() {
            this.read(4, this._parseChunkEnd.bind(this));
          }, H.prototype._parseChunkEnd = function(P) {
            var M = P.readInt32BE(0), E = this._crc.crc32();
            if (this._options.checkCRC && E !== M) {
              this.error(new Error("Crc error - " + M + " - " + E));
              return;
            }
            this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
          }, H.prototype._handleIHDR = function(P) {
            this.read(P, this._parseIHDR.bind(this));
          }, H.prototype._parseIHDR = function(P) {
            this._crc.write(P);
            var M = P.readUInt32BE(0), E = P.readUInt32BE(4), x = P[8], m = P[9], I = P[10], z = P[11], w = P[12];
            if (x !== 8 && x !== 4 && x !== 2 && x !== 1 && x !== 16) {
              this.error(new Error("Unsupported bit depth " + x));
              return;
            }
            if (!(m in r.COLORTYPE_TO_BPP_MAP)) {
              this.error(new Error("Unsupported color type"));
              return;
            }
            if (I !== 0) {
              this.error(new Error("Unsupported compression method"));
              return;
            }
            if (z !== 0) {
              this.error(new Error("Unsupported filter method"));
              return;
            }
            if (w !== 0 && w !== 1) {
              this.error(new Error("Unsupported interlace method"));
              return;
            }
            this._colorType = m;
            var C = r.COLORTYPE_TO_BPP_MAP[this._colorType];
            this._hasIHDR = !0, this.metadata({
              width: M,
              height: E,
              depth: x,
              interlace: !!w,
              palette: !!(m & r.COLORTYPE_PALETTE),
              color: !!(m & r.COLORTYPE_COLOR),
              alpha: !!(m & r.COLORTYPE_ALPHA),
              bpp: C,
              colorType: m
            }), this._handleChunkEnd();
          }, H.prototype._handlePLTE = function(P) {
            this.read(P, this._parsePLTE.bind(this));
          }, H.prototype._parsePLTE = function(P) {
            this._crc.write(P);
            for (var M = Math.floor(P.length / 3), E = 0; E < M; E++)
              this._palette.push([
                P[E * 3],
                P[E * 3 + 1],
                P[E * 3 + 2],
                255
              ]);
            this.palette(this._palette), this._handleChunkEnd();
          }, H.prototype._handleTRNS = function(P) {
            this.read(P, this._parseTRNS.bind(this));
          }, H.prototype._parseTRNS = function(P) {
            if (this._crc.write(P), this._colorType === r.COLORTYPE_PALETTE_COLOR) {
              if (this._palette.length === 0) {
                this.error(new Error("Transparency chunk must be after palette"));
                return;
              }
              if (P.length > this._palette.length) {
                this.error(new Error("More transparent colors than palette size"));
                return;
              }
              for (var M = 0; M < P.length; M++)
                this._palette[M][3] = P[M];
              this.palette(this._palette);
            }
            this._colorType === r.COLORTYPE_GRAYSCALE && this.transColor([P.readUInt16BE(0)]), this._colorType === r.COLORTYPE_COLOR && this.transColor([P.readUInt16BE(0), P.readUInt16BE(2), P.readUInt16BE(4)]), this._handleChunkEnd();
          }, H.prototype._handleGAMA = function(P) {
            this.read(P, this._parseGAMA.bind(this));
          }, H.prototype._parseGAMA = function(P) {
            this._crc.write(P), this.gamma(P.readUInt32BE(0) / r.GAMMA_DIVISION), this._handleChunkEnd();
          }, H.prototype._handleIDAT = function(P) {
            this.read(-P, this._parseIDAT.bind(this, P));
          }, H.prototype._parseIDAT = function(P, M) {
            if (this._crc.write(M), this._colorType === r.COLORTYPE_PALETTE_COLOR && this._palette.length === 0)
              throw new Error("Expected palette not found");
            this.inflateData(M);
            var E = P - M.length;
            E > 0 ? this._handleIDAT(E) : this._handleChunkEnd();
          }, H.prototype._handleIEND = function(P) {
            this.read(P, this._parseIEND.bind(this));
          }, H.prototype._parseIEND = function(P) {
            this._crc.write(P), this._hasIEND = !0, this._handleChunkEnd(), this.finished && this.finished();
          };
        }).call(this, te("buffer").Buffer);
      }, { "./constants": 113, "./crc": 114, buffer: 48 }], 128: [function(te, Ee, $) {
        var Q = te("./parser-sync"), r = te("./packer-sync");
        $.read = function(F, H) {
          return Q(F, H || {});
        }, $.write = function(F, H) {
          return r(F, H);
        };
      }, { "./packer-sync": 122, "./parser-sync": 126 }], 129: [function(te, Ee, $) {
        (function(Q, r) {
          var F = te("util"), H = te("stream"), P = te("./parser-async"), M = te("./packer-async"), E = te("./png-sync"), x = $.PNG = function(m) {
            H.call(this), m = m || {}, this.width = m.width | 0, this.height = m.height | 0, this.data = this.width > 0 && this.height > 0 ? new r(4 * this.width * this.height) : null, m.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = !0, this._parser = new P(m), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", (function(I) {
              this.data = I, this.emit("parsed", I);
            }).bind(this)), this._packer = new M(m), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
          };
          F.inherits(x, H), x.sync = E, x.prototype.pack = function() {
            return !this.data || !this.data.length ? (this.emit("error", "No data provided"), this) : (Q.nextTick((function() {
              this._packer.pack(this.data, this.width, this.height, this.gamma);
            }).bind(this)), this);
          }, x.prototype.parse = function(m, I) {
            if (I) {
              var z, w;
              z = (function(C) {
                this.removeListener("error", w), this.data = C, I(null, this);
              }).bind(this), w = (function(C) {
                this.removeListener("parsed", z), I(C, null);
              }).bind(this), this.once("parsed", z), this.once("error", w);
            }
            return this.end(m), this;
          }, x.prototype.write = function(m) {
            return this._parser.write(m), !0;
          }, x.prototype.end = function(m) {
            this._parser.end(m);
          }, x.prototype._metadata = function(m) {
            this.width = m.width, this.height = m.height, this.emit("metadata", m);
          }, x.prototype._gamma = function(m) {
            this.gamma = m;
          }, x.prototype._handleClose = function() {
            !this._parser.writable && !this._packer.readable && this.emit("close");
          }, x.bitblt = function(m, I, z, w, C, b, B, N) {
            if (z |= 0, w |= 0, C |= 0, b |= 0, B |= 0, N |= 0, z > m.width || w > m.height || z + C > m.width || w + b > m.height)
              throw new Error("bitblt reading outside image");
            if (B > I.width || N > I.height || B + C > I.width || N + b > I.height)
              throw new Error("bitblt writing outside image");
            for (var U = 0; U < b; U++)
              m.data.copy(
                I.data,
                (N + U) * I.width + B << 2,
                (w + U) * m.width + z << 2,
                (w + U) * m.width + z + C << 2
              );
          }, x.prototype.bitblt = function(m, I, z, w, C, b, B) {
            return x.bitblt(this, m, I, z, w, C, b, B), this;
          }, x.adjustGamma = function(m) {
            if (m.gamma) {
              for (var I = 0; I < m.height; I++)
                for (var z = 0; z < m.width; z++)
                  for (var w = m.width * I + z << 2, C = 0; C < 3; C++) {
                    var b = m.data[w + C] / 255;
                    b = Math.pow(b, 1 / 2.2 / m.gamma), m.data[w + C] = Math.round(b * 255);
                  }
              m.gamma = 0;
            }
          }, x.prototype.adjustGamma = function() {
            x.adjustGamma(this);
          };
        }).call(this, te("_process"), te("buffer").Buffer);
      }, { "./packer-async": 121, "./parser-async": 125, "./png-sync": 128, _process: 133, buffer: 48, stream: 155, util: 186 }], 130: [function(te, Ee, $) {
        (function(Q, r) {
          var F = te("assert").ok, H = te("zlib"), P = te("util"), M = te("buffer").kMaxLength;
          function E(w) {
            if (!(this instanceof E))
              return new E(w);
            w && w.chunkSize < H.Z_MIN_CHUNK && (w.chunkSize = H.Z_MIN_CHUNK), H.Inflate.call(this, w), this._offset = this._offset === void 0 ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, w && w.maxLength != null && (this._maxLength = w.maxLength);
          }
          function x(w) {
            return new E(w);
          }
          function m(w, C) {
            w._handle && (w._handle.close(), w._handle = null);
          }
          E.prototype._processChunk = function(w, C, b) {
            if (typeof b == "function")
              return H.Inflate._processChunk.call(this, w, C, b);
            var B = this, N = w && w.length, U = this._chunkSize - this._offset, V = this._maxLength, W = 0, q = [], Y = 0, re;
            this.on("error", function(be) {
              re = be;
            });
            function se(be, Me) {
              if (!B._hadError) {
                var xe = U - Me;
                if (F(xe >= 0, "have should not go down"), xe > 0) {
                  var le = B._buffer.slice(B._offset, B._offset + xe);
                  if (B._offset += xe, le.length > V && (le = le.slice(0, V)), q.push(le), Y += le.length, V -= le.length, V === 0)
                    return !1;
                }
                return (Me === 0 || B._offset >= B._chunkSize) && (U = B._chunkSize, B._offset = 0, B._buffer = r.allocUnsafe(B._chunkSize)), Me === 0 ? (W += N - be, N = be, !0) : !1;
              }
            }
            F(this._handle, "zlib binding closed");
            do {
              var ve = this._handle.writeSync(
                C,
                w,
                // in
                W,
                // in_off
                N,
                // in_len
                this._buffer,
                // out
                this._offset,
                //out_off
                U
              );
              ve = ve || this._writeState;
            } while (!this._hadError && se(ve[0], ve[1]));
            if (this._hadError)
              throw re;
            if (Y >= M)
              throw m(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + M.toString(16) + " bytes");
            var ce = r.concat(q, Y);
            return m(this), ce;
          }, P.inherits(E, H.Inflate);
          function I(w, C) {
            if (typeof C == "string" && (C = r.from(C)), !(C instanceof r))
              throw new TypeError("Not a string or buffer");
            var b = w._finishFlushFlag;
            return b == null && (b = H.Z_FINISH), w._processChunk(C, b);
          }
          function z(w, C) {
            return I(new E(C), w);
          }
          Ee.exports = $ = z, $.Inflate = E, $.createInflate = x, $.inflateSync = z;
        }).call(this, te("_process"), te("buffer").Buffer);
      }, { _process: 133, assert: 25, buffer: 48, util: 186, zlib: 35 }], 131: [function(te, Ee, $) {
        var Q = Ee.exports = function(r) {
          this._buffer = r, this._reads = [];
        };
        Q.prototype.read = function(r, F) {
          this._reads.push({
            length: Math.abs(r),
            // if length < 0 then at most this length
            allowLess: r < 0,
            func: F
          });
        }, Q.prototype.process = function() {
          for (; this._reads.length > 0 && this._buffer.length; ) {
            var r = this._reads[0];
            if (this._buffer.length && (this._buffer.length >= r.length || r.allowLess)) {
              this._reads.shift();
              var F = this._buffer;
              this._buffer = F.slice(r.length), r.func.call(this, F.slice(0, r.length));
            } else
              break;
          }
          if (this._reads.length > 0)
            return new Error("There are some read requests waitng on finished stream");
          if (this._buffer.length > 0)
            return new Error("unrecognised content at end of stream");
        };
      }, {}], 132: [function(te, Ee, $) {
        (function(Q) {
          typeof Q > "u" || !Q.version || Q.version.indexOf("v0.") === 0 || Q.version.indexOf("v1.") === 0 && Q.version.indexOf("v1.8.") !== 0 ? Ee.exports = { nextTick: r } : Ee.exports = Q;
          function r(F, H, P, M) {
            if (typeof F != "function")
              throw new TypeError('"callback" argument must be a function');
            var E = arguments.length, x, m;
            switch (E) {
              case 0:
              case 1:
                return Q.nextTick(F);
              case 2:
                return Q.nextTick(function() {
                  F.call(null, H);
                });
              case 3:
                return Q.nextTick(function() {
                  F.call(null, H, P);
                });
              case 4:
                return Q.nextTick(function() {
                  F.call(null, H, P, M);
                });
              default:
                for (x = new Array(E - 1), m = 0; m < x.length; )
                  x[m++] = arguments[m];
                return Q.nextTick(function() {
                  F.apply(null, x);
                });
            }
          }
        }).call(this, te("_process"));
      }, { _process: 133 }], 133: [function(te, Ee, $) {
        var Q = Ee.exports = {}, r, F;
        function H() {
          throw new Error("setTimeout has not been defined");
        }
        function P() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? r = setTimeout : r = H;
          } catch {
            r = H;
          }
          try {
            typeof clearTimeout == "function" ? F = clearTimeout : F = P;
          } catch {
            F = P;
          }
        })();
        function M(N) {
          if (r === setTimeout)
            return setTimeout(N, 0);
          if ((r === H || !r) && setTimeout)
            return r = setTimeout, setTimeout(N, 0);
          try {
            return r(N, 0);
          } catch {
            try {
              return r.call(null, N, 0);
            } catch {
              return r.call(this, N, 0);
            }
          }
        }
        function E(N) {
          if (F === clearTimeout)
            return clearTimeout(N);
          if ((F === P || !F) && clearTimeout)
            return F = clearTimeout, clearTimeout(N);
          try {
            return F(N);
          } catch {
            try {
              return F.call(null, N);
            } catch {
              return F.call(this, N);
            }
          }
        }
        var x = [], m = !1, I, z = -1;
        function w() {
          !m || !I || (m = !1, I.length ? x = I.concat(x) : z = -1, x.length && C());
        }
        function C() {
          if (!m) {
            var N = M(w);
            m = !0;
            for (var U = x.length; U; ) {
              for (I = x, x = []; ++z < U; )
                I && I[z].run();
              z = -1, U = x.length;
            }
            I = null, m = !1, E(N);
          }
        }
        Q.nextTick = function(N) {
          var U = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var V = 1; V < arguments.length; V++)
              U[V - 1] = arguments[V];
          x.push(new b(N, U)), x.length === 1 && !m && M(C);
        };
        function b(N, U) {
          this.fun = N, this.array = U;
        }
        b.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, Q.title = "browser", Q.browser = !0, Q.env = {}, Q.argv = [], Q.version = "", Q.versions = {};
        function B() {
        }
        Q.on = B, Q.addListener = B, Q.once = B, Q.off = B, Q.removeListener = B, Q.removeAllListeners = B, Q.emit = B, Q.prependListener = B, Q.prependOnceListener = B, Q.listeners = function(N) {
          return [];
        }, Q.binding = function(N) {
          throw new Error("process.binding is not supported");
        }, Q.cwd = function() {
          return "/";
        }, Q.chdir = function(N) {
          throw new Error("process.chdir is not supported");
        }, Q.umask = function() {
          return 0;
        };
      }, {}], 134: [function(te, Ee, $) {
        (function(Q) {
          (function(r) {
            var F = typeof $ == "object" && $ && !$.nodeType && $, H = typeof Ee == "object" && Ee && !Ee.nodeType && Ee, P = typeof Q == "object" && Q;
            (P.global === P || P.window === P || P.self === P) && (r = P);
            var M, E = 2147483647, x = 36, m = 1, I = 26, z = 38, w = 700, C = 72, b = 128, B = "-", N = /^xn--/, U = /[^\x20-\x7E]/, V = /[\x2E\u3002\uFF0E\uFF61]/g, W = {
              overflow: "Overflow: input needs wider integers to process",
              "not-basic": "Illegal input >= 0x80 (not a basic code point)",
              "invalid-input": "Invalid input"
            }, q = x - m, Y = Math.floor, re = String.fromCharCode, se;
            function ve(je) {
              throw new RangeError(W[je]);
            }
            function ce(je, Fe) {
              for (var $e = je.length, ct = []; $e--; )
                ct[$e] = Fe(je[$e]);
              return ct;
            }
            function be(je, Fe) {
              var $e = je.split("@"), ct = "";
              $e.length > 1 && (ct = $e[0] + "@", je = $e[1]), je = je.replace(V, ".");
              var wt = je.split("."), Oe = ce(wt, Fe).join(".");
              return ct + Oe;
            }
            function Me(je) {
              for (var Fe = [], $e = 0, ct = je.length, wt, Oe; $e < ct; )
                wt = je.charCodeAt($e++), wt >= 55296 && wt <= 56319 && $e < ct ? (Oe = je.charCodeAt($e++), (Oe & 64512) == 56320 ? Fe.push(((wt & 1023) << 10) + (Oe & 1023) + 65536) : (Fe.push(wt), $e--)) : Fe.push(wt);
              return Fe;
            }
            function xe(je) {
              return ce(je, function(Fe) {
                var $e = "";
                return Fe > 65535 && (Fe -= 65536, $e += re(Fe >>> 10 & 1023 | 55296), Fe = 56320 | Fe & 1023), $e += re(Fe), $e;
              }).join("");
            }
            function le(je) {
              return je - 48 < 10 ? je - 22 : je - 65 < 26 ? je - 65 : je - 97 < 26 ? je - 97 : x;
            }
            function de(je, Fe) {
              return je + 22 + 75 * (je < 26) - ((Fe != 0) << 5);
            }
            function De(je, Fe, $e) {
              var ct = 0;
              for (je = $e ? Y(je / w) : je >> 1, je += Y(je / Fe); je > q * I >> 1; ct += x)
                je = Y(je / q);
              return Y(ct + (q + 1) * je / (je + z));
            }
            function ze(je) {
              var Fe = [], $e = je.length, ct, wt = 0, Oe = b, Ct = C, Xt, vt, Ye, qe, rt, it, Ae, _e, fe;
              for (Xt = je.lastIndexOf(B), Xt < 0 && (Xt = 0), vt = 0; vt < Xt; ++vt)
                je.charCodeAt(vt) >= 128 && ve("not-basic"), Fe.push(je.charCodeAt(vt));
              for (Ye = Xt > 0 ? Xt + 1 : 0; Ye < $e; ) {
                for (qe = wt, rt = 1, it = x; Ye >= $e && ve("invalid-input"), Ae = le(je.charCodeAt(Ye++)), (Ae >= x || Ae > Y((E - wt) / rt)) && ve("overflow"), wt += Ae * rt, _e = it <= Ct ? m : it >= Ct + I ? I : it - Ct, !(Ae < _e); it += x)
                  fe = x - _e, rt > Y(E / fe) && ve("overflow"), rt *= fe;
                ct = Fe.length + 1, Ct = De(wt - qe, ct, qe == 0), Y(wt / ct) > E - Oe && ve("overflow"), Oe += Y(wt / ct), wt %= ct, Fe.splice(wt++, 0, Oe);
              }
              return xe(Fe);
            }
            function Ze(je) {
              var Fe, $e, ct, wt, Oe, Ct, Xt, vt, Ye, qe, rt, it = [], Ae, _e, fe, We;
              for (je = Me(je), Ae = je.length, Fe = b, $e = 0, Oe = C, Ct = 0; Ct < Ae; ++Ct)
                rt = je[Ct], rt < 128 && it.push(re(rt));
              for (ct = wt = it.length, wt && it.push(B); ct < Ae; ) {
                for (Xt = E, Ct = 0; Ct < Ae; ++Ct)
                  rt = je[Ct], rt >= Fe && rt < Xt && (Xt = rt);
                for (_e = ct + 1, Xt - Fe > Y((E - $e) / _e) && ve("overflow"), $e += (Xt - Fe) * _e, Fe = Xt, Ct = 0; Ct < Ae; ++Ct)
                  if (rt = je[Ct], rt < Fe && ++$e > E && ve("overflow"), rt == Fe) {
                    for (vt = $e, Ye = x; qe = Ye <= Oe ? m : Ye >= Oe + I ? I : Ye - Oe, !(vt < qe); Ye += x)
                      We = vt - qe, fe = x - qe, it.push(
                        re(de(qe + We % fe, 0))
                      ), vt = Y(We / fe);
                    it.push(re(de(vt, 0))), Oe = De($e, _e, ct == wt), $e = 0, ++ct;
                  }
                ++$e, ++Fe;
              }
              return it.join("");
            }
            function Ue(je) {
              return be(je, function(Fe) {
                return N.test(Fe) ? ze(Fe.slice(4).toLowerCase()) : Fe;
              });
            }
            function Ie(je) {
              return be(je, function(Fe) {
                return U.test(Fe) ? "xn--" + Ze(Fe) : Fe;
              });
            }
            if (M = {
              /**
               * A string representing the current Punycode.js version number.
               * @memberOf punycode
               * @type String
               */
              version: "1.4.1",
              /**
               * An object of methods to convert from JavaScript's internal character
               * representation (UCS-2) to Unicode code points, and back.
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode
               * @type Object
               */
              ucs2: {
                decode: Me,
                encode: xe
              },
              decode: ze,
              encode: Ze,
              toASCII: Ie,
              toUnicode: Ue
            }, F && H)
              if (Ee.exports == F)
                H.exports = M;
              else
                for (se in M)
                  M.hasOwnProperty(se) && (F[se] = M[se]);
            else
              r.punycode = M;
          })(this);
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {});
      }, {}], 135: [function(te, Ee, $) {
        function Q(F, H) {
          return Object.prototype.hasOwnProperty.call(F, H);
        }
        Ee.exports = function(F, H, P, M) {
          H = H || "&", P = P || "=";
          var E = {};
          if (typeof F != "string" || F.length === 0)
            return E;
          var x = /\+/g;
          F = F.split(H);
          var m = 1e3;
          M && typeof M.maxKeys == "number" && (m = M.maxKeys);
          var I = F.length;
          m > 0 && I > m && (I = m);
          for (var z = 0; z < I; ++z) {
            var w = F[z].replace(x, "%20"), C = w.indexOf(P), b, B, N, U;
            C >= 0 ? (b = w.substr(0, C), B = w.substr(C + 1)) : (b = w, B = ""), N = decodeURIComponent(b), U = decodeURIComponent(B), Q(E, N) ? r(E[N]) ? E[N].push(U) : E[N] = [E[N], U] : E[N] = U;
          }
          return E;
        };
        var r = Array.isArray || function(F) {
          return Object.prototype.toString.call(F) === "[object Array]";
        };
      }, {}], 136: [function(te, Ee, $) {
        var Q = function(P) {
          switch (typeof P) {
            case "string":
              return P;
            case "boolean":
              return P ? "true" : "false";
            case "number":
              return isFinite(P) ? P : "";
            default:
              return "";
          }
        };
        Ee.exports = function(P, M, E, x) {
          return M = M || "&", E = E || "=", P === null && (P = void 0), typeof P == "object" ? F(H(P), function(m) {
            var I = encodeURIComponent(Q(m)) + E;
            return r(P[m]) ? F(P[m], function(z) {
              return I + encodeURIComponent(Q(z));
            }).join(M) : I + encodeURIComponent(Q(P[m]));
          }).join(M) : x ? encodeURIComponent(Q(x)) + E + encodeURIComponent(Q(P)) : "";
        };
        var r = Array.isArray || function(P) {
          return Object.prototype.toString.call(P) === "[object Array]";
        };
        function F(P, M) {
          if (P.map) return P.map(M);
          for (var E = [], x = 0; x < P.length; x++)
            E.push(M(P[x], x));
          return E;
        }
        var H = Object.keys || function(P) {
          var M = [];
          for (var E in P)
            Object.prototype.hasOwnProperty.call(P, E) && M.push(E);
          return M;
        };
      }, {}], 137: [function(te, Ee, $) {
        $.decode = $.parse = te("./decode"), $.encode = $.stringify = te("./encode");
      }, { "./decode": 135, "./encode": 136 }], 138: [function(te, Ee, $) {
        Ee.exports = te("./lib/_stream_duplex.js");
      }, { "./lib/_stream_duplex.js": 139 }], 139: [function(te, Ee, $) {
        var Q = te("process-nextick-args"), r = Object.keys || function(w) {
          var C = [];
          for (var b in w)
            C.push(b);
          return C;
        };
        Ee.exports = m;
        var F = te("core-util-is");
        F.inherits = te("inherits");
        var H = te("./_stream_readable"), P = te("./_stream_writable");
        F.inherits(m, H);
        for (var M = r(P.prototype), E = 0; E < M.length; E++) {
          var x = M[E];
          m.prototype[x] || (m.prototype[x] = P.prototype[x]);
        }
        function m(w) {
          if (!(this instanceof m)) return new m(w);
          H.call(this, w), P.call(this, w), w && w.readable === !1 && (this.readable = !1), w && w.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, w && w.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", I);
        }
        Object.defineProperty(m.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: !1,
          get: function() {
            return this._writableState.highWaterMark;
          }
        });
        function I() {
          this.allowHalfOpen || this._writableState.ended || Q.nextTick(z, this);
        }
        function z(w) {
          w.end();
        }
        Object.defineProperty(m.prototype, "destroyed", {
          get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
          },
          set: function(w) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = w, this._writableState.destroyed = w);
          }
        }), m.prototype._destroy = function(w, C) {
          this.push(null), this.end(), Q.nextTick(C, w);
        };
      }, { "./_stream_readable": 141, "./_stream_writable": 143, "core-util-is": 51, inherits: 75, "process-nextick-args": 132 }], 140: [function(te, Ee, $) {
        Ee.exports = F;
        var Q = te("./_stream_transform"), r = te("core-util-is");
        r.inherits = te("inherits"), r.inherits(F, Q);
        function F(H) {
          if (!(this instanceof F)) return new F(H);
          Q.call(this, H);
        }
        F.prototype._transform = function(H, P, M) {
          M(null, H);
        };
      }, { "./_stream_transform": 142, "core-util-is": 51, inherits: 75 }], 141: [function(te, Ee, $) {
        (function(Q, r) {
          var F = te("process-nextick-args");
          Ee.exports = Y;
          var H = te("isarray"), P;
          Y.ReadableState = q, te("events").EventEmitter;
          var M = function(qe, rt) {
            return qe.listeners(rt).length;
          }, E = te("./internal/streams/stream"), x = te("safe-buffer").Buffer, m = r.Uint8Array || function() {
          };
          function I(qe) {
            return x.from(qe);
          }
          function z(qe) {
            return x.isBuffer(qe) || qe instanceof m;
          }
          var w = te("core-util-is");
          w.inherits = te("inherits");
          var C = te("util"), b = void 0;
          C && C.debuglog ? b = C.debuglog("stream") : b = function() {
          };
          var B = te("./internal/streams/BufferList"), N = te("./internal/streams/destroy"), U;
          w.inherits(Y, E);
          var V = ["error", "close", "destroy", "pause", "resume"];
          function W(qe, rt, it) {
            if (typeof qe.prependListener == "function") return qe.prependListener(rt, it);
            !qe._events || !qe._events[rt] ? qe.on(rt, it) : H(qe._events[rt]) ? qe._events[rt].unshift(it) : qe._events[rt] = [it, qe._events[rt]];
          }
          function q(qe, rt) {
            P = P || te("./_stream_duplex"), qe = qe || {};
            var it = rt instanceof P;
            this.objectMode = !!qe.objectMode, it && (this.objectMode = this.objectMode || !!qe.readableObjectMode);
            var Ae = qe.highWaterMark, _e = qe.readableHighWaterMark, fe = this.objectMode ? 16 : 16 * 1024;
            Ae || Ae === 0 ? this.highWaterMark = Ae : it && (_e || _e === 0) ? this.highWaterMark = _e : this.highWaterMark = fe, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new B(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = qe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, qe.encoding && (U || (U = te("string_decoder/").StringDecoder), this.decoder = new U(qe.encoding), this.encoding = qe.encoding);
          }
          function Y(qe) {
            if (P = P || te("./_stream_duplex"), !(this instanceof Y)) return new Y(qe);
            this._readableState = new q(qe, this), this.readable = !0, qe && (typeof qe.read == "function" && (this._read = qe.read), typeof qe.destroy == "function" && (this._destroy = qe.destroy)), E.call(this);
          }
          Object.defineProperty(Y.prototype, "destroyed", {
            get: function() {
              return this._readableState === void 0 ? !1 : this._readableState.destroyed;
            },
            set: function(qe) {
              this._readableState && (this._readableState.destroyed = qe);
            }
          }), Y.prototype.destroy = N.destroy, Y.prototype._undestroy = N.undestroy, Y.prototype._destroy = function(qe, rt) {
            this.push(null), rt(qe);
          }, Y.prototype.push = function(qe, rt) {
            var it = this._readableState, Ae;
            return it.objectMode ? Ae = !0 : typeof qe == "string" && (rt = rt || it.defaultEncoding, rt !== it.encoding && (qe = x.from(qe, rt), rt = ""), Ae = !0), re(this, qe, rt, !1, Ae);
          }, Y.prototype.unshift = function(qe) {
            return re(this, qe, null, !0, !1);
          };
          function re(qe, rt, it, Ae, _e) {
            var fe = qe._readableState;
            if (rt === null)
              fe.reading = !1, le(qe, fe);
            else {
              var We;
              _e || (We = ve(fe, rt)), We ? qe.emit("error", We) : fe.objectMode || rt && rt.length > 0 ? (typeof rt != "string" && !fe.objectMode && Object.getPrototypeOf(rt) !== x.prototype && (rt = I(rt)), Ae ? fe.endEmitted ? qe.emit("error", new Error("stream.unshift() after end event")) : se(qe, fe, rt, !0) : fe.ended ? qe.emit("error", new Error("stream.push() after EOF")) : (fe.reading = !1, fe.decoder && !it ? (rt = fe.decoder.write(rt), fe.objectMode || rt.length !== 0 ? se(qe, fe, rt, !1) : ze(qe, fe)) : se(qe, fe, rt, !1))) : Ae || (fe.reading = !1);
            }
            return ce(fe);
          }
          function se(qe, rt, it, Ae) {
            rt.flowing && rt.length === 0 && !rt.sync ? (qe.emit("data", it), qe.read(0)) : (rt.length += rt.objectMode ? 1 : it.length, Ae ? rt.buffer.unshift(it) : rt.buffer.push(it), rt.needReadable && de(qe)), ze(qe, rt);
          }
          function ve(qe, rt) {
            var it;
            return !z(rt) && typeof rt != "string" && rt !== void 0 && !qe.objectMode && (it = new TypeError("Invalid non-string/buffer chunk")), it;
          }
          function ce(qe) {
            return !qe.ended && (qe.needReadable || qe.length < qe.highWaterMark || qe.length === 0);
          }
          Y.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, Y.prototype.setEncoding = function(qe) {
            return U || (U = te("string_decoder/").StringDecoder), this._readableState.decoder = new U(qe), this._readableState.encoding = qe, this;
          };
          var be = 8388608;
          function Me(qe) {
            return qe >= be ? qe = be : (qe--, qe |= qe >>> 1, qe |= qe >>> 2, qe |= qe >>> 4, qe |= qe >>> 8, qe |= qe >>> 16, qe++), qe;
          }
          function xe(qe, rt) {
            return qe <= 0 || rt.length === 0 && rt.ended ? 0 : rt.objectMode ? 1 : qe !== qe ? rt.flowing && rt.length ? rt.buffer.head.data.length : rt.length : (qe > rt.highWaterMark && (rt.highWaterMark = Me(qe)), qe <= rt.length ? qe : rt.ended ? rt.length : (rt.needReadable = !0, 0));
          }
          Y.prototype.read = function(qe) {
            b("read", qe), qe = parseInt(qe, 10);
            var rt = this._readableState, it = qe;
            if (qe !== 0 && (rt.emittedReadable = !1), qe === 0 && rt.needReadable && (rt.length >= rt.highWaterMark || rt.ended))
              return b("read: emitReadable", rt.length, rt.ended), rt.length === 0 && rt.ended ? Xt(this) : de(this), null;
            if (qe = xe(qe, rt), qe === 0 && rt.ended)
              return rt.length === 0 && Xt(this), null;
            var Ae = rt.needReadable;
            b("need readable", Ae), (rt.length === 0 || rt.length - qe < rt.highWaterMark) && (Ae = !0, b("length less than watermark", Ae)), rt.ended || rt.reading ? (Ae = !1, b("reading or ended", Ae)) : Ae && (b("do read"), rt.reading = !0, rt.sync = !0, rt.length === 0 && (rt.needReadable = !0), this._read(rt.highWaterMark), rt.sync = !1, rt.reading || (qe = xe(it, rt)));
            var _e;
            return qe > 0 ? _e = ct(qe, rt) : _e = null, _e === null ? (rt.needReadable = !0, qe = 0) : rt.length -= qe, rt.length === 0 && (rt.ended || (rt.needReadable = !0), it !== qe && rt.ended && Xt(this)), _e !== null && this.emit("data", _e), _e;
          };
          function le(qe, rt) {
            if (!rt.ended) {
              if (rt.decoder) {
                var it = rt.decoder.end();
                it && it.length && (rt.buffer.push(it), rt.length += rt.objectMode ? 1 : it.length);
              }
              rt.ended = !0, de(qe);
            }
          }
          function de(qe) {
            var rt = qe._readableState;
            rt.needReadable = !1, rt.emittedReadable || (b("emitReadable", rt.flowing), rt.emittedReadable = !0, rt.sync ? F.nextTick(De, qe) : De(qe));
          }
          function De(qe) {
            b("emit readable"), qe.emit("readable"), $e(qe);
          }
          function ze(qe, rt) {
            rt.readingMore || (rt.readingMore = !0, F.nextTick(Ze, qe, rt));
          }
          function Ze(qe, rt) {
            for (var it = rt.length; !rt.reading && !rt.flowing && !rt.ended && rt.length < rt.highWaterMark && (b("maybeReadMore read 0"), qe.read(0), it !== rt.length); )
              it = rt.length;
            rt.readingMore = !1;
          }
          Y.prototype._read = function(qe) {
            this.emit("error", new Error("_read() is not implemented"));
          }, Y.prototype.pipe = function(qe, rt) {
            var it = this, Ae = this._readableState;
            switch (Ae.pipesCount) {
              case 0:
                Ae.pipes = qe;
                break;
              case 1:
                Ae.pipes = [Ae.pipes, qe];
                break;
              default:
                Ae.pipes.push(qe);
                break;
            }
            Ae.pipesCount += 1, b("pipe count=%d opts=%j", Ae.pipesCount, rt);
            var _e = (!rt || rt.end !== !1) && qe !== Q.stdout && qe !== Q.stderr, fe = _e ? Pe : kr;
            Ae.endEmitted ? F.nextTick(fe) : it.once("end", fe), qe.on("unpipe", We);
            function We(Ur, Rr) {
              b("onunpipe"), Ur === it && Rr && Rr.hasUnpiped === !1 && (Rr.hasUnpiped = !0, Xe());
            }
            function Pe() {
              b("onend"), qe.end();
            }
            var he = Ue(it);
            qe.on("drain", he);
            var ie = !1;
            function Xe() {
              b("cleanup"), qe.removeListener("close", Sr), qe.removeListener("finish", Fr), qe.removeListener("drain", he), qe.removeListener("error", Qt), qe.removeListener("unpipe", We), it.removeListener("end", Pe), it.removeListener("end", kr), it.removeListener("data", Wt), ie = !0, Ae.awaitDrain && (!qe._writableState || qe._writableState.needDrain) && he();
            }
            var bt = !1;
            it.on("data", Wt);
            function Wt(Ur) {
              b("ondata"), bt = !1;
              var Rr = qe.write(Ur);
              Rr === !1 && !bt && ((Ae.pipesCount === 1 && Ae.pipes === qe || Ae.pipesCount > 1 && Ye(Ae.pipes, qe) !== -1) && !ie && (b("false write response, pause", it._readableState.awaitDrain), it._readableState.awaitDrain++, bt = !0), it.pause());
            }
            function Qt(Ur) {
              b("onerror", Ur), kr(), qe.removeListener("error", Qt), M(qe, "error") === 0 && qe.emit("error", Ur);
            }
            W(qe, "error", Qt);
            function Sr() {
              qe.removeListener("finish", Fr), kr();
            }
            qe.once("close", Sr);
            function Fr() {
              b("onfinish"), qe.removeListener("close", Sr), kr();
            }
            qe.once("finish", Fr);
            function kr() {
              b("unpipe"), it.unpipe(qe);
            }
            return qe.emit("pipe", it), Ae.flowing || (b("pipe resume"), it.resume()), qe;
          };
          function Ue(qe) {
            return function() {
              var rt = qe._readableState;
              b("pipeOnDrain", rt.awaitDrain), rt.awaitDrain && rt.awaitDrain--, rt.awaitDrain === 0 && M(qe, "data") && (rt.flowing = !0, $e(qe));
            };
          }
          Y.prototype.unpipe = function(qe) {
            var rt = this._readableState, it = { hasUnpiped: !1 };
            if (rt.pipesCount === 0) return this;
            if (rt.pipesCount === 1)
              return qe && qe !== rt.pipes ? this : (qe || (qe = rt.pipes), rt.pipes = null, rt.pipesCount = 0, rt.flowing = !1, qe && qe.emit("unpipe", this, it), this);
            if (!qe) {
              var Ae = rt.pipes, _e = rt.pipesCount;
              rt.pipes = null, rt.pipesCount = 0, rt.flowing = !1;
              for (var fe = 0; fe < _e; fe++)
                Ae[fe].emit("unpipe", this, it);
              return this;
            }
            var We = Ye(rt.pipes, qe);
            return We === -1 ? this : (rt.pipes.splice(We, 1), rt.pipesCount -= 1, rt.pipesCount === 1 && (rt.pipes = rt.pipes[0]), qe.emit("unpipe", this, it), this);
          }, Y.prototype.on = function(qe, rt) {
            var it = E.prototype.on.call(this, qe, rt);
            if (qe === "data")
              this._readableState.flowing !== !1 && this.resume();
            else if (qe === "readable") {
              var Ae = this._readableState;
              !Ae.endEmitted && !Ae.readableListening && (Ae.readableListening = Ae.needReadable = !0, Ae.emittedReadable = !1, Ae.reading ? Ae.length && de(this) : F.nextTick(Ie, this));
            }
            return it;
          }, Y.prototype.addListener = Y.prototype.on;
          function Ie(qe) {
            b("readable nexttick read 0"), qe.read(0);
          }
          Y.prototype.resume = function() {
            var qe = this._readableState;
            return qe.flowing || (b("resume"), qe.flowing = !0, je(this, qe)), this;
          };
          function je(qe, rt) {
            rt.resumeScheduled || (rt.resumeScheduled = !0, F.nextTick(Fe, qe, rt));
          }
          function Fe(qe, rt) {
            rt.reading || (b("resume read 0"), qe.read(0)), rt.resumeScheduled = !1, rt.awaitDrain = 0, qe.emit("resume"), $e(qe), rt.flowing && !rt.reading && qe.read(0);
          }
          Y.prototype.pause = function() {
            return b("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (b("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
          };
          function $e(qe) {
            var rt = qe._readableState;
            for (b("flow", rt.flowing); rt.flowing && qe.read() !== null; )
              ;
          }
          Y.prototype.wrap = function(qe) {
            var rt = this, it = this._readableState, Ae = !1;
            qe.on("end", function() {
              if (b("wrapped end"), it.decoder && !it.ended) {
                var We = it.decoder.end();
                We && We.length && rt.push(We);
              }
              rt.push(null);
            }), qe.on("data", function(We) {
              if (b("wrapped data"), it.decoder && (We = it.decoder.write(We)), !(it.objectMode && We == null) && !(!it.objectMode && (!We || !We.length))) {
                var Pe = rt.push(We);
                Pe || (Ae = !0, qe.pause());
              }
            });
            for (var _e in qe)
              this[_e] === void 0 && typeof qe[_e] == "function" && (this[_e] = /* @__PURE__ */ function(We) {
                return function() {
                  return qe[We].apply(qe, arguments);
                };
              }(_e));
            for (var fe = 0; fe < V.length; fe++)
              qe.on(V[fe], this.emit.bind(this, V[fe]));
            return this._read = function(We) {
              b("wrapped _read", We), Ae && (Ae = !1, qe.resume());
            }, this;
          }, Object.defineProperty(Y.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.highWaterMark;
            }
          }), Y._fromList = ct;
          function ct(qe, rt) {
            if (rt.length === 0) return null;
            var it;
            return rt.objectMode ? it = rt.buffer.shift() : !qe || qe >= rt.length ? (rt.decoder ? it = rt.buffer.join("") : rt.buffer.length === 1 ? it = rt.buffer.head.data : it = rt.buffer.concat(rt.length), rt.buffer.clear()) : it = wt(qe, rt.buffer, rt.decoder), it;
          }
          function wt(qe, rt, it) {
            var Ae;
            return qe < rt.head.data.length ? (Ae = rt.head.data.slice(0, qe), rt.head.data = rt.head.data.slice(qe)) : qe === rt.head.data.length ? Ae = rt.shift() : Ae = it ? Oe(qe, rt) : Ct(qe, rt), Ae;
          }
          function Oe(qe, rt) {
            var it = rt.head, Ae = 1, _e = it.data;
            for (qe -= _e.length; it = it.next; ) {
              var fe = it.data, We = qe > fe.length ? fe.length : qe;
              if (We === fe.length ? _e += fe : _e += fe.slice(0, qe), qe -= We, qe === 0) {
                We === fe.length ? (++Ae, it.next ? rt.head = it.next : rt.head = rt.tail = null) : (rt.head = it, it.data = fe.slice(We));
                break;
              }
              ++Ae;
            }
            return rt.length -= Ae, _e;
          }
          function Ct(qe, rt) {
            var it = x.allocUnsafe(qe), Ae = rt.head, _e = 1;
            for (Ae.data.copy(it), qe -= Ae.data.length; Ae = Ae.next; ) {
              var fe = Ae.data, We = qe > fe.length ? fe.length : qe;
              if (fe.copy(it, it.length - qe, 0, We), qe -= We, qe === 0) {
                We === fe.length ? (++_e, Ae.next ? rt.head = Ae.next : rt.head = rt.tail = null) : (rt.head = Ae, Ae.data = fe.slice(We));
                break;
              }
              ++_e;
            }
            return rt.length -= _e, it;
          }
          function Xt(qe) {
            var rt = qe._readableState;
            if (rt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
            rt.endEmitted || (rt.ended = !0, F.nextTick(vt, rt, qe));
          }
          function vt(qe, rt) {
            !qe.endEmitted && qe.length === 0 && (qe.endEmitted = !0, rt.readable = !1, rt.emit("end"));
          }
          function Ye(qe, rt) {
            for (var it = 0, Ae = qe.length; it < Ae; it++)
              if (qe[it] === rt) return it;
            return -1;
          }
        }).call(this, te("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {});
      }, { "./_stream_duplex": 139, "./internal/streams/BufferList": 144, "./internal/streams/destroy": 145, "./internal/streams/stream": 146, _process: 133, "core-util-is": 51, events: 52, inherits: 75, isarray: 79, "process-nextick-args": 132, "safe-buffer": 147, "string_decoder/": 148, util: 33 }], 142: [function(te, Ee, $) {
        Ee.exports = H;
        var Q = te("./_stream_duplex"), r = te("core-util-is");
        r.inherits = te("inherits"), r.inherits(H, Q);
        function F(E, x) {
          var m = this._transformState;
          m.transforming = !1;
          var I = m.writecb;
          if (!I)
            return this.emit("error", new Error("write callback called multiple times"));
          m.writechunk = null, m.writecb = null, x != null && this.push(x), I(E);
          var z = this._readableState;
          z.reading = !1, (z.needReadable || z.length < z.highWaterMark) && this._read(z.highWaterMark);
        }
        function H(E) {
          if (!(this instanceof H)) return new H(E);
          Q.call(this, E), this._transformState = {
            afterTransform: F.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }, this._readableState.needReadable = !0, this._readableState.sync = !1, E && (typeof E.transform == "function" && (this._transform = E.transform), typeof E.flush == "function" && (this._flush = E.flush)), this.on("prefinish", P);
        }
        function P() {
          var E = this;
          typeof this._flush == "function" ? this._flush(function(x, m) {
            M(E, x, m);
          }) : M(this, null, null);
        }
        H.prototype.push = function(E, x) {
          return this._transformState.needTransform = !1, Q.prototype.push.call(this, E, x);
        }, H.prototype._transform = function(E, x, m) {
          throw new Error("_transform() is not implemented");
        }, H.prototype._write = function(E, x, m) {
          var I = this._transformState;
          if (I.writecb = m, I.writechunk = E, I.writeencoding = x, !I.transforming) {
            var z = this._readableState;
            (I.needTransform || z.needReadable || z.length < z.highWaterMark) && this._read(z.highWaterMark);
          }
        }, H.prototype._read = function(E) {
          var x = this._transformState;
          x.writechunk !== null && x.writecb && !x.transforming ? (x.transforming = !0, this._transform(x.writechunk, x.writeencoding, x.afterTransform)) : x.needTransform = !0;
        }, H.prototype._destroy = function(E, x) {
          var m = this;
          Q.prototype._destroy.call(this, E, function(I) {
            x(I), m.emit("close");
          });
        };
        function M(E, x, m) {
          if (x) return E.emit("error", x);
          if (m != null && E.push(m), E._writableState.length) throw new Error("Calling transform done when ws.length != 0");
          if (E._transformState.transforming) throw new Error("Calling transform done when still transforming");
          return E.push(null);
        }
      }, { "./_stream_duplex": 139, "core-util-is": 51, inherits: 75 }], 143: [function(te, Ee, $) {
        (function(Q, r, F) {
          var H = te("process-nextick-args");
          Ee.exports = W;
          function P(Fe) {
            var $e = this;
            this.next = null, this.entry = null, this.finish = function() {
              je($e, Fe);
            };
          }
          var M = !Q.browser && ["v0.10", "v0.9."].indexOf(Q.version.slice(0, 5)) > -1 ? F : H.nextTick, E;
          W.WritableState = U;
          var x = te("core-util-is");
          x.inherits = te("inherits");
          var m = {
            deprecate: te("util-deprecate")
          }, I = te("./internal/streams/stream"), z = te("safe-buffer").Buffer, w = r.Uint8Array || function() {
          };
          function C(Fe) {
            return z.from(Fe);
          }
          function b(Fe) {
            return z.isBuffer(Fe) || Fe instanceof w;
          }
          var B = te("./internal/streams/destroy");
          x.inherits(W, I);
          function N() {
          }
          function U(Fe, $e) {
            E = E || te("./_stream_duplex"), Fe = Fe || {};
            var ct = $e instanceof E;
            this.objectMode = !!Fe.objectMode, ct && (this.objectMode = this.objectMode || !!Fe.writableObjectMode);
            var wt = Fe.highWaterMark, Oe = Fe.writableHighWaterMark, Ct = this.objectMode ? 16 : 16 * 1024;
            wt || wt === 0 ? this.highWaterMark = wt : ct && (Oe || Oe === 0) ? this.highWaterMark = Oe : this.highWaterMark = Ct, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var Xt = Fe.decodeStrings === !1;
            this.decodeStrings = !Xt, this.defaultEncoding = Fe.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(vt) {
              Me($e, vt);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new P(this);
          }
          U.prototype.getBuffer = function() {
            for (var $e = this.bufferedRequest, ct = []; $e; )
              ct.push($e), $e = $e.next;
            return ct;
          }, function() {
            try {
              Object.defineProperty(U.prototype, "buffer", {
                get: m.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch {
            }
          }();
          var V;
          typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (V = Function.prototype[Symbol.hasInstance], Object.defineProperty(W, Symbol.hasInstance, {
            value: function(Fe) {
              return V.call(this, Fe) ? !0 : this !== W ? !1 : Fe && Fe._writableState instanceof U;
            }
          })) : V = function(Fe) {
            return Fe instanceof this;
          };
          function W(Fe) {
            if (E = E || te("./_stream_duplex"), !V.call(W, this) && !(this instanceof E))
              return new W(Fe);
            this._writableState = new U(Fe, this), this.writable = !0, Fe && (typeof Fe.write == "function" && (this._write = Fe.write), typeof Fe.writev == "function" && (this._writev = Fe.writev), typeof Fe.destroy == "function" && (this._destroy = Fe.destroy), typeof Fe.final == "function" && (this._final = Fe.final)), I.call(this);
          }
          W.prototype.pipe = function() {
            this.emit("error", new Error("Cannot pipe, not readable"));
          };
          function q(Fe, $e) {
            var ct = new Error("write after end");
            Fe.emit("error", ct), H.nextTick($e, ct);
          }
          function Y(Fe, $e, ct, wt) {
            var Oe = !0, Ct = !1;
            return ct === null ? Ct = new TypeError("May not write null values to stream") : typeof ct != "string" && ct !== void 0 && !$e.objectMode && (Ct = new TypeError("Invalid non-string/buffer chunk")), Ct && (Fe.emit("error", Ct), H.nextTick(wt, Ct), Oe = !1), Oe;
          }
          W.prototype.write = function(Fe, $e, ct) {
            var wt = this._writableState, Oe = !1, Ct = !wt.objectMode && b(Fe);
            return Ct && !z.isBuffer(Fe) && (Fe = C(Fe)), typeof $e == "function" && (ct = $e, $e = null), Ct ? $e = "buffer" : $e || ($e = wt.defaultEncoding), typeof ct != "function" && (ct = N), wt.ended ? q(this, ct) : (Ct || Y(this, wt, Fe, ct)) && (wt.pendingcb++, Oe = se(this, wt, Ct, Fe, $e, ct)), Oe;
          }, W.prototype.cork = function() {
            var Fe = this._writableState;
            Fe.corked++;
          }, W.prototype.uncork = function() {
            var Fe = this._writableState;
            Fe.corked && (Fe.corked--, !Fe.writing && !Fe.corked && !Fe.finished && !Fe.bufferProcessing && Fe.bufferedRequest && de(this, Fe));
          }, W.prototype.setDefaultEncoding = function($e) {
            if (typeof $e == "string" && ($e = $e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf(($e + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + $e);
            return this._writableState.defaultEncoding = $e, this;
          };
          function re(Fe, $e, ct) {
            return !Fe.objectMode && Fe.decodeStrings !== !1 && typeof $e == "string" && ($e = z.from($e, ct)), $e;
          }
          Object.defineProperty(W.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.highWaterMark;
            }
          });
          function se(Fe, $e, ct, wt, Oe, Ct) {
            if (!ct) {
              var Xt = re($e, wt, Oe);
              wt !== Xt && (ct = !0, Oe = "buffer", wt = Xt);
            }
            var vt = $e.objectMode ? 1 : wt.length;
            $e.length += vt;
            var Ye = $e.length < $e.highWaterMark;
            if (Ye || ($e.needDrain = !0), $e.writing || $e.corked) {
              var qe = $e.lastBufferedRequest;
              $e.lastBufferedRequest = {
                chunk: wt,
                encoding: Oe,
                isBuf: ct,
                callback: Ct,
                next: null
              }, qe ? qe.next = $e.lastBufferedRequest : $e.bufferedRequest = $e.lastBufferedRequest, $e.bufferedRequestCount += 1;
            } else
              ve(Fe, $e, !1, vt, wt, Oe, Ct);
            return Ye;
          }
          function ve(Fe, $e, ct, wt, Oe, Ct, Xt) {
            $e.writelen = wt, $e.writecb = Xt, $e.writing = !0, $e.sync = !0, ct ? Fe._writev(Oe, $e.onwrite) : Fe._write(Oe, Ct, $e.onwrite), $e.sync = !1;
          }
          function ce(Fe, $e, ct, wt, Oe) {
            --$e.pendingcb, ct ? (H.nextTick(Oe, wt), H.nextTick(Ue, Fe, $e), Fe._writableState.errorEmitted = !0, Fe.emit("error", wt)) : (Oe(wt), Fe._writableState.errorEmitted = !0, Fe.emit("error", wt), Ue(Fe, $e));
          }
          function be(Fe) {
            Fe.writing = !1, Fe.writecb = null, Fe.length -= Fe.writelen, Fe.writelen = 0;
          }
          function Me(Fe, $e) {
            var ct = Fe._writableState, wt = ct.sync, Oe = ct.writecb;
            if (be(ct), $e) ce(Fe, ct, wt, $e, Oe);
            else {
              var Ct = De(ct);
              !Ct && !ct.corked && !ct.bufferProcessing && ct.bufferedRequest && de(Fe, ct), wt ? M(xe, Fe, ct, Ct, Oe) : xe(Fe, ct, Ct, Oe);
            }
          }
          function xe(Fe, $e, ct, wt) {
            ct || le(Fe, $e), $e.pendingcb--, wt(), Ue(Fe, $e);
          }
          function le(Fe, $e) {
            $e.length === 0 && $e.needDrain && ($e.needDrain = !1, Fe.emit("drain"));
          }
          function de(Fe, $e) {
            $e.bufferProcessing = !0;
            var ct = $e.bufferedRequest;
            if (Fe._writev && ct && ct.next) {
              var wt = $e.bufferedRequestCount, Oe = new Array(wt), Ct = $e.corkedRequestsFree;
              Ct.entry = ct;
              for (var Xt = 0, vt = !0; ct; )
                Oe[Xt] = ct, ct.isBuf || (vt = !1), ct = ct.next, Xt += 1;
              Oe.allBuffers = vt, ve(Fe, $e, !0, $e.length, Oe, "", Ct.finish), $e.pendingcb++, $e.lastBufferedRequest = null, Ct.next ? ($e.corkedRequestsFree = Ct.next, Ct.next = null) : $e.corkedRequestsFree = new P($e), $e.bufferedRequestCount = 0;
            } else {
              for (; ct; ) {
                var Ye = ct.chunk, qe = ct.encoding, rt = ct.callback, it = $e.objectMode ? 1 : Ye.length;
                if (ve(Fe, $e, !1, it, Ye, qe, rt), ct = ct.next, $e.bufferedRequestCount--, $e.writing)
                  break;
              }
              ct === null && ($e.lastBufferedRequest = null);
            }
            $e.bufferedRequest = ct, $e.bufferProcessing = !1;
          }
          W.prototype._write = function(Fe, $e, ct) {
            ct(new Error("_write() is not implemented"));
          }, W.prototype._writev = null, W.prototype.end = function(Fe, $e, ct) {
            var wt = this._writableState;
            typeof Fe == "function" ? (ct = Fe, Fe = null, $e = null) : typeof $e == "function" && (ct = $e, $e = null), Fe != null && this.write(Fe, $e), wt.corked && (wt.corked = 1, this.uncork()), !wt.ending && !wt.finished && Ie(this, wt, ct);
          };
          function De(Fe) {
            return Fe.ending && Fe.length === 0 && Fe.bufferedRequest === null && !Fe.finished && !Fe.writing;
          }
          function ze(Fe, $e) {
            Fe._final(function(ct) {
              $e.pendingcb--, ct && Fe.emit("error", ct), $e.prefinished = !0, Fe.emit("prefinish"), Ue(Fe, $e);
            });
          }
          function Ze(Fe, $e) {
            !$e.prefinished && !$e.finalCalled && (typeof Fe._final == "function" ? ($e.pendingcb++, $e.finalCalled = !0, H.nextTick(ze, Fe, $e)) : ($e.prefinished = !0, Fe.emit("prefinish")));
          }
          function Ue(Fe, $e) {
            var ct = De($e);
            return ct && (Ze(Fe, $e), $e.pendingcb === 0 && ($e.finished = !0, Fe.emit("finish"))), ct;
          }
          function Ie(Fe, $e, ct) {
            $e.ending = !0, Ue(Fe, $e), ct && ($e.finished ? H.nextTick(ct) : Fe.once("finish", ct)), $e.ended = !0, Fe.writable = !1;
          }
          function je(Fe, $e, ct) {
            var wt = Fe.entry;
            for (Fe.entry = null; wt; ) {
              var Oe = wt.callback;
              $e.pendingcb--, Oe(ct), wt = wt.next;
            }
            $e.corkedRequestsFree ? $e.corkedRequestsFree.next = Fe : $e.corkedRequestsFree = Fe;
          }
          Object.defineProperty(W.prototype, "destroyed", {
            get: function() {
              return this._writableState === void 0 ? !1 : this._writableState.destroyed;
            },
            set: function(Fe) {
              this._writableState && (this._writableState.destroyed = Fe);
            }
          }), W.prototype.destroy = B.destroy, W.prototype._undestroy = B.undestroy, W.prototype._destroy = function(Fe, $e) {
            this.end(), $e(Fe);
          };
        }).call(this, te("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {}, te("timers").setImmediate);
      }, { "./_stream_duplex": 139, "./internal/streams/destroy": 145, "./internal/streams/stream": 146, _process: 133, "core-util-is": 51, inherits: 75, "process-nextick-args": 132, "safe-buffer": 147, timers: 176, "util-deprecate": 183 }], 144: [function(te, Ee, $) {
        function Q(P, M) {
          if (!(P instanceof M))
            throw new TypeError("Cannot call a class as a function");
        }
        var r = te("safe-buffer").Buffer, F = te("util");
        function H(P, M, E) {
          P.copy(M, E);
        }
        Ee.exports = function() {
          function P() {
            Q(this, P), this.head = null, this.tail = null, this.length = 0;
          }
          return P.prototype.push = function(E) {
            var x = { data: E, next: null };
            this.length > 0 ? this.tail.next = x : this.head = x, this.tail = x, ++this.length;
          }, P.prototype.unshift = function(E) {
            var x = { data: E, next: this.head };
            this.length === 0 && (this.tail = x), this.head = x, ++this.length;
          }, P.prototype.shift = function() {
            if (this.length !== 0) {
              var E = this.head.data;
              return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, E;
            }
          }, P.prototype.clear = function() {
            this.head = this.tail = null, this.length = 0;
          }, P.prototype.join = function(E) {
            if (this.length === 0) return "";
            for (var x = this.head, m = "" + x.data; x = x.next; )
              m += E + x.data;
            return m;
          }, P.prototype.concat = function(E) {
            if (this.length === 0) return r.alloc(0);
            if (this.length === 1) return this.head.data;
            for (var x = r.allocUnsafe(E >>> 0), m = this.head, I = 0; m; )
              H(m.data, x, I), I += m.data.length, m = m.next;
            return x;
          }, P;
        }(), F && F.inspect && F.inspect.custom && (Ee.exports.prototype[F.inspect.custom] = function() {
          var P = F.inspect({ length: this.length });
          return this.constructor.name + " " + P;
        });
      }, { "safe-buffer": 147, util: 33 }], 145: [function(te, Ee, $) {
        var Q = te("process-nextick-args");
        function r(P, M) {
          var E = this, x = this._readableState && this._readableState.destroyed, m = this._writableState && this._writableState.destroyed;
          return x || m ? (M ? M(P) : P && (!this._writableState || !this._writableState.errorEmitted) && Q.nextTick(H, this, P), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(P || null, function(I) {
            !M && I ? (Q.nextTick(H, E, I), E._writableState && (E._writableState.errorEmitted = !0)) : M && M(I);
          }), this);
        }
        function F() {
          this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
        }
        function H(P, M) {
          P.emit("error", M);
        }
        Ee.exports = {
          destroy: r,
          undestroy: F
        };
      }, { "process-nextick-args": 132 }], 146: [function(te, Ee, $) {
        Ee.exports = te("events").EventEmitter;
      }, { events: 52 }], 147: [function(te, Ee, $) {
        var Q = te("buffer"), r = Q.Buffer;
        function F(P, M) {
          for (var E in P)
            M[E] = P[E];
        }
        r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? Ee.exports = Q : (F(Q, $), $.Buffer = H);
        function H(P, M, E) {
          return r(P, M, E);
        }
        F(r, H), H.from = function(P, M, E) {
          if (typeof P == "number")
            throw new TypeError("Argument must not be a number");
          return r(P, M, E);
        }, H.alloc = function(P, M, E) {
          if (typeof P != "number")
            throw new TypeError("Argument must be a number");
          var x = r(P);
          return M !== void 0 ? typeof E == "string" ? x.fill(M, E) : x.fill(M) : x.fill(0), x;
        }, H.allocUnsafe = function(P) {
          if (typeof P != "number")
            throw new TypeError("Argument must be a number");
          return r(P);
        }, H.allocUnsafeSlow = function(P) {
          if (typeof P != "number")
            throw new TypeError("Argument must be a number");
          return Q.SlowBuffer(P);
        };
      }, { buffer: 48 }], 148: [function(te, Ee, $) {
        var Q = te("safe-buffer").Buffer, r = Q.isEncoding || function(V) {
          switch (V = "" + V, V && V.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return !0;
            default:
              return !1;
          }
        };
        function F(V) {
          if (!V) return "utf8";
          for (var W; ; )
            switch (V) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return V;
              default:
                if (W) return;
                V = ("" + V).toLowerCase(), W = !0;
            }
        }
        function H(V) {
          var W = F(V);
          if (typeof W != "string" && (Q.isEncoding === r || !r(V))) throw new Error("Unknown encoding: " + V);
          return W || V;
        }
        $.StringDecoder = P;
        function P(V) {
          this.encoding = H(V);
          var W;
          switch (this.encoding) {
            case "utf16le":
              this.text = w, this.end = C, W = 4;
              break;
            case "utf8":
              this.fillLast = m, W = 4;
              break;
            case "base64":
              this.text = b, this.end = B, W = 3;
              break;
            default:
              this.write = N, this.end = U;
              return;
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Q.allocUnsafe(W);
        }
        P.prototype.write = function(V) {
          if (V.length === 0) return "";
          var W, q;
          if (this.lastNeed) {
            if (W = this.fillLast(V), W === void 0) return "";
            q = this.lastNeed, this.lastNeed = 0;
          } else
            q = 0;
          return q < V.length ? W ? W + this.text(V, q) : this.text(V, q) : W || "";
        }, P.prototype.end = z, P.prototype.text = I, P.prototype.fillLast = function(V) {
          if (this.lastNeed <= V.length)
            return V.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          V.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, V.length), this.lastNeed -= V.length;
        };
        function M(V) {
          return V <= 127 ? 0 : V >> 5 === 6 ? 2 : V >> 4 === 14 ? 3 : V >> 3 === 30 ? 4 : V >> 6 === 2 ? -1 : -2;
        }
        function E(V, W, q) {
          var Y = W.length - 1;
          if (Y < q) return 0;
          var re = M(W[Y]);
          return re >= 0 ? (re > 0 && (V.lastNeed = re - 1), re) : --Y < q || re === -2 ? 0 : (re = M(W[Y]), re >= 0 ? (re > 0 && (V.lastNeed = re - 2), re) : --Y < q || re === -2 ? 0 : (re = M(W[Y]), re >= 0 ? (re > 0 && (re === 2 ? re = 0 : V.lastNeed = re - 3), re) : 0));
        }
        function x(V, W, q) {
          if ((W[0] & 192) !== 128)
            return V.lastNeed = 0, "�";
          if (V.lastNeed > 1 && W.length > 1) {
            if ((W[1] & 192) !== 128)
              return V.lastNeed = 1, "�";
            if (V.lastNeed > 2 && W.length > 2 && (W[2] & 192) !== 128)
              return V.lastNeed = 2, "�";
          }
        }
        function m(V) {
          var W = this.lastTotal - this.lastNeed, q = x(this, V);
          if (q !== void 0) return q;
          if (this.lastNeed <= V.length)
            return V.copy(this.lastChar, W, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          V.copy(this.lastChar, W, 0, V.length), this.lastNeed -= V.length;
        }
        function I(V, W) {
          var q = E(this, V, W);
          if (!this.lastNeed) return V.toString("utf8", W);
          this.lastTotal = q;
          var Y = V.length - (q - this.lastNeed);
          return V.copy(this.lastChar, 0, Y), V.toString("utf8", W, Y);
        }
        function z(V) {
          var W = V && V.length ? this.write(V) : "";
          return this.lastNeed ? W + "�" : W;
        }
        function w(V, W) {
          if ((V.length - W) % 2 === 0) {
            var q = V.toString("utf16le", W);
            if (q) {
              var Y = q.charCodeAt(q.length - 1);
              if (Y >= 55296 && Y <= 56319)
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = V[V.length - 2], this.lastChar[1] = V[V.length - 1], q.slice(0, -1);
            }
            return q;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = V[V.length - 1], V.toString("utf16le", W, V.length - 1);
        }
        function C(V) {
          var W = V && V.length ? this.write(V) : "";
          if (this.lastNeed) {
            var q = this.lastTotal - this.lastNeed;
            return W + this.lastChar.toString("utf16le", 0, q);
          }
          return W;
        }
        function b(V, W) {
          var q = (V.length - W) % 3;
          return q === 0 ? V.toString("base64", W) : (this.lastNeed = 3 - q, this.lastTotal = 3, q === 1 ? this.lastChar[0] = V[V.length - 1] : (this.lastChar[0] = V[V.length - 2], this.lastChar[1] = V[V.length - 1]), V.toString("base64", W, V.length - q));
        }
        function B(V) {
          var W = V && V.length ? this.write(V) : "";
          return this.lastNeed ? W + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : W;
        }
        function N(V) {
          return V.toString(this.encoding);
        }
        function U(V) {
          return V && V.length ? this.write(V) : "";
        }
      }, { "safe-buffer": 147 }], 149: [function(te, Ee, $) {
        Ee.exports = te("./readable").PassThrough;
      }, { "./readable": 150 }], 150: [function(te, Ee, $) {
        $ = Ee.exports = te("./lib/_stream_readable.js"), $.Stream = $, $.Readable = $, $.Writable = te("./lib/_stream_writable.js"), $.Duplex = te("./lib/_stream_duplex.js"), $.Transform = te("./lib/_stream_transform.js"), $.PassThrough = te("./lib/_stream_passthrough.js");
      }, { "./lib/_stream_duplex.js": 139, "./lib/_stream_passthrough.js": 140, "./lib/_stream_readable.js": 141, "./lib/_stream_transform.js": 142, "./lib/_stream_writable.js": 143 }], 151: [function(te, Ee, $) {
        Ee.exports = te("./readable").Transform;
      }, { "./readable": 150 }], 152: [function(te, Ee, $) {
        Ee.exports = te("./lib/_stream_writable.js");
      }, { "./lib/_stream_writable.js": 143 }], 153: [function(te, Ee, $) {
        var Q = function(r) {
          var F = Object.prototype, H = F.hasOwnProperty, P, M = typeof Symbol == "function" ? Symbol : {}, E = M.iterator || "@@iterator", x = M.asyncIterator || "@@asyncIterator", m = M.toStringTag || "@@toStringTag";
          function I(Ze, Ue, Ie, je) {
            var Fe = Ue && Ue.prototype instanceof U ? Ue : U, $e = Object.create(Fe.prototype), ct = new de(je || []);
            return $e._invoke = be(Ze, Ie, ct), $e;
          }
          r.wrap = I;
          function z(Ze, Ue, Ie) {
            try {
              return { type: "normal", arg: Ze.call(Ue, Ie) };
            } catch (je) {
              return { type: "throw", arg: je };
            }
          }
          var w = "suspendedStart", C = "suspendedYield", b = "executing", B = "completed", N = {};
          function U() {
          }
          function V() {
          }
          function W() {
          }
          var q = {};
          q[E] = function() {
            return this;
          };
          var Y = Object.getPrototypeOf, re = Y && Y(Y(De([])));
          re && re !== F && H.call(re, E) && (q = re);
          var se = W.prototype = U.prototype = Object.create(q);
          V.prototype = se.constructor = W, W.constructor = V, W[m] = V.displayName = "GeneratorFunction";
          function ve(Ze) {
            ["next", "throw", "return"].forEach(function(Ue) {
              Ze[Ue] = function(Ie) {
                return this._invoke(Ue, Ie);
              };
            });
          }
          r.isGeneratorFunction = function(Ze) {
            var Ue = typeof Ze == "function" && Ze.constructor;
            return Ue ? Ue === V || // For the native GeneratorFunction constructor, the best we can
            // do is to check its .name property.
            (Ue.displayName || Ue.name) === "GeneratorFunction" : !1;
          }, r.mark = function(Ze) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(Ze, W) : (Ze.__proto__ = W, m in Ze || (Ze[m] = "GeneratorFunction")), Ze.prototype = Object.create(se), Ze;
          }, r.awrap = function(Ze) {
            return { __await: Ze };
          };
          function ce(Ze) {
            function Ue(Fe, $e, ct, wt) {
              var Oe = z(Ze[Fe], Ze, $e);
              if (Oe.type === "throw")
                wt(Oe.arg);
              else {
                var Ct = Oe.arg, Xt = Ct.value;
                return Xt && typeof Xt == "object" && H.call(Xt, "__await") ? Promise.resolve(Xt.__await).then(function(vt) {
                  Ue("next", vt, ct, wt);
                }, function(vt) {
                  Ue("throw", vt, ct, wt);
                }) : Promise.resolve(Xt).then(function(vt) {
                  Ct.value = vt, ct(Ct);
                }, function(vt) {
                  return Ue("throw", vt, ct, wt);
                });
              }
            }
            var Ie;
            function je(Fe, $e) {
              function ct() {
                return new Promise(function(wt, Oe) {
                  Ue(Fe, $e, wt, Oe);
                });
              }
              return Ie = // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              Ie ? Ie.then(
                ct,
                // Avoid propagating failures to Promises returned by later
                // invocations of the iterator.
                ct
              ) : ct();
            }
            this._invoke = je;
          }
          ve(ce.prototype), ce.prototype[x] = function() {
            return this;
          }, r.AsyncIterator = ce, r.async = function(Ze, Ue, Ie, je) {
            var Fe = new ce(
              I(Ze, Ue, Ie, je)
            );
            return r.isGeneratorFunction(Ue) ? Fe : Fe.next().then(function($e) {
              return $e.done ? $e.value : Fe.next();
            });
          };
          function be(Ze, Ue, Ie) {
            var je = w;
            return function($e, ct) {
              if (je === b)
                throw new Error("Generator is already running");
              if (je === B) {
                if ($e === "throw")
                  throw ct;
                return ze();
              }
              for (Ie.method = $e, Ie.arg = ct; ; ) {
                var wt = Ie.delegate;
                if (wt) {
                  var Oe = Me(wt, Ie);
                  if (Oe) {
                    if (Oe === N) continue;
                    return Oe;
                  }
                }
                if (Ie.method === "next")
                  Ie.sent = Ie._sent = Ie.arg;
                else if (Ie.method === "throw") {
                  if (je === w)
                    throw je = B, Ie.arg;
                  Ie.dispatchException(Ie.arg);
                } else Ie.method === "return" && Ie.abrupt("return", Ie.arg);
                je = b;
                var Ct = z(Ze, Ue, Ie);
                if (Ct.type === "normal") {
                  if (je = Ie.done ? B : C, Ct.arg === N)
                    continue;
                  return {
                    value: Ct.arg,
                    done: Ie.done
                  };
                } else Ct.type === "throw" && (je = B, Ie.method = "throw", Ie.arg = Ct.arg);
              }
            };
          }
          function Me(Ze, Ue) {
            var Ie = Ze.iterator[Ue.method];
            if (Ie === P) {
              if (Ue.delegate = null, Ue.method === "throw") {
                if (Ze.iterator.return && (Ue.method = "return", Ue.arg = P, Me(Ze, Ue), Ue.method === "throw"))
                  return N;
                Ue.method = "throw", Ue.arg = new TypeError(
                  "The iterator does not provide a 'throw' method"
                );
              }
              return N;
            }
            var je = z(Ie, Ze.iterator, Ue.arg);
            if (je.type === "throw")
              return Ue.method = "throw", Ue.arg = je.arg, Ue.delegate = null, N;
            var Fe = je.arg;
            if (!Fe)
              return Ue.method = "throw", Ue.arg = new TypeError("iterator result is not an object"), Ue.delegate = null, N;
            if (Fe.done)
              Ue[Ze.resultName] = Fe.value, Ue.next = Ze.nextLoc, Ue.method !== "return" && (Ue.method = "next", Ue.arg = P);
            else
              return Fe;
            return Ue.delegate = null, N;
          }
          ve(se), se[m] = "Generator", se[E] = function() {
            return this;
          }, se.toString = function() {
            return "[object Generator]";
          };
          function xe(Ze) {
            var Ue = { tryLoc: Ze[0] };
            1 in Ze && (Ue.catchLoc = Ze[1]), 2 in Ze && (Ue.finallyLoc = Ze[2], Ue.afterLoc = Ze[3]), this.tryEntries.push(Ue);
          }
          function le(Ze) {
            var Ue = Ze.completion || {};
            Ue.type = "normal", delete Ue.arg, Ze.completion = Ue;
          }
          function de(Ze) {
            this.tryEntries = [{ tryLoc: "root" }], Ze.forEach(xe, this), this.reset(!0);
          }
          r.keys = function(Ze) {
            var Ue = [];
            for (var Ie in Ze)
              Ue.push(Ie);
            return Ue.reverse(), function je() {
              for (; Ue.length; ) {
                var Fe = Ue.pop();
                if (Fe in Ze)
                  return je.value = Fe, je.done = !1, je;
              }
              return je.done = !0, je;
            };
          };
          function De(Ze) {
            if (Ze) {
              var Ue = Ze[E];
              if (Ue)
                return Ue.call(Ze);
              if (typeof Ze.next == "function")
                return Ze;
              if (!isNaN(Ze.length)) {
                var Ie = -1, je = function Fe() {
                  for (; ++Ie < Ze.length; )
                    if (H.call(Ze, Ie))
                      return Fe.value = Ze[Ie], Fe.done = !1, Fe;
                  return Fe.value = P, Fe.done = !0, Fe;
                };
                return je.next = je;
              }
            }
            return { next: ze };
          }
          r.values = De;
          function ze() {
            return { value: P, done: !0 };
          }
          return de.prototype = {
            constructor: de,
            reset: function(Ze) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = P, this.done = !1, this.delegate = null, this.method = "next", this.arg = P, this.tryEntries.forEach(le), !Ze)
                for (var Ue in this)
                  Ue.charAt(0) === "t" && H.call(this, Ue) && !isNaN(+Ue.slice(1)) && (this[Ue] = P);
            },
            stop: function() {
              this.done = !0;
              var Ze = this.tryEntries[0], Ue = Ze.completion;
              if (Ue.type === "throw")
                throw Ue.arg;
              return this.rval;
            },
            dispatchException: function(Ze) {
              if (this.done)
                throw Ze;
              var Ue = this;
              function Ie(Oe, Ct) {
                return $e.type = "throw", $e.arg = Ze, Ue.next = Oe, Ct && (Ue.method = "next", Ue.arg = P), !!Ct;
              }
              for (var je = this.tryEntries.length - 1; je >= 0; --je) {
                var Fe = this.tryEntries[je], $e = Fe.completion;
                if (Fe.tryLoc === "root")
                  return Ie("end");
                if (Fe.tryLoc <= this.prev) {
                  var ct = H.call(Fe, "catchLoc"), wt = H.call(Fe, "finallyLoc");
                  if (ct && wt) {
                    if (this.prev < Fe.catchLoc)
                      return Ie(Fe.catchLoc, !0);
                    if (this.prev < Fe.finallyLoc)
                      return Ie(Fe.finallyLoc);
                  } else if (ct) {
                    if (this.prev < Fe.catchLoc)
                      return Ie(Fe.catchLoc, !0);
                  } else if (wt) {
                    if (this.prev < Fe.finallyLoc)
                      return Ie(Fe.finallyLoc);
                  } else
                    throw new Error("try statement without catch or finally");
                }
              }
            },
            abrupt: function(Ze, Ue) {
              for (var Ie = this.tryEntries.length - 1; Ie >= 0; --Ie) {
                var je = this.tryEntries[Ie];
                if (je.tryLoc <= this.prev && H.call(je, "finallyLoc") && this.prev < je.finallyLoc) {
                  var Fe = je;
                  break;
                }
              }
              Fe && (Ze === "break" || Ze === "continue") && Fe.tryLoc <= Ue && Ue <= Fe.finallyLoc && (Fe = null);
              var $e = Fe ? Fe.completion : {};
              return $e.type = Ze, $e.arg = Ue, Fe ? (this.method = "next", this.next = Fe.finallyLoc, N) : this.complete($e);
            },
            complete: function(Ze, Ue) {
              if (Ze.type === "throw")
                throw Ze.arg;
              return Ze.type === "break" || Ze.type === "continue" ? this.next = Ze.arg : Ze.type === "return" ? (this.rval = this.arg = Ze.arg, this.method = "return", this.next = "end") : Ze.type === "normal" && Ue && (this.next = Ue), N;
            },
            finish: function(Ze) {
              for (var Ue = this.tryEntries.length - 1; Ue >= 0; --Ue) {
                var Ie = this.tryEntries[Ue];
                if (Ie.finallyLoc === Ze)
                  return this.complete(Ie.completion, Ie.afterLoc), le(Ie), N;
              }
            },
            catch: function(Ze) {
              for (var Ue = this.tryEntries.length - 1; Ue >= 0; --Ue) {
                var Ie = this.tryEntries[Ue];
                if (Ie.tryLoc === Ze) {
                  var je = Ie.completion;
                  if (je.type === "throw") {
                    var Fe = je.arg;
                    le(Ie);
                  }
                  return Fe;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function(Ze, Ue, Ie) {
              return this.delegate = {
                iterator: De(Ze),
                resultName: Ue,
                nextLoc: Ie
              }, this.method === "next" && (this.arg = P), N;
            }
          }, r;
        }(
          // If this script is executing as a CommonJS module, use module.exports
          // as the regeneratorRuntime namespace. Otherwise create a new empty
          // object. Either way, the resulting object will be used to initialize
          // the regeneratorRuntime variable at the top of this file.
          typeof Ee == "object" ? Ee.exports : {}
        );
        try {
          regeneratorRuntime = Q;
        } catch {
          Function("r", "regeneratorRuntime = r")(Q);
        }
      }, {}], 154: [function(te, Ee, $) {
        var Q = te("buffer"), r = Q.Buffer;
        function F(P, M) {
          for (var E in P)
            M[E] = P[E];
        }
        r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? Ee.exports = Q : (F(Q, $), $.Buffer = H);
        function H(P, M, E) {
          return r(P, M, E);
        }
        H.prototype = Object.create(r.prototype), F(r, H), H.from = function(P, M, E) {
          if (typeof P == "number")
            throw new TypeError("Argument must not be a number");
          return r(P, M, E);
        }, H.alloc = function(P, M, E) {
          if (typeof P != "number")
            throw new TypeError("Argument must be a number");
          var x = r(P);
          return M !== void 0 ? typeof E == "string" ? x.fill(M, E) : x.fill(M) : x.fill(0), x;
        }, H.allocUnsafe = function(P) {
          if (typeof P != "number")
            throw new TypeError("Argument must be a number");
          return r(P);
        }, H.allocUnsafeSlow = function(P) {
          if (typeof P != "number")
            throw new TypeError("Argument must be a number");
          return Q.SlowBuffer(P);
        };
      }, { buffer: 48 }], 155: [function(te, Ee, $) {
        Ee.exports = F;
        var Q = te("events").EventEmitter, r = te("inherits");
        r(F, Q), F.Readable = te("readable-stream/readable.js"), F.Writable = te("readable-stream/writable.js"), F.Duplex = te("readable-stream/duplex.js"), F.Transform = te("readable-stream/transform.js"), F.PassThrough = te("readable-stream/passthrough.js"), F.Stream = F;
        function F() {
          Q.call(this);
        }
        F.prototype.pipe = function(H, P) {
          var M = this;
          function E(b) {
            H.writable && H.write(b) === !1 && M.pause && M.pause();
          }
          M.on("data", E);
          function x() {
            M.readable && M.resume && M.resume();
          }
          H.on("drain", x), !H._isStdio && (!P || P.end !== !1) && (M.on("end", I), M.on("close", z));
          var m = !1;
          function I() {
            m || (m = !0, H.end());
          }
          function z() {
            m || (m = !0, typeof H.destroy == "function" && H.destroy());
          }
          function w(b) {
            if (C(), Q.listenerCount(this, "error") === 0)
              throw b;
          }
          M.on("error", w), H.on("error", w);
          function C() {
            M.removeListener("data", E), H.removeListener("drain", x), M.removeListener("end", I), M.removeListener("close", z), M.removeListener("error", w), H.removeListener("error", w), M.removeListener("end", C), M.removeListener("close", C), H.removeListener("close", C);
          }
          return M.on("end", C), M.on("close", C), H.on("close", C), H.emit("pipe", M), H;
        };
      }, { events: 52, inherits: 75, "readable-stream/duplex.js": 138, "readable-stream/passthrough.js": 149, "readable-stream/readable.js": 150, "readable-stream/transform.js": 151, "readable-stream/writable.js": 152 }], 156: [function(te, Ee, $) {
        (function(Q) {
          var r = te("./lib/request"), F = te("./lib/response"), H = te("xtend"), P = te("builtin-status-codes"), M = te("url"), E = $;
          E.request = function(x, m) {
            typeof x == "string" ? x = M.parse(x) : x = H(x);
            var I = Q.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", z = x.protocol || I, w = x.hostname || x.host, C = x.port, b = x.path || "/";
            w && w.indexOf(":") !== -1 && (w = "[" + w + "]"), x.url = (w ? z + "//" + w : "") + (C ? ":" + C : "") + b, x.method = (x.method || "GET").toUpperCase(), x.headers = x.headers || {};
            var B = new r(x);
            return m && B.on("response", m), B;
          }, E.get = function(m, I) {
            var z = E.request(m, I);
            return z.end(), z;
          }, E.ClientRequest = r, E.IncomingMessage = F.IncomingMessage, E.Agent = function() {
          }, E.Agent.defaultMaxSockets = 4, E.globalAgent = new E.Agent(), E.STATUS_CODES = P, E.METHODS = [
            "CHECKOUT",
            "CONNECT",
            "COPY",
            "DELETE",
            "GET",
            "HEAD",
            "LOCK",
            "M-SEARCH",
            "MERGE",
            "MKACTIVITY",
            "MKCOL",
            "MOVE",
            "NOTIFY",
            "OPTIONS",
            "PATCH",
            "POST",
            "PROPFIND",
            "PROPPATCH",
            "PURGE",
            "PUT",
            "REPORT",
            "SEARCH",
            "SUBSCRIBE",
            "TRACE",
            "UNLOCK",
            "UNSUBSCRIBE"
          ];
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {});
      }, { "./lib/request": 158, "./lib/response": 159, "builtin-status-codes": 50, url: 180, xtend: 189 }], 157: [function(te, Ee, $) {
        (function(Q) {
          $.fetch = P(Q.fetch) && P(Q.ReadableStream), $.writableStream = P(Q.WritableStream), $.abortController = P(Q.AbortController);
          var r;
          function F() {
            if (r !== void 0) return r;
            if (Q.XMLHttpRequest) {
              r = new Q.XMLHttpRequest();
              try {
                r.open("GET", Q.XDomainRequest ? "/" : "https://example.com");
              } catch {
                r = null;
              }
            } else
              r = null;
            return r;
          }
          function H(M) {
            var E = F();
            if (!E) return !1;
            try {
              return E.responseType = M, E.responseType === M;
            } catch {
            }
            return !1;
          }
          $.arraybuffer = $.fetch || H("arraybuffer"), $.msstream = !$.fetch && H("ms-stream"), $.mozchunkedarraybuffer = !$.fetch && H("moz-chunked-arraybuffer"), $.overrideMimeType = $.fetch || (F() ? P(F().overrideMimeType) : !1);
          function P(M) {
            return typeof M == "function";
          }
          r = null;
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {});
      }, {}], 158: [function(te, Ee, $) {
        (function(Q, r, F) {
          var H = te("./capability"), P = te("inherits"), M = te("./response"), E = te("readable-stream"), x = M.IncomingMessage, m = M.readyStates;
          function I(b, B) {
            return H.fetch && B ? "fetch" : H.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : H.msstream ? "ms-stream" : H.arraybuffer && b ? "arraybuffer" : "text";
          }
          var z = Ee.exports = function(b) {
            var B = this;
            E.Writable.call(B), B._opts = b, B._body = [], B._headers = {}, b.auth && B.setHeader("Authorization", "Basic " + F.from(b.auth).toString("base64")), Object.keys(b.headers).forEach(function(V) {
              B.setHeader(V, b.headers[V]);
            });
            var N, U = !0;
            if (b.mode === "disable-fetch" || "requestTimeout" in b && !H.abortController)
              U = !1, N = !0;
            else if (b.mode === "prefer-streaming")
              N = !1;
            else if (b.mode === "allow-wrong-content-type")
              N = !H.overrideMimeType;
            else if (!b.mode || b.mode === "default" || b.mode === "prefer-fast")
              N = !0;
            else
              throw new Error("Invalid value for opts.mode");
            B._mode = I(N, U), B._fetchTimer = null, B.on("finish", function() {
              B._onFinish();
            });
          };
          P(z, E.Writable), z.prototype.setHeader = function(b, B) {
            var N = this, U = b.toLowerCase();
            C.indexOf(U) === -1 && (N._headers[U] = {
              name: b,
              value: B
            });
          }, z.prototype.getHeader = function(b) {
            var B = this._headers[b.toLowerCase()];
            return B ? B.value : null;
          }, z.prototype.removeHeader = function(b) {
            var B = this;
            delete B._headers[b.toLowerCase()];
          }, z.prototype._onFinish = function() {
            var b = this;
            if (!b._destroyed) {
              var B = b._opts, N = b._headers, U = null;
              B.method !== "GET" && B.method !== "HEAD" && (U = new Blob(b._body, {
                type: (N["content-type"] || {}).value || ""
              }));
              var V = [];
              if (Object.keys(N).forEach(function(re) {
                var se = N[re].name, ve = N[re].value;
                Array.isArray(ve) ? ve.forEach(function(ce) {
                  V.push([se, ce]);
                }) : V.push([se, ve]);
              }), b._mode === "fetch") {
                var W = null;
                if (H.abortController) {
                  var q = new AbortController();
                  W = q.signal, b._fetchAbortController = q, "requestTimeout" in B && B.requestTimeout !== 0 && (b._fetchTimer = r.setTimeout(function() {
                    b.emit("requestTimeout"), b._fetchAbortController && b._fetchAbortController.abort();
                  }, B.requestTimeout));
                }
                r.fetch(b._opts.url, {
                  method: b._opts.method,
                  headers: V,
                  body: U || void 0,
                  mode: "cors",
                  credentials: B.withCredentials ? "include" : "same-origin",
                  signal: W
                }).then(function(re) {
                  b._fetchResponse = re, b._connect();
                }, function(re) {
                  r.clearTimeout(b._fetchTimer), b._destroyed || b.emit("error", re);
                });
              } else {
                var Y = b._xhr = new r.XMLHttpRequest();
                try {
                  Y.open(b._opts.method, b._opts.url, !0);
                } catch (re) {
                  Q.nextTick(function() {
                    b.emit("error", re);
                  });
                  return;
                }
                "responseType" in Y && (Y.responseType = b._mode), "withCredentials" in Y && (Y.withCredentials = !!B.withCredentials), b._mode === "text" && "overrideMimeType" in Y && Y.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in B && (Y.timeout = B.requestTimeout, Y.ontimeout = function() {
                  b.emit("requestTimeout");
                }), V.forEach(function(re) {
                  Y.setRequestHeader(re[0], re[1]);
                }), b._response = null, Y.onreadystatechange = function() {
                  switch (Y.readyState) {
                    case m.LOADING:
                    case m.DONE:
                      b._onXHRProgress();
                      break;
                  }
                }, b._mode === "moz-chunked-arraybuffer" && (Y.onprogress = function() {
                  b._onXHRProgress();
                }), Y.onerror = function() {
                  b._destroyed || b.emit("error", new Error("XHR error"));
                };
                try {
                  Y.send(U);
                } catch (re) {
                  Q.nextTick(function() {
                    b.emit("error", re);
                  });
                  return;
                }
              }
            }
          };
          function w(b) {
            try {
              var B = b.status;
              return B !== null && B !== 0;
            } catch {
              return !1;
            }
          }
          z.prototype._onXHRProgress = function() {
            var b = this;
            !w(b._xhr) || b._destroyed || (b._response || b._connect(), b._response._onXHRProgress());
          }, z.prototype._connect = function() {
            var b = this;
            b._destroyed || (b._response = new x(b._xhr, b._fetchResponse, b._mode, b._fetchTimer), b._response.on("error", function(B) {
              b.emit("error", B);
            }), b.emit("response", b._response));
          }, z.prototype._write = function(b, B, N) {
            var U = this;
            U._body.push(b), N();
          }, z.prototype.abort = z.prototype.destroy = function() {
            var b = this;
            b._destroyed = !0, r.clearTimeout(b._fetchTimer), b._response && (b._response._destroyed = !0), b._xhr ? b._xhr.abort() : b._fetchAbortController && b._fetchAbortController.abort();
          }, z.prototype.end = function(b, B, N) {
            var U = this;
            typeof b == "function" && (N = b, b = void 0), E.Writable.prototype.end.call(U, b, B, N);
          }, z.prototype.flushHeaders = function() {
          }, z.prototype.setTimeout = function() {
          }, z.prototype.setNoDelay = function() {
          }, z.prototype.setSocketKeepAlive = function() {
          };
          var C = [
            "accept-charset",
            "accept-encoding",
            "access-control-request-headers",
            "access-control-request-method",
            "connection",
            "content-length",
            "cookie",
            "cookie2",
            "date",
            "dnt",
            "expect",
            "host",
            "keep-alive",
            "origin",
            "referer",
            "te",
            "trailer",
            "transfer-encoding",
            "upgrade",
            "via"
          ];
        }).call(this, te("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {}, te("buffer").Buffer);
      }, { "./capability": 157, "./response": 159, _process: 133, buffer: 48, inherits: 75, "readable-stream": 174 }], 159: [function(te, Ee, $) {
        (function(Q, r, F) {
          var H = te("./capability"), P = te("inherits"), M = te("readable-stream"), E = $.readyStates = {
            UNSENT: 0,
            OPENED: 1,
            HEADERS_RECEIVED: 2,
            LOADING: 3,
            DONE: 4
          }, x = $.IncomingMessage = function(m, I, z, w) {
            var C = this;
            if (M.Readable.call(C), C._mode = z, C.headers = {}, C.rawHeaders = [], C.trailers = {}, C.rawTrailers = [], C.on("end", function() {
              Q.nextTick(function() {
                C.emit("close");
              });
            }), z === "fetch") {
              let W = function() {
                B.read().then(function(q) {
                  if (!C._destroyed) {
                    if (q.done) {
                      r.clearTimeout(w), C.push(null);
                      return;
                    }
                    C.push(F.from(q.value)), W();
                  }
                }).catch(function(q) {
                  r.clearTimeout(w), C._destroyed || C.emit("error", q);
                });
              };
              if (C._fetchResponse = I, C.url = I.url, C.statusCode = I.status, C.statusMessage = I.statusText, I.headers.forEach(function(q, Y) {
                C.headers[Y.toLowerCase()] = q, C.rawHeaders.push(Y, q);
              }), H.writableStream) {
                var b = new WritableStream({
                  write: function(q) {
                    return new Promise(function(Y, re) {
                      C._destroyed ? re() : C.push(F.from(q)) ? Y() : C._resumeFetch = Y;
                    });
                  },
                  close: function() {
                    r.clearTimeout(w), C._destroyed || C.push(null);
                  },
                  abort: function(q) {
                    C._destroyed || C.emit("error", q);
                  }
                });
                try {
                  I.body.pipeTo(b).catch(function(q) {
                    r.clearTimeout(w), C._destroyed || C.emit("error", q);
                  });
                  return;
                } catch {
                }
              }
              var B = I.body.getReader();
              W();
            } else {
              C._xhr = m, C._pos = 0, C.url = m.responseURL, C.statusCode = m.status, C.statusMessage = m.statusText;
              var N = m.getAllResponseHeaders().split(/\r?\n/);
              if (N.forEach(function(W) {
                var q = W.match(/^([^:]+):\s*(.*)/);
                if (q) {
                  var Y = q[1].toLowerCase();
                  Y === "set-cookie" ? (C.headers[Y] === void 0 && (C.headers[Y] = []), C.headers[Y].push(q[2])) : C.headers[Y] !== void 0 ? C.headers[Y] += ", " + q[2] : C.headers[Y] = q[2], C.rawHeaders.push(q[1], q[2]);
                }
              }), C._charset = "x-user-defined", !H.overrideMimeType) {
                var U = C.rawHeaders["mime-type"];
                if (U) {
                  var V = U.match(/;\s*charset=([^;])(;|$)/);
                  V && (C._charset = V[1].toLowerCase());
                }
                C._charset || (C._charset = "utf-8");
              }
            }
          };
          P(x, M.Readable), x.prototype._read = function() {
            var m = this, I = m._resumeFetch;
            I && (m._resumeFetch = null, I());
          }, x.prototype._onXHRProgress = function() {
            var m = this, I = m._xhr, z = null;
            switch (m._mode) {
              case "text":
                if (z = I.responseText, z.length > m._pos) {
                  var w = z.substr(m._pos);
                  if (m._charset === "x-user-defined") {
                    for (var C = F.alloc(w.length), b = 0; b < w.length; b++)
                      C[b] = w.charCodeAt(b) & 255;
                    m.push(C);
                  } else
                    m.push(w, m._charset);
                  m._pos = z.length;
                }
                break;
              case "arraybuffer":
                if (I.readyState !== E.DONE || !I.response)
                  break;
                z = I.response, m.push(F.from(new Uint8Array(z)));
                break;
              case "moz-chunked-arraybuffer":
                if (z = I.response, I.readyState !== E.LOADING || !z)
                  break;
                m.push(F.from(new Uint8Array(z)));
                break;
              case "ms-stream":
                if (z = I.response, I.readyState !== E.LOADING)
                  break;
                var B = new r.MSStreamReader();
                B.onprogress = function() {
                  B.result.byteLength > m._pos && (m.push(F.from(new Uint8Array(B.result.slice(m._pos)))), m._pos = B.result.byteLength);
                }, B.onload = function() {
                  m.push(null);
                }, B.readAsArrayBuffer(z);
                break;
            }
            m._xhr.readyState === E.DONE && m._mode !== "ms-stream" && m.push(null);
          };
        }).call(this, te("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {}, te("buffer").Buffer);
      }, { "./capability": 157, _process: 133, buffer: 48, inherits: 75, "readable-stream": 174 }], 160: [function(te, Ee, $) {
        function Q(x, m) {
          x.prototype = Object.create(m.prototype), x.prototype.constructor = x, x.__proto__ = m;
        }
        var r = {};
        function F(x, m, I) {
          I || (I = Error);
          function z(C, b, B) {
            return typeof m == "string" ? m : m(C, b, B);
          }
          var w = /* @__PURE__ */ function(C) {
            Q(b, C);
            function b(B, N, U) {
              return C.call(this, z(B, N, U)) || this;
            }
            return b;
          }(I);
          w.prototype.name = I.name, w.prototype.code = x, r[x] = w;
        }
        function H(x, m) {
          if (Array.isArray(x)) {
            var I = x.length;
            return x = x.map(function(z) {
              return String(z);
            }), I > 2 ? "one of ".concat(m, " ").concat(x.slice(0, I - 1).join(", "), ", or ") + x[I - 1] : I === 2 ? "one of ".concat(m, " ").concat(x[0], " or ").concat(x[1]) : "of ".concat(m, " ").concat(x[0]);
          } else
            return "of ".concat(m, " ").concat(String(x));
        }
        function P(x, m, I) {
          return x.substr(0, m.length) === m;
        }
        function M(x, m, I) {
          return (I === void 0 || I > x.length) && (I = x.length), x.substring(I - m.length, I) === m;
        }
        function E(x, m, I) {
          return typeof I != "number" && (I = 0), I + m.length > x.length ? !1 : x.indexOf(m, I) !== -1;
        }
        F("ERR_INVALID_OPT_VALUE", function(x, m) {
          return 'The value "' + m + '" is invalid for option "' + x + '"';
        }, TypeError), F("ERR_INVALID_ARG_TYPE", function(x, m, I) {
          var z;
          typeof m == "string" && P(m, "not ") ? (z = "must not be", m = m.replace(/^not /, "")) : z = "must be";
          var w;
          if (M(x, " argument"))
            w = "The ".concat(x, " ").concat(z, " ").concat(H(m, "type"));
          else {
            var C = E(x, ".") ? "property" : "argument";
            w = 'The "'.concat(x, '" ').concat(C, " ").concat(z, " ").concat(H(m, "type"));
          }
          return w += ". Received type ".concat(typeof I), w;
        }, TypeError), F("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), F("ERR_METHOD_NOT_IMPLEMENTED", function(x) {
          return "The " + x + " method is not implemented";
        }), F("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), F("ERR_STREAM_DESTROYED", function(x) {
          return "Cannot call " + x + " after a stream was destroyed";
        }), F("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), F("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), F("ERR_STREAM_WRITE_AFTER_END", "write after end"), F("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), F("ERR_UNKNOWN_ENCODING", function(x) {
          return "Unknown encoding: " + x;
        }, TypeError), F("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Ee.exports.codes = r;
      }, {}], 161: [function(te, Ee, $) {
        (function(Q) {
          var r = /* @__PURE__ */ new Set();
          function F(P) {
            if (!r.has(P)) {
              var M = P + " is an experimental feature. This feature could change at any time";
              r.add(P), Q.emitWarning(M, "ExperimentalWarning");
            }
          }
          function H() {
          }
          Ee.exports.emitExperimentalWarning = Q.emitWarning ? F : H;
        }).call(this, te("_process"));
      }, { _process: 133 }], 162: [function(te, Ee, $) {
        (function(Q) {
          var r = Object.keys || function(z) {
            var w = [];
            for (var C in z)
              w.push(C);
            return w;
          };
          Ee.exports = x;
          var F = te("./_stream_readable"), H = te("./_stream_writable");
          te("inherits")(x, F);
          for (var P = r(H.prototype), M = 0; M < P.length; M++) {
            var E = P[M];
            x.prototype[E] || (x.prototype[E] = H.prototype[E]);
          }
          function x(z) {
            if (!(this instanceof x)) return new x(z);
            F.call(this, z), H.call(this, z), this.allowHalfOpen = !0, z && (z.readable === !1 && (this.readable = !1), z.writable === !1 && (this.writable = !1), z.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", m)));
          }
          Object.defineProperty(x.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.highWaterMark;
            }
          }), Object.defineProperty(x.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState && this._writableState.getBuffer();
            }
          }), Object.defineProperty(x.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.length;
            }
          });
          function m() {
            this._writableState.ended || Q.nextTick(I, this);
          }
          function I(z) {
            z.end();
          }
          Object.defineProperty(x.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function(w) {
              this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = w, this._writableState.destroyed = w);
            }
          });
        }).call(this, te("_process"));
      }, { "./_stream_readable": 164, "./_stream_writable": 166, _process: 133, inherits: 75 }], 163: [function(te, Ee, $) {
        Ee.exports = r;
        var Q = te("./_stream_transform");
        te("inherits")(r, Q);
        function r(F) {
          if (!(this instanceof r)) return new r(F);
          Q.call(this, F);
        }
        r.prototype._transform = function(F, H, P) {
          P(null, F);
        };
      }, { "./_stream_transform": 165, inherits: 75 }], 164: [function(te, Ee, $) {
        (function(Q, r) {
          Ee.exports = xe;
          var F;
          xe.ReadableState = Me, te("events").EventEmitter;
          var H = function(fe, We) {
            return fe.listeners(We).length;
          }, P = te("./internal/streams/stream"), M = te("buffer").Buffer, E = r.Uint8Array || function() {
          };
          function x(_e) {
            return M.from(_e);
          }
          function m(_e) {
            return M.isBuffer(_e) || _e instanceof E;
          }
          var I = te("util"), z;
          I && I.debuglog ? z = I.debuglog("stream") : z = function() {
          };
          var w = te("./internal/streams/buffer_list"), C = te("./internal/streams/destroy"), b = te("./internal/streams/state"), B = b.getHighWaterMark, N = te("../errors").codes, U = N.ERR_INVALID_ARG_TYPE, V = N.ERR_STREAM_PUSH_AFTER_EOF, W = N.ERR_METHOD_NOT_IMPLEMENTED, q = N.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Y = te("../experimentalWarning"), re = Y.emitExperimentalWarning, se, ve;
          te("inherits")(xe, P);
          var ce = ["error", "close", "destroy", "pause", "resume"];
          function be(_e, fe, We) {
            if (typeof _e.prependListener == "function") return _e.prependListener(fe, We);
            !_e._events || !_e._events[fe] ? _e.on(fe, We) : Array.isArray(_e._events[fe]) ? _e._events[fe].unshift(We) : _e._events[fe] = [We, _e._events[fe]];
          }
          function Me(_e, fe, We) {
            F = F || te("./_stream_duplex"), _e = _e || {}, typeof We != "boolean" && (We = fe instanceof F), this.objectMode = !!_e.objectMode, We && (this.objectMode = this.objectMode || !!_e.readableObjectMode), this.highWaterMark = B(this, _e, "readableHighWaterMark", We), this.buffer = new w(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = _e.emitClose !== !1, this.destroyed = !1, this.defaultEncoding = _e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, _e.encoding && (se || (se = te("string_decoder/").StringDecoder), this.decoder = new se(_e.encoding), this.encoding = _e.encoding);
          }
          function xe(_e) {
            if (F = F || te("./_stream_duplex"), !(this instanceof xe)) return new xe(_e);
            var fe = this instanceof F;
            this._readableState = new Me(_e, this, fe), this.readable = !0, _e && (typeof _e.read == "function" && (this._read = _e.read), typeof _e.destroy == "function" && (this._destroy = _e.destroy)), P.call(this);
          }
          Object.defineProperty(xe.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState === void 0 ? !1 : this._readableState.destroyed;
            },
            set: function(fe) {
              this._readableState && (this._readableState.destroyed = fe);
            }
          }), xe.prototype.destroy = C.destroy, xe.prototype._undestroy = C.undestroy, xe.prototype._destroy = function(_e, fe) {
            fe(_e);
          }, xe.prototype.push = function(_e, fe) {
            var We = this._readableState, Pe;
            return We.objectMode ? Pe = !0 : typeof _e == "string" && (fe = fe || We.defaultEncoding, fe !== We.encoding && (_e = M.from(_e, fe), fe = ""), Pe = !0), le(this, _e, fe, !1, Pe);
          }, xe.prototype.unshift = function(_e) {
            return le(this, _e, null, !0, !1);
          };
          function le(_e, fe, We, Pe, he) {
            z("readableAddChunk", fe);
            var ie = _e._readableState;
            if (fe === null)
              ie.reading = !1, Ie(_e, ie);
            else {
              var Xe;
              if (he || (Xe = De(ie, fe)), Xe)
                _e.emit("error", Xe);
              else if (ie.objectMode || fe && fe.length > 0)
                if (typeof fe != "string" && !ie.objectMode && Object.getPrototypeOf(fe) !== M.prototype && (fe = x(fe)), Pe)
                  ie.endEmitted ? _e.emit("error", new q()) : de(_e, ie, fe, !0);
                else if (ie.ended)
                  _e.emit("error", new V());
                else {
                  if (ie.destroyed)
                    return !1;
                  ie.reading = !1, ie.decoder && !We ? (fe = ie.decoder.write(fe), ie.objectMode || fe.length !== 0 ? de(_e, ie, fe, !1) : $e(_e, ie)) : de(_e, ie, fe, !1);
                }
              else Pe || (ie.reading = !1, $e(_e, ie));
            }
            return !ie.ended && (ie.length < ie.highWaterMark || ie.length === 0);
          }
          function de(_e, fe, We, Pe) {
            fe.flowing && fe.length === 0 && !fe.sync ? (fe.awaitDrain = 0, _e.emit("data", We)) : (fe.length += fe.objectMode ? 1 : We.length, Pe ? fe.buffer.unshift(We) : fe.buffer.push(We), fe.needReadable && je(_e)), $e(_e, fe);
          }
          function De(_e, fe) {
            var We;
            return !m(fe) && typeof fe != "string" && fe !== void 0 && !_e.objectMode && (We = new U("chunk", ["string", "Buffer", "Uint8Array"], fe)), We;
          }
          xe.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, xe.prototype.setEncoding = function(_e) {
            return se || (se = te("string_decoder/").StringDecoder), this._readableState.decoder = new se(_e), this._readableState.encoding = this._readableState.decoder.encoding, this;
          };
          var ze = 8388608;
          function Ze(_e) {
            return _e >= ze ? _e = ze : (_e--, _e |= _e >>> 1, _e |= _e >>> 2, _e |= _e >>> 4, _e |= _e >>> 8, _e |= _e >>> 16, _e++), _e;
          }
          function Ue(_e, fe) {
            return _e <= 0 || fe.length === 0 && fe.ended ? 0 : fe.objectMode ? 1 : _e !== _e ? fe.flowing && fe.length ? fe.buffer.head.data.length : fe.length : (_e > fe.highWaterMark && (fe.highWaterMark = Ze(_e)), _e <= fe.length ? _e : fe.ended ? fe.length : (fe.needReadable = !0, 0));
          }
          xe.prototype.read = function(_e) {
            z("read", _e), _e = parseInt(_e, 10);
            var fe = this._readableState, We = _e;
            if (_e !== 0 && (fe.emittedReadable = !1), _e === 0 && fe.needReadable && ((fe.highWaterMark !== 0 ? fe.length >= fe.highWaterMark : fe.length > 0) || fe.ended))
              return z("read: emitReadable", fe.length, fe.ended), fe.length === 0 && fe.ended ? rt(this) : je(this), null;
            if (_e = Ue(_e, fe), _e === 0 && fe.ended)
              return fe.length === 0 && rt(this), null;
            var Pe = fe.needReadable;
            z("need readable", Pe), (fe.length === 0 || fe.length - _e < fe.highWaterMark) && (Pe = !0, z("length less than watermark", Pe)), fe.ended || fe.reading ? (Pe = !1, z("reading or ended", Pe)) : Pe && (z("do read"), fe.reading = !0, fe.sync = !0, fe.length === 0 && (fe.needReadable = !0), this._read(fe.highWaterMark), fe.sync = !1, fe.reading || (_e = Ue(We, fe)));
            var he;
            return _e > 0 ? he = qe(_e, fe) : he = null, he === null ? (fe.needReadable = !0, _e = 0) : (fe.length -= _e, fe.awaitDrain = 0), fe.length === 0 && (fe.ended || (fe.needReadable = !0), We !== _e && fe.ended && rt(this)), he !== null && this.emit("data", he), he;
          };
          function Ie(_e, fe) {
            if (!fe.ended) {
              if (fe.decoder) {
                var We = fe.decoder.end();
                We && We.length && (fe.buffer.push(We), fe.length += fe.objectMode ? 1 : We.length);
              }
              fe.ended = !0, fe.sync ? je(_e) : (fe.needReadable = !1, fe.emittedReadable || (fe.emittedReadable = !0, Fe(_e)));
            }
          }
          function je(_e) {
            var fe = _e._readableState;
            fe.needReadable = !1, fe.emittedReadable || (z("emitReadable", fe.flowing), fe.emittedReadable = !0, Q.nextTick(Fe, _e));
          }
          function Fe(_e) {
            var fe = _e._readableState;
            z("emitReadable_", fe.destroyed, fe.length, fe.ended), !fe.destroyed && (fe.length || fe.ended) && _e.emit("readable"), fe.needReadable = !fe.flowing && !fe.ended && fe.length <= fe.highWaterMark, Ye(_e);
          }
          function $e(_e, fe) {
            fe.readingMore || (fe.readingMore = !0, Q.nextTick(ct, _e, fe));
          }
          function ct(_e, fe) {
            for (; !fe.reading && !fe.ended && (fe.length < fe.highWaterMark || fe.flowing && fe.length === 0); ) {
              var We = fe.length;
              if (z("maybeReadMore read 0"), _e.read(0), We === fe.length)
                break;
            }
            fe.readingMore = !1;
          }
          xe.prototype._read = function(_e) {
            this.emit("error", new W("_read()"));
          }, xe.prototype.pipe = function(_e, fe) {
            var We = this, Pe = this._readableState;
            switch (Pe.pipesCount) {
              case 0:
                Pe.pipes = _e;
                break;
              case 1:
                Pe.pipes = [Pe.pipes, _e];
                break;
              default:
                Pe.pipes.push(_e);
                break;
            }
            Pe.pipesCount += 1, z("pipe count=%d opts=%j", Pe.pipesCount, fe);
            var he = (!fe || fe.end !== !1) && _e !== Q.stdout && _e !== Q.stderr, ie = he ? bt : Pr;
            Pe.endEmitted ? Q.nextTick(ie) : We.once("end", ie), _e.on("unpipe", Xe);
            function Xe(hi, Vr) {
              z("onunpipe"), hi === We && Vr && Vr.hasUnpiped === !1 && (Vr.hasUnpiped = !0, Sr());
            }
            function bt() {
              z("onend"), _e.end();
            }
            var Wt = wt(We);
            _e.on("drain", Wt);
            var Qt = !1;
            function Sr() {
              z("cleanup"), _e.removeListener("close", Ur), _e.removeListener("finish", Rr), _e.removeListener("drain", Wt), _e.removeListener("error", kr), _e.removeListener("unpipe", Xe), We.removeListener("end", bt), We.removeListener("end", Pr), We.removeListener("data", Fr), Qt = !0, Pe.awaitDrain && (!_e._writableState || _e._writableState.needDrain) && Wt();
            }
            We.on("data", Fr);
            function Fr(hi) {
              z("ondata");
              var Vr = _e.write(hi);
              z("dest.write", Vr), Vr === !1 && ((Pe.pipesCount === 1 && Pe.pipes === _e || Pe.pipesCount > 1 && Ae(Pe.pipes, _e) !== -1) && !Qt && (z("false write response, pause", Pe.awaitDrain), Pe.awaitDrain++), We.pause());
            }
            function kr(hi) {
              z("onerror", hi), Pr(), _e.removeListener("error", kr), H(_e, "error") === 0 && _e.emit("error", hi);
            }
            be(_e, "error", kr);
            function Ur() {
              _e.removeListener("finish", Rr), Pr();
            }
            _e.once("close", Ur);
            function Rr() {
              z("onfinish"), _e.removeListener("close", Ur), Pr();
            }
            _e.once("finish", Rr);
            function Pr() {
              z("unpipe"), We.unpipe(_e);
            }
            return _e.emit("pipe", We), Pe.flowing || (z("pipe resume"), We.resume()), _e;
          };
          function wt(_e) {
            return function() {
              var We = _e._readableState;
              z("pipeOnDrain", We.awaitDrain), We.awaitDrain && We.awaitDrain--, We.awaitDrain === 0 && H(_e, "data") && (We.flowing = !0, Ye(_e));
            };
          }
          xe.prototype.unpipe = function(_e) {
            var fe = this._readableState, We = {
              hasUnpiped: !1
            };
            if (fe.pipesCount === 0) return this;
            if (fe.pipesCount === 1)
              return _e && _e !== fe.pipes ? this : (_e || (_e = fe.pipes), fe.pipes = null, fe.pipesCount = 0, fe.flowing = !1, _e && _e.emit("unpipe", this, We), this);
            if (!_e) {
              var Pe = fe.pipes, he = fe.pipesCount;
              fe.pipes = null, fe.pipesCount = 0, fe.flowing = !1;
              for (var ie = 0; ie < he; ie++)
                Pe[ie].emit("unpipe", this, {
                  hasUnpiped: !1
                });
              return this;
            }
            var Xe = Ae(fe.pipes, _e);
            return Xe === -1 ? this : (fe.pipes.splice(Xe, 1), fe.pipesCount -= 1, fe.pipesCount === 1 && (fe.pipes = fe.pipes[0]), _e.emit("unpipe", this, We), this);
          }, xe.prototype.on = function(_e, fe) {
            var We = P.prototype.on.call(this, _e, fe), Pe = this._readableState;
            return _e === "data" ? (Pe.readableListening = this.listenerCount("readable") > 0, Pe.flowing !== !1 && this.resume()) : _e === "readable" && !Pe.endEmitted && !Pe.readableListening && (Pe.readableListening = Pe.needReadable = !0, Pe.flowing = !1, Pe.emittedReadable = !1, z("on readable", Pe.length, Pe.reading), Pe.length ? je(this) : Pe.reading || Q.nextTick(Ct, this)), We;
          }, xe.prototype.addListener = xe.prototype.on, xe.prototype.removeListener = function(_e, fe) {
            var We = P.prototype.removeListener.call(this, _e, fe);
            return _e === "readable" && Q.nextTick(Oe, this), We;
          }, xe.prototype.removeAllListeners = function(_e) {
            var fe = P.prototype.removeAllListeners.apply(this, arguments);
            return (_e === "readable" || _e === void 0) && Q.nextTick(Oe, this), fe;
          };
          function Oe(_e) {
            var fe = _e._readableState;
            fe.readableListening = _e.listenerCount("readable") > 0, fe.resumeScheduled && !fe.paused ? fe.flowing = !0 : _e.listenerCount("data") > 0 && _e.resume();
          }
          function Ct(_e) {
            z("readable nexttick read 0"), _e.read(0);
          }
          xe.prototype.resume = function() {
            var _e = this._readableState;
            return _e.flowing || (z("resume"), _e.flowing = !_e.readableListening, Xt(this, _e)), _e.paused = !1, this;
          };
          function Xt(_e, fe) {
            fe.resumeScheduled || (fe.resumeScheduled = !0, Q.nextTick(vt, _e, fe));
          }
          function vt(_e, fe) {
            z("resume", fe.reading), fe.reading || _e.read(0), fe.resumeScheduled = !1, _e.emit("resume"), Ye(_e), fe.flowing && !fe.reading && _e.read(0);
          }
          xe.prototype.pause = function() {
            return z("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (z("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
          };
          function Ye(_e) {
            var fe = _e._readableState;
            for (z("flow", fe.flowing); fe.flowing && _e.read() !== null; )
              ;
          }
          xe.prototype.wrap = function(_e) {
            var fe = this, We = this._readableState, Pe = !1;
            _e.on("end", function() {
              if (z("wrapped end"), We.decoder && !We.ended) {
                var Xe = We.decoder.end();
                Xe && Xe.length && fe.push(Xe);
              }
              fe.push(null);
            }), _e.on("data", function(Xe) {
              if (z("wrapped data"), We.decoder && (Xe = We.decoder.write(Xe)), !(We.objectMode && Xe == null) && !(!We.objectMode && (!Xe || !Xe.length))) {
                var bt = fe.push(Xe);
                bt || (Pe = !0, _e.pause());
              }
            });
            for (var he in _e)
              this[he] === void 0 && typeof _e[he] == "function" && (this[he] = /* @__PURE__ */ function(bt) {
                return function() {
                  return _e[bt].apply(_e, arguments);
                };
              }(he));
            for (var ie = 0; ie < ce.length; ie++)
              _e.on(ce[ie], this.emit.bind(this, ce[ie]));
            return this._read = function(Xe) {
              z("wrapped _read", Xe), Pe && (Pe = !1, _e.resume());
            }, this;
          }, typeof Symbol == "function" && (xe.prototype[Symbol.asyncIterator] = function() {
            return re("Readable[Symbol.asyncIterator]"), ve === void 0 && (ve = te("./internal/streams/async_iterator")), ve(this);
          }), Object.defineProperty(xe.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.highWaterMark;
            }
          }), Object.defineProperty(xe.prototype, "readableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState && this._readableState.buffer;
            }
          }), Object.defineProperty(xe.prototype, "readableFlowing", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.flowing;
            },
            set: function(fe) {
              this._readableState && (this._readableState.flowing = fe);
            }
          }), xe._fromList = qe, Object.defineProperty(xe.prototype, "readableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.length;
            }
          });
          function qe(_e, fe) {
            if (fe.length === 0) return null;
            var We;
            return fe.objectMode ? We = fe.buffer.shift() : !_e || _e >= fe.length ? (fe.decoder ? We = fe.buffer.join("") : fe.buffer.length === 1 ? We = fe.buffer.first() : We = fe.buffer.concat(fe.length), fe.buffer.clear()) : We = fe.buffer.consume(_e, fe.decoder), We;
          }
          function rt(_e) {
            var fe = _e._readableState;
            z("endReadable", fe.endEmitted), fe.endEmitted || (fe.ended = !0, Q.nextTick(it, fe, _e));
          }
          function it(_e, fe) {
            z("endReadableNT", _e.endEmitted, _e.length), !_e.endEmitted && _e.length === 0 && (_e.endEmitted = !0, fe.readable = !1, fe.emit("end"));
          }
          function Ae(_e, fe) {
            for (var We = 0, Pe = _e.length; We < Pe; We++)
              if (_e[We] === fe) return We;
            return -1;
          }
        }).call(this, te("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {});
      }, { "../errors": 160, "../experimentalWarning": 161, "./_stream_duplex": 162, "./internal/streams/async_iterator": 167, "./internal/streams/buffer_list": 168, "./internal/streams/destroy": 169, "./internal/streams/state": 172, "./internal/streams/stream": 173, _process: 133, buffer: 48, events: 52, inherits: 75, "string_decoder/": 175, util: 33 }], 165: [function(te, Ee, $) {
        Ee.exports = x;
        var Q = te("../errors").codes, r = Q.ERR_METHOD_NOT_IMPLEMENTED, F = Q.ERR_MULTIPLE_CALLBACK, H = Q.ERR_TRANSFORM_ALREADY_TRANSFORMING, P = Q.ERR_TRANSFORM_WITH_LENGTH_0, M = te("./_stream_duplex");
        te("inherits")(x, M);
        function E(z, w) {
          var C = this._transformState;
          C.transforming = !1;
          var b = C.writecb;
          if (b === null)
            return this.emit("error", new F());
          C.writechunk = null, C.writecb = null, w != null && this.push(w), b(z);
          var B = this._readableState;
          B.reading = !1, (B.needReadable || B.length < B.highWaterMark) && this._read(B.highWaterMark);
        }
        function x(z) {
          if (!(this instanceof x)) return new x(z);
          M.call(this, z), this._transformState = {
            afterTransform: E.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }, this._readableState.needReadable = !0, this._readableState.sync = !1, z && (typeof z.transform == "function" && (this._transform = z.transform), typeof z.flush == "function" && (this._flush = z.flush)), this.on("prefinish", m);
        }
        function m() {
          var z = this;
          typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(w, C) {
            I(z, w, C);
          }) : I(this, null, null);
        }
        x.prototype.push = function(z, w) {
          return this._transformState.needTransform = !1, M.prototype.push.call(this, z, w);
        }, x.prototype._transform = function(z, w, C) {
          C(new r("_transform()"));
        }, x.prototype._write = function(z, w, C) {
          var b = this._transformState;
          if (b.writecb = C, b.writechunk = z, b.writeencoding = w, !b.transforming) {
            var B = this._readableState;
            (b.needTransform || B.needReadable || B.length < B.highWaterMark) && this._read(B.highWaterMark);
          }
        }, x.prototype._read = function(z) {
          var w = this._transformState;
          w.writechunk !== null && !w.transforming ? (w.transforming = !0, this._transform(w.writechunk, w.writeencoding, w.afterTransform)) : w.needTransform = !0;
        }, x.prototype._destroy = function(z, w) {
          M.prototype._destroy.call(this, z, function(C) {
            w(C);
          });
        };
        function I(z, w, C) {
          if (w) return z.emit("error", w);
          if (C != null && z.push(C), z._writableState.length) throw new P();
          if (z._transformState.transforming) throw new H();
          return z.push(null);
        }
      }, { "../errors": 160, "./_stream_duplex": 162, inherits: 75 }], 166: [function(te, Ee, $) {
        (function(Q, r) {
          Ee.exports = be;
          function F(vt) {
            var Ye = this;
            this.next = null, this.entry = null, this.finish = function() {
              Xt(Ye, vt);
            };
          }
          var H;
          be.WritableState = ve;
          var P = {
            deprecate: te("util-deprecate")
          }, M = te("./internal/streams/stream"), E = te("buffer").Buffer, x = r.Uint8Array || function() {
          };
          function m(vt) {
            return E.from(vt);
          }
          function I(vt) {
            return E.isBuffer(vt) || vt instanceof x;
          }
          var z = te("./internal/streams/destroy"), w = te("./internal/streams/state"), C = w.getHighWaterMark, b = te("../errors").codes, B = b.ERR_INVALID_ARG_TYPE, N = b.ERR_METHOD_NOT_IMPLEMENTED, U = b.ERR_MULTIPLE_CALLBACK, V = b.ERR_STREAM_CANNOT_PIPE, W = b.ERR_STREAM_DESTROYED, q = b.ERR_STREAM_NULL_VALUES, Y = b.ERR_STREAM_WRITE_AFTER_END, re = b.ERR_UNKNOWN_ENCODING;
          te("inherits")(be, M);
          function se() {
          }
          function ve(vt, Ye, qe) {
            H = H || te("./_stream_duplex"), vt = vt || {}, typeof qe != "boolean" && (qe = Ye instanceof H), this.objectMode = !!vt.objectMode, qe && (this.objectMode = this.objectMode || !!vt.writableObjectMode), this.highWaterMark = C(this, vt, "writableHighWaterMark", qe), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var rt = vt.decodeStrings === !1;
            this.decodeStrings = !rt, this.defaultEncoding = vt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(it) {
              Ue(Ye, it);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = vt.emitClose !== !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new F(this);
          }
          ve.prototype.getBuffer = function() {
            for (var Ye = this.bufferedRequest, qe = []; Ye; )
              qe.push(Ye), Ye = Ye.next;
            return qe;
          }, function() {
            try {
              Object.defineProperty(ve.prototype, "buffer", {
                get: P.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch {
            }
          }();
          var ce;
          typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ce = Function.prototype[Symbol.hasInstance], Object.defineProperty(be, Symbol.hasInstance, {
            value: function(Ye) {
              return ce.call(this, Ye) ? !0 : this !== be ? !1 : Ye && Ye._writableState instanceof ve;
            }
          })) : ce = function(Ye) {
            return Ye instanceof this;
          };
          function be(vt) {
            H = H || te("./_stream_duplex");
            var Ye = this instanceof H;
            if (!Ye && !ce.call(be, this)) return new be(vt);
            this._writableState = new ve(vt, this, Ye), this.writable = !0, vt && (typeof vt.write == "function" && (this._write = vt.write), typeof vt.writev == "function" && (this._writev = vt.writev), typeof vt.destroy == "function" && (this._destroy = vt.destroy), typeof vt.final == "function" && (this._final = vt.final)), M.call(this);
          }
          be.prototype.pipe = function() {
            this.emit("error", new V());
          };
          function Me(vt, Ye) {
            var qe = new Y();
            vt.emit("error", qe), Q.nextTick(Ye, qe);
          }
          function xe(vt, Ye, qe, rt) {
            var it;
            return qe === null ? it = new q() : typeof qe != "string" && !Ye.objectMode && (it = new B("chunk", ["string", "Buffer"], qe)), it ? (vt.emit("error", it), Q.nextTick(rt, it), !1) : !0;
          }
          be.prototype.write = function(vt, Ye, qe) {
            var rt = this._writableState, it = !1, Ae = !rt.objectMode && I(vt);
            return Ae && !E.isBuffer(vt) && (vt = m(vt)), typeof Ye == "function" && (qe = Ye, Ye = null), Ae ? Ye = "buffer" : Ye || (Ye = rt.defaultEncoding), typeof qe != "function" && (qe = se), rt.ending ? Me(this, qe) : (Ae || xe(this, rt, vt, qe)) && (rt.pendingcb++, it = de(this, rt, Ae, vt, Ye, qe)), it;
          }, be.prototype.cork = function() {
            this._writableState.corked++;
          }, be.prototype.uncork = function() {
            var vt = this._writableState;
            vt.corked && (vt.corked--, !vt.writing && !vt.corked && !vt.bufferProcessing && vt.bufferedRequest && Fe(this, vt));
          }, be.prototype.setDefaultEncoding = function(Ye) {
            if (typeof Ye == "string" && (Ye = Ye.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Ye + "").toLowerCase()) > -1)) throw new re(Ye);
            return this._writableState.defaultEncoding = Ye, this;
          }, Object.defineProperty(be.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          function le(vt, Ye, qe) {
            return !vt.objectMode && vt.decodeStrings !== !1 && typeof Ye == "string" && (Ye = E.from(Ye, qe)), Ye;
          }
          Object.defineProperty(be.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.highWaterMark;
            }
          });
          function de(vt, Ye, qe, rt, it, Ae) {
            if (!qe) {
              var _e = le(Ye, rt, it);
              rt !== _e && (qe = !0, it = "buffer", rt = _e);
            }
            var fe = Ye.objectMode ? 1 : rt.length;
            Ye.length += fe;
            var We = Ye.length < Ye.highWaterMark;
            if (We || (Ye.needDrain = !0), Ye.writing || Ye.corked) {
              var Pe = Ye.lastBufferedRequest;
              Ye.lastBufferedRequest = {
                chunk: rt,
                encoding: it,
                isBuf: qe,
                callback: Ae,
                next: null
              }, Pe ? Pe.next = Ye.lastBufferedRequest : Ye.bufferedRequest = Ye.lastBufferedRequest, Ye.bufferedRequestCount += 1;
            } else
              De(vt, Ye, !1, fe, rt, it, Ae);
            return We;
          }
          function De(vt, Ye, qe, rt, it, Ae, _e) {
            Ye.writelen = rt, Ye.writecb = _e, Ye.writing = !0, Ye.sync = !0, Ye.destroyed ? Ye.onwrite(new W("write")) : qe ? vt._writev(it, Ye.onwrite) : vt._write(it, Ae, Ye.onwrite), Ye.sync = !1;
          }
          function ze(vt, Ye, qe, rt, it) {
            --Ye.pendingcb, qe ? (Q.nextTick(it, rt), Q.nextTick(Oe, vt, Ye), vt._writableState.errorEmitted = !0, vt.emit("error", rt)) : (it(rt), vt._writableState.errorEmitted = !0, vt.emit("error", rt), Oe(vt, Ye));
          }
          function Ze(vt) {
            vt.writing = !1, vt.writecb = null, vt.length -= vt.writelen, vt.writelen = 0;
          }
          function Ue(vt, Ye) {
            var qe = vt._writableState, rt = qe.sync, it = qe.writecb;
            if (typeof it != "function") throw new U();
            if (Ze(qe), Ye) ze(vt, qe, rt, Ye, it);
            else {
              var Ae = $e(qe) || vt.destroyed;
              !Ae && !qe.corked && !qe.bufferProcessing && qe.bufferedRequest && Fe(vt, qe), rt ? Q.nextTick(Ie, vt, qe, Ae, it) : Ie(vt, qe, Ae, it);
            }
          }
          function Ie(vt, Ye, qe, rt) {
            qe || je(vt, Ye), Ye.pendingcb--, rt(), Oe(vt, Ye);
          }
          function je(vt, Ye) {
            Ye.length === 0 && Ye.needDrain && (Ye.needDrain = !1, vt.emit("drain"));
          }
          function Fe(vt, Ye) {
            Ye.bufferProcessing = !0;
            var qe = Ye.bufferedRequest;
            if (vt._writev && qe && qe.next) {
              var rt = Ye.bufferedRequestCount, it = new Array(rt), Ae = Ye.corkedRequestsFree;
              Ae.entry = qe;
              for (var _e = 0, fe = !0; qe; )
                it[_e] = qe, qe.isBuf || (fe = !1), qe = qe.next, _e += 1;
              it.allBuffers = fe, De(vt, Ye, !0, Ye.length, it, "", Ae.finish), Ye.pendingcb++, Ye.lastBufferedRequest = null, Ae.next ? (Ye.corkedRequestsFree = Ae.next, Ae.next = null) : Ye.corkedRequestsFree = new F(Ye), Ye.bufferedRequestCount = 0;
            } else {
              for (; qe; ) {
                var We = qe.chunk, Pe = qe.encoding, he = qe.callback, ie = Ye.objectMode ? 1 : We.length;
                if (De(vt, Ye, !1, ie, We, Pe, he), qe = qe.next, Ye.bufferedRequestCount--, Ye.writing)
                  break;
              }
              qe === null && (Ye.lastBufferedRequest = null);
            }
            Ye.bufferedRequest = qe, Ye.bufferProcessing = !1;
          }
          be.prototype._write = function(vt, Ye, qe) {
            qe(new N("_write()"));
          }, be.prototype._writev = null, be.prototype.end = function(vt, Ye, qe) {
            var rt = this._writableState;
            return typeof vt == "function" ? (qe = vt, vt = null, Ye = null) : typeof Ye == "function" && (qe = Ye, Ye = null), vt != null && this.write(vt, Ye), rt.corked && (rt.corked = 1, this.uncork()), rt.ending || Ct(this, rt, qe), this;
          }, Object.defineProperty(be.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.length;
            }
          });
          function $e(vt) {
            return vt.ending && vt.length === 0 && vt.bufferedRequest === null && !vt.finished && !vt.writing;
          }
          function ct(vt, Ye) {
            vt._final(function(qe) {
              Ye.pendingcb--, qe && vt.emit("error", qe), Ye.prefinished = !0, vt.emit("prefinish"), Oe(vt, Ye);
            });
          }
          function wt(vt, Ye) {
            !Ye.prefinished && !Ye.finalCalled && (typeof vt._final == "function" && !Ye.destroyed ? (Ye.pendingcb++, Ye.finalCalled = !0, Q.nextTick(ct, vt, Ye)) : (Ye.prefinished = !0, vt.emit("prefinish")));
          }
          function Oe(vt, Ye) {
            var qe = $e(Ye);
            return qe && (wt(vt, Ye), Ye.pendingcb === 0 && (Ye.finished = !0, vt.emit("finish"))), qe;
          }
          function Ct(vt, Ye, qe) {
            Ye.ending = !0, Oe(vt, Ye), qe && (Ye.finished ? Q.nextTick(qe) : vt.once("finish", qe)), Ye.ended = !0, vt.writable = !1;
          }
          function Xt(vt, Ye, qe) {
            var rt = vt.entry;
            for (vt.entry = null; rt; ) {
              var it = rt.callback;
              Ye.pendingcb--, it(qe), rt = rt.next;
            }
            Ye.corkedRequestsFree.next = vt;
          }
          Object.defineProperty(be.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState === void 0 ? !1 : this._writableState.destroyed;
            },
            set: function(Ye) {
              this._writableState && (this._writableState.destroyed = Ye);
            }
          }), be.prototype.destroy = z.destroy, be.prototype._undestroy = z.undestroy, be.prototype._destroy = function(vt, Ye) {
            Ye(vt);
          };
        }).call(this, te("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {});
      }, { "../errors": 160, "./_stream_duplex": 162, "./internal/streams/destroy": 169, "./internal/streams/state": 172, "./internal/streams/stream": 173, _process: 133, buffer: 48, inherits: 75, "util-deprecate": 183 }], 167: [function(te, Ee, $) {
        (function(Q) {
          var r;
          function F(W, q, Y) {
            return q in W ? Object.defineProperty(W, q, { value: Y, enumerable: !0, configurable: !0, writable: !0 }) : W[q] = Y, W;
          }
          var H = te("./end-of-stream"), P = Symbol("lastResolve"), M = Symbol("lastReject"), E = Symbol("error"), x = Symbol("ended"), m = Symbol("lastPromise"), I = Symbol("handlePromise"), z = Symbol("stream");
          function w(W, q) {
            return {
              value: W,
              done: q
            };
          }
          function C(W) {
            var q = W[P];
            if (q !== null) {
              var Y = W[z].read();
              Y !== null && (W[m] = null, W[P] = null, W[M] = null, q(w(Y, !1)));
            }
          }
          function b(W) {
            Q.nextTick(C, W);
          }
          function B(W, q) {
            return function(Y, re) {
              W.then(function() {
                if (q[x]) {
                  Y(w(void 0, !0));
                  return;
                }
                q[I](Y, re);
              }, re);
            };
          }
          var N = Object.getPrototypeOf(function() {
          }), U = Object.setPrototypeOf((r = {
            get stream() {
              return this[z];
            },
            next: function() {
              var q = this, Y = this[E];
              if (Y !== null)
                return Promise.reject(Y);
              if (this[x])
                return Promise.resolve(w(void 0, !0));
              if (this[z].destroyed)
                return new Promise(function(ce, be) {
                  Q.nextTick(function() {
                    q[E] ? be(q[E]) : ce(w(void 0, !0));
                  });
                });
              var re = this[m], se;
              if (re)
                se = new Promise(B(re, this));
              else {
                var ve = this[z].read();
                if (ve !== null)
                  return Promise.resolve(w(ve, !1));
                se = new Promise(this[I]);
              }
              return this[m] = se, se;
            }
          }, F(r, Symbol.asyncIterator, function() {
            return this;
          }), F(r, "return", function() {
            var q = this;
            return new Promise(function(Y, re) {
              q[z].destroy(null, function(se) {
                if (se) {
                  re(se);
                  return;
                }
                Y(w(void 0, !0));
              });
            });
          }), r), N), V = function(q) {
            var Y, re = Object.create(U, (Y = {}, F(Y, z, {
              value: q,
              writable: !0
            }), F(Y, P, {
              value: null,
              writable: !0
            }), F(Y, M, {
              value: null,
              writable: !0
            }), F(Y, E, {
              value: null,
              writable: !0
            }), F(Y, x, {
              value: q._readableState.endEmitted,
              writable: !0
            }), F(Y, I, {
              value: function(ve, ce) {
                var be = re[z].read();
                be ? (re[m] = null, re[P] = null, re[M] = null, ve(w(be, !1))) : (re[P] = ve, re[M] = ce);
              },
              writable: !0
            }), Y));
            return re[m] = null, H(q, function(se) {
              if (se && se.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var ve = re[M];
                ve !== null && (re[m] = null, re[P] = null, re[M] = null, ve(se)), re[E] = se;
                return;
              }
              var ce = re[P];
              ce !== null && (re[m] = null, re[P] = null, re[M] = null, ce(w(void 0, !0))), re[x] = !0;
            }), q.on("readable", b.bind(null, re)), re;
          };
          Ee.exports = V;
        }).call(this, te("_process"));
      }, { "./end-of-stream": 170, _process: 133 }], 168: [function(te, Ee, $) {
        function Q(m) {
          for (var I = 1; I < arguments.length; I++) {
            var z = arguments[I] != null ? arguments[I] : {}, w = Object.keys(z);
            typeof Object.getOwnPropertySymbols == "function" && (w = w.concat(Object.getOwnPropertySymbols(z).filter(function(C) {
              return Object.getOwnPropertyDescriptor(z, C).enumerable;
            }))), w.forEach(function(C) {
              r(m, C, z[C]);
            });
          }
          return m;
        }
        function r(m, I, z) {
          return I in m ? Object.defineProperty(m, I, { value: z, enumerable: !0, configurable: !0, writable: !0 }) : m[I] = z, m;
        }
        var F = te("buffer"), H = F.Buffer, P = te("util"), M = P.inspect, E = M && M.custom || "inspect";
        function x(m, I, z) {
          H.prototype.copy.call(m, I, z);
        }
        Ee.exports = /* @__PURE__ */ function() {
          function m() {
            this.head = null, this.tail = null, this.length = 0;
          }
          var I = m.prototype;
          return I.push = function(w) {
            var C = {
              data: w,
              next: null
            };
            this.length > 0 ? this.tail.next = C : this.head = C, this.tail = C, ++this.length;
          }, I.unshift = function(w) {
            var C = {
              data: w,
              next: this.head
            };
            this.length === 0 && (this.tail = C), this.head = C, ++this.length;
          }, I.shift = function() {
            if (this.length !== 0) {
              var w = this.head.data;
              return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, w;
            }
          }, I.clear = function() {
            this.head = this.tail = null, this.length = 0;
          }, I.join = function(w) {
            if (this.length === 0) return "";
            for (var C = this.head, b = "" + C.data; C = C.next; )
              b += w + C.data;
            return b;
          }, I.concat = function(w) {
            if (this.length === 0) return H.alloc(0);
            for (var C = H.allocUnsafe(w >>> 0), b = this.head, B = 0; b; )
              x(b.data, C, B), B += b.data.length, b = b.next;
            return C;
          }, I.consume = function(w, C) {
            var b;
            return w < this.head.data.length ? (b = this.head.data.slice(0, w), this.head.data = this.head.data.slice(w)) : w === this.head.data.length ? b = this.shift() : b = C ? this._getString(w) : this._getBuffer(w), b;
          }, I.first = function() {
            return this.head.data;
          }, I._getString = function(w) {
            var C = this.head, b = 1, B = C.data;
            for (w -= B.length; C = C.next; ) {
              var N = C.data, U = w > N.length ? N.length : w;
              if (U === N.length ? B += N : B += N.slice(0, w), w -= U, w === 0) {
                U === N.length ? (++b, C.next ? this.head = C.next : this.head = this.tail = null) : (this.head = C, C.data = N.slice(U));
                break;
              }
              ++b;
            }
            return this.length -= b, B;
          }, I._getBuffer = function(w) {
            var C = H.allocUnsafe(w), b = this.head, B = 1;
            for (b.data.copy(C), w -= b.data.length; b = b.next; ) {
              var N = b.data, U = w > N.length ? N.length : w;
              if (N.copy(C, C.length - w, 0, U), w -= U, w === 0) {
                U === N.length ? (++B, b.next ? this.head = b.next : this.head = this.tail = null) : (this.head = b, b.data = N.slice(U));
                break;
              }
              ++B;
            }
            return this.length -= B, C;
          }, I[E] = function(z, w) {
            return M(this, Q({}, w, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: !1
            }));
          }, m;
        }();
      }, { buffer: 48, util: 33 }], 169: [function(te, Ee, $) {
        (function(Q) {
          function r(E, x) {
            var m = this, I = this._readableState && this._readableState.destroyed, z = this._writableState && this._writableState.destroyed;
            return I || z ? (x ? x(E) : E && (!this._writableState || !this._writableState.errorEmitted) && Q.nextTick(M, this, E), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(E || null, function(w) {
              !x && w ? (Q.nextTick(F, m, w), m._writableState && (m._writableState.errorEmitted = !0)) : x ? (Q.nextTick(H, m), x(w)) : Q.nextTick(H, m);
            }), this);
          }
          function F(E, x) {
            M(E, x), H(E);
          }
          function H(E) {
            E._writableState && !E._writableState.emitClose || E._readableState && !E._readableState.emitClose || E.emit("close");
          }
          function P() {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
          }
          function M(E, x) {
            E.emit("error", x);
          }
          Ee.exports = {
            destroy: r,
            undestroy: P
          };
        }).call(this, te("_process"));
      }, { _process: 133 }], 170: [function(te, Ee, $) {
        var Q = te("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function r(M) {
          var E = !1;
          return function() {
            if (!E) {
              E = !0;
              for (var x = arguments.length, m = new Array(x), I = 0; I < x; I++)
                m[I] = arguments[I];
              M.apply(this, m);
            }
          };
        }
        function F() {
        }
        function H(M) {
          return M.setHeader && typeof M.abort == "function";
        }
        function P(M, E, x) {
          if (typeof E == "function") return P(M, null, E);
          E || (E = {}), x = r(x || F);
          var m = E.readable || E.readable !== !1 && M.readable, I = E.writable || E.writable !== !1 && M.writable, z = function() {
            M.writable || C();
          }, w = M._writableState && M._writableState.finished, C = function() {
            I = !1, w = !0, m || x.call(M);
          }, b = M._readableState && M._readableState.endEmitted, B = function() {
            m = !1, b = !0, I || x.call(M);
          }, N = function(q) {
            x.call(M, q);
          }, U = function() {
            var q;
            if (m && !b)
              return (!M._readableState || !M._readableState.ended) && (q = new Q()), x.call(M, q);
            if (I && !w)
              return (!M._writableState || !M._writableState.ended) && (q = new Q()), x.call(M, q);
          }, V = function() {
            M.req.on("finish", C);
          };
          return H(M) ? (M.on("complete", C), M.on("abort", U), M.req ? V() : M.on("request", V)) : I && !M._writableState && (M.on("end", z), M.on("close", z)), M.on("end", B), M.on("finish", C), E.error !== !1 && M.on("error", N), M.on("close", U), function() {
            M.removeListener("complete", C), M.removeListener("abort", U), M.removeListener("request", V), M.req && M.req.removeListener("finish", C), M.removeListener("end", z), M.removeListener("close", z), M.removeListener("finish", C), M.removeListener("end", B), M.removeListener("error", N), M.removeListener("close", U);
          };
        }
        Ee.exports = P;
      }, { "../../../errors": 160 }], 171: [function(te, Ee, $) {
        var Q;
        function r(C) {
          var b = !1;
          return function() {
            b || (b = !0, C.apply(void 0, arguments));
          };
        }
        var F = te("../../../errors").codes, H = F.ERR_MISSING_ARGS, P = F.ERR_STREAM_DESTROYED;
        function M(C) {
          if (C) throw C;
        }
        function E(C) {
          return C.setHeader && typeof C.abort == "function";
        }
        function x(C, b, B, N) {
          N = r(N);
          var U = !1;
          C.on("close", function() {
            U = !0;
          }), Q === void 0 && (Q = te("./end-of-stream")), Q(C, {
            readable: b,
            writable: B
          }, function(W) {
            if (W) return N(W);
            U = !0, N();
          });
          var V = !1;
          return function(W) {
            if (!U && !V) {
              if (V = !0, E(C)) return C.abort();
              if (typeof C.destroy == "function") return C.destroy();
              N(W || new P("pipe"));
            }
          };
        }
        function m(C) {
          C();
        }
        function I(C, b) {
          return C.pipe(b);
        }
        function z(C) {
          return !C.length || typeof C[C.length - 1] != "function" ? M : C.pop();
        }
        function w() {
          for (var C = arguments.length, b = new Array(C), B = 0; B < C; B++)
            b[B] = arguments[B];
          var N = z(b);
          if (Array.isArray(b[0]) && (b = b[0]), b.length < 2)
            throw new H("streams");
          var U, V = b.map(function(W, q) {
            var Y = q < b.length - 1, re = q > 0;
            return x(W, Y, re, function(se) {
              U || (U = se), se && V.forEach(m), !Y && (V.forEach(m), N(U));
            });
          });
          return b.reduce(I);
        }
        Ee.exports = w;
      }, { "../../../errors": 160, "./end-of-stream": 170 }], 172: [function(te, Ee, $) {
        var Q = te("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        function r(H, P, M) {
          return H.highWaterMark != null ? H.highWaterMark : P ? H[M] : null;
        }
        function F(H, P, M, E) {
          var x = r(P, E, M);
          if (x != null) {
            if (!(isFinite(x) && Math.floor(x) === x) || x < 0) {
              var m = E ? M : "highWaterMark";
              throw new Q(m, x);
            }
            return Math.floor(x);
          }
          return H.objectMode ? 16 : 16 * 1024;
        }
        Ee.exports = {
          getHighWaterMark: F
        };
      }, { "../../../errors": 160 }], 173: [function(te, Ee, $) {
        arguments[4][146][0].apply($, arguments);
      }, { dup: 146, events: 52 }], 174: [function(te, Ee, $) {
        $ = Ee.exports = te("./lib/_stream_readable.js"), $.Stream = $, $.Readable = $, $.Writable = te("./lib/_stream_writable.js"), $.Duplex = te("./lib/_stream_duplex.js"), $.Transform = te("./lib/_stream_transform.js"), $.PassThrough = te("./lib/_stream_passthrough.js"), $.finished = te("./lib/internal/streams/end-of-stream.js"), $.pipeline = te("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 162, "./lib/_stream_passthrough.js": 163, "./lib/_stream_readable.js": 164, "./lib/_stream_transform.js": 165, "./lib/_stream_writable.js": 166, "./lib/internal/streams/end-of-stream.js": 170, "./lib/internal/streams/pipeline.js": 171 }], 175: [function(te, Ee, $) {
        arguments[4][148][0].apply($, arguments);
      }, { dup: 148, "safe-buffer": 154 }], 176: [function(te, Ee, $) {
        (function(Q, r) {
          var F = te("process/browser.js").nextTick, H = Function.prototype.apply, P = Array.prototype.slice, M = {}, E = 0;
          $.setTimeout = function() {
            return new x(H.call(setTimeout, pt, arguments), clearTimeout);
          }, $.setInterval = function() {
            return new x(H.call(setInterval, pt, arguments), clearInterval);
          }, $.clearTimeout = $.clearInterval = function(m) {
            m.close();
          };
          function x(m, I) {
            this._id = m, this._clearFn = I;
          }
          x.prototype.unref = x.prototype.ref = function() {
          }, x.prototype.close = function() {
            this._clearFn.call(pt, this._id);
          }, $.enroll = function(m, I) {
            clearTimeout(m._idleTimeoutId), m._idleTimeout = I;
          }, $.unenroll = function(m) {
            clearTimeout(m._idleTimeoutId), m._idleTimeout = -1;
          }, $._unrefActive = $.active = function(m) {
            clearTimeout(m._idleTimeoutId);
            var I = m._idleTimeout;
            I >= 0 && (m._idleTimeoutId = setTimeout(function() {
              m._onTimeout && m._onTimeout();
            }, I));
          }, $.setImmediate = typeof Q == "function" ? Q : function(m) {
            var I = E++, z = arguments.length < 2 ? !1 : P.call(arguments, 1);
            return M[I] = !0, F(function() {
              M[I] && (z ? m.apply(null, z) : m.call(null), $.clearImmediate(I));
            }), I;
          }, $.clearImmediate = typeof r == "function" ? r : function(m) {
            delete M[m];
          };
        }).call(this, te("timers").setImmediate, te("timers").clearImmediate);
      }, { "process/browser.js": 133, timers: 176 }], 177: [function(te, Ee, $) {
        (function(Q) {
          Object.defineProperty($, "__esModule", {
            value: !0
          });
          var r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(le) {
            return typeof le;
          } : function(le) {
            return le && typeof Symbol == "function" && le.constructor === Symbol && le !== Symbol.prototype ? "symbol" : typeof le;
          };
          $.clone = E, $.addLast = I, $.addFirst = z, $.removeLast = w, $.removeFirst = C, $.insert = b, $.removeAt = B, $.replaceAt = N, $.getIn = U, $.set = V, $.setIn = q, $.update = Y, $.updateIn = re, $.merge = se, $.mergeDeep = ve, $.mergeIn = ce, $.omit = be, $.addDefaults = Me;
          /*!
           * Timm
           *
           * Immutability helpers with fast reads and acceptable writes.
           *
           * @copyright Guillermo Grau Panea 2016
           * @license MIT
           */
          var F = "INVALID_ARGS";
          function H(le) {
            throw new Error(le);
          }
          function P(le) {
            var de = Object.keys(le);
            return Object.getOwnPropertySymbols ? de.concat(Object.getOwnPropertySymbols(le)) : de;
          }
          var M = {}.hasOwnProperty;
          function E(le) {
            if (Array.isArray(le)) return le.slice();
            for (var de = P(le), De = {}, ze = 0; ze < de.length; ze++) {
              var Ze = de[ze];
              De[Ze] = le[Ze];
            }
            return De;
          }
          function x(le, de, De) {
            var ze = De;
            ze == null && H(Q.env.NODE_ENV !== "production" ? "At least one object should be provided to merge()" : F);
            for (var Ze = !1, Ue = arguments.length, Ie = Array(Ue > 3 ? Ue - 3 : 0), je = 3; je < Ue; je++)
              Ie[je - 3] = arguments[je];
            for (var Fe = 0; Fe < Ie.length; Fe++) {
              var $e = Ie[Fe];
              if ($e != null) {
                var ct = P($e);
                if (ct.length)
                  for (var wt = 0; wt <= ct.length; wt++) {
                    var Oe = ct[wt];
                    if (!(le && ze[Oe] !== void 0)) {
                      var Ct = $e[Oe];
                      de && m(ze[Oe]) && m(Ct) && (Ct = x(le, de, ze[Oe], Ct)), !(Ct === void 0 || Ct === ze[Oe]) && (Ze || (Ze = !0, ze = E(ze)), ze[Oe] = Ct);
                    }
                  }
              }
            }
            return ze;
          }
          function m(le) {
            var de = typeof le > "u" ? "undefined" : r(le);
            return le != null && de === "object";
          }
          function I(le, de) {
            return Array.isArray(de) ? le.concat(de) : le.concat([de]);
          }
          function z(le, de) {
            return Array.isArray(de) ? de.concat(le) : [de].concat(le);
          }
          function w(le) {
            return le.length ? le.slice(0, le.length - 1) : le;
          }
          function C(le) {
            return le.length ? le.slice(1) : le;
          }
          function b(le, de, De) {
            return le.slice(0, de).concat(Array.isArray(De) ? De : [De]).concat(le.slice(de));
          }
          function B(le, de) {
            return de >= le.length || de < 0 ? le : le.slice(0, de).concat(le.slice(de + 1));
          }
          function N(le, de, De) {
            if (le[de] === De) return le;
            for (var ze = le.length, Ze = Array(ze), Ue = 0; Ue < ze; Ue++)
              Ze[Ue] = le[Ue];
            return Ze[de] = De, Ze;
          }
          function U(le, de) {
            if (!Array.isArray(de) && H(Q.env.NODE_ENV !== "production" ? "A path array should be provided when calling getIn()" : F), le != null) {
              for (var De = le, ze = 0; ze < de.length; ze++) {
                var Ze = de[ze];
                if (De = De != null ? De[Ze] : void 0, De === void 0) return De;
              }
              return De;
            }
          }
          function V(le, de, De) {
            var ze = typeof de == "number" ? [] : {}, Ze = le ?? ze;
            if (Ze[de] === De) return Ze;
            var Ue = E(Ze);
            return Ue[de] = De, Ue;
          }
          function W(le, de, De, ze) {
            var Ze = void 0, Ue = de[ze];
            if (ze === de.length - 1)
              Ze = De;
            else {
              var Ie = m(le) && m(le[Ue]) ? le[Ue] : typeof de[ze + 1] == "number" ? [] : {};
              Ze = W(Ie, de, De, ze + 1);
            }
            return V(le, Ue, Ze);
          }
          function q(le, de, De) {
            return de.length ? W(le, de, De, 0) : De;
          }
          function Y(le, de, De) {
            var ze = le == null ? void 0 : le[de], Ze = De(ze);
            return V(le, de, Ze);
          }
          function re(le, de, De) {
            var ze = U(le, de), Ze = De(ze);
            return q(le, de, Ze);
          }
          function se(le, de, De, ze, Ze, Ue) {
            for (var Ie = arguments.length, je = Array(Ie > 6 ? Ie - 6 : 0), Fe = 6; Fe < Ie; Fe++)
              je[Fe - 6] = arguments[Fe];
            return je.length ? x.call.apply(x, [null, !1, !1, le, de, De, ze, Ze, Ue].concat(je)) : x(!1, !1, le, de, De, ze, Ze, Ue);
          }
          function ve(le, de, De, ze, Ze, Ue) {
            for (var Ie = arguments.length, je = Array(Ie > 6 ? Ie - 6 : 0), Fe = 6; Fe < Ie; Fe++)
              je[Fe - 6] = arguments[Fe];
            return je.length ? x.call.apply(x, [null, !1, !0, le, de, De, ze, Ze, Ue].concat(je)) : x(!1, !0, le, de, De, ze, Ze, Ue);
          }
          function ce(le, de, De, ze, Ze, Ue, Ie) {
            var je = U(le, de);
            je == null && (je = {});
            for (var Fe = void 0, $e = arguments.length, ct = Array($e > 7 ? $e - 7 : 0), wt = 7; wt < $e; wt++)
              ct[wt - 7] = arguments[wt];
            return ct.length ? Fe = x.call.apply(x, [null, !1, !1, je, De, ze, Ze, Ue, Ie].concat(ct)) : Fe = x(!1, !1, je, De, ze, Ze, Ue, Ie), q(le, de, Fe);
          }
          function be(le, de) {
            for (var De = Array.isArray(de) ? de : [de], ze = !1, Ze = 0; Ze < De.length; Ze++)
              if (M.call(le, De[Ze])) {
                ze = !0;
                break;
              }
            if (!ze) return le;
            for (var Ue = {}, Ie = P(le), je = 0; je < Ie.length; je++) {
              var Fe = Ie[je];
              De.indexOf(Fe) >= 0 || (Ue[Fe] = le[Fe]);
            }
            return Ue;
          }
          function Me(le, de, De, ze, Ze, Ue) {
            for (var Ie = arguments.length, je = Array(Ie > 6 ? Ie - 6 : 0), Fe = 6; Fe < Ie; Fe++)
              je[Fe - 6] = arguments[Fe];
            return je.length ? x.call.apply(x, [null, !0, !1, le, de, De, ze, Ze, Ue].concat(je)) : x(!0, !1, le, de, De, ze, Ze, Ue);
          }
          var xe = {
            clone: E,
            addLast: I,
            addFirst: z,
            removeLast: w,
            removeFirst: C,
            insert: b,
            removeAt: B,
            replaceAt: N,
            getIn: U,
            // eslint-disable-next-line object-shorthand
            set: V,
            // so that flow doesn't complain
            setIn: q,
            update: Y,
            updateIn: re,
            merge: se,
            mergeDeep: ve,
            mergeIn: ce,
            omit: be,
            addDefaults: Me
          };
          $.default = xe;
        }).call(this, te("_process"));
      }, { _process: 133 }], 178: [function(te, Ee, $) {
        (function(Q) {
          var r = /^\s+/, F = /\s+$/, H = 0, P = Q.round, M = Q.min, E = Q.max, x = Q.random;
          function m(Ae, _e) {
            if (Ae = Ae || "", _e = _e || {}, Ae instanceof m)
              return Ae;
            if (!(this instanceof m))
              return new m(Ae, _e);
            var fe = I(Ae);
            this._originalInput = Ae, this._r = fe.r, this._g = fe.g, this._b = fe.b, this._a = fe.a, this._roundA = P(100 * this._a) / 100, this._format = _e.format || fe.format, this._gradientType = _e.gradientType, this._r < 1 && (this._r = P(this._r)), this._g < 1 && (this._g = P(this._g)), this._b < 1 && (this._b = P(this._b)), this._ok = fe.ok, this._tc_id = H++;
          }
          m.prototype = {
            isDark: function() {
              return this.getBrightness() < 128;
            },
            isLight: function() {
              return !this.isDark();
            },
            isValid: function() {
              return this._ok;
            },
            getOriginalInput: function() {
              return this._originalInput;
            },
            getFormat: function() {
              return this._format;
            },
            getAlpha: function() {
              return this._a;
            },
            getBrightness: function() {
              var Ae = this.toRgb();
              return (Ae.r * 299 + Ae.g * 587 + Ae.b * 114) / 1e3;
            },
            getLuminance: function() {
              var Ae = this.toRgb(), _e, fe, We, Pe, he, ie;
              return _e = Ae.r / 255, fe = Ae.g / 255, We = Ae.b / 255, _e <= 0.03928 ? Pe = _e / 12.92 : Pe = Q.pow((_e + 0.055) / 1.055, 2.4), fe <= 0.03928 ? he = fe / 12.92 : he = Q.pow((fe + 0.055) / 1.055, 2.4), We <= 0.03928 ? ie = We / 12.92 : ie = Q.pow((We + 0.055) / 1.055, 2.4), 0.2126 * Pe + 0.7152 * he + 0.0722 * ie;
            },
            setAlpha: function(Ae) {
              return this._a = Ie(Ae), this._roundA = P(100 * this._a) / 100, this;
            },
            toHsv: function() {
              var Ae = b(this._r, this._g, this._b);
              return { h: Ae.h * 360, s: Ae.s, v: Ae.v, a: this._a };
            },
            toHsvString: function() {
              var Ae = b(this._r, this._g, this._b), _e = P(Ae.h * 360), fe = P(Ae.s * 100), We = P(Ae.v * 100);
              return this._a == 1 ? "hsv(" + _e + ", " + fe + "%, " + We + "%)" : "hsva(" + _e + ", " + fe + "%, " + We + "%, " + this._roundA + ")";
            },
            toHsl: function() {
              var Ae = w(this._r, this._g, this._b);
              return { h: Ae.h * 360, s: Ae.s, l: Ae.l, a: this._a };
            },
            toHslString: function() {
              var Ae = w(this._r, this._g, this._b), _e = P(Ae.h * 360), fe = P(Ae.s * 100), We = P(Ae.l * 100);
              return this._a == 1 ? "hsl(" + _e + ", " + fe + "%, " + We + "%)" : "hsla(" + _e + ", " + fe + "%, " + We + "%, " + this._roundA + ")";
            },
            toHex: function(Ae) {
              return N(this._r, this._g, this._b, Ae);
            },
            toHexString: function(Ae) {
              return "#" + this.toHex(Ae);
            },
            toHex8: function(Ae) {
              return U(this._r, this._g, this._b, this._a, Ae);
            },
            toHex8String: function(Ae) {
              return "#" + this.toHex8(Ae);
            },
            toRgb: function() {
              return { r: P(this._r), g: P(this._g), b: P(this._b), a: this._a };
            },
            toRgbString: function() {
              return this._a == 1 ? "rgb(" + P(this._r) + ", " + P(this._g) + ", " + P(this._b) + ")" : "rgba(" + P(this._r) + ", " + P(this._g) + ", " + P(this._b) + ", " + this._roundA + ")";
            },
            toPercentageRgb: function() {
              return { r: P(je(this._r, 255) * 100) + "%", g: P(je(this._g, 255) * 100) + "%", b: P(je(this._b, 255) * 100) + "%", a: this._a };
            },
            toPercentageRgbString: function() {
              return this._a == 1 ? "rgb(" + P(je(this._r, 255) * 100) + "%, " + P(je(this._g, 255) * 100) + "%, " + P(je(this._b, 255) * 100) + "%)" : "rgba(" + P(je(this._r, 255) * 100) + "%, " + P(je(this._g, 255) * 100) + "%, " + P(je(this._b, 255) * 100) + "%, " + this._roundA + ")";
            },
            toName: function() {
              return this._a === 0 ? "transparent" : this._a < 1 ? !1 : Ze[N(this._r, this._g, this._b, !0)] || !1;
            },
            toFilter: function(Ae) {
              var _e = "#" + V(this._r, this._g, this._b, this._a), fe = _e, We = this._gradientType ? "GradientType = 1, " : "";
              if (Ae) {
                var Pe = m(Ae);
                fe = "#" + V(Pe._r, Pe._g, Pe._b, Pe._a);
              }
              return "progid:DXImageTransform.Microsoft.gradient(" + We + "startColorstr=" + _e + ",endColorstr=" + fe + ")";
            },
            toString: function(Ae) {
              var _e = !!Ae;
              Ae = Ae || this._format;
              var fe = !1, We = this._a < 1 && this._a >= 0, Pe = !_e && We && (Ae === "hex" || Ae === "hex6" || Ae === "hex3" || Ae === "hex4" || Ae === "hex8" || Ae === "name");
              return Pe ? Ae === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (Ae === "rgb" && (fe = this.toRgbString()), Ae === "prgb" && (fe = this.toPercentageRgbString()), (Ae === "hex" || Ae === "hex6") && (fe = this.toHexString()), Ae === "hex3" && (fe = this.toHexString(!0)), Ae === "hex4" && (fe = this.toHex8String(!0)), Ae === "hex8" && (fe = this.toHex8String()), Ae === "name" && (fe = this.toName()), Ae === "hsl" && (fe = this.toHslString()), Ae === "hsv" && (fe = this.toHsvString()), fe || this.toHexString());
            },
            clone: function() {
              return m(this.toString());
            },
            _applyModification: function(Ae, _e) {
              var fe = Ae.apply(null, [this].concat([].slice.call(_e)));
              return this._r = fe._r, this._g = fe._g, this._b = fe._b, this.setAlpha(fe._a), this;
            },
            lighten: function() {
              return this._applyModification(re, arguments);
            },
            brighten: function() {
              return this._applyModification(se, arguments);
            },
            darken: function() {
              return this._applyModification(ve, arguments);
            },
            desaturate: function() {
              return this._applyModification(W, arguments);
            },
            saturate: function() {
              return this._applyModification(q, arguments);
            },
            greyscale: function() {
              return this._applyModification(Y, arguments);
            },
            spin: function() {
              return this._applyModification(ce, arguments);
            },
            _applyCombination: function(Ae, _e) {
              return Ae.apply(null, [this].concat([].slice.call(_e)));
            },
            analogous: function() {
              return this._applyCombination(de, arguments);
            },
            complement: function() {
              return this._applyCombination(be, arguments);
            },
            monochromatic: function() {
              return this._applyCombination(De, arguments);
            },
            splitcomplement: function() {
              return this._applyCombination(le, arguments);
            },
            triad: function() {
              return this._applyCombination(Me, arguments);
            },
            tetrad: function() {
              return this._applyCombination(xe, arguments);
            }
          }, m.fromRatio = function(Ae, _e) {
            if (typeof Ae == "object") {
              var fe = {};
              for (var We in Ae)
                Ae.hasOwnProperty(We) && (We === "a" ? fe[We] = Ae[We] : fe[We] = Ct(Ae[We]));
              Ae = fe;
            }
            return m(Ae, _e);
          };
          function I(Ae) {
            var _e = { r: 0, g: 0, b: 0 }, fe = 1, We = null, Pe = null, he = null, ie = !1, Xe = !1;
            return typeof Ae == "string" && (Ae = rt(Ae)), typeof Ae == "object" && (qe(Ae.r) && qe(Ae.g) && qe(Ae.b) ? (_e = z(Ae.r, Ae.g, Ae.b), ie = !0, Xe = String(Ae.r).substr(-1) === "%" ? "prgb" : "rgb") : qe(Ae.h) && qe(Ae.s) && qe(Ae.v) ? (We = Ct(Ae.s), Pe = Ct(Ae.v), _e = B(Ae.h, We, Pe), ie = !0, Xe = "hsv") : qe(Ae.h) && qe(Ae.s) && qe(Ae.l) && (We = Ct(Ae.s), he = Ct(Ae.l), _e = C(Ae.h, We, he), ie = !0, Xe = "hsl"), Ae.hasOwnProperty("a") && (fe = Ae.a)), fe = Ie(fe), {
              ok: ie,
              format: Ae.format || Xe,
              r: M(255, E(_e.r, 0)),
              g: M(255, E(_e.g, 0)),
              b: M(255, E(_e.b, 0)),
              a: fe
            };
          }
          function z(Ae, _e, fe) {
            return {
              r: je(Ae, 255) * 255,
              g: je(_e, 255) * 255,
              b: je(fe, 255) * 255
            };
          }
          function w(Ae, _e, fe) {
            Ae = je(Ae, 255), _e = je(_e, 255), fe = je(fe, 255);
            var We = E(Ae, _e, fe), Pe = M(Ae, _e, fe), he, ie, Xe = (We + Pe) / 2;
            if (We == Pe)
              he = ie = 0;
            else {
              var bt = We - Pe;
              switch (ie = Xe > 0.5 ? bt / (2 - We - Pe) : bt / (We + Pe), We) {
                case Ae:
                  he = (_e - fe) / bt + (_e < fe ? 6 : 0);
                  break;
                case _e:
                  he = (fe - Ae) / bt + 2;
                  break;
                case fe:
                  he = (Ae - _e) / bt + 4;
                  break;
              }
              he /= 6;
            }
            return { h: he, s: ie, l: Xe };
          }
          function C(Ae, _e, fe) {
            var We, Pe, he;
            Ae = je(Ae, 360), _e = je(_e, 100), fe = je(fe, 100);
            function ie(Wt, Qt, Sr) {
              return Sr < 0 && (Sr += 1), Sr > 1 && (Sr -= 1), Sr < 1 / 6 ? Wt + (Qt - Wt) * 6 * Sr : Sr < 1 / 2 ? Qt : Sr < 2 / 3 ? Wt + (Qt - Wt) * (2 / 3 - Sr) * 6 : Wt;
            }
            if (_e === 0)
              We = Pe = he = fe;
            else {
              var Xe = fe < 0.5 ? fe * (1 + _e) : fe + _e - fe * _e, bt = 2 * fe - Xe;
              We = ie(bt, Xe, Ae + 1 / 3), Pe = ie(bt, Xe, Ae), he = ie(bt, Xe, Ae - 1 / 3);
            }
            return { r: We * 255, g: Pe * 255, b: he * 255 };
          }
          function b(Ae, _e, fe) {
            Ae = je(Ae, 255), _e = je(_e, 255), fe = je(fe, 255);
            var We = E(Ae, _e, fe), Pe = M(Ae, _e, fe), he, ie, Xe = We, bt = We - Pe;
            if (ie = We === 0 ? 0 : bt / We, We == Pe)
              he = 0;
            else {
              switch (We) {
                case Ae:
                  he = (_e - fe) / bt + (_e < fe ? 6 : 0);
                  break;
                case _e:
                  he = (fe - Ae) / bt + 2;
                  break;
                case fe:
                  he = (Ae - _e) / bt + 4;
                  break;
              }
              he /= 6;
            }
            return { h: he, s: ie, v: Xe };
          }
          function B(Ae, _e, fe) {
            Ae = je(Ae, 360) * 6, _e = je(_e, 100), fe = je(fe, 100);
            var We = Q.floor(Ae), Pe = Ae - We, he = fe * (1 - _e), ie = fe * (1 - Pe * _e), Xe = fe * (1 - (1 - Pe) * _e), bt = We % 6, Wt = [fe, ie, he, he, Xe, fe][bt], Qt = [Xe, fe, fe, ie, he, he][bt], Sr = [he, he, Xe, fe, fe, ie][bt];
            return { r: Wt * 255, g: Qt * 255, b: Sr * 255 };
          }
          function N(Ae, _e, fe, We) {
            var Pe = [
              Oe(P(Ae).toString(16)),
              Oe(P(_e).toString(16)),
              Oe(P(fe).toString(16))
            ];
            return We && Pe[0].charAt(0) == Pe[0].charAt(1) && Pe[1].charAt(0) == Pe[1].charAt(1) && Pe[2].charAt(0) == Pe[2].charAt(1) ? Pe[0].charAt(0) + Pe[1].charAt(0) + Pe[2].charAt(0) : Pe.join("");
          }
          function U(Ae, _e, fe, We, Pe) {
            var he = [
              Oe(P(Ae).toString(16)),
              Oe(P(_e).toString(16)),
              Oe(P(fe).toString(16)),
              Oe(Xt(We))
            ];
            return Pe && he[0].charAt(0) == he[0].charAt(1) && he[1].charAt(0) == he[1].charAt(1) && he[2].charAt(0) == he[2].charAt(1) && he[3].charAt(0) == he[3].charAt(1) ? he[0].charAt(0) + he[1].charAt(0) + he[2].charAt(0) + he[3].charAt(0) : he.join("");
          }
          function V(Ae, _e, fe, We) {
            var Pe = [
              Oe(Xt(We)),
              Oe(P(Ae).toString(16)),
              Oe(P(_e).toString(16)),
              Oe(P(fe).toString(16))
            ];
            return Pe.join("");
          }
          m.equals = function(Ae, _e) {
            return !Ae || !_e ? !1 : m(Ae).toRgbString() == m(_e).toRgbString();
          }, m.random = function() {
            return m.fromRatio({
              r: x(),
              g: x(),
              b: x()
            });
          };
          function W(Ae, _e) {
            _e = _e === 0 ? 0 : _e || 10;
            var fe = m(Ae).toHsl();
            return fe.s -= _e / 100, fe.s = Fe(fe.s), m(fe);
          }
          function q(Ae, _e) {
            _e = _e === 0 ? 0 : _e || 10;
            var fe = m(Ae).toHsl();
            return fe.s += _e / 100, fe.s = Fe(fe.s), m(fe);
          }
          function Y(Ae) {
            return m(Ae).desaturate(100);
          }
          function re(Ae, _e) {
            _e = _e === 0 ? 0 : _e || 10;
            var fe = m(Ae).toHsl();
            return fe.l += _e / 100, fe.l = Fe(fe.l), m(fe);
          }
          function se(Ae, _e) {
            _e = _e === 0 ? 0 : _e || 10;
            var fe = m(Ae).toRgb();
            return fe.r = E(0, M(255, fe.r - P(255 * -(_e / 100)))), fe.g = E(0, M(255, fe.g - P(255 * -(_e / 100)))), fe.b = E(0, M(255, fe.b - P(255 * -(_e / 100)))), m(fe);
          }
          function ve(Ae, _e) {
            _e = _e === 0 ? 0 : _e || 10;
            var fe = m(Ae).toHsl();
            return fe.l -= _e / 100, fe.l = Fe(fe.l), m(fe);
          }
          function ce(Ae, _e) {
            var fe = m(Ae).toHsl(), We = (fe.h + _e) % 360;
            return fe.h = We < 0 ? 360 + We : We, m(fe);
          }
          function be(Ae) {
            var _e = m(Ae).toHsl();
            return _e.h = (_e.h + 180) % 360, m(_e);
          }
          function Me(Ae) {
            var _e = m(Ae).toHsl(), fe = _e.h;
            return [
              m(Ae),
              m({ h: (fe + 120) % 360, s: _e.s, l: _e.l }),
              m({ h: (fe + 240) % 360, s: _e.s, l: _e.l })
            ];
          }
          function xe(Ae) {
            var _e = m(Ae).toHsl(), fe = _e.h;
            return [
              m(Ae),
              m({ h: (fe + 90) % 360, s: _e.s, l: _e.l }),
              m({ h: (fe + 180) % 360, s: _e.s, l: _e.l }),
              m({ h: (fe + 270) % 360, s: _e.s, l: _e.l })
            ];
          }
          function le(Ae) {
            var _e = m(Ae).toHsl(), fe = _e.h;
            return [
              m(Ae),
              m({ h: (fe + 72) % 360, s: _e.s, l: _e.l }),
              m({ h: (fe + 216) % 360, s: _e.s, l: _e.l })
            ];
          }
          function de(Ae, _e, fe) {
            _e = _e || 6, fe = fe || 30;
            var We = m(Ae).toHsl(), Pe = 360 / fe, he = [m(Ae)];
            for (We.h = (We.h - (Pe * _e >> 1) + 720) % 360; --_e; )
              We.h = (We.h + Pe) % 360, he.push(m(We));
            return he;
          }
          function De(Ae, _e) {
            _e = _e || 6;
            for (var fe = m(Ae).toHsv(), We = fe.h, Pe = fe.s, he = fe.v, ie = [], Xe = 1 / _e; _e--; )
              ie.push(m({ h: We, s: Pe, v: he })), he = (he + Xe) % 1;
            return ie;
          }
          m.mix = function(Ae, _e, fe) {
            fe = fe === 0 ? 0 : fe || 50;
            var We = m(Ae).toRgb(), Pe = m(_e).toRgb(), he = fe / 100, ie = {
              r: (Pe.r - We.r) * he + We.r,
              g: (Pe.g - We.g) * he + We.g,
              b: (Pe.b - We.b) * he + We.b,
              a: (Pe.a - We.a) * he + We.a
            };
            return m(ie);
          }, m.readability = function(Ae, _e) {
            var fe = m(Ae), We = m(_e);
            return (Q.max(fe.getLuminance(), We.getLuminance()) + 0.05) / (Q.min(fe.getLuminance(), We.getLuminance()) + 0.05);
          }, m.isReadable = function(Ae, _e, fe) {
            var We = m.readability(Ae, _e), Pe, he;
            switch (he = !1, Pe = it(fe), Pe.level + Pe.size) {
              case "AAsmall":
              case "AAAlarge":
                he = We >= 4.5;
                break;
              case "AAlarge":
                he = We >= 3;
                break;
              case "AAAsmall":
                he = We >= 7;
                break;
            }
            return he;
          }, m.mostReadable = function(Ae, _e, fe) {
            var We = null, Pe = 0, he, ie, Xe, bt;
            fe = fe || {}, ie = fe.includeFallbackColors, Xe = fe.level, bt = fe.size;
            for (var Wt = 0; Wt < _e.length; Wt++)
              he = m.readability(Ae, _e[Wt]), he > Pe && (Pe = he, We = m(_e[Wt]));
            return m.isReadable(Ae, We, { level: Xe, size: bt }) || !ie ? We : (fe.includeFallbackColors = !1, m.mostReadable(Ae, ["#fff", "#000"], fe));
          };
          var ze = m.names = {
            aliceblue: "f0f8ff",
            antiquewhite: "faebd7",
            aqua: "0ff",
            aquamarine: "7fffd4",
            azure: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "000",
            blanchedalmond: "ffebcd",
            blue: "00f",
            blueviolet: "8a2be2",
            brown: "a52a2a",
            burlywood: "deb887",
            burntsienna: "ea7e5d",
            cadetblue: "5f9ea0",
            chartreuse: "7fff00",
            chocolate: "d2691e",
            coral: "ff7f50",
            cornflowerblue: "6495ed",
            cornsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "0ff",
            darkblue: "00008b",
            darkcyan: "008b8b",
            darkgoldenrod: "b8860b",
            darkgray: "a9a9a9",
            darkgreen: "006400",
            darkgrey: "a9a9a9",
            darkkhaki: "bdb76b",
            darkmagenta: "8b008b",
            darkolivegreen: "556b2f",
            darkorange: "ff8c00",
            darkorchid: "9932cc",
            darkred: "8b0000",
            darksalmon: "e9967a",
            darkseagreen: "8fbc8f",
            darkslateblue: "483d8b",
            darkslategray: "2f4f4f",
            darkslategrey: "2f4f4f",
            darkturquoise: "00ced1",
            darkviolet: "9400d3",
            deeppink: "ff1493",
            deepskyblue: "00bfff",
            dimgray: "696969",
            dimgrey: "696969",
            dodgerblue: "1e90ff",
            firebrick: "b22222",
            floralwhite: "fffaf0",
            forestgreen: "228b22",
            fuchsia: "f0f",
            gainsboro: "dcdcdc",
            ghostwhite: "f8f8ff",
            gold: "ffd700",
            goldenrod: "daa520",
            gray: "808080",
            green: "008000",
            greenyellow: "adff2f",
            grey: "808080",
            honeydew: "f0fff0",
            hotpink: "ff69b4",
            indianred: "cd5c5c",
            indigo: "4b0082",
            ivory: "fffff0",
            khaki: "f0e68c",
            lavender: "e6e6fa",
            lavenderblush: "fff0f5",
            lawngreen: "7cfc00",
            lemonchiffon: "fffacd",
            lightblue: "add8e6",
            lightcoral: "f08080",
            lightcyan: "e0ffff",
            lightgoldenrodyellow: "fafad2",
            lightgray: "d3d3d3",
            lightgreen: "90ee90",
            lightgrey: "d3d3d3",
            lightpink: "ffb6c1",
            lightsalmon: "ffa07a",
            lightseagreen: "20b2aa",
            lightskyblue: "87cefa",
            lightslategray: "789",
            lightslategrey: "789",
            lightsteelblue: "b0c4de",
            lightyellow: "ffffe0",
            lime: "0f0",
            limegreen: "32cd32",
            linen: "faf0e6",
            magenta: "f0f",
            maroon: "800000",
            mediumaquamarine: "66cdaa",
            mediumblue: "0000cd",
            mediumorchid: "ba55d3",
            mediumpurple: "9370db",
            mediumseagreen: "3cb371",
            mediumslateblue: "7b68ee",
            mediumspringgreen: "00fa9a",
            mediumturquoise: "48d1cc",
            mediumvioletred: "c71585",
            midnightblue: "191970",
            mintcream: "f5fffa",
            mistyrose: "ffe4e1",
            moccasin: "ffe4b5",
            navajowhite: "ffdead",
            navy: "000080",
            oldlace: "fdf5e6",
            olive: "808000",
            olivedrab: "6b8e23",
            orange: "ffa500",
            orangered: "ff4500",
            orchid: "da70d6",
            palegoldenrod: "eee8aa",
            palegreen: "98fb98",
            paleturquoise: "afeeee",
            palevioletred: "db7093",
            papayawhip: "ffefd5",
            peachpuff: "ffdab9",
            peru: "cd853f",
            pink: "ffc0cb",
            plum: "dda0dd",
            powderblue: "b0e0e6",
            purple: "800080",
            rebeccapurple: "663399",
            red: "f00",
            rosybrown: "bc8f8f",
            royalblue: "4169e1",
            saddlebrown: "8b4513",
            salmon: "fa8072",
            sandybrown: "f4a460",
            seagreen: "2e8b57",
            seashell: "fff5ee",
            sienna: "a0522d",
            silver: "c0c0c0",
            skyblue: "87ceeb",
            slateblue: "6a5acd",
            slategray: "708090",
            slategrey: "708090",
            snow: "fffafa",
            springgreen: "00ff7f",
            steelblue: "4682b4",
            tan: "d2b48c",
            teal: "008080",
            thistle: "d8bfd8",
            tomato: "ff6347",
            turquoise: "40e0d0",
            violet: "ee82ee",
            wheat: "f5deb3",
            white: "fff",
            whitesmoke: "f5f5f5",
            yellow: "ff0",
            yellowgreen: "9acd32"
          }, Ze = m.hexNames = Ue(ze);
          function Ue(Ae) {
            var _e = {};
            for (var fe in Ae)
              Ae.hasOwnProperty(fe) && (_e[Ae[fe]] = fe);
            return _e;
          }
          function Ie(Ae) {
            return Ae = parseFloat(Ae), (isNaN(Ae) || Ae < 0 || Ae > 1) && (Ae = 1), Ae;
          }
          function je(Ae, _e) {
            ct(Ae) && (Ae = "100%");
            var fe = wt(Ae);
            return Ae = M(_e, E(0, parseFloat(Ae))), fe && (Ae = parseInt(Ae * _e, 10) / 100), Q.abs(Ae - _e) < 1e-6 ? 1 : Ae % _e / parseFloat(_e);
          }
          function Fe(Ae) {
            return M(1, E(0, Ae));
          }
          function $e(Ae) {
            return parseInt(Ae, 16);
          }
          function ct(Ae) {
            return typeof Ae == "string" && Ae.indexOf(".") != -1 && parseFloat(Ae) === 1;
          }
          function wt(Ae) {
            return typeof Ae == "string" && Ae.indexOf("%") != -1;
          }
          function Oe(Ae) {
            return Ae.length == 1 ? "0" + Ae : "" + Ae;
          }
          function Ct(Ae) {
            return Ae <= 1 && (Ae = Ae * 100 + "%"), Ae;
          }
          function Xt(Ae) {
            return Q.round(parseFloat(Ae) * 255).toString(16);
          }
          function vt(Ae) {
            return $e(Ae) / 255;
          }
          var Ye = function() {
            var Ae = "[-\\+]?\\d+%?", _e = "[-\\+]?\\d*\\.\\d+%?", fe = "(?:" + _e + ")|(?:" + Ae + ")", We = "[\\s|\\(]+(" + fe + ")[,|\\s]+(" + fe + ")[,|\\s]+(" + fe + ")\\s*\\)?", Pe = "[\\s|\\(]+(" + fe + ")[,|\\s]+(" + fe + ")[,|\\s]+(" + fe + ")[,|\\s]+(" + fe + ")\\s*\\)?";
            return {
              CSS_UNIT: new RegExp(fe),
              rgb: new RegExp("rgb" + We),
              rgba: new RegExp("rgba" + Pe),
              hsl: new RegExp("hsl" + We),
              hsla: new RegExp("hsla" + Pe),
              hsv: new RegExp("hsv" + We),
              hsva: new RegExp("hsva" + Pe),
              hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
              hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
            };
          }();
          function qe(Ae) {
            return !!Ye.CSS_UNIT.exec(Ae);
          }
          function rt(Ae) {
            Ae = Ae.replace(r, "").replace(F, "").toLowerCase();
            var _e = !1;
            if (ze[Ae])
              Ae = ze[Ae], _e = !0;
            else if (Ae == "transparent")
              return { r: 0, g: 0, b: 0, a: 0, format: "name" };
            var fe;
            return (fe = Ye.rgb.exec(Ae)) ? { r: fe[1], g: fe[2], b: fe[3] } : (fe = Ye.rgba.exec(Ae)) ? { r: fe[1], g: fe[2], b: fe[3], a: fe[4] } : (fe = Ye.hsl.exec(Ae)) ? { h: fe[1], s: fe[2], l: fe[3] } : (fe = Ye.hsla.exec(Ae)) ? { h: fe[1], s: fe[2], l: fe[3], a: fe[4] } : (fe = Ye.hsv.exec(Ae)) ? { h: fe[1], s: fe[2], v: fe[3] } : (fe = Ye.hsva.exec(Ae)) ? { h: fe[1], s: fe[2], v: fe[3], a: fe[4] } : (fe = Ye.hex8.exec(Ae)) ? {
              r: $e(fe[1]),
              g: $e(fe[2]),
              b: $e(fe[3]),
              a: vt(fe[4]),
              format: _e ? "name" : "hex8"
            } : (fe = Ye.hex6.exec(Ae)) ? {
              r: $e(fe[1]),
              g: $e(fe[2]),
              b: $e(fe[3]),
              format: _e ? "name" : "hex"
            } : (fe = Ye.hex4.exec(Ae)) ? {
              r: $e(fe[1] + "" + fe[1]),
              g: $e(fe[2] + "" + fe[2]),
              b: $e(fe[3] + "" + fe[3]),
              a: vt(fe[4] + "" + fe[4]),
              format: _e ? "name" : "hex8"
            } : (fe = Ye.hex3.exec(Ae)) ? {
              r: $e(fe[1] + "" + fe[1]),
              g: $e(fe[2] + "" + fe[2]),
              b: $e(fe[3] + "" + fe[3]),
              format: _e ? "name" : "hex"
            } : !1;
          }
          function it(Ae) {
            var _e, fe;
            return Ae = Ae || { level: "AA", size: "small" }, _e = (Ae.level || "AA").toUpperCase(), fe = (Ae.size || "small").toLowerCase(), _e !== "AA" && _e !== "AAA" && (_e = "AA"), fe !== "small" && fe !== "large" && (fe = "small"), { level: _e, size: fe };
          }
          typeof Ee < "u" && Ee.exports ? Ee.exports = m : pt.tinycolor = m;
        })(Math);
      }, {}], 179: [function(te, Ee, $) {
        $ = Ee.exports = Q;
        function Q(r) {
          return r.replace(/^\s*|\s*$/g, "");
        }
        $.left = function(r) {
          return r.replace(/^\s*/, "");
        }, $.right = function(r) {
          return r.replace(/\s*$/, "");
        };
      }, {}], 180: [function(te, Ee, $) {
        var Q = te("punycode"), r = te("./util");
        $.parse = W, $.resolve = Y, $.resolveObject = re, $.format = q, $.Url = F;
        function F() {
          this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
        }
        var H = /^([a-z0-9.+-]+:)/i, P = /:[0-9]*$/, M = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, E = ["<", ">", '"', "`", " ", "\r", `
`, "	"], x = ["{", "}", "|", "\\", "^", "`"].concat(E), m = ["'"].concat(x), I = ["%", "/", "?", ";", "#"].concat(m), z = ["/", "?", "#"], w = 255, C = /^[+a-z0-9A-Z_-]{0,63}$/, b = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, B = {
          javascript: !0,
          "javascript:": !0
        }, N = {
          javascript: !0,
          "javascript:": !0
        }, U = {
          http: !0,
          https: !0,
          ftp: !0,
          gopher: !0,
          file: !0,
          "http:": !0,
          "https:": !0,
          "ftp:": !0,
          "gopher:": !0,
          "file:": !0
        }, V = te("querystring");
        function W(se, ve, ce) {
          if (se && r.isObject(se) && se instanceof F) return se;
          var be = new F();
          return be.parse(se, ve, ce), be;
        }
        F.prototype.parse = function(se, ve, ce) {
          if (!r.isString(se))
            throw new TypeError("Parameter 'url' must be a string, not " + typeof se);
          var be = se.indexOf("?"), Me = be !== -1 && be < se.indexOf("#") ? "?" : "#", xe = se.split(Me), le = /\\/g;
          xe[0] = xe[0].replace(le, "/"), se = xe.join(Me);
          var de = se;
          if (de = de.trim(), !ce && se.split("#").length === 1) {
            var De = M.exec(de);
            if (De)
              return this.path = de, this.href = de, this.pathname = De[1], De[2] ? (this.search = De[2], ve ? this.query = V.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : ve && (this.search = "", this.query = {}), this;
          }
          var ze = H.exec(de);
          if (ze) {
            ze = ze[0];
            var Ze = ze.toLowerCase();
            this.protocol = Ze, de = de.substr(ze.length);
          }
          if (ce || ze || de.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var Ue = de.substr(0, 2) === "//";
            Ue && !(ze && N[ze]) && (de = de.substr(2), this.slashes = !0);
          }
          if (!N[ze] && (Ue || ze && !U[ze])) {
            for (var Ie = -1, je = 0; je < z.length; je++) {
              var Fe = de.indexOf(z[je]);
              Fe !== -1 && (Ie === -1 || Fe < Ie) && (Ie = Fe);
            }
            var $e, ct;
            Ie === -1 ? ct = de.lastIndexOf("@") : ct = de.lastIndexOf("@", Ie), ct !== -1 && ($e = de.slice(0, ct), de = de.slice(ct + 1), this.auth = decodeURIComponent($e)), Ie = -1;
            for (var je = 0; je < I.length; je++) {
              var Fe = de.indexOf(I[je]);
              Fe !== -1 && (Ie === -1 || Fe < Ie) && (Ie = Fe);
            }
            Ie === -1 && (Ie = de.length), this.host = de.slice(0, Ie), de = de.slice(Ie), this.parseHost(), this.hostname = this.hostname || "";
            var wt = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!wt)
              for (var Oe = this.hostname.split(/\./), je = 0, Ct = Oe.length; je < Ct; je++) {
                var Xt = Oe[je];
                if (Xt && !Xt.match(C)) {
                  for (var vt = "", Ye = 0, qe = Xt.length; Ye < qe; Ye++)
                    Xt.charCodeAt(Ye) > 127 ? vt += "x" : vt += Xt[Ye];
                  if (!vt.match(C)) {
                    var rt = Oe.slice(0, je), it = Oe.slice(je + 1), Ae = Xt.match(b);
                    Ae && (rt.push(Ae[1]), it.unshift(Ae[2])), it.length && (de = "/" + it.join(".") + de), this.hostname = rt.join(".");
                    break;
                  }
                }
              }
            this.hostname.length > w ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), wt || (this.hostname = Q.toASCII(this.hostname));
            var _e = this.port ? ":" + this.port : "", fe = this.hostname || "";
            this.host = fe + _e, this.href += this.host, wt && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), de[0] !== "/" && (de = "/" + de));
          }
          if (!B[Ze])
            for (var je = 0, Ct = m.length; je < Ct; je++) {
              var We = m[je];
              if (de.indexOf(We) !== -1) {
                var Pe = encodeURIComponent(We);
                Pe === We && (Pe = escape(We)), de = de.split(We).join(Pe);
              }
            }
          var he = de.indexOf("#");
          he !== -1 && (this.hash = de.substr(he), de = de.slice(0, he));
          var ie = de.indexOf("?");
          if (ie !== -1 ? (this.search = de.substr(ie), this.query = de.substr(ie + 1), ve && (this.query = V.parse(this.query)), de = de.slice(0, ie)) : ve && (this.search = "", this.query = {}), de && (this.pathname = de), U[Ze] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            var _e = this.pathname || "", Xe = this.search || "";
            this.path = _e + Xe;
          }
          return this.href = this.format(), this;
        };
        function q(se) {
          return r.isString(se) && (se = W(se)), se instanceof F ? se.format() : F.prototype.format.call(se);
        }
        F.prototype.format = function() {
          var se = this.auth || "";
          se && (se = encodeURIComponent(se), se = se.replace(/%3A/i, ":"), se += "@");
          var ve = this.protocol || "", ce = this.pathname || "", be = this.hash || "", Me = !1, xe = "";
          this.host ? Me = se + this.host : this.hostname && (Me = se + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (Me += ":" + this.port)), this.query && r.isObject(this.query) && Object.keys(this.query).length && (xe = V.stringify(this.query));
          var le = this.search || xe && "?" + xe || "";
          return ve && ve.substr(-1) !== ":" && (ve += ":"), this.slashes || (!ve || U[ve]) && Me !== !1 ? (Me = "//" + (Me || ""), ce && ce.charAt(0) !== "/" && (ce = "/" + ce)) : Me || (Me = ""), be && be.charAt(0) !== "#" && (be = "#" + be), le && le.charAt(0) !== "?" && (le = "?" + le), ce = ce.replace(/[?#]/g, function(de) {
            return encodeURIComponent(de);
          }), le = le.replace("#", "%23"), ve + Me + ce + le + be;
        };
        function Y(se, ve) {
          return W(se, !1, !0).resolve(ve);
        }
        F.prototype.resolve = function(se) {
          return this.resolveObject(W(se, !1, !0)).format();
        };
        function re(se, ve) {
          return se ? W(se, !1, !0).resolveObject(ve) : ve;
        }
        F.prototype.resolveObject = function(se) {
          if (r.isString(se)) {
            var ve = new F();
            ve.parse(se, !1, !0), se = ve;
          }
          for (var ce = new F(), be = Object.keys(this), Me = 0; Me < be.length; Me++) {
            var xe = be[Me];
            ce[xe] = this[xe];
          }
          if (ce.hash = se.hash, se.href === "")
            return ce.href = ce.format(), ce;
          if (se.slashes && !se.protocol) {
            for (var le = Object.keys(se), de = 0; de < le.length; de++) {
              var De = le[de];
              De !== "protocol" && (ce[De] = se[De]);
            }
            return U[ce.protocol] && ce.hostname && !ce.pathname && (ce.path = ce.pathname = "/"), ce.href = ce.format(), ce;
          }
          if (se.protocol && se.protocol !== ce.protocol) {
            if (!U[se.protocol]) {
              for (var ze = Object.keys(se), Ze = 0; Ze < ze.length; Ze++) {
                var Ue = ze[Ze];
                ce[Ue] = se[Ue];
              }
              return ce.href = ce.format(), ce;
            }
            if (ce.protocol = se.protocol, !se.host && !N[se.protocol]) {
              for (var Ct = (se.pathname || "").split("/"); Ct.length && !(se.host = Ct.shift()); ) ;
              se.host || (se.host = ""), se.hostname || (se.hostname = ""), Ct[0] !== "" && Ct.unshift(""), Ct.length < 2 && Ct.unshift(""), ce.pathname = Ct.join("/");
            } else
              ce.pathname = se.pathname;
            if (ce.search = se.search, ce.query = se.query, ce.host = se.host || "", ce.auth = se.auth, ce.hostname = se.hostname || se.host, ce.port = se.port, ce.pathname || ce.search) {
              var Ie = ce.pathname || "", je = ce.search || "";
              ce.path = Ie + je;
            }
            return ce.slashes = ce.slashes || se.slashes, ce.href = ce.format(), ce;
          }
          var Fe = ce.pathname && ce.pathname.charAt(0) === "/", $e = se.host || se.pathname && se.pathname.charAt(0) === "/", ct = $e || Fe || ce.host && se.pathname, wt = ct, Oe = ce.pathname && ce.pathname.split("/") || [], Ct = se.pathname && se.pathname.split("/") || [], Xt = ce.protocol && !U[ce.protocol];
          if (Xt && (ce.hostname = "", ce.port = null, ce.host && (Oe[0] === "" ? Oe[0] = ce.host : Oe.unshift(ce.host)), ce.host = "", se.protocol && (se.hostname = null, se.port = null, se.host && (Ct[0] === "" ? Ct[0] = se.host : Ct.unshift(se.host)), se.host = null), ct = ct && (Ct[0] === "" || Oe[0] === "")), $e)
            ce.host = se.host || se.host === "" ? se.host : ce.host, ce.hostname = se.hostname || se.hostname === "" ? se.hostname : ce.hostname, ce.search = se.search, ce.query = se.query, Oe = Ct;
          else if (Ct.length)
            Oe || (Oe = []), Oe.pop(), Oe = Oe.concat(Ct), ce.search = se.search, ce.query = se.query;
          else if (!r.isNullOrUndefined(se.search)) {
            if (Xt) {
              ce.hostname = ce.host = Oe.shift();
              var vt = ce.host && ce.host.indexOf("@") > 0 ? ce.host.split("@") : !1;
              vt && (ce.auth = vt.shift(), ce.host = ce.hostname = vt.shift());
            }
            return ce.search = se.search, ce.query = se.query, (!r.isNull(ce.pathname) || !r.isNull(ce.search)) && (ce.path = (ce.pathname ? ce.pathname : "") + (ce.search ? ce.search : "")), ce.href = ce.format(), ce;
          }
          if (!Oe.length)
            return ce.pathname = null, ce.search ? ce.path = "/" + ce.search : ce.path = null, ce.href = ce.format(), ce;
          for (var Ye = Oe.slice(-1)[0], qe = (ce.host || se.host || Oe.length > 1) && (Ye === "." || Ye === "..") || Ye === "", rt = 0, it = Oe.length; it >= 0; it--)
            Ye = Oe[it], Ye === "." ? Oe.splice(it, 1) : Ye === ".." ? (Oe.splice(it, 1), rt++) : rt && (Oe.splice(it, 1), rt--);
          if (!ct && !wt)
            for (; rt--; rt)
              Oe.unshift("..");
          ct && Oe[0] !== "" && (!Oe[0] || Oe[0].charAt(0) !== "/") && Oe.unshift(""), qe && Oe.join("/").substr(-1) !== "/" && Oe.push("");
          var Ae = Oe[0] === "" || Oe[0] && Oe[0].charAt(0) === "/";
          if (Xt) {
            ce.hostname = ce.host = Ae ? "" : Oe.length ? Oe.shift() : "";
            var vt = ce.host && ce.host.indexOf("@") > 0 ? ce.host.split("@") : !1;
            vt && (ce.auth = vt.shift(), ce.host = ce.hostname = vt.shift());
          }
          return ct = ct || ce.host && Oe.length, ct && !Ae && Oe.unshift(""), Oe.length ? ce.pathname = Oe.join("/") : (ce.pathname = null, ce.path = null), (!r.isNull(ce.pathname) || !r.isNull(ce.search)) && (ce.path = (ce.pathname ? ce.pathname : "") + (ce.search ? ce.search : "")), ce.auth = se.auth || ce.auth, ce.slashes = ce.slashes || se.slashes, ce.href = ce.format(), ce;
        }, F.prototype.parseHost = function() {
          var se = this.host, ve = P.exec(se);
          ve && (ve = ve[0], ve !== ":" && (this.port = ve.substr(1)), se = se.substr(0, se.length - ve.length)), se && (this.hostname = se);
        };
      }, { "./util": 181, punycode: 134, querystring: 137 }], 181: [function(te, Ee, $) {
        Ee.exports = {
          isString: function(Q) {
            return typeof Q == "string";
          },
          isObject: function(Q) {
            return typeof Q == "object" && Q !== null;
          },
          isNull: function(Q) {
            return Q === null;
          },
          isNullOrUndefined: function(Q) {
            return Q == null;
          }
        };
      }, {}], 182: [function(te, Ee, $) {
        (function(Q) {
          (function() {
            var r = {};
            typeof Ee == "object" ? Ee.exports = r : self.UTIF = r;
            var F;
            typeof te == "function" ? F = te("pako") : F = self.pako;
            function H() {
              (typeof Q > "u" || Q.env.NODE_ENV == "development") && console.log.apply(console, arguments);
            }
            (function(P, M) {
              (function() {
                var E = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(I) {
                  return typeof I;
                } : function(I) {
                  return I && typeof Symbol == "function" && I.constructor === Symbol && I !== Symbol.prototype ? "symbol" : typeof I;
                }, x = function() {
                  function I(z) {
                    this.message = "JPEG error: " + z;
                  }
                  return I.prototype = Error(), I.prototype.name = "JpegError", I.constructor = I;
                }(), m = function() {
                  function I(z, w) {
                    this.message = z, this.g = w;
                  }
                  return I.prototype = Error(), I.prototype.name = "DNLMarkerError", I.constructor = I;
                }();
                (function() {
                  function I() {
                    this.M = null, this.B = -1;
                  }
                  function z(N, U) {
                    for (var V = 0, W = [], q, Y, re = 16; 0 < re && !N[re - 1]; ) re--;
                    W.push({ children: [], index: 0 });
                    var se = W[0], ve;
                    for (q = 0; q < re; q++) {
                      for (Y = 0; Y < N[q]; Y++) {
                        for (se = W.pop(), se.children[se.index] = U[V]; 0 < se.index; ) se = W.pop();
                        for (se.index++, W.push(se); W.length <= q; ) W.push(ve = { children: [], index: 0 }), se.children[se.index] = ve.children, se = ve;
                        V++;
                      }
                      q + 1 < re && (W.push(ve = { children: [], index: 0 }), se.children[se.index] = ve.children, se = ve);
                    }
                    return W[0].children;
                  }
                  function w(N, U, V, W, q, Y, re, se, ve) {
                    function ce() {
                      if (0 < $e) return $e--, Fe >> $e & 1;
                      if (Fe = N[U++], Fe === 255) {
                        var he = N[U++];
                        if (he) {
                          if (he === 220 && Ue) {
                            U += 2;
                            var ie = N[U++] << 8 | N[U++];
                            if (0 < ie && ie !== V.g) throw new m("Found DNL marker (0xFFDC) while parsing scan data", ie);
                          }
                          throw new x("unexpected marker " + (Fe << 8 | he).toString(16));
                        }
                      }
                      return $e = 7, Fe >>> 7;
                    }
                    function be(he) {
                      for (; ; ) {
                        if (he = he[ce()], typeof he == "number") return he;
                        if ((typeof he > "u" ? "undefined" : E(he)) !== "object") throw new x("invalid huffman sequence");
                      }
                    }
                    function Me(he) {
                      for (var ie = 0; 0 < he; ) ie = ie << 1 | ce(), he--;
                      return ie;
                    }
                    function xe(he) {
                      if (he === 1) return ce() === 1 ? 1 : -1;
                      var ie = Me(he);
                      return ie >= 1 << he - 1 ? ie : ie + (-1 << he) + 1;
                    }
                    function le(he, ie) {
                      var Xe = be(he.D);
                      for (Xe = Xe === 0 ? 0 : xe(Xe), he.a[ie] = he.m += Xe, Xe = 1; 64 > Xe; ) {
                        var bt = be(he.o), Wt = bt & 15;
                        if (bt >>= 4, Wt === 0) {
                          if (15 > bt) break;
                          Xe += 16;
                        } else Xe += bt, he.a[ie + B[Xe]] = xe(Wt), Xe++;
                      }
                    }
                    function de(he, ie) {
                      var Xe = be(he.D);
                      Xe = Xe === 0 ? 0 : xe(Xe) << ve, he.a[ie] = he.m += Xe;
                    }
                    function De(he, ie) {
                      he.a[ie] |= ce() << ve;
                    }
                    function ze(he, ie) {
                      if (0 < ct) ct--;
                      else for (var Xe = Y; Xe <= re; ) {
                        var bt = be(he.o), Wt = bt & 15;
                        if (bt >>= 4, Wt === 0) {
                          if (15 > bt) {
                            ct = Me(bt) + (1 << bt) - 1;
                            break;
                          }
                          Xe += 16;
                        } else Xe += bt, he.a[ie + B[Xe]] = xe(Wt) * (1 << ve), Xe++;
                      }
                    }
                    function Ze(he, ie) {
                      for (var Xe = Y, bt = 0, Wt; Xe <= re; ) {
                        Wt = ie + B[Xe];
                        var Qt = 0 > he.a[Wt] ? -1 : 1;
                        switch (wt) {
                          case 0:
                            if (bt = be(he.o), Wt = bt & 15, bt >>= 4, Wt === 0) 15 > bt ? (ct = Me(bt) + (1 << bt), wt = 4) : (bt = 16, wt = 1);
                            else {
                              if (Wt !== 1) throw new x("invalid ACn encoding");
                              Oe = xe(Wt), wt = bt ? 2 : 3;
                            }
                            continue;
                          case 1:
                          case 2:
                            he.a[Wt] ? he.a[Wt] += Qt * (ce() << ve) : (bt--, bt === 0 && (wt = wt === 2 ? 3 : 0));
                            break;
                          case 3:
                            he.a[Wt] ? he.a[Wt] += Qt * (ce() << ve) : (he.a[Wt] = Oe << ve, wt = 0);
                            break;
                          case 4:
                            he.a[Wt] && (he.a[Wt] += Qt * (ce() << ve));
                        }
                        Xe++;
                      }
                      wt === 4 && (ct--, ct === 0 && (wt = 0));
                    }
                    for (var Ue = 9 < arguments.length && arguments[9] !== void 0 ? arguments[9] : !1, Ie = V.P, je = U, Fe = 0, $e = 0, ct = 0, wt = 0, Oe, Ct = W.length, Xt, vt, Ye, qe, rt = V.S ? Y === 0 ? se === 0 ? de : De : se === 0 ? ze : Ze : le, it = 0, Ae = Ct === 1 ? W[0].c * W[0].l : Ie * V.O, _e, fe; it < Ae; ) {
                      var We = q ? Math.min(Ae - it, q) : Ae;
                      for (Xt = 0; Xt < Ct; Xt++) W[Xt].m = 0;
                      if (ct = 0, Ct === 1) {
                        var Pe = W[0];
                        for (qe = 0; qe < We; qe++) rt(Pe, 64 * ((Pe.c + 1) * (it / Pe.c | 0) + it % Pe.c)), it++;
                      } else for (qe = 0; qe < We; qe++) {
                        for (Xt = 0; Xt < Ct; Xt++) for (Pe = W[Xt], _e = Pe.h, fe = Pe.j, vt = 0; vt < fe; vt++) for (Ye = 0; Ye < _e; Ye++) rt(Pe, 64 * ((Pe.c + 1) * ((it / Ie | 0) * Pe.j + vt) + (it % Ie * Pe.h + Ye)));
                        it++;
                      }
                      if ($e = 0, (Pe = b(N, U)) && Pe.f && ((0, _util.warn)("decodeScan - unexpected MCU data, current marker is: " + Pe.f), U = Pe.offset), Pe = Pe && Pe.F, !Pe || 65280 >= Pe) throw new x("marker was not found");
                      if (65488 <= Pe && 65495 >= Pe) U += 2;
                      else break;
                    }
                    return (Pe = b(N, U)) && Pe.f && ((0, _util.warn)("decodeScan - unexpected Scan data, current marker is: " + Pe.f), U = Pe.offset), U - je;
                  }
                  function C(N, U) {
                    for (var V = U.c, W = U.l, q = new Int16Array(64), Y = 0; Y < W; Y++) for (var re = 0; re < V; re++) {
                      var se = 64 * ((U.c + 1) * Y + re), ve = q, ce = U.G, be = U.a;
                      if (!ce) throw new x("missing required Quantization Table.");
                      for (var Me = 0; 64 > Me; Me += 8) {
                        var xe = be[se + Me], le = be[se + Me + 1], de = be[se + Me + 2], De = be[se + Me + 3], ze = be[se + Me + 4], Ze = be[se + Me + 5], Ue = be[se + Me + 6], Ie = be[se + Me + 7];
                        if (xe *= ce[Me], !(le | de | De | ze | Ze | Ue | Ie)) xe = 5793 * xe + 512 >> 10, ve[Me] = xe, ve[Me + 1] = xe, ve[Me + 2] = xe, ve[Me + 3] = xe, ve[Me + 4] = xe, ve[Me + 5] = xe, ve[Me + 6] = xe, ve[Me + 7] = xe;
                        else {
                          le *= ce[Me + 1], de *= ce[Me + 2], De *= ce[Me + 3], ze *= ce[Me + 4], Ze *= ce[Me + 5], Ue *= ce[Me + 6], Ie *= ce[Me + 7];
                          var je = 5793 * xe + 128 >> 8, Fe = 5793 * ze + 128 >> 8, $e = de, ct = Ue;
                          ze = 2896 * (le - Ie) + 128 >> 8, Ie = 2896 * (le + Ie) + 128 >> 8, De <<= 4, Ze <<= 4, je = je + Fe + 1 >> 1, Fe = je - Fe, xe = 3784 * $e + 1567 * ct + 128 >> 8, $e = 1567 * $e - 3784 * ct + 128 >> 8, ct = xe, ze = ze + Ze + 1 >> 1, Ze = ze - Ze, Ie = Ie + De + 1 >> 1, De = Ie - De, je = je + ct + 1 >> 1, ct = je - ct, Fe = Fe + $e + 1 >> 1, $e = Fe - $e, xe = 2276 * ze + 3406 * Ie + 2048 >> 12, ze = 3406 * ze - 2276 * Ie + 2048 >> 12, Ie = xe, xe = 799 * De + 4017 * Ze + 2048 >> 12, De = 4017 * De - 799 * Ze + 2048 >> 12, Ze = xe, ve[Me] = je + Ie, ve[Me + 7] = je - Ie, ve[Me + 1] = Fe + Ze, ve[Me + 6] = Fe - Ze, ve[Me + 2] = $e + De, ve[Me + 5] = $e - De, ve[Me + 3] = ct + ze, ve[Me + 4] = ct - ze;
                        }
                      }
                      for (ce = 0; 8 > ce; ++ce) xe = ve[ce], le = ve[ce + 8], de = ve[ce + 16], De = ve[ce + 24], ze = ve[ce + 32], Ze = ve[ce + 40], Ue = ve[ce + 48], Ie = ve[ce + 56], le | de | De | ze | Ze | Ue | Ie ? (je = 5793 * xe + 2048 >> 12, Fe = 5793 * ze + 2048 >> 12, $e = de, ct = Ue, ze = 2896 * (le - Ie) + 2048 >> 12, Ie = 2896 * (le + Ie) + 2048 >> 12, je = (je + Fe + 1 >> 1) + 4112, Fe = je - Fe, xe = 3784 * $e + 1567 * ct + 2048 >> 12, $e = 1567 * $e - 3784 * ct + 2048 >> 12, ct = xe, ze = ze + Ze + 1 >> 1, Ze = ze - Ze, Ie = Ie + De + 1 >> 1, De = Ie - De, je = je + ct + 1 >> 1, ct = je - ct, Fe = Fe + $e + 1 >> 1, $e = Fe - $e, xe = 2276 * ze + 3406 * Ie + 2048 >> 12, ze = 3406 * ze - 2276 * Ie + 2048 >> 12, Ie = xe, xe = 799 * De + 4017 * Ze + 2048 >> 12, De = 4017 * De - 799 * Ze + 2048 >> 12, Ze = xe, xe = je + Ie, Ie = je - Ie, le = Fe + Ze, Ue = Fe - Ze, de = $e + De, Ze = $e - De, De = ct + ze, ze = ct - ze, xe = 16 > xe ? 0 : 4080 <= xe ? 255 : xe >> 4, le = 16 > le ? 0 : 4080 <= le ? 255 : le >> 4, de = 16 > de ? 0 : 4080 <= de ? 255 : de >> 4, De = 16 > De ? 0 : 4080 <= De ? 255 : De >> 4, ze = 16 > ze ? 0 : 4080 <= ze ? 255 : ze >> 4, Ze = 16 > Ze ? 0 : 4080 <= Ze ? 255 : Ze >> 4, Ue = 16 > Ue ? 0 : 4080 <= Ue ? 255 : Ue >> 4, Ie = 16 > Ie ? 0 : 4080 <= Ie ? 255 : Ie >> 4, be[se + ce] = xe, be[se + ce + 8] = le, be[se + ce + 16] = de, be[se + ce + 24] = De, be[se + ce + 32] = ze, be[se + ce + 40] = Ze, be[se + ce + 48] = Ue, be[se + ce + 56] = Ie) : (xe = 5793 * xe + 8192 >> 14, xe = -2040 > xe ? 0 : 2024 <= xe ? 255 : xe + 2056 >> 4, be[se + ce] = xe, be[se + ce + 8] = xe, be[se + ce + 16] = xe, be[se + ce + 24] = xe, be[se + ce + 32] = xe, be[se + ce + 40] = xe, be[se + ce + 48] = xe, be[se + ce + 56] = xe);
                    }
                    return U.a;
                  }
                  function b(N, U) {
                    var V = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : U, W = N.length - 1;
                    if (V = V < U ? V : U, U >= W) return null;
                    var q = N[U] << 8 | N[U + 1];
                    if (65472 <= q && 65534 >= q) return { f: null, F: q, offset: U };
                    for (var Y = N[V] << 8 | N[V + 1]; !(65472 <= Y && 65534 >= Y); ) {
                      if (++V >= W) return null;
                      Y = N[V] << 8 | N[V + 1];
                    }
                    return { f: q.toString(16), F: Y, offset: V };
                  }
                  var B = new Uint8Array([
                    0,
                    1,
                    8,
                    16,
                    9,
                    2,
                    3,
                    10,
                    17,
                    24,
                    32,
                    25,
                    18,
                    11,
                    4,
                    5,
                    12,
                    19,
                    26,
                    33,
                    40,
                    48,
                    41,
                    34,
                    27,
                    20,
                    13,
                    6,
                    7,
                    14,
                    21,
                    28,
                    35,
                    42,
                    49,
                    56,
                    57,
                    50,
                    43,
                    36,
                    29,
                    22,
                    15,
                    23,
                    30,
                    37,
                    44,
                    51,
                    58,
                    59,
                    52,
                    45,
                    38,
                    31,
                    39,
                    46,
                    53,
                    60,
                    61,
                    54,
                    47,
                    55,
                    62,
                    63
                  ]);
                  I.prototype = { parse: function(N) {
                    function U() {
                      var $e = N[re] << 8 | N[re + 1];
                      return re += 2, $e;
                    }
                    function V() {
                      var $e = U();
                      $e = re + $e - 2;
                      var ct = b(N, $e, re);
                      return ct && ct.f && ((0, _util.warn)("readDataBlock - incorrect length, current marker is: " + ct.f), $e = ct.offset), $e = N.subarray(re, $e), re += $e.length, $e;
                    }
                    function W($e) {
                      for (var ct = Math.ceil($e.v / 8 / $e.s), wt = Math.ceil($e.g / 8 / $e.u), Oe = 0; Oe < $e.b.length; Oe++) {
                        je = $e.b[Oe];
                        var Ct = Math.ceil(Math.ceil($e.v / 8) * je.h / $e.s), Xt = Math.ceil(Math.ceil($e.g / 8) * je.j / $e.u);
                        je.a = new Int16Array(64 * wt * je.j * (ct * je.h + 1)), je.c = Ct, je.l = Xt;
                      }
                      $e.P = ct, $e.O = wt;
                    }
                    var q = (1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}).N, Y = q === void 0 ? null : q, re = 0, se = null, ve = 0;
                    q = [];
                    var ce = [], be = [], Me = U();
                    if (Me !== 65496) throw new x("SOI not found");
                    for (Me = U(); Me !== 65497; ) {
                      switch (Me) {
                        case 65504:
                        case 65505:
                        case 65506:
                        case 65507:
                        case 65508:
                        case 65509:
                        case 65510:
                        case 65511:
                        case 65512:
                        case 65513:
                        case 65514:
                        case 65515:
                        case 65516:
                        case 65517:
                        case 65518:
                        case 65519:
                        case 65534:
                          var xe = V();
                          Me === 65518 && xe[0] === 65 && xe[1] === 100 && xe[2] === 111 && xe[3] === 98 && xe[4] === 101 && (se = { version: xe[5] << 8 | xe[6], Y: xe[7] << 8 | xe[8], Z: xe[9] << 8 | xe[10], W: xe[11] });
                          break;
                        case 65499:
                          Me = U() + re - 2;
                          for (var le; re < Me; ) {
                            var de = N[re++], De = new Uint16Array(64);
                            if (de >> 4) if (de >> 4 === 1) for (xe = 0; 64 > xe; xe++) le = B[xe], De[le] = U();
                            else throw new x("DQT - invalid table spec");
                            else for (xe = 0; 64 > xe; xe++) le = B[xe], De[le] = N[re++];
                            q[de & 15] = De;
                          }
                          break;
                        case 65472:
                        case 65473:
                        case 65474:
                          if (ze) throw new x("Only single frame JPEGs supported");
                          U();
                          var ze = {};
                          for (ze.X = Me === 65473, ze.S = Me === 65474, ze.precision = N[re++], Me = U(), ze.g = Y || Me, ze.v = U(), ze.b = [], ze.C = {}, xe = N[re++], Me = De = de = 0; Me < xe; Me++) {
                            le = N[re];
                            var Ze = N[re + 1] >> 4, Ue = N[re + 1] & 15;
                            de < Ze && (de = Ze), De < Ue && (De = Ue), Ze = ze.b.push({ h: Ze, j: Ue, T: N[re + 2], G: null }), ze.C[le] = Ze - 1, re += 3;
                          }
                          ze.s = de, ze.u = De, W(ze);
                          break;
                        case 65476:
                          for (le = U(), Me = 2; Me < le; ) {
                            for (de = N[re++], De = new Uint8Array(16), xe = Ze = 0; 16 > xe; xe++, re++) Ze += De[xe] = N[re];
                            for (Ue = new Uint8Array(Ze), xe = 0; xe < Ze; xe++, re++) Ue[xe] = N[re];
                            Me += 17 + Ze, (de >> 4 ? ce : be)[de & 15] = z(De, Ue);
                          }
                          break;
                        case 65501:
                          U();
                          var Ie = U();
                          break;
                        case 65498:
                          for (xe = ++ve === 1 && !Y, U(), de = N[re++], le = [], Me = 0; Me < de; Me++) {
                            De = ze.C[N[re++]];
                            var je = ze.b[De];
                            De = N[re++], je.D = be[De >> 4], je.o = ce[De & 15], le.push(je);
                          }
                          Me = N[re++], de = N[re++], De = N[re++];
                          try {
                            var Fe = w(N, re, ze, le, Ie, Me, de, De >> 4, De & 15, xe);
                            re += Fe;
                          } catch ($e) {
                            if ($e instanceof m) return (0, _util.warn)('Attempting to re-parse JPEG image using "scanLines" parameter found in DNL marker (0xFFDC) segment.'), this.parse(N, { N: $e.g });
                            throw $e;
                          }
                          break;
                        case 65500:
                          re += 4;
                          break;
                        case 65535:
                          N[re] !== 255 && re--;
                          break;
                        default:
                          if (N[re - 3] === 255 && 192 <= N[re - 2] && 254 >= N[re - 2]) re -= 3;
                          else if ((xe = b(N, re - 2)) && xe.f) (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + xe.f), re = xe.offset;
                          else throw new x("unknown marker " + Me.toString(16));
                      }
                      Me = U();
                    }
                    for (this.width = ze.v, this.height = ze.g, this.A = se, this.b = [], Me = 0; Me < ze.b.length; Me++)
                      je = ze.b[Me], (Ie = q[je.T]) && (je.G = Ie), this.b.push({ R: C(ze, je), U: je.h / ze.s, V: je.j / ze.u, c: je.c, l: je.l });
                    this.i = this.b.length;
                  }, L: function(N, U) {
                    var V = this.width / N, W = this.height / U, q, Y, re = this.b.length, se = N * U * re, ve = new Uint8ClampedArray(se), ce = new Uint32Array(N);
                    for (Y = 0; Y < re; Y++) {
                      var be = this.b[Y], Me = be.U * V, xe = be.V * W, le = Y, de = be.R, De = be.c + 1 << 3;
                      for (q = 0; q < N; q++) be = 0 | q * Me, ce[q] = (be & 4294967288) << 3 | be & 7;
                      for (Me = 0; Me < U; Me++) for (be = 0 | Me * xe, be = De * (be & 4294967288) | (be & 7) << 3, q = 0; q < N; q++) ve[le] = de[be + ce[q]], le += re;
                    }
                    if (W = this.M) for (Y = 0; Y < se; ) for (V = be = 0; be < re; be++, Y++, V += 2) ve[Y] = (ve[Y] * W[V] >> 8) + W[V + 1];
                    return ve;
                  }, w: function() {
                    return this.A ? !!this.A.W : this.i === 3 ? this.B !== 0 : this.B === 1;
                  }, I: function(N) {
                    for (var U, V, W, q = 0, Y = N.length; q < Y; q += 3) U = N[q], V = N[q + 1], W = N[q + 2], N[q] = U - 179.456 + 1.402 * W, N[q + 1] = U + 135.459 - 0.344 * V - 0.714 * W, N[q + 2] = U - 226.816 + 1.772 * V;
                    return N;
                  }, K: function(N) {
                    for (var U, V, W, q, Y = 0, re = 0, se = N.length; re < se; re += 4) U = N[re], V = N[re + 1], W = N[re + 2], q = N[re + 3], N[Y++] = -122.67195406894 + V * (-660635669420364e-19 * V + 437130475926232e-18 * W - 54080610064599e-18 * U + 48449797120281e-17 * q - 0.154362151871126) + W * (-957964378445773e-18 * W + 817076911346625e-18 * U - 0.00477271405408747 * q + 1.53380253221734) + U * (961250184130688e-18 * U - 0.00266257332283933 * q + 0.48357088451265) + q * (-336197177618394e-18 * q + 0.484791561490776), N[Y++] = 107.268039397724 + V * (219927104525741e-19 * V - 640992018297945e-18 * W + 659397001245577e-18 * U + 426105652938837e-18 * q - 0.176491792462875) + W * (-778269941513683e-18 * W + 0.00130872261408275 * U + 770482631801132e-18 * q - 0.151051492775562) + U * (0.00126935368114843 * U - 0.00265090189010898 * q + 0.25802910206845) + q * (-318913117588328e-18 * q - 0.213742400323665), N[Y++] = -20.810012546947 + V * (-570115196973677e-18 * V - 263409051004589e-19 * W + 0.0020741088115012 * U - 0.00288260236853442 * q + 0.814272968359295) + W * (-153496057440975e-19 * W - 132689043961446e-18 * U + 560833691242812e-18 * q - 0.195152027534049) + U * (0.00174418132927582 * U - 0.00255243321439347 * q + 0.116935020465145) + q * (-343531996510555e-18 * q + 0.24165260232407);
                    return N.subarray(
                      0,
                      Y
                    );
                  }, J: function(N) {
                    for (var U, V, W, q = 0, Y = N.length; q < Y; q += 4) U = N[q], V = N[q + 1], W = N[q + 2], N[q] = 434.456 - U - 1.402 * W, N[q + 1] = 119.541 - U + 0.344 * V + 0.714 * W, N[q + 2] = 481.816 - U - 1.772 * V;
                    return N;
                  }, H: function(N) {
                    for (var U, V, W, q, Y = 0, re = 1 / 255, se = 0, ve = N.length; se < ve; se += 4) U = N[se] * re, V = N[se + 1] * re, W = N[se + 2] * re, q = N[se + 3] * re, N[Y++] = 255 + U * (-4.387332384609988 * U + 54.48615194189176 * V + 18.82290502165302 * W + 212.25662451639585 * q - 285.2331026137004) + V * (1.7149763477362134 * V - 5.6096736904047315 * W - 17.873870861415444 * q - 5.497006427196366) + W * (-2.5217340131683033 * W - 21.248923337353073 * q + 17.5119270841813) - q * (21.86122147463605 * q + 189.48180835922747), N[Y++] = 255 + U * (8.841041422036149 * U + 60.118027045597366 * V + 6.871425592049007 * W + 31.159100130055922 * q - 79.2970844816548) + V * (-15.310361306967817 * V + 17.575251261109482 * W + 131.35250912493976 * q - 190.9453302588951) + W * (4.444339102852739 * W + 9.8632861493405 * q - 24.86741582555878) - q * (20.737325471181034 * q + 187.80453709719578), N[Y++] = 255 + U * (0.8842522430003296 * U + 8.078677503112928 * V + 30.89978309703729 * W - 0.23883238689178934 * q - 14.183576799673286) + V * (10.49593273432072 * V + 63.02378494754052 * W + 50.606957656360734 * q - 112.23884253719248) + W * (0.03296041114873217 * W + 115.60384449646641 * q - 193.58209356861505) - q * (22.33816807309886 * q + 180.12613974708367);
                    return N.subarray(0, Y);
                  }, getData: function(N, U, V) {
                    if (4 < this.i) throw new x("Unsupported color mode");
                    if (N = this.L(N, U), this.i === 1 && V) {
                      V = N.length, U = new Uint8ClampedArray(3 * V);
                      for (var W = 0, q = 0; q < V; q++) {
                        var Y = N[q];
                        U[W++] = Y, U[W++] = Y, U[W++] = Y;
                      }
                      return U;
                    }
                    if (this.i === 3 && this.w()) return this.I(N);
                    if (this.i === 4) {
                      if (this.w()) return V ? this.K(N) : this.J(N);
                      if (V) return this.H(N);
                    }
                    return N;
                  } }, P.JpegDecoder = I;
                })();
              })(), P.encodeImage = function(E, x, m, I) {
                var z = {
                  t256: [x],
                  t257: [m],
                  t258: [8, 8, 8, 8],
                  t259: [1],
                  t262: [2],
                  t273: [1e3],
                  // strips offset
                  t277: [4],
                  t278: [m],
                  /* rows per strip */
                  t279: [x * m * 4],
                  // strip byte counts
                  t282: [1],
                  t283: [1],
                  t284: [1],
                  t286: [0],
                  t287: [0],
                  t296: [1],
                  t305: ["Photopea (UTIF.js)"],
                  t338: [1]
                };
                if (I) for (var w in I) z[w] = I[w];
                for (var C = new Uint8Array(P.encode([z])), b = new Uint8Array(E), B = new Uint8Array(1e3 + x * m * 4), w = 0; w < C.length; w++) B[w] = C[w];
                for (var w = 0; w < b.length; w++) B[1e3 + w] = b[w];
                return B.buffer;
              }, P.encode = function(E) {
                var x = new Uint8Array(2e4), m = 4, I = P._binBE;
                x[0] = 77, x[1] = 77, x[3] = 42;
                var z = 8;
                I.writeUint(x, m, z), m += 4;
                for (var w = 0; w < E.length; w++) {
                  var C = P._writeIFD(I, x, z, E[w]);
                  z = C[1], w < E.length - 1 && I.writeUint(x, C[0], z);
                }
                return x.slice(0, z).buffer;
              }, P.decode = function(E) {
                P.decode._decodeG3.allow2D = null;
                var x = new Uint8Array(E), m = 0, I = P._binBE.readASCII(x, m, 2);
                m += 2;
                var z = I == "II" ? P._binLE : P._binBE;
                z.readUshort(x, m), m += 2;
                var w = z.readUint(x, m);
                m += 4;
                for (var C = []; ; ) {
                  var b = P._readIFD(z, x, w, C);
                  if (w = z.readUint(x, b), w == 0) break;
                }
                return C;
              }, P.decodeImages = function(E, x) {
                for (var m = new Uint8Array(E), I = P._binBE.readASCII(m, 0, 2), z = 0; z < x.length; z++) {
                  var w = x[z];
                  if (w.t256 != null) {
                    w.isLE = I == "II", w.width = w.t256[0], w.height = w.t257[0];
                    var C = w.t259 ? w.t259[0] : 1, b = w.t266 ? w.t266[0] : 1;
                    w.t284 && w.t284[0] == 2 && H("PlanarConfiguration 2 should not be used!");
                    var B = (w.t258 ? Math.min(32, w.t258[0]) : 1) * (w.t277 ? w.t277[0] : 1), N = Math.ceil(w.width * B / 8) * 8, U = w.t273;
                    U == null && (U = w.t324);
                    var V = w.t279;
                    C == 1 && U.length == 1 && (V = [w.height * (N >>> 3)]), V == null && (V = w.t325);
                    var W = new Uint8Array(w.height * (N >>> 3)), q = 0;
                    if (w.t322 != null) {
                      for (var Y = w.t322[0], re = w.t323[0], se = Math.floor((w.width + Y - 1) / Y), ve = Math.floor((w.height + re - 1) / re), ce = new Uint8Array(Math.ceil(Y * re * B / 8) | 0), be = 0; be < ve; be++)
                        for (var Me = 0; Me < se; Me++) {
                          for (var xe = be * se + Me, le = 0; le < ce.length; le++) ce[le] = 0;
                          P.decode._decompress(w, m, U[xe], V[xe], C, ce, 0, b), C == 6 ? W = ce : P._copyTile(ce, Math.ceil(Y * B / 8) | 0, re, W, Math.ceil(w.width * B / 8) | 0, w.height, Math.ceil(Me * Y * B / 8) | 0, be * re);
                        }
                      q = W.length * 8;
                    } else {
                      var de = w.t278 ? w.t278[0] : w.height;
                      de = Math.min(de, w.height);
                      for (var xe = 0; xe < U.length; xe++)
                        P.decode._decompress(w, m, U[xe], V[xe], C, W, Math.ceil(q / 8) | 0, b), q += N * de;
                      q = Math.min(q, W.length * 8);
                    }
                    w.data = new Uint8Array(W.buffer, 0, Math.ceil(q / 8) | 0);
                  }
                }
              }, P.decode._decompress = function(E, x, m, I, z, w, C, b) {
                if (z == 1) for (var B = 0; B < I; B++) w[C + B] = x[m + B];
                else if (z == 3) P.decode._decodeG3(x, m, I, w, C, E.width, b);
                else if (z == 4) P.decode._decodeG4(x, m, I, w, C, E.width, b);
                else if (z == 5) P.decode._decodeLZW(x, m, w, C);
                else if (z == 6) P.decode._decodeOldJPEG(E, x, m, I, w, C);
                else if (z == 7) P.decode._decodeNewJPEG(E, x, m, I, w, C);
                else if (z == 8)
                  for (var N = new Uint8Array(x.buffer, m, I), U = M.inflate(N), V = 0; V < U.length; V++) w[C + V] = U[V];
                else z == 32773 ? P.decode._decodePackBits(x, m, I, w, C) : z == 32809 ? P.decode._decodeThunder(x, m, I, w, C) : H("Unknown compression", z);
                if (E.t317 && E.t317[0] == 2)
                  for (var W = E.t277 ? E.t277[0] : 1, q = E.t278 ? E.t278[0] : E.height, Y = E.width * W, re = 0; re < q; re++) {
                    var se = C + re * Y;
                    if (W == 3) for (var B = 3; B < Y; B += 3)
                      w[se + B] = w[se + B] + w[se + B - 3] & 255, w[se + B + 1] = w[se + B + 1] + w[se + B - 2] & 255, w[se + B + 2] = w[se + B + 2] + w[se + B - 1] & 255;
                    else for (var B = W; B < Y; B++) w[se + B] = w[se + B] + w[se + B - W] & 255;
                  }
              }, P.decode._decodeNikon = function(E, x, b, I, z) {
                var w, C, b;
                H(E.slice(x, x + 100)), w = E[x], x++, C = E[x], x++, H(w.toString(16), C.toString(16), b);
              }, P.decode._decodeNewJPEG = function(E, x, m, I, z, w) {
                var C = E.t347, b = C ? C.length : 0, B = new Uint8Array(b + I);
                if (C) {
                  for (var N = 216, U = 217, V = 0, W = 0; W < b - 1 && !(C[W] == 255 && C[W + 1] == U); W++)
                    B[V++] = C[W];
                  var q = x[m], Y = x[m + 1];
                  (q != 255 || Y != N) && (B[V++] = q, B[V++] = Y);
                  for (var W = 2; W < I; W++) B[V++] = x[m + W];
                } else for (var W = 0; W < I; W++) B[W] = x[m + W];
                if (E.t262 == 32803) {
                  var re = E.t258[0], se = new LosslessJpegDecoder(), ve = se.decode(B), ce = ve.length;
                  if (re == 16) for (var W = 0; W < ce; W++)
                    z[w++] = ve[W] & 255, z[w++] = ve[W] >>> 8;
                  else if (re == 12) for (var W = 0; W < ce; W += 2)
                    z[w++] = ve[W] >>> 4, z[w++] = (ve[W] << 4 | ve[W + 1] >>> 8) & 255, z[w++] = ve[W + 1] & 255;
                  else throw new Error("unsupported bit depth " + re);
                } else {
                  var be = new P.JpegDecoder();
                  be.parse(B);
                  for (var Me = be.getData(be.width, be.height), W = 0; W < Me.length; W++) z[w + W] = Me[W];
                }
                E.t262[0] == 6 && (E.t262[0] = 2);
              }, P.decode._decodeOldJPEGInit = function(E, x, m, I) {
                var z = 216, w = 219, C = 196, b = 221, B = 192, N = 218, U = 0, V = 0, W, q, Y = !1, re, se, ve, ce = E.t513, be = ce ? ce[0] : 0, Me = E.t514, xe = Me ? Me[0] : 0, le = E.t324 || E.t273 || ce, de = E.t530, De = 0, ze = 0, Ze = E.t277 ? E.t277[0] : 1, Ue = E.t515;
                if (le && (V = le[0], Y = le.length > 1), !Y) {
                  if (x[m] == 255 && x[m + 1] == z) return { jpegOffset: m };
                  if (ce != null && (x[m + be] == 255 && x[m + be + 1] == z ? U = m + be : H("JPEGInterchangeFormat does not point to SOI"), Me == null ? H("JPEGInterchangeFormatLength field is missing") : (be >= V || be + xe <= V) && H("JPEGInterchangeFormatLength field value is invalid"), U != null))
                    return { jpegOffset: U };
                }
                if (de != null && (De = de[0], ze = de[1]), ce != null && Me != null)
                  if (xe >= 2 && be + xe <= V) {
                    for (x[m + be + xe - 2] == 255 && x[m + be + xe - 1] == z ? W = new Uint8Array(xe - 2) : W = new Uint8Array(xe), re = 0; re < W.length; re++) W[re] = x[m + be + re];
                    H("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
                  } else H("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
                if (W == null) {
                  var Ie = 0, je = [];
                  je[Ie++] = 255, je[Ie++] = z;
                  var Fe = E.t519;
                  if (Fe == null) throw new Error("JPEGQTables tag is missing");
                  for (re = 0; re < Fe.length; re++)
                    for (je[Ie++] = 255, je[Ie++] = w, je[Ie++] = 0, je[Ie++] = 67, je[Ie++] = re, se = 0; se < 64; se++) je[Ie++] = x[m + Fe[re] + se];
                  for (ve = 0; ve < 2; ve++) {
                    var $e = E[ve == 0 ? "t520" : "t521"];
                    if ($e == null) throw new Error((ve == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
                    for (re = 0; re < $e.length; re++) {
                      je[Ie++] = 255, je[Ie++] = C;
                      var ct = 19;
                      for (se = 0; se < 16; se++) ct += x[m + $e[re] + se];
                      for (je[Ie++] = ct >>> 8, je[Ie++] = ct & 255, je[Ie++] = re | ve << 4, se = 0; se < 16; se++) je[Ie++] = x[m + $e[re] + se];
                      for (se = 0; se < ct; se++) je[Ie++] = x[m + $e[re] + 16 + se];
                    }
                  }
                  if (je[Ie++] = 255, je[Ie++] = B, je[Ie++] = 0, je[Ie++] = 8 + 3 * Ze, je[Ie++] = 8, je[Ie++] = E.height >>> 8 & 255, je[Ie++] = E.height & 255, je[Ie++] = E.width >>> 8 & 255, je[Ie++] = E.width & 255, je[Ie++] = Ze, Ze == 1)
                    je[Ie++] = 1, je[Ie++] = 17, je[Ie++] = 0;
                  else for (re = 0; re < 3; re++)
                    je[Ie++] = re + 1, je[Ie++] = re != 0 ? 17 : (De & 15) << 4 | ze & 15, je[Ie++] = re;
                  Ue != null && Ue[0] != 0 && (je[Ie++] = 255, je[Ie++] = b, je[Ie++] = 0, je[Ie++] = 4, je[Ie++] = Ue[0] >>> 8 & 255, je[Ie++] = Ue[0] & 255), W = new Uint8Array(je);
                }
                var wt = -1;
                for (re = 0; re < W.length - 1; ) {
                  if (W[re] == 255 && W[re + 1] == B) {
                    wt = re;
                    break;
                  }
                  re++;
                }
                if (wt == -1) {
                  var Oe = new Uint8Array(W.length + 10 + 3 * Ze);
                  Oe.set(W);
                  var Ct = W.length;
                  if (wt = W.length, W = Oe, W[Ct++] = 255, W[Ct++] = B, W[Ct++] = 0, W[Ct++] = 8 + 3 * Ze, W[Ct++] = 8, W[Ct++] = E.height >>> 8 & 255, W[Ct++] = E.height & 255, W[Ct++] = E.width >>> 8 & 255, W[Ct++] = E.width & 255, W[Ct++] = Ze, Ze == 1)
                    W[Ct++] = 1, W[Ct++] = 17, W[Ct++] = 0;
                  else for (re = 0; re < 3; re++)
                    W[Ct++] = re + 1, W[Ct++] = re != 0 ? 17 : (De & 15) << 4 | ze & 15, W[Ct++] = re;
                }
                if (x[V] == 255 && x[V + 1] == N) {
                  var Xt = x[V + 2] << 8 | x[V + 3];
                  for (q = new Uint8Array(Xt + 2), q[0] = x[V], q[1] = x[V + 1], q[2] = x[V + 2], q[3] = x[V + 3], re = 0; re < Xt - 2; re++) q[re + 4] = x[V + re + 4];
                } else {
                  q = new Uint8Array(8 + 2 * Ze);
                  var vt = 0;
                  if (q[vt++] = 255, q[vt++] = N, q[vt++] = 0, q[vt++] = 6 + 2 * Ze, q[vt++] = Ze, Ze == 1)
                    q[vt++] = 1, q[vt++] = 0;
                  else for (re = 0; re < 3; re++)
                    q[vt++] = re + 1, q[vt++] = re << 4 | re;
                  q[vt++] = 0, q[vt++] = 63, q[vt++] = 0;
                }
                return { jpegOffset: m, tables: W, sosMarker: q, sofPosition: wt };
              }, P.decode._decodeOldJPEG = function(E, x, m, I, z, w) {
                var C, b, B, N, U = P.decode._decodeOldJPEGInit(E, x, m, I);
                if (U.jpegOffset != null)
                  for (b = m + I - U.jpegOffset, N = new Uint8Array(b), C = 0; C < b; C++) N[C] = x[U.jpegOffset + C];
                else {
                  for (B = U.tables.length, N = new Uint8Array(B + U.sosMarker.length + I + 2), N.set(U.tables), N[U.sofPosition + 5] = E.height >>> 8 & 255, N[U.sofPosition + 6] = E.height & 255, N[U.sofPosition + 7] = E.width >>> 8 & 255, N[U.sofPosition + 8] = E.width & 255, (x[m] != 255 || x[m + 1] != SOS) && (N.set(U.sosMarker, bufoff), bufoff += sosMarker.length), C = 0; C < I; C++) N[bufoff++] = x[m + C];
                  N[bufoff++] = 255, N[bufoff++] = EOI;
                }
                var V = new P.JpegDecoder();
                V.parse(N);
                for (var W = V.getData(V.width, V.height), C = 0; C < W.length; C++) z[w + C] = W[C];
                E.t262[0] == 6 && (E.t262[0] = 2);
              }, P.decode._decodePackBits = function(E, x, m, I, z) {
                for (var w = new Int8Array(E.buffer), C = new Int8Array(I.buffer), b = x + m; x < b; ) {
                  var B = w[x];
                  if (x++, B >= 0 && B < 128) for (var N = 0; N < B + 1; N++)
                    C[z] = w[x], z++, x++;
                  if (B >= -127 && B < 0) {
                    for (var N = 0; N < -B + 1; N++)
                      C[z] = w[x], z++;
                    x++;
                  }
                }
              }, P.decode._decodeThunder = function(E, x, m, I, z) {
                for (var w = [0, 1, 0, -1], C = [0, 1, 2, 3, 0, -3, -2, -1], b = x + m, B = z * 2, N = 0; x < b; ) {
                  var U = E[x], V = U >>> 6, W = U & 63;
                  if (x++, V == 3 && (N = W & 15, I[B >>> 1] |= N << 4 * (1 - B & 1), B++), V == 0) for (var q = 0; q < W; q++)
                    I[B >>> 1] |= N << 4 * (1 - B & 1), B++;
                  if (V == 2) for (var q = 0; q < 2; q++) {
                    var Y = W >>> 3 * (1 - q) & 7;
                    Y != 4 && (N += C[Y], I[B >>> 1] |= N << 4 * (1 - B & 1), B++);
                  }
                  if (V == 1) for (var q = 0; q < 3; q++) {
                    var Y = W >>> 2 * (2 - q) & 3;
                    Y != 2 && (N += w[Y], I[B >>> 1] |= N << 4 * (1 - B & 1), B++);
                  }
                }
              }, P.decode._dmap = { 1: 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 }, P.decode._lens = function() {
                var E = function(B, N, U, V) {
                  for (var W = 0; W < N.length; W++) B[N[W]] = U + W * V;
                }, x = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", m = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", I = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", z = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", w = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
                x = x.split(","), m = m.split(","), I = I.split(","), z = z.split(","), w = w.split(",");
                var C = {}, b = {};
                return E(C, x, 0, 1), E(C, I, 64, 64), E(C, w, 1792, 64), E(b, m, 0, 1), E(b, z, 64, 64), E(b, w, 1792, 64), [C, b];
              }(), P.decode._decodeG4 = function(E, x, m, I, z, w, C) {
                for (var b = P.decode, B = x << 3, N = 0, U = "", V = [], W = [], q = 0; q < w; q++) W.push(0);
                W = b._makeDiff(W);
                for (var Y = 0, re = 0, se = 0, ve = 0, ce = 0, be = 0, Me = "", xe = 0, le = Math.ceil(w / 8) * 8; B >>> 3 < x + m; ) {
                  se = b._findDiff(W, Y + (Y == 0 ? 0 : 1), 1 - ce), ve = b._findDiff(W, se, ce);
                  var de = 0;
                  if (C == 1 && (de = E[B >>> 3] >>> 7 - (B & 7) & 1), C == 2 && (de = E[B >>> 3] >>> (B & 7) & 1), B++, U += de, Me == "H") {
                    if (b._lens[ce][U] != null) {
                      var De = b._lens[ce][U];
                      U = "", N += De, De < 64 && (b._addNtimes(V, N, ce), Y += N, ce = 1 - ce, N = 0, xe--, xe == 0 && (Me = ""));
                    }
                  } else
                    U == "0001" && (U = "", b._addNtimes(V, ve - Y, ce), Y = ve), U == "001" && (U = "", Me = "H", xe = 2), b._dmap[U] != null && (re = se + b._dmap[U], b._addNtimes(V, re - Y, ce), Y = re, U = "", ce = 1 - ce);
                  V.length == w && Me == "" && (b._writeBits(V, I, z * 8 + be * le), ce = 0, be++, Y = 0, W = b._makeDiff(V), V = []);
                }
              }, P.decode._findDiff = function(E, x, m) {
                for (var I = 0; I < E.length; I += 2) if (E[I] >= x && E[I + 1] == m) return E[I];
              }, P.decode._makeDiff = function(E) {
                var x = [];
                E[0] == 1 && x.push(0, 1);
                for (var m = 1; m < E.length; m++) E[m - 1] != E[m] && x.push(m, E[m]);
                return x.push(E.length, 0, E.length, 1), x;
              }, P.decode._decodeG3 = function(E, x, m, I, z, w, C) {
                for (var b = P.decode, B = x << 3, N = 0, U = "", V = [], W = [], q = 0; q < w; q++) V.push(0);
                for (var Y = 0, re = 0, se = 0, ve = 0, ce = 0, be = -1, Me = "", xe = 0, le = !1, de = Math.ceil(w / 8) * 8; B >>> 3 < x + m; ) {
                  se = b._findDiff(W, Y + (Y == 0 ? 0 : 1), 1 - ce), ve = b._findDiff(W, se, ce);
                  var De = 0;
                  if (C == 1 && (De = E[B >>> 3] >>> 7 - (B & 7) & 1), C == 2 && (De = E[B >>> 3] >>> (B & 7) & 1), B++, U += De, le) {
                    if (b._lens[ce][U] != null) {
                      var ze = b._lens[ce][U];
                      U = "", N += ze, ze < 64 && (b._addNtimes(V, N, ce), ce = 1 - ce, N = 0);
                    }
                  } else if (Me == "H") {
                    if (b._lens[ce][U] != null) {
                      var ze = b._lens[ce][U];
                      U = "", N += ze, ze < 64 && (b._addNtimes(V, N, ce), Y += N, ce = 1 - ce, N = 0, xe--, xe == 0 && (Me = ""));
                    }
                  } else
                    U == "0001" && (U = "", b._addNtimes(V, ve - Y, ce), Y = ve), U == "001" && (U = "", Me = "H", xe = 2), b._dmap[U] != null && (re = se + b._dmap[U], b._addNtimes(V, re - Y, ce), Y = re, U = "", ce = 1 - ce);
                  U.endsWith("000000000001") && (be >= 0 && b._writeBits(V, I, z * 8 + be * de), C == 1 && (le = (E[B >>> 3] >>> 7 - (B & 7) & 1) == 1), C == 2 && (le = (E[B >>> 3] >>> (B & 7) & 1) == 1), B++, b._decodeG3.allow2D == null && (b._decodeG3.allow2D = le), b._decodeG3.allow2D || (le = !0, B--), U = "", ce = 0, be++, Y = 0, W = b._makeDiff(V), V = []);
                }
                V.length == w && b._writeBits(V, I, z * 8 + be * de);
              }, P.decode._addNtimes = function(E, x, m) {
                for (var I = 0; I < x; I++) E.push(m);
              }, P.decode._writeBits = function(E, x, m) {
                for (var I = 0; I < E.length; I++) x[m + I >>> 3] |= E[I] << 7 - (m + I & 7);
              }, P.decode._decodeLZW = function(E, x, m, I) {
                if (P.decode._lzwTab == null) {
                  for (var z = new Uint32Array(65535), w = new Uint16Array(65535), U = new Uint8Array(2e6), C = 0; C < 256; C++)
                    U[C << 2] = C, z[C] = C << 2, w[C] = 1;
                  P.decode._lzwTab = [z, w, U];
                }
                for (var b = P.decode._copyData, B = P.decode._lzwTab[0], N = P.decode._lzwTab[1], U = P.decode._lzwTab[2], V = 258, W = 1032, q = 9, Y = x << 3, re = 256, se = 257, ve = 0, ce = 0, be = 0; ve = E[Y >>> 3] << 16 | E[Y + 8 >>> 3] << 8 | E[Y + 16 >>> 3], ce = ve >> 24 - (Y & 7) - q & (1 << q) - 1, Y += q, ce != se; ) {
                  if (ce == re) {
                    if (q = 9, V = 258, W = 1032, ve = E[Y >>> 3] << 16 | E[Y + 8 >>> 3] << 8 | E[Y + 16 >>> 3], ce = ve >> 24 - (Y & 7) - q & (1 << q) - 1, Y += q, ce == se) break;
                    m[I] = ce, I++;
                  } else if (ce < V) {
                    var Me = B[ce], xe = N[ce];
                    if (b(U, Me, m, I, xe), I += xe, be >= V)
                      B[V] = W, U[B[V]] = Me[0], N[V] = 1, W = W + 1 + 3 & -4, V++;
                    else {
                      B[V] = W;
                      var le = B[be], de = N[be];
                      b(U, le, U, W, de), U[W + de] = U[Me], de++, N[V] = de, V++, W = W + de + 3 & -4;
                    }
                    V + 1 == 1 << q && q++;
                  } else {
                    if (be >= V)
                      B[V] = W, N[V] = 0, V++;
                    else {
                      B[V] = W;
                      var le = B[be], de = N[be];
                      b(U, le, U, W, de), U[W + de] = U[W], de++, N[V] = de, V++, b(U, W, m, I, de), I += de, W = W + de + 3 & -4;
                    }
                    V + 1 == 1 << q && q++;
                  }
                  be = ce;
                }
              }, P.decode._copyData = function(E, x, m, I, z) {
                for (var w = 0; w < z; w += 4)
                  m[I + w] = E[x + w], m[I + w + 1] = E[x + w + 1], m[I + w + 2] = E[x + w + 2], m[I + w + 3] = E[x + w + 3];
              }, P.tags = {
                254: "NewSubfileType",
                255: "SubfileType",
                256: "ImageWidth",
                257: "ImageLength",
                258: "BitsPerSample",
                259: "Compression",
                262: "PhotometricInterpretation",
                266: "FillOrder",
                269: "DocumentName",
                270: "ImageDescription",
                271: "Make",
                272: "Model",
                273: "StripOffset",
                274: "Orientation",
                277: "SamplesPerPixel",
                278: "RowsPerStrip",
                279: "StripByteCounts",
                280: "MinSampleValue",
                281: "MaxSampleValue",
                282: "XResolution",
                283: "YResolution",
                284: "PlanarConfiguration",
                285: "PageName",
                286: "XPosition",
                287: "YPosition",
                292: "T4Options",
                296: "ResolutionUnit",
                297: "PageNumber",
                305: "Software",
                306: "DateTime",
                315: "Artist",
                316: "HostComputer",
                317: "Predictor",
                318: "WhitePoint",
                319: "PrimaryChromaticities",
                320: "ColorMap",
                321: "HalftoneHints",
                322: "TileWidth",
                323: "TileLength",
                324: "TileOffset",
                325: "TileByteCounts",
                330: "SubIFDs",
                336: "DotRange",
                338: "ExtraSample",
                339: "SampleFormat",
                347: "JPEGTables",
                512: "JPEGProc",
                513: "JPEGInterchangeFormat",
                514: "JPEGInterchangeFormatLength",
                519: "JPEGQTables",
                520: "JPEGDCTables",
                521: "JPEGACTables",
                529: "YCbCrCoefficients",
                530: "YCbCrSubSampling",
                531: "YCbCrPositioning",
                532: "ReferenceBlackWhite",
                700: "XMP",
                33421: "CFARepeatPatternDim",
                33422: "CFAPattern",
                33432: "Copyright",
                33434: "ExposureTime",
                33437: "FNumber",
                33723: "IPTC/NAA",
                34377: "Photoshop",
                34665: "ExifIFD",
                34675: "ICC Profile",
                34850: "ExposureProgram",
                34853: "GPSInfo",
                34855: "ISOSpeedRatings",
                34858: "TimeZoneOffset",
                34859: "SelfTimeMode",
                36867: "DateTimeOriginal",
                36868: "DateTimeDigitized",
                37377: "ShutterSpeedValue",
                37378: "ApertureValue",
                37380: "ExposureBiasValue",
                37383: "MeteringMode",
                37385: "Flash",
                37386: "FocalLength",
                37390: "FocalPlaneXResolution",
                37391: "FocalPlaneYResolution",
                37392: "FocalPlaneResolutionUnit",
                37393: "ImageNumber",
                37398: "TIFF/EPStandardID",
                37399: "SensingMethod",
                37500: "MakerNote",
                37510: "UserComment",
                37724: "ImageSourceData",
                40092: "XPComment",
                40094: "XPKeywords",
                40961: "ColorSpace",
                40962: "PixelXDimension",
                40963: "PixelXDimension",
                41486: "FocalPlaneXResolution",
                41487: "FocalPlaneYResolution",
                41488: "FocalPlaneResolutionUnit",
                41985: "CustomRendered",
                41986: "ExposureMode",
                41987: "WhiteBalance",
                41990: "SceneCaptureType",
                50706: "DNGVersion",
                50707: "DNGBackwardVersion",
                50708: "UniqueCameraModel",
                50709: "LocalizedCameraModel",
                50710: "CFAPlaneColor",
                50711: "CFALayout",
                50712: "LinearizationTable",
                50713: "BlackLevelRepeatDim",
                50714: "BlackLevel",
                50716: "BlackLevelDeltaV",
                50717: "WhiteLevel",
                50718: "DefaultScale",
                50719: "DefaultCropOrigin",
                50720: "DefaultCropSize",
                50733: "BayerGreenSplit",
                50738: "AntiAliasStrength",
                50721: "ColorMatrix1",
                50722: "ColorMatrix2",
                50723: "CameraCalibration1",
                50724: "CameraCalibration2",
                50727: "AnalogBalance",
                50728: "AsShotNeutral",
                50730: "BaselineExposure",
                50731: "BaselineNoise",
                50732: "BaselineSharpness",
                50734: "LinearResponseLimit",
                50735: "CameraSerialNumber",
                50736: "LensInfo",
                50739: "ShadowScale",
                50740: "DNGPrivateData",
                50741: "MakerNoteSafety",
                50778: "CalibrationIlluminant1",
                50779: "CalibrationIlluminant2",
                50780: "BestQualityScale",
                50781: "RawDataUniqueID",
                50827: "OriginalRawFileName",
                50829: "ActiveArea",
                50830: "MaskedAreas",
                50931: "CameraCalibrationSignature",
                50932: "ProfileCalibrationSignature",
                50935: "NoiseReductionApplied",
                50936: "ProfileName",
                50937: "ProfileHueSatMapDims",
                50938: "ProfileHueSatMapData1",
                50939: "ProfileHueSatMapData2",
                50940: "ProfileToneCurve",
                50941: "ProfileEmbedPolicy",
                50942: "ProfileCopyright",
                50964: "ForwardMatrix1",
                50965: "ForwardMatrix2",
                50966: "PreviewApplicationName",
                50967: "PreviewApplicationVersion",
                50969: "PreviewSettingsDigest",
                50970: "PreviewColorSpace",
                50971: "PreviewDateTime",
                50972: "RawImageDigest",
                51008: "OpcodeList1",
                51009: "OpcodeList2",
                51022: "OpcodeList3",
                51041: "NoiseProfile",
                51089: "OriginalDefaultFinalSize",
                51090: "OriginalBestQualityFinalSize",
                51091: "OriginalDefaultCropSize",
                51125: "DefaultUserCrop"
              }, P.ttypes = { 256: 3, 257: 3, 258: 3, 259: 3, 262: 3, 273: 4, 274: 3, 277: 3, 278: 4, 279: 4, 282: 5, 283: 5, 284: 3, 286: 5, 287: 5, 296: 3, 305: 2, 306: 2, 338: 3, 513: 4, 514: 4, 34665: 4 }, P._readIFD = function(E, x, m, I) {
                var z = E.readUshort(x, m);
                m += 2;
                var w = {};
                I.push(w);
                for (var C = 0; C < z; C++) {
                  var b = E.readUshort(x, m);
                  m += 2;
                  var B = E.readUshort(x, m);
                  m += 2;
                  var N = E.readUint(x, m);
                  m += 4;
                  var U = E.readUint(x, m);
                  m += 4;
                  var V = [];
                  if (w["t" + b] = V, B == 1 || B == 7)
                    for (var W = 0; W < N; W++) V.push(x[(N < 5 ? m - 4 : U) + W]);
                  if (B == 2 && V.push(E.readASCII(x, N < 5 ? m - 4 : U, N - 1)), B == 3)
                    for (var W = 0; W < N; W++) V.push(E.readUshort(x, (N < 3 ? m - 4 : U) + 2 * W));
                  if (B == 4)
                    for (var W = 0; W < N; W++) V.push(E.readUint(x, (N < 2 ? m - 4 : U) + 4 * W));
                  if (B == 5)
                    for (var W = 0; W < N; W++) V.push(E.readUint(x, U + W * 8) / E.readUint(x, U + W * 8 + 4));
                  if (B == 8)
                    for (var W = 0; W < N; W++) V.push(E.readShort(x, (N < 3 ? m - 4 : U) + 2 * W));
                  if (B == 9)
                    for (var W = 0; W < N; W++) V.push(E.readInt(x, (N < 2 ? m - 4 : U) + 4 * W));
                  if (B == 10)
                    for (var W = 0; W < N; W++) V.push(E.readInt(x, U + W * 8) / E.readInt(x, U + W * 8 + 4));
                  if (B == 11)
                    for (var W = 0; W < N; W++) V.push(E.readFloat(x, U + W * 4));
                  if (B == 12)
                    for (var W = 0; W < N; W++) V.push(E.readDouble(x, U + W * 8));
                  if (N != 0 && V.length == 0 && H("unknown TIFF tag type: ", B, "num:", N), b == 330) for (var W = 0; W < N; W++) P._readIFD(E, x, V[W], I);
                }
                return m;
              }, P._writeIFD = function(E, x, m, I) {
                var z = Object.keys(I);
                E.writeUshort(x, m, z.length), m += 2;
                for (var w = m + z.length * 12 + 4, C = 0; C < z.length; C++) {
                  var b = z[C], B = parseInt(b.slice(1)), N = P.ttypes[B];
                  if (N == null) throw new Error("unknown type of tag: " + B);
                  var U = I[b];
                  N == 2 && (U = U[0] + "\0");
                  var V = U.length;
                  E.writeUshort(x, m, B), m += 2, E.writeUshort(x, m, N), m += 2, E.writeUint(x, m, V), m += 4;
                  var W = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][N] * V, q = m;
                  if (W > 4 && (E.writeUint(x, m, w), q = w), N == 2 && E.writeASCII(x, q, U), N == 3)
                    for (var Y = 0; Y < V; Y++) E.writeUshort(x, q + 2 * Y, U[Y]);
                  if (N == 4)
                    for (var Y = 0; Y < V; Y++) E.writeUint(x, q + 4 * Y, U[Y]);
                  if (N == 5)
                    for (var Y = 0; Y < V; Y++)
                      E.writeUint(x, q + 8 * Y, Math.round(U[Y] * 1e4)), E.writeUint(x, q + 8 * Y + 4, 1e4);
                  if (N == 12)
                    for (var Y = 0; Y < V; Y++) E.writeDouble(x, q + 8 * Y, U[Y]);
                  W > 4 && (W += W & 1, w += W), m += 4;
                }
                return [m, w];
              }, P.toRGBA8 = function(E) {
                var x = E.width, m = E.height, I = x * m, z = I * 4, w = E.data, C = new Uint8Array(I * 4), b = E.t262[0], B = E.t258 ? Math.min(32, E.t258[0]) : 1, N = E.isLE ? 1 : 0;
                if (b == 0)
                  for (var U = Math.ceil(B * x / 8), V = 0; V < m; V++) {
                    var W = V * U, q = V * x;
                    if (B == 1) for (var Y = 0; Y < x; Y++) {
                      var re = q + Y << 2, se = w[W + (Y >> 3)] >> 7 - (Y & 7) & 1;
                      C[re] = C[re + 1] = C[re + 2] = (1 - se) * 255, C[re + 3] = 255;
                    }
                    if (B == 4) for (var Y = 0; Y < x; Y++) {
                      var re = q + Y << 2, se = w[W + (Y >> 1)] >> 4 - 4 * (Y & 1) & 15;
                      C[re] = C[re + 1] = C[re + 2] = (15 - se) * 17, C[re + 3] = 255;
                    }
                    if (B == 8) for (var Y = 0; Y < x; Y++) {
                      var re = q + Y << 2, se = w[W + Y];
                      C[re] = C[re + 1] = C[re + 2] = 255 - se, C[re + 3] = 255;
                    }
                  }
                else if (b == 1)
                  for (var U = Math.ceil(B * x / 8), V = 0; V < m; V++) {
                    var W = V * U, q = V * x;
                    if (B == 1) for (var Y = 0; Y < x; Y++) {
                      var re = q + Y << 2, se = w[W + (Y >> 3)] >> 7 - (Y & 7) & 1;
                      C[re] = C[re + 1] = C[re + 2] = se * 255, C[re + 3] = 255;
                    }
                    if (B == 2) for (var Y = 0; Y < x; Y++) {
                      var re = q + Y << 2, se = w[W + (Y >> 2)] >> 6 - 2 * (Y & 3) & 3;
                      C[re] = C[re + 1] = C[re + 2] = se * 85, C[re + 3] = 255;
                    }
                    if (B == 8) for (var Y = 0; Y < x; Y++) {
                      var re = q + Y << 2, se = w[W + Y];
                      C[re] = C[re + 1] = C[re + 2] = se, C[re + 3] = 255;
                    }
                    if (B == 16) for (var Y = 0; Y < x; Y++) {
                      var re = q + Y << 2, se = w[W + (2 * Y + N)];
                      C[re] = C[re + 1] = C[re + 2] = Math.min(255, se), C[re + 3] = 255;
                    }
                  }
                else if (b == 2)
                  if (B == 8)
                    if (E.t338)
                      if (E.t338[0] > 0) for (var Y = 0; Y < z; Y++) C[Y] = w[Y];
                      else for (var Y = 0; Y < z; Y += 4)
                        C[Y] = w[Y], C[Y + 1] = w[Y + 1], C[Y + 2] = w[Y + 2], C[Y + 3] = 255;
                    else {
                      var ve = E.t258 ? E.t258.length : 3;
                      if (ve == 4) for (var Y = 0; Y < z; Y++) C[Y] = w[Y];
                      if (ve == 3) for (var Y = 0; Y < I; Y++) {
                        var re = Y << 2, ce = Y * 3;
                        C[re] = w[ce], C[re + 1] = w[ce + 1], C[re + 2] = w[ce + 2], C[re + 3] = 255;
                      }
                    }
                  else
                    for (var Y = 0; Y < I; Y++) {
                      var re = Y << 2, ce = Y * 6;
                      C[re] = w[ce], C[re + 1] = w[ce + 2], C[re + 2] = w[ce + 4], C[re + 3] = 255;
                    }
                else if (b == 3)
                  for (var be = E.t320, Y = 0; Y < I; Y++) {
                    var re = Y << 2, Me = w[Y];
                    C[re] = be[Me] >> 8, C[re + 1] = be[256 + Me] >> 8, C[re + 2] = be[512 + Me] >> 8, C[re + 3] = 255;
                  }
                else if (b == 5)
                  for (var ve = E.t258 ? E.t258.length : 4, xe = ve > 4 ? 1 : 0, Y = 0; Y < I; Y++) {
                    var re = Y << 2, le = Y * ve, de = 255 - w[le], De = 255 - w[le + 1], ze = 255 - w[le + 2], Ze = (255 - w[le + 3]) * (1 / 255);
                    C[re] = ~~(de * Ze + 0.5), C[re + 1] = ~~(De * Ze + 0.5), C[re + 2] = ~~(ze * Ze + 0.5), C[re + 3] = 255 * (1 - xe) + w[le + 4] * xe;
                  }
                else H("Unknown Photometric interpretation: " + b);
                return C;
              }, P.replaceIMG = function() {
                for (var E = document.getElementsByTagName("img"), x = 0; x < E.length; x++) {
                  var m = E[x], I = m.getAttribute("src");
                  if (I != null) {
                    var z = I.split(".").pop().toLowerCase();
                    if (!(z != "tif" && z != "tiff")) {
                      var w = new XMLHttpRequest();
                      P._xhrs.push(w), P._imgs.push(m), w.open("GET", I), w.responseType = "arraybuffer", w.onload = P._imgLoaded, w.send();
                    }
                  }
                }
              }, P._xhrs = [], P._imgs = [], P._imgLoaded = function(E) {
                var x = E.target.response, m = P.decode(x), I = m[0];
                P.decodeImages(x, m);
                var z = P.toRGBA8(I), w = I.width, C = I.height, b = P._xhrs.indexOf(E.target), B = P._imgs[b];
                P._xhrs.splice(b, 1), P._imgs.splice(b, 1);
                var N = document.createElement("canvas");
                N.width = w, N.height = C;
                for (var U = N.getContext("2d"), V = U.createImageData(w, C), W = 0; W < z.length; W++) V.data[W] = z[W];
                U.putImageData(V, 0, 0);
                for (var q = ["style", "class", "id"], W = 0; W < q.length; W++) N.setAttribute(q[W], B.getAttribute(q[W]));
                B.parentNode.replaceChild(N, B);
              }, P._binBE = {
                nextZero: function(E, x) {
                  for (; E[x] != 0; ) x++;
                  return x;
                },
                readUshort: function(E, x) {
                  return E[x] << 8 | E[x + 1];
                },
                readShort: function(E, x) {
                  var m = P._binBE.ui8;
                  return m[0] = E[x + 1], m[1] = E[x + 0], P._binBE.i16[0];
                },
                readInt: function(E, x) {
                  var m = P._binBE.ui8;
                  return m[0] = E[x + 3], m[1] = E[x + 2], m[2] = E[x + 1], m[3] = E[x + 0], P._binBE.i32[0];
                },
                readUint: function(E, x) {
                  var m = P._binBE.ui8;
                  return m[0] = E[x + 3], m[1] = E[x + 2], m[2] = E[x + 1], m[3] = E[x + 0], P._binBE.ui32[0];
                },
                readASCII: function(E, x, m) {
                  for (var I = "", z = 0; z < m; z++) I += String.fromCharCode(E[x + z]);
                  return I;
                },
                readFloat: function(E, x) {
                  for (var m = P._binBE.ui8, I = 0; I < 4; I++) m[I] = E[x + 3 - I];
                  return P._binBE.fl32[0];
                },
                readDouble: function(E, x) {
                  for (var m = P._binBE.ui8, I = 0; I < 8; I++) m[I] = E[x + 7 - I];
                  return P._binBE.fl64[0];
                },
                writeUshort: function(E, x, m) {
                  E[x] = m >> 8 & 255, E[x + 1] = m & 255;
                },
                writeUint: function(E, x, m) {
                  E[x] = m >> 24 & 255, E[x + 1] = m >> 16 & 255, E[x + 2] = m >> 8 & 255, E[x + 3] = m >> 0 & 255;
                },
                writeASCII: function(E, x, m) {
                  for (var I = 0; I < m.length; I++) E[x + I] = m.charCodeAt(I);
                },
                writeDouble: function(E, x, m) {
                  P._binBE.fl64[0] = m;
                  for (var I = 0; I < 8; I++) E[x + I] = P._binBE.ui8[7 - I];
                }
              }, P._binBE.ui8 = new Uint8Array(8), P._binBE.i16 = new Int16Array(P._binBE.ui8.buffer), P._binBE.i32 = new Int32Array(P._binBE.ui8.buffer), P._binBE.ui32 = new Uint32Array(P._binBE.ui8.buffer), P._binBE.fl32 = new Float32Array(P._binBE.ui8.buffer), P._binBE.fl64 = new Float64Array(P._binBE.ui8.buffer), P._binLE = {
                nextZero: P._binBE.nextZero,
                readUshort: function(E, x) {
                  return E[x + 1] << 8 | E[x];
                },
                readShort: function(E, x) {
                  var m = P._binBE.ui8;
                  return m[0] = E[x + 0], m[1] = E[x + 1], P._binBE.i16[0];
                },
                readInt: function(E, x) {
                  var m = P._binBE.ui8;
                  return m[0] = E[x + 0], m[1] = E[x + 1], m[2] = E[x + 2], m[3] = E[x + 3], P._binBE.i32[0];
                },
                readUint: function(E, x) {
                  var m = P._binBE.ui8;
                  return m[0] = E[x + 0], m[1] = E[x + 1], m[2] = E[x + 2], m[3] = E[x + 3], P._binBE.ui32[0];
                },
                readASCII: P._binBE.readASCII,
                readFloat: function(E, x) {
                  for (var m = P._binBE.ui8, I = 0; I < 4; I++) m[I] = E[x + I];
                  return P._binBE.fl32[0];
                },
                readDouble: function(E, x) {
                  for (var m = P._binBE.ui8, I = 0; I < 8; I++) m[I] = E[x + I];
                  return P._binBE.fl64[0];
                }
              }, P._copyTile = function(E, x, m, I, z, w, C, b) {
                for (var B = Math.min(x, z - C), N = Math.min(m, w - b), U = 0; U < N; U++)
                  for (var V = (b + U) * z + C, W = U * x, q = 0; q < B; q++) I[V + q] = E[W + q];
              };
            })(r, F);
          })();
        }).call(this, te("_process"));
      }, { _process: 133, pako: 86 }], 183: [function(te, Ee, $) {
        (function(Q) {
          Ee.exports = r;
          function r(H, P) {
            if (F("noDeprecation"))
              return H;
            var M = !1;
            function E() {
              if (!M) {
                if (F("throwDeprecation"))
                  throw new Error(P);
                F("traceDeprecation") ? console.trace(P) : console.warn(P), M = !0;
              }
              return H.apply(this, arguments);
            }
            return E;
          }
          function F(H) {
            try {
              if (!Q.localStorage) return !1;
            } catch {
              return !1;
            }
            var P = Q.localStorage[H];
            return P == null ? !1 : String(P).toLowerCase() === "true";
          }
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof pt < "u" ? pt : {});
      }, {}], 184: [function(te, Ee, $) {
        arguments[4][26][0].apply($, arguments);
      }, { dup: 26 }], 185: [function(te, Ee, $) {
        arguments[4][27][0].apply($, arguments);
      }, { dup: 27 }], 186: [function(te, Ee, $) {
        arguments[4][28][0].apply($, arguments);
      }, { "./support/isBuffer": 185, _process: 133, dup: 28, inherits: 184 }], 187: [function(te, Ee, $) {
        var Q = te("global/window"), r = te("is-function"), F = te("parse-headers"), H = te("xtend");
        Ee.exports = x, Ee.exports.default = x, x.XMLHttpRequest = Q.XMLHttpRequest || z, x.XDomainRequest = "withCredentials" in new x.XMLHttpRequest() ? x.XMLHttpRequest : Q.XDomainRequest, P(["get", "put", "post", "patch", "head", "delete"], function(w) {
          x[w === "delete" ? "del" : w] = function(C, b, B) {
            return b = E(C, b, B), b.method = w.toUpperCase(), m(b);
          };
        });
        function P(w, C) {
          for (var b = 0; b < w.length; b++)
            C(w[b]);
        }
        function M(w) {
          for (var C in w)
            if (w.hasOwnProperty(C)) return !1;
          return !0;
        }
        function E(w, C, b) {
          var B = w;
          return r(C) ? (b = C, typeof w == "string" && (B = { uri: w })) : B = H(C, { uri: w }), B.callback = b, B;
        }
        function x(w, C, b) {
          return C = E(w, C, b), m(C);
        }
        function m(w) {
          if (typeof w.callback > "u")
            throw new Error("callback argument missing");
          var C = !1, b = function(De, ze, Ze) {
            C || (C = !0, w.callback(De, ze, Ze));
          };
          function B() {
            W.readyState === 4 && setTimeout(V, 0);
          }
          function N() {
            var de = void 0;
            if (W.response ? de = W.response : de = W.responseText || I(W), Me)
              try {
                de = JSON.parse(de);
              } catch {
              }
            return de;
          }
          function U(de) {
            return clearTimeout(xe), de instanceof Error || (de = new Error("" + (de || "Unknown XMLHttpRequest Error"))), de.statusCode = 0, b(de, le);
          }
          function V() {
            if (!Y) {
              var de;
              clearTimeout(xe), w.useXDR && W.status === void 0 ? de = 200 : de = W.status === 1223 ? 204 : W.status;
              var De = le, ze = null;
              return de !== 0 ? (De = {
                body: N(),
                statusCode: de,
                method: se,
                headers: {},
                url: re,
                rawRequest: W
              }, W.getAllResponseHeaders && (De.headers = F(W.getAllResponseHeaders()))) : ze = new Error("Internal XMLHttpRequest Error"), b(ze, De, De.body);
            }
          }
          var W = w.xhr || null;
          W || (w.cors || w.useXDR ? W = new x.XDomainRequest() : W = new x.XMLHttpRequest());
          var q, Y, re = W.url = w.uri || w.url, se = W.method = w.method || "GET", ve = w.body || w.data, ce = W.headers = w.headers || {}, be = !!w.sync, Me = !1, xe, le = {
            body: void 0,
            headers: {},
            statusCode: 0,
            method: se,
            url: re,
            rawRequest: W
          };
          if ("json" in w && w.json !== !1 && (Me = !0, ce.accept || ce.Accept || (ce.Accept = "application/json"), se !== "GET" && se !== "HEAD" && (ce["content-type"] || ce["Content-Type"] || (ce["Content-Type"] = "application/json"), ve = JSON.stringify(w.json === !0 ? ve : w.json))), W.onreadystatechange = B, W.onload = V, W.onerror = U, W.onprogress = function() {
          }, W.onabort = function() {
            Y = !0;
          }, W.ontimeout = U, W.open(se, re, !be, w.username, w.password), be || (W.withCredentials = !!w.withCredentials), !be && w.timeout > 0 && (xe = setTimeout(function() {
            if (!Y) {
              Y = !0, W.abort("timeout");
              var de = new Error("XMLHttpRequest timeout");
              de.code = "ETIMEDOUT", U(de);
            }
          }, w.timeout)), W.setRequestHeader)
            for (q in ce)
              ce.hasOwnProperty(q) && W.setRequestHeader(q, ce[q]);
          else if (w.headers && !M(w.headers))
            throw new Error("Headers cannot be set on an XDomainRequest object");
          return "responseType" in w && (W.responseType = w.responseType), "beforeSend" in w && typeof w.beforeSend == "function" && w.beforeSend(W), W.send(ve || null), W;
        }
        function I(w) {
          try {
            if (w.responseType === "document")
              return w.responseXML;
            var C = w.responseXML && w.responseXML.documentElement.nodeName === "parsererror";
            if (w.responseType === "" && !C)
              return w.responseXML;
          } catch {
          }
          return null;
        }
        function z() {
        }
      }, { "global/window": 71, "is-function": 78, "parse-headers": 106, xtend: 189 }], 188: [function(te, Ee, $) {
        Ee.exports = function() {
          return typeof self.DOMParser < "u" ? function(r) {
            var F = new self.DOMParser();
            return F.parseFromString(r, "application/xml");
          } : typeof self.ActiveXObject < "u" && new self.ActiveXObject("Microsoft.XMLDOM") ? function(r) {
            var F = new self.ActiveXObject("Microsoft.XMLDOM");
            return F.async = "false", F.loadXML(r), F;
          } : function(r) {
            var F = document.createElement("div");
            return F.innerHTML = r, F;
          };
        }();
      }, {}], 189: [function(te, Ee, $) {
        Ee.exports = r;
        var Q = Object.prototype.hasOwnProperty;
        function r() {
          for (var F = {}, H = 0; H < arguments.length; H++) {
            var P = arguments[H];
            for (var M in P)
              Q.call(P, M) && (F[M] = P[M]);
          }
          return F;
        }
      }, {}], 190: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.srcOver = Q, $.dstOver = r, $.multiply = F, $.add = H, $.screen = P, $.overlay = M, $.darken = E, $.lighten = x, $.hardLight = m, $.difference = I, $.exclusion = z;
        function Q(w, C) {
          var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          w.a *= b;
          var B = C.a + w.a - C.a * w.a, N = (w.r * w.a + C.r * C.a * (1 - w.a)) / B, U = (w.g * w.a + C.g * C.a * (1 - w.a)) / B, V = (w.b * w.a + C.b * C.a * (1 - w.a)) / B;
          return {
            r: N,
            g: U,
            b: V,
            a: B
          };
        }
        function r(w, C) {
          var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          w.a *= b;
          var B = C.a + w.a - C.a * w.a, N = (C.r * C.a + w.r * w.a * (1 - C.a)) / B, U = (C.g * C.a + w.g * w.a * (1 - C.a)) / B, V = (C.b * C.a + w.b * w.a * (1 - C.a)) / B;
          return {
            r: N,
            g: U,
            b: V,
            a: B
          };
        }
        function F(w, C) {
          var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          w.a *= b;
          var B = C.a + w.a - C.a * w.a, N = w.r * w.a, U = w.g * w.a, V = w.b * w.a, W = C.r * C.a, q = C.g * C.a, Y = C.b * C.a, re = (N * W + N * (1 - C.a) + W * (1 - w.a)) / B, se = (U * q + U * (1 - C.a) + q * (1 - w.a)) / B, ve = (V * Y + V * (1 - C.a) + Y * (1 - w.a)) / B;
          return {
            r: re,
            g: se,
            b: ve,
            a: B
          };
        }
        function H(w, C) {
          var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          w.a *= b;
          var B = C.a + w.a - C.a * w.a, N = w.r * w.a, U = w.g * w.a, V = w.b * w.a, W = C.r * C.a, q = C.g * C.a, Y = C.b * C.a, re = (N + W) / B, se = (U + q) / B, ve = (V + Y) / B;
          return {
            r: re,
            g: se,
            b: ve,
            a: B
          };
        }
        function P(w, C) {
          var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          w.a *= b;
          var B = C.a + w.a - C.a * w.a, N = w.r * w.a, U = w.g * w.a, V = w.b * w.a, W = C.r * C.a, q = C.g * C.a, Y = C.b * C.a, re = (N * C.a + W * w.a - N * W + N * (1 - C.a) + W * (1 - w.a)) / B, se = (U * C.a + q * w.a - U * q + U * (1 - C.a) + q * (1 - w.a)) / B, ve = (V * C.a + Y * w.a - V * Y + V * (1 - C.a) + Y * (1 - w.a)) / B;
          return {
            r: re,
            g: se,
            b: ve,
            a: B
          };
        }
        function M(w, C) {
          var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          w.a *= b;
          var B = C.a + w.a - C.a * w.a, N = w.r * w.a, U = w.g * w.a, V = w.b * w.a, W = C.r * C.a, q = C.g * C.a, Y = C.b * C.a, re = (2 * W <= C.a ? 2 * N * W + N * (1 - C.a) + W * (1 - w.a) : N * (1 + C.a) + W * (1 + w.a) - 2 * W * N - C.a * w.a) / B, se = (2 * q <= C.a ? 2 * U * q + U * (1 - C.a) + q * (1 - w.a) : U * (1 + C.a) + q * (1 + w.a) - 2 * q * U - C.a * w.a) / B, ve = (2 * Y <= C.a ? 2 * V * Y + V * (1 - C.a) + Y * (1 - w.a) : V * (1 + C.a) + Y * (1 + w.a) - 2 * Y * V - C.a * w.a) / B;
          return {
            r: re,
            g: se,
            b: ve,
            a: B
          };
        }
        function E(w, C) {
          var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          w.a *= b;
          var B = C.a + w.a - C.a * w.a, N = w.r * w.a, U = w.g * w.a, V = w.b * w.a, W = C.r * C.a, q = C.g * C.a, Y = C.b * C.a, re = (Math.min(N * C.a, W * w.a) + N * (1 - C.a) + W * (1 - w.a)) / B, se = (Math.min(U * C.a, q * w.a) + U * (1 - C.a) + q * (1 - w.a)) / B, ve = (Math.min(V * C.a, Y * w.a) + V * (1 - C.a) + Y * (1 - w.a)) / B;
          return {
            r: re,
            g: se,
            b: ve,
            a: B
          };
        }
        function x(w, C) {
          var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          w.a *= b;
          var B = C.a + w.a - C.a * w.a, N = w.r * w.a, U = w.g * w.a, V = w.b * w.a, W = C.r * C.a, q = C.g * C.a, Y = C.b * C.a, re = (Math.max(N * C.a, W * w.a) + N * (1 - C.a) + W * (1 - w.a)) / B, se = (Math.max(U * C.a, q * w.a) + U * (1 - C.a) + q * (1 - w.a)) / B, ve = (Math.max(V * C.a, Y * w.a) + V * (1 - C.a) + Y * (1 - w.a)) / B;
          return {
            r: re,
            g: se,
            b: ve,
            a: B
          };
        }
        function m(w, C) {
          var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          w.a *= b;
          var B = C.a + w.a - C.a * w.a, N = w.r * w.a, U = w.g * w.a, V = w.b * w.a, W = C.r * C.a, q = C.g * C.a, Y = C.b * C.a, re = (2 * N <= w.a ? 2 * N * W + N * (1 - C.a) + W * (1 - w.a) : N * (1 + C.a) + W * (1 + w.a) - 2 * W * N - C.a * w.a) / B, se = (2 * U <= w.a ? 2 * U * q + U * (1 - C.a) + q * (1 - w.a) : U * (1 + C.a) + q * (1 + w.a) - 2 * q * U - C.a * w.a) / B, ve = (2 * V <= w.a ? 2 * V * Y + V * (1 - C.a) + Y * (1 - w.a) : V * (1 + C.a) + Y * (1 + w.a) - 2 * Y * V - C.a * w.a) / B;
          return {
            r: re,
            g: se,
            b: ve,
            a: B
          };
        }
        function I(w, C) {
          var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          w.a *= b;
          var B = C.a + w.a - C.a * w.a, N = w.r * w.a, U = w.g * w.a, V = w.b * w.a, W = C.r * C.a, q = C.g * C.a, Y = C.b * C.a, re = (N + W - 2 * Math.min(N * C.a, W * w.a)) / B, se = (U + q - 2 * Math.min(U * C.a, q * w.a)) / B, ve = (V + Y - 2 * Math.min(V * C.a, Y * w.a)) / B;
          return {
            r: re,
            g: se,
            b: ve,
            a: B
          };
        }
        function z(w, C) {
          var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          w.a *= b;
          var B = C.a + w.a - C.a * w.a, N = w.r * w.a, U = w.g * w.a, V = w.b * w.a, W = C.r * C.a, q = C.g * C.a, Y = C.b * C.a, re = (N * C.a + W * w.a - 2 * N * W + N * (1 - C.a) + W * (1 - w.a)) / B, se = (U * C.a + q * w.a - 2 * U * q + U * (1 - C.a) + q * (1 - w.a)) / B, ve = (V * C.a + Y * w.a - 2 * V * Y + V * (1 - C.a) + Y * (1 - w.a)) / B;
          return {
            r: re,
            g: se,
            b: ve,
            a: B
          };
        }
      }, {}], 191: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireWildcard");
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = P;
        var r = te("@jimp/utils"), F = Q(te("../constants")), H = Q(te("./composite-modes"));
        function P(M, E, x) {
          var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, I = arguments.length > 4 ? arguments[4] : void 0;
          if (typeof m == "function" && (I = m, m = {}), !(M instanceof this.constructor))
            return r.throwError.call(this, "The source must be a Jimp image", I);
          if (typeof E != "number" || typeof x != "number")
            return r.throwError.call(this, "x and y must be numbers", I);
          var z = m, w = z.mode, C = z.opacitySource, b = z.opacityDest;
          w || (w = F.BLEND_SOURCE_OVER), (typeof C != "number" || C < 0 || C > 1) && (C = 1), (typeof b != "number" || b < 0 || b > 1) && (b = 1);
          var B = H[w];
          E = Math.round(E), x = Math.round(x);
          var N = this;
          return b !== 1 && N.opacity(b), M.scanQuiet(0, 0, M.bitmap.width, M.bitmap.height, function(U, V, W) {
            var q = N.getPixelIndex(E + U, x + V, F.EDGE_CROP), Y = B({
              r: this.bitmap.data[W + 0] / 255,
              g: this.bitmap.data[W + 1] / 255,
              b: this.bitmap.data[W + 2] / 255,
              a: this.bitmap.data[W + 3] / 255
            }, {
              r: N.bitmap.data[q + 0] / 255,
              g: N.bitmap.data[q + 1] / 255,
              b: N.bitmap.data[q + 2] / 255,
              a: N.bitmap.data[q + 3] / 255
            }, C);
            N.bitmap.data[q + 0] = this.constructor.limit255(Y.r * 255), N.bitmap.data[q + 1] = this.constructor.limit255(Y.g * 255), N.bitmap.data[q + 2] = this.constructor.limit255(Y.b * 255), N.bitmap.data[q + 3] = this.constructor.limit255(Y.a * 255);
          }), (0, r.isNodePattern)(I) && I.call(this, null, this), this;
        }
        Ee.exports = $.default;
      }, { "../constants": 192, "./composite-modes": 190, "@babel/runtime/helpers/interopRequireWildcard": 12, "@jimp/utils": 235 }], 192: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.EDGE_CROP = $.EDGE_WRAP = $.EDGE_EXTEND = $.BLEND_EXCLUSION = $.BLEND_DIFFERENCE = $.BLEND_HARDLIGHT = $.BLEND_LIGHTEN = $.BLEND_DARKEN = $.BLEND_OVERLAY = $.BLEND_SCREEN = $.BLEND_ADD = $.BLEND_MULTIPLY = $.BLEND_DESTINATION_OVER = $.BLEND_SOURCE_OVER = $.VERTICAL_ALIGN_BOTTOM = $.VERTICAL_ALIGN_MIDDLE = $.VERTICAL_ALIGN_TOP = $.HORIZONTAL_ALIGN_RIGHT = $.HORIZONTAL_ALIGN_CENTER = $.HORIZONTAL_ALIGN_LEFT = $.AUTO = void 0;
        var Q = -1;
        $.AUTO = Q;
        var r = 1;
        $.HORIZONTAL_ALIGN_LEFT = r;
        var F = 2;
        $.HORIZONTAL_ALIGN_CENTER = F;
        var H = 4;
        $.HORIZONTAL_ALIGN_RIGHT = H;
        var P = 8;
        $.VERTICAL_ALIGN_TOP = P;
        var M = 16;
        $.VERTICAL_ALIGN_MIDDLE = M;
        var E = 32;
        $.VERTICAL_ALIGN_BOTTOM = E;
        var x = "srcOver";
        $.BLEND_SOURCE_OVER = x;
        var m = "dstOver";
        $.BLEND_DESTINATION_OVER = m;
        var I = "multiply";
        $.BLEND_MULTIPLY = I;
        var z = "add";
        $.BLEND_ADD = z;
        var w = "screen";
        $.BLEND_SCREEN = w;
        var C = "overlay";
        $.BLEND_OVERLAY = C;
        var b = "darken";
        $.BLEND_DARKEN = b;
        var B = "lighten";
        $.BLEND_LIGHTEN = B;
        var N = "hardLight";
        $.BLEND_HARDLIGHT = N;
        var U = "difference";
        $.BLEND_DIFFERENCE = U;
        var V = "exclusion";
        $.BLEND_EXCLUSION = V;
        var W = 1;
        $.EDGE_EXTEND = W;
        var q = 2;
        $.EDGE_WRAP = q;
        var Y = 3;
        $.EDGE_CROP = Y;
      }, {}], 193: [function(te, Ee, $) {
        (function(Q) {
          var r = te("@babel/runtime/helpers/interopRequireWildcard"), F = te("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty($, "__esModule", {
            value: !0
          }), $.addConstants = Ct, $.addJimpMethods = Xt, $.jimpEvMethod = vt, $.jimpEvChange = Ye, Object.defineProperty($, "addType", {
            enumerable: !0,
            get: function() {
              return be.addType;
            }
          }), $.default = void 0;
          for (var H = F(te("@babel/runtime/helpers/construct")), P = F(te("@babel/runtime/helpers/slicedToArray")), M = F(te("@babel/runtime/helpers/classCallCheck")), E = F(te("@babel/runtime/helpers/createClass")), x = F(te("@babel/runtime/helpers/possibleConstructorReturn")), m = F(te("@babel/runtime/helpers/getPrototypeOf")), I = F(te("@babel/runtime/helpers/assertThisInitialized")), z = F(te("@babel/runtime/helpers/inherits")), w = F(te("@babel/runtime/helpers/defineProperty")), C = F(te("@babel/runtime/helpers/typeof")), b = F(te("fs")), B = F(te("path")), N = F(te("events")), U = te("@jimp/utils"), V = F(te("any-base")), W = F(te("mkdirp")), q = F(te("pixelmatch")), Y = F(te("tinycolor2")), re = F(te("./modules/phash")), se = F(te("./request")), ve = F(te("./composite")), ce = F(te("./utils/promisify")), be = r(te("./utils/mime")), Me = te("./utils/image-bitmap"), xe = r(te("./constants")), le = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", de = [NaN, NaN], De = 2; De < 65; De++) {
            var ze = (0, V.default)(V.default.BIN, le.slice(0, De))(new Array(65).join("1"));
            de.push(ze.length);
          }
          function Ze() {
          }
          function Ue(it) {
            return Object.prototype.toString.call(it).toLowerCase().indexOf("arraybuffer") > -1;
          }
          function Ie(it) {
            for (var Ae = Q.alloc(it.byteLength), _e = new Uint8Array(it), fe = 0; fe < Ae.length; ++fe)
              Ae[fe] = _e[fe];
            return Ae;
          }
          function je(it, Ae) {
            (0, se.default)(it, function(_e, fe, We) {
              if (_e)
                return Ae(_e);
              if ("headers" in fe && "location" in fe.headers)
                return it.url = fe.headers.location, je(it, Ae);
              if ((0, C.default)(We) === "object" && Q.isBuffer(We))
                return Ae(null, We);
              var Pe = "Could not load Buffer from <" + it.url + "> (HTTP: " + fe.statusCode + ")";
              return new Error(Pe);
            });
          }
          function Fe(it, Ae) {
            b.default && typeof b.default.readFile == "function" && !it.match(/^(http|ftp)s?:\/\/./) ? b.default.readFile(it, Ae) : je({
              url: it
            }, Ae);
          }
          function $e(it) {
            return it && (0, C.default)(it) === "object" && typeof it.width == "number" && typeof it.height == "number" && (Q.isBuffer(it.data) || it.data instanceof Uint8Array || typeof Uint8ClampedArray == "function" && it.data instanceof Uint8ClampedArray) && (it.data.length === it.width * it.height * 4 || it.data.length === it.width * it.height * 3);
          }
          function ct(it) {
            if (it.length % 3 !== 0)
              throw new Error("Buffer length is incorrect");
            for (var Ae = Q.allocUnsafe(it.length / 3 * 4), _e = 0, fe = 0; fe < it.length; fe++)
              Ae[_e] = it[fe], (fe + 1) % 3 === 0 && (Ae[++_e] = 255), _e++;
            return Ae;
          }
          var wt = {
            data: null,
            width: null,
            height: null
          }, Oe = /* @__PURE__ */ function(it) {
            (0, z.default)(Ae, it);
            function Ae() {
              for (var _e, fe = arguments.length, We = new Array(fe), Pe = 0; Pe < fe; Pe++)
                We[Pe] = arguments[Pe];
              (0, M.default)(this, Ae), _e = (0, x.default)(this, (0, m.default)(Ae).call(this)), (0, w.default)((0, I.default)(_e), "bitmap", wt), (0, w.default)((0, I.default)(_e), "_background", 0), (0, w.default)((0, I.default)(_e), "_originalMime", Ae.MIME_PNG), (0, w.default)((0, I.default)(_e), "_exif", null), (0, w.default)((0, I.default)(_e), "_rgba", !0), (0, w.default)((0, I.default)(_e), "writeAsync", function(Vr) {
                return (0, ce.default)(_e.write, (0, I.default)(_e), Vr);
              }), (0, w.default)((0, I.default)(_e), "getBase64Async", function(Vr) {
                return (0, ce.default)(_e.getBase64, (0, I.default)(_e), Vr);
              }), (0, w.default)((0, I.default)(_e), "getBuffer", Me.getBuffer), (0, w.default)((0, I.default)(_e), "getBufferAsync", Me.getBufferAsync), (0, w.default)((0, I.default)(_e), "getPixelColour", _e.getPixelColor), (0, w.default)((0, I.default)(_e), "setPixelColour", _e.setPixelColor);
              var he = (0, I.default)(_e), ie = Ze;
              Ue(We[0]) && (We[0] = Ie(We[0]));
              function Xe() {
                for (var Vr = arguments.length, Te = new Array(Vr), Tt = 0; Tt < Vr; Tt++)
                  Te[Tt] = arguments[Tt];
                var Gt = Te[0], pr = Gt || {};
                pr.methodName = "constructor", setTimeout(function() {
                  var kt;
                  Gt && ie === Ze ? he.emitError("constructor", Gt) : Gt || he.emitMulti("constructor", "initialized"), (kt = ie).call.apply(kt, [he].concat(Te));
                }, 1);
              }
              if (typeof We[0] == "number" && typeof We[1] == "number" || parseInt(We[0], 10) && parseInt(We[1], 10)) {
                var bt = parseInt(We[0], 10), Wt = parseInt(We[1], 10);
                if (ie = We[2], typeof We[2] == "number" && (_e._background = We[2], ie = We[3]), typeof We[2] == "string" && (_e._background = Ae.cssColorToHex(We[2]), ie = We[3]), typeof ie > "u" && (ie = Ze), typeof ie != "function")
                  return (0, x.default)(_e, U.throwError.call((0, I.default)(_e), "cb must be a function", Xe));
                _e.bitmap = {
                  data: Q.alloc(bt * Wt * 4),
                  width: bt,
                  height: Wt
                };
                for (var Qt = 0; Qt < _e.bitmap.data.length; Qt += 4)
                  _e.bitmap.data.writeUInt32BE(_e._background, Qt);
                Xe(null, (0, I.default)(_e));
              } else if ((0, C.default)(We[0]) === "object" && We[0].url) {
                if (ie = We[1] || Ze, typeof ie != "function")
                  return (0, x.default)(_e, U.throwError.call((0, I.default)(_e), "cb must be a function", Xe));
                je(We[0], function(Vr, Te) {
                  if (Vr)
                    return U.throwError.call((0, I.default)(_e), Vr, Xe);
                  _e.parseBitmap(Te, We[0].url, Xe);
                });
              } else if (We[0] instanceof Ae) {
                var Sr = We[0];
                if (ie = We[1], typeof ie > "u" && (ie = Ze), typeof ie != "function")
                  return (0, x.default)(_e, U.throwError.call((0, I.default)(_e), "cb must be a function", Xe));
                _e.bitmap = {
                  data: Q.from(Sr.bitmap.data),
                  width: Sr.bitmap.width,
                  height: Sr.bitmap.height
                }, _e._quality = Sr._quality, _e._deflateLevel = Sr._deflateLevel, _e._deflateStrategy = Sr._deflateStrategy, _e._filterType = Sr._filterType, _e._rgba = Sr._rgba, _e._background = Sr._background, _e._originalMime = Sr._originalMime, Xe(null, (0, I.default)(_e));
              } else if ($e(We[0])) {
                var Fr = We[0];
                ie = We[1] || Ze;
                var kr = Fr.width * Fr.height * 4 === Fr.data.length, Ur = kr ? Q.from(Fr.data) : ct(Fr.data);
                _e.bitmap = {
                  data: Ur,
                  width: Fr.width,
                  height: Fr.height
                }, Xe(null, (0, I.default)(_e));
              } else if (typeof We[0] == "string") {
                var Rr = We[0];
                if (ie = We[1], typeof ie > "u" && (ie = Ze), typeof ie != "function")
                  return (0, x.default)(_e, U.throwError.call((0, I.default)(_e), "cb must be a function", Xe));
                Fe(Rr, function(Vr, Te) {
                  if (Vr)
                    return U.throwError.call((0, I.default)(_e), Vr, Xe);
                  _e.parseBitmap(Te, Rr, Xe);
                });
              } else if ((0, C.default)(We[0]) === "object" && Q.isBuffer(We[0])) {
                var Pr = We[0];
                if (ie = We[1], typeof ie != "function")
                  return (0, x.default)(_e, U.throwError.call((0, I.default)(_e), "cb must be a function", Xe));
                _e.parseBitmap(Pr, null, Xe);
              } else {
                ie = We[We.length - 1], typeof ie != "function" && (ie = We[We.length - 2], typeof ie != "function" && (ie = Ze));
                var hi = Ae.__extraConstructors.find(function(Vr) {
                  return Vr.test.apply(Vr, We);
                });
                if (hi)
                  new Promise(function(Vr, Te) {
                    var Tt;
                    return (Tt = hi.run).call.apply(Tt, [(0, I.default)(_e), Vr, Te].concat(We));
                  }).then(function() {
                    return Xe(null, (0, I.default)(_e));
                  }).catch(Xe);
                else
                  return (0, x.default)(_e, U.throwError.call((0, I.default)(_e), "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", Xe));
              }
              return _e;
            }
            return (0, E.default)(Ae, [{
              key: "parseBitmap",
              value: function(fe, We, Pe) {
                Me.parseBitmap.call(this, fe, null, Pe);
              }
              /**
               * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)
               * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "rgba",
              value: function(fe, We) {
                return typeof fe != "boolean" ? U.throwError.call(this, "bool must be a boolean, true for RGBA or false for RGB", We) : (this._rgba = fe, (0, U.isNodePattern)(We) && We.call(this, null, this), this);
              }
              /**
               * Emit for multiple listeners
               * @param {string} methodName name of the method to emit an error for
               * @param {string} eventName name of the eventName to emit an error for
               * @param {object} data to emit
               */
            }, {
              key: "emitMulti",
              value: function(fe, We) {
                var Pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                Pe = Object.assign(Pe, {
                  methodName: fe,
                  eventName: We
                }), this.emit("any", Pe), fe && this.emit(fe, Pe), this.emit(We, Pe);
              }
            }, {
              key: "emitError",
              value: function(fe, We) {
                this.emitMulti(fe, "error", We);
              }
              /**
               * Get the current height of the image
               * @return {number} height of the image
               */
            }, {
              key: "getHeight",
              value: function() {
                return this.bitmap.height;
              }
              /**
               * Get the current width of the image
               * @return {number} width of the image
               */
            }, {
              key: "getWidth",
              value: function() {
                return this.bitmap.width;
              }
              /**
               * Nicely format Jimp object when sent to the console e.g. console.log(image)
               * @returns {string} pretty printed
               */
            }, {
              key: "inspect",
              value: function() {
                return "<Jimp " + (this.bitmap === wt ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
              }
              /**
               * Nicely format Jimp object when converted to a string
               * @returns {string} pretty printed
               */
            }, {
              key: "toString",
              value: function() {
                return "[object Jimp]";
              }
              /**
               * Returns the original MIME of the image (default: "image/png")
               * @returns {string} the MIME
               */
            }, {
              key: "getMIME",
              value: function() {
                var fe = this._originalMime || Ae.MIME_PNG;
                return fe;
              }
              /**
               * Returns the appropriate file extension for the original MIME of the image (default: "png")
               * @returns {string} the file extension
               */
            }, {
              key: "getExtension",
              value: function() {
                var fe = this.getMIME();
                return be.getExtension(fe);
              }
              /**
               * Writes the image to a file
               * @param {string} path a path to the destination file
               * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "write",
              value: function(fe, We) {
                var Pe = this;
                if (!b.default || !b.default.createWriteStream)
                  throw new Error("Cant access the filesystem. You can use the getBase64 method.");
                if (typeof fe != "string")
                  return U.throwError.call(this, "path must be a string", We);
                if (typeof We > "u" && (We = Ze), typeof We != "function")
                  return U.throwError.call(this, "cb must be a function", We);
                var he = be.getType(fe) || this.getMIME(), ie = B.default.parse(fe);
                return ie.dir && W.default.sync(ie.dir), this.getBuffer(he, function(Xe, bt) {
                  if (Xe)
                    return U.throwError.call(Pe, Xe, We);
                  var Wt = b.default.createWriteStream(fe);
                  Wt.on("open", function() {
                    Wt.write(bt), Wt.end();
                  }).on("error", function(Qt) {
                    return U.throwError.call(Pe, Qt, We);
                  }), Wt.on("finish", function() {
                    We.call(Pe, null, Pe);
                  });
                }), this;
              }
            }, {
              key: "getBase64",
              /**
               * Converts the image to a base 64 string
               * @param {string} mime the mime type of the image data to be created
               * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
               * @returns {Jimp} this for chaining of methods
               */
              value: function(fe, We) {
                return fe === Ae.AUTO && (fe = this.getMIME()), typeof fe != "string" ? U.throwError.call(this, "mime must be a string", We) : typeof We != "function" ? U.throwError.call(this, "cb must be a function", We) : (this.getBuffer(fe, function(Pe, he) {
                  if (Pe)
                    return U.throwError.call(this, Pe, We);
                  var ie = "data:" + fe + ";base64," + he.toString("base64");
                  We.call(this, null, ie);
                }), this);
              }
            }, {
              key: "hash",
              /**
               * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.
               * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {string} a string representing the hash
               */
              value: function(fe, We) {
                if (fe = fe || 64, typeof fe == "function" && (We = fe, fe = 64), typeof fe != "number")
                  return U.throwError.call(this, "base must be a number", We);
                if (fe < 2 || fe > 64)
                  return U.throwError.call(this, "base must be a number between 2 and 64", We);
                var Pe = this.pHash();
                for (Pe = (0, V.default)(V.default.BIN, le.slice(0, fe))(Pe); Pe.length < de[fe]; )
                  Pe = "0" + Pe;
                return (0, U.isNodePattern)(We) && We.call(this, null, Pe), Pe;
              }
              /**
               * Calculates the perceptual hash
               * @returns {number} the perceptual hash
               */
            }, {
              key: "pHash",
              value: function() {
                var fe = new re.default();
                return fe.getHash(this);
              }
              /**
               * Calculates the hamming distance of the current image and a hash based on their perceptual hash
               * @param {hash} compareHash hash to compare to
               * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
               */
            }, {
              key: "distanceFromHash",
              value: function(fe) {
                var We = new re.default(), Pe = We.getHash(this);
                return We.distance(Pe, fe);
              }
              /**
               * Converts the image to a buffer
               * @param {string} mime the mime type of the image buffer to be created
               * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "getPixelIndex",
              /**
               * Returns the offset of a pixel in the bitmap buffer
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
               * @param {number} cb (optional) a callback for when complete
               * @returns {number} the index of the pixel or -1 if not found
               */
              value: function(fe, We, Pe, he) {
                var ie, Xe;
                if (typeof Pe == "function" && typeof he > "u" && (he = Pe, Pe = null), Pe || (Pe = Ae.EDGE_EXTEND), typeof fe != "number" || typeof We != "number")
                  return U.throwError.call(this, "x and y must be numbers", he);
                fe = Math.round(fe), We = Math.round(We), ie = fe, Xe = We, Pe === Ae.EDGE_EXTEND && (fe < 0 && (ie = 0), fe >= this.bitmap.width && (ie = this.bitmap.width - 1), We < 0 && (Xe = 0), We >= this.bitmap.height && (Xe = this.bitmap.height - 1)), Pe === Ae.EDGE_WRAP && (fe < 0 && (ie = this.bitmap.width + fe), fe >= this.bitmap.width && (ie = fe % this.bitmap.width), We < 0 && (ie = this.bitmap.height + We), We >= this.bitmap.height && (Xe = We % this.bitmap.height));
                var bt = this.bitmap.width * Xe + ie << 2;
                return (ie < 0 || ie >= this.bitmap.width) && (bt = -1), (Xe < 0 || Xe >= this.bitmap.height) && (bt = -1), (0, U.isNodePattern)(he) && he.call(this, null, bt), bt;
              }
              /**
               * Returns the hex colour value of a pixel
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {number} the color of the pixel
               */
            }, {
              key: "getPixelColor",
              value: function(fe, We, Pe) {
                if (typeof fe != "number" || typeof We != "number") return U.throwError.call(this, "x and y must be numbers", Pe);
                fe = Math.round(fe), We = Math.round(We);
                var he = this.getPixelIndex(fe, We), ie = this.bitmap.data.readUInt32BE(he);
                return (0, U.isNodePattern)(Pe) && Pe.call(this, null, ie), ie;
              }
            }, {
              key: "setPixelColor",
              /**
               * Returns the hex colour value of a pixel
               * @param {number} hex color to set
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {number} the index of the pixel or -1 if not found
               */
              value: function(fe, We, Pe, he) {
                if (typeof fe != "number" || typeof We != "number" || typeof Pe != "number") return U.throwError.call(this, "hex, x and y must be numbers", he);
                We = Math.round(We), Pe = Math.round(Pe);
                var ie = this.getPixelIndex(We, Pe);
                return this.bitmap.data.writeUInt32BE(fe, ie), (0, U.isNodePattern)(he) && he.call(this, null, this), this;
              }
            }, {
              key: "hasAlpha",
              /**
               * Determine if the image contains opaque pixels.
               * @return {boolean} hasAlpha whether the image contains opaque pixels
               */
              value: function() {
                for (var fe = 0; fe < this.bitmap.height; fe++)
                  for (var We = 0; We < this.bitmap.width; We++) {
                    var Pe = this.bitmap.width * fe + We << 2, he = this.bitmap.data[Pe + 3];
                    if (he !== 255)
                      return !0;
                  }
                return !1;
              }
              /**
               * Iterate scan through a region of the bitmap
               * @param {number} x the x coordinate to begin the scan at
               * @param {number} y the y coordinate to begin the scan at
               * @param w the width of the scan region
               * @param h the height of the scan region
               * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}
               */
            }, {
              key: "scanIterator",
              value: function(fe, We, Pe, he) {
                return typeof fe != "number" || typeof We != "number" ? U.throwError.call(this, "x and y must be numbers") : typeof Pe != "number" || typeof he != "number" ? U.throwError.call(this, "w and h must be numbers") : (0, U.scanIterator)(this, fe, We, Pe, he);
              }
            }]), Ae;
          }(N.default);
          function Ct(it) {
            var Ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Oe;
            Object.entries(it).forEach(function(_e) {
              var fe = (0, P.default)(_e, 2), We = fe[0], Pe = fe[1];
              Ae[We] = Pe;
            });
          }
          function Xt(it) {
            var Ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Oe;
            Object.entries(it).forEach(function(_e) {
              var fe = (0, P.default)(_e, 2), We = fe[0], Pe = fe[1];
              Ae.prototype[We] = Pe;
            });
          }
          Ct(xe), Xt({
            composite: ve.default
          }), Oe.__extraConstructors = [], Oe.appendConstructorOption = function(it, Ae, _e) {
            Oe.__extraConstructors.push({
              name: it,
              test: Ae,
              run: _e
            });
          }, Oe.read = function() {
            for (var it = arguments.length, Ae = new Array(it), _e = 0; _e < it; _e++)
              Ae[_e] = arguments[_e];
            return new Promise(function(fe, We) {
              (0, H.default)(Oe, Ae.concat([function(Pe, he) {
                Pe ? We(Pe) : fe(he);
              }]));
            });
          }, Oe.create = Oe.read, Oe.rgbaToInt = function(it, Ae, _e, fe, We) {
            if (typeof it != "number" || typeof Ae != "number" || typeof _e != "number" || typeof fe != "number")
              return U.throwError.call(this, "r, g, b and a must be numbers", We);
            if (it < 0 || it > 255)
              return U.throwError.call(this, "r must be between 0 and 255", We);
            if ((Ae < 0 || Ae > 255) && U.throwError.call(this, "g must be between 0 and 255", We), _e < 0 || _e > 255)
              return U.throwError.call(this, "b must be between 0 and 255", We);
            if (fe < 0 || fe > 255)
              return U.throwError.call(this, "a must be between 0 and 255", We);
            it = Math.round(it), _e = Math.round(_e), Ae = Math.round(Ae), fe = Math.round(fe);
            var Pe = it * Math.pow(256, 3) + Ae * Math.pow(256, 2) + _e * Math.pow(256, 1) + fe * Math.pow(256, 0);
            return (0, U.isNodePattern)(We) && We.call(this, null, Pe), Pe;
          }, Oe.intToRGBA = function(it, Ae) {
            if (typeof it != "number")
              return U.throwError.call(this, "i must be a number", Ae);
            var _e = {};
            return _e.r = Math.floor(it / Math.pow(256, 3)), _e.g = Math.floor((it - _e.r * Math.pow(256, 3)) / Math.pow(256, 2)), _e.b = Math.floor((it - _e.r * Math.pow(256, 3) - _e.g * Math.pow(256, 2)) / Math.pow(256, 1)), _e.a = Math.floor((it - _e.r * Math.pow(256, 3) - _e.g * Math.pow(256, 2) - _e.b * Math.pow(256, 1)) / Math.pow(256, 0)), (0, U.isNodePattern)(Ae) && Ae.call(this, null, _e), _e;
          }, Oe.cssColorToHex = function(it) {
            return it = it || 0, typeof it == "number" ? Number(it) : parseInt((0, Y.default)(it).toHex8(), 16);
          }, Oe.limit255 = function(it) {
            return it = Math.max(it, 0), it = Math.min(it, 255), it;
          }, Oe.diff = function(it, Ae) {
            var _e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.1;
            if (!(it instanceof Oe) || !(Ae instanceof Oe)) return U.throwError.call(this, "img1 and img2 must be an Jimp images");
            var fe = it.bitmap, We = Ae.bitmap;
            if ((fe.width !== We.width || fe.height !== We.height) && (fe.width * fe.height > We.width * We.height ? it = it.cloneQuiet().resize(We.width, We.height) : Ae = Ae.cloneQuiet().resize(fe.width, fe.height)), typeof _e != "number" || _e < 0 || _e > 1)
              return U.throwError.call(this, "threshold must be a number between 0 and 1");
            var Pe = new Oe(fe.width, fe.height, 4294967295), he = (0, q.default)(fe.data, We.data, Pe.bitmap.data, Pe.bitmap.width, Pe.bitmap.height, {
              threshold: _e
            });
            return {
              percent: he / (Pe.bitmap.width * Pe.bitmap.height),
              image: Pe
            };
          }, Oe.distance = function(it, Ae) {
            var _e = new re.default(), fe = _e.getHash(it), We = _e.getHash(Ae);
            return _e.distance(fe, We);
          }, Oe.compareHashes = function(it, Ae) {
            var _e = new re.default();
            return _e.distance(it, Ae);
          }, Oe.colorDiff = function(it, Ae) {
            var _e = function(he) {
              return Math.pow(he, 2);
            }, fe = Math.max, We = 255 * 255 * 3;
            return it.a !== 0 && !it.a && (it.a = 255), Ae.a !== 0 && !Ae.a && (Ae.a = 255), (fe(_e(it.r - Ae.r), _e(it.r - Ae.r - it.a + Ae.a)) + fe(_e(it.g - Ae.g), _e(it.g - Ae.g - it.a + Ae.a)) + fe(_e(it.b - Ae.b), _e(it.b - Ae.b - it.a + Ae.a))) / We;
          };
          function vt(it, Ae, _e) {
            var fe = "before-" + Ae, We = Ae.replace(/e$/, "") + "ed";
            Oe.prototype[it] = function() {
              for (var Pe, he = arguments.length, ie = new Array(he), Xe = 0; Xe < he; Xe++)
                ie[Xe] = arguments[Xe];
              var bt = ie[_e.length - 1], Wt = this;
              typeof bt == "function" ? (Pe = function() {
                for (var Fr = arguments.length, kr = new Array(Fr), Ur = 0; Ur < Fr; Ur++)
                  kr[Ur] = arguments[Ur];
                var Rr = kr[0], Pr = kr[1];
                Rr ? Wt.emitError(it, Rr) : Wt.emitMulti(it, We, (0, w.default)({}, it, Pr)), bt.apply(this, kr);
              }, ie[ie.length - 1] = Pe) : Pe = !1, this.emitMulti(it, fe);
              var Qt;
              try {
                Qt = _e.apply(this, ie), Pe || this.emitMulti(it, We, (0, w.default)({}, it, Qt));
              } catch (Sr) {
                Sr.methodName = it, this.emitError(it, Sr);
              }
              return Qt;
            }, Oe.prototype[it + "Quiet"] = _e;
          }
          vt("clone", "clone", function(it) {
            var Ae = new Oe(this);
            return (0, U.isNodePattern)(it) && it.call(Ae, null, Ae), Ae;
          });
          function Ye(it, Ae) {
            vt(it, "change", Ae);
          }
          Ye("background", function(it, Ae) {
            return typeof it != "number" ? U.throwError.call(this, "hex must be a hexadecimal rgba value", Ae) : (this._background = it, (0, U.isNodePattern)(Ae) && Ae.call(this, null, this), this);
          }), Ye("scan", function(it, Ae, _e, fe, We, Pe) {
            if (typeof it != "number" || typeof Ae != "number")
              return U.throwError.call(this, "x and y must be numbers", Pe);
            if (typeof _e != "number" || typeof fe != "number")
              return U.throwError.call(this, "w and h must be numbers", Pe);
            if (typeof We != "function")
              return U.throwError.call(this, "f must be a function", Pe);
            var he = (0, U.scan)(this, it, Ae, _e, fe, We);
            return (0, U.isNodePattern)(Pe) && Pe.call(this, null, he), he;
          });
          {
            var qe;
            typeof pt < "u" && (typeof pt > "u" ? "undefined" : (0, C.default)(pt)) === "object" && (qe = pt), typeof self < "u" && (typeof self > "u" ? "undefined" : (0, C.default)(self)) === "object" && (qe = self), qe.Jimp = Oe, qe.Buffer = Q;
          }
          var rt = Oe;
          $.default = rt;
        }).call(this, te("buffer").Buffer);
      }, { "./composite": 191, "./constants": 192, "./modules/phash": 194, "./request": 195, "./utils/image-bitmap": 196, "./utils/mime": 197, "./utils/promisify": 198, "@babel/runtime/helpers/assertThisInitialized": 3, "@babel/runtime/helpers/classCallCheck": 4, "@babel/runtime/helpers/construct": 5, "@babel/runtime/helpers/createClass": 6, "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/getPrototypeOf": 9, "@babel/runtime/helpers/inherits": 10, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/possibleConstructorReturn": 17, "@babel/runtime/helpers/slicedToArray": 19, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, "any-base": 23, buffer: 48, events: 52, fs: 47, mkdirp: 83, path: 107, pixelmatch: 109, tinycolor2: 178 }], 194: [function(te, Ee, $) {
        function Q(M, E) {
          this.size = this.size || M, this.smallerSize = this.smallerSize || E, H(this.size);
        }
        Q.prototype.size = 32, Q.prototype.smallerSize = 8, Q.prototype.distance = function(M, E) {
          for (var x = 0, m = 0; m < M.length; m++)
            M[m] !== E[m] && x++;
          return x / M.length;
        }, Q.prototype.getHash = function(M) {
          M = M.clone().resize(this.size, this.size), M.grayscale();
          for (var E = [], x = 0; x < M.bitmap.width; x++) {
            E[x] = [];
            for (var m = 0; m < M.bitmap.height; m++)
              E[x][m] = r(M.getPixelColor(x, m)).b;
          }
          for (var I = P(E, this.size), z = 0, w = 0; w < this.smallerSize; w++)
            for (var C = 0; C < this.smallerSize; C++)
              z += I[w][C];
          for (var b = z / (this.smallerSize * this.smallerSize), B = "", N = 0; N < this.smallerSize; N++)
            for (var U = 0; U < this.smallerSize; U++)
              B += I[N][U] > b ? "1" : "0";
          return B;
        };
        function r(M) {
          var E = {};
          return E.r = Math.floor(M / Math.pow(256, 3)), E.g = Math.floor((M - E.r * Math.pow(256, 3)) / Math.pow(256, 2)), E.b = Math.floor((M - E.r * Math.pow(256, 3) - E.g * Math.pow(256, 2)) / Math.pow(256, 1)), E.a = Math.floor((M - E.r * Math.pow(256, 3) - E.g * Math.pow(256, 2) - E.b * Math.pow(256, 1)) / Math.pow(256, 0)), E;
        }
        var F = [];
        function H(M) {
          for (var E = 1; E < M; E++)
            F[E] = 1;
          F[0] = 1 / Math.sqrt(2);
        }
        function P(M, E) {
          for (var x = E, m = [], I = 0; I < x; I++) {
            m[I] = [];
            for (var z = 0; z < x; z++) {
              for (var w = 0, C = 0; C < x; C++)
                for (var b = 0; b < x; b++)
                  w += Math.cos((2 * C + 1) / (2 * x) * I * Math.PI) * Math.cos((2 * b + 1) / (2 * x) * z * Math.PI) * M[C][b];
              w *= F[I] * F[z] / 4, m[I][z] = w;
            }
          }
          return m;
        }
        Ee.exports = Q;
      }, {}], 195: [function(te, Ee, $) {
        (function(Q, r) {
          var F = te("@babel/runtime/helpers/interopRequireDefault");
          F(te("@babel/runtime/helpers/defineProperty")), F(te("@babel/runtime/helpers/extends")), Q.browser, Ee.exports = function(H, P) {
            var M = new XMLHttpRequest();
            M.open("GET", H.url, !0), M.responseType = "arraybuffer", M.addEventListener("load", function() {
              if (M.status < 400)
                try {
                  var E = r.from(this.response);
                  P(null, M, E);
                } catch (x) {
                  return P(new Error("Response is not a buffer for url " + H.url + ". Error: " + x.message));
                }
              else
                P(new Error("HTTP Status " + M.status + " for url " + H.url));
            }), M.addEventListener("error", function(E) {
              P(E);
            }), M.send();
          };
        }).call(this, te("_process"), te("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/extends": 8, "@babel/runtime/helpers/interopRequireDefault": 11, _process: 133, buffer: 48, phin: 108 }], 196: [function(te, Ee, $) {
        (function(Q) {
          var r = te("@babel/runtime/helpers/interopRequireWildcard"), F = te("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty($, "__esModule", {
            value: !0
          }), $.parseBitmap = N, $.getBuffer = V, $.getBufferAsync = W;
          var H = F(te("@babel/runtime/helpers/slicedToArray")), P = F(te("file-type")), M = F(te("exif-parser")), E = te("@jimp/utils"), x = r(te("../constants")), m = r(te("./mime")), I = F(te("./promisify"));
          function z(q, Y) {
            var re = (0, P.default)(q);
            return re ? re.mime : Y ? m.getType(Y) : null;
          }
          function w(q) {
            return q._exif && q._exif.tags && q._exif.tags.Orientation || 1;
          }
          function C(q) {
            var Y = q.getWidth(), re = q.getHeight();
            switch (w(q)) {
              case 1:
                return null;
              case 2:
                return function(se, ve) {
                  return [Y - se - 1, ve];
                };
              case 3:
                return function(se, ve) {
                  return [Y - se - 1, re - ve - 1];
                };
              case 4:
                return function(se, ve) {
                  return [se, re - ve - 1];
                };
              case 5:
                return function(se, ve) {
                  return [ve, se];
                };
              case 6:
                return function(se, ve) {
                  return [ve, re - se - 1];
                };
              case 7:
                return function(se, ve) {
                  return [Y - ve - 1, re - se - 1];
                };
              case 8:
                return function(se, ve) {
                  return [Y - ve - 1, se];
                };
              default:
                return null;
            }
          }
          function b(q, Y, re, se) {
            for (var ve = q.bitmap.data, ce = q.bitmap.width, be = Q.alloc(ve.length), Me = 0; Me < Y; Me++)
              for (var xe = 0; xe < re; xe++) {
                var le = se(Me, xe), de = (0, H.default)(le, 2), De = de[0], ze = de[1], Ze = Y * xe + Me << 2, Ue = ce * ze + De << 2, Ie = ve.readUInt32BE(Ue);
                be.writeUInt32BE(Ie, Ze);
              }
            q.bitmap.data = be, q.bitmap.width = Y, q.bitmap.height = re;
          }
          function B(q) {
            if (!(w(q) < 2)) {
              var Y = C(q), re = w(q) > 4, se = re ? q.bitmap.height : q.bitmap.width, ve = re ? q.bitmap.width : q.bitmap.height;
              b(q, se, ve, Y);
            }
          }
          function N(q, Y, re) {
            var se = z(q, Y);
            if (typeof se != "string")
              return re(new Error("Could not find MIME for Buffer <" + Y + ">"));
            this._originalMime = se.toLowerCase();
            try {
              var ve = this.getMIME();
              if (this.constructor.decoders[ve])
                this.bitmap = this.constructor.decoders[ve](q);
              else
                return E.throwError.call(this, "Unsupported MIME type: " + ve, re);
            } catch (ce) {
              return re.call(this, ce, this);
            }
            try {
              this._exif = M.default.create(q).parse(), B(this);
            } catch {
            }
            return re.call(this, null, this), this;
          }
          function U(q, Y) {
            return new q(Y.bitmap.width, Y.bitmap.height, Y._background).composite(Y, 0, 0).bitmap;
          }
          function V(q, Y) {
            if (q === x.AUTO && (q = this.getMIME()), typeof q != "string")
              return E.throwError.call(this, "mime must be a string", Y);
            if (typeof Y != "function")
              return E.throwError.call(this, "cb must be a function", Y);
            if (q = q.toLowerCase(), this._rgba && this.constructor.hasAlpha[q] ? this.bitmap.data = Q.from(this.bitmap.data) : this.bitmap.data = U(this.constructor, this).data, this.constructor.encoders[q]) {
              var re = this.constructor.encoders[q](this);
              Y.call(this, null, re);
            } else
              Y.call(this, "Unsupported MIME type: " + q);
            return this;
          }
          function W(q) {
            return (0, I.default)(V, this, q);
          }
        }).call(this, te("buffer").Buffer);
      }, { "../constants": 192, "./mime": 197, "./promisify": 198, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/slicedToArray": 19, "@jimp/utils": 235, buffer: 48, "exif-parser": 53, "file-type": 62 }], 197: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.getExtension = $.getType = $.addType = void 0;
        var Q = {}, r = function(E) {
          return Object.entries(Q).find(function(x) {
            return x[1].includes(E);
          }) || [];
        }, F = function(E, x) {
          Q[E] = x;
        };
        $.addType = F;
        var H = function(E) {
          var x = E.split("/").slice(-1), m = x[x.length - 1].split(".").pop(), I = r(m);
          return I[0];
        };
        $.getType = H;
        var P = function(E) {
          return (Q[E.toLowerCase()] || [])[0];
        };
        $.getExtension = P;
      }, {}], 198: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = function(H, P) {
          for (var M = arguments.length, E = new Array(M > 2 ? M - 2 : 0), x = 2; x < M; x++)
            E[x - 2] = arguments[x];
          return new Promise(function(m, I) {
            E.push(function(z, w) {
              z && I(z), m(w);
            }), H.bind(P).apply(void 0, E);
          });
        }, r = Q;
        $.default = r, Ee.exports = $.default;
      }, {}], 199: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireWildcard"), r = te("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = m;
        var F = r(te("@babel/runtime/helpers/toConsumableArray")), H = r(te("@babel/runtime/helpers/defineProperty")), P = r(te("@babel/runtime/helpers/slicedToArray")), M = Q(te("@jimp/core"));
        function E(I, z) {
          var w = Object.keys(I);
          if (Object.getOwnPropertySymbols) {
            var C = Object.getOwnPropertySymbols(I);
            z && (C = C.filter(function(b) {
              return Object.getOwnPropertyDescriptor(I, b).enumerable;
            })), w.push.apply(w, C);
          }
          return w;
        }
        function x(I) {
          for (var z = 1; z < arguments.length; z++) {
            var w = arguments[z] != null ? arguments[z] : {};
            z % 2 ? E(w, !0).forEach(function(C) {
              (0, H.default)(I, C, w[C]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(I, Object.getOwnPropertyDescriptors(w)) : E(w).forEach(function(C) {
              Object.defineProperty(I, C, Object.getOwnPropertyDescriptor(w, C));
            });
          }
          return I;
        }
        function m(I) {
          var z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : M.default, w = {
            hasAlpha: {},
            encoders: {},
            decoders: {},
            class: {},
            constants: {}
          };
          function C(N) {
            Object.entries(N).forEach(function(U) {
              var V = (0, P.default)(U, 2), W = V[0], q = V[1];
              w[W] = x({}, w[W], {}, q);
            });
          }
          function b(N) {
            var U = N();
            Array.isArray(U.mime) ? M.addType.apply(void 0, (0, F.default)(U.mime)) : Object.entries(U.mime).forEach(function(V) {
              return M.addType.apply(void 0, (0, F.default)(V));
            }), delete U.mime, C(U);
          }
          function B(N) {
            var U = N(M.jimpEvChange) || {};
            !U.class && !U.constants ? C({
              class: U
            }) : C(U);
          }
          return I.types && (I.types.forEach(b), z.decoders = x({}, z.decoders, {}, w.decoders), z.encoders = x({}, z.encoders, {}, w.encoders), z.hasAlpha = x({}, z.hasAlpha, {}, w.hasAlpha)), I.plugins && I.plugins.forEach(B), (0, M.addJimpMethods)(w.class, z), (0, M.addConstants)(w.constants, z), M.default;
        }
        Ee.exports = $.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/slicedToArray": 19, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/core": 193 }], 200: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var r = Q(te("@jimp/custom")), F = Q(te("@jimp/types")), H = Q(te("@jimp/plugins")), P = (0, r.default)({
          types: [F.default],
          plugins: [H.default]
        });
        $.default = P, Ee.exports = $.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/custom": 199, "@jimp/plugins": 228, "@jimp/types": 234 }], 201: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var r = Q(te("@babel/runtime/helpers/typeof")), F = te("@jimp/utils"), H = function() {
          return {
            /**
             * Blits a source image on to this image
             * @param {Jimp} src the source Jimp instance
             * @param {number} x the x position to blit the image
             * @param {number} y the y position to blit the image
             * @param {number} srcx (optional) the x position from which to crop the source image
             * @param {number} srcy (optional) the y position from which to crop the source image
             * @param {number} srcw (optional) the width to which to crop the source image
             * @param {number} srch (optional) the height to which to crop the source image
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            blit: function(E, x, m, I, z, w, C, b) {
              if (!(E instanceof this.constructor))
                return F.throwError.call(this, "The source must be a Jimp image", b);
              if (typeof x != "number" || typeof m != "number")
                return F.throwError.call(this, "x and y must be numbers", b);
              if (typeof I == "function")
                b = I, I = 0, z = 0, w = E.bitmap.width, C = E.bitmap.height;
              else if ((0, r.default)(I) === (0, r.default)(z) && (0, r.default)(z) === (0, r.default)(w) && (0, r.default)(w) === (0, r.default)(C))
                I = I || 0, z = z || 0, w = w || E.bitmap.width, C = C || E.bitmap.height;
              else
                return F.throwError.call(this, "srcx, srcy, srcw, srch must be numbers", b);
              x = Math.round(x), m = Math.round(m), I = Math.round(I), z = Math.round(z), w = Math.round(w), C = Math.round(C);
              var B = this.bitmap.width, N = this.bitmap.height, U = this;
              return E.scanQuiet(I, z, w, C, function(V, W, q) {
                var Y = x + V - I, re = m + W - z;
                if (Y >= 0 && re >= 0 && B - Y > 0 && N - re > 0) {
                  var se = U.getPixelIndex(Y, re), ve = {
                    r: this.bitmap.data[q],
                    g: this.bitmap.data[q + 1],
                    b: this.bitmap.data[q + 2],
                    a: this.bitmap.data[q + 3]
                  }, ce = {
                    r: U.bitmap.data[se],
                    g: U.bitmap.data[se + 1],
                    b: U.bitmap.data[se + 2],
                    a: U.bitmap.data[se + 3]
                  };
                  U.bitmap.data[se] = (ve.a * (ve.r - ce.r) - ce.r + 255 >> 8) + ce.r, U.bitmap.data[se + 1] = (ve.a * (ve.g - ce.g) - ce.g + 255 >> 8) + ce.g, U.bitmap.data[se + 2] = (ve.a * (ve.b - ce.b) - ce.b + 255 >> 8) + ce.b, U.bitmap.data[se + 3] = this.constructor.limit255(ce.a + ve.a);
                }
              }), (0, F.isNodePattern)(b) && b.call(this, null, this), this;
            }
          };
        };
        $.default = H, Ee.exports = $.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235 }], 202: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.shgTable = $.mulTable = void 0;
        var Q = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
        $.mulTable = Q;
        var r = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
        $.shgTable = r;
      }, {}], 203: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils"), r = te("./blur-tables"), F = function() {
          return {
            /**
             * A fast blur algorithm that produces similar effect to a Gaussian blur - but MUCH quicker
             * @param {number} r the pixel radius of the blur
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            blur: function(M, E) {
              if (typeof M != "number") return Q.throwError.call(this, "r must be a number", E);
              if (M < 1) return Q.throwError.call(this, "r must be greater than 0", E);
              for (var x, m, I, z, w, C, b, B, N, U, V, W, q, Y, re = this.bitmap.width - 1, se = this.bitmap.height - 1, ve = M + 1, ce = r.mulTable[M], be = r.shgTable[M], Me = [], xe = [], le = [], de = [], De = [], ze = [], Ze = 2; Ze-- > 0; ) {
                for (W = 0, q = 0, C = 0; C < this.bitmap.height; C++) {
                  for (x = this.bitmap.data[q] * ve, m = this.bitmap.data[q + 1] * ve, I = this.bitmap.data[q + 2] * ve, z = this.bitmap.data[q + 3] * ve, b = 1; b <= M; b++)
                    B = q + ((b > re ? re : b) << 2), x += this.bitmap.data[B++], m += this.bitmap.data[B++], I += this.bitmap.data[B++], z += this.bitmap.data[B];
                  for (w = 0; w < this.bitmap.width; w++)
                    Me[W] = x, xe[W] = m, le[W] = I, de[W] = z, C === 0 && (De[w] = ((B = w + ve) < re ? B : re) << 2, ze[w] = (B = w - M) > 0 ? B << 2 : 0), N = q + De[w], U = q + ze[w], x += this.bitmap.data[N++] - this.bitmap.data[U++], m += this.bitmap.data[N++] - this.bitmap.data[U++], I += this.bitmap.data[N++] - this.bitmap.data[U++], z += this.bitmap.data[N] - this.bitmap.data[U], W++;
                  q += this.bitmap.width << 2;
                }
                for (w = 0; w < this.bitmap.width; w++) {
                  for (V = w, x = Me[V] * ve, m = xe[V] * ve, I = le[V] * ve, z = de[V] * ve, b = 1; b <= M; b++)
                    V += b > se ? 0 : this.bitmap.width, x += Me[V], m += xe[V], I += le[V], z += de[V];
                  for (W = w << 2, C = 0; C < this.bitmap.height; C++)
                    Y = z * ce >>> be, this.bitmap.data[W + 3] = Y, Y > 255 && (this.bitmap.data[W + 3] = 255), Y > 0 ? (Y = 255 / Y, this.bitmap.data[W] = (x * ce >>> be) * Y, this.bitmap.data[W + 1] = (m * ce >>> be) * Y, this.bitmap.data[W + 2] = (I * ce >>> be) * Y) : (this.bitmap.data[W + 2] = 0, this.bitmap.data[W + 1] = 0, this.bitmap.data[W] = 0), w === 0 && (De[C] = ((B = C + ve) < se ? B : se) * this.bitmap.width, ze[C] = (B = C - M) > 0 ? B * this.bitmap.width : 0), N = w + De[C], U = w + ze[C], x += Me[N] - Me[U], m += xe[N] - xe[U], I += le[N] - le[U], z += de[N] - de[U], W += this.bitmap.width << 2;
                }
              }
              return (0, Q.isNodePattern)(E) && E.call(this, null, this), this;
            }
          };
        };
        $.default = F, Ee.exports = $.default;
      }, { "./blur-tables": 202, "@jimp/utils": 235 }], 204: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils"), r = function() {
          return {
            circle: function() {
              var P = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, M = arguments.length > 1 ? arguments[1] : void 0;
              typeof P == "function" && (M = P, P = {});
              var E = P.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2, x = {
                x: typeof P.x == "number" ? P.x : this.bitmap.width / 2,
                y: typeof P.y == "number" ? P.y : this.bitmap.height / 2
              };
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(m, I, z) {
                var w = Math.sqrt(Math.pow(m - x.x, 2) + Math.pow(I - x.y, 2));
                E - w <= 0 ? this.bitmap.data[z + 3] = 0 : E - w < 1 && (this.bitmap.data[z + 3] = 255 * (E - w));
              }), (0, Q.isNodePattern)(M) && M.call(this, null, this), this;
            }
          };
        };
        $.default = r, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 205: [function(te, Ee, $) {
        (function(Q) {
          var r = te("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty($, "__esModule", {
            value: !0
          }), $.default = void 0;
          var F = r(te("@babel/runtime/helpers/toConsumableArray")), H = r(te("tinycolor2")), P = te("@jimp/utils");
          function M(w, C, b, B) {
            for (var N = [0, 0, 0], U = (C.length - 1) / 2, V = 0; V < C.length; V += 1)
              for (var W = 0; W < C[V].length; W += 1) {
                var q = w.getPixelIndex(b + V - U, B + W - U);
                N[0] += w.bitmap.data[q] * C[V][W], N[1] += w.bitmap.data[q + 1] * C[V][W], N[2] += w.bitmap.data[q + 2] * C[V][W];
              }
            return N;
          }
          var E = function(C) {
            return typeof C < "u" && C !== null;
          };
          function x(w) {
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(C, b, B) {
              var N = parseInt(0.2126 * this.bitmap.data[B] + 0.7152 * this.bitmap.data[B + 1] + 0.0722 * this.bitmap.data[B + 2], 10);
              this.bitmap.data[B] = N, this.bitmap.data[B + 1] = N, this.bitmap.data[B + 2] = N;
            }), (0, P.isNodePattern)(w) && w.call(this, null, this), this;
          }
          function m(w, C) {
            var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50;
            return {
              r: (C.r - w.r) * (b / 100) + w.r,
              g: (C.g - w.g) * (b / 100) + w.g,
              b: (C.b - w.b) * (b / 100) + w.b
            };
          }
          function I(w, C) {
            var b = this;
            return !w || !Array.isArray(w) ? P.throwError.call(this, "actions must be an array", C) : (w = w.map(function(B) {
              return (B.apply === "xor" || B.apply === "mix") && (B.params[0] = (0, H.default)(B.params[0]).toRgb()), B;
            }), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(B, N, U) {
              var V = {
                r: b.bitmap.data[U],
                g: b.bitmap.data[U + 1],
                b: b.bitmap.data[U + 2]
              }, W = function(Y, re) {
                return b.constructor.limit255(V[Y] + re);
              };
              w.forEach(function(q) {
                if (q.apply === "mix")
                  V = m(V, q.params[0], q.params[1]);
                else if (q.apply === "tint")
                  V = m(V, {
                    r: 255,
                    g: 255,
                    b: 255
                  }, q.params[0]);
                else if (q.apply === "shade")
                  V = m(V, {
                    r: 0,
                    g: 0,
                    b: 0
                  }, q.params[0]);
                else if (q.apply === "xor")
                  V = {
                    r: V.r ^ q.params[0].r,
                    g: V.g ^ q.params[0].g,
                    b: V.b ^ q.params[0].b
                  };
                else if (q.apply === "red")
                  V.r = W("r", q.params[0]);
                else if (q.apply === "green")
                  V.g = W("g", q.params[0]);
                else if (q.apply === "blue")
                  V.b = W("b", q.params[0]);
                else {
                  var Y;
                  if (q.apply === "hue" && (q.apply = "spin"), V = (0, H.default)(V), !V[q.apply])
                    return P.throwError.call(b, "action " + q.apply + " not supported", C);
                  V = (Y = V)[q.apply].apply(Y, (0, F.default)(q.params)).toRgb();
                }
              }), b.bitmap.data[U] = V.r, b.bitmap.data[U + 1] = V.g, b.bitmap.data[U + 2] = V.b;
            }), (0, P.isNodePattern)(C) && C.call(this, null, this), this);
          }
          var z = function() {
            return {
              /**
               * Adjusts the brightness of the image
               * @param {number} val the amount to adjust the brightness, a number between -1 and +1
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              brightness: function(b, B) {
                return typeof b != "number" ? P.throwError.call(this, "val must be numbers", B) : b < -1 || b > 1 ? P.throwError.call(this, "val must be a number between -1 and +1", B) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(N, U, V) {
                  b < 0 ? (this.bitmap.data[V] = this.bitmap.data[V] * (1 + b), this.bitmap.data[V + 1] = this.bitmap.data[V + 1] * (1 + b), this.bitmap.data[V + 2] = this.bitmap.data[V + 2] * (1 + b)) : (this.bitmap.data[V] = this.bitmap.data[V] + (255 - this.bitmap.data[V]) * b, this.bitmap.data[V + 1] = this.bitmap.data[V + 1] + (255 - this.bitmap.data[V + 1]) * b, this.bitmap.data[V + 2] = this.bitmap.data[V + 2] + (255 - this.bitmap.data[V + 2]) * b);
                }), (0, P.isNodePattern)(B) && B.call(this, null, this), this);
              },
              /**
               * Adjusts the contrast of the image
               * @param {number} val the amount to adjust the contrast, a number between -1 and +1
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              contrast: function(b, B) {
                if (typeof b != "number")
                  return P.throwError.call(this, "val must be numbers", B);
                if (b < -1 || b > 1)
                  return P.throwError.call(this, "val must be a number between -1 and +1", B);
                var N = (b + 1) / (1 - b);
                function U(V) {
                  return V = Math.floor(N * (V - 127) + 127), V < 0 ? 0 : V > 255 ? 255 : V;
                }
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(V, W, q) {
                  this.bitmap.data[q] = U(this.bitmap.data[q]), this.bitmap.data[q + 1] = U(this.bitmap.data[q + 1]), this.bitmap.data[q + 2] = U(this.bitmap.data[q + 2]);
                }), (0, P.isNodePattern)(B) && B.call(this, null, this), this;
              },
              /**
               * Apply a posterize effect
               * @param {number} n the amount to adjust the contrast, minimum threshold is two
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              posterize: function(b, B) {
                return typeof b != "number" ? P.throwError.call(this, "n must be numbers", B) : (b < 2 && (b = 2), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(N, U, V) {
                  this.bitmap.data[V] = Math.floor(this.bitmap.data[V] / 255 * (b - 1)) / (b - 1) * 255, this.bitmap.data[V + 1] = Math.floor(this.bitmap.data[V + 1] / 255 * (b - 1)) / (b - 1) * 255, this.bitmap.data[V + 2] = Math.floor(this.bitmap.data[V + 2] / 255 * (b - 1)) / (b - 1) * 255;
                }), (0, P.isNodePattern)(B) && B.call(this, null, this), this);
              },
              /**
               * Removes colour from the image using ITU Rec 709 luminance values
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              greyscale: x,
              // Alias of greyscale for our American friends
              grayscale: x,
              /**
               * Multiplies the opacity of each pixel by a factor between 0 and 1
               * @param {number} f A number, the factor by which to multiply the opacity of each pixel
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              opacity: function(b, B) {
                return typeof b != "number" ? P.throwError.call(this, "f must be a number", B) : b < 0 || b > 1 ? P.throwError.call(this, "f must be a number from 0 to 1", B) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(N, U, V) {
                  var W = this.bitmap.data[V + 3] * b;
                  this.bitmap.data[V + 3] = W;
                }), (0, P.isNodePattern)(B) && B.call(this, null, this), this);
              },
              /**
               * Applies a sepia tone to the image
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              sepia: function(b) {
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(B, N, U) {
                  var V = this.bitmap.data[U], W = this.bitmap.data[U + 1], q = this.bitmap.data[U + 2];
                  V = V * 0.393 + W * 0.769 + q * 0.189, W = V * 0.349 + W * 0.686 + q * 0.168, q = V * 0.272 + W * 0.534 + q * 0.131, this.bitmap.data[U] = V < 255 ? V : 255, this.bitmap.data[U + 1] = W < 255 ? W : 255, this.bitmap.data[U + 2] = q < 255 ? q : 255;
                }), (0, P.isNodePattern)(b) && b.call(this, null, this), this;
              },
              /**
               * Fades each pixel by a factor between 0 and 1
               * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              fade: function(b, B) {
                return typeof b != "number" ? P.throwError.call(this, "f must be a number", B) : b < 0 || b > 1 ? P.throwError.call(this, "f must be a number from 0 to 1", B) : (this.opacity(1 - b), (0, P.isNodePattern)(B) && B.call(this, null, this), this);
              },
              /**
               * Adds each element of the image to its local neighbors, weighted by the kernel
               * @param {array} kernel a matrix to weight the neighbors sum
               * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              convolution: function(b, B, N) {
                typeof B == "function" && typeof N > "u" && (N = B, B = null), B || (B = this.constructor.EDGE_EXTEND);
                var U = Q.from(this.bitmap.data), V = b.length, W = b[0].length, q = Math.floor(V / 2), Y = Math.floor(W / 2), re = -q, se = -Y, ve, ce, be, Me, xe, le, de, De, ze, Ze;
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(Ue, Ie, je) {
                  Me = 0, be = 0, ce = 0;
                  for (var Fe = re; Fe <= q; Fe++)
                    for (var $e = se; $e <= Y; $e++)
                      De = Ue + $e, ze = Ie + Fe, ve = b[Fe + q][$e + Y], Ze = this.getPixelIndex(De, ze, B), Ze === -1 ? (de = 0, le = 0, xe = 0) : (xe = this.bitmap.data[Ze + 0], le = this.bitmap.data[Ze + 1], de = this.bitmap.data[Ze + 2]), ce += ve * xe, be += ve * le, Me += ve * de;
                  ce < 0 && (ce = 0), be < 0 && (be = 0), Me < 0 && (Me = 0), ce > 255 && (ce = 255), be > 255 && (be = 255), Me > 255 && (Me = 255), U[je + 0] = ce, U[je + 1] = be, U[je + 2] = Me;
                }), this.bitmap.data = U, (0, P.isNodePattern)(N) && N.call(this, null, this), this;
              },
              /**
               * Set the alpha channel on every pixel to fully opaque
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              opaque: function(b) {
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(B, N, U) {
                  this.bitmap.data[U + 3] = 255;
                }), (0, P.isNodePattern)(b) && b.call(this, null, this), this;
              },
              /**
               * Pixelates the image or a region
               * @param {number} size the size of the pixels
               * @param {number} x (optional) the x position of the region to pixelate
               * @param {number} y (optional) the y position of the region to pixelate
               * @param {number} w (optional) the width of the region to pixelate
               * @param {number} h (optional) the height of the region to pixelate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              pixelate: function(b, B, N, U, V, W) {
                if (typeof B == "function")
                  W = B, V = null, U = null, N = null, B = null;
                else {
                  if (typeof b != "number")
                    return P.throwError.call(this, "size must be a number", W);
                  if (E(B) && typeof B != "number")
                    return P.throwError.call(this, "x must be a number", W);
                  if (E(N) && typeof N != "number")
                    return P.throwError.call(this, "y must be a number", W);
                  if (E(U) && typeof U != "number")
                    return P.throwError.call(this, "w must be a number", W);
                  if (E(V) && typeof V != "number")
                    return P.throwError.call(this, "h must be a number", W);
                }
                var q = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];
                B = B || 0, N = N || 0, U = E(U) ? U : this.bitmap.width - B, V = E(V) ? V : this.bitmap.height - N;
                var Y = this.cloneQuiet();
                return this.scanQuiet(B, N, U, V, function(re, se, ve) {
                  re = b * Math.floor(re / b), se = b * Math.floor(se / b);
                  var ce = M(Y, q, re, se);
                  this.bitmap.data[ve] = ce[0], this.bitmap.data[ve + 1] = ce[1], this.bitmap.data[ve + 2] = ce[2];
                }), (0, P.isNodePattern)(W) && W.call(this, null, this), this;
              },
              /**
               * Applies a convolution kernel to the image or a region
               * @param {array} kernel the convolution kernel
               * @param {number} x (optional) the x position of the region to apply convolution to
               * @param {number} y (optional) the y position of the region to apply convolution to
               * @param {number} w (optional) the width of the region to apply convolution to
               * @param {number} h (optional) the height of the region to apply convolution to
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              convolute: function(b, B, N, U, V, W) {
                if (!Array.isArray(b)) return P.throwError.call(this, "the kernel must be an array", W);
                if (typeof B == "function")
                  W = B, B = null, N = null, U = null, V = null;
                else {
                  if (E(B) && typeof B != "number")
                    return P.throwError.call(this, "x must be a number", W);
                  if (E(N) && typeof N != "number")
                    return P.throwError.call(this, "y must be a number", W);
                  if (E(U) && typeof U != "number")
                    return P.throwError.call(this, "w must be a number", W);
                  if (E(V) && typeof V != "number")
                    return P.throwError.call(this, "h must be a number", W);
                }
                var q = (b.length - 1) / 2;
                B = E(B) ? B : q, N = E(N) ? N : q, U = E(U) ? U : this.bitmap.width - B, V = E(V) ? V : this.bitmap.height - N;
                var Y = this.cloneQuiet();
                return this.scanQuiet(B, N, U, V, function(re, se, ve) {
                  var ce = M(Y, b, re, se);
                  this.bitmap.data[ve] = this.constructor.limit255(ce[0]), this.bitmap.data[ve + 1] = this.constructor.limit255(ce[1]), this.bitmap.data[ve + 2] = this.constructor.limit255(ce[2]);
                }), (0, P.isNodePattern)(W) && W.call(this, null, this), this;
              },
              /**
               * Apply multiple color modification rules
               * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              color: I,
              colour: I
            };
          };
          $.default = z, Ee.exports = $.default;
        }).call(this, te("buffer").Buffer);
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/utils": 235, buffer: 48, tinycolor2: 178 }], 206: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils"), r = function() {
          return {
            contain: function(P, M, E, x, m) {
              if (typeof P != "number" || typeof M != "number")
                return Q.throwError.call(this, "w and h must be numbers", m);
              typeof E == "string" && (typeof x == "function" && typeof m > "u" && (m = x), x = E, E = null), typeof E == "function" && (typeof m > "u" && (m = E), x = null, E = null), typeof x == "function" && typeof m > "u" && (m = x, x = null), E = E || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
              var I = E & 7, z = E >> 3;
              if (!(I !== 0 && !(I & I - 1) || z !== 0 && !(z & z - 1)))
                return Q.throwError.call(this, "only use one flag per alignment direction", m);
              var w = I >> 1, C = z >> 1, b = P / M > this.bitmap.width / this.bitmap.height ? M / this.bitmap.height : P / this.bitmap.width, B = this.cloneQuiet().scale(b, x);
              return this.resize(P, M, x), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(N, U, V) {
                this.bitmap.data.writeUInt32BE(this._background, V);
              }), this.blit(B, (this.bitmap.width - B.bitmap.width) / 2 * w, (this.bitmap.height - B.bitmap.height) / 2 * C), (0, Q.isNodePattern)(m) && m.call(this, null, this), this;
            }
          };
        };
        $.default = r, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 207: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils"), r = function() {
          return {
            cover: function(P, M, E, x, m) {
              if (typeof P != "number" || typeof M != "number")
                return Q.throwError.call(this, "w and h must be numbers", m);
              E && typeof E == "function" && typeof m > "u" ? (m = E, E = null, x = null) : typeof x == "function" && typeof m > "u" && (m = x, x = null), E = E || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
              var I = E & 7, z = E >> 3;
              if (!(I !== 0 && !(I & I - 1) || z !== 0 && !(z & z - 1))) return Q.throwError.call(this, "only use one flag per alignment direction", m);
              var w = I >> 1, C = z >> 1, b = P / M > this.bitmap.width / this.bitmap.height ? P / this.bitmap.width : M / this.bitmap.height;
              return this.scale(b, x), this.crop((this.bitmap.width - P) / 2 * w, (this.bitmap.height - M) / 2 * C, P, M), (0, Q.isNodePattern)(m) && m.call(this, null, this), this;
            }
          };
        };
        $.default = r, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 208: [function(te, Ee, $) {
        (function(Q) {
          var r = te("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty($, "__esModule", {
            value: !0
          }), $.default = P;
          var F = r(te("@babel/runtime/helpers/typeof")), H = te("@jimp/utils");
          function P(M) {
            return M("crop", function(E, x, m, I, z) {
              if (typeof E != "number" || typeof x != "number") return H.throwError.call(this, "x and y must be numbers", z);
              if (typeof m != "number" || typeof I != "number") return H.throwError.call(this, "w and h must be numbers", z);
              if (E = Math.round(E), x = Math.round(x), m = Math.round(m), I = Math.round(I), E === 0 && m === this.bitmap.width) {
                var w = m * x + E << 2, C = w + I * m << 2;
                this.bitmap.data = this.bitmap.data.slice(w, C);
              } else {
                var b = Q.allocUnsafe(m * I * 4), B = 0;
                this.scanQuiet(E, x, m, I, function(N, U, V) {
                  var W = this.bitmap.data.readUInt32BE(V, !0);
                  b.writeUInt32BE(W, B, !0), B += 4;
                }), this.bitmap.data = b;
              }
              return this.bitmap.width = m, this.bitmap.height = I, (0, H.isNodePattern)(z) && z.call(this, null, this), this;
            }), {
              class: {
                /**
                 * Autocrop same color borders from this image
                 * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)
                 * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)
                 * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)
                 * @returns {Jimp} this for chaining of methods
                 */
                autocrop: function() {
                  for (var x = this.bitmap.width, m = this.bitmap.height, I = 1, z, w = 0, C = 2e-4, b = !0, B = !1, N = arguments.length, U = new Array(N), V = 0; V < N; V++)
                    U[V] = arguments[V];
                  for (var W = 0, q = U.length; W < q; W++)
                    if (typeof U[W] == "number" && (C = U[W]), typeof U[W] == "boolean" && (b = U[W]), typeof U[W] == "function" && (z = U[W]), (0, F.default)(U[W]) === "object") {
                      var Y = U[W];
                      typeof Y.tolerance < "u" && (C = Y.tolerance), typeof Y.cropOnlyFrames < "u" && (b = Y.cropOnlyFrames), typeof Y.cropSymmetric < "u" && (B = Y.cropSymmetric), typeof Y.leaveBorder < "u" && (w = Y.leaveBorder);
                    }
                  var re = this.getPixelColor(0, 0), se = this.constructor.intToRGBA(re), ve = 0, ce = 0, be = 0, Me = 0;
                  re = this.getPixelColor(0, 0);
                  e: for (var xe = 0; xe < m - I; xe++) {
                    for (var le = 0; le < x; le++) {
                      var de = this.getPixelColor(le, xe), De = this.constructor.intToRGBA(de);
                      if (this.constructor.colorDiff(se, De) > C)
                        break e;
                    }
                    ve++;
                  }
                  re = this.getPixelColor(x, 0);
                  e: for (var ze = 0; ze < x - I; ze++) {
                    for (var Ze = 0 + ve; Ze < m; Ze++) {
                      var Ue = this.getPixelColor(ze, Ze), Ie = this.constructor.intToRGBA(Ue);
                      if (this.constructor.colorDiff(se, Ie) > C)
                        break e;
                    }
                    ce++;
                  }
                  re = this.getPixelColor(0, m);
                  e: for (var je = m - 1; je >= ve + I; je--) {
                    for (var Fe = x - ce - 1; Fe >= 0; Fe--) {
                      var $e = this.getPixelColor(Fe, je), ct = this.constructor.intToRGBA($e);
                      if (this.constructor.colorDiff(se, ct) > C)
                        break e;
                    }
                    be++;
                  }
                  re = this.getPixelColor(x, m);
                  e: for (var wt = x - 1; wt >= 0 + ce + I; wt--) {
                    for (var Oe = m - 1; Oe >= 0 + ve; Oe--) {
                      var Ct = this.getPixelColor(wt, Oe), Xt = this.constructor.intToRGBA(Ct);
                      if (this.constructor.colorDiff(se, Xt) > C)
                        break e;
                    }
                    Me++;
                  }
                  var vt = !1;
                  if (Me -= w, ce -= w, ve -= w, be -= w, B) {
                    var Ye = Math.min(ce, Me), qe = Math.min(ve, be);
                    Me = Ye, ce = Ye, ve = qe, be = qe;
                  }
                  Me = Me >= 0 ? Me : 0, ce = ce >= 0 ? ce : 0, ve = ve >= 0 ? ve : 0, be = be >= 0 ? be : 0;
                  var rt = x - (Me + ce), it = m - (be + ve);
                  return b ? vt = ce !== 0 && ve !== 0 && Me !== 0 && be !== 0 : vt = ce !== 0 || ve !== 0 || Me !== 0 || be !== 0, vt && this.crop(ce, ve, rt, it), (0, H.isNodePattern)(z) && z.call(this, null, this), this;
                }
              }
            };
          }
          Ee.exports = $.default;
        }).call(this, te("buffer").Buffer);
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, buffer: 48 }], 209: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var r = Q(te("@babel/runtime/helpers/typeof")), F = te("@jimp/utils"), H = function() {
          return {
            displace: function(E, x, m) {
              if ((0, r.default)(E) !== "object" || E.constructor !== this.constructor)
                return F.throwError.call(this, "The source must be a Jimp image", m);
              if (typeof x != "number")
                return F.throwError.call(this, "factor must be a number", m);
              var I = this.cloneQuiet();
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(z, w, C) {
                var b = E.bitmap.data[C] / 256 * x;
                b = Math.round(b);
                var B = this.getPixelIndex(z + b, w);
                this.bitmap.data[B] = I.bitmap.data[C], this.bitmap.data[B + 1] = I.bitmap.data[C + 1], this.bitmap.data[B + 2] = I.bitmap.data[C + 2];
              }), (0, F.isNodePattern)(m) && m.call(this, null, this), this;
            }
          };
        };
        $.default = H, Ee.exports = $.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235 }], 210: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils");
        function r(H) {
          var P = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
          return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(M, E, x) {
            var m = ((E & 3) << 2) + M % 4, I = P[m];
            this.bitmap.data[x] = Math.min(this.bitmap.data[x] + I, 255), this.bitmap.data[x + 1] = Math.min(this.bitmap.data[x + 1] + I, 255), this.bitmap.data[x + 2] = Math.min(this.bitmap.data[x + 2] + I, 255);
          }), (0, Q.isNodePattern)(H) && H.call(this, null, this), this;
        }
        var F = function() {
          return {
            dither565: r,
            dither16: r
          };
        };
        $.default = F, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 211: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils"), r = function() {
          return {
            fisheye: function() {
              var P = this, M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
                r: 2.5
              }, E = arguments.length > 1 ? arguments[1] : void 0;
              typeof M == "function" && (E = M, M = {
                r: 2.5
              });
              var x = this.cloneQuiet(), m = x.bitmap, I = m.width, z = m.height;
              return x.scanQuiet(0, 0, I, z, function(w, C) {
                var b = w / I, B = C / z, N = Math.sqrt(Math.pow(b - 0.5, 2) + Math.pow(B - 0.5, 2)), U = 2 * Math.pow(N, M.r), V = (b - 0.5) / N, W = (B - 0.5) / N, q = Math.round((U * V + 0.5) * I), Y = Math.round((U * W + 0.5) * z), re = x.getPixelColor(q, Y);
                P.setPixelColor(re, w, C);
              }), this.setPixelColor(x.getPixelColor(I / 2, z / 2), I / 2, z / 2), (0, Q.isNodePattern)(E) && E.call(this, null, this), this;
            }
          };
        };
        $.default = r, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 212: [function(te, Ee, $) {
        (function(Q) {
          Object.defineProperty($, "__esModule", {
            value: !0
          }), $.default = void 0;
          var r = te("@jimp/utils");
          function F(P, M, E) {
            if (typeof P != "boolean" || typeof M != "boolean") return r.throwError.call(this, "horizontal and vertical must be Booleans", E);
            var x = Q.alloc(this.bitmap.data.length);
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(m, I, z) {
              var w = P ? this.bitmap.width - 1 - m : m, C = M ? this.bitmap.height - 1 - I : I, b = this.bitmap.width * C + w << 2, B = this.bitmap.data.readUInt32BE(z);
              x.writeUInt32BE(B, b);
            }), this.bitmap.data = Q.from(x), (0, r.isNodePattern)(E) && E.call(this, null, this), this;
          }
          var H = function() {
            return {
              flip: F,
              mirror: F
            };
          };
          $.default = H, Ee.exports = $.default;
        }).call(this, te("buffer").Buffer);
      }, { "@jimp/utils": 235, buffer: 48 }], 213: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils"), r = function() {
          return {
            gaussian: function(P, M) {
              if (typeof P != "number")
                return Q.throwError.call(this, "r must be a number", M);
              if (P < 1)
                return Q.throwError.call(this, "r must be greater than 0", M);
              for (var E = Math.ceil(P * 2.57), x = E * 2 + 1, m = P * P * 2, I = m * Math.PI, z = [], w = 0; w < x; w++) {
                z[w] = [];
                for (var C = 0; C < x; C++) {
                  var b = Math.pow(C - E, 2) + Math.pow(w - E, 2);
                  z[w][C] = Math.exp(-b / m) / I;
                }
              }
              for (var B = 0; B < this.bitmap.height; B++)
                for (var N = 0; N < this.bitmap.width; N++)
                  for (var U = 0, V = 0, W = 0, q = 0, Y = 0, re = 0; re < x; re++) {
                    for (var se = 0; se < x; se++) {
                      var ve = Math.min(this.bitmap.width - 1, Math.max(0, se + N - E)), ce = Math.min(this.bitmap.height - 1, Math.max(0, re + B - E)), be = z[re][se], Me = ce * this.bitmap.width + ve << 2;
                      U += this.bitmap.data[Me] * be, V += this.bitmap.data[Me + 1] * be, W += this.bitmap.data[Me + 2] * be, q += this.bitmap.data[Me + 3] * be, Y += be;
                    }
                    var xe = B * this.bitmap.width + N << 2;
                    this.bitmap.data[xe] = Math.round(U / Y), this.bitmap.data[xe + 1] = Math.round(V / Y), this.bitmap.data[xe + 2] = Math.round(W / Y), this.bitmap.data[xe + 3] = Math.round(q / Y);
                  }
              return (0, Q.isNodePattern)(M) && M.call(this, null, this), this;
            }
          };
        };
        $.default = r, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 214: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils"), r = function() {
          return {
            invert: function(P) {
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(M, E, x) {
                this.bitmap.data[x] = 255 - this.bitmap.data[x], this.bitmap.data[x + 1] = 255 - this.bitmap.data[x + 1], this.bitmap.data[x + 2] = 255 - this.bitmap.data[x + 2];
              }), (0, Q.isNodePattern)(P) && P.call(this, null, this), this;
            }
          };
        };
        $.default = r, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 215: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils"), r = function() {
          return {
            mask: function(P) {
              var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, x = arguments.length > 3 ? arguments[3] : void 0;
              if (!(P instanceof this.constructor))
                return Q.throwError.call(this, "The source must be a Jimp image", x);
              if (typeof M != "number" || typeof E != "number")
                return Q.throwError.call(this, "x and y must be numbers", x);
              M = Math.round(M), E = Math.round(E);
              var m = this.bitmap.width, I = this.bitmap.height, z = this;
              return P.scanQuiet(0, 0, P.bitmap.width, P.bitmap.height, function(w, C, b) {
                var B = M + w, N = E + C;
                if (B >= 0 && N >= 0 && B < m && N < I) {
                  var U = z.getPixelIndex(B, N), V = this.bitmap.data, W = (V[b + 0] + V[b + 1] + V[b + 2]) / 3;
                  z.bitmap.data[U + 3] *= W / 255;
                }
              }), (0, Q.isNodePattern)(x) && x.call(this, null, this), this;
            }
          };
        };
        $.default = r, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 216: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils");
        function r() {
          var M = {
            r: new Array(256).fill(0),
            g: new Array(256).fill(0),
            b: new Array(256).fill(0)
          };
          return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(E, x, m) {
            M.r[this.bitmap.data[m + 0]]++, M.g[this.bitmap.data[m + 1]]++, M.b[this.bitmap.data[m + 2]]++;
          }), M;
        }
        var F = function(E, x, m) {
          return (E - x) * 255 / (m - x);
        }, H = function(E) {
          return [E.findIndex(function(x) {
            return x > 0;
          }), 255 - E.slice().reverse().findIndex(function(x) {
            return x > 0;
          })];
        }, P = function() {
          return {
            normalize: function(x) {
              var m = r.call(this), I = {
                r: H(m.r),
                g: H(m.g),
                b: H(m.b)
              };
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(z, w, C) {
                var b = this.bitmap.data[C + 0], B = this.bitmap.data[C + 1], N = this.bitmap.data[C + 2];
                this.bitmap.data[C + 0] = F(b, I.r[0], I.r[1]), this.bitmap.data[C + 1] = F(B, I.g[0], I.g[1]), this.bitmap.data[C + 2] = F(N, I.b[0], I.b[1]);
              }), (0, Q.isNodePattern)(x) && x.call(this, null, this), this;
            }
          };
        };
        $.default = P, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 217: [function(te, Ee, $) {
        (function(Q) {
          var r = te("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty($, "__esModule", {
            value: !0
          }), $.default = void 0;
          var F = r(te("@babel/runtime/helpers/typeof")), H = r(te("@babel/runtime/helpers/toConsumableArray")), P = r(te("path")), M = r(te("load-bmfont")), E = te("@jimp/utils"), x = te("./measure-text");
          function m(N, U, V, W, q) {
            return q === N.HORIZONTAL_ALIGN_LEFT ? 0 : q === N.HORIZONTAL_ALIGN_CENTER ? (W - (0, x.measureText)(U, V)) / 2 : W - (0, x.measureText)(U, V);
          }
          function I(N, U, V, W, q) {
            if (q.width > 0 && q.height > 0) {
              var Y = U.pages[q.page];
              N.blit(Y, V + q.xoffset, W + q.yoffset, q.x, q.y, q.width, q.height);
            }
            return N;
          }
          function z(N, U, V, W, q) {
            for (var Y = 0; Y < W.length; Y++) {
              var re = void 0;
              N.chars[W[Y]] ? re = W[Y] : /\s/.test(W[Y]) ? re = "" : re = "?";
              var se = N.chars[re] || {}, ve = N.kernings[re];
              I(this, N, U, V, se || {});
              var ce = ve && ve[W[Y + 1]] ? ve[W[Y + 1]] : 0;
              U += ce + (se.xadvance || q);
            }
          }
          function w(N, U, V) {
            var W = U.split(" "), q = [], Y = [], re = 0;
            return W.forEach(function(se) {
              var ve = [].concat((0, H.default)(Y), [se]).join(" "), ce = (0, x.measureText)(N, ve);
              ce <= V ? (ce > re && (re = ce), Y.push(se)) : (q.push(Y), Y = [se]);
            }), q.push(Y), {
              lines: q,
              longestLine: re
            };
          }
          function C(N, U, V) {
            var W = V.map(function(q) {
              return N.read(U + "/" + q);
            });
            return Promise.all(W);
          }
          var b = "browser/lib/", B = function() {
            return {
              constants: {
                measureText: x.measureText,
                measureTextHeight: x.measureTextHeight,
                FONT_SANS_8_BLACK: P.default.join(b, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"),
                FONT_SANS_10_BLACK: P.default.join(b, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"),
                FONT_SANS_12_BLACK: P.default.join(b, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"),
                FONT_SANS_14_BLACK: P.default.join(b, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"),
                FONT_SANS_16_BLACK: P.default.join(b, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"),
                FONT_SANS_32_BLACK: P.default.join(b, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"),
                FONT_SANS_64_BLACK: P.default.join(b, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"),
                FONT_SANS_128_BLACK: P.default.join(b, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"),
                FONT_SANS_8_WHITE: P.default.join(b, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"),
                FONT_SANS_16_WHITE: P.default.join(b, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"),
                FONT_SANS_32_WHITE: P.default.join(b, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"),
                FONT_SANS_64_WHITE: P.default.join(b, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"),
                FONT_SANS_128_WHITE: P.default.join(b, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"),
                /**
                 * Loads a bitmap font from a file
                 * @param {string} file the file path of a .fnt file
                 * @param {function(Error, Jimp)} cb (optional) a function to call when the font is loaded
                 * @returns {Promise} a promise
                 */
                loadFont: function(V, W) {
                  var q = this;
                  return typeof V != "string" ? E.throwError.call(this, "file must be a string", W) : new Promise(function(Y, re) {
                    W = W || function(se, ve) {
                      se ? re(se) : Y(ve);
                    }, (0, M.default)(V, function(se, ve) {
                      var ce = {}, be = {};
                      if (se)
                        return E.throwError.call(q, se, W);
                      for (var Me = 0; Me < ve.chars.length; Me++)
                        ce[String.fromCharCode(ve.chars[Me].id)] = ve.chars[Me];
                      for (var xe = 0; xe < ve.kernings.length; xe++) {
                        var le = String.fromCharCode(ve.kernings[xe].first);
                        be[le] = be[le] || {}, be[le][String.fromCharCode(ve.kernings[xe].second)] = ve.kernings[xe].amount;
                      }
                      C(q, P.default.dirname(V), ve.pages).then(function(de) {
                        W(null, {
                          chars: ce,
                          kernings: be,
                          pages: de,
                          common: ve.common,
                          info: ve.info
                        });
                      });
                    });
                  });
                }
              },
              class: {
                /**
                 * Draws a text on a image on a given boundary
                 * @param {Jimp} font a bitmap font loaded from `Jimp.loadFont` command
                 * @param {number} x the x position to start drawing the text
                 * @param {number} y the y position to start drawing the text
                 * @param {any} text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)
                 * @param {number} maxWidth (optional) the boundary width to draw in
                 * @param {number} maxHeight (optional) the boundary height to draw in
                 * @param {function(Error, Jimp)} cb (optional) a function to call when the text is written
                 * @returns {Jimp} this for chaining of methods
                 */
                print: function(V, W, q, Y, re, se, ve) {
                  var ce = this;
                  if (typeof re == "function" && typeof ve > "u" && (ve = re, re = 1 / 0), typeof re > "u" && (re = 1 / 0), typeof se == "function" && typeof ve > "u" && (ve = se, se = 1 / 0), typeof se > "u" && (se = 1 / 0), (0, F.default)(V) !== "object")
                    return E.throwError.call(this, "font must be a Jimp loadFont", ve);
                  if (typeof W != "number" || typeof q != "number" || typeof re != "number")
                    return E.throwError.call(this, "x, y and maxWidth must be numbers", ve);
                  if (typeof re != "number")
                    return E.throwError.call(this, "maxWidth must be a number", ve);
                  if (typeof se != "number")
                    return E.throwError.call(this, "maxHeight must be a number", ve);
                  var be, Me;
                  if ((0, F.default)(Y) === "object" && Y.text !== null && Y.text !== void 0) {
                    be = Y.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT, Me = Y.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;
                    var xe = Y;
                    Y = xe.text;
                  } else
                    be = this.constructor.HORIZONTAL_ALIGN_LEFT, Me = this.constructor.VERTICAL_ALIGN_TOP, Y = Y.toString();
                  se !== 1 / 0 && Me === this.constructor.VERTICAL_ALIGN_BOTTOM ? q += se - (0, x.measureTextHeight)(V, Y, re) : se !== 1 / 0 && Me === this.constructor.VERTICAL_ALIGN_MIDDLE && (q += se / 2 - (0, x.measureTextHeight)(V, Y, re) / 2);
                  var le = Object.entries(V.chars)[0][1].xadvance, de = w(V, Y, re), De = de.lines, ze = de.longestLine;
                  return De.forEach(function(Ze) {
                    var Ue = Ze.join(" "), Ie = m(ce.constructor, V, Ue, re, be);
                    z.call(ce, V, W + Ie, q, Ue, le), q += V.common.lineHeight;
                  }), (0, E.isNodePattern)(ve) && ve.call(this, null, this, {
                    x: W + ze,
                    y: q
                  }), this;
                }
              }
            };
          };
          $.default = B, Ee.exports = $.default;
        }).call(this, "/../../node_modules/@jimp/plugin-print/dist");
      }, { "./measure-text": 218, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, "load-bmfont": 219, path: 107 }], 218: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.measureText = Q, $.measureTextHeight = r;
        function Q(F, H) {
          for (var P = 0, M = 0; M < H.length; M++)
            if (F.chars[H[M]]) {
              var E = F.kernings[H[M]] && F.kernings[H[M]][H[M + 1]] ? F.kernings[H[M]][H[M + 1]] : 0;
              P += (F.chars[H[M]].xadvance || 0) + E;
            }
          return P;
        }
        function r(F, H, P) {
          for (var M = H.split(" "), E = "", x = F.common.lineHeight, m = 0; m < M.length; m++) {
            var I = E + M[m] + " ", z = Q(F, I);
            z > P && m > 0 ? (x += F.common.lineHeight, E = M[m] + " ") : E = I;
          }
          return x;
        }
      }, {}], 219: [function(te, Ee, $) {
        (function(Q) {
          var r = te("xhr"), F = function() {
          }, H = te("parse-bmfont-ascii"), P = te("parse-bmfont-xml"), M = te("parse-bmfont-binary"), E = te("./lib/is-binary"), x = te("xtend"), m = function() {
            return self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
          }();
          Ee.exports = function(w, C) {
            C = typeof C == "function" ? C : F, typeof w == "string" ? w = { uri: w } : w || (w = {});
            var b = w.binary;
            b && (w = z(w)), r(w, function(B, N, U) {
              if (B)
                return C(B);
              if (!/^2/.test(N.statusCode))
                return C(new Error("http status code: " + N.statusCode));
              if (!U)
                return C(new Error("no body result"));
              var V = !1;
              if (I(U)) {
                var W = new Uint8Array(U);
                U = new Q(W, "binary");
              }
              E(U) && (V = !0, typeof U == "string" && (U = new Q(U, "binary"))), V || (Q.isBuffer(U) && (U = U.toString(w.encoding)), U = U.trim());
              var q;
              try {
                var Y = N.headers["content-type"];
                V ? q = M(U) : /json/.test(Y) || U.charAt(0) === "{" ? q = JSON.parse(U) : /xml/.test(Y) || U.charAt(0) === "<" ? q = P(U) : q = H(U);
              } catch (re) {
                C(new Error("error parsing font " + re.message)), C = F;
              }
              C(null, q);
            });
          };
          function I(w) {
            var C = Object.prototype.toString;
            return C.call(w) === "[object ArrayBuffer]";
          }
          function z(w) {
            if (m)
              return x(w, { responseType: "arraybuffer" });
            if (typeof self.XMLHttpRequest > "u")
              throw new Error("your browser does not support XHR loading");
            var C = new self.XMLHttpRequest();
            return C.overrideMimeType("text/plain; charset=x-user-defined"), x({
              xhr: C
            }, w);
          }
        }).call(this, te("buffer").Buffer);
      }, { "./lib/is-binary": 220, buffer: 48, "parse-bmfont-ascii": 102, "parse-bmfont-binary": 103, "parse-bmfont-xml": 104, xhr: 187, xtend: 189 }], 220: [function(te, Ee, $) {
        (function(Q) {
          var r = te("buffer-equal"), F = new Q([66, 77, 70, 3]);
          Ee.exports = function(H) {
            return typeof H == "string" ? H.substring(0, 3) === "BMF" : H.length > 4 && r(H.slice(0, 4), F);
          };
        }).call(this, te("buffer").Buffer);
      }, { buffer: 48, "buffer-equal": 49 }], 221: [function(te, Ee, $) {
        (function(Q) {
          var r = te("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty($, "__esModule", {
            value: !0
          }), $.default = void 0;
          var F = te("@jimp/utils"), H = r(te("./modules/resize")), P = r(te("./modules/resize2")), M = function() {
            return {
              constants: {
                RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor",
                RESIZE_BILINEAR: "bilinearInterpolation",
                RESIZE_BICUBIC: "bicubicInterpolation",
                RESIZE_HERMITE: "hermiteInterpolation",
                RESIZE_BEZIER: "bezierInterpolation"
              },
              class: {
                /**
                 * Resizes the image to a set width and height using a 2-pass bilinear algorithm
                 * @param {number} w the width to resize the image to (or Jimp.AUTO)
                 * @param {number} h the height to resize the image to (or Jimp.AUTO)
                 * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
                 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
                 * @returns {Jimp} this for chaining of methods
                 */
                resize: function(m, I, z, w) {
                  if (typeof m != "number" || typeof I != "number")
                    return F.throwError.call(this, "w and h must be numbers", w);
                  if (typeof z == "function" && typeof w > "u" && (w = z, z = null), m === this.constructor.AUTO && I === this.constructor.AUTO)
                    return F.throwError.call(this, "w and h cannot both be set to auto", w);
                  if (m === this.constructor.AUTO && (m = this.bitmap.width * (I / this.bitmap.height)), I === this.constructor.AUTO && (I = this.bitmap.height * (m / this.bitmap.width)), m < 0 || I < 0)
                    return F.throwError.call(this, "w and h must be positive numbers", w);
                  if (m = Math.round(m), I = Math.round(I), typeof P.default[z] == "function") {
                    var C = {
                      data: Q.alloc(m * I * 4),
                      width: m,
                      height: I
                    };
                    P.default[z](this.bitmap, C), this.bitmap = C;
                  } else {
                    var b = this, B = new H.default(this.bitmap.width, this.bitmap.height, m, I, !0, !0, function(N) {
                      b.bitmap.data = Q.from(N), b.bitmap.width = m, b.bitmap.height = I;
                    });
                    B.resize(this.bitmap.data);
                  }
                  return (0, F.isNodePattern)(w) && w.call(this, null, this), this;
                }
              }
            };
          };
          $.default = M, Ee.exports = $.default;
        }).call(this, te("buffer").Buffer);
      }, { "./modules/resize": 222, "./modules/resize2": 223, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, buffer: 48 }], 222: [function(te, Ee, $) {
        function Q(r, F, H, P, M, E, x) {
          this.widthOriginal = Math.abs(Math.floor(r) || 0), this.heightOriginal = Math.abs(Math.floor(F) || 0), this.targetWidth = Math.abs(Math.floor(H) || 0), this.targetHeight = Math.abs(Math.floor(P) || 0), this.colorChannels = M ? 4 : 3, this.interpolationPass = !!E, this.resizeCallback = typeof x == "function" ? x : function() {
          }, this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels, this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels, this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels, this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal, this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight, this.initialize();
        }
        Q.prototype.initialize = function() {
          if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0)
            this.configurePasses();
          else
            throw new Error("Invalid settings specified for the resizer.");
        }, Q.prototype.configurePasses = function() {
          this.widthOriginal === this.targetWidth ? this.resizeWidth = this.bypassResizer : (this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth, this.ratioWeightWidthPass < 1 && this.interpolationPass ? (this.initializeFirstPassBuffers(!0), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB) : (this.initializeFirstPassBuffers(!1), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB)), this.heightOriginal === this.targetHeight ? this.resizeHeight = this.bypassResizer : (this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight, this.ratioWeightHeightPass < 1 && this.interpolationPass ? (this.initializeSecondPassBuffers(!0), this.resizeHeight = this.resizeHeightInterpolated) : (this.initializeSecondPassBuffers(!1), this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB));
        }, Q.prototype._resizeWidthInterpolatedRGBChannels = function(r, F) {
          var H = F ? 4 : 3, P = this.ratioWeightWidthPass, M = this.widthBuffer, E = 0, x = 0, m = 0, I = 0, z = 0, w;
          for (w = 0; E < 1 / 3; w += H, E += P)
            for (x = w, m = 0; x < this.widthPassResultSize; m += this.originalWidthMultipliedByChannels, x += this.targetWidthMultipliedByChannels)
              M[x] = r[m], M[x + 1] = r[m + 1], M[x + 2] = r[m + 2], F && (M[x + 3] = r[m + 3]);
          E -= 1 / 3;
          var C;
          for (C = this.widthOriginal - 1; E < C; w += H, E += P)
            for (z = E % 1, I = 1 - z, x = w, m = Math.floor(E) * H; x < this.widthPassResultSize; m += this.originalWidthMultipliedByChannels, x += this.targetWidthMultipliedByChannels)
              M[x + 0] = r[m + 0] * I + r[m + H + 0] * z, M[x + 1] = r[m + 1] * I + r[m + H + 1] * z, M[x + 2] = r[m + 2] * I + r[m + H + 2] * z, F && (M[x + 3] = r[m + 3] * I + r[m + H + 3] * z);
          for (C = this.originalWidthMultipliedByChannels - H; w < this.targetWidthMultipliedByChannels; w += H)
            for (x = w, m = C; x < this.widthPassResultSize; m += this.originalWidthMultipliedByChannels, x += this.targetWidthMultipliedByChannels)
              M[x] = r[m], M[x + 1] = r[m + 1], M[x + 2] = r[m + 2], F && (M[x + 3] = r[m + 3]);
          return M;
        }, Q.prototype._resizeWidthRGBChannels = function(r, F) {
          var H = F ? 4 : 3, P = this.ratioWeightWidthPass, M = 1 / P, E = this.originalWidthMultipliedByChannels - H + 1, x = this.targetWidthMultipliedByChannels - H + 1, m = this.outputWidthWorkBench, I = this.widthBuffer, z = this.outputWidthWorkBenchOpaquePixelsCount, w = 0, C = 0, b = 0, B = 0, N = 0, U = 0, V = 0, W = 1, q = 0, Y = 0, re = 0, se = 0;
          do {
            for (N = 0; N < this.originalHeightMultipliedByChannels; )
              m[N++] = 0, m[N++] = 0, m[N++] = 0, F && (m[N++] = 0, z[N / H - 1] = 0);
            w = P;
            do {
              for (C = 1 + b - B, W = Math.min(w, C), N = 0, U = b; N < this.originalHeightMultipliedByChannels; U += E)
                q = r[U], Y = r[++U], re = r[++U], se = F ? r[++U] : 255, m[N++] += (se ? q : 0) * W, m[N++] += (se ? Y : 0) * W, m[N++] += (se ? re : 0) * W, F && (m[N++] += se * W, z[N / H - 1] += se ? W : 0);
              if (w >= C)
                b += H, B = b, w -= C;
              else {
                B += w;
                break;
              }
            } while (w > 0 && b < this.originalWidthMultipliedByChannels);
            for (N = 0, U = V; N < this.originalHeightMultipliedByChannels; U += x)
              w = F ? z[N / H] : 1, W = F ? w ? 1 / w : 0 : M, I[U] = m[N++] * W, I[++U] = m[N++] * W, I[++U] = m[N++] * W, F && (I[++U] = m[N++] * M);
            V += H;
          } while (V < this.targetWidthMultipliedByChannels);
          return I;
        }, Q.prototype._resizeHeightRGBChannels = function(r, F) {
          var H = this.ratioWeightHeightPass, P = 1 / H, M = this.outputHeightWorkBench, E = this.heightBuffer, x = this.outputHeightWorkBenchOpaquePixelsCount, m = 0, I = 0, z = 0, w = 0, C = 0, b = 0, B = 0, N = 1, U = 0, V = 0, W = 0, q = 0;
          do {
            for (C = 0; C < this.targetWidthMultipliedByChannels; )
              M[C++] = 0, M[C++] = 0, M[C++] = 0, F && (M[C++] = 0, x[C / 4 - 1] = 0);
            m = H;
            do {
              for (I = 1 + z - w, N = Math.min(m, I), B = z, C = 0; C < this.targetWidthMultipliedByChannels; )
                U = r[B++], V = r[B++], W = r[B++], q = F ? r[B++] : 255, M[C++] += (q ? U : 0) * N, M[C++] += (q ? V : 0) * N, M[C++] += (q ? W : 0) * N, F && (M[C++] += q * N, x[C / 4 - 1] += q ? N : 0);
              if (m >= I)
                z = B, w = z, m -= I;
              else {
                w += m;
                break;
              }
            } while (m > 0 && z < this.widthPassResultSize);
            for (C = 0; C < this.targetWidthMultipliedByChannels; )
              m = F ? x[C / 4] : 1, N = F ? m ? 1 / m : 0 : P, E[b++] = Math.round(M[C++] * N), E[b++] = Math.round(M[C++] * N), E[b++] = Math.round(M[C++] * N), F && (E[b++] = Math.round(M[C++] * P));
          } while (b < this.finalResultSize);
          return E;
        }, Q.prototype.resizeWidthInterpolatedRGB = function(r) {
          return this._resizeWidthInterpolatedRGBChannels(r, !1);
        }, Q.prototype.resizeWidthInterpolatedRGBA = function(r) {
          return this._resizeWidthInterpolatedRGBChannels(r, !0);
        }, Q.prototype.resizeWidthRGB = function(r) {
          return this._resizeWidthRGBChannels(r, !1);
        }, Q.prototype.resizeWidthRGBA = function(r) {
          return this._resizeWidthRGBChannels(r, !0);
        }, Q.prototype.resizeHeightInterpolated = function(r) {
          for (var F = this.ratioWeightHeightPass, H = this.heightBuffer, P = 0, M = 0, E = 0, x = 0, m = 0, I = 0, z = 0, w; P < 1 / 3; P += F)
            for (E = 0; E < this.targetWidthMultipliedByChannels; )
              H[M++] = Math.round(r[E++]);
          for (P -= 1 / 3, w = this.heightOriginal - 1; P < w; P += F)
            for (z = P % 1, I = 1 - z, x = Math.floor(P) * this.targetWidthMultipliedByChannels, m = x + this.targetWidthMultipliedByChannels, E = 0; E < this.targetWidthMultipliedByChannels; ++E)
              H[M++] = Math.round(r[x++] * I + r[m++] * z);
          for (; M < this.finalResultSize; )
            for (E = 0, x = w * this.targetWidthMultipliedByChannels; E < this.targetWidthMultipliedByChannels; ++E)
              H[M++] = Math.round(r[x++]);
          return H;
        }, Q.prototype.resizeHeightRGB = function(r) {
          return this._resizeHeightRGBChannels(r, !1);
        }, Q.prototype.resizeHeightRGBA = function(r) {
          return this._resizeHeightRGBChannels(r, !0);
        }, Q.prototype.resize = function(r) {
          this.resizeCallback(this.resizeHeight(this.resizeWidth(r)));
        }, Q.prototype.bypassResizer = function(r) {
          return r;
        }, Q.prototype.initializeFirstPassBuffers = function(r) {
          this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize), r || (this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels), this.colorChannels > 3 && (this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal)));
        }, Q.prototype.initializeSecondPassBuffers = function(r) {
          this.heightBuffer = this.generateUint8Buffer(this.finalResultSize), r || (this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels), this.colorChannels > 3 && (this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth)));
        }, Q.prototype.generateFloatBuffer = function(r) {
          try {
            return new Float32Array(r);
          } catch {
            return [];
          }
        }, Q.prototype.generateFloat64Buffer = function(r) {
          try {
            return new Float64Array(r);
          } catch {
            return [];
          }
        }, Q.prototype.generateUint8Buffer = function(r) {
          try {
            return new Uint8Array(r);
          } catch {
            return [];
          }
        }, Ee.exports = Q;
      }, {}], 223: [function(te, Ee, $) {
        (function(Q) {
          Ee.exports = {
            nearestNeighbor: function(F, H) {
              for (var P = F.width, M = F.height, E = H.width, x = H.height, m = F.data, I = H.data, z = 0; z < x; z++)
                for (var w = 0; w < E; w++) {
                  var C = (z * E + w) * 4, b = Math.floor(z * M / x), B = Math.floor(w * P / E), N = (b * P + B) * 4;
                  I[C++] = m[N++], I[C++] = m[N++], I[C++] = m[N++], I[C++] = m[N++];
                }
            },
            bilinearInterpolation: function(F, H) {
              for (var P = F.width, M = F.height, E = H.width, x = H.height, m = F.data, I = H.data, z = function(se, ve, ce, be, Me) {
                return ve === be ? ce : Math.round((se - ve) * Me + (be - se) * ce);
              }, w = function(se, ve, ce, be, Me, xe, le, de) {
                var De = (le * P + be) * 4 + ve, ze = (le * P + Me) * 4 + ve, Ze = z(ce, be, m[De], Me, m[ze]);
                if (de === le)
                  I[se + ve] = Ze;
                else {
                  De = (de * P + be) * 4 + ve, ze = (de * P + Me) * 4 + ve;
                  var Ue = z(ce, be, m[De], Me, m[ze]);
                  I[se + ve] = z(xe, le, Ze, de, Ue);
                }
              }, C = 0; C < x; C++)
                for (var b = 0; b < E; b++) {
                  var B = (C * E + b) * 4, N = b * P / E, U = Math.floor(N), V = Math.min(Math.ceil(N), P - 1), W = C * M / x, q = Math.floor(W), Y = Math.min(Math.ceil(W), M - 1);
                  w(B, 0, N, U, V, W, q, Y), w(B, 1, N, U, V, W, q, Y), w(B, 2, N, U, V, W, q, Y), w(B, 3, N, U, V, W, q, Y);
                }
            },
            _interpolate2D: function(F, H, P, M) {
              for (var E = F.data, x = H.data, m = F.width, I = F.height, z = H.width, w = H.height, C = Math.max(1, Math.floor(m / z)), b = z * C, B = Math.max(1, Math.floor(I / w)), N = w * B, U = Q.alloc(b * I * 4), V = 0; V < I; V++)
                for (var W = 0; W < b; W++)
                  for (var q = W * (m - 1) / b, Y = Math.floor(q), re = q - Y, se = (V * m + Y) * 4, ve = (V * b + W) * 4, ce = 0; ce < 4; ce++) {
                    var be = se + ce, Me = Y > 0 ? E[be - 4] : 2 * E[be] - E[be + 4], xe = E[be], le = E[be + 4], de = Y < m - 2 ? E[be + 8] : 2 * E[be + 4] - E[be];
                    U[ve + ce] = M(Me, xe, le, de, re);
                  }
              for (var De = Q.alloc(b * N * 4), ze = 0; ze < N; ze++)
                for (var Ze = 0; Ze < b; Ze++)
                  for (var Ue = ze * (I - 1) / N, Ie = Math.floor(Ue), je = Ue - Ie, Fe = (Ie * b + Ze) * 4, $e = (ze * b + Ze) * 4, ct = 0; ct < 4; ct++) {
                    var wt = Fe + ct, Oe = Ie > 0 ? U[wt - b * 4] : 2 * U[wt] - U[wt + b * 4], Ct = U[wt], Xt = U[wt + b * 4], vt = Ie < I - 2 ? U[wt + b * 8] : 2 * U[wt + b * 4] - U[wt];
                    De[$e + ct] = M(Oe, Ct, Xt, vt, je);
                  }
              var Ye = C * B;
              if (Ye > 1)
                for (var qe = 0; qe < w; qe++)
                  for (var rt = 0; rt < z; rt++) {
                    for (var it = 0, Ae = 0, _e = 0, fe = 0, We = 0, Pe = 0; Pe < B; Pe++)
                      for (var he = qe * B + Pe, ie = 0; ie < C; ie++) {
                        var Xe = rt * C + ie, bt = (he * b + Xe) * 4, Wt = De[bt + 3];
                        Wt && (it += De[bt], Ae += De[bt + 1], _e += De[bt + 2], We++), fe += Wt;
                      }
                    var Qt = (qe * z + rt) * 4;
                    x[Qt] = We ? Math.round(it / We) : 0, x[Qt + 1] = We ? Math.round(Ae / We) : 0, x[Qt + 2] = We ? Math.round(_e / We) : 0, x[Qt + 3] = Math.round(fe / Ye);
                  }
              else
                H.data = De;
            },
            bicubicInterpolation: function(F, H, P) {
              var M = function(x, m, I, z, w) {
                var C = z - I - x + m, b = x - m - C, B = I - x, N = m;
                return Math.max(0, Math.min(255, C * (w * w * w) + b * (w * w) + B * w + N));
              };
              return this._interpolate2D(F, H, P, M);
            },
            hermiteInterpolation: function(F, H, P) {
              var M = function(x, m, I, z, w) {
                var C = m, b = 0.5 * (I - x), B = x - 2.5 * m + 2 * I - 0.5 * z, N = 0.5 * (z - x) + 1.5 * (m - I);
                return Math.max(0, Math.min(255, Math.round(((N * w + B) * w + b) * w + C)));
              };
              return this._interpolate2D(F, H, P, M);
            },
            bezierInterpolation: function(F, H, P) {
              var M = function(x, m, I, z, w) {
                var C = m + (I - x) / 4, b = I - (z - m) / 4, B = 1 - w, N = m * B * B * B, U = 3 * C * B * B * w, V = 3 * b * B * w * w, W = I * w * w * w;
                return Math.max(0, Math.min(255, Math.round(N + U + V + W)));
              };
              return this._interpolate2D(F, H, P, M);
            }
          };
        }).call(this, te("buffer").Buffer);
      }, { buffer: 48 }], 224: [function(te, Ee, $) {
        (function(Q) {
          Object.defineProperty($, "__esModule", {
            value: !0
          }), $.default = void 0;
          var r = te("@jimp/utils");
          function F(P, M) {
            P %= 360;
            var E = P * Math.PI / 180, x = Math.cos(E), m = Math.sin(E), I = this.bitmap.width, z = this.bitmap.height;
            if (M === !0 || typeof M == "string") {
              I = Math.ceil(Math.abs(this.bitmap.width * x) + Math.abs(this.bitmap.height * m)) + 1, z = Math.ceil(Math.abs(this.bitmap.width * m) + Math.abs(this.bitmap.height * x)) + 1, I % 2 !== 0 && I++, z % 2 !== 0 && z++;
              var w = this.cloneQuiet();
              this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(le, de, De) {
                this.bitmap.data.writeUInt32BE(this._background, De);
              });
              var C = Math.max(I, z, this.bitmap.width, this.bitmap.height);
              this.resize(C, C, M), this.blit(w, this.bitmap.width / 2 - w.bitmap.width / 2, this.bitmap.height / 2 - w.bitmap.height / 2);
            }
            var b = this.bitmap.width, B = this.bitmap.height, N = Q.alloc(this.bitmap.data.length);
            function U(le, de) {
              return function(De, ze) {
                return {
                  x: De + le,
                  y: ze + de
                };
              };
            }
            for (var V = U(-(b / 2), -(B / 2)), W = U(b / 2 + 0.5, B / 2 + 0.5), q = 1; q <= B; q++)
              for (var Y = 1; Y <= b; Y++) {
                var re = V(Y, q), se = W(x * re.x - m * re.y, x * re.y + m * re.x), ve = b * (q - 1) + Y - 1 << 2;
                if (se.x >= 0 && se.x < b && se.y >= 0 && se.y < B) {
                  var ce = (b * (se.y | 0) + se.x | 0) << 2, be = this.bitmap.data.readUInt32BE(ce);
                  N.writeUInt32BE(be, ve);
                } else
                  N.writeUInt32BE(this._background, ve);
              }
            if (this.bitmap.data = N, M === !0 || typeof M == "string") {
              var Me = b / 2 - I / 2, xe = B / 2 - z / 2;
              this.crop(Me, xe, I, z);
            }
          }
          var H = function() {
            return {
              /**
               * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.
               * @param {number} deg the number of degrees to rotate the image by
               * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              rotate: function(E, x, m) {
                return (typeof x > "u" || x === null) && (x = !0), typeof x == "function" && typeof m > "u" && (m = x, x = !0), typeof E != "number" ? r.throwError.call(this, "deg must be a number", m) : typeof x != "boolean" && typeof x != "string" ? r.throwError.call(this, "mode must be a boolean or a string", m) : (F.call(this, E, x, m), (0, r.isNodePattern)(m) && m.call(this, null, this), this);
              }
            };
          };
          $.default = H, Ee.exports = $.default;
        }).call(this, te("buffer").Buffer);
      }, { "@jimp/utils": 235, buffer: 48 }], 225: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils"), r = function() {
          return {
            /**
             * Uniformly scales the image by a factor.
             * @param {number} f the factor to scale the image by
             * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            scale: function(P, M, E) {
              if (typeof P != "number")
                return Q.throwError.call(this, "f must be a number", E);
              if (P < 0)
                return Q.throwError.call(this, "f must be a positive number", E);
              typeof M == "function" && typeof E > "u" && (E = M, M = null);
              var x = this.bitmap.width * P, m = this.bitmap.height * P;
              return this.resize(x, m, M), (0, Q.isNodePattern)(E) && E.call(this, null, this), this;
            },
            /**
             * Scale the image to the largest size that fits inside the rectangle that has the given width and height.
             * @param {number} w the width to resize the image to
             * @param {number} h the height to resize the image to
             * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            scaleToFit: function(P, M, E, x) {
              if (typeof P != "number" || typeof M != "number")
                return Q.throwError.call(this, "w and h must be numbers", x);
              typeof E == "function" && typeof x > "u" && (x = E, E = null);
              var m = P / M > this.bitmap.width / this.bitmap.height ? M / this.bitmap.height : P / this.bitmap.width;
              return this.scale(m, E), (0, Q.isNodePattern)(x) && x.call(this, null, this), this;
            }
          };
        };
        $.default = r, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 226: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils"), r = function() {
          return {
            shadow: function() {
              var P = this, M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, E = arguments.length > 1 ? arguments[1] : void 0;
              typeof M == "function" && (E = M, M = {});
              var x = M, m = x.opacity, I = m === void 0 ? 0.7 : m, z = x.size, w = z === void 0 ? 1.1 : z, C = x.x, b = C === void 0 ? -25 : C, B = x.y, N = B === void 0 ? 25 : B, U = x.blur, V = U === void 0 ? 5 : U, W = this.clone(), q = this.clone();
              return q.scan(0, 0, q.bitmap.width, q.bitmap.height, function(Y, re, se) {
                q.bitmap.data[se] = 0, q.bitmap.data[se + 1] = 0, q.bitmap.data[se + 2] = 0, q.bitmap.data[se + 3] = q.constructor.limit255(q.bitmap.data[se + 3] * I), P.bitmap.data[se] = 0, P.bitmap.data[se + 1] = 0, P.bitmap.data[se + 2] = 0, P.bitmap.data[se + 3] = 0;
              }), q.resize(q.bitmap.width * w, q.bitmap.height * w).blur(V), this.composite(q, b, N), this.composite(W, 0, 0), (0, Q.isNodePattern)(E) && E.call(this, null, this), this;
            }
          };
        };
        $.default = r, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 227: [function(te, Ee, $) {
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var Q = te("@jimp/utils"), r = function() {
          return {
            threshold: function(P, M) {
              var E = this, x = P.max, m = P.replace, I = m === void 0 ? 255 : m, z = P.autoGreyscale, w = z === void 0 ? !0 : z;
              return typeof x != "number" ? Q.throwError.call(this, "max must be a number", M) : typeof I != "number" ? Q.throwError.call(this, "replace must be a number", M) : typeof w != "boolean" ? Q.throwError.call(this, "autoGreyscale must be a boolean", M) : (x = this.constructor.limit255(x), I = this.constructor.limit255(I), w && this.greyscale(), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(C, b, B) {
                var N = E.bitmap.data[B] < x ? E.bitmap.data[B] : I;
                E.bitmap.data[B] = N, E.bitmap.data[B + 1] = N, E.bitmap.data[B + 2] = N;
              }), (0, Q.isNodePattern)(M) && M.call(this, null, this), this);
            }
          };
        };
        $.default = r, Ee.exports = $.default;
      }, { "@jimp/utils": 235 }], 228: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var r = Q(te("@babel/runtime/helpers/toConsumableArray")), F = te("timm"), H = Q(te("@jimp/plugin-blit")), P = Q(te("@jimp/plugin-blur")), M = Q(te("@jimp/plugin-circle")), E = Q(te("@jimp/plugin-color")), x = Q(te("@jimp/plugin-contain")), m = Q(te("@jimp/plugin-cover")), I = Q(te("@jimp/plugin-crop")), z = Q(te("@jimp/plugin-displace")), w = Q(te("@jimp/plugin-dither")), C = Q(te("@jimp/plugin-fisheye")), b = Q(te("@jimp/plugin-flip")), B = Q(te("@jimp/plugin-gaussian")), N = Q(te("@jimp/plugin-invert")), U = Q(te("@jimp/plugin-mask")), V = Q(te("@jimp/plugin-normalize")), W = Q(te("@jimp/plugin-print")), q = Q(te("@jimp/plugin-resize")), Y = Q(te("@jimp/plugin-rotate")), re = Q(te("@jimp/plugin-scale")), se = Q(te("@jimp/plugin-shadow")), ve = Q(te("@jimp/plugin-threshold")), ce = [H.default, P.default, M.default, E.default, x.default, m.default, I.default, z.default, w.default, C.default, b.default, B.default, N.default, U.default, V.default, W.default, q.default, Y.default, re.default, se.default, ve.default], be = function(xe) {
          var le = ce.map(function(de) {
            var De = de(xe) || {};
            return !De.class && !De.constants && (De = {
              class: De
            }), De;
          });
          return F.mergeDeep.apply(void 0, (0, r.default)(le));
        };
        $.default = be, Ee.exports = $.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/plugin-blit": 201, "@jimp/plugin-blur": 203, "@jimp/plugin-circle": 204, "@jimp/plugin-color": 205, "@jimp/plugin-contain": 206, "@jimp/plugin-cover": 207, "@jimp/plugin-crop": 208, "@jimp/plugin-displace": 209, "@jimp/plugin-dither": 210, "@jimp/plugin-fisheye": 211, "@jimp/plugin-flip": 212, "@jimp/plugin-gaussian": 213, "@jimp/plugin-invert": 214, "@jimp/plugin-mask": 215, "@jimp/plugin-normalize": 216, "@jimp/plugin-print": 217, "@jimp/plugin-resize": 221, "@jimp/plugin-rotate": 224, "@jimp/plugin-scale": 225, "@jimp/plugin-shadow": 226, "@jimp/plugin-threshold": 227, timm: 177 }], 229: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var r = Q(te("@babel/runtime/helpers/defineProperty")), F = Q(te("bmp-js")), H = te("@jimp/utils"), P = "image/bmp", M = "image/x-ms-bmp";
        function E(w) {
          return (0, H.scan)(w, 0, 0, w.bitmap.width, w.bitmap.height, function(C, b, B) {
            var N = this.bitmap.data[B + 0], U = this.bitmap.data[B + 1], V = this.bitmap.data[B + 2], W = this.bitmap.data[B + 3];
            this.bitmap.data[B + 0] = W, this.bitmap.data[B + 1] = V, this.bitmap.data[B + 2] = U, this.bitmap.data[B + 3] = N;
          }).bitmap;
        }
        function x(w) {
          return (0, H.scan)({
            bitmap: w
          }, 0, 0, w.width, w.height, function(C, b, B) {
            var N = this.bitmap.data[B + 0], U = this.bitmap.data[B + 1], V = this.bitmap.data[B + 2], W = this.bitmap.data[B + 3];
            this.bitmap.data[B + 0] = W, this.bitmap.data[B + 1] = V, this.bitmap.data[B + 2] = U, this.bitmap.data[B + 3] = w.is_with_alpha ? N : 255;
          }).bitmap;
        }
        var m = function(C) {
          return x(F.default.decode(C));
        }, I = function(C) {
          return F.default.encode(E(C)).data;
        }, z = function() {
          var C, b;
          return {
            mime: (0, r.default)({}, P, ["bmp"]),
            constants: {
              MIME_BMP: P,
              MIME_X_MS_BMP: M
            },
            decoders: (C = {}, (0, r.default)(C, P, m), (0, r.default)(C, M, m), C),
            encoders: (b = {}, (0, r.default)(b, P, I), (0, r.default)(b, M, I), b)
          };
        };
        $.default = z, Ee.exports = $.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, "bmp-js": 30 }], 230: [function(te, Ee, $) {
        (function(Q) {
          var r = te("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty($, "__esModule", {
            value: !0
          }), $.default = void 0;
          var F = r(te("@babel/runtime/helpers/defineProperty")), H = r(te("omggif")), P = te("gifwrap"), M = "image/gif", E = function() {
            return {
              mime: (0, F.default)({}, M, ["gif"]),
              constants: {
                MIME_GIF: M
              },
              decoders: (0, F.default)({}, M, function(m) {
                var I = new H.default.GifReader(m), z = Q.alloc(I.width * I.height * 4);
                return I.decodeAndBlitFrameRGBA(0, z), {
                  data: z,
                  width: I.width,
                  height: I.height
                };
              }),
              encoders: (0, F.default)({}, M, function(m) {
                var I = new P.BitmapImage(m.bitmap);
                P.GifUtil.quantizeDekker(I, 256);
                var z = new P.GifFrame(I), w = new P.GifCodec();
                return w.encodeGif([z], {}).then(function(C) {
                  return C.buffer;
                });
              })
            };
          };
          $.default = E, Ee.exports = $.default;
        }).call(this, te("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, buffer: 48, gifwrap: 70, omggif: 85 }], 231: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var r = Q(te("@babel/runtime/helpers/defineProperty")), F = Q(te("jpeg-js")), H = te("@jimp/utils"), P = "image/jpeg", M = function() {
          return {
            mime: (0, r.default)({}, P, ["jpeg", "jpg", "jpe"]),
            constants: {
              MIME_JPEG: P
            },
            decoders: (0, r.default)({}, P, F.default.decode),
            encoders: (0, r.default)({}, P, function(x) {
              return F.default.encode(x.bitmap, x._quality).data;
            }),
            class: {
              // The quality to be used when saving JPEG images
              _quality: 100,
              /**
               * Sets the quality of the image when saving as JPEG format (default is 100)
               * @param {number} n The quality to use 0-100
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              quality: function(m, I) {
                return typeof m != "number" ? H.throwError.call(this, "n must be a number", I) : m < 0 || m > 100 ? H.throwError.call(this, "n must be a number 0 - 100", I) : (this._quality = Math.round(m), (0, H.isNodePattern)(I) && I.call(this, null, this), this);
              }
            }
          };
        };
        $.default = M, Ee.exports = $.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, "jpeg-js": 80 }], 232: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var r = Q(te("@babel/runtime/helpers/defineProperty")), F = te("pngjs"), H = te("@jimp/utils"), P = "image/png", M = -1, E = 0, x = 1, m = 2, I = 3, z = 4, w = function() {
          return {
            mime: (0, r.default)({}, P, ["png"]),
            constants: {
              MIME_PNG: P,
              PNG_FILTER_AUTO: M,
              PNG_FILTER_NONE: E,
              PNG_FILTER_SUB: x,
              PNG_FILTER_UP: m,
              PNG_FILTER_AVERAGE: I,
              PNG_FILTER_PATH: z
            },
            hasAlpha: (0, r.default)({}, P, !0),
            decoders: (0, r.default)({}, P, F.PNG.sync.read),
            encoders: (0, r.default)({}, P, function(b) {
              var B = new F.PNG({
                width: b.bitmap.width,
                height: b.bitmap.height
              });
              return B.data = b.bitmap.data, F.PNG.sync.write(B, {
                width: b.bitmap.width,
                height: b.bitmap.height,
                deflateLevel: b._deflateLevel,
                deflateStrategy: b._deflateStrategy,
                filterType: b._filterType,
                colorType: typeof b._colorType == "number" ? b._colorType : b._rgba ? 6 : 2,
                inputHasAlpha: b._rgba
              });
            }),
            class: {
              _deflateLevel: 9,
              _deflateStrategy: 3,
              _filterType: M,
              _colorType: null,
              /**
               * Sets the deflate level used when saving as PNG format (default is 9)
               * @param {number} l Deflate level to use 0-9. 0 is no compression. 9 (default) is maximum compression.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              deflateLevel: function(B, N) {
                return typeof B != "number" ? H.throwError.call(this, "l must be a number", N) : B < 0 || B > 9 ? H.throwError.call(this, "l must be a number 0 - 9", N) : (this._deflateLevel = Math.round(B), (0, H.isNodePattern)(N) && N.call(this, null, this), this);
              },
              /**
               * Sets the deflate strategy used when saving as PNG format (default is 3)
               * @param {number} s Deflate strategy to use 0-3.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              deflateStrategy: function(B, N) {
                return typeof B != "number" ? H.throwError.call(this, "s must be a number", N) : B < 0 || B > 3 ? H.throwError.call(this, "s must be a number 0 - 3", N) : (this._deflateStrategy = Math.round(B), (0, H.isNodePattern)(N) && N.call(this, null, this), this);
              },
              /**
               * Sets the filter type used when saving as PNG format (default is automatic filters)
               * @param {number} f The quality to use -1-4.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              filterType: function(B, N) {
                return typeof B != "number" ? H.throwError.call(this, "n must be a number", N) : B < -1 || B > 4 ? H.throwError.call(this, "n must be -1 (auto) or a number 0 - 4", N) : (this._filterType = Math.round(B), (0, H.isNodePattern)(N) && N.call(this, null, this), this);
              },
              /**
               * Sets the color type used when saving as PNG format
               * @param {number} s color type to use 0, 2, 4, 6.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              colorType: function(B, N) {
                return typeof B != "number" ? H.throwError.call(this, "s must be a number", N) : B !== 0 && B !== 2 && B !== 4 && B !== 6 ? H.throwError.call(this, "s must be a number 0, 2, 4, 6.", N) : (this._colorType = Math.round(B), (0, H.isNodePattern)(N) && N.call(this, null, this), this);
              }
            }
          };
        };
        $.default = w, Ee.exports = $.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, pngjs: 129 }], 233: [function(te, Ee, $) {
        (function(Q) {
          var r = te("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty($, "__esModule", {
            value: !0
          }), $.default = void 0;
          var F = r(te("@babel/runtime/helpers/defineProperty")), H = r(te("utif")), P = "image/tiff", M = function() {
            return {
              mime: (0, F.default)({}, P, ["tiff", "tif"]),
              constants: {
                MIME_TIFF: P
              },
              decoders: (0, F.default)({}, P, function(x) {
                var m = H.default.decode(x), I = m[0];
                H.default.decodeImages(x, m);
                var z = H.default.toRGBA8(I);
                return {
                  data: Q.from(z),
                  width: I.t256[0],
                  height: I.t257[0]
                };
              }),
              encoders: (0, F.default)({}, P, function(x) {
                var m = H.default.encodeImage(x.bitmap.data, x.bitmap.width, x.bitmap.height);
                return Q.from(m);
              })
            };
          };
          $.default = M, Ee.exports = $.default;
        }).call(this, te("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, buffer: 48, utif: 182 }], 234: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.default = void 0;
        var r = te("timm"), F = Q(te("@jimp/jpeg")), H = Q(te("@jimp/png")), P = Q(te("@jimp/bmp")), M = Q(te("@jimp/tiff")), E = Q(te("@jimp/gif")), x = function() {
          return (0, r.mergeDeep)((0, F.default)(), (0, H.default)(), (0, P.default)(), (0, M.default)(), (0, E.default)());
        };
        $.default = x, Ee.exports = $.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/bmp": 229, "@jimp/gif": 230, "@jimp/jpeg": 231, "@jimp/png": 232, "@jimp/tiff": 233, timm: 177 }], 235: [function(te, Ee, $) {
        var Q = te("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty($, "__esModule", {
          value: !0
        }), $.isNodePattern = H, $.throwError = P, $.scan = M, $.scanIterator = E;
        var r = Q(te("@babel/runtime/regenerator")), F = /* @__PURE__ */ r.default.mark(E);
        function H(x) {
          if (typeof x > "u")
            return !1;
          if (typeof x != "function")
            throw new TypeError("Callback must be a function");
          return !0;
        }
        function P(x, m) {
          if (typeof x == "string" && (x = new Error(x)), typeof m == "function")
            return m.call(this, x);
          throw x;
        }
        function M(x, m, I, z, w, C) {
          m = Math.round(m), I = Math.round(I), z = Math.round(z), w = Math.round(w);
          for (var b = I; b < I + w; b++)
            for (var B = m; B < m + z; B++) {
              var N = x.bitmap.width * b + B << 2;
              C.call(x, B, b, N);
            }
          return x;
        }
        function E(x, m, I, z, w) {
          var C, b, B;
          return r.default.wrap(function(U) {
            for (; ; )
              switch (U.prev = U.next) {
                case 0:
                  m = Math.round(m), I = Math.round(I), z = Math.round(z), w = Math.round(w), C = I;
                case 5:
                  if (!(C < I + w)) {
                    U.next = 17;
                    break;
                  }
                  b = m;
                case 7:
                  if (!(b < m + z)) {
                    U.next = 14;
                    break;
                  }
                  return B = x.bitmap.width * C + b << 2, U.next = 11, {
                    x: b,
                    y: C,
                    idx: B,
                    image: x
                  };
                case 11:
                  b++, U.next = 7;
                  break;
                case 14:
                  C++, U.next = 5;
                  break;
                case 17:
                case "end":
                  return U.stop();
              }
          }, F);
        }
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/regenerator": 22 }] }, {}, [200])(200);
    });
  }(d_)), d_.exports;
}
var p_, ev;
function Zp() {
  if (ev) return p_;
  ev = 1;
  function Qe(Mt, pt) {
    this.x = Mt || 0, this.y = pt || 0;
  }
  return Qe.prototype = {
    copy: function() {
      return new Qe(this.x, this.y);
    }
  }, p_ = Qe, p_;
}
var m_, tv;
function qp() {
  if (tv) return m_;
  tv = 1;
  var Qe = Zp(), Mt = {};
  function pt(C) {
    return Mt[C] || (Mt[C] = new RegExp(" " + C + '="((?:\\\\(?=")"|[^"])+)"', "i")), Mt[C];
  }
  function te(C, b, B) {
    var N = " " + b + '="' + B + '"';
    return C.indexOf(" " + b + '="') === -1 ? C = C.replace(/<[a-z]+/i, function(U) {
      return U + N;
    }) : C = C.replace(pt(b), N), C;
  }
  function Ee(C) {
    return C.toFixed(3).replace(".000", "");
  }
  function $(C, b) {
    return C >= b ? C % b : C >= 0 ? C : b - 1 - (-1 - C) % b;
  }
  function Q(C, b) {
    return C.x * b.y - C.y * b.x;
  }
  function r(C, b, B) {
    return C <= B ? C <= b && b < B : C <= b || b < B;
  }
  function F(C) {
    return C > 0 ? 1 : C < 0 ? -1 : 0;
  }
  function H(C, b) {
    var B = new Array(3), N, U, V;
    for (B[0] = b.x, B[1] = b.y, B[2] = 1, V = 0, N = 0; N < 3; N++)
      for (U = 0; U < 3; U++)
        V += B[N] * C.at(N, U) * B[U];
    return V;
  }
  function P(C, b, B) {
    var N = new Qe();
    return N.x = b.x + C * (B.x - b.x), N.y = b.y + C * (B.y - b.y), N;
  }
  function M(C, b) {
    var B = new Qe();
    return B.y = F(b.x - C.x), B.x = -F(b.y - C.y), B;
  }
  function E(C, b) {
    var B = M(C, b);
    return B.y * (b.x - C.x) - B.x * (b.y - C.y);
  }
  function x(C, b, B) {
    var N, U, V, W;
    return N = b.x - C.x, U = b.y - C.y, V = B.x - C.x, W = B.y - C.y, N * W - V * U;
  }
  function m(C, b, B, N) {
    var U, V, W, q;
    return U = b.x - C.x, V = b.y - C.y, W = N.x - B.x, q = N.y - B.y, U * q - W * V;
  }
  function I(C, b, B) {
    var N, U, V, W;
    return N = b.x - C.x, U = b.y - C.y, V = B.x - C.x, W = B.y - C.y, N * V + U * W;
  }
  function z(C, b, B, N) {
    var U, V, W, q;
    return U = b.x - C.x, V = b.y - C.y, W = N.x - B.x, q = N.y - B.y, U * W + V * q;
  }
  function w(C, b) {
    return Math.sqrt((C.x - b.x) * (C.x - b.x) + (C.y - b.y) * (C.y - b.y));
  }
  return m_ = {
    luminance: function(C, b, B) {
      return Math.round(0.2126 * C + 0.7153 * b + 0.0721 * B);
    },
    between: function(C, b, B) {
      return C >= b && C <= B;
    },
    clamp: function(C, b, B) {
      return Math.min(B, Math.max(b, C));
    },
    isNumber: function(C) {
      return typeof C == "number";
    },
    setHtmlAttr: te,
    /**
     * Generates path instructions for given curve
     *
     * @param {Curve} curve
     * @param {Number} [scale]
     * @returns {string}
     */
    renderCurve: function(C, b) {
      b = b || { x: 1, y: 1 };
      var B = C.c[(C.n - 1) * 3 + 2], N = [
        "M " + Ee(B.x * b.x) + " " + Ee(B.y * b.y)
      ];
      return C.tag.forEach(function(U, V) {
        var W = V * 3, q = C.c[W], Y = C.c[W + 1], re = C.c[W + 2];
        U === "CURVE" ? N.push(
          "C " + Ee(q.x * b.x) + " " + Ee(q.y * b.y) + ", " + Ee(Y.x * b.x) + " " + Ee(Y.y * b.y) + ", " + Ee(re.x * b.x) + " " + Ee(re.y * b.y)
        ) : U === "CORNER" && N.push(
          "L " + Ee(Y.x * b.x) + " " + Ee(Y.y * b.y) + " " + Ee(re.x * b.x) + " " + Ee(re.y * b.y)
        );
      }), N.join(" ");
    },
    bezier: function(b, B, N, U, V) {
      var W = 1 - b, q = new Qe();
      return q.x = W * W * W * B.x + 3 * (W * W * b) * N.x + 3 * (b * b * W) * U.x + b * b * b * V.x, q.y = W * W * W * B.y + 3 * (W * W * b) * N.y + 3 * (b * b * W) * U.y + b * b * b * V.y, q;
    },
    tangent: function(b, B, N, U, V, W) {
      var q, Y, re, se, ve, ce, be, Me, xe, le;
      return q = m(b, B, V, W), Y = m(B, N, V, W), re = m(N, U, V, W), se = q - 2 * Y + re, ve = -2 * q + 2 * Y, ce = q, be = ve * ve - 4 * se * ce, se === 0 || be < 0 ? -1 : (Me = Math.sqrt(be), xe = (-ve + Me) / (2 * se), le = (-ve - Me) / (2 * se), xe >= 0 && xe <= 1 ? xe : le >= 0 && le <= 1 ? le : -1);
    },
    mod: $,
    xprod: Q,
    cyclic: r,
    sign: F,
    quadform: H,
    interval: P,
    dorth_infty: M,
    ddenom: E,
    dpara: x,
    cprod: m,
    iprod: I,
    iprod1: z,
    ddist: w
  }, m_;
}
var __, rv;
function iv() {
  if (rv) return __;
  rv = 1;
  var Qe = qp(), Mt = null;
  try {
    Mt = wv();
  } catch {
  }
  var pt = Ev(), te = 256, Ee = te - 1;
  function $(F, H) {
    return te * F + H;
  }
  function Q(F, H) {
    if (F = typeof F == "number" ? Qe.clamp(Math.round(F), 0, Ee) : 0, H = typeof H == "number" ? Qe.clamp(Math.round(H), 0, Ee) : Ee, F > H)
      throw new Error('Invalid range "' + F + "..." + H + '"');
    return [F, H];
  }
  function r(F, H) {
    if (this.data = null, this.pixels = 0, this._sortedIndexes = null, this._cachedStats = {}, this._lookupTableH = null, typeof F == "number")
      this._createArray(F);
    else if (F instanceof pt)
      this._collectValuesBitmap(F);
    else if (Mt && F instanceof Mt)
      this._collectValuesJimp(F, H);
    else
      throw new Error("Unsupported image source");
  }
  return r.MODE_LUMINANCE = "luminance", r.MODE_R = "r", r.MODE_G = "g", r.MODE_B = "b", r.prototype = {
    /**
     * Initializes data array for an image of given pixel size
     * @param imageSize
     * @returns {Uint8Array|Uint16Array|Uint32Array}
     * @private
     */
    _createArray: function(F) {
      var H = F <= Math.pow(2, 8) ? Uint8Array : F <= Math.pow(2, 16) ? Uint16Array : Uint32Array;
      return this.pixels = F, this.data = new H(te);
    },
    /**
     * Aggregates color data from {@link Jimp} instance
     * @param {Jimp} source
     * @param mode
     * @private
     */
    _collectValuesJimp: function(F, H) {
      var P = F.bitmap.data, M = this._createArray(F.bitmap.width * F.bitmap.height);
      F.scan(0, 0, F.bitmap.width, F.bitmap.height, function(E, x, m) {
        var I = H === r.MODE_R ? P[m] : H === r.MODE_G ? P[m + 1] : H === r.MODE_B ? P[m + 2] : Qe.luminance(P[m], P[m + 1], P[m + 2]);
        M[I]++;
      });
    },
    /**
     * Aggregates color data from {@link Bitmap} instance
     * @param {Bitmap} source
     * @private
     */
    _collectValuesBitmap: function(F) {
      for (var H = this._createArray(F.size), P = F.data.length, M, E = 0; E < P; E++)
        M = F.data[E], H[M]++;
    },
    /**
     * Returns array of color indexes in ascending order
     * @param refresh
     * @returns {*}
     * @private
     */
    _getSortedIndexes: function(F) {
      if (!F && this._sortedIndexes)
        return this._sortedIndexes;
      var H = this.data, P = new Array(te), M = 0;
      for (M; M < te; M++)
        P[M] = M;
      return P.sort(function(E, x) {
        return H[E] > H[x] ? 1 : H[E] < H[x] ? -1 : 0;
      }), this._sortedIndexes = P, P;
    },
    /**
     * Builds lookup table H from lookup tables P and S.
     * see {@link http://www.iis.sinica.edu.tw/page/jise/2001/200109_01.pdf|this paper} for more details
     *
     * @returns {Float64Array}
     * @private
     */
    _thresholdingBuildLookupTable: function() {
      var F = new Float64Array(te * te), H = new Float64Array(te * te), P = new Float64Array(te * te), M = this.pixels, E, x, m, I;
      for (E = 1; E < te; ++E)
        m = $(E, E), I = this.data[E] / M, F[m] = I, H[m] = E * I;
      for (E = 1; E < te - 1; ++E)
        I = this.data[E + 1] / M, m = $(1, E), F[m + 1] = F[m] + I, H[m + 1] = H[m] + (E + 1) * I;
      for (E = 2; E < te; E++)
        for (x = E + 1; x < te; x++)
          F[$(E, x)] = F[$(1, x)] - F[$(1, E - 1)], H[$(E, x)] = H[$(1, x)] - H[$(1, E - 1)];
      for (E = 1; E < te; ++E)
        for (x = E + 1; x < te; x++)
          m = $(E, x), P[m] = F[m] !== 0 ? H[m] * H[m] / F[m] : 0;
      return this._lookupTableH = P;
    },
    /**
     * Implements Algorithm For Multilevel Thresholding
     * Receives desired number of color stops, returns array of said size. Could be limited to a range levelMin..levelMax
     *
     * Regardless of levelMin and levelMax values it still relies on between class variances for the entire histogram
     *
     * @param amount - how many thresholds should be calculated
     * @param [levelMin=0] - histogram segment start
     * @param [levelMax=255] - histogram segment end
     * @returns {number[]}
    */
    multilevelThresholding: function(F, H, P) {
      if (H = Q(H, P), P = H[1], H = H[0], F = Math.min(P - H - 2, ~~F), F < 1)
        return [];
      this._lookupTableH || this._thresholdingBuildLookupTable();
      var M = this._lookupTableH, E = null, x = 0;
      F > 4 && console.log("[Warning]: Threshold computation for more than 5 levels may take a long time");
      function m(I, z, w, C) {
        I = (I || 0) + 1, z = z || 0, w = w || new Array(F), C = C || 0;
        for (var b = C + 1, B, N = I; N < P - F + C; N++)
          B = z + M[$(I, N)], w[b - 1] = N, b + 1 < F + 1 ? m(N, B, w, b) : (B += M[$(N + 1, P)], x < B && (x = B, E = w.slice()));
      }
      return m(H || 0), E || [];
    },
    /**
     * Automatically finds threshold value using Algorithm For Multilevel Thresholding
     *
     * @param {number} [levelMin]
     * @param {number} [levelMax]
     * @returns {null|number}
     */
    autoThreshold: function(F, H) {
      var P = this.multilevelThresholding(1, F, H);
      return P.length ? P[0] : null;
    },
    /**
     * Returns dominant color in given range. Returns -1 if not a single color from the range present on the image
     *
     * @param [levelMin=0]
     * @param [levelMax=255]
     * @param [tolerance=1]
     * @returns {number}
     */
    getDominantColor: function(F, H, P) {
      F = Q(F, H), H = F[1], F = F[0], P = P || 1;
      var M = this.data, E = -1, x = -1, m, I, z;
      if (F === H)
        return M[F] ? F : -1;
      for (m = F; m <= H; m++) {
        for (z = 0, I = ~~(P / -2); I < P; I++)
          z += Qe.between(m + I, 0, Ee) ? M[m + I] : 0;
        var w = z > x, C = x === z && (E < 0 || M[m] > M[E]);
        (w || C) && (E = m, x = z);
      }
      return x <= 0 ? -1 : E;
    },
    /**
     * Returns stats for histogram or its segment.
     *
     * Returned object contains median, mean and standard deviation for pixel values;
     * peak, mean and median number of pixels per level and few other values
     *
     * If no pixels colors from specified range present on the image - most values will be NaN
     *
     * @param {Number} [levelMin=0] - histogram segment start
     * @param {Number} [levelMax=255] - histogram segment end
     * @param {Boolean} [refresh=false] - if cached result can be returned
     * @returns {{levels: {mean: (number|*), median: *, stdDev: number, unique: number}, pixelsPerLevel: {mean: (number|*), median: (number|*), peak: number}, pixels: number}}
     */
    getStats: function(F, H, P) {
      if (F = Q(F, H), H = F[1], F = F[0], !P && this._cachedStats[F + "-" + H])
        return this._cachedStats[F + "-" + H];
      var M = this.data, E = this._getSortedIndexes(), x = 0, m = null, I, z, w, C, b = 0, B = 0, N = 0, U, V, W, q = 0, Y = 0;
      for (U = F; U <= H; U++)
        x += M[U], N += M[U] * U, q += M[U] === 0 ? 0 : 1, Y < M[U] && (Y = M[U]);
      for (I = N / x, w = x / (H - F), C = x / q, z = Math.floor(x / 2), U = 0; U < te; U++)
        W = E[U], V = M[W], !(W < F || W > H) && (B += V, b += Math.pow(W - I, 2) * V, m === null && B >= z && (m = W));
      return this._cachedStats[F + "-" + H] = {
        // various pixel counts for levels (0..255)
        levels: {
          mean: I,
          median: m,
          stdDev: Math.sqrt(b / x),
          unique: q
        },
        // what's visually represented as bars
        pixelsPerLevel: {
          mean: w,
          median: C,
          peak: Y
        },
        pixels: x
      };
    }
  }, __ = r, __;
}
var g_, nv;
function Ev() {
  if (nv) return g_;
  nv = 1;
  var Qe = Zp(), Mt = qp();
  function pt(te, Ee) {
    this._histogram = null, this.width = te, this.height = Ee, this.size = te * Ee, this.arrayBuffer = new ArrayBuffer(this.size), this.data = new Uint8Array(this.arrayBuffer);
  }
  return g_ = pt, iv(), pt.prototype = {
    /**
     * Returns pixel value
     *
     * @param {Number|Point} x - index, point or x
     * @param {Number} [y]
     */
    getValueAt: function(te, Ee) {
      var $ = typeof te == "number" && typeof Ee != "number" ? te : this.pointToIndex(te, Ee);
      return this.data[$];
    },
    /**
     * Converts {@link Point} to index value
     *
     * @param {Number} index
     * @returns {Point}
     */
    indexToPoint: function(te) {
      var Ee = new Qe();
      return Mt.between(te, 0, this.size) ? (Ee.y = Math.floor(te / this.width), Ee.x = te - Ee.y * this.width) : (Ee.x = -1, Ee.y = -1), Ee;
    },
    /**
     * Calculates index for point or coordinate pair
     *
     * @param {Number|Point} pointOrX
     * @param {Number} [y]
     * @returns {Number}
     */
    pointToIndex: function(te, Ee) {
      var $ = te, Q = Ee;
      return te instanceof Qe && ($ = te.x, Q = te.y), !Mt.between($, 0, this.width) || !Mt.between(Q, 0, this.height) ? -1 : this.width * Q + $;
    },
    /**
     * Makes a copy of current bitmap
     *
     * @param {Function} [iterator] optional callback, used for processing pixel value. Accepted arguments: value, index
     * @returns {Bitmap}
     */
    copy: function(te) {
      var Ee = new pt(this.width, this.height), $ = typeof te == "function", Q;
      for (Q = 0; Q < this.size; Q++)
        Ee.data[Q] = $ ? te(this.data[Q], Q) : this.data[Q];
      return Ee;
    },
    histogram: function() {
      var te = iv();
      return this._histogram ? this._histogram : (this._histogram = new te(this), this._histogram);
    }
  }, g_;
}
var y_, av;
function Ib() {
  if (av) return y_;
  av = 1;
  function Qe(Mt) {
    this.n = Mt, this.tag = new Array(Mt), this.c = new Array(Mt * 3), this.alphaCurve = 0, this.vertex = new Array(Mt), this.alpha = new Array(Mt), this.alpha0 = new Array(Mt), this.beta = new Array(Mt);
  }
  return y_ = Qe, y_;
}
var v_, ov;
function Cb() {
  if (ov) return v_;
  ov = 1;
  function Qe() {
    this.area = 0, this.len = 0, this.curve = {}, this.pt = [], this.minX = 1e5, this.minY = 1e5, this.maxX = -1, this.maxY = -1;
  }
  return v_ = Qe, v_;
}
var x_, sv;
function Pb() {
  if (sv) return x_;
  sv = 1;
  function Qe() {
    this.data = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  return Qe.prototype.at = function(Mt, pt) {
    return this.data[Mt * 3 + pt];
  }, x_ = Qe, x_;
}
var b_, lv;
function Rb() {
  if (lv) return b_;
  lv = 1;
  function Qe(Mt, pt, te, Ee, $) {
    this.x = Mt, this.y = pt, this.xy = te, this.x2 = Ee, this.y2 = $;
  }
  return b_ = Qe, b_;
}
var w_, uv;
function Lb() {
  if (uv) return w_;
  uv = 1;
  var Qe = Zp();
  function Mt() {
    this.pen = 0, this.c = [new Qe(), new Qe()], this.t = 0, this.s = 0, this.alpha = 0;
  }
  return w_ = Mt, w_;
}
var E_, cv;
function Sv() {
  if (cv) return E_;
  cv = 1;
  var Qe = wv(), Mt = Ev(), pt = Ib(), te = Zp(), Ee = Cb(), $ = Pb(), Q = Rb(), r = Lb(), F = qp();
  function H(M) {
    this._luminanceData = null, this._pathlist = [], this._imageLoadingIdentifier = null, this._imageLoaded = !1, this._processed = !1, this._params = {
      turnPolicy: H.TURNPOLICY_MINORITY,
      turdSize: 2,
      alphaMax: 1,
      optCurve: !0,
      optTolerance: 0.2,
      threshold: H.THRESHOLD_AUTO,
      blackOnWhite: !0,
      color: H.COLOR_AUTO,
      background: H.COLOR_TRANSPARENT,
      width: null,
      height: null
    }, M && this.setParameters(M);
  }
  H.COLOR_AUTO = "auto", H.COLOR_TRANSPARENT = "transparent", H.THRESHOLD_AUTO = -1, H.TURNPOLICY_BLACK = "black", H.TURNPOLICY_WHITE = "white", H.TURNPOLICY_LEFT = "left", H.TURNPOLICY_RIGHT = "right", H.TURNPOLICY_MINORITY = "minority", H.TURNPOLICY_MAJORITY = "majority";
  var P = [
    H.TURNPOLICY_BLACK,
    H.TURNPOLICY_WHITE,
    H.TURNPOLICY_LEFT,
    H.TURNPOLICY_RIGHT,
    H.TURNPOLICY_MINORITY,
    H.TURNPOLICY_MAJORITY
  ];
  return H.prototype = {
    /**
     * Creating a new {@link Path} for every group of black pixels.
     * @private
     */
    _bmToPathlist: function() {
      var M = this, E = this._params.threshold, x = this._params.blackOnWhite, m, I = new te(0, 0), z;
      E === H.THRESHOLD_AUTO && (E = this._luminanceData.histogram().autoThreshold() || 128), m = this._luminanceData.copy(function(N) {
        var U = x ? N > E : N < E;
        return U ? 0 : 1;
      });
      function w(N) {
        for (var U = m.pointToIndex(N); U < m.size && m.data[U] !== 1; )
          U++;
        return U < m.size && m.indexToPoint(U);
      }
      function C(N, U) {
        var V, W, q;
        for (V = 2; V < 5; V++) {
          for (q = 0, W = -V + 1; W <= V - 1; W++)
            q += m.getValueAt(N + W, U + V - 1) ? 1 : -1, q += m.getValueAt(N + V - 1, U + W - 1) ? 1 : -1, q += m.getValueAt(N + W - 1, U - V) ? 1 : -1, q += m.getValueAt(N - V, U + W) ? 1 : -1;
          if (q > 0)
            return 1;
          if (q < 0)
            return 0;
        }
        return 0;
      }
      function b(N) {
        var U = new Ee(), V = N.x, W = N.y, q = 0, Y = 1, re;
        for (U.sign = m.getValueAt(N.x, N.y) ? "+" : "-"; U.pt.push(new te(V, W)), V > U.maxX && (U.maxX = V), V < U.minX && (U.minX = V), W > U.maxY && (U.maxY = W), W < U.minY && (U.minY = W), U.len++, V += q, W += Y, U.area -= V * Y, !(V === N.x && W === N.y); ) {
          var se = m.getValueAt(V + (q + Y - 1) / 2, W + (Y - q - 1) / 2), ve = m.getValueAt(V + (q - Y - 1) / 2, W + (Y + q - 1) / 2);
          ve && !se ? M._params.turnPolicy === "right" || M._params.turnPolicy === "black" && U.sign === "+" || M._params.turnPolicy === "white" && U.sign === "-" || M._params.turnPolicy === "majority" && C(V, W) || M._params.turnPolicy === "minority" && !C(V, W) ? (re = q, q = -Y, Y = re) : (re = q, q = Y, Y = -re) : ve ? (re = q, q = -Y, Y = re) : se || (re = q, q = Y, Y = -re);
        }
        return U;
      }
      function B(N) {
        var U = N.pt[0].y, V = N.len, W, q, Y, re, se, ve, ce;
        for (se = 1; se < V; se++)
          if (W = N.pt[se].x, q = N.pt[se].y, q !== U) {
            for (re = U < q ? U : q, Y = N.maxX, ve = W; ve < Y; ve++)
              ce = m.pointToIndex(ve, re), m.data[ce] = m.data[ce] ? 0 : 1;
            U = q;
          }
      }
      for (this._pathlist = []; I = w(I); )
        z = b(I), B(z), z.area > M._params.turdSize && this._pathlist.push(z);
    },
    /**
     * Processes path list created by _bmToPathlist method creating and optimizing {@link Curve}'s
     * @private
     */
    _processPath: function() {
      var M = this;
      function E(N) {
        var U, V, W;
        N.x0 = N.pt[0].x, N.y0 = N.pt[0].y, N.sums = [];
        var q = N.sums;
        for (q.push(new Q(0, 0, 0, 0, 0)), U = 0; U < N.len; U++)
          V = N.pt[U].x - N.x0, W = N.pt[U].y - N.y0, q.push(new Q(
            q[U].x + V,
            q[U].y + W,
            q[U].xy + V * W,
            q[U].x2 + V * V,
            q[U].y2 + W * W
          ));
      }
      function x(N) {
        var U = N.len, V = N.pt, W, q = new Array(U), Y = new Array(U), re = new Array(4);
        N.lon = new Array(U);
        var se = [new te(), new te()], ve = new te(), ce = new te(), be = new te(), Me, xe, le, de, De, ze, Ze, Ue, Ie = 0;
        for (xe = U - 1; xe >= 0; xe--)
          V[xe].x != V[Ie].x && V[xe].y != V[Ie].y && (Ie = xe + 1), Y[xe] = Ie;
        for (xe = U - 1; xe >= 0; xe--) {
          for (re[0] = re[1] = re[2] = re[3] = 0, W = (3 + 3 * (V[F.mod(xe + 1, U)].x - V[xe].x) + (V[F.mod(xe + 1, U)].y - V[xe].y)) / 2, re[W]++, se[0].x = 0, se[0].y = 0, se[1].x = 0, se[1].y = 0, Ie = Y[xe], de = xe; ; ) {
            if (Me = 0, W = (3 + 3 * F.sign(V[Ie].x - V[de].x) + F.sign(V[Ie].y - V[de].y)) / 2, re[W]++, re[0] && re[1] && re[2] && re[3]) {
              q[xe] = de, Me = 1;
              break;
            }
            if (ve.x = V[Ie].x - V[xe].x, ve.y = V[Ie].y - V[xe].y, F.xprod(se[0], ve) < 0 || F.xprod(se[1], ve) > 0 || (Math.abs(ve.x) <= 1 && Math.abs(ve.y) <= 1 || (ce.x = ve.x + (ve.y >= 0 && (ve.y > 0 || ve.x < 0) ? 1 : -1), ce.y = ve.y + (ve.x <= 0 && (ve.x < 0 || ve.y < 0) ? 1 : -1), F.xprod(se[0], ce) >= 0 && (se[0].x = ce.x, se[0].y = ce.y), ce.x = ve.x + (ve.y <= 0 && (ve.y < 0 || ve.x < 0) ? 1 : -1), ce.y = ve.y + (ve.x >= 0 && (ve.x > 0 || ve.y < 0) ? 1 : -1), F.xprod(se[1], ce) <= 0 && (se[1].x = ce.x, se[1].y = ce.y)), de = Ie, Ie = Y[de], !F.cyclic(Ie, xe, de)))
              break;
          }
          Me === 0 && (be.x = F.sign(V[Ie].x - V[de].x), be.y = F.sign(V[Ie].y - V[de].y), ve.x = V[de].x - V[xe].x, ve.y = V[de].y - V[xe].y, De = F.xprod(se[0], ve), ze = F.xprod(se[0], be), Ze = F.xprod(se[1], ve), Ue = F.xprod(se[1], be), le = 1e7, ze < 0 && (le = Math.floor(De / -ze)), Ue > 0 && (le = Math.min(le, Math.floor(-Ze / Ue))), q[xe] = F.mod(de + le, U));
        }
        for (le = q[U - 1], N.lon[U - 1] = le, xe = U - 2; xe >= 0; xe--)
          F.cyclic(xe + 1, q[xe], le) && (le = q[xe]), N.lon[xe] = le;
        for (xe = U - 1; F.cyclic(F.mod(xe + 1, U), le, N.lon[xe]); xe--)
          N.lon[xe] = le;
      }
      function m(N) {
        function U(ze, Ze, Ue) {
          var Ie = ze.len, je = ze.pt, Fe = ze.sums, $e, ct, wt, Oe, Ct, Xt, vt, Ye, qe, rt, it, Ae, _e, fe, We = 0;
          return Ue >= Ie && (Ue -= Ie, We = 1), We === 0 ? ($e = Fe[Ue + 1].x - Fe[Ze].x, ct = Fe[Ue + 1].y - Fe[Ze].y, Oe = Fe[Ue + 1].x2 - Fe[Ze].x2, wt = Fe[Ue + 1].xy - Fe[Ze].xy, Ct = Fe[Ue + 1].y2 - Fe[Ze].y2, Xt = Ue + 1 - Ze) : ($e = Fe[Ue + 1].x - Fe[Ze].x + Fe[Ie].x, ct = Fe[Ue + 1].y - Fe[Ze].y + Fe[Ie].y, Oe = Fe[Ue + 1].x2 - Fe[Ze].x2 + Fe[Ie].x2, wt = Fe[Ue + 1].xy - Fe[Ze].xy + Fe[Ie].xy, Ct = Fe[Ue + 1].y2 - Fe[Ze].y2 + Fe[Ie].y2, Xt = Ue + 1 - Ze + Ie), it = (je[Ze].x + je[Ue].x) / 2 - je[0].x, Ae = (je[Ze].y + je[Ue].y) / 2 - je[0].y, fe = je[Ue].x - je[Ze].x, _e = -(je[Ue].y - je[Ze].y), vt = (Oe - 2 * $e * it) / Xt + it * it, Ye = (wt - $e * Ae - ct * it) / Xt + it * Ae, qe = (Ct - 2 * ct * Ae) / Xt + Ae * Ae, rt = _e * _e * vt + 2 * _e * fe * Ye + fe * fe * qe, Math.sqrt(rt);
        }
        var V, W, q, Y, re = N.len, se = new Array(re + 1), ve = new Array(re + 1), ce = new Array(re), be = new Array(re + 1), Me = new Array(re + 1), xe = new Array(re + 1), le, de, De;
        for (V = 0; V < re; V++)
          De = F.mod(N.lon[F.mod(V - 1, re)] - 1, re), De == V && (De = F.mod(V + 1, re)), De < V ? ce[V] = re : ce[V] = De;
        for (W = 1, V = 0; V < re; V++)
          for (; W <= ce[V]; )
            be[W] = V, W++;
        for (V = 0, W = 0; V < re; W++)
          Me[W] = V, V = ce[V];
        for (Me[W] = re, q = W, V = re, W = q; W > 0; W--)
          xe[W] = V, V = be[V];
        for (xe[0] = 0, se[0] = 0, W = 1; W <= q; W++)
          for (V = xe[W]; V <= Me[W]; V++) {
            for (de = -1, Y = Me[W - 1]; Y >= be[V]; Y--)
              le = U(N, Y, V) + se[Y], (de < 0 || le < de) && (ve[V] = Y, de = le);
            se[V] = de;
          }
        for (N.m = q, N.po = new Array(q), V = re, W = q - 1; V > 0; W--)
          V = ve[V], N.po[W] = V;
      }
      function I(N) {
        function U(vt, Ye, qe, rt, it) {
          for (var Ae = vt.len, _e = vt.sums, fe, We, Pe, he, ie, Xe, bt, Wt, Qt, Sr, Fr, kr = 0; qe >= Ae; )
            qe -= Ae, kr += 1;
          for (; Ye >= Ae; )
            Ye -= Ae, kr -= 1;
          for (; qe < 0; )
            qe += Ae, kr -= 1;
          for (; Ye < 0; )
            Ye += Ae, kr += 1;
          fe = _e[qe + 1].x - _e[Ye].x + kr * _e[Ae].x, We = _e[qe + 1].y - _e[Ye].y + kr * _e[Ae].y, Pe = _e[qe + 1].x2 - _e[Ye].x2 + kr * _e[Ae].x2, he = _e[qe + 1].xy - _e[Ye].xy + kr * _e[Ae].xy, ie = _e[qe + 1].y2 - _e[Ye].y2 + kr * _e[Ae].y2, Xe = qe + 1 - Ye + kr * Ae, rt.x = fe / Xe, rt.y = We / Xe, bt = (Pe - fe * fe / Xe) / Xe, Wt = (he - fe * We / Xe) / Xe, Qt = (ie - We * We / Xe) / Xe, Sr = (bt + Qt + Math.sqrt((bt - Qt) * (bt - Qt) + 4 * Wt * Wt)) / 2, bt -= Sr, Qt -= Sr, Math.abs(bt) >= Math.abs(Qt) ? (Fr = Math.sqrt(bt * bt + Wt * Wt), Fr !== 0 && (it.x = -Wt / Fr, it.y = bt / Fr)) : (Fr = Math.sqrt(Qt * Qt + Wt * Wt), Fr !== 0 && (it.x = -Qt / Fr, it.y = Wt / Fr)), Fr === 0 && (it.x = it.y = 0);
        }
        var V = N.m, W = N.po, q = N.len, Y = N.pt, re = N.x0, se = N.y0, ve = new Array(V), ce = new Array(V), be = new Array(V), Me = new Array(3), xe, le, de, De, ze, Ze = new te();
        for (N.curve = new pt(V), le = 0; le < V; le++)
          de = W[F.mod(le + 1, V)], de = F.mod(de - W[le], q) + W[le], ve[le] = new te(), ce[le] = new te(), U(N, W[le], de, ve[le], ce[le]);
        for (le = 0; le < V; le++)
          if (be[le] = new $(), xe = ce[le].x * ce[le].x + ce[le].y * ce[le].y, xe === 0)
            for (de = 0; de < 3; de++)
              for (De = 0; De < 3; De++)
                be[le].data[de * 3 + De] = 0;
          else
            for (Me[0] = ce[le].y, Me[1] = -ce[le].x, Me[2] = -Me[1] * ve[le].y - Me[0] * ve[le].x, ze = 0; ze < 3; ze++)
              for (De = 0; De < 3; De++)
                be[le].data[ze * 3 + De] = Me[ze] * Me[De] / xe;
        var Ue, Ie, je, Fe, $e, ct, wt, Oe, Ct, Xt;
        for (le = 0; le < V; le++) {
          for (Ue = new $(), Ie = new te(), Ze.x = Y[W[le]].x - re, Ze.y = Y[W[le]].y - se, de = F.mod(le - 1, V), ze = 0; ze < 3; ze++)
            for (De = 0; De < 3; De++)
              Ue.data[ze * 3 + De] = be[de].at(ze, De) + be[le].at(ze, De);
          for (; ; ) {
            if ($e = Ue.at(0, 0) * Ue.at(1, 1) - Ue.at(0, 1) * Ue.at(1, 0), $e !== 0) {
              Ie.x = (-Ue.at(0, 2) * Ue.at(1, 1) + Ue.at(1, 2) * Ue.at(0, 1)) / $e, Ie.y = (Ue.at(0, 2) * Ue.at(1, 0) - Ue.at(1, 2) * Ue.at(0, 0)) / $e;
              break;
            }
            for (Ue.at(0, 0) > Ue.at(1, 1) ? (Me[0] = -Ue.at(0, 1), Me[1] = Ue.at(0, 0)) : Ue.at(1, 1) ? (Me[0] = -Ue.at(1, 1), Me[1] = Ue.at(1, 0)) : (Me[0] = 1, Me[1] = 0), xe = Me[0] * Me[0] + Me[1] * Me[1], Me[2] = -Me[1] * Ze.y - Me[0] * Ze.x, ze = 0; ze < 3; ze++)
              for (De = 0; De < 3; De++)
                Ue.data[ze * 3 + De] += Me[ze] * Me[De] / xe;
          }
          if (je = Math.abs(Ie.x - Ze.x), Fe = Math.abs(Ie.y - Ze.y), je <= 0.5 && Fe <= 0.5) {
            N.curve.vertex[le] = new te(Ie.x + re, Ie.y + se);
            continue;
          }
          if (ct = F.quadform(Ue, Ze), Oe = Ze.x, Ct = Ze.y, Ue.at(0, 0) !== 0)
            for (Xt = 0; Xt < 2; Xt++)
              Ie.y = Ze.y - 0.5 + Xt, Ie.x = -(Ue.at(0, 1) * Ie.y + Ue.at(0, 2)) / Ue.at(0, 0), je = Math.abs(Ie.x - Ze.x), wt = F.quadform(Ue, Ie), je <= 0.5 && wt < ct && (ct = wt, Oe = Ie.x, Ct = Ie.y);
          if (Ue.at(1, 1) !== 0)
            for (Xt = 0; Xt < 2; Xt++)
              Ie.x = Ze.x - 0.5 + Xt, Ie.y = -(Ue.at(1, 0) * Ie.x + Ue.at(1, 2)) / Ue.at(1, 1), Fe = Math.abs(Ie.y - Ze.y), wt = F.quadform(Ue, Ie), Fe <= 0.5 && wt < ct && (ct = wt, Oe = Ie.x, Ct = Ie.y);
          for (ze = 0; ze < 2; ze++)
            for (De = 0; De < 2; De++)
              Ie.x = Ze.x - 0.5 + ze, Ie.y = Ze.y - 0.5 + De, wt = F.quadform(Ue, Ie), wt < ct && (ct = wt, Oe = Ie.x, Ct = Ie.y);
          N.curve.vertex[le] = new te(Oe + re, Ct + se);
        }
      }
      function z(N) {
        var U = N.curve, V = U.n, W = U.vertex, q, Y, re;
        for (q = 0, Y = V - 1; q < Y; q++, Y--)
          re = W[q], W[q] = W[Y], W[Y] = re;
      }
      function w(N) {
        var U = N.curve.n, V = N.curve, W, q, Y, re, se, ve, ce, be, Me;
        for (W = 0; W < U; W++)
          q = F.mod(W + 1, U), Y = F.mod(W + 2, U), Me = F.interval(1 / 2, V.vertex[Y], V.vertex[q]), se = F.ddenom(V.vertex[W], V.vertex[Y]), se !== 0 ? (re = F.dpara(V.vertex[W], V.vertex[q], V.vertex[Y]) / se, re = Math.abs(re), ve = re > 1 ? 1 - 1 / re : 0, ve = ve / 0.75) : ve = 4 / 3, V.alpha0[q] = ve, ve >= M._params.alphaMax ? (V.tag[q] = "CORNER", V.c[3 * q + 1] = V.vertex[q], V.c[3 * q + 2] = Me) : (ve < 0.55 ? ve = 0.55 : ve > 1 && (ve = 1), ce = F.interval(0.5 + 0.5 * ve, V.vertex[W], V.vertex[q]), be = F.interval(0.5 + 0.5 * ve, V.vertex[Y], V.vertex[q]), V.tag[q] = "CURVE", V.c[3 * q + 0] = ce, V.c[3 * q + 1] = be, V.c[3 * q + 2] = Me), V.alpha[q] = ve, V.beta[q] = 0.5;
        V.alphaCurve = 1;
      }
      function C(N) {
        function U(ct, wt, Oe, Ct, Xt, vt, Ye) {
          var qe = ct.curve.n, rt = ct.curve, it = rt.vertex, Ae, _e, fe, We, Pe, he, ie, Xe, bt, Wt, Qt, Sr, Fr, kr, Ur, Rr, Pr, hi, Vr, Te, Tt, Gt, pr;
          if (wt == Oe || (Ae = wt, Pe = F.mod(wt + 1, qe), _e = F.mod(Ae + 1, qe), We = vt[_e], We === 0))
            return 1;
          for (Xe = F.ddist(it[wt], it[Pe]), Ae = _e; Ae != Oe; Ae = _e)
            if (_e = F.mod(Ae + 1, qe), fe = F.mod(Ae + 2, qe), vt[_e] != We || F.sign(F.cprod(it[wt], it[Pe], it[_e], it[fe])) != We || F.iprod1(it[wt], it[Pe], it[_e], it[fe]) < Xe * F.ddist(it[_e], it[fe]) * -0.999847695156)
              return 1;
          if (Qt = rt.c[F.mod(wt, qe) * 3 + 2].copy(), Sr = it[F.mod(wt + 1, qe)].copy(), Fr = it[F.mod(Oe, qe)].copy(), kr = rt.c[F.mod(Oe, qe) * 3 + 2].copy(), he = Ye[Oe] - Ye[wt], he -= F.dpara(it[0], rt.c[wt * 3 + 2], rt.c[Oe * 3 + 2]) / 2, wt >= Oe && (he += Ye[qe]), hi = F.dpara(Qt, Sr, Fr), Vr = F.dpara(Qt, Sr, kr), Te = F.dpara(Qt, Fr, kr), Tt = hi + Te - Vr, Vr == hi || (pr = Te / (Te - Tt), Gt = Vr / (Vr - hi), Rr = Vr * pr / 2, Rr === 0))
            return 1;
          for (Pr = he / Rr, ie = 2 - Math.sqrt(4 - Pr / 0.3), Ct.c[0] = F.interval(pr * ie, Qt, Sr), Ct.c[1] = F.interval(Gt * ie, kr, Fr), Ct.alpha = ie, Ct.t = pr, Ct.s = Gt, Sr = Ct.c[0].copy(), Fr = Ct.c[1].copy(), Ct.pen = 0, Ae = F.mod(wt + 1, qe); Ae != Oe; Ae = _e) {
            if (_e = F.mod(Ae + 1, qe), pr = F.tangent(Qt, Sr, Fr, kr, it[Ae], it[_e]), pr < -0.5 || (Ur = F.bezier(pr, Qt, Sr, Fr, kr), Xe = F.ddist(it[Ae], it[_e]), Xe === 0) || (bt = F.dpara(it[Ae], it[_e], Ur) / Xe, Math.abs(bt) > Xt) || F.iprod(it[Ae], it[_e], Ur) < 0 || F.iprod(it[_e], it[Ae], Ur) < 0)
              return 1;
            Ct.pen += bt * bt;
          }
          for (Ae = wt; Ae != Oe; Ae = _e) {
            if (_e = F.mod(Ae + 1, qe), pr = F.tangent(Qt, Sr, Fr, kr, rt.c[Ae * 3 + 2], rt.c[_e * 3 + 2]), pr < -0.5 || (Ur = F.bezier(pr, Qt, Sr, Fr, kr), Xe = F.ddist(rt.c[Ae * 3 + 2], rt.c[_e * 3 + 2]), Xe === 0) || (bt = F.dpara(rt.c[Ae * 3 + 2], rt.c[_e * 3 + 2], Ur) / Xe, Wt = F.dpara(rt.c[Ae * 3 + 2], rt.c[_e * 3 + 2], it[_e]) / Xe, Wt *= 0.75 * rt.alpha[_e], Wt < 0 && (bt = -bt, Wt = -Wt), bt < Wt - Xt))
              return 1;
            bt < Wt && (Ct.pen += (bt - Wt) * (bt - Wt));
          }
          return 0;
        }
        var V = N.curve, W = V.n, q = V.vertex, Y = new Array(W + 1), re = new Array(W + 1), se = new Array(W + 1), ve = new Array(W + 1), ce, be, Me, xe, le = new r(), de, De, ze, Ze, Ue, Ie, je, Fe = new Array(W), $e = new Array(W + 1);
        for (be = 0; be < W; be++)
          V.tag[be] == "CURVE" ? Fe[be] = F.sign(F.dpara(q[F.mod(be - 1, W)], q[be], q[F.mod(be + 1, W)])) : Fe[be] = 0;
        for (ze = 0, $e[0] = 0, de = V.vertex[0], be = 0; be < W; be++)
          De = F.mod(be + 1, W), V.tag[De] == "CURVE" && (Ze = V.alpha[De], ze += 0.3 * Ze * (4 - Ze) * F.dpara(V.c[be * 3 + 2], q[De], V.c[De * 3 + 2]) / 2, ze += F.dpara(de, V.c[be * 3 + 2], V.c[De * 3 + 2]) / 2), $e[be + 1] = ze;
        for (Y[0] = -1, re[0] = 0, se[0] = 0, Me = 1; Me <= W; Me++)
          for (Y[Me] = Me - 1, re[Me] = re[Me - 1], se[Me] = se[Me - 1] + 1, be = Me - 2; be >= 0 && (xe = U(
            N,
            be,
            F.mod(Me, W),
            le,
            M._params.optTolerance,
            Fe,
            $e
          ), !xe); be--)
            (se[Me] > se[be] + 1 || se[Me] == se[be] + 1 && re[Me] > re[be] + le.pen) && (Y[Me] = be, re[Me] = re[be] + le.pen, se[Me] = se[be] + 1, ve[Me] = le, le = new r());
        for (ce = se[W], Ue = new pt(ce), Ie = new Array(ce), je = new Array(ce), Me = W, be = ce - 1; be >= 0; be--)
          Y[Me] == Me - 1 ? (Ue.tag[be] = V.tag[F.mod(Me, W)], Ue.c[be * 3 + 0] = V.c[F.mod(Me, W) * 3 + 0], Ue.c[be * 3 + 1] = V.c[F.mod(Me, W) * 3 + 1], Ue.c[be * 3 + 2] = V.c[F.mod(Me, W) * 3 + 2], Ue.vertex[be] = V.vertex[F.mod(Me, W)], Ue.alpha[be] = V.alpha[F.mod(Me, W)], Ue.alpha0[be] = V.alpha0[F.mod(Me, W)], Ue.beta[be] = V.beta[F.mod(Me, W)], Ie[be] = je[be] = 1) : (Ue.tag[be] = "CURVE", Ue.c[be * 3 + 0] = ve[Me].c[0], Ue.c[be * 3 + 1] = ve[Me].c[1], Ue.c[be * 3 + 2] = V.c[F.mod(Me, W) * 3 + 2], Ue.vertex[be] = F.interval(
            ve[Me].s,
            V.c[F.mod(Me, W) * 3 + 2],
            q[F.mod(Me, W)]
          ), Ue.alpha[be] = ve[Me].alpha, Ue.alpha0[be] = ve[Me].alpha, Ie[be] = ve[Me].s, je[be] = ve[Me].t), Me = Y[Me];
        for (be = 0; be < ce; be++)
          De = F.mod(be + 1, ce), Ue.beta[be] = Ie[be] / (Ie[be] + je[De]);
        Ue.alphaCurve = 1, N.curve = Ue;
      }
      for (var b = 0; b < this._pathlist.length; b++) {
        var B = this._pathlist[b];
        E(B), x(B), m(B), I(B), B.sign === "-" && z(B), w(B), M._params.optCurve && C(B);
      }
    },
    /**
     * Validates some of parameters
     * @param params
     * @private
     */
    _validateParameters: function(M) {
      if (M && M.turnPolicy && P.indexOf(M.turnPolicy) === -1) {
        var E = "'" + P.join("', '") + "'";
        throw new Error("Bad turnPolicy value. Allowed values are: " + E);
      }
      if (M && M.threshold != null && M.threshold !== H.THRESHOLD_AUTO && (typeof M.threshold != "number" || !F.between(M.threshold, 0, 255)))
        throw new Error("Bad threshold value. Expected to be an integer in range 0..255");
      if (M && M.optCurve != null && typeof M.optCurve != "boolean")
        throw new Error("'optCurve' must be Boolean");
    },
    _processLoadedImage: function(M) {
      var E = new Mt(M.bitmap.width, M.bitmap.height), x = M.bitmap.data;
      M.scan(0, 0, M.bitmap.width, M.bitmap.height, function(m, I, z) {
        var w = x[z + 3] / 255, C = 255 + (x[z + 0] - 255) * w, b = 255 + (x[z + 1] - 255) * w, B = 255 + (x[z + 2] - 255) * w;
        E.data[z / 4] = F.luminance(C, b, B);
      }), this._luminanceData = E, this._imageLoaded = !0;
    },
    /**
     * Reads given image. Uses {@link Jimp} under the hood, so target can be whatever Jimp can take
     *
     * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or BMP
     * @param {Function} callback
     */
    loadImage: function(M, E) {
      var x = this, m = {};
      this._imageLoadingIdentifier = m, this._imageLoaded = !1, M instanceof Qe ? (this._imageLoadingIdentifier = null, this._imageLoaded = !0, x._processLoadedImage(M), E.call(x, null)) : Qe.read(M, function(I, z) {
        var w = x._imageLoadingIdentifier !== m;
        if (w) {
          var C = I || new Error("Another image was loaded instead");
          return E.call(x, C);
        }
        x._imageLoadingIdentifier = null, x._processLoadedImage(z), E.call(x, null);
      });
    },
    /**
     * Sets algorithm parameters
     * @param {Potrace~Options} newParams
     */
    setParameters: function(M) {
      var E, x;
      this._validateParameters(M);
      for (E in this._params)
        this._params.hasOwnProperty(E) && M.hasOwnProperty(E) && (x = this._params[E], this._params[E] = M[E], x !== this._params[E] && ["color", "background"].indexOf(E) === -1 && (this._processed = !1));
    },
    /**
     * Generates just <path> tag without rest of the SVG file
     *
     * @param {String} [fillColor] - overrides color from parameters
     * @returns {String}
     */
    getPathTag: function(M, E) {
      if (M = arguments.length === 0 ? this._params.color : M, M === H.COLOR_AUTO && (M = this._params.blackOnWhite ? "black" : "white"), !this._imageLoaded)
        throw new Error("Image should be loaded first");
      this._processed || (this._bmToPathlist(), this._processPath(), this._processed = !0);
      var x = '<path d="';
      return x += this._pathlist.map(function(m) {
        return F.renderCurve(m.curve, E);
      }).join(" "), x += '" stroke="none" fill="' + M + '" fill-rule="evenodd"/>', x;
    },
    /**
     * Returns <symbol> tag. Always has viewBox specified and comes with no fill color,
     * so it could be changed with <use> tag
     *
     * @param id
     * @returns {string}
     */
    getSymbol: function(M) {
      return '<symbol viewBox="0 0 ' + this._luminanceData.width + " " + this._luminanceData.height + '" id="' + M + '">' + this.getPathTag("") + "</symbol>";
    },
    /**
     * Generates SVG image
     * @returns {String}
     */
    getSVG: function() {
      var M = this._params.width || this._luminanceData.width, E = this._params.height || this._luminanceData.height, x = {
        x: this._params.width ? this._params.width / this._luminanceData.width : 1,
        y: this._params.height ? this._params.height / this._luminanceData.height : 1
      };
      return '<svg xmlns="http://www.w3.org/2000/svg" width="' + M + '" height="' + E + '" viewBox="0 0 ' + M + " " + E + `" version="1.1">
` + (this._params.background !== H.COLOR_TRANSPARENT ? '	<rect x="0" y="0" width="100%" height="100%" fill="' + this._params.background + `" />
` : "") + "	" + this.getPathTag(this._params.color, x) + `
</svg>`;
    }
  }, E_ = H, E_;
}
var S_, hv;
function Db() {
  if (hv) return S_;
  hv = 1;
  var Qe = Sv(), Mt = qp();
  function pt(Ee) {
    this._potrace = new Qe(), this._calculatedThreshold = null, this._params = {
      threshold: Qe.THRESHOLD_AUTO,
      blackOnWhite: !0,
      steps: pt.STEPS_AUTO,
      background: Qe.COLOR_TRANSPARENT,
      fillStrategy: pt.FILL_DOMINANT,
      rangeDistribution: pt.RANGES_AUTO
    }, Ee && this.setParameters(Ee);
  }
  for (var te in Qe)
    Object.prototype.hasOwnProperty.call(Qe, te) && te === te.toUpperCase() && (pt[te] = Qe[te]);
  return pt.STEPS_AUTO = -1, pt.FILL_SPREAD = "spread", pt.FILL_DOMINANT = "dominant", pt.FILL_MEDIAN = "median", pt.FILL_MEAN = "mean", pt.RANGES_AUTO = "auto", pt.RANGES_EQUAL = "equal", pt.prototype = {
    /**
     * Fine tuning to color ranges.
     *
     * If last range (featuring most saturated color) is larger than 10% of color space (25 units)
     * then we want to add another color stop, that hopefully will include darkest pixels, improving presence of
     * shadows and line art
     *
     * @param ranges
     * @private
     */
    _addExtraColorStop: function(Ee) {
      var $ = this._params.blackOnWhite, Q = Ee[Ee.length - 1], r = $ ? 0 : Q.value, F = $ ? Q.value : 255;
      if (F - r > 25 && Q.colorIntensity !== 1) {
        var H = this._getImageHistogram(), P = H.getStats(r, F).levels, M = P.mean + P.stdDev <= 25 ? P.mean + P.stdDev : P.mean - P.stdDev <= 25 ? P.mean - P.stdDev : 25, E = $ ? H.getStats(0, M) : H.getStats(M, 255), x = E.levels.mean;
        Ee.push({
          value: Math.abs(($ ? 0 : 255) - M),
          colorIntensity: isNaN(x) ? 0 : ($ ? 255 - x : x) / 255
        });
      }
      return Ee;
    },
    /**
     * Calculates color intensity for each element of numeric array
     * 
     * @param {number[]} colorStops
     * @returns {{ levels: number, colorIntensity: number }[]}
     * @private
     */
    _calcColorIntensity: function(Ee) {
      var $ = this._params.blackOnWhite, Q = this._params.fillStrategy, r = Q !== pt.FILL_SPREAD ? this._getImageHistogram() : null, F = Math.abs(this._paramThreshold() - ($ ? 0 : 255));
      return Ee.map(function(H, P) {
        var M = P + 1 === Ee.length ? $ ? -1 : 256 : Ee[P + 1], E = Math.round($ ? M + 1 : H), x = Math.round($ ? H : M - 1), m = P / (Ee.length - 1), I = x - E, z = r.getStats(E, x), w = -1;
        if (z.pixels === 0)
          return {
            value: H,
            colorIntensity: 0
          };
        switch (Q) {
          case pt.FILL_SPREAD:
            w = ($ ? E : x) + ($ ? 1 : -1) * I * Math.max(0.5, F / 255) * m;
            break;
          case pt.FILL_DOMINANT:
            w = r.getDominantColor(E, x, Mt.clamp(I, 1, 5));
            break;
          case pt.FILL_MEAN:
            w = z.levels.mean;
            break;
          case pt.FILL_MEDIAN:
            w = z.levels.median;
            break;
        }
        return P !== 0 && (w = $ ? Mt.clamp(w, E, x - Math.round(I * 0.1)) : Mt.clamp(w, E + Math.round(I * 0.1), x)), {
          value: H,
          colorIntensity: w === -1 ? 0 : ($ ? 255 - w : w) / 255
        };
      });
    },
    /**
     * @returns {Histogram}
     * @private
     */
    _getImageHistogram: function() {
      return this._potrace._luminanceData.histogram();
    },
    /**
     * Processes threshold, steps and rangeDistribution parameters and returns normalized array of color stops
     * @returns {*}
     * @private
     */
    _getRanges: function() {
      var Ee = this._paramSteps();
      if (!Array.isArray(Ee))
        return this._params.rangeDistribution === pt.RANGES_AUTO ? this._getRangesAuto() : this._getRangesEquallyDistributed();
      var $ = [], Q = this._paramThreshold(), r = this._params.blackOnWhite;
      return Ee.forEach(function(F) {
        $.indexOf(F) === -1 && Mt.between(F, 0, 255) && $.push(F);
      }), $.length || $.push(Q), $ = $.sort(function(F, H) {
        return F < H === r ? 1 : -1;
      }), r && $[0] < Q ? $.unshift(Q) : !r && $[$.length - 1] < Q && $.push(Q), this._calcColorIntensity($);
    },
    /**
     * Calculates given (or lower) number of thresholds using automatic thresholding algorithm
     * @returns {*}
     * @private
     */
    _getRangesAuto: function() {
      var Ee = this._getImageHistogram(), $ = this._paramSteps(!0), Q;
      if (this._params.threshold === Qe.THRESHOLD_AUTO)
        Q = Ee.multilevelThresholding($);
      else {
        var r = this._paramThreshold();
        Q = this._params.blackOnWhite ? Ee.multilevelThresholding($ - 1, 0, r) : Ee.multilevelThresholding($ - 1, r, 255), this._params.blackOnWhite ? Q.push(r) : Q.unshift(r);
      }
      return this._params.blackOnWhite && (Q = Q.reverse()), this._calcColorIntensity(Q);
    },
    /**
     * Calculates color stops and color representing each segment, returning them
     * from least to most intense color (black or white, depending on blackOnWhite parameter)
     *
     * @private
     */
    _getRangesEquallyDistributed: function() {
      for (var Ee = this._params.blackOnWhite, $ = Ee ? this._paramThreshold() : 255 - this._paramThreshold(), Q = this._paramSteps(), r = $ / Q, F = [], H = Q - 1, P; H >= 0; )
        P = Math.min($, (H + 1) * r), P = Ee ? P : 255 - P, H--, F.push(P);
      return this._calcColorIntensity(F);
    },
    /**
     * Returns valid steps value
     * @param {Boolean} [count=false]
     * @returns {number|number[]}
     * @private
     */
    _paramSteps: function(Ee) {
      var $ = this._params.steps;
      if (Array.isArray($))
        return Ee ? $.length : $;
      if ($ === pt.STEPS_AUTO && this._params.threshold === Qe.THRESHOLD_AUTO)
        return 4;
      var Q = this._params.blackOnWhite, r = Q ? this._paramThreshold() : 255 - this._paramThreshold();
      return $ === pt.STEPS_AUTO ? r > 200 ? 4 : 3 : Math.min(r, Math.max(2, $));
    },
    /**
     * Returns valid threshold value
     * @returns {number}
     * @private
     */
    _paramThreshold: function() {
      if (this._calculatedThreshold !== null)
        return this._calculatedThreshold;
      if (this._params.threshold !== Qe.THRESHOLD_AUTO)
        return this._calculatedThreshold = this._params.threshold, this._calculatedThreshold;
      var Ee = this._getImageHistogram().multilevelThresholding(2);
      return this._calculatedThreshold = this._params.blackOnWhite ? Ee[1] : Ee[0], this._calculatedThreshold = this._calculatedThreshold || 128, this._calculatedThreshold;
    },
    /**
     * Running potrace on the image multiple times with different thresholds and returns an array
     * of path tags
     *
     * @param {Boolean} [noFillColor]
     * @returns {string[]}
     * @private
     */
    _pathTags: function(Ee) {
      var $ = this._getRanges(), Q = this._potrace, r = this._params.blackOnWhite;
      $.length >= 10 && ($ = this._addExtraColorStop($)), Q.setParameters({ blackOnWhite: r });
      var F = 0;
      return $.map(function(H) {
        var P = H.colorIntensity;
        if (P === 0)
          return "";
        var M = !F || P === 1 ? P : (F - P) / (F - 1);
        M = Mt.clamp(parseFloat(M.toFixed(3)), 0, 1), F = F + (1 - F) * M, Q.setParameters({ threshold: H.value });
        var E = Ee ? Q.getPathTag("") : Q.getPathTag();
        E = Mt.setHtmlAttr(E, "fill-opacity", M.toFixed(3));
        var x = M === 0 || E.indexOf(' d=""') !== -1;
        return x ? "" : E;
      });
    },
    /**
     * Loads image.
     *
     * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or BMP
     * @param {Function} callback
     */
    loadImage: function(Ee, $) {
      var Q = this;
      this._potrace.loadImage(Ee, function(r) {
        Q._calculatedThreshold = null, $.call(Q, r);
      });
    },
    /**
     * Sets parameters. Accepts same object as {Potrace}
     *
     * @param {Posterizer~Options} params
     */
    setParameters: function(Ee) {
      if (Ee) {
        if (this._potrace.setParameters(Ee), Ee.steps && !Array.isArray(Ee.steps) && (!Mt.isNumber(Ee.steps) || !Mt.between(Ee.steps, 1, 255)))
          throw new Error("Bad 'steps' value");
        for (var $ in this._params)
          this._params.hasOwnProperty($) && Ee.hasOwnProperty($) && (this._params[$] = Ee[$]);
        this._calculatedThreshold = null;
      }
    },
    /**
     * Returns image as <symbol> tag. Always has viewBox specified
     *
     * @param {string} id
     */
    getSymbol: function(Ee) {
      var $ = this._potrace._luminanceData.width, Q = this._potrace._luminanceData.height, r = this._pathTags(!0);
      return '<symbol viewBox="0 0 ' + $ + " " + Q + '" id="' + Ee + '">' + r.join("") + "</symbol>";
    },
    /**
     * Generates SVG image
     * @returns {String}
     */
    getSVG: function() {
      var Ee = this._potrace._luminanceData.width, $ = this._potrace._luminanceData.height, Q = this._pathTags(!1), r = '<svg xmlns="http://www.w3.org/2000/svg" width="' + Ee + '" height="' + $ + '" viewBox="0 0 ' + Ee + " " + $ + `" version="1.1">
	` + (this._params.background !== Qe.COLOR_TRANSPARENT ? '<rect x="0" y="0" width="100%" height="100%" fill="' + this._params.background + `" />
	` : "") + Q.join(`
	`) + `
</svg>`;
      return r.replace(/\n(?:\t*\n)+(\t*)/g, `
$1`);
    }
  }, S_ = pt, S_;
}
var T_, fv;
function kb() {
  if (fv) return T_;
  fv = 1;
  var Qe = Sv(), Mt = Db();
  function pt(Ee, $, Q) {
    arguments.length === 2 && (Q = $, $ = {});
    var r = new Qe($);
    r.loadImage(Ee, function(F) {
      if (F)
        return Q(F);
      Q(null, r.getSVG(), r);
    });
  }
  function te(Ee, $, Q) {
    arguments.length === 2 && (Q = $, $ = {});
    var r = new Mt($);
    r.loadImage(Ee, function(F) {
      if (F)
        return Q(F);
      Q(null, r.getSVG(), r);
    });
  }
  return T_ = {
    trace: pt,
    posterize: te,
    Potrace: Qe,
    Posterizer: Mt
  }, T_;
}
var zb = kb();
const dv = /* @__PURE__ */ Hp(zb), Ob = ({
  map: Qe,
  metalType: Mt,
  setPreviewContent: pt,
  setPreviewType: te,
  setShowBackgroundSelector: Ee,
  cf: $,
  setCustomFields: Q
}) => {
  const r = () => {
    const F = Qe.current.getCenter(), H = Qe.current.project(F), E = document.querySelector(".map-mask").getBoundingClientRect().width / 2, x = Qe.current.queryRenderedFeatures({
      layers: ["road-network", "parks", "water", "background"],
      geometry: {
        type: "Circle",
        coordinates: F.toArray(),
        radius: E * 2 / Qe.current.transform.scale
      }
    });
    let m = [];
    const I = document.createElement("canvas");
    I.width = E * 2, I.height = E * 2;
    const z = I.getContext("2d");
    x.forEach((N) => {
      if (N.layer.id === "parks" && N.geometry.coordinates.forEach((U) => {
        const V = U[0].map((W) => {
          if (W[0] && W[1]) {
            const q = Qe.current.project([W[0], W[1]]);
            return {
              x: q.x - (H.x - E),
              y: q.y - (H.y - E)
            };
          }
        }).filter(Boolean);
        z.fillStyle = "#91d891", z.beginPath(), V.forEach((W, q) => {
          q === 0 ? z.moveTo(W.x, W.y) : z.lineTo(W.x, W.y);
        }), z.closePath(), z.fill(), m.push(V);
      }), N.geometry.type === "LineString") {
        const U = N.geometry.coordinates.map((V) => {
          const W = Qe.current.project([V[0], V[1]]);
          return {
            x: W.x - (H.x - E),
            y: W.y - (H.y - E)
          };
        });
        m.push(U);
      }
      N.geometry.type === "MultiLineString" && N.geometry.coordinates.forEach((U) => {
        const V = U.map((W) => {
          const q = Qe.current.project([W[0], W[1]]);
          return {
            x: q.x - (H.x - E),
            y: q.y - (H.y - E)
          };
        });
        m.push(V);
      });
    });
    const w = document.createElement("canvas");
    w.width = E * 2, w.height = E * 2;
    const C = w.getContext("2d");
    C.strokeStyle = `var(--metal-${Mt}-color)`, C.beginPath(), m.forEach((N) => {
      N.forEach((U, V) => {
        V === 0 ? C.moveTo(U.x, U.y) : C.lineTo(U.x, U.y);
      });
    }), C.stroke();
    const b = new dv.Potrace(), B = new dv.Potrace();
    B.loadImage(I.toDataURL(), () => {
      const N = B.getPathTag().replace("<path", '<path class="park-area"');
      b.loadImage(w.toDataURL(), () => {
        const U = b.getPathTag(), V = `
                    <defs>
                        <clipPath id="circleClip">
                            <circle cx="${E}" cy="${E}" r="${E}"/>
                        </clipPath>
                    </defs>
                `, W = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
                    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
                    <svg width="${E * 2}" height="${E * 2}" viewBox="0 0 ${E * 2} ${E * 2}" xmlns="http://www.w3.org/2000/svg" version="1.1">
                        ${V}
                        <g clip-path="url(#circleClip)" class="metal-${Mt}">
                            ${U}${N}
                        </g>
                    </svg>`;
        pt(W), te("svg"), Q($), Ee(!0);
      });
    });
  };
  return /* @__PURE__ */ gi.jsx("div", { className: "design-confirmation", children: /* @__PURE__ */ gi.jsx("div", { className: "confirm-button", onClick: r, children: $.name }) });
};
function Bb(Qe, Mt) {
  if (Qe.match(/^[a-z]+:\/\//i))
    return Qe;
  if (Qe.match(/^\/\//))
    return window.location.protocol + Qe;
  if (Qe.match(/^[a-z]+:/i))
    return Qe;
  const pt = document.implementation.createHTMLDocument(), te = pt.createElement("base"), Ee = pt.createElement("a");
  return pt.head.appendChild(te), pt.body.appendChild(Ee), Mt && (te.href = Mt), Ee.href = Qe, Ee.href;
}
const Fb = /* @__PURE__ */ (() => {
  let Qe = 0;
  const Mt = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => (Qe += 1, `u${Mt()}${Qe}`);
})();
function Sh(Qe) {
  const Mt = [];
  for (let pt = 0, te = Qe.length; pt < te; pt++)
    Mt.push(Qe[pt]);
  return Mt;
}
let rd = null;
function Tv(Qe = {}) {
  return rd || (Qe.includeStyleProperties ? (rd = Qe.includeStyleProperties, rd) : (rd = Sh(window.getComputedStyle(document.documentElement)), rd));
}
function Vp(Qe, Mt) {
  const te = (Qe.ownerDocument.defaultView || window).getComputedStyle(Qe).getPropertyValue(Mt);
  return te ? parseFloat(te.replace("px", "")) : 0;
}
function Nb(Qe) {
  const Mt = Vp(Qe, "border-left-width"), pt = Vp(Qe, "border-right-width");
  return Qe.clientWidth + Mt + pt;
}
function Ub(Qe) {
  const Mt = Vp(Qe, "border-top-width"), pt = Vp(Qe, "border-bottom-width");
  return Qe.clientHeight + Mt + pt;
}
function Mv(Qe, Mt = {}) {
  const pt = Mt.width || Nb(Qe), te = Mt.height || Ub(Qe);
  return { width: pt, height: te };
}
function jb() {
  let Qe, Mt;
  try {
    Mt = process;
  } catch {
  }
  const pt = Mt && Mt.env ? Mt.env.devicePixelRatio : null;
  return pt && (Qe = parseInt(pt, 10), Number.isNaN(Qe) && (Qe = 1)), Qe || window.devicePixelRatio || 1;
}
const Bs = 16384;
function Vb(Qe) {
  (Qe.width > Bs || Qe.height > Bs) && (Qe.width > Bs && Qe.height > Bs ? Qe.width > Qe.height ? (Qe.height *= Bs / Qe.width, Qe.width = Bs) : (Qe.width *= Bs / Qe.height, Qe.height = Bs) : Qe.width > Bs ? (Qe.height *= Bs / Qe.width, Qe.width = Bs) : (Qe.width *= Bs / Qe.height, Qe.height = Bs));
}
function Gp(Qe) {
  return new Promise((Mt, pt) => {
    const te = new Image();
    te.onload = () => {
      te.decode().then(() => {
        requestAnimationFrame(() => Mt(te));
      });
    }, te.onerror = pt, te.crossOrigin = "anonymous", te.decoding = "async", te.src = Qe;
  });
}
async function Gb(Qe) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(Qe)).then(encodeURIComponent).then((Mt) => `data:image/svg+xml;charset=utf-8,${Mt}`);
}
async function Hb(Qe, Mt, pt) {
  const te = "http://www.w3.org/2000/svg", Ee = document.createElementNS(te, "svg"), $ = document.createElementNS(te, "foreignObject");
  return Ee.setAttribute("width", `${Mt}`), Ee.setAttribute("height", `${pt}`), Ee.setAttribute("viewBox", `0 0 ${Mt} ${pt}`), $.setAttribute("width", "100%"), $.setAttribute("height", "100%"), $.setAttribute("x", "0"), $.setAttribute("y", "0"), $.setAttribute("externalResourcesRequired", "true"), Ee.appendChild($), $.appendChild(Qe), Gb(Ee);
}
const hs = (Qe, Mt) => {
  if (Qe instanceof Mt)
    return !0;
  const pt = Object.getPrototypeOf(Qe);
  return pt === null ? !1 : pt.constructor.name === Mt.name || hs(pt, Mt);
};
function Wb(Qe) {
  const Mt = Qe.getPropertyValue("content");
  return `${Qe.cssText} content: '${Mt.replace(/'|"/g, "")}';`;
}
function Zb(Qe, Mt) {
  return Tv(Mt).map((pt) => {
    const te = Qe.getPropertyValue(pt), Ee = Qe.getPropertyPriority(pt);
    return `${pt}: ${te}${Ee ? " !important" : ""};`;
  }).join(" ");
}
function qb(Qe, Mt, pt, te) {
  const Ee = `.${Qe}:${Mt}`, $ = pt.cssText ? Wb(pt) : Zb(pt, te);
  return document.createTextNode(`${Ee}{${$}}`);
}
function pv(Qe, Mt, pt, te) {
  const Ee = window.getComputedStyle(Qe, pt), $ = Ee.getPropertyValue("content");
  if ($ === "" || $ === "none")
    return;
  const Q = Fb();
  try {
    Mt.className = `${Mt.className} ${Q}`;
  } catch {
    return;
  }
  const r = document.createElement("style");
  r.appendChild(qb(Q, pt, Ee, te)), Mt.appendChild(r);
}
function $b(Qe, Mt, pt) {
  pv(Qe, Mt, ":before", pt), pv(Qe, Mt, ":after", pt);
}
const mv = "application/font-woff", _v = "image/jpeg", Xb = {
  woff: mv,
  woff2: mv,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: _v,
  jpeg: _v,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function Yb(Qe) {
  const Mt = /\.([^./]*?)$/g.exec(Qe);
  return Mt ? Mt[1] : "";
}
function z_(Qe) {
  const Mt = Yb(Qe).toLowerCase();
  return Xb[Mt] || "";
}
function Kb(Qe) {
  return Qe.split(/,/)[1];
}
function L_(Qe) {
  return Qe.search(/^(data:)/) !== -1;
}
function Jb(Qe, Mt) {
  return `data:${Mt};base64,${Qe}`;
}
async function Av(Qe, Mt, pt) {
  const te = await fetch(Qe, Mt);
  if (te.status === 404)
    throw new Error(`Resource "${te.url}" not found`);
  const Ee = await te.blob();
  return new Promise(($, Q) => {
    const r = new FileReader();
    r.onerror = Q, r.onloadend = () => {
      try {
        $(pt({ res: te, result: r.result }));
      } catch (F) {
        Q(F);
      }
    }, r.readAsDataURL(Ee);
  });
}
const M_ = {};
function Qb(Qe, Mt, pt) {
  let te = Qe.replace(/\?.*/, "");
  return pt && (te = Qe), /ttf|otf|eot|woff2?/i.test(te) && (te = te.replace(/.*\//, "")), Mt ? `[${Mt}]${te}` : te;
}
async function O_(Qe, Mt, pt) {
  const te = Qb(Qe, Mt, pt.includeQueryParams);
  if (M_[te] != null)
    return M_[te];
  pt.cacheBust && (Qe += (/\?/.test(Qe) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime());
  let Ee;
  try {
    const $ = await Av(Qe, pt.fetchRequestInit, ({ res: Q, result: r }) => (Mt || (Mt = Q.headers.get("Content-Type") || ""), Kb(r)));
    Ee = Jb($, Mt);
  } catch ($) {
    Ee = pt.imagePlaceholder || "";
    let Q = `Failed to fetch resource: ${Qe}`;
    $ && (Q = typeof $ == "string" ? $ : $.message), Q && console.warn(Q);
  }
  return M_[te] = Ee, Ee;
}
async function ew(Qe) {
  const Mt = Qe.toDataURL();
  return Mt === "data:," ? Qe.cloneNode(!1) : Gp(Mt);
}
async function tw(Qe, Mt) {
  if (Qe.currentSrc) {
    const $ = document.createElement("canvas"), Q = $.getContext("2d");
    $.width = Qe.clientWidth, $.height = Qe.clientHeight, Q == null || Q.drawImage(Qe, 0, 0, $.width, $.height);
    const r = $.toDataURL();
    return Gp(r);
  }
  const pt = Qe.poster, te = z_(pt), Ee = await O_(pt, te, Mt);
  return Gp(Ee);
}
async function rw(Qe, Mt) {
  var pt;
  try {
    if (!((pt = Qe == null ? void 0 : Qe.contentDocument) === null || pt === void 0) && pt.body)
      return await $p(Qe.contentDocument.body, Mt, !0);
  } catch {
  }
  return Qe.cloneNode(!1);
}
async function iw(Qe, Mt) {
  return hs(Qe, HTMLCanvasElement) ? ew(Qe) : hs(Qe, HTMLVideoElement) ? tw(Qe, Mt) : hs(Qe, HTMLIFrameElement) ? rw(Qe, Mt) : Qe.cloneNode(Iv(Qe));
}
const nw = (Qe) => Qe.tagName != null && Qe.tagName.toUpperCase() === "SLOT", Iv = (Qe) => Qe.tagName != null && Qe.tagName.toUpperCase() === "SVG";
async function aw(Qe, Mt, pt) {
  var te, Ee;
  if (Iv(Mt))
    return Mt;
  let $ = [];
  return nw(Qe) && Qe.assignedNodes ? $ = Sh(Qe.assignedNodes()) : hs(Qe, HTMLIFrameElement) && (!((te = Qe.contentDocument) === null || te === void 0) && te.body) ? $ = Sh(Qe.contentDocument.body.childNodes) : $ = Sh(((Ee = Qe.shadowRoot) !== null && Ee !== void 0 ? Ee : Qe).childNodes), $.length === 0 || hs(Qe, HTMLVideoElement) || await $.reduce((Q, r) => Q.then(() => $p(r, pt)).then((F) => {
    F && Mt.appendChild(F);
  }), Promise.resolve()), Mt;
}
function ow(Qe, Mt, pt) {
  const te = Mt.style;
  if (!te)
    return;
  const Ee = window.getComputedStyle(Qe);
  Ee.cssText ? (te.cssText = Ee.cssText, te.transformOrigin = Ee.transformOrigin) : Tv(pt).forEach(($) => {
    let Q = Ee.getPropertyValue($);
    $ === "font-size" && Q.endsWith("px") && (Q = `${Math.floor(parseFloat(Q.substring(0, Q.length - 2))) - 0.1}px`), hs(Qe, HTMLIFrameElement) && $ === "display" && Q === "inline" && (Q = "block"), $ === "d" && Mt.getAttribute("d") && (Q = `path(${Mt.getAttribute("d")})`), te.setProperty($, Q, Ee.getPropertyPriority($));
  });
}
function sw(Qe, Mt) {
  hs(Qe, HTMLTextAreaElement) && (Mt.innerHTML = Qe.value), hs(Qe, HTMLInputElement) && Mt.setAttribute("value", Qe.value);
}
function lw(Qe, Mt) {
  if (hs(Qe, HTMLSelectElement)) {
    const pt = Mt, te = Array.from(pt.children).find((Ee) => Qe.value === Ee.getAttribute("value"));
    te && te.setAttribute("selected", "");
  }
}
function uw(Qe, Mt, pt) {
  return hs(Mt, Element) && (ow(Qe, Mt, pt), $b(Qe, Mt, pt), sw(Qe, Mt), lw(Qe, Mt)), Mt;
}
async function cw(Qe, Mt) {
  const pt = Qe.querySelectorAll ? Qe.querySelectorAll("use") : [];
  if (pt.length === 0)
    return Qe;
  const te = {};
  for (let $ = 0; $ < pt.length; $++) {
    const r = pt[$].getAttribute("xlink:href");
    if (r) {
      const F = Qe.querySelector(r), H = document.querySelector(r);
      !F && H && !te[r] && (te[r] = await $p(H, Mt, !0));
    }
  }
  const Ee = Object.values(te);
  if (Ee.length) {
    const $ = "http://www.w3.org/1999/xhtml", Q = document.createElementNS($, "svg");
    Q.setAttribute("xmlns", $), Q.style.position = "absolute", Q.style.width = "0", Q.style.height = "0", Q.style.overflow = "hidden", Q.style.display = "none";
    const r = document.createElementNS($, "defs");
    Q.appendChild(r);
    for (let F = 0; F < Ee.length; F++)
      r.appendChild(Ee[F]);
    Qe.appendChild(Q);
  }
  return Qe;
}
async function $p(Qe, Mt, pt) {
  return !pt && Mt.filter && !Mt.filter(Qe) ? null : Promise.resolve(Qe).then((te) => iw(te, Mt)).then((te) => aw(Qe, te, Mt)).then((te) => uw(Qe, te, Mt)).then((te) => cw(te, Mt));
}
const Cv = /url\((['"]?)([^'"]+?)\1\)/g, hw = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g, fw = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function dw(Qe) {
  const Mt = Qe.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${Mt})(['"]?\\))`, "g");
}
function pw(Qe) {
  const Mt = [];
  return Qe.replace(Cv, (pt, te, Ee) => (Mt.push(Ee), pt)), Mt.filter((pt) => !L_(pt));
}
async function mw(Qe, Mt, pt, te, Ee) {
  try {
    const $ = pt ? Bb(Mt, pt) : Mt, Q = z_(Mt);
    let r;
    return Ee || (r = await O_($, Q, te)), Qe.replace(dw(Mt), `$1${r}$3`);
  } catch {
  }
  return Qe;
}
function _w(Qe, { preferredFontFormat: Mt }) {
  return Mt ? Qe.replace(fw, (pt) => {
    for (; ; ) {
      const [te, , Ee] = hw.exec(pt) || [];
      if (!Ee)
        return "";
      if (Ee === Mt)
        return `src: ${te};`;
    }
  }) : Qe;
}
function Pv(Qe) {
  return Qe.search(Cv) !== -1;
}
async function Rv(Qe, Mt, pt) {
  if (!Pv(Qe))
    return Qe;
  const te = _w(Qe, pt);
  return pw(te).reduce(($, Q) => $.then((r) => mw(r, Q, Mt, pt)), Promise.resolve(te));
}
async function id(Qe, Mt, pt) {
  var te;
  const Ee = (te = Mt.style) === null || te === void 0 ? void 0 : te.getPropertyValue(Qe);
  if (Ee) {
    const $ = await Rv(Ee, null, pt);
    return Mt.style.setProperty(Qe, $, Mt.style.getPropertyPriority(Qe)), !0;
  }
  return !1;
}
async function gw(Qe, Mt) {
  await id("background", Qe, Mt) || await id("background-image", Qe, Mt), await id("mask", Qe, Mt) || await id("-webkit-mask", Qe, Mt) || await id("mask-image", Qe, Mt) || await id("-webkit-mask-image", Qe, Mt);
}
async function yw(Qe, Mt) {
  const pt = hs(Qe, HTMLImageElement);
  if (!(pt && !L_(Qe.src)) && !(hs(Qe, SVGImageElement) && !L_(Qe.href.baseVal)))
    return;
  const te = pt ? Qe.src : Qe.href.baseVal, Ee = await O_(te, z_(te), Mt);
  await new Promise(($, Q) => {
    Qe.onload = $, Qe.onerror = Mt.onImageErrorHandler ? (...F) => {
      try {
        $(Mt.onImageErrorHandler(...F));
      } catch (H) {
        Q(H);
      }
    } : Q;
    const r = Qe;
    r.decode && (r.decode = $), r.loading === "lazy" && (r.loading = "eager"), pt ? (Qe.srcset = "", Qe.src = Ee) : Qe.href.baseVal = Ee;
  });
}
async function vw(Qe, Mt) {
  const te = Sh(Qe.childNodes).map((Ee) => Lv(Ee, Mt));
  await Promise.all(te).then(() => Qe);
}
async function Lv(Qe, Mt) {
  hs(Qe, Element) && (await gw(Qe, Mt), await yw(Qe, Mt), await vw(Qe, Mt));
}
function xw(Qe, Mt) {
  const { style: pt } = Qe;
  Mt.backgroundColor && (pt.backgroundColor = Mt.backgroundColor), Mt.width && (pt.width = `${Mt.width}px`), Mt.height && (pt.height = `${Mt.height}px`);
  const te = Mt.style;
  return te != null && Object.keys(te).forEach((Ee) => {
    pt[Ee] = te[Ee];
  }), Qe;
}
const gv = {};
async function yv(Qe) {
  let Mt = gv[Qe];
  if (Mt != null)
    return Mt;
  const te = await (await fetch(Qe)).text();
  return Mt = { url: Qe, cssText: te }, gv[Qe] = Mt, Mt;
}
async function vv(Qe, Mt) {
  let pt = Qe.cssText;
  const te = /url\(["']?([^"')]+)["']?\)/g, $ = (pt.match(/url\([^)]+\)/g) || []).map(async (Q) => {
    let r = Q.replace(te, "$1");
    return r.startsWith("https://") || (r = new URL(r, Qe.url).href), Av(r, Mt.fetchRequestInit, ({ result: F }) => (pt = pt.replace(Q, `url(${F})`), [Q, F]));
  });
  return Promise.all($).then(() => pt);
}
function xv(Qe) {
  if (Qe == null)
    return [];
  const Mt = [], pt = /(\/\*[\s\S]*?\*\/)/gi;
  let te = Qe.replace(pt, "");
  const Ee = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  for (; ; ) {
    const F = Ee.exec(te);
    if (F === null)
      break;
    Mt.push(F[0]);
  }
  te = te.replace(Ee, "");
  const $ = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi, Q = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})", r = new RegExp(Q, "gi");
  for (; ; ) {
    let F = $.exec(te);
    if (F === null) {
      if (F = r.exec(te), F === null)
        break;
      $.lastIndex = r.lastIndex;
    } else
      r.lastIndex = $.lastIndex;
    Mt.push(F[0]);
  }
  return Mt;
}
async function bw(Qe, Mt) {
  const pt = [], te = [];
  return Qe.forEach((Ee) => {
    if ("cssRules" in Ee)
      try {
        Sh(Ee.cssRules || []).forEach(($, Q) => {
          if ($.type === CSSRule.IMPORT_RULE) {
            let r = Q + 1;
            const F = $.href, H = yv(F).then((P) => vv(P, Mt)).then((P) => xv(P).forEach((M) => {
              try {
                Ee.insertRule(M, M.startsWith("@import") ? r += 1 : Ee.cssRules.length);
              } catch (E) {
                console.error("Error inserting rule from remote css", {
                  rule: M,
                  error: E
                });
              }
            })).catch((P) => {
              console.error("Error loading remote css", P.toString());
            });
            te.push(H);
          }
        });
      } catch ($) {
        const Q = Qe.find((r) => r.href == null) || document.styleSheets[0];
        Ee.href != null && te.push(yv(Ee.href).then((r) => vv(r, Mt)).then((r) => xv(r).forEach((F) => {
          Q.insertRule(F, Q.cssRules.length);
        })).catch((r) => {
          console.error("Error loading remote stylesheet", r);
        })), console.error("Error inlining remote css file", $);
      }
  }), Promise.all(te).then(() => (Qe.forEach((Ee) => {
    if ("cssRules" in Ee)
      try {
        Sh(Ee.cssRules || []).forEach(($) => {
          pt.push($);
        });
      } catch ($) {
        console.error(`Error while reading CSS rules from ${Ee.href}`, $);
      }
  }), pt));
}
function ww(Qe) {
  return Qe.filter((Mt) => Mt.type === CSSRule.FONT_FACE_RULE).filter((Mt) => Pv(Mt.style.getPropertyValue("src")));
}
async function Ew(Qe, Mt) {
  if (Qe.ownerDocument == null)
    throw new Error("Provided element is not within a Document");
  const pt = Sh(Qe.ownerDocument.styleSheets), te = await bw(pt, Mt);
  return ww(te);
}
function Dv(Qe) {
  return Qe.trim().replace(/["']/g, "");
}
function Sw(Qe) {
  const Mt = /* @__PURE__ */ new Set();
  function pt(te) {
    (te.style.fontFamily || getComputedStyle(te).fontFamily).split(",").forEach(($) => {
      Mt.add(Dv($));
    }), Array.from(te.children).forEach(($) => {
      $ instanceof HTMLElement && pt($);
    });
  }
  return pt(Qe), Mt;
}
async function Tw(Qe, Mt) {
  const pt = await Ew(Qe, Mt), te = Sw(Qe);
  return (await Promise.all(pt.filter(($) => te.has(Dv($.style.fontFamily))).map(($) => {
    const Q = $.parentStyleSheet ? $.parentStyleSheet.href : null;
    return Rv($.cssText, Q, Mt);
  }))).join(`
`);
}
async function Mw(Qe, Mt) {
  const pt = Mt.fontEmbedCSS != null ? Mt.fontEmbedCSS : Mt.skipFonts ? null : await Tw(Qe, Mt);
  if (pt) {
    const te = document.createElement("style"), Ee = document.createTextNode(pt);
    te.appendChild(Ee), Qe.firstChild ? Qe.insertBefore(te, Qe.firstChild) : Qe.appendChild(te);
  }
}
async function Aw(Qe, Mt = {}) {
  const { width: pt, height: te } = Mv(Qe, Mt), Ee = await $p(Qe, Mt, !0);
  return await Mw(Ee, Mt), await Lv(Ee, Mt), xw(Ee, Mt), await Hb(Ee, pt, te);
}
async function Iw(Qe, Mt = {}) {
  const { width: pt, height: te } = Mv(Qe, Mt), Ee = await Aw(Qe, Mt), $ = await Gp(Ee), Q = document.createElement("canvas"), r = Q.getContext("2d"), F = Mt.pixelRatio || jb(), H = Mt.canvasWidth || pt, P = Mt.canvasHeight || te;
  return Q.width = H * F, Q.height = P * F, Mt.skipAutoScale || Vb(Q), Q.style.width = `${H}`, Q.style.height = `${P}`, Mt.backgroundColor && (r.fillStyle = Mt.backgroundColor, r.fillRect(0, 0, Q.width, Q.height)), r.drawImage($, 0, 0, Q.width, Q.height), Q;
}
async function Cw(Qe, Mt = {}) {
  return (await Iw(Qe, Mt)).toDataURL();
}
const Pw = ({
  previewContent: Qe,
  previewType: Mt,
  metalType: pt,
  selectedMarker: te,
  showBackgroundSelector: Ee,
  currentVariant: $,
  customFields: Q
}) => {
  var m;
  const r = nd(), [F, H] = Un.useState("transparent"), [P, M] = Un.useState((m = r.variant_metafields[$.id]) == null ? void 0 : m.shape), E = [{ type: "transparent" }, { type: "black" }], x = ({ onSelect: I, activeBackground: z }) => /* @__PURE__ */ gi.jsx("ul", { className: "background-selector", children: E.map((w) => /* @__PURE__ */ gi.jsx(
    "li",
    {
      className: `circle-option ${w.type} ${z === w.type ? "active" : ""}`,
      onClick: () => I(w.type)
    },
    w.type
  )) });
  return Up.useEffect(() => {
    Qe && (async () => {
      const z = document.querySelector(".preview-block"), w = await Cw(z, {
        quality: 1,
        pixelRatio: 2,
        skipAutoScale: !0
      }), C = await fetch(w).then((B) => B.blob());
      document.querySelectorAll('form[action="/cart/add"]').forEach((B) => {
        let N = B.querySelector(`input[name="properties[${Q.name}]"]`);
        N || (N = document.createElement("input"), N.type = "file", N.name = `properties[${Q.name}]`, N.accept = ".jpg,.jpeg,.png,.svg,.tiff,.bmp,.webp,.bpg", N.style.display = "none", B.appendChild(N)), B.querySelectorAll('button[type="submit"]').forEach((q) => {
          q.disabled = !1;
        });
        const V = new DataTransfer();
        V.items.add(new File([C], "map-snapshot.png", { type: "image/png" })), N.files = V.files;
        const W = new Promise((q, Y) => {
          B.addEventListener(
            "submit",
            async (re) => {
              console.log("flash"), re.preventDefault();
              const se = new FormData(B), ce = await (await fetch("/cart/add.js", {
                method: "POST",
                body: se
              })).json(), xe = (await (await fetch("/cart.js")).json()).items.filter(
                (le) => le.variant_id === $.id && !le.properties[Q.name]
              );
              for (const le of xe)
                await fetch("/cart/change.js", {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json"
                  },
                  body: JSON.stringify({
                    id: le.key,
                    quantity: 0
                  })
                });
              q(ce);
            },
            { once: !0 }
          );
        });
        B.dispatchEvent(
          new CustomEvent("shineon/add_submit_deferred", {
            detail: { promise: W }
          })
        );
      });
    })();
  }, [Qe, te]), /* @__PURE__ */ gi.jsxs("div", { className: "preview-wrapper", children: [
    /* @__PURE__ */ gi.jsxs("div", { className: "preview-grid", children: [
      /* @__PURE__ */ gi.jsxs(
        "div",
        {
          className: `preview-block ${Mt !== "image" ? `metal-${pt}` : ""} bg-${F} mask-${P}`,
          style: {
            width: document.querySelector(".map-mask").offsetWidth + "px",
            height: document.querySelector(".map-mask").offsetHeight + "px"
          },
          children: [
            Mt === "image" ? /* @__PURE__ */ gi.jsx("img", { src: Qe, alt: "Map preview" }) : /* @__PURE__ */ gi.jsx("div", { dangerouslySetInnerHTML: { __html: Qe } }),
            /* @__PURE__ */ gi.jsx(R_, { renderInMap: !0, selectedType: te, metalType: pt })
          ]
        }
      ),
      Ee && /* @__PURE__ */ gi.jsx(gi.Fragment, { children: /* @__PURE__ */ gi.jsx(
        x,
        {
          onSelect: (I) => H(I),
          activeBackground: F
        }
      ) })
    ] }),
    !1
  ] });
}, Rw = ({ currentVariant: Qe }) => {
  var b;
  const [Mt, pt] = Un.useState("none"), te = Up.useRef(null), Ee = Up.useRef(null), $ = nd(), r = Wp().filter((B) => {
    var N;
    return B.field_type === "custom" && ((N = B.slug) == null ? void 0 : N.includes("capture-"));
  }), F = ((b = $.variant_metafields[Qe.id]) == null ? void 0 : b.metal) || "", [H, P] = Un.useState(F), [M, E] = Un.useState(null), [x, m] = Un.useState(null), [I, z] = Un.useState(null), [w, C] = Un.useState(!1);
  return Un.useEffect(() => {
    var N;
    const B = ((N = $.variant_metafields[Qe.id]) == null ? void 0 : N.metal) || "";
    P(B);
  }, [Qe, $]), Un.useEffect(() => {
    document.querySelectorAll('form[action="/cart/add"]').forEach((N) => {
      N.querySelectorAll('button[type="submit"]').forEach((V) => {
        V.disabled = !0;
      });
    });
  }, []), Up.useEffect(() => (P_.accessToken = "pk.eyJ1IjoiYWxla3NoaW5lb24iLCJhIjoiY202ejZiYjZxMDFnZjJrcXM3b2F4OTI1ZiJ9.OuSSAJIvxBUncZsIa4f9dg", document.querySelector(".map-mask").getBoundingClientRect().width / 2, Ee.current = new P_.Map({
    container: te.current,
    preserveDrawingBuffer: !0,
    style: {
      version: 8,
      sources: {
        "mapbox-streets": {
          type: "vector",
          url: "mapbox://mapbox.mapbox-streets-v8"
        }
      },
      layers: [
        {
          id: "background",
          type: "background",
          paint: {
            "background-color": "#ffffff"
          }
        },
        {
          id: "water",
          type: "fill",
          source: "mapbox-streets",
          "source-layer": "water",
          paint: {
            "fill-color": "#82b8ff"
          }
        },
        {
          id: "parks",
          type: "fill",
          source: "mapbox-streets",
          "source-layer": "landuse",
          filter: ["==", "class", "park"],
          paint: {
            "fill-color": "#91d891"
          }
        },
        {
          id: "road-network",
          type: "line",
          source: "mapbox-streets",
          "source-layer": "road",
          filter: [
            "in",
            "class",
            "motorway",
            "trunk",
            "primary",
            "secondary",
            "tertiary",
            "street",
            "street_limited",
            "residential"
          ],
          paint: {
            "line-color": "#222222",
            "line-width": [
              "match",
              ["get", "class"],
              "motorway",
              2,
              "trunk",
              1.5,
              "primary",
              1,
              "secondary",
              0.8,
              "tertiary",
              0.6,
              "street",
              0.5,
              "street_limited",
              0.4,
              "residential",
              0.3,
              0.3
            ]
          }
        }
      ]
    },
    center: [-74.006, 40.7128],
    zoom: 12
  }), () => Ee.current.remove()), []), /* @__PURE__ */ gi.jsx(gi.Fragment, { children: /* @__PURE__ */ gi.jsxs("div", { className: "so-tw", children: [
    /* @__PURE__ */ gi.jsxs("div", { className: "map-container", children: [
      /* @__PURE__ */ gi.jsx("div", { ref: te, className: "map" }),
      /* @__PURE__ */ gi.jsx("div", { className: "map-overlay", children: /* @__PURE__ */ gi.jsx("div", { className: `map-mask map-circle metal-${H}`, children: /* @__PURE__ */ gi.jsx("span", { className: "so-hidden hidden" }) }) }),
      /* @__PURE__ */ gi.jsx(R_, { renderInMap: !0, selectedType: Mt, metalType: H })
    ] }),
    /* @__PURE__ */ gi.jsx(
      R_,
      {
        renderInMap: !1,
        selectedType: Mt,
        onMarkerChange: pt,
        metalType: H
      }
    ),
    M && /* @__PURE__ */ gi.jsx(
      Pw,
      {
        previewContent: M,
        previewType: I,
        metalType: H,
        width: document.querySelector(".map-mask").offsetWidth + "px",
        height: document.querySelector(".map-mask").offsetHeight + "px",
        selectedMarker: Mt,
        showBackgroundSelector: w,
        currentVariant: Qe,
        customFields: x
      }
    ),
    /* @__PURE__ */ gi.jsx("div", { className: "button-row", children: r.map(
      (B) => B.slug === "capture-image" ? /* @__PURE__ */ gi.jsx(
        Ab,
        {
          map: Ee,
          setPreviewContent: E,
          setPreviewType: z,
          setShowBackgroundSelector: C,
          setCustomFields: m,
          cf: B
        }
      ) : B.slug === "capture-vector" ? /* @__PURE__ */ gi.jsx(
        Ob,
        {
          map: Ee,
          metalType: H,
          currentVariant: Qe,
          setPreviewContent: E,
          setPreviewType: z,
          setShowBackgroundSelector: C,
          setCustomFields: m,
          cf: B
        }
      ) : null
    ) })
  ] }) });
}, A_ = [
  {
    type: "birthstone"
  },
  {
    type: "heart"
  }
], Lw = ({
  formId: Qe,
  availableAccessories: Mt,
  currentVariant: pt,
  InputField: te,
  selectedAccessories: Ee,
  setSelectedAccessories: $,
  accessoriesCF: Q
}) => {
  const { state: r, dispatch: F } = Un.useContext(B_), H = nd(), P = Wp(), [M, E] = Un.useState([]), x = Un.useMemo(
    () => {
      var b;
      return ((b = H.variant_metafields[pt.id]) == null ? void 0 : b.engravings) || 0;
    },
    [pt.id, H.variant_metafields]
  ), m = Un.useMemo(
    () => P.filter(
      (b) => b.field_type === "engraving" && Ee.some((B) => {
        var N;
        return (N = b.class) == null ? void 0 : N.includes(B.type);
      })
    ),
    [P, Ee]
  ), I = (b, B) => {
    if (Ee.length >= x) return;
    const N = { type: b, option: B };
    $([...Ee, N]), C(!1);
    const U = Ee.length;
    document.querySelectorAll('form[action="/cart/add"]').forEach((W) => {
      const q = document.createElement("input");
      q.type = "hidden", q.name = `properties[${Q[U].name}]`, q.value = B, W.appendChild(q);
    });
  }, z = (b, B) => {
    document.querySelectorAll('form[action="/cart/add"]').forEach((V) => {
      const W = V.querySelector(`input[name="properties[${B}]"]`);
      W && W.type === "hidden" && W.remove();
      const q = V.querySelector(`input[name="properties[${Q[b].name}]"]`);
      q && q.remove(), Array.from(V.querySelectorAll('input[name^="properties[Birthstone"]')).forEach((re, se) => {
        se >= b && (re.name = `properties[${Q[se].name}]`);
      });
    });
    const U = [];
    m.slice(0, Ee.length).map((V, W) => {
      const q = V.name, Y = document.querySelector(`input[name="properties[${q}]"]`);
      B !== q && U.push({
        name: q,
        value: Y.value
      });
    }), E(U), $((V) => V.filter((W, q) => q !== b));
  };
  Un.useEffect(() => wb(() => {
    var U;
    const N = ((U = H.variant_metafields[pt.id]) == null ? void 0 : U.engravings) || 0;
    Ee.length > N && $((V) => V.slice(0, N));
  }), []), Un.useEffect(() => {
    var B;
    const b = ((B = H.variant_metafields[pt.id]) == null ? void 0 : B.engravings) || 0;
    $((N) => N.slice(0, b));
  }, [pt]);
  const [w, C] = Un.useState(!1);
  return Un.useEffect(() => {
    const b = document.querySelectorAll('form[action="/cart/add"]');
    m.slice(0, Ee.length).map((N, U) => {
      const V = N.name, W = document.querySelector(`input[name="properties[${V}]"]`);
      M[U] && (W && (W.value = M[U].value), b.forEach((q) => {
        const Y = q.querySelector(`input[name="properties[${V}]"]`), re = q.querySelector(
          `input[name="properties[${M[U].name}]"]`
        );
        re && (Y == null ? void 0 : Y.type) === "hidden" && (re.name = `properties[${V}]`);
      }), E([]));
    });
    const B = (N) => {
      Ee.length < x && (N.preventDefault(), C(!0));
    };
    return b.forEach((N) => {
      const U = N.querySelector('button[type="submit"]');
      U && U.addEventListener("click", B);
    }), () => {
      b.forEach((N) => {
        const U = N.querySelector('button[type="submit"]');
        U && U.removeEventListener("click", B);
      });
    };
  }, [Ee, x]), /* @__PURE__ */ gi.jsxs("div", { className: "so-accessories", children: [
    Mt.map((b) => /* @__PURE__ */ gi.jsxs(
      "div",
      {
        className: `so-${b.field_type}-container ${w && Ee.length < x ? "so-validation-error" : ""}`,
        children: [
          /* @__PURE__ */ gi.jsx("div", { className: "so-counter-wrap", children: /* @__PURE__ */ gi.jsxs("span", { children: [
            "Selected: ",
            Ee.length,
            " of ",
            x
          ] }) }),
          /* @__PURE__ */ gi.jsx("div", { className: "so-options-grid", children: /* @__PURE__ */ gi.jsx("ul", { className: "so-accessories-list", children: b.options.map((B) => {
            var N;
            return /* @__PURE__ */ gi.jsxs("li", { children: [
              /* @__PURE__ */ gi.jsx(
                "input",
                {
                  type: "radio",
                  name: b.name,
                  value: B,
                  required: Ee.length < x,
                  style: { position: "absolute", opacity: 0 },
                  checked: Ee.some((U) => U.option === B),
                  onChange: () => I(b.field_type, B)
                }
              ),
              /* @__PURE__ */ gi.jsxs(
                "label",
                {
                  className: "so-accessory-option",
                  onClick: () => I(b.field_type, B),
                  "aria-disabled": Ee.length >= x,
                  children: [
                    b.field_type === "birthstone" && /* @__PURE__ */ gi.jsx(
                      "div",
                      {
                        className: `so-custom-field-birthstone-circle ${B} no-loop ${(N = b.class) != null && N.includes("engraving") ? "no-loop" : ""}`,
                        children: /* @__PURE__ */ gi.jsx("span", { class: "visually-hidden", children: B })
                      }
                    ),
                    /* @__PURE__ */ gi.jsx("span", { children: B })
                  ]
                }
              )
            ] }, B);
          }) }) })
        ]
      },
      b.field_type
    )),
    Ee.length > 0 && /* @__PURE__ */ gi.jsx("div", { className: "so-engraving-fields-container", children: m.slice(0, Ee.length).map((b, B) => {
      const N = Ee[B], U = b.name;
      return /* @__PURE__ */ gi.jsxs("div", { className: "so-input-with-remove", children: [
        /* @__PURE__ */ gi.jsx(
          "button",
          {
            type: "button",
            className: "so-remove-acc",
            onClick: () => z(B, U),
            children: /* @__PURE__ */ gi.jsx(
              "svg",
              {
                width: "14",
                height: "14",
                viewBox: "0 0 14 14",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                children: /* @__PURE__ */ gi.jsx(
                  "path",
                  {
                    d: "M13 1L1 13M1 1L13 13",
                    stroke: "currentColor",
                    strokeWidth: "2",
                    strokeLinecap: "round"
                  }
                )
              }
            )
          }
        ),
        /* @__PURE__ */ gi.jsx(
          te,
          {
            product_cf: {
              ...b,
              name: U,
              placeholder: `${b.label} ${N.option}`
            },
            required: b.required,
            formId: Qe,
            dispatch: F,
            index: B,
            productInfo: H,
            currentVariant: pt,
            selectedAccessories: Ee,
            setSelectedAccessories: $
          }
        )
      ] });
    }) })
  ] });
}, B_ = Un.createContext(), Dw = (Qe, Mt) => {
  switch (Mt.type) {
    case "UPDATE_SYMBOL_COUNT":
      return {
        ...Qe,
        symbolCounts: {
          ...Qe.symbolCounts,
          [Mt.payload.id]: Mt.payload.count
        }
      };
    case "SET_ERROR":
      return {
        ...Qe,
        showNotification: Mt.payload.show,
        errorSymbol: Mt.payload.symbol
      };
    case "RESET_SYMBOL_COUNTS":
      return {
        ...Qe,
        symbolCounts: {}
      };
    default:
      return Qe;
  }
}, I_ = Un.memo(
  ({ product_cf: Qe, required: Mt, formId: pt, dispatch: te, fontPreviewConfig: Ee, currentVariant: $, productInfo: Q }) => {
    var C;
    const { state: r } = Un.useContext(B_), [F, H] = Un.useState(""), P = window.Shopify.locale, M = ((C = Q.variant_metafields[$.id]) == null ? void 0 : C.metal) || "silver", E = (b) => {
      const B = Qe.pattern;
      B && (new RegExp(B).test(b.data) ? te({
        type: "SET_ERROR",
        payload: { show: !1, symbol: "" }
      }) : (b.preventDefault(), te({
        type: "SET_ERROR",
        payload: { show: !0, symbol: b.data }
      })));
    }, x = (b) => {
      document.querySelectorAll('form[action="/cart/add"]').forEach((N) => {
        let U = N.querySelector(`input[name="${b.name}"]`);
        U || (U = document.createElement("input"), U.type = "hidden", U.name = b.name, N.appendChild(U)), U.value = b.value;
      });
    }, [m, I] = Un.useState({}), z = async (b) => {
      b.preventDefault();
      const B = document.querySelectorAll('.so-hyper input[type="text"]'), N = {};
      B.forEach((U) => {
        U.required && !U.value.length && (N[U.name] = !0);
      }), I(N);
    }, w = (b) => {
      I((N) => ({
        ...N,
        [b.target.name]: !1
      }));
      const B = b.target.value.charAt(0).toUpperCase() + b.target.value.slice(1);
      b.target.value = B, H(B), te({
        type: "UPDATE_SYMBOL_COUNT",
        payload: { id: Qe.id.key, count: b.target.value.length }
      }), bb(() => {
        x(b.target);
      });
    };
    return Un.useEffect(() => {
      const b = document.querySelectorAll('form[action="/cart/add"]');
      return b.forEach((B) => {
        const N = B.querySelector('button[type="submit"]');
        N && N.addEventListener("click", z);
      }), () => {
        b.forEach((B) => {
          const N = B.querySelector('button[type="submit"]');
          N && N.removeEventListener("click", z);
        });
      };
    }, []), /* @__PURE__ */ gi.jsxs("div", { className: `so-field-wrapper ${m[`properties[${Qe.name}]`] ? "error" : ""}`, children: [
      /* @__PURE__ */ gi.jsx("label", { className: "so-form__label", children: Qe.name }),
      /* @__PURE__ */ gi.jsxs("div", { className: "so-field", children: [
        /* @__PURE__ */ gi.jsxs("div", { className: "so-input-counter-w", children: [
          /* @__PURE__ */ gi.jsx(
            Eb,
            {
              product_cf: Qe,
              required: Mt,
              formId: pt,
              onBeforeInput: E,
              onChange: w
            }
          ),
          !r.showNotification && /* @__PURE__ */ gi.jsxs(
            "span",
            {
              className: `so-counter ${r.symbolCounts[Qe.id.key] ? "so-input-filled" : ""}`,
              children: [
                r.symbolCounts[Qe.id.key] || 0,
                "/",
                Qe.maxlength || 20
              ]
            }
          )
        ] }),
        (Ee == null ? void 0 : Ee.fields.length) > 0 && /* @__PURE__ */ gi.jsx("div", { className: "font-preview-w", "data-metal": M, children: /* @__PURE__ */ gi.jsx("div", { className: `preview ${Ee.fields[0].class}`, children: /* @__PURE__ */ gi.jsx("span", { className: "colored-with-gradient", children: (F || Qe.name) + (Ee.symbolAtEnd.length > 0 ? Ee.symbolAtEnd[0].options[0].code : "") }) }) }),
        r.showNotification && /* @__PURE__ */ gi.jsx("span", { className: "so-wrong-input-notification", children: `"${r.errorSymbol}"${yb[P].errors.invalid_character}` })
      ] })
    ] });
  }
), kw = () => {
  var I;
  const Qe = nd(), Mt = Wp(), pt = Qe.shop_info.sectionID ? "product-form-" + Qe.shop_info.sectionID : vb(), [te, Ee] = Un.useState(xb()), [$, Q] = Un.useState([]), [r, F] = Un.useReducer(Dw, {
    symbolCounts: {},
    showNotification: !1,
    errorSymbol: ""
  });
  Un.useEffect(() => {
    const z = (b) => {
      Ee(
        Qe.product.variants.filter(
          (B) => B.id === parseInt(document.querySelector('[name="id"]').value)
        )[0]
      );
    }, w = Qe.trigger_selector ? Qe.trigger_selector : Qe.variant_id_input, C = document.querySelectorAll(w);
    return C.forEach((b) => b.addEventListener("change", z)), () => {
      C.forEach((b) => b.removeEventListener("change", z));
    };
  }, []);
  const H = Mt.filter(
    (z) => z.field_type === "engraving" && z.required && !A_.some((w) => {
      var C;
      return (C = z.class) == null ? void 0 : C.includes(w.type);
    })
  ), P = Mt.filter(
    (z) => z.field_type === "engraving" && !z.required && !A_.some((w) => {
      var C;
      return (C = z.class) == null ? void 0 : C.includes(w.type);
    })
  ).slice(0, ((I = Qe.variant_metafields[te.id]) == null ? void 0 : I.engravings) || 0), M = Mt.filter((z) => A_.some((w) => z.field_type === w.type)), E = Mt.filter((z) => z.field_type === "custom" && z.type != "none"), x = {
    fields: Mt.filter(
      (z) => {
        var w;
        return z.field_type === "custom" && ((w = z.slug) == null ? void 0 : w.includes("font-family-preview"));
      }
    ),
    symbolAtEnd: Mt.filter(
      (z) => {
        var w;
        return z.field_type === "custom" && ((w = z.class) == null ? void 0 : w.includes("symbol-at-the-end"));
      }
    )
  }, m = Mt.filter((z) => {
    var w;
    return z.field_type === "custom" && ((w = z.slug) == null ? void 0 : w.includes("capture-"));
  });
  return /* @__PURE__ */ gi.jsxs(B_.Provider, { value: { state: r, dispatch: F }, children: [
    /* @__PURE__ */ gi.jsxs("div", { className: "so-hyper so-tw", children: [
      H.map((z, w) => /* @__PURE__ */ gi.jsx(
        I_,
        {
          product_cf: z,
          required: !0,
          formId: pt,
          dispatch: F,
          fontPreviewConfig: x,
          currentVariant: te,
          productInfo: Qe
        },
        `required-${w}`
      )),
      P.map((z, w) => /* @__PURE__ */ gi.jsx(
        I_,
        {
          product_cf: z,
          required: !0,
          formId: pt,
          dispatch: F,
          currentVariant: te,
          productInfo: Qe
        },
        `optional-${w}`
      )),
      M.length > 0 && /* @__PURE__ */ gi.jsx(
        Lw,
        {
          formId: pt,
          availableAccessories: M,
          currentVariant: te,
          InputField: I_,
          selectedAccessories: $,
          setSelectedAccessories: Q,
          accessoriesCF: E,
          productInfo: Qe
        }
      )
    ] }),
    (m == null ? void 0 : m.length) > 0 && /* @__PURE__ */ gi.jsx(Rw, { currentVariant: te })
  ] });
};
document.addEventListener("DOMContentLoaded", () => {
  const Qe = document.getElementById("so-hyper");
  Qe && _b.createRoot(Qe).render(
    /* @__PURE__ */ gi.jsx(Un.StrictMode, { children: /* @__PURE__ */ gi.jsx(kw, {}) })
  );
});
