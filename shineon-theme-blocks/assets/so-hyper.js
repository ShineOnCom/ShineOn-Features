var Qn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function dd(mt) {
  return mt && mt.__esModule && Object.prototype.hasOwnProperty.call(mt, "default") ? mt.default : mt;
}
function Xy(mt) {
  if (mt.__esModule) return mt;
  var Tt = mt.default;
  if (typeof Tt == "function") {
    var qe = function Q() {
      return this instanceof Q ? Reflect.construct(Tt, arguments, this.constructor) : Tt.apply(this, arguments);
    };
    qe.prototype = Tt.prototype;
  } else qe = {};
  return Object.defineProperty(qe, "__esModule", { value: !0 }), Object.keys(mt).forEach(function(Q) {
    var de = Object.getOwnPropertyDescriptor(mt, Q);
    Object.defineProperty(qe, Q, de.get ? de : {
      enumerable: !0,
      get: function() {
        return mt[Q];
      }
    });
  }), qe;
}
var v_ = { exports: {} }, ep = {}, y_ = { exports: {} }, Fn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var R1;
function Vw() {
  if (R1) return Fn;
  R1 = 1;
  var mt = Symbol.for("react.element"), Tt = Symbol.for("react.portal"), qe = Symbol.for("react.fragment"), Q = Symbol.for("react.strict_mode"), de = Symbol.for("react.profiler"), q = Symbol.for("react.provider"), ie = Symbol.for("react.context"), i = Symbol.for("react.forward_ref"), N = Symbol.for("react.suspense"), Z = Symbol.for("react.memo"), R = Symbol.for("react.lazy"), A = Symbol.iterator;
  function M(ut) {
    return ut === null || typeof ut != "object" ? null : (ut = A && ut[A] || ut["@@iterator"], typeof ut == "function" ? ut : null);
  }
  var x = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, m = Object.assign, w = {};
  function k(ut, bt, pt) {
    this.props = ut, this.context = bt, this.refs = w, this.updater = pt || x;
  }
  k.prototype.isReactComponent = {}, k.prototype.setState = function(ut, bt) {
    if (typeof ut != "object" && typeof ut != "function" && ut != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, ut, bt, "setState");
  }, k.prototype.forceUpdate = function(ut) {
    this.updater.enqueueForceUpdate(this, ut, "forceUpdate");
  };
  function E() {
  }
  E.prototype = k.prototype;
  function P(ut, bt, pt) {
    this.props = ut, this.context = bt, this.refs = w, this.updater = pt || x;
  }
  var S = P.prototype = new E();
  S.constructor = P, m(S, k.prototype), S.isPureReactComponent = !0;
  var U = Array.isArray, j = Object.prototype.hasOwnProperty, T = { current: null }, W = { key: !0, ref: !0, __self: !0, __source: !0 };
  function J(ut, bt, pt) {
    var Ke, dt = {}, ct = null, wt = null;
    if (bt != null) for (Ke in bt.ref !== void 0 && (wt = bt.ref), bt.key !== void 0 && (ct = "" + bt.key), bt) j.call(bt, Ke) && !W.hasOwnProperty(Ke) && (dt[Ke] = bt[Ke]);
    var Ht = arguments.length - 2;
    if (Ht === 1) dt.children = pt;
    else if (1 < Ht) {
      for (var $t = Array(Ht), rt = 0; rt < Ht; rt++) $t[rt] = arguments[rt + 2];
      dt.children = $t;
    }
    if (ut && ut.defaultProps) for (Ke in Ht = ut.defaultProps, Ht) dt[Ke] === void 0 && (dt[Ke] = Ht[Ke]);
    return { $$typeof: mt, type: ut, key: ct, ref: wt, props: dt, _owner: T.current };
  }
  function ee(ut, bt) {
    return { $$typeof: mt, type: ut.type, key: bt, ref: ut.ref, props: ut.props, _owner: ut._owner };
  }
  function te(ut) {
    return typeof ut == "object" && ut !== null && ut.$$typeof === mt;
  }
  function le(ut) {
    var bt = { "=": "=0", ":": "=2" };
    return "$" + ut.replace(/[=:]/g, function(pt) {
      return bt[pt];
    });
  }
  var me = /\/+/g;
  function ke(ut, bt) {
    return typeof ut == "object" && ut !== null && ut.key != null ? le("" + ut.key) : bt.toString(36);
  }
  function ge(ut, bt, pt, Ke, dt) {
    var ct = typeof ut;
    (ct === "undefined" || ct === "boolean") && (ut = null);
    var wt = !1;
    if (ut === null) wt = !0;
    else switch (ct) {
      case "string":
      case "number":
        wt = !0;
        break;
      case "object":
        switch (ut.$$typeof) {
          case mt:
          case Tt:
            wt = !0;
        }
    }
    if (wt) return wt = ut, dt = dt(wt), ut = Ke === "" ? "." + ke(wt, 0) : Ke, U(dt) ? (pt = "", ut != null && (pt = ut.replace(me, "$&/") + "/"), ge(dt, bt, pt, "", function(rt) {
      return rt;
    })) : dt != null && (te(dt) && (dt = ee(dt, pt + (!dt.key || wt && wt.key === dt.key ? "" : ("" + dt.key).replace(me, "$&/") + "/") + ut)), bt.push(dt)), 1;
    if (wt = 0, Ke = Ke === "" ? "." : Ke + ":", U(ut)) for (var Ht = 0; Ht < ut.length; Ht++) {
      ct = ut[Ht];
      var $t = Ke + ke(ct, Ht);
      wt += ge(ct, bt, pt, $t, dt);
    }
    else if ($t = M(ut), typeof $t == "function") for (ut = $t.call(ut), Ht = 0; !(ct = ut.next()).done; ) ct = ct.value, $t = Ke + ke(ct, Ht++), wt += ge(ct, bt, pt, $t, dt);
    else if (ct === "object") throw bt = String(ut), Error("Objects are not valid as a React child (found: " + (bt === "[object Object]" ? "object with keys {" + Object.keys(ut).join(", ") + "}" : bt) + "). If you meant to render a collection of children, use an array instead.");
    return wt;
  }
  function Ve(ut, bt, pt) {
    if (ut == null) return ut;
    var Ke = [], dt = 0;
    return ge(ut, Ke, "", "", function(ct) {
      return bt.call(pt, ct, dt++);
    }), Ke;
  }
  function Oe(ut) {
    if (ut._status === -1) {
      var bt = ut._result;
      bt = bt(), bt.then(function(pt) {
        (ut._status === 0 || ut._status === -1) && (ut._status = 1, ut._result = pt);
      }, function(pt) {
        (ut._status === 0 || ut._status === -1) && (ut._status = 2, ut._result = pt);
      }), ut._status === -1 && (ut._status = 0, ut._result = bt);
    }
    if (ut._status === 1) return ut._result.default;
    throw ut._result;
  }
  var Ue = { current: null }, we = { transition: null }, Ce = { ReactCurrentDispatcher: Ue, ReactCurrentBatchConfig: we, ReactCurrentOwner: T };
  function it() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return Fn.Children = { map: Ve, forEach: function(ut, bt, pt) {
    Ve(ut, function() {
      bt.apply(this, arguments);
    }, pt);
  }, count: function(ut) {
    var bt = 0;
    return Ve(ut, function() {
      bt++;
    }), bt;
  }, toArray: function(ut) {
    return Ve(ut, function(bt) {
      return bt;
    }) || [];
  }, only: function(ut) {
    if (!te(ut)) throw Error("React.Children.only expected to receive a single React element child.");
    return ut;
  } }, Fn.Component = k, Fn.Fragment = qe, Fn.Profiler = de, Fn.PureComponent = P, Fn.StrictMode = Q, Fn.Suspense = N, Fn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ce, Fn.act = it, Fn.cloneElement = function(ut, bt, pt) {
    if (ut == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + ut + ".");
    var Ke = m({}, ut.props), dt = ut.key, ct = ut.ref, wt = ut._owner;
    if (bt != null) {
      if (bt.ref !== void 0 && (ct = bt.ref, wt = T.current), bt.key !== void 0 && (dt = "" + bt.key), ut.type && ut.type.defaultProps) var Ht = ut.type.defaultProps;
      for ($t in bt) j.call(bt, $t) && !W.hasOwnProperty($t) && (Ke[$t] = bt[$t] === void 0 && Ht !== void 0 ? Ht[$t] : bt[$t]);
    }
    var $t = arguments.length - 2;
    if ($t === 1) Ke.children = pt;
    else if (1 < $t) {
      Ht = Array($t);
      for (var rt = 0; rt < $t; rt++) Ht[rt] = arguments[rt + 2];
      Ke.children = Ht;
    }
    return { $$typeof: mt, type: ut.type, key: dt, ref: ct, props: Ke, _owner: wt };
  }, Fn.createContext = function(ut) {
    return ut = { $$typeof: ie, _currentValue: ut, _currentValue2: ut, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, ut.Provider = { $$typeof: q, _context: ut }, ut.Consumer = ut;
  }, Fn.createElement = J, Fn.createFactory = function(ut) {
    var bt = J.bind(null, ut);
    return bt.type = ut, bt;
  }, Fn.createRef = function() {
    return { current: null };
  }, Fn.forwardRef = function(ut) {
    return { $$typeof: i, render: ut };
  }, Fn.isValidElement = te, Fn.lazy = function(ut) {
    return { $$typeof: R, _payload: { _status: -1, _result: ut }, _init: Oe };
  }, Fn.memo = function(ut, bt) {
    return { $$typeof: Z, type: ut, compare: bt === void 0 ? null : bt };
  }, Fn.startTransition = function(ut) {
    var bt = we.transition;
    we.transition = {};
    try {
      ut();
    } finally {
      we.transition = bt;
    }
  }, Fn.unstable_act = it, Fn.useCallback = function(ut, bt) {
    return Ue.current.useCallback(ut, bt);
  }, Fn.useContext = function(ut) {
    return Ue.current.useContext(ut);
  }, Fn.useDebugValue = function() {
  }, Fn.useDeferredValue = function(ut) {
    return Ue.current.useDeferredValue(ut);
  }, Fn.useEffect = function(ut, bt) {
    return Ue.current.useEffect(ut, bt);
  }, Fn.useId = function() {
    return Ue.current.useId();
  }, Fn.useImperativeHandle = function(ut, bt, pt) {
    return Ue.current.useImperativeHandle(ut, bt, pt);
  }, Fn.useInsertionEffect = function(ut, bt) {
    return Ue.current.useInsertionEffect(ut, bt);
  }, Fn.useLayoutEffect = function(ut, bt) {
    return Ue.current.useLayoutEffect(ut, bt);
  }, Fn.useMemo = function(ut, bt) {
    return Ue.current.useMemo(ut, bt);
  }, Fn.useReducer = function(ut, bt, pt) {
    return Ue.current.useReducer(ut, bt, pt);
  }, Fn.useRef = function(ut) {
    return Ue.current.useRef(ut);
  }, Fn.useState = function(ut) {
    return Ue.current.useState(ut);
  }, Fn.useSyncExternalStore = function(ut, bt, pt) {
    return Ue.current.useSyncExternalStore(ut, bt, pt);
  }, Fn.useTransition = function() {
    return Ue.current.useTransition();
  }, Fn.version = "18.3.1", Fn;
}
var k1;
function bg() {
  return k1 || (k1 = 1, y_.exports = Vw()), y_.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var L1;
function jw() {
  if (L1) return ep;
  L1 = 1;
  var mt = bg(), Tt = Symbol.for("react.element"), qe = Symbol.for("react.fragment"), Q = Object.prototype.hasOwnProperty, de = mt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, q = { key: !0, ref: !0, __self: !0, __source: !0 };
  function ie(i, N, Z) {
    var R, A = {}, M = null, x = null;
    Z !== void 0 && (M = "" + Z), N.key !== void 0 && (M = "" + N.key), N.ref !== void 0 && (x = N.ref);
    for (R in N) Q.call(N, R) && !q.hasOwnProperty(R) && (A[R] = N[R]);
    if (i && i.defaultProps) for (R in N = i.defaultProps, N) A[R] === void 0 && (A[R] = N[R]);
    return { $$typeof: Tt, type: i, key: M, ref: x, props: A, _owner: de.current };
  }
  return ep.Fragment = qe, ep.jsx = ie, ep.jsxs = ie, ep;
}
var O1;
function Gw() {
  return O1 || (O1 = 1, v_.exports = jw()), v_.exports;
}
var Dr = Gw(), _a = bg();
const Pf = /* @__PURE__ */ dd(_a);
var Zp = {}, x_ = { exports: {} }, nl = {}, b_ = { exports: {} }, w_ = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var D1;
function Hw() {
  return D1 || (D1 = 1, function(mt) {
    function Tt(we, Ce) {
      var it = we.length;
      we.push(Ce);
      e: for (; 0 < it; ) {
        var ut = it - 1 >>> 1, bt = we[ut];
        if (0 < de(bt, Ce)) we[ut] = Ce, we[it] = bt, it = ut;
        else break e;
      }
    }
    function qe(we) {
      return we.length === 0 ? null : we[0];
    }
    function Q(we) {
      if (we.length === 0) return null;
      var Ce = we[0], it = we.pop();
      if (it !== Ce) {
        we[0] = it;
        e: for (var ut = 0, bt = we.length, pt = bt >>> 1; ut < pt; ) {
          var Ke = 2 * (ut + 1) - 1, dt = we[Ke], ct = Ke + 1, wt = we[ct];
          if (0 > de(dt, it)) ct < bt && 0 > de(wt, dt) ? (we[ut] = wt, we[ct] = it, ut = ct) : (we[ut] = dt, we[Ke] = it, ut = Ke);
          else if (ct < bt && 0 > de(wt, it)) we[ut] = wt, we[ct] = it, ut = ct;
          else break e;
        }
      }
      return Ce;
    }
    function de(we, Ce) {
      var it = we.sortIndex - Ce.sortIndex;
      return it !== 0 ? it : we.id - Ce.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var q = performance;
      mt.unstable_now = function() {
        return q.now();
      };
    } else {
      var ie = Date, i = ie.now();
      mt.unstable_now = function() {
        return ie.now() - i;
      };
    }
    var N = [], Z = [], R = 1, A = null, M = 3, x = !1, m = !1, w = !1, k = typeof setTimeout == "function" ? setTimeout : null, E = typeof clearTimeout == "function" ? clearTimeout : null, P = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function S(we) {
      for (var Ce = qe(Z); Ce !== null; ) {
        if (Ce.callback === null) Q(Z);
        else if (Ce.startTime <= we) Q(Z), Ce.sortIndex = Ce.expirationTime, Tt(N, Ce);
        else break;
        Ce = qe(Z);
      }
    }
    function U(we) {
      if (w = !1, S(we), !m) if (qe(N) !== null) m = !0, Oe(j);
      else {
        var Ce = qe(Z);
        Ce !== null && Ue(U, Ce.startTime - we);
      }
    }
    function j(we, Ce) {
      m = !1, w && (w = !1, E(J), J = -1), x = !0;
      var it = M;
      try {
        for (S(Ce), A = qe(N); A !== null && (!(A.expirationTime > Ce) || we && !le()); ) {
          var ut = A.callback;
          if (typeof ut == "function") {
            A.callback = null, M = A.priorityLevel;
            var bt = ut(A.expirationTime <= Ce);
            Ce = mt.unstable_now(), typeof bt == "function" ? A.callback = bt : A === qe(N) && Q(N), S(Ce);
          } else Q(N);
          A = qe(N);
        }
        if (A !== null) var pt = !0;
        else {
          var Ke = qe(Z);
          Ke !== null && Ue(U, Ke.startTime - Ce), pt = !1;
        }
        return pt;
      } finally {
        A = null, M = it, x = !1;
      }
    }
    var T = !1, W = null, J = -1, ee = 5, te = -1;
    function le() {
      return !(mt.unstable_now() - te < ee);
    }
    function me() {
      if (W !== null) {
        var we = mt.unstable_now();
        te = we;
        var Ce = !0;
        try {
          Ce = W(!0, we);
        } finally {
          Ce ? ke() : (T = !1, W = null);
        }
      } else T = !1;
    }
    var ke;
    if (typeof P == "function") ke = function() {
      P(me);
    };
    else if (typeof MessageChannel < "u") {
      var ge = new MessageChannel(), Ve = ge.port2;
      ge.port1.onmessage = me, ke = function() {
        Ve.postMessage(null);
      };
    } else ke = function() {
      k(me, 0);
    };
    function Oe(we) {
      W = we, T || (T = !0, ke());
    }
    function Ue(we, Ce) {
      J = k(function() {
        we(mt.unstable_now());
      }, Ce);
    }
    mt.unstable_IdlePriority = 5, mt.unstable_ImmediatePriority = 1, mt.unstable_LowPriority = 4, mt.unstable_NormalPriority = 3, mt.unstable_Profiling = null, mt.unstable_UserBlockingPriority = 2, mt.unstable_cancelCallback = function(we) {
      we.callback = null;
    }, mt.unstable_continueExecution = function() {
      m || x || (m = !0, Oe(j));
    }, mt.unstable_forceFrameRate = function(we) {
      0 > we || 125 < we ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ee = 0 < we ? Math.floor(1e3 / we) : 5;
    }, mt.unstable_getCurrentPriorityLevel = function() {
      return M;
    }, mt.unstable_getFirstCallbackNode = function() {
      return qe(N);
    }, mt.unstable_next = function(we) {
      switch (M) {
        case 1:
        case 2:
        case 3:
          var Ce = 3;
          break;
        default:
          Ce = M;
      }
      var it = M;
      M = Ce;
      try {
        return we();
      } finally {
        M = it;
      }
    }, mt.unstable_pauseExecution = function() {
    }, mt.unstable_requestPaint = function() {
    }, mt.unstable_runWithPriority = function(we, Ce) {
      switch (we) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          we = 3;
      }
      var it = M;
      M = we;
      try {
        return Ce();
      } finally {
        M = it;
      }
    }, mt.unstable_scheduleCallback = function(we, Ce, it) {
      var ut = mt.unstable_now();
      switch (typeof it == "object" && it !== null ? (it = it.delay, it = typeof it == "number" && 0 < it ? ut + it : ut) : it = ut, we) {
        case 1:
          var bt = -1;
          break;
        case 2:
          bt = 250;
          break;
        case 5:
          bt = 1073741823;
          break;
        case 4:
          bt = 1e4;
          break;
        default:
          bt = 5e3;
      }
      return bt = it + bt, we = { id: R++, callback: Ce, priorityLevel: we, startTime: it, expirationTime: bt, sortIndex: -1 }, it > ut ? (we.sortIndex = it, Tt(Z, we), qe(N) === null && we === qe(Z) && (w ? (E(J), J = -1) : w = !0, Ue(U, it - ut))) : (we.sortIndex = bt, Tt(N, we), m || x || (m = !0, Oe(j))), we;
    }, mt.unstable_shouldYield = le, mt.unstable_wrapCallback = function(we) {
      var Ce = M;
      return function() {
        var it = M;
        M = Ce;
        try {
          return we.apply(this, arguments);
        } finally {
          M = it;
        }
      };
    };
  }(w_)), w_;
}
var z1;
function qw() {
  return z1 || (z1 = 1, b_.exports = Hw()), b_.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var B1;
function Ww() {
  if (B1) return nl;
  B1 = 1;
  var mt = bg(), Tt = qw();
  function qe(d) {
    for (var g = "https://reactjs.org/docs/error-decoder.html?invariant=" + d, $ = 1; $ < arguments.length; $++) g += "&args[]=" + encodeURIComponent(arguments[$]);
    return "Minified React error #" + d + "; visit " + g + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var Q = /* @__PURE__ */ new Set(), de = {};
  function q(d, g) {
    ie(d, g), ie(d + "Capture", g);
  }
  function ie(d, g) {
    for (de[d] = g, d = 0; d < g.length; d++) Q.add(g[d]);
  }
  var i = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), N = Object.prototype.hasOwnProperty, Z = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, R = {}, A = {};
  function M(d) {
    return N.call(A, d) ? !0 : N.call(R, d) ? !1 : Z.test(d) ? A[d] = !0 : (R[d] = !0, !1);
  }
  function x(d, g, $, he) {
    if ($ !== null && $.type === 0) return !1;
    switch (typeof g) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return he ? !1 : $ !== null ? !$.acceptsBooleans : (d = d.toLowerCase().slice(0, 5), d !== "data-" && d !== "aria-");
      default:
        return !1;
    }
  }
  function m(d, g, $, he) {
    if (g === null || typeof g > "u" || x(d, g, $, he)) return !0;
    if (he) return !1;
    if ($ !== null) switch ($.type) {
      case 3:
        return !g;
      case 4:
        return g === !1;
      case 5:
        return isNaN(g);
      case 6:
        return isNaN(g) || 1 > g;
    }
    return !1;
  }
  function w(d, g, $, he, je, ot, Vt) {
    this.acceptsBooleans = g === 2 || g === 3 || g === 4, this.attributeName = he, this.attributeNamespace = je, this.mustUseProperty = $, this.propertyName = d, this.type = g, this.sanitizeURL = ot, this.removeEmptyString = Vt;
  }
  var k = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(d) {
    k[d] = new w(d, 0, !1, d, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(d) {
    var g = d[0];
    k[g] = new w(g, 1, !1, d[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(d) {
    k[d] = new w(d, 2, !1, d.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(d) {
    k[d] = new w(d, 2, !1, d, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(d) {
    k[d] = new w(d, 3, !1, d.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(d) {
    k[d] = new w(d, 3, !0, d, null, !1, !1);
  }), ["capture", "download"].forEach(function(d) {
    k[d] = new w(d, 4, !1, d, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(d) {
    k[d] = new w(d, 6, !1, d, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(d) {
    k[d] = new w(d, 5, !1, d.toLowerCase(), null, !1, !1);
  });
  var E = /[\-:]([a-z])/g;
  function P(d) {
    return d[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(d) {
    var g = d.replace(
      E,
      P
    );
    k[g] = new w(g, 1, !1, d, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(d) {
    var g = d.replace(E, P);
    k[g] = new w(g, 1, !1, d, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(d) {
    var g = d.replace(E, P);
    k[g] = new w(g, 1, !1, d, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(d) {
    k[d] = new w(d, 1, !1, d.toLowerCase(), null, !1, !1);
  }), k.xlinkHref = new w("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(d) {
    k[d] = new w(d, 1, !1, d.toLowerCase(), null, !0, !0);
  });
  function S(d, g, $, he) {
    var je = k.hasOwnProperty(g) ? k[g] : null;
    (je !== null ? je.type !== 0 : he || !(2 < g.length) || g[0] !== "o" && g[0] !== "O" || g[1] !== "n" && g[1] !== "N") && (m(g, $, je, he) && ($ = null), he || je === null ? M(g) && ($ === null ? d.removeAttribute(g) : d.setAttribute(g, "" + $)) : je.mustUseProperty ? d[je.propertyName] = $ === null ? je.type === 3 ? !1 : "" : $ : (g = je.attributeName, he = je.attributeNamespace, $ === null ? d.removeAttribute(g) : (je = je.type, $ = je === 3 || je === 4 && $ === !0 ? "" : "" + $, he ? d.setAttributeNS(he, g, $) : d.setAttribute(g, $))));
  }
  var U = mt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, j = Symbol.for("react.element"), T = Symbol.for("react.portal"), W = Symbol.for("react.fragment"), J = Symbol.for("react.strict_mode"), ee = Symbol.for("react.profiler"), te = Symbol.for("react.provider"), le = Symbol.for("react.context"), me = Symbol.for("react.forward_ref"), ke = Symbol.for("react.suspense"), ge = Symbol.for("react.suspense_list"), Ve = Symbol.for("react.memo"), Oe = Symbol.for("react.lazy"), Ue = Symbol.for("react.offscreen"), we = Symbol.iterator;
  function Ce(d) {
    return d === null || typeof d != "object" ? null : (d = we && d[we] || d["@@iterator"], typeof d == "function" ? d : null);
  }
  var it = Object.assign, ut;
  function bt(d) {
    if (ut === void 0) try {
      throw Error();
    } catch ($) {
      var g = $.stack.trim().match(/\n( *(at )?)/);
      ut = g && g[1] || "";
    }
    return `
` + ut + d;
  }
  var pt = !1;
  function Ke(d, g) {
    if (!d || pt) return "";
    pt = !0;
    var $ = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (g) if (g = function() {
        throw Error();
      }, Object.defineProperty(g.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(g, []);
        } catch ($i) {
          var he = $i;
        }
        Reflect.construct(d, [], g);
      } else {
        try {
          g.call();
        } catch ($i) {
          he = $i;
        }
        d.call(g.prototype);
      }
      else {
        try {
          throw Error();
        } catch ($i) {
          he = $i;
        }
        d();
      }
    } catch ($i) {
      if ($i && he && typeof $i.stack == "string") {
        for (var je = $i.stack.split(`
`), ot = he.stack.split(`
`), Vt = je.length - 1, bi = ot.length - 1; 1 <= Vt && 0 <= bi && je[Vt] !== ot[bi]; ) bi--;
        for (; 1 <= Vt && 0 <= bi; Vt--, bi--) if (je[Vt] !== ot[bi]) {
          if (Vt !== 1 || bi !== 1)
            do
              if (Vt--, bi--, 0 > bi || je[Vt] !== ot[bi]) {
                var Ii = `
` + je[Vt].replace(" at new ", " at ");
                return d.displayName && Ii.includes("<anonymous>") && (Ii = Ii.replace("<anonymous>", d.displayName)), Ii;
              }
            while (1 <= Vt && 0 <= bi);
          break;
        }
      }
    } finally {
      pt = !1, Error.prepareStackTrace = $;
    }
    return (d = d ? d.displayName || d.name : "") ? bt(d) : "";
  }
  function dt(d) {
    switch (d.tag) {
      case 5:
        return bt(d.type);
      case 16:
        return bt("Lazy");
      case 13:
        return bt("Suspense");
      case 19:
        return bt("SuspenseList");
      case 0:
      case 2:
      case 15:
        return d = Ke(d.type, !1), d;
      case 11:
        return d = Ke(d.type.render, !1), d;
      case 1:
        return d = Ke(d.type, !0), d;
      default:
        return "";
    }
  }
  function ct(d) {
    if (d == null) return null;
    if (typeof d == "function") return d.displayName || d.name || null;
    if (typeof d == "string") return d;
    switch (d) {
      case W:
        return "Fragment";
      case T:
        return "Portal";
      case ee:
        return "Profiler";
      case J:
        return "StrictMode";
      case ke:
        return "Suspense";
      case ge:
        return "SuspenseList";
    }
    if (typeof d == "object") switch (d.$$typeof) {
      case le:
        return (d.displayName || "Context") + ".Consumer";
      case te:
        return (d._context.displayName || "Context") + ".Provider";
      case me:
        var g = d.render;
        return d = d.displayName, d || (d = g.displayName || g.name || "", d = d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef"), d;
      case Ve:
        return g = d.displayName || null, g !== null ? g : ct(d.type) || "Memo";
      case Oe:
        g = d._payload, d = d._init;
        try {
          return ct(d(g));
        } catch {
        }
    }
    return null;
  }
  function wt(d) {
    var g = d.type;
    switch (d.tag) {
      case 24:
        return "Cache";
      case 9:
        return (g.displayName || "Context") + ".Consumer";
      case 10:
        return (g._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return d = g.render, d = d.displayName || d.name || "", g.displayName || (d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return g;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return ct(g);
      case 8:
        return g === J ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof g == "function") return g.displayName || g.name || null;
        if (typeof g == "string") return g;
    }
    return null;
  }
  function Ht(d) {
    switch (typeof d) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return d;
      case "object":
        return d;
      default:
        return "";
    }
  }
  function $t(d) {
    var g = d.type;
    return (d = d.nodeName) && d.toLowerCase() === "input" && (g === "checkbox" || g === "radio");
  }
  function rt(d) {
    var g = $t(d) ? "checked" : "value", $ = Object.getOwnPropertyDescriptor(d.constructor.prototype, g), he = "" + d[g];
    if (!d.hasOwnProperty(g) && typeof $ < "u" && typeof $.get == "function" && typeof $.set == "function") {
      var je = $.get, ot = $.set;
      return Object.defineProperty(d, g, { configurable: !0, get: function() {
        return je.call(this);
      }, set: function(Vt) {
        he = "" + Vt, ot.call(this, Vt);
      } }), Object.defineProperty(d, g, { enumerable: $.enumerable }), { getValue: function() {
        return he;
      }, setValue: function(Vt) {
        he = "" + Vt;
      }, stopTracking: function() {
        d._valueTracker = null, delete d[g];
      } };
    }
  }
  function ri(d) {
    d._valueTracker || (d._valueTracker = rt(d));
  }
  function wi(d) {
    if (!d) return !1;
    var g = d._valueTracker;
    if (!g) return !0;
    var $ = g.getValue(), he = "";
    return d && (he = $t(d) ? d.checked ? "true" : "false" : d.value), d = he, d !== $ ? (g.setValue(d), !0) : !1;
  }
  function Qt(d) {
    if (d = d || (typeof document < "u" ? document : void 0), typeof d > "u") return null;
    try {
      return d.activeElement || d.body;
    } catch {
      return d.body;
    }
  }
  function At(d, g) {
    var $ = g.checked;
    return it({}, g, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: $ ?? d._wrapperState.initialChecked });
  }
  function St(d, g) {
    var $ = g.defaultValue == null ? "" : g.defaultValue, he = g.checked != null ? g.checked : g.defaultChecked;
    $ = Ht(g.value != null ? g.value : $), d._wrapperState = { initialChecked: he, initialValue: $, controlled: g.type === "checkbox" || g.type === "radio" ? g.checked != null : g.value != null };
  }
  function Lt(d, g) {
    g = g.checked, g != null && S(d, "checked", g, !1);
  }
  function kt(d, g) {
    Lt(d, g);
    var $ = Ht(g.value), he = g.type;
    if ($ != null) he === "number" ? ($ === 0 && d.value === "" || d.value != $) && (d.value = "" + $) : d.value !== "" + $ && (d.value = "" + $);
    else if (he === "submit" || he === "reset") {
      d.removeAttribute("value");
      return;
    }
    g.hasOwnProperty("value") ? De(d, g.type, $) : g.hasOwnProperty("defaultValue") && De(d, g.type, Ht(g.defaultValue)), g.checked == null && g.defaultChecked != null && (d.defaultChecked = !!g.defaultChecked);
  }
  function Ye(d, g, $) {
    if (g.hasOwnProperty("value") || g.hasOwnProperty("defaultValue")) {
      var he = g.type;
      if (!(he !== "submit" && he !== "reset" || g.value !== void 0 && g.value !== null)) return;
      g = "" + d._wrapperState.initialValue, $ || g === d.value || (d.value = g), d.defaultValue = g;
    }
    $ = d.name, $ !== "" && (d.name = ""), d.defaultChecked = !!d._wrapperState.initialChecked, $ !== "" && (d.name = $);
  }
  function De(d, g, $) {
    (g !== "number" || Qt(d.ownerDocument) !== d) && ($ == null ? d.defaultValue = "" + d._wrapperState.initialValue : d.defaultValue !== "" + $ && (d.defaultValue = "" + $));
  }
  var Re = Array.isArray;
  function _t(d, g, $, he) {
    if (d = d.options, g) {
      g = {};
      for (var je = 0; je < $.length; je++) g["$" + $[je]] = !0;
      for ($ = 0; $ < d.length; $++) je = g.hasOwnProperty("$" + d[$].value), d[$].selected !== je && (d[$].selected = je), je && he && (d[$].defaultSelected = !0);
    } else {
      for ($ = "" + Ht($), g = null, je = 0; je < d.length; je++) {
        if (d[je].value === $) {
          d[je].selected = !0, he && (d[je].defaultSelected = !0);
          return;
        }
        g !== null || d[je].disabled || (g = d[je]);
      }
      g !== null && (g.selected = !0);
    }
  }
  function et(d, g) {
    if (g.dangerouslySetInnerHTML != null) throw Error(qe(91));
    return it({}, g, { value: void 0, defaultValue: void 0, children: "" + d._wrapperState.initialValue });
  }
  function Ie(d, g) {
    var $ = g.value;
    if ($ == null) {
      if ($ = g.children, g = g.defaultValue, $ != null) {
        if (g != null) throw Error(qe(92));
        if (Re($)) {
          if (1 < $.length) throw Error(qe(93));
          $ = $[0];
        }
        g = $;
      }
      g == null && (g = ""), $ = g;
    }
    d._wrapperState = { initialValue: Ht($) };
  }
  function pe(d, g) {
    var $ = Ht(g.value), he = Ht(g.defaultValue);
    $ != null && ($ = "" + $, $ !== d.value && (d.value = $), g.defaultValue == null && d.defaultValue !== $ && (d.defaultValue = $)), he != null && (d.defaultValue = "" + he);
  }
  function xt(d) {
    var g = d.textContent;
    g === d._wrapperState.initialValue && g !== "" && g !== null && (d.value = g);
  }
  function l(d) {
    switch (d) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function _(d, g) {
    return d == null || d === "http://www.w3.org/1999/xhtml" ? l(g) : d === "http://www.w3.org/2000/svg" && g === "foreignObject" ? "http://www.w3.org/1999/xhtml" : d;
  }
  var I, X = function(d) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(g, $, he, je) {
      MSApp.execUnsafeLocalFunction(function() {
        return d(g, $, he, je);
      });
    } : d;
  }(function(d, g) {
    if (d.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in d) d.innerHTML = g;
    else {
      for (I = I || document.createElement("div"), I.innerHTML = "<svg>" + g.valueOf().toString() + "</svg>", g = I.firstChild; d.firstChild; ) d.removeChild(d.firstChild);
      for (; g.firstChild; ) d.appendChild(g.firstChild);
    }
  });
  function ne(d, g) {
    if (g) {
      var $ = d.firstChild;
      if ($ && $ === d.lastChild && $.nodeType === 3) {
        $.nodeValue = g;
        return;
      }
    }
    d.textContent = g;
  }
  var ue = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Te = ["Webkit", "ms", "Moz", "O"];
  Object.keys(ue).forEach(function(d) {
    Te.forEach(function(g) {
      g = g + d.charAt(0).toUpperCase() + d.substring(1), ue[g] = ue[d];
    });
  });
  function ye(d, g, $) {
    return g == null || typeof g == "boolean" || g === "" ? "" : $ || typeof g != "number" || g === 0 || ue.hasOwnProperty(d) && ue[d] ? ("" + g).trim() : g + "px";
  }
  function Me(d, g) {
    d = d.style;
    for (var $ in g) if (g.hasOwnProperty($)) {
      var he = $.indexOf("--") === 0, je = ye($, g[$], he);
      $ === "float" && ($ = "cssFloat"), he ? d.setProperty($, je) : d[$] = je;
    }
  }
  var Ge = it({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function Qe(d, g) {
    if (g) {
      if (Ge[d] && (g.children != null || g.dangerouslySetInnerHTML != null)) throw Error(qe(137, d));
      if (g.dangerouslySetInnerHTML != null) {
        if (g.children != null) throw Error(qe(60));
        if (typeof g.dangerouslySetInnerHTML != "object" || !("__html" in g.dangerouslySetInnerHTML)) throw Error(qe(61));
      }
      if (g.style != null && typeof g.style != "object") throw Error(qe(62));
    }
  }
  function re(d, g) {
    if (d.indexOf("-") === -1) return typeof g.is == "string";
    switch (d) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Se = null;
  function Pe(d) {
    return d = d.target || d.srcElement || window, d.correspondingUseElement && (d = d.correspondingUseElement), d.nodeType === 3 ? d.parentNode : d;
  }
  var at = null, Be = null, Ze = null;
  function fe(d) {
    if (d = gu(d)) {
      if (typeof at != "function") throw Error(qe(280));
      var g = d.stateNode;
      g && (g = sc(g), at(d.stateNode, d.type, g));
    }
  }
  function Je(d) {
    Be ? Ze ? Ze.push(d) : Ze = [d] : Be = d;
  }
  function Xe() {
    if (Be) {
      var d = Be, g = Ze;
      if (Ze = Be = null, fe(d), g) for (d = 0; d < g.length; d++) fe(g[d]);
    }
  }
  function z(d, g) {
    return d(g);
  }
  function He() {
  }
  var nt = !1;
  function ae(d, g, $) {
    if (nt) return d(g, $);
    nt = !0;
    try {
      return z(d, g, $);
    } finally {
      nt = !1, (Be !== null || Ze !== null) && (He(), Xe());
    }
  }
  function $e(d, g) {
    var $ = d.stateNode;
    if ($ === null) return null;
    var he = sc($);
    if (he === null) return null;
    $ = he[g];
    e: switch (g) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (he = !he.disabled) || (d = d.type, he = !(d === "button" || d === "input" || d === "select" || d === "textarea")), d = !he;
        break e;
      default:
        d = !1;
    }
    if (d) return null;
    if ($ && typeof $ != "function") throw Error(qe(231, g, typeof $));
    return $;
  }
  var Et = !1;
  if (i) try {
    var Nt = {};
    Object.defineProperty(Nt, "passive", { get: function() {
      Et = !0;
    } }), window.addEventListener("test", Nt, Nt), window.removeEventListener("test", Nt, Nt);
  } catch {
    Et = !1;
  }
  function Yt(d, g, $, he, je, ot, Vt, bi, Ii) {
    var $i = Array.prototype.slice.call(arguments, 3);
    try {
      g.apply($, $i);
    } catch (gr) {
      this.onError(gr);
    }
  }
  var Ft = !1, ai = null, Mt = !1, Ae = null, Fe = { onError: function(d) {
    Ft = !0, ai = d;
  } };
  function tt(d, g, $, he, je, ot, Vt, bi, Ii) {
    Ft = !1, ai = null, Yt.apply(Fe, arguments);
  }
  function Ct(d, g, $, he, je, ot, Vt, bi, Ii) {
    if (tt.apply(this, arguments), Ft) {
      if (Ft) {
        var $i = ai;
        Ft = !1, ai = null;
      } else throw Error(qe(198));
      Mt || (Mt = !0, Ae = $i);
    }
  }
  function It(d) {
    var g = d, $ = d;
    if (d.alternate) for (; g.return; ) g = g.return;
    else {
      d = g;
      do
        g = d, g.flags & 4098 && ($ = g.return), d = g.return;
      while (d);
    }
    return g.tag === 3 ? $ : null;
  }
  function Ut(d) {
    if (d.tag === 13) {
      var g = d.memoizedState;
      if (g === null && (d = d.alternate, d !== null && (g = d.memoizedState)), g !== null) return g.dehydrated;
    }
    return null;
  }
  function ti(d) {
    if (It(d) !== d) throw Error(qe(188));
  }
  function Pt(d) {
    var g = d.alternate;
    if (!g) {
      if (g = It(d), g === null) throw Error(qe(188));
      return g !== d ? null : d;
    }
    for (var $ = d, he = g; ; ) {
      var je = $.return;
      if (je === null) break;
      var ot = je.alternate;
      if (ot === null) {
        if (he = je.return, he !== null) {
          $ = he;
          continue;
        }
        break;
      }
      if (je.child === ot.child) {
        for (ot = je.child; ot; ) {
          if (ot === $) return ti(je), d;
          if (ot === he) return ti(je), g;
          ot = ot.sibling;
        }
        throw Error(qe(188));
      }
      if ($.return !== he.return) $ = je, he = ot;
      else {
        for (var Vt = !1, bi = je.child; bi; ) {
          if (bi === $) {
            Vt = !0, $ = je, he = ot;
            break;
          }
          if (bi === he) {
            Vt = !0, he = je, $ = ot;
            break;
          }
          bi = bi.sibling;
        }
        if (!Vt) {
          for (bi = ot.child; bi; ) {
            if (bi === $) {
              Vt = !0, $ = ot, he = je;
              break;
            }
            if (bi === he) {
              Vt = !0, he = ot, $ = je;
              break;
            }
            bi = bi.sibling;
          }
          if (!Vt) throw Error(qe(189));
        }
      }
      if ($.alternate !== he) throw Error(qe(190));
    }
    if ($.tag !== 3) throw Error(qe(188));
    return $.stateNode.current === $ ? d : g;
  }
  function Wt(d) {
    return d = Pt(d), d !== null ? ei(d) : null;
  }
  function ei(d) {
    if (d.tag === 5 || d.tag === 6) return d;
    for (d = d.child; d !== null; ) {
      var g = ei(d);
      if (g !== null) return g;
      d = d.sibling;
    }
    return null;
  }
  var oi = Tt.unstable_scheduleCallback, _i = Tt.unstable_cancelCallback, Di = Tt.unstable_shouldYield, Bi = Tt.unstable_requestPaint, Hi = Tt.unstable_now, nr = Tt.unstable_getCurrentPriorityLevel, rr = Tt.unstable_ImmediatePriority, dr = Tt.unstable_UserBlockingPriority, Rr = Tt.unstable_NormalPriority, Br = Tt.unstable_LowPriority, Ki = Tt.unstable_IdlePriority, Ir = null, Mr = null;
  function wn(d) {
    if (Mr && typeof Mr.onCommitFiberRoot == "function") try {
      Mr.onCommitFiberRoot(Ir, d, void 0, (d.current.flags & 128) === 128);
    } catch {
    }
  }
  var xn = Math.clz32 ? Math.clz32 : Yn, En = Math.log, Vn = Math.LN2;
  function Yn(d) {
    return d >>>= 0, d === 0 ? 32 : 31 - (En(d) / Vn | 0) | 0;
  }
  var ka = 64, ea = 4194304;
  function ga(d) {
    switch (d & -d) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return d & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return d & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return d;
    }
  }
  function Ta(d, g) {
    var $ = d.pendingLanes;
    if ($ === 0) return 0;
    var he = 0, je = d.suspendedLanes, ot = d.pingedLanes, Vt = $ & 268435455;
    if (Vt !== 0) {
      var bi = Vt & ~je;
      bi !== 0 ? he = ga(bi) : (ot &= Vt, ot !== 0 && (he = ga(ot)));
    } else Vt = $ & ~je, Vt !== 0 ? he = ga(Vt) : ot !== 0 && (he = ga(ot));
    if (he === 0) return 0;
    if (g !== 0 && g !== he && !(g & je) && (je = he & -he, ot = g & -g, je >= ot || je === 16 && (ot & 4194240) !== 0)) return g;
    if (he & 4 && (he |= $ & 16), g = d.entangledLanes, g !== 0) for (d = d.entanglements, g &= he; 0 < g; ) $ = 31 - xn(g), je = 1 << $, he |= d[$], g &= ~je;
    return he;
  }
  function ha(d, g) {
    switch (d) {
      case 1:
      case 2:
      case 4:
        return g + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return g + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Bo(d, g) {
    for (var $ = d.suspendedLanes, he = d.pingedLanes, je = d.expirationTimes, ot = d.pendingLanes; 0 < ot; ) {
      var Vt = 31 - xn(ot), bi = 1 << Vt, Ii = je[Vt];
      Ii === -1 ? (!(bi & $) || bi & he) && (je[Vt] = ha(bi, g)) : Ii <= g && (d.expiredLanes |= bi), ot &= ~bi;
    }
  }
  function Ao(d) {
    return d = d.pendingLanes & -1073741825, d !== 0 ? d : d & 1073741824 ? 1073741824 : 0;
  }
  function za() {
    var d = ka;
    return ka <<= 1, !(ka & 4194240) && (ka = 64), d;
  }
  function ss(d) {
    for (var g = [], $ = 0; 31 > $; $++) g.push(d);
    return g;
  }
  function os(d, g, $) {
    d.pendingLanes |= g, g !== 536870912 && (d.suspendedLanes = 0, d.pingedLanes = 0), d = d.eventTimes, g = 31 - xn(g), d[g] = $;
  }
  function Ms(d, g) {
    var $ = d.pendingLanes & ~g;
    d.pendingLanes = g, d.suspendedLanes = 0, d.pingedLanes = 0, d.expiredLanes &= g, d.mutableReadLanes &= g, d.entangledLanes &= g, g = d.entanglements;
    var he = d.eventTimes;
    for (d = d.expirationTimes; 0 < $; ) {
      var je = 31 - xn($), ot = 1 << je;
      g[je] = 0, he[je] = -1, d[je] = -1, $ &= ~ot;
    }
  }
  function La(d, g) {
    var $ = d.entangledLanes |= g;
    for (d = d.entanglements; $; ) {
      var he = 31 - xn($), je = 1 << he;
      je & g | d[he] & g && (d[he] |= g), $ &= ~je;
    }
  }
  var mn = 0;
  function eo(d) {
    return d &= -d, 1 < d ? 4 < d ? d & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var mo, Ba, tn, ys, Qa, fa = !1, Wr = [], es = null, Tr = null, Is = null, D = /* @__PURE__ */ new Map(), be = /* @__PURE__ */ new Map(), ht = [], Ot = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function hi(d, g) {
    switch (d) {
      case "focusin":
      case "focusout":
        es = null;
        break;
      case "dragenter":
      case "dragleave":
        Tr = null;
        break;
      case "mouseover":
      case "mouseout":
        Is = null;
        break;
      case "pointerover":
      case "pointerout":
        D.delete(g.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        be.delete(g.pointerId);
    }
  }
  function di(d, g, $, he, je, ot) {
    return d === null || d.nativeEvent !== ot ? (d = { blockedOn: g, domEventName: $, eventSystemFlags: he, nativeEvent: ot, targetContainers: [je] }, g !== null && (g = gu(g), g !== null && Ba(g)), d) : (d.eventSystemFlags |= he, g = d.targetContainers, je !== null && g.indexOf(je) === -1 && g.push(je), d);
  }
  function ki(d, g, $, he, je) {
    switch (g) {
      case "focusin":
        return es = di(es, d, g, $, he, je), !0;
      case "dragenter":
        return Tr = di(Tr, d, g, $, he, je), !0;
      case "mouseover":
        return Is = di(Is, d, g, $, he, je), !0;
      case "pointerover":
        var ot = je.pointerId;
        return D.set(ot, di(D.get(ot) || null, d, g, $, he, je)), !0;
      case "gotpointercapture":
        return ot = je.pointerId, be.set(ot, di(be.get(ot) || null, d, g, $, he, je)), !0;
    }
    return !1;
  }
  function er(d) {
    var g = Ul(d.target);
    if (g !== null) {
      var $ = It(g);
      if ($ !== null) {
        if (g = $.tag, g === 13) {
          if (g = Ut($), g !== null) {
            d.blockedOn = g, Qa(d.priority, function() {
              tn($);
            });
            return;
          }
        } else if (g === 3 && $.stateNode.current.memoizedState.isDehydrated) {
          d.blockedOn = $.tag === 3 ? $.stateNode.containerInfo : null;
          return;
        }
      }
    }
    d.blockedOn = null;
  }
  function _r(d) {
    if (d.blockedOn !== null) return !1;
    for (var g = d.targetContainers; 0 < g.length; ) {
      var $ = Fo(d.domEventName, d.eventSystemFlags, g[0], d.nativeEvent);
      if ($ === null) {
        $ = d.nativeEvent;
        var he = new $.constructor($.type, $);
        Se = he, $.target.dispatchEvent(he), Se = null;
      } else return g = gu($), g !== null && Ba(g), d.blockedOn = $, !1;
      g.shift();
    }
    return !0;
  }
  function en(d, g, $) {
    _r(d) && $.delete(g);
  }
  function br() {
    fa = !1, es !== null && _r(es) && (es = null), Tr !== null && _r(Tr) && (Tr = null), Is !== null && _r(Is) && (Is = null), D.forEach(en), be.forEach(en);
  }
  function Gn(d, g) {
    d.blockedOn === g && (d.blockedOn = null, fa || (fa = !0, Tt.unstable_scheduleCallback(Tt.unstable_NormalPriority, br)));
  }
  function Ia(d) {
    function g(je) {
      return Gn(je, d);
    }
    if (0 < Wr.length) {
      Gn(Wr[0], d);
      for (var $ = 1; $ < Wr.length; $++) {
        var he = Wr[$];
        he.blockedOn === d && (he.blockedOn = null);
      }
    }
    for (es !== null && Gn(es, d), Tr !== null && Gn(Tr, d), Is !== null && Gn(Is, d), D.forEach(g), be.forEach(g), $ = 0; $ < ht.length; $++) he = ht[$], he.blockedOn === d && (he.blockedOn = null);
    for (; 0 < ht.length && ($ = ht[0], $.blockedOn === null); ) er($), $.blockedOn === null && ht.shift();
  }
  var ls = U.ReactCurrentBatchConfig, Hn = !0;
  function Dn(d, g, $, he) {
    var je = mn, ot = ls.transition;
    ls.transition = null;
    try {
      mn = 1, va(d, g, $, he);
    } finally {
      mn = je, ls.transition = ot;
    }
  }
  function xs(d, g, $, he) {
    var je = mn, ot = ls.transition;
    ls.transition = null;
    try {
      mn = 4, va(d, g, $, he);
    } finally {
      mn = je, ls.transition = ot;
    }
  }
  function va(d, g, $, he) {
    if (Hn) {
      var je = Fo(d, g, $, he);
      if (je === null) du(d, g, he, sl, $), hi(d, he);
      else if (ki(je, d, g, $, he)) he.stopPropagation();
      else if (hi(d, he), g & 4 && -1 < Ot.indexOf(d)) {
        for (; je !== null; ) {
          var ot = gu(je);
          if (ot !== null && mo(ot), ot = Fo(d, g, $, he), ot === null && du(d, g, he, sl, $), ot === je) break;
          je = ot;
        }
        je !== null && he.stopPropagation();
      } else du(d, g, he, null, $);
    }
  }
  var sl = null;
  function Fo(d, g, $, he) {
    if (sl = null, d = Pe(he), d = Ul(d), d !== null) if (g = It(d), g === null) d = null;
    else if ($ = g.tag, $ === 13) {
      if (d = Ut(g), d !== null) return d;
      d = null;
    } else if ($ === 3) {
      if (g.stateNode.current.memoizedState.isDehydrated) return g.tag === 3 ? g.stateNode.containerInfo : null;
      d = null;
    } else g !== d && (d = null);
    return sl = d, null;
  }
  function No(d) {
    switch (d) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (nr()) {
          case rr:
            return 1;
          case dr:
            return 4;
          case Rr:
          case Br:
            return 16;
          case Ki:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Vs = null, Na = null, bs = null;
  function Ua() {
    if (bs) return bs;
    var d, g = Na, $ = g.length, he, je = "value" in Vs ? Vs.value : Vs.textContent, ot = je.length;
    for (d = 0; d < $ && g[d] === je[d]; d++) ;
    var Vt = $ - d;
    for (he = 1; he <= Vt && g[$ - he] === je[ot - he]; he++) ;
    return bs = je.slice(d, 1 < he ? 1 - he : void 0);
  }
  function ol(d) {
    var g = d.keyCode;
    return "charCode" in d ? (d = d.charCode, d === 0 && g === 13 && (d = 13)) : d = g, d === 10 && (d = 13), 32 <= d || d === 13 ? d : 0;
  }
  function js() {
    return !0;
  }
  function Nn() {
    return !1;
  }
  function qn(d) {
    function g($, he, je, ot, Vt) {
      this._reactName = $, this._targetInst = je, this.type = he, this.nativeEvent = ot, this.target = Vt, this.currentTarget = null;
      for (var bi in d) d.hasOwnProperty(bi) && ($ = d[bi], this[bi] = $ ? $(ot) : ot[bi]);
      return this.isDefaultPrevented = (ot.defaultPrevented != null ? ot.defaultPrevented : ot.returnValue === !1) ? js : Nn, this.isPropagationStopped = Nn, this;
    }
    return it(g.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var $ = this.nativeEvent;
      $ && ($.preventDefault ? $.preventDefault() : typeof $.returnValue != "unknown" && ($.returnValue = !1), this.isDefaultPrevented = js);
    }, stopPropagation: function() {
      var $ = this.nativeEvent;
      $ && ($.stopPropagation ? $.stopPropagation() : typeof $.cancelBubble != "unknown" && ($.cancelBubble = !0), this.isPropagationStopped = js);
    }, persist: function() {
    }, isPersistent: js }), g;
  }
  var ta = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(d) {
    return d.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, ia = qn(ta), ps = it({}, ta, { view: 0, detail: 0 }), Gs = qn(ps), aa, ll, ts, to = it({}, ps, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: io, button: 0, buttons: 0, relatedTarget: function(d) {
    return d.relatedTarget === void 0 ? d.fromElement === d.srcElement ? d.toElement : d.fromElement : d.relatedTarget;
  }, movementX: function(d) {
    return "movementX" in d ? d.movementX : (d !== ts && (ts && d.type === "mousemove" ? (aa = d.screenX - ts.screenX, ll = d.screenY - ts.screenY) : ll = aa = 0, ts = d), aa);
  }, movementY: function(d) {
    return "movementY" in d ? d.movementY : ll;
  } }), _o = qn(to), Yh = it({}, to, { dataTransfer: 0 }), Mc = qn(Yh), ms = it({}, ps, { relatedTarget: 0 }), au = qn(ms), Zu = it({}, ta, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), su = qn(Zu), ou = it({}, ta, { clipboardData: function(d) {
    return "clipboardData" in d ? d.clipboardData : window.clipboardData;
  } }), Kh = qn(ou), ul = it({}, ta, { data: 0 }), Ca = qn(ul), kl = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, lu = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Ll = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function $u(d) {
    var g = this.nativeEvent;
    return g.getModifierState ? g.getModifierState(d) : (d = Ll[d]) ? !!g[d] : !1;
  }
  function io() {
    return $u;
  }
  var ro = it({}, ps, { key: function(d) {
    if (d.key) {
      var g = kl[d.key] || d.key;
      if (g !== "Unidentified") return g;
    }
    return d.type === "keypress" ? (d = ol(d), d === 13 ? "Enter" : String.fromCharCode(d)) : d.type === "keydown" || d.type === "keyup" ? lu[d.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: io, charCode: function(d) {
    return d.type === "keypress" ? ol(d) : 0;
  }, keyCode: function(d) {
    return d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0;
  }, which: function(d) {
    return d.type === "keypress" ? ol(d) : d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0;
  } }), Ol = qn(ro), Xu = it({}, to, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Ic = qn(Xu), Pn = it({}, ps, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: io }), Pc = qn(Pn), Yu = it({}, ta, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Uo = qn(Yu), zr = it({}, to, {
    deltaX: function(d) {
      return "deltaX" in d ? d.deltaX : "wheelDeltaX" in d ? -d.wheelDeltaX : 0;
    },
    deltaY: function(d) {
      return "deltaY" in d ? d.deltaY : "wheelDeltaY" in d ? -d.wheelDeltaY : "wheelDelta" in d ? -d.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Sr = qn(zr), _n = [9, 13, 27, 32], Lr = i && "CompositionEvent" in window, zn = null;
  i && "documentMode" in document && (zn = document.documentMode);
  var cl = i && "TextEvent" in window && !zn, kr = i && (!Lr || zn && 8 < zn && 11 >= zn), sa = " ", us = !1;
  function hl(d, g) {
    switch (d) {
      case "keyup":
        return _n.indexOf(g.keyCode) !== -1;
      case "keydown":
        return g.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function uu(d) {
    return d = d.detail, typeof d == "object" && "data" in d ? d.data : null;
  }
  var Pa = !1;
  function $a(d, g) {
    switch (d) {
      case "compositionend":
        return uu(g);
      case "keypress":
        return g.which !== 32 ? null : (us = !0, sa);
      case "textInput":
        return d = g.data, d === sa && us ? null : d;
      default:
        return null;
    }
  }
  function tr(d, g) {
    if (Pa) return d === "compositionend" || !Lr && hl(d, g) ? (d = Ua(), bs = Na = Vs = null, Pa = !1, d) : null;
    switch (d) {
      case "paste":
        return null;
      case "keypress":
        if (!(g.ctrlKey || g.altKey || g.metaKey) || g.ctrlKey && g.altKey) {
          if (g.char && 1 < g.char.length) return g.char;
          if (g.which) return String.fromCharCode(g.which);
        }
        return null;
      case "compositionend":
        return kr && g.locale !== "ko" ? null : g.data;
      default:
        return null;
    }
  }
  var fl = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Mo(d) {
    var g = d && d.nodeName && d.nodeName.toLowerCase();
    return g === "input" ? !!fl[d.type] : g === "textarea";
  }
  function Vo(d, g, $, he) {
    Je(he), g = Bc(g, "onChange"), 0 < g.length && ($ = new ia("onChange", "change", null, $, he), d.push({ event: $, listeners: g }));
  }
  var Ps = null, ya = null;
  function xa(d) {
    hh(d, 0);
  }
  function jo(d) {
    var g = ao(d);
    if (wi(g)) return d;
  }
  function dl(d, g) {
    if (d === "change") return g;
  }
  var Go = !1;
  if (i) {
    var no;
    if (i) {
      var pl = "oninput" in document;
      if (!pl) {
        var oh = document.createElement("div");
        oh.setAttribute("oninput", "return;"), pl = typeof oh.oninput == "function";
      }
      no = pl;
    } else no = !1;
    Go = no && (!document.documentMode || 9 < document.documentMode);
  }
  function Ho() {
    Ps && (Ps.detachEvent("onpropertychange", Ku), ya = Ps = null);
  }
  function Ku(d) {
    if (d.propertyName === "value" && jo(ya)) {
      var g = [];
      Vo(g, ya, d, Pe(d)), ae(xa, g);
    }
  }
  function lh(d, g, $) {
    d === "focusin" ? (Ho(), Ps = g, ya = $, Ps.attachEvent("onpropertychange", Ku)) : d === "focusout" && Ho();
  }
  function Rc(d) {
    if (d === "selectionchange" || d === "keyup" || d === "keydown") return jo(ya);
  }
  function Ju(d, g) {
    if (d === "click") return jo(g);
  }
  function kc(d, g) {
    if (d === "input" || d === "change") return jo(g);
  }
  function Qu(d, g) {
    return d === g && (d !== 0 || 1 / d === 1 / g) || d !== d && g !== g;
  }
  var ba = typeof Object.is == "function" ? Object.is : Qu;
  function vi(d, g) {
    if (ba(d, g)) return !0;
    if (typeof d != "object" || d === null || typeof g != "object" || g === null) return !1;
    var $ = Object.keys(d), he = Object.keys(g);
    if ($.length !== he.length) return !1;
    for (he = 0; he < $.length; he++) {
      var je = $[he];
      if (!N.call(g, je) || !ba(d[je], g[je])) return !1;
    }
    return !0;
  }
  function Ci(d) {
    for (; d && d.firstChild; ) d = d.firstChild;
    return d;
  }
  function Xi(d, g) {
    var $ = Ci(d);
    d = 0;
    for (var he; $; ) {
      if ($.nodeType === 3) {
        if (he = d + $.textContent.length, d <= g && he >= g) return { node: $, offset: g - d };
        d = he;
      }
      e: {
        for (; $; ) {
          if ($.nextSibling) {
            $ = $.nextSibling;
            break e;
          }
          $ = $.parentNode;
        }
        $ = void 0;
      }
      $ = Ci($);
    }
  }
  function sr(d, g) {
    return d && g ? d === g ? !0 : d && d.nodeType === 3 ? !1 : g && g.nodeType === 3 ? sr(d, g.parentNode) : "contains" in d ? d.contains(g) : d.compareDocumentPosition ? !!(d.compareDocumentPosition(g) & 16) : !1 : !1;
  }
  function rn() {
    for (var d = window, g = Qt(); g instanceof d.HTMLIFrameElement; ) {
      try {
        var $ = typeof g.contentWindow.location.href == "string";
      } catch {
        $ = !1;
      }
      if ($) d = g.contentWindow;
      else break;
      g = Qt(d.document);
    }
    return g;
  }
  function Hr(d) {
    var g = d && d.nodeName && d.nodeName.toLowerCase();
    return g && (g === "input" && (d.type === "text" || d.type === "search" || d.type === "tel" || d.type === "url" || d.type === "password") || g === "textarea" || d.contentEditable === "true");
  }
  function on(d) {
    var g = rn(), $ = d.focusedElem, he = d.selectionRange;
    if (g !== $ && $ && $.ownerDocument && sr($.ownerDocument.documentElement, $)) {
      if (he !== null && Hr($)) {
        if (g = he.start, d = he.end, d === void 0 && (d = g), "selectionStart" in $) $.selectionStart = g, $.selectionEnd = Math.min(d, $.value.length);
        else if (d = (g = $.ownerDocument || document) && g.defaultView || window, d.getSelection) {
          d = d.getSelection();
          var je = $.textContent.length, ot = Math.min(he.start, je);
          he = he.end === void 0 ? ot : Math.min(he.end, je), !d.extend && ot > he && (je = he, he = ot, ot = je), je = Xi($, ot);
          var Vt = Xi(
            $,
            he
          );
          je && Vt && (d.rangeCount !== 1 || d.anchorNode !== je.node || d.anchorOffset !== je.offset || d.focusNode !== Vt.node || d.focusOffset !== Vt.offset) && (g = g.createRange(), g.setStart(je.node, je.offset), d.removeAllRanges(), ot > he ? (d.addRange(g), d.extend(Vt.node, Vt.offset)) : (g.setEnd(Vt.node, Vt.offset), d.addRange(g)));
        }
      }
      for (g = [], d = $; d = d.parentNode; ) d.nodeType === 1 && g.push({ element: d, left: d.scrollLeft, top: d.scrollTop });
      for (typeof $.focus == "function" && $.focus(), $ = 0; $ < g.length; $++) d = g[$], d.element.scrollLeft = d.left, d.element.scrollTop = d.top;
    }
  }
  var Mn = i && "documentMode" in document && 11 >= document.documentMode, Va = null, cs = null, go = null, qo = !1;
  function Wo(d, g, $) {
    var he = $.window === $ ? $.document : $.nodeType === 9 ? $ : $.ownerDocument;
    qo || Va == null || Va !== Qt(he) || (he = Va, "selectionStart" in he && Hr(he) ? he = { start: he.selectionStart, end: he.selectionEnd } : (he = (he.ownerDocument && he.ownerDocument.defaultView || window).getSelection(), he = { anchorNode: he.anchorNode, anchorOffset: he.anchorOffset, focusNode: he.focusNode, focusOffset: he.focusOffset }), go && vi(go, he) || (go = he, he = Bc(cs, "onSelect"), 0 < he.length && (g = new ia("onSelect", "select", null, g, $), d.push({ event: g, listeners: he }), g.target = Va)));
  }
  function ml(d, g) {
    var $ = {};
    return $[d.toLowerCase()] = g.toLowerCase(), $["Webkit" + d] = "webkit" + g, $["Moz" + d] = "moz" + g, $;
  }
  var Zo = { animationend: ml("Animation", "AnimationEnd"), animationiteration: ml("Animation", "AnimationIteration"), animationstart: ml("Animation", "AnimationStart"), transitionend: ml("Transition", "TransitionEnd") }, cu = {}, Dl = {};
  i && (Dl = document.createElement("div").style, "AnimationEvent" in window || (delete Zo.animationend.animation, delete Zo.animationiteration.animation, delete Zo.animationstart.animation), "TransitionEvent" in window || delete Zo.transitionend.transition);
  function $o(d) {
    if (cu[d]) return cu[d];
    if (!Zo[d]) return d;
    var g = Zo[d], $;
    for ($ in g) if (g.hasOwnProperty($) && $ in Dl) return cu[d] = g[$];
    return d;
  }
  var hu = $o("animationend"), ec = $o("animationiteration"), Lc = $o("animationstart"), tc = $o("transitionend"), fu = /* @__PURE__ */ new Map(), zl = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Qr(d, g) {
    fu.set(d, g), q(g, [d]);
  }
  for (var uh = 0; uh < zl.length; uh++) {
    var Bl = zl[uh], Rf = Bl.toLowerCase(), kf = Bl[0].toUpperCase() + Bl.slice(1);
    Qr(Rf, "on" + kf);
  }
  Qr(hu, "onAnimationEnd"), Qr(ec, "onAnimationIteration"), Qr(Lc, "onAnimationStart"), Qr("dblclick", "onDoubleClick"), Qr("focusin", "onFocus"), Qr("focusout", "onBlur"), Qr(tc, "onTransitionEnd"), ie("onMouseEnter", ["mouseout", "mouseover"]), ie("onMouseLeave", ["mouseout", "mouseover"]), ie("onPointerEnter", ["pointerout", "pointerover"]), ie("onPointerLeave", ["pointerout", "pointerover"]), q("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), q("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), q("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), q("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), q("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), q("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Oc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), jn = new Set("cancel close invalid load scroll toggle".split(" ").concat(Oc));
  function ch(d, g, $) {
    var he = d.type || "unknown-event";
    d.currentTarget = $, Ct(he, g, void 0, d), d.currentTarget = null;
  }
  function hh(d, g) {
    g = (g & 4) !== 0;
    for (var $ = 0; $ < d.length; $++) {
      var he = d[$], je = he.event;
      he = he.listeners;
      e: {
        var ot = void 0;
        if (g) for (var Vt = he.length - 1; 0 <= Vt; Vt--) {
          var bi = he[Vt], Ii = bi.instance, $i = bi.currentTarget;
          if (bi = bi.listener, Ii !== ot && je.isPropagationStopped()) break e;
          ch(je, bi, $i), ot = Ii;
        }
        else for (Vt = 0; Vt < he.length; Vt++) {
          if (bi = he[Vt], Ii = bi.instance, $i = bi.currentTarget, bi = bi.listener, Ii !== ot && je.isPropagationStopped()) break e;
          ch(je, bi, $i), ot = Ii;
        }
      }
    }
    if (Mt) throw d = Ae, Mt = !1, Ae = null, d;
  }
  function da(d, g) {
    var $ = g[Nl];
    $ === void 0 && ($ = g[Nl] = /* @__PURE__ */ new Set());
    var he = d + "__bubble";
    $.has(he) || (Lf(g, d, 2, !1), $.add(he));
  }
  function Dc(d, g, $) {
    var he = 0;
    g && (he |= 4), Lf($, d, he, g);
  }
  var zc = "_reactListening" + Math.random().toString(36).slice(2);
  function ic(d) {
    if (!d[zc]) {
      d[zc] = !0, Q.forEach(function($) {
        $ !== "selectionchange" && (jn.has($) || Dc($, !1, d), Dc($, !0, d));
      });
      var g = d.nodeType === 9 ? d : d.ownerDocument;
      g === null || g[zc] || (g[zc] = !0, Dc("selectionchange", !1, g));
    }
  }
  function Lf(d, g, $, he) {
    switch (No(g)) {
      case 1:
        var je = Dn;
        break;
      case 4:
        je = xs;
        break;
      default:
        je = va;
    }
    $ = je.bind(null, g, $, d), je = void 0, !Et || g !== "touchstart" && g !== "touchmove" && g !== "wheel" || (je = !0), he ? je !== void 0 ? d.addEventListener(g, $, { capture: !0, passive: je }) : d.addEventListener(g, $, !0) : je !== void 0 ? d.addEventListener(g, $, { passive: je }) : d.addEventListener(g, $, !1);
  }
  function du(d, g, $, he, je) {
    var ot = he;
    if (!(g & 1) && !(g & 2) && he !== null) e: for (; ; ) {
      if (he === null) return;
      var Vt = he.tag;
      if (Vt === 3 || Vt === 4) {
        var bi = he.stateNode.containerInfo;
        if (bi === je || bi.nodeType === 8 && bi.parentNode === je) break;
        if (Vt === 4) for (Vt = he.return; Vt !== null; ) {
          var Ii = Vt.tag;
          if ((Ii === 3 || Ii === 4) && (Ii = Vt.stateNode.containerInfo, Ii === je || Ii.nodeType === 8 && Ii.parentNode === je)) return;
          Vt = Vt.return;
        }
        for (; bi !== null; ) {
          if (Vt = Ul(bi), Vt === null) return;
          if (Ii = Vt.tag, Ii === 5 || Ii === 6) {
            he = ot = Vt;
            continue e;
          }
          bi = bi.parentNode;
        }
      }
      he = he.return;
    }
    ae(function() {
      var $i = ot, gr = Pe($), yr = [];
      e: {
        var vr = fu.get(d);
        if (vr !== void 0) {
          var Vr = ia, jr = d;
          switch (d) {
            case "keypress":
              if (ol($) === 0) break e;
            case "keydown":
            case "keyup":
              Vr = Ol;
              break;
            case "focusin":
              jr = "focus", Vr = au;
              break;
            case "focusout":
              jr = "blur", Vr = au;
              break;
            case "beforeblur":
            case "afterblur":
              Vr = au;
              break;
            case "click":
              if ($.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Vr = _o;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Vr = Mc;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Vr = Pc;
              break;
            case hu:
            case ec:
            case Lc:
              Vr = su;
              break;
            case tc:
              Vr = Uo;
              break;
            case "scroll":
              Vr = Gs;
              break;
            case "wheel":
              Vr = Sr;
              break;
            case "copy":
            case "cut":
            case "paste":
              Vr = Kh;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Vr = Ic;
          }
          var qr = (g & 4) !== 0, qa = !qr && d === "scroll", Vi = qr ? vr !== null ? vr + "Capture" : null : vr;
          qr = [];
          for (var Li = $i, Wi; Li !== null; ) {
            Wi = Li;
            var Cr = Wi.stateNode;
            if (Wi.tag === 5 && Cr !== null && (Wi = Cr, Vi !== null && (Cr = $e(Li, Vi), Cr != null && qr.push(_l(Li, Cr, Wi)))), qa) break;
            Li = Li.return;
          }
          0 < qr.length && (vr = new Vr(vr, jr, null, $, gr), yr.push({ event: vr, listeners: qr }));
        }
      }
      if (!(g & 7)) {
        e: {
          if (vr = d === "mouseover" || d === "pointerover", Vr = d === "mouseout" || d === "pointerout", vr && $ !== Se && (jr = $.relatedTarget || $.fromElement) && (Ul(jr) || jr[yo])) break e;
          if ((Vr || vr) && (vr = gr.window === gr ? gr : (vr = gr.ownerDocument) ? vr.defaultView || vr.parentWindow : window, Vr ? (jr = $.relatedTarget || $.toElement, Vr = $i, jr = jr ? Ul(jr) : null, jr !== null && (qa = It(jr), jr !== qa || jr.tag !== 5 && jr.tag !== 6) && (jr = null)) : (Vr = null, jr = $i), Vr !== jr)) {
            if (qr = _o, Cr = "onMouseLeave", Vi = "onMouseEnter", Li = "mouse", (d === "pointerout" || d === "pointerover") && (qr = Ic, Cr = "onPointerLeave", Vi = "onPointerEnter", Li = "pointer"), qa = Vr == null ? vr : ao(Vr), Wi = jr == null ? vr : ao(jr), vr = new qr(Cr, Li + "leave", Vr, $, gr), vr.target = qa, vr.relatedTarget = Wi, Cr = null, Ul(gr) === $i && (qr = new qr(Vi, Li + "enter", jr, $, gr), qr.target = Wi, qr.relatedTarget = qa, Cr = qr), qa = Cr, Vr && jr) t: {
              for (qr = Vr, Vi = jr, Li = 0, Wi = qr; Wi; Wi = is(Wi)) Li++;
              for (Wi = 0, Cr = Vi; Cr; Cr = is(Cr)) Wi++;
              for (; 0 < Li - Wi; ) qr = is(qr), Li--;
              for (; 0 < Wi - Li; ) Vi = is(Vi), Wi--;
              for (; Li--; ) {
                if (qr === Vi || Vi !== null && qr === Vi.alternate) break t;
                qr = is(qr), Vi = is(Vi);
              }
              qr = null;
            }
            else qr = null;
            Vr !== null && fh(yr, vr, Vr, qr, !1), jr !== null && qa !== null && fh(yr, qa, jr, qr, !0);
          }
        }
        e: {
          if (vr = $i ? ao($i) : window, Vr = vr.nodeName && vr.nodeName.toLowerCase(), Vr === "select" || Vr === "input" && vr.type === "file") var Zr = dl;
          else if (Mo(vr)) if (Go) Zr = kc;
          else {
            Zr = Rc;
            var $r = lh;
          }
          else (Vr = vr.nodeName) && Vr.toLowerCase() === "input" && (vr.type === "checkbox" || vr.type === "radio") && (Zr = Ju);
          if (Zr && (Zr = Zr(d, $i))) {
            Vo(yr, Zr, $, gr);
            break e;
          }
          $r && $r(d, vr, $i), d === "focusout" && ($r = vr._wrapperState) && $r.controlled && vr.type === "number" && De(vr, "number", vr.value);
        }
        switch ($r = $i ? ao($i) : window, d) {
          case "focusin":
            (Mo($r) || $r.contentEditable === "true") && (Va = $r, cs = $i, go = null);
            break;
          case "focusout":
            go = cs = Va = null;
            break;
          case "mousedown":
            qo = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            qo = !1, Wo(yr, $, gr);
            break;
          case "selectionchange":
            if (Mn) break;
          case "keydown":
          case "keyup":
            Wo(yr, $, gr);
        }
        var un;
        if (Lr) e: {
          switch (d) {
            case "compositionstart":
              var vn = "onCompositionStart";
              break e;
            case "compositionend":
              vn = "onCompositionEnd";
              break e;
            case "compositionupdate":
              vn = "onCompositionUpdate";
              break e;
          }
          vn = void 0;
        }
        else Pa ? hl(d, $) && (vn = "onCompositionEnd") : d === "keydown" && $.keyCode === 229 && (vn = "onCompositionStart");
        vn && (kr && $.locale !== "ko" && (Pa || vn !== "onCompositionStart" ? vn === "onCompositionEnd" && Pa && (un = Ua()) : (Vs = gr, Na = "value" in Vs ? Vs.value : Vs.textContent, Pa = !0)), $r = Bc($i, vn), 0 < $r.length && (vn = new Ca(vn, d, null, $, gr), yr.push({ event: vn, listeners: $r }), un ? vn.data = un : (un = uu($), un !== null && (vn.data = un)))), (un = cl ? $a(d, $) : tr(d, $)) && ($i = Bc($i, "onBeforeInput"), 0 < $i.length && (gr = new Ca("onBeforeInput", "beforeinput", null, $, gr), yr.push({ event: gr, listeners: $i }), gr.data = un));
      }
      hh(yr, g);
    });
  }
  function _l(d, g, $) {
    return { instance: d, listener: g, currentTarget: $ };
  }
  function Bc(d, g) {
    for (var $ = g + "Capture", he = []; d !== null; ) {
      var je = d, ot = je.stateNode;
      je.tag === 5 && ot !== null && (je = ot, ot = $e(d, $), ot != null && he.unshift(_l(d, ot, je)), ot = $e(d, g), ot != null && he.push(_l(d, ot, je))), d = d.return;
    }
    return he;
  }
  function is(d) {
    if (d === null) return null;
    do
      d = d.return;
    while (d && d.tag !== 5);
    return d || null;
  }
  function fh(d, g, $, he, je) {
    for (var ot = g._reactName, Vt = []; $ !== null && $ !== he; ) {
      var bi = $, Ii = bi.alternate, $i = bi.stateNode;
      if (Ii !== null && Ii === he) break;
      bi.tag === 5 && $i !== null && (bi = $i, je ? (Ii = $e($, ot), Ii != null && Vt.unshift(_l($, Ii, bi))) : je || (Ii = $e($, ot), Ii != null && Vt.push(_l($, Ii, bi)))), $ = $.return;
    }
    Vt.length !== 0 && d.push({ event: g, listeners: Vt });
  }
  var dh = /\r\n?/g, ph = /\u0000|\uFFFD/g;
  function mh(d) {
    return (typeof d == "string" ? d : "" + d).replace(dh, `
`).replace(ph, "");
  }
  function rc(d, g, $) {
    if (g = mh(g), mh(d) !== g && $) throw Error(qe(425));
  }
  function pu() {
  }
  var Fc = null, Nc = null;
  function nc(d, g) {
    return d === "textarea" || d === "noscript" || typeof g.children == "string" || typeof g.children == "number" || typeof g.dangerouslySetInnerHTML == "object" && g.dangerouslySetInnerHTML !== null && g.dangerouslySetInnerHTML.__html != null;
  }
  var _h = typeof setTimeout == "function" ? setTimeout : void 0, Of = typeof clearTimeout == "function" ? clearTimeout : void 0, mu = typeof Promise == "function" ? Promise : void 0, _d = typeof queueMicrotask == "function" ? queueMicrotask : typeof mu < "u" ? function(d) {
    return mu.resolve(null).then(d).catch(gd);
  } : _h;
  function gd(d) {
    setTimeout(function() {
      throw d;
    });
  }
  function Jh(d, g) {
    var $ = g, he = 0;
    do {
      var je = $.nextSibling;
      if (d.removeChild($), je && je.nodeType === 8) if ($ = je.data, $ === "/$") {
        if (he === 0) {
          d.removeChild(je), Ia(g);
          return;
        }
        he--;
      } else $ !== "$" && $ !== "$?" && $ !== "$!" || he++;
      $ = je;
    } while ($);
    Ia(g);
  }
  function Fl(d) {
    for (; d != null; d = d.nextSibling) {
      var g = d.nodeType;
      if (g === 1 || g === 3) break;
      if (g === 8) {
        if (g = d.data, g === "$" || g === "$!" || g === "$?") break;
        if (g === "/$") return null;
      }
    }
    return d;
  }
  function Df(d) {
    d = d.previousSibling;
    for (var g = 0; d; ) {
      if (d.nodeType === 8) {
        var $ = d.data;
        if ($ === "$" || $ === "$!" || $ === "$?") {
          if (g === 0) return d;
          g--;
        } else $ === "/$" && g++;
      }
      d = d.previousSibling;
    }
    return null;
  }
  var ac = Math.random().toString(36).slice(2), vo = "__reactFiber$" + ac, _u = "__reactProps$" + ac, yo = "__reactContainer$" + ac, Nl = "__reactEvents$" + ac, Qh = "__reactListeners$" + ac, zf = "__reactHandles$" + ac;
  function Ul(d) {
    var g = d[vo];
    if (g) return g;
    for (var $ = d.parentNode; $; ) {
      if (g = $[yo] || $[vo]) {
        if ($ = g.alternate, g.child !== null || $ !== null && $.child !== null) for (d = Df(d); d !== null; ) {
          if ($ = d[vo]) return $;
          d = Df(d);
        }
        return g;
      }
      d = $, $ = d.parentNode;
    }
    return null;
  }
  function gu(d) {
    return d = d[vo] || d[yo], !d || d.tag !== 5 && d.tag !== 6 && d.tag !== 13 && d.tag !== 3 ? null : d;
  }
  function ao(d) {
    if (d.tag === 5 || d.tag === 6) return d.stateNode;
    throw Error(qe(33));
  }
  function sc(d) {
    return d[_u] || null;
  }
  var Rs = [], gl = -1;
  function xo(d) {
    return { current: d };
  }
  function wa(d) {
    0 > gl || (d.current = Rs[gl], Rs[gl] = null, gl--);
  }
  function ra(d, g) {
    gl++, Rs[gl] = d.current, d.current = g;
  }
  var bo = {}, hs = xo(bo), Hs = xo(!1), vl = bo;
  function Io(d, g) {
    var $ = d.type.contextTypes;
    if (!$) return bo;
    var he = d.stateNode;
    if (he && he.__reactInternalMemoizedUnmaskedChildContext === g) return he.__reactInternalMemoizedMaskedChildContext;
    var je = {}, ot;
    for (ot in $) je[ot] = g[ot];
    return he && (d = d.stateNode, d.__reactInternalMemoizedUnmaskedChildContext = g, d.__reactInternalMemoizedMaskedChildContext = je), je;
  }
  function qs(d) {
    return d = d.childContextTypes, d != null;
  }
  function gh() {
    wa(Hs), wa(hs);
  }
  function ef(d, g, $) {
    if (hs.current !== bo) throw Error(qe(168));
    ra(hs, g), ra(Hs, $);
  }
  function tf(d, g, $) {
    var he = d.stateNode;
    if (g = g.childContextTypes, typeof he.getChildContext != "function") return $;
    he = he.getChildContext();
    for (var je in he) if (!(je in g)) throw Error(qe(108, wt(d) || "Unknown", je));
    return it({}, $, he);
  }
  function vu(d) {
    return d = (d = d.stateNode) && d.__reactInternalMemoizedMergedChildContext || bo, vl = hs.current, ra(hs, d), ra(Hs, Hs.current), !0;
  }
  function yu(d, g, $) {
    var he = d.stateNode;
    if (!he) throw Error(qe(169));
    $ ? (d = tf(d, g, vl), he.__reactInternalMemoizedMergedChildContext = d, wa(Hs), wa(hs), ra(hs, d)) : wa(Hs), ra(Hs, $);
  }
  var Ws = null, xu = !1, bu = !1;
  function rf(d) {
    Ws === null ? Ws = [d] : Ws.push(d);
  }
  function Uc(d) {
    xu = !0, rf(d);
  }
  function wo() {
    if (!bu && Ws !== null) {
      bu = !0;
      var d = 0, g = mn;
      try {
        var $ = Ws;
        for (mn = 1; d < $.length; d++) {
          var he = $[d];
          do
            he = he(!0);
          while (he !== null);
        }
        Ws = null, xu = !1;
      } catch (je) {
        throw Ws !== null && (Ws = Ws.slice(d + 1)), oi(rr, wo), je;
      } finally {
        mn = g, bu = !1;
      }
    }
    return null;
  }
  var Vl = [], wu = 0, vh = null, Xo = 0, ks = [], ur = 0, yl = null, Po = 1, ws = "";
  function so(d, g) {
    Vl[wu++] = Xo, Vl[wu++] = vh, vh = d, Xo = g;
  }
  function wr(d, g, $) {
    ks[ur++] = Po, ks[ur++] = ws, ks[ur++] = yl, yl = d;
    var he = Po;
    d = ws;
    var je = 32 - xn(he) - 1;
    he &= ~(1 << je), $ += 1;
    var ot = 32 - xn(g) + je;
    if (30 < ot) {
      var Vt = je - je % 5;
      ot = (he & (1 << Vt) - 1).toString(32), he >>= Vt, je -= Vt, Po = 1 << 32 - xn(g) + je | $ << je | he, ws = ot + d;
    } else Po = 1 << ot | $ << je | he, ws = d;
  }
  function Vc(d) {
    d.return !== null && (so(d, 1), wr(d, 1, 0));
  }
  function nf(d) {
    for (; d === vh; ) vh = Vl[--wu], Vl[wu] = null, Xo = Vl[--wu], Vl[wu] = null;
    for (; d === yl; ) yl = ks[--ur], ks[ur] = null, ws = ks[--ur], ks[ur] = null, Po = ks[--ur], ks[ur] = null;
  }
  var oo = null, Ss = null, Sa = !1, lo = null;
  function af(d, g) {
    var $ = rl(5, null, null, 0);
    $.elementType = "DELETED", $.stateNode = g, $.return = d, g = d.deletions, g === null ? (d.deletions = [$], d.flags |= 16) : g.push($);
  }
  function yh(d, g) {
    switch (d.tag) {
      case 5:
        var $ = d.type;
        return g = g.nodeType !== 1 || $.toLowerCase() !== g.nodeName.toLowerCase() ? null : g, g !== null ? (d.stateNode = g, oo = d, Ss = Fl(g.firstChild), !0) : !1;
      case 6:
        return g = d.pendingProps === "" || g.nodeType !== 3 ? null : g, g !== null ? (d.stateNode = g, oo = d, Ss = null, !0) : !1;
      case 13:
        return g = g.nodeType !== 8 ? null : g, g !== null ? ($ = yl !== null ? { id: Po, overflow: ws } : null, d.memoizedState = { dehydrated: g, treeContext: $, retryLane: 1073741824 }, $ = rl(18, null, null, 0), $.stateNode = g, $.return = d, d.child = $, oo = d, Ss = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Su(d) {
    return (d.mode & 1) !== 0 && (d.flags & 128) === 0;
  }
  function oc(d) {
    if (Sa) {
      var g = Ss;
      if (g) {
        var $ = g;
        if (!yh(d, g)) {
          if (Su(d)) throw Error(qe(418));
          g = Fl($.nextSibling);
          var he = oo;
          g && yh(d, g) ? af(he, $) : (d.flags = d.flags & -4097 | 2, Sa = !1, oo = d);
        }
      } else {
        if (Su(d)) throw Error(qe(418));
        d.flags = d.flags & -4097 | 2, Sa = !1, oo = d;
      }
    }
  }
  function xh(d) {
    for (d = d.return; d !== null && d.tag !== 5 && d.tag !== 3 && d.tag !== 13; ) d = d.return;
    oo = d;
  }
  function uo(d) {
    if (d !== oo) return !1;
    if (!Sa) return xh(d), Sa = !0, !1;
    var g;
    if ((g = d.tag !== 3) && !(g = d.tag !== 5) && (g = d.type, g = g !== "head" && g !== "body" && !nc(d.type, d.memoizedProps)), g && (g = Ss)) {
      if (Su(d)) throw Ls(), Error(qe(418));
      for (; g; ) af(d, g), g = Fl(g.nextSibling);
    }
    if (xh(d), d.tag === 13) {
      if (d = d.memoizedState, d = d !== null ? d.dehydrated : null, !d) throw Error(qe(317));
      e: {
        for (d = d.nextSibling, g = 0; d; ) {
          if (d.nodeType === 8) {
            var $ = d.data;
            if ($ === "/$") {
              if (g === 0) {
                Ss = Fl(d.nextSibling);
                break e;
              }
              g--;
            } else $ !== "$" && $ !== "$!" && $ !== "$?" || g++;
          }
          d = d.nextSibling;
        }
        Ss = null;
      }
    } else Ss = oo ? Fl(d.stateNode.nextSibling) : null;
    return !0;
  }
  function Ls() {
    for (var d = Ss; d; ) d = Fl(d.nextSibling);
  }
  function co() {
    Ss = oo = null, Sa = !1;
  }
  function jc(d) {
    lo === null ? lo = [d] : lo.push(d);
  }
  var sf = U.ReactCurrentBatchConfig;
  function Yo(d, g, $) {
    if (d = $.ref, d !== null && typeof d != "function" && typeof d != "object") {
      if ($._owner) {
        if ($ = $._owner, $) {
          if ($.tag !== 1) throw Error(qe(309));
          var he = $.stateNode;
        }
        if (!he) throw Error(qe(147, d));
        var je = he, ot = "" + d;
        return g !== null && g.ref !== null && typeof g.ref == "function" && g.ref._stringRef === ot ? g.ref : (g = function(Vt) {
          var bi = je.refs;
          Vt === null ? delete bi[ot] : bi[ot] = Vt;
        }, g._stringRef = ot, g);
      }
      if (typeof d != "string") throw Error(qe(284));
      if (!$._owner) throw Error(qe(290, d));
    }
    return d;
  }
  function Eu(d, g) {
    throw d = Object.prototype.toString.call(g), Error(qe(31, d === "[object Object]" ? "object with keys {" + Object.keys(g).join(", ") + "}" : d));
  }
  function lc(d) {
    var g = d._init;
    return g(d._payload);
  }
  function Zs(d) {
    function g(Vi, Li) {
      if (d) {
        var Wi = Vi.deletions;
        Wi === null ? (Vi.deletions = [Li], Vi.flags |= 16) : Wi.push(Li);
      }
    }
    function $(Vi, Li) {
      if (!d) return null;
      for (; Li !== null; ) g(Vi, Li), Li = Li.sibling;
      return null;
    }
    function he(Vi, Li) {
      for (Vi = /* @__PURE__ */ new Map(); Li !== null; ) Li.key !== null ? Vi.set(Li.key, Li) : Vi.set(Li.index, Li), Li = Li.sibling;
      return Vi;
    }
    function je(Vi, Li) {
      return Vi = Nu(Vi, Li), Vi.index = 0, Vi.sibling = null, Vi;
    }
    function ot(Vi, Li, Wi) {
      return Vi.index = Wi, d ? (Wi = Vi.alternate, Wi !== null ? (Wi = Wi.index, Wi < Li ? (Vi.flags |= 2, Li) : Wi) : (Vi.flags |= 2, Li)) : (Vi.flags |= 1048576, Li);
    }
    function Vt(Vi) {
      return d && Vi.alternate === null && (Vi.flags |= 2), Vi;
    }
    function bi(Vi, Li, Wi, Cr) {
      return Li === null || Li.tag !== 6 ? (Li = jf(Wi, Vi.mode, Cr), Li.return = Vi, Li) : (Li = je(Li, Wi), Li.return = Vi, Li);
    }
    function Ii(Vi, Li, Wi, Cr) {
      var Zr = Wi.type;
      return Zr === W ? gr(Vi, Li, Wi.props.children, Cr, Wi.key) : Li !== null && (Li.elementType === Zr || typeof Zr == "object" && Zr !== null && Zr.$$typeof === Oe && lc(Zr) === Li.type) ? (Cr = je(Li, Wi.props), Cr.ref = Yo(Vi, Li, Wi), Cr.return = Vi, Cr) : (Cr = yf(Wi.type, Wi.key, Wi.props, null, Vi.mode, Cr), Cr.ref = Yo(Vi, Li, Wi), Cr.return = Vi, Cr);
    }
    function $i(Vi, Li, Wi, Cr) {
      return Li === null || Li.tag !== 4 || Li.stateNode.containerInfo !== Wi.containerInfo || Li.stateNode.implementation !== Wi.implementation ? (Li = Gf(Wi, Vi.mode, Cr), Li.return = Vi, Li) : (Li = je(Li, Wi.children || []), Li.return = Vi, Li);
    }
    function gr(Vi, Li, Wi, Cr, Zr) {
      return Li === null || Li.tag !== 7 ? (Li = Ec(Wi, Vi.mode, Cr, Zr), Li.return = Vi, Li) : (Li = je(Li, Wi), Li.return = Vi, Li);
    }
    function yr(Vi, Li, Wi) {
      if (typeof Li == "string" && Li !== "" || typeof Li == "number") return Li = jf("" + Li, Vi.mode, Wi), Li.return = Vi, Li;
      if (typeof Li == "object" && Li !== null) {
        switch (Li.$$typeof) {
          case j:
            return Wi = yf(Li.type, Li.key, Li.props, null, Vi.mode, Wi), Wi.ref = Yo(Vi, null, Li), Wi.return = Vi, Wi;
          case T:
            return Li = Gf(Li, Vi.mode, Wi), Li.return = Vi, Li;
          case Oe:
            var Cr = Li._init;
            return yr(Vi, Cr(Li._payload), Wi);
        }
        if (Re(Li) || Ce(Li)) return Li = Ec(Li, Vi.mode, Wi, null), Li.return = Vi, Li;
        Eu(Vi, Li);
      }
      return null;
    }
    function vr(Vi, Li, Wi, Cr) {
      var Zr = Li !== null ? Li.key : null;
      if (typeof Wi == "string" && Wi !== "" || typeof Wi == "number") return Zr !== null ? null : bi(Vi, Li, "" + Wi, Cr);
      if (typeof Wi == "object" && Wi !== null) {
        switch (Wi.$$typeof) {
          case j:
            return Wi.key === Zr ? Ii(Vi, Li, Wi, Cr) : null;
          case T:
            return Wi.key === Zr ? $i(Vi, Li, Wi, Cr) : null;
          case Oe:
            return Zr = Wi._init, vr(
              Vi,
              Li,
              Zr(Wi._payload),
              Cr
            );
        }
        if (Re(Wi) || Ce(Wi)) return Zr !== null ? null : gr(Vi, Li, Wi, Cr, null);
        Eu(Vi, Wi);
      }
      return null;
    }
    function Vr(Vi, Li, Wi, Cr, Zr) {
      if (typeof Cr == "string" && Cr !== "" || typeof Cr == "number") return Vi = Vi.get(Wi) || null, bi(Li, Vi, "" + Cr, Zr);
      if (typeof Cr == "object" && Cr !== null) {
        switch (Cr.$$typeof) {
          case j:
            return Vi = Vi.get(Cr.key === null ? Wi : Cr.key) || null, Ii(Li, Vi, Cr, Zr);
          case T:
            return Vi = Vi.get(Cr.key === null ? Wi : Cr.key) || null, $i(Li, Vi, Cr, Zr);
          case Oe:
            var $r = Cr._init;
            return Vr(Vi, Li, Wi, $r(Cr._payload), Zr);
        }
        if (Re(Cr) || Ce(Cr)) return Vi = Vi.get(Wi) || null, gr(Li, Vi, Cr, Zr, null);
        Eu(Li, Cr);
      }
      return null;
    }
    function jr(Vi, Li, Wi, Cr) {
      for (var Zr = null, $r = null, un = Li, vn = Li = 0, As = null; un !== null && vn < Wi.length; vn++) {
        un.index > vn ? (As = un, un = null) : As = un.sibling;
        var Kn = vr(Vi, un, Wi[vn], Cr);
        if (Kn === null) {
          un === null && (un = As);
          break;
        }
        d && un && Kn.alternate === null && g(Vi, un), Li = ot(Kn, Li, vn), $r === null ? Zr = Kn : $r.sibling = Kn, $r = Kn, un = As;
      }
      if (vn === Wi.length) return $(Vi, un), Sa && so(Vi, vn), Zr;
      if (un === null) {
        for (; vn < Wi.length; vn++) un = yr(Vi, Wi[vn], Cr), un !== null && (Li = ot(un, Li, vn), $r === null ? Zr = un : $r.sibling = un, $r = un);
        return Sa && so(Vi, vn), Zr;
      }
      for (un = he(Vi, un); vn < Wi.length; vn++) As = Vr(un, Vi, vn, Wi[vn], Cr), As !== null && (d && As.alternate !== null && un.delete(As.key === null ? vn : As.key), Li = ot(As, Li, vn), $r === null ? Zr = As : $r.sibling = As, $r = As);
      return d && un.forEach(function(Cc) {
        return g(Vi, Cc);
      }), Sa && so(Vi, vn), Zr;
    }
    function qr(Vi, Li, Wi, Cr) {
      var Zr = Ce(Wi);
      if (typeof Zr != "function") throw Error(qe(150));
      if (Wi = Zr.call(Wi), Wi == null) throw Error(qe(151));
      for (var $r = Zr = null, un = Li, vn = Li = 0, As = null, Kn = Wi.next(); un !== null && !Kn.done; vn++, Kn = Wi.next()) {
        un.index > vn ? (As = un, un = null) : As = un.sibling;
        var Cc = vr(Vi, un, Kn.value, Cr);
        if (Cc === null) {
          un === null && (un = As);
          break;
        }
        d && un && Cc.alternate === null && g(Vi, un), Li = ot(Cc, Li, vn), $r === null ? Zr = Cc : $r.sibling = Cc, $r = Cc, un = As;
      }
      if (Kn.done) return $(
        Vi,
        un
      ), Sa && so(Vi, vn), Zr;
      if (un === null) {
        for (; !Kn.done; vn++, Kn = Wi.next()) Kn = yr(Vi, Kn.value, Cr), Kn !== null && (Li = ot(Kn, Li, vn), $r === null ? Zr = Kn : $r.sibling = Kn, $r = Kn);
        return Sa && so(Vi, vn), Zr;
      }
      for (un = he(Vi, un); !Kn.done; vn++, Kn = Wi.next()) Kn = Vr(un, Vi, vn, Kn.value, Cr), Kn !== null && (d && Kn.alternate !== null && un.delete(Kn.key === null ? vn : Kn.key), Li = ot(Kn, Li, vn), $r === null ? Zr = Kn : $r.sibling = Kn, $r = Kn);
      return d && un.forEach(function(um) {
        return g(Vi, um);
      }), Sa && so(Vi, vn), Zr;
    }
    function qa(Vi, Li, Wi, Cr) {
      if (typeof Wi == "object" && Wi !== null && Wi.type === W && Wi.key === null && (Wi = Wi.props.children), typeof Wi == "object" && Wi !== null) {
        switch (Wi.$$typeof) {
          case j:
            e: {
              for (var Zr = Wi.key, $r = Li; $r !== null; ) {
                if ($r.key === Zr) {
                  if (Zr = Wi.type, Zr === W) {
                    if ($r.tag === 7) {
                      $(Vi, $r.sibling), Li = je($r, Wi.props.children), Li.return = Vi, Vi = Li;
                      break e;
                    }
                  } else if ($r.elementType === Zr || typeof Zr == "object" && Zr !== null && Zr.$$typeof === Oe && lc(Zr) === $r.type) {
                    $(Vi, $r.sibling), Li = je($r, Wi.props), Li.ref = Yo(Vi, $r, Wi), Li.return = Vi, Vi = Li;
                    break e;
                  }
                  $(Vi, $r);
                  break;
                } else g(Vi, $r);
                $r = $r.sibling;
              }
              Wi.type === W ? (Li = Ec(Wi.props.children, Vi.mode, Cr, Wi.key), Li.return = Vi, Vi = Li) : (Cr = yf(Wi.type, Wi.key, Wi.props, null, Vi.mode, Cr), Cr.ref = Yo(Vi, Li, Wi), Cr.return = Vi, Vi = Cr);
            }
            return Vt(Vi);
          case T:
            e: {
              for ($r = Wi.key; Li !== null; ) {
                if (Li.key === $r) if (Li.tag === 4 && Li.stateNode.containerInfo === Wi.containerInfo && Li.stateNode.implementation === Wi.implementation) {
                  $(Vi, Li.sibling), Li = je(Li, Wi.children || []), Li.return = Vi, Vi = Li;
                  break e;
                } else {
                  $(Vi, Li);
                  break;
                }
                else g(Vi, Li);
                Li = Li.sibling;
              }
              Li = Gf(Wi, Vi.mode, Cr), Li.return = Vi, Vi = Li;
            }
            return Vt(Vi);
          case Oe:
            return $r = Wi._init, qa(Vi, Li, $r(Wi._payload), Cr);
        }
        if (Re(Wi)) return jr(Vi, Li, Wi, Cr);
        if (Ce(Wi)) return qr(Vi, Li, Wi, Cr);
        Eu(Vi, Wi);
      }
      return typeof Wi == "string" && Wi !== "" || typeof Wi == "number" ? (Wi = "" + Wi, Li !== null && Li.tag === 6 ? ($(Vi, Li.sibling), Li = je(Li, Wi), Li.return = Vi, Vi = Li) : ($(Vi, Li), Li = jf(Wi, Vi.mode, Cr), Li.return = Vi, Vi = Li), Vt(Vi)) : $(Vi, Li);
    }
    return qa;
  }
  var Tn = Zs(!0), Gc = Zs(!1), jl = xo(null), Tu = null, Gl = null, Cu = null;
  function Hl() {
    Cu = Gl = Tu = null;
  }
  function ql(d) {
    var g = jl.current;
    wa(jl), d._currentValue = g;
  }
  function Wl(d, g, $) {
    for (; d !== null; ) {
      var he = d.alternate;
      if ((d.childLanes & g) !== g ? (d.childLanes |= g, he !== null && (he.childLanes |= g)) : he !== null && (he.childLanes & g) !== g && (he.childLanes |= g), d === $) break;
      d = d.return;
    }
  }
  function Ji(d, g) {
    Tu = d, Cu = Gl = null, d = d.dependencies, d !== null && d.firstContext !== null && (d.lanes & g && (Es = !0), d.firstContext = null);
  }
  function or(d) {
    var g = d._currentValue;
    if (Cu !== d) if (d = { context: d, memoizedValue: g, next: null }, Gl === null) {
      if (Tu === null) throw Error(qe(308));
      Gl = d, Tu.dependencies = { lanes: 0, firstContext: d };
    } else Gl = Gl.next = d;
    return g;
  }
  var So = null;
  function Wn(d) {
    So === null ? So = [d] : So.push(d);
  }
  function Ei(d, g, $, he) {
    var je = g.interleaved;
    return je === null ? ($.next = $, Wn(g)) : ($.next = je.next, je.next = $), g.interleaved = $, Ko(d, he);
  }
  function Ko(d, g) {
    d.lanes |= g;
    var $ = d.alternate;
    for ($ !== null && ($.lanes |= g), $ = d, d = d.return; d !== null; ) d.childLanes |= g, $ = d.alternate, $ !== null && ($.childLanes |= g), $ = d, d = d.return;
    return $.tag === 3 ? $.stateNode : null;
  }
  var Ro = !1;
  function Hc(d) {
    d.updateQueue = { baseState: d.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function of(d, g) {
    d = d.updateQueue, g.updateQueue === d && (g.updateQueue = { baseState: d.baseState, firstBaseUpdate: d.firstBaseUpdate, lastBaseUpdate: d.lastBaseUpdate, shared: d.shared, effects: d.effects });
  }
  function Jo(d, g) {
    return { eventTime: d, lane: g, tag: 0, payload: null, callback: null, next: null };
  }
  function xl(d, g, $) {
    var he = d.updateQueue;
    if (he === null) return null;
    if (he = he.shared, Jt & 2) {
      var je = he.pending;
      return je === null ? g.next = g : (g.next = je.next, je.next = g), he.pending = g, Ko(d, $);
    }
    return je = he.interleaved, je === null ? (g.next = g, Wn(he)) : (g.next = je.next, je.next = g), he.interleaved = g, Ko(d, $);
  }
  function bl(d, g, $) {
    if (g = g.updateQueue, g !== null && (g = g.shared, ($ & 4194240) !== 0)) {
      var he = g.lanes;
      he &= d.pendingLanes, $ |= he, g.lanes = $, La(d, $);
    }
  }
  function Bf(d, g) {
    var $ = d.updateQueue, he = d.alternate;
    if (he !== null && (he = he.updateQueue, $ === he)) {
      var je = null, ot = null;
      if ($ = $.firstBaseUpdate, $ !== null) {
        do {
          var Vt = { eventTime: $.eventTime, lane: $.lane, tag: $.tag, payload: $.payload, callback: $.callback, next: null };
          ot === null ? je = ot = Vt : ot = ot.next = Vt, $ = $.next;
        } while ($ !== null);
        ot === null ? je = ot = g : ot = ot.next = g;
      } else je = ot = g;
      $ = { baseState: he.baseState, firstBaseUpdate: je, lastBaseUpdate: ot, shared: he.shared, effects: he.effects }, d.updateQueue = $;
      return;
    }
    d = $.lastBaseUpdate, d === null ? $.firstBaseUpdate = g : d.next = g, $.lastBaseUpdate = g;
  }
  function bh(d, g, $, he) {
    var je = d.updateQueue;
    Ro = !1;
    var ot = je.firstBaseUpdate, Vt = je.lastBaseUpdate, bi = je.shared.pending;
    if (bi !== null) {
      je.shared.pending = null;
      var Ii = bi, $i = Ii.next;
      Ii.next = null, Vt === null ? ot = $i : Vt.next = $i, Vt = Ii;
      var gr = d.alternate;
      gr !== null && (gr = gr.updateQueue, bi = gr.lastBaseUpdate, bi !== Vt && (bi === null ? gr.firstBaseUpdate = $i : bi.next = $i, gr.lastBaseUpdate = Ii));
    }
    if (ot !== null) {
      var yr = je.baseState;
      Vt = 0, gr = $i = Ii = null, bi = ot;
      do {
        var vr = bi.lane, Vr = bi.eventTime;
        if ((he & vr) === vr) {
          gr !== null && (gr = gr.next = {
            eventTime: Vr,
            lane: 0,
            tag: bi.tag,
            payload: bi.payload,
            callback: bi.callback,
            next: null
          });
          e: {
            var jr = d, qr = bi;
            switch (vr = g, Vr = $, qr.tag) {
              case 1:
                if (jr = qr.payload, typeof jr == "function") {
                  yr = jr.call(Vr, yr, vr);
                  break e;
                }
                yr = jr;
                break e;
              case 3:
                jr.flags = jr.flags & -65537 | 128;
              case 0:
                if (jr = qr.payload, vr = typeof jr == "function" ? jr.call(Vr, yr, vr) : jr, vr == null) break e;
                yr = it({}, yr, vr);
                break e;
              case 2:
                Ro = !0;
            }
          }
          bi.callback !== null && bi.lane !== 0 && (d.flags |= 64, vr = je.effects, vr === null ? je.effects = [bi] : vr.push(bi));
        } else Vr = { eventTime: Vr, lane: vr, tag: bi.tag, payload: bi.payload, callback: bi.callback, next: null }, gr === null ? ($i = gr = Vr, Ii = yr) : gr = gr.next = Vr, Vt |= vr;
        if (bi = bi.next, bi === null) {
          if (bi = je.shared.pending, bi === null) break;
          vr = bi, bi = vr.next, vr.next = null, je.lastBaseUpdate = vr, je.shared.pending = null;
        }
      } while (!0);
      if (gr === null && (Ii = yr), je.baseState = Ii, je.firstBaseUpdate = $i, je.lastBaseUpdate = gr, g = je.shared.interleaved, g !== null) {
        je = g;
        do
          Vt |= je.lane, je = je.next;
        while (je !== g);
      } else ot === null && (je.shared.lanes = 0);
      ji |= Vt, d.lanes = Vt, d.memoizedState = yr;
    }
  }
  function lf(d, g, $) {
    if (d = g.effects, g.effects = null, d !== null) for (g = 0; g < d.length; g++) {
      var he = d[g], je = he.callback;
      if (je !== null) {
        if (he.callback = null, he = $, typeof je != "function") throw Error(qe(191, je));
        je.call(he);
      }
    }
  }
  var Zl = {}, _s = xo(Zl), Au = xo(Zl), Mu = xo(Zl);
  function ho(d) {
    if (d === Zl) throw Error(qe(174));
    return d;
  }
  function uc(d, g) {
    switch (ra(Mu, g), ra(Au, d), ra(_s, Zl), d = g.nodeType, d) {
      case 9:
      case 11:
        g = (g = g.documentElement) ? g.namespaceURI : _(null, "");
        break;
      default:
        d = d === 8 ? g.parentNode : g, g = d.namespaceURI || null, d = d.tagName, g = _(g, d);
    }
    wa(_s), ra(_s, g);
  }
  function Os() {
    wa(_s), wa(Au), wa(Mu);
  }
  function Qo(d) {
    ho(Mu.current);
    var g = ho(_s.current), $ = _(g, d.type);
    g !== $ && (ra(Au, d), ra(_s, $));
  }
  function wh(d) {
    Au.current === d && (wa(_s), wa(Au));
  }
  var bn = xo(0);
  function Sh(d) {
    for (var g = d; g !== null; ) {
      if (g.tag === 13) {
        var $ = g.memoizedState;
        if ($ !== null && ($ = $.dehydrated, $ === null || $.data === "$?" || $.data === "$!")) return g;
      } else if (g.tag === 19 && g.memoizedProps.revealOrder !== void 0) {
        if (g.flags & 128) return g;
      } else if (g.child !== null) {
        g.child.return = g, g = g.child;
        continue;
      }
      if (g === d) break;
      for (; g.sibling === null; ) {
        if (g.return === null || g.return === d) return null;
        g = g.return;
      }
      g.sibling.return = g.return, g = g.sibling;
    }
    return null;
  }
  var Iu = [];
  function Ln() {
    for (var d = 0; d < Iu.length; d++) Iu[d]._workInProgressVersionPrimary = null;
    Iu.length = 0;
  }
  var dn = U.ReactCurrentDispatcher, Eh = U.ReactCurrentBatchConfig, Ds = 0, oa = null, pa = null, ja = null, $l = !1, $s = !1, Ga = 0, Th = 0;
  function Xa() {
    throw Error(qe(321));
  }
  function qc(d, g) {
    if (g === null) return !1;
    for (var $ = 0; $ < g.length && $ < d.length; $++) if (!ba(d[$], g[$])) return !1;
    return !0;
  }
  function Wc(d, g, $, he, je, ot) {
    if (Ds = ot, oa = g, g.memoizedState = null, g.updateQueue = null, g.lanes = 0, dn.current = d === null || d.memoizedState === null ? vd : Ea, d = $(he, je), $s) {
      ot = 0;
      do {
        if ($s = !1, Ga = 0, 25 <= ot) throw Error(qe(301));
        ot += 1, ja = pa = null, g.updateQueue = null, dn.current = kh, d = $(he, je);
      } while ($s);
    }
    if (dn.current = Rh, g = pa !== null && pa.next !== null, Ds = 0, ja = pa = oa = null, $l = !1, g) throw Error(qe(300));
    return d;
  }
  function wl() {
    var d = Ga !== 0;
    return Ga = 0, d;
  }
  function Eo() {
    var d = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return ja === null ? oa.memoizedState = ja = d : ja = ja.next = d, ja;
  }
  function rs() {
    if (pa === null) {
      var d = oa.alternate;
      d = d !== null ? d.memoizedState : null;
    } else d = pa.next;
    var g = ja === null ? oa.memoizedState : ja.next;
    if (g !== null) ja = g, pa = d;
    else {
      if (d === null) throw Error(qe(310));
      pa = d, d = { memoizedState: pa.memoizedState, baseState: pa.baseState, baseQueue: pa.baseQueue, queue: pa.queue, next: null }, ja === null ? oa.memoizedState = ja = d : ja = ja.next = d;
    }
    return ja;
  }
  function Pu(d, g) {
    return typeof g == "function" ? g(d) : g;
  }
  function cc(d) {
    var g = rs(), $ = g.queue;
    if ($ === null) throw Error(qe(311));
    $.lastRenderedReducer = d;
    var he = pa, je = he.baseQueue, ot = $.pending;
    if (ot !== null) {
      if (je !== null) {
        var Vt = je.next;
        je.next = ot.next, ot.next = Vt;
      }
      he.baseQueue = je = ot, $.pending = null;
    }
    if (je !== null) {
      ot = je.next, he = he.baseState;
      var bi = Vt = null, Ii = null, $i = ot;
      do {
        var gr = $i.lane;
        if ((Ds & gr) === gr) Ii !== null && (Ii = Ii.next = { lane: 0, action: $i.action, hasEagerState: $i.hasEagerState, eagerState: $i.eagerState, next: null }), he = $i.hasEagerState ? $i.eagerState : d(he, $i.action);
        else {
          var yr = {
            lane: gr,
            action: $i.action,
            hasEagerState: $i.hasEagerState,
            eagerState: $i.eagerState,
            next: null
          };
          Ii === null ? (bi = Ii = yr, Vt = he) : Ii = Ii.next = yr, oa.lanes |= gr, ji |= gr;
        }
        $i = $i.next;
      } while ($i !== null && $i !== ot);
      Ii === null ? Vt = he : Ii.next = bi, ba(he, g.memoizedState) || (Es = !0), g.memoizedState = he, g.baseState = Vt, g.baseQueue = Ii, $.lastRenderedState = he;
    }
    if (d = $.interleaved, d !== null) {
      je = d;
      do
        ot = je.lane, oa.lanes |= ot, ji |= ot, je = je.next;
      while (je !== d);
    } else je === null && ($.lanes = 0);
    return [g.memoizedState, $.dispatch];
  }
  function Zc(d) {
    var g = rs(), $ = g.queue;
    if ($ === null) throw Error(qe(311));
    $.lastRenderedReducer = d;
    var he = $.dispatch, je = $.pending, ot = g.memoizedState;
    if (je !== null) {
      $.pending = null;
      var Vt = je = je.next;
      do
        ot = d(ot, Vt.action), Vt = Vt.next;
      while (Vt !== je);
      ba(ot, g.memoizedState) || (Es = !0), g.memoizedState = ot, g.baseQueue === null && (g.baseState = ot), $.lastRenderedState = ot;
    }
    return [ot, he];
  }
  function Ch() {
  }
  function Ya(d, g) {
    var $ = oa, he = rs(), je = g(), ot = !ba(he.memoizedState, je);
    if (ot && (he.memoizedState = je, Es = !0), he = he.queue, ku(hc.bind(null, $, he, d), [d]), he.getSnapshot !== g || ot || ja !== null && ja.memoizedState.tag & 1) {
      if ($.flags |= 2048, Xl(9, Mh.bind(null, $, he, je, g), void 0, null), ui === null) throw Error(qe(349));
      Ds & 30 || Ah($, g, je);
    }
    return je;
  }
  function Ah(d, g, $) {
    d.flags |= 16384, d = { getSnapshot: g, value: $ }, g = oa.updateQueue, g === null ? (g = { lastEffect: null, stores: null }, oa.updateQueue = g, g.stores = [d]) : ($ = g.stores, $ === null ? g.stores = [d] : $.push(d));
  }
  function Mh(d, g, $, he) {
    g.value = $, g.getSnapshot = he, Sl(g) && $c(d);
  }
  function hc(d, g, $) {
    return $(function() {
      Sl(g) && $c(d);
    });
  }
  function Sl(d) {
    var g = d.getSnapshot;
    d = d.value;
    try {
      var $ = g();
      return !ba(d, $);
    } catch {
      return !0;
    }
  }
  function $c(d) {
    var g = Ko(d, 1);
    g !== null && Jr(g, d, 1, -1);
  }
  function ko(d) {
    var g = Eo();
    return typeof d == "function" && (d = d()), g.memoizedState = g.baseState = d, d = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Pu, lastRenderedState: d }, g.queue = d, d = d.dispatch = Kc.bind(null, oa, d), [g.memoizedState, d];
  }
  function Xl(d, g, $, he) {
    return d = { tag: d, create: g, destroy: $, deps: he, next: null }, g = oa.updateQueue, g === null ? (g = { lastEffect: null, stores: null }, oa.updateQueue = g, g.lastEffect = d.next = d) : ($ = g.lastEffect, $ === null ? g.lastEffect = d.next = d : (he = $.next, $.next = d, d.next = he, g.lastEffect = d)), d;
  }
  function Ru() {
    return rs().memoizedState;
  }
  function fc(d, g, $, he) {
    var je = Eo();
    oa.flags |= d, je.memoizedState = Xl(1 | g, $, void 0, he === void 0 ? null : he);
  }
  function dc(d, g, $, he) {
    var je = rs();
    he = he === void 0 ? null : he;
    var ot = void 0;
    if (pa !== null) {
      var Vt = pa.memoizedState;
      if (ot = Vt.destroy, he !== null && qc(he, Vt.deps)) {
        je.memoizedState = Xl(g, $, ot, he);
        return;
      }
    }
    oa.flags |= d, je.memoizedState = Xl(1 | g, $, ot, he);
  }
  function pc(d, g) {
    return fc(8390656, 8, d, g);
  }
  function ku(d, g) {
    return dc(2048, 8, d, g);
  }
  function Ih(d, g) {
    return dc(4, 2, d, g);
  }
  function Xc(d, g) {
    return dc(4, 4, d, g);
  }
  function uf(d, g) {
    if (typeof g == "function") return d = d(), g(d), function() {
      g(null);
    };
    if (g != null) return d = d(), g.current = d, function() {
      g.current = null;
    };
  }
  function Ph(d, g, $) {
    return $ = $ != null ? $.concat([d]) : null, dc(4, 4, uf.bind(null, g, d), $);
  }
  function Lu() {
  }
  function cf(d, g) {
    var $ = rs();
    g = g === void 0 ? null : g;
    var he = $.memoizedState;
    return he !== null && g !== null && qc(g, he[1]) ? he[0] : ($.memoizedState = [d, g], d);
  }
  function hf(d, g) {
    var $ = rs();
    g = g === void 0 ? null : g;
    var he = $.memoizedState;
    return he !== null && g !== null && qc(g, he[1]) ? he[0] : (d = d(), $.memoizedState = [d, g], d);
  }
  function ff(d, g, $) {
    return Ds & 21 ? (ba($, g) || ($ = za(), oa.lanes |= $, ji |= $, d.baseState = !0), g) : (d.baseState && (d.baseState = !1, Es = !0), d.memoizedState = $);
  }
  function Ff(d, g) {
    var $ = mn;
    mn = $ !== 0 && 4 > $ ? $ : 4, d(!0);
    var he = Eh.transition;
    Eh.transition = {};
    try {
      d(!1), g();
    } finally {
      mn = $, Eh.transition = he;
    }
  }
  function df() {
    return rs().memoizedState;
  }
  function Yc(d, g, $) {
    var he = Nr(d);
    if ($ = { lane: he, action: $, hasEagerState: !1, eagerState: null, next: null }, zs(d)) mc(g, $);
    else if ($ = Ei(d, g, $, he), $ !== null) {
      var je = fn();
      Jr($, d, he, je), pf($, g, he);
    }
  }
  function Kc(d, g, $) {
    var he = Nr(d), je = { lane: he, action: $, hasEagerState: !1, eagerState: null, next: null };
    if (zs(d)) mc(g, je);
    else {
      var ot = d.alternate;
      if (d.lanes === 0 && (ot === null || ot.lanes === 0) && (ot = g.lastRenderedReducer, ot !== null)) try {
        var Vt = g.lastRenderedState, bi = ot(Vt, $);
        if (je.hasEagerState = !0, je.eagerState = bi, ba(bi, Vt)) {
          var Ii = g.interleaved;
          Ii === null ? (je.next = je, Wn(g)) : (je.next = Ii.next, Ii.next = je), g.interleaved = je;
          return;
        }
      } catch {
      } finally {
      }
      $ = Ei(d, g, je, he), $ !== null && (je = fn(), Jr($, d, he, je), pf($, g, he));
    }
  }
  function zs(d) {
    var g = d.alternate;
    return d === oa || g !== null && g === oa;
  }
  function mc(d, g) {
    $s = $l = !0;
    var $ = d.pending;
    $ === null ? g.next = g : (g.next = $.next, $.next = g), d.pending = g;
  }
  function pf(d, g, $) {
    if ($ & 4194240) {
      var he = g.lanes;
      he &= d.pendingLanes, $ |= he, g.lanes = $, La(d, $);
    }
  }
  var Rh = { readContext: or, useCallback: Xa, useContext: Xa, useEffect: Xa, useImperativeHandle: Xa, useInsertionEffect: Xa, useLayoutEffect: Xa, useMemo: Xa, useReducer: Xa, useRef: Xa, useState: Xa, useDebugValue: Xa, useDeferredValue: Xa, useTransition: Xa, useMutableSource: Xa, useSyncExternalStore: Xa, useId: Xa, unstable_isNewReconciler: !1 }, vd = { readContext: or, useCallback: function(d, g) {
    return Eo().memoizedState = [d, g === void 0 ? null : g], d;
  }, useContext: or, useEffect: pc, useImperativeHandle: function(d, g, $) {
    return $ = $ != null ? $.concat([d]) : null, fc(
      4194308,
      4,
      uf.bind(null, g, d),
      $
    );
  }, useLayoutEffect: function(d, g) {
    return fc(4194308, 4, d, g);
  }, useInsertionEffect: function(d, g) {
    return fc(4, 2, d, g);
  }, useMemo: function(d, g) {
    var $ = Eo();
    return g = g === void 0 ? null : g, d = d(), $.memoizedState = [d, g], d;
  }, useReducer: function(d, g, $) {
    var he = Eo();
    return g = $ !== void 0 ? $(g) : g, he.memoizedState = he.baseState = g, d = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: d, lastRenderedState: g }, he.queue = d, d = d.dispatch = Yc.bind(null, oa, d), [he.memoizedState, d];
  }, useRef: function(d) {
    var g = Eo();
    return d = { current: d }, g.memoizedState = d;
  }, useState: ko, useDebugValue: Lu, useDeferredValue: function(d) {
    return Eo().memoizedState = d;
  }, useTransition: function() {
    var d = ko(!1), g = d[0];
    return d = Ff.bind(null, d[1]), Eo().memoizedState = d, [g, d];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(d, g, $) {
    var he = oa, je = Eo();
    if (Sa) {
      if ($ === void 0) throw Error(qe(407));
      $ = $();
    } else {
      if ($ = g(), ui === null) throw Error(qe(349));
      Ds & 30 || Ah(he, g, $);
    }
    je.memoizedState = $;
    var ot = { value: $, getSnapshot: g };
    return je.queue = ot, pc(hc.bind(
      null,
      he,
      ot,
      d
    ), [d]), he.flags |= 2048, Xl(9, Mh.bind(null, he, ot, $, g), void 0, null), $;
  }, useId: function() {
    var d = Eo(), g = ui.identifierPrefix;
    if (Sa) {
      var $ = ws, he = Po;
      $ = (he & ~(1 << 32 - xn(he) - 1)).toString(32) + $, g = ":" + g + "R" + $, $ = Ga++, 0 < $ && (g += "H" + $.toString(32)), g += ":";
    } else $ = Th++, g = ":" + g + "r" + $.toString(32) + ":";
    return d.memoizedState = g;
  }, unstable_isNewReconciler: !1 }, Ea = {
    readContext: or,
    useCallback: cf,
    useContext: or,
    useEffect: ku,
    useImperativeHandle: Ph,
    useInsertionEffect: Ih,
    useLayoutEffect: Xc,
    useMemo: hf,
    useReducer: cc,
    useRef: Ru,
    useState: function() {
      return cc(Pu);
    },
    useDebugValue: Lu,
    useDeferredValue: function(d) {
      var g = rs();
      return ff(g, pa.memoizedState, d);
    },
    useTransition: function() {
      var d = cc(Pu)[0], g = rs().memoizedState;
      return [d, g];
    },
    useMutableSource: Ch,
    useSyncExternalStore: Ya,
    useId: df,
    unstable_isNewReconciler: !1
  }, kh = { readContext: or, useCallback: cf, useContext: or, useEffect: ku, useImperativeHandle: Ph, useInsertionEffect: Ih, useLayoutEffect: Xc, useMemo: hf, useReducer: Zc, useRef: Ru, useState: function() {
    return Zc(Pu);
  }, useDebugValue: Lu, useDeferredValue: function(d) {
    var g = rs();
    return pa === null ? g.memoizedState = d : ff(g, pa.memoizedState, d);
  }, useTransition: function() {
    var d = Zc(Pu)[0], g = rs().memoizedState;
    return [d, g];
  }, useMutableSource: Ch, useSyncExternalStore: Ya, useId: df, unstable_isNewReconciler: !1 };
  function Lo(d, g) {
    if (d && d.defaultProps) {
      g = it({}, g), d = d.defaultProps;
      for (var $ in d) g[$] === void 0 && (g[$] = d[$]);
      return g;
    }
    return g;
  }
  function Jc(d, g, $, he) {
    g = d.memoizedState, $ = $(he, g), $ = $ == null ? g : it({}, g, $), d.memoizedState = $, d.lanes === 0 && (d.updateQueue.baseState = $);
  }
  var Yl = { isMounted: function(d) {
    return (d = d._reactInternals) ? It(d) === d : !1;
  }, enqueueSetState: function(d, g, $) {
    d = d._reactInternals;
    var he = fn(), je = Nr(d), ot = Jo(he, je);
    ot.payload = g, $ != null && (ot.callback = $), g = xl(d, ot, je), g !== null && (Jr(g, d, je, he), bl(g, d, je));
  }, enqueueReplaceState: function(d, g, $) {
    d = d._reactInternals;
    var he = fn(), je = Nr(d), ot = Jo(he, je);
    ot.tag = 1, ot.payload = g, $ != null && (ot.callback = $), g = xl(d, ot, je), g !== null && (Jr(g, d, je, he), bl(g, d, je));
  }, enqueueForceUpdate: function(d, g) {
    d = d._reactInternals;
    var $ = fn(), he = Nr(d), je = Jo($, he);
    je.tag = 2, g != null && (je.callback = g), g = xl(d, je, he), g !== null && (Jr(g, d, he, $), bl(g, d, he));
  } };
  function mf(d, g, $, he, je, ot, Vt) {
    return d = d.stateNode, typeof d.shouldComponentUpdate == "function" ? d.shouldComponentUpdate(he, ot, Vt) : g.prototype && g.prototype.isPureReactComponent ? !vi($, he) || !vi(je, ot) : !0;
  }
  function _c(d, g, $) {
    var he = !1, je = bo, ot = g.contextType;
    return typeof ot == "object" && ot !== null ? ot = or(ot) : (je = qs(g) ? vl : hs.current, he = g.contextTypes, ot = (he = he != null) ? Io(d, je) : bo), g = new g($, ot), d.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null, g.updater = Yl, d.stateNode = g, g._reactInternals = d, he && (d = d.stateNode, d.__reactInternalMemoizedUnmaskedChildContext = je, d.__reactInternalMemoizedMaskedChildContext = ot), g;
  }
  function Qc(d, g, $, he) {
    d = g.state, typeof g.componentWillReceiveProps == "function" && g.componentWillReceiveProps($, he), typeof g.UNSAFE_componentWillReceiveProps == "function" && g.UNSAFE_componentWillReceiveProps($, he), g.state !== d && Yl.enqueueReplaceState(g, g.state, null);
  }
  function To(d, g, $, he) {
    var je = d.stateNode;
    je.props = $, je.state = d.memoizedState, je.refs = {}, Hc(d);
    var ot = g.contextType;
    typeof ot == "object" && ot !== null ? je.context = or(ot) : (ot = qs(g) ? vl : hs.current, je.context = Io(d, ot)), je.state = d.memoizedState, ot = g.getDerivedStateFromProps, typeof ot == "function" && (Jc(d, g, ot, $), je.state = d.memoizedState), typeof g.getDerivedStateFromProps == "function" || typeof je.getSnapshotBeforeUpdate == "function" || typeof je.UNSAFE_componentWillMount != "function" && typeof je.componentWillMount != "function" || (g = je.state, typeof je.componentWillMount == "function" && je.componentWillMount(), typeof je.UNSAFE_componentWillMount == "function" && je.UNSAFE_componentWillMount(), g !== je.state && Yl.enqueueReplaceState(je, je.state, null), bh(d, $, je, he), je.state = d.memoizedState), typeof je.componentDidMount == "function" && (d.flags |= 4194308);
  }
  function el(d, g) {
    try {
      var $ = "", he = g;
      do
        $ += dt(he), he = he.return;
      while (he);
      var je = $;
    } catch (ot) {
      je = `
Error generating stack: ` + ot.message + `
` + ot.stack;
    }
    return { value: d, source: g, stack: je, digest: null };
  }
  function ma(d, g, $) {
    return { value: d, source: null, stack: $ ?? null, digest: g ?? null };
  }
  function Xs(d, g) {
    try {
      console.error(g.value);
    } catch ($) {
      setTimeout(function() {
        throw $;
      });
    }
  }
  var gc = typeof WeakMap == "function" ? WeakMap : Map;
  function vc(d, g, $) {
    $ = Jo(-1, $), $.tag = 3, $.payload = { element: null };
    var he = g.value;
    return $.callback = function() {
      ir || (ir = !0, cr = he), Xs(d, g);
    }, $;
  }
  function _f(d, g, $) {
    $ = Jo(-1, $), $.tag = 3;
    var he = d.type.getDerivedStateFromError;
    if (typeof he == "function") {
      var je = g.value;
      $.payload = function() {
        return he(je);
      }, $.callback = function() {
        Xs(d, g);
      };
    }
    var ot = d.stateNode;
    return ot !== null && typeof ot.componentDidCatch == "function" && ($.callback = function() {
      Xs(d, g), typeof he != "function" && (fr === null ? fr = /* @__PURE__ */ new Set([this]) : fr.add(this));
      var Vt = g.stack;
      this.componentDidCatch(g.value, { componentStack: Vt !== null ? Vt : "" });
    }), $;
  }
  function gf(d, g, $) {
    var he = d.pingCache;
    if (he === null) {
      he = d.pingCache = new gc();
      var je = /* @__PURE__ */ new Set();
      he.set(g, je);
    } else je = he.get(g), je === void 0 && (je = /* @__PURE__ */ new Set(), he.set(g, je));
    je.has($) || (je.add($), d = Bu.bind(null, d, g, $), g.then(d, d));
  }
  function yc(d) {
    do {
      var g;
      if ((g = d.tag === 13) && (g = d.memoizedState, g = g !== null ? g.dehydrated !== null : !0), g) return d;
      d = d.return;
    } while (d !== null);
    return null;
  }
  function Lh(d, g, $, he, je) {
    return d.mode & 1 ? (d.flags |= 65536, d.lanes = je, d) : (d === g ? d.flags |= 65536 : (d.flags |= 128, $.flags |= 131072, $.flags &= -52805, $.tag === 1 && ($.alternate === null ? $.tag = 17 : (g = Jo(-1, 1), g.tag = 2, xl($, g, 1))), $.lanes |= 1), d);
  }
  var yd = U.ReactCurrentOwner, Es = !1;
  function gs(d, g, $, he) {
    g.child = d === null ? Gc(g, null, $, he) : Tn(g, d.child, $, he);
  }
  function Kl(d, g, $, he, je) {
    $ = $.render;
    var ot = g.ref;
    return Ji(g, je), he = Wc(d, g, $, he, ot, je), $ = wl(), d !== null && !Es ? (g.updateQueue = d.updateQueue, g.flags &= -2053, d.lanes &= ~je, Ks(d, g, je)) : (Sa && $ && Vc(g), g.flags |= 1, gs(d, g, he, je), g.child);
  }
  function Jl(d, g, $, he, je) {
    if (d === null) {
      var ot = $.type;
      return typeof ot == "function" && !xd(ot) && ot.defaultProps === void 0 && $.compare === null && $.defaultProps === void 0 ? (g.tag = 15, g.type = ot, tl(d, g, ot, he, je)) : (d = yf($.type, null, he, g, g.mode, je), d.ref = g.ref, d.return = g, g.child = d);
    }
    if (ot = d.child, !(d.lanes & je)) {
      var Vt = ot.memoizedProps;
      if ($ = $.compare, $ = $ !== null ? $ : vi, $(Vt, he) && d.ref === g.ref) return Ks(d, g, je);
    }
    return g.flags |= 1, d = Nu(ot, he), d.ref = g.ref, d.return = g, g.child = d;
  }
  function tl(d, g, $, he, je) {
    if (d !== null) {
      var ot = d.memoizedProps;
      if (vi(ot, he) && d.ref === g.ref) if (Es = !1, g.pendingProps = he = ot, (d.lanes & je) !== 0) d.flags & 131072 && (Es = !0);
      else return g.lanes = d.lanes, Ks(d, g, je);
    }
    return Tl(d, g, $, he, je);
  }
  function Co(d, g, $) {
    var he = g.pendingProps, je = he.children, ot = d !== null ? d.memoizedState : null;
    if (he.mode === "hidden") if (!(g.mode & 1)) g.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ra(Ri, Pi), Pi |= $;
    else {
      if (!($ & 1073741824)) return d = ot !== null ? ot.baseLanes | $ : $, g.lanes = g.childLanes = 1073741824, g.memoizedState = { baseLanes: d, cachePool: null, transitions: null }, g.updateQueue = null, ra(Ri, Pi), Pi |= d, null;
      g.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, he = ot !== null ? ot.baseLanes : $, ra(Ri, Pi), Pi |= he;
    }
    else ot !== null ? (he = ot.baseLanes | $, g.memoizedState = null) : he = $, ra(Ri, Pi), Pi |= he;
    return gs(d, g, je, $), g.child;
  }
  function El(d, g) {
    var $ = g.ref;
    (d === null && $ !== null || d !== null && d.ref !== $) && (g.flags |= 512, g.flags |= 2097152);
  }
  function Tl(d, g, $, he, je) {
    var ot = qs($) ? vl : hs.current;
    return ot = Io(g, ot), Ji(g, je), $ = Wc(d, g, $, he, ot, je), he = wl(), d !== null && !Es ? (g.updateQueue = d.updateQueue, g.flags &= -2053, d.lanes &= ~je, Ks(d, g, je)) : (Sa && he && Vc(g), g.flags |= 1, gs(d, g, $, je), g.child);
  }
  function Cl(d, g, $, he, je) {
    if (qs($)) {
      var ot = !0;
      vu(g);
    } else ot = !1;
    if (Ji(g, je), g.stateNode === null) Ts(d, g), _c(g, $, he), To(g, $, he, je), he = !0;
    else if (d === null) {
      var Vt = g.stateNode, bi = g.memoizedProps;
      Vt.props = bi;
      var Ii = Vt.context, $i = $.contextType;
      typeof $i == "object" && $i !== null ? $i = or($i) : ($i = qs($) ? vl : hs.current, $i = Io(g, $i));
      var gr = $.getDerivedStateFromProps, yr = typeof gr == "function" || typeof Vt.getSnapshotBeforeUpdate == "function";
      yr || typeof Vt.UNSAFE_componentWillReceiveProps != "function" && typeof Vt.componentWillReceiveProps != "function" || (bi !== he || Ii !== $i) && Qc(g, Vt, he, $i), Ro = !1;
      var vr = g.memoizedState;
      Vt.state = vr, bh(g, he, Vt, je), Ii = g.memoizedState, bi !== he || vr !== Ii || Hs.current || Ro ? (typeof gr == "function" && (Jc(g, $, gr, he), Ii = g.memoizedState), (bi = Ro || mf(g, $, bi, he, vr, Ii, $i)) ? (yr || typeof Vt.UNSAFE_componentWillMount != "function" && typeof Vt.componentWillMount != "function" || (typeof Vt.componentWillMount == "function" && Vt.componentWillMount(), typeof Vt.UNSAFE_componentWillMount == "function" && Vt.UNSAFE_componentWillMount()), typeof Vt.componentDidMount == "function" && (g.flags |= 4194308)) : (typeof Vt.componentDidMount == "function" && (g.flags |= 4194308), g.memoizedProps = he, g.memoizedState = Ii), Vt.props = he, Vt.state = Ii, Vt.context = $i, he = bi) : (typeof Vt.componentDidMount == "function" && (g.flags |= 4194308), he = !1);
    } else {
      Vt = g.stateNode, of(d, g), bi = g.memoizedProps, $i = g.type === g.elementType ? bi : Lo(g.type, bi), Vt.props = $i, yr = g.pendingProps, vr = Vt.context, Ii = $.contextType, typeof Ii == "object" && Ii !== null ? Ii = or(Ii) : (Ii = qs($) ? vl : hs.current, Ii = Io(g, Ii));
      var Vr = $.getDerivedStateFromProps;
      (gr = typeof Vr == "function" || typeof Vt.getSnapshotBeforeUpdate == "function") || typeof Vt.UNSAFE_componentWillReceiveProps != "function" && typeof Vt.componentWillReceiveProps != "function" || (bi !== yr || vr !== Ii) && Qc(g, Vt, he, Ii), Ro = !1, vr = g.memoizedState, Vt.state = vr, bh(g, he, Vt, je);
      var jr = g.memoizedState;
      bi !== yr || vr !== jr || Hs.current || Ro ? (typeof Vr == "function" && (Jc(g, $, Vr, he), jr = g.memoizedState), ($i = Ro || mf(g, $, $i, he, vr, jr, Ii) || !1) ? (gr || typeof Vt.UNSAFE_componentWillUpdate != "function" && typeof Vt.componentWillUpdate != "function" || (typeof Vt.componentWillUpdate == "function" && Vt.componentWillUpdate(he, jr, Ii), typeof Vt.UNSAFE_componentWillUpdate == "function" && Vt.UNSAFE_componentWillUpdate(he, jr, Ii)), typeof Vt.componentDidUpdate == "function" && (g.flags |= 4), typeof Vt.getSnapshotBeforeUpdate == "function" && (g.flags |= 1024)) : (typeof Vt.componentDidUpdate != "function" || bi === d.memoizedProps && vr === d.memoizedState || (g.flags |= 4), typeof Vt.getSnapshotBeforeUpdate != "function" || bi === d.memoizedProps && vr === d.memoizedState || (g.flags |= 1024), g.memoizedProps = he, g.memoizedState = jr), Vt.props = he, Vt.state = jr, Vt.context = Ii, he = $i) : (typeof Vt.componentDidUpdate != "function" || bi === d.memoizedProps && vr === d.memoizedState || (g.flags |= 4), typeof Vt.getSnapshotBeforeUpdate != "function" || bi === d.memoizedProps && vr === d.memoizedState || (g.flags |= 1024), he = !1);
    }
    return vf(d, g, $, he, ot, je);
  }
  function vf(d, g, $, he, je, ot) {
    El(d, g);
    var Vt = (g.flags & 128) !== 0;
    if (!he && !Vt) return je && yu(g, $, !1), Ks(d, g, ot);
    he = g.stateNode, yd.current = g;
    var bi = Vt && typeof $.getDerivedStateFromError != "function" ? null : he.render();
    return g.flags |= 1, d !== null && Vt ? (g.child = Tn(g, d.child, null, ot), g.child = Tn(g, null, bi, ot)) : gs(d, g, bi, ot), g.memoizedState = he.state, je && yu(g, $, !0), g.child;
  }
  function Nf(d) {
    var g = d.stateNode;
    g.pendingContext ? ef(d, g.pendingContext, g.pendingContext !== g.context) : g.context && ef(d, g.context, !1), uc(d, g.containerInfo);
  }
  function Uf(d, g, $, he, je) {
    return co(), jc(je), g.flags |= 256, gs(d, g, $, he), g.child;
  }
  var xc = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Oh(d) {
    return { baseLanes: d, cachePool: null, transitions: null };
  }
  function vs(d, g, $) {
    var he = g.pendingProps, je = bn.current, ot = !1, Vt = (g.flags & 128) !== 0, bi;
    if ((bi = Vt) || (bi = d !== null && d.memoizedState === null ? !1 : (je & 2) !== 0), bi ? (ot = !0, g.flags &= -129) : (d === null || d.memoizedState !== null) && (je |= 1), ra(bn, je & 1), d === null)
      return oc(g), d = g.memoizedState, d !== null && (d = d.dehydrated, d !== null) ? (g.mode & 1 ? d.data === "$!" ? g.lanes = 8 : g.lanes = 1073741824 : g.lanes = 1, null) : (Vt = he.children, d = he.fallback, ot ? (he = g.mode, ot = g.child, Vt = { mode: "hidden", children: Vt }, !(he & 1) && ot !== null ? (ot.childLanes = 0, ot.pendingProps = Vt) : ot = xf(Vt, he, 0, null), d = Ec(d, he, $, null), ot.return = g, d.return = g, ot.sibling = d, g.child = ot, g.child.memoizedState = Oh($), g.memoizedState = xc, d) : Ql(g, Vt));
    if (je = d.memoizedState, je !== null && (bi = je.dehydrated, bi !== null)) return Vf(d, g, Vt, he, bi, je, $);
    if (ot) {
      ot = he.fallback, Vt = g.mode, je = d.child, bi = je.sibling;
      var Ii = { mode: "hidden", children: he.children };
      return !(Vt & 1) && g.child !== je ? (he = g.child, he.childLanes = 0, he.pendingProps = Ii, g.deletions = null) : (he = Nu(je, Ii), he.subtreeFlags = je.subtreeFlags & 14680064), bi !== null ? ot = Nu(bi, ot) : (ot = Ec(ot, Vt, $, null), ot.flags |= 2), ot.return = g, he.return = g, he.sibling = ot, g.child = he, he = ot, ot = g.child, Vt = d.child.memoizedState, Vt = Vt === null ? Oh($) : { baseLanes: Vt.baseLanes | $, cachePool: null, transitions: Vt.transitions }, ot.memoizedState = Vt, ot.childLanes = d.childLanes & ~$, g.memoizedState = xc, he;
    }
    return ot = d.child, d = ot.sibling, he = Nu(ot, { mode: "visible", children: he.children }), !(g.mode & 1) && (he.lanes = $), he.return = g, he.sibling = null, d !== null && ($ = g.deletions, $ === null ? (g.deletions = [d], g.flags |= 16) : $.push(d)), g.child = he, g.memoizedState = null, he;
  }
  function Ql(d, g) {
    return g = xf({ mode: "visible", children: g }, d.mode, 0, null), g.return = d, d.child = g;
  }
  function eh(d, g, $, he) {
    return he !== null && jc(he), Tn(g, d.child, null, $), d = Ql(g, g.pendingProps.children), d.flags |= 2, g.memoizedState = null, d;
  }
  function Vf(d, g, $, he, je, ot, Vt) {
    if ($)
      return g.flags & 256 ? (g.flags &= -257, he = ma(Error(qe(422))), eh(d, g, Vt, he)) : g.memoizedState !== null ? (g.child = d.child, g.flags |= 128, null) : (ot = he.fallback, je = g.mode, he = xf({ mode: "visible", children: he.children }, je, 0, null), ot = Ec(ot, je, Vt, null), ot.flags |= 2, he.return = g, ot.return = g, he.sibling = ot, g.child = he, g.mode & 1 && Tn(g, d.child, null, Vt), g.child.memoizedState = Oh(Vt), g.memoizedState = xc, ot);
    if (!(g.mode & 1)) return eh(d, g, Vt, null);
    if (je.data === "$!") {
      if (he = je.nextSibling && je.nextSibling.dataset, he) var bi = he.dgst;
      return he = bi, ot = Error(qe(419)), he = ma(ot, he, void 0), eh(d, g, Vt, he);
    }
    if (bi = (Vt & d.childLanes) !== 0, Es || bi) {
      if (he = ui, he !== null) {
        switch (Vt & -Vt) {
          case 4:
            je = 2;
            break;
          case 16:
            je = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            je = 32;
            break;
          case 536870912:
            je = 268435456;
            break;
          default:
            je = 0;
        }
        je = je & (he.suspendedLanes | Vt) ? 0 : je, je !== 0 && je !== ot.retryLane && (ot.retryLane = je, Ko(d, je), Jr(he, d, je, -1));
      }
      return ln(), he = ma(Error(qe(421))), eh(d, g, Vt, he);
    }
    return je.data === "$?" ? (g.flags |= 128, g.child = d.child, g = Fu.bind(null, d), je._reactRetry = g, null) : (d = ot.treeContext, Ss = Fl(je.nextSibling), oo = g, Sa = !0, lo = null, d !== null && (ks[ur++] = Po, ks[ur++] = ws, ks[ur++] = yl, Po = d.id, ws = d.overflow, yl = g), g = Ql(g, he.children), g.flags |= 4096, g);
  }
  function Ou(d, g, $) {
    d.lanes |= g;
    var he = d.alternate;
    he !== null && (he.lanes |= g), Wl(d.return, g, $);
  }
  function bc(d, g, $, he, je) {
    var ot = d.memoizedState;
    ot === null ? d.memoizedState = { isBackwards: g, rendering: null, renderingStartTime: 0, last: he, tail: $, tailMode: je } : (ot.isBackwards = g, ot.rendering = null, ot.renderingStartTime = 0, ot.last = he, ot.tail = $, ot.tailMode = je);
  }
  function Ys(d, g, $) {
    var he = g.pendingProps, je = he.revealOrder, ot = he.tail;
    if (gs(d, g, he.children, $), he = bn.current, he & 2) he = he & 1 | 2, g.flags |= 128;
    else {
      if (d !== null && d.flags & 128) e: for (d = g.child; d !== null; ) {
        if (d.tag === 13) d.memoizedState !== null && Ou(d, $, g);
        else if (d.tag === 19) Ou(d, $, g);
        else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === g) break e;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === g) break e;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      he &= 1;
    }
    if (ra(bn, he), !(g.mode & 1)) g.memoizedState = null;
    else switch (je) {
      case "forwards":
        for ($ = g.child, je = null; $ !== null; ) d = $.alternate, d !== null && Sh(d) === null && (je = $), $ = $.sibling;
        $ = je, $ === null ? (je = g.child, g.child = null) : (je = $.sibling, $.sibling = null), bc(g, !1, je, $, ot);
        break;
      case "backwards":
        for ($ = null, je = g.child, g.child = null; je !== null; ) {
          if (d = je.alternate, d !== null && Sh(d) === null) {
            g.child = je;
            break;
          }
          d = je.sibling, je.sibling = $, $ = je, je = d;
        }
        bc(g, !0, $, null, ot);
        break;
      case "together":
        bc(g, !1, null, null, void 0);
        break;
      default:
        g.memoizedState = null;
    }
    return g.child;
  }
  function Ts(d, g) {
    !(g.mode & 1) && d !== null && (d.alternate = null, g.alternate = null, g.flags |= 2);
  }
  function Ks(d, g, $) {
    if (d !== null && (g.dependencies = d.dependencies), ji |= g.lanes, !($ & g.childLanes)) return null;
    if (d !== null && g.child !== d.child) throw Error(qe(153));
    if (g.child !== null) {
      for (d = g.child, $ = Nu(d, d.pendingProps), g.child = $, $.return = g; d.sibling !== null; ) d = d.sibling, $ = $.sibling = Nu(d, d.pendingProps), $.return = g;
      $.sibling = null;
    }
    return g.child;
  }
  function Du(d, g, $) {
    switch (g.tag) {
      case 3:
        Nf(g), co();
        break;
      case 5:
        Qo(g);
        break;
      case 1:
        qs(g.type) && vu(g);
        break;
      case 4:
        uc(g, g.stateNode.containerInfo);
        break;
      case 10:
        var he = g.type._context, je = g.memoizedProps.value;
        ra(jl, he._currentValue), he._currentValue = je;
        break;
      case 13:
        if (he = g.memoizedState, he !== null)
          return he.dehydrated !== null ? (ra(bn, bn.current & 1), g.flags |= 128, null) : $ & g.child.childLanes ? vs(d, g, $) : (ra(bn, bn.current & 1), d = Ks(d, g, $), d !== null ? d.sibling : null);
        ra(bn, bn.current & 1);
        break;
      case 19:
        if (he = ($ & g.childLanes) !== 0, d.flags & 128) {
          if (he) return Ys(d, g, $);
          g.flags |= 128;
        }
        if (je = g.memoizedState, je !== null && (je.rendering = null, je.tail = null, je.lastEffect = null), ra(bn, bn.current), he) break;
        return null;
      case 22:
      case 23:
        return g.lanes = 0, Co(d, g, $);
    }
    return Ks(d, g, $);
  }
  var eu, th, hn, Al;
  eu = function(d, g) {
    for (var $ = g.child; $ !== null; ) {
      if ($.tag === 5 || $.tag === 6) d.appendChild($.stateNode);
      else if ($.tag !== 4 && $.child !== null) {
        $.child.return = $, $ = $.child;
        continue;
      }
      if ($ === g) break;
      for (; $.sibling === null; ) {
        if ($.return === null || $.return === g) return;
        $ = $.return;
      }
      $.sibling.return = $.return, $ = $.sibling;
    }
  }, th = function() {
  }, hn = function(d, g, $, he) {
    var je = d.memoizedProps;
    if (je !== he) {
      d = g.stateNode, ho(_s.current);
      var ot = null;
      switch ($) {
        case "input":
          je = At(d, je), he = At(d, he), ot = [];
          break;
        case "select":
          je = it({}, je, { value: void 0 }), he = it({}, he, { value: void 0 }), ot = [];
          break;
        case "textarea":
          je = et(d, je), he = et(d, he), ot = [];
          break;
        default:
          typeof je.onClick != "function" && typeof he.onClick == "function" && (d.onclick = pu);
      }
      Qe($, he);
      var Vt;
      $ = null;
      for ($i in je) if (!he.hasOwnProperty($i) && je.hasOwnProperty($i) && je[$i] != null) if ($i === "style") {
        var bi = je[$i];
        for (Vt in bi) bi.hasOwnProperty(Vt) && ($ || ($ = {}), $[Vt] = "");
      } else $i !== "dangerouslySetInnerHTML" && $i !== "children" && $i !== "suppressContentEditableWarning" && $i !== "suppressHydrationWarning" && $i !== "autoFocus" && (de.hasOwnProperty($i) ? ot || (ot = []) : (ot = ot || []).push($i, null));
      for ($i in he) {
        var Ii = he[$i];
        if (bi = je != null ? je[$i] : void 0, he.hasOwnProperty($i) && Ii !== bi && (Ii != null || bi != null)) if ($i === "style") if (bi) {
          for (Vt in bi) !bi.hasOwnProperty(Vt) || Ii && Ii.hasOwnProperty(Vt) || ($ || ($ = {}), $[Vt] = "");
          for (Vt in Ii) Ii.hasOwnProperty(Vt) && bi[Vt] !== Ii[Vt] && ($ || ($ = {}), $[Vt] = Ii[Vt]);
        } else $ || (ot || (ot = []), ot.push(
          $i,
          $
        )), $ = Ii;
        else $i === "dangerouslySetInnerHTML" ? (Ii = Ii ? Ii.__html : void 0, bi = bi ? bi.__html : void 0, Ii != null && bi !== Ii && (ot = ot || []).push($i, Ii)) : $i === "children" ? typeof Ii != "string" && typeof Ii != "number" || (ot = ot || []).push($i, "" + Ii) : $i !== "suppressContentEditableWarning" && $i !== "suppressHydrationWarning" && (de.hasOwnProperty($i) ? (Ii != null && $i === "onScroll" && da("scroll", d), ot || bi === Ii || (ot = [])) : (ot = ot || []).push($i, Ii));
      }
      $ && (ot = ot || []).push("style", $);
      var $i = ot;
      (g.updateQueue = $i) && (g.flags |= 4);
    }
  }, Al = function(d, g, $, he) {
    $ !== he && (g.flags |= 4);
  };
  function ih(d, g) {
    if (!Sa) switch (d.tailMode) {
      case "hidden":
        g = d.tail;
        for (var $ = null; g !== null; ) g.alternate !== null && ($ = g), g = g.sibling;
        $ === null ? d.tail = null : $.sibling = null;
        break;
      case "collapsed":
        $ = d.tail;
        for (var he = null; $ !== null; ) $.alternate !== null && (he = $), $ = $.sibling;
        he === null ? g || d.tail === null ? d.tail = null : d.tail.sibling = null : he.sibling = null;
    }
  }
  function Cs(d) {
    var g = d.alternate !== null && d.alternate.child === d.child, $ = 0, he = 0;
    if (g) for (var je = d.child; je !== null; ) $ |= je.lanes | je.childLanes, he |= je.subtreeFlags & 14680064, he |= je.flags & 14680064, je.return = d, je = je.sibling;
    else for (je = d.child; je !== null; ) $ |= je.lanes | je.childLanes, he |= je.subtreeFlags, he |= je.flags, je.return = d, je = je.sibling;
    return d.subtreeFlags |= he, d.childLanes = $, g;
  }
  function Dh(d, g, $) {
    var he = g.pendingProps;
    switch (nf(g), g.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Cs(g), null;
      case 1:
        return qs(g.type) && gh(), Cs(g), null;
      case 3:
        return he = g.stateNode, Os(), wa(Hs), wa(hs), Ln(), he.pendingContext && (he.context = he.pendingContext, he.pendingContext = null), (d === null || d.child === null) && (uo(g) ? g.flags |= 4 : d === null || d.memoizedState.isDehydrated && !(g.flags & 256) || (g.flags |= 1024, lo !== null && (gn(lo), lo = null))), th(d, g), Cs(g), null;
      case 5:
        wh(g);
        var je = ho(Mu.current);
        if ($ = g.type, d !== null && g.stateNode != null) hn(d, g, $, he, je), d.ref !== g.ref && (g.flags |= 512, g.flags |= 2097152);
        else {
          if (!he) {
            if (g.stateNode === null) throw Error(qe(166));
            return Cs(g), null;
          }
          if (d = ho(_s.current), uo(g)) {
            he = g.stateNode, $ = g.type;
            var ot = g.memoizedProps;
            switch (he[vo] = g, he[_u] = ot, d = (g.mode & 1) !== 0, $) {
              case "dialog":
                da("cancel", he), da("close", he);
                break;
              case "iframe":
              case "object":
              case "embed":
                da("load", he);
                break;
              case "video":
              case "audio":
                for (je = 0; je < Oc.length; je++) da(Oc[je], he);
                break;
              case "source":
                da("error", he);
                break;
              case "img":
              case "image":
              case "link":
                da(
                  "error",
                  he
                ), da("load", he);
                break;
              case "details":
                da("toggle", he);
                break;
              case "input":
                St(he, ot), da("invalid", he);
                break;
              case "select":
                he._wrapperState = { wasMultiple: !!ot.multiple }, da("invalid", he);
                break;
              case "textarea":
                Ie(he, ot), da("invalid", he);
            }
            Qe($, ot), je = null;
            for (var Vt in ot) if (ot.hasOwnProperty(Vt)) {
              var bi = ot[Vt];
              Vt === "children" ? typeof bi == "string" ? he.textContent !== bi && (ot.suppressHydrationWarning !== !0 && rc(he.textContent, bi, d), je = ["children", bi]) : typeof bi == "number" && he.textContent !== "" + bi && (ot.suppressHydrationWarning !== !0 && rc(
                he.textContent,
                bi,
                d
              ), je = ["children", "" + bi]) : de.hasOwnProperty(Vt) && bi != null && Vt === "onScroll" && da("scroll", he);
            }
            switch ($) {
              case "input":
                ri(he), Ye(he, ot, !0);
                break;
              case "textarea":
                ri(he), xt(he);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof ot.onClick == "function" && (he.onclick = pu);
            }
            he = je, g.updateQueue = he, he !== null && (g.flags |= 4);
          } else {
            Vt = je.nodeType === 9 ? je : je.ownerDocument, d === "http://www.w3.org/1999/xhtml" && (d = l($)), d === "http://www.w3.org/1999/xhtml" ? $ === "script" ? (d = Vt.createElement("div"), d.innerHTML = "<script><\/script>", d = d.removeChild(d.firstChild)) : typeof he.is == "string" ? d = Vt.createElement($, { is: he.is }) : (d = Vt.createElement($), $ === "select" && (Vt = d, he.multiple ? Vt.multiple = !0 : he.size && (Vt.size = he.size))) : d = Vt.createElementNS(d, $), d[vo] = g, d[_u] = he, eu(d, g, !1, !1), g.stateNode = d;
            e: {
              switch (Vt = re($, he), $) {
                case "dialog":
                  da("cancel", d), da("close", d), je = he;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  da("load", d), je = he;
                  break;
                case "video":
                case "audio":
                  for (je = 0; je < Oc.length; je++) da(Oc[je], d);
                  je = he;
                  break;
                case "source":
                  da("error", d), je = he;
                  break;
                case "img":
                case "image":
                case "link":
                  da(
                    "error",
                    d
                  ), da("load", d), je = he;
                  break;
                case "details":
                  da("toggle", d), je = he;
                  break;
                case "input":
                  St(d, he), je = At(d, he), da("invalid", d);
                  break;
                case "option":
                  je = he;
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!he.multiple }, je = it({}, he, { value: void 0 }), da("invalid", d);
                  break;
                case "textarea":
                  Ie(d, he), je = et(d, he), da("invalid", d);
                  break;
                default:
                  je = he;
              }
              Qe($, je), bi = je;
              for (ot in bi) if (bi.hasOwnProperty(ot)) {
                var Ii = bi[ot];
                ot === "style" ? Me(d, Ii) : ot === "dangerouslySetInnerHTML" ? (Ii = Ii ? Ii.__html : void 0, Ii != null && X(d, Ii)) : ot === "children" ? typeof Ii == "string" ? ($ !== "textarea" || Ii !== "") && ne(d, Ii) : typeof Ii == "number" && ne(d, "" + Ii) : ot !== "suppressContentEditableWarning" && ot !== "suppressHydrationWarning" && ot !== "autoFocus" && (de.hasOwnProperty(ot) ? Ii != null && ot === "onScroll" && da("scroll", d) : Ii != null && S(d, ot, Ii, Vt));
              }
              switch ($) {
                case "input":
                  ri(d), Ye(d, he, !1);
                  break;
                case "textarea":
                  ri(d), xt(d);
                  break;
                case "option":
                  he.value != null && d.setAttribute("value", "" + Ht(he.value));
                  break;
                case "select":
                  d.multiple = !!he.multiple, ot = he.value, ot != null ? _t(d, !!he.multiple, ot, !1) : he.defaultValue != null && _t(
                    d,
                    !!he.multiple,
                    he.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof je.onClick == "function" && (d.onclick = pu);
              }
              switch ($) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  he = !!he.autoFocus;
                  break e;
                case "img":
                  he = !0;
                  break e;
                default:
                  he = !1;
              }
            }
            he && (g.flags |= 4);
          }
          g.ref !== null && (g.flags |= 512, g.flags |= 2097152);
        }
        return Cs(g), null;
      case 6:
        if (d && g.stateNode != null) Al(d, g, d.memoizedProps, he);
        else {
          if (typeof he != "string" && g.stateNode === null) throw Error(qe(166));
          if ($ = ho(Mu.current), ho(_s.current), uo(g)) {
            if (he = g.stateNode, $ = g.memoizedProps, he[vo] = g, (ot = he.nodeValue !== $) && (d = oo, d !== null)) switch (d.tag) {
              case 3:
                rc(he.nodeValue, $, (d.mode & 1) !== 0);
                break;
              case 5:
                d.memoizedProps.suppressHydrationWarning !== !0 && rc(he.nodeValue, $, (d.mode & 1) !== 0);
            }
            ot && (g.flags |= 4);
          } else he = ($.nodeType === 9 ? $ : $.ownerDocument).createTextNode(he), he[vo] = g, g.stateNode = he;
        }
        return Cs(g), null;
      case 13:
        if (wa(bn), he = g.memoizedState, d === null || d.memoizedState !== null && d.memoizedState.dehydrated !== null) {
          if (Sa && Ss !== null && g.mode & 1 && !(g.flags & 128)) Ls(), co(), g.flags |= 98560, ot = !1;
          else if (ot = uo(g), he !== null && he.dehydrated !== null) {
            if (d === null) {
              if (!ot) throw Error(qe(318));
              if (ot = g.memoizedState, ot = ot !== null ? ot.dehydrated : null, !ot) throw Error(qe(317));
              ot[vo] = g;
            } else co(), !(g.flags & 128) && (g.memoizedState = null), g.flags |= 4;
            Cs(g), ot = !1;
          } else lo !== null && (gn(lo), lo = null), ot = !0;
          if (!ot) return g.flags & 65536 ? g : null;
        }
        return g.flags & 128 ? (g.lanes = $, g) : (he = he !== null, he !== (d !== null && d.memoizedState !== null) && he && (g.child.flags |= 8192, g.mode & 1 && (d === null || bn.current & 1 ? mi === 0 && (mi = 3) : ln())), g.updateQueue !== null && (g.flags |= 4), Cs(g), null);
      case 4:
        return Os(), th(d, g), d === null && ic(g.stateNode.containerInfo), Cs(g), null;
      case 10:
        return ql(g.type._context), Cs(g), null;
      case 17:
        return qs(g.type) && gh(), Cs(g), null;
      case 19:
        if (wa(bn), ot = g.memoizedState, ot === null) return Cs(g), null;
        if (he = (g.flags & 128) !== 0, Vt = ot.rendering, Vt === null) if (he) ih(ot, !1);
        else {
          if (mi !== 0 || d !== null && d.flags & 128) for (d = g.child; d !== null; ) {
            if (Vt = Sh(d), Vt !== null) {
              for (g.flags |= 128, ih(ot, !1), he = Vt.updateQueue, he !== null && (g.updateQueue = he, g.flags |= 4), g.subtreeFlags = 0, he = $, $ = g.child; $ !== null; ) ot = $, d = he, ot.flags &= 14680066, Vt = ot.alternate, Vt === null ? (ot.childLanes = 0, ot.lanes = d, ot.child = null, ot.subtreeFlags = 0, ot.memoizedProps = null, ot.memoizedState = null, ot.updateQueue = null, ot.dependencies = null, ot.stateNode = null) : (ot.childLanes = Vt.childLanes, ot.lanes = Vt.lanes, ot.child = Vt.child, ot.subtreeFlags = 0, ot.deletions = null, ot.memoizedProps = Vt.memoizedProps, ot.memoizedState = Vt.memoizedState, ot.updateQueue = Vt.updateQueue, ot.type = Vt.type, d = Vt.dependencies, ot.dependencies = d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }), $ = $.sibling;
              return ra(bn, bn.current & 1 | 2), g.child;
            }
            d = d.sibling;
          }
          ot.tail !== null && Hi() > Fi && (g.flags |= 128, he = !0, ih(ot, !1), g.lanes = 4194304);
        }
        else {
          if (!he) if (d = Sh(Vt), d !== null) {
            if (g.flags |= 128, he = !0, $ = d.updateQueue, $ !== null && (g.updateQueue = $, g.flags |= 4), ih(ot, !0), ot.tail === null && ot.tailMode === "hidden" && !Vt.alternate && !Sa) return Cs(g), null;
          } else 2 * Hi() - ot.renderingStartTime > Fi && $ !== 1073741824 && (g.flags |= 128, he = !0, ih(ot, !1), g.lanes = 4194304);
          ot.isBackwards ? (Vt.sibling = g.child, g.child = Vt) : ($ = ot.last, $ !== null ? $.sibling = Vt : g.child = Vt, ot.last = Vt);
        }
        return ot.tail !== null ? (g = ot.tail, ot.rendering = g, ot.tail = g.sibling, ot.renderingStartTime = Hi(), g.sibling = null, $ = bn.current, ra(bn, he ? $ & 1 | 2 : $ & 1), g) : (Cs(g), null);
      case 22:
      case 23:
        return as(), he = g.memoizedState !== null, d !== null && d.memoizedState !== null !== he && (g.flags |= 8192), he && g.mode & 1 ? Pi & 1073741824 && (Cs(g), g.subtreeFlags & 6 && (g.flags |= 8192)) : Cs(g), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(qe(156, g.tag));
  }
  function il(d, g) {
    switch (nf(g), g.tag) {
      case 1:
        return qs(g.type) && gh(), d = g.flags, d & 65536 ? (g.flags = d & -65537 | 128, g) : null;
      case 3:
        return Os(), wa(Hs), wa(hs), Ln(), d = g.flags, d & 65536 && !(d & 128) ? (g.flags = d & -65537 | 128, g) : null;
      case 5:
        return wh(g), null;
      case 13:
        if (wa(bn), d = g.memoizedState, d !== null && d.dehydrated !== null) {
          if (g.alternate === null) throw Error(qe(340));
          co();
        }
        return d = g.flags, d & 65536 ? (g.flags = d & -65537 | 128, g) : null;
      case 19:
        return wa(bn), null;
      case 4:
        return Os(), null;
      case 10:
        return ql(g.type._context), null;
      case 22:
      case 23:
        return as(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Js = !1, Zn = !1, Qs = typeof WeakSet == "function" ? WeakSet : Set, Pr = null;
  function zu(d, g) {
    var $ = d.ref;
    if ($ !== null) if (typeof $ == "function") try {
      $(null);
    } catch (he) {
      Bn(d, g, he);
    }
    else $.current = null;
  }
  function la(d, g, $) {
    try {
      $();
    } catch (he) {
      Bn(d, g, he);
    }
  }
  var zh = !1;
  function wc(d, g) {
    if (Fc = Hn, d = rn(), Hr(d)) {
      if ("selectionStart" in d) var $ = { start: d.selectionStart, end: d.selectionEnd };
      else e: {
        $ = ($ = d.ownerDocument) && $.defaultView || window;
        var he = $.getSelection && $.getSelection();
        if (he && he.rangeCount !== 0) {
          $ = he.anchorNode;
          var je = he.anchorOffset, ot = he.focusNode;
          he = he.focusOffset;
          try {
            $.nodeType, ot.nodeType;
          } catch {
            $ = null;
            break e;
          }
          var Vt = 0, bi = -1, Ii = -1, $i = 0, gr = 0, yr = d, vr = null;
          t: for (; ; ) {
            for (var Vr; yr !== $ || je !== 0 && yr.nodeType !== 3 || (bi = Vt + je), yr !== ot || he !== 0 && yr.nodeType !== 3 || (Ii = Vt + he), yr.nodeType === 3 && (Vt += yr.nodeValue.length), (Vr = yr.firstChild) !== null; )
              vr = yr, yr = Vr;
            for (; ; ) {
              if (yr === d) break t;
              if (vr === $ && ++$i === je && (bi = Vt), vr === ot && ++gr === he && (Ii = Vt), (Vr = yr.nextSibling) !== null) break;
              yr = vr, vr = yr.parentNode;
            }
            yr = Vr;
          }
          $ = bi === -1 || Ii === -1 ? null : { start: bi, end: Ii };
        } else $ = null;
      }
      $ = $ || { start: 0, end: 0 };
    } else $ = null;
    for (Nc = { focusedElem: d, selectionRange: $ }, Hn = !1, Pr = g; Pr !== null; ) if (g = Pr, d = g.child, (g.subtreeFlags & 1028) !== 0 && d !== null) d.return = g, Pr = d;
    else for (; Pr !== null; ) {
      g = Pr;
      try {
        var jr = g.alternate;
        if (g.flags & 1024) switch (g.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (jr !== null) {
              var qr = jr.memoizedProps, qa = jr.memoizedState, Vi = g.stateNode, Li = Vi.getSnapshotBeforeUpdate(g.elementType === g.type ? qr : Lo(g.type, qr), qa);
              Vi.__reactInternalSnapshotBeforeUpdate = Li;
            }
            break;
          case 3:
            var Wi = g.stateNode.containerInfo;
            Wi.nodeType === 1 ? Wi.textContent = "" : Wi.nodeType === 9 && Wi.documentElement && Wi.removeChild(Wi.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(qe(163));
        }
      } catch (Cr) {
        Bn(g, g.return, Cr);
      }
      if (d = g.sibling, d !== null) {
        d.return = g.return, Pr = d;
        break;
      }
      Pr = g.return;
    }
    return jr = zh, zh = !1, jr;
  }
  function u(d, g, $) {
    var he = g.updateQueue;
    if (he = he !== null ? he.lastEffect : null, he !== null) {
      var je = he = he.next;
      do {
        if ((je.tag & d) === d) {
          var ot = je.destroy;
          je.destroy = void 0, ot !== void 0 && la(g, $, ot);
        }
        je = je.next;
      } while (je !== he);
    }
  }
  function t(d, g) {
    if (g = g.updateQueue, g = g !== null ? g.lastEffect : null, g !== null) {
      var $ = g = g.next;
      do {
        if (($.tag & d) === d) {
          var he = $.create;
          $.destroy = he();
        }
        $ = $.next;
      } while ($ !== g);
    }
  }
  function n(d) {
    var g = d.ref;
    if (g !== null) {
      var $ = d.stateNode;
      switch (d.tag) {
        case 5:
          d = $;
          break;
        default:
          d = $;
      }
      typeof g == "function" ? g(d) : g.current = d;
    }
  }
  function c(d) {
    var g = d.alternate;
    g !== null && (d.alternate = null, c(g)), d.child = null, d.deletions = null, d.sibling = null, d.tag === 5 && (g = d.stateNode, g !== null && (delete g[vo], delete g[_u], delete g[Nl], delete g[Qh], delete g[zf])), d.stateNode = null, d.return = null, d.dependencies = null, d.memoizedProps = null, d.memoizedState = null, d.pendingProps = null, d.stateNode = null, d.updateQueue = null;
  }
  function p(d) {
    return d.tag === 5 || d.tag === 3 || d.tag === 4;
  }
  function v(d) {
    e: for (; ; ) {
      for (; d.sibling === null; ) {
        if (d.return === null || p(d.return)) return null;
        d = d.return;
      }
      for (d.sibling.return = d.return, d = d.sibling; d.tag !== 5 && d.tag !== 6 && d.tag !== 18; ) {
        if (d.flags & 2 || d.child === null || d.tag === 4) continue e;
        d.child.return = d, d = d.child;
      }
      if (!(d.flags & 2)) return d.stateNode;
    }
  }
  function C(d, g, $) {
    var he = d.tag;
    if (he === 5 || he === 6) d = d.stateNode, g ? $.nodeType === 8 ? $.parentNode.insertBefore(d, g) : $.insertBefore(d, g) : ($.nodeType === 8 ? (g = $.parentNode, g.insertBefore(d, $)) : (g = $, g.appendChild(d)), $ = $._reactRootContainer, $ != null || g.onclick !== null || (g.onclick = pu));
    else if (he !== 4 && (d = d.child, d !== null)) for (C(d, g, $), d = d.sibling; d !== null; ) C(d, g, $), d = d.sibling;
  }
  function V(d, g, $) {
    var he = d.tag;
    if (he === 5 || he === 6) d = d.stateNode, g ? $.insertBefore(d, g) : $.appendChild(d);
    else if (he !== 4 && (d = d.child, d !== null)) for (V(d, g, $), d = d.sibling; d !== null; ) V(d, g, $), d = d.sibling;
  }
  var K = null, se = !1;
  function oe(d, g, $) {
    for ($ = $.child; $ !== null; ) ve(d, g, $), $ = $.sibling;
  }
  function ve(d, g, $) {
    if (Mr && typeof Mr.onCommitFiberUnmount == "function") try {
      Mr.onCommitFiberUnmount(Ir, $);
    } catch {
    }
    switch ($.tag) {
      case 5:
        Zn || zu($, g);
      case 6:
        var he = K, je = se;
        K = null, oe(d, g, $), K = he, se = je, K !== null && (se ? (d = K, $ = $.stateNode, d.nodeType === 8 ? d.parentNode.removeChild($) : d.removeChild($)) : K.removeChild($.stateNode));
        break;
      case 18:
        K !== null && (se ? (d = K, $ = $.stateNode, d.nodeType === 8 ? Jh(d.parentNode, $) : d.nodeType === 1 && Jh(d, $), Ia(d)) : Jh(K, $.stateNode));
        break;
      case 4:
        he = K, je = se, K = $.stateNode.containerInfo, se = !0, oe(d, g, $), K = he, se = je;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Zn && (he = $.updateQueue, he !== null && (he = he.lastEffect, he !== null))) {
          je = he = he.next;
          do {
            var ot = je, Vt = ot.destroy;
            ot = ot.tag, Vt !== void 0 && (ot & 2 || ot & 4) && la($, g, Vt), je = je.next;
          } while (je !== he);
        }
        oe(d, g, $);
        break;
      case 1:
        if (!Zn && (zu($, g), he = $.stateNode, typeof he.componentWillUnmount == "function")) try {
          he.props = $.memoizedProps, he.state = $.memoizedState, he.componentWillUnmount();
        } catch (bi) {
          Bn($, g, bi);
        }
        oe(d, g, $);
        break;
      case 21:
        oe(d, g, $);
        break;
      case 22:
        $.mode & 1 ? (Zn = (he = Zn) || $.memoizedState !== null, oe(d, g, $), Zn = he) : oe(d, g, $);
        break;
      default:
        oe(d, g, $);
    }
  }
  function xe(d) {
    var g = d.updateQueue;
    if (g !== null) {
      d.updateQueue = null;
      var $ = d.stateNode;
      $ === null && ($ = d.stateNode = new Qs()), g.forEach(function(he) {
        var je = Sc.bind(null, d, he);
        $.has(he) || ($.add(he), he.then(je, je));
      });
    }
  }
  function Le(d, g) {
    var $ = g.deletions;
    if ($ !== null) for (var he = 0; he < $.length; he++) {
      var je = $[he];
      try {
        var ot = d, Vt = g, bi = Vt;
        e: for (; bi !== null; ) {
          switch (bi.tag) {
            case 5:
              K = bi.stateNode, se = !1;
              break e;
            case 3:
              K = bi.stateNode.containerInfo, se = !0;
              break e;
            case 4:
              K = bi.stateNode.containerInfo, se = !0;
              break e;
          }
          bi = bi.return;
        }
        if (K === null) throw Error(qe(160));
        ve(ot, Vt, je), K = null, se = !1;
        var Ii = je.alternate;
        Ii !== null && (Ii.return = null), je.return = null;
      } catch ($i) {
        Bn(je, g, $i);
      }
    }
    if (g.subtreeFlags & 12854) for (g = g.child; g !== null; ) ft(g, d), g = g.sibling;
  }
  function ft(d, g) {
    var $ = d.alternate, he = d.flags;
    switch (d.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Le(g, d), st(d), he & 4) {
          try {
            u(3, d, d.return), t(3, d);
          } catch (qr) {
            Bn(d, d.return, qr);
          }
          try {
            u(5, d, d.return);
          } catch (qr) {
            Bn(d, d.return, qr);
          }
        }
        break;
      case 1:
        Le(g, d), st(d), he & 512 && $ !== null && zu($, $.return);
        break;
      case 5:
        if (Le(g, d), st(d), he & 512 && $ !== null && zu($, $.return), d.flags & 32) {
          var je = d.stateNode;
          try {
            ne(je, "");
          } catch (qr) {
            Bn(d, d.return, qr);
          }
        }
        if (he & 4 && (je = d.stateNode, je != null)) {
          var ot = d.memoizedProps, Vt = $ !== null ? $.memoizedProps : ot, bi = d.type, Ii = d.updateQueue;
          if (d.updateQueue = null, Ii !== null) try {
            bi === "input" && ot.type === "radio" && ot.name != null && Lt(je, ot), re(bi, Vt);
            var $i = re(bi, ot);
            for (Vt = 0; Vt < Ii.length; Vt += 2) {
              var gr = Ii[Vt], yr = Ii[Vt + 1];
              gr === "style" ? Me(je, yr) : gr === "dangerouslySetInnerHTML" ? X(je, yr) : gr === "children" ? ne(je, yr) : S(je, gr, yr, $i);
            }
            switch (bi) {
              case "input":
                kt(je, ot);
                break;
              case "textarea":
                pe(je, ot);
                break;
              case "select":
                var vr = je._wrapperState.wasMultiple;
                je._wrapperState.wasMultiple = !!ot.multiple;
                var Vr = ot.value;
                Vr != null ? _t(je, !!ot.multiple, Vr, !1) : vr !== !!ot.multiple && (ot.defaultValue != null ? _t(
                  je,
                  !!ot.multiple,
                  ot.defaultValue,
                  !0
                ) : _t(je, !!ot.multiple, ot.multiple ? [] : "", !1));
            }
            je[_u] = ot;
          } catch (qr) {
            Bn(d, d.return, qr);
          }
        }
        break;
      case 6:
        if (Le(g, d), st(d), he & 4) {
          if (d.stateNode === null) throw Error(qe(162));
          je = d.stateNode, ot = d.memoizedProps;
          try {
            je.nodeValue = ot;
          } catch (qr) {
            Bn(d, d.return, qr);
          }
        }
        break;
      case 3:
        if (Le(g, d), st(d), he & 4 && $ !== null && $.memoizedState.isDehydrated) try {
          Ia(g.containerInfo);
        } catch (qr) {
          Bn(d, d.return, qr);
        }
        break;
      case 4:
        Le(g, d), st(d);
        break;
      case 13:
        Le(g, d), st(d), je = d.child, je.flags & 8192 && (ot = je.memoizedState !== null, je.stateNode.isHidden = ot, !ot || je.alternate !== null && je.alternate.memoizedState !== null || (Ui = Hi())), he & 4 && xe(d);
        break;
      case 22:
        if (gr = $ !== null && $.memoizedState !== null, d.mode & 1 ? (Zn = ($i = Zn) || gr, Le(g, d), Zn = $i) : Le(g, d), st(d), he & 8192) {
          if ($i = d.memoizedState !== null, (d.stateNode.isHidden = $i) && !gr && d.mode & 1) for (Pr = d, gr = d.child; gr !== null; ) {
            for (yr = Pr = gr; Pr !== null; ) {
              switch (vr = Pr, Vr = vr.child, vr.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  u(4, vr, vr.return);
                  break;
                case 1:
                  zu(vr, vr.return);
                  var jr = vr.stateNode;
                  if (typeof jr.componentWillUnmount == "function") {
                    he = vr, $ = vr.return;
                    try {
                      g = he, jr.props = g.memoizedProps, jr.state = g.memoizedState, jr.componentWillUnmount();
                    } catch (qr) {
                      Bn(he, $, qr);
                    }
                  }
                  break;
                case 5:
                  zu(vr, vr.return);
                  break;
                case 22:
                  if (vr.memoizedState !== null) {
                    qt(yr);
                    continue;
                  }
              }
              Vr !== null ? (Vr.return = vr, Pr = Vr) : qt(yr);
            }
            gr = gr.sibling;
          }
          e: for (gr = null, yr = d; ; ) {
            if (yr.tag === 5) {
              if (gr === null) {
                gr = yr;
                try {
                  je = yr.stateNode, $i ? (ot = je.style, typeof ot.setProperty == "function" ? ot.setProperty("display", "none", "important") : ot.display = "none") : (bi = yr.stateNode, Ii = yr.memoizedProps.style, Vt = Ii != null && Ii.hasOwnProperty("display") ? Ii.display : null, bi.style.display = ye("display", Vt));
                } catch (qr) {
                  Bn(d, d.return, qr);
                }
              }
            } else if (yr.tag === 6) {
              if (gr === null) try {
                yr.stateNode.nodeValue = $i ? "" : yr.memoizedProps;
              } catch (qr) {
                Bn(d, d.return, qr);
              }
            } else if ((yr.tag !== 22 && yr.tag !== 23 || yr.memoizedState === null || yr === d) && yr.child !== null) {
              yr.child.return = yr, yr = yr.child;
              continue;
            }
            if (yr === d) break e;
            for (; yr.sibling === null; ) {
              if (yr.return === null || yr.return === d) break e;
              gr === yr && (gr = null), yr = yr.return;
            }
            gr === yr && (gr = null), yr.sibling.return = yr.return, yr = yr.sibling;
          }
        }
        break;
      case 19:
        Le(g, d), st(d), he & 4 && xe(d);
        break;
      case 21:
        break;
      default:
        Le(
          g,
          d
        ), st(d);
    }
  }
  function st(d) {
    var g = d.flags;
    if (g & 2) {
      try {
        e: {
          for (var $ = d.return; $ !== null; ) {
            if (p($)) {
              var he = $;
              break e;
            }
            $ = $.return;
          }
          throw Error(qe(160));
        }
        switch (he.tag) {
          case 5:
            var je = he.stateNode;
            he.flags & 32 && (ne(je, ""), he.flags &= -33);
            var ot = v(d);
            V(d, ot, je);
            break;
          case 3:
          case 4:
            var Vt = he.stateNode.containerInfo, bi = v(d);
            C(d, bi, Vt);
            break;
          default:
            throw Error(qe(161));
        }
      } catch (Ii) {
        Bn(d, d.return, Ii);
      }
      d.flags &= -3;
    }
    g & 4096 && (d.flags &= -4097);
  }
  function vt(d, g, $) {
    Pr = d, gt(d);
  }
  function gt(d, g, $) {
    for (var he = (d.mode & 1) !== 0; Pr !== null; ) {
      var je = Pr, ot = je.child;
      if (je.tag === 22 && he) {
        var Vt = je.memoizedState !== null || Js;
        if (!Vt) {
          var bi = je.alternate, Ii = bi !== null && bi.memoizedState !== null || Zn;
          bi = Js;
          var $i = Zn;
          if (Js = Vt, (Zn = Ii) && !$i) for (Pr = je; Pr !== null; ) Vt = Pr, Ii = Vt.child, Vt.tag === 22 && Vt.memoizedState !== null ? jt(je) : Ii !== null ? (Ii.return = Vt, Pr = Ii) : jt(je);
          for (; ot !== null; ) Pr = ot, gt(ot), ot = ot.sibling;
          Pr = je, Js = bi, Zn = $i;
        }
        Rt(d);
      } else je.subtreeFlags & 8772 && ot !== null ? (ot.return = je, Pr = ot) : Rt(d);
    }
  }
  function Rt(d) {
    for (; Pr !== null; ) {
      var g = Pr;
      if (g.flags & 8772) {
        var $ = g.alternate;
        try {
          if (g.flags & 8772) switch (g.tag) {
            case 0:
            case 11:
            case 15:
              Zn || t(5, g);
              break;
            case 1:
              var he = g.stateNode;
              if (g.flags & 4 && !Zn) if ($ === null) he.componentDidMount();
              else {
                var je = g.elementType === g.type ? $.memoizedProps : Lo(g.type, $.memoizedProps);
                he.componentDidUpdate(je, $.memoizedState, he.__reactInternalSnapshotBeforeUpdate);
              }
              var ot = g.updateQueue;
              ot !== null && lf(g, ot, he);
              break;
            case 3:
              var Vt = g.updateQueue;
              if (Vt !== null) {
                if ($ = null, g.child !== null) switch (g.child.tag) {
                  case 5:
                    $ = g.child.stateNode;
                    break;
                  case 1:
                    $ = g.child.stateNode;
                }
                lf(g, Vt, $);
              }
              break;
            case 5:
              var bi = g.stateNode;
              if ($ === null && g.flags & 4) {
                $ = bi;
                var Ii = g.memoizedProps;
                switch (g.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    Ii.autoFocus && $.focus();
                    break;
                  case "img":
                    Ii.src && ($.src = Ii.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (g.memoizedState === null) {
                var $i = g.alternate;
                if ($i !== null) {
                  var gr = $i.memoizedState;
                  if (gr !== null) {
                    var yr = gr.dehydrated;
                    yr !== null && Ia(yr);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(qe(163));
          }
          Zn || g.flags & 512 && n(g);
        } catch (vr) {
          Bn(g, g.return, vr);
        }
      }
      if (g === d) {
        Pr = null;
        break;
      }
      if ($ = g.sibling, $ !== null) {
        $.return = g.return, Pr = $;
        break;
      }
      Pr = g.return;
    }
  }
  function qt(d) {
    for (; Pr !== null; ) {
      var g = Pr;
      if (g === d) {
        Pr = null;
        break;
      }
      var $ = g.sibling;
      if ($ !== null) {
        $.return = g.return, Pr = $;
        break;
      }
      Pr = g.return;
    }
  }
  function jt(d) {
    for (; Pr !== null; ) {
      var g = Pr;
      try {
        switch (g.tag) {
          case 0:
          case 11:
          case 15:
            var $ = g.return;
            try {
              t(4, g);
            } catch (Ii) {
              Bn(g, $, Ii);
            }
            break;
          case 1:
            var he = g.stateNode;
            if (typeof he.componentDidMount == "function") {
              var je = g.return;
              try {
                he.componentDidMount();
              } catch (Ii) {
                Bn(g, je, Ii);
              }
            }
            var ot = g.return;
            try {
              n(g);
            } catch (Ii) {
              Bn(g, ot, Ii);
            }
            break;
          case 5:
            var Vt = g.return;
            try {
              n(g);
            } catch (Ii) {
              Bn(g, Vt, Ii);
            }
        }
      } catch (Ii) {
        Bn(g, g.return, Ii);
      }
      if (g === d) {
        Pr = null;
        break;
      }
      var bi = g.sibling;
      if (bi !== null) {
        bi.return = g.return, Pr = bi;
        break;
      }
      Pr = g.return;
    }
  }
  var ii = Math.ceil, Xt = U.ReactCurrentDispatcher, Kt = U.ReactCurrentOwner, Zt = U.ReactCurrentBatchConfig, Jt = 0, ui = null, Ti = null, xi = 0, Pi = 0, Ri = xo(0), mi = 0, Ai = null, ji = 0, yi = 0, Ni = 0, Mi = null, Yi = null, Ui = 0, Fi = 1 / 0, Zi = null, ir = !1, cr = null, fr = null, Or = !1, Er = null, Ar = 0, Fr = 0, an = null, yn = -1, $n = 0;
  function fn() {
    return Jt & 6 ? Hi() : yn !== -1 ? yn : yn = Hi();
  }
  function Nr(d) {
    return d.mode & 1 ? Jt & 2 && xi !== 0 ? xi & -xi : sf.transition !== null ? ($n === 0 && ($n = za()), $n) : (d = mn, d !== 0 || (d = window.event, d = d === void 0 ? 16 : No(d.type)), d) : 1;
  }
  function Jr(d, g, $, he) {
    if (50 < Fr) throw Fr = 0, an = null, Error(qe(185));
    os(d, $, he), (!(Jt & 2) || d !== ui) && (d === ui && (!(Jt & 2) && (yi |= $), mi === 4 && ua(d, xi)), mr(d, he), $ === 1 && Jt === 0 && !(g.mode & 1) && (Fi = Hi() + 500, xu && wo()));
  }
  function mr(d, g) {
    var $ = d.callbackNode;
    Bo(d, g);
    var he = Ta(d, d === ui ? xi : 0);
    if (he === 0) $ !== null && _i($), d.callbackNode = null, d.callbackPriority = 0;
    else if (g = he & -he, d.callbackPriority !== g) {
      if ($ != null && _i($), g === 1) d.tag === 0 ? Uc(Ra.bind(null, d)) : rf(Ra.bind(null, d)), _d(function() {
        !(Jt & 6) && wo();
      }), $ = null;
      else {
        switch (eo(he)) {
          case 1:
            $ = rr;
            break;
          case 4:
            $ = dr;
            break;
          case 16:
            $ = Rr;
            break;
          case 536870912:
            $ = Ki;
            break;
          default:
            $ = Rr;
        }
        $ = Bh($, nn.bind(null, d));
      }
      d.callbackPriority = g, d.callbackNode = $;
    }
  }
  function nn(d, g) {
    if (yn = -1, $n = 0, Jt & 6) throw Error(qe(327));
    var $ = d.callbackNode;
    if (Fs() && d.callbackNode !== $) return null;
    var he = Ta(d, d === ui ? xi : 0);
    if (he === 0) return null;
    if (he & 30 || he & d.expiredLanes || g) g = ca(d, he);
    else {
      g = he;
      var je = Jt;
      Jt |= 2;
      var ot = Cn();
      (ui !== d || xi !== g) && (Zi = null, Fi = Hi() + 500, On(d, g));
      do
        try {
          kn();
          break;
        } catch (bi) {
          Rn(d, bi);
        }
      while (!0);
      Hl(), Xt.current = ot, Jt = je, Ti !== null ? g = 0 : (ui = null, xi = 0, g = mi);
    }
    if (g !== 0) {
      if (g === 2 && (je = Ao(d), je !== 0 && (he = je, g = pn(d, je))), g === 1) throw $ = Ai, On(d, 0), ua(d, he), mr(d, Hi()), $;
      if (g === 6) ua(d, he);
      else {
        if (je = d.current.alternate, !(he & 30) && !na(je) && (g = ca(d, he), g === 2 && (ot = Ao(d), ot !== 0 && (he = ot, g = pn(d, ot))), g === 1)) throw $ = Ai, On(d, 0), ua(d, he), mr(d, Hi()), $;
        switch (d.finishedWork = je, d.finishedLanes = he, g) {
          case 0:
          case 1:
            throw Error(qe(345));
          case 2:
            Ka(d, Yi, Zi);
            break;
          case 3:
            if (ua(d, he), (he & 130023424) === he && (g = Ui + 500 - Hi(), 10 < g)) {
              if (Ta(d, 0) !== 0) break;
              if (je = d.suspendedLanes, (je & he) !== he) {
                fn(), d.pingedLanes |= d.suspendedLanes & je;
                break;
              }
              d.timeoutHandle = _h(Ka.bind(null, d, Yi, Zi), g);
              break;
            }
            Ka(d, Yi, Zi);
            break;
          case 4:
            if (ua(d, he), (he & 4194240) === he) break;
            for (g = d.eventTimes, je = -1; 0 < he; ) {
              var Vt = 31 - xn(he);
              ot = 1 << Vt, Vt = g[Vt], Vt > je && (je = Vt), he &= ~ot;
            }
            if (he = je, he = Hi() - he, he = (120 > he ? 120 : 480 > he ? 480 : 1080 > he ? 1080 : 1920 > he ? 1920 : 3e3 > he ? 3e3 : 4320 > he ? 4320 : 1960 * ii(he / 1960)) - he, 10 < he) {
              d.timeoutHandle = _h(Ka.bind(null, d, Yi, Zi), he);
              break;
            }
            Ka(d, Yi, Zi);
            break;
          case 5:
            Ka(d, Yi, Zi);
            break;
          default:
            throw Error(qe(329));
        }
      }
    }
    return mr(d, Hi()), d.callbackNode === $ ? nn.bind(null, d) : null;
  }
  function pn(d, g) {
    var $ = Mi;
    return d.current.memoizedState.isDehydrated && (On(d, g).flags |= 256), d = ca(d, g), d !== 2 && (g = Yi, Yi = $, g !== null && gn(g)), d;
  }
  function gn(d) {
    Yi === null ? Yi = d : Yi.push.apply(Yi, d);
  }
  function na(d) {
    for (var g = d; ; ) {
      if (g.flags & 16384) {
        var $ = g.updateQueue;
        if ($ !== null && ($ = $.stores, $ !== null)) for (var he = 0; he < $.length; he++) {
          var je = $[he], ot = je.getSnapshot;
          je = je.value;
          try {
            if (!ba(ot(), je)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if ($ = g.child, g.subtreeFlags & 16384 && $ !== null) $.return = g, g = $;
      else {
        if (g === d) break;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === d) return !0;
          g = g.return;
        }
        g.sibling.return = g.return, g = g.sibling;
      }
    }
    return !0;
  }
  function ua(d, g) {
    for (g &= ~Ni, g &= ~yi, d.suspendedLanes |= g, d.pingedLanes &= ~g, d = d.expirationTimes; 0 < g; ) {
      var $ = 31 - xn(g), he = 1 << $;
      d[$] = -1, g &= ~he;
    }
  }
  function Ra(d) {
    if (Jt & 6) throw Error(qe(327));
    Fs();
    var g = Ta(d, 0);
    if (!(g & 1)) return mr(d, Hi()), null;
    var $ = ca(d, g);
    if (d.tag !== 0 && $ === 2) {
      var he = Ao(d);
      he !== 0 && (g = he, $ = pn(d, he));
    }
    if ($ === 1) throw $ = Ai, On(d, 0), ua(d, g), mr(d, Hi()), $;
    if ($ === 6) throw Error(qe(345));
    return d.finishedWork = d.current.alternate, d.finishedLanes = g, Ka(d, Yi, Zi), mr(d, Hi()), null;
  }
  function Aa(d, g) {
    var $ = Jt;
    Jt |= 1;
    try {
      return d(g);
    } finally {
      Jt = $, Jt === 0 && (Fi = Hi() + 500, xu && wo());
    }
  }
  function ns(d) {
    Er !== null && Er.tag === 0 && !(Jt & 6) && Fs();
    var g = Jt;
    Jt |= 1;
    var $ = Zt.transition, he = mn;
    try {
      if (Zt.transition = null, mn = 1, d) return d();
    } finally {
      mn = he, Zt.transition = $, Jt = g, !(Jt & 6) && wo();
    }
  }
  function as() {
    Pi = Ri.current, wa(Ri);
  }
  function On(d, g) {
    d.finishedWork = null, d.finishedLanes = 0;
    var $ = d.timeoutHandle;
    if ($ !== -1 && (d.timeoutHandle = -1, Of($)), Ti !== null) for ($ = Ti.return; $ !== null; ) {
      var he = $;
      switch (nf(he), he.tag) {
        case 1:
          he = he.type.childContextTypes, he != null && gh();
          break;
        case 3:
          Os(), wa(Hs), wa(hs), Ln();
          break;
        case 5:
          wh(he);
          break;
        case 4:
          Os();
          break;
        case 13:
          wa(bn);
          break;
        case 19:
          wa(bn);
          break;
        case 10:
          ql(he.type._context);
          break;
        case 22:
        case 23:
          as();
      }
      $ = $.return;
    }
    if (ui = d, Ti = d = Nu(d.current, null), xi = Pi = g, mi = 0, Ai = null, Ni = yi = ji = 0, Yi = Mi = null, So !== null) {
      for (g = 0; g < So.length; g++) if ($ = So[g], he = $.interleaved, he !== null) {
        $.interleaved = null;
        var je = he.next, ot = $.pending;
        if (ot !== null) {
          var Vt = ot.next;
          ot.next = je, he.next = Vt;
        }
        $.pending = he;
      }
      So = null;
    }
    return d;
  }
  function Rn(d, g) {
    do {
      var $ = Ti;
      try {
        if (Hl(), dn.current = Rh, $l) {
          for (var he = oa.memoizedState; he !== null; ) {
            var je = he.queue;
            je !== null && (je.pending = null), he = he.next;
          }
          $l = !1;
        }
        if (Ds = 0, ja = pa = oa = null, $s = !1, Ga = 0, Kt.current = null, $ === null || $.return === null) {
          mi = 1, Ai = g, Ti = null;
          break;
        }
        e: {
          var ot = d, Vt = $.return, bi = $, Ii = g;
          if (g = xi, bi.flags |= 32768, Ii !== null && typeof Ii == "object" && typeof Ii.then == "function") {
            var $i = Ii, gr = bi, yr = gr.tag;
            if (!(gr.mode & 1) && (yr === 0 || yr === 11 || yr === 15)) {
              var vr = gr.alternate;
              vr ? (gr.updateQueue = vr.updateQueue, gr.memoizedState = vr.memoizedState, gr.lanes = vr.lanes) : (gr.updateQueue = null, gr.memoizedState = null);
            }
            var Vr = yc(Vt);
            if (Vr !== null) {
              Vr.flags &= -257, Lh(Vr, Vt, bi, ot, g), Vr.mode & 1 && gf(ot, $i, g), g = Vr, Ii = $i;
              var jr = g.updateQueue;
              if (jr === null) {
                var qr = /* @__PURE__ */ new Set();
                qr.add(Ii), g.updateQueue = qr;
              } else jr.add(Ii);
              break e;
            } else {
              if (!(g & 1)) {
                gf(ot, $i, g), ln();
                break e;
              }
              Ii = Error(qe(426));
            }
          } else if (Sa && bi.mode & 1) {
            var qa = yc(Vt);
            if (qa !== null) {
              !(qa.flags & 65536) && (qa.flags |= 256), Lh(qa, Vt, bi, ot, g), jc(el(Ii, bi));
              break e;
            }
          }
          ot = Ii = el(Ii, bi), mi !== 4 && (mi = 2), Mi === null ? Mi = [ot] : Mi.push(ot), ot = Vt;
          do {
            switch (ot.tag) {
              case 3:
                ot.flags |= 65536, g &= -g, ot.lanes |= g;
                var Vi = vc(ot, Ii, g);
                Bf(ot, Vi);
                break e;
              case 1:
                bi = Ii;
                var Li = ot.type, Wi = ot.stateNode;
                if (!(ot.flags & 128) && (typeof Li.getDerivedStateFromError == "function" || Wi !== null && typeof Wi.componentDidCatch == "function" && (fr === null || !fr.has(Wi)))) {
                  ot.flags |= 65536, g &= -g, ot.lanes |= g;
                  var Cr = _f(ot, bi, g);
                  Bf(ot, Cr);
                  break e;
                }
            }
            ot = ot.return;
          } while (ot !== null);
        }
        fo($);
      } catch (Zr) {
        g = Zr, Ti === $ && $ !== null && (Ti = $ = $.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Cn() {
    var d = Xt.current;
    return Xt.current = Rh, d === null ? Rh : d;
  }
  function ln() {
    (mi === 0 || mi === 3 || mi === 2) && (mi = 4), ui === null || !(ji & 268435455) && !(yi & 268435455) || ua(ui, xi);
  }
  function ca(d, g) {
    var $ = Jt;
    Jt |= 2;
    var he = Cn();
    (ui !== d || xi !== g) && (Zi = null, On(d, g));
    do
      try {
        Ha();
        break;
      } catch (je) {
        Rn(d, je);
      }
    while (!0);
    if (Hl(), Jt = $, Xt.current = he, Ti !== null) throw Error(qe(261));
    return ui = null, xi = 0, mi;
  }
  function Ha() {
    for (; Ti !== null; ) fs(Ti);
  }
  function kn() {
    for (; Ti !== null && !Di(); ) fs(Ti);
  }
  function fs(d) {
    var g = rh(d.alternate, d, Pi);
    d.memoizedProps = d.pendingProps, g === null ? fo(d) : Ti = g, Kt.current = null;
  }
  function fo(d) {
    var g = d;
    do {
      var $ = g.alternate;
      if (d = g.return, g.flags & 32768) {
        if ($ = il($, g), $ !== null) {
          $.flags &= 32767, Ti = $;
          return;
        }
        if (d !== null) d.flags |= 32768, d.subtreeFlags = 0, d.deletions = null;
        else {
          mi = 6, Ti = null;
          return;
        }
      } else if ($ = Dh($, g, Pi), $ !== null) {
        Ti = $;
        return;
      }
      if (g = g.sibling, g !== null) {
        Ti = g;
        return;
      }
      Ti = g = d;
    } while (g !== null);
    mi === 0 && (mi = 5);
  }
  function Ka(d, g, $) {
    var he = mn, je = Zt.transition;
    try {
      Zt.transition = null, mn = 1, Bs(d, g, $, he);
    } finally {
      Zt.transition = je, mn = he;
    }
    return null;
  }
  function Bs(d, g, $, he) {
    do
      Fs();
    while (Er !== null);
    if (Jt & 6) throw Error(qe(327));
    $ = d.finishedWork;
    var je = d.finishedLanes;
    if ($ === null) return null;
    if (d.finishedWork = null, d.finishedLanes = 0, $ === d.current) throw Error(qe(177));
    d.callbackNode = null, d.callbackPriority = 0;
    var ot = $.lanes | $.childLanes;
    if (Ms(d, ot), d === ui && (Ti = ui = null, xi = 0), !($.subtreeFlags & 2064) && !($.flags & 2064) || Or || (Or = !0, Bh(Rr, function() {
      return Fs(), null;
    })), ot = ($.flags & 15990) !== 0, $.subtreeFlags & 15990 || ot) {
      ot = Zt.transition, Zt.transition = null;
      var Vt = mn;
      mn = 1;
      var bi = Jt;
      Jt |= 4, Kt.current = null, wc(d, $), ft($, d), on(Nc), Hn = !!Fc, Nc = Fc = null, d.current = $, vt($), Bi(), Jt = bi, mn = Vt, Zt.transition = ot;
    } else d.current = $;
    if (Or && (Or = !1, Er = d, Ar = je), ot = d.pendingLanes, ot === 0 && (fr = null), wn($.stateNode), mr(d, Hi()), g !== null) for (he = d.onRecoverableError, $ = 0; $ < g.length; $++) je = g[$], he(je.value, { componentStack: je.stack, digest: je.digest });
    if (ir) throw ir = !1, d = cr, cr = null, d;
    return Ar & 1 && d.tag !== 0 && Fs(), ot = d.pendingLanes, ot & 1 ? d === an ? Fr++ : (Fr = 0, an = d) : Fr = 0, wo(), null;
  }
  function Fs() {
    if (Er !== null) {
      var d = eo(Ar), g = Zt.transition, $ = mn;
      try {
        if (Zt.transition = null, mn = 16 > d ? 16 : d, Er === null) var he = !1;
        else {
          if (d = Er, Er = null, Ar = 0, Jt & 6) throw Error(qe(331));
          var je = Jt;
          for (Jt |= 4, Pr = d.current; Pr !== null; ) {
            var ot = Pr, Vt = ot.child;
            if (Pr.flags & 16) {
              var bi = ot.deletions;
              if (bi !== null) {
                for (var Ii = 0; Ii < bi.length; Ii++) {
                  var $i = bi[Ii];
                  for (Pr = $i; Pr !== null; ) {
                    var gr = Pr;
                    switch (gr.tag) {
                      case 0:
                      case 11:
                      case 15:
                        u(8, gr, ot);
                    }
                    var yr = gr.child;
                    if (yr !== null) yr.return = gr, Pr = yr;
                    else for (; Pr !== null; ) {
                      gr = Pr;
                      var vr = gr.sibling, Vr = gr.return;
                      if (c(gr), gr === $i) {
                        Pr = null;
                        break;
                      }
                      if (vr !== null) {
                        vr.return = Vr, Pr = vr;
                        break;
                      }
                      Pr = Vr;
                    }
                  }
                }
                var jr = ot.alternate;
                if (jr !== null) {
                  var qr = jr.child;
                  if (qr !== null) {
                    jr.child = null;
                    do {
                      var qa = qr.sibling;
                      qr.sibling = null, qr = qa;
                    } while (qr !== null);
                  }
                }
                Pr = ot;
              }
            }
            if (ot.subtreeFlags & 2064 && Vt !== null) Vt.return = ot, Pr = Vt;
            else e: for (; Pr !== null; ) {
              if (ot = Pr, ot.flags & 2048) switch (ot.tag) {
                case 0:
                case 11:
                case 15:
                  u(9, ot, ot.return);
              }
              var Vi = ot.sibling;
              if (Vi !== null) {
                Vi.return = ot.return, Pr = Vi;
                break e;
              }
              Pr = ot.return;
            }
          }
          var Li = d.current;
          for (Pr = Li; Pr !== null; ) {
            Vt = Pr;
            var Wi = Vt.child;
            if (Vt.subtreeFlags & 2064 && Wi !== null) Wi.return = Vt, Pr = Wi;
            else e: for (Vt = Li; Pr !== null; ) {
              if (bi = Pr, bi.flags & 2048) try {
                switch (bi.tag) {
                  case 0:
                  case 11:
                  case 15:
                    t(9, bi);
                }
              } catch (Zr) {
                Bn(bi, bi.return, Zr);
              }
              if (bi === Vt) {
                Pr = null;
                break e;
              }
              var Cr = bi.sibling;
              if (Cr !== null) {
                Cr.return = bi.return, Pr = Cr;
                break e;
              }
              Pr = bi.return;
            }
          }
          if (Jt = je, wo(), Mr && typeof Mr.onPostCommitFiberRoot == "function") try {
            Mr.onPostCommitFiberRoot(Ir, d);
          } catch {
          }
          he = !0;
        }
        return he;
      } finally {
        mn = $, Zt.transition = g;
      }
    }
    return !1;
  }
  function po(d, g, $) {
    g = el($, g), g = vc(d, g, 1), d = xl(d, g, 1), g = fn(), d !== null && (os(d, 1, g), mr(d, g));
  }
  function Bn(d, g, $) {
    if (d.tag === 3) po(d, d, $);
    else for (; g !== null; ) {
      if (g.tag === 3) {
        po(g, d, $);
        break;
      } else if (g.tag === 1) {
        var he = g.stateNode;
        if (typeof g.type.getDerivedStateFromError == "function" || typeof he.componentDidCatch == "function" && (fr === null || !fr.has(he))) {
          d = el($, d), d = _f(g, d, 1), g = xl(g, d, 1), d = fn(), g !== null && (os(g, 1, d), mr(g, d));
          break;
        }
      }
      g = g.return;
    }
  }
  function Bu(d, g, $) {
    var he = d.pingCache;
    he !== null && he.delete(g), g = fn(), d.pingedLanes |= d.suspendedLanes & $, ui === d && (xi & $) === $ && (mi === 4 || mi === 3 && (xi & 130023424) === xi && 500 > Hi() - Ui ? On(d, 0) : Ni |= $), mr(d, g);
  }
  function Oo(d, g) {
    g === 0 && (d.mode & 1 ? (g = ea, ea <<= 1, !(ea & 130023424) && (ea = 4194304)) : g = 1);
    var $ = fn();
    d = Ko(d, g), d !== null && (os(d, g, $), mr(d, $));
  }
  function Fu(d) {
    var g = d.memoizedState, $ = 0;
    g !== null && ($ = g.retryLane), Oo(d, $);
  }
  function Sc(d, g) {
    var $ = 0;
    switch (d.tag) {
      case 13:
        var he = d.stateNode, je = d.memoizedState;
        je !== null && ($ = je.retryLane);
        break;
      case 19:
        he = d.stateNode;
        break;
      default:
        throw Error(qe(314));
    }
    he !== null && he.delete(g), Oo(d, $);
  }
  var rh;
  rh = function(d, g, $) {
    if (d !== null) if (d.memoizedProps !== g.pendingProps || Hs.current) Es = !0;
    else {
      if (!(d.lanes & $) && !(g.flags & 128)) return Es = !1, Du(d, g, $);
      Es = !!(d.flags & 131072);
    }
    else Es = !1, Sa && g.flags & 1048576 && wr(g, Xo, g.index);
    switch (g.lanes = 0, g.tag) {
      case 2:
        var he = g.type;
        Ts(d, g), d = g.pendingProps;
        var je = Io(g, hs.current);
        Ji(g, $), je = Wc(null, g, he, d, je, $);
        var ot = wl();
        return g.flags |= 1, typeof je == "object" && je !== null && typeof je.render == "function" && je.$$typeof === void 0 ? (g.tag = 1, g.memoizedState = null, g.updateQueue = null, qs(he) ? (ot = !0, vu(g)) : ot = !1, g.memoizedState = je.state !== null && je.state !== void 0 ? je.state : null, Hc(g), je.updater = Yl, g.stateNode = je, je._reactInternals = g, To(g, he, d, $), g = vf(null, g, he, !0, ot, $)) : (g.tag = 0, Sa && ot && Vc(g), gs(null, g, je, $), g = g.child), g;
      case 16:
        he = g.elementType;
        e: {
          switch (Ts(d, g), d = g.pendingProps, je = he._init, he = je(he._payload), g.type = he, je = g.tag = op(he), d = Lo(he, d), je) {
            case 0:
              g = Tl(null, g, he, d, $);
              break e;
            case 1:
              g = Cl(null, g, he, d, $);
              break e;
            case 11:
              g = Kl(null, g, he, d, $);
              break e;
            case 14:
              g = Jl(null, g, he, Lo(he.type, d), $);
              break e;
          }
          throw Error(qe(
            306,
            he,
            ""
          ));
        }
        return g;
      case 0:
        return he = g.type, je = g.pendingProps, je = g.elementType === he ? je : Lo(he, je), Tl(d, g, he, je, $);
      case 1:
        return he = g.type, je = g.pendingProps, je = g.elementType === he ? je : Lo(he, je), Cl(d, g, he, je, $);
      case 3:
        e: {
          if (Nf(g), d === null) throw Error(qe(387));
          he = g.pendingProps, ot = g.memoizedState, je = ot.element, of(d, g), bh(g, he, null, $);
          var Vt = g.memoizedState;
          if (he = Vt.element, ot.isDehydrated) if (ot = { element: he, isDehydrated: !1, cache: Vt.cache, pendingSuspenseBoundaries: Vt.pendingSuspenseBoundaries, transitions: Vt.transitions }, g.updateQueue.baseState = ot, g.memoizedState = ot, g.flags & 256) {
            je = el(Error(qe(423)), g), g = Uf(d, g, he, $, je);
            break e;
          } else if (he !== je) {
            je = el(Error(qe(424)), g), g = Uf(d, g, he, $, je);
            break e;
          } else for (Ss = Fl(g.stateNode.containerInfo.firstChild), oo = g, Sa = !0, lo = null, $ = Gc(g, null, he, $), g.child = $; $; ) $.flags = $.flags & -3 | 4096, $ = $.sibling;
          else {
            if (co(), he === je) {
              g = Ks(d, g, $);
              break e;
            }
            gs(d, g, he, $);
          }
          g = g.child;
        }
        return g;
      case 5:
        return Qo(g), d === null && oc(g), he = g.type, je = g.pendingProps, ot = d !== null ? d.memoizedProps : null, Vt = je.children, nc(he, je) ? Vt = null : ot !== null && nc(he, ot) && (g.flags |= 32), El(d, g), gs(d, g, Vt, $), g.child;
      case 6:
        return d === null && oc(g), null;
      case 13:
        return vs(d, g, $);
      case 4:
        return uc(g, g.stateNode.containerInfo), he = g.pendingProps, d === null ? g.child = Tn(g, null, he, $) : gs(d, g, he, $), g.child;
      case 11:
        return he = g.type, je = g.pendingProps, je = g.elementType === he ? je : Lo(he, je), Kl(d, g, he, je, $);
      case 7:
        return gs(d, g, g.pendingProps, $), g.child;
      case 8:
        return gs(d, g, g.pendingProps.children, $), g.child;
      case 12:
        return gs(d, g, g.pendingProps.children, $), g.child;
      case 10:
        e: {
          if (he = g.type._context, je = g.pendingProps, ot = g.memoizedProps, Vt = je.value, ra(jl, he._currentValue), he._currentValue = Vt, ot !== null) if (ba(ot.value, Vt)) {
            if (ot.children === je.children && !Hs.current) {
              g = Ks(d, g, $);
              break e;
            }
          } else for (ot = g.child, ot !== null && (ot.return = g); ot !== null; ) {
            var bi = ot.dependencies;
            if (bi !== null) {
              Vt = ot.child;
              for (var Ii = bi.firstContext; Ii !== null; ) {
                if (Ii.context === he) {
                  if (ot.tag === 1) {
                    Ii = Jo(-1, $ & -$), Ii.tag = 2;
                    var $i = ot.updateQueue;
                    if ($i !== null) {
                      $i = $i.shared;
                      var gr = $i.pending;
                      gr === null ? Ii.next = Ii : (Ii.next = gr.next, gr.next = Ii), $i.pending = Ii;
                    }
                  }
                  ot.lanes |= $, Ii = ot.alternate, Ii !== null && (Ii.lanes |= $), Wl(
                    ot.return,
                    $,
                    g
                  ), bi.lanes |= $;
                  break;
                }
                Ii = Ii.next;
              }
            } else if (ot.tag === 10) Vt = ot.type === g.type ? null : ot.child;
            else if (ot.tag === 18) {
              if (Vt = ot.return, Vt === null) throw Error(qe(341));
              Vt.lanes |= $, bi = Vt.alternate, bi !== null && (bi.lanes |= $), Wl(Vt, $, g), Vt = ot.sibling;
            } else Vt = ot.child;
            if (Vt !== null) Vt.return = ot;
            else for (Vt = ot; Vt !== null; ) {
              if (Vt === g) {
                Vt = null;
                break;
              }
              if (ot = Vt.sibling, ot !== null) {
                ot.return = Vt.return, Vt = ot;
                break;
              }
              Vt = Vt.return;
            }
            ot = Vt;
          }
          gs(d, g, je.children, $), g = g.child;
        }
        return g;
      case 9:
        return je = g.type, he = g.pendingProps.children, Ji(g, $), je = or(je), he = he(je), g.flags |= 1, gs(d, g, he, $), g.child;
      case 14:
        return he = g.type, je = Lo(he, g.pendingProps), je = Lo(he.type, je), Jl(d, g, he, je, $);
      case 15:
        return tl(d, g, g.type, g.pendingProps, $);
      case 17:
        return he = g.type, je = g.pendingProps, je = g.elementType === he ? je : Lo(he, je), Ts(d, g), g.tag = 1, qs(he) ? (d = !0, vu(g)) : d = !1, Ji(g, $), _c(g, he, je), To(g, he, je, $), vf(null, g, he, !0, d, $);
      case 19:
        return Ys(d, g, $);
      case 22:
        return Co(d, g, $);
    }
    throw Error(qe(156, g.tag));
  };
  function Bh(d, g) {
    return oi(d, g);
  }
  function sp(d, g, $, he) {
    this.tag = d, this.key = $, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = g, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = he, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function rl(d, g, $, he) {
    return new sp(d, g, $, he);
  }
  function xd(d) {
    return d = d.prototype, !(!d || !d.isReactComponent);
  }
  function op(d) {
    if (typeof d == "function") return xd(d) ? 1 : 0;
    if (d != null) {
      if (d = d.$$typeof, d === me) return 11;
      if (d === Ve) return 14;
    }
    return 2;
  }
  function Nu(d, g) {
    var $ = d.alternate;
    return $ === null ? ($ = rl(d.tag, g, d.key, d.mode), $.elementType = d.elementType, $.type = d.type, $.stateNode = d.stateNode, $.alternate = d, d.alternate = $) : ($.pendingProps = g, $.type = d.type, $.flags = 0, $.subtreeFlags = 0, $.deletions = null), $.flags = d.flags & 14680064, $.childLanes = d.childLanes, $.lanes = d.lanes, $.child = d.child, $.memoizedProps = d.memoizedProps, $.memoizedState = d.memoizedState, $.updateQueue = d.updateQueue, g = d.dependencies, $.dependencies = g === null ? null : { lanes: g.lanes, firstContext: g.firstContext }, $.sibling = d.sibling, $.index = d.index, $.ref = d.ref, $;
  }
  function yf(d, g, $, he, je, ot) {
    var Vt = 2;
    if (he = d, typeof d == "function") xd(d) && (Vt = 1);
    else if (typeof d == "string") Vt = 5;
    else e: switch (d) {
      case W:
        return Ec($.children, je, ot, g);
      case J:
        Vt = 8, je |= 8;
        break;
      case ee:
        return d = rl(12, $, g, je | 2), d.elementType = ee, d.lanes = ot, d;
      case ke:
        return d = rl(13, $, g, je), d.elementType = ke, d.lanes = ot, d;
      case ge:
        return d = rl(19, $, g, je), d.elementType = ge, d.lanes = ot, d;
      case Ue:
        return xf($, je, ot, g);
      default:
        if (typeof d == "object" && d !== null) switch (d.$$typeof) {
          case te:
            Vt = 10;
            break e;
          case le:
            Vt = 9;
            break e;
          case me:
            Vt = 11;
            break e;
          case Ve:
            Vt = 14;
            break e;
          case Oe:
            Vt = 16, he = null;
            break e;
        }
        throw Error(qe(130, d == null ? d : typeof d, ""));
    }
    return g = rl(Vt, $, g, je), g.elementType = d, g.type = he, g.lanes = ot, g;
  }
  function Ec(d, g, $, he) {
    return d = rl(7, d, he, g), d.lanes = $, d;
  }
  function xf(d, g, $, he) {
    return d = rl(22, d, he, g), d.elementType = Ue, d.lanes = $, d.stateNode = { isHidden: !1 }, d;
  }
  function jf(d, g, $) {
    return d = rl(6, d, null, g), d.lanes = $, d;
  }
  function Gf(d, g, $) {
    return g = rl(4, d.children !== null ? d.children : [], d.key, g), g.lanes = $, g.stateNode = { containerInfo: d.containerInfo, pendingChildren: null, implementation: d.implementation }, g;
  }
  function bd(d, g, $, he, je) {
    this.tag = g, this.containerInfo = d, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ss(0), this.expirationTimes = ss(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ss(0), this.identifierPrefix = he, this.onRecoverableError = je, this.mutableSourceEagerHydrationData = null;
  }
  function tu(d, g, $, he, je, ot, Vt, bi, Ii) {
    return d = new bd(d, g, $, bi, Ii), g === 1 ? (g = 1, ot === !0 && (g |= 8)) : g = 0, ot = rl(3, null, null, g), d.current = ot, ot.stateNode = d, ot.memoizedState = { element: he, isDehydrated: $, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Hc(ot), d;
  }
  function ds(d, g, $) {
    var he = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: T, key: he == null ? null : "" + he, children: d, containerInfo: g, implementation: $ };
  }
  function wd(d) {
    if (!d) return bo;
    d = d._reactInternals;
    e: {
      if (It(d) !== d || d.tag !== 1) throw Error(qe(170));
      var g = d;
      do {
        switch (g.tag) {
          case 3:
            g = g.stateNode.context;
            break e;
          case 1:
            if (qs(g.type)) {
              g = g.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        g = g.return;
      } while (g !== null);
      throw Error(qe(171));
    }
    if (d.tag === 1) {
      var $ = d.type;
      if (qs($)) return tf(d, $, g);
    }
    return g;
  }
  function Fh(d, g, $, he, je, ot, Vt, bi, Ii) {
    return d = tu($, he, !0, d, je, ot, Vt, bi, Ii), d.context = wd(null), $ = d.current, he = fn(), je = Nr($), ot = Jo(he, je), ot.callback = g ?? null, xl($, ot, je), d.current.lanes = je, os(d, je, he), mr(d, he), d;
  }
  function Hf(d, g, $, he) {
    var je = g.current, ot = fn(), Vt = Nr(je);
    return $ = wd($), g.context === null ? g.context = $ : g.pendingContext = $, g = Jo(ot, Vt), g.payload = { element: d }, he = he === void 0 ? null : he, he !== null && (g.callback = he), d = xl(je, g, Vt), d !== null && (Jr(d, je, Vt, ot), bl(d, je, Vt)), Vt;
  }
  function qf(d) {
    if (d = d.current, !d.child) return null;
    switch (d.child.tag) {
      case 5:
        return d.child.stateNode;
      default:
        return d.child.stateNode;
    }
  }
  function Nh(d, g) {
    if (d = d.memoizedState, d !== null && d.dehydrated !== null) {
      var $ = d.retryLane;
      d.retryLane = $ !== 0 && $ < g ? $ : g;
    }
  }
  function Wf(d, g) {
    Nh(d, g), (d = d.alternate) && Nh(d, g);
  }
  var Tc = typeof reportError == "function" ? reportError : function(d) {
    console.error(d);
  };
  function nh(d) {
    this._internalRoot = d;
  }
  Zf.prototype.render = nh.prototype.render = function(d) {
    var g = this._internalRoot;
    if (g === null) throw Error(qe(409));
    Hf(d, g, null, null);
  }, Zf.prototype.unmount = nh.prototype.unmount = function() {
    var d = this._internalRoot;
    if (d !== null) {
      this._internalRoot = null;
      var g = d.containerInfo;
      ns(function() {
        Hf(null, d, null, null);
      }), g[yo] = null;
    }
  };
  function Zf(d) {
    this._internalRoot = d;
  }
  Zf.prototype.unstable_scheduleHydration = function(d) {
    if (d) {
      var g = ys();
      d = { blockedOn: null, target: d, priority: g };
      for (var $ = 0; $ < ht.length && g !== 0 && g < ht[$].priority; $++) ;
      ht.splice($, 0, d), $ === 0 && er(d);
    }
  };
  function Sd(d) {
    return !(!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11);
  }
  function $f(d) {
    return !(!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11 && (d.nodeType !== 8 || d.nodeValue !== " react-mount-point-unstable "));
  }
  function lp() {
  }
  function sm(d, g, $, he, je) {
    if (je) {
      if (typeof he == "function") {
        var ot = he;
        he = function() {
          var $i = qf(Vt);
          ot.call($i);
        };
      }
      var Vt = Fh(g, he, d, 0, null, !1, !1, "", lp);
      return d._reactRootContainer = Vt, d[yo] = Vt.current, ic(d.nodeType === 8 ? d.parentNode : d), ns(), Vt;
    }
    for (; je = d.lastChild; ) d.removeChild(je);
    if (typeof he == "function") {
      var bi = he;
      he = function() {
        var $i = qf(Ii);
        bi.call($i);
      };
    }
    var Ii = tu(d, 0, !1, null, null, !1, !1, "", lp);
    return d._reactRootContainer = Ii, d[yo] = Ii.current, ic(d.nodeType === 8 ? d.parentNode : d), ns(function() {
      Hf(g, Ii, $, he);
    }), Ii;
  }
  function Xf(d, g, $, he, je) {
    var ot = $._reactRootContainer;
    if (ot) {
      var Vt = ot;
      if (typeof je == "function") {
        var bi = je;
        je = function() {
          var Ii = qf(Vt);
          bi.call(Ii);
        };
      }
      Hf(g, Vt, d, je);
    } else Vt = sm($, g, d, je, he);
    return qf(Vt);
  }
  mo = function(d) {
    switch (d.tag) {
      case 3:
        var g = d.stateNode;
        if (g.current.memoizedState.isDehydrated) {
          var $ = ga(g.pendingLanes);
          $ !== 0 && (La(g, $ | 1), mr(g, Hi()), !(Jt & 6) && (Fi = Hi() + 500, wo()));
        }
        break;
      case 13:
        ns(function() {
          var he = Ko(d, 1);
          if (he !== null) {
            var je = fn();
            Jr(he, d, 1, je);
          }
        }), Wf(d, 1);
    }
  }, Ba = function(d) {
    if (d.tag === 13) {
      var g = Ko(d, 134217728);
      if (g !== null) {
        var $ = fn();
        Jr(g, d, 134217728, $);
      }
      Wf(d, 134217728);
    }
  }, tn = function(d) {
    if (d.tag === 13) {
      var g = Nr(d), $ = Ko(d, g);
      if ($ !== null) {
        var he = fn();
        Jr($, d, g, he);
      }
      Wf(d, g);
    }
  }, ys = function() {
    return mn;
  }, Qa = function(d, g) {
    var $ = mn;
    try {
      return mn = d, g();
    } finally {
      mn = $;
    }
  }, at = function(d, g, $) {
    switch (g) {
      case "input":
        if (kt(d, $), g = $.name, $.type === "radio" && g != null) {
          for ($ = d; $.parentNode; ) $ = $.parentNode;
          for ($ = $.querySelectorAll("input[name=" + JSON.stringify("" + g) + '][type="radio"]'), g = 0; g < $.length; g++) {
            var he = $[g];
            if (he !== d && he.form === d.form) {
              var je = sc(he);
              if (!je) throw Error(qe(90));
              wi(he), kt(he, je);
            }
          }
        }
        break;
      case "textarea":
        pe(d, $);
        break;
      case "select":
        g = $.value, g != null && _t(d, !!$.multiple, g, !1);
    }
  }, z = Aa, He = ns;
  var om = { usingClientEntryPoint: !1, Events: [gu, ao, sc, Je, Xe, Aa] }, ah = { findFiberByHostInstance: Ul, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, lm = { bundleType: ah.bundleType, version: ah.version, rendererPackageName: ah.rendererPackageName, rendererConfig: ah.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: U.ReactCurrentDispatcher, findHostInstanceByFiber: function(d) {
    return d = Wt(d), d === null ? null : d.stateNode;
  }, findFiberByHostInstance: ah.findFiberByHostInstance, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Uu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Uu.isDisabled && Uu.supportsFiber) try {
      Ir = Uu.inject(lm), Mr = Uu;
    } catch {
    }
  }
  return nl.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = om, nl.createPortal = function(d, g) {
    var $ = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Sd(g)) throw Error(qe(200));
    return ds(d, g, null, $);
  }, nl.createRoot = function(d, g) {
    if (!Sd(d)) throw Error(qe(299));
    var $ = !1, he = "", je = Tc;
    return g != null && (g.unstable_strictMode === !0 && ($ = !0), g.identifierPrefix !== void 0 && (he = g.identifierPrefix), g.onRecoverableError !== void 0 && (je = g.onRecoverableError)), g = tu(d, 1, !1, null, null, $, !1, he, je), d[yo] = g.current, ic(d.nodeType === 8 ? d.parentNode : d), new nh(g);
  }, nl.findDOMNode = function(d) {
    if (d == null) return null;
    if (d.nodeType === 1) return d;
    var g = d._reactInternals;
    if (g === void 0)
      throw typeof d.render == "function" ? Error(qe(188)) : (d = Object.keys(d).join(","), Error(qe(268, d)));
    return d = Wt(g), d = d === null ? null : d.stateNode, d;
  }, nl.flushSync = function(d) {
    return ns(d);
  }, nl.hydrate = function(d, g, $) {
    if (!$f(g)) throw Error(qe(200));
    return Xf(null, d, g, !0, $);
  }, nl.hydrateRoot = function(d, g, $) {
    if (!Sd(d)) throw Error(qe(405));
    var he = $ != null && $.hydratedSources || null, je = !1, ot = "", Vt = Tc;
    if ($ != null && ($.unstable_strictMode === !0 && (je = !0), $.identifierPrefix !== void 0 && (ot = $.identifierPrefix), $.onRecoverableError !== void 0 && (Vt = $.onRecoverableError)), g = Fh(g, null, d, 1, $ ?? null, je, !1, ot, Vt), d[yo] = g.current, ic(d), he) for (d = 0; d < he.length; d++) $ = he[d], je = $._getVersion, je = je($._source), g.mutableSourceEagerHydrationData == null ? g.mutableSourceEagerHydrationData = [$, je] : g.mutableSourceEagerHydrationData.push(
      $,
      je
    );
    return new Zf(g);
  }, nl.render = function(d, g, $) {
    if (!$f(g)) throw Error(qe(200));
    return Xf(null, d, g, !1, $);
  }, nl.unmountComponentAtNode = function(d) {
    if (!$f(d)) throw Error(qe(40));
    return d._reactRootContainer ? (ns(function() {
      Xf(null, null, d, !1, function() {
        d._reactRootContainer = null, d[yo] = null;
      });
    }), !0) : !1;
  }, nl.unstable_batchedUpdates = Aa, nl.unstable_renderSubtreeIntoContainer = function(d, g, $, he) {
    if (!$f($)) throw Error(qe(200));
    if (d == null || d._reactInternals === void 0) throw Error(qe(38));
    return Xf(d, g, $, !1, he);
  }, nl.version = "18.3.1-next-f1338f8080-20240426", nl;
}
var F1;
function Zw() {
  if (F1) return x_.exports;
  F1 = 1;
  function mt() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(mt);
      } catch (Tt) {
        console.error(Tt);
      }
  }
  return mt(), x_.exports = Ww(), x_.exports;
}
var N1;
function $w() {
  if (N1) return Zp;
  N1 = 1;
  var mt = Zw();
  return Zp.createRoot = mt.createRoot, Zp.hydrateRoot = mt.hydrateRoot, Zp;
}
var Xw = $w();
const Yw = /* @__PURE__ */ dd(Xw), pd = () => {
  const mt = document.getElementById("product-info"), Tt = JSON.parse((mt == null ? void 0 : mt.textContent) || "{}");
  return window.shineon = window.shineon || {}, window.shineon.product_info = Tt, Tt;
}, tm = () => {
  const mt = pd();
  return Kw(mt);
}, Kw = (mt) => {
  var Tt;
  return !mt.shop_cf || !((Tt = mt.shop_pt_id_obj) != null && Tt.custom_fields) ? [] : mt.shop_pt_id_obj.custom_fields.map((qe) => ({
    ...mt.shop_cf[qe.key],
    id: qe
  }));
}, Jw = {
  en: {
    errors: {
      invalid_character: " isn't available"
    }
  },
  fr: {
    errors: {
      invalid_character: " n'est pas disponible"
    }
  },
  es: {
    errors: {
      invalid_character: " no est disponible"
    }
  },
  de: {
    errors: {
      invalid_character: " ist nicht verfgbar"
    }
  },
  it: {
    errors: {
      invalid_character: " non  disponibile"
    }
  },
  pt: {
    errors: {
      invalid_character: " no est disponvel"
    }
  },
  ua: {
    errors: {
      invalid_character: " "
    }
  },
  pl: {
    errors: {
      invalid_character: " jest niedostpny"
    }
  }
}, wg = pd();
let S_ = wg.selected_variant;
const yg = {
  get variantInputs() {
    return document.querySelectorAll(wg.variant_id_input);
  }
}, Qw = () => {
  const mt = document.querySelectorAll('form[action="/cart/add"]');
  return Array.from(mt).map((Tt) => Tt.getAttribute("id"));
}, e2 = () => (S_ || yg.variantInputs.forEach((mt) => {
  if (mt) {
    const Tt = parseInt(mt.value);
    S_ = wg.product.variants.find((qe) => qe.id === Tt);
  }
}), S_), t2 = (mt) => {
  clearTimeout(window.variantChangeTimeout), window.variantChangeTimeout = setTimeout(() => {
    mt();
  }, 300);
}, i2 = (mt) => (yg.variantInputs.forEach((Tt) => {
  Tt.addEventListener("change", mt);
}), () => {
  yg.variantInputs.forEach((Tt) => {
    Tt.removeEventListener("change", mt);
  });
}), r2 = ({ product_cf: mt, required: Tt, formId: qe, onBeforeInput: Q, onChange: de }) => {
  const q = (ie, i) => ({
    type: "text",
    id: ie.id.key,
    name: `properties[${ie.name}]`,
    autoComplete: "off",
    placeholder: ie.placeholder,
    form: i,
    required: Tt,
    className: `so-field__input ${ie.class || ""}`,
    minLength: ie.minlength > 0 ? ie.minlength : void 0,
    maxLength: ie.maxlength > 0 ? ie.maxlength : 20,
    onBeforeInput: Q,
    onChange: de
  });
  return /* @__PURE__ */ Dr.jsx("input", { ...q(mt, qe) });
};
var Xp = { exports: {} }, n2 = Xp.exports, U1;
function a2() {
  return U1 || (U1 = 1, function(mt, Tt) {
    (function(qe, Q) {
      mt.exports = Q();
    })(n2, function() {
      var qe, Q, de;
      function q(i, N) {
        if (!qe)
          qe = N;
        else if (!Q)
          Q = N;
        else {
          var Z = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + qe + ")(sharedChunk); (" + Q + ")(sharedChunk); self.onerror = null;", R = {};
          qe(R), de = N(R), typeof window < "u" && window && window.URL && window.URL.createObjectURL && (de.workerUrl = window.URL.createObjectURL(new Blob([Z], { type: "text/javascript" })));
        }
      }
      q(["exports"], function(i) {
        function N(a) {
          return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
        }
        var Z, R = {}, A = {};
        function M() {
          if (Z) return A;
          Z = 1, Object.defineProperty(A, "__esModule", { value: !0 }), A.setMatrixArrayType = function(h) {
            A.ARRAY_TYPE = e = h;
          }, A.toRadian = function(h) {
            return h * s;
          }, A.equals = function(h, o) {
            return Math.abs(h - o) <= a * Math.max(1, Math.abs(h), Math.abs(o));
          }, A.RANDOM = A.ARRAY_TYPE = A.EPSILON = void 0;
          var a = 1e-6;
          A.EPSILON = a;
          var e = typeof Float32Array < "u" ? Float32Array : Array;
          A.ARRAY_TYPE = e;
          var r = Math.random;
          A.RANDOM = r;
          var s = Math.PI / 180;
          return Math.hypot || (Math.hypot = function() {
            for (var h = 0, o = arguments.length; o--; ) h += arguments[o] * arguments[o];
            return Math.sqrt(h);
          }), A;
        }
        var x, m = {};
        function w() {
          if (x) return m;
          function a(o) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
              return typeof f;
            } : function(f) {
              return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
            }, a(o);
          }
          x = 1, Object.defineProperty(m, "__esModule", { value: !0 }), m.create = function() {
            var o = new e.ARRAY_TYPE(4);
            return e.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0), o[0] = 1, o[3] = 1, o;
          }, m.clone = function(o) {
            var f = new e.ARRAY_TYPE(4);
            return f[0] = o[0], f[1] = o[1], f[2] = o[2], f[3] = o[3], f;
          }, m.copy = function(o, f) {
            return o[0] = f[0], o[1] = f[1], o[2] = f[2], o[3] = f[3], o;
          }, m.identity = function(o) {
            return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 1, o;
          }, m.fromValues = function(o, f, b, O) {
            var H = new e.ARRAY_TYPE(4);
            return H[0] = o, H[1] = f, H[2] = b, H[3] = O, H;
          }, m.set = function(o, f, b, O, H) {
            return o[0] = f, o[1] = b, o[2] = O, o[3] = H, o;
          }, m.transpose = function(o, f) {
            if (o === f) {
              var b = f[1];
              o[1] = f[2], o[2] = b;
            } else o[0] = f[0], o[1] = f[2], o[2] = f[1], o[3] = f[3];
            return o;
          }, m.invert = function(o, f) {
            var b = f[0], O = f[1], H = f[2], y = f[3], B = b * y - H * O;
            return B ? (o[0] = y * (B = 1 / B), o[1] = -O * B, o[2] = -H * B, o[3] = b * B, o) : null;
          }, m.adjoint = function(o, f) {
            var b = f[0];
            return o[0] = f[3], o[1] = -f[1], o[2] = -f[2], o[3] = b, o;
          }, m.determinant = function(o) {
            return o[0] * o[3] - o[2] * o[1];
          }, m.multiply = s, m.rotate = function(o, f, b) {
            var O = f[0], H = f[1], y = f[2], B = f[3], G = Math.sin(b), L = Math.cos(b);
            return o[0] = O * L + y * G, o[1] = H * L + B * G, o[2] = O * -G + y * L, o[3] = H * -G + B * L, o;
          }, m.scale = function(o, f, b) {
            var O = f[1], H = f[2], y = f[3], B = b[0], G = b[1];
            return o[0] = f[0] * B, o[1] = O * B, o[2] = H * G, o[3] = y * G, o;
          }, m.fromRotation = function(o, f) {
            var b = Math.sin(f), O = Math.cos(f);
            return o[0] = O, o[1] = b, o[2] = -b, o[3] = O, o;
          }, m.fromScaling = function(o, f) {
            return o[0] = f[0], o[1] = 0, o[2] = 0, o[3] = f[1], o;
          }, m.str = function(o) {
            return "mat2(" + o[0] + ", " + o[1] + ", " + o[2] + ", " + o[3] + ")";
          }, m.frob = function(o) {
            return Math.hypot(o[0], o[1], o[2], o[3]);
          }, m.LDU = function(o, f, b, O) {
            return o[2] = O[2] / O[0], b[0] = O[0], b[1] = O[1], b[3] = O[3] - o[2] * b[1], [o, f, b];
          }, m.add = function(o, f, b) {
            return o[0] = f[0] + b[0], o[1] = f[1] + b[1], o[2] = f[2] + b[2], o[3] = f[3] + b[3], o;
          }, m.subtract = h, m.exactEquals = function(o, f) {
            return o[0] === f[0] && o[1] === f[1] && o[2] === f[2] && o[3] === f[3];
          }, m.equals = function(o, f) {
            var b = o[0], O = o[1], H = o[2], y = o[3], B = f[0], G = f[1], L = f[2], F = f[3];
            return Math.abs(b - B) <= e.EPSILON * Math.max(1, Math.abs(b), Math.abs(B)) && Math.abs(O - G) <= e.EPSILON * Math.max(1, Math.abs(O), Math.abs(G)) && Math.abs(H - L) <= e.EPSILON * Math.max(1, Math.abs(H), Math.abs(L)) && Math.abs(y - F) <= e.EPSILON * Math.max(1, Math.abs(y), Math.abs(F));
          }, m.multiplyScalar = function(o, f, b) {
            return o[0] = f[0] * b, o[1] = f[1] * b, o[2] = f[2] * b, o[3] = f[3] * b, o;
          }, m.multiplyScalarAndAdd = function(o, f, b, O) {
            return o[0] = f[0] + b[0] * O, o[1] = f[1] + b[1] * O, o[2] = f[2] + b[2] * O, o[3] = f[3] + b[3] * O, o;
          }, m.sub = m.mul = void 0;
          var e = function(o, f) {
            if (o && o.__esModule) return o;
            if (o === null || a(o) !== "object" && typeof o != "function") return { default: o };
            var b = r(void 0);
            if (b && b.has(o)) return b.get(o);
            var O = {}, H = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var y in o) if (y !== "default" && Object.prototype.hasOwnProperty.call(o, y)) {
              var B = H ? Object.getOwnPropertyDescriptor(o, y) : null;
              B && (B.get || B.set) ? Object.defineProperty(O, y, B) : O[y] = o[y];
            }
            return O.default = o, b && b.set(o, O), O;
          }(M());
          function r(o) {
            if (typeof WeakMap != "function") return null;
            var f = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap();
            return (r = function(O) {
              return O ? b : f;
            })(o);
          }
          function s(o, f, b) {
            var O = f[0], H = f[1], y = f[2], B = f[3], G = b[0], L = b[1], F = b[2], Y = b[3];
            return o[0] = O * G + y * L, o[1] = H * G + B * L, o[2] = O * F + y * Y, o[3] = H * F + B * Y, o;
          }
          function h(o, f, b) {
            return o[0] = f[0] - b[0], o[1] = f[1] - b[1], o[2] = f[2] - b[2], o[3] = f[3] - b[3], o;
          }
          return m.mul = s, m.sub = h, m;
        }
        var k, E = {};
        function P() {
          if (k) return E;
          function a(o) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
              return typeof f;
            } : function(f) {
              return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
            }, a(o);
          }
          k = 1, Object.defineProperty(E, "__esModule", { value: !0 }), E.create = function() {
            var o = new e.ARRAY_TYPE(6);
            return e.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0, o[4] = 0, o[5] = 0), o[0] = 1, o[3] = 1, o;
          }, E.clone = function(o) {
            var f = new e.ARRAY_TYPE(6);
            return f[0] = o[0], f[1] = o[1], f[2] = o[2], f[3] = o[3], f[4] = o[4], f[5] = o[5], f;
          }, E.copy = function(o, f) {
            return o[0] = f[0], o[1] = f[1], o[2] = f[2], o[3] = f[3], o[4] = f[4], o[5] = f[5], o;
          }, E.identity = function(o) {
            return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 1, o[4] = 0, o[5] = 0, o;
          }, E.fromValues = function(o, f, b, O, H, y) {
            var B = new e.ARRAY_TYPE(6);
            return B[0] = o, B[1] = f, B[2] = b, B[3] = O, B[4] = H, B[5] = y, B;
          }, E.set = function(o, f, b, O, H, y, B) {
            return o[0] = f, o[1] = b, o[2] = O, o[3] = H, o[4] = y, o[5] = B, o;
          }, E.invert = function(o, f) {
            var b = f[0], O = f[1], H = f[2], y = f[3], B = f[4], G = f[5], L = b * y - O * H;
            return L ? (o[0] = y * (L = 1 / L), o[1] = -O * L, o[2] = -H * L, o[3] = b * L, o[4] = (H * G - y * B) * L, o[5] = (O * B - b * G) * L, o) : null;
          }, E.determinant = function(o) {
            return o[0] * o[3] - o[1] * o[2];
          }, E.multiply = s, E.rotate = function(o, f, b) {
            var O = f[0], H = f[1], y = f[2], B = f[3], G = f[4], L = f[5], F = Math.sin(b), Y = Math.cos(b);
            return o[0] = O * Y + y * F, o[1] = H * Y + B * F, o[2] = O * -F + y * Y, o[3] = H * -F + B * Y, o[4] = G, o[5] = L, o;
          }, E.scale = function(o, f, b) {
            var O = f[1], H = f[2], y = f[3], B = f[4], G = f[5], L = b[0], F = b[1];
            return o[0] = f[0] * L, o[1] = O * L, o[2] = H * F, o[3] = y * F, o[4] = B, o[5] = G, o;
          }, E.translate = function(o, f, b) {
            var O = f[0], H = f[1], y = f[2], B = f[3], G = f[4], L = f[5], F = b[0], Y = b[1];
            return o[0] = O, o[1] = H, o[2] = y, o[3] = B, o[4] = O * F + y * Y + G, o[5] = H * F + B * Y + L, o;
          }, E.fromRotation = function(o, f) {
            var b = Math.sin(f), O = Math.cos(f);
            return o[0] = O, o[1] = b, o[2] = -b, o[3] = O, o[4] = 0, o[5] = 0, o;
          }, E.fromScaling = function(o, f) {
            return o[0] = f[0], o[1] = 0, o[2] = 0, o[3] = f[1], o[4] = 0, o[5] = 0, o;
          }, E.fromTranslation = function(o, f) {
            return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 1, o[4] = f[0], o[5] = f[1], o;
          }, E.str = function(o) {
            return "mat2d(" + o[0] + ", " + o[1] + ", " + o[2] + ", " + o[3] + ", " + o[4] + ", " + o[5] + ")";
          }, E.frob = function(o) {
            return Math.hypot(o[0], o[1], o[2], o[3], o[4], o[5], 1);
          }, E.add = function(o, f, b) {
            return o[0] = f[0] + b[0], o[1] = f[1] + b[1], o[2] = f[2] + b[2], o[3] = f[3] + b[3], o[4] = f[4] + b[4], o[5] = f[5] + b[5], o;
          }, E.subtract = h, E.multiplyScalar = function(o, f, b) {
            return o[0] = f[0] * b, o[1] = f[1] * b, o[2] = f[2] * b, o[3] = f[3] * b, o[4] = f[4] * b, o[5] = f[5] * b, o;
          }, E.multiplyScalarAndAdd = function(o, f, b, O) {
            return o[0] = f[0] + b[0] * O, o[1] = f[1] + b[1] * O, o[2] = f[2] + b[2] * O, o[3] = f[3] + b[3] * O, o[4] = f[4] + b[4] * O, o[5] = f[5] + b[5] * O, o;
          }, E.exactEquals = function(o, f) {
            return o[0] === f[0] && o[1] === f[1] && o[2] === f[2] && o[3] === f[3] && o[4] === f[4] && o[5] === f[5];
          }, E.equals = function(o, f) {
            var b = o[0], O = o[1], H = o[2], y = o[3], B = o[4], G = o[5], L = f[0], F = f[1], Y = f[2], ce = f[3], _e = f[4], ze = f[5];
            return Math.abs(b - L) <= e.EPSILON * Math.max(1, Math.abs(b), Math.abs(L)) && Math.abs(O - F) <= e.EPSILON * Math.max(1, Math.abs(O), Math.abs(F)) && Math.abs(H - Y) <= e.EPSILON * Math.max(1, Math.abs(H), Math.abs(Y)) && Math.abs(y - ce) <= e.EPSILON * Math.max(1, Math.abs(y), Math.abs(ce)) && Math.abs(B - _e) <= e.EPSILON * Math.max(1, Math.abs(B), Math.abs(_e)) && Math.abs(G - ze) <= e.EPSILON * Math.max(1, Math.abs(G), Math.abs(ze));
          }, E.sub = E.mul = void 0;
          var e = function(o, f) {
            if (o && o.__esModule) return o;
            if (o === null || a(o) !== "object" && typeof o != "function") return { default: o };
            var b = r(void 0);
            if (b && b.has(o)) return b.get(o);
            var O = {}, H = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var y in o) if (y !== "default" && Object.prototype.hasOwnProperty.call(o, y)) {
              var B = H ? Object.getOwnPropertyDescriptor(o, y) : null;
              B && (B.get || B.set) ? Object.defineProperty(O, y, B) : O[y] = o[y];
            }
            return O.default = o, b && b.set(o, O), O;
          }(M());
          function r(o) {
            if (typeof WeakMap != "function") return null;
            var f = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap();
            return (r = function(O) {
              return O ? b : f;
            })(o);
          }
          function s(o, f, b) {
            var O = f[0], H = f[1], y = f[2], B = f[3], G = f[4], L = f[5], F = b[0], Y = b[1], ce = b[2], _e = b[3], ze = b[4], Ne = b[5];
            return o[0] = O * F + y * Y, o[1] = H * F + B * Y, o[2] = O * ce + y * _e, o[3] = H * ce + B * _e, o[4] = O * ze + y * Ne + G, o[5] = H * ze + B * Ne + L, o;
          }
          function h(o, f, b) {
            return o[0] = f[0] - b[0], o[1] = f[1] - b[1], o[2] = f[2] - b[2], o[3] = f[3] - b[3], o[4] = f[4] - b[4], o[5] = f[5] - b[5], o;
          }
          return E.mul = s, E.sub = h, E;
        }
        var S, U = {};
        function j() {
          if (S) return U;
          function a(o) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
              return typeof f;
            } : function(f) {
              return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
            }, a(o);
          }
          S = 1, Object.defineProperty(U, "__esModule", { value: !0 }), U.create = function() {
            var o = new e.ARRAY_TYPE(9);
            return e.ARRAY_TYPE != Float32Array && (o[1] = 0, o[2] = 0, o[3] = 0, o[5] = 0, o[6] = 0, o[7] = 0), o[0] = 1, o[4] = 1, o[8] = 1, o;
          }, U.fromMat4 = function(o, f) {
            return o[0] = f[0], o[1] = f[1], o[2] = f[2], o[3] = f[4], o[4] = f[5], o[5] = f[6], o[6] = f[8], o[7] = f[9], o[8] = f[10], o;
          }, U.clone = function(o) {
            var f = new e.ARRAY_TYPE(9);
            return f[0] = o[0], f[1] = o[1], f[2] = o[2], f[3] = o[3], f[4] = o[4], f[5] = o[5], f[6] = o[6], f[7] = o[7], f[8] = o[8], f;
          }, U.copy = function(o, f) {
            return o[0] = f[0], o[1] = f[1], o[2] = f[2], o[3] = f[3], o[4] = f[4], o[5] = f[5], o[6] = f[6], o[7] = f[7], o[8] = f[8], o;
          }, U.fromValues = function(o, f, b, O, H, y, B, G, L) {
            var F = new e.ARRAY_TYPE(9);
            return F[0] = o, F[1] = f, F[2] = b, F[3] = O, F[4] = H, F[5] = y, F[6] = B, F[7] = G, F[8] = L, F;
          }, U.set = function(o, f, b, O, H, y, B, G, L, F) {
            return o[0] = f, o[1] = b, o[2] = O, o[3] = H, o[4] = y, o[5] = B, o[6] = G, o[7] = L, o[8] = F, o;
          }, U.identity = function(o) {
            return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 1, o[5] = 0, o[6] = 0, o[7] = 0, o[8] = 1, o;
          }, U.transpose = function(o, f) {
            if (o === f) {
              var b = f[1], O = f[2], H = f[5];
              o[1] = f[3], o[2] = f[6], o[3] = b, o[5] = f[7], o[6] = O, o[7] = H;
            } else o[0] = f[0], o[1] = f[3], o[2] = f[6], o[3] = f[1], o[4] = f[4], o[5] = f[7], o[6] = f[2], o[7] = f[5], o[8] = f[8];
            return o;
          }, U.invert = function(o, f) {
            var b = f[0], O = f[1], H = f[2], y = f[3], B = f[4], G = f[5], L = f[6], F = f[7], Y = f[8], ce = Y * B - G * F, _e = -Y * y + G * L, ze = F * y - B * L, Ne = b * ce + O * _e + H * ze;
            return Ne ? (o[0] = ce * (Ne = 1 / Ne), o[1] = (-Y * O + H * F) * Ne, o[2] = (G * O - H * B) * Ne, o[3] = _e * Ne, o[4] = (Y * b - H * L) * Ne, o[5] = (-G * b + H * y) * Ne, o[6] = ze * Ne, o[7] = (-F * b + O * L) * Ne, o[8] = (B * b - O * y) * Ne, o) : null;
          }, U.adjoint = function(o, f) {
            var b = f[0], O = f[1], H = f[2], y = f[3], B = f[4], G = f[5], L = f[6], F = f[7], Y = f[8];
            return o[0] = B * Y - G * F, o[1] = H * F - O * Y, o[2] = O * G - H * B, o[3] = G * L - y * Y, o[4] = b * Y - H * L, o[5] = H * y - b * G, o[6] = y * F - B * L, o[7] = O * L - b * F, o[8] = b * B - O * y, o;
          }, U.determinant = function(o) {
            var f = o[3], b = o[4], O = o[5], H = o[6], y = o[7], B = o[8];
            return o[0] * (B * b - O * y) + o[1] * (-B * f + O * H) + o[2] * (y * f - b * H);
          }, U.multiply = s, U.translate = function(o, f, b) {
            var O = f[0], H = f[1], y = f[2], B = f[3], G = f[4], L = f[5], F = f[6], Y = f[7], ce = f[8], _e = b[0], ze = b[1];
            return o[0] = O, o[1] = H, o[2] = y, o[3] = B, o[4] = G, o[5] = L, o[6] = _e * O + ze * B + F, o[7] = _e * H + ze * G + Y, o[8] = _e * y + ze * L + ce, o;
          }, U.rotate = function(o, f, b) {
            var O = f[0], H = f[1], y = f[2], B = f[3], G = f[4], L = f[5], F = f[6], Y = f[7], ce = f[8], _e = Math.sin(b), ze = Math.cos(b);
            return o[0] = ze * O + _e * B, o[1] = ze * H + _e * G, o[2] = ze * y + _e * L, o[3] = ze * B - _e * O, o[4] = ze * G - _e * H, o[5] = ze * L - _e * y, o[6] = F, o[7] = Y, o[8] = ce, o;
          }, U.scale = function(o, f, b) {
            var O = b[0], H = b[1];
            return o[0] = O * f[0], o[1] = O * f[1], o[2] = O * f[2], o[3] = H * f[3], o[4] = H * f[4], o[5] = H * f[5], o[6] = f[6], o[7] = f[7], o[8] = f[8], o;
          }, U.fromTranslation = function(o, f) {
            return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 1, o[5] = 0, o[6] = f[0], o[7] = f[1], o[8] = 1, o;
          }, U.fromRotation = function(o, f) {
            var b = Math.sin(f), O = Math.cos(f);
            return o[0] = O, o[1] = b, o[2] = 0, o[3] = -b, o[4] = O, o[5] = 0, o[6] = 0, o[7] = 0, o[8] = 1, o;
          }, U.fromScaling = function(o, f) {
            return o[0] = f[0], o[1] = 0, o[2] = 0, o[3] = 0, o[4] = f[1], o[5] = 0, o[6] = 0, o[7] = 0, o[8] = 1, o;
          }, U.fromMat2d = function(o, f) {
            return o[0] = f[0], o[1] = f[1], o[2] = 0, o[3] = f[2], o[4] = f[3], o[5] = 0, o[6] = f[4], o[7] = f[5], o[8] = 1, o;
          }, U.fromQuat = function(o, f) {
            var b = f[0], O = f[1], H = f[2], y = f[3], B = b + b, G = O + O, L = H + H, F = b * B, Y = O * B, ce = O * G, _e = H * B, ze = H * G, Ne = H * L, Ee = y * B, We = y * G, lt = y * L;
            return o[0] = 1 - ce - Ne, o[3] = Y - lt, o[6] = _e + We, o[1] = Y + lt, o[4] = 1 - F - Ne, o[7] = ze - Ee, o[2] = _e - We, o[5] = ze + Ee, o[8] = 1 - F - ce, o;
          }, U.normalFromMat4 = function(o, f) {
            var b = f[0], O = f[1], H = f[2], y = f[3], B = f[4], G = f[5], L = f[6], F = f[7], Y = f[8], ce = f[9], _e = f[10], ze = f[11], Ne = f[12], Ee = f[13], We = f[14], lt = f[15], yt = b * G - O * B, Bt = b * L - H * B, zt = b * F - y * B, Dt = O * L - H * G, ni = O * F - y * G, Gt = H * F - y * L, si = Y * Ee - ce * Ne, ci = Y * We - _e * Ne, li = Y * lt - ze * Ne, fi = ce * We - _e * Ee, gi = ce * lt - ze * Ee, Si = _e * lt - ze * We, pi = yt * Si - Bt * gi + zt * fi + Dt * li - ni * ci + Gt * si;
            return pi ? (o[0] = (G * Si - L * gi + F * fi) * (pi = 1 / pi), o[1] = (L * li - B * Si - F * ci) * pi, o[2] = (B * gi - G * li + F * si) * pi, o[3] = (H * gi - O * Si - y * fi) * pi, o[4] = (b * Si - H * li + y * ci) * pi, o[5] = (O * li - b * gi - y * si) * pi, o[6] = (Ee * Gt - We * ni + lt * Dt) * pi, o[7] = (We * zt - Ne * Gt - lt * Bt) * pi, o[8] = (Ne * ni - Ee * zt + lt * yt) * pi, o) : null;
          }, U.projection = function(o, f, b) {
            return o[0] = 2 / f, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = -2 / b, o[5] = 0, o[6] = -1, o[7] = 1, o[8] = 1, o;
          }, U.str = function(o) {
            return "mat3(" + o[0] + ", " + o[1] + ", " + o[2] + ", " + o[3] + ", " + o[4] + ", " + o[5] + ", " + o[6] + ", " + o[7] + ", " + o[8] + ")";
          }, U.frob = function(o) {
            return Math.hypot(o[0], o[1], o[2], o[3], o[4], o[5], o[6], o[7], o[8]);
          }, U.add = function(o, f, b) {
            return o[0] = f[0] + b[0], o[1] = f[1] + b[1], o[2] = f[2] + b[2], o[3] = f[3] + b[3], o[4] = f[4] + b[4], o[5] = f[5] + b[5], o[6] = f[6] + b[6], o[7] = f[7] + b[7], o[8] = f[8] + b[8], o;
          }, U.subtract = h, U.multiplyScalar = function(o, f, b) {
            return o[0] = f[0] * b, o[1] = f[1] * b, o[2] = f[2] * b, o[3] = f[3] * b, o[4] = f[4] * b, o[5] = f[5] * b, o[6] = f[6] * b, o[7] = f[7] * b, o[8] = f[8] * b, o;
          }, U.multiplyScalarAndAdd = function(o, f, b, O) {
            return o[0] = f[0] + b[0] * O, o[1] = f[1] + b[1] * O, o[2] = f[2] + b[2] * O, o[3] = f[3] + b[3] * O, o[4] = f[4] + b[4] * O, o[5] = f[5] + b[5] * O, o[6] = f[6] + b[6] * O, o[7] = f[7] + b[7] * O, o[8] = f[8] + b[8] * O, o;
          }, U.exactEquals = function(o, f) {
            return o[0] === f[0] && o[1] === f[1] && o[2] === f[2] && o[3] === f[3] && o[4] === f[4] && o[5] === f[5] && o[6] === f[6] && o[7] === f[7] && o[8] === f[8];
          }, U.equals = function(o, f) {
            var b = o[0], O = o[1], H = o[2], y = o[3], B = o[4], G = o[5], L = o[6], F = o[7], Y = o[8], ce = f[0], _e = f[1], ze = f[2], Ne = f[3], Ee = f[4], We = f[5], lt = f[6], yt = f[7], Bt = f[8];
            return Math.abs(b - ce) <= e.EPSILON * Math.max(1, Math.abs(b), Math.abs(ce)) && Math.abs(O - _e) <= e.EPSILON * Math.max(1, Math.abs(O), Math.abs(_e)) && Math.abs(H - ze) <= e.EPSILON * Math.max(1, Math.abs(H), Math.abs(ze)) && Math.abs(y - Ne) <= e.EPSILON * Math.max(1, Math.abs(y), Math.abs(Ne)) && Math.abs(B - Ee) <= e.EPSILON * Math.max(1, Math.abs(B), Math.abs(Ee)) && Math.abs(G - We) <= e.EPSILON * Math.max(1, Math.abs(G), Math.abs(We)) && Math.abs(L - lt) <= e.EPSILON * Math.max(1, Math.abs(L), Math.abs(lt)) && Math.abs(F - yt) <= e.EPSILON * Math.max(1, Math.abs(F), Math.abs(yt)) && Math.abs(Y - Bt) <= e.EPSILON * Math.max(1, Math.abs(Y), Math.abs(Bt));
          }, U.sub = U.mul = void 0;
          var e = function(o, f) {
            if (o && o.__esModule) return o;
            if (o === null || a(o) !== "object" && typeof o != "function") return { default: o };
            var b = r(void 0);
            if (b && b.has(o)) return b.get(o);
            var O = {}, H = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var y in o) if (y !== "default" && Object.prototype.hasOwnProperty.call(o, y)) {
              var B = H ? Object.getOwnPropertyDescriptor(o, y) : null;
              B && (B.get || B.set) ? Object.defineProperty(O, y, B) : O[y] = o[y];
            }
            return O.default = o, b && b.set(o, O), O;
          }(M());
          function r(o) {
            if (typeof WeakMap != "function") return null;
            var f = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap();
            return (r = function(O) {
              return O ? b : f;
            })(o);
          }
          function s(o, f, b) {
            var O = f[0], H = f[1], y = f[2], B = f[3], G = f[4], L = f[5], F = f[6], Y = f[7], ce = f[8], _e = b[0], ze = b[1], Ne = b[2], Ee = b[3], We = b[4], lt = b[5], yt = b[6], Bt = b[7], zt = b[8];
            return o[0] = _e * O + ze * B + Ne * F, o[1] = _e * H + ze * G + Ne * Y, o[2] = _e * y + ze * L + Ne * ce, o[3] = Ee * O + We * B + lt * F, o[4] = Ee * H + We * G + lt * Y, o[5] = Ee * y + We * L + lt * ce, o[6] = yt * O + Bt * B + zt * F, o[7] = yt * H + Bt * G + zt * Y, o[8] = yt * y + Bt * L + zt * ce, o;
          }
          function h(o, f, b) {
            return o[0] = f[0] - b[0], o[1] = f[1] - b[1], o[2] = f[2] - b[2], o[3] = f[3] - b[3], o[4] = f[4] - b[4], o[5] = f[5] - b[5], o[6] = f[6] - b[6], o[7] = f[7] - b[7], o[8] = f[8] - b[8], o;
          }
          return U.mul = s, U.sub = h, U;
        }
        var T, W = {};
        function J() {
          if (T) return W;
          function a(y) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(B) {
              return typeof B;
            } : function(B) {
              return B && typeof Symbol == "function" && B.constructor === Symbol && B !== Symbol.prototype ? "symbol" : typeof B;
            }, a(y);
          }
          T = 1, Object.defineProperty(W, "__esModule", { value: !0 }), W.create = function() {
            var y = new e.ARRAY_TYPE(16);
            return e.ARRAY_TYPE != Float32Array && (y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[6] = 0, y[7] = 0, y[8] = 0, y[9] = 0, y[11] = 0, y[12] = 0, y[13] = 0, y[14] = 0), y[0] = 1, y[5] = 1, y[10] = 1, y[15] = 1, y;
          }, W.clone = function(y) {
            var B = new e.ARRAY_TYPE(16);
            return B[0] = y[0], B[1] = y[1], B[2] = y[2], B[3] = y[3], B[4] = y[4], B[5] = y[5], B[6] = y[6], B[7] = y[7], B[8] = y[8], B[9] = y[9], B[10] = y[10], B[11] = y[11], B[12] = y[12], B[13] = y[13], B[14] = y[14], B[15] = y[15], B;
          }, W.copy = function(y, B) {
            return y[0] = B[0], y[1] = B[1], y[2] = B[2], y[3] = B[3], y[4] = B[4], y[5] = B[5], y[6] = B[6], y[7] = B[7], y[8] = B[8], y[9] = B[9], y[10] = B[10], y[11] = B[11], y[12] = B[12], y[13] = B[13], y[14] = B[14], y[15] = B[15], y;
          }, W.fromValues = function(y, B, G, L, F, Y, ce, _e, ze, Ne, Ee, We, lt, yt, Bt, zt) {
            var Dt = new e.ARRAY_TYPE(16);
            return Dt[0] = y, Dt[1] = B, Dt[2] = G, Dt[3] = L, Dt[4] = F, Dt[5] = Y, Dt[6] = ce, Dt[7] = _e, Dt[8] = ze, Dt[9] = Ne, Dt[10] = Ee, Dt[11] = We, Dt[12] = lt, Dt[13] = yt, Dt[14] = Bt, Dt[15] = zt, Dt;
          }, W.set = function(y, B, G, L, F, Y, ce, _e, ze, Ne, Ee, We, lt, yt, Bt, zt, Dt) {
            return y[0] = B, y[1] = G, y[2] = L, y[3] = F, y[4] = Y, y[5] = ce, y[6] = _e, y[7] = ze, y[8] = Ne, y[9] = Ee, y[10] = We, y[11] = lt, y[12] = yt, y[13] = Bt, y[14] = zt, y[15] = Dt, y;
          }, W.identity = s, W.transpose = function(y, B) {
            if (y === B) {
              var G = B[1], L = B[2], F = B[3], Y = B[6], ce = B[7], _e = B[11];
              y[1] = B[4], y[2] = B[8], y[3] = B[12], y[4] = G, y[6] = B[9], y[7] = B[13], y[8] = L, y[9] = Y, y[11] = B[14], y[12] = F, y[13] = ce, y[14] = _e;
            } else y[0] = B[0], y[1] = B[4], y[2] = B[8], y[3] = B[12], y[4] = B[1], y[5] = B[5], y[6] = B[9], y[7] = B[13], y[8] = B[2], y[9] = B[6], y[10] = B[10], y[11] = B[14], y[12] = B[3], y[13] = B[7], y[14] = B[11], y[15] = B[15];
            return y;
          }, W.invert = function(y, B) {
            var G = B[0], L = B[1], F = B[2], Y = B[3], ce = B[4], _e = B[5], ze = B[6], Ne = B[7], Ee = B[8], We = B[9], lt = B[10], yt = B[11], Bt = B[12], zt = B[13], Dt = B[14], ni = B[15], Gt = G * _e - L * ce, si = G * ze - F * ce, ci = G * Ne - Y * ce, li = L * ze - F * _e, fi = L * Ne - Y * _e, gi = F * Ne - Y * ze, Si = Ee * zt - We * Bt, pi = Ee * Dt - lt * Bt, zi = Ee * ni - yt * Bt, Gi = We * Dt - lt * zt, Oi = We * ni - yt * zt, lr = lt * ni - yt * Dt, ar = Gt * lr - si * Oi + ci * Gi + li * zi - fi * pi + gi * Si;
            return ar ? (y[0] = (_e * lr - ze * Oi + Ne * Gi) * (ar = 1 / ar), y[1] = (F * Oi - L * lr - Y * Gi) * ar, y[2] = (zt * gi - Dt * fi + ni * li) * ar, y[3] = (lt * fi - We * gi - yt * li) * ar, y[4] = (ze * zi - ce * lr - Ne * pi) * ar, y[5] = (G * lr - F * zi + Y * pi) * ar, y[6] = (Dt * ci - Bt * gi - ni * si) * ar, y[7] = (Ee * gi - lt * ci + yt * si) * ar, y[8] = (ce * Oi - _e * zi + Ne * Si) * ar, y[9] = (L * zi - G * Oi - Y * Si) * ar, y[10] = (Bt * fi - zt * ci + ni * Gt) * ar, y[11] = (We * ci - Ee * fi - yt * Gt) * ar, y[12] = (_e * pi - ce * Gi - ze * Si) * ar, y[13] = (G * Gi - L * pi + F * Si) * ar, y[14] = (zt * si - Bt * li - Dt * Gt) * ar, y[15] = (Ee * li - We * si + lt * Gt) * ar, y) : null;
          }, W.adjoint = function(y, B) {
            var G = B[0], L = B[1], F = B[2], Y = B[3], ce = B[4], _e = B[5], ze = B[6], Ne = B[7], Ee = B[8], We = B[9], lt = B[10], yt = B[11], Bt = B[12], zt = B[13], Dt = B[14], ni = B[15];
            return y[0] = _e * (lt * ni - yt * Dt) - We * (ze * ni - Ne * Dt) + zt * (ze * yt - Ne * lt), y[1] = -(L * (lt * ni - yt * Dt) - We * (F * ni - Y * Dt) + zt * (F * yt - Y * lt)), y[2] = L * (ze * ni - Ne * Dt) - _e * (F * ni - Y * Dt) + zt * (F * Ne - Y * ze), y[3] = -(L * (ze * yt - Ne * lt) - _e * (F * yt - Y * lt) + We * (F * Ne - Y * ze)), y[4] = -(ce * (lt * ni - yt * Dt) - Ee * (ze * ni - Ne * Dt) + Bt * (ze * yt - Ne * lt)), y[5] = G * (lt * ni - yt * Dt) - Ee * (F * ni - Y * Dt) + Bt * (F * yt - Y * lt), y[6] = -(G * (ze * ni - Ne * Dt) - ce * (F * ni - Y * Dt) + Bt * (F * Ne - Y * ze)), y[7] = G * (ze * yt - Ne * lt) - ce * (F * yt - Y * lt) + Ee * (F * Ne - Y * ze), y[8] = ce * (We * ni - yt * zt) - Ee * (_e * ni - Ne * zt) + Bt * (_e * yt - Ne * We), y[9] = -(G * (We * ni - yt * zt) - Ee * (L * ni - Y * zt) + Bt * (L * yt - Y * We)), y[10] = G * (_e * ni - Ne * zt) - ce * (L * ni - Y * zt) + Bt * (L * Ne - Y * _e), y[11] = -(G * (_e * yt - Ne * We) - ce * (L * yt - Y * We) + Ee * (L * Ne - Y * _e)), y[12] = -(ce * (We * Dt - lt * zt) - Ee * (_e * Dt - ze * zt) + Bt * (_e * lt - ze * We)), y[13] = G * (We * Dt - lt * zt) - Ee * (L * Dt - F * zt) + Bt * (L * lt - F * We), y[14] = -(G * (_e * Dt - ze * zt) - ce * (L * Dt - F * zt) + Bt * (L * ze - F * _e)), y[15] = G * (_e * lt - ze * We) - ce * (L * lt - F * We) + Ee * (L * ze - F * _e), y;
          }, W.determinant = function(y) {
            var B = y[0], G = y[1], L = y[2], F = y[3], Y = y[4], ce = y[5], _e = y[6], ze = y[7], Ne = y[8], Ee = y[9], We = y[10], lt = y[11], yt = y[12], Bt = y[13], zt = y[14], Dt = y[15];
            return (B * ce - G * Y) * (We * Dt - lt * zt) - (B * _e - L * Y) * (Ee * Dt - lt * Bt) + (B * ze - F * Y) * (Ee * zt - We * Bt) + (G * _e - L * ce) * (Ne * Dt - lt * yt) - (G * ze - F * ce) * (Ne * zt - We * yt) + (L * ze - F * _e) * (Ne * Bt - Ee * yt);
          }, W.multiply = h, W.translate = function(y, B, G) {
            var L, F, Y, ce, _e, ze, Ne, Ee, We, lt, yt, Bt, zt = G[0], Dt = G[1], ni = G[2];
            return B === y ? (y[12] = B[0] * zt + B[4] * Dt + B[8] * ni + B[12], y[13] = B[1] * zt + B[5] * Dt + B[9] * ni + B[13], y[14] = B[2] * zt + B[6] * Dt + B[10] * ni + B[14], y[15] = B[3] * zt + B[7] * Dt + B[11] * ni + B[15]) : (F = B[1], Y = B[2], ce = B[3], _e = B[4], ze = B[5], Ne = B[6], Ee = B[7], We = B[8], lt = B[9], yt = B[10], Bt = B[11], y[0] = L = B[0], y[1] = F, y[2] = Y, y[3] = ce, y[4] = _e, y[5] = ze, y[6] = Ne, y[7] = Ee, y[8] = We, y[9] = lt, y[10] = yt, y[11] = Bt, y[12] = L * zt + _e * Dt + We * ni + B[12], y[13] = F * zt + ze * Dt + lt * ni + B[13], y[14] = Y * zt + Ne * Dt + yt * ni + B[14], y[15] = ce * zt + Ee * Dt + Bt * ni + B[15]), y;
          }, W.scale = function(y, B, G) {
            var L = G[0], F = G[1], Y = G[2];
            return y[0] = B[0] * L, y[1] = B[1] * L, y[2] = B[2] * L, y[3] = B[3] * L, y[4] = B[4] * F, y[5] = B[5] * F, y[6] = B[6] * F, y[7] = B[7] * F, y[8] = B[8] * Y, y[9] = B[9] * Y, y[10] = B[10] * Y, y[11] = B[11] * Y, y[12] = B[12], y[13] = B[13], y[14] = B[14], y[15] = B[15], y;
          }, W.rotate = function(y, B, G, L) {
            var F, Y, ce, _e, ze, Ne, Ee, We, lt, yt, Bt, zt, Dt, ni, Gt, si, ci, li, fi, gi, Si, pi, zi, Gi, Oi = L[0], lr = L[1], ar = L[2], Qi = Math.hypot(Oi, lr, ar);
            return Qi < e.EPSILON ? null : (Oi *= Qi = 1 / Qi, lr *= Qi, ar *= Qi, F = Math.sin(G), Y = Math.cos(G), ze = B[1], Ne = B[2], Ee = B[3], lt = B[5], yt = B[6], Bt = B[7], Dt = B[9], ni = B[10], Gt = B[11], si = Oi * Oi * (ce = 1 - Y) + Y, fi = Oi * lr * ce - ar * F, gi = lr * lr * ce + Y, Si = ar * lr * ce + Oi * F, pi = Oi * ar * ce + lr * F, zi = lr * ar * ce - Oi * F, Gi = ar * ar * ce + Y, y[0] = (_e = B[0]) * si + (We = B[4]) * (ci = lr * Oi * ce + ar * F) + (zt = B[8]) * (li = ar * Oi * ce - lr * F), y[1] = ze * si + lt * ci + Dt * li, y[2] = Ne * si + yt * ci + ni * li, y[3] = Ee * si + Bt * ci + Gt * li, y[4] = _e * fi + We * gi + zt * Si, y[5] = ze * fi + lt * gi + Dt * Si, y[6] = Ne * fi + yt * gi + ni * Si, y[7] = Ee * fi + Bt * gi + Gt * Si, y[8] = _e * pi + We * zi + zt * Gi, y[9] = ze * pi + lt * zi + Dt * Gi, y[10] = Ne * pi + yt * zi + ni * Gi, y[11] = Ee * pi + Bt * zi + Gt * Gi, B !== y && (y[12] = B[12], y[13] = B[13], y[14] = B[14], y[15] = B[15]), y);
          }, W.rotateX = function(y, B, G) {
            var L = Math.sin(G), F = Math.cos(G), Y = B[4], ce = B[5], _e = B[6], ze = B[7], Ne = B[8], Ee = B[9], We = B[10], lt = B[11];
            return B !== y && (y[0] = B[0], y[1] = B[1], y[2] = B[2], y[3] = B[3], y[12] = B[12], y[13] = B[13], y[14] = B[14], y[15] = B[15]), y[4] = Y * F + Ne * L, y[5] = ce * F + Ee * L, y[6] = _e * F + We * L, y[7] = ze * F + lt * L, y[8] = Ne * F - Y * L, y[9] = Ee * F - ce * L, y[10] = We * F - _e * L, y[11] = lt * F - ze * L, y;
          }, W.rotateY = function(y, B, G) {
            var L = Math.sin(G), F = Math.cos(G), Y = B[0], ce = B[1], _e = B[2], ze = B[3], Ne = B[8], Ee = B[9], We = B[10], lt = B[11];
            return B !== y && (y[4] = B[4], y[5] = B[5], y[6] = B[6], y[7] = B[7], y[12] = B[12], y[13] = B[13], y[14] = B[14], y[15] = B[15]), y[0] = Y * F - Ne * L, y[1] = ce * F - Ee * L, y[2] = _e * F - We * L, y[3] = ze * F - lt * L, y[8] = Y * L + Ne * F, y[9] = ce * L + Ee * F, y[10] = _e * L + We * F, y[11] = ze * L + lt * F, y;
          }, W.rotateZ = function(y, B, G) {
            var L = Math.sin(G), F = Math.cos(G), Y = B[0], ce = B[1], _e = B[2], ze = B[3], Ne = B[4], Ee = B[5], We = B[6], lt = B[7];
            return B !== y && (y[8] = B[8], y[9] = B[9], y[10] = B[10], y[11] = B[11], y[12] = B[12], y[13] = B[13], y[14] = B[14], y[15] = B[15]), y[0] = Y * F + Ne * L, y[1] = ce * F + Ee * L, y[2] = _e * F + We * L, y[3] = ze * F + lt * L, y[4] = Ne * F - Y * L, y[5] = Ee * F - ce * L, y[6] = We * F - _e * L, y[7] = lt * F - ze * L, y;
          }, W.fromTranslation = function(y, B) {
            return y[0] = 1, y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[5] = 1, y[6] = 0, y[7] = 0, y[8] = 0, y[9] = 0, y[10] = 1, y[11] = 0, y[12] = B[0], y[13] = B[1], y[14] = B[2], y[15] = 1, y;
          }, W.fromScaling = function(y, B) {
            return y[0] = B[0], y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[5] = B[1], y[6] = 0, y[7] = 0, y[8] = 0, y[9] = 0, y[10] = B[2], y[11] = 0, y[12] = 0, y[13] = 0, y[14] = 0, y[15] = 1, y;
          }, W.fromRotation = function(y, B, G) {
            var L, F, Y, ce = G[0], _e = G[1], ze = G[2], Ne = Math.hypot(ce, _e, ze);
            return Ne < e.EPSILON ? null : (ce *= Ne = 1 / Ne, _e *= Ne, ze *= Ne, L = Math.sin(B), F = Math.cos(B), y[0] = ce * ce * (Y = 1 - F) + F, y[1] = _e * ce * Y + ze * L, y[2] = ze * ce * Y - _e * L, y[3] = 0, y[4] = ce * _e * Y - ze * L, y[5] = _e * _e * Y + F, y[6] = ze * _e * Y + ce * L, y[7] = 0, y[8] = ce * ze * Y + _e * L, y[9] = _e * ze * Y - ce * L, y[10] = ze * ze * Y + F, y[11] = 0, y[12] = 0, y[13] = 0, y[14] = 0, y[15] = 1, y);
          }, W.fromXRotation = function(y, B) {
            var G = Math.sin(B), L = Math.cos(B);
            return y[0] = 1, y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[5] = L, y[6] = G, y[7] = 0, y[8] = 0, y[9] = -G, y[10] = L, y[11] = 0, y[12] = 0, y[13] = 0, y[14] = 0, y[15] = 1, y;
          }, W.fromYRotation = function(y, B) {
            var G = Math.sin(B), L = Math.cos(B);
            return y[0] = L, y[1] = 0, y[2] = -G, y[3] = 0, y[4] = 0, y[5] = 1, y[6] = 0, y[7] = 0, y[8] = G, y[9] = 0, y[10] = L, y[11] = 0, y[12] = 0, y[13] = 0, y[14] = 0, y[15] = 1, y;
          }, W.fromZRotation = function(y, B) {
            var G = Math.sin(B), L = Math.cos(B);
            return y[0] = L, y[1] = G, y[2] = 0, y[3] = 0, y[4] = -G, y[5] = L, y[6] = 0, y[7] = 0, y[8] = 0, y[9] = 0, y[10] = 1, y[11] = 0, y[12] = 0, y[13] = 0, y[14] = 0, y[15] = 1, y;
          }, W.fromRotationTranslation = o, W.fromQuat2 = function(y, B) {
            var G = new e.ARRAY_TYPE(3), L = -B[0], F = -B[1], Y = -B[2], ce = B[3], _e = B[4], ze = B[5], Ne = B[6], Ee = B[7], We = L * L + F * F + Y * Y + ce * ce;
            return We > 0 ? (G[0] = 2 * (_e * ce + Ee * L + ze * Y - Ne * F) / We, G[1] = 2 * (ze * ce + Ee * F + Ne * L - _e * Y) / We, G[2] = 2 * (Ne * ce + Ee * Y + _e * F - ze * L) / We) : (G[0] = 2 * (_e * ce + Ee * L + ze * Y - Ne * F), G[1] = 2 * (ze * ce + Ee * F + Ne * L - _e * Y), G[2] = 2 * (Ne * ce + Ee * Y + _e * F - ze * L)), o(y, B, G), y;
          }, W.getTranslation = function(y, B) {
            return y[0] = B[12], y[1] = B[13], y[2] = B[14], y;
          }, W.getScaling = f, W.getRotation = function(y, B) {
            var G = new e.ARRAY_TYPE(3);
            f(G, B);
            var L = 1 / G[0], F = 1 / G[1], Y = 1 / G[2], ce = B[0] * L, _e = B[1] * F, ze = B[2] * Y, Ne = B[4] * L, Ee = B[5] * F, We = B[6] * Y, lt = B[8] * L, yt = B[9] * F, Bt = B[10] * Y, zt = ce + Ee + Bt, Dt = 0;
            return zt > 0 ? (Dt = 2 * Math.sqrt(zt + 1), y[3] = 0.25 * Dt, y[0] = (We - yt) / Dt, y[1] = (lt - ze) / Dt, y[2] = (_e - Ne) / Dt) : ce > Ee && ce > Bt ? (Dt = 2 * Math.sqrt(1 + ce - Ee - Bt), y[3] = (We - yt) / Dt, y[0] = 0.25 * Dt, y[1] = (_e + Ne) / Dt, y[2] = (lt + ze) / Dt) : Ee > Bt ? (Dt = 2 * Math.sqrt(1 + Ee - ce - Bt), y[3] = (lt - ze) / Dt, y[0] = (_e + Ne) / Dt, y[1] = 0.25 * Dt, y[2] = (We + yt) / Dt) : (Dt = 2 * Math.sqrt(1 + Bt - ce - Ee), y[3] = (_e - Ne) / Dt, y[0] = (lt + ze) / Dt, y[1] = (We + yt) / Dt, y[2] = 0.25 * Dt), y;
          }, W.fromRotationTranslationScale = function(y, B, G, L) {
            var F = B[0], Y = B[1], ce = B[2], _e = B[3], ze = F + F, Ne = Y + Y, Ee = ce + ce, We = F * ze, lt = F * Ne, yt = F * Ee, Bt = Y * Ne, zt = Y * Ee, Dt = ce * Ee, ni = _e * ze, Gt = _e * Ne, si = _e * Ee, ci = L[0], li = L[1], fi = L[2];
            return y[0] = (1 - (Bt + Dt)) * ci, y[1] = (lt + si) * ci, y[2] = (yt - Gt) * ci, y[3] = 0, y[4] = (lt - si) * li, y[5] = (1 - (We + Dt)) * li, y[6] = (zt + ni) * li, y[7] = 0, y[8] = (yt + Gt) * fi, y[9] = (zt - ni) * fi, y[10] = (1 - (We + Bt)) * fi, y[11] = 0, y[12] = G[0], y[13] = G[1], y[14] = G[2], y[15] = 1, y;
          }, W.fromRotationTranslationScaleOrigin = function(y, B, G, L, F) {
            var Y = B[0], ce = B[1], _e = B[2], ze = B[3], Ne = Y + Y, Ee = ce + ce, We = _e + _e, lt = Y * Ne, yt = Y * Ee, Bt = Y * We, zt = ce * Ee, Dt = ce * We, ni = _e * We, Gt = ze * Ne, si = ze * Ee, ci = ze * We, li = L[0], fi = L[1], gi = L[2], Si = F[0], pi = F[1], zi = F[2], Gi = (1 - (zt + ni)) * li, Oi = (yt + ci) * li, lr = (Bt - si) * li, ar = (yt - ci) * fi, Qi = (1 - (lt + ni)) * fi, qi = (Dt + Gt) * fi, xr = (Bt + si) * gi, hr = (Dt - Gt) * gi, pr = (1 - (lt + zt)) * gi;
            return y[0] = Gi, y[1] = Oi, y[2] = lr, y[3] = 0, y[4] = ar, y[5] = Qi, y[6] = qi, y[7] = 0, y[8] = xr, y[9] = hr, y[10] = pr, y[11] = 0, y[12] = G[0] + Si - (Gi * Si + ar * pi + xr * zi), y[13] = G[1] + pi - (Oi * Si + Qi * pi + hr * zi), y[14] = G[2] + zi - (lr * Si + qi * pi + pr * zi), y[15] = 1, y;
          }, W.fromQuat = function(y, B) {
            var G = B[0], L = B[1], F = B[2], Y = B[3], ce = G + G, _e = L + L, ze = F + F, Ne = G * ce, Ee = L * ce, We = L * _e, lt = F * ce, yt = F * _e, Bt = F * ze, zt = Y * ce, Dt = Y * _e, ni = Y * ze;
            return y[0] = 1 - We - Bt, y[1] = Ee + ni, y[2] = lt - Dt, y[3] = 0, y[4] = Ee - ni, y[5] = 1 - Ne - Bt, y[6] = yt + zt, y[7] = 0, y[8] = lt + Dt, y[9] = yt - zt, y[10] = 1 - Ne - We, y[11] = 0, y[12] = 0, y[13] = 0, y[14] = 0, y[15] = 1, y;
          }, W.frustum = function(y, B, G, L, F, Y, ce) {
            var _e = 1 / (G - B), ze = 1 / (F - L), Ne = 1 / (Y - ce);
            return y[0] = 2 * Y * _e, y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[5] = 2 * Y * ze, y[6] = 0, y[7] = 0, y[8] = (G + B) * _e, y[9] = (F + L) * ze, y[10] = (ce + Y) * Ne, y[11] = -1, y[12] = 0, y[13] = 0, y[14] = ce * Y * 2 * Ne, y[15] = 0, y;
          }, W.perspectiveNO = b, W.perspectiveZO = function(y, B, G, L, F) {
            var Y, ce = 1 / Math.tan(B / 2);
            return y[0] = ce / G, y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[5] = ce, y[6] = 0, y[7] = 0, y[8] = 0, y[9] = 0, y[11] = -1, y[12] = 0, y[13] = 0, y[15] = 0, F != null && F !== 1 / 0 ? (y[10] = F * (Y = 1 / (L - F)), y[14] = F * L * Y) : (y[10] = -1, y[14] = -L), y;
          }, W.perspectiveFromFieldOfView = function(y, B, G, L) {
            var F = Math.tan(B.upDegrees * Math.PI / 180), Y = Math.tan(B.downDegrees * Math.PI / 180), ce = Math.tan(B.leftDegrees * Math.PI / 180), _e = Math.tan(B.rightDegrees * Math.PI / 180), ze = 2 / (ce + _e), Ne = 2 / (F + Y);
            return y[0] = ze, y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[5] = Ne, y[6] = 0, y[7] = 0, y[8] = -(ce - _e) * ze * 0.5, y[9] = (F - Y) * Ne * 0.5, y[10] = L / (G - L), y[11] = -1, y[12] = 0, y[13] = 0, y[14] = L * G / (G - L), y[15] = 0, y;
          }, W.orthoNO = O, W.orthoZO = function(y, B, G, L, F, Y, ce) {
            var _e = 1 / (B - G), ze = 1 / (L - F), Ne = 1 / (Y - ce);
            return y[0] = -2 * _e, y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[5] = -2 * ze, y[6] = 0, y[7] = 0, y[8] = 0, y[9] = 0, y[10] = Ne, y[11] = 0, y[12] = (B + G) * _e, y[13] = (F + L) * ze, y[14] = Y * Ne, y[15] = 1, y;
          }, W.lookAt = function(y, B, G, L) {
            var F, Y, ce, _e, ze, Ne, Ee, We, lt, yt, Bt = B[0], zt = B[1], Dt = B[2], ni = L[0], Gt = L[1], si = L[2], ci = G[0], li = G[1], fi = G[2];
            return Math.abs(Bt - ci) < e.EPSILON && Math.abs(zt - li) < e.EPSILON && Math.abs(Dt - fi) < e.EPSILON ? s(y) : (Ee = Bt - ci, We = zt - li, lt = Dt - fi, F = Gt * (lt *= yt = 1 / Math.hypot(Ee, We, lt)) - si * (We *= yt), Y = si * (Ee *= yt) - ni * lt, ce = ni * We - Gt * Ee, (yt = Math.hypot(F, Y, ce)) ? (F *= yt = 1 / yt, Y *= yt, ce *= yt) : (F = 0, Y = 0, ce = 0), _e = We * ce - lt * Y, ze = lt * F - Ee * ce, Ne = Ee * Y - We * F, (yt = Math.hypot(_e, ze, Ne)) ? (_e *= yt = 1 / yt, ze *= yt, Ne *= yt) : (_e = 0, ze = 0, Ne = 0), y[0] = F, y[1] = _e, y[2] = Ee, y[3] = 0, y[4] = Y, y[5] = ze, y[6] = We, y[7] = 0, y[8] = ce, y[9] = Ne, y[10] = lt, y[11] = 0, y[12] = -(F * Bt + Y * zt + ce * Dt), y[13] = -(_e * Bt + ze * zt + Ne * Dt), y[14] = -(Ee * Bt + We * zt + lt * Dt), y[15] = 1, y);
          }, W.targetTo = function(y, B, G, L) {
            var F = B[0], Y = B[1], ce = B[2], _e = L[0], ze = L[1], Ne = L[2], Ee = F - G[0], We = Y - G[1], lt = ce - G[2], yt = Ee * Ee + We * We + lt * lt;
            yt > 0 && (Ee *= yt = 1 / Math.sqrt(yt), We *= yt, lt *= yt);
            var Bt = ze * lt - Ne * We, zt = Ne * Ee - _e * lt, Dt = _e * We - ze * Ee;
            return (yt = Bt * Bt + zt * zt + Dt * Dt) > 0 && (Bt *= yt = 1 / Math.sqrt(yt), zt *= yt, Dt *= yt), y[0] = Bt, y[1] = zt, y[2] = Dt, y[3] = 0, y[4] = We * Dt - lt * zt, y[5] = lt * Bt - Ee * Dt, y[6] = Ee * zt - We * Bt, y[7] = 0, y[8] = Ee, y[9] = We, y[10] = lt, y[11] = 0, y[12] = F, y[13] = Y, y[14] = ce, y[15] = 1, y;
          }, W.str = function(y) {
            return "mat4(" + y[0] + ", " + y[1] + ", " + y[2] + ", " + y[3] + ", " + y[4] + ", " + y[5] + ", " + y[6] + ", " + y[7] + ", " + y[8] + ", " + y[9] + ", " + y[10] + ", " + y[11] + ", " + y[12] + ", " + y[13] + ", " + y[14] + ", " + y[15] + ")";
          }, W.frob = function(y) {
            return Math.hypot(y[0], y[1], y[2], y[3], y[4], y[5], y[6], y[7], y[8], y[9], y[10], y[11], y[12], y[13], y[14], y[15]);
          }, W.add = function(y, B, G) {
            return y[0] = B[0] + G[0], y[1] = B[1] + G[1], y[2] = B[2] + G[2], y[3] = B[3] + G[3], y[4] = B[4] + G[4], y[5] = B[5] + G[5], y[6] = B[6] + G[6], y[7] = B[7] + G[7], y[8] = B[8] + G[8], y[9] = B[9] + G[9], y[10] = B[10] + G[10], y[11] = B[11] + G[11], y[12] = B[12] + G[12], y[13] = B[13] + G[13], y[14] = B[14] + G[14], y[15] = B[15] + G[15], y;
          }, W.subtract = H, W.multiplyScalar = function(y, B, G) {
            return y[0] = B[0] * G, y[1] = B[1] * G, y[2] = B[2] * G, y[3] = B[3] * G, y[4] = B[4] * G, y[5] = B[5] * G, y[6] = B[6] * G, y[7] = B[7] * G, y[8] = B[8] * G, y[9] = B[9] * G, y[10] = B[10] * G, y[11] = B[11] * G, y[12] = B[12] * G, y[13] = B[13] * G, y[14] = B[14] * G, y[15] = B[15] * G, y;
          }, W.multiplyScalarAndAdd = function(y, B, G, L) {
            return y[0] = B[0] + G[0] * L, y[1] = B[1] + G[1] * L, y[2] = B[2] + G[2] * L, y[3] = B[3] + G[3] * L, y[4] = B[4] + G[4] * L, y[5] = B[5] + G[5] * L, y[6] = B[6] + G[6] * L, y[7] = B[7] + G[7] * L, y[8] = B[8] + G[8] * L, y[9] = B[9] + G[9] * L, y[10] = B[10] + G[10] * L, y[11] = B[11] + G[11] * L, y[12] = B[12] + G[12] * L, y[13] = B[13] + G[13] * L, y[14] = B[14] + G[14] * L, y[15] = B[15] + G[15] * L, y;
          }, W.exactEquals = function(y, B) {
            return y[0] === B[0] && y[1] === B[1] && y[2] === B[2] && y[3] === B[3] && y[4] === B[4] && y[5] === B[5] && y[6] === B[6] && y[7] === B[7] && y[8] === B[8] && y[9] === B[9] && y[10] === B[10] && y[11] === B[11] && y[12] === B[12] && y[13] === B[13] && y[14] === B[14] && y[15] === B[15];
          }, W.equals = function(y, B) {
            var G = y[0], L = y[1], F = y[2], Y = y[3], ce = y[4], _e = y[5], ze = y[6], Ne = y[7], Ee = y[8], We = y[9], lt = y[10], yt = y[11], Bt = y[12], zt = y[13], Dt = y[14], ni = y[15], Gt = B[0], si = B[1], ci = B[2], li = B[3], fi = B[4], gi = B[5], Si = B[6], pi = B[7], zi = B[8], Gi = B[9], Oi = B[10], lr = B[11], ar = B[12], Qi = B[13], qi = B[14], xr = B[15];
            return Math.abs(G - Gt) <= e.EPSILON * Math.max(1, Math.abs(G), Math.abs(Gt)) && Math.abs(L - si) <= e.EPSILON * Math.max(1, Math.abs(L), Math.abs(si)) && Math.abs(F - ci) <= e.EPSILON * Math.max(1, Math.abs(F), Math.abs(ci)) && Math.abs(Y - li) <= e.EPSILON * Math.max(1, Math.abs(Y), Math.abs(li)) && Math.abs(ce - fi) <= e.EPSILON * Math.max(1, Math.abs(ce), Math.abs(fi)) && Math.abs(_e - gi) <= e.EPSILON * Math.max(1, Math.abs(_e), Math.abs(gi)) && Math.abs(ze - Si) <= e.EPSILON * Math.max(1, Math.abs(ze), Math.abs(Si)) && Math.abs(Ne - pi) <= e.EPSILON * Math.max(1, Math.abs(Ne), Math.abs(pi)) && Math.abs(Ee - zi) <= e.EPSILON * Math.max(1, Math.abs(Ee), Math.abs(zi)) && Math.abs(We - Gi) <= e.EPSILON * Math.max(1, Math.abs(We), Math.abs(Gi)) && Math.abs(lt - Oi) <= e.EPSILON * Math.max(1, Math.abs(lt), Math.abs(Oi)) && Math.abs(yt - lr) <= e.EPSILON * Math.max(1, Math.abs(yt), Math.abs(lr)) && Math.abs(Bt - ar) <= e.EPSILON * Math.max(1, Math.abs(Bt), Math.abs(ar)) && Math.abs(zt - Qi) <= e.EPSILON * Math.max(1, Math.abs(zt), Math.abs(Qi)) && Math.abs(Dt - qi) <= e.EPSILON * Math.max(1, Math.abs(Dt), Math.abs(qi)) && Math.abs(ni - xr) <= e.EPSILON * Math.max(1, Math.abs(ni), Math.abs(xr));
          }, W.sub = W.mul = W.ortho = W.perspective = void 0;
          var e = function(y, B) {
            if (y && y.__esModule) return y;
            if (y === null || a(y) !== "object" && typeof y != "function") return { default: y };
            var G = r(void 0);
            if (G && G.has(y)) return G.get(y);
            var L = {}, F = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var Y in y) if (Y !== "default" && Object.prototype.hasOwnProperty.call(y, Y)) {
              var ce = F ? Object.getOwnPropertyDescriptor(y, Y) : null;
              ce && (ce.get || ce.set) ? Object.defineProperty(L, Y, ce) : L[Y] = y[Y];
            }
            return L.default = y, G && G.set(y, L), L;
          }(M());
          function r(y) {
            if (typeof WeakMap != "function") return null;
            var B = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap();
            return (r = function(L) {
              return L ? G : B;
            })(y);
          }
          function s(y) {
            return y[0] = 1, y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[5] = 1, y[6] = 0, y[7] = 0, y[8] = 0, y[9] = 0, y[10] = 1, y[11] = 0, y[12] = 0, y[13] = 0, y[14] = 0, y[15] = 1, y;
          }
          function h(y, B, G) {
            var L = B[0], F = B[1], Y = B[2], ce = B[3], _e = B[4], ze = B[5], Ne = B[6], Ee = B[7], We = B[8], lt = B[9], yt = B[10], Bt = B[11], zt = B[12], Dt = B[13], ni = B[14], Gt = B[15], si = G[0], ci = G[1], li = G[2], fi = G[3];
            return y[0] = si * L + ci * _e + li * We + fi * zt, y[1] = si * F + ci * ze + li * lt + fi * Dt, y[2] = si * Y + ci * Ne + li * yt + fi * ni, y[3] = si * ce + ci * Ee + li * Bt + fi * Gt, y[4] = (si = G[4]) * L + (ci = G[5]) * _e + (li = G[6]) * We + (fi = G[7]) * zt, y[5] = si * F + ci * ze + li * lt + fi * Dt, y[6] = si * Y + ci * Ne + li * yt + fi * ni, y[7] = si * ce + ci * Ee + li * Bt + fi * Gt, y[8] = (si = G[8]) * L + (ci = G[9]) * _e + (li = G[10]) * We + (fi = G[11]) * zt, y[9] = si * F + ci * ze + li * lt + fi * Dt, y[10] = si * Y + ci * Ne + li * yt + fi * ni, y[11] = si * ce + ci * Ee + li * Bt + fi * Gt, y[12] = (si = G[12]) * L + (ci = G[13]) * _e + (li = G[14]) * We + (fi = G[15]) * zt, y[13] = si * F + ci * ze + li * lt + fi * Dt, y[14] = si * Y + ci * Ne + li * yt + fi * ni, y[15] = si * ce + ci * Ee + li * Bt + fi * Gt, y;
          }
          function o(y, B, G) {
            var L = B[0], F = B[1], Y = B[2], ce = B[3], _e = L + L, ze = F + F, Ne = Y + Y, Ee = L * _e, We = L * ze, lt = L * Ne, yt = F * ze, Bt = F * Ne, zt = Y * Ne, Dt = ce * _e, ni = ce * ze, Gt = ce * Ne;
            return y[0] = 1 - (yt + zt), y[1] = We + Gt, y[2] = lt - ni, y[3] = 0, y[4] = We - Gt, y[5] = 1 - (Ee + zt), y[6] = Bt + Dt, y[7] = 0, y[8] = lt + ni, y[9] = Bt - Dt, y[10] = 1 - (Ee + yt), y[11] = 0, y[12] = G[0], y[13] = G[1], y[14] = G[2], y[15] = 1, y;
          }
          function f(y, B) {
            var G = B[4], L = B[5], F = B[6], Y = B[8], ce = B[9], _e = B[10];
            return y[0] = Math.hypot(B[0], B[1], B[2]), y[1] = Math.hypot(G, L, F), y[2] = Math.hypot(Y, ce, _e), y;
          }
          function b(y, B, G, L, F) {
            var Y, ce = 1 / Math.tan(B / 2);
            return y[0] = ce / G, y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[5] = ce, y[6] = 0, y[7] = 0, y[8] = 0, y[9] = 0, y[11] = -1, y[12] = 0, y[13] = 0, y[15] = 0, F != null && F !== 1 / 0 ? (y[10] = (F + L) * (Y = 1 / (L - F)), y[14] = 2 * F * L * Y) : (y[10] = -1, y[14] = -2 * L), y;
          }
          function O(y, B, G, L, F, Y, ce) {
            var _e = 1 / (B - G), ze = 1 / (L - F), Ne = 1 / (Y - ce);
            return y[0] = -2 * _e, y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[5] = -2 * ze, y[6] = 0, y[7] = 0, y[8] = 0, y[9] = 0, y[10] = 2 * Ne, y[11] = 0, y[12] = (B + G) * _e, y[13] = (F + L) * ze, y[14] = (ce + Y) * Ne, y[15] = 1, y;
          }
          function H(y, B, G) {
            return y[0] = B[0] - G[0], y[1] = B[1] - G[1], y[2] = B[2] - G[2], y[3] = B[3] - G[3], y[4] = B[4] - G[4], y[5] = B[5] - G[5], y[6] = B[6] - G[6], y[7] = B[7] - G[7], y[8] = B[8] - G[8], y[9] = B[9] - G[9], y[10] = B[10] - G[10], y[11] = B[11] - G[11], y[12] = B[12] - G[12], y[13] = B[13] - G[13], y[14] = B[14] - G[14], y[15] = B[15] - G[15], y;
          }
          return W.perspective = b, W.ortho = O, W.mul = h, W.sub = H, W;
        }
        var ee, te = {}, le = {};
        function me() {
          if (ee) return le;
          function a(F) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Y) {
              return typeof Y;
            } : function(Y) {
              return Y && typeof Symbol == "function" && Y.constructor === Symbol && Y !== Symbol.prototype ? "symbol" : typeof Y;
            }, a(F);
          }
          ee = 1, Object.defineProperty(le, "__esModule", { value: !0 }), le.create = s, le.clone = function(F) {
            var Y = new e.ARRAY_TYPE(3);
            return Y[0] = F[0], Y[1] = F[1], Y[2] = F[2], Y;
          }, le.length = h, le.fromValues = function(F, Y, ce) {
            var _e = new e.ARRAY_TYPE(3);
            return _e[0] = F, _e[1] = Y, _e[2] = ce, _e;
          }, le.copy = function(F, Y) {
            return F[0] = Y[0], F[1] = Y[1], F[2] = Y[2], F;
          }, le.set = function(F, Y, ce, _e) {
            return F[0] = Y, F[1] = ce, F[2] = _e, F;
          }, le.add = function(F, Y, ce) {
            return F[0] = Y[0] + ce[0], F[1] = Y[1] + ce[1], F[2] = Y[2] + ce[2], F;
          }, le.subtract = o, le.multiply = f, le.divide = b, le.ceil = function(F, Y) {
            return F[0] = Math.ceil(Y[0]), F[1] = Math.ceil(Y[1]), F[2] = Math.ceil(Y[2]), F;
          }, le.floor = function(F, Y) {
            return F[0] = Math.floor(Y[0]), F[1] = Math.floor(Y[1]), F[2] = Math.floor(Y[2]), F;
          }, le.min = function(F, Y, ce) {
            return F[0] = Math.min(Y[0], ce[0]), F[1] = Math.min(Y[1], ce[1]), F[2] = Math.min(Y[2], ce[2]), F;
          }, le.max = function(F, Y, ce) {
            return F[0] = Math.max(Y[0], ce[0]), F[1] = Math.max(Y[1], ce[1]), F[2] = Math.max(Y[2], ce[2]), F;
          }, le.round = function(F, Y) {
            return F[0] = Math.round(Y[0]), F[1] = Math.round(Y[1]), F[2] = Math.round(Y[2]), F;
          }, le.scale = function(F, Y, ce) {
            return F[0] = Y[0] * ce, F[1] = Y[1] * ce, F[2] = Y[2] * ce, F;
          }, le.scaleAndAdd = function(F, Y, ce, _e) {
            return F[0] = Y[0] + ce[0] * _e, F[1] = Y[1] + ce[1] * _e, F[2] = Y[2] + ce[2] * _e, F;
          }, le.distance = O, le.squaredDistance = H, le.squaredLength = y, le.negate = function(F, Y) {
            return F[0] = -Y[0], F[1] = -Y[1], F[2] = -Y[2], F;
          }, le.inverse = function(F, Y) {
            return F[0] = 1 / Y[0], F[1] = 1 / Y[1], F[2] = 1 / Y[2], F;
          }, le.normalize = function(F, Y) {
            var ce = Y[0], _e = Y[1], ze = Y[2], Ne = ce * ce + _e * _e + ze * ze;
            return Ne > 0 && (Ne = 1 / Math.sqrt(Ne)), F[0] = Y[0] * Ne, F[1] = Y[1] * Ne, F[2] = Y[2] * Ne, F;
          }, le.dot = B, le.cross = function(F, Y, ce) {
            var _e = Y[0], ze = Y[1], Ne = Y[2], Ee = ce[0], We = ce[1], lt = ce[2];
            return F[0] = ze * lt - Ne * We, F[1] = Ne * Ee - _e * lt, F[2] = _e * We - ze * Ee, F;
          }, le.lerp = function(F, Y, ce, _e) {
            var ze = Y[0], Ne = Y[1], Ee = Y[2];
            return F[0] = ze + _e * (ce[0] - ze), F[1] = Ne + _e * (ce[1] - Ne), F[2] = Ee + _e * (ce[2] - Ee), F;
          }, le.hermite = function(F, Y, ce, _e, ze, Ne) {
            var Ee = Ne * Ne, We = Ee * (2 * Ne - 3) + 1, lt = Ee * (Ne - 2) + Ne, yt = Ee * (Ne - 1), Bt = Ee * (3 - 2 * Ne);
            return F[0] = Y[0] * We + ce[0] * lt + _e[0] * yt + ze[0] * Bt, F[1] = Y[1] * We + ce[1] * lt + _e[1] * yt + ze[1] * Bt, F[2] = Y[2] * We + ce[2] * lt + _e[2] * yt + ze[2] * Bt, F;
          }, le.bezier = function(F, Y, ce, _e, ze, Ne) {
            var Ee = 1 - Ne, We = Ee * Ee, lt = Ne * Ne, yt = We * Ee, Bt = 3 * Ne * We, zt = 3 * lt * Ee, Dt = lt * Ne;
            return F[0] = Y[0] * yt + ce[0] * Bt + _e[0] * zt + ze[0] * Dt, F[1] = Y[1] * yt + ce[1] * Bt + _e[1] * zt + ze[1] * Dt, F[2] = Y[2] * yt + ce[2] * Bt + _e[2] * zt + ze[2] * Dt, F;
          }, le.random = function(F, Y) {
            Y = Y || 1;
            var ce = 2 * e.RANDOM() * Math.PI, _e = 2 * e.RANDOM() - 1, ze = Math.sqrt(1 - _e * _e) * Y;
            return F[0] = Math.cos(ce) * ze, F[1] = Math.sin(ce) * ze, F[2] = _e * Y, F;
          }, le.transformMat4 = function(F, Y, ce) {
            var _e = Y[0], ze = Y[1], Ne = Y[2], Ee = ce[3] * _e + ce[7] * ze + ce[11] * Ne + ce[15];
            return F[0] = (ce[0] * _e + ce[4] * ze + ce[8] * Ne + ce[12]) / (Ee = Ee || 1), F[1] = (ce[1] * _e + ce[5] * ze + ce[9] * Ne + ce[13]) / Ee, F[2] = (ce[2] * _e + ce[6] * ze + ce[10] * Ne + ce[14]) / Ee, F;
          }, le.transformMat3 = function(F, Y, ce) {
            var _e = Y[0], ze = Y[1], Ne = Y[2];
            return F[0] = _e * ce[0] + ze * ce[3] + Ne * ce[6], F[1] = _e * ce[1] + ze * ce[4] + Ne * ce[7], F[2] = _e * ce[2] + ze * ce[5] + Ne * ce[8], F;
          }, le.transformQuat = function(F, Y, ce) {
            var _e = ce[0], ze = ce[1], Ne = ce[2], Ee = Y[0], We = Y[1], lt = Y[2], yt = ze * lt - Ne * We, Bt = Ne * Ee - _e * lt, zt = _e * We - ze * Ee, Dt = ze * zt - Ne * Bt, ni = Ne * yt - _e * zt, Gt = _e * Bt - ze * yt, si = 2 * ce[3];
            return Bt *= si, zt *= si, ni *= 2, Gt *= 2, F[0] = Ee + (yt *= si) + (Dt *= 2), F[1] = We + Bt + ni, F[2] = lt + zt + Gt, F;
          }, le.rotateX = function(F, Y, ce, _e) {
            var ze = [], Ne = [];
            return ze[0] = Y[0] - ce[0], ze[1] = Y[1] - ce[1], ze[2] = Y[2] - ce[2], Ne[0] = ze[0], Ne[1] = ze[1] * Math.cos(_e) - ze[2] * Math.sin(_e), Ne[2] = ze[1] * Math.sin(_e) + ze[2] * Math.cos(_e), F[0] = Ne[0] + ce[0], F[1] = Ne[1] + ce[1], F[2] = Ne[2] + ce[2], F;
          }, le.rotateY = function(F, Y, ce, _e) {
            var ze = [], Ne = [];
            return ze[0] = Y[0] - ce[0], ze[1] = Y[1] - ce[1], ze[2] = Y[2] - ce[2], Ne[0] = ze[2] * Math.sin(_e) + ze[0] * Math.cos(_e), Ne[1] = ze[1], Ne[2] = ze[2] * Math.cos(_e) - ze[0] * Math.sin(_e), F[0] = Ne[0] + ce[0], F[1] = Ne[1] + ce[1], F[2] = Ne[2] + ce[2], F;
          }, le.rotateZ = function(F, Y, ce, _e) {
            var ze = [], Ne = [];
            return ze[0] = Y[0] - ce[0], ze[1] = Y[1] - ce[1], ze[2] = Y[2] - ce[2], Ne[0] = ze[0] * Math.cos(_e) - ze[1] * Math.sin(_e), Ne[1] = ze[0] * Math.sin(_e) + ze[1] * Math.cos(_e), Ne[2] = ze[2], F[0] = Ne[0] + ce[0], F[1] = Ne[1] + ce[1], F[2] = Ne[2] + ce[2], F;
          }, le.angle = function(F, Y) {
            var ce = F[0], _e = F[1], ze = F[2], Ne = Y[0], Ee = Y[1], We = Y[2], lt = Math.sqrt(ce * ce + _e * _e + ze * ze) * Math.sqrt(Ne * Ne + Ee * Ee + We * We), yt = lt && B(F, Y) / lt;
            return Math.acos(Math.min(Math.max(yt, -1), 1));
          }, le.zero = function(F) {
            return F[0] = 0, F[1] = 0, F[2] = 0, F;
          }, le.str = function(F) {
            return "vec3(" + F[0] + ", " + F[1] + ", " + F[2] + ")";
          }, le.exactEquals = function(F, Y) {
            return F[0] === Y[0] && F[1] === Y[1] && F[2] === Y[2];
          }, le.equals = function(F, Y) {
            var ce = F[0], _e = F[1], ze = F[2], Ne = Y[0], Ee = Y[1], We = Y[2];
            return Math.abs(ce - Ne) <= e.EPSILON * Math.max(1, Math.abs(ce), Math.abs(Ne)) && Math.abs(_e - Ee) <= e.EPSILON * Math.max(1, Math.abs(_e), Math.abs(Ee)) && Math.abs(ze - We) <= e.EPSILON * Math.max(1, Math.abs(ze), Math.abs(We));
          }, le.forEach = le.sqrLen = le.len = le.sqrDist = le.dist = le.div = le.mul = le.sub = void 0;
          var e = function(F, Y) {
            if (F && F.__esModule) return F;
            if (F === null || a(F) !== "object" && typeof F != "function") return { default: F };
            var ce = r(void 0);
            if (ce && ce.has(F)) return ce.get(F);
            var _e = {}, ze = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var Ne in F) if (Ne !== "default" && Object.prototype.hasOwnProperty.call(F, Ne)) {
              var Ee = ze ? Object.getOwnPropertyDescriptor(F, Ne) : null;
              Ee && (Ee.get || Ee.set) ? Object.defineProperty(_e, Ne, Ee) : _e[Ne] = F[Ne];
            }
            return _e.default = F, ce && ce.set(F, _e), _e;
          }(M());
          function r(F) {
            if (typeof WeakMap != "function") return null;
            var Y = /* @__PURE__ */ new WeakMap(), ce = /* @__PURE__ */ new WeakMap();
            return (r = function(_e) {
              return _e ? ce : Y;
            })(F);
          }
          function s() {
            var F = new e.ARRAY_TYPE(3);
            return e.ARRAY_TYPE != Float32Array && (F[0] = 0, F[1] = 0, F[2] = 0), F;
          }
          function h(F) {
            return Math.hypot(F[0], F[1], F[2]);
          }
          function o(F, Y, ce) {
            return F[0] = Y[0] - ce[0], F[1] = Y[1] - ce[1], F[2] = Y[2] - ce[2], F;
          }
          function f(F, Y, ce) {
            return F[0] = Y[0] * ce[0], F[1] = Y[1] * ce[1], F[2] = Y[2] * ce[2], F;
          }
          function b(F, Y, ce) {
            return F[0] = Y[0] / ce[0], F[1] = Y[1] / ce[1], F[2] = Y[2] / ce[2], F;
          }
          function O(F, Y) {
            return Math.hypot(Y[0] - F[0], Y[1] - F[1], Y[2] - F[2]);
          }
          function H(F, Y) {
            var ce = Y[0] - F[0], _e = Y[1] - F[1], ze = Y[2] - F[2];
            return ce * ce + _e * _e + ze * ze;
          }
          function y(F) {
            var Y = F[0], ce = F[1], _e = F[2];
            return Y * Y + ce * ce + _e * _e;
          }
          function B(F, Y) {
            return F[0] * Y[0] + F[1] * Y[1] + F[2] * Y[2];
          }
          le.sub = o, le.mul = f, le.div = b, le.dist = O, le.sqrDist = H, le.len = h, le.sqrLen = y;
          var G, L = (G = s(), function(F, Y, ce, _e, ze, Ne) {
            var Ee, We;
            for (Y || (Y = 3), ce || (ce = 0), We = _e ? Math.min(_e * Y + ce, F.length) : F.length, Ee = ce; Ee < We; Ee += Y) G[0] = F[Ee], G[1] = F[Ee + 1], G[2] = F[Ee + 2], ze(G, G, Ne), F[Ee] = G[0], F[Ee + 1] = G[1], F[Ee + 2] = G[2];
            return F;
          });
          return le.forEach = L, le;
        }
        var ke, ge, Ve = {};
        function Oe() {
          if (ke) return Ve;
          function a(L) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(F) {
              return typeof F;
            } : function(F) {
              return F && typeof Symbol == "function" && F.constructor === Symbol && F !== Symbol.prototype ? "symbol" : typeof F;
            }, a(L);
          }
          ke = 1, Object.defineProperty(Ve, "__esModule", { value: !0 }), Ve.create = s, Ve.clone = function(L) {
            var F = new e.ARRAY_TYPE(4);
            return F[0] = L[0], F[1] = L[1], F[2] = L[2], F[3] = L[3], F;
          }, Ve.fromValues = function(L, F, Y, ce) {
            var _e = new e.ARRAY_TYPE(4);
            return _e[0] = L, _e[1] = F, _e[2] = Y, _e[3] = ce, _e;
          }, Ve.copy = function(L, F) {
            return L[0] = F[0], L[1] = F[1], L[2] = F[2], L[3] = F[3], L;
          }, Ve.set = function(L, F, Y, ce, _e) {
            return L[0] = F, L[1] = Y, L[2] = ce, L[3] = _e, L;
          }, Ve.add = function(L, F, Y) {
            return L[0] = F[0] + Y[0], L[1] = F[1] + Y[1], L[2] = F[2] + Y[2], L[3] = F[3] + Y[3], L;
          }, Ve.subtract = h, Ve.multiply = o, Ve.divide = f, Ve.ceil = function(L, F) {
            return L[0] = Math.ceil(F[0]), L[1] = Math.ceil(F[1]), L[2] = Math.ceil(F[2]), L[3] = Math.ceil(F[3]), L;
          }, Ve.floor = function(L, F) {
            return L[0] = Math.floor(F[0]), L[1] = Math.floor(F[1]), L[2] = Math.floor(F[2]), L[3] = Math.floor(F[3]), L;
          }, Ve.min = function(L, F, Y) {
            return L[0] = Math.min(F[0], Y[0]), L[1] = Math.min(F[1], Y[1]), L[2] = Math.min(F[2], Y[2]), L[3] = Math.min(F[3], Y[3]), L;
          }, Ve.max = function(L, F, Y) {
            return L[0] = Math.max(F[0], Y[0]), L[1] = Math.max(F[1], Y[1]), L[2] = Math.max(F[2], Y[2]), L[3] = Math.max(F[3], Y[3]), L;
          }, Ve.round = function(L, F) {
            return L[0] = Math.round(F[0]), L[1] = Math.round(F[1]), L[2] = Math.round(F[2]), L[3] = Math.round(F[3]), L;
          }, Ve.scale = function(L, F, Y) {
            return L[0] = F[0] * Y, L[1] = F[1] * Y, L[2] = F[2] * Y, L[3] = F[3] * Y, L;
          }, Ve.scaleAndAdd = function(L, F, Y, ce) {
            return L[0] = F[0] + Y[0] * ce, L[1] = F[1] + Y[1] * ce, L[2] = F[2] + Y[2] * ce, L[3] = F[3] + Y[3] * ce, L;
          }, Ve.distance = b, Ve.squaredDistance = O, Ve.length = H, Ve.squaredLength = y, Ve.negate = function(L, F) {
            return L[0] = -F[0], L[1] = -F[1], L[2] = -F[2], L[3] = -F[3], L;
          }, Ve.inverse = function(L, F) {
            return L[0] = 1 / F[0], L[1] = 1 / F[1], L[2] = 1 / F[2], L[3] = 1 / F[3], L;
          }, Ve.normalize = function(L, F) {
            var Y = F[0], ce = F[1], _e = F[2], ze = F[3], Ne = Y * Y + ce * ce + _e * _e + ze * ze;
            return Ne > 0 && (Ne = 1 / Math.sqrt(Ne)), L[0] = Y * Ne, L[1] = ce * Ne, L[2] = _e * Ne, L[3] = ze * Ne, L;
          }, Ve.dot = function(L, F) {
            return L[0] * F[0] + L[1] * F[1] + L[2] * F[2] + L[3] * F[3];
          }, Ve.cross = function(L, F, Y, ce) {
            var _e = Y[0] * ce[1] - Y[1] * ce[0], ze = Y[0] * ce[2] - Y[2] * ce[0], Ne = Y[0] * ce[3] - Y[3] * ce[0], Ee = Y[1] * ce[2] - Y[2] * ce[1], We = Y[1] * ce[3] - Y[3] * ce[1], lt = Y[2] * ce[3] - Y[3] * ce[2], yt = F[0], Bt = F[1], zt = F[2], Dt = F[3];
            return L[0] = Bt * lt - zt * We + Dt * Ee, L[1] = -yt * lt + zt * Ne - Dt * ze, L[2] = yt * We - Bt * Ne + Dt * _e, L[3] = -yt * Ee + Bt * ze - zt * _e, L;
          }, Ve.lerp = function(L, F, Y, ce) {
            var _e = F[0], ze = F[1], Ne = F[2], Ee = F[3];
            return L[0] = _e + ce * (Y[0] - _e), L[1] = ze + ce * (Y[1] - ze), L[2] = Ne + ce * (Y[2] - Ne), L[3] = Ee + ce * (Y[3] - Ee), L;
          }, Ve.random = function(L, F) {
            var Y, ce, _e, ze, Ne, Ee;
            F = F || 1;
            do
              Ne = (Y = 2 * e.RANDOM() - 1) * Y + (ce = 2 * e.RANDOM() - 1) * ce;
            while (Ne >= 1);
            do
              Ee = (_e = 2 * e.RANDOM() - 1) * _e + (ze = 2 * e.RANDOM() - 1) * ze;
            while (Ee >= 1);
            var We = Math.sqrt((1 - Ne) / Ee);
            return L[0] = F * Y, L[1] = F * ce, L[2] = F * _e * We, L[3] = F * ze * We, L;
          }, Ve.transformMat4 = function(L, F, Y) {
            var ce = F[0], _e = F[1], ze = F[2], Ne = F[3];
            return L[0] = Y[0] * ce + Y[4] * _e + Y[8] * ze + Y[12] * Ne, L[1] = Y[1] * ce + Y[5] * _e + Y[9] * ze + Y[13] * Ne, L[2] = Y[2] * ce + Y[6] * _e + Y[10] * ze + Y[14] * Ne, L[3] = Y[3] * ce + Y[7] * _e + Y[11] * ze + Y[15] * Ne, L;
          }, Ve.transformQuat = function(L, F, Y) {
            var ce = F[0], _e = F[1], ze = F[2], Ne = Y[0], Ee = Y[1], We = Y[2], lt = Y[3], yt = lt * ce + Ee * ze - We * _e, Bt = lt * _e + We * ce - Ne * ze, zt = lt * ze + Ne * _e - Ee * ce, Dt = -Ne * ce - Ee * _e - We * ze;
            return L[0] = yt * lt + Dt * -Ne + Bt * -We - zt * -Ee, L[1] = Bt * lt + Dt * -Ee + zt * -Ne - yt * -We, L[2] = zt * lt + Dt * -We + yt * -Ee - Bt * -Ne, L[3] = F[3], L;
          }, Ve.zero = function(L) {
            return L[0] = 0, L[1] = 0, L[2] = 0, L[3] = 0, L;
          }, Ve.str = function(L) {
            return "vec4(" + L[0] + ", " + L[1] + ", " + L[2] + ", " + L[3] + ")";
          }, Ve.exactEquals = function(L, F) {
            return L[0] === F[0] && L[1] === F[1] && L[2] === F[2] && L[3] === F[3];
          }, Ve.equals = function(L, F) {
            var Y = L[0], ce = L[1], _e = L[2], ze = L[3], Ne = F[0], Ee = F[1], We = F[2], lt = F[3];
            return Math.abs(Y - Ne) <= e.EPSILON * Math.max(1, Math.abs(Y), Math.abs(Ne)) && Math.abs(ce - Ee) <= e.EPSILON * Math.max(1, Math.abs(ce), Math.abs(Ee)) && Math.abs(_e - We) <= e.EPSILON * Math.max(1, Math.abs(_e), Math.abs(We)) && Math.abs(ze - lt) <= e.EPSILON * Math.max(1, Math.abs(ze), Math.abs(lt));
          }, Ve.forEach = Ve.sqrLen = Ve.len = Ve.sqrDist = Ve.dist = Ve.div = Ve.mul = Ve.sub = void 0;
          var e = function(L, F) {
            if (L && L.__esModule) return L;
            if (L === null || a(L) !== "object" && typeof L != "function") return { default: L };
            var Y = r(void 0);
            if (Y && Y.has(L)) return Y.get(L);
            var ce = {}, _e = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var ze in L) if (ze !== "default" && Object.prototype.hasOwnProperty.call(L, ze)) {
              var Ne = _e ? Object.getOwnPropertyDescriptor(L, ze) : null;
              Ne && (Ne.get || Ne.set) ? Object.defineProperty(ce, ze, Ne) : ce[ze] = L[ze];
            }
            return ce.default = L, Y && Y.set(L, ce), ce;
          }(M());
          function r(L) {
            if (typeof WeakMap != "function") return null;
            var F = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap();
            return (r = function(ce) {
              return ce ? Y : F;
            })(L);
          }
          function s() {
            var L = new e.ARRAY_TYPE(4);
            return e.ARRAY_TYPE != Float32Array && (L[0] = 0, L[1] = 0, L[2] = 0, L[3] = 0), L;
          }
          function h(L, F, Y) {
            return L[0] = F[0] - Y[0], L[1] = F[1] - Y[1], L[2] = F[2] - Y[2], L[3] = F[3] - Y[3], L;
          }
          function o(L, F, Y) {
            return L[0] = F[0] * Y[0], L[1] = F[1] * Y[1], L[2] = F[2] * Y[2], L[3] = F[3] * Y[3], L;
          }
          function f(L, F, Y) {
            return L[0] = F[0] / Y[0], L[1] = F[1] / Y[1], L[2] = F[2] / Y[2], L[3] = F[3] / Y[3], L;
          }
          function b(L, F) {
            return Math.hypot(F[0] - L[0], F[1] - L[1], F[2] - L[2], F[3] - L[3]);
          }
          function O(L, F) {
            var Y = F[0] - L[0], ce = F[1] - L[1], _e = F[2] - L[2], ze = F[3] - L[3];
            return Y * Y + ce * ce + _e * _e + ze * ze;
          }
          function H(L) {
            return Math.hypot(L[0], L[1], L[2], L[3]);
          }
          function y(L) {
            var F = L[0], Y = L[1], ce = L[2], _e = L[3];
            return F * F + Y * Y + ce * ce + _e * _e;
          }
          Ve.sub = h, Ve.mul = o, Ve.div = f, Ve.dist = b, Ve.sqrDist = O, Ve.len = H, Ve.sqrLen = y;
          var B, G = (B = s(), function(L, F, Y, ce, _e, ze) {
            var Ne, Ee;
            for (F || (F = 4), Y || (Y = 0), Ee = ce ? Math.min(ce * F + Y, L.length) : L.length, Ne = Y; Ne < Ee; Ne += F) B[0] = L[Ne], B[1] = L[Ne + 1], B[2] = L[Ne + 2], B[3] = L[Ne + 3], _e(B, B, ze), L[Ne] = B[0], L[Ne + 1] = B[1], L[Ne + 2] = B[2], L[Ne + 3] = B[3];
            return L;
          });
          return Ve.forEach = G, Ve;
        }
        function Ue() {
          if (ge) return te;
          function a(Gt) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(si) {
              return typeof si;
            } : function(si) {
              return si && typeof Symbol == "function" && si.constructor === Symbol && si !== Symbol.prototype ? "symbol" : typeof si;
            }, a(Gt);
          }
          ge = 1, Object.defineProperty(te, "__esModule", { value: !0 }), te.create = b, te.identity = function(Gt) {
            return Gt[0] = 0, Gt[1] = 0, Gt[2] = 0, Gt[3] = 1, Gt;
          }, te.setAxisAngle = O, te.getAxisAngle = function(Gt, si) {
            var ci = 2 * Math.acos(si[3]), li = Math.sin(ci / 2);
            return li > e.EPSILON ? (Gt[0] = si[0] / li, Gt[1] = si[1] / li, Gt[2] = si[2] / li) : (Gt[0] = 1, Gt[1] = 0, Gt[2] = 0), ci;
          }, te.getAngle = function(Gt, si) {
            var ci = Y(Gt, si);
            return Math.acos(2 * ci * ci - 1);
          }, te.multiply = H, te.rotateX = function(Gt, si, ci) {
            ci *= 0.5;
            var li = si[0], fi = si[1], gi = si[2], Si = si[3], pi = Math.sin(ci), zi = Math.cos(ci);
            return Gt[0] = li * zi + Si * pi, Gt[1] = fi * zi + gi * pi, Gt[2] = gi * zi - fi * pi, Gt[3] = Si * zi - li * pi, Gt;
          }, te.rotateY = function(Gt, si, ci) {
            ci *= 0.5;
            var li = si[0], fi = si[1], gi = si[2], Si = si[3], pi = Math.sin(ci), zi = Math.cos(ci);
            return Gt[0] = li * zi - gi * pi, Gt[1] = fi * zi + Si * pi, Gt[2] = gi * zi + li * pi, Gt[3] = Si * zi - fi * pi, Gt;
          }, te.rotateZ = function(Gt, si, ci) {
            ci *= 0.5;
            var li = si[0], fi = si[1], gi = si[2], Si = si[3], pi = Math.sin(ci), zi = Math.cos(ci);
            return Gt[0] = li * zi + fi * pi, Gt[1] = fi * zi - li * pi, Gt[2] = gi * zi + Si * pi, Gt[3] = Si * zi - gi * pi, Gt;
          }, te.calculateW = function(Gt, si) {
            var ci = si[0], li = si[1], fi = si[2];
            return Gt[0] = ci, Gt[1] = li, Gt[2] = fi, Gt[3] = Math.sqrt(Math.abs(1 - ci * ci - li * li - fi * fi)), Gt;
          }, te.exp = y, te.ln = B, te.pow = function(Gt, si, ci) {
            return B(Gt, si), F(Gt, Gt, ci), y(Gt, Gt), Gt;
          }, te.slerp = G, te.random = function(Gt) {
            var si = e.RANDOM(), ci = e.RANDOM(), li = e.RANDOM(), fi = Math.sqrt(1 - si), gi = Math.sqrt(si);
            return Gt[0] = fi * Math.sin(2 * Math.PI * ci), Gt[1] = fi * Math.cos(2 * Math.PI * ci), Gt[2] = gi * Math.sin(2 * Math.PI * li), Gt[3] = gi * Math.cos(2 * Math.PI * li), Gt;
          }, te.invert = function(Gt, si) {
            var ci = si[0], li = si[1], fi = si[2], gi = si[3], Si = ci * ci + li * li + fi * fi + gi * gi, pi = Si ? 1 / Si : 0;
            return Gt[0] = -ci * pi, Gt[1] = -li * pi, Gt[2] = -fi * pi, Gt[3] = gi * pi, Gt;
          }, te.conjugate = function(Gt, si) {
            return Gt[0] = -si[0], Gt[1] = -si[1], Gt[2] = -si[2], Gt[3] = si[3], Gt;
          }, te.fromMat3 = L, te.fromEuler = function(Gt, si, ci, li) {
            var fi = 0.5 * Math.PI / 180;
            si *= fi, ci *= fi, li *= fi;
            var gi = Math.sin(si), Si = Math.cos(si), pi = Math.sin(ci), zi = Math.cos(ci), Gi = Math.sin(li), Oi = Math.cos(li);
            return Gt[0] = gi * zi * Oi - Si * pi * Gi, Gt[1] = Si * pi * Oi + gi * zi * Gi, Gt[2] = Si * zi * Gi - gi * pi * Oi, Gt[3] = Si * zi * Oi + gi * pi * Gi, Gt;
          }, te.str = function(Gt) {
            return "quat(" + Gt[0] + ", " + Gt[1] + ", " + Gt[2] + ", " + Gt[3] + ")";
          }, te.setAxes = te.sqlerp = te.rotationTo = te.equals = te.exactEquals = te.normalize = te.sqrLen = te.squaredLength = te.len = te.length = te.lerp = te.dot = te.scale = te.mul = te.add = te.set = te.copy = te.fromValues = te.clone = void 0;
          var e = f(M()), r = f(j()), s = f(me()), h = f(Oe());
          function o(Gt) {
            if (typeof WeakMap != "function") return null;
            var si = /* @__PURE__ */ new WeakMap(), ci = /* @__PURE__ */ new WeakMap();
            return (o = function(li) {
              return li ? ci : si;
            })(Gt);
          }
          function f(Gt, si) {
            if (Gt && Gt.__esModule) return Gt;
            if (Gt === null || a(Gt) !== "object" && typeof Gt != "function") return { default: Gt };
            var ci = o(si);
            if (ci && ci.has(Gt)) return ci.get(Gt);
            var li = {}, fi = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var gi in Gt) if (gi !== "default" && Object.prototype.hasOwnProperty.call(Gt, gi)) {
              var Si = fi ? Object.getOwnPropertyDescriptor(Gt, gi) : null;
              Si && (Si.get || Si.set) ? Object.defineProperty(li, gi, Si) : li[gi] = Gt[gi];
            }
            return li.default = Gt, ci && ci.set(Gt, li), li;
          }
          function b() {
            var Gt = new e.ARRAY_TYPE(4);
            return e.ARRAY_TYPE != Float32Array && (Gt[0] = 0, Gt[1] = 0, Gt[2] = 0), Gt[3] = 1, Gt;
          }
          function O(Gt, si, ci) {
            ci *= 0.5;
            var li = Math.sin(ci);
            return Gt[0] = li * si[0], Gt[1] = li * si[1], Gt[2] = li * si[2], Gt[3] = Math.cos(ci), Gt;
          }
          function H(Gt, si, ci) {
            var li = si[0], fi = si[1], gi = si[2], Si = si[3], pi = ci[0], zi = ci[1], Gi = ci[2], Oi = ci[3];
            return Gt[0] = li * Oi + Si * pi + fi * Gi - gi * zi, Gt[1] = fi * Oi + Si * zi + gi * pi - li * Gi, Gt[2] = gi * Oi + Si * Gi + li * zi - fi * pi, Gt[3] = Si * Oi - li * pi - fi * zi - gi * Gi, Gt;
          }
          function y(Gt, si) {
            var ci = si[0], li = si[1], fi = si[2], gi = si[3], Si = Math.sqrt(ci * ci + li * li + fi * fi), pi = Math.exp(gi), zi = Si > 0 ? pi * Math.sin(Si) / Si : 0;
            return Gt[0] = ci * zi, Gt[1] = li * zi, Gt[2] = fi * zi, Gt[3] = pi * Math.cos(Si), Gt;
          }
          function B(Gt, si) {
            var ci = si[0], li = si[1], fi = si[2], gi = si[3], Si = Math.sqrt(ci * ci + li * li + fi * fi), pi = Si > 0 ? Math.atan2(Si, gi) / Si : 0;
            return Gt[0] = ci * pi, Gt[1] = li * pi, Gt[2] = fi * pi, Gt[3] = 0.5 * Math.log(ci * ci + li * li + fi * fi + gi * gi), Gt;
          }
          function G(Gt, si, ci, li) {
            var fi, gi, Si, pi, zi, Gi = si[0], Oi = si[1], lr = si[2], ar = si[3], Qi = ci[0], qi = ci[1], xr = ci[2], hr = ci[3];
            return (gi = Gi * Qi + Oi * qi + lr * xr + ar * hr) < 0 && (gi = -gi, Qi = -Qi, qi = -qi, xr = -xr, hr = -hr), 1 - gi > e.EPSILON ? (fi = Math.acos(gi), Si = Math.sin(fi), pi = Math.sin((1 - li) * fi) / Si, zi = Math.sin(li * fi) / Si) : (pi = 1 - li, zi = li), Gt[0] = pi * Gi + zi * Qi, Gt[1] = pi * Oi + zi * qi, Gt[2] = pi * lr + zi * xr, Gt[3] = pi * ar + zi * hr, Gt;
          }
          function L(Gt, si) {
            var ci, li = si[0] + si[4] + si[8];
            if (li > 0) ci = Math.sqrt(li + 1), Gt[3] = 0.5 * ci, Gt[0] = (si[5] - si[7]) * (ci = 0.5 / ci), Gt[1] = (si[6] - si[2]) * ci, Gt[2] = (si[1] - si[3]) * ci;
            else {
              var fi = 0;
              si[4] > si[0] && (fi = 1), si[8] > si[3 * fi + fi] && (fi = 2);
              var gi = (fi + 1) % 3, Si = (fi + 2) % 3;
              ci = Math.sqrt(si[3 * fi + fi] - si[3 * gi + gi] - si[3 * Si + Si] + 1), Gt[fi] = 0.5 * ci, Gt[3] = (si[3 * gi + Si] - si[3 * Si + gi]) * (ci = 0.5 / ci), Gt[gi] = (si[3 * gi + fi] + si[3 * fi + gi]) * ci, Gt[Si] = (si[3 * Si + fi] + si[3 * fi + Si]) * ci;
            }
            return Gt;
          }
          te.clone = h.clone, te.fromValues = h.fromValues, te.copy = h.copy, te.set = h.set, te.add = h.add, te.mul = H;
          var F = h.scale;
          te.scale = F;
          var Y = h.dot;
          te.dot = Y, te.lerp = h.lerp;
          var ce = h.length;
          te.length = ce, te.len = ce;
          var _e = h.squaredLength;
          te.squaredLength = _e, te.sqrLen = _e;
          var ze = h.normalize;
          te.normalize = ze, te.exactEquals = h.exactEquals, te.equals = h.equals;
          var Ne, Ee, We, lt = (Ne = s.create(), Ee = s.fromValues(1, 0, 0), We = s.fromValues(0, 1, 0), function(Gt, si, ci) {
            var li = s.dot(si, ci);
            return li < -0.999999 ? (s.cross(Ne, Ee, si), s.len(Ne) < 1e-6 && s.cross(Ne, We, si), s.normalize(Ne, Ne), O(Gt, Ne, Math.PI), Gt) : li > 0.999999 ? (Gt[0] = 0, Gt[1] = 0, Gt[2] = 0, Gt[3] = 1, Gt) : (s.cross(Ne, si, ci), Gt[0] = Ne[0], Gt[1] = Ne[1], Gt[2] = Ne[2], Gt[3] = 1 + li, ze(Gt, Gt));
          });
          te.rotationTo = lt;
          var yt, Bt, zt = (yt = b(), Bt = b(), function(Gt, si, ci, li, fi, gi) {
            return G(yt, si, fi, gi), G(Bt, ci, li, gi), G(Gt, yt, Bt, 2 * gi * (1 - gi)), Gt;
          });
          te.sqlerp = zt;
          var Dt, ni = (Dt = r.create(), function(Gt, si, ci, li) {
            return Dt[0] = ci[0], Dt[3] = ci[1], Dt[6] = ci[2], Dt[1] = li[0], Dt[4] = li[1], Dt[7] = li[2], Dt[2] = -si[0], Dt[5] = -si[1], Dt[8] = -si[2], ze(Gt, L(Gt, Dt));
          });
          return te.setAxes = ni, te;
        }
        var we, Ce = {};
        function it() {
          if (we) return Ce;
          function a(G) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(L) {
              return typeof L;
            } : function(L) {
              return L && typeof Symbol == "function" && L.constructor === Symbol && L !== Symbol.prototype ? "symbol" : typeof L;
            }, a(G);
          }
          we = 1, Object.defineProperty(Ce, "__esModule", { value: !0 }), Ce.create = function() {
            var G = new e.ARRAY_TYPE(8);
            return e.ARRAY_TYPE != Float32Array && (G[0] = 0, G[1] = 0, G[2] = 0, G[4] = 0, G[5] = 0, G[6] = 0, G[7] = 0), G[3] = 1, G;
          }, Ce.clone = function(G) {
            var L = new e.ARRAY_TYPE(8);
            return L[0] = G[0], L[1] = G[1], L[2] = G[2], L[3] = G[3], L[4] = G[4], L[5] = G[5], L[6] = G[6], L[7] = G[7], L;
          }, Ce.fromValues = function(G, L, F, Y, ce, _e, ze, Ne) {
            var Ee = new e.ARRAY_TYPE(8);
            return Ee[0] = G, Ee[1] = L, Ee[2] = F, Ee[3] = Y, Ee[4] = ce, Ee[5] = _e, Ee[6] = ze, Ee[7] = Ne, Ee;
          }, Ce.fromRotationTranslationValues = function(G, L, F, Y, ce, _e, ze) {
            var Ne = new e.ARRAY_TYPE(8);
            Ne[0] = G, Ne[1] = L, Ne[2] = F, Ne[3] = Y;
            var Ee = 0.5 * ce, We = 0.5 * _e, lt = 0.5 * ze;
            return Ne[4] = Ee * Y + We * F - lt * L, Ne[5] = We * Y + lt * G - Ee * F, Ne[6] = lt * Y + Ee * L - We * G, Ne[7] = -Ee * G - We * L - lt * F, Ne;
          }, Ce.fromRotationTranslation = f, Ce.fromTranslation = function(G, L) {
            return G[0] = 0, G[1] = 0, G[2] = 0, G[3] = 1, G[4] = 0.5 * L[0], G[5] = 0.5 * L[1], G[6] = 0.5 * L[2], G[7] = 0, G;
          }, Ce.fromRotation = function(G, L) {
            return G[0] = L[0], G[1] = L[1], G[2] = L[2], G[3] = L[3], G[4] = 0, G[5] = 0, G[6] = 0, G[7] = 0, G;
          }, Ce.fromMat4 = function(G, L) {
            var F = r.create();
            s.getRotation(F, L);
            var Y = new e.ARRAY_TYPE(3);
            return s.getTranslation(Y, L), f(G, F, Y), G;
          }, Ce.copy = b, Ce.identity = function(G) {
            return G[0] = 0, G[1] = 0, G[2] = 0, G[3] = 1, G[4] = 0, G[5] = 0, G[6] = 0, G[7] = 0, G;
          }, Ce.set = function(G, L, F, Y, ce, _e, ze, Ne, Ee) {
            return G[0] = L, G[1] = F, G[2] = Y, G[3] = ce, G[4] = _e, G[5] = ze, G[6] = Ne, G[7] = Ee, G;
          }, Ce.getDual = function(G, L) {
            return G[0] = L[4], G[1] = L[5], G[2] = L[6], G[3] = L[7], G;
          }, Ce.setDual = function(G, L) {
            return G[4] = L[0], G[5] = L[1], G[6] = L[2], G[7] = L[3], G;
          }, Ce.getTranslation = function(G, L) {
            var F = L[4], Y = L[5], ce = L[6], _e = L[7], ze = -L[0], Ne = -L[1], Ee = -L[2], We = L[3];
            return G[0] = 2 * (F * We + _e * ze + Y * Ee - ce * Ne), G[1] = 2 * (Y * We + _e * Ne + ce * ze - F * Ee), G[2] = 2 * (ce * We + _e * Ee + F * Ne - Y * ze), G;
          }, Ce.translate = function(G, L, F) {
            var Y = L[0], ce = L[1], _e = L[2], ze = L[3], Ne = 0.5 * F[0], Ee = 0.5 * F[1], We = 0.5 * F[2], lt = L[4], yt = L[5], Bt = L[6], zt = L[7];
            return G[0] = Y, G[1] = ce, G[2] = _e, G[3] = ze, G[4] = ze * Ne + ce * We - _e * Ee + lt, G[5] = ze * Ee + _e * Ne - Y * We + yt, G[6] = ze * We + Y * Ee - ce * Ne + Bt, G[7] = -Y * Ne - ce * Ee - _e * We + zt, G;
          }, Ce.rotateX = function(G, L, F) {
            var Y = -L[0], ce = -L[1], _e = -L[2], ze = L[3], Ne = L[4], Ee = L[5], We = L[6], lt = L[7], yt = Ne * ze + lt * Y + Ee * _e - We * ce, Bt = Ee * ze + lt * ce + We * Y - Ne * _e, zt = We * ze + lt * _e + Ne * ce - Ee * Y, Dt = lt * ze - Ne * Y - Ee * ce - We * _e;
            return r.rotateX(G, L, F), G[4] = yt * (ze = G[3]) + Dt * (Y = G[0]) + Bt * (_e = G[2]) - zt * (ce = G[1]), G[5] = Bt * ze + Dt * ce + zt * Y - yt * _e, G[6] = zt * ze + Dt * _e + yt * ce - Bt * Y, G[7] = Dt * ze - yt * Y - Bt * ce - zt * _e, G;
          }, Ce.rotateY = function(G, L, F) {
            var Y = -L[0], ce = -L[1], _e = -L[2], ze = L[3], Ne = L[4], Ee = L[5], We = L[6], lt = L[7], yt = Ne * ze + lt * Y + Ee * _e - We * ce, Bt = Ee * ze + lt * ce + We * Y - Ne * _e, zt = We * ze + lt * _e + Ne * ce - Ee * Y, Dt = lt * ze - Ne * Y - Ee * ce - We * _e;
            return r.rotateY(G, L, F), G[4] = yt * (ze = G[3]) + Dt * (Y = G[0]) + Bt * (_e = G[2]) - zt * (ce = G[1]), G[5] = Bt * ze + Dt * ce + zt * Y - yt * _e, G[6] = zt * ze + Dt * _e + yt * ce - Bt * Y, G[7] = Dt * ze - yt * Y - Bt * ce - zt * _e, G;
          }, Ce.rotateZ = function(G, L, F) {
            var Y = -L[0], ce = -L[1], _e = -L[2], ze = L[3], Ne = L[4], Ee = L[5], We = L[6], lt = L[7], yt = Ne * ze + lt * Y + Ee * _e - We * ce, Bt = Ee * ze + lt * ce + We * Y - Ne * _e, zt = We * ze + lt * _e + Ne * ce - Ee * Y, Dt = lt * ze - Ne * Y - Ee * ce - We * _e;
            return r.rotateZ(G, L, F), G[4] = yt * (ze = G[3]) + Dt * (Y = G[0]) + Bt * (_e = G[2]) - zt * (ce = G[1]), G[5] = Bt * ze + Dt * ce + zt * Y - yt * _e, G[6] = zt * ze + Dt * _e + yt * ce - Bt * Y, G[7] = Dt * ze - yt * Y - Bt * ce - zt * _e, G;
          }, Ce.rotateByQuatAppend = function(G, L, F) {
            var Y = F[0], ce = F[1], _e = F[2], ze = F[3], Ne = L[0], Ee = L[1], We = L[2], lt = L[3];
            return G[0] = Ne * ze + lt * Y + Ee * _e - We * ce, G[1] = Ee * ze + lt * ce + We * Y - Ne * _e, G[2] = We * ze + lt * _e + Ne * ce - Ee * Y, G[3] = lt * ze - Ne * Y - Ee * ce - We * _e, G[4] = (Ne = L[4]) * ze + (lt = L[7]) * Y + (Ee = L[5]) * _e - (We = L[6]) * ce, G[5] = Ee * ze + lt * ce + We * Y - Ne * _e, G[6] = We * ze + lt * _e + Ne * ce - Ee * Y, G[7] = lt * ze - Ne * Y - Ee * ce - We * _e, G;
          }, Ce.rotateByQuatPrepend = function(G, L, F) {
            var Y = L[0], ce = L[1], _e = L[2], ze = L[3], Ne = F[0], Ee = F[1], We = F[2], lt = F[3];
            return G[0] = Y * lt + ze * Ne + ce * We - _e * Ee, G[1] = ce * lt + ze * Ee + _e * Ne - Y * We, G[2] = _e * lt + ze * We + Y * Ee - ce * Ne, G[3] = ze * lt - Y * Ne - ce * Ee - _e * We, G[4] = Y * (lt = F[7]) + ze * (Ne = F[4]) + ce * (We = F[6]) - _e * (Ee = F[5]), G[5] = ce * lt + ze * Ee + _e * Ne - Y * We, G[6] = _e * lt + ze * We + Y * Ee - ce * Ne, G[7] = ze * lt - Y * Ne - ce * Ee - _e * We, G;
          }, Ce.rotateAroundAxis = function(G, L, F, Y) {
            if (Math.abs(Y) < e.EPSILON) return b(G, L);
            var ce = Math.hypot(F[0], F[1], F[2]);
            Y *= 0.5;
            var _e = Math.sin(Y), ze = _e * F[0] / ce, Ne = _e * F[1] / ce, Ee = _e * F[2] / ce, We = Math.cos(Y), lt = L[0], yt = L[1], Bt = L[2], zt = L[3];
            G[0] = lt * We + zt * ze + yt * Ee - Bt * Ne, G[1] = yt * We + zt * Ne + Bt * ze - lt * Ee, G[2] = Bt * We + zt * Ee + lt * Ne - yt * ze, G[3] = zt * We - lt * ze - yt * Ne - Bt * Ee;
            var Dt = L[4], ni = L[5], Gt = L[6], si = L[7];
            return G[4] = Dt * We + si * ze + ni * Ee - Gt * Ne, G[5] = ni * We + si * Ne + Gt * ze - Dt * Ee, G[6] = Gt * We + si * Ee + Dt * Ne - ni * ze, G[7] = si * We - Dt * ze - ni * Ne - Gt * Ee, G;
          }, Ce.add = function(G, L, F) {
            return G[0] = L[0] + F[0], G[1] = L[1] + F[1], G[2] = L[2] + F[2], G[3] = L[3] + F[3], G[4] = L[4] + F[4], G[5] = L[5] + F[5], G[6] = L[6] + F[6], G[7] = L[7] + F[7], G;
          }, Ce.multiply = O, Ce.scale = function(G, L, F) {
            return G[0] = L[0] * F, G[1] = L[1] * F, G[2] = L[2] * F, G[3] = L[3] * F, G[4] = L[4] * F, G[5] = L[5] * F, G[6] = L[6] * F, G[7] = L[7] * F, G;
          }, Ce.lerp = function(G, L, F, Y) {
            var ce = 1 - Y;
            return H(L, F) < 0 && (Y = -Y), G[0] = L[0] * ce + F[0] * Y, G[1] = L[1] * ce + F[1] * Y, G[2] = L[2] * ce + F[2] * Y, G[3] = L[3] * ce + F[3] * Y, G[4] = L[4] * ce + F[4] * Y, G[5] = L[5] * ce + F[5] * Y, G[6] = L[6] * ce + F[6] * Y, G[7] = L[7] * ce + F[7] * Y, G;
          }, Ce.invert = function(G, L) {
            var F = B(L);
            return G[0] = -L[0] / F, G[1] = -L[1] / F, G[2] = -L[2] / F, G[3] = L[3] / F, G[4] = -L[4] / F, G[5] = -L[5] / F, G[6] = -L[6] / F, G[7] = L[7] / F, G;
          }, Ce.conjugate = function(G, L) {
            return G[0] = -L[0], G[1] = -L[1], G[2] = -L[2], G[3] = L[3], G[4] = -L[4], G[5] = -L[5], G[6] = -L[6], G[7] = L[7], G;
          }, Ce.normalize = function(G, L) {
            var F = B(L);
            if (F > 0) {
              F = Math.sqrt(F);
              var Y = L[0] / F, ce = L[1] / F, _e = L[2] / F, ze = L[3] / F, Ne = L[4], Ee = L[5], We = L[6], lt = L[7], yt = Y * Ne + ce * Ee + _e * We + ze * lt;
              G[0] = Y, G[1] = ce, G[2] = _e, G[3] = ze, G[4] = (Ne - Y * yt) / F, G[5] = (Ee - ce * yt) / F, G[6] = (We - _e * yt) / F, G[7] = (lt - ze * yt) / F;
            }
            return G;
          }, Ce.str = function(G) {
            return "quat2(" + G[0] + ", " + G[1] + ", " + G[2] + ", " + G[3] + ", " + G[4] + ", " + G[5] + ", " + G[6] + ", " + G[7] + ")";
          }, Ce.exactEquals = function(G, L) {
            return G[0] === L[0] && G[1] === L[1] && G[2] === L[2] && G[3] === L[3] && G[4] === L[4] && G[5] === L[5] && G[6] === L[6] && G[7] === L[7];
          }, Ce.equals = function(G, L) {
            var F = G[0], Y = G[1], ce = G[2], _e = G[3], ze = G[4], Ne = G[5], Ee = G[6], We = G[7], lt = L[0], yt = L[1], Bt = L[2], zt = L[3], Dt = L[4], ni = L[5], Gt = L[6], si = L[7];
            return Math.abs(F - lt) <= e.EPSILON * Math.max(1, Math.abs(F), Math.abs(lt)) && Math.abs(Y - yt) <= e.EPSILON * Math.max(1, Math.abs(Y), Math.abs(yt)) && Math.abs(ce - Bt) <= e.EPSILON * Math.max(1, Math.abs(ce), Math.abs(Bt)) && Math.abs(_e - zt) <= e.EPSILON * Math.max(1, Math.abs(_e), Math.abs(zt)) && Math.abs(ze - Dt) <= e.EPSILON * Math.max(1, Math.abs(ze), Math.abs(Dt)) && Math.abs(Ne - ni) <= e.EPSILON * Math.max(1, Math.abs(Ne), Math.abs(ni)) && Math.abs(Ee - Gt) <= e.EPSILON * Math.max(1, Math.abs(Ee), Math.abs(Gt)) && Math.abs(We - si) <= e.EPSILON * Math.max(1, Math.abs(We), Math.abs(si));
          }, Ce.sqrLen = Ce.squaredLength = Ce.len = Ce.length = Ce.dot = Ce.mul = Ce.setReal = Ce.getReal = void 0;
          var e = o(M()), r = o(Ue()), s = o(J());
          function h(G) {
            if (typeof WeakMap != "function") return null;
            var L = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap();
            return (h = function(Y) {
              return Y ? F : L;
            })(G);
          }
          function o(G, L) {
            if (G && G.__esModule) return G;
            if (G === null || a(G) !== "object" && typeof G != "function") return { default: G };
            var F = h(L);
            if (F && F.has(G)) return F.get(G);
            var Y = {}, ce = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var _e in G) if (_e !== "default" && Object.prototype.hasOwnProperty.call(G, _e)) {
              var ze = ce ? Object.getOwnPropertyDescriptor(G, _e) : null;
              ze && (ze.get || ze.set) ? Object.defineProperty(Y, _e, ze) : Y[_e] = G[_e];
            }
            return Y.default = G, F && F.set(G, Y), Y;
          }
          function f(G, L, F) {
            var Y = 0.5 * F[0], ce = 0.5 * F[1], _e = 0.5 * F[2], ze = L[0], Ne = L[1], Ee = L[2], We = L[3];
            return G[0] = ze, G[1] = Ne, G[2] = Ee, G[3] = We, G[4] = Y * We + ce * Ee - _e * Ne, G[5] = ce * We + _e * ze - Y * Ee, G[6] = _e * We + Y * Ne - ce * ze, G[7] = -Y * ze - ce * Ne - _e * Ee, G;
          }
          function b(G, L) {
            return G[0] = L[0], G[1] = L[1], G[2] = L[2], G[3] = L[3], G[4] = L[4], G[5] = L[5], G[6] = L[6], G[7] = L[7], G;
          }
          function O(G, L, F) {
            var Y = L[0], ce = L[1], _e = L[2], ze = L[3], Ne = F[4], Ee = F[5], We = F[6], lt = F[7], yt = L[4], Bt = L[5], zt = L[6], Dt = L[7], ni = F[0], Gt = F[1], si = F[2], ci = F[3];
            return G[0] = Y * ci + ze * ni + ce * si - _e * Gt, G[1] = ce * ci + ze * Gt + _e * ni - Y * si, G[2] = _e * ci + ze * si + Y * Gt - ce * ni, G[3] = ze * ci - Y * ni - ce * Gt - _e * si, G[4] = Y * lt + ze * Ne + ce * We - _e * Ee + yt * ci + Dt * ni + Bt * si - zt * Gt, G[5] = ce * lt + ze * Ee + _e * Ne - Y * We + Bt * ci + Dt * Gt + zt * ni - yt * si, G[6] = _e * lt + ze * We + Y * Ee - ce * Ne + zt * ci + Dt * si + yt * Gt - Bt * ni, G[7] = ze * lt - Y * Ne - ce * Ee - _e * We + Dt * ci - yt * ni - Bt * Gt - zt * si, G;
          }
          Ce.getReal = r.copy, Ce.setReal = r.copy, Ce.mul = O;
          var H = r.dot;
          Ce.dot = H;
          var y = r.length;
          Ce.length = y, Ce.len = y;
          var B = r.squaredLength;
          return Ce.squaredLength = B, Ce.sqrLen = B, Ce;
        }
        var ut, bt, pt = {};
        function Ke() {
          if (ut) return pt;
          function a(L) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(F) {
              return typeof F;
            } : function(F) {
              return F && typeof Symbol == "function" && F.constructor === Symbol && F !== Symbol.prototype ? "symbol" : typeof F;
            }, a(L);
          }
          ut = 1, Object.defineProperty(pt, "__esModule", { value: !0 }), pt.create = s, pt.clone = function(L) {
            var F = new e.ARRAY_TYPE(2);
            return F[0] = L[0], F[1] = L[1], F;
          }, pt.fromValues = function(L, F) {
            var Y = new e.ARRAY_TYPE(2);
            return Y[0] = L, Y[1] = F, Y;
          }, pt.copy = function(L, F) {
            return L[0] = F[0], L[1] = F[1], L;
          }, pt.set = function(L, F, Y) {
            return L[0] = F, L[1] = Y, L;
          }, pt.add = function(L, F, Y) {
            return L[0] = F[0] + Y[0], L[1] = F[1] + Y[1], L;
          }, pt.subtract = h, pt.multiply = o, pt.divide = f, pt.ceil = function(L, F) {
            return L[0] = Math.ceil(F[0]), L[1] = Math.ceil(F[1]), L;
          }, pt.floor = function(L, F) {
            return L[0] = Math.floor(F[0]), L[1] = Math.floor(F[1]), L;
          }, pt.min = function(L, F, Y) {
            return L[0] = Math.min(F[0], Y[0]), L[1] = Math.min(F[1], Y[1]), L;
          }, pt.max = function(L, F, Y) {
            return L[0] = Math.max(F[0], Y[0]), L[1] = Math.max(F[1], Y[1]), L;
          }, pt.round = function(L, F) {
            return L[0] = Math.round(F[0]), L[1] = Math.round(F[1]), L;
          }, pt.scale = function(L, F, Y) {
            return L[0] = F[0] * Y, L[1] = F[1] * Y, L;
          }, pt.scaleAndAdd = function(L, F, Y, ce) {
            return L[0] = F[0] + Y[0] * ce, L[1] = F[1] + Y[1] * ce, L;
          }, pt.distance = b, pt.squaredDistance = O, pt.length = H, pt.squaredLength = y, pt.negate = function(L, F) {
            return L[0] = -F[0], L[1] = -F[1], L;
          }, pt.inverse = function(L, F) {
            return L[0] = 1 / F[0], L[1] = 1 / F[1], L;
          }, pt.normalize = function(L, F) {
            var Y = F[0], ce = F[1], _e = Y * Y + ce * ce;
            return _e > 0 && (_e = 1 / Math.sqrt(_e)), L[0] = F[0] * _e, L[1] = F[1] * _e, L;
          }, pt.dot = function(L, F) {
            return L[0] * F[0] + L[1] * F[1];
          }, pt.cross = function(L, F, Y) {
            var ce = F[0] * Y[1] - F[1] * Y[0];
            return L[0] = L[1] = 0, L[2] = ce, L;
          }, pt.lerp = function(L, F, Y, ce) {
            var _e = F[0], ze = F[1];
            return L[0] = _e + ce * (Y[0] - _e), L[1] = ze + ce * (Y[1] - ze), L;
          }, pt.random = function(L, F) {
            F = F || 1;
            var Y = 2 * e.RANDOM() * Math.PI;
            return L[0] = Math.cos(Y) * F, L[1] = Math.sin(Y) * F, L;
          }, pt.transformMat2 = function(L, F, Y) {
            var ce = F[0], _e = F[1];
            return L[0] = Y[0] * ce + Y[2] * _e, L[1] = Y[1] * ce + Y[3] * _e, L;
          }, pt.transformMat2d = function(L, F, Y) {
            var ce = F[0], _e = F[1];
            return L[0] = Y[0] * ce + Y[2] * _e + Y[4], L[1] = Y[1] * ce + Y[3] * _e + Y[5], L;
          }, pt.transformMat3 = function(L, F, Y) {
            var ce = F[0], _e = F[1];
            return L[0] = Y[0] * ce + Y[3] * _e + Y[6], L[1] = Y[1] * ce + Y[4] * _e + Y[7], L;
          }, pt.transformMat4 = function(L, F, Y) {
            var ce = F[0], _e = F[1];
            return L[0] = Y[0] * ce + Y[4] * _e + Y[12], L[1] = Y[1] * ce + Y[5] * _e + Y[13], L;
          }, pt.rotate = function(L, F, Y, ce) {
            var _e = F[0] - Y[0], ze = F[1] - Y[1], Ne = Math.sin(ce), Ee = Math.cos(ce);
            return L[0] = _e * Ee - ze * Ne + Y[0], L[1] = _e * Ne + ze * Ee + Y[1], L;
          }, pt.angle = function(L, F) {
            var Y = L[0], ce = L[1], _e = F[0], ze = F[1], Ne = Math.sqrt(Y * Y + ce * ce) * Math.sqrt(_e * _e + ze * ze);
            return Math.acos(Math.min(Math.max(Ne && (Y * _e + ce * ze) / Ne, -1), 1));
          }, pt.zero = function(L) {
            return L[0] = 0, L[1] = 0, L;
          }, pt.str = function(L) {
            return "vec2(" + L[0] + ", " + L[1] + ")";
          }, pt.exactEquals = function(L, F) {
            return L[0] === F[0] && L[1] === F[1];
          }, pt.equals = function(L, F) {
            var Y = L[0], ce = L[1], _e = F[0], ze = F[1];
            return Math.abs(Y - _e) <= e.EPSILON * Math.max(1, Math.abs(Y), Math.abs(_e)) && Math.abs(ce - ze) <= e.EPSILON * Math.max(1, Math.abs(ce), Math.abs(ze));
          }, pt.forEach = pt.sqrLen = pt.sqrDist = pt.dist = pt.div = pt.mul = pt.sub = pt.len = void 0;
          var e = function(L, F) {
            if (L && L.__esModule) return L;
            if (L === null || a(L) !== "object" && typeof L != "function") return { default: L };
            var Y = r(void 0);
            if (Y && Y.has(L)) return Y.get(L);
            var ce = {}, _e = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var ze in L) if (ze !== "default" && Object.prototype.hasOwnProperty.call(L, ze)) {
              var Ne = _e ? Object.getOwnPropertyDescriptor(L, ze) : null;
              Ne && (Ne.get || Ne.set) ? Object.defineProperty(ce, ze, Ne) : ce[ze] = L[ze];
            }
            return ce.default = L, Y && Y.set(L, ce), ce;
          }(M());
          function r(L) {
            if (typeof WeakMap != "function") return null;
            var F = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap();
            return (r = function(ce) {
              return ce ? Y : F;
            })(L);
          }
          function s() {
            var L = new e.ARRAY_TYPE(2);
            return e.ARRAY_TYPE != Float32Array && (L[0] = 0, L[1] = 0), L;
          }
          function h(L, F, Y) {
            return L[0] = F[0] - Y[0], L[1] = F[1] - Y[1], L;
          }
          function o(L, F, Y) {
            return L[0] = F[0] * Y[0], L[1] = F[1] * Y[1], L;
          }
          function f(L, F, Y) {
            return L[0] = F[0] / Y[0], L[1] = F[1] / Y[1], L;
          }
          function b(L, F) {
            return Math.hypot(F[0] - L[0], F[1] - L[1]);
          }
          function O(L, F) {
            var Y = F[0] - L[0], ce = F[1] - L[1];
            return Y * Y + ce * ce;
          }
          function H(L) {
            return Math.hypot(L[0], L[1]);
          }
          function y(L) {
            var F = L[0], Y = L[1];
            return F * F + Y * Y;
          }
          pt.len = H, pt.sub = h, pt.mul = o, pt.div = f, pt.dist = b, pt.sqrDist = O, pt.sqrLen = y;
          var B, G = (B = s(), function(L, F, Y, ce, _e, ze) {
            var Ne, Ee;
            for (F || (F = 2), Y || (Y = 0), Ee = ce ? Math.min(ce * F + Y, L.length) : L.length, Ne = Y; Ne < Ee; Ne += F) B[0] = L[Ne], B[1] = L[Ne + 1], _e(B, B, ze), L[Ne] = B[0], L[Ne + 1] = B[1];
            return L;
          });
          return pt.forEach = G, pt;
        }
        function dt() {
          if (bt) return R;
          function a(L) {
            return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(F) {
              return typeof F;
            } : function(F) {
              return F && typeof Symbol == "function" && F.constructor === Symbol && F !== Symbol.prototype ? "symbol" : typeof F;
            }, a(L);
          }
          bt = 1, Object.defineProperty(R, "__esModule", { value: !0 }), R.vec4 = R.vec3 = R.vec2 = R.quat2 = R.quat = R.mat4 = R.mat3 = R.mat2d = R.mat2 = R.glMatrix = void 0;
          var e = G(M());
          R.glMatrix = e;
          var r = G(w());
          R.mat2 = r;
          var s = G(P());
          R.mat2d = s;
          var h = G(j());
          R.mat3 = h;
          var o = G(J());
          R.mat4 = o;
          var f = G(Ue());
          R.quat = f;
          var b = G(it());
          R.quat2 = b;
          var O = G(Ke());
          R.vec2 = O;
          var H = G(me());
          R.vec3 = H;
          var y = G(Oe());
          function B(L) {
            if (typeof WeakMap != "function") return null;
            var F = /* @__PURE__ */ new WeakMap(), Y = /* @__PURE__ */ new WeakMap();
            return (B = function(ce) {
              return ce ? Y : F;
            })(L);
          }
          function G(L, F) {
            if (L && L.__esModule) return L;
            if (L === null || a(L) !== "object" && typeof L != "function") return { default: L };
            var Y = B(F);
            if (Y && Y.has(L)) return Y.get(L);
            var ce = {}, _e = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var ze in L) if (ze !== "default" && Object.prototype.hasOwnProperty.call(L, ze)) {
              var Ne = _e ? Object.getOwnPropertyDescriptor(L, ze) : null;
              Ne && (Ne.get || Ne.set) ? Object.defineProperty(ce, ze, Ne) : ce[ze] = L[ze];
            }
            return ce.default = L, Y && Y.set(L, ce), ce;
          }
          return R.vec4 = y, R;
        }
        var ct, wt, Ht, $t, rt = dt(), ri = function() {
          if (wt) return ct;
          function a(e, r, s, h) {
            this.cx = 3 * e, this.bx = 3 * (s - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * r, this.by = 3 * (h - r) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = r, this.p2x = s, this.p2y = h;
          }
          return wt = 1, ct = a, a.prototype = { sampleCurveX: function(e) {
            return ((this.ax * e + this.bx) * e + this.cx) * e;
          }, sampleCurveY: function(e) {
            return ((this.ay * e + this.by) * e + this.cy) * e;
          }, sampleCurveDerivativeX: function(e) {
            return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
          }, solveCurveX: function(e, r) {
            if (r === void 0 && (r = 1e-6), e < 0) return 0;
            if (e > 1) return 1;
            for (var s = e, h = 0; h < 8; h++) {
              var o = this.sampleCurveX(s) - e;
              if (Math.abs(o) < r) return s;
              var f = this.sampleCurveDerivativeX(s);
              if (Math.abs(f) < 1e-6) break;
              s -= o / f;
            }
            var b = 0, O = 1;
            for (s = e, h = 0; h < 20 && (o = this.sampleCurveX(s), !(Math.abs(o - e) < r)); h++) e > o ? b = s : O = s, s = 0.5 * (O - b) + b;
            return s;
          }, solve: function(e, r) {
            return this.sampleCurveY(this.solveCurveX(e, r));
          } }, ct;
        }(), wi = N(ri);
        function Qt() {
          if ($t) return Ht;
          function a(e, r) {
            this.x = e, this.y = r;
          }
          return $t = 1, Ht = a, a.prototype = { clone: function() {
            return new a(this.x, this.y);
          }, add: function(e) {
            return this.clone()._add(e);
          }, sub: function(e) {
            return this.clone()._sub(e);
          }, multByPoint: function(e) {
            return this.clone()._multByPoint(e);
          }, divByPoint: function(e) {
            return this.clone()._divByPoint(e);
          }, mult: function(e) {
            return this.clone()._mult(e);
          }, div: function(e) {
            return this.clone()._div(e);
          }, rotate: function(e) {
            return this.clone()._rotate(e);
          }, rotateAround: function(e, r) {
            return this.clone()._rotateAround(e, r);
          }, matMult: function(e) {
            return this.clone()._matMult(e);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(e) {
            return this.x === e.x && this.y === e.y;
          }, dist: function(e) {
            return Math.sqrt(this.distSqr(e));
          }, distSqr: function(e) {
            var r = e.x - this.x, s = e.y - this.y;
            return r * r + s * s;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(e) {
            return Math.atan2(this.y - e.y, this.x - e.x);
          }, angleWith: function(e) {
            return this.angleWithSep(e.x, e.y);
          }, angleWithSep: function(e, r) {
            return Math.atan2(this.x * r - this.y * e, this.x * e + this.y * r);
          }, _matMult: function(e) {
            var r = e[2] * this.x + e[3] * this.y;
            return this.x = e[0] * this.x + e[1] * this.y, this.y = r, this;
          }, _add: function(e) {
            return this.x += e.x, this.y += e.y, this;
          }, _sub: function(e) {
            return this.x -= e.x, this.y -= e.y, this;
          }, _mult: function(e) {
            return this.x *= e, this.y *= e, this;
          }, _div: function(e) {
            return this.x /= e, this.y /= e, this;
          }, _multByPoint: function(e) {
            return this.x *= e.x, this.y *= e.y, this;
          }, _divByPoint: function(e) {
            return this.x /= e.x, this.y /= e.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var e = this.y;
            return this.y = this.x, this.x = -e, this;
          }, _rotate: function(e) {
            var r = Math.cos(e), s = Math.sin(e), h = s * this.x + r * this.y;
            return this.x = r * this.x - s * this.y, this.y = h, this;
          }, _rotateAround: function(e, r) {
            var s = Math.cos(e), h = Math.sin(e), o = r.y + h * (this.x - r.x) + s * (this.y - r.y);
            return this.x = r.x + s * (this.x - r.x) - h * (this.y - r.y), this.y = o, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, a.convert = function(e) {
            return e instanceof a ? e : Array.isArray(e) ? new a(e[0], e[1]) : e;
          }, Ht;
        }
        var At = N(Qt());
        function St(a, e) {
          if (Array.isArray(a)) {
            if (!Array.isArray(e) || a.length !== e.length) return !1;
            for (let r = 0; r < a.length; r++) if (!St(a[r], e[r])) return !1;
            return !0;
          }
          if (typeof a == "object" && a !== null && e !== null) {
            if (typeof e != "object" || Object.keys(a).length !== Object.keys(e).length) return !1;
            for (const r in a) if (!St(a[r], e[r])) return !1;
            return !0;
          }
          return a === e;
        }
        const Lt = Math.PI / 180, kt = 180 / Math.PI;
        function Ye(a) {
          return a * Lt;
        }
        function De(a) {
          return a * kt;
        }
        const Re = [[0, 0], [1, 0], [1, 1], [0, 1]];
        function _t(a) {
          if (a <= 0) return 0;
          if (a >= 1) return 1;
          const e = a * a, r = e * a;
          return 4 * (a < 0.5 ? r : 3 * (a - e) + r - 0.75);
        }
        function et(a, e, r, s) {
          const h = new wi(a, e, r, s);
          return function(o) {
            return h.solve(o);
          };
        }
        const Ie = et(0.25, 0.1, 0.25, 1);
        function pe(a, e, r) {
          return Math.min(r, Math.max(e, a));
        }
        function xt(a, e, r) {
          return (r = pe((r - a) / (e - a), 0, 1)) * r * (3 - 2 * r);
        }
        function l(a, e, r) {
          const s = r - e, h = ((a - e) % s + s) % s + e;
          return h === e ? r : h;
        }
        function _(a, e, r) {
          if (!a.length) return r(null, []);
          let s = a.length;
          const h = new Array(a.length);
          let o = null;
          a.forEach((f, b) => {
            e(f, (O, H) => {
              O && (o = O), h[b] = H, --s == 0 && r(o, h);
            });
          });
        }
        function I(a, ...e) {
          for (const r of e) for (const s in r) a[s] = r[s];
          return a;
        }
        let X = 1;
        function ne() {
          return X++;
        }
        function ue(a) {
          return a <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
        }
        function Te(a, e) {
          a.forEach((r) => {
            e[r] && (e[r] = e[r].bind(e));
          });
        }
        function ye(a, e) {
          return a.indexOf(e, a.length - e.length) !== -1;
        }
        function Me(a, e, r) {
          const s = {};
          for (const h in a) s[h] = e.call(this, a[h], h, a);
          return s;
        }
        function Ge(a, e, r) {
          const s = {};
          for (const h in a) e.call(this, a[h], h, a) && (s[h] = a[h]);
          return s;
        }
        function Qe(a) {
          return Array.isArray(a) ? a.map(Qe) : typeof a == "object" && a ? Me(a, Qe) : a;
        }
        const re = {};
        function Se(a) {
          re[a] || (typeof console < "u" && console.warn(a), re[a] = !0);
        }
        function Pe(a, e, r) {
          return (r.y - a.y) * (e.x - a.x) > (e.y - a.y) * (r.x - a.x);
        }
        function at(a) {
          let e = 0;
          for (let r, s, h = 0, o = a.length, f = o - 1; h < o; f = h++) r = a[h], s = a[f], e += (s.x - r.x) * (r.y + s.y);
          return e;
        }
        function Be([a, e, r]) {
          const s = Ye(e + 90), h = Ye(r);
          return { x: a * Math.cos(s) * Math.sin(h), y: a * Math.sin(s) * Math.sin(h), z: a * Math.cos(h), azimuthal: e, polar: r };
        }
        function Ze() {
          return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
        }
        function fe(a) {
          const e = {};
          if (a.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (r, s, h, o) => {
            const f = h || o;
            return e[s] = !f || f.toLowerCase(), "";
          }), e["max-age"]) {
            const r = parseInt(e["max-age"], 10);
            isNaN(r) ? delete e["max-age"] : e["max-age"] = r;
          }
          return e;
        }
        let Je = null;
        function Xe(a, e) {
          return [a[4 * e], a[4 * e + 1], a[4 * e + 2], a[4 * e + 3]];
        }
        function z(a, e, r, s) {
          for (; e < r; ) {
            const h = e + r >> 1;
            a[h] < s ? e = h + 1 : r = h;
          }
          return e;
        }
        function He(a, e, r, s) {
          for (; e < r; ) {
            const h = e + r >> 1;
            a[h] <= s ? e = h + 1 : r = h;
          }
          return e;
        }
        function nt(a) {
          return a > 0 ? 1 / (1.001 - a) : 1 + a;
        }
        function ae(a) {
          return a > 0 ? 1 - 1 / (1.001 - a) : -a;
        }
        const $e = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
        }, get API_TILEJSON_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
        }, get API_SPRITE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
        }, get API_FONTS_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
        }, get API_STYLE_REGEX() {
          return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
        }, get API_CDN_URL_REGEX() {
          return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
        }, get EVENTS_URL() {
          if (!$e.API_URL) return null;
          try {
            const a = new URL($e.API_URL);
            return a.hostname === "api.mapbox.cn" ? "https://events.mapbox.cn/events/v2" : a.hostname === "api.mapbox.com" ? "https://events.mapbox.com/events/v2" : null;
          } catch {
            return null;
          }
        }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf", TILES3D_URL_PREFIX: "3dtiles/v1" };
        function Et(a) {
          return $e.API_URL_REGEX.test(a);
        }
        function Nt(a) {
          return $e.API_SPRITE_REGEX.test(a);
        }
        let Yt, Ft, ai, Mt, Ae, Fe;
        function tt() {
          return Yt == null && (Yt = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && typeof self.createImageBitmap == "function"), Yt;
        }
        const Ct = { now: () => Mt !== void 0 ? Mt : performance.now(), setNow(a) {
          Mt = a;
        }, restoreNow() {
          Mt = void 0;
        }, frame(a) {
          const e = requestAnimationFrame(a);
          return { cancel: () => cancelAnimationFrame(e) };
        }, getImageData(a, e = 0) {
          const { width: r, height: s } = a;
          Ae || (Ae = document.createElement("canvas"));
          const h = Ae.getContext("2d", { willReadFrequently: !0 });
          if (!h) throw new Error("failed to create canvas 2d context");
          return (r > Ae.width || s > Ae.height) && (Ae.width = r, Ae.height = s), h.clearRect(-e, -e, r + 2 * e, s + 2 * e), h.drawImage(a, 0, 0, r, s), h.getImageData(-e, -e, r + 2 * e, s + 2 * e);
        }, resolveURL: (a) => (Ft || (Ft = document.createElement("a")), Ft.href = a, Ft.href), get devicePixelRatio() {
          return window.devicePixelRatio;
        }, get prefersReducedMotion() {
          return !!window.matchMedia && (ai == null && (ai = window.matchMedia("(prefers-reduced-motion: reduce)")), ai.matches);
        }, hasCanvasFingerprintNoise() {
          if (Fe !== void 0) return Fe;
          if (!tt()) return Fe = !1, !1;
          const a = new OffscreenCanvas(85, 1), e = a.getContext("2d", { willReadFrequently: !0 });
          let r = 0;
          for (let h = 0; h < a.width; ++h) e.fillStyle = `rgba(${r++},${r++},${r++}, 255)`, e.fillRect(h, 0, 1, 1);
          const s = e.getImageData(0, 0, a.width, a.height);
          r = 0;
          for (let h = 0; h < s.data.length; ++h) if (h % 4 != 3 && r++ !== s.data[h]) return Fe = !0, !0;
          return Fe = !1, !1;
        } };
        function It(a, e) {
          const r = a.indexOf("?");
          if (r < 0) return `${a}?${new URLSearchParams(e).toString()}`;
          const s = new URLSearchParams(a.slice(r));
          for (const h in e) s.set(h, e[h]);
          return `${a.slice(0, r)}?${s.toString()}`;
        }
        function Ut(a, e = { persistentParams: [] }) {
          const r = a.indexOf("?");
          if (r < 0) return a;
          const s = new URLSearchParams(), h = new URLSearchParams(a.slice(r));
          for (const f of e.persistentParams) {
            const b = h.get(f);
            b && s.set(f, b);
          }
          const o = s.toString();
          return `${a.slice(0, r)}${o.length > 0 ? `?${o}` : ""}`;
        }
        const ti = "mapbox-tiles";
        let Pt = 500, Wt = 50;
        const ei = ["language", "worldview", "jobid"];
        let oi, _i;
        function Di() {
          try {
            return caches;
          } catch {
          }
        }
        function Bi() {
          const a = Di();
          a && oi == null && (oi = a.open(ti));
        }
        let Hi = 1 / 0;
        const nr = { supported: !1, testSupport: function(a) {
          !Rr && dr && (Br ? Ir(a) : rr = a);
        } };
        let rr, dr, Rr = !1, Br = !1;
        const Ki = typeof self < "u" ? self : {};
        function Ir(a) {
          const e = a.createTexture();
          a.bindTexture(a.TEXTURE_2D, e);
          try {
            if (a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, dr), a.isContextLost()) return;
            nr.supported = !0;
          } catch {
          }
          a.deleteTexture(e), Rr = !0;
        }
        Ki.document && (dr = Ki.document.createElement("img"), dr.onload = function() {
          rr && Ir(rr), rr = null, Br = !0;
        }, dr.onerror = function() {
          Rr = !0, rr = null;
        }, dr.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const Mr = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Iconset: "Iconset", Image: "Image", Model: "Model" };
        typeof Object.freeze == "function" && Object.freeze(Mr);
        class wn extends Error {
          constructor(e, r, s) {
            r === 401 && Et(s) && (e += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(e), this.status = r, this.url = s;
          }
          toString() {
            return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
          }
        }
        const xn = Ze() ? () => self.worker && self.worker.referrer : () => (location.protocol === "blob:" ? parent : self).location.href, En = function(a, e) {
          if (!(/^file:/.test(r = a.url) || /^file:/.test(xn()) && !/^\w+:/.test(r))) {
            if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function(s, h) {
              const o = new AbortController(), f = new Request(s.url, { method: s.method || "GET", body: s.body, credentials: s.credentials, headers: s.headers, referrer: xn(), referrerPolicy: s.referrerPolicy, signal: o.signal });
              let b = !1, O = !1;
              const H = (y = f.url).indexOf("sku=") > 0 && Et(y);
              var y;
              s.type === "json" && f.headers.set("Accept", "application/json");
              const B = (L, F, Y) => {
                if (O) return;
                if (L && L.message !== "SecurityError" && Se(L.toString()), F && Y) return G(F);
                const ce = Date.now();
                fetch(f).then((_e) => {
                  if (_e.ok) {
                    const ze = H ? _e.clone() : null;
                    return G(_e, ze, ce);
                  }
                  return h(new wn(_e.statusText, _e.status, s.url));
                }).catch((_e) => {
                  _e.name !== "AbortError" && h(new Error(`${_e.message} ${s.url}`));
                });
              }, G = (L, F, Y) => {
                (s.type === "arrayBuffer" ? L.arrayBuffer() : s.type === "json" ? L.json() : L.text()).then((ce) => {
                  O || (F && Y && function(_e, ze, Ne) {
                    if (Bi(), oi == null) return;
                    const Ee = fe(ze.headers.get("Cache-Control") || "");
                    if (Ee["no-store"]) return;
                    const We = { status: ze.status, statusText: ze.statusText, headers: new Headers() };
                    ze.headers.forEach((Bt, zt) => We.headers.set(zt, Bt)), Ee["max-age"] && We.headers.set("Expires", new Date(Ne + 1e3 * Ee["max-age"]).toUTCString());
                    const lt = We.headers.get("Expires");
                    if (!lt || new Date(lt).getTime() - Ne < 42e4) return;
                    let yt = Ut(_e.url, { persistentParams: ei });
                    if (ze.status === 206) {
                      const Bt = _e.headers.get("Range");
                      if (!Bt) return;
                      We.status = 200, yt = It(yt, { range: Bt });
                    }
                    (function(Bt, zt) {
                      if (_i === void 0) try {
                        new Response(new ReadableStream()), _i = !0;
                      } catch {
                        _i = !1;
                      }
                      _i ? zt(Bt.body) : Bt.blob().then(zt);
                    })(ze, (Bt) => {
                      const zt = new Response((Dt = ze.status) !== 200 && Dt !== 404 && [101, 103, 204, 205, 304].includes(Dt) ? null : Bt, We);
                      var Dt;
                      Bi(), oi != null && oi.then((ni) => ni.put(yt, zt)).catch((ni) => Se(ni.message));
                    });
                  }(f, F, Y), b = !0, h(null, ce, L.headers.get("Cache-Control"), L.headers.get("Expires")));
                }).catch((ce) => {
                  O || h(new Error(ce.message));
                });
              };
              return H ? function(L, F) {
                if (Bi(), oi == null) return F(null);
                oi.then((Y) => {
                  let ce = Ut(L.url, { persistentParams: ei });
                  const _e = L.headers.get("Range");
                  _e && (ce = It(ce, { range: _e })), Y.match(ce).then((ze) => {
                    const Ne = function(Ee) {
                      if (!Ee) return !1;
                      const We = new Date(Ee.headers.get("Expires") || 0), lt = fe(Ee.headers.get("Cache-Control") || "");
                      return We > Date.now() && !lt["no-cache"];
                    }(ze);
                    Y.delete(ce), Ne && Y.put(ce, ze.clone()), F(null, ze, Ne);
                  }).catch(F);
                }).catch(F);
              }(f, B) : B(null, null), { cancel: () => {
                O = !0, b || o.abort();
              } };
            }(a, e);
            if (Ze() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", a, e, void 0, !0);
          }
          var r;
          return function(s, h) {
            const o = new XMLHttpRequest();
            o.open(s.method || "GET", s.url, !0), s.type === "arrayBuffer" && (o.responseType = "arraybuffer");
            for (const f in s.headers) o.setRequestHeader(f, s.headers[f]);
            return s.type === "json" && (o.responseType = "text", o.setRequestHeader("Accept", "application/json")), o.withCredentials = s.credentials === "include", o.onerror = () => {
              h(new Error(o.statusText));
            }, o.onload = () => {
              if ((o.status >= 200 && o.status < 300 || o.status === 0) && o.response !== null) {
                let f = o.response;
                if (s.type === "json") try {
                  f = JSON.parse(o.response);
                } catch (b) {
                  return h(b);
                }
                h(null, f, o.getResponseHeader("Cache-Control"), o.getResponseHeader("Expires"));
              } else h(new wn(o.statusText, o.status, s.url));
            }, o.send(s.body), { cancel: () => o.abort() };
          }(a, e);
        }, Vn = function(a, e) {
          return En(I(a, { type: "arrayBuffer" }), e);
        };
        function Yn(a) {
          const e = document.createElement("a");
          return e.href = a, e.protocol === location.protocol && e.host === location.host;
        }
        const ka = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let ea, ga;
        ea = [], ga = 0;
        const Ta = function(a, e) {
          if (nr.supported && (a.headers || (a.headers = {}), a.headers.accept = "image/webp,*/*"), ga >= $e.MAX_PARALLEL_IMAGE_REQUESTS) {
            const o = { requestParameters: a, callback: e, cancelled: !1, cancel() {
              this.cancelled = !0;
            } };
            return ea.push(o), o;
          }
          ga++;
          let r = !1;
          const s = () => {
            if (!r) for (r = !0, ga--; ea.length && ga < $e.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const o = ea.shift(), { requestParameters: f, callback: b, cancelled: O } = o;
              O || (o.cancel = Ta(f, b).cancel);
            }
          }, h = Vn(a, (o, f, b, O) => {
            s(), o ? e(o) : f && (self.createImageBitmap ? function(H, y) {
              const B = new Blob([new Uint8Array(H)], { type: "image/png" });
              createImageBitmap(B).then((G) => {
                y(null, G);
              }).catch((G) => {
                y(new Error(`Could not load image because of ${G.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
              });
            }(f, (H, y) => e(H, y, b, O)) : function(H, y) {
              const B = new Image();
              B.onload = () => {
                y(null, B), URL.revokeObjectURL(B.src), B.onload = null, requestAnimationFrame(() => {
                  B.src = ka;
                });
              }, B.onerror = () => y(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              const G = new Blob([new Uint8Array(H)], { type: "image/png" });
              B.src = H.byteLength ? URL.createObjectURL(G) : ka;
            }(f, (H, y) => e(H, y, b, O)));
          });
          return { cancel: () => {
            h.cancel(), s();
          } };
        };
        var ha, Bo, Ao, za = { exports: {} }, ss = { exports: {} }, os = { exports: {} }, Ms = function() {
          if (Ao) return za.exports;
          Ao = 1;
          var a = (ha || (ha = 1, ss.exports = function(r, s) {
            var h, o, f, b, O, H, y, B;
            for (o = r.length - (h = 3 & r.length), f = s, O = 3432918353, H = 461845907, B = 0; B < o; ) y = 255 & r.charCodeAt(B) | (255 & r.charCodeAt(++B)) << 8 | (255 & r.charCodeAt(++B)) << 16 | (255 & r.charCodeAt(++B)) << 24, ++B, f = 27492 + (65535 & (b = 5 * (65535 & (f = (f ^= y = (65535 & (y = (y = (65535 & y) * O + (((y >>> 16) * O & 65535) << 16) & 4294967295) << 15 | y >>> 17)) * H + (((y >>> 16) * H & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (b >>> 16) & 65535) << 16);
            switch (y = 0, h) {
              case 3:
                y ^= (255 & r.charCodeAt(B + 2)) << 16;
              case 2:
                y ^= (255 & r.charCodeAt(B + 1)) << 8;
              case 1:
                f ^= y = (65535 & (y = (y = (65535 & (y ^= 255 & r.charCodeAt(B))) * O + (((y >>> 16) * O & 65535) << 16) & 4294967295) << 15 | y >>> 17)) * H + (((y >>> 16) * H & 65535) << 16) & 4294967295;
            }
            return f ^= r.length, f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295, f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295, (f ^= f >>> 16) >>> 0;
          }), ss.exports), e = (Bo || (Bo = 1, os.exports = function(r, s) {
            for (var h, o = r.length, f = s ^ o, b = 0; o >= 4; ) h = 1540483477 * (65535 & (h = 255 & r.charCodeAt(b) | (255 & r.charCodeAt(++b)) << 8 | (255 & r.charCodeAt(++b)) << 16 | (255 & r.charCodeAt(++b)) << 24)) + ((1540483477 * (h >>> 16) & 65535) << 16), f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (h = 1540483477 * (65535 & (h ^= h >>> 24)) + ((1540483477 * (h >>> 16) & 65535) << 16)), o -= 4, ++b;
            switch (o) {
              case 3:
                f ^= (255 & r.charCodeAt(b + 2)) << 16;
              case 2:
                f ^= (255 & r.charCodeAt(b + 1)) << 8;
              case 1:
                f = 1540483477 * (65535 & (f ^= 255 & r.charCodeAt(b))) + ((1540483477 * (f >>> 16) & 65535) << 16);
            }
            return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16), (f ^= f >>> 15) >>> 0;
          }), os.exports);
          return za.exports = a, za.exports.murmur3 = a, za.exports.murmur2 = e, za.exports;
        }(), La = N(Ms);
        class mn {
          constructor(e, ...r) {
            I(this, r[0] || {}), this.type = e;
          }
        }
        class eo extends mn {
          constructor(e, r = {}) {
            super("error", I({ error: e }, r));
          }
        }
        function mo(a, e, r) {
          r[a] && r[a].indexOf(e) !== -1 || (r[a] = r[a] || [], r[a].push(e));
        }
        function Ba(a, e, r) {
          if (r && r[a]) {
            const s = r[a].indexOf(e);
            s !== -1 && r[a].splice(s, 1);
          }
        }
        class tn {
          on(e, r) {
            return this._listeners = this._listeners || {}, mo(e, r, this._listeners), this;
          }
          off(e, r) {
            return Ba(e, r, this._listeners), Ba(e, r, this._oneTimeListeners), this;
          }
          once(e, r) {
            return r ? (this._oneTimeListeners = this._oneTimeListeners || {}, mo(e, r, this._oneTimeListeners), this) : new Promise((s) => this.once(e, s));
          }
          fire(e, r) {
            const s = typeof e == "string" ? new mn(e, r) : e, h = s.type;
            if (this.listens(h)) {
              s.target = this;
              const o = this._listeners && this._listeners[h] ? this._listeners[h].slice() : [];
              for (const O of o) O.call(this, s);
              const f = this._oneTimeListeners && this._oneTimeListeners[h] ? this._oneTimeListeners[h].slice() : [];
              for (const O of f) Ba(h, O, this._oneTimeListeners), O.call(this, s);
              const b = this._eventedParent;
              b && (I(s, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), b.fire(s));
            } else s instanceof eo && console.error(s.error);
            return this;
          }
          listens(e) {
            return !!(this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e));
          }
          setEventedParent(e, r) {
            return this._eventedParent = e, this._eventedParentData = r, this;
          }
        }
        var ys, Qa = {}, fa = function() {
          if (ys) return Qa;
          ys = 1;
          var a = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
          function e(o) {
            return (o = Math.round(o)) < 0 ? 0 : o > 255 ? 255 : o;
          }
          function r(o) {
            return e(o[o.length - 1] === "%" ? parseFloat(o) / 100 * 255 : parseInt(o));
          }
          function s(o) {
            return (f = o[o.length - 1] === "%" ? parseFloat(o) / 100 : parseFloat(o)) < 0 ? 0 : f > 1 ? 1 : f;
            var f;
          }
          function h(o, f, b) {
            return b < 0 ? b += 1 : b > 1 && (b -= 1), 6 * b < 1 ? o + (f - o) * b * 6 : 2 * b < 1 ? f : 3 * b < 2 ? o + (f - o) * (2 / 3 - b) * 6 : o;
          }
          try {
            Qa.parseCSSColor = function(o) {
              var f, b = o.replace(/ /g, "").toLowerCase();
              if (b in a) return a[b].slice();
              if (b[0] === "#") return b.length === 4 ? (f = parseInt(b.substr(1), 16)) >= 0 && f <= 4095 ? [(3840 & f) >> 4 | (3840 & f) >> 8, 240 & f | (240 & f) >> 4, 15 & f | (15 & f) << 4, 1] : null : b.length === 7 && (f = parseInt(b.substr(1), 16)) >= 0 && f <= 16777215 ? [(16711680 & f) >> 16, (65280 & f) >> 8, 255 & f, 1] : null;
              var O = b.indexOf("("), H = b.indexOf(")");
              if (O !== -1 && H + 1 === b.length) {
                var y = b.substr(0, O), B = b.substr(O + 1, H - (O + 1)).split(","), G = 1;
                switch (y) {
                  case "rgba":
                    if (B.length !== 4) return null;
                    G = s(B.pop());
                  case "rgb":
                    return B.length !== 3 ? null : [r(B[0]), r(B[1]), r(B[2]), G];
                  case "hsla":
                    if (B.length !== 4) return null;
                    G = s(B.pop());
                  case "hsl":
                    if (B.length !== 3) return null;
                    var L = (parseFloat(B[0]) % 360 + 360) % 360 / 360, F = s(B[1]), Y = s(B[2]), ce = Y <= 0.5 ? Y * (F + 1) : Y + F - Y * F, _e = 2 * Y - ce;
                    return [e(255 * h(_e, ce, L + 1 / 3)), e(255 * h(_e, ce, L)), e(255 * h(_e, ce, L - 1 / 3)), G];
                  default:
                    return null;
                }
              }
              return null;
            };
          } catch {
          }
          return Qa;
        }();
        class Wr {
          constructor(e, r, s, h = 1) {
            this.r = e, this.g = r, this.b = s, this.a = h;
          }
          static parse(e) {
            if (!e) return;
            if (e instanceof Wr) return e;
            if (typeof e != "string") return;
            const r = fa.parseCSSColor(e);
            return r ? new Wr(r[0] / 255 * r[3], r[1] / 255 * r[3], r[2] / 255 * r[3], r[3]) : void 0;
          }
          toStringPremultipliedAlpha() {
            const [e, r, s, h] = this.a === 0 ? [0, 0, 0, 0] : [255 * this.r / this.a, 255 * this.g / this.a, 255 * this.b / this.a, this.a];
            return `rgba(${Math.round(e)},${Math.round(r)},${Math.round(s)},${h})`;
          }
          toString() {
            const [e, r, s, h] = [this.r, this.g, this.b, this.a];
            return `rgba(${Math.round(255 * e)},${Math.round(255 * r)},${Math.round(255 * s)},${h})`;
          }
          toRenderColor(e) {
            const { r, g: s, b: h, a: o } = this;
            return new es(e, r, s, h, o);
          }
          clone() {
            return new Wr(this.r, this.g, this.b, this.a);
          }
        }
        class es {
          constructor(e, r, s, h, o) {
            if (e) {
              const f = e.image.height, b = f * f;
              r = o === 0 ? 0 : r / o * (f - 1), s = o === 0 ? 0 : s / o * (f - 1), h = o === 0 ? 0 : h / o * (f - 1);
              const O = Math.floor(r), H = Math.floor(s), y = Math.floor(h), B = Math.ceil(r), G = Math.ceil(s), L = Math.ceil(h), F = r - O, Y = s - H, ce = h - y, _e = e.image.data, ze = 4 * (O + H * b + y * f), Ne = 4 * (O + H * b + L * f), Ee = 4 * (O + G * b + y * f), We = 4 * (O + G * b + L * f), lt = 4 * (B + H * b + y * f), yt = 4 * (B + H * b + L * f), Bt = 4 * (B + G * b + y * f), zt = 4 * (B + G * b + L * f);
              if (ze < 0 || zt >= _e.length) throw new Error("out of range");
              this.r = Tr(Tr(Tr(_e[ze], _e[Ne], ce), Tr(_e[Ee], _e[We], ce), Y), Tr(Tr(_e[lt], _e[yt], ce), Tr(_e[Bt], _e[zt], ce), Y), F) / 255 * o, this.g = Tr(Tr(Tr(_e[ze + 1], _e[Ne + 1], ce), Tr(_e[Ee + 1], _e[We + 1], ce), Y), Tr(Tr(_e[lt + 1], _e[yt + 1], ce), Tr(_e[Bt + 1], _e[zt + 1], ce), Y), F) / 255 * o, this.b = Tr(Tr(Tr(_e[ze + 2], _e[Ne + 2], ce), Tr(_e[Ee + 2], _e[We + 2], ce), Y), Tr(Tr(_e[lt + 2], _e[yt + 2], ce), Tr(_e[Bt + 2], _e[zt + 2], ce), Y), F) / 255 * o, this.a = o;
            } else this.r = r, this.g = s, this.b = h, this.a = o;
          }
          toArray() {
            const { r: e, g: r, b: s, a: h } = this;
            return h === 0 ? [0, 0, 0, 0] : [255 * e / h, 255 * r / h, 255 * s / h, h];
          }
          toHslaArray() {
            if (this.a === 0) return [0, 0, 0, 0];
            const { r: e, g: r, b: s, a: h } = this, o = Math.min(Math.max(e / h, 0), 1), f = Math.min(Math.max(r / h, 0), 1), b = Math.min(Math.max(s / h, 0), 1), O = Math.min(o, f, b), H = Math.max(o, f, b), y = (O + H) / 2;
            if (O === H) return [0, 0, 100 * y, h];
            const B = H - O, G = y > 0.5 ? B / (2 - H - O) : B / (H + O);
            let L = 0;
            return H === o ? L = (f - b) / B + (f < b ? 6 : 0) : H === f ? L = (b - o) / B + 2 : H === b && (L = (o - f) / B + 4), L *= 60, [Math.min(Math.max(L, 0), 360), Math.min(Math.max(100 * G, 0), 100), Math.min(Math.max(100 * y, 0), 100), h];
          }
          toArray01() {
            const { r: e, g: r, b: s, a: h } = this;
            return h === 0 ? [0, 0, 0, 0] : [e / h, r / h, s / h, h];
          }
          toArray01Scaled(e) {
            const { r, g: s, b: h, a: o } = this;
            return o === 0 ? [0, 0, 0] : [r / o * e, s / o * e, h / o * e];
          }
          toArray01PremultipliedAlpha() {
            const { r: e, g: r, b: s, a: h } = this;
            return [e, r, s, h];
          }
          toArray01Linear() {
            const { r: e, g: r, b: s, a: h } = this;
            return h === 0 ? [0, 0, 0, 0] : [Math.pow(e / h, 2.2), Math.pow(r / h, 2.2), Math.pow(s / h, 2.2), h];
          }
        }
        function Tr(a, e, r) {
          return a * (1 - r) + e * r;
        }
        function Is(a, e, r) {
          return a.map((s, h) => Tr(s, e[h], r));
        }
        Wr.black = new Wr(0, 0, 0, 1), Wr.white = new Wr(1, 1, 1, 1), Wr.transparent = new Wr(0, 0, 0, 0), Wr.red = new Wr(1, 0, 0, 1), Wr.blue = new Wr(0, 0, 1, 1);
        var D = Object.freeze({ __proto__: null, array: Is, color: function(a, e, r) {
          return new Wr(Tr(a.r, e.r, r), Tr(a.g, e.g, r), Tr(a.b, e.b, r), Tr(a.a, e.a, r));
        }, number: Tr });
        function be(a, ...e) {
          for (const r of e) for (const s in r) a[s] = r[s];
          return a;
        }
        class ht extends Error {
          constructor(e, r) {
            super(r), this.message = r, this.key = e;
          }
        }
        class Ot {
          constructor(e, r = []) {
            this.parent = e, this.bindings = {};
            for (const [s, h] of r) this.bindings[s] = h;
          }
          concat(e) {
            return new Ot(this, e);
          }
          get(e) {
            if (this.bindings[e]) return this.bindings[e];
            if (this.parent) return this.parent.get(e);
            throw new Error(`${e} not found in scope.`);
          }
          has(e) {
            return !!this.bindings[e] || !!this.parent && this.parent.has(e);
          }
        }
        const hi = { kind: "null" }, di = { kind: "number" }, ki = { kind: "string" }, er = { kind: "boolean" }, _r = { kind: "color" }, en = { kind: "object" }, br = { kind: "value" }, Gn = { kind: "collator" }, Ia = { kind: "formatted" }, ls = { kind: "resolvedImage" };
        function Hn(a, e) {
          return { kind: "array", itemType: a, N: e };
        }
        function Dn(a) {
          if (a.kind === "array") {
            const e = Dn(a.itemType);
            return typeof a.N == "number" ? `array<${e}, ${a.N}>` : a.itemType.kind === "value" ? "array" : `array<${e}>`;
          }
          return a.kind;
        }
        const xs = [hi, di, ki, er, _r, Ia, en, Hn(br), ls];
        function va(a, e) {
          if (e.kind === "error") return null;
          if (a.kind === "array") {
            if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !va(a.itemType, e.itemType)) && (typeof a.N != "number" || a.N === e.N)) return null;
          } else {
            if (a.kind === e.kind) return null;
            if (a.kind === "value") {
              for (const r of xs) if (!va(r, e)) return null;
            }
          }
          return `Expected ${Dn(a)} but found ${Dn(e)} instead.`;
        }
        function sl(a, e) {
          return e.some((r) => r.kind === a.kind);
        }
        function Fo(a, e) {
          return e.some((r) => r === "null" ? a === null : r === "array" ? Array.isArray(a) : r === "object" ? a && !Array.isArray(a) && typeof a == "object" : r === typeof a);
        }
        class No {
          constructor(e, r, s) {
            this.sensitivity = e ? r ? "variant" : "case" : r ? "accent" : "base", this.locale = s, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(e, r) {
            return this.collator.compare(e, r);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        class Vs {
          constructor(e, r, s, h, o) {
            this.text = e.normalize ? e.normalize() : e, this.image = r, this.scale = s, this.fontStack = h, this.textColor = o;
          }
        }
        class Na {
          constructor(e) {
            this.sections = e;
          }
          static fromString(e) {
            return new Na([new Vs(e, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.namePrimary);
          }
          static factory(e) {
            return e instanceof Na ? e : Na.fromString(e);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
          }
          serialize() {
            const e = ["format"];
            for (const r of this.sections) {
              if (r.image) {
                e.push(["image", r.image.namePrimary]);
                continue;
              }
              e.push(r.text);
              const s = {};
              r.fontStack && (s["text-font"] = ["literal", r.fontStack.split(",")]), r.scale && (s["font-scale"] = r.scale), r.textColor && (s["text-color"] = ["rgba"].concat(r.textColor.toRenderColor(null).toArray())), e.push(s);
            }
            return e;
          }
        }
        class bs {
          constructor(e, r) {
            if (this.id = e, this.options = r || { params: {} }, this.options.transform) {
              const { a: s, b: h, c: o, d: f, e: b, f: O } = this.options.transform;
              this.options.transform = new DOMMatrix([s, h, o, f, b, O]);
            } else this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0]);
          }
          static deserializeId(e) {
            return JSON.parse(e).id;
          }
          static deserializeFromString(e) {
            const r = JSON.parse(e), { a: s, b: h, c: o, d: f, e: b, f: O } = r.options.transform;
            return new DOMMatrix([s, h, o, f, b, O]), new bs(r.id, r.options);
          }
          scaleSelf(e) {
            return this.options.transform = this.options.transform.scale(e), this;
          }
          serialize() {
            const e = { id: this.id };
            this.options && (e.options = this.options);
            const { a: r, b: s, c: h, d: o, e: f, f: b } = this.options.transform;
            return e.options.transform = { a: r, b: s, c: h, d: o, e: f, f: b }, JSON.stringify(e);
          }
        }
        class Ua {
          constructor(e) {
            this.namePrimary = e.namePrimary, e.nameSecondary && (this.nameSecondary = e.nameSecondary), e.optionsPrimary && (this.optionsPrimary = e.optionsPrimary), e.optionsSecondary && (this.optionsSecondary = e.optionsSecondary), this.available = e.available;
          }
          toString() {
            return this.namePrimary && this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
          }
          getPrimary() {
            return new bs(this.namePrimary, { params: this.optionsPrimary && this.optionsPrimary.params || {} });
          }
          getSerializedPrimary() {
            return this.getPrimary().serialize();
          }
          getSecondary() {
            return this.nameSecondary ? new bs(this.nameSecondary, { params: this.optionsSecondary && this.optionsSecondary.params || {} }) : null;
          }
          static from(e) {
            return typeof e == "string" ? Ua.build(e) : e;
          }
          static build(e, r, s, h) {
            return e ? new Ua({ namePrimary: e, nameSecondary: r, optionsPrimary: s, optionsSecondary: h, available: !1 }) : null;
          }
        }
        function ol(a, e, r, s) {
          return typeof a == "number" && a >= 0 && a <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof r == "number" && r >= 0 && r <= 255 ? s === void 0 || typeof s == "number" && s >= 0 && s <= 1 ? null : `Invalid rgba value [${[a, e, r, s].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof s == "number" ? [a, e, r, s] : [a, e, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function js(a) {
          if (a === null || typeof a == "string" || typeof a == "boolean" || typeof a == "number" || a instanceof Wr || a instanceof No || a instanceof Na || a instanceof Ua) return !0;
          if (Array.isArray(a)) {
            for (const e of a) if (!js(e)) return !1;
            return !0;
          }
          if (typeof a == "object") {
            for (const e in a) if (!js(a[e])) return !1;
            return !0;
          }
          return !1;
        }
        function Nn(a) {
          if (a === null) return hi;
          if (typeof a == "string") return ki;
          if (typeof a == "boolean") return er;
          if (typeof a == "number") return di;
          if (a instanceof Wr) return _r;
          if (a instanceof No) return Gn;
          if (a instanceof Na) return Ia;
          if (a instanceof Ua) return ls;
          if (Array.isArray(a)) {
            const e = a.length;
            let r;
            for (const s of a) {
              const h = Nn(s);
              if (r) {
                if (r === h) continue;
                r = br;
                break;
              }
              r = h;
            }
            return Hn(r || br, e);
          }
          return en;
        }
        function qn(a) {
          const e = typeof a;
          return a === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(a) : a instanceof Wr ? a.toStringPremultipliedAlpha() : a instanceof Na || a instanceof Ua ? a.toString() : JSON.stringify(a);
        }
        class ta {
          constructor(e, r) {
            this.type = e, this.value = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (!js(e[1])) return r.error("invalid value");
            const s = e[1];
            let h = Nn(s);
            const o = r.expectedType;
            return h.kind !== "array" || h.N !== 0 || !o || o.kind !== "array" || typeof o.N == "number" && o.N !== 0 || (h = o), new ta(h, s);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof Wr ? ["rgba"].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof Na ? this.value.serialize() : this.value;
          }
        }
        class ia {
          constructor(e) {
            this.name = "ExpressionEvaluationError", this.message = e;
          }
          toJSON() {
            return this.message;
          }
        }
        const ps = { string: ki, number: di, boolean: er, object: en };
        class Gs {
          constructor(e, r) {
            this.type = e, this.args = r;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected at least one argument.");
            let s, h = 1;
            const o = e[0];
            if (o === "array") {
              let b, O;
              if (e.length > 2) {
                const H = e[1];
                if (typeof H != "string" || !(H in ps) || H === "object") return r.error('The item type argument of "array" must be one of string, number, boolean', 1);
                b = ps[H], h++;
              } else b = br;
              if (e.length > 3) {
                if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return r.error('The length argument to "array" must be a positive integer literal', 2);
                O = e[2], h++;
              }
              s = Hn(b, O);
            } else s = ps[o];
            const f = [];
            for (; h < e.length; h++) {
              const b = r.parse(e[h], h, br);
              if (!b) return null;
              f.push(b);
            }
            return new Gs(s, f);
          }
          evaluate(e) {
            for (let r = 0; r < this.args.length; r++) {
              const s = this.args[r].evaluate(e);
              if (!va(this.type, Nn(s))) return s;
              if (r === this.args.length - 1) throw new ia(`The expression ${JSON.stringify(this.args[r].serialize())} evaluated to ${Dn(Nn(s))} but was expected to be of type ${Dn(this.type)}.`);
            }
            return null;
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every((e) => e.outputDefined());
          }
          serialize() {
            const e = this.type, r = [e.kind];
            if (e.kind === "array") {
              const s = e.itemType;
              if (s.kind === "string" || s.kind === "number" || s.kind === "boolean") {
                r.push(s.kind);
                const h = e.N;
                (typeof h == "number" || this.args.length > 1) && r.push(h);
              }
            }
            return r.concat(this.args.map((s) => s.serialize()));
          }
        }
        class aa {
          constructor(e) {
            this.type = Ia, this.sections = e;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected at least one argument.");
            const s = e[1];
            if (!Array.isArray(s) && typeof s == "object") return r.error("First argument must be an image or text section.");
            const h = [];
            let o = !1;
            for (let f = 1; f <= e.length - 1; ++f) {
              const b = e[f];
              if (o && typeof b == "object" && !Array.isArray(b)) {
                o = !1;
                let O = null;
                if (b["font-scale"] && (O = r.parseObjectValue(b["font-scale"], f, "font-scale", di), !O)) return null;
                let H = null;
                if (b["text-font"] && (H = r.parseObjectValue(b["text-font"], f, "text-font", Hn(ki)), !H)) return null;
                let y = null;
                if (b["text-color"] && (y = r.parseObjectValue(b["text-color"], f, "text-color", _r), !y)) return null;
                const B = h[h.length - 1];
                B.scale = O, B.font = H, B.textColor = y;
              } else {
                const O = r.parse(e[f], f, br);
                if (!O) return null;
                const H = O.type.kind;
                if (H !== "string" && H !== "value" && H !== "null" && H !== "resolvedImage") return r.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                o = !0, h.push({ content: O, scale: null, font: null, textColor: null });
              }
            }
            return new aa(h);
          }
          evaluate(e) {
            return new Na(this.sections.map((r) => {
              const s = r.content.evaluate(e);
              return Nn(s) === ls ? new Vs("", s, null, null, null) : new Vs(qn(s), null, r.scale ? r.scale.evaluate(e) : null, r.font ? r.font.evaluate(e).join(",") : null, r.textColor ? r.textColor.evaluate(e) : null);
            }));
          }
          eachChild(e) {
            for (const r of this.sections) e(r.content), r.scale && e(r.scale), r.font && e(r.font), r.textColor && e(r.textColor);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            const e = ["format"];
            for (const r of this.sections) {
              e.push(r.content.serialize());
              const s = {};
              r.scale && (s["font-scale"] = r.scale.serialize()), r.font && (s["text-font"] = r.font.serialize()), r.textColor && (s["text-color"] = r.textColor.serialize()), e.push(s);
            }
            return e;
          }
        }
        class ll {
          constructor(e, r, s, h) {
            this._imageWarnHistory = {}, this.type = ls, this.inputPrimary = e, this.inputSecondary = r, this.inputPrimaryParams = s, this.inputSecondaryParams = h;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected two or more arguments.");
            let s = 1;
            const h = [];
            function o() {
              if (s < e.length) {
                const b = r.parse(e[s], s++, ki);
                return b ? (h.push({ image: b, options: void 0 }), !0) : (r.error(h.length ? "Secondary image variant is not a string." : "No image name provided."), !1);
              }
              return !0;
            }
            function f() {
              if (s < e.length) {
                if ((b = e[s]) === null || typeof b != "object" || Array.isArray(b)) return !0;
                const O = e[s].params, H = r.concat(s);
                if (!O) return s++, !0;
                if (typeof O != "object" || O.constructor !== Object) return H.error('Image options "params" should be an object'), !1;
                const y = {}, B = H.concat(void 0, "params");
                for (const G in O) {
                  if (!G) return B.error("Image parameter name should be non-empty"), !1;
                  const L = B.concat(void 0, G).parse(O[G], void 0, _r, void 0, { typeAnnotation: "coerce" });
                  if (!L) return !1;
                  y[G] = L;
                }
                return h[h.length - 1].options = y, s++, !0;
              }
              var b;
              return !0;
            }
            for (let b = 0; b < 2; b++) if (!o() || !f()) return;
            return new ll(h[0].image, h[1] ? h[1].image : void 0, h[0].options, h[1] ? h[1].options : void 0);
          }
          evaluateParams(e, r) {
            const s = {};
            if (r) {
              for (const h in r) if (r[h]) try {
                const o = r[h].evaluate(e), f = `Ignoring image parameter "${h}" with semi-transparent color ${o.toString()}`;
                if (o.a !== 1) {
                  this._imageWarnHistory[f] || (console.warn(f), this._imageWarnHistory[f] = !0);
                  continue;
                }
                s[h] = o;
              } catch {
                continue;
              }
              if (Object.keys(s).length !== 0) return { params: s };
            }
          }
          evaluate(e) {
            const r = Ua.build(this.inputPrimary.evaluate(e), this.inputSecondary ? this.inputSecondary.evaluate(e) : void 0, this.inputPrimaryParams ? this.evaluateParams(e, this.inputPrimaryParams) : void 0, this.inputSecondaryParams ? this.evaluateParams(e, this.inputSecondaryParams) : void 0);
            return r && e.availableImages && (r.available = e.availableImages.indexOf(r.namePrimary) > -1, r.nameSecondary && r.available && e.availableImages && (r.available = e.availableImages.indexOf(r.nameSecondary) > -1)), r;
          }
          eachChild(e) {
            if (e(this.inputPrimary), this.inputPrimaryParams) for (const r in this.inputPrimaryParams) this.inputPrimaryParams[r] && e(this.inputPrimaryParams[r]);
            if (this.inputSecondary && (e(this.inputSecondary), this.inputSecondaryParams)) for (const r in this.inputSecondaryParams) this.inputSecondaryParams[r] && e(this.inputSecondaryParams[r]);
          }
          outputDefined() {
            return !1;
          }
          serializeParams(e) {
            const r = {};
            if (e) {
              for (const s in e) e[s] && (r[s] = e[s].serialize());
              return { params: r };
            }
          }
          serialize() {
            const e = ["image", this.inputPrimary.serialize()];
            return this.inputPrimaryParams && e.push(this.serializeParams(this.inputPrimaryParams)), this.inputSecondary && (e.push(this.inputSecondary.serialize()), this.inputSecondaryParams && e.push(this.serializeParams(this.inputSecondaryParams))), e;
          }
        }
        function ts(a) {
          return a instanceof Number ? "number" : a instanceof String ? "string" : a instanceof Boolean ? "boolean" : Array.isArray(a) ? "array" : a === null ? "null" : typeof a;
        }
        const to = { "to-boolean": er, "to-color": _r, "to-number": di, "to-string": ki };
        class _o {
          constructor(e, r) {
            this.type = e, this.args = r;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expected at least one argument.");
            const s = e[0], h = [];
            let o = hi;
            if (s === "to-array") {
              if (!Array.isArray(e[1])) return null;
              const f = e[1].length;
              if (r.expectedType) {
                if (r.expectedType.kind !== "array") return r.error(`Expected ${r.expectedType.kind} but found array.`);
                o = Hn(r.expectedType.itemType, f);
              } else {
                if (!(f > 0 && js(e[1][0]))) return null;
                o = Hn(Nn(e[1][0]), f);
              }
              for (let b = 0; b < f; b++) {
                const O = e[1][b];
                let H;
                if (ts(O) === "array") H = r.parse(O, void 0, o.itemType);
                else {
                  const y = ts(O);
                  if (y !== o.itemType.kind) return r.error(`Expected ${o.itemType.kind} but found ${y}.`);
                  H = r.registry.literal.parse(["literal", O === void 0 ? null : O], r);
                }
                if (!H) return null;
                h.push(H);
              }
            } else {
              if ((s === "to-boolean" || s === "to-string") && e.length !== 2) return r.error("Expected one argument.");
              o = to[s];
              for (let f = 1; f < e.length; f++) {
                const b = r.parse(e[f], f, br);
                if (!b) return null;
                h.push(b);
              }
            }
            return new _o(o, h);
          }
          evaluate(e) {
            if (this.type.kind === "boolean") return !!this.args[0].evaluate(e);
            if (this.type.kind === "color") {
              let r, s;
              for (const h of this.args) {
                if (r = h.evaluate(e), s = null, r instanceof Wr) return r;
                if (typeof r == "string") {
                  const o = e.parseColor(r);
                  if (o) return o;
                } else if (Array.isArray(r) && (s = r.length < 3 || r.length > 4 ? `Invalid rbga value ${JSON.stringify(r)}: expected an array containing either three or four numeric values.` : ol(r[0], r[1], r[2], r[3]), !s)) return new Wr(r[0] / 255, r[1] / 255, r[2] / 255, r[3]);
              }
              throw new ia(s || `Could not parse color from value '${typeof r == "string" ? r : String(JSON.stringify(r))}'`);
            }
            if (this.type.kind === "number") {
              let r = null;
              for (const s of this.args) {
                if (r = s.evaluate(e), r === null) return 0;
                const h = Number(r);
                if (!isNaN(h)) return h;
              }
              throw new ia(`Could not convert ${JSON.stringify(r)} to number.`);
            }
            return this.type.kind === "formatted" ? Na.fromString(qn(this.args[0].evaluate(e))) : this.type.kind === "resolvedImage" ? Ua.build(qn(this.args[0].evaluate(e))) : this.type.kind === "array" ? this.args.map((r) => r.evaluate(e)) : qn(this.args[0].evaluate(e));
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every((e) => e.outputDefined());
          }
          serialize() {
            if (this.type.kind === "formatted") return new aa([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
            if (this.type.kind === "resolvedImage") return new ll(this.args[0]).serialize();
            const e = this.type.kind === "array" ? [] : [`to-${this.type.kind}`];
            return this.eachChild((r) => {
              e.push(r.serialize());
            }), e;
          }
        }
        const Yh = ["Unknown", "Point", "LineString", "Polygon"];
        class Mc {
          constructor(e, r) {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = e, this.options = r;
          }
          id() {
            return this.feature && this.feature.id !== void 0 ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Yh[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          measureLight(e) {
            return this.globals.brightness || 0;
          }
          distanceFromCenter() {
            if (this.featureTileCoord && this.featureDistanceData) {
              const e = this.featureDistanceData.center, r = this.featureDistanceData.scale, { x: s, y: h } = this.featureTileCoord;
              return this.featureDistanceData.bearing[0] * (s * r - e[0]) + this.featureDistanceData.bearing[1] * (h * r - e[1]);
            }
            return 0;
          }
          parseColor(e) {
            let r = this._parseColorCache[e];
            return r || (r = this._parseColorCache[e] = Wr.parse(e)), r;
          }
          getConfig(e) {
            return this.options ? this.options.get(e) : null;
          }
        }
        class ms {
          constructor(e, r, s, h, o) {
            this.name = e, this.type = r, this._evaluate = s, this.args = h, this._overloadIndex = o;
          }
          evaluate(e) {
            if (!this._evaluate) {
              const r = ms.definitions[this.name];
              this._evaluate = Array.isArray(r) ? r[2] : r.overloads[this._overloadIndex][1];
            }
            return this._evaluate(e, this.args);
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return [this.name].concat(this.args.map((e) => e.serialize()));
          }
          static parse(e, r) {
            const s = e[0], h = ms.definitions[s];
            if (!h) return r.error(`Unknown expression "${s}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const o = Array.isArray(h) ? h[0] : h.type, f = Array.isArray(h) ? [[h[1], h[2]]] : h.overloads, b = [];
            let O = null, H = -1;
            for (const [y, B] of f) {
              if (Array.isArray(y) && y.length !== e.length - 1) continue;
              b.push(y), H++, O = new ec(r.registry, r.path, null, r.scope, void 0, r._scope, r.options);
              const G = [];
              let L = !1;
              for (let F = 1; F < e.length; F++) {
                const Y = e[F], ce = Array.isArray(y) ? y[F - 1] : y.type, _e = O.parse(Y, 1 + G.length, ce);
                if (!_e) {
                  L = !0;
                  break;
                }
                G.push(_e);
              }
              if (!L) if (Array.isArray(y) && y.length !== G.length) O.error(`Expected ${y.length} arguments, but found ${G.length} instead.`);
              else {
                for (let F = 0; F < G.length; F++) {
                  const Y = Array.isArray(y) ? y[F] : y.type, ce = G[F];
                  O.concat(F + 1).checkSubtype(Y, ce.type);
                }
                if (O.errors.length === 0) return new ms(s, o, B, G, H);
              }
            }
            if (b.length === 1) r.errors.push(...O.errors);
            else {
              const y = (b.length ? b : f.map(([G]) => G)).map(au).join(" | "), B = [];
              for (let G = 1; G < e.length; G++) {
                const L = r.parse(e[G], 1 + B.length);
                if (!L) return null;
                B.push(Dn(L.type));
              }
              r.error(`Expected arguments of type ${y}, but found (${B.join(", ")}) instead.`);
            }
            return null;
          }
          static register(e, r) {
            ms.definitions = r;
            for (const s in r) e[s] = ms;
          }
        }
        function au(a) {
          return Array.isArray(a) ? `(${a.map(Dn).join(", ")})` : `(${Dn(a.type)}...)`;
        }
        class Zu {
          constructor(e, r, s) {
            this.type = Gn, this.locale = s, this.caseSensitive = e, this.diacriticSensitive = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error("Expected one argument.");
            const s = e[1];
            if (typeof s != "object" || Array.isArray(s)) return r.error("Collator options argument must be an object.");
            const h = s["case-sensitive"] === void 0 ? r.parse(!1, 1, er) : r.parseObjectValue(s["case-sensitive"], 1, "case-sensitive", er);
            if (!h) return null;
            const o = s["diacritic-sensitive"] === void 0 ? r.parse(!1, 1, er) : r.parseObjectValue(s["diacritic-sensitive"], 1, "diacritic-sensitive", er);
            if (!o) return null;
            let f = null;
            return s.locale && (f = r.parseObjectValue(s.locale, 1, "locale", ki), !f) ? null : new Zu(h, o, f);
          }
          evaluate(e) {
            return new No(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
          }
          eachChild(e) {
            e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            const e = {};
            return e["case-sensitive"] = this.caseSensitive.serialize(), e["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e.locale = this.locale.serialize()), ["collator", e];
          }
        }
        function su(a, e, r = 0, s = a.length - 1, h = Kh) {
          for (; s > r; ) {
            if (s - r > 600) {
              const O = s - r + 1, H = e - r + 1, y = Math.log(O), B = 0.5 * Math.exp(2 * y / 3), G = 0.5 * Math.sqrt(y * B * (O - B) / O) * (H - O / 2 < 0 ? -1 : 1);
              su(a, e, Math.max(r, Math.floor(e - H * B / O + G)), Math.min(s, Math.floor(e + (O - H) * B / O + G)), h);
            }
            const o = a[e];
            let f = r, b = s;
            for (ou(a, r, e), h(a[s], o) > 0 && ou(a, r, s); f < b; ) {
              for (ou(a, f, b), f++, b--; h(a[f], o) < 0; ) f++;
              for (; h(a[b], o) > 0; ) b--;
            }
            h(a[r], o) === 0 ? ou(a, r, b) : (b++, ou(a, b, s)), b <= e && (r = b + 1), e <= b && (s = b - 1);
          }
        }
        function ou(a, e, r) {
          const s = a[e];
          a[e] = a[r], a[r] = s;
        }
        function Kh(a, e) {
          return a < e ? -1 : a > e ? 1 : 0;
        }
        function ul(a) {
          let e = 0;
          for (let r, s, h = 0, o = a.length, f = o - 1; h < o; f = h++) r = a[h], s = a[f], e += (s.x - r.x) * (r.y + s.y);
          return e;
        }
        function Ca(a, e) {
          a[0] = Math.min(a[0], e[0]), a[1] = Math.min(a[1], e[1]), a[2] = Math.max(a[2], e[0]), a[3] = Math.max(a[3], e[1]);
        }
        function kl(a, e) {
          return !(a[0] <= e[0] || a[2] >= e[2] || a[1] <= e[1] || a[3] >= e[3]);
        }
        function lu(a, e, r) {
          const s = a[0] - e[0], h = a[1] - e[1], o = a[0] - r[0], f = a[1] - r[1];
          return s * f - o * h == 0 && s * o <= 0 && h * f <= 0;
        }
        function Ll(a, e, r = !1) {
          let s = !1;
          for (let b = 0, O = e.length; b < O; b++) {
            const H = e[b];
            for (let y = 0, B = H.length, G = B - 1; y < B; G = y++) {
              const L = H[G], F = H[y];
              if (lu(a, L, F)) return r;
              (o = L)[1] > (h = a)[1] != (f = F)[1] > h[1] && h[0] < (f[0] - o[0]) * (h[1] - o[1]) / (f[1] - o[1]) + o[0] && (s = !s);
            }
          }
          var h, o, f;
          return s;
        }
        function $u(a, e, r, s) {
          const h = s[0] - r[0], o = s[1] - r[1], f = (a[0] - r[0]) * o - h * (a[1] - r[1]), b = (e[0] - r[0]) * o - h * (e[1] - r[1]);
          return f > 0 && b < 0 || f < 0 && b > 0;
        }
        function io(a, e, r, s) {
          return (h = [s[0] - r[0], s[1] - r[1]])[0] * (o = [e[0] - a[0], e[1] - a[1]])[1] - h[1] * o[0] != 0 && !(!$u(a, e, r, s) || !$u(r, s, a, e));
          var h, o;
        }
        const ro = 8192;
        function Ol(a, e) {
          const r = (180 + a[0]) / 360, s = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a[1] * Math.PI / 360))) / 360, h = Math.pow(2, e.z);
          return [Math.round(r * h * ro), Math.round(s * h * ro)];
        }
        function Xu(a, e) {
          for (let r = 0; r < e.length; r++) if (Ll(a, e[r])) return !0;
          return !1;
        }
        function Ic(a, e, r) {
          for (const s of r) for (let h = 0, o = s.length, f = o - 1; h < o; f = h++) if (io(a, e, s[f], s[h])) return !0;
          return !1;
        }
        function Pn(a, e) {
          for (let r = 0; r < a.length; ++r) if (!Ll(a[r], e)) return !1;
          for (let r = 0; r < a.length - 1; ++r) if (Ic(a[r], a[r + 1], e)) return !1;
          return !0;
        }
        function Pc(a, e) {
          for (let r = 0; r < e.length; r++) if (Pn(a, e[r])) return !0;
          return !1;
        }
        function Yu(a, e, r) {
          const s = [];
          for (let h = 0; h < a.length; h++) {
            const o = [];
            for (let f = 0; f < a[h].length; f++) {
              const b = Ol(a[h][f], r);
              Ca(e, b), o.push(b);
            }
            s.push(o);
          }
          return s;
        }
        function Uo(a, e, r) {
          const s = [];
          for (let h = 0; h < a.length; h++) {
            const o = Yu(a[h], e, r);
            s.push(o);
          }
          return s;
        }
        function zr(a, e, r, s) {
          if (a[0] < r[0] || a[0] > r[2]) {
            const h = 0.5 * s;
            let o = a[0] - r[0] > h ? -s : r[0] - a[0] > h ? s : 0;
            o === 0 && (o = a[0] - r[2] > h ? -s : r[2] - a[0] > h ? s : 0), a[0] += o;
          }
          Ca(e, a);
        }
        function Sr(a, e, r, s) {
          const h = Math.pow(2, s.z) * ro, o = [s.x * ro, s.y * ro], f = [];
          if (!a) return f;
          for (const b of a) for (const O of b) {
            const H = [O.x + o[0], O.y + o[1]];
            zr(H, e, r, h), f.push(H);
          }
          return f;
        }
        function _n(a, e, r, s) {
          const h = Math.pow(2, s.z) * ro, o = [s.x * ro, s.y * ro], f = [];
          if (!a) return f;
          for (const O of a) {
            const H = [];
            for (const y of O) {
              const B = [y.x + o[0], y.y + o[1]];
              Ca(e, B), H.push(B);
            }
            f.push(H);
          }
          if (e[2] - e[0] <= h / 2) {
            (b = e)[0] = b[1] = 1 / 0, b[2] = b[3] = -1 / 0;
            for (const O of f) for (const H of O) zr(H, e, r, h);
          }
          var b;
          return f;
        }
        class Lr {
          constructor(e, r) {
            this.type = er, this.geojson = e, this.geometries = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
            if (js(e[1])) {
              const s = e[1];
              if (s.type === "FeatureCollection") for (let h = 0; h < s.features.length; ++h) {
                const o = s.features[h].geometry.type;
                if (o === "Polygon" || o === "MultiPolygon") return new Lr(s, s.features[h].geometry);
              }
              else if (s.type === "Feature") {
                const h = s.geometry.type;
                if (h === "Polygon" || h === "MultiPolygon") return new Lr(s, s.geometry);
              } else if (s.type === "Polygon" || s.type === "MultiPolygon") return new Lr(s, s);
            }
            return r.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(e) {
            if (e.geometry() != null && e.canonicalID() != null) {
              if (e.geometryType() === "Point") return function(r, s) {
                const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], o = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = r.canonicalID();
                if (!f) return !1;
                if (s.type === "Polygon") {
                  const b = Yu(s.coordinates, o, f), O = Sr(r.geometry(), h, o, f);
                  if (!kl(h, o)) return !1;
                  for (const H of O) if (!Ll(H, b)) return !1;
                }
                if (s.type === "MultiPolygon") {
                  const b = Uo(s.coordinates, o, f), O = Sr(r.geometry(), h, o, f);
                  if (!kl(h, o)) return !1;
                  for (const H of O) if (!Xu(H, b)) return !1;
                }
                return !0;
              }(e, this.geometries);
              if (e.geometryType() === "LineString") return function(r, s) {
                const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0], o = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = r.canonicalID();
                if (!f) return !1;
                if (s.type === "Polygon") {
                  const b = Yu(s.coordinates, o, f), O = _n(r.geometry(), h, o, f);
                  if (!kl(h, o)) return !1;
                  for (const H of O) if (!Pn(H, b)) return !1;
                }
                if (s.type === "MultiPolygon") {
                  const b = Uo(s.coordinates, o, f), O = _n(r.geometry(), h, o, f);
                  if (!kl(h, o)) return !1;
                  for (const H of O) if (!Pc(H, b)) return !1;
                }
                return !0;
              }(e, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            return ["within", this.geojson];
          }
        }
        const zn = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, cl = 1 / 298.257223563, kr = cl * (2 - cl), sa = Math.PI / 180;
        class us {
          static fromTile(e, r, s) {
            const h = Math.PI * (1 - 2 * (e + 0.5) / Math.pow(2, r)), o = Math.atan(0.5 * (Math.exp(h) - Math.exp(-h))) / sa;
            return new us(o, s);
          }
          static get units() {
            return zn;
          }
          constructor(e, r) {
            if (e === void 0) throw new Error("No latitude given.");
            if (r && !zn[r]) throw new Error(`Unknown unit ${r}. Use one of: ${Object.keys(zn).join(", ")}`);
            const s = 6378.137 * sa * (r ? zn[r] : 1), h = Math.cos(e * sa), o = 1 / (1 - kr * (1 - h * h)), f = Math.sqrt(o);
            this.kx = s * f * h, this.ky = s * f * o * (1 - kr);
          }
          distance(e, r) {
            const s = Pa(e[0] - r[0]) * this.kx, h = (e[1] - r[1]) * this.ky;
            return Math.sqrt(s * s + h * h);
          }
          bearing(e, r) {
            const s = Pa(r[0] - e[0]) * this.kx;
            return Math.atan2(s, (r[1] - e[1]) * this.ky) / sa;
          }
          destination(e, r, s) {
            const h = s * sa;
            return this.offset(e, Math.sin(h) * r, Math.cos(h) * r);
          }
          offset(e, r, s) {
            return [e[0] + r / this.kx, e[1] + s / this.ky];
          }
          lineDistance(e) {
            let r = 0;
            for (let s = 0; s < e.length - 1; s++) r += this.distance(e[s], e[s + 1]);
            return r;
          }
          area(e) {
            let r = 0;
            for (let s = 0; s < e.length; s++) {
              const h = e[s];
              for (let o = 0, f = h.length, b = f - 1; o < f; b = o++) r += Pa(h[o][0] - h[b][0]) * (h[o][1] + h[b][1]) * (s ? -1 : 1);
            }
            return Math.abs(r) / 2 * this.kx * this.ky;
          }
          along(e, r) {
            let s = 0;
            if (r <= 0) return e[0];
            for (let h = 0; h < e.length - 1; h++) {
              const o = e[h], f = e[h + 1], b = this.distance(o, f);
              if (s += b, s > r) return uu(o, f, (r - (s - b)) / b);
            }
            return e[e.length - 1];
          }
          pointToSegmentDistance(e, r, s) {
            let [h, o] = r, f = Pa(s[0] - h) * this.kx, b = (s[1] - o) * this.ky;
            if (f !== 0 || b !== 0) {
              const O = (Pa(e[0] - h) * this.kx * f + (e[1] - o) * this.ky * b) / (f * f + b * b);
              O > 1 ? (h = s[0], o = s[1]) : O > 0 && (h += f / this.kx * O, o += b / this.ky * O);
            }
            return f = Pa(e[0] - h) * this.kx, b = (e[1] - o) * this.ky, Math.sqrt(f * f + b * b);
          }
          pointOnLine(e, r) {
            let s = 1 / 0, h = e[0][0], o = e[0][1], f = 0, b = 0;
            for (let O = 0; O < e.length - 1; O++) {
              let H = e[O][0], y = e[O][1], B = Pa(e[O + 1][0] - H) * this.kx, G = (e[O + 1][1] - y) * this.ky, L = 0;
              B === 0 && G === 0 || (L = (Pa(r[0] - H) * this.kx * B + (r[1] - y) * this.ky * G) / (B * B + G * G), L > 1 ? (H = e[O + 1][0], y = e[O + 1][1]) : L > 0 && (H += B / this.kx * L, y += G / this.ky * L)), B = Pa(r[0] - H) * this.kx, G = (r[1] - y) * this.ky;
              const F = B * B + G * G;
              F < s && (s = F, h = H, o = y, f = O, b = L);
            }
            return { point: [h, o], index: f, t: Math.max(0, Math.min(1, b)) };
          }
          lineSlice(e, r, s) {
            let h = this.pointOnLine(s, e), o = this.pointOnLine(s, r);
            if (h.index > o.index || h.index === o.index && h.t > o.t) {
              const H = h;
              h = o, o = H;
            }
            const f = [h.point], b = h.index + 1, O = o.index;
            !hl(s[b], f[0]) && b <= O && f.push(s[b]);
            for (let H = b + 1; H <= O; H++) f.push(s[H]);
            return hl(s[O], o.point) || f.push(o.point), f;
          }
          lineSliceAlong(e, r, s) {
            let h = 0;
            const o = [];
            for (let f = 0; f < s.length - 1; f++) {
              const b = s[f], O = s[f + 1], H = this.distance(b, O);
              if (h += H, h > e && o.length === 0 && o.push(uu(b, O, (e - (h - H)) / H)), h >= r) return o.push(uu(b, O, (r - (h - H)) / H)), o;
              h > e && o.push(O);
            }
            return o;
          }
          bufferPoint(e, r) {
            const s = r / this.ky, h = r / this.kx;
            return [e[0] - h, e[1] - s, e[0] + h, e[1] + s];
          }
          bufferBBox(e, r) {
            const s = r / this.ky, h = r / this.kx;
            return [e[0] - h, e[1] - s, e[2] + h, e[3] + s];
          }
          insideBBox(e, r) {
            return Pa(e[0] - r[0]) >= 0 && Pa(e[0] - r[2]) <= 0 && e[1] >= r[1] && e[1] <= r[3];
          }
        }
        function hl(a, e) {
          return a[0] === e[0] && a[1] === e[1];
        }
        function uu(a, e, r) {
          const s = Pa(e[0] - a[0]);
          return [a[0] + s * r, a[1] + (e[1] - a[1]) * r];
        }
        function Pa(a) {
          for (; a < -180; ) a += 360;
          for (; a > 180; ) a -= 360;
          return a;
        }
        class $a {
          constructor(e = [], r = (s, h) => s < h ? -1 : s > h ? 1 : 0) {
            if (this.data = e, this.length = this.data.length, this.compare = r, this.length > 0) for (let s = (this.length >> 1) - 1; s >= 0; s--) this._down(s);
          }
          push(e) {
            this.data.push(e), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const e = this.data[0], r = this.data.pop();
            return --this.length > 0 && (this.data[0] = r, this._down(0)), e;
          }
          peek() {
            return this.data[0];
          }
          _up(e) {
            const { data: r, compare: s } = this, h = r[e];
            for (; e > 0; ) {
              const o = e - 1 >> 1, f = r[o];
              if (s(h, f) >= 0) break;
              r[e] = f, e = o;
            }
            r[e] = h;
          }
          _down(e) {
            const { data: r, compare: s } = this, h = this.length >> 1, o = r[e];
            for (; e < h; ) {
              let f = 1 + (e << 1);
              const b = f + 1;
              if (b < this.length && s(r[b], r[f]) < 0 && (f = b), s(r[f], o) >= 0) break;
              r[e] = r[f], e = f;
            }
            r[e] = o;
          }
        }
        var tr = 8192;
        function fl(a, e) {
          return e.dist - a.dist;
        }
        const Mo = 100, Vo = 50;
        function Ps(a) {
          const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          if (e.length !== a.length) return !1;
          for (let r = 0; r < e.length; r++) if (e[r] !== a[r]) return !1;
          return !0;
        }
        function ya(a) {
          return a[1] - a[0] + 1;
        }
        function xa(a, e) {
          const r = a[1] >= a[0] && a[1] < e;
          return r || console.warn("Distance Expression: Index is out of range"), r;
        }
        function jo(a, e) {
          if (a[0] > a[1]) return [null, null];
          const r = ya(a);
          if (e) {
            if (r === 2) return [a, null];
            const s = Math.floor(r / 2);
            return [[a[0], a[0] + s], [a[0] + s, a[1]]];
          }
          {
            if (r === 1) return [a, null];
            const s = Math.floor(r / 2) - 1;
            return [[a[0], a[0] + s], [a[0] + s + 1, a[1]]];
          }
        }
        function dl(a, e) {
          const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          if (!xa(e, a.length)) return r;
          for (let s = e[0]; s <= e[1]; ++s) Ca(r, a[s]);
          return r;
        }
        function Go(a) {
          const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let r = 0; r < a.length; ++r) for (let s = 0; s < a[r].length; ++s) Ca(e, a[r][s]);
          return e;
        }
        function no(a, e, r) {
          if (Ps(a) || Ps(e)) return NaN;
          let s = 0, h = 0;
          return a[2] < e[0] && (s = e[0] - a[2]), a[0] > e[2] && (s = a[0] - e[2]), a[1] > e[3] && (h = a[1] - e[3]), a[3] < e[1] && (h = e[1] - a[3]), r.distance([0, 0], [s, h]);
        }
        function pl(a) {
          return 360 * a - 180;
        }
        function oh(a) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90;
        }
        function Ho(a, e) {
          const r = Math.pow(2, e.z), s = (a.y / tr + e.y) / r;
          return [pl((a.x / tr + e.x) / r), oh(s)];
        }
        function Ku(a, e) {
          const r = [];
          for (let s = 0; s < a.length; ++s) r.push(Ho(a[s], e));
          return r;
        }
        function lh(a, e, r) {
          const s = r.pointOnLine(e, a).point;
          return r.distance(a, s);
        }
        function Rc(a, e, r, s, h) {
          const o = r.slice(s[0], s[1] + 1);
          let f = 1 / 0;
          for (let b = e[0]; b <= e[1]; ++b) if ((f = Math.min(f, lh(a[b], o, h))) === 0) return 0;
          return f;
        }
        function Ju(a, e, r, s, h) {
          const o = Math.min(h.pointToSegmentDistance(a, r, s), h.pointToSegmentDistance(e, r, s)), f = Math.min(h.pointToSegmentDistance(r, a, e), h.pointToSegmentDistance(s, a, e));
          return Math.min(o, f);
        }
        function kc(a, e, r, s, h) {
          if (!xa(e, a.length) || !xa(s, r.length)) return NaN;
          let o = 1 / 0;
          for (let f = e[0]; f < e[1]; ++f) for (let b = s[0]; b < s[1]; ++b) {
            if (io(a[f], a[f + 1], r[b], r[b + 1])) return 0;
            o = Math.min(o, Ju(a[f], a[f + 1], r[b], r[b + 1], h));
          }
          return o;
        }
        function Qu(a, e, r, s, h) {
          if (!xa(e, a.length) || !xa(s, r.length)) return NaN;
          let o = 1 / 0;
          for (let f = e[0]; f <= e[1]; ++f) for (let b = s[0]; b <= s[1]; ++b) if ((o = Math.min(o, h.distance(a[f], r[b]))) === 0) return o;
          return o;
        }
        function ba(a, e, r) {
          if (Ll(a, e, !0)) return 0;
          let s = 1 / 0;
          for (const h of e) {
            const o = h.length;
            if (o < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
            if (h[0] !== h[o - 1] && (s = Math.min(s, r.pointToSegmentDistance(a, h[o - 1], h[0]))) === 0 || (s = Math.min(s, lh(a, h, r))) === 0) return s;
          }
          return s;
        }
        function vi(a, e, r, s) {
          if (!xa(e, a.length)) return NaN;
          for (let o = e[0]; o <= e[1]; ++o) if (Ll(a[o], r, !0)) return 0;
          let h = 1 / 0;
          for (let o = e[0]; o < e[1]; ++o) for (const f of r) for (let b = 0, O = f.length, H = O - 1; b < O; H = b++) {
            if (io(a[o], a[o + 1], f[H], f[b])) return 0;
            h = Math.min(h, Ju(a[o], a[o + 1], f[H], f[b], s));
          }
          return h;
        }
        function Ci(a, e) {
          for (const r of a) for (let s = 0; s <= r.length - 1; ++s) if (Ll(r[s], e, !0)) return !0;
          return !1;
        }
        function Xi(a, e, r, s = 1 / 0) {
          const h = Go(a), o = Go(e);
          if (s !== 1 / 0 && no(h, o, r) >= s) return s;
          if (kl(h, o)) {
            if (Ci(a, e)) return 0;
          } else if (Ci(e, a)) return 0;
          let f = s;
          for (const b of a) for (let O = 0, H = b.length, y = H - 1; O < H; y = O++) for (const B of e) for (let G = 0, L = B.length, F = L - 1; G < L; F = G++) {
            if (io(b[y], b[O], B[F], B[G])) return 0;
            f = Math.min(f, Ju(b[y], b[O], B[F], B[G], r));
          }
          return f;
        }
        function sr(a, e, r, s, h, o, f) {
          if (o === null || f === null) return;
          const b = no(dl(s, o), dl(h, f), r);
          b < e && a.push({ dist: b, range1: o, range2: f });
        }
        function rn(a, e, r, s, h = 1 / 0) {
          let o = Math.min(s.distance(a[0], r[0][0]), h);
          if (o === 0) return o;
          const f = new $a([{ dist: 0, range1: [0, a.length - 1], range2: [0, 0] }], fl), b = e ? Vo : Mo, O = Go(r);
          for (; f.length; ) {
            const H = f.pop();
            if (H.dist >= o) continue;
            const y = H.range1;
            if (ya(y) <= b) {
              if (!xa(y, a.length)) return NaN;
              if (e) {
                const B = vi(a, y, r, s);
                if ((o = Math.min(o, B)) === 0) return o;
              } else for (let B = y[0]; B <= y[1]; ++B) {
                const G = ba(a[B], r, s);
                if ((o = Math.min(o, G)) === 0) return o;
              }
            } else {
              const B = jo(y, e);
              if (B[0] !== null) {
                const G = no(dl(a, B[0]), O, s);
                G < o && f.push({ dist: G, range1: B[0], range2: [0, 0] });
              }
              if (B[1] !== null) {
                const G = no(dl(a, B[1]), O, s);
                G < o && f.push({ dist: G, range1: B[1], range2: [0, 0] });
              }
            }
          }
          return o;
        }
        function Hr(a, e, r, s, h, o = 1 / 0) {
          let f = Math.min(o, h.distance(a[0], r[0]));
          if (f === 0) return f;
          const b = new $a([{ dist: 0, range1: [0, a.length - 1], range2: [0, r.length - 1] }], fl), O = e ? Vo : Mo, H = s ? Vo : Mo;
          for (; b.length; ) {
            const y = b.pop();
            if (y.dist >= f) continue;
            const B = y.range1, G = y.range2;
            if (ya(B) <= O && ya(G) <= H) {
              if (!xa(B, a.length) || !xa(G, r.length)) return NaN;
              if (e && s ? f = Math.min(f, kc(a, B, r, G, h)) : e || s ? e && !s ? f = Math.min(f, Rc(r, G, a, B, h)) : !e && s && (f = Math.min(f, Rc(a, B, r, G, h))) : f = Math.min(f, Qu(a, B, r, G, h)), f === 0) return f;
            } else {
              const L = jo(B, e), F = jo(G, s);
              sr(b, f, h, a, r, L[0], F[0]), sr(b, f, h, a, r, L[0], F[1]), sr(b, f, h, a, r, L[1], F[0]), sr(b, f, h, a, r, L[1], F[1]);
            }
          }
          return f;
        }
        function on(a, e, r, s, h = 1 / 0) {
          let o = h;
          const f = dl(a, [0, a.length - 1]);
          for (const b of r) if (!(o !== 1 / 0 && no(f, dl(b, [0, b.length - 1]), s) >= o) && (o = Math.min(o, Hr(a, e, b, !0, s, o)), o === 0)) return o;
          return o;
        }
        function Mn(a, e, r, s, h = 1 / 0) {
          let o = h;
          const f = dl(a, [0, a.length - 1]);
          for (const b of r) {
            if (o !== 1 / 0 && no(f, Go(b), s) >= o) continue;
            const O = rn(a, e, b, s, o);
            if (isNaN(O)) return O;
            if ((o = Math.min(o, O)) === 0) return o;
          }
          return o;
        }
        function Va(a) {
          return a === "Point" || a === "MultiPoint" || a === "LineString" || a === "MultiLineString" || a === "Polygon" || a === "MultiPolygon";
        }
        class cs {
          constructor(e, r) {
            this.type = di, this.geojson = e, this.geometries = r;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`'distance' expression requires either one argument, but found ' ${e.length - 1} instead.`);
            if (js(e[1])) {
              const s = e[1];
              if (s.type === "FeatureCollection") {
                for (let h = 0; h < s.features.length; ++h) if (Va(s.features[h].geometry.type)) return new cs(s, s.features[h].geometry);
              } else if (s.type === "Feature") {
                if (Va(s.geometry.type)) return new cs(s, s.geometry);
              } else if (Va(s.type)) return new cs(s, s);
            }
            return r.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
          }
          evaluate(e) {
            const r = e.geometry(), s = e.canonicalID();
            if (r != null && s != null) {
              if (e.geometryType() === "Point") return function(h, o, f) {
                const b = [];
                for (const H of h) for (const y of H) b.push(Ho(y, o));
                const O = new us(b[0][1], "meters");
                return f.type === "Point" || f.type === "MultiPoint" || f.type === "LineString" ? Hr(b, !1, f.type === "Point" ? [f.coordinates] : f.coordinates, f.type === "LineString", O) : f.type === "MultiLineString" ? on(b, !1, f.coordinates, O) : f.type === "Polygon" || f.type === "MultiPolygon" ? Mn(b, !1, f.type === "Polygon" ? [f.coordinates] : f.coordinates, O) : null;
              }(r, s, this.geometries);
              if (e.geometryType() === "LineString") return function(h, o, f) {
                const b = [];
                for (const H of h) {
                  const y = [];
                  for (const B of H) y.push(Ho(B, o));
                  b.push(y);
                }
                const O = new us(b[0][0][1], "meters");
                if (f.type === "Point" || f.type === "MultiPoint" || f.type === "LineString") return on(f.type === "Point" ? [f.coordinates] : f.coordinates, f.type === "LineString", b, O);
                if (f.type === "MultiLineString") {
                  let H = 1 / 0;
                  for (let y = 0; y < f.coordinates.length; y++) {
                    const B = on(f.coordinates[y], !0, b, O, H);
                    if (isNaN(B)) return B;
                    if ((H = Math.min(H, B)) === 0) return H;
                  }
                  return H;
                }
                if (f.type === "Polygon" || f.type === "MultiPolygon") {
                  let H = 1 / 0;
                  for (let y = 0; y < b.length; y++) {
                    const B = Mn(b[y], !0, f.type === "Polygon" ? [f.coordinates] : f.coordinates, O, H);
                    if (isNaN(B)) return B;
                    if ((H = Math.min(H, B)) === 0) return H;
                  }
                  return H;
                }
                return null;
              }(r, s, this.geometries);
              if (e.geometryType() === "Polygon") return function(h, o, f) {
                const b = [];
                for (const H of function(y, B) {
                  const G = y.length;
                  if (G <= 1) return [y];
                  const L = [];
                  let F, Y;
                  for (let ce = 0; ce < G; ce++) {
                    const _e = ul(y[ce]);
                    _e !== 0 && (y[ce].area = Math.abs(_e), Y === void 0 && (Y = _e < 0), Y === _e < 0 ? (F && L.push(F), F = [y[ce]]) : F.push(y[ce]));
                  }
                  return F && L.push(F), L;
                }(h)) {
                  const y = [];
                  for (let B = 0; B < H.length; ++B) y.push(Ku(H[B], o));
                  b.push(y);
                }
                const O = new us(b[0][0][0][1], "meters");
                if (f.type === "Point" || f.type === "MultiPoint" || f.type === "LineString") return Mn(f.type === "Point" ? [f.coordinates] : f.coordinates, f.type === "LineString", b, O);
                if (f.type === "MultiLineString") {
                  let H = 1 / 0;
                  for (let y = 0; y < f.coordinates.length; y++) {
                    const B = Mn(f.coordinates[y], !0, b, O, H);
                    if (isNaN(B)) return B;
                    if ((H = Math.min(H, B)) === 0) return H;
                  }
                  return H;
                }
                return f.type === "Polygon" || f.type === "MultiPolygon" ? function(H, y, B) {
                  let G = 1 / 0;
                  for (const L of H) for (const F of y) {
                    const Y = Xi(L, F, B, G);
                    if (isNaN(Y)) return Y;
                    if ((G = Math.min(G, Y)) === 0) return G;
                  }
                  return G;
                }(f.type === "Polygon" ? [f.coordinates] : f.coordinates, b, O) : null;
              }(r, s, this.geometries);
              console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
            } else console.warn("Distance Expression: requirs valid feature and canonical information.");
            return null;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            return ["distance", this.geojson];
          }
        }
        function go(a, e) {
          switch (a) {
            case "string":
              return qn(e);
            case "number":
              return +e;
            case "boolean":
              return !!e;
            case "color":
              return Wr.parse(e);
            case "formatted":
              return Na.fromString(qn(e));
            case "resolvedImage":
              return Ua.build(qn(e));
          }
          return e;
        }
        function qo(a, e, r, s) {
          return s !== void 0 && (a = s * Math.round(a / s)), e !== void 0 && a < e && (a = e), r !== void 0 && a > r && (a = r), a;
        }
        class Wo {
          constructor(e, r, s) {
            this.type = e, this.key = r, this.scope = s;
          }
          static parse(e, r) {
            let s = r.expectedType;
            if (s == null && (s = br), e.length < 2 || e.length > 3) return r.error("Invalid number of arguments for 'config' expression.");
            const h = r.parse(e[1], 1);
            if (!(h instanceof ta)) return r.error("Key name of 'config' expression must be a string literal.");
            if (e.length >= 3) {
              const o = r.parse(e[2], 2);
              return o instanceof ta ? new Wo(s, qn(h.value), qn(o.value)) : r.error("Scope of 'config' expression must be a string literal.");
            }
            return new Wo(s, qn(h.value));
          }
          evaluate(e) {
            const r = [this.key, this.scope, e.scope].filter(Boolean).join(""), s = e.getConfig(r);
            if (!s) return null;
            const { type: h, value: o, values: f, minValue: b, maxValue: O, stepValue: H } = s, y = s.default.evaluate(e);
            let B = y;
            if (o) {
              const G = e.scope;
              e.scope = (G || "").split("").slice(1).join(""), B = o.evaluate(e), e.scope = G;
            }
            return h && (B = go(h, B)), B === void 0 || b === void 0 && O === void 0 && H === void 0 || (typeof B == "number" ? B = qo(B, b, O, H) : Array.isArray(B) && (B = B.map((G) => typeof G == "number" ? qo(G, b, O, H) : G))), o !== void 0 && B !== void 0 && f && !f.includes(B) && (B = y, h && (B = go(h, B))), (h && h !== this.type || B !== void 0 && Nn(B) !== this.type) && (B = go(this.type.kind, B)), B;
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            const e = ["config", this.key];
            return this.scope && e.concat(this.key), e;
          }
        }
        function ml(a) {
          if (a instanceof ms && (a.name === "get" && a.args.length === 1 || a.name === "feature-state" || a.name === "has" && a.args.length === 1 || a.name === "properties" || a.name === "geometry-type" || a.name === "id" || /^filter-/.test(a.name)) || a instanceof Lr || a instanceof cs) return !1;
          let e = !0;
          return a.eachChild((r) => {
            e && !ml(r) && (e = !1);
          }), e;
        }
        function Zo(a) {
          if (a instanceof ms && a.name === "feature-state") return !1;
          let e = !0;
          return a.eachChild((r) => {
            e && !Zo(r) && (e = !1);
          }), e;
        }
        function cu(a) {
          if (a instanceof Wo) return /* @__PURE__ */ new Set([a.key]);
          let e = /* @__PURE__ */ new Set();
          return a.eachChild((r) => {
            e = /* @__PURE__ */ new Set([...e, ...cu(r)]);
          }), e;
        }
        function Dl(a, e) {
          if (a instanceof ms && e.indexOf(a.name) >= 0) return !1;
          let r = !0;
          return a.eachChild((s) => {
            r && !Dl(s, e) && (r = !1);
          }), r;
        }
        class $o {
          constructor(e, r) {
            this.type = r.type, this.name = e, this.boundExpression = r;
          }
          static parse(e, r) {
            if (e.length !== 2 || typeof e[1] != "string") return r.error("'var' expression requires exactly one string literal argument.");
            const s = e[1];
            return r.scope.has(s) ? new $o(s, r.scope.get(s)) : r.error(`Unknown variable "${s}". Make sure "${s}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(e) {
            return this.boundExpression.evaluate(e);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return ["var", this.name];
          }
        }
        class hu {
          constructor(e, r = [], s, h = new Ot(), o = [], f, b) {
            this.registry = e, this.path = r, this.key = r.map((O) => typeof O == "string" ? `['${O}']` : `[${O}]`).join(""), this.scope = h, this.errors = o, this.expectedType = s, this._scope = f, this.options = b;
          }
          parse(e, r, s, h, o = {}) {
            return r || s ? this.concat(r, null, s, h)._parse(e, o) : this._parse(e, o);
          }
          parseObjectValue(e, r, s, h, o, f = {}) {
            return this.concat(r, s, h, o)._parse(e, f);
          }
          _parse(e, r) {
            function s(h, o, f) {
              return f === "assert" ? new Gs(o, [h]) : f === "coerce" ? new _o(o, [h]) : h;
            }
            if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
              if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const h = typeof e[0] == "string" ? this.registry[e[0]] : void 0;
              if (h) {
                let o = h.parse(e, this);
                if (!o) return null;
                if (this.expectedType) {
                  const f = this.expectedType, b = o.type;
                  if (f.kind !== "string" && f.kind !== "number" && f.kind !== "boolean" && f.kind !== "object" && f.kind !== "array" || b.kind !== "value") if (f.kind !== "color" && f.kind !== "formatted" && f.kind !== "resolvedImage" || b.kind !== "value" && b.kind !== "string") {
                    if (this.checkSubtype(f, b)) return null;
                  } else o = s(o, f, r.typeAnnotation || "coerce");
                  else o = s(o, f, r.typeAnnotation || "assert");
                }
                if (!(o instanceof ta) && o.type.kind !== "resolvedImage" && Lc(o)) {
                  const f = new Mc(this._scope, this.options);
                  try {
                    o = new ta(o.type, o.evaluate(f));
                  } catch (b) {
                    return this.error(b.message), null;
                  }
                }
                return o;
              }
              return _o.parse(["to-array", e], this);
            }
            return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`);
          }
          concat(e, r, s, h) {
            let o = typeof e == "number" ? this.path.concat(e) : this.path;
            o = typeof r == "string" ? o.concat(r) : o;
            const f = h ? this.scope.concat(h) : this.scope;
            return new hu(this.registry, o, s || null, f, this.errors, this._scope, this.options);
          }
          error(e, ...r) {
            const s = `${this.key}${r.map((h) => `[${h}]`).join("")}`;
            this.errors.push(new ht(s, e));
          }
          checkSubtype(e, r) {
            const s = va(e, r);
            return s && this.error(s), s;
          }
        }
        var ec = hu;
        function Lc(a) {
          if (a instanceof $o) return Lc(a.boundExpression);
          if (a instanceof ms && a.name === "error" || a instanceof Zu || a instanceof Lr || a instanceof cs || a instanceof Wo) return !1;
          const e = a instanceof _o || a instanceof Gs;
          let r = !0;
          return a.eachChild((s) => {
            r = e ? r && Lc(s) : r && s instanceof ta;
          }), !!r && ml(a) && Dl(a, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]);
        }
        function tc(a, e) {
          const r = a.length - 1;
          let s, h, o = 0, f = r, b = 0;
          for (; o <= f; ) if (b = Math.floor((o + f) / 2), s = a[b], h = a[b + 1], s <= e) {
            if (b === r || e < h) return b;
            o = b + 1;
          } else {
            if (!(s > e)) throw new ia("Input is not a number.");
            f = b - 1;
          }
          return 0;
        }
        class fu {
          constructor(e, r, s) {
            this.type = e, this.input = r, this.labels = [], this.outputs = [];
            for (const [h, o] of s) this.labels.push(h), this.outputs.push(o);
          }
          static parse(e, r) {
            if (e.length - 1 < 4) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if ((e.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            const s = r.parse(e[1], 1, di);
            if (!s) return null;
            const h = [];
            let o = null;
            r.expectedType && r.expectedType.kind !== "value" && (o = r.expectedType);
            for (let f = 1; f < e.length; f += 2) {
              const b = f === 1 ? -1 / 0 : e[f], O = e[f + 1], H = f, y = f + 1;
              if (typeof b != "number") return r.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', H);
              if (h.length && h[h.length - 1][0] >= b) return r.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', H);
              const B = r.parse(O, y, o);
              if (!B) return null;
              o = o || B.type, h.push([b, B]);
            }
            return new fu(o, s, h);
          }
          evaluate(e) {
            const r = this.labels, s = this.outputs;
            if (r.length === 1) return s[0].evaluate(e);
            const h = this.input.evaluate(e);
            if (h <= r[0]) return s[0].evaluate(e);
            const o = r.length;
            return h >= r[o - 1] ? s[o - 1].evaluate(e) : s[tc(r, h)].evaluate(e);
          }
          eachChild(e) {
            e(this.input);
            for (const r of this.outputs) e(r);
          }
          outputDefined() {
            return this.outputs.every((e) => e.outputDefined());
          }
          serialize() {
            const e = ["step", this.input.serialize()];
            for (let r = 0; r < this.labels.length; r++) r > 0 && e.push(this.labels[r]), e.push(this.outputs[r].serialize());
            return e;
          }
        }
        const zl = 0.95047, Qr = 1.08883, uh = 4 / 29, Bl = 6 / 29, Rf = 3 * Bl * Bl, kf = Bl * Bl * Bl, Oc = Math.PI / 180, jn = 180 / Math.PI;
        function ch(a) {
          return a > kf ? Math.pow(a, 1 / 3) : a / Rf + uh;
        }
        function hh(a) {
          return a > Bl ? a * a * a : Rf * (a - uh);
        }
        function da(a) {
          return 255 * (a <= 31308e-7 ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - 0.055);
        }
        function Dc(a) {
          return (a /= 255) <= 0.04045 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4);
        }
        function zc(a) {
          const e = Dc(a.r), r = Dc(a.g), s = Dc(a.b), h = ch((0.4124564 * e + 0.3575761 * r + 0.1804375 * s) / zl), o = ch((0.2126729 * e + 0.7151522 * r + 0.072175 * s) / 1);
          return { l: 116 * o - 16, a: 500 * (h - o), b: 200 * (o - ch((0.0193339 * e + 0.119192 * r + 0.9503041 * s) / Qr)), alpha: a.a };
        }
        function ic(a) {
          let e = (a.l + 16) / 116, r = isNaN(a.a) ? e : e + a.a / 500, s = isNaN(a.b) ? e : e - a.b / 200;
          return e = 1 * hh(e), r = zl * hh(r), s = Qr * hh(s), new Wr(da(3.2404542 * r - 1.5371385 * e - 0.4985314 * s), da(-0.969266 * r + 1.8760108 * e + 0.041556 * s), da(0.0556434 * r - 0.2040259 * e + 1.0572252 * s), a.alpha);
        }
        function Lf(a, e, r) {
          const s = e - a;
          return a + r * (s > 180 || s < -180 ? s - 360 * Math.round(s / 360) : s);
        }
        const du = { forward: zc, reverse: ic, interpolate: function(a, e, r) {
          return { l: Tr(a.l, e.l, r), a: Tr(a.a, e.a, r), b: Tr(a.b, e.b, r), alpha: Tr(a.alpha, e.alpha, r) };
        } }, _l = { forward: function(a) {
          const { l: e, a: r, b: s } = zc(a), h = Math.atan2(s, r) * jn;
          return { h: h < 0 ? h + 360 : h, c: Math.sqrt(r * r + s * s), l: e, alpha: a.a };
        }, reverse: function(a) {
          const e = a.h * Oc, r = a.c;
          return ic({ l: a.l, a: Math.cos(e) * r, b: Math.sin(e) * r, alpha: a.alpha });
        }, interpolate: function(a, e, r) {
          return { h: Lf(a.h, e.h, r), c: Tr(a.c, e.c, r), l: Tr(a.l, e.l, r), alpha: Tr(a.alpha, e.alpha, r) };
        } };
        var Bc = Object.freeze({ __proto__: null, hcl: _l, lab: du });
        class is {
          constructor(e, r, s, h, o, f) {
            this.type = e, this.operator = r, this.interpolation = s, this.input = h, this.dynamicStops = o, this.labels = [], this.outputs = [];
            for (const [b, O] of f) this.labels.push(b), this.outputs.push(O);
          }
          static interpolationFactor(e, r, s, h) {
            let o = 0;
            if (e.name === "exponential") o = fh(r, e.base, s, h);
            else if (e.name === "linear") o = fh(r, 1, s, h);
            else if (e.name === "cubic-bezier") {
              const f = e.controlPoints;
              o = new wi(f[0], f[1], f[2], f[3]).solve(fh(r, 1, s, h));
            }
            return o;
          }
          static parse(e, r) {
            let [s, h, o, ...f] = e;
            if (!Array.isArray(h) || h.length === 0) return r.error("Expected an interpolation type expression.", 1);
            if (h[0] === "linear") h = { name: "linear" };
            else if (h[0] === "exponential") {
              const H = h[1];
              if (typeof H != "number") return r.error("Exponential interpolation requires a numeric base.", 1, 1);
              h = { name: "exponential", base: H };
            } else {
              if (h[0] !== "cubic-bezier") return r.error(`Unknown interpolation type ${String(h[0])}`, 1, 0);
              {
                const H = h.slice(1);
                if (H.length !== 4 || H.some((y) => typeof y != "number" || y < 0 || y > 1)) return r.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                h = { name: "cubic-bezier", controlPoints: H };
              }
            }
            if (e.length - 1 < 3) return r.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
            if (e.length - 1 > 3 && (e.length - 1) % 2 != 0) return r.error("Expected an even number of arguments.");
            if (o = r.parse(o, 2, di), !o) return null;
            const b = [];
            let O = null;
            if (s === "interpolate-hcl" || s === "interpolate-lab" ? O = _r : r.expectedType && r.expectedType.kind !== "value" && (O = r.expectedType), e.length - 1 == 3) {
              const H = r.parse(f[0], 3, br);
              return H ? new is(O, s, h, o, H, b) : null;
            }
            for (let H = 0; H < f.length; H += 2) {
              const y = f[H], B = f[H + 1], G = H + 3, L = H + 4;
              if (typeof y != "number") return r.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', G);
              if (b.length && b[b.length - 1][0] >= y) return r.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', G);
              const F = r.parse(B, L, O);
              if (!F) return null;
              O = O || F.type, b.push([y, F]);
            }
            return O.kind === "number" || O.kind === "color" || O.kind === "array" && O.itemType.kind === "number" && typeof O.N == "number" ? new is(O, s, h, o, null, b) : r.error(`Type ${Dn(O)} is not interpolatable.`);
          }
          evaluate(e) {
            let r = this.labels, s = this.outputs;
            if (this.dynamicStops) {
              const y = this.dynamicStops.evaluate(e);
              if (y.length % 2 != 0) throw new ia("Expected an even number of arguments.");
              r = [], s = [];
              for (let B = 0; B < y.length; B += 2) {
                const G = y[B], L = new ta(di, y[B + 1]);
                if (typeof G != "number") throw new ia('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.');
                if (r.length && r[r.length - 1] >= G) throw new ia('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.');
                r.push(G), s.push(L);
              }
              if (r.length === 0) throw new ia("Expected at least one input/output pair.");
            }
            if (r.length === 1) return s[0].evaluate(e);
            const h = this.input.evaluate(e);
            if (h <= r[0]) return s[0].evaluate(e);
            const o = r.length;
            if (h >= r[o - 1]) return s[o - 1].evaluate(e);
            const f = tc(r, h), b = is.interpolationFactor(this.interpolation, h, r[f], r[f + 1]), O = s[f].evaluate(e), H = s[f + 1].evaluate(e);
            return this.operator === "interpolate" ? D[this.type.kind.toLowerCase()](O, H, b) : this.operator === "interpolate-hcl" ? _l.reverse(_l.interpolate(_l.forward(O), _l.forward(H), b)) : du.reverse(du.interpolate(du.forward(O), du.forward(H), b));
          }
          eachChild(e) {
            e(this.input);
            for (const r of this.outputs) e(r);
          }
          outputDefined() {
            return this.outputs.every((e) => e.outputDefined());
          }
          serialize() {
            let e;
            e = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
            const r = [this.operator, e, this.input.serialize()];
            if (this.dynamicStops) r.push(this.dynamicStops.serialize());
            else for (let s = 0; s < this.labels.length; s++) r.push(this.labels[s], this.outputs[s].serialize());
            return r;
          }
        }
        function fh(a, e, r, s) {
          const h = s - r, o = a - r;
          return h === 0 ? 0 : e === 1 ? o / h : (Math.pow(e, o) - 1) / (Math.pow(e, h) - 1);
        }
        class dh {
          constructor(e, r) {
            this.type = e, this.args = r;
          }
          static parse(e, r) {
            if (e.length < 2) return r.error("Expectected at least one argument.");
            let s = null;
            const h = r.expectedType;
            h && h.kind !== "value" && (s = h);
            const o = [];
            for (const b of e.slice(1)) {
              const O = r.parse(b, 1 + o.length, s, void 0, { typeAnnotation: "omit" });
              if (!O) return null;
              s = s || O.type, o.push(O);
            }
            const f = h && o.some((b) => va(h, b.type));
            return new dh(f ? br : s, o);
          }
          evaluate(e) {
            let r, s = null, h = 0;
            for (const o of this.args) {
              if (h++, s = o.evaluate(e), s && s instanceof Ua && !s.available && (r || (r = s), s = null, h === this.args.length)) return r;
              if (s !== null) break;
            }
            return s;
          }
          eachChild(e) {
            this.args.forEach(e);
          }
          outputDefined() {
            return this.args.every((e) => e.outputDefined());
          }
          serialize() {
            const e = ["coalesce"];
            return this.eachChild((r) => {
              e.push(r.serialize());
            }), e;
          }
        }
        class ph {
          constructor(e, r) {
            this.type = r.type, this.bindings = [].concat(e), this.result = r;
          }
          evaluate(e) {
            return this.result.evaluate(e);
          }
          eachChild(e) {
            for (const r of this.bindings) e(r[1]);
            e(this.result);
          }
          static parse(e, r) {
            if (e.length < 4) return r.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
            const s = [];
            for (let o = 1; o < e.length - 1; o += 2) {
              const f = e[o];
              if (typeof f != "string") return r.error(`Expected string, but found ${typeof f} instead.`, o);
              if (/[^a-zA-Z0-9_]/.test(f)) return r.error("Variable names must contain only alphanumeric characters or '_'.", o);
              const b = r.parse(e[o + 1], o + 1);
              if (!b) return null;
              s.push([f, b]);
            }
            const h = r.parse(e[e.length - 1], e.length - 1, r.expectedType, s);
            return h ? new ph(s, h) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
          serialize() {
            const e = ["let"];
            for (const [r, s] of this.bindings) e.push(r, s.serialize());
            return e.push(this.result.serialize()), e;
          }
        }
        class mh {
          constructor(e, r, s) {
            this.type = e, this.index = r, this.input = s;
          }
          static parse(e, r) {
            if (e.length !== 3) return r.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
            const s = r.parse(e[1], 1, di), h = r.parse(e[2], 2, Hn(r.expectedType || br));
            return s && h ? new mh(h.type.itemType, s, h) : null;
          }
          evaluate(e) {
            const r = this.index.evaluate(e), s = this.input.evaluate(e);
            if (r < 0) throw new ia(`Array index out of bounds: ${r} < 0.`);
            if (r > s.length - 1) throw new ia(`Array index out of bounds: ${r} > ${s.length - 1}.`);
            if (r === Math.floor(r)) return s[r];
            const h = Math.floor(r), o = Math.ceil(r), f = s[h], b = s[o];
            if (typeof f != "number" || typeof b != "number") throw new ia(`Cannot interpolate between non-number values at index ${r}.`);
            const O = r - h;
            return f * (1 - O) + b * O;
          }
          eachChild(e) {
            e(this.index), e(this.input);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return ["at", this.index.serialize(), this.input.serialize()];
          }
        }
        class rc {
          constructor(e, r) {
            this.type = er, this.needle = e, this.haystack = r;
          }
          static parse(e, r) {
            if (e.length !== 3) return r.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
            const s = r.parse(e[1], 1, br), h = r.parse(e[2], 2, br);
            return s && h ? sl(s.type, [er, ki, di, hi, br]) ? new rc(s, h) : r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Dn(s.type)} instead`) : null;
          }
          evaluate(e) {
            const r = this.needle.evaluate(e), s = this.haystack.evaluate(e);
            if (s == null) return !1;
            if (!Fo(r, ["boolean", "string", "number", "null"])) throw new ia(`Expected first argument to be of type boolean, string, number or null, but found ${Dn(Nn(r))} instead.`);
            if (!Fo(s, ["string", "array"])) throw new ia(`Expected second argument to be of type array or string, but found ${Dn(Nn(s))} instead.`);
            return s.indexOf(r) >= 0;
          }
          eachChild(e) {
            e(this.needle), e(this.haystack);
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            return ["in", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class pu {
          constructor(e, r, s) {
            this.type = di, this.needle = e, this.haystack = r, this.fromIndex = s;
          }
          static parse(e, r) {
            if (e.length <= 2 || e.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
            const s = r.parse(e[1], 1, br), h = r.parse(e[2], 2, br);
            if (!s || !h) return null;
            if (!sl(s.type, [er, ki, di, hi, br])) return r.error(`Expected first argument to be of type boolean, string, number or null, but found ${Dn(s.type)} instead`);
            if (e.length === 4) {
              const o = r.parse(e[3], 3, di);
              return o ? new pu(s, h, o) : null;
            }
            return new pu(s, h);
          }
          evaluate(e) {
            const r = this.needle.evaluate(e), s = this.haystack.evaluate(e);
            if (!Fo(r, ["boolean", "string", "number", "null"])) throw new ia(`Expected first argument to be of type boolean, string, number or null, but found ${Dn(Nn(r))} instead.`);
            if (!Fo(s, ["string", "array"])) throw new ia(`Expected second argument to be of type array or string, but found ${Dn(Nn(s))} instead.`);
            if (this.fromIndex) {
              const h = this.fromIndex.evaluate(e);
              return s.indexOf(r, h);
            }
            return s.indexOf(r);
          }
          eachChild(e) {
            e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            if (this.fromIndex != null && this.fromIndex !== void 0) {
              const e = this.fromIndex.serialize();
              return ["index-of", this.needle.serialize(), this.haystack.serialize(), e];
            }
            return ["index-of", this.needle.serialize(), this.haystack.serialize()];
          }
        }
        class Fc {
          constructor(e, r, s, h, o, f) {
            this.inputType = e, this.type = r, this.input = s, this.cases = h, this.outputs = o, this.otherwise = f;
          }
          static parse(e, r) {
            if (e.length < 5) return r.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
            if (e.length % 2 != 1) return r.error("Expected an even number of arguments.");
            let s, h;
            r.expectedType && r.expectedType.kind !== "value" && (h = r.expectedType);
            const o = {}, f = [];
            for (let H = 2; H < e.length - 1; H += 2) {
              let y = e[H];
              const B = e[H + 1];
              Array.isArray(y) || (y = [y]);
              const G = r.concat(H);
              if (y.length === 0) return G.error("Expected at least one branch label.");
              for (const F of y) {
                if (typeof F != "number" && typeof F != "string") return G.error("Branch labels must be numbers or strings.");
                if (typeof F == "number" && Math.abs(F) > Number.MAX_SAFE_INTEGER) return G.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof F == "number" && Math.floor(F) !== F) return G.error("Numeric branch labels must be integer values.");
                if (s) {
                  if (G.checkSubtype(s, Nn(F))) return null;
                } else s = Nn(F);
                if (o[String(F)] !== void 0) return G.error("Branch labels must be unique.");
                o[String(F)] = f.length;
              }
              const L = r.parse(B, H, h);
              if (!L) return null;
              h = h || L.type, f.push(L);
            }
            const b = r.parse(e[1], 1, br);
            if (!b) return null;
            const O = r.parse(e[e.length - 1], e.length - 1, h);
            return O ? b.type.kind !== "value" && r.concat(1).checkSubtype(s, b.type) ? null : new Fc(s, h, b, o, f, O) : null;
          }
          evaluate(e) {
            const r = this.input.evaluate(e);
            return (Nn(r) === this.inputType && this.outputs[this.cases[r]] || this.otherwise).evaluate(e);
          }
          eachChild(e) {
            e(this.input), this.outputs.forEach(e), e(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const e = ["match", this.input.serialize()], r = Object.keys(this.cases).sort(), s = [], h = {};
            for (const f of r) {
              const b = h[this.cases[f]];
              b === void 0 ? (h[this.cases[f]] = s.length, s.push([this.cases[f], [f]])) : s[b][1].push(f);
            }
            const o = (f) => this.inputType.kind === "number" ? Number(f) : f;
            for (const [f, b] of s) e.push(b.length === 1 ? o(b[0]) : b.map(o)), e.push(this.outputs[f].serialize());
            return e.push(this.otherwise.serialize()), e;
          }
        }
        class Nc {
          constructor(e, r, s) {
            this.type = e, this.branches = r, this.otherwise = s;
          }
          static parse(e, r) {
            if (e.length < 4) return r.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
            if (e.length % 2 != 0) return r.error("Expected an odd number of arguments.");
            let s;
            r.expectedType && r.expectedType.kind !== "value" && (s = r.expectedType);
            const h = [];
            for (let f = 1; f < e.length - 1; f += 2) {
              const b = r.parse(e[f], f, er);
              if (!b) return null;
              const O = r.parse(e[f + 1], f + 1, s);
              if (!O) return null;
              h.push([b, O]), s = s || O.type;
            }
            const o = r.parse(e[e.length - 1], e.length - 1, s);
            return o ? new Nc(s, h, o) : null;
          }
          evaluate(e) {
            for (const [r, s] of this.branches) if (r.evaluate(e)) return s.evaluate(e);
            return this.otherwise.evaluate(e);
          }
          eachChild(e) {
            for (const [r, s] of this.branches) e(r), e(s);
            e(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([e, r]) => r.outputDefined()) && this.otherwise.outputDefined();
          }
          serialize() {
            const e = ["case"];
            return this.eachChild((r) => {
              e.push(r.serialize());
            }), e;
          }
        }
        class nc {
          constructor(e, r, s, h) {
            this.type = e, this.input = r, this.beginIndex = s, this.endIndex = h;
          }
          static parse(e, r) {
            if (e.length <= 2 || e.length >= 5) return r.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
            const s = r.parse(e[1], 1, br), h = r.parse(e[2], 2, di);
            if (!s || !h) return null;
            if (!sl(s.type, [Hn(br), ki, br])) return r.error(`Expected first argument to be of type array or string, but found ${Dn(s.type)} instead`);
            if (e.length === 4) {
              const o = r.parse(e[3], 3, di);
              return o ? new nc(s.type, s, h, o) : null;
            }
            return new nc(s.type, s, h);
          }
          evaluate(e) {
            const r = this.input.evaluate(e), s = this.beginIndex.evaluate(e);
            if (!Fo(r, ["string", "array"])) throw new ia(`Expected first argument to be of type array or string, but found ${Dn(Nn(r))} instead.`);
            if (this.endIndex) {
              const h = this.endIndex.evaluate(e);
              return r.slice(s, h);
            }
            return r.slice(s);
          }
          eachChild(e) {
            e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            if (this.endIndex != null && this.endIndex !== void 0) {
              const e = this.endIndex.serialize();
              return ["slice", this.input.serialize(), this.beginIndex.serialize(), e];
            }
            return ["slice", this.input.serialize(), this.beginIndex.serialize()];
          }
        }
        function _h(a, e) {
          return a === "==" || a === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
        }
        function Of(a, e, r, s) {
          return s.compare(e, r) === 0;
        }
        function mu(a, e, r) {
          const s = a !== "==" && a !== "!=";
          return class Yy {
            constructor(o, f, b) {
              this.type = er, this.lhs = o, this.rhs = f, this.collator = b, this.hasUntypedArgument = o.type.kind === "value" || f.type.kind === "value";
            }
            static parse(o, f) {
              if (o.length !== 3 && o.length !== 4) return f.error("Expected two or three arguments.");
              const b = o[0];
              let O = f.parse(o[1], 1, br);
              if (!O) return null;
              if (!_h(b, O.type)) return f.concat(1).error(`"${b}" comparisons are not supported for type '${Dn(O.type)}'.`);
              let H = f.parse(o[2], 2, br);
              if (!H) return null;
              if (!_h(b, H.type)) return f.concat(2).error(`"${b}" comparisons are not supported for type '${Dn(H.type)}'.`);
              if (O.type.kind !== H.type.kind && O.type.kind !== "value" && H.type.kind !== "value") return f.error(`Cannot compare types '${Dn(O.type)}' and '${Dn(H.type)}'.`);
              s && (O.type.kind === "value" && H.type.kind !== "value" ? O = new Gs(H.type, [O]) : O.type.kind !== "value" && H.type.kind === "value" && (H = new Gs(O.type, [H])));
              let y = null;
              if (o.length === 4) {
                if (O.type.kind !== "string" && H.type.kind !== "string" && O.type.kind !== "value" && H.type.kind !== "value") return f.error("Cannot use collator to compare non-string types.");
                if (y = f.parse(o[3], 3, Gn), !y) return null;
              }
              return new Yy(O, H, y);
            }
            evaluate(o) {
              const f = this.lhs.evaluate(o), b = this.rhs.evaluate(o);
              if (s && this.hasUntypedArgument) {
                const O = Nn(f), H = Nn(b);
                if (O.kind !== H.kind || O.kind !== "string" && O.kind !== "number") throw new ia(`Expected arguments for "${a}" to be (string, string) or (number, number), but found (${O.kind}, ${H.kind}) instead.`);
              }
              if (this.collator && !s && this.hasUntypedArgument) {
                const O = Nn(f), H = Nn(b);
                if (O.kind !== "string" || H.kind !== "string") return e(o, f, b);
              }
              return this.collator ? r(o, f, b, this.collator.evaluate(o)) : e(o, f, b);
            }
            eachChild(o) {
              o(this.lhs), o(this.rhs), this.collator && o(this.collator);
            }
            outputDefined() {
              return !0;
            }
            serialize() {
              const o = [a];
              return this.eachChild((f) => {
                o.push(f.serialize());
              }), o;
            }
          };
        }
        const _d = mu("==", function(a, e, r) {
          return e === r;
        }, Of), gd = mu("!=", function(a, e, r) {
          return e !== r;
        }, function(a, e, r, s) {
          return !Of(0, e, r, s);
        }), Jh = mu("<", function(a, e, r) {
          return e < r;
        }, function(a, e, r, s) {
          return s.compare(e, r) < 0;
        }), Fl = mu(">", function(a, e, r) {
          return e > r;
        }, function(a, e, r, s) {
          return s.compare(e, r) > 0;
        }), Df = mu("<=", function(a, e, r) {
          return e <= r;
        }, function(a, e, r, s) {
          return s.compare(e, r) <= 0;
        }), ac = mu(">=", function(a, e, r) {
          return e >= r;
        }, function(a, e, r, s) {
          return s.compare(e, r) >= 0;
        });
        class vo {
          constructor(e, r, s, h, o, f) {
            this.type = ki, this.number = e, this.locale = r, this.currency = s, this.unit = h, this.minFractionDigits = o, this.maxFractionDigits = f;
          }
          static parse(e, r) {
            if (e.length !== 3) return r.error("Expected two arguments.");
            const s = r.parse(e[1], 1, di);
            if (!s) return null;
            const h = e[2];
            if (typeof h != "object" || Array.isArray(h)) return r.error("NumberFormat options argument must be an object.");
            let o = null;
            if (h.locale && (o = r.parseObjectValue(h.locale, 2, "locale", ki), !o)) return null;
            let f = null;
            if (h.currency && (f = r.parseObjectValue(h.currency, 2, "currency", ki), !f)) return null;
            let b = null;
            if (h.unit && (b = r.parseObjectValue(h.unit, 2, "unit", ki), !b)) return null;
            let O = null;
            if (h["min-fraction-digits"] && (O = r.parseObjectValue(h["min-fraction-digits"], 2, "min-fraction-digits", di), !O)) return null;
            let H = null;
            return h["max-fraction-digits"] && (H = r.parseObjectValue(h["max-fraction-digits"], 2, "max-fraction-digits", di), !H) ? null : new vo(s, o, f, b, O, H);
          }
          evaluate(e) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, unit: this.unit ? this.unit.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
          }
          eachChild(e) {
            e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.unit && e(this.unit), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            const e = {};
            return this.locale && (e.locale = this.locale.serialize()), this.currency && (e.currency = this.currency.serialize()), this.unit && (e.unit = this.unit.serialize()), this.minFractionDigits && (e["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), e];
          }
        }
        class _u {
          constructor(e) {
            this.type = di, this.input = e;
          }
          static parse(e, r) {
            if (e.length !== 2) return r.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
            const s = r.parse(e[1], 1);
            return s ? s.type.kind !== "array" && s.type.kind !== "string" && s.type.kind !== "value" ? r.error(`Expected argument of type string or array, but found ${Dn(s.type)} instead.`) : new _u(s) : null;
          }
          evaluate(e) {
            const r = this.input.evaluate(e);
            if (typeof r == "string" || Array.isArray(r)) return r.length;
            throw new ia(`Expected value to be of type string or array, but found ${Dn(Nn(r))} instead.`);
          }
          eachChild(e) {
            e(this.input);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            const e = ["length"];
            return this.eachChild((r) => {
              e.push(r.serialize());
            }), e;
          }
        }
        function yo(a) {
          return function() {
            a = 1831565813 + (a |= 0) | 0;
            let e = Math.imul(a ^ a >>> 15, 1 | a);
            return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;
          };
        }
        const Nl = { "==": _d, "!=": gd, ">": Fl, "<": Jh, ">=": ac, "<=": Df, array: Gs, at: mh, boolean: Gs, case: Nc, coalesce: dh, collator: Zu, format: aa, image: ll, in: rc, "index-of": pu, interpolate: is, "interpolate-hcl": is, "interpolate-lab": is, length: _u, let: ph, literal: ta, match: Fc, number: Gs, "number-format": vo, object: Gs, slice: nc, step: fu, string: Gs, "to-boolean": _o, "to-color": _o, "to-number": _o, "to-string": _o, var: $o, within: Lr, distance: cs, config: Wo };
        function Qh(a, [e, r, s, h]) {
          e = e.evaluate(a), r = r.evaluate(a), s = s.evaluate(a);
          const o = h ? h.evaluate(a) : 1, f = ol(e, r, s, o);
          if (f) throw new ia(f);
          return new Wr(e / 255 * o, r / 255 * o, s / 255 * o, o);
        }
        function zf(a, [e, r, s, h]) {
          e = e.evaluate(a), r = r.evaluate(a), s = s.evaluate(a);
          const o = h ? h.evaluate(a) : 1, f = function(H, y, B, G) {
            return typeof H == "number" && H >= 0 && H <= 360 ? typeof y == "number" && y >= 0 && y <= 100 && typeof B == "number" && B >= 0 && B <= 100 ? G === void 0 || typeof G == "number" && G >= 0 && G <= 1 ? null : `Invalid hsla value [${[H, y, B, G].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${(typeof G == "number" ? [H, y, B, G] : [H, y, B]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${(typeof G == "number" ? [H, y, B, G] : [H, y, B]).join(", ")}]: 'h' must be between 0 and 360.`;
          }(e, r, s, o);
          if (f) throw new ia(f);
          const b = `hsla(${e}, ${r}%, ${s}%, ${o})`, O = Wr.parse(b);
          if (!O) throw new ia(`Failed to parse HSLA color: ${b}`);
          return O;
        }
        function Ul(a, e) {
          return a in e;
        }
        function gu(a, e) {
          const r = e[a];
          return r === void 0 ? null : r;
        }
        function ao(a) {
          return { type: a };
        }
        function sc(a) {
          return { result: "success", value: a };
        }
        function Rs(a) {
          return { result: "error", value: a };
        }
        function gl(a, e) {
          return !!a && !!a.parameters && a.parameters.indexOf(e) > -1;
        }
        function xo(a) {
          return a["property-type"] === "data-driven";
        }
        function wa(a) {
          return gl(a.expression, "measure-light");
        }
        function ra(a) {
          return gl(a.expression, "zoom");
        }
        function bo(a) {
          return !!a.expression && a.expression.interpolated;
        }
        function hs(a) {
          return typeof a == "object" && a !== null && !Array.isArray(a);
        }
        function Hs(a) {
          return a;
        }
        function vl(a, e) {
          const r = e.type === "color", s = a.stops && typeof a.stops[0][0] == "object", h = s || !(s || a.property !== void 0), o = a.type || (bo(e) ? "exponential" : "interval");
          if (r && ((a = be({}, a)).stops && (a.stops = a.stops.map((H) => [H[0], Wr.parse(H[1])])), a.default = Wr.parse(a.default ? a.default : e.default)), a.colorSpace && a.colorSpace !== "rgb" && !Bc[a.colorSpace]) throw new Error(`Unknown color space: ${a.colorSpace}`);
          let f, b, O;
          if (o === "exponential") f = ef;
          else if (o === "interval") f = gh;
          else if (o === "categorical") {
            f = qs, b = /* @__PURE__ */ Object.create(null);
            for (const H of a.stops) b[H[0]] = H[1];
            O = typeof a.stops[0][0];
          } else {
            if (o !== "identity") throw new Error(`Unknown function type "${o}"`);
            f = tf;
          }
          if (s) {
            const H = {}, y = [];
            for (let L = 0; L < a.stops.length; L++) {
              const F = a.stops[L], Y = F[0].zoom;
              H[Y] === void 0 && (H[Y] = { zoom: Y, type: a.type, property: a.property, default: a.default, stops: [] }, y.push(Y)), H[Y].stops.push([F[0].value, F[1]]);
            }
            const B = [];
            for (const L of y) B.push([H[L].zoom, vl(H[L], e)]);
            const G = { name: "linear" };
            return { kind: "composite", interpolationType: G, interpolationFactor: is.interpolationFactor.bind(void 0, G), zoomStops: B.map((L) => L[0]), evaluate: ({ zoom: L }, F) => ef({ stops: B, base: a.base }, e, L).evaluate(L, F) };
          }
          if (h) {
            const H = o === "exponential" ? { name: "exponential", base: a.base !== void 0 ? a.base : 1 } : null;
            return { kind: "camera", interpolationType: H, interpolationFactor: is.interpolationFactor.bind(void 0, H), zoomStops: a.stops.map((y) => y[0]), evaluate: ({ zoom: y }) => f(a, e, y, b, O) };
          }
          return { kind: "source", evaluate(H, y) {
            const B = y && y.properties ? y.properties[a.property] : void 0;
            return B === void 0 ? Io(a.default, e.default) : f(a, e, B, b, O);
          } };
        }
        function Io(a, e, r) {
          return a !== void 0 ? a : e !== void 0 ? e : r !== void 0 ? r : void 0;
        }
        function qs(a, e, r, s, h) {
          return Io(typeof r === h ? s[r] : void 0, a.default, e.default);
        }
        function gh(a, e, r) {
          if (ts(r) !== "number") return Io(a.default, e.default);
          const s = a.stops.length;
          if (s === 1 || r <= a.stops[0][0]) return a.stops[0][1];
          if (r >= a.stops[s - 1][0]) return a.stops[s - 1][1];
          const h = tc(a.stops.map((o) => o[0]), r);
          return a.stops[h][1];
        }
        function ef(a, e, r) {
          const s = a.base !== void 0 ? a.base : 1;
          if (ts(r) !== "number") return Io(a.default, e.default);
          const h = a.stops.length;
          if (h === 1 || r <= a.stops[0][0]) return a.stops[0][1];
          if (r >= a.stops[h - 1][0]) return a.stops[h - 1][1];
          const o = tc(a.stops.map((y) => y[0]), r), f = function(y, B, G, L) {
            const F = L - G, Y = y - G;
            return F === 0 ? 0 : B === 1 ? Y / F : (Math.pow(B, Y) - 1) / (Math.pow(B, F) - 1);
          }(r, s, a.stops[o][0], a.stops[o + 1][0]), b = a.stops[o][1], O = a.stops[o + 1][1];
          let H = D[e.type] || Hs;
          if (a.colorSpace && a.colorSpace !== "rgb") {
            const y = Bc[a.colorSpace];
            H = (B, G) => y.reverse(y.interpolate(y.forward(B), y.forward(G), f));
          }
          return typeof b.evaluate == "function" ? { evaluate(...y) {
            const B = b.evaluate.apply(void 0, y), G = O.evaluate.apply(void 0, y);
            if (B !== void 0 && G !== void 0) return H(B, G, f);
          } } : H(b, O, f);
        }
        function tf(a, e, r) {
          return e.type === "color" ? r = Wr.parse(r) : e.type === "formatted" ? r = Na.fromString(r.toString()) : e.type === "resolvedImage" ? r = Ua.build(r.toString()) : ts(r) === e.type || e.type === "enum" && e.values[r] || (r = void 0), Io(r, a.default, e.default);
        }
        ms.register(Nl, { error: [{ kind: "error" }, [ki], (a, [e]) => {
          throw new ia(e.evaluate(a));
        }], typeof: [ki, [br], (a, [e]) => Dn(Nn(e.evaluate(a)))], "to-rgba": [Hn(di, 4), [_r], (a, [e]) => e.evaluate(a).toRenderColor(null).toArray()], "to-hsla": [Hn(di, 4), [_r], (a, [e]) => e.evaluate(a).toRenderColor(null).toHslaArray()], rgb: [_r, [di, di, di], Qh], rgba: [_r, [di, di, di, di], Qh], hsl: [_r, [di, di, di], zf], hsla: [_r, [di, di, di, di], zf], has: { type: er, overloads: [[[ki], (a, [e]) => Ul(e.evaluate(a), a.properties())], [[ki, en], (a, [e, r]) => Ul(e.evaluate(a), r.evaluate(a))]] }, get: { type: br, overloads: [[[ki], (a, [e]) => gu(e.evaluate(a), a.properties())], [[ki, en], (a, [e, r]) => gu(e.evaluate(a), r.evaluate(a))]] }, "feature-state": [br, [ki], (a, [e]) => gu(e.evaluate(a), a.featureState || {})], properties: [en, [], (a) => a.properties()], "geometry-type": [ki, [], (a) => a.geometryType()], id: [br, [], (a) => a.id()], zoom: [di, [], (a) => a.globals.zoom], pitch: [di, [], (a) => a.globals.pitch || 0], "distance-from-center": [di, [], (a) => a.distanceFromCenter()], "measure-light": [di, [ki], (a, [e]) => a.measureLight(e.evaluate(a))], "heatmap-density": [di, [], (a) => a.globals.heatmapDensity || 0], "line-progress": [di, [], (a) => a.globals.lineProgress || 0], "raster-value": [di, [], (a) => a.globals.rasterValue || 0], "raster-particle-speed": [di, [], (a) => a.globals.rasterParticleSpeed || 0], "sky-radial-progress": [di, [], (a) => a.globals.skyRadialProgress || 0], accumulated: [br, [], (a) => a.globals.accumulated === void 0 ? null : a.globals.accumulated], "+": [di, ao(di), (a, e) => {
          let r = 0;
          for (const s of e) r += s.evaluate(a);
          return r;
        }], "*": [di, ao(di), (a, e) => {
          let r = 1;
          for (const s of e) r *= s.evaluate(a);
          return r;
        }], "-": { type: di, overloads: [[[di, di], (a, [e, r]) => e.evaluate(a) - r.evaluate(a)], [[di], (a, [e]) => -e.evaluate(a)]] }, "/": [di, [di, di], (a, [e, r]) => e.evaluate(a) / r.evaluate(a)], "%": [di, [di, di], (a, [e, r]) => e.evaluate(a) % r.evaluate(a)], ln2: [di, [], () => Math.LN2], pi: [di, [], () => Math.PI], e: [di, [], () => Math.E], "^": [di, [di, di], (a, [e, r]) => Math.pow(e.evaluate(a), r.evaluate(a))], sqrt: [di, [di], (a, [e]) => Math.sqrt(e.evaluate(a))], log10: [di, [di], (a, [e]) => Math.log(e.evaluate(a)) / Math.LN10], ln: [di, [di], (a, [e]) => Math.log(e.evaluate(a))], log2: [di, [di], (a, [e]) => Math.log(e.evaluate(a)) / Math.LN2], sin: [di, [di], (a, [e]) => Math.sin(e.evaluate(a))], cos: [di, [di], (a, [e]) => Math.cos(e.evaluate(a))], tan: [di, [di], (a, [e]) => Math.tan(e.evaluate(a))], asin: [di, [di], (a, [e]) => Math.asin(e.evaluate(a))], acos: [di, [di], (a, [e]) => Math.acos(e.evaluate(a))], atan: [di, [di], (a, [e]) => Math.atan(e.evaluate(a))], min: [di, ao(di), (a, e) => Math.min(...e.map((r) => r.evaluate(a)))], max: [di, ao(di), (a, e) => Math.max(...e.map((r) => r.evaluate(a)))], abs: [di, [di], (a, [e]) => Math.abs(e.evaluate(a))], round: [di, [di], (a, [e]) => {
          const r = e.evaluate(a);
          return r < 0 ? -Math.round(-r) : Math.round(r);
        }], floor: [di, [di], (a, [e]) => Math.floor(e.evaluate(a))], ceil: [di, [di], (a, [e]) => Math.ceil(e.evaluate(a))], "filter-==": [er, [ki, br], (a, [e, r]) => a.properties()[e.value] === r.value], "filter-id-==": [er, [br], (a, [e]) => a.id() === e.value], "filter-type-==": [er, [ki], (a, [e]) => a.geometryType() === e.value], "filter-<": [er, [ki, br], (a, [e, r]) => {
          const s = a.properties()[e.value], h = r.value;
          return typeof s == typeof h && s < h;
        }], "filter-id-<": [er, [br], (a, [e]) => {
          const r = a.id(), s = e.value;
          return typeof r == typeof s && r < s;
        }], "filter->": [er, [ki, br], (a, [e, r]) => {
          const s = a.properties()[e.value], h = r.value;
          return typeof s == typeof h && s > h;
        }], "filter-id->": [er, [br], (a, [e]) => {
          const r = a.id(), s = e.value;
          return typeof r == typeof s && r > s;
        }], "filter-<=": [er, [ki, br], (a, [e, r]) => {
          const s = a.properties()[e.value], h = r.value;
          return typeof s == typeof h && s <= h;
        }], "filter-id-<=": [er, [br], (a, [e]) => {
          const r = a.id(), s = e.value;
          return typeof r == typeof s && r <= s;
        }], "filter->=": [er, [ki, br], (a, [e, r]) => {
          const s = a.properties()[e.value], h = r.value;
          return typeof s == typeof h && s >= h;
        }], "filter-id->=": [er, [br], (a, [e]) => {
          const r = a.id(), s = e.value;
          return typeof r == typeof s && r >= s;
        }], "filter-has": [er, [br], (a, [e]) => e.value in a.properties()], "filter-has-id": [er, [], (a) => a.id() !== null && a.id() !== void 0], "filter-type-in": [er, [Hn(ki)], (a, [e]) => e.value.indexOf(a.geometryType()) >= 0], "filter-id-in": [er, [Hn(br)], (a, [e]) => e.value.indexOf(a.id()) >= 0], "filter-in-small": [er, [ki, Hn(br)], (a, [e, r]) => r.value.indexOf(a.properties()[e.value]) >= 0], "filter-in-large": [er, [ki, Hn(br)], (a, [e, r]) => function(s, h, o, f) {
          for (; o <= f; ) {
            const b = o + f >> 1;
            if (h[b] === s) return !0;
            h[b] > s ? f = b - 1 : o = b + 1;
          }
          return !1;
        }(a.properties()[e.value], r.value, 0, r.value.length - 1)], all: { type: er, overloads: [[[er, er], (a, [e, r]) => e.evaluate(a) && r.evaluate(a)], [ao(er), (a, e) => {
          for (const r of e) if (!r.evaluate(a)) return !1;
          return !0;
        }]] }, any: { type: er, overloads: [[[er, er], (a, [e, r]) => e.evaluate(a) || r.evaluate(a)], [ao(er), (a, e) => {
          for (const r of e) if (r.evaluate(a)) return !0;
          return !1;
        }]] }, "!": [er, [er], (a, [e]) => !e.evaluate(a)], "is-supported-script": [er, [ki], (a, [e]) => {
          const r = a.globals && a.globals.isSupportedScript;
          return !r || r(e.evaluate(a));
        }], upcase: [ki, [ki], (a, [e]) => e.evaluate(a).toUpperCase()], downcase: [ki, [ki], (a, [e]) => e.evaluate(a).toLowerCase()], concat: [ki, ao(br), (a, e) => e.map((r) => qn(r.evaluate(a))).join("")], "resolved-locale": [ki, [Gn], (a, [e]) => e.evaluate(a).resolvedLocale()], random: [di, [di, di, br], (a, e) => {
          const [r, s, h] = e.map((f) => f.evaluate(a));
          if (r > s || r === s) return r;
          let o;
          if (typeof h == "string") o = function(f) {
            let b = 0;
            if (f.length === 0) return b;
            for (let O = 0; O < f.length; O++) b = (b << 5) - b + f.charCodeAt(O), b |= 0;
            return b;
          }(h);
          else {
            if (typeof h != "number") throw new ia(`Invalid seed input: ${h}`);
            o = h;
          }
          return r + yo(o)() * (s - r);
        }] });
        class vu {
          constructor(e, r, s, h) {
            this.expression = e, this._warningHistory = {}, this._evaluator = new Mc(s, h), this._defaultValue = r ? function(o) {
              return o.type === "color" && (hs(o.default) || Array.isArray(o.default)) ? new Wr(0, 0, 0, 0) : o.type === "color" ? Wr.parse(o.default) || null : o.default === void 0 ? null : o.default;
            }(r) : null, this._enumValues = r && r.type === "enum" ? r.values : null, this.configDependencies = cu(e);
          }
          evaluateWithoutErrorHandling(e, r, s, h, o, f, b, O) {
            return this._evaluator.globals = e, this._evaluator.feature = r, this._evaluator.featureState = s, this._evaluator.canonical = h || null, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = f, this._evaluator.featureTileCoord = b || null, this._evaluator.featureDistanceData = O || null, this.expression.evaluate(this._evaluator);
          }
          evaluate(e, r, s, h, o, f, b, O) {
            this._evaluator.globals = e, this._evaluator.feature = r || null, this._evaluator.featureState = s || null, this._evaluator.canonical = h || null, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = f || null, this._evaluator.featureTileCoord = b || null, this._evaluator.featureDistanceData = O || null;
            try {
              const H = this.expression.evaluate(this._evaluator);
              if (H == null || typeof H == "number" && H != H) return this._defaultValue;
              if (this._enumValues && !(H in this._enumValues)) throw new ia(`Expected value to be one of ${Object.keys(this._enumValues).map((y) => JSON.stringify(y)).join(", ")}, but found ${JSON.stringify(H)} instead.`);
              return H;
            } catch (H) {
              return this._warningHistory[H.message] || (this._warningHistory[H.message] = !0, typeof console < "u" && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${H.message}`)), this._defaultValue;
            }
          }
        }
        function yu(a) {
          return Array.isArray(a) && a.length > 0 && typeof a[0] == "string" && a[0] in Nl;
        }
        function Ws(a, e, r, s) {
          const h = new ec(Nl, [], e ? function(f) {
            const b = { color: _r, string: ki, number: di, enum: ki, boolean: er, formatted: Ia, resolvedImage: ls };
            return f.type === "array" ? Hn(b[f.value] || br, f.length) : b[f.type];
          }(e) : void 0, void 0, void 0, r, s), o = h.parse(a, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return o ? sc(new vu(o, e, r, s)) : Rs(h.errors);
        }
        class xu {
          constructor(e, r, s, h) {
            this.kind = e, this._styleExpression = r, this.isLightConstant = s, this.isLineProgressConstant = h, this.isStateDependent = e !== "constant" && !Zo(r.expression), this.configDependencies = cu(r.expression);
          }
          evaluateWithoutErrorHandling(e, r, s, h, o, f) {
            return this._styleExpression.evaluateWithoutErrorHandling(e, r, s, h, o, f);
          }
          evaluate(e, r, s, h, o, f) {
            return this._styleExpression.evaluate(e, r, s, h, o, f);
          }
        }
        class bu {
          constructor(e, r, s, h, o, f) {
            this.kind = e, this.zoomStops = s, this._styleExpression = r, this.isStateDependent = e !== "camera" && !Zo(r.expression), this.isLightConstant = o, this.isLineProgressConstant = f, this.configDependencies = cu(r.expression), this.interpolationType = h;
          }
          evaluateWithoutErrorHandling(e, r, s, h, o, f) {
            return this._styleExpression.evaluateWithoutErrorHandling(e, r, s, h, o, f);
          }
          evaluate(e, r, s, h, o, f) {
            return this._styleExpression.evaluate(e, r, s, h, o, f);
          }
          interpolationFactor(e, r, s) {
            return this.interpolationType ? is.interpolationFactor(this.interpolationType, e, r, s) : 0;
          }
        }
        function rf(a, e, r, s) {
          if ((a = Ws(a, e, r, s)).result === "error") return a;
          const h = a.value.expression, o = ml(h);
          if (!o && !xo(e)) return Rs([new ht("", "data expressions not supported")]);
          const f = Dl(h, ["zoom", "pitch", "distance-from-center"]);
          if (!f && !ra(e)) return Rs([new ht("", "zoom expressions not supported")]);
          const b = Dl(h, ["measure-light"]);
          if (!b && !wa(e)) return Rs([new ht("", "measure-light expression not supported")]);
          const O = Dl(h, ["line-progress"]);
          if (!O && !function(B) {
            return gl(B.expression, "line-progress");
          }(e)) return Rs([new ht("", "line-progress expression not supported")]);
          const H = e.expression && e.expression.relaxZoomRestriction, y = wo(h);
          return y || f || H ? y instanceof ht ? Rs([y]) : y instanceof is && !bo(e) ? Rs([new ht("", '"interpolate" expressions cannot be used with this property')]) : sc(y ? new bu(o && O ? "camera" : "composite", a.value, y.labels, y instanceof is ? y.interpolation : void 0, b, O) : new xu(o && O ? "constant" : "source", a.value, b, O)) : Rs([new ht("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
        }
        class Uc {
          constructor(e, r) {
            this._parameters = e, this._specification = r, be(this, vl(this._parameters, this._specification));
          }
          static deserialize(e) {
            return new Uc(e._parameters, e._specification);
          }
          static serialize(e) {
            return { _parameters: e._parameters, _specification: e._specification };
          }
        }
        function wo(a) {
          let e = null;
          if (a instanceof ph) e = wo(a.result);
          else if (a instanceof dh) {
            for (const r of a.args) if (e = wo(r), e) break;
          } else (a instanceof fu || a instanceof is) && a.input instanceof ms && a.input.name === "zoom" && (e = a);
          return e instanceof ht || a.eachChild((r) => {
            const s = wo(r);
            s instanceof ht ? e = s : e && s && e !== s && (e = new ht("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e;
        }
        var Vl, wu, vh = function() {
          if (wu) return Vl;
          wu = 1, Vl = e;
          var a = 3;
          function e(r, s, h) {
            var o = this.cells = [];
            if (r instanceof ArrayBuffer) {
              this.arrayBuffer = r;
              var f = new Int32Array(this.arrayBuffer);
              r = f[0], this.d = (s = f[1]) + 2 * (h = f[2]);
              for (var b = 0; b < this.d * this.d; b++) {
                var O = f[a + b], H = f[a + b + 1];
                o.push(O === H ? null : f.subarray(O, H));
              }
              var y = f[a + o.length + 1];
              this.keys = f.subarray(f[a + o.length], y), this.bboxes = f.subarray(y), this.insert = this._insertReadonly;
            } else {
              this.d = s + 2 * h;
              for (var B = 0; B < this.d * this.d; B++) o.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = s, this.extent = r, this.padding = h, this.scale = s / r, this.uid = 0;
            var G = h / s * r;
            this.min = -G, this.max = r + G;
          }
          return e.prototype.insert = function(r, s, h, o, f) {
            this._forEachCell(s, h, o, f, this._insertCell, this.uid++), this.keys.push(r), this.bboxes.push(s), this.bboxes.push(h), this.bboxes.push(o), this.bboxes.push(f);
          }, e.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
          }, e.prototype._insertCell = function(r, s, h, o, f, b) {
            this.cells[f].push(b);
          }, e.prototype.query = function(r, s, h, o, f) {
            var b = this.min, O = this.max;
            if (r <= b && s <= b && O <= h && O <= o && !f) return Array.prototype.slice.call(this.keys);
            var H = [];
            return this._forEachCell(r, s, h, o, this._queryCell, H, {}, f), H;
          }, e.prototype._queryCell = function(r, s, h, o, f, b, O, H) {
            var y = this.cells[f];
            if (y !== null) for (var B = this.keys, G = this.bboxes, L = 0; L < y.length; L++) {
              var F = y[L];
              if (O[F] === void 0) {
                var Y = 4 * F;
                (H ? H(G[Y + 0], G[Y + 1], G[Y + 2], G[Y + 3]) : r <= G[Y + 2] && s <= G[Y + 3] && h >= G[Y + 0] && o >= G[Y + 1]) ? (O[F] = !0, b.push(B[F])) : O[F] = !1;
              }
            }
          }, e.prototype._forEachCell = function(r, s, h, o, f, b, O, H) {
            for (var y = this._convertToCellCoord(r), B = this._convertToCellCoord(s), G = this._convertToCellCoord(h), L = this._convertToCellCoord(o), F = y; F <= G; F++) for (var Y = B; Y <= L; Y++) {
              var ce = this.d * Y + F;
              if ((!H || H(this._convertFromCellCoord(F), this._convertFromCellCoord(Y), this._convertFromCellCoord(F + 1), this._convertFromCellCoord(Y + 1))) && f.call(this, r, s, h, o, ce, b, O, H)) return;
            }
          }, e.prototype._convertFromCellCoord = function(r) {
            return (r - this.padding) / this.scale;
          }, e.prototype._convertToCellCoord = function(r) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(r * this.scale) + this.padding));
          }, e.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer) return this.arrayBuffer;
            for (var r = this.cells, s = a + this.cells.length + 1 + 1, h = 0, o = 0; o < this.cells.length; o++) h += this.cells[o].length;
            var f = new Int32Array(s + h + this.keys.length + this.bboxes.length);
            f[0] = this.extent, f[1] = this.n, f[2] = this.padding;
            for (var b = s, O = 0; O < r.length; O++) {
              var H = r[O];
              f[a + O] = b, f.set(H, b), b += H.length;
            }
            return f[a + r.length] = b, f.set(this.keys, b), f[a + r.length + 1] = b += this.keys.length, f.set(this.bboxes, b), b += this.bboxes.length, f.buffer;
          }, Vl;
        }(), Xo = N(vh);
        const ks = {};
        function ur(a, e, r = {}) {
          Object.defineProperty(a, "_classRegistryKey", { value: e, writable: !1 }), ks[e] = { klass: a, omit: r.omit || [] };
        }
        ur(Object, "Object"), Xo.serialize = function(a, e) {
          const r = a.toArrayBuffer();
          return e && e.add(r), { buffer: r };
        }, Xo.deserialize = function(a) {
          return new Xo(a.buffer);
        }, Object.defineProperty(Xo, "name", { value: "Grid" }), ur(Xo, "Grid"), typeof DOMMatrix < "u" && ur(DOMMatrix, "DOMMatrix"), ur(Wr, "Color"), ur(Error, "Error"), ur(Na, "Formatted"), ur(Vs, "FormattedSection"), ur(wn, "AJAXError"), ur(Ua, "ResolvedImage"), ur(Uc, "StylePropertyFunction"), ur(vu, "StyleExpression", { omit: ["_evaluator"] }), ur(bs, "ImageIdWithOptions"), ur(bu, "ZoomDependentExpression"), ur(xu, "ZoomConstantExpression"), ur(ms, "CompoundExpression", { omit: ["_evaluate"] });
        for (const a in Nl) ks[Nl[a]._classRegistryKey] || ur(Nl[a], `Expression${a}`);
        function yl(a) {
          return a && typeof ArrayBuffer < "u" && (a instanceof ArrayBuffer || a.constructor && a.constructor.name === "ArrayBuffer");
        }
        function Po(a) {
          return self.ImageBitmap && a instanceof ImageBitmap;
        }
        function ws(a, e) {
          if (a == null || typeof a == "boolean" || typeof a == "number" || typeof a == "string" || a instanceof Boolean || a instanceof Number || a instanceof String || a instanceof Date || a instanceof RegExp) return a;
          if (yl(a) || Po(a)) return e && e.add(a), a;
          if (ArrayBuffer.isView(a)) return e && e.add(a.buffer), a;
          if (a instanceof ImageData) return e && e.add(a.data.buffer), a;
          if (Array.isArray(a)) {
            const r = [];
            for (const s of a) r.push(ws(s, e));
            return r;
          }
          if (a instanceof Map) {
            const r = { $name: "Map" };
            for (const [s, h] of a.entries()) r[s] = ws(h);
            return r;
          }
          if (a instanceof Set) {
            const r = { $name: "Set" };
            let s = 0;
            for (const h of a.values()) r[++s] = ws(h);
            return r;
          }
          if (typeof a == "object") {
            const r = a.constructor, s = r._classRegistryKey;
            if (!s) throw new Error(`Can't serialize object of unregistered class "${s}".`);
            const h = r.serialize ? r.serialize(a, e) : {};
            if (!r.serialize) {
              for (const o in a) a.hasOwnProperty(o) && (ks[s].omit.indexOf(o) >= 0 || (h[o] = ws(a[o], e)));
              a instanceof Error && (h.message = a.message);
            }
            if (h.$name) throw new Error("$name property is reserved for worker serialization logic.");
            return s !== "Object" && (h.$name = s), h;
          }
          throw new Error("can't serialize object of type " + typeof a);
        }
        function so(a) {
          if (a == null || typeof a == "boolean" || typeof a == "number" || typeof a == "string" || a instanceof Boolean || a instanceof Number || a instanceof String || a instanceof Date || a instanceof RegExp || yl(a) || Po(a) || ArrayBuffer.isView(a) || a instanceof ImageData) return a;
          if (Array.isArray(a)) return a.map(so);
          if (typeof a == "object") {
            const e = a.$name || "Object";
            if (e === "Map") {
              const h = /* @__PURE__ */ new Map();
              for (const o of Object.keys(a)) o !== "$name" && h.set(o, so(a[o]));
              return h;
            }
            if (e === "Set") {
              const h = /* @__PURE__ */ new Set();
              for (const o of Object.keys(a)) o !== "$name" && h.add(so(a[o]));
              return h;
            }
            const { klass: r } = ks[e];
            if (!r) throw new Error(`Can't deserialize unregistered class "${e}".`);
            if (r.deserialize) return r.deserialize(a);
            const s = Object.create(r.prototype);
            for (const h of Object.keys(a)) h !== "$name" && (s[h] = so(a[h]));
            return s;
          }
          throw new Error("can't deserialize object of type " + typeof a);
        }
        const wr = { "Latin-1 Supplement": (a) => a >= 128 && a <= 255, Arabic: (a) => a >= 1536 && a <= 1791, "Arabic Supplement": (a) => a >= 1872 && a <= 1919, "Arabic Extended-A": (a) => a >= 2208 && a <= 2303, "Hangul Jamo": (a) => a >= 4352 && a <= 4607, "Unified Canadian Aboriginal Syllabics": (a) => a >= 5120 && a <= 5759, Khmer: (a) => a >= 6016 && a <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (a) => a >= 6320 && a <= 6399, "General Punctuation": (a) => a >= 8192 && a <= 8303, "Letterlike Symbols": (a) => a >= 8448 && a <= 8527, "Number Forms": (a) => a >= 8528 && a <= 8591, "Miscellaneous Technical": (a) => a >= 8960 && a <= 9215, "Control Pictures": (a) => a >= 9216 && a <= 9279, "Optical Character Recognition": (a) => a >= 9280 && a <= 9311, "Enclosed Alphanumerics": (a) => a >= 9312 && a <= 9471, "Geometric Shapes": (a) => a >= 9632 && a <= 9727, "Miscellaneous Symbols": (a) => a >= 9728 && a <= 9983, "Miscellaneous Symbols and Arrows": (a) => a >= 11008 && a <= 11263, "CJK Radicals Supplement": (a) => a >= 11904 && a <= 12031, "Kangxi Radicals": (a) => a >= 12032 && a <= 12255, "Ideographic Description Characters": (a) => a >= 12272 && a <= 12287, "CJK Symbols and Punctuation": (a) => a >= 12288 && a <= 12351, Hiragana: (a) => a >= 12352 && a <= 12447, Katakana: (a) => a >= 12448 && a <= 12543, Bopomofo: (a) => a >= 12544 && a <= 12591, "Hangul Compatibility Jamo": (a) => a >= 12592 && a <= 12687, Kanbun: (a) => a >= 12688 && a <= 12703, "Bopomofo Extended": (a) => a >= 12704 && a <= 12735, "CJK Strokes": (a) => a >= 12736 && a <= 12783, "Katakana Phonetic Extensions": (a) => a >= 12784 && a <= 12799, "Enclosed CJK Letters and Months": (a) => a >= 12800 && a <= 13055, "CJK Compatibility": (a) => a >= 13056 && a <= 13311, "CJK Unified Ideographs Extension A": (a) => a >= 13312 && a <= 19903, "Yijing Hexagram Symbols": (a) => a >= 19904 && a <= 19967, "CJK Unified Ideographs": (a) => a >= 19968 && a <= 40959, "Yi Syllables": (a) => a >= 40960 && a <= 42127, "Yi Radicals": (a) => a >= 42128 && a <= 42191, "Hangul Jamo Extended-A": (a) => a >= 43360 && a <= 43391, "Hangul Syllables": (a) => a >= 44032 && a <= 55215, "Hangul Jamo Extended-B": (a) => a >= 55216 && a <= 55295, "Private Use Area": (a) => a >= 57344 && a <= 63743, "CJK Compatibility Ideographs": (a) => a >= 63744 && a <= 64255, "Arabic Presentation Forms-A": (a) => a >= 64336 && a <= 65023, "Vertical Forms": (a) => a >= 65040 && a <= 65055, "CJK Compatibility Forms": (a) => a >= 65072 && a <= 65103, "Small Form Variants": (a) => a >= 65104 && a <= 65135, "Arabic Presentation Forms-B": (a) => a >= 65136 && a <= 65279, "Halfwidth and Fullwidth Forms": (a) => a >= 65280 && a <= 65519, Osage: (a) => a >= 66736 && a <= 66815, "CJK Unified Ideographs Extension B": (a) => a >= 131072 && a <= 173791 };
        function Vc(a) {
          for (const e of a) if (Ss(e.charCodeAt(0))) return !0;
          return !1;
        }
        function nf(a) {
          for (const e of a) if (!oo(e.charCodeAt(0))) return !1;
          return !0;
        }
        function oo(a) {
          return !(wr.Arabic(a) || wr["Arabic Supplement"](a) || wr["Arabic Extended-A"](a) || wr["Arabic Presentation Forms-A"](a) || wr["Arabic Presentation Forms-B"](a));
        }
        function Ss(a) {
          return !(a !== 746 && a !== 747 && (a < 4352 || !(wr["Bopomofo Extended"](a) || wr.Bopomofo(a) || wr["CJK Compatibility Forms"](a) && !(a >= 65097 && a <= 65103) || wr["CJK Compatibility Ideographs"](a) || wr["CJK Compatibility"](a) || wr["CJK Radicals Supplement"](a) || wr["CJK Strokes"](a) || !(!wr["CJK Symbols and Punctuation"](a) || a >= 12296 && a <= 12305 || a >= 12308 && a <= 12319 || a === 12336) || wr["CJK Unified Ideographs Extension A"](a) || wr["CJK Unified Ideographs"](a) || wr["Enclosed CJK Letters and Months"](a) || wr["Hangul Compatibility Jamo"](a) || wr["Hangul Jamo Extended-A"](a) || wr["Hangul Jamo Extended-B"](a) || wr["Hangul Jamo"](a) || wr["Hangul Syllables"](a) || wr.Hiragana(a) || wr["Ideographic Description Characters"](a) || wr.Kanbun(a) || wr["Kangxi Radicals"](a) || wr["Katakana Phonetic Extensions"](a) || wr.Katakana(a) && a !== 12540 || !(!wr["Halfwidth and Fullwidth Forms"](a) || a === 65288 || a === 65289 || a === 65293 || a >= 65306 && a <= 65310 || a === 65339 || a === 65341 || a === 65343 || a >= 65371 && a <= 65503 || a === 65507 || a >= 65512 && a <= 65519) || !(!wr["Small Form Variants"](a) || a >= 65112 && a <= 65118 || a >= 65123 && a <= 65126) || wr["Unified Canadian Aboriginal Syllabics"](a) || wr["Unified Canadian Aboriginal Syllabics Extended"](a) || wr["Vertical Forms"](a) || wr["Yijing Hexagram Symbols"](a) || wr["Yi Syllables"](a) || wr["Yi Radicals"](a))));
        }
        function Sa(a) {
          return !(Ss(a) || function(e) {
            return !!(wr["Latin-1 Supplement"](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || wr["General Punctuation"](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || wr["Letterlike Symbols"](e) || wr["Number Forms"](e) || wr["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || wr["Control Pictures"](e) && e !== 9251 || wr["Optical Character Recognition"](e) || wr["Enclosed Alphanumerics"](e) || wr["Geometric Shapes"](e) || wr["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || wr["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || wr["CJK Symbols and Punctuation"](e) || wr.Katakana(e) || wr["Private Use Area"](e) || wr["CJK Compatibility Forms"](e) || wr["Small Form Variants"](e) || wr["Halfwidth and Fullwidth Forms"](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533);
          }(a));
        }
        function lo(a) {
          return a >= 1424 && a <= 2303 || wr["Arabic Presentation Forms-A"](a) || wr["Arabic Presentation Forms-B"](a);
        }
        function af(a, e) {
          return !(!e && lo(a) || a >= 2304 && a <= 3583 || a >= 3840 && a <= 4255 || wr.Khmer(a));
        }
        function yh(a) {
          for (const e of a) if (lo(e.charCodeAt(0))) return !0;
          return !1;
        }
        const Su = "deferred", oc = "loading", xh = "loaded";
        let uo = null, Ls = "unavailable", co = null;
        const jc = function(a) {
          a && typeof a == "string" && a.indexOf("NetworkError") > -1 && (Ls = "error"), uo && uo(a);
        };
        function sf() {
          Yo.fire(new mn("pluginStateChange", { pluginStatus: Ls, pluginURL: co }));
        }
        const Yo = new tn(), Eu = function() {
          return Ls;
        }, lc = function() {
          if (Ls !== Su || !co) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
          Ls = oc, sf(), co && Vn({ url: co }, (a) => {
            a ? jc(a) : (Ls = xh, sf());
          });
        }, Zs = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Ls === xh || Zs.applyArabicShaping != null, isLoading: () => Ls === oc, setState(a) {
          Ls = a.pluginStatus, co = a.pluginURL;
        }, isParsed: () => Zs.applyArabicShaping != null && Zs.processBidirectionalText != null && Zs.processStyledBidirectionalText != null, getPluginURL: () => co };
        class Tn {
          constructor(e, r) {
            this.zoom = e, r ? (this.now = r.now, this.fadeDuration = r.fadeDuration, this.transition = r.transition, this.pitch = r.pitch, this.brightness = r.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
          }
          isSupportedScript(e) {
            return function(r, s) {
              for (const h of r) if (!af(h.charCodeAt(0), s)) return !1;
              return !0;
            }(e, Zs.isLoaded());
          }
        }
        class Gc {
          constructor(e, r, s, h) {
            this.property = e, this.value = r, this.expression = function(o, f, b, O) {
              if (hs(o)) return new Uc(o, f);
              if (yu(o) || Array.isArray(o) && o.length > 0) {
                const H = rf(o, f, b, O);
                if (H.result === "error") throw new Error(H.value.map((y) => `${y.key}: ${y.message}`).join(", "));
                return H.value;
              }
              {
                let H = o;
                return typeof o == "string" && f.type === "color" && (H = Wr.parse(o)), { kind: "constant", configDependencies: /* @__PURE__ */ new Set(), evaluate: () => H };
              }
            }(r === void 0 ? e.specification.default : r, e.specification, s, h);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          possiblyEvaluate(e, r, s) {
            return this.property.possiblyEvaluate(this, e, r, s);
          }
        }
        class jl {
          constructor(e, r, s) {
            this.property = e, this.value = new Gc(e, void 0, r, s);
          }
          transitioned(e, r) {
            return new Gl(this.property, this.value, r, I({}, e.transition, this.transition), e.now);
          }
          untransitioned() {
            return new Gl(this.property, this.value, null, {}, 0);
          }
        }
        class Tu {
          constructor(e, r, s) {
            this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues), this._scope = r, this._options = s, this.configDependencies = /* @__PURE__ */ new Set();
          }
          getValue(e) {
            return Qe(this._values[e].value.value);
          }
          setValue(e, r) {
            this._values.hasOwnProperty(e) || (this._values[e] = new jl(this._values[e].property, this._scope, this._options)), this._values[e].value = new Gc(this._values[e].property, r === null ? void 0 : Qe(r), this._scope, this._options), this._values[e].value.expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[e].value.expression.configDependencies]));
          }
          setTransitionOrValue(e, r) {
            r && (this._options = r);
            const s = this._properties.properties;
            if (e) for (const h in e) {
              const o = e[h];
              if (ye(h, "-transition")) {
                const f = h.slice(0, -11);
                s[f] && this.setTransition(f, o);
              } else s.hasOwnProperty(h) && this.setValue(h, o);
            }
          }
          getTransition(e) {
            return Qe(this._values[e].transition);
          }
          setTransition(e, r) {
            this._values.hasOwnProperty(e) || (this._values[e] = new jl(this._values[e].property)), this._values[e].transition = Qe(r) || void 0;
          }
          serialize() {
            const e = {};
            for (const r of Object.keys(this._values)) {
              const s = this.getValue(r);
              s !== void 0 && (e[r] = s);
              const h = this.getTransition(r);
              h !== void 0 && (e[`${r}-transition`] = h);
            }
            return e;
          }
          transitioned(e, r) {
            const s = new Cu(this._properties);
            for (const h of Object.keys(this._values)) s._values[h] = this._values[h].transitioned(e, r._values[h]);
            return s;
          }
          untransitioned() {
            const e = new Cu(this._properties);
            for (const r of Object.keys(this._values)) e._values[r] = this._values[r].untransitioned();
            return e;
          }
        }
        class Gl {
          constructor(e, r, s, h, o) {
            const f = h.delay || 0, b = h.duration || 0;
            o = o || 0, this.property = e, this.value = r, this.begin = o + f, this.end = this.begin + b, e.specification.transition && (h.delay || h.duration) && (this.prior = s);
          }
          possiblyEvaluate(e, r, s) {
            const h = e.now || 0, o = this.value.possiblyEvaluate(e, r, s), f = this.prior;
            if (f) {
              if (h > this.end) return this.prior = null, o;
              if (this.value.isDataDriven()) return this.prior = null, o;
              if (h < this.begin) return f.possiblyEvaluate(e, r, s);
              {
                const b = (h - this.begin) / (this.end - this.begin);
                return this.property.interpolate(f.possiblyEvaluate(e, r, s), o, _t(b));
              }
            }
            return o;
          }
        }
        class Cu {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(e, r, s) {
            const h = new Wl(this._properties);
            for (const o of Object.keys(this._values)) h._values[o] = this._values[o].possiblyEvaluate(e, r, s);
            return h;
          }
          hasTransition() {
            for (const e of Object.keys(this._values)) if (this._values[e].prior) return !0;
            return !1;
          }
        }
        class Hl {
          constructor(e, r, s) {
            this._properties = e, this._values = Object.create(e.defaultPropertyValues), this._scope = r, this._options = s, this.configDependencies = /* @__PURE__ */ new Set();
          }
          getValue(e) {
            return Qe(this._values[e].value);
          }
          setValue(e, r) {
            this._values[e] = new Gc(this._values[e].property, r === null ? void 0 : Qe(r), this._scope, this._options), this._values[e].expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[e].expression.configDependencies]));
          }
          serialize() {
            const e = {};
            for (const r of Object.keys(this._values)) {
              const s = this.getValue(r);
              s !== void 0 && (e[r] = s);
            }
            return e;
          }
          possiblyEvaluate(e, r, s) {
            const h = new Wl(this._properties);
            for (const o of Object.keys(this._values)) h._values[o] = this._values[o].possiblyEvaluate(e, r, s);
            return h;
          }
        }
        class ql {
          constructor(e, r, s) {
            this.property = e, this.value = r, this.parameters = s;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(e) {
            return this.value.kind === "constant" ? this.value.value : e;
          }
          evaluate(e, r, s, h) {
            return this.property.evaluate(this.value, this.parameters, e, r, s, h);
          }
        }
        class Wl {
          constructor(e) {
            this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
          }
          get(e) {
            return this._values[e];
          }
        }
        class Ji {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, r) {
            return e.expression.evaluate(r);
          }
          interpolate(e, r, s) {
            const h = D[this.specification.type];
            return h ? h(e, r, s) : e;
          }
        }
        class or {
          constructor(e, r) {
            this.specification = e, this.overrides = r;
          }
          possiblyEvaluate(e, r, s, h) {
            return new ql(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(r, null, {}, s, h) } : e.expression, r);
          }
          interpolate(e, r, s) {
            if (e.value.kind !== "constant" || r.value.kind !== "constant") return e;
            if (e.value.value === void 0 || r.value.value === void 0) return new ql(this, { kind: "constant", value: void 0 }, e.parameters);
            const h = D[this.specification.type];
            return h ? new ql(this, { kind: "constant", value: h(e.value.value, r.value.value, s) }, e.parameters) : e;
          }
          evaluate(e, r, s, h, o, f) {
            return e.kind === "constant" ? e.value : e.evaluate(r, s, h, o, f);
          }
        }
        class So {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, r, s, h) {
            return !!e.expression.evaluate(r, null, {}, s, h);
          }
          interpolate() {
            return !1;
          }
        }
        class Wn {
          constructor(e) {
            this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            const r = new Tn(0, {});
            for (const s in e) {
              const h = e[s];
              h.specification.overridable && this.overridableProperties.push(s);
              const o = this.defaultPropertyValues[s] = new Gc(h, void 0), f = this.defaultTransitionablePropertyValues[s] = new jl(h);
              this.defaultTransitioningPropertyValues[s] = f.untransitioned(), this.defaultPossiblyEvaluatedValues[s] = o.possiblyEvaluate(r);
            }
          }
        }
        ur(or, "DataDrivenProperty"), ur(Ji, "DataConstantProperty"), ur(So, "ColorRampProperty");
        var Ei = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow","experimental":true},"rain":{"type":"rain","experimental":true},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor","experimental":true},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"experimental":true,"type":"featuresets"}},"featuresets":{"experimental":true,"*":{"type":"featureset"}},"featureset":{"experimental":true,"metadata":{"experimental":true,"type":"*"},"selectors":{"experimental":true,"type":"array","value":"selector"}},"selector":{"experimental":true,"layer":{"experimental":true,"type":"string","required":true},"properties":{"experimental":true,"type":"selectorProperty","required":false},"featureNamespace":{"experimental":true,"type":"string","required":false},"_uniqueFeatureID":{"experimental":true,"type":"boolean","private":true,"required":false}},"selectorProperty":{"experimental":true,"*":{"experimental":true,"type":"*"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","property-type":"data-constant","expression":{},"required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"property-type":"data-constant"},"shadow-quality":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]},"experimental":true},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"experimental":true,"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{"experimental":true},"hillshade":{},"model":{"experimental":true},"background":{},"sky":{},"slot":{},"clip":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{},"property-type":"data-constant"},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{},"property-type":"data-constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","experimental":true,"private":true,"expression":{},"property-type":"data-constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"circle-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-markup":1},"default":"none","experimental":true,"expression":{},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","experimental":true,"default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","experimental":true,"expression":{},"property-type":"data-constant"},"line-cross-slope":{"type":"number","experimental":true,"expression":{},"property-type":"constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","experimental":true,"private":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","experimental":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.4,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","property-type":"data-constant","default":0.71,"minimum":0,"maximum":5,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.57,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","property-type":"data-constant","default":0.7,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"colorTheme":{"data":{"type":"string","property-type":"data-constant","expression":{}}},"indoor":{"floorplanFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}},"buildingFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"flat","property-type":"data-constant"},"fill-extrusion-base-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"terrain","property-type":"data-constant"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","experimental":true,"default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","experimental":true,"default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"experimental":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-trim-fade-range":{"type":"array","value":"number","experimental":true,"length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-trim-color":{"type":"color","experimental":true,"default":"transparent","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"property-type":"data-constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"experimental":true,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]},"experimental":true,"property-type":"data-constant"},"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"model-front-cutoff":{"type":"array","private":true,"value":"number","property-type":"data-constant","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"*"}}}');
        function Ko(a) {
          return a instanceof Number || a instanceof String || a instanceof Boolean ? a.valueOf() : a;
        }
        function Ro(a) {
          if (Array.isArray(a)) return a.map(Ro);
          if (a instanceof Object && !(a instanceof Number || a instanceof String || a instanceof Boolean)) {
            const e = {};
            for (const r in a) e[r] = Ro(a[r]);
            return e;
          }
          return Ko(a);
        }
        function Hc(a) {
          if (a === !0 || a === !1) return !0;
          if (!Array.isArray(a) || a.length === 0) return !1;
          switch (a[0]) {
            case "has":
              return a.length >= 2 && a[1] !== "$id" && a[1] !== "$type";
            case "in":
              return a.length >= 3 && (typeof a[1] != "string" || Array.isArray(a[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return a.length !== 3 || Array.isArray(a[1]) || Array.isArray(a[2]);
            case "any":
            case "all":
              for (const e of a.slice(1)) if (!Hc(e) && typeof e != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        function of(a, e = "", r = null, s = "fill") {
          if (a == null) return { filter: () => !0, needGeometry: !1, needFeature: !1 };
          Hc(a) || (a = Zl(a));
          const h = a;
          let o = !0;
          try {
            o = function(y) {
              if (!bl(y)) return y;
              let B = Ro(y);
              return xl(B), B = Jo(B), B;
            }(h);
          } catch {
            console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(h, null, 2)}
        `);
          }
          let f = null, b = null;
          if (s !== "background" && s !== "sky" && s !== "slot") {
            b = Ei[`filter_${s}`];
            const y = Ws(o, b, e, r);
            if (y.result === "error") throw new Error(y.value.map((B) => `${B.key}: ${B.message}`).join(", "));
            f = (B, G, L) => y.value.evaluate(B, G, {}, L);
          }
          let O = null, H = null;
          if (o !== h) {
            const y = Ws(h, b, e, r);
            if (y.result === "error") throw new Error(y.value.map((B) => `${B.key}: ${B.message}`).join(", "));
            O = (B, G, L, F, Y) => y.value.evaluate(B, G, {}, L, void 0, void 0, F, Y), H = !ml(y.value.expression);
          }
          return { filter: f, dynamicFilter: O || void 0, needGeometry: lf(o), needFeature: !!H };
        }
        function Jo(a) {
          if (!Array.isArray(a)) return a;
          const e = function(r) {
            if (Bf.has(r[0])) {
              for (let s = 1; s < r.length; s++) if (bl(r[s])) return !0;
            }
            return r;
          }(a);
          return e === !0 ? e : e.map((r) => Jo(r));
        }
        function xl(a) {
          let e = !1;
          const r = [];
          if (a[0] === "case") {
            for (let s = 1; s < a.length - 1; s += 2) e = e || bl(a[s]), r.push(a[s + 1]);
            r.push(a[a.length - 1]);
          } else if (a[0] === "match") {
            e = e || bl(a[1]);
            for (let s = 2; s < a.length - 1; s += 2) r.push(a[s + 1]);
            r.push(a[a.length - 1]);
          } else if (a[0] === "step") {
            e = e || bl(a[1]);
            for (let s = 1; s < a.length - 1; s += 2) r.push(a[s + 1]);
          }
          e && (a.length = 0, a.push("any", ...r));
          for (let s = 1; s < a.length; s++) xl(a[s]);
        }
        function bl(a) {
          if (!Array.isArray(a)) return !1;
          if ((e = a[0]) === "pitch" || e === "distance-from-center") return !0;
          var e;
          for (let r = 1; r < a.length; r++) if (bl(a[r])) return !0;
          return !1;
        }
        const Bf = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
        function bh(a, e) {
          return a < e ? -1 : a > e ? 1 : 0;
        }
        function lf(a) {
          if (!Array.isArray(a)) return !1;
          if (a[0] === "within" || a[0] === "distance") return !0;
          for (let e = 1; e < a.length; e++) if (lf(a[e])) return !0;
          return !1;
        }
        function Zl(a) {
          if (!a) return !0;
          const e = a[0];
          return a.length <= 1 ? e !== "any" : e === "==" ? _s(a[1], a[2], "==") : e === "!=" ? ho(_s(a[1], a[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? _s(a[1], a[2], e) : e === "any" ? (r = a.slice(1), ["any"].concat(r.map(Zl))) : e === "all" ? ["all"].concat(a.slice(1).map(Zl)) : e === "none" ? ["all"].concat(a.slice(1).map(Zl).map(ho)) : e === "in" ? Au(a[1], a.slice(2)) : e === "!in" ? ho(Au(a[1], a.slice(2))) : e === "has" ? Mu(a[1]) : e !== "!has" || ho(Mu(a[1]));
          var r;
        }
        function _s(a, e, r) {
          switch (a) {
            case "$type":
              return [`filter-type-${r}`, e];
            case "$id":
              return [`filter-id-${r}`, e];
            default:
              return [`filter-${r}`, a, e];
          }
        }
        function Au(a, e) {
          if (e.length === 0) return !1;
          switch (a) {
            case "$type":
              return ["filter-type-in", ["literal", e]];
            case "$id":
              return ["filter-id-in", ["literal", e]];
            default:
              return e.length > 200 && !e.some((r) => typeof r != typeof e[0]) ? ["filter-in-large", a, ["literal", e.sort(bh)]] : ["filter-in-small", a, ["literal", e]];
          }
        }
        function Mu(a) {
          switch (a) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", a];
          }
        }
        function ho(a) {
          return ["!", a];
        }
        const uc = "";
        function Os(a, e) {
          return e ? `${a}${uc}${e}` : a;
        }
        const Qo = "-transition", wh = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
        class bn extends tn {
          constructor(e, r, s, h, o) {
            if (super(), this.id = e.id, this.fqid = Os(this.id, s), this.type = e.type, this.scope = s, this.lut = h, this.options = o, this._featureFilter = { filter: () => !0, needGeometry: !1, needFeature: !1 }, this._filterCompiled = !1, this.configDependencies = /* @__PURE__ */ new Set(), e.type !== "custom") {
              if (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type && e.type !== "background" && e.type !== "sky" && e.type !== "slot") {
                this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter;
                const f = Ws(this.filter, Ei[`filter_${e.type}`]);
                f.result !== "error" && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...f.value.configDependencies]));
              }
              if (e.slot && (this.slot = e.slot), r.layout && (this._unevaluatedLayout = new Hl(r.layout, this.scope, o), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), r.paint) {
                this._transitionablePaint = new Tu(r.paint, this.scope, o);
                for (const f in e.paint) this.setPaintProperty(f, e.paint[f]);
                for (const f in e.layout) this.setLayoutProperty(f, e.layout[f]);
                this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Wl(r.paint);
              }
            }
          }
          onAdd(e) {
          }
          onRemove(e) {
          }
          isDraped(e) {
            return !this.is3D() && wh.has(this.type);
          }
          getLayoutProperty(e) {
            return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
          }
          setLayoutProperty(e, r) {
            if (this.type === "custom" && e === "visibility") return void (this.visibility = r);
            const s = this._unevaluatedLayout;
            s._properties.properties[e] && (s.setValue(e, r), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...s.configDependencies]), e === "visibility" && this.possiblyEvaluateVisibility());
          }
          possiblyEvaluateVisibility() {
            this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 }));
          }
          getPaintProperty(e) {
            return ye(e, Qo) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
          }
          setPaintProperty(e, r) {
            const s = this._transitionablePaint, h = s._properties.properties;
            if (ye(e, Qo)) {
              const B = e.slice(0, -11);
              return h[B] && s.setTransition(B, r || void 0), !1;
            }
            if (!h[e]) return !1;
            const o = s._values[e], f = o.value.isDataDriven(), b = o.value;
            s.setValue(e, r), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...s.configDependencies]), this._handleSpecialPaintPropertyUpdate(e);
            const O = s._values[e].value, H = O.isDataDriven(), y = ye(e, "pattern") || e === "line-dasharray";
            return H || f || y || this._handleOverridablePaintPropertyUpdate(e, b, O);
          }
          _handleSpecialPaintPropertyUpdate(e) {
          }
          getProgramIds() {
            return null;
          }
          getDefaultProgramParams(e, r, s) {
            return null;
          }
          _handleOverridablePaintPropertyUpdate(e, r, s) {
            return !1;
          }
          isHidden(e) {
            return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(e) {
            this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(e, r) {
            this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, r)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, r);
          }
          serialize() {
            return Ge({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (e, r) => !(e === void 0 || r === "layout" && !Object.keys(e).length || r === "paint" && !Object.keys(e).length));
          }
          is3D() {
            return !1;
          }
          isSky() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          hasShadowPass() {
            return !1;
          }
          canCastShadows() {
            return !1;
          }
          hasLightBeamPass() {
            return !1;
          }
          cutoffRange() {
            return 0;
          }
          tileCoverLift() {
            return 0;
          }
          resize() {
          }
          isStateDependent() {
            for (const e in this.paint._values) {
              const r = this.paint.get(e);
              if (r instanceof ql && xo(r.property.specification) && (r.value.kind === "source" || r.value.kind === "composite") && r.value.isStateDependent) return !0;
            }
            return !1;
          }
          compileFilter(e) {
            this._filterCompiled || (this._featureFilter = of(this.filter, this.scope, e), this._filterCompiled = !0);
          }
          invalidateCompiledFilter() {
            this._filterCompiled = !1;
          }
          dynamicFilter() {
            return this._featureFilter.dynamicFilter;
          }
          dynamicFilterNeedsFeature() {
            return this._featureFilter.needFeature;
          }
          getLayerRenderingStats() {
            return this._stats;
          }
          resetLayerRenderingStats(e) {
            this._stats && (e.renderPass === "shadow" ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
          }
          queryRadius(e) {
          }
          queryIntersectsFeature(e, r, s, h, o, f, b, O, H) {
          }
        }
        const Sh = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Iu {
          constructor(e, r) {
            this._structArray = e, this._pos1 = r * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class Ln {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(e, r) {
            return e._trim(), r && (e.isTransferred = !0, r.add(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
          }
          static deserialize(e) {
            const r = Object.create(this.prototype);
            return r.arrayBuffer = e.arrayBuffer, r.length = e.length, r.capacity = e.arrayBuffer.byteLength / r.bytesPerElement, r._refreshViews(), r;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(e) {
            this.reserve(e), this.length = e;
          }
          reserve(e) {
            if (e > this.capacity) {
              this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const r = this.uint8;
              this._refreshViews(), r && this.uint8.set(r);
            }
          }
          _refreshViews() {
            throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
          }
          emplace(...e) {
            throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
          }
          emplaceBack(...e) {
            throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
          }
          destroy() {
            this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
          }
        }
        function dn(a, e = 1) {
          let r = 0, s = 0;
          return { members: a.map((h) => {
            const o = Sh[h.type].BYTES_PER_ELEMENT, f = r = Eh(r, Math.max(e, o)), b = h.components || 1;
            return s = Math.max(s, o), r += o * b, { name: h.name, type: h.type, components: b, offset: f };
          }), size: Eh(r, Math.max(s, e)), alignment: e };
        }
        function Eh(a, e) {
          return Math.ceil(a / e) * e;
        }
        class Ds extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, e, r);
          }
          emplace(e, r, s) {
            const h = 2 * e;
            return this.int16[h + 0] = r, this.int16[h + 1] = s, e;
          }
        }
        Ds.prototype.bytesPerElement = 4, ur(Ds, "StructArrayLayout2i4");
        class oa extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, e, r, s);
          }
          emplace(e, r, s, h) {
            const o = 3 * e;
            return this.int16[o + 0] = r, this.int16[o + 1] = s, this.int16[o + 2] = h, e;
          }
        }
        oa.prototype.bytesPerElement = 6, ur(oa, "StructArrayLayout3i6");
        class pa extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, e, r, s, h);
          }
          emplace(e, r, s, h, o) {
            const f = 4 * e;
            return this.int16[f + 0] = r, this.int16[f + 1] = s, this.int16[f + 2] = h, this.int16[f + 3] = o, e;
          }
        }
        pa.prototype.bytesPerElement = 8, ur(pa, "StructArrayLayout4i8");
        class ja extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, s, h, o);
          }
          emplace(e, r, s, h, o, f) {
            const b = 5 * e;
            return this.int16[b + 0] = r, this.int16[b + 1] = s, this.int16[b + 2] = h, this.int16[b + 3] = o, this.int16[b + 4] = f, e;
          }
        }
        ja.prototype.bytesPerElement = 10, ur(ja, "StructArrayLayout5i10");
        class $l extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f, b) {
            const O = this.length;
            return this.resize(O + 1), this.emplace(O, e, r, s, h, o, f, b);
          }
          emplace(e, r, s, h, o, f, b, O) {
            const H = 6 * e, y = 12 * e, B = 3 * e;
            return this.int16[H + 0] = r, this.int16[H + 1] = s, this.uint8[y + 4] = h, this.uint8[y + 5] = o, this.uint8[y + 6] = f, this.uint8[y + 7] = b, this.float32[B + 2] = O, e;
          }
        }
        $l.prototype.bytesPerElement = 12, ur($l, "StructArrayLayout2i4ub1f12");
        class $s extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, e, r, s);
          }
          emplace(e, r, s, h) {
            const o = 3 * e;
            return this.float32[o + 0] = r, this.float32[o + 1] = s, this.float32[o + 2] = h, e;
          }
        }
        $s.prototype.bytesPerElement = 12, ur($s, "StructArrayLayout3f12");
        class Ga extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, s, h, o);
          }
          emplace(e, r, s, h, o, f) {
            const b = 6 * e, O = 3 * e;
            return this.uint16[b + 0] = r, this.uint16[b + 1] = s, this.uint16[b + 2] = h, this.uint16[b + 3] = o, this.float32[O + 2] = f, e;
          }
        }
        Ga.prototype.bytesPerElement = 12, ur(Ga, "StructArrayLayout4ui1f12");
        class Th extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, e, r, s, h);
          }
          emplace(e, r, s, h, o) {
            const f = 4 * e;
            return this.uint16[f + 0] = r, this.uint16[f + 1] = s, this.uint16[f + 2] = h, this.uint16[f + 3] = o, e;
          }
        }
        Th.prototype.bytesPerElement = 8, ur(Th, "StructArrayLayout4ui8");
        class Xa extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f) {
            const b = this.length;
            return this.resize(b + 1), this.emplace(b, e, r, s, h, o, f);
          }
          emplace(e, r, s, h, o, f, b) {
            const O = 6 * e;
            return this.int16[O + 0] = r, this.int16[O + 1] = s, this.int16[O + 2] = h, this.int16[O + 3] = o, this.int16[O + 4] = f, this.int16[O + 5] = b, e;
          }
        }
        Xa.prototype.bytesPerElement = 12, ur(Xa, "StructArrayLayout6i12");
        class qc extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f, b, O, H, y, B, G) {
            const L = this.length;
            return this.resize(L + 1), this.emplace(L, e, r, s, h, o, f, b, O, H, y, B, G);
          }
          emplace(e, r, s, h, o, f, b, O, H, y, B, G, L) {
            const F = 12 * e;
            return this.int16[F + 0] = r, this.int16[F + 1] = s, this.int16[F + 2] = h, this.int16[F + 3] = o, this.uint16[F + 4] = f, this.uint16[F + 5] = b, this.uint16[F + 6] = O, this.uint16[F + 7] = H, this.int16[F + 8] = y, this.int16[F + 9] = B, this.int16[F + 10] = G, this.int16[F + 11] = L, e;
          }
        }
        qc.prototype.bytesPerElement = 24, ur(qc, "StructArrayLayout4i4ui4i24");
        class Wc extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f) {
            const b = this.length;
            return this.resize(b + 1), this.emplace(b, e, r, s, h, o, f);
          }
          emplace(e, r, s, h, o, f, b) {
            const O = 10 * e, H = 5 * e;
            return this.int16[O + 0] = r, this.int16[O + 1] = s, this.int16[O + 2] = h, this.float32[H + 2] = o, this.float32[H + 3] = f, this.float32[H + 4] = b, e;
          }
        }
        Wc.prototype.bytesPerElement = 20, ur(Wc, "StructArrayLayout3i3f20");
        class wl extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, e, r, s, h);
          }
          emplace(e, r, s, h, o) {
            const f = 4 * e;
            return this.float32[f + 0] = r, this.float32[f + 1] = s, this.float32[f + 2] = h, this.float32[f + 3] = o, e;
          }
        }
        wl.prototype.bytesPerElement = 16, ur(wl, "StructArrayLayout4f16");
        class Eo extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, e);
          }
          emplace(e, r) {
            return this.uint32[1 * e + 0] = r, e;
          }
        }
        Eo.prototype.bytesPerElement = 4, ur(Eo, "StructArrayLayout1ul4");
        class rs extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, e, r);
          }
          emplace(e, r, s) {
            const h = 2 * e;
            return this.uint16[h + 0] = r, this.uint16[h + 1] = s, e;
          }
        }
        rs.prototype.bytesPerElement = 4, ur(rs, "StructArrayLayout2ui4");
        class Pu extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f, b, O, H, y, B, G, L) {
            const F = this.length;
            return this.resize(F + 1), this.emplace(F, e, r, s, h, o, f, b, O, H, y, B, G, L);
          }
          emplace(e, r, s, h, o, f, b, O, H, y, B, G, L, F) {
            const Y = 20 * e, ce = 10 * e;
            return this.int16[Y + 0] = r, this.int16[Y + 1] = s, this.int16[Y + 2] = h, this.int16[Y + 3] = o, this.int16[Y + 4] = f, this.float32[ce + 3] = b, this.float32[ce + 4] = O, this.float32[ce + 5] = H, this.float32[ce + 6] = y, this.int16[Y + 14] = B, this.uint32[ce + 8] = G, this.uint16[Y + 18] = L, this.uint16[Y + 19] = F, e;
          }
        }
        Pu.prototype.bytesPerElement = 40, ur(Pu, "StructArrayLayout5i4f1i1ul2ui40");
        class cc extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f, b) {
            const O = this.length;
            return this.resize(O + 1), this.emplace(O, e, r, s, h, o, f, b);
          }
          emplace(e, r, s, h, o, f, b, O) {
            const H = 8 * e;
            return this.int16[H + 0] = r, this.int16[H + 1] = s, this.int16[H + 2] = h, this.int16[H + 4] = o, this.int16[H + 5] = f, this.int16[H + 6] = b, this.int16[H + 7] = O, e;
          }
        }
        cc.prototype.bytesPerElement = 16, ur(cc, "StructArrayLayout3i2i2i16");
        class Zc extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, s, h, o);
          }
          emplace(e, r, s, h, o, f) {
            const b = 4 * e, O = 8 * e;
            return this.float32[b + 0] = r, this.float32[b + 1] = s, this.float32[b + 2] = h, this.int16[O + 6] = o, this.int16[O + 7] = f, e;
          }
        }
        Zc.prototype.bytesPerElement = 16, ur(Zc, "StructArrayLayout2f1f2i16");
        class Ch extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f) {
            const b = this.length;
            return this.resize(b + 1), this.emplace(b, e, r, s, h, o, f);
          }
          emplace(e, r, s, h, o, f, b) {
            const O = 20 * e, H = 5 * e;
            return this.uint8[O + 0] = r, this.uint8[O + 1] = s, this.float32[H + 1] = h, this.float32[H + 2] = o, this.float32[H + 3] = f, this.float32[H + 4] = b, e;
          }
        }
        Ch.prototype.bytesPerElement = 20, ur(Ch, "StructArrayLayout2ub4f20");
        class Ya extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, e, r, s);
          }
          emplace(e, r, s, h) {
            const o = 3 * e;
            return this.uint16[o + 0] = r, this.uint16[o + 1] = s, this.uint16[o + 2] = h, e;
          }
        }
        Ya.prototype.bytesPerElement = 6, ur(Ya, "StructArrayLayout3ui6");
        class Ah extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f, b, O, H, y, B, G, L, F, Y, ce, _e, ze, Ne, Ee, We) {
            const lt = this.length;
            return this.resize(lt + 1), this.emplace(lt, e, r, s, h, o, f, b, O, H, y, B, G, L, F, Y, ce, _e, ze, Ne, Ee, We);
          }
          emplace(e, r, s, h, o, f, b, O, H, y, B, G, L, F, Y, ce, _e, ze, Ne, Ee, We, lt) {
            const yt = 30 * e, Bt = 15 * e, zt = 60 * e;
            return this.int16[yt + 0] = r, this.int16[yt + 1] = s, this.int16[yt + 2] = h, this.float32[Bt + 2] = o, this.float32[Bt + 3] = f, this.uint16[yt + 8] = b, this.uint16[yt + 9] = O, this.uint32[Bt + 5] = H, this.uint32[Bt + 6] = y, this.uint32[Bt + 7] = B, this.uint16[yt + 16] = G, this.uint16[yt + 17] = L, this.uint16[yt + 18] = F, this.float32[Bt + 10] = Y, this.float32[Bt + 11] = ce, this.uint8[zt + 48] = _e, this.uint8[zt + 49] = ze, this.uint8[zt + 50] = Ne, this.uint32[Bt + 13] = Ee, this.int16[yt + 28] = We, this.uint8[zt + 58] = lt, e;
          }
        }
        Ah.prototype.bytesPerElement = 60, ur(Ah, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class Mh extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f, b, O, H, y, B, G, L, F, Y, ce, _e, ze, Ne, Ee, We, lt, yt, Bt, zt, Dt, ni, Gt, si, ci, li, fi) {
            const gi = this.length;
            return this.resize(gi + 1), this.emplace(gi, e, r, s, h, o, f, b, O, H, y, B, G, L, F, Y, ce, _e, ze, Ne, Ee, We, lt, yt, Bt, zt, Dt, ni, Gt, si, ci, li, fi);
          }
          emplace(e, r, s, h, o, f, b, O, H, y, B, G, L, F, Y, ce, _e, ze, Ne, Ee, We, lt, yt, Bt, zt, Dt, ni, Gt, si, ci, li, fi, gi) {
            const Si = 20 * e, pi = 40 * e, zi = 80 * e;
            return this.float32[Si + 0] = r, this.float32[Si + 1] = s, this.int16[pi + 4] = h, this.int16[pi + 5] = o, this.int16[pi + 6] = f, this.int16[pi + 7] = b, this.int16[pi + 8] = O, this.int16[pi + 9] = H, this.int16[pi + 10] = y, this.int16[pi + 11] = B, this.int16[pi + 12] = G, this.uint16[pi + 13] = L, this.uint16[pi + 14] = F, this.uint16[pi + 15] = Y, this.uint16[pi + 16] = ce, this.uint16[pi + 17] = _e, this.uint16[pi + 18] = ze, this.uint16[pi + 19] = Ne, this.uint16[pi + 20] = Ee, this.uint16[pi + 21] = We, this.uint16[pi + 22] = lt, this.uint16[pi + 23] = yt, this.uint16[pi + 24] = Bt, this.uint16[pi + 25] = zt, this.uint16[pi + 26] = Dt, this.uint16[pi + 27] = ni, this.uint32[Si + 14] = Gt, this.float32[Si + 15] = si, this.float32[Si + 16] = ci, this.float32[Si + 17] = li, this.float32[Si + 18] = fi, this.uint8[zi + 76] = gi, e;
          }
        }
        Mh.prototype.bytesPerElement = 80, ur(Mh, "StructArrayLayout2f9i15ui1ul4f1ub80");
        class hc extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, e);
          }
          emplace(e, r) {
            return this.float32[1 * e + 0] = r, e;
          }
        }
        hc.prototype.bytesPerElement = 4, ur(hc, "StructArrayLayout1f4");
        class Sl extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o) {
            const f = this.length;
            return this.resize(f + 1), this.emplace(f, e, r, s, h, o);
          }
          emplace(e, r, s, h, o, f) {
            const b = 5 * e;
            return this.float32[b + 0] = r, this.float32[b + 1] = s, this.float32[b + 2] = h, this.float32[b + 3] = o, this.float32[b + 4] = f, e;
          }
        }
        Sl.prototype.bytesPerElement = 20, ur(Sl, "StructArrayLayout5f20");
        class $c extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f, b) {
            const O = this.length;
            return this.resize(O + 1), this.emplace(O, e, r, s, h, o, f, b);
          }
          emplace(e, r, s, h, o, f, b, O) {
            const H = 7 * e;
            return this.float32[H + 0] = r, this.float32[H + 1] = s, this.float32[H + 2] = h, this.float32[H + 3] = o, this.float32[H + 4] = f, this.float32[H + 5] = b, this.float32[H + 6] = O, e;
          }
        }
        $c.prototype.bytesPerElement = 28, ur($c, "StructArrayLayout7f28");
        class ko extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f, b, O, H, y, B) {
            const G = this.length;
            return this.resize(G + 1), this.emplace(G, e, r, s, h, o, f, b, O, H, y, B);
          }
          emplace(e, r, s, h, o, f, b, O, H, y, B, G) {
            const L = 11 * e;
            return this.float32[L + 0] = r, this.float32[L + 1] = s, this.float32[L + 2] = h, this.float32[L + 3] = o, this.float32[L + 4] = f, this.float32[L + 5] = b, this.float32[L + 6] = O, this.float32[L + 7] = H, this.float32[L + 8] = y, this.float32[L + 9] = B, this.float32[L + 10] = G, e;
          }
        }
        ko.prototype.bytesPerElement = 44, ur(ko, "StructArrayLayout11f44");
        class Xl extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f, b, O, H) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, e, r, s, h, o, f, b, O, H);
          }
          emplace(e, r, s, h, o, f, b, O, H, y) {
            const B = 9 * e;
            return this.float32[B + 0] = r, this.float32[B + 1] = s, this.float32[B + 2] = h, this.float32[B + 3] = o, this.float32[B + 4] = f, this.float32[B + 5] = b, this.float32[B + 6] = O, this.float32[B + 7] = H, this.float32[B + 8] = y, e;
          }
        }
        Xl.prototype.bytesPerElement = 36, ur(Xl, "StructArrayLayout9f36");
        class Ru extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r) {
            const s = this.length;
            return this.resize(s + 1), this.emplace(s, e, r);
          }
          emplace(e, r, s) {
            const h = 2 * e;
            return this.float32[h + 0] = r, this.float32[h + 1] = s, e;
          }
        }
        Ru.prototype.bytesPerElement = 8, ur(Ru, "StructArrayLayout2f8");
        class fc extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h) {
            const o = this.length;
            return this.resize(o + 1), this.emplace(o, e, r, s, h);
          }
          emplace(e, r, s, h, o) {
            const f = 6 * e;
            return this.uint32[3 * e + 0] = r, this.uint16[f + 2] = s, this.uint16[f + 3] = h, this.uint16[f + 4] = o, e;
          }
        }
        fc.prototype.bytesPerElement = 12, ur(fc, "StructArrayLayout1ul3ui12");
        class dc extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, e);
          }
          emplace(e, r) {
            return this.uint16[1 * e + 0] = r, e;
          }
        }
        dc.prototype.bytesPerElement = 2, ur(dc, "StructArrayLayout1ui2");
        class pc extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f, b, O, H, y, B, G, L, F, Y, ce) {
            const _e = this.length;
            return this.resize(_e + 1), this.emplace(_e, e, r, s, h, o, f, b, O, H, y, B, G, L, F, Y, ce);
          }
          emplace(e, r, s, h, o, f, b, O, H, y, B, G, L, F, Y, ce, _e) {
            const ze = 16 * e;
            return this.float32[ze + 0] = r, this.float32[ze + 1] = s, this.float32[ze + 2] = h, this.float32[ze + 3] = o, this.float32[ze + 4] = f, this.float32[ze + 5] = b, this.float32[ze + 6] = O, this.float32[ze + 7] = H, this.float32[ze + 8] = y, this.float32[ze + 9] = B, this.float32[ze + 10] = G, this.float32[ze + 11] = L, this.float32[ze + 12] = F, this.float32[ze + 13] = Y, this.float32[ze + 14] = ce, this.float32[ze + 15] = _e, e;
          }
        }
        pc.prototype.bytesPerElement = 64, ur(pc, "StructArrayLayout16f64");
        class ku extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(e, r, s, h, o, f, b) {
            const O = this.length;
            return this.resize(O + 1), this.emplace(O, e, r, s, h, o, f, b);
          }
          emplace(e, r, s, h, o, f, b, O) {
            const H = 10 * e, y = 5 * e;
            return this.uint16[H + 0] = r, this.uint16[H + 1] = s, this.uint16[H + 2] = h, this.uint16[H + 3] = o, this.float32[y + 2] = f, this.float32[y + 3] = b, this.float32[y + 4] = O, e;
          }
        }
        ku.prototype.bytesPerElement = 20, ur(ku, "StructArrayLayout4ui3f20");
        class Ih extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, e);
          }
          emplace(e, r) {
            return this.int16[1 * e + 0] = r, e;
          }
        }
        Ih.prototype.bytesPerElement = 2, ur(Ih, "StructArrayLayout1i2");
        class Xc extends Ln {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer);
          }
          emplaceBack(e) {
            const r = this.length;
            return this.resize(r + 1), this.emplace(r, e);
          }
          emplace(e, r) {
            return this.uint8[1 * e + 0] = r, e;
          }
        }
        Xc.prototype.bytesPerElement = 1, ur(Xc, "StructArrayLayout1ub1");
        class uf extends Iu {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get tileAnchorY() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get x1() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get y1() {
            return this._structArray.float32[this._pos4 + 4];
          }
          get x2() {
            return this._structArray.float32[this._pos4 + 5];
          }
          get y2() {
            return this._structArray.float32[this._pos4 + 6];
          }
          get padding() {
            return this._structArray.int16[this._pos2 + 14];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 8];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
        }
        uf.prototype.size = 40;
        class Ph extends Pu {
          get(e) {
            return new uf(this, e);
          }
        }
        ur(Ph, "CollisionBoxArray");
        class Lu extends Iu {
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 2];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 3];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 5];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 6];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 7];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 10];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 11];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 48];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 49];
          }
          set placedOrientation(e) {
            this._structArray.uint8[this._pos1 + 49] = e;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 50];
          }
          set hidden(e) {
            this._structArray.uint8[this._pos1 + 50] = e;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 13];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 13] = e;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 28];
          }
          get flipState() {
            return this._structArray.uint8[this._pos1 + 58];
          }
          set flipState(e) {
            this._structArray.uint8[this._pos1 + 58] = e;
          }
        }
        Lu.prototype.size = 60;
        class cf extends Ah {
          get(e) {
            return new Lu(this, e);
          }
        }
        ur(cf, "PlacedSymbolArray");
        class hf extends Iu {
          get tileAnchorX() {
            return this._structArray.float32[this._pos4 + 0];
          }
          get tileAnchorY() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get projectedAnchorX() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get projectedAnchorY() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get projectedAnchorZ() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 8];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 9];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 10];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 11];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 12];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 23];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 24];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 25];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 26];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 27];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 14];
          }
          set crossTileID(e) {
            this._structArray.uint32[this._pos4 + 14] = e;
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 15];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 16];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 17];
          }
          get zOffset() {
            return this._structArray.float32[this._pos4 + 18];
          }
          set zOffset(e) {
            this._structArray.float32[this._pos4 + 18] = e;
          }
          get hasIconTextFit() {
            return this._structArray.uint8[this._pos1 + 76];
          }
        }
        hf.prototype.size = 80;
        class ff extends Mh {
          get(e) {
            return new hf(this, e);
          }
        }
        ur(ff, "SymbolInstanceArray");
        class Ff extends hc {
          getoffsetX(e) {
            return this.float32[1 * e + 0];
          }
        }
        ur(Ff, "GlyphOffsetArray");
        class df extends Ds {
          getx(e) {
            return this.int16[2 * e + 0];
          }
          gety(e) {
            return this.int16[2 * e + 1];
          }
        }
        ur(df, "SymbolLineVertexArray");
        class Yc extends Iu {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get layoutVertexArrayOffset() {
            return this._structArray.uint16[this._pos2 + 4];
          }
        }
        Yc.prototype.size = 12;
        class Kc extends fc {
          get(e) {
            return new Yc(this, e);
          }
        }
        ur(Kc, "FeatureIndexArray");
        class zs extends rs {
          geta_centroid_pos0(e) {
            return this.uint16[2 * e + 0];
          }
          geta_centroid_pos1(e) {
            return this.uint16[2 * e + 1];
          }
        }
        ur(zs, "FillExtrusionCentroidArray");
        class mc extends Iu {
          get a_join_normal_inside0() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get a_join_normal_inside1() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get a_join_normal_inside2() {
            return this._structArray.int16[this._pos2 + 2];
          }
        }
        mc.prototype.size = 6;
        class pf extends oa {
          get(e) {
            return new mc(this, e);
          }
        }
        ur(pf, "FillExtrusionWallArray");
        const Rh = dn([{ name: "a_pos", components: 2, type: "Int16" }], 4), vd = dn([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
        class Ea {
          constructor(e = []) {
            this.segments = e;
          }
          _prepareSegment(e, r, s, h) {
            let o = this.segments[this.segments.length - 1];
            return e > Ea.MAX_VERTEX_ARRAY_LENGTH && Se(`Max vertices per segment is ${Ea.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!o || o.vertexLength + e > Ea.MAX_VERTEX_ARRAY_LENGTH || o.sortKey !== h) && (o = { vertexOffset: r, primitiveOffset: s, vertexLength: 0, primitiveLength: 0 }, h !== void 0 && (o.sortKey = h), this.segments.push(o)), o;
          }
          prepareSegment(e, r, s, h) {
            return this._prepareSegment(e, r.length, s.length, h);
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const e of this.segments) for (const r in e.vaos) e.vaos[r].destroy();
          }
          static simpleSegment(e, r, s, h) {
            return new Ea([{ vertexOffset: e, primitiveOffset: r, vertexLength: s, primitiveLength: h, vaos: {}, sortKey: 0 }]);
          }
        }
        function kh(a, e) {
          return 256 * (a = pe(Math.floor(a), 0, 255)) + pe(Math.floor(e), 0, 255);
        }
        Ea.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, ur(Ea, "SegmentVector");
        const Lo = dn([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), Jc = dn([{ name: "a_dash", components: 4, type: "Uint16" }]);
        class Yl {
          constructor() {
            this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;
          }
          add(e, r, s, h) {
            this.ids.push(mf(e)), this.positions.push(r, s, h);
          }
          eachPosition(e, r) {
            const s = mf(e);
            let h = 0, o = this.ids.length - 1;
            for (; h < o; ) {
              const f = h + o >> 1;
              this.ids[f] >= s ? o = f : h = f + 1;
            }
            for (; this.ids[h] === s; ) r(this.positions[3 * h], this.positions[3 * h + 1], this.positions[3 * h + 2]), h++;
          }
          static serialize(e, r) {
            const s = new Float64Array(e.ids), h = new Uint32Array(e.positions);
            return _c(s, h, 0, s.length - 1), r && (r.add(s.buffer), r.add(h.buffer)), { ids: s, positions: h };
          }
          static deserialize(e) {
            const r = new Yl();
            let s;
            r.ids = e.ids, r.positions = e.positions;
            for (const h of r.ids) h !== s && r.uniqueIds.push(h), s = h;
            return r.indexed = !0, r;
          }
        }
        function mf(a) {
          const e = +a;
          return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : La(String(a));
        }
        function _c(a, e, r, s) {
          for (; r < s; ) {
            const h = a[r + s >> 1];
            let o = r - 1, f = s + 1;
            for (; ; ) {
              do
                o++;
              while (a[o] < h);
              do
                f--;
              while (a[f] > h);
              if (o >= f) break;
              Qc(a, o, f), Qc(e, 3 * o, 3 * f), Qc(e, 3 * o + 1, 3 * f + 1), Qc(e, 3 * o + 2, 3 * f + 2);
            }
            f - r < s - f ? (_c(a, e, r, f), r = f + 1) : (_c(a, e, f + 1, s), s = f);
          }
        }
        function Qc(a, e, r) {
          const s = a[e];
          a[e] = a[r], a[r] = s;
        }
        ur(Yl, "FeaturePositionMap");
        class To {
          constructor(e) {
            this.gl = e.gl, this.initialized = !1;
          }
          fetchUniformLocation(e, r) {
            return this.location || this.initialized || (this.location = this.gl.getUniformLocation(e, r), this.initialized = !0), !!this.location;
          }
          set(e, r, s) {
            throw new Error("Uniform#set() must be implemented by each concrete Uniform");
          }
        }
        class el extends To {
          constructor(e) {
            super(e), this.current = 0;
          }
          set(e, r, s) {
            this.fetchUniformLocation(e, r) && this.current !== s && (this.current = s, this.gl.uniform1i(this.location, s));
          }
        }
        class ma extends To {
          constructor(e) {
            super(e), this.current = 0;
          }
          set(e, r, s) {
            this.fetchUniformLocation(e, r) && this.current !== s && (this.current = s, this.gl.uniform1f(this.location, s));
          }
        }
        class Xs extends To {
          constructor(e) {
            super(e), this.current = [0, 0];
          }
          set(e, r, s) {
            this.fetchUniformLocation(e, r) && (s[0] === this.current[0] && s[1] === this.current[1] || (this.current = s, this.gl.uniform2f(this.location, s[0], s[1])));
          }
        }
        class gc extends To {
          constructor(e) {
            super(e), this.current = [0, 0, 0];
          }
          set(e, r, s) {
            this.fetchUniformLocation(e, r) && (s[0] === this.current[0] && s[1] === this.current[1] && s[2] === this.current[2] || (this.current = s, this.gl.uniform3f(this.location, s[0], s[1], s[2])));
          }
        }
        class vc extends To {
          constructor(e) {
            super(e), this.current = [0, 0, 0, 0];
          }
          set(e, r, s) {
            this.fetchUniformLocation(e, r) && (s[0] === this.current[0] && s[1] === this.current[1] && s[2] === this.current[2] && s[3] === this.current[3] || (this.current = s, this.gl.uniform4f(this.location, s[0], s[1], s[2], s[3])));
          }
        }
        class _f extends To {
          constructor(e) {
            super(e), this.current = Wr.transparent.toRenderColor(null);
          }
          set(e, r, s) {
            this.fetchUniformLocation(e, r) && (s.r === this.current.r && s.g === this.current.g && s.b === this.current.b && s.a === this.current.a || (this.current = s, this.gl.uniform4f(this.location, s.r, s.g, s.b, s.a)));
          }
        }
        const gf = new Float32Array(16);
        class yc extends To {
          constructor(e) {
            super(e), this.current = gf;
          }
          set(e, r, s) {
            if (this.fetchUniformLocation(e, r)) {
              if (s[12] !== this.current[12] || s[0] !== this.current[0]) return this.current = s, void this.gl.uniformMatrix4fv(this.location, !1, s);
              for (let h = 1; h < 16; h++) if (s[h] !== this.current[h]) {
                this.current = s, this.gl.uniformMatrix4fv(this.location, !1, s);
                break;
              }
            }
          }
        }
        const Lh = new Float32Array(9), yd = new Float32Array(4);
        class Es extends To {
          constructor(e) {
            super(e), this.current = yd;
          }
          set(e, r, s) {
            if (this.fetchUniformLocation(e, r)) {
              for (let h = 0; h < 4; h++) if (s[h] !== this.current[h]) {
                this.current = s, this.gl.uniformMatrix2fv(this.location, !1, s);
                break;
              }
            }
          }
        }
        function gs(a) {
          return [kh(255 * a.r, 255 * a.g), kh(255 * a.b, 255 * a.a)];
        }
        class Kl {
          constructor(e, r, s, h) {
            this.value = e, this.uniformNames = r.map((o) => `u_${o}`), this.type = s, this.context = h;
          }
          setUniform(e, r, s, h, o) {
            const f = h.constantOr(this.value);
            r.set(e, o, f instanceof Wr ? f.toRenderColor(this.ignoreLut ? null : this.context.lut) : f);
          }
          getBinding(e, r) {
            return this.type === "color" ? new _f(e) : new ma(e);
          }
        }
        class Jl {
          constructor(e, r) {
            this.uniformNames = r.map((s) => `u_${s}`), this.pattern = null, this.pixelRatio = 1;
          }
          setConstantPatternPositions(e) {
            this.pixelRatio = e.pixelRatio || 1, this.pattern = e.tl.concat(e.br);
          }
          setUniform(e, r, s, h, o) {
            const f = o === "u_pattern" || o === "u_dash" ? this.pattern : o === "u_pixel_ratio" ? this.pixelRatio : null;
            f && r.set(e, o, f);
          }
          getBinding(e, r) {
            return r === "u_pattern" || r === "u_dash" ? new vc(e) : new ma(e);
          }
        }
        class tl {
          constructor(e, r, s, h) {
            this.expression = e, this.type = s, this.maxValue = 0, this.paintVertexAttributes = r.map((o) => ({ name: `a_${o}`, type: "Float32", components: s === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new h();
          }
          populatePaintArray(e, r, s, h, o, f, b) {
            const O = this.paintVertexArray.length, H = this.expression.kind === "composite" || this.expression.kind === "source" ? this.expression.evaluate(new Tn(0, { brightness: f }), r, {}, o, h, b) : this.expression.kind === "constant" && this.expression.value;
            !this.lutExpression || this.lutExpression.kind !== "composite" && this.lutExpression.kind !== "source" || (this.ignoreLut = this.lutExpression.evaluate(new Tn(0, { brightness: f }), r, {}, o, h, b) === "none"), this.paintVertexArray.resize(e), this._setPaintValue(O, e, H, this.context);
          }
          updatePaintArray(e, r, s, h, o, f, b) {
            const O = this.expression.kind === "composite" || this.expression.kind === "source" ? this.expression.evaluate({ zoom: 0, brightness: b }, s, h, void 0, o) : this.expression.kind === "constant" && this.expression.value;
            !this.lutExpression || this.lutExpression.kind !== "composite" && this.lutExpression.kind !== "source" || (this.ignoreLut = this.lutExpression.evaluate({ zoom: 0, brightness: b }, s, h, void 0, o) === "none"), this._setPaintValue(e, r, O, this.context);
          }
          _setPaintValue(e, r, s, h) {
            if (this.type === "color") {
              const o = gs(s.toRenderColor(this.ignoreLut ? null : h.lut));
              for (let f = e; f < r; f++) this.paintVertexArray.emplace(f, o[0], o[1]);
            } else {
              for (let o = e; o < r; o++) this.paintVertexArray.emplace(o, s);
              this.maxValue = Math.max(this.maxValue, Math.abs(s));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && this.lutExpression.kind !== "constant" && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || this.expression.kind !== "constant" && (this.expression.isStateDependent || !this.expression.isLightConstant)));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Co {
          constructor(e, r, s, h, o, f) {
            this.expression = e, this.uniformNames = r.map((b) => `u_${b}_t`), this.type = s, this.useIntegerZoom = h, this.context = o, this.maxValue = 0, this.paintVertexAttributes = r.map((b) => ({ name: `a_${b}`, type: "Float32", components: s === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new f();
          }
          populatePaintArray(e, r, s, h, o, f, b) {
            const O = this.expression.evaluate(new Tn(this.context.zoom, { brightness: f }), r, {}, o, h, b), H = this.expression.evaluate(new Tn(this.context.zoom + 1, { brightness: f }), r, {}, o, h, b);
            !this.lutExpression || this.lutExpression.kind !== "composite" && this.lutExpression.kind !== "source" || (this.ignoreLut = this.lutExpression.evaluate(new Tn(this.context.zoom, { brightness: f }), r, {}, o, h, b) === "none");
            const y = this.paintVertexArray.length;
            this.paintVertexArray.resize(e), this._setPaintValue(y, e, O, H, this.context);
          }
          updatePaintArray(e, r, s, h, o, f, b) {
            const O = this.expression.evaluate({ zoom: this.context.zoom, brightness: b }, s, h, void 0, o), H = this.expression.evaluate({ zoom: this.context.zoom + 1, brightness: b }, s, h, void 0, o);
            !this.lutExpression || this.lutExpression.kind !== "composite" && this.lutExpression.kind !== "source" || (this.ignoreLut = this.lutExpression.evaluate({ zoom: this.context.zoom, brightness: b }, s, h, void 0, o) === "none"), this._setPaintValue(e, r, O, H, this.context);
          }
          _setPaintValue(e, r, s, h, o) {
            if (this.type === "color") {
              const f = gs(s.toRenderColor(this.ignoreLut ? null : o.lut)), b = gs(s.toRenderColor(this.ignoreLut ? null : o.lut));
              for (let O = e; O < r; O++) this.paintVertexArray.emplace(O, f[0], f[1], b[0], b[1]);
            } else {
              for (let f = e; f < r; f++) this.paintVertexArray.emplace(f, s, h);
              this.maxValue = Math.max(this.maxValue, Math.abs(s), Math.abs(h));
            }
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(e, r, s, h, o) {
            const f = this.useIntegerZoom ? Math.floor(s.zoom) : s.zoom, b = pe(this.expression.interpolationFactor(f, this.context.zoom, this.context.zoom + 1), 0, 1);
            r.set(e, o, b);
          }
          getBinding(e, r) {
            return new ma(e);
          }
        }
        class El {
          constructor(e, r, s, h, o) {
            this.expression = e, this.layerId = o, this.paintVertexAttributes = (s === "array" ? Jc : Lo).members;
            for (let f = 0; f < r.length; ++f) ;
            this.paintVertexArray = new h();
          }
          populatePaintArray(e, r, s, h) {
            const o = this.paintVertexArray.length;
            this.paintVertexArray.resize(e), this._setPaintValues(o, e, r.patterns && r.patterns[this.layerId], s);
          }
          updatePaintArray(e, r, s, h, o, f, b) {
            this._setPaintValues(e, r, s.patterns && s.patterns[this.layerId], f);
          }
          _setPaintValues(e, r, s, h) {
            if (!h || !s) return;
            const o = h[s];
            if (!o) return;
            const { tl: f, br: b, pixelRatio: O } = o;
            for (let H = e; H < r; H++) this.paintVertexArray.emplace(H, f[0], f[1], b[0], b[1], O);
          }
          upload(e) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Tl {
          constructor(e, r, s = () => !0) {
            this.binders = {}, this._buffers = [], this.context = r;
            const h = [];
            for (const o in e.paint._values) {
              const f = e.paint.get(o), b = e.paint.get(`${o}-use-theme`);
              if (o.endsWith("-use-theme") || !s(o) || !(f instanceof ql && xo(f.property.specification))) continue;
              const O = Nf(o, e.type), H = f.value, y = f.property.specification.type, B = !!f.property.useIntegerZoom, G = o === "line-dasharray" || o.endsWith("pattern"), L = o === "line-dasharray" && e.layout.get("line-cap").value.kind !== "constant" || b && b.value.kind !== "constant";
              if (H.kind !== "constant" || L) if (H.kind === "source" || L || G) {
                const F = Oh(o, y, "source");
                this.binders[o] = G ? new El(H, O, y, F, e.id) : new tl(H, O, y, F), h.push(`/a_${o}`);
              } else {
                const F = Oh(o, y, "composite");
                this.binders[o] = new Co(H, O, y, B, r, F), h.push(`/z_${o}`);
              }
              else this.binders[o] = G ? new Jl(H.value, O) : new Kl(H.value, O, y, r), h.push(`/u_${o}`);
              b && (this.binders[o].ignoreLut = b.constantOr("default") === "none", this.binders[o].lutExpression = b.value, this.binders[o].checkUseTheme = !0);
            }
            this.cacheKey = h.sort().join("");
          }
          getMaxValue(e) {
            const r = this.binders[e];
            return r instanceof tl || r instanceof Co ? r.maxValue : 0;
          }
          populatePaintArrays(e, r, s, h, o, f, b) {
            for (const O in this.binders) {
              const H = this.binders[O];
              H.context = this.context, H instanceof tl || H instanceof Co || H instanceof El ? H.populatePaintArray(e, r, s, h, o, f, b) : H.lutExpression && H instanceof Kl && H.lutExpression && (H.lutExpression.kind === "composite" || H.lutExpression.kind === "source") && (H.ignoreLut = H.lutExpression.evaluate(new Tn(0, { brightness: f }), r, {}, o, h, b) === "none");
            }
          }
          setConstantPatternPositions(e) {
            for (const r in this.binders) {
              const s = this.binders[r];
              s instanceof Jl && s.setConstantPatternPositions(e);
            }
          }
          updatePaintArrays(e, r, s, h, o, f, b, O, H) {
            let y = !1;
            const B = Object.keys(e), G = B.length !== 0 && !O, L = G ? B : r.uniqueIds;
            this.context.lut = o.lut;
            for (const F in this.binders) {
              const Y = this.binders[F];
              if (Y.context = this.context, (Y instanceof tl || Y instanceof Co || Y instanceof El) && Y.expression && Y.expression.kind && Y.expression.kind !== "constant" && (Y.expression.isStateDependent === !0 || Y.expression.isLightConstant === !1)) {
                const ce = o.paint.get(F);
                Y.expression = ce.value;
                for (const _e of L) {
                  const ze = e[_e.toString()];
                  r.eachPosition(_e, (Ne, Ee, We) => {
                    const lt = h.feature(Ne);
                    Y.updatePaintArray(Ee, We, lt, ze, f, b, H);
                  });
                }
                if (!G) for (const _e of s.uniqueIds) {
                  const ze = e[_e.toString()];
                  s.eachPosition(_e, (Ne, Ee, We) => {
                    const lt = h.feature(Ne);
                    Y.updatePaintArray(Ee, We, lt, ze, f, b, H);
                  });
                }
                y = !0;
              }
            }
            return y;
          }
          defines() {
            const e = [];
            for (const r in this.binders) {
              const s = this.binders[r];
              (s instanceof Kl || s instanceof Jl) && e.push(...s.uniformNames.map((h) => `#define HAS_UNIFORM_${h}`));
            }
            return e;
          }
          getBinderAttributes() {
            const e = [];
            for (const r in this.binders) {
              const s = this.binders[r];
              if (s instanceof tl || s instanceof Co || s instanceof El) for (let h = 0; h < s.paintVertexAttributes.length; h++) e.push(s.paintVertexAttributes[h].name);
            }
            return e;
          }
          getBinderUniforms() {
            const e = [];
            for (const r in this.binders) {
              const s = this.binders[r];
              if (s instanceof Kl || s instanceof Jl || s instanceof Co) for (const h of s.uniformNames) e.push(h);
            }
            return e;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(e) {
            const r = [];
            for (const s in this.binders) {
              const h = this.binders[s];
              if (h instanceof Kl || h instanceof Jl || h instanceof Co) for (const o of h.uniformNames) r.push({ name: o, property: s, binding: h.getBinding(e, o) });
            }
            return r;
          }
          setUniforms(e, r, s, h, o) {
            for (const { name: f, property: b, binding: O } of s) {
              if (this.binders[b].checkUseTheme && this.binders[b] instanceof Kl) {
                const H = h.get(`${b}-use-theme`);
                H.isConstant() && (this.binders[b].ignoreLut = H.constantOr("default") === "none");
              }
              this.binders[b].setUniform(e, O, o, h.get(b), f);
            }
          }
          updatePaintBuffers() {
            this._buffers = [];
            for (const e in this.binders) {
              const r = this.binders[e];
              (r instanceof tl || r instanceof Co || r instanceof El) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer);
            }
          }
          upload(e) {
            for (const r in this.binders) {
              const s = this.binders[r];
              (s instanceof tl || s instanceof Co || s instanceof El) && s.upload(e);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const e in this.binders) {
              const r = this.binders[e];
              (r instanceof tl || r instanceof Co || r instanceof El) && r.destroy();
            }
          }
        }
        class Cl {
          constructor(e, r, s = () => !0) {
            this.programConfigurations = {};
            for (const h of e) this.programConfigurations[h.id] = new Tl(h, r, s);
            this.needsUpload = !1, this._featureMap = new Yl(), this._featureMapWithoutIds = new Yl(), this._bufferOffset = 0, this._idlessCounter = 0;
          }
          populatePaintArrays(e, r, s, h, o, f, b, O) {
            for (const H in this.programConfigurations) this.programConfigurations[H].populatePaintArrays(e, r, h, o, f, b, O);
            r.id !== void 0 ? this._featureMap.add(r.id, s, this._bufferOffset, e) : (this._featureMapWithoutIds.add(this._idlessCounter, s, this._bufferOffset, e), this._idlessCounter += 1), this._bufferOffset = e, this.needsUpload = !0;
          }
          updatePaintArrays(e, r, s, h, o, f, b) {
            for (const O of s) this.needsUpload = this.programConfigurations[O.id].updatePaintArrays(e, this._featureMap, this._featureMapWithoutIds, r, O, h, o, f, b || 0) || this.needsUpload;
          }
          get(e) {
            return this.programConfigurations[e];
          }
          upload(e) {
            if (this.needsUpload) {
              for (const r in this.programConfigurations) this.programConfigurations[r].upload(e);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const e in this.programConfigurations) this.programConfigurations[e].destroy();
          }
        }
        const vf = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-occlusion-opacity": ["occlusion_opacity"], "icon-occlusion-opacity": ["occlusion_opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "symbol-z-offset": ["z_offset"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
        function Nf(a, e) {
          return vf[a] || [a.replace(`${e}-`, "").replace(/-/g, "_")];
        }
        const Uf = { "line-pattern": { source: Ga, composite: Ga }, "fill-pattern": { source: Ga, composite: Ga }, "fill-extrusion-pattern": { source: Ga, composite: Ga }, "line-dasharray": { source: Th, composite: Th } }, xc = { color: { source: Ru, composite: wl }, number: { source: hc, composite: Ru } };
        function Oh(a, e, r) {
          const s = Uf[a];
          return s && s[r] || xc[e][r];
        }
        ur(Kl, "ConstantBinder"), ur(Jl, "PatternConstantBinder"), ur(tl, "SourceExpressionBinder"), ur(El, "PatternCompositeBinder"), ur(Co, "CompositeExpressionBinder"), ur(Tl, "ProgramConfiguration", { omit: ["_buffers"] }), ur(Cl, "ProgramConfigurationSet");
        const vs = tr / Math.PI / 2, Ql = 5, eh = 6, Vf = 16383, Ou = 64, bc = [Ou, 32, 16], Ys = -vs, Ts = vs;
        function Ks(a, e, r, s = vs) {
          return r = Ye(r), [a * Math.sin(r) * s, -e * s, a * Math.cos(r) * s];
        }
        function Du(a, e, r) {
          return Ks(Math.cos(Ye(a)), Math.sin(Ye(a)), e, r);
        }
        const eu = 63710088e-1, th = 2 * Math.PI * eu;
        class hn {
          constructor(e, r) {
            if (isNaN(e) || isNaN(r)) throw new Error(`Invalid LngLat object: (${e}, ${r})`);
            if (this.lng = +e, this.lat = +r, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new hn(l(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(e) {
            const r = Math.PI / 180, s = this.lat * r, h = e.lat * r, o = Math.sin(s) * Math.sin(h) + Math.cos(s) * Math.cos(h) * Math.cos((e.lng - this.lng) * r);
            return eu * Math.acos(Math.min(o, 1));
          }
          toBounds(e = 0) {
            const r = 360 * e / 40075017, s = r / Math.cos(Math.PI / 180 * this.lat);
            return new Al({ lng: this.lng - s, lat: this.lat - r }, { lng: this.lng + s, lat: this.lat + r });
          }
          toEcef(e) {
            return Du(this.lat, this.lng, vs + e * vs / eu);
          }
          static convert(e) {
            if (e instanceof hn) return e;
            if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new hn(Number(e[0]), Number(e[1]));
            if (!Array.isArray(e) && typeof e == "object" && e !== null) return new hn(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        class Al {
          constructor(e, r) {
            if (e) if (r) this.setSouthWest(e).setNorthEast(r);
            else if (e.length === 4) {
              const s = e;
              this.setSouthWest([s[0], s[1]]).setNorthEast([s[2], s[3]]);
            } else {
              const s = e;
              this.setSouthWest(s[0]).setNorthEast(s[1]);
            }
          }
          setNorthEast(e) {
            return this._ne = e instanceof hn ? new hn(e.lng, e.lat) : hn.convert(e), this;
          }
          setSouthWest(e) {
            return this._sw = e instanceof hn ? new hn(e.lng, e.lat) : hn.convert(e), this;
          }
          extend(e) {
            const r = this._sw, s = this._ne;
            let h, o;
            if (e instanceof hn) h = e, o = e;
            else {
              if (!(e instanceof Al)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(Al.convert(e)) : this.extend(hn.convert(e)) : typeof e == "object" && e !== null && e.hasOwnProperty("lat") && (e.hasOwnProperty("lon") || e.hasOwnProperty("lng")) ? this.extend(hn.convert(e)) : this;
              if (h = e._sw, o = e._ne, !h || !o) return this;
            }
            return r || s ? (r.lng = Math.min(h.lng, r.lng), r.lat = Math.min(h.lat, r.lat), s.lng = Math.max(o.lng, s.lng), s.lat = Math.max(o.lat, s.lat)) : (this._sw = new hn(h.lng, h.lat), this._ne = new hn(o.lng, o.lat)), this;
          }
          getCenter() {
            return new hn((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new hn(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new hn(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e) {
            const { lng: r, lat: s } = hn.convert(e);
            let h = this._sw.lng <= r && r <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (h = this._sw.lng >= r && r >= this._ne.lng), this._sw.lat <= s && s <= this._ne.lat && h;
          }
          static convert(e) {
            if (e) return e instanceof Al ? e : new Al(e);
          }
        }
        const ih = 0, Cs = 25.5;
        function Dh(a) {
          return th * Math.cos(a * Math.PI / 180);
        }
        function il(a) {
          return (180 + a) / 360;
        }
        function Js(a) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a * Math.PI / 360))) / 360;
        }
        function Zn(a, e) {
          return a / Dh(e);
        }
        function Qs(a) {
          return 360 * a - 180;
        }
        function Pr(a) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * a) * Math.PI / 180)) - 90;
        }
        function zu(a, e) {
          return a * Dh(Pr(e));
        }
        const la = 85.051129;
        function zh(a) {
          return Math.cos(Ye(pe(a, -la, la)));
        }
        function wc(a, e) {
          const r = pe(e, ih, Cs), s = Math.pow(2, r);
          return zh(a) * th / (512 * s);
        }
        function u(a) {
          return 1 / Math.cos(a * Math.PI / 180);
        }
        function t(a, e = 0) {
          const r = Math.exp(Math.PI * (1 - (a.y + e / tr) / (1 << a.z) * 2));
          return 80150034 * r / (r * r + 1) / tr / (1 << a.z);
        }
        class n {
          constructor(e, r, s = 0) {
            this.x = +e, this.y = +r, this.z = +s;
          }
          static fromLngLat(e, r = 0) {
            const s = hn.convert(e);
            return new n(il(s.lng), Js(s.lat), Zn(r, s.lat));
          }
          toLngLat() {
            return new hn(Qs(this.x), Pr(this.y));
          }
          toAltitude() {
            return zu(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / th * u(Pr(this.y));
          }
        }
        function c(a, e, r, s, h, o, f, b, O) {
          const H = (e + s) / 2, y = (r + h) / 2, B = new At(H, y);
          b(B), function(G, L, F, Y, ce, _e) {
            const ze = F - ce, Ne = Y - _e;
            return Math.abs((Y - L) * ze - (F - G) * Ne) / Math.hypot(ze, Ne);
          }(B.x, B.y, o.x, o.y, f.x, f.y) >= O ? (c(a, e, r, H, y, o, B, b, O), c(a, H, y, s, h, B, f, b, O)) : a.push(f);
        }
        function p(a, e, r) {
          let s = a[0], h = s.x, o = s.y;
          e(s);
          const f = [s];
          for (let b = 1; b < a.length; b++) {
            const O = a[b], { x: H, y } = O;
            e(O), c(f, h, o, H, y, s, O, e, r), h = H, o = y, s = O;
          }
          return f;
        }
        function v(a, e, r, s) {
          if (s(e, r)) {
            const h = e.add(r)._mult(0.5);
            v(a, e, h, s), v(a, h, r, s);
          } else a.push(r);
        }
        function C(a, e) {
          let r = a[0];
          const s = [r];
          for (let h = 1; h < a.length; h++) {
            const o = a[h];
            v(s, r, o, e), r = o;
          }
          return s;
        }
        const V = Math.pow(2, 14) - 1, K = -V - 1;
        function se(a, e) {
          const r = Math.round(a.x * e), s = Math.round(a.y * e);
          return a.x = pe(r, K, V), a.y = pe(s, K, V), (r < a.x || r > a.x + 1 || s < a.y || s > a.y + 1) && Se("Geometry exceeds allowed extent, reduce your vector tile buffer size"), a;
        }
        function oe(a, e, r) {
          const s = a.loadGeometry(), h = a.extent, o = tr / h;
          if (e && r && r.projection.isReprojectedInTileSpace) {
            const f = 1 << e.z, { scale: b, x: O, y: H, projection: y } = r, B = (G) => {
              const L = Qs((e.x + G.x / h) / f), F = Pr((e.y + G.y / h) / f), Y = y.project(L, F);
              G.x = (Y.x * b - O) * h, G.y = (Y.y * b - H) * h;
            };
            for (let G = 0; G < s.length; G++) if (a.type !== 1) s[G] = p(s[G], B, 1);
            else {
              const L = [];
              for (const F of s[G]) F.x < 0 || F.x >= h || F.y < 0 || F.y >= h || (B(F), L.push(F));
              s[G] = L;
            }
          }
          for (const f of s) for (const b of f) se(b, o);
          return s;
        }
        function ve(a, e) {
          return { type: a.type, id: a.id, properties: a.properties, geometry: e ? oe(a) : [] };
        }
        function xe(a, e, r, s, h) {
          a.emplaceBack(2 * e + (s + 1) / 2, 2 * r + (h + 1) / 2);
        }
        function Le(a, e, r) {
          a.emplaceBack(e.x, e.y, e.z, r[0] * 16384, r[1] * 16384, r[2] * 16384);
        }
        class ft {
          constructor(e) {
            this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((r) => r.fqid), this.index = e.index, this.hasPattern = !1, this.projection = e.projection, this.layoutVertexArray = new Ds(), this.indexArray = new Ya(), this.segments = new Ea(), this.programConfigurations = new Cl(e.layers, { zoom: e.zoom, lut: e.lut }), this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id);
          }
          updateFootprints(e, r) {
          }
          populate(e, r, s, h) {
            const o = this.layers[0], f = [];
            let b = null;
            o.type === "circle" && (b = o.layout.get("circle-sort-key"));
            for (const { feature: H, id: y, index: B, sourceLayerIndex: G } of e) {
              const L = this.layers[0]._featureFilter.needGeometry, F = ve(H, L);
              if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), F, s)) continue;
              const Y = b ? b.evaluate(F, {}, s) : void 0, ce = { id: y, properties: H.properties, type: H.type, sourceLayerIndex: G, index: B, geometry: L ? F.geometry : oe(H, s, h), patterns: {}, sortKey: Y };
              f.push(ce);
            }
            b && f.sort((H, y) => H.sortKey - y.sortKey);
            let O = null;
            h.projection.name === "globe" && (this.globeExtVertexArray = new Xa(), O = h.projection);
            for (const H of f) {
              const { geometry: y, index: B, sourceLayerIndex: G } = H, L = e[B].feature;
              this.addFeature(H, y, B, r.availableImages, s, O, r.brightness), r.featureIndex.insert(L, y, B, G, this.index);
            }
          }
          update(e, r, s, h, o, f, b) {
            this.programConfigurations.updatePaintArrays(e, r, o, s, h, f, b);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Rh.members), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, vd.members))), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
          }
          addFeature(e, r, s, h, o, f, b) {
            for (const O of r) for (const H of O) {
              const y = H.x, B = H.y;
              if (y < 0 || y >= tr || B < 0 || B >= tr) continue;
              if (f) {
                const F = f.projectTilePoint(y, B, o), Y = f.upVector(o, y, B), ce = this.globeExtVertexArray;
                Le(ce, F, Y), Le(ce, F, Y), Le(ce, F, Y), Le(ce, F, Y);
              }
              const G = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), L = G.vertexLength;
              xe(this.layoutVertexArray, y, B, -1, -1), xe(this.layoutVertexArray, y, B, 1, -1), xe(this.layoutVertexArray, y, B, 1, 1), xe(this.layoutVertexArray, y, B, -1, 1), this.indexArray.emplaceBack(L, L + 1, L + 2), this.indexArray.emplaceBack(L, L + 2, L + 3), G.vertexLength += 4, G.primitiveLength += 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, s, {}, h, o, b);
          }
        }
        function st(a, e) {
          for (let r = 0; r < a.length; r++) if (Zt(e, a[r])) return !0;
          for (let r = 0; r < e.length; r++) if (Zt(a, e[r])) return !0;
          return !!qt(a, e);
        }
        function vt(a, e, r) {
          return !!Zt(a, e) || !!ii(e, a, r);
        }
        function gt(a, e) {
          if (a.length === 1) return Kt(e, a[0]);
          for (let r = 0; r < e.length; r++) {
            const s = e[r];
            for (let h = 0; h < s.length; h++) if (Zt(a, s[h])) return !0;
          }
          for (let r = 0; r < a.length; r++) if (Kt(e, a[r])) return !0;
          for (let r = 0; r < e.length; r++) if (qt(a, e[r])) return !0;
          return !1;
        }
        function Rt(a, e, r) {
          if (a.length > 1) {
            if (qt(a, e)) return !0;
            for (let s = 0; s < e.length; s++) if (ii(e[s], a, r)) return !0;
          }
          for (let s = 0; s < a.length; s++) if (ii(a[s], e, r)) return !0;
          return !1;
        }
        function qt(a, e) {
          if (a.length === 0 || e.length === 0) return !1;
          for (let r = 0; r < a.length - 1; r++) {
            const s = a[r], h = a[r + 1];
            for (let o = 0; o < e.length - 1; o++) if (jt(s, h, e[o], e[o + 1])) return !0;
          }
          return !1;
        }
        function jt(a, e, r, s) {
          return Pe(a, r, s) !== Pe(e, r, s) && Pe(a, e, r) !== Pe(a, e, s);
        }
        function ii(a, e, r) {
          const s = r * r;
          if (e.length === 1) return a.distSqr(e[0]) < s;
          for (let h = 1; h < e.length; h++) if (Xt(a, e[h - 1], e[h]) < s) return !0;
          return !1;
        }
        function Xt(a, e, r) {
          const s = e.distSqr(r);
          if (s === 0) return a.distSqr(e);
          const h = ((a.x - e.x) * (r.x - e.x) + (a.y - e.y) * (r.y - e.y)) / s;
          return a.distSqr(h < 0 ? e : h > 1 ? r : r.sub(e)._mult(h)._add(e));
        }
        function Kt(a, e) {
          let r, s, h, o = !1;
          for (let f = 0; f < a.length; f++) {
            r = a[f];
            for (let b = 0, O = r.length - 1; b < r.length; O = b++) s = r[b], h = r[O], s.y > e.y != h.y > e.y && e.x < (h.x - s.x) * (e.y - s.y) / (h.y - s.y) + s.x && (o = !o);
          }
          return o;
        }
        function Zt(a, e) {
          let r = !1;
          for (let s = 0, h = a.length - 1; s < a.length; h = s++) {
            const o = a[s], f = a[h];
            o.y > e.y != f.y > e.y && e.x < (f.x - o.x) * (e.y - o.y) / (f.y - o.y) + o.x && (r = !r);
          }
          return r;
        }
        function Jt(a, e, r, s, h) {
          for (const f of a) if (e <= f.x && r <= f.y && s >= f.x && h >= f.y) return !0;
          const o = [new At(e, r), new At(e, h), new At(s, h), new At(s, r)];
          if (a.length > 2) {
            for (const f of o) if (Zt(a, f)) return !0;
          }
          for (let f = 0; f < a.length - 1; f++) if (ui(a[f], a[f + 1], o)) return !0;
          return !1;
        }
        function ui(a, e, r) {
          const s = r[0], h = r[2];
          if (a.x < s.x && e.x < s.x || a.x > h.x && e.x > h.x || a.y < s.y && e.y < s.y || a.y > h.y && e.y > h.y) return !1;
          const o = Pe(a, e, r[0]);
          return o !== Pe(a, e, r[1]) || o !== Pe(a, e, r[2]) || o !== Pe(a, e, r[3]);
        }
        function Ti(a, e, r, s, h, o) {
          let f = e.y - a.y, b = a.x - e.x;
          if (o = o || 0) {
            const O = f * f + b * b;
            if (O === 0) return !0;
            const H = Math.sqrt(O);
            f /= H, b /= H;
          }
          return !((r.x - a.x) * f + (r.y - a.y) * b - o < 0 || (s.x - a.x) * f + (s.y - a.y) * b - o < 0 || (h.x - a.x) * f + (h.y - a.y) * b - o < 0);
        }
        function xi(a, e, r, s, h, o, f) {
          return !(Ti(a, e, s, h, o, f) || Ti(e, r, s, h, o, f) || Ti(r, a, s, h, o, f) || Ti(s, h, a, e, r, f) || Ti(h, o, a, e, r, f) || Ti(o, s, a, e, r, f));
        }
        function Pi(a, e, r) {
          const s = e.paint.get(a).value;
          return s.kind === "constant" ? s.value : r.programConfigurations.get(e.id).getMaxValue(a);
        }
        function Ri(a) {
          return Math.sqrt(a[0] * a[0] + a[1] * a[1]);
        }
        function mi(a, e, r, s, h) {
          if (!e[0] && !e[1]) return a;
          const o = At.convert(e)._mult(h);
          r === "viewport" && o._rotate(-s);
          const f = [];
          for (let b = 0; b < a.length; b++) f.push(a[b].sub(o));
          return f;
        }
        function Ai(a, e, r, s) {
          const h = At.convert(a)._mult(s);
          return e === "viewport" && h._rotate(-r), h;
        }
        let ji, yi;
        ur(ft, "CircleBucket", { omit: ["layers"] });
        var Ni, Mi = { exports: {} }, Yi = (Ni || (Ni = 1, function(a, e) {
          (function(r) {
            function s(o, f, b) {
              var O = h(256 * o, 256 * (f = Math.pow(2, b) - f - 1), b), H = h(256 * (o + 1), 256 * (f + 1), b);
              return O[0] + "," + O[1] + "," + H[0] + "," + H[1];
            }
            function h(o, f, b) {
              var O = 2 * Math.PI * 6378137 / 256 / Math.pow(2, b);
              return [o * O - 2 * Math.PI * 6378137 / 2, f * O - 2 * Math.PI * 6378137 / 2];
            }
            r.getURL = function(o, f, b, O, H, y) {
              return y = y || {}, o + "?" + ["bbox=" + s(b, O, H), "format=" + (y.format || "image/png"), "service=" + (y.service || "WMS"), "version=" + (y.version || "1.1.1"), "request=" + (y.request || "GetMap"), "srs=" + (y.srs || "EPSG:3857"), "width=" + (y.width || 256), "height=" + (y.height || 256), "layers=" + f].join("&");
            }, r.getTileBBox = s, r.getMercCoords = h, Object.defineProperty(r, "__esModule", { value: !0 });
          })(e);
        }(0, Mi.exports)), Mi.exports);
        class Ui {
          constructor(e, r, s) {
            this.z = e, this.x = r, this.y = s, this.key = ir(0, e, e, r, s);
          }
          equals(e) {
            return this.z === e.z && this.x === e.x && this.y === e.y;
          }
          url(e, r) {
            const s = Yi.getTileBBox(this.x, this.y, this.z), h = function(o, f, b) {
              let O, H = "";
              for (let y = o; y > 0; y--) O = 1 << y - 1, H += (f & O ? 1 : 0) + (b & O ? 2 : 0);
              return H;
            }(this.z, this.x, this.y);
            return e[(this.x + this.y) % e.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(r === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", h).replace("{bbox-epsg-3857}", s);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class Fi {
          constructor(e, r) {
            this.wrap = e, this.canonical = r, this.key = ir(e, r.z, r.z, r.x, r.y);
          }
        }
        class Zi {
          constructor(e, r, s, h, o) {
            this.overscaledZ = e, this.wrap = r, this.canonical = new Ui(s, +h, +o), this.key = r === 0 && e === s ? this.canonical.key : ir(r, e, s, h, o);
          }
          equals(e) {
            return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
          }
          scaledTo(e) {
            const r = this.canonical.z - e;
            return e > this.canonical.z ? new Zi(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Zi(e, this.wrap, e, this.canonical.x >> r, this.canonical.y >> r);
          }
          calculateScaledKey(e, r = !0) {
            if (this.overscaledZ === e && r) return this.key;
            if (e > this.canonical.z) return ir(this.wrap * +r, e, this.canonical.z, this.canonical.x, this.canonical.y);
            {
              const s = this.canonical.z - e;
              return ir(this.wrap * +r, e, e, this.canonical.x >> s, this.canonical.y >> s);
            }
          }
          isChildOf(e) {
            if (e.wrap !== this.wrap) return !1;
            const r = this.canonical.z - e.canonical.z;
            return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.z < this.canonical.z && e.canonical.x === this.canonical.x >> r && e.canonical.y === this.canonical.y >> r;
          }
          children(e) {
            if (this.overscaledZ >= e) return [new Zi(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const r = this.canonical.z + 1, s = 2 * this.canonical.x, h = 2 * this.canonical.y;
            return [new Zi(r, this.wrap, r, s, h), new Zi(r, this.wrap, r, s + 1, h), new Zi(r, this.wrap, r, s, h + 1), new Zi(r, this.wrap, r, s + 1, h + 1)];
          }
          isLessThan(e) {
            return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
          }
          wrapped() {
            return new Zi(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(e) {
            return new Zi(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new Fi(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
        }
        function ir(a, e, r, s, h) {
          const o = 1 << Math.min(r, 22);
          let f = o * (h % o) + s % o;
          return a && r < 22 && (f += o * o * ((a < 0 ? -2 * a - 1 : 2 * a) % (1 << 2 * (22 - r)))), 16 * (32 * f + r) + (e - r);
        }
        const cr = [(a) => {
          let e = a.canonical.x - 1, r = a.wrap;
          return e < 0 && (e = (1 << a.canonical.z) - 1, r--), new Zi(a.overscaledZ, r, a.canonical.z, e, a.canonical.y);
        }, (a) => {
          let e = a.canonical.x + 1, r = a.wrap;
          return e === 1 << a.canonical.z && (e = 0, r++), new Zi(a.overscaledZ, r, a.canonical.z, e, a.canonical.y);
        }, (a) => new Zi(a.overscaledZ, a.wrap, a.canonical.z, a.canonical.x, (a.canonical.y === 0 ? 1 << a.canonical.z : a.canonical.y) - 1), (a) => new Zi(a.overscaledZ, a.wrap, a.canonical.z, a.canonical.x, a.canonical.y === (1 << a.canonical.z) - 1 ? 0 : a.canonical.y + 1)];
        ur(Ui, "CanonicalTileID"), ur(Zi, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
        const fr = dn([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: Or } = fr, Er = dn([{ name: "a_pos_3", components: 3, type: "Int16" }]);
        var Ar = dn([{ name: "a_pos", type: "Int16", components: 2 }]);
        class Fr {
          constructor(e, r) {
            this.pos = e, this.dir = r;
          }
          intersectsPlane(e, r, s) {
            const h = rt.vec3.dot(r, this.dir);
            if (Math.abs(h) < 1e-6) return !1;
            const o = ((e[0] - this.pos[0]) * r[0] + (e[1] - this.pos[1]) * r[1] + (e[2] - this.pos[2]) * r[2]) / h;
            return s[0] = this.pos[0] + this.dir[0] * o, s[1] = this.pos[1] + this.dir[1] * o, s[2] = this.pos[2] + this.dir[2] * o, !0;
          }
          closestPointOnSphere(e, r, s) {
            if (rt.vec3.equals(this.pos, e) || r === 0) return s[0] = s[1] = s[2] = 0, !1;
            const [h, o, f] = this.dir, b = this.pos[0] - e[0], O = this.pos[1] - e[1], H = this.pos[2] - e[2], y = h * h + o * o + f * f, B = 2 * (b * h + O * o + H * f), G = B * B - 4 * y * (b * b + O * O + H * H - r * r);
            if (G < 0) {
              const L = Math.max(-B / 2, 0), F = b + h * L, Y = O + o * L, ce = H + f * L, _e = Math.hypot(F, Y, ce);
              return s[0] = F * r / _e, s[1] = Y * r / _e, s[2] = ce * r / _e, !1;
            }
            {
              const L = (-B - Math.sqrt(G)) / (2 * y);
              if (L < 0) {
                const F = Math.hypot(b, O, H);
                return s[0] = b * r / F, s[1] = O * r / F, s[2] = H * r / F, !1;
              }
              return s[0] = b + h * L, s[1] = O + o * L, s[2] = H + f * L, !0;
            }
          }
        }
        class an {
          constructor(e, r, s, h, o) {
            this.TL = e, this.TR = r, this.BR = s, this.BL = h, this.horizon = o;
          }
          static fromInvProjectionMatrix(e, r, s) {
            const h = [-1, 1, 1], o = [1, 1, 1], f = [1, -1, 1], b = [-1, -1, 1], O = rt.vec3.transformMat4(h, h, e), H = rt.vec3.transformMat4(o, o, e), y = rt.vec3.transformMat4(f, f, e), B = rt.vec3.transformMat4(b, b, e);
            return new an(O, H, y, B, r / s);
          }
        }
        function yn(a, e, r) {
          let s = 1 / 0, h = -1 / 0;
          const o = [];
          for (const f of a) {
            rt.vec3.sub(o, f, e);
            const b = rt.vec3.dot(o, r);
            s = Math.min(s, b), h = Math.max(h, b);
          }
          return [s, h];
        }
        function $n(a, e) {
          let r = !0;
          for (let s = 0; s < a.planes.length; s++) {
            const h = a.planes[s];
            let o = 0;
            for (let f = 0; f < e.length; f++) o += rt.vec3.dot(h, e[f]) + h[3] >= 0;
            if (o === 0) return 0;
            o !== e.length && (r = !1);
          }
          return r ? 2 : 1;
        }
        function fn(a, e) {
          for (const r of a.projections) {
            const s = yn(e, a.points[0], r.axis);
            if (r.projection[1] < s[0] || r.projection[0] > s[1]) return 0;
          }
          return 1;
        }
        function Nr(a, e) {
          let r = 0;
          const s = [0, 0, 0, 0];
          for (let h = 0; h < a.length; h++) s[0] = a[h][0], s[1] = a[h][1], s[2] = a[h][2], s[3] = 1, rt.vec4.dot(s, e) >= 0 && r++;
          return r;
        }
        class Jr {
          constructor(e, r) {
            this.points = e || new Array(8).fill([0, 0, 0]), this.planes = r || new Array(6).fill([0, 0, 0, 0]), this.bounds = mr.fromPoints(this.points), this.projections = [], this.frustumEdges = [rt.vec3.sub([], this.points[2], this.points[3]), rt.vec3.sub([], this.points[0], this.points[3]), rt.vec3.sub([], this.points[4], this.points[0]), rt.vec3.sub([], this.points[5], this.points[1]), rt.vec3.sub([], this.points[6], this.points[2]), rt.vec3.sub([], this.points[7], this.points[3])];
            for (const s of this.frustumEdges) {
              const h = [0, -s[2], s[1]], o = [s[2], 0, -s[0]];
              this.projections.push({ axis: h, projection: yn(this.points, this.points[0], h) }), this.projections.push({ axis: o, projection: yn(this.points, this.points[0], o) });
            }
          }
          static fromInvProjectionMatrix(e, r, s, h) {
            const o = Math.pow(2, s), f = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((H) => {
              const y = rt.vec4.transformMat4([], H, e), B = 1 / y[3] / r * o;
              return rt.vec4.mul(y, y, [B, B, h ? 1 / y[3] : B, B]);
            }), b = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((H) => {
              const y = rt.vec3.sub([], f[H[0]], f[H[1]]), B = rt.vec3.sub([], f[H[2]], f[H[1]]), G = rt.vec3.normalize([], rt.vec3.cross([], y, B)), L = -rt.vec3.dot(G, f[H[1]]);
              return G.concat(L);
            }), O = [];
            for (let H = 0; H < f.length; H++) O.push([f[H][0], f[H][1], f[H][2]]);
            return new Jr(O, b);
          }
          intersectsPrecise(e, r, s) {
            for (let h = 0; h < r.length; h++) if (!Nr(e, r[h])) return 0;
            for (let h = 0; h < this.planes.length; h++) if (!Nr(e, this.planes[h])) return 0;
            for (const h of s) for (const o of this.frustumEdges) {
              const f = rt.vec3.cross([], h, o), b = rt.vec3.length(f);
              if (b === 0) continue;
              rt.vec3.scale(f, f, 1 / b);
              const O = yn(this.points, this.points[0], f), H = yn(e, this.points[0], f);
              if (O[0] > H[1] || H[0] > O[1]) return 0;
            }
            return 1;
          }
          containsPoint(e) {
            for (const r of this.planes) {
              const s = r[3];
              if (rt.vec3.dot([r[0], r[1], r[2]], e) + s < 0) return !1;
            }
            return !0;
          }
        }
        class mr {
          static fromPoints(e) {
            const r = [1 / 0, 1 / 0, 1 / 0], s = [-1 / 0, -1 / 0, -1 / 0];
            for (const h of e) rt.vec3.min(r, r, h), rt.vec3.max(s, s, h);
            return new mr(r, s);
          }
          static fromTileIdAndHeight(e, r, s) {
            const h = 1 << e.canonical.z, o = e.canonical.x, f = e.canonical.y;
            return new mr([o / h, f / h, r], [(o + 1) / h, (f + 1) / h, s]);
          }
          static applyTransform(e, r) {
            const s = e.getCorners();
            for (let h = 0; h < s.length; ++h) rt.vec3.transformMat4(s[h], s[h], r);
            return mr.fromPoints(s);
          }
          static applyTransformFast(e, r) {
            const s = [r[12], r[13], r[14]], h = [...s];
            for (let o = 0; o < 3; o++) for (let f = 0; f < 3; f++) {
              const b = r[4 * f + o], O = b * e.min[f], H = b * e.max[f];
              s[o] += Math.min(O, H), h[o] += Math.max(O, H);
            }
            return new mr(s, h);
          }
          static projectAabbCorners(e, r) {
            const s = e.getCorners();
            for (let h = 0; h < s.length; ++h) rt.vec3.transformMat4(s[h], s[h], r);
            return s;
          }
          constructor(e, r) {
            this.min = e, this.max = r, this.center = rt.vec3.scale([], rt.vec3.add([], this.min, this.max), 0.5);
          }
          quadrant(e) {
            const r = [e % 2 == 0, e < 2], s = rt.vec3.clone(this.min), h = rt.vec3.clone(this.max);
            for (let o = 0; o < r.length; o++) s[o] = r[o] ? this.min[o] : this.center[o], h[o] = r[o] ? this.center[o] : this.max[o];
            return h[2] = this.max[2], new mr(s, h);
          }
          distanceX(e) {
            return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
          }
          distanceY(e) {
            return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
          }
          distanceZ(e) {
            return Math.max(Math.min(this.max[2], e[2]), this.min[2]) - e[2];
          }
          getCorners() {
            const e = this.min, r = this.max;
            return [[e[0], e[1], e[2]], [r[0], e[1], e[2]], [r[0], r[1], e[2]], [e[0], r[1], e[2]], [e[0], e[1], r[2]], [r[0], e[1], r[2]], [r[0], r[1], r[2]], [e[0], r[1], r[2]]];
          }
          intersects(e) {
            return this.intersectsAabb(e.bounds) ? $n(e, this.getCorners()) : 0;
          }
          intersectsFlat(e) {
            return this.intersectsAabb(e.bounds) ? $n(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
          }
          intersectsPrecise(e, r) {
            return r || this.intersects(e) ? fn(e, this.getCorners()) : 0;
          }
          intersectsPreciseFlat(e, r) {
            return r || this.intersectsFlat(e) ? fn(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
          }
          intersectsAabb(e) {
            for (let r = 0; r < 3; ++r) if (this.min[r] > e.max[r] || e.min[r] > this.max[r]) return !1;
            return !0;
          }
          intersectsAabbXY(e) {
            return !(this.min[0] > e.max[0] || e.min[0] > this.max[0] || this.min[1] > e.max[1] || e.min[1] > this.max[1]);
          }
          encapsulate(e) {
            for (let r = 0; r < 3; r++) this.min[r] = Math.min(this.min[r], e.min[r]), this.max[r] = Math.max(this.max[r], e.max[r]);
          }
          encapsulatePoint(e) {
            for (let r = 0; r < 3; r++) this.min[r] = Math.min(this.min[r], e[r]), this.max[r] = Math.max(this.max[r], e[r]);
          }
          closestPoint(e) {
            return [Math.max(Math.min(this.max[0], e[0]), this.min[0]), Math.max(Math.min(this.max[1], e[1]), this.min[1]), Math.max(Math.min(this.max[2], e[2]), this.min[2])];
          }
        }
        function nn(a) {
          return a * vs / eu;
        }
        ur(mr, "Aabb");
        const pn = [new mr([Ys, Ys, Ys], [Ts, Ts, Ts]), new mr([Ys, Ys, Ys], [0, 0, Ts]), new mr([0, Ys, Ys], [Ts, 0, Ts]), new mr([Ys, 0, Ys], [0, Ts, Ts]), new mr([0, 0, Ys], [Ts, Ts, Ts])];
        function gn(a, e, r, s = !0) {
          const h = rt.vec3.scale([], a._camera.position, a.worldSize), o = [e, r, 1, 1];
          rt.vec4.transformMat4(o, o, a.pixelMatrixInverse), rt.vec4.scale(o, o, 1 / o[3]);
          const f = rt.vec3.sub([], o, h), b = rt.vec3.normalize([], f), O = a.globeMatrix, H = [O[12], O[13], O[14]], y = rt.vec3.sub([], H, h), B = rt.vec3.length(y), G = rt.vec3.normalize([], y), L = a.worldSize / (2 * Math.PI), F = rt.vec3.dot(G, b), Y = Math.asin(L / B);
          if (Y < Math.acos(F)) {
            if (!s) return null;
            const ni = [], Gt = [];
            rt.vec3.scale(ni, b, B / F), rt.vec3.normalize(Gt, rt.vec3.sub(Gt, ni, y)), rt.vec3.normalize(b, rt.vec3.add(b, y, rt.vec3.scale(b, Gt, Math.tan(Y) * B)));
          }
          const ce = [];
          new Fr(h, b).closestPointOnSphere(H, L, ce);
          const _e = rt.vec3.normalize([], Xe(O, 0)), ze = rt.vec3.normalize([], Xe(O, 1)), Ne = rt.vec3.normalize([], Xe(O, 2)), Ee = rt.vec3.dot(_e, ce), We = rt.vec3.dot(ze, ce), lt = rt.vec3.dot(Ne, ce), yt = De(Math.asin(-We / L));
          let Bt = De(Math.atan2(Ee, lt));
          Bt = a.center.lng + function(ni, Gt) {
            const si = (Gt - ni + 180) % 360 - 180;
            return si < -180 ? si + 360 : si;
          }(a.center.lng, Bt);
          const zt = il(Bt), Dt = pe(Js(yt), 0, 1);
          return new n(zt, Dt);
        }
        class na {
          constructor(e, r, s) {
            this.a = rt.vec3.sub([], e, s), this.b = rt.vec3.sub([], r, s), this.center = s;
            const h = rt.vec3.normalize([], this.a), o = rt.vec3.normalize([], this.b);
            this.angle = Math.acos(rt.vec3.dot(h, o));
          }
        }
        function ua(a, e) {
          if (a.angle === 0) return null;
          let r;
          return r = a.a[e] === 0 ? 1 / a.angle * 0.5 * Math.PI : 1 / a.angle * Math.atan(a.b[e] / a.a[e] / Math.sin(a.angle) - 1 / Math.tan(a.angle)), r < 0 || r > 1 ? null : function(s, h, o, f) {
            const b = Math.sin(o);
            return s * (Math.sin((1 - f) * o) / b) + h * (Math.sin(f * o) / b);
          }(a.a[e], a.b[e], a.angle, pe(r, 0, 1)) + a.center[e];
        }
        function Ra(a) {
          if (a.z <= 1) return pn[a.z + 2 * a.y + a.x];
          const e = Rn(On(a));
          return mr.fromPoints(e);
        }
        function Aa(a, e, r) {
          return rt.vec3.scale(a, a, 1 - r), rt.vec3.scaleAndAdd(a, a, e, r);
        }
        function ns(a, e, r) {
          for (const s of a) rt.vec3.transformMat4(s, s, e), rt.vec3.scale(s, s, r);
        }
        function as(a, e, r, s) {
          const h = e / a.worldSize, o = a.globeMatrix;
          if (r.z <= 1) {
            const zt = Ra(r).getCorners();
            return ns(zt, o, h), mr.fromPoints(zt);
          }
          const f = On(r, s), b = Rn(f, vs + nn(a._tileCoverLift));
          ns(b, o, h);
          const O = Number.MAX_VALUE, H = [-O, -O, -O], y = [O, O, O];
          if (f.contains(a.center)) {
            for (const ni of b) rt.vec3.min(y, y, ni), rt.vec3.max(H, H, ni);
            H[2] = 0;
            const zt = a.point, Dt = [zt.x * h, zt.y * h, 0];
            return rt.vec3.min(y, y, Dt), rt.vec3.max(H, H, Dt), new mr(y, H);
          }
          if (a._tileCoverLift > 0) {
            for (const zt of b) rt.vec3.min(y, y, zt), rt.vec3.max(H, H, zt);
            return new mr(y, H);
          }
          const B = [o[12] * h, o[13] * h, o[14] * h], G = f.getCenter(), L = pe(a.center.lat, -la, la), F = pe(G.lat, -la, la), Y = il(a.center.lng), ce = Js(L);
          let _e = Y - il(G.lng);
          const ze = ce - Js(F);
          _e > 0.5 ? _e -= 1 : _e < -0.5 && (_e += 1);
          let Ne = 0;
          if (Math.abs(_e) > Math.abs(ze)) Ne = _e >= 0 ? 1 : 3;
          else {
            Ne = ze >= 0 ? 0 : 2;
            const zt = [o[4] * h, o[5] * h, o[6] * h], Dt = -Math.sin(Ye(ze >= 0 ? f.getSouth() : f.getNorth())) * vs;
            rt.vec3.scaleAndAdd(B, B, zt, Dt);
          }
          const Ee = b[Ne], We = b[(Ne + 1) % 4], lt = new na(Ee, We, B), yt = [ua(lt, 0) || Ee[0], ua(lt, 1) || Ee[1], ua(lt, 2) || Ee[2]], Bt = Bs(a.zoom);
          if (Bt > 0) {
            const zt = function({ x: ni, y: Gt, z: si }, ci, li, fi, gi) {
              const Si = 1 / (1 << si);
              let pi = ni * Si, zi = pi + Si, Gi = Gt * Si, Oi = Gi + Si, lr = 0;
              const ar = (pi + zi) / 2 - fi;
              return ar > 0.5 ? lr = -1 : ar < -0.5 && (lr = 1), pi = ((pi + lr) * ci - (fi *= ci)) * li + fi, zi = ((zi + lr) * ci - fi) * li + fi, Gi = (Gi * ci - (gi *= ci)) * li + gi, Oi = (Oi * ci - gi) * li + gi, [[pi, Oi, 0], [zi, Oi, 0], [zi, Gi, 0], [pi, Gi, 0]];
            }(r, e, a._pixelsPerMercatorPixel, Y, ce);
            for (let ni = 0; ni < b.length; ni++) Aa(b[ni], zt[ni], Bt);
            const Dt = rt.vec3.add([], zt[Ne], zt[(Ne + 1) % 4]);
            rt.vec3.scale(Dt, Dt, 0.5), Aa(yt, Dt, Bt);
          }
          for (const zt of b) rt.vec3.min(y, y, zt), rt.vec3.max(H, H, zt);
          return y[2] = Math.min(Ee[2], We[2]), rt.vec3.min(y, y, yt), rt.vec3.max(H, H, yt), new mr(y, H);
        }
        function On({ x: a, y: e, z: r }, s = !1) {
          const h = 1 / (1 << r), o = new hn(Qs(a * h), e === (1 << r) - 1 && s ? -90 : Pr((e + 1) * h)), f = new hn(Qs((a + 1) * h), e === 0 && s ? 90 : Pr(e * h));
          return new Al(o, f);
        }
        function Rn(a, e = vs) {
          const r = Ye(a.getNorth()), s = Ye(a.getSouth()), h = Math.cos(r), o = Math.cos(s), f = Math.sin(r), b = Math.sin(s), O = a.getWest(), H = a.getEast();
          return [Ks(o, b, O, e), Ks(o, b, H, e), Ks(h, f, H, e), Ks(h, f, O, e)];
        }
        function Cn(a, e, r, s) {
          const h = 1 << r.z, o = (a / tr + r.x) / h;
          return Du(Pr((e / tr + r.y) / h), Qs(o), s);
        }
        function ln({ min: a, max: e }) {
          return Vf / Math.max(e[0] - a[0], e[1] - a[1], e[2] - a[2]);
        }
        const ca = new Float64Array(16);
        function Ha(a) {
          const e = ln(a), r = rt.mat4.fromScaling(ca, [e, e, e]);
          return rt.mat4.translate(r, r, rt.vec3.negate([], a.min));
        }
        function kn(a) {
          const e = rt.mat4.fromTranslation(ca, a.min), r = 1 / ln(a);
          return rt.mat4.scale(e, e, [r, r, r]);
        }
        function fs(a) {
          const e = tr / (2 * Math.PI);
          return a / (2 * Math.PI) / e;
        }
        function fo(a, e) {
          return tr / (512 * Math.pow(2, a)) * ln(Ra(e));
        }
        function Ka(a, e, r, s, h) {
          const o = fs(r), f = [a, e, -r / (2 * Math.PI)], b = rt.mat4.identity(new Float64Array(16));
          return rt.mat4.translate(b, b, f), rt.mat4.scale(b, b, [o, o, o]), rt.mat4.rotateX(b, b, Ye(-h)), rt.mat4.rotateY(b, b, Ye(-s)), b;
        }
        function Bs(a) {
          return xt(Ql, eh, a);
        }
        function Fs(a, e) {
          const r = Du(e.lat, e.lng), s = function(o) {
            const f = Du(o._center.lat, o._center.lng), b = rt.vec3.fromValues(0, 1, 0);
            let O = rt.vec3.cross([], b, f);
            const H = rt.mat4.fromRotation([], -o.angle, f);
            O = rt.vec3.transformMat4(O, O, H), rt.mat4.fromRotation(H, -o._pitch, O);
            const y = rt.vec3.normalize([], f);
            return rt.vec3.scale(y, y, nn(o.cameraToCenterDistance / o.pixelsPerMeter)), rt.vec3.transformMat4(y, y, H), rt.vec3.add([], f, y);
          }(a), h = rt.vec3.subtract([], s, r);
          return rt.vec3.angle(h, r);
        }
        function po(a, e) {
          return Fs(a, e) > Math.PI / 2 * 1.01;
        }
        const Bn = Ye(85), Bu = Math.cos(Bn), Oo = Math.sin(Bn), Fu = rt.mat4.create(), Sc = (a) => {
          const e = [];
          return a.paint.get("circle-pitch-alignment") === "map" && e.push("PITCH_WITH_MAP"), a.paint.get("circle-pitch-scale") === "map" && e.push("SCALE_WITH_MAP"), e;
        };
        function rh(a, e, r, s, h, o, f, b, O) {
          if (o && a.queryGeometry.isAboveHorizon) return !1;
          o && (O *= a.pixelToTileUnitsFactor);
          const H = a.tileID.canonical, y = r.projection.upVectorScale(H, r.center.lat, r.worldSize).metersToTile;
          for (const B of e) for (const G of B) {
            const L = G.add(b), F = h && r.elevation ? r.elevation.exaggeration() * h.getElevationAt(L.x, L.y, !0) : 0, Y = r.projection.projectTilePoint(L.x, L.y, H);
            if (F > 0) {
              const Ne = r.projection.upVector(H, L.x, L.y);
              Y.x += Ne[0] * y * F, Y.y += Ne[1] * y * F, Y.z += Ne[2] * y * F;
            }
            const ce = o ? L : Bh(Y.x, Y.y, Y.z, s), _e = o ? a.tilespaceRays.map((Ne) => xd(Ne, F)) : a.queryGeometry.screenGeometry, ze = rt.vec4.transformMat4([], [Y.x, Y.y, Y.z, 1], s);
            if (!f && o ? O *= ze[3] / r.cameraToCenterDistance : f && !o && (O *= r.cameraToCenterDistance / ze[3]), o) {
              const Ne = Pr((G.y / tr + H.y) / (1 << H.z));
              O /= r.projection.pixelsPerMeter(Ne, 1) / Zn(1, Ne);
            }
            if (vt(_e, ce, O)) return !0;
          }
          return !1;
        }
        function Bh(a, e, r, s) {
          const h = rt.vec4.transformMat4([], [a, e, r, 1], s);
          return new At(h[0] / h[3], h[1] / h[3]);
        }
        const sp = rt.vec3.fromValues(0, 0, 0), rl = rt.vec3.fromValues(0, 0, 1);
        function xd(a, e) {
          const r = rt.vec3.create();
          return sp[2] = e, a.intersectsPlane(sp, rl, r), new At(r[0], r[1]);
        }
        class op extends ft {
        }
        let Nu, yf, Ec, xf;
        function jf(a, { width: e, height: r }, s, h) {
          if (h) {
            if (h instanceof Uint8ClampedArray) h = new Uint8Array(h.buffer);
            else if (h.length !== e * r * s) throw new RangeError("mismatched image size");
          } else h = new Uint8Array(e * r * s);
          return a.width = e, a.height = r, a.data = h, a;
        }
        function Gf(a, e, r) {
          const { width: s, height: h } = e;
          s === a.width && h === a.height || (bd(a, e, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(a.width, s), height: Math.min(a.height, h) }, r, null), a.width = s, a.height = h, a.data = e.data);
        }
        function bd(a, e, r, s, h, o, f, b) {
          if (h.width === 0 || h.height === 0) return e;
          if (h.width > a.width || h.height > a.height || r.x > a.width - h.width || r.y > a.height - h.height) throw new RangeError("out of range source coordinates for image copy");
          if (h.width > e.width || h.height > e.height || s.x > e.width - h.width || s.y > e.height - h.height) throw new RangeError("out of range destination coordinates for image copy");
          const O = a.data, H = e.data, y = o === 4 && b;
          for (let B = 0; B < h.height; B++) {
            const G = ((r.y + B) * a.width + r.x) * o, L = ((s.y + B) * e.width + s.x) * o;
            if (y) for (let F = 0; F < h.width; F++) {
              const Y = G + F * o + 3, ce = L + F * o;
              H[ce + 0] = 255, H[ce + 1] = 255, H[ce + 2] = 255, H[ce + 3] = O[Y];
            }
            else if (f) for (let F = 0; F < h.width; F++) {
              const Y = G + F * o, ce = L + F * o, _e = O[Y + 3], ze = new Wr(O[Y + 0] / 255 * _e, O[Y + 1] / 255 * _e, O[Y + 2] / 255 * _e, _e).toRenderColor(f).toArray();
              H[ce + 0] = ze[0], H[ce + 1] = ze[1], H[ce + 2] = ze[2], H[ce + 3] = ze[3];
            }
            else for (let F = 0; F < h.width * o; F++) H[L + F] = O[G + F];
          }
          return e;
        }
        ur(op, "HeatmapBucket", { omit: ["layers"] });
        class tu {
          constructor(e, r) {
            jf(this, e, 1, r);
          }
          resize(e) {
            Gf(this, new tu(e), 1);
          }
          clone() {
            return new tu({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(e, r, s, h, o) {
            bd(e, r, s, h, o, 1, null);
          }
        }
        class ds {
          constructor(e, r) {
            jf(this, e, 4, r);
          }
          resize(e) {
            Gf(this, new ds(e), 4);
          }
          replace(e, r) {
            r ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
          }
          clone() {
            return new ds({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(e, r, s, h, o, f, b) {
            bd(e, r, s, h, o, 4, f, b);
          }
        }
        class wd {
          constructor(e, r) {
            this.width = e.width, this.height = e.height, this.data = r instanceof Uint8Array ? new Float32Array(r.buffer) : r;
          }
        }
        function Fh(a) {
          const e = {}, r = a.resolution || 256, s = a.clips ? a.clips.length : 1, h = a.image || new ds({ width: r, height: s }), o = (f, b, O) => {
            e[a.evaluationKey] = O;
            const H = a.expression.evaluate(e);
            H && (h.data[f + b + 0] = Math.floor(255 * H.r / H.a), h.data[f + b + 1] = Math.floor(255 * H.g / H.a), h.data[f + b + 2] = Math.floor(255 * H.b / H.a), h.data[f + b + 3] = Math.floor(255 * H.a));
          };
          if (a.clips) for (let f = 0, b = 0; f < s; ++f, b += 4 * r) for (let O = 0, H = 0; O < r; O++, H += 4) {
            const y = O / (r - 1), { start: B, end: G } = a.clips[f];
            o(b, H, B * (1 - y) + G * y);
          }
          else for (let f = 0, b = 0; f < r; f++, b += 4) o(0, b, f / (r - 1));
          return h;
        }
        ur(tu, "AlphaImage"), ur(ds, "RGBAImage");
        const Hf = dn([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: qf } = Hf;
        function Nh(a, e, r = 2) {
          const s = e && e.length, h = s ? e[0] * r : a.length;
          let o = Wf(a, 0, h, r, !0);
          const f = [];
          if (!o || o.next === o.prev) return f;
          let b, O, H;
          if (s && (o = function(y, B, G, L) {
            const F = [];
            for (let Y = 0, ce = B.length; Y < ce; Y++) {
              const _e = Wf(y, B[Y] * L, Y < ce - 1 ? B[Y + 1] * L : y.length, L, !1);
              _e === _e.next && (_e.steiner = !0), F.push(lm(_e));
            }
            F.sort(sm);
            for (let Y = 0; Y < F.length; Y++) G = Xf(F[Y], G);
            return G;
          }(a, e, o, r)), a.length > 80 * r) {
            b = 1 / 0, O = 1 / 0;
            let y = -1 / 0, B = -1 / 0;
            for (let G = r; G < h; G += r) {
              const L = a[G], F = a[G + 1];
              L < b && (b = L), F < O && (O = F), L > y && (y = L), F > B && (B = F);
            }
            H = Math.max(y - b, B - O), H = H !== 0 ? 32767 / H : 0;
          }
          return nh(o, f, r, b, O, H, 0), f;
        }
        function Wf(a, e, r, s, h) {
          let o;
          if (h === function(f, b, O, H) {
            let y = 0;
            for (let B = b, G = O - H; B < O; B += H) y += (f[G] - f[B]) * (f[B + 1] + f[G + 1]), G = B;
            return y;
          }(a, e, r, s) > 0) for (let f = e; f < r; f += s) o = Ii(f / s | 0, a[f], a[f + 1], o);
          else for (let f = r - s; f >= e; f -= s) o = Ii(f / s | 0, a[f], a[f + 1], o);
          return o && $(o, o.next) && ($i(o), o = o.next), o;
        }
        function Tc(a, e) {
          if (!a) return a;
          e || (e = a);
          let r, s = a;
          do
            if (r = !1, s.steiner || !$(s, s.next) && g(s.prev, s, s.next) !== 0) s = s.next;
            else {
              if ($i(s), s = e = s.prev, s === s.next) break;
              r = !0;
            }
          while (r || s !== e);
          return e;
        }
        function nh(a, e, r, s, h, o, f) {
          if (!a) return;
          !f && o && function(O, H, y, B) {
            let G = O;
            do
              G.z === 0 && (G.z = ah(G.x, G.y, H, y, B)), G.prevZ = G.prev, G.nextZ = G.next, G = G.next;
            while (G !== O);
            G.prevZ.nextZ = null, G.prevZ = null, function(L) {
              let F, Y = 1;
              do {
                let ce, _e = L;
                L = null;
                let ze = null;
                for (F = 0; _e; ) {
                  F++;
                  let Ne = _e, Ee = 0;
                  for (let lt = 0; lt < Y && (Ee++, Ne = Ne.nextZ, Ne); lt++) ;
                  let We = Y;
                  for (; Ee > 0 || We > 0 && Ne; ) Ee !== 0 && (We === 0 || !Ne || _e.z <= Ne.z) ? (ce = _e, _e = _e.nextZ, Ee--) : (ce = Ne, Ne = Ne.nextZ, We--), ze ? ze.nextZ = ce : L = ce, ce.prevZ = ze, ze = ce;
                  _e = Ne;
                }
                ze.nextZ = null, Y *= 2;
              } while (F > 1);
            }(G);
          }(a, s, h, o);
          let b = a;
          for (; a.prev !== a.next; ) {
            const O = a.prev, H = a.next;
            if (o ? Sd(a, s, h, o) : Zf(a)) e.push(O.i, a.i, H.i), $i(a), a = H.next, b = H.next;
            else if ((a = H) === b) {
              f ? f === 1 ? nh(a = $f(Tc(a), e), e, r, s, h, o, 2) : f === 2 && lp(a, e, r, s, h, o) : nh(Tc(a), e, r, s, h, o, 1);
              break;
            }
          }
        }
        function Zf(a) {
          const e = a.prev, r = a, s = a.next;
          if (g(e, r, s) >= 0) return !1;
          const h = e.x, o = r.x, f = s.x, b = e.y, O = r.y, H = s.y, y = h < o ? h < f ? h : f : o < f ? o : f, B = b < O ? b < H ? b : H : O < H ? O : H, G = h > o ? h > f ? h : f : o > f ? o : f, L = b > O ? b > H ? b : H : O > H ? O : H;
          let F = s.next;
          for (; F !== e; ) {
            if (F.x >= y && F.x <= G && F.y >= B && F.y <= L && Uu(h, b, o, O, f, H, F.x, F.y) && g(F.prev, F, F.next) >= 0) return !1;
            F = F.next;
          }
          return !0;
        }
        function Sd(a, e, r, s) {
          const h = a.prev, o = a, f = a.next;
          if (g(h, o, f) >= 0) return !1;
          const b = h.x, O = o.x, H = f.x, y = h.y, B = o.y, G = f.y, L = b < O ? b < H ? b : H : O < H ? O : H, F = y < B ? y < G ? y : G : B < G ? B : G, Y = b > O ? b > H ? b : H : O > H ? O : H, ce = y > B ? y > G ? y : G : B > G ? B : G, _e = ah(L, F, e, r, s), ze = ah(Y, ce, e, r, s);
          let Ne = a.prevZ, Ee = a.nextZ;
          for (; Ne && Ne.z >= _e && Ee && Ee.z <= ze; ) {
            if (Ne.x >= L && Ne.x <= Y && Ne.y >= F && Ne.y <= ce && Ne !== h && Ne !== f && Uu(b, y, O, B, H, G, Ne.x, Ne.y) && g(Ne.prev, Ne, Ne.next) >= 0 || (Ne = Ne.prevZ, Ee.x >= L && Ee.x <= Y && Ee.y >= F && Ee.y <= ce && Ee !== h && Ee !== f && Uu(b, y, O, B, H, G, Ee.x, Ee.y) && g(Ee.prev, Ee, Ee.next) >= 0)) return !1;
            Ee = Ee.nextZ;
          }
          for (; Ne && Ne.z >= _e; ) {
            if (Ne.x >= L && Ne.x <= Y && Ne.y >= F && Ne.y <= ce && Ne !== h && Ne !== f && Uu(b, y, O, B, H, G, Ne.x, Ne.y) && g(Ne.prev, Ne, Ne.next) >= 0) return !1;
            Ne = Ne.prevZ;
          }
          for (; Ee && Ee.z <= ze; ) {
            if (Ee.x >= L && Ee.x <= Y && Ee.y >= F && Ee.y <= ce && Ee !== h && Ee !== f && Uu(b, y, O, B, H, G, Ee.x, Ee.y) && g(Ee.prev, Ee, Ee.next) >= 0) return !1;
            Ee = Ee.nextZ;
          }
          return !0;
        }
        function $f(a, e) {
          let r = a;
          do {
            const s = r.prev, h = r.next.next;
            !$(s, h) && he(s, r, r.next, h) && Vt(s, h) && Vt(h, s) && (e.push(s.i, r.i, h.i), $i(r), $i(r.next), r = a = h), r = r.next;
          } while (r !== a);
          return Tc(r);
        }
        function lp(a, e, r, s, h, o) {
          let f = a;
          do {
            let b = f.next.next;
            for (; b !== f.prev; ) {
              if (f.i !== b.i && d(f, b)) {
                let O = bi(f, b);
                return f = Tc(f, f.next), O = Tc(O, O.next), nh(f, e, r, s, h, o, 0), void nh(O, e, r, s, h, o, 0);
              }
              b = b.next;
            }
            f = f.next;
          } while (f !== a);
        }
        function sm(a, e) {
          return a.x - e.x;
        }
        function Xf(a, e) {
          const r = function(h, o) {
            let f = o;
            const b = h.x, O = h.y;
            let H, y = -1 / 0;
            do {
              if (O <= f.y && O >= f.next.y && f.next.y !== f.y) {
                const Y = f.x + (O - f.y) * (f.next.x - f.x) / (f.next.y - f.y);
                if (Y <= b && Y > y && (y = Y, H = f.x < f.next.x ? f : f.next, Y === b)) return H;
              }
              f = f.next;
            } while (f !== o);
            if (!H) return null;
            const B = H, G = H.x, L = H.y;
            let F = 1 / 0;
            f = H;
            do {
              if (b >= f.x && f.x >= G && b !== f.x && Uu(O < L ? b : y, O, G, L, O < L ? y : b, O, f.x, f.y)) {
                const Y = Math.abs(O - f.y) / (b - f.x);
                Vt(f, h) && (Y < F || Y === F && (f.x > H.x || f.x === H.x && om(H, f))) && (H = f, F = Y);
              }
              f = f.next;
            } while (f !== B);
            return H;
          }(a, e);
          if (!r) return e;
          const s = bi(r, a);
          return Tc(s, s.next), Tc(r, r.next);
        }
        function om(a, e) {
          return g(a.prev, a, e.prev) < 0 && g(e.next, a, a.next) < 0;
        }
        function ah(a, e, r, s, h) {
          return (a = 1431655765 & ((a = 858993459 & ((a = 252645135 & ((a = 16711935 & ((a = (a - r) * h | 0) | a << 8)) | a << 4)) | a << 2)) | a << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - s) * h | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
        }
        function lm(a) {
          let e = a, r = a;
          do
            (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;
          while (e !== a);
          return r;
        }
        function Uu(a, e, r, s, h, o, f, b) {
          return (h - f) * (e - b) >= (a - f) * (o - b) && (a - f) * (s - b) >= (r - f) * (e - b) && (r - f) * (o - b) >= (h - f) * (s - b);
        }
        function d(a, e) {
          return a.next.i !== e.i && a.prev.i !== e.i && !function(r, s) {
            let h = r;
            do {
              if (h.i !== r.i && h.next.i !== r.i && h.i !== s.i && h.next.i !== s.i && he(h, h.next, r, s)) return !0;
              h = h.next;
            } while (h !== r);
            return !1;
          }(a, e) && (Vt(a, e) && Vt(e, a) && function(r, s) {
            let h = r, o = !1;
            const f = (r.x + s.x) / 2, b = (r.y + s.y) / 2;
            do
              h.y > b != h.next.y > b && h.next.y !== h.y && f < (h.next.x - h.x) * (b - h.y) / (h.next.y - h.y) + h.x && (o = !o), h = h.next;
            while (h !== r);
            return o;
          }(a, e) && (g(a.prev, a, e.prev) || g(a, e.prev, e)) || $(a, e) && g(a.prev, a, a.next) > 0 && g(e.prev, e, e.next) > 0);
        }
        function g(a, e, r) {
          return (e.y - a.y) * (r.x - e.x) - (e.x - a.x) * (r.y - e.y);
        }
        function $(a, e) {
          return a.x === e.x && a.y === e.y;
        }
        function he(a, e, r, s) {
          const h = ot(g(a, e, r)), o = ot(g(a, e, s)), f = ot(g(r, s, a)), b = ot(g(r, s, e));
          return h !== o && f !== b || !(h !== 0 || !je(a, r, e)) || !(o !== 0 || !je(a, s, e)) || !(f !== 0 || !je(r, a, s)) || !(b !== 0 || !je(r, e, s));
        }
        function je(a, e, r) {
          return e.x <= Math.max(a.x, r.x) && e.x >= Math.min(a.x, r.x) && e.y <= Math.max(a.y, r.y) && e.y >= Math.min(a.y, r.y);
        }
        function ot(a) {
          return a > 0 ? 1 : a < 0 ? -1 : 0;
        }
        function Vt(a, e) {
          return g(a.prev, a, a.next) < 0 ? g(a, e, a.next) >= 0 && g(a, a.prev, e) >= 0 : g(a, e, a.prev) < 0 || g(a, a.next, e) < 0;
        }
        function bi(a, e) {
          const r = gr(a.i, a.x, a.y), s = gr(e.i, e.x, e.y), h = a.next, o = e.prev;
          return a.next = e, e.prev = a, r.next = h, h.prev = r, s.next = r, r.prev = s, o.next = s, s.prev = o, s;
        }
        function Ii(a, e, r, s) {
          const h = gr(a, e, r);
          return s ? (h.next = s.next, h.prev = s, s.next.prev = h, s.next = h) : (h.prev = h, h.next = h), h;
        }
        function $i(a) {
          a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ);
        }
        function gr(a, e, r) {
          return { i: a, x: e, y: r, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        function yr(a, e) {
          const r = a.length;
          if (r <= 1) return [a];
          const s = [];
          let h, o;
          for (let f = 0; f < r; f++) {
            const b = at(a[f]);
            b !== 0 && (a[f].area = Math.abs(b), o === void 0 && (o = b < 0), o === b < 0 ? (h && s.push(h), h = [a[f]]) : h.push(a[f]));
          }
          if (h && s.push(h), e > 1) for (let f = 0; f < s.length; f++) s[f].length <= e || (su(s[f], e, 1, s[f].length - 1, vr), s[f] = s[f].slice(0, e));
          return s;
        }
        function vr(a, e) {
          return e.area - a.area;
        }
        function Vr(a, e, r = 1) {
          if (!a) return null;
          const s = typeof a == "string" ? a : a.getPrimary().id;
          e[s] || (e[s] = []);
          const h = Ua.from(s).getPrimary().scaleSelf(r);
          return e[s].push(h), h.serialize();
        }
        function jr(a, e, r, s) {
          const h = s.patternDependencies;
          let o = !1;
          for (const f of e) {
            const b = f.paint.get(`${a}-pattern`);
            b.isConstant() || (o = !0), Vr(b.constantOr(null), h, r) && (o = !0);
          }
          return o;
        }
        function qr(a, e, r, s, h, o) {
          const f = o.patternDependencies;
          for (const b of e) {
            const O = b.paint.get(`${a}-pattern`).value;
            if (O.kind !== "constant") {
              let H = O.evaluate({ zoom: s }, r, {}, o.availableImages);
              H = H && H.name ? H.name : H;
              const y = Vr(H, f, h);
              y && (r.patterns[b.id] = y);
            }
          }
          return r;
        }
        class qa {
          constructor(e) {
            this.zoom = e.zoom, this.pixelRatio = e.pixelRatio, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((r) => r.fqid), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Ds(), this.indexArray = new Ya(), this.indexArray2 = new rs(), this.programConfigurations = new Cl(e.layers, { zoom: e.zoom, lut: e.lut }), this.segments = new Ea(), this.segments2 = new Ea(), this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id), this.projection = e.projection;
          }
          updateFootprints(e, r) {
          }
          populate(e, r, s, h) {
            this.hasPattern = jr("fill", this.layers, this.pixelRatio, r);
            const o = this.layers[0].layout.get("fill-sort-key"), f = [];
            for (const { feature: b, id: O, index: H, sourceLayerIndex: y } of e) {
              const B = this.layers[0]._featureFilter.needGeometry, G = ve(b, B);
              if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), G, s)) continue;
              const L = o ? o.evaluate(G, {}, s, r.availableImages) : void 0, F = { id: O, properties: b.properties, type: b.type, sourceLayerIndex: y, index: H, geometry: B ? G.geometry : oe(b, s, h), patterns: {}, sortKey: L };
              f.push(F);
            }
            o && f.sort((b, O) => b.sortKey - O.sortKey);
            for (const b of f) {
              const { geometry: O, index: H, sourceLayerIndex: y } = b;
              if (this.hasPattern) {
                const B = qr("fill", this.layers, b, this.zoom, this.pixelRatio, r);
                this.patternFeatures.push(B);
              } else this.addFeature(b, O, H, s, {}, r.availableImages, r.brightness, r.elevationFeatures);
              r.featureIndex.insert(e[H].feature, O, H, y, this.index);
            }
          }
          update(e, r, s, h, o, f, b) {
            this.programConfigurations.updatePaintArrays(e, r, o, s, h, f, b);
          }
          addFeatures(e, r, s, h, o, f) {
            for (const b of this.patternFeatures) this.addFeature(b, b.geometry, b.index, r, s, h, f, e.elevationFeatures);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, qf), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(e, r, s, h, o, f = [], b, O) {
            for (const H of yr(r, 500)) {
              let y = 0;
              for (const ce of H) y += ce.length;
              const B = this.segments.prepareSegment(y, this.layoutVertexArray, this.indexArray), G = B.vertexLength, L = [], F = [];
              for (const ce of H) {
                if (ce.length === 0) continue;
                ce !== H[0] && F.push(L.length / 2);
                const _e = this.segments2.prepareSegment(ce.length, this.layoutVertexArray, this.indexArray2), ze = _e.vertexLength;
                this.layoutVertexArray.emplaceBack(ce[0].x, ce[0].y), this.indexArray2.emplaceBack(ze + ce.length - 1, ze), L.push(ce[0].x), L.push(ce[0].y);
                for (let Ne = 1; Ne < ce.length; Ne++) this.layoutVertexArray.emplaceBack(ce[Ne].x, ce[Ne].y), this.indexArray2.emplaceBack(ze + Ne - 1, ze + Ne), L.push(ce[Ne].x), L.push(ce[Ne].y);
                _e.vertexLength += ce.length, _e.primitiveLength += ce.length;
              }
              const Y = Nh(L, F);
              for (let ce = 0; ce < Y.length; ce += 3) this.indexArray.emplaceBack(G + Y[ce], G + Y[ce + 1], G + Y[ce + 2]);
              B.vertexLength += y, B.primitiveLength += Y.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, s, o, f, h, b);
          }
        }
        let Vi, Li, Wi, Cr;
        ur(qa, "FillBucket", { omit: ["layers", "patternFeatures"] });
        class Zr {
          constructor(e, r, s, h) {
            if (this.triangleCount = r.length / 3, this.min = new At(0, 0), this.max = new At(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], this.triangleCount === 0 || e.length === 0) return;
            const [o, f] = [e[0].clone(), e[0].clone()];
            for (let B = 1; B < e.length; ++B) {
              const G = e[B];
              o.x = Math.min(o.x, G.x), o.y = Math.min(o.y, G.y), f.x = Math.max(f.x, G.x), f.y = Math.max(f.y, G.y);
            }
            if (h) {
              const B = Math.ceil(Math.max(f.x - o.x, f.y - o.y) / h);
              s = Math.max(s, B);
            }
            if (s === 0) return;
            this.min = o, this.max = f;
            const b = this.max.sub(this.min);
            b.x = Math.max(b.x, 1), b.y = Math.max(b.y, 1);
            const O = Math.max(b.x, b.y) / s;
            this.cellsX = Math.max(1, Math.ceil(b.x / O)), this.cellsY = Math.max(1, Math.ceil(b.y / O)), this.xScale = 1 / O, this.yScale = 1 / O;
            const H = [];
            for (let B = 0; B < this.triangleCount; B++) {
              const G = e[r[3 * B + 0]].sub(this.min), L = e[r[3 * B + 1]].sub(this.min), F = e[r[3 * B + 2]].sub(this.min), Y = $r(Math.floor(Math.min(G.x, L.x, F.x)), this.xScale, this.cellsX), ce = $r(Math.floor(Math.max(G.x, L.x, F.x)), this.xScale, this.cellsX), _e = $r(Math.floor(Math.min(G.y, L.y, F.y)), this.yScale, this.cellsY), ze = $r(Math.floor(Math.max(G.y, L.y, F.y)), this.yScale, this.cellsY), Ne = new At(0, 0), Ee = new At(0, 0), We = new At(0, 0), lt = new At(0, 0);
              for (let yt = _e; yt <= ze; ++yt) {
                Ne.y = Ee.y = yt * O, We.y = lt.y = (yt + 1) * O;
                for (let Bt = Y; Bt <= ce; ++Bt) Ne.x = We.x = Bt * O, Ee.x = lt.x = (Bt + 1) * O, (xi(G, L, F, Ne, Ee, lt) || xi(G, L, F, Ne, lt, We)) && H.push({ cellIdx: yt * this.cellsX + Bt, triIdx: B });
              }
            }
            if (H.length === 0) return;
            H.sort((B, G) => B.cellIdx - G.cellIdx || B.triIdx - G.triIdx);
            let y = 0;
            for (; y < H.length; ) {
              const B = H[y].cellIdx, G = { start: this.payload.length, len: 0 };
              for (; y < H.length && H[y].cellIdx === B; ) ++G.len, this.payload.push(H[y++].triIdx);
              this.cells[B] = G;
            }
          }
          _lazyInitLookup() {
            this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
          }
          queryPoint(e, r) {
            if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > e.x || e.y > this.max.y || this.min.y > e.y) return;
            const s = $r(e.x - this.min.x, this.xScale, this.cellsX), h = $r(e.y - this.min.y, this.yScale, this.cellsY), o = this.cells[h * this.cellsX + s];
            if (o) {
              this._lazyInitLookup();
              for (let f = 0; f < o.len; f++) {
                const b = this.payload[o.start + f], O = Math.floor(b / 8), H = 1 << b % 8;
                if (!(this.lookup[O] & H) && (this.lookup[O] |= H, r.push(b), r.length === this.triangleCount)) return;
              }
            }
          }
          query(e, r, s) {
            if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > r.x || e.y > this.max.y || this.min.y > r.y) return;
            this._lazyInitLookup();
            const h = $r(e.x - this.min.x, this.xScale, this.cellsX), o = $r(r.x - this.min.x, this.xScale, this.cellsX), f = $r(e.y - this.min.y, this.yScale, this.cellsY), b = $r(r.y - this.min.y, this.yScale, this.cellsY);
            for (let O = f; O <= b; O++) for (let H = h; H <= o; H++) {
              const y = this.cells[O * this.cellsX + H];
              if (y) for (let B = 0; B < y.len; B++) {
                const G = this.payload[y.start + B], L = Math.floor(G / 8), F = 1 << G % 8;
                if (!(this.lookup[L] & F) && (this.lookup[L] |= F, s.push(G), s.length === this.triangleCount)) return;
              }
            }
          }
        }
        function $r(a, e, r) {
          return Math.max(0, Math.min(r - 1, Math.floor(a * e)));
        }
        ur(Zr, "TriangleGridIndex");
        class un {
          constructor(e) {
            this.zoom = e.zoom, this.layers = e.layers, this.layerIds = this.layers.map((r) => r.fqid), this.index = e.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id), this.footprints = [];
          }
          updateFootprints(e, r) {
            for (const s of this.footprints) r.push({ footprint: s, id: e });
          }
          populate(e, r, s, h) {
            const o = [];
            for (const { feature: f, id: b, index: O, sourceLayerIndex: H } of e) {
              const y = this.layers[0]._featureFilter.needGeometry, B = ve(f, y);
              if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), B, s)) continue;
              const G = { id: b, properties: f.properties, type: f.type, sourceLayerIndex: H, index: O, geometry: y ? B.geometry : oe(f, s, h), patterns: {} };
              o.push(G);
            }
            for (const f of o) {
              const { geometry: b, index: O, sourceLayerIndex: H } = f;
              this.addFeature(f, b, O, s, {}, r.availableImages, r.brightness), r.featureIndex.insert(e[O].feature, b, O, H, this.index);
            }
          }
          isEmpty() {
            return this.footprints.length === 0;
          }
          uploadPending() {
            return !1;
          }
          upload(e) {
          }
          update(e, r, s, h, o, f, b) {
          }
          destroy() {
          }
          addFeature(e, r, s, h, o, f = [], b) {
            for (const O of yr(r, 2)) {
              const H = [], y = [], B = [], G = new At(1 / 0, 1 / 0), L = new At(-1 / 0, -1 / 0);
              for (const ce of O) if (ce.length !== 0) {
                ce !== O[0] && B.push(y.length / 2);
                for (let _e = 0; _e < ce.length; _e++) y.push(ce[_e].x), y.push(ce[_e].y), H.push(ce[_e]), G.x = Math.min(G.x, ce[_e].x), G.y = Math.min(G.y, ce[_e].y), L.x = Math.max(L.x, ce[_e].x), L.y = Math.max(L.y, ce[_e].y);
              }
              const F = Nh(y, B), Y = new Zr(H, F, 8, 256);
              this.footprints.push({ vertices: H, indices: F, grid: Y, min: G, max: L });
            }
          }
        }
        ur(un, "ClipBucket", { omit: ["layers"] });
        const vn = dn([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), As = dn([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), Kn = dn([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Cc = dn([{ name: "a_join_normal_inside", components: 3, type: "Int16" }]), um = dn([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), px = dn([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: mx } = vn;
        var cm, Cg, hm, Ag, fm, Mg, Ig, up = {};
        function Pg() {
          if (Cg) return cm;
          Cg = 1;
          var a = Qt();
          function e(h, o, f, b, O) {
            this.properties = {}, this.extent = f, this.type = 0, this._pbf = h, this._geometry = -1, this._keys = b, this._values = O, h.readFields(r, this, o);
          }
          function r(h, o, f) {
            h == 1 ? o.id = f.readVarint() : h == 2 ? function(b, O) {
              for (var H = b.readVarint() + b.pos; b.pos < H; ) {
                var y = O._keys[b.readVarint()], B = O._values[b.readVarint()];
                O.properties[y] = B;
              }
            }(f, o) : h == 3 ? o.type = f.readVarint() : h == 4 && (o._geometry = f.pos);
          }
          function s(h) {
            for (var o, f, b = 0, O = 0, H = h.length, y = H - 1; O < H; y = O++) b += ((f = h[y]).x - (o = h[O]).x) * (o.y + f.y);
            return b;
          }
          return cm = e, e.types = ["Unknown", "Point", "LineString", "Polygon"], e.prototype.loadGeometry = function() {
            var h = this._pbf;
            h.pos = this._geometry;
            for (var o, f = h.readVarint() + h.pos, b = 1, O = 0, H = 0, y = 0, B = []; h.pos < f; ) {
              if (O <= 0) {
                var G = h.readVarint();
                b = 7 & G, O = G >> 3;
              }
              if (O--, b === 1 || b === 2) H += h.readSVarint(), y += h.readSVarint(), b === 1 && (o && B.push(o), o = []), o.push(new a(H, y));
              else {
                if (b !== 7) throw new Error("unknown command " + b);
                o && o.push(o[0].clone());
              }
            }
            return o && B.push(o), B;
          }, e.prototype.bbox = function() {
            var h = this._pbf;
            h.pos = this._geometry;
            for (var o = h.readVarint() + h.pos, f = 1, b = 0, O = 0, H = 0, y = 1 / 0, B = -1 / 0, G = 1 / 0, L = -1 / 0; h.pos < o; ) {
              if (b <= 0) {
                var F = h.readVarint();
                f = 7 & F, b = F >> 3;
              }
              if (b--, f === 1 || f === 2) (O += h.readSVarint()) < y && (y = O), O > B && (B = O), (H += h.readSVarint()) < G && (G = H), H > L && (L = H);
              else if (f !== 7) throw new Error("unknown command " + f);
            }
            return [y, G, B, L];
          }, e.prototype.toGeoJSON = function(h, o, f) {
            var b, O, H = this.extent * Math.pow(2, f), y = this.extent * h, B = this.extent * o, G = this.loadGeometry(), L = e.types[this.type];
            function F(_e) {
              for (var ze = 0; ze < _e.length; ze++) {
                var Ne = _e[ze];
                _e[ze] = [360 * (Ne.x + y) / H - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (Ne.y + B) / H) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var Y = [];
                for (b = 0; b < G.length; b++) Y[b] = G[b][0];
                F(G = Y);
                break;
              case 2:
                for (b = 0; b < G.length; b++) F(G[b]);
                break;
              case 3:
                for (G = function(_e) {
                  var ze = _e.length;
                  if (ze <= 1) return [_e];
                  for (var Ne, Ee, We = [], lt = 0; lt < ze; lt++) {
                    var yt = s(_e[lt]);
                    yt !== 0 && (Ee === void 0 && (Ee = yt < 0), Ee === yt < 0 ? (Ne && We.push(Ne), Ne = [_e[lt]]) : Ne.push(_e[lt]));
                  }
                  return Ne && We.push(Ne), We;
                }(G), b = 0; b < G.length; b++) for (O = 0; O < G[b].length; O++) F(G[b][O]);
            }
            G.length === 1 ? G = G[0] : L = "Multi" + L;
            var ce = { type: "Feature", geometry: { type: L, coordinates: G }, properties: this.properties };
            return "id" in this && (ce.id = this.id), ce;
          }, cm;
        }
        function Rg() {
          if (Ag) return hm;
          Ag = 1;
          var a = Pg();
          function e(s, h) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = s, this._keys = [], this._values = [], this._features = [], s.readFields(r, this, h), this.length = this._features.length;
          }
          function r(s, h, o) {
            s === 15 ? h.version = o.readVarint() : s === 1 ? h.name = o.readString() : s === 5 ? h.extent = o.readVarint() : s === 2 ? h._features.push(o.pos) : s === 3 ? h._keys.push(o.readString()) : s === 4 && h._values.push(function(f) {
              for (var b = null, O = f.readVarint() + f.pos; f.pos < O; ) {
                var H = f.readVarint() >> 3;
                b = H === 1 ? f.readString() : H === 2 ? f.readFloat() : H === 3 ? f.readDouble() : H === 4 ? f.readVarint64() : H === 5 ? f.readVarint() : H === 6 ? f.readSVarint() : H === 7 ? f.readBoolean() : null;
              }
              return b;
            }(o));
          }
          return hm = e, e.prototype.feature = function(s) {
            if (s < 0 || s >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[s];
            var h = this._pbf.readVarint() + this._pbf.pos;
            return new a(this._pbf, h, this.extent, this._keys, this._values);
          }, hm;
        }
        function kg() {
          return Ig || (Ig = 1, up.VectorTile = function() {
            if (Mg) return fm;
            Mg = 1;
            var a = Rg();
            function e(r, s, h) {
              if (r === 3) {
                var o = new a(h, h.readVarint() + h.pos);
                o.length && (s[o.name] = o);
              }
            }
            return fm = function(r, s) {
              this.layers = r.readFields(e, {}, s);
            }, fm;
          }(), up.VectorTileFeature = Pg(), up.VectorTileLayer = Rg()), up;
        }
        var Yf = kg();
        class bf extends At {
          constructor(e, r, s) {
            super(e, r), this.z = s;
          }
        }
        class Lg extends bf {
          constructor(e, r, s, h) {
            super(e, r, s), this.w = h;
          }
        }
        function cp(a, e, r, s) {
          const h = [], o = s === 0 ? (f, b, O, H, y, B) => {
            f.push(new At(B, O + (B - b) / (H - b) * (y - O)));
          } : (f, b, O, H, y, B) => {
            f.push(new At(b + (B - O) / (y - O) * (H - b), B));
          };
          for (const f of a) {
            const b = [];
            for (const O of f) {
              if (O.length <= 2) continue;
              const H = [];
              for (let G = 0; G < O.length - 1; G++) {
                const L = O[G].x, F = O[G].y, Y = O[G + 1].x, ce = O[G + 1].y, _e = s === 0 ? L : F, ze = s === 0 ? Y : ce;
                _e < e ? ze > e && o(H, L, F, Y, ce, e) : _e > r ? ze < r && o(H, L, F, Y, ce, r) : H.push(O[G]), ze < e && _e >= e && o(H, L, F, Y, ce, e), ze > r && _e <= r && o(H, L, F, Y, ce, r);
              }
              let y = O[O.length - 1];
              const B = s === 0 ? y.x : y.y;
              B >= e && B <= r && H.push(y), H.length && (y = H[H.length - 1], H[0].x === y.x && H[0].y === y.y || H.push(H[0]), b.push(H));
            }
            b.length && h.push(b);
          }
          return h;
        }
        function Og(a, e, r, s) {
          const h = r === "x" ? "y" : "x", o = (s - a[r]) / (e[r] - a[r]);
          a[h] = a[h] + (e[h] - a[h]) * o, a[r] = s, a.hasOwnProperty("z") && (a.z = Tr(a.z, e.z, o)), a.hasOwnProperty("w") && (a.w = Tr(a.w, e.w, o));
        }
        function Dg(a, e, r, s) {
          const h = r, o = s;
          for (const f of ["x", "y"]) {
            let b = a, O = e;
            b[f] >= O[f] && (b = e, O = a), b[f] < h && O[f] > h && Og(b, O, f, h), b[f] < o && O[f] > o && Og(O, b, f, o);
          }
        }
        const hp = Number.MAX_SAFE_INTEGER;
        function zg(a, e, r, s) {
          return a.order < e || a.order === hp || !(a.clipMask & r) || function(h, o) {
            return o.length !== 0 && o.find((f) => f === h) === void 0;
          }(s, a.clipScope);
        }
        function fp(a, e) {
          return a.x - e.x || a.y - e.y;
        }
        function Bg(a, e) {
          return fp(a.min, e.min) === 0 && fp(a.max, e.max) === 0;
        }
        function dm(a, e) {
          return !(a.min.x > e.max.x || a.max.x < e.min.x || a.min.y > e.max.y || a.max.y < e.min.y);
        }
        function pm(a, e) {
          if (a.length !== e.length) return !1;
          for (let r = 0; r < a.length; r++) if (a[r].sourceId !== e[r].sourceId || !Bg(a[r], e[r]) || a[r].order !== e[r].order || a[r].clipMask !== e[r].clipMask || !St(a[r].clipScope, e[r].clipScope)) return !1;
          return !0;
        }
        function Fg(a, e, r) {
          const s = 1 / tr, h = 1 / (1 << r.canonical.z), o = (e.x * s + r.canonical.x) * h + r.wrap, f = (e.y * s + r.canonical.y) * h;
          return { min: new At((a.x * s + r.canonical.x) * h + r.wrap, (a.y * s + r.canonical.y) * h), max: new At(o, f) };
        }
        function _x(a, e, r) {
          const s = 1 << r.canonical.z, h = ((e.x - r.wrap) * s - r.canonical.x) * tr, o = (e.y * s - r.canonical.y) * tr;
          return { min: new At(((a.x - r.wrap) * s - r.canonical.x) * tr, (a.y * s - r.canonical.y) * tr), max: new At(h, o) };
        }
        function Ng(a, e, r, s, h, o, f) {
          const b = a.indices, O = a.vertices, H = [];
          for (let y = s; y < s + h; y += 3) {
            const B = e[r[y + 0] + o], G = e[r[y + 1] + o], L = e[r[y + 2] + o], F = Math.min(B.x, G.x, L.x), Y = Math.max(B.x, G.x, L.x), ce = Math.min(B.y, G.y, L.y), _e = Math.max(B.y, G.y, L.y);
            H.length = 0, a.grid.query(new At(F, ce), new At(Y, _e), H);
            for (let ze = 0; ze < H.length; ze++) {
              const Ne = H[ze];
              if (xi(O[b[3 * Ne + 0]], O[b[3 * Ne + 1]], O[b[3 * Ne + 2]], B, G, L, f)) return !0;
            }
          }
          return !1;
        }
        function Ug(a, e, r, s) {
          if (!a || !r) return !1;
          let h = a.vertices;
          if (!e.canonical.equals(s.canonical) || e.wrap !== s.wrap) {
            if (r.vertices.length < a.vertices.length) return Ug(r, s, a, e);
            const o = e.canonical, f = s.canonical, b = Math.pow(2, f.z - o.z);
            h = a.vertices.map((O) => new At((O.x + o.x * tr) * b - f.x * tr, (O.y + o.y * tr) * b - f.y * tr));
          }
          return Ng(r, h, a.indices, 0, a.indices.length, 0, 0);
        }
        function Vg(a, e, r, s) {
          const h = Math.pow(2, s.z - r.z);
          return new At((a + r.x * tr) * h - s.x * tr, (e + r.y * tr) * h - s.y * tr);
        }
        function jg(a, e) {
          const r = [];
          e.grid.queryPoint(a, r);
          const s = e.indices, h = e.vertices;
          for (let o = 0; o < r.length; o++) {
            const f = r[o];
            if (Zt([h[s[3 * f + 0]], h[s[3 * f + 1]], h[s[3 * f + 2]]], a)) return !0;
          }
          return !1;
        }
        const mm = [new At(0, 0), new At(tr, 0), new At(tr, tr), new At(0, tr)];
        function Gg(a, e) {
          const r = [];
          let s = [];
          if (!e || a.length < 2) return [a];
          if (a.length === 2) return ui(a[0], a[1], mm) ? [a] : [];
          for (let h = 0; h < a.length + 2; h++) {
            const o = a[h % a.length], f = a[(h + 1) % a.length], b = ui(h === 0 ? a[a.length - 1] : a[(h - 1) % a.length], o, mm), O = ui(o, f, mm), H = b || O;
            H && s.push(o), H && O || s.length > 0 && (s.length > 1 && r.push(s), s = []);
          }
          return s.length > 1 && r.push(s), r;
        }
        const _m = Yf.VectorTileFeature.types, gx = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"], vx = ["fill-extrusion-flood-light-ground-radius"], yx = Math.pow(2, 13), xx = Math.pow(2, 15) - 1, Hg = new At(0, 1), Uh = 2147483648;
        function Ed(a, e, r, s, h, o, f, b) {
          a.emplaceBack((e << 1) + f, (r << 1) + o, (Math.floor(s * yx) << 1) + h, Math.round(b));
        }
        function Td(a, e, r) {
          a.emplaceBack(e.x * tr, e.y * tr, r ? 1 : 0);
        }
        function dp(a, e, r, s, h, o) {
          a.emplaceBack(e.x, e.y, (r.x << 1) + s, (r.y << 1) + h, o);
        }
        function Cd(a, e, r) {
          a.emplaceBack(e.x, e.y, e.z, r[0] * 16384, r[1] * 16384, r[2] * 16384);
        }
        class qg {
          constructor() {
            this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
          }
        }
        class Wg {
          constructor() {
            this.centroidXY = new At(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new At(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new At(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
          }
          span() {
            return new At(this.max.x - this.min.x, this.max.y - this.min.y);
          }
        }
        class Zg {
          constructor() {
            this.acc = new At(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
          }
          startRing(e, r) {
            e.min.x === Number.MAX_VALUE && (e.min.x = e.max.x = r.x, e.min.y = e.max.y = r.y);
          }
          appendEdge(e, r, s) {
            this.accCount++, this.acc._add(r);
            let h = !!this.borders;
            r.x < e.min.x ? (e.min.x = r.x, h = !0) : r.x > e.max.x && (e.max.x = r.x, h = !0), r.y < e.min.y ? (e.min.y = r.y, h = !0) : r.y > e.max.y && (e.max.y = r.y, h = !0), ((r.x === 0 || r.x === tr) && r.x === s.x) != ((r.y === 0 || r.y === tr) && r.y === s.y) && this.processBorderOverlap(r, s), h && this.checkBorderIntersection(r, s);
          }
          checkBorderIntersection(e, r) {
            r.x < 0 != e.x < 0 && this.addBorderIntersection(0, Tr(r.y, e.y, (0 - r.x) / (e.x - r.x))), r.x > tr != e.x > tr && this.addBorderIntersection(1, Tr(r.y, e.y, (tr - r.x) / (e.x - r.x))), r.y < 0 != e.y < 0 && this.addBorderIntersection(2, Tr(r.x, e.x, (0 - r.y) / (e.y - r.y))), r.y > tr != e.y > tr && this.addBorderIntersection(3, Tr(r.x, e.x, (tr - r.y) / (e.y - r.y)));
          }
          addBorderIntersection(e, r) {
            this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
            const s = this.borders[e];
            r < s[0] && (s[0] = r), r > s[1] && (s[1] = r);
          }
          processBorderOverlap(e, r) {
            if (e.x === r.x) {
              if (e.y === r.y) return;
              const s = e.x === 0 ? 0 : 1;
              this.addBorderIntersection(s, r.y), this.addBorderIntersection(s, e.y);
            } else {
              const s = e.y === 0 ? 2 : 3;
              this.addBorderIntersection(s, r.x), this.addBorderIntersection(s, e.x);
            }
          }
          centroid() {
            return this.accCount === 0 ? new At(0, 0) : new At(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
          }
          intersectsCount() {
            return this.borders ? this.borders.reduce((e, r) => e + +(r[0] !== Number.MAX_VALUE), 0) : 0;
          }
        }
        function $g(a, e) {
          const r = a.add(e)._unit(), s = pe(a.x * r.x + a.y * r.y, -1, 1);
          var h, o, f;
          return f = Math.acos(s), Math.min(4, Math.max(-4, Math.tan(f))) / 4 * xx * ((h = a).x * (o = e).y - h.y * o.x < 0 ? -1 : 1);
        }
        const bx = [(a) => a.x < 0, (a) => a.x > tr, (a) => a.y < 0, (a) => a.y > tr];
        function wx(a, e, r, s) {
          const h = [4];
          if (s === 0) return h;
          r._mult(s);
          const o = a.sub(r), f = e.sub(r), b = [a, e, o, f];
          for (let O = 0; O < 4; O++) for (const H of b) if (bx[O](H)) {
            h.push(O);
            break;
          }
          return h;
        }
        class Xg {
          constructor(e) {
            this.vertexArray = new ja(), this.indexArray = new Ya(), this.programConfigurations = new Cl(e.layers, { zoom: e.zoom, lut: e.lut }, (r) => vx.includes(r)), this._segments = new Ea(), this.hiddenByLandmarkVertexArray = new Xc(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new Ea();
          }
          getDefaultSegment() {
            return this.regionSegments[4];
          }
          hasData() {
            return this.vertexArray.length !== 0;
          }
          addData(e, r, s, h = !1) {
            const o = e.length;
            if (o > 2) {
              let f = Math.max(0, this._segments.get().length - 1);
              const b = this._segments._prepareSegment(4 * o, this.vertexArray.length, 2 * this._segmentToGroundQuads[f].length);
              let O;
              f !== this._segments.get().length - 1 && (f++, this._segmentToGroundQuads[f] = [], this._segmentToRegionTriCounts[f] = [0, 0, 0, 0, 0]);
              {
                const H = e[0], y = e[1];
                O = $g(H.sub(e[o - 1])._perp()._unit(), y.sub(H)._perp()._unit());
              }
              for (let H = 0; H < o; H++) {
                const y = H === o - 1 ? 0 : H + 1, B = e[H], G = e[y], L = e[y === o - 1 ? 0 : y + 1], F = G.sub(B)._perp()._unit(), Y = $g(F, L.sub(G)._perp()._unit()), ce = O, _e = Y;
                if (gm(B, G, r) || h && Jg(B, r) && Jg(G, r)) {
                  O = Y;
                  continue;
                }
                const ze = b.vertexLength;
                dp(this.vertexArray, B, G, 1, 1, ce), dp(this.vertexArray, B, G, 1, 0, ce), dp(this.vertexArray, B, G, 0, 1, _e), dp(this.vertexArray, B, G, 0, 0, _e), b.vertexLength += 4;
                const Ne = wx(B, G, F, s);
                for (const Ee of Ne) this._segmentToGroundQuads[f].push({ id: ze, region: Ee }), this._segmentToRegionTriCounts[f][Ee] += 2, b.primitiveLength += 2;
                O = Y;
              }
            }
          }
          prepareBorderSegments() {
            if (!this.hasData()) return;
            const e = this._segments.get(), r = e.length;
            for (let s = 0; s < r; s++) this._segmentToGroundQuads[s].sort((h, o) => h.region - o.region);
            for (let s = 0; s < r; s++) {
              const h = this._segmentToGroundQuads[s], o = e[s], f = this._segmentToRegionTriCounts[s];
              f.reduce((O, H) => O + H, 0);
              let b = 0;
              for (let O = 0; O <= 4; O++) {
                const H = f[O];
                if (H !== 0) {
                  let y = this.regionSegments[O];
                  y || (y = this.regionSegments[O] = new Ea());
                  const B = { vertexOffset: o.vertexOffset, primitiveOffset: o.primitiveOffset + b, vertexLength: o.vertexLength, primitiveLength: H };
                  y.get().push(B);
                }
                b += H;
              }
              for (let O = 0; O < h.length; O++) {
                const H = h[O].id;
                this.indexArray.emplaceBack(H, H + 1, H + 3), this.indexArray.emplaceBack(H, H + 3, H + 2);
              }
            }
            this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
          }
          addPaintPropertiesData(e, r, s, h, o, f) {
            this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, e, r, s, h, o, f);
          }
          upload(e) {
            this.hasData() && (this.vertexBuffer = e.createVertexBuffer(this.vertexArray, As.members), this.indexBuffer = e.createIndexBuffer(this.indexArray));
          }
          uploadPaintProperties(e) {
            this.hasData() && this.programConfigurations.upload(e);
          }
          update(e, r, s, h, o, f, b) {
            this.hasData() && this.programConfigurations.updatePaintArrays(e, r, s, h, o, f, b);
          }
          updateHiddenByLandmark(e) {
            if (!this.hasData()) return;
            const r = e.groundVertexCount + e.groundVertexArrayOffset;
            if (e.groundVertexCount === 0) return;
            const s = e.flags & Uh ? 1 : 0;
            for (let h = e.groundVertexArrayOffset; h < r; ++h) this.hiddenByLandmarkVertexArray.emplace(h, s);
            this._needsHiddenByLandmarkUpdate = !0;
          }
          uploadHiddenByLandmark(e) {
            this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = e.createVertexBuffer(this.hiddenByLandmarkVertexArray, um.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);
          }
          destroy() {
            if (this.vertexBuffer) {
              this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
              for (let e = 0; e <= 4; e++) {
                const r = this.regionSegments[e];
                r && r.destroy();
              }
            }
          }
        }
        class pp {
          constructor(e) {
            this.zoom = e.zoom, this.canonical = e.canonical, this.overscaling = e.overscaling, this.layers = e.layers, this.pixelRatio = e.pixelRatio, this.layerIds = this.layers.map((r) => r.fqid), this.index = e.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = e.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Ya(), this.footprintVertices = new Ds(), this.footprintSegments = [], this.layoutVertexArray = new pa(), this.centroidVertexArray = new zs(), this.wallVertexArray = new pf(), this.indexArray = new Ya(), this.programConfigurations = new Cl(e.layers, { zoom: e.zoom, lut: e.lut }, (r) => gx.includes(r)), this.segments = new Ea(), this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id), this.groundEffect = new Xg(e), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
          }
          updateFootprints(e, r) {
          }
          populate(e, r, s, h) {
            this.features = [], this.hasPattern = jr("fill-extrusion", this.layers, this.pixelRatio, r), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this.tileToMeter = t(s), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1) !== 0;
            for (const { feature: o, id: f, index: b, sourceLayerIndex: O } of e) {
              const H = this.layers[0]._featureFilter.needGeometry, y = ve(o, H);
              if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), y, s)) continue;
              const B = { id: f, sourceLayerIndex: O, index: b, geometry: H ? y.geometry : oe(o, s, h), properties: o.properties, type: o.type, patterns: {} }, G = this.layoutVertexArray.length, L = _m[B.type] === "Polygon";
              if (this.hasPattern) this.features.push(qr("fill-extrusion", this.layers, B, this.zoom, this.pixelRatio, r));
              else if (this.wallMode) for (const F of B.geometry) for (const Y of Gg(F, L)) this.addFeature(B, [Y], b, s, {}, r.availableImages, h, r.brightness);
              else this.addFeature(B, B.geometry, b, s, {}, r.availableImages, h, r.brightness);
              r.featureIndex.insert(o, B.geometry, b, O, this.index, G);
            }
            this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
          }
          addFeatures(e, r, s, h, o, f) {
            for (const b of this.features) {
              const O = _m[b.type] === "Polygon", { geometry: H } = b;
              if (this.wallMode) for (const y of H) for (const B of Gg(y, O)) this.addFeature(b, [B], b.index, r, s, h, o, f);
              else this.addFeature(b, H, b.index, r, s, h, o, f);
            }
            this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles();
          }
          update(e, r, s, h, o, f, b) {
            this.programConfigurations.updatePaintArrays(e, r, o, s, h, f, b), this.groundEffect.update(e, r, o, s, h, f, b);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, mx), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.wallVertexBuffer = e.createVertexBuffer(this.wallVertexArray, Cc.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = e.createVertexBuffer(this.layoutVertexExtArray, px.members, !0)), this.groundEffect.upload(e)), this.groundEffect.uploadPaintProperties(e), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          uploadCentroid(e) {
            this.groundEffect.uploadHiddenByLandmark(e), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, Kn.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(e, r, s, h, o, f, b, O) {
            const H = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(e, {}) / this.tileToMeter, y = [new At(0, 0), new At(tr, tr)], B = b.projection, G = B.name === "globe", L = this.wallMode || _m[e.type] === "Polygon", F = new Zg();
            F.centroidDataIndex = this.centroidData.length;
            const Y = new Wg(), ce = this.layers[0].paint.get("fill-extrusion-base").evaluate(e, {}, h) <= 0, _e = this.layers[0].paint.get("fill-extrusion-height").evaluate(e, {}, h);
            let ze;
            if (Y.height = _e, Y.vertexArrayOffset = this.layoutVertexArray.length, Y.groundVertexArrayOffset = this.groundEffect.vertexArray.length, G && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Xa()), this.wallMode) {
              if (G) return void Se("Non zero fill-extrusion-line-width is not yet supported on globe.");
              if (r.length !== 1) return;
              ze = function(Dt) {
                const ni = Dt[0].x === Dt[Dt.length - 1].x && Dt[0].y === Dt[Dt.length - 1].y;
                (function(Qi) {
                  let qi = 0;
                  const xr = Qi.length;
                  for (let hr = 0; hr < xr; hr++) qi += (Qi[(hr + 1) % xr].x - Qi[hr].x) * (Qi[(hr + 1) % xr].y + Qi[hr].y);
                  return qi >= 0;
                })(Dt) || (Dt = Dt.reverse());
                const si = { geometry: [], joinNormals: [], indices: [] }, ci = [], li = [], fi = [];
                let gi = Dt.length;
                for (; gi >= 2 && Dt[gi - 1].equals(Dt[gi - 2]); ) gi--;
                if (gi < (ni ? 3 : 2)) return si;
                let Si, pi, zi, Gi, Oi, lr = 0;
                for (; lr < gi - 1 && Dt[lr].equals(Dt[lr + 1]); ) lr++;
                ni && (Si = Dt[gi - 2], Oi = Dt[lr].sub(Si)._unit()._perp());
                for (let Qi = lr; Qi < gi; Qi++) {
                  if (zi = Qi === gi - 1 ? ni ? Dt[lr + 1] : void 0 : Dt[Qi + 1], zi && Dt[Qi].equals(zi)) continue;
                  Oi && (Gi = Oi), Si && (pi = Si), Si = Dt[Qi], Oi = zi ? zi.sub(Si)._unit()._perp() : Gi, Gi = Gi || Oi;
                  let qi = Gi.add(Oi);
                  qi.x === 0 && qi.y === 0 || qi._unit();
                  const xr = qi.x * Oi.x + qi.y * Oi.y, hr = xr !== 0 ? 1 / xr : 1 / 0, pr = Gi.x * Oi.y - Gi.y * Oi.x > 0;
                  let Ur = "miter";
                  const Xr = 2;
                  Ur === "miter" && hr > Xr && (Ur = "bevel"), Ur === "bevel" && (hr > 100 && (Ur = "flipbevel"), hr < Xr && (Ur = "miter"));
                  const Yr = (Kr, sn, cn, Un) => {
                    const In = new At(Kr.x, Kr.y), Gr = new At(Kr.x, Kr.y);
                    In.x += sn.x * Un, In.y += sn.y * Un, Gr.x -= sn.x * Math.max(cn, 1), Gr.y -= sn.y * Math.max(cn, 1), fi.push(sn), ci.push(In), li.push(Gr);
                  };
                  if (Ur === "miter") qi._mult(hr), Yr(Si, qi, 0, 0);
                  else if (Ur === "flipbevel") qi = Oi.mult(-1), Yr(Si, qi, 0, 0), Yr(Si, qi.mult(-1), 0, 0);
                  else {
                    const Kr = -Math.sqrt(hr * hr - 1), sn = pr ? Kr : 0, cn = pr ? 0 : Kr;
                    pi && Yr(Si, Gi, sn, cn), zi && Yr(Si, Oi, sn, cn);
                  }
                }
                si.geometry = [...ci, ...li.reverse(), ci[0]], si.joinNormals = [...fi, ...fi.reverse(), fi[fi.length - 1]];
                const ar = si.geometry.length - 1;
                for (let Qi = 0; Qi < ar / 2; Qi++) if (Qi + 1 < ar / 2) {
                  let qi = Qi, xr = Qi + 1, hr = ar - 1 - Qi, pr = ar - 2 - Qi;
                  qi = qi === 0 ? ar - 1 : qi - 1, xr = xr === 0 ? ar - 1 : xr - 1, hr = hr === 0 ? ar - 1 : hr - 1, pr = pr === 0 ? ar - 1 : pr - 1, si.indices.push(hr), si.indices.push(xr), si.indices.push(qi), si.indices.push(hr), si.indices.push(pr), si.indices.push(xr);
                }
                return si;
              }(r[0]), r = [ze.geometry];
            }
            const Ne = (Dt, ni) => Dt < (ni.length - 1) / 2 || Dt === ni.length - 1, Ee = this.wallMode ? [r] : yr(r, 500);
            for (let Dt = Ee.length - 1; Dt >= 0; Dt--) {
              const ni = Ee[Dt];
              (ni.length === 0 || (We = ni[0]).every((Gt) => Gt.x <= 0) || We.every((Gt) => Gt.x >= tr) || We.every((Gt) => Gt.y <= 0) || We.every((Gt) => Gt.y >= tr)) && Ee.splice(Dt, 1);
            }
            var We;
            let lt;
            if (G) lt = i0(Ee, y, h);
            else {
              lt = [];
              for (const Dt of Ee) lt.push({ polygon: Dt, bounds: y });
            }
            const yt = L ? this.edgeRadius : 0, Bt = yt > 0 && this.zoom < 17, zt = (Dt, ni) => {
              if (Dt.length === 0) return !1;
              const Gt = Dt[Dt.length - 1];
              return ni.x === Gt.x && ni.y === Gt.y;
            };
            for (const { polygon: Dt, bounds: ni } of lt) {
              let Gt = 0, si = 0;
              for (const gi of Dt) L && !gi[0].equals(gi[gi.length - 1]) && gi.push(gi[0]), si += L ? gi.length - 1 : gi.length;
              const ci = this.segments.prepareSegment((L ? 5 : 4) * si, this.layoutVertexArray, this.indexArray);
              Y.footprintSegIdx < 0 && (Y.footprintSegIdx = this.footprintSegments.length), Y.polygonSegIdx < 0 && (Y.polygonSegIdx = this.polygonSegments.length);
              const li = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, fi = new qg();
              if (fi.vertexOffset = this.footprintVertices.length, fi.indexOffset = 3 * this.footprintIndices.length, fi.ringIndices = [], L) {
                const gi = [], Si = [];
                Gt = ci.vertexLength;
                for (let zi = 0; zi < Dt.length; zi++) {
                  const Gi = Dt[zi];
                  Gi.length && zi !== 0 && Si.push(gi.length / 2);
                  const Oi = [];
                  let lr, ar;
                  lr = Gi[1].sub(Gi[0])._perp()._unit(), fi.ringIndices.push(Gi.length - 1);
                  for (let Qi = 1; Qi < Gi.length; Qi++) {
                    const qi = Gi[Qi], xr = Gi[Qi === Gi.length - 1 ? 1 : Qi + 1], hr = qi.clone();
                    if (yt) {
                      ar = xr.sub(qi)._perp()._unit();
                      const pr = lr.add(ar)._unit(), Ur = yt * Math.min(4, 1 / (lr.x * pr.x + lr.y * pr.y));
                      hr.x += Ur * pr.x, hr.y += Ur * pr.y, hr.x = Math.round(hr.x), hr.y = Math.round(hr.y), lr = ar;
                    }
                    if (!ce || yt !== 0 && !Bt || zt(Oi, hr) || Oi.push(hr), Ed(this.layoutVertexArray, hr.x, hr.y, 0, 0, 1, 1, 0), this.wallMode) {
                      const pr = Ne(Qi, Gi);
                      Td(this.wallVertexArray, ze.joinNormals[Qi], !pr);
                    }
                    ci.vertexLength++, this.footprintVertices.emplaceBack(qi.x, qi.y), gi.push(qi.x, qi.y), G && Cd(this.layoutVertexExtArray, B.projectTilePoint(hr.x, hr.y, h), B.upVector(h, hr.x, hr.y));
                  }
                  ce && (yt === 0 || Bt) && (Oi.length !== 0 && zt(Oi, Oi[0]) && Oi.pop(), this.groundEffect.addData(Oi, ni, H));
                }
                const pi = this.wallMode ? ze.indices : Nh(gi, Si);
                for (let zi = 0; zi < pi.length; zi += 3) this.footprintIndices.emplaceBack(fi.vertexOffset + pi[zi + 0], fi.vertexOffset + pi[zi + 1], fi.vertexOffset + pi[zi + 2]), this.indexArray.emplaceBack(Gt + pi[zi], Gt + pi[zi + 2], Gt + pi[zi + 1]), ci.primitiveLength++;
                fi.indexCount += pi.length, fi.vertexCount += this.footprintVertices.length - fi.vertexOffset;
              }
              for (let gi = 0; gi < Dt.length; gi++) {
                const Si = Dt[gi];
                F.startRing(Y, Si[0]);
                let pi = Si.length > 4 && Qg(Si[Si.length - 2], Si[0], Si[1]), zi = yt ? Sx(Si[Si.length - 2], Si[0], Si[1], yt) : 0;
                const Gi = [];
                let Oi, lr, ar;
                lr = Si[1].sub(Si[0])._perp()._unit();
                let Qi = !0;
                for (let qi = 1, xr = 0; qi < Si.length; qi++) {
                  let hr = Si[qi - 1], pr = Si[qi];
                  const Ur = Si[qi === Si.length - 1 ? 1 : qi + 1];
                  if (F.appendEdge(Y, pr, hr), gm(pr, hr, ni)) {
                    yt && (lr = Ur.sub(pr)._perp()._unit(), Qi = !Qi);
                    continue;
                  }
                  const Xr = pr.sub(hr)._perp(), Yr = Xr.x / (Math.abs(Xr.x) + Math.abs(Xr.y)), Kr = Xr.y > 0 ? 1 : 0, sn = hr.dist(pr);
                  if (xr + sn > 32768 && (xr = 0), yt) {
                    ar = Ur.sub(pr)._perp()._unit();
                    let Gr = Kg(hr, pr, Ur, Yg(lr, ar), yt);
                    isNaN(Gr) && (Gr = 0);
                    const Sn = pr.sub(hr)._unit();
                    hr = hr.add(Sn.mult(zi))._round(), pr = pr.add(Sn.mult(-Gr))._round(), zi = Gr, lr = ar, ce && this.zoom >= 17 && (zt(Gi, hr) || Gi.push(hr), zt(Gi, pr) || Gi.push(pr));
                  }
                  const cn = ci.vertexLength, Un = Si.length > 4 && Qg(hr, pr, Ur);
                  let In = e0(xr, pi, Qi);
                  if (Ed(this.layoutVertexArray, hr.x, hr.y, Yr, Kr, 0, 0, In), Ed(this.layoutVertexArray, hr.x, hr.y, Yr, Kr, 0, 1, In), this.wallMode) {
                    const Gr = Ne(qi - 1, Si), Sn = ze.joinNormals[qi - 1];
                    Td(this.wallVertexArray, Sn, Gr), Td(this.wallVertexArray, Sn, Gr);
                  }
                  if (xr += sn, In = e0(xr, Un, !Qi), pi = Un, Ed(this.layoutVertexArray, pr.x, pr.y, Yr, Kr, 0, 0, In), Ed(this.layoutVertexArray, pr.x, pr.y, Yr, Kr, 0, 1, In), this.wallMode) {
                    const Gr = Ne(qi, Si), Sn = ze.joinNormals[qi];
                    Td(this.wallVertexArray, Sn, Gr), Td(this.wallVertexArray, Sn, Gr);
                  }
                  if (ci.vertexLength += 4, this.indexArray.emplaceBack(cn + 0, cn + 1, cn + 2), this.indexArray.emplaceBack(cn + 1, cn + 3, cn + 2), ci.primitiveLength += 2, yt) {
                    const Gr = Gt + (qi === 1 ? Si.length - 2 : qi - 2), Sn = qi === 1 ? Gt : Gr + 1;
                    if (this.indexArray.emplaceBack(cn + 1, Gr, cn + 3), this.indexArray.emplaceBack(Gr, Sn, cn + 3), ci.primitiveLength += 2, Oi === void 0 && (Oi = cn), !gm(Ur, Si[qi], ni)) {
                      const An = qi === Si.length - 1 ? Oi : ci.vertexLength;
                      this.indexArray.emplaceBack(cn + 2, cn + 3, An), this.indexArray.emplaceBack(cn + 3, An + 1, An), this.indexArray.emplaceBack(cn + 3, Sn, An + 1), ci.primitiveLength += 3;
                    }
                    Qi = !Qi;
                  }
                  if (G) {
                    const Gr = this.layoutVertexExtArray, Sn = B.projectTilePoint(hr.x, hr.y, h), An = B.projectTilePoint(pr.x, pr.y, h), Jn = B.upVector(h, hr.x, hr.y), Oa = B.upVector(h, pr.x, pr.y);
                    Cd(Gr, Sn, Jn), Cd(Gr, Sn, Jn), Cd(Gr, An, Oa), Cd(Gr, An, Oa);
                  }
                }
                L && (Gt += Si.length - 1), ce && yt && this.zoom >= 17 && (Gi.length !== 0 && zt(Gi, Gi[0]) && Gi.pop(), this.groundEffect.addData(Gi, ni, H, yt > 0));
              }
              this.footprintSegments.push(fi), li.triangleCount = this.indexArray.length - li.triangleArrayOffset, this.polygonSegments.push(li), ++Y.footprintSegLen, ++Y.polygonSegLen;
            }
            if (Y.vertexCount = this.layoutVertexArray.length - Y.vertexArrayOffset, Y.groundVertexCount = this.groundEffect.vertexArray.length - Y.groundVertexArrayOffset, Y.vertexCount !== 0) {
              if (Y.centroidXY = F.borders ? Hg : this.encodeCentroid(F, Y), this.centroidData.push(Y), F.borders) {
                this.featuresOnBorder.push(F);
                const Dt = this.featuresOnBorder.length - 1;
                for (let ni = 0; ni < F.borders.length; ni++) F.borders[ni][0] !== Number.MAX_VALUE && this.borderFeatureIndices[ni].push(Dt);
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, s, o, f, h, O), this.groundEffect.addPaintPropertiesData(e, s, o, f, h, O), this.maxHeight = Math.max(this.maxHeight, _e);
            }
          }
          sortBorders() {
            for (let e = 0; e < this.borderFeatureIndices.length; e++) this.borderFeatureIndices[e].sort((r, s) => this.featuresOnBorder[r].borders[e][0] - this.featuresOnBorder[s].borders[e][0]);
          }
          splitToSubtiles() {
            const e = [];
            for (let b = 0; b < this.centroidData.length; b++) {
              const O = this.centroidData[b], H = +(O.min.y + O.max.y > tr), y = 2 * H + (+(O.min.x + O.max.x > tr) ^ H);
              for (let B = 0; B < O.polygonSegLen; B++) {
                const G = O.polygonSegIdx + B;
                e.push({ centroidIdx: b, subtile: y, polygonSegmentIdx: G, triangleSegmentIdx: this.polygonSegments[G].triangleSegIdx });
              }
            }
            const r = new Ya();
            e.sort((b, O) => b.triangleSegmentIdx === O.triangleSegmentIdx ? b.subtile - O.subtile : b.triangleSegmentIdx - O.triangleSegmentIdx);
            let s = 0, h = 0, o = 0;
            for (const b of e) {
              if (b.triangleSegmentIdx !== s) break;
              o++;
            }
            const f = e.length;
            for (; h !== e.length; ) {
              s = e[h].triangleSegmentIdx;
              let b = 0, O = h, H = h;
              for (let y = O; y < o && e[y].subtile === b; y++) H++;
              for (; O !== o; ) {
                const y = e[O];
                b = y.subtile;
                const B = this.centroidData[y.centroidIdx].min.clone(), G = this.centroidData[y.centroidIdx].max.clone(), L = { vertexOffset: this.segments.segments[s].vertexOffset, primitiveOffset: r.length, vertexLength: this.segments.segments[s].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
                for (let F = O; F < H; F++) {
                  const Y = e[F], ce = this.polygonSegments[Y.polygonSegmentIdx], _e = this.centroidData[Y.centroidIdx].min, ze = this.centroidData[Y.centroidIdx].max, Ne = this.indexArray.uint16;
                  for (let Ee = ce.triangleArrayOffset; Ee < ce.triangleArrayOffset + ce.triangleCount; Ee++) r.emplaceBack(Ne[3 * Ee], Ne[3 * Ee + 1], Ne[3 * Ee + 2]);
                  L.primitiveLength += ce.triangleCount, B.x = Math.min(B.x, _e.x), B.y = Math.min(B.y, _e.y), G.x = Math.max(G.x, ze.x), G.y = Math.max(G.y, ze.y);
                }
                L.primitiveLength > 0 && this.triangleSubSegments.push({ segment: L, min: B, max: G }), O = H;
                for (let F = O; F < o && e[F].subtile === e[O].subtile; F++) H++;
              }
              h = o;
              for (let y = h; y < f && e[y].triangleSegmentIdx === e[h].triangleSegmentIdx; y++) o++;
            }
            r._trim(), this.indexArray = r;
          }
          getVisibleSegments(e, r, s) {
            const h = new Ea();
            if (this.wallMode) {
              for (const Y of this.triangleSubSegments) h.segments.push(Y.segment);
              return h;
            }
            let o = 0, f = 0;
            const b = 1 << e.canonical.z;
            if (r) {
              const Y = r.getMinMaxForTile(e);
              Y && (o = Y.min, f = Y.max);
            }
            f += this.maxHeight;
            const O = e.toUnwrapped();
            let H;
            const y = [O.canonical.x / b + O.wrap, O.canonical.y / b], B = [(O.canonical.x + 1) / b + O.wrap, (O.canonical.y + 1) / b], G = (Y, ce, _e) => [Y[0] * (1 - _e[0]) + ce[0] * _e[0], Y[1] * (1 - _e[1]) + ce[1] * _e[1]], L = [], F = [];
            for (const Y of this.triangleSubSegments) {
              L[0] = Y.min.x / tr, L[1] = Y.min.y / tr, F[0] = Y.max.x / tr, F[1] = Y.max.y / tr;
              const ce = G(y, B, L), _e = G(y, B, F);
              if (new mr([ce[0], ce[1], o], [_e[0], _e[1], f]).intersectsPrecise(s) === 0) {
                H && (h.segments.push(H), H = void 0);
                continue;
              }
              const ze = Y.segment;
              H && H.vertexOffset !== ze.vertexOffset && (h.segments.push(H), H = void 0), H ? (H.vertexLength += ze.vertexLength, H.primitiveLength += ze.primitiveLength) : H = { vertexOffset: ze.vertexOffset, primitiveLength: ze.primitiveLength, vertexLength: ze.vertexLength, primitiveOffset: ze.primitiveOffset, sortKey: void 0, vaos: {} };
            }
            return H && h.segments.push(H), h;
          }
          encodeCentroid(e, r) {
            const s = e.centroid(), h = r.span(), o = Math.min(7, Math.round(h.x * this.tileToMeter / 10)), f = Math.min(7, Math.round(h.y * this.tileToMeter / 10));
            return new At(pe(s.x, 1, tr - 1) << 3 | o, pe(s.y, 1, tr - 1) << 3 | f);
          }
          encodeBorderCentroid(e) {
            if (!e.borders) return new At(0, 0);
            const r = e.borders, s = Number.MAX_VALUE;
            if (r[0][0] !== s || r[1][0] !== s) {
              const h = r[0][0] !== s ? 0 : 1;
              return new At(6 | (r[0][0] !== s ? 0 : 65528), (r[h][0] + r[h][1]) / 2 << 3 | 6);
            }
            {
              const h = r[2][0] !== s ? 2 : 3;
              return new At((r[h][0] + r[h][1]) / 2 << 3 | 6, 6 | (r[2][0] !== s ? 0 : 65528));
            }
          }
          showCentroid(e) {
            const r = this.centroidData[e.centroidDataIndex];
            r.flags &= Uh, r.centroidXY.x = 0, r.centroidXY.y = 0, this.writeCentroidToBuffer(r);
          }
          writeCentroidToBuffer(e) {
            this.groundEffect.updateHiddenByLandmark(e);
            const r = e.vertexArrayOffset, s = e.vertexCount + e.vertexArrayOffset, h = e.flags & Uh ? Hg : e.centroidXY, o = this.centroidVertexArray.geta_centroid_pos0(r);
            if (this.centroidVertexArray.geta_centroid_pos1(r) !== h.y || o !== h.x) {
              for (let f = r; f < s; ++f) this.centroidVertexArray.emplace(f, h.x, h.y);
              this.needsCentroidUpdate = !0;
            }
          }
          createCentroidsBuffer() {
            this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
            for (const e of this.centroidData) this.writeCentroidToBuffer(e);
          }
          updateReplacement(e, r, s) {
            if (r.updateTime === this.replacementUpdateTime) return;
            this.replacementUpdateTime = r.updateTime;
            const h = r.getReplacementRegionsForTile(e.toUnwrapped());
            if (pm(this.activeReplacements, h)) return;
            if (this.activeReplacements = h, this.centroidVertexArray.length === 0) this.createCentroidsBuffer();
            else for (const f of this.centroidData) f.flags &= 2147483647;
            const o = [];
            for (const f of this.activeReplacements) {
              if (f.order < s) continue;
              const b = Math.max(1, Math.pow(2, f.footprintTileId.canonical.z - e.canonical.z));
              for (const O of this.centroidData) if (!(O.flags & Uh || f.min.x > O.max.x || O.min.x > f.max.x || f.min.y > O.max.y || O.min.y > f.max.y)) for (let H = 0; H < O.footprintSegLen; H++) {
                const y = this.footprintSegments[O.footprintSegIdx + H];
                if (o.length = 0, Ex(this.footprintVertices, y.vertexOffset, y.vertexCount, f.footprintTileId.canonical, e.canonical, o), Ng(f.footprint, o, this.footprintIndices.uint16, y.indexOffset, y.indexCount, -y.vertexOffset, -b)) {
                  O.flags |= Uh;
                  break;
                }
              }
            }
            for (const f of this.centroidData) this.writeCentroidToBuffer(f);
            this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
          }
          footprintContainsPoint(e, r, s) {
            let h = !1;
            for (let o = 0; o < s.footprintSegLen; o++) {
              const f = this.footprintSegments[s.footprintSegIdx + o];
              let b = 0;
              for (const O of f.ringIndices) {
                for (let H = b, y = O + b - 1; H < O + b; y = H++) {
                  const B = this.footprintVertices.int16[2 * (H + f.vertexOffset) + 0], G = this.footprintVertices.int16[2 * (H + f.vertexOffset) + 1], L = this.footprintVertices.int16[2 * (y + f.vertexOffset) + 1];
                  G > r != L > r && e < (this.footprintVertices.int16[2 * (y + f.vertexOffset) + 0] - B) * (r - G) / (L - G) + B && (h = !h);
                }
                b = O;
              }
            }
            return h;
          }
          getHeightAtTileCoord(e, r) {
            let s = Number.NEGATIVE_INFINITY, h = !0;
            const o = 4 * (e + tr) * tr + (r + tr);
            if (this.partLookup.hasOwnProperty(o)) {
              const f = this.partLookup[o];
              return f ? { height: f.height, hidden: !!(f.flags & Uh) } : void 0;
            }
            for (const f of this.centroidData) e > f.max.x || f.min.x > e || r > f.max.y || f.min.y > r || this.footprintContainsPoint(e, r, f) && f && f.height > s && (s = f.height, this.partLookup[o] = f, h = !!(f.flags & Uh));
            if (s !== Number.NEGATIVE_INFINITY) return { height: s, hidden: h };
            this.partLookup[o] = void 0;
          }
        }
        function Yg(a, e) {
          const r = a.add(e)._unit();
          return a.x * r.x + a.y * r.y;
        }
        function Sx(a, e, r, s) {
          const h = e.sub(a)._perp()._unit(), o = r.sub(e)._perp()._unit();
          return Kg(a, e, r, Yg(h, o), s);
        }
        function Kg(a, e, r, s, h) {
          const o = Math.sqrt(1 - s * s);
          return Math.min(a.dist(e) / 3, e.dist(r) / 3, h * o / s);
        }
        function gm(a, e, r) {
          return a.x < r[0].x && e.x < r[0].x || a.x > r[1].x && e.x > r[1].x || a.y < r[0].y && e.y < r[0].y || a.y > r[1].y && e.y > r[1].y;
        }
        function Jg(a, e) {
          return a.x < e[0].x || a.x > e[1].x || a.y < e[0].y || a.y > e[1].y;
        }
        function Qg(a, e, r) {
          if (a.x < 0 || a.x >= tr || e.x < 0 || e.x >= tr || r.x < 0 || r.x >= tr) return !1;
          const s = r.sub(e), h = s.perp(), o = a.sub(e);
          return (s.x * o.x + s.y * o.y) / Math.sqrt((s.x * s.x + s.y * s.y) * (o.x * o.x + o.y * o.y)) > -0.866 && h.x * o.x + h.y * o.y < 0;
        }
        function e0(a, e, r) {
          const s = e ? 2 | a : -3 & a;
          return r ? 1 | s : -2 & s;
        }
        function t0() {
          const a = Math.PI / 32, e = Math.tan(a), r = eu;
          return r * Math.sqrt(1 + 2 * e * e) - r;
        }
        function i0(a, e, r) {
          const s = 1 << r.z, h = Qs(r.x / s), o = Qs((r.x + 1) / s), f = Pr(r.y / s), b = Pr((r.y + 1) / s);
          return function(O, H, y, B, G = 0, L) {
            const F = [];
            if (!O.length || !y || !B) return F;
            const Y = (lt, yt) => {
              for (const Bt of lt) F.push({ polygon: Bt, bounds: yt });
            }, ce = Math.ceil(Math.log2(y)), _e = Math.ceil(Math.log2(B)), ze = ce - _e, Ne = [];
            for (let lt = 0; lt < Math.abs(ze); lt++) Ne.push(ze > 0 ? 0 : 1);
            for (let lt = 0; lt < Math.min(ce, _e); lt++) Ne.push(0), Ne.push(1);
            let Ee = O;
            if (Ee = cp(Ee, H[0].y - G, H[1].y + G, 1), Ee = cp(Ee, H[0].x - G, H[1].x + G, 0), !Ee.length) return F;
            const We = [];
            for (Ne.length ? We.push({ polygons: Ee, bounds: H, depth: 0 }) : Y(Ee, H); We.length; ) {
              const lt = We.pop(), yt = lt.depth, Bt = Ne[yt], zt = lt.bounds[0], Dt = lt.bounds[1], ni = Bt === 0 ? zt.x : zt.y, Gt = Bt === 0 ? Dt.x : Dt.y, si = L(Bt, ni, Gt), ci = cp(lt.polygons, ni - G, si + G, Bt), li = cp(lt.polygons, si - G, Gt + G, Bt);
              if (ci.length) {
                const fi = [zt, new At(Bt === 0 ? si : Dt.x, Bt === 1 ? si : Dt.y)];
                Ne.length > yt + 1 ? We.push({ polygons: ci, bounds: fi, depth: yt + 1 }) : Y(ci, fi);
              }
              if (li.length) {
                const fi = [new At(Bt === 0 ? si : zt.x, Bt === 1 ? si : zt.y), Dt];
                Ne.length > yt + 1 ? We.push({ polygons: li, bounds: fi, depth: yt + 1 }) : Y(li, fi);
              }
            }
            return F;
          }(a, e, Math.ceil((o - h) / 11.25), Math.ceil((f - b) / 11.25), 1, (O, H, y) => {
            if (O === 0) return 0.5 * (H + y);
            {
              const B = Pr((r.y + H / tr) / s);
              return (Js(0.5 * (Pr((r.y + y / tr) / s) + B)) * s - r.y) * tr;
            }
          });
        }
        function Ex(a, e, r, s, h, o) {
          const f = Math.pow(2, s.z - h.z);
          for (let b = 0; b < r; b++) {
            let O = a.int16[2 * (b + e) + 0], H = a.int16[2 * (b + e) + 1];
            O = (O + h.x * tr) * f - s.x * tr, H = (H + h.y * tr) * f - s.y * tr, o.push(new At(O, H));
          }
        }
        let r0, n0;
        function Ad(a, e) {
          return a.x * e.x + a.y * e.y;
        }
        function a0(a, e) {
          if (a.length === 1) {
            let r = 0;
            const s = e[r++];
            let h;
            for (; !h || s.equals(h); ) if (h = e[r++], !h) return 1 / 0;
            for (; r < e.length; r++) {
              const o = e[r], f = a[0], b = h.sub(s), O = o.sub(s), H = f.sub(s), y = Ad(b, b), B = Ad(b, O), G = Ad(O, O), L = Ad(H, b), F = Ad(H, O), Y = y * G - B * B, ce = (G * L - B * F) / Y, _e = (y * F - B * L) / Y, ze = s.z * (1 - ce - _e) + h.z * ce + o.z * _e;
              if (isFinite(ze)) return ze;
            }
            return 1 / 0;
          }
          {
            let r = 1 / 0;
            for (const s of e) r = Math.min(r, s.z);
            return r;
          }
        }
        function s0(a, e, r, s, h, o, f, b) {
          const O = f * h.getElevationAt(a, e, !0, !0), H = o[0] !== 0, y = H ? o[1] === 0 ? f * (o[0] / 7 - 450) : f * function(B, G, L) {
            const F = Math.floor(G[0] / 8), Y = Math.floor(G[1] / 8), ce = 10 * (G[0] - 8 * F), _e = 10 * (G[1] - 8 * Y), ze = B.getElevationAt(F, Y, !0, !0), Ne = B.getMeterToDEM(L), Ee = Math.floor(0.5 * (ce * Ne - 1)), We = Math.floor(0.5 * (_e * Ne - 1)), lt = B.tileCoordToPixel(F, Y), yt = 2 * Ee + 1, Bt = 2 * We + 1, zt = function(li, fi, gi, Si, pi) {
              return [li.getElevationAtPixel(fi, gi, !0), li.getElevationAtPixel(fi + pi, gi, !0), li.getElevationAtPixel(fi, gi + pi, !0), li.getElevationAtPixel(fi + Si, gi + pi, !0)];
            }(B, lt.x - Ee, lt.y - We, yt, Bt), Dt = Math.abs(zt[0] - zt[1]), ni = Math.abs(zt[2] - zt[3]), Gt = Math.abs(zt[0] - zt[2]) + Math.abs(zt[1] - zt[3]), si = Math.min(0.25, 0.5 * Ne * (Dt + ni) / yt), ci = Math.min(0.25, 0.5 * Ne * Gt / Bt);
            return ze + Math.max(si * ce, ci * _e);
          }(h, o, b) : O;
          return { base: O + (r === 0 ? -1 : r), top: H ? Math.max(y + s, O + r + 2) : O + s };
        }
        ur(pp, "FillExtrusionBucket", { omit: ["layers", "features"] }), ur(Wg, "PartData"), ur(qg, "FootprintSegment"), ur(Zg, "BorderCentroidData"), ur(Xg, "GroundEffect");
        const Tx = dn([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), Cx = dn([{ name: "a_z_offset_width", components: 3, type: "Float32" }], 4), { members: Ax } = Tx, Mx = dn([{ name: "a_packed", components: 3, type: "Float32" }]), { members: Ix } = Mx, Px = dn([{ name: "a_pattern_data", components: 3, type: "Float32" }]), { members: Rx } = Px;
        class o0 {
          constructor(e, r) {
            this.width = e, this.height = r, this.nextRow = 0, this.image = new tu({ width: e, height: r }), this.positions = {}, this.uploaded = !1;
          }
          getDash(e, r) {
            const s = this.getKey(e, r);
            return this.positions[s];
          }
          trim() {
            const e = this.width, r = this.height = ue(this.nextRow);
            this.image.resize({ width: e, height: r });
          }
          getKey(e, r) {
            return e.join(",") + r;
          }
          getDashRanges(e, r, s) {
            const h = [];
            let o = e.length % 2 == 1 ? -e[e.length - 1] * s : 0, f = e[0] * s, b = !0;
            h.push({ left: o, right: f, isDash: b, zeroLength: e[0] === 0 });
            let O = e[0];
            for (let H = 1; H < e.length; H++) {
              b = !b;
              const y = e[H];
              o = O * s, O += y, f = O * s, h.push({ left: o, right: f, isDash: b, zeroLength: y === 0 });
            }
            return h;
          }
          addRoundDash(e, r, s) {
            const h = r / 2;
            for (let o = -s; o <= s; o++) {
              const f = this.width * (this.nextRow + s + o);
              let b = 0, O = e[b];
              for (let H = 0; H < this.width; H++) {
                H / O.right > 1 && (O = e[++b]);
                const y = Math.abs(H - O.left), B = Math.abs(H - O.right), G = Math.min(y, B);
                let L;
                const F = o / s * (h + 1);
                if (O.isDash) {
                  const Y = h - Math.abs(F);
                  L = Math.sqrt(G * G + Y * Y);
                } else L = h - Math.sqrt(G * G + F * F);
                this.image.data[f + H] = Math.max(0, Math.min(255, L + 128));
              }
            }
          }
          addRegularDash(e, r) {
            for (let O = e.length - 1; O >= 0; --O) {
              const H = e[O], y = e[O + 1];
              H.zeroLength ? e.splice(O, 1) : y && y.isDash === H.isDash && (y.left = H.left, e.splice(O, 1));
            }
            const s = e[0], h = e[e.length - 1];
            s.isDash === h.isDash && (s.left = h.left - this.width, h.right = s.right + this.width);
            const o = this.width * this.nextRow;
            let f = 0, b = e[f];
            for (let O = 0; O < this.width; O++) {
              O / b.right > 1 && (b = e[++f]);
              const H = Math.abs(O - b.left), y = Math.abs(O - b.right), B = Math.min(H, y);
              this.image.data[o + O] = Math.max(0, Math.min(255, (b.isDash ? B : -B) + r + 128));
            }
          }
          addDash(e, r) {
            const s = this.getKey(e, r);
            if (this.positions[s]) return this.positions[s];
            const h = r === "round", o = h ? 7 : 0, f = 2 * o + 1;
            if (this.nextRow + f > this.height) return Se("LineAtlas out of space"), null;
            e.length === 0 && e.push(1);
            let b = 0;
            for (let y = 0; y < e.length; y++) e[y] < 0 && (Se("Negative value is found in line dasharray, replacing values with 0"), e[y] = 0), b += e[y];
            if (b !== 0) {
              const y = this.width / b, B = this.getDashRanges(e, this.width, y);
              h ? this.addRoundDash(B, y, o) : this.addRegularDash(B, r === "square" ? 0.5 * y : 0);
            }
            const O = this.nextRow + o;
            this.nextRow += f;
            const H = { tl: [O, o], br: [b, 0] };
            return this.positions[s] = H, H;
          }
        }
        ur(o0, "LineAtlas");
        const kx = Yf.VectorTileFeature.types, Lx = Math.cos(Math.PI / 180 * 37.5), Ox = Math.cos(Math.PI / 180 * 5);
        class vm {
          constructor(e) {
            this.evaluationGlobals = { zoom: 0, lineProgress: void 0 }, this.zoom = e.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = e.overscaling, this.pixelRatio = e.pixelRatio, this.layers = e.layers, this.layerIds = this.layers.map((r) => r.fqid), this.index = e.index, this.projection = e.projection, this.hasPattern = !1, this.hasZOffset = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((r) => {
              this.gradients[r.id] = {};
            }), this.layoutVertexArray = new $l(), this.layoutVertexArray2 = new $s(), this.patternVertexArray = new $s(), this.indexArray = new Ya(), this.programConfigurations = new Cl(e.layers, { zoom: e.zoom, lut: e.lut }), this.segments = new Ea(), this.maxLineLength = 0, this.zOffsetVertexArray = new $s(), this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id), this.tessellationStep = e.tessellationStep ? e.tessellationStep : tr / 64;
          }
          updateFootprints(e, r) {
          }
          populate(e, r, s, h) {
            this.hasPattern = jr("line", this.layers, this.pixelRatio, r);
            const o = this.layers[0].layout.get("line-sort-key");
            this.tileToMeter = t(s);
            const f = this.layers[0].layout.get("line-z-offset"), b = f.isConstant() && !f.constantOr(0), O = this.layers[0].layout.get("line-elevation-reference");
            this.hasZOffset = O === "sea" || O === "ground" || !b && O === "none", this.hasZOffset && O === "none" && Se(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
            const H = this.layers[0].layout.get("line-cross-slope");
            this.hasCrossSlope = this.hasZOffset && H !== void 0;
            const y = [];
            for (const { feature: F, id: Y, index: ce, sourceLayerIndex: _e } of e) {
              const ze = this.layers[0]._featureFilter.needGeometry, Ne = ve(F, ze);
              if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), Ne, s)) continue;
              const Ee = o ? o.evaluate(Ne, {}, s) : void 0, We = { id: Y, properties: F.properties, type: F.type, sourceLayerIndex: _e, index: ce, geometry: ze ? Ne.geometry : oe(F, s, h), patterns: {}, sortKey: Ee };
              y.push(We);
            }
            o && y.sort((F, Y) => F.sortKey - Y.sortKey);
            const { lineAtlas: B, featureIndex: G } = r, L = this.addConstantDashes(B);
            for (const F of y) {
              const { geometry: Y, index: ce, sourceLayerIndex: _e } = F;
              if (L && this.addFeatureDashes(F, B), this.hasPattern) {
                const ze = qr("line", this.layers, F, this.zoom, this.pixelRatio, r);
                this.patternFeatures.push(ze);
              } else this.addFeature(F, Y, ce, s, B.positions, r.availableImages, r.brightness);
              G.insert(e[ce].feature, Y, ce, _e, this.index);
            }
          }
          addConstantDashes(e) {
            let r = !1;
            for (const s of this.layers) {
              const h = s.paint.get("line-dasharray").value, o = s.layout.get("line-cap").value;
              if (h.kind !== "constant" || o.kind !== "constant") r = !0;
              else {
                const f = o.value, b = h.value;
                if (!b) continue;
                e.addDash(b, f);
              }
            }
            return r;
          }
          addFeatureDashes(e, r) {
            const s = this.zoom;
            for (const h of this.layers) {
              const o = h.paint.get("line-dasharray").value, f = h.layout.get("line-cap").value;
              if (o.kind === "constant" && f.kind === "constant") continue;
              let b, O;
              if (o.kind === "constant") {
                if (b = o.value, !b) continue;
              } else b = o.evaluate({ zoom: s }, e);
              O = f.kind === "constant" ? f.value : f.evaluate({ zoom: s }, e), r.addDash(b, O), e.patterns[h.id] = r.getKey(b, O);
            }
          }
          update(e, r, s, h, o, f, b) {
            this.programConfigurations.updatePaintArrays(e, r, o, s, h, f, b);
          }
          addFeatures(e, r, s, h, o, f) {
            for (const b of this.patternFeatures) this.addFeature(b, b.geometry, b.index, r, s, h, f);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(e) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, Ix)), this.patternVertexArray.length !== 0 && (this.patternVertexBuffer = e.createVertexBuffer(this.patternVertexArray, Rx)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, Cx.members, !0)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Ax), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(e) {
            if (e.properties && e.properties.hasOwnProperty("mapbox_clip_start") && e.properties.hasOwnProperty("mapbox_clip_end")) return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end };
          }
          addFeature(e, r, s, h, o, f, b) {
            const O = this.layers[0].layout, H = O.get("line-join").evaluate(e, {}), y = O.get("line-cap").evaluate(e, {}), B = O.get("line-miter-limit"), G = O.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(e), this.lineFeature = e, this.zOffsetValue = O.get("line-z-offset").value;
            const L = this.layers[0].paint.get("line-width").value;
            L.kind !== "constant" && L.isLineProgressConstant === !1 && (this.variableWidthValue = L);
            for (const F of r) this.addLine(F, e, h, H, y, B, G);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, s, o, f, h, b);
          }
          addLine(e, r, s, h, o, f, b) {
            this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0;
            const O = h === "none";
            if (this.patternJoinNone = this.hasPattern && O, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [], this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let Ne = 0; Ne < e.length - 1; Ne++) this.totalDistance += e[Ne].dist(e[Ne + 1]);
              this.totalFeatureLength = this.totalDistance / (this.lineClips.end - this.lineClips.start), this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const H = kx[r.type] === "Polygon";
            let y = e.length;
            for (; y >= 2 && e[y - 1].equals(e[y - 2]); ) y--;
            let B = 0;
            for (; B < y - 1 && e[B].equals(e[B + 1]); ) B++;
            if (y < (H ? 3 : 2)) return;
            h === "bevel" && (f = 1.05);
            const G = this.segments.prepareSegment(10 * y, this.layoutVertexArray, this.indexArray);
            let L, F, Y, ce, _e, ze;
            this.e1 = this.e2 = -1, H && (L = e[y - 2], _e = e[B].sub(L)._unit()._perp());
            for (let Ne = B; Ne < y; Ne++) {
              if (Y = Ne === y - 1 ? H ? e[B + 1] : void 0 : e[Ne + 1], Y && e[Ne].equals(Y)) continue;
              _e && (ce = _e), L && (F = L), L = e[Ne], ze = this.evaluateLineProgressFeatures(F ? F.dist(L) : 0), _e = Y ? Y.sub(L)._unit()._perp() : ce, ce = ce || _e;
              const Ee = F && Y;
              let We = Ee ? h : H || O ? "butt" : o;
              const lt = ce.x * _e.x + ce.y * _e.y;
              if (O) {
                const ci = function(li) {
                  if (li.patternJoinNone) {
                    const fi = li.segmentPoints.length / 2, gi = li.lineSoFar - li.segmentStart;
                    for (let Si = 0; Si < fi; ++Si) {
                      const pi = li.segmentPoints[2 * Si + 1], zi = Math.round(li.segmentPoints[2 * Si]) + 0.5 + 0.25 * pi;
                      li.patternVertexArray.emplaceBack(zi, gi, li.segmentStart), li.patternVertexArray.emplaceBack(zi, gi, li.segmentStart);
                    }
                    li.segmentPoints.length = 0;
                  }
                  li.e1 = li.e2 = -1;
                };
                if (Ee && lt < Ox) {
                  this.updateDistance(F, L), this.addCurrentVertex(L, ce, 1, 1, G, ze), ci(this), this.addCurrentVertex(L, _e, -1, -1, G, ze);
                  continue;
                }
                if (F) {
                  if (!Y) {
                    this.updateDistance(F, L), this.addCurrentVertex(L, ce, 1, 1, G, ze), ci(this);
                    continue;
                  }
                  We = "miter";
                }
              }
              let yt = ce.add(_e);
              yt.x === 0 && yt.y === 0 || yt._unit();
              const Bt = yt.x * _e.x + yt.y * _e.y, zt = Bt !== 0 ? 1 / Bt : 1 / 0, Dt = 2 * Math.sqrt(2 - 2 * Bt), ni = Bt < Lx && F && Y, Gt = ce.x * _e.y - ce.y * _e.x > 0, si = this.overscaling <= 16 ? 15 * tr / (512 * this.overscaling) : 0;
              if (Ee && We === "round") {
                if (zt < b) We = "miter";
                else if (zt <= 2) {
                  const ci = ym(L, -10, tr + 10);
                  We = this.hasZOffset && (ci || this.hasCrossSlope) ? "miter" : "fakeround";
                }
              }
              if (We === "miter" && zt > f && (We = "bevel"), We === "bevel" && (zt > 2 && (We = "flipbevel"), zt < f && (We = "miter")), F && !(We === "miter" && ni) && this.updateDistance(F, L), We === "miter") if (ni) {
                const ci = L.dist(F);
                if (ci > 2 * si) {
                  const fi = L.sub(L.sub(F)._mult(si / ci)._round());
                  this.updateDistance(F, fi), this.addCurrentVertex(fi, ce, 0, 0, G, ze), F = fi;
                }
                this.updateDistance(F, L), yt._mult(zt), this.addCurrentVertex(L, yt, 0, 0, G, ze);
                const li = L.dist(Y);
                if (li > 2 * si) {
                  const fi = L.add(Y.sub(L)._mult(si / li)._round());
                  this.updateDistance(L, fi), this.addCurrentVertex(fi, _e, 0, 0, G, ze), L = fi;
                }
              } else yt._mult(zt), this.addCurrentVertex(L, yt, 0, 0, G, ze);
              else if (We === "flipbevel") {
                if (zt > 100) yt = _e.mult(-1);
                else {
                  const ci = zt * ce.add(_e).mag() / ce.sub(_e).mag();
                  yt._perp()._mult(ci * (Gt ? -1 : 1));
                }
                this.addCurrentVertex(L, yt, 0, 0, G, ze), this.addCurrentVertex(L, yt.mult(-1), 0, 0, G, ze);
              } else if (We === "bevel" || We === "fakeround") {
                ze != null && F && this.addCurrentVertex(L, ce, -1, -1, G, ze);
                const ci = L.dist(F) <= 2 * si && We !== "bevel", li = yt.mult(Gt ? 1 : -1);
                li._mult(zt);
                const fi = _e.mult(Gt ? -1 : 1), gi = ce.mult(Gt ? -1 : 1), Si = this.evaluateLineProgressFeatures(this.distance);
                if (ze == null && (this.addHalfVertex(L, li.x, li.y, !1, !Gt, 0, G, Si), ci || this.addHalfVertex(L, li.x + 2 * gi.x, li.y + 2 * gi.y, !1, Gt, 0, G, Si)), We === "fakeround") {
                  const pi = Math.round(180 * Dt / Math.PI / 20);
                  this.addHalfVertex(L, gi.x, gi.y, !1, Gt, 0, G, Si);
                  for (let zi = 0; zi < pi; zi++) {
                    let Gi = zi / pi;
                    if (Gi !== 0.5) {
                      const lr = Gi - 0.5;
                      Gi += Gi * lr * (Gi - 1) * ((1.0904 + lt * (lt * (3.55645 - 1.43519 * lt) - 3.2452)) * lr * lr + (0.848013 + lt * (0.215638 * lt - 1.06021)));
                    }
                    const Oi = fi.sub(gi)._mult(Gi)._add(gi)._unit();
                    this.addHalfVertex(L, Oi.x, Oi.y, !1, Gt, 0, G, Si);
                  }
                  this.addHalfVertex(L, fi.x, fi.y, !1, Gt, 0, G, Si);
                }
                ci || ze != null || this.addHalfVertex(L, li.x + 2 * fi.x, li.y + 2 * fi.y, !1, Gt, 0, G, Si), ze != null && Y && this.addCurrentVertex(L, _e, 1, 1, G, ze);
              } else We === "butt" ? this.addCurrentVertex(L, yt, 0, 0, G, ze) : We === "square" ? (F || this.addCurrentVertex(L, yt, -1, -1, G, ze), this.addCurrentVertex(L, yt, 0, 0, G, ze), F && this.addCurrentVertex(L, yt, 1, 1, G, ze)) : We === "round" && (F && (this.addCurrentVertex(L, ce, 0, 0, G, ze), this.addCurrentVertex(L, ce, 1, 1, G, ze, !0)), Y && (this.addCurrentVertex(L, _e, -1, -1, G, ze, !0), this.addCurrentVertex(L, _e, 0, 0, G, ze)));
            }
          }
          addVerticesTo(e, r, s, h, o, f, b, O, H, y) {
            const B = (r.w - e.w) / this.tessellationStep | 0;
            let G = 0;
            const L = this.scaledDistance;
            if (B > 1) {
              this.lineSoFar = e.w;
              const Y = (r.x - e.x) / B, ce = (r.y - e.y) / B, _e = (r.z - e.z) / B, ze = (r.w - e.w) / B;
              for (let Ne = 1; Ne < B; ++Ne) {
                e.x += Y, e.y += ce, e.z += _e, this.lineSoFar += ze, G += ze;
                const Ee = this.evaluateLineProgressFeatures(this.prevDistance + G);
                this.scaledDistance = (this.prevDistance + G) / this.totalDistance, this.addHalfVertex(e, s, h, y, !1, b, H, Ee), this.addHalfVertex(e, o, f, y, !0, -O, H, Ee);
              }
            }
            this.lineSoFar = r.w, this.scaledDistance = L;
            const F = this.evaluateLineProgressFeatures(this.distance);
            this.addHalfVertex(r, s, h, y, !1, b, H, F), this.addHalfVertex(r, o, f, y, !0, -O, H, F);
          }
          evaluateLineProgressFeatures(e) {
            if (!this.variableWidthValue && !this.hasZOffset) return null;
            this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + e) / this.totalFeatureLength) : Se(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
            let r = 0;
            return this.variableWidthValue && this.variableWidthValue.kind !== "constant" && (r = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), this.hasZOffset ? this.zOffsetValue.kind === "constant" ? { zOffset: this.zOffsetValue.value, variableWidth: r } : { zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0, variableWidth: r } : { zOffset: 0, variableWidth: r };
          }
          addCurrentVertex(e, r, s, h, o, f, b = !1) {
            const O = r.x + r.y * s, H = r.y - r.x * s, y = r.y * h - r.x, B = -r.y - r.x * h;
            if (f != null) {
              const G = this.hasZOffset, L = -10, F = tr + 10, Y = f.zOffset, ce = new Lg(e.x, e.y, Y, this.lineSoFar), _e = !!G && ym(e, L, F), ze = this.lineSoFar, Ne = this.distance;
              if (this.currentVertex) if (_e) {
                const Ee = this.currentVertexIsOutside, We = this.currentVertex, lt = new Lg(e.x, e.y, Y, this.lineSoFar);
                if (Dg(We, lt, L, F), !ym(lt, L, F)) {
                  if (Ee) {
                    this.e1 = this.e2 = -1, this.distance -= We.dist(ce), this.lineSoFar = We.w;
                    const yt = this.evaluateLineProgressFeatures(We.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                    this.addHalfVertex(We, O, H, b, !1, s, o, yt), this.addHalfVertex(We, y, B, b, !0, -h, o, yt), this.prevDistance = this.distance;
                  }
                  this.distance = this.prevDistance + We.dist(lt), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(We, lt, O, H, y, B, s, h, o, b), this.distance = Ne, this.scaledDistance = this.distance / this.totalDistance;
                }
              } else {
                const Ee = this.currentVertex;
                if (this.currentVertexIsOutside) {
                  Dg(Ee, ce, L, F), this.e1 = this.e2 = -1, this.distance -= Ee.dist(ce), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = Ee.w;
                  const We = this.evaluateLineProgressFeatures(Ee.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                  this.addHalfVertex(Ee, O, H, b, !1, s, o, We), this.addHalfVertex(Ee, y, B, b, !0, -h, o, We), this.prevDistance = this.distance, this.distance = Ne, this.scaledDistance = this.distance / this.totalDistance;
                }
                this.addVerticesTo(Ee, ce, O, H, y, B, s, h, o, b);
              }
              else _e || (this.addHalfVertex(e, O, H, b, !1, s, o, f), this.addHalfVertex(e, y, B, b, !0, -h, o, f));
              this.currentVertex = ce, this.currentVertexIsOutside = _e, this.lineSoFar = ze;
            } else this.addHalfVertex(e, O, H, b, !1, s, o, f), this.addHalfVertex(e, y, B, b, !0, -h, o, f);
          }
          addHalfVertex({ x: e, y: r }, s, h, o, f, b, O, H) {
            if (this.patternJoinNone && (this.segmentPoints.length === 0 && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), f || this.segmentPoints.push(this.lineSoFar - this.segmentStart, b)), this.layoutVertexArray.emplaceBack((e << 1) + (o ? 1 : 0), (r << 1) + (f ? 1 : 0), Math.round(63 * s) + 128, Math.round(63 * h) + 128, 1 + (b === 0 ? 0 : b < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {
              const B = Tr(this.lineClips.start, this.lineClips.end, this.scaledDistance);
              this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, B);
            }
            const y = O.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, y), O.primitiveLength++), f ? this.e2 = y : this.e1 = y, H != null && this.zOffsetVertexArray.emplaceBack(H.zOffset, H.variableWidth, H.variableWidth);
          }
          updateScaledDistance() {
            this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;
          }
          updateDistance(e, r) {
            this.prevDistance = this.distance, this.distance += e.dist(r), this.updateScaledDistance();
          }
        }
        function ym(a, e, r) {
          return a.x < e || a.x > r || a.y < e || a.y > r;
        }
        let l0, u0;
        function c0(a, e, r) {
          return e * (tr / (a.tileSize * Math.pow(2, r - a.tileID.overscaledZ)));
        }
        ur(vm, "LineBucket", { omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"] });
        const h0 = (a, e, r) => (1 - r) * a + r * e;
        function f0(a, e) {
          return 1 / c0(a, 1, e.tileZoom);
        }
        function d0(a, e, r, s) {
          return a.translatePosMatrix(s || e.tileID.projMatrix, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
        }
        const p0 = (a) => {
          const e = [];
          m0(a) && e.push("RENDER_LINE_DASH"), a.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
          const r = a.paint.get("line-trim-offset");
          r[0] === 0 && r[1] === 0 || e.push("RENDER_LINE_TRIM_OFFSET"), a.paint.get("line-border-width").constantOr(1) !== 0 && e.push("RENDER_LINE_BORDER");
          const s = a.layout.get("line-join").constantOr("miter") === "none", h = !!a.paint.get("line-pattern").constantOr(1);
          return s && h && e.push("LINE_JOIN_NONE"), e;
        };
        function m0(a) {
          const e = a.paint.get("line-dasharray").value;
          return e.value || e.kind !== "constant";
        }
        let xm;
        const _0 = () => xm || (xm = { layout: l0 || (l0 = new Wn({ "line-cap": new or(Ei.layout_line["line-cap"]), "line-join": new or(Ei.layout_line["line-join"]), "line-miter-limit": new Ji(Ei.layout_line["line-miter-limit"]), "line-round-limit": new Ji(Ei.layout_line["line-round-limit"]), "line-sort-key": new or(Ei.layout_line["line-sort-key"]), "line-z-offset": new or(Ei.layout_line["line-z-offset"]), "line-elevation-reference": new Ji(Ei.layout_line["line-elevation-reference"]), "line-cross-slope": new Ji(Ei.layout_line["line-cross-slope"]), visibility: new Ji(Ei.layout_line.visibility), "line-width-unit": new Ji(Ei.layout_line["line-width-unit"]) })), paint: u0 || (u0 = new Wn({ "line-opacity": new or(Ei.paint_line["line-opacity"]), "line-color": new or(Ei.paint_line["line-color"]), "line-translate": new Ji(Ei.paint_line["line-translate"]), "line-translate-anchor": new Ji(Ei.paint_line["line-translate-anchor"]), "line-width": new or(Ei.paint_line["line-width"]), "line-gap-width": new or(Ei.paint_line["line-gap-width"]), "line-offset": new or(Ei.paint_line["line-offset"]), "line-blur": new or(Ei.paint_line["line-blur"]), "line-dasharray": new or(Ei.paint_line["line-dasharray"]), "line-pattern": new or(Ei.paint_line["line-pattern"]), "line-gradient": new So(Ei.paint_line["line-gradient"]), "line-trim-offset": new Ji(Ei.paint_line["line-trim-offset"]), "line-trim-fade-range": new Ji(Ei.paint_line["line-trim-fade-range"]), "line-trim-color": new Ji(Ei.paint_line["line-trim-color"]), "line-emissive-strength": new Ji(Ei.paint_line["line-emissive-strength"]), "line-border-width": new or(Ei.paint_line["line-border-width"]), "line-border-color": new or(Ei.paint_line["line-border-color"]), "line-occlusion-opacity": new Ji(Ei.paint_line["line-occlusion-opacity"]), "line-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "line-gradient-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "line-trim-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "line-border-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, xm);
        class Dx extends or {
          possiblyEvaluate(e, r) {
            return r = new Tn(Math.floor(r.zoom), { now: r.now, fadeDuration: r.fadeDuration, transition: r.transition }), super.possiblyEvaluate(e, r);
          }
          evaluate(e, r, s, h) {
            return r = I({}, r, { zoom: Math.floor(r.zoom) }), super.evaluate(e, r, s, h);
          }
        }
        let Md;
        function g0(a, e) {
          return e > 0 ? e + 2 * a : a;
        }
        const zx = dn([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Bx = dn([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), Fx = dn([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
        dn([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Nx = dn([{ name: "a_auto_z_offset", components: 1, type: "Float32" }], 4), Ux = dn([{ name: "a_texb", components: 2, type: "Uint16" }]), Vx = dn([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_elevation_from_sea", components: 2, type: "Float32" }]), jx = dn([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_auto_z_offset", components: 1, type: "Float32" }]);
        dn([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const v0 = dn([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Gx = dn([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        dn([{ name: "triangle", components: 3, type: "Uint16" }]), dn([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), dn([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }]), dn([{ type: "Float32", name: "offsetX" }]), dn([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
        var Ns = 24;
        const Vu = 128;
        function bm(a, e, r, s, h) {
          if (a.kind === "camera") return a.maxSize;
          if (a.kind === "composite") {
            const o = e.possiblyEvaluate(new Tn(a.maxZoom), r).evaluate(h, {}, r), f = e.possiblyEvaluate(new Tn(a.minZoom), r).evaluate(h, {}, r);
            return Math.max(o, f);
          }
          return e.possiblyEvaluate(new Tn(s)).evaluate(h, {}, r);
        }
        function wm(a, e) {
          const { expression: r } = e;
          if (r.kind === "constant") return { kind: "constant", layoutSize: r.evaluate(new Tn(a + 1)) };
          if (r.kind === "source") return { kind: "source" };
          {
            const { zoomStops: s, interpolationType: h } = r;
            let o = 0;
            for (; o < s.length && s[o] <= a; ) o++;
            o = Math.max(0, o - 1);
            let f = o;
            for (; f < s.length && s[f] < a + 1; ) f++;
            f = Math.min(s.length - 1, f);
            const b = s[o], O = s[f];
            return r.kind === "composite" ? { kind: "composite", minZoom: b, maxZoom: O, interpolationType: h } : { kind: "camera", minZoom: b, maxZoom: O, minSize: r.evaluate(new Tn(b)), maxSize: r.evaluate(new Tn(O)), interpolationType: h };
          }
        }
        function mp(a, { uSize: e, uSizeT: r }, { lowerSize: s, upperSize: h }) {
          return a.kind === "source" ? s / Vu : a.kind === "composite" ? Tr(s / Vu, h / Vu, r) : e;
        }
        function Kf(a, e, r = 1) {
          let s = 0, h = 0;
          if (a.kind === "constant") h = a.layoutSize * r;
          else if (a.kind !== "source") {
            const { interpolationType: o, minZoom: f, maxZoom: b } = a, O = o ? pe(is.interpolationFactor(o, e, f, b), 0, 1) : 0;
            a.kind === "camera" ? h = Tr(a.minSize, a.maxSize, O) * r : s = O * r;
          }
          return { uSizeT: s, uSize: h };
        }
        var Hx = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: Vu, evaluateSizeForFeature: mp, evaluateSizeForZoom: Kf, getRasterizedIconSize: bm, getSizeData: wm });
        function qx(a, e, r) {
          return a.sections.forEach((s) => {
            s.text = function(h, o, f) {
              const b = o.layout.get("text-transform").evaluate(f, {});
              return b === "uppercase" ? h = h.toLocaleUpperCase() : b === "lowercase" && (h = h.toLocaleLowerCase()), Zs.applyArabicShaping && (h = Zs.applyArabicShaping(h)), h;
            }(s.text, e, r);
          }), a;
        }
        const Id = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
        function Wx(a) {
          return a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "";
        }
        function Zx(a) {
          return a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "" || a === "";
        }
        var y0, Sm, x0, Em = {};
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        function $x() {
          return y0 || (y0 = 1, Em.read = function(a, e, r, s, h) {
            var o, f, b = 8 * h - s - 1, O = (1 << b) - 1, H = O >> 1, y = -7, B = r ? h - 1 : 0, G = r ? -1 : 1, L = a[e + B];
            for (B += G, o = L & (1 << -y) - 1, L >>= -y, y += b; y > 0; o = 256 * o + a[e + B], B += G, y -= 8) ;
            for (f = o & (1 << -y) - 1, o >>= -y, y += s; y > 0; f = 256 * f + a[e + B], B += G, y -= 8) ;
            if (o === 0) o = 1 - H;
            else {
              if (o === O) return f ? NaN : 1 / 0 * (L ? -1 : 1);
              f += Math.pow(2, s), o -= H;
            }
            return (L ? -1 : 1) * f * Math.pow(2, o - s);
          }, Em.write = function(a, e, r, s, h, o) {
            var f, b, O, H = 8 * o - h - 1, y = (1 << H) - 1, B = y >> 1, G = h === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, L = s ? 0 : o - 1, F = s ? 1 : -1, Y = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
            for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (b = isNaN(e) ? 1 : 0, f = y) : (f = Math.floor(Math.log(e) / Math.LN2), e * (O = Math.pow(2, -f)) < 1 && (f--, O *= 2), (e += f + B >= 1 ? G / O : G * Math.pow(2, 1 - B)) * O >= 2 && (f++, O /= 2), f + B >= y ? (b = 0, f = y) : f + B >= 1 ? (b = (e * O - 1) * Math.pow(2, h), f += B) : (b = e * Math.pow(2, B - 1) * Math.pow(2, h), f = 0)); h >= 8; a[r + L] = 255 & b, L += F, b /= 256, h -= 8) ;
            for (f = f << h | b, H += h; H > 0; a[r + L] = 255 & f, L += F, f /= 256, H -= 8) ;
            a[r + L - F] |= 128 * Y;
          }), Em;
        }
        function b0() {
          if (x0) return Sm;
          x0 = 1, Sm = e;
          var a = $x();
          function e(Ee) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(Ee) ? Ee : new Uint8Array(Ee || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          e.Varint = 0, e.Fixed64 = 1, e.Bytes = 2, e.Fixed32 = 5;
          var r = 4294967296, s = 1 / r, h = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
          function o(Ee) {
            return Ee.type === e.Bytes ? Ee.readVarint() + Ee.pos : Ee.pos + 1;
          }
          function f(Ee, We, lt) {
            return lt ? 4294967296 * We + (Ee >>> 0) : 4294967296 * (We >>> 0) + (Ee >>> 0);
          }
          function b(Ee, We, lt) {
            var yt = We <= 16383 ? 1 : We <= 2097151 ? 2 : We <= 268435455 ? 3 : Math.floor(Math.log(We) / (7 * Math.LN2));
            lt.realloc(yt);
            for (var Bt = lt.pos - 1; Bt >= Ee; Bt--) lt.buf[Bt + yt] = lt.buf[Bt];
          }
          function O(Ee, We) {
            for (var lt = 0; lt < Ee.length; lt++) We.writeVarint(Ee[lt]);
          }
          function H(Ee, We) {
            for (var lt = 0; lt < Ee.length; lt++) We.writeSVarint(Ee[lt]);
          }
          function y(Ee, We) {
            for (var lt = 0; lt < Ee.length; lt++) We.writeFloat(Ee[lt]);
          }
          function B(Ee, We) {
            for (var lt = 0; lt < Ee.length; lt++) We.writeDouble(Ee[lt]);
          }
          function G(Ee, We) {
            for (var lt = 0; lt < Ee.length; lt++) We.writeBoolean(Ee[lt]);
          }
          function L(Ee, We) {
            for (var lt = 0; lt < Ee.length; lt++) We.writeFixed32(Ee[lt]);
          }
          function F(Ee, We) {
            for (var lt = 0; lt < Ee.length; lt++) We.writeSFixed32(Ee[lt]);
          }
          function Y(Ee, We) {
            for (var lt = 0; lt < Ee.length; lt++) We.writeFixed64(Ee[lt]);
          }
          function ce(Ee, We) {
            for (var lt = 0; lt < Ee.length; lt++) We.writeSFixed64(Ee[lt]);
          }
          function _e(Ee, We) {
            return (Ee[We] | Ee[We + 1] << 8 | Ee[We + 2] << 16) + 16777216 * Ee[We + 3];
          }
          function ze(Ee, We, lt) {
            Ee[lt] = We, Ee[lt + 1] = We >>> 8, Ee[lt + 2] = We >>> 16, Ee[lt + 3] = We >>> 24;
          }
          function Ne(Ee, We) {
            return (Ee[We] | Ee[We + 1] << 8 | Ee[We + 2] << 16) + (Ee[We + 3] << 24);
          }
          return e.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(Ee, We, lt) {
            for (lt = lt || this.length; this.pos < lt; ) {
              var yt = this.readVarint(), Bt = yt >> 3, zt = this.pos;
              this.type = 7 & yt, Ee(Bt, We, this), this.pos === zt && this.skip(yt);
            }
            return We;
          }, readMessage: function(Ee, We) {
            return this.readFields(Ee, We, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var Ee = _e(this.buf, this.pos);
            return this.pos += 4, Ee;
          }, readSFixed32: function() {
            var Ee = Ne(this.buf, this.pos);
            return this.pos += 4, Ee;
          }, readFixed64: function() {
            var Ee = _e(this.buf, this.pos) + _e(this.buf, this.pos + 4) * r;
            return this.pos += 8, Ee;
          }, readSFixed64: function() {
            var Ee = _e(this.buf, this.pos) + Ne(this.buf, this.pos + 4) * r;
            return this.pos += 8, Ee;
          }, readFloat: function() {
            var Ee = a.read(this.buf, this.pos, !0, 23, 4);
            return this.pos += 4, Ee;
          }, readDouble: function() {
            var Ee = a.read(this.buf, this.pos, !0, 52, 8);
            return this.pos += 8, Ee;
          }, readVarint: function(Ee) {
            var We, lt, yt = this.buf;
            return We = 127 & (lt = yt[this.pos++]), lt < 128 ? We : (We |= (127 & (lt = yt[this.pos++])) << 7, lt < 128 ? We : (We |= (127 & (lt = yt[this.pos++])) << 14, lt < 128 ? We : (We |= (127 & (lt = yt[this.pos++])) << 21, lt < 128 ? We : function(Bt, zt, Dt) {
              var ni, Gt, si = Dt.buf;
              if (ni = (112 & (Gt = si[Dt.pos++])) >> 4, Gt < 128 || (ni |= (127 & (Gt = si[Dt.pos++])) << 3, Gt < 128) || (ni |= (127 & (Gt = si[Dt.pos++])) << 10, Gt < 128) || (ni |= (127 & (Gt = si[Dt.pos++])) << 17, Gt < 128) || (ni |= (127 & (Gt = si[Dt.pos++])) << 24, Gt < 128) || (ni |= (1 & (Gt = si[Dt.pos++])) << 31, Gt < 128)) return f(Bt, ni, zt);
              throw new Error("Expected varint not more than 10 bytes");
            }(We |= (15 & (lt = yt[this.pos])) << 28, Ee, this))));
          }, readVarint64: function() {
            return this.readVarint(!0);
          }, readSVarint: function() {
            var Ee = this.readVarint();
            return Ee % 2 == 1 ? (Ee + 1) / -2 : Ee / 2;
          }, readBoolean: function() {
            return !!this.readVarint();
          }, readString: function() {
            var Ee = this.readVarint() + this.pos, We = this.pos;
            return this.pos = Ee, Ee - We >= 12 && h ? function(lt, yt, Bt) {
              return h.decode(lt.subarray(yt, Bt));
            }(this.buf, We, Ee) : function(lt, yt, Bt) {
              for (var zt = "", Dt = yt; Dt < Bt; ) {
                var ni, Gt, si, ci = lt[Dt], li = null, fi = ci > 239 ? 4 : ci > 223 ? 3 : ci > 191 ? 2 : 1;
                if (Dt + fi > Bt) break;
                fi === 1 ? ci < 128 && (li = ci) : fi === 2 ? (192 & (ni = lt[Dt + 1])) == 128 && (li = (31 & ci) << 6 | 63 & ni) <= 127 && (li = null) : fi === 3 ? (Gt = lt[Dt + 2], (192 & (ni = lt[Dt + 1])) == 128 && (192 & Gt) == 128 && ((li = (15 & ci) << 12 | (63 & ni) << 6 | 63 & Gt) <= 2047 || li >= 55296 && li <= 57343) && (li = null)) : fi === 4 && (Gt = lt[Dt + 2], si = lt[Dt + 3], (192 & (ni = lt[Dt + 1])) == 128 && (192 & Gt) == 128 && (192 & si) == 128 && ((li = (15 & ci) << 18 | (63 & ni) << 12 | (63 & Gt) << 6 | 63 & si) <= 65535 || li >= 1114112) && (li = null)), li === null ? (li = 65533, fi = 1) : li > 65535 && (li -= 65536, zt += String.fromCharCode(li >>> 10 & 1023 | 55296), li = 56320 | 1023 & li), zt += String.fromCharCode(li), Dt += fi;
              }
              return zt;
            }(this.buf, We, Ee);
          }, readBytes: function() {
            var Ee = this.readVarint() + this.pos, We = this.buf.subarray(this.pos, Ee);
            return this.pos = Ee, We;
          }, readPackedVarint: function(Ee, We) {
            if (this.type !== e.Bytes) return Ee.push(this.readVarint(We));
            var lt = o(this);
            for (Ee = Ee || []; this.pos < lt; ) Ee.push(this.readVarint(We));
            return Ee;
          }, readPackedSVarint: function(Ee) {
            if (this.type !== e.Bytes) return Ee.push(this.readSVarint());
            var We = o(this);
            for (Ee = Ee || []; this.pos < We; ) Ee.push(this.readSVarint());
            return Ee;
          }, readPackedBoolean: function(Ee) {
            if (this.type !== e.Bytes) return Ee.push(this.readBoolean());
            var We = o(this);
            for (Ee = Ee || []; this.pos < We; ) Ee.push(this.readBoolean());
            return Ee;
          }, readPackedFloat: function(Ee) {
            if (this.type !== e.Bytes) return Ee.push(this.readFloat());
            var We = o(this);
            for (Ee = Ee || []; this.pos < We; ) Ee.push(this.readFloat());
            return Ee;
          }, readPackedDouble: function(Ee) {
            if (this.type !== e.Bytes) return Ee.push(this.readDouble());
            var We = o(this);
            for (Ee = Ee || []; this.pos < We; ) Ee.push(this.readDouble());
            return Ee;
          }, readPackedFixed32: function(Ee) {
            if (this.type !== e.Bytes) return Ee.push(this.readFixed32());
            var We = o(this);
            for (Ee = Ee || []; this.pos < We; ) Ee.push(this.readFixed32());
            return Ee;
          }, readPackedSFixed32: function(Ee) {
            if (this.type !== e.Bytes) return Ee.push(this.readSFixed32());
            var We = o(this);
            for (Ee = Ee || []; this.pos < We; ) Ee.push(this.readSFixed32());
            return Ee;
          }, readPackedFixed64: function(Ee) {
            if (this.type !== e.Bytes) return Ee.push(this.readFixed64());
            var We = o(this);
            for (Ee = Ee || []; this.pos < We; ) Ee.push(this.readFixed64());
            return Ee;
          }, readPackedSFixed64: function(Ee) {
            if (this.type !== e.Bytes) return Ee.push(this.readSFixed64());
            var We = o(this);
            for (Ee = Ee || []; this.pos < We; ) Ee.push(this.readSFixed64());
            return Ee;
          }, skip: function(Ee) {
            var We = 7 & Ee;
            if (We === e.Varint) for (; this.buf[this.pos++] > 127; ) ;
            else if (We === e.Bytes) this.pos = this.readVarint() + this.pos;
            else if (We === e.Fixed32) this.pos += 4;
            else {
              if (We !== e.Fixed64) throw new Error("Unimplemented type: " + We);
              this.pos += 8;
            }
          }, writeTag: function(Ee, We) {
            this.writeVarint(Ee << 3 | We);
          }, realloc: function(Ee) {
            for (var We = this.length || 16; We < this.pos + Ee; ) We *= 2;
            if (We !== this.length) {
              var lt = new Uint8Array(We);
              lt.set(this.buf), this.buf = lt, this.length = We;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(Ee) {
            this.realloc(4), ze(this.buf, Ee, this.pos), this.pos += 4;
          }, writeSFixed32: function(Ee) {
            this.realloc(4), ze(this.buf, Ee, this.pos), this.pos += 4;
          }, writeFixed64: function(Ee) {
            this.realloc(8), ze(this.buf, -1 & Ee, this.pos), ze(this.buf, Math.floor(Ee * s), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(Ee) {
            this.realloc(8), ze(this.buf, -1 & Ee, this.pos), ze(this.buf, Math.floor(Ee * s), this.pos + 4), this.pos += 8;
          }, writeVarint: function(Ee) {
            (Ee = +Ee || 0) > 268435455 || Ee < 0 ? function(We, lt) {
              var yt, Bt;
              if (We >= 0 ? (yt = We % 4294967296 | 0, Bt = We / 4294967296 | 0) : (Bt = ~(-We / 4294967296), 4294967295 ^ (yt = ~(-We % 4294967296)) ? yt = yt + 1 | 0 : (yt = 0, Bt = Bt + 1 | 0)), We >= 18446744073709552e3 || We < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              lt.realloc(10), function(zt, Dt, ni) {
                ni.buf[ni.pos++] = 127 & zt | 128, zt >>>= 7, ni.buf[ni.pos++] = 127 & zt | 128, zt >>>= 7, ni.buf[ni.pos++] = 127 & zt | 128, zt >>>= 7, ni.buf[ni.pos++] = 127 & zt | 128, ni.buf[ni.pos] = 127 & (zt >>>= 7);
              }(yt, 0, lt), function(zt, Dt) {
                var ni = (7 & zt) << 4;
                Dt.buf[Dt.pos++] |= ni | ((zt >>>= 3) ? 128 : 0), zt && (Dt.buf[Dt.pos++] = 127 & zt | ((zt >>>= 7) ? 128 : 0), zt && (Dt.buf[Dt.pos++] = 127 & zt | ((zt >>>= 7) ? 128 : 0), zt && (Dt.buf[Dt.pos++] = 127 & zt | ((zt >>>= 7) ? 128 : 0), zt && (Dt.buf[Dt.pos++] = 127 & zt | ((zt >>>= 7) ? 128 : 0), zt && (Dt.buf[Dt.pos++] = 127 & zt)))));
              }(Bt, lt);
            }(Ee, this) : (this.realloc(4), this.buf[this.pos++] = 127 & Ee | (Ee > 127 ? 128 : 0), Ee <= 127 || (this.buf[this.pos++] = 127 & (Ee >>>= 7) | (Ee > 127 ? 128 : 0), Ee <= 127 || (this.buf[this.pos++] = 127 & (Ee >>>= 7) | (Ee > 127 ? 128 : 0), Ee <= 127 || (this.buf[this.pos++] = Ee >>> 7 & 127))));
          }, writeSVarint: function(Ee) {
            this.writeVarint(Ee < 0 ? 2 * -Ee - 1 : 2 * Ee);
          }, writeBoolean: function(Ee) {
            this.writeVarint(!!Ee);
          }, writeString: function(Ee) {
            Ee = String(Ee), this.realloc(4 * Ee.length), this.pos++;
            var We = this.pos;
            this.pos = function(yt, Bt, zt) {
              for (var Dt, ni, Gt = 0; Gt < Bt.length; Gt++) {
                if ((Dt = Bt.charCodeAt(Gt)) > 55295 && Dt < 57344) {
                  if (!ni) {
                    Dt > 56319 || Gt + 1 === Bt.length ? (yt[zt++] = 239, yt[zt++] = 191, yt[zt++] = 189) : ni = Dt;
                    continue;
                  }
                  if (Dt < 56320) {
                    yt[zt++] = 239, yt[zt++] = 191, yt[zt++] = 189, ni = Dt;
                    continue;
                  }
                  Dt = ni - 55296 << 10 | Dt - 56320 | 65536, ni = null;
                } else ni && (yt[zt++] = 239, yt[zt++] = 191, yt[zt++] = 189, ni = null);
                Dt < 128 ? yt[zt++] = Dt : (Dt < 2048 ? yt[zt++] = Dt >> 6 | 192 : (Dt < 65536 ? yt[zt++] = Dt >> 12 | 224 : (yt[zt++] = Dt >> 18 | 240, yt[zt++] = Dt >> 12 & 63 | 128), yt[zt++] = Dt >> 6 & 63 | 128), yt[zt++] = 63 & Dt | 128);
              }
              return zt;
            }(this.buf, Ee, this.pos);
            var lt = this.pos - We;
            lt >= 128 && b(We, lt, this), this.pos = We - 1, this.writeVarint(lt), this.pos += lt;
          }, writeFloat: function(Ee) {
            this.realloc(4), a.write(this.buf, Ee, this.pos, !0, 23, 4), this.pos += 4;
          }, writeDouble: function(Ee) {
            this.realloc(8), a.write(this.buf, Ee, this.pos, !0, 52, 8), this.pos += 8;
          }, writeBytes: function(Ee) {
            var We = Ee.length;
            this.writeVarint(We), this.realloc(We);
            for (var lt = 0; lt < We; lt++) this.buf[this.pos++] = Ee[lt];
          }, writeRawMessage: function(Ee, We) {
            this.pos++;
            var lt = this.pos;
            Ee(We, this);
            var yt = this.pos - lt;
            yt >= 128 && b(lt, yt, this), this.pos = lt - 1, this.writeVarint(yt), this.pos += yt;
          }, writeMessage: function(Ee, We, lt) {
            this.writeTag(Ee, e.Bytes), this.writeRawMessage(We, lt);
          }, writePackedVarint: function(Ee, We) {
            We.length && this.writeMessage(Ee, O, We);
          }, writePackedSVarint: function(Ee, We) {
            We.length && this.writeMessage(Ee, H, We);
          }, writePackedBoolean: function(Ee, We) {
            We.length && this.writeMessage(Ee, G, We);
          }, writePackedFloat: function(Ee, We) {
            We.length && this.writeMessage(Ee, y, We);
          }, writePackedDouble: function(Ee, We) {
            We.length && this.writeMessage(Ee, B, We);
          }, writePackedFixed32: function(Ee, We) {
            We.length && this.writeMessage(Ee, L, We);
          }, writePackedSFixed32: function(Ee, We) {
            We.length && this.writeMessage(Ee, F, We);
          }, writePackedFixed64: function(Ee, We) {
            We.length && this.writeMessage(Ee, Y, We);
          }, writePackedSFixed64: function(Ee, We) {
            We.length && this.writeMessage(Ee, ce, We);
          }, writeBytesField: function(Ee, We) {
            this.writeTag(Ee, e.Bytes), this.writeBytes(We);
          }, writeFixed32Field: function(Ee, We) {
            this.writeTag(Ee, e.Fixed32), this.writeFixed32(We);
          }, writeSFixed32Field: function(Ee, We) {
            this.writeTag(Ee, e.Fixed32), this.writeSFixed32(We);
          }, writeFixed64Field: function(Ee, We) {
            this.writeTag(Ee, e.Fixed64), this.writeFixed64(We);
          }, writeSFixed64Field: function(Ee, We) {
            this.writeTag(Ee, e.Fixed64), this.writeSFixed64(We);
          }, writeVarintField: function(Ee, We) {
            this.writeTag(Ee, e.Varint), this.writeVarint(We);
          }, writeSVarintField: function(Ee, We) {
            this.writeTag(Ee, e.Varint), this.writeSVarint(We);
          }, writeStringField: function(Ee, We) {
            this.writeTag(Ee, e.Bytes), this.writeString(We);
          }, writeFloatField: function(Ee, We) {
            this.writeTag(Ee, e.Fixed32), this.writeFloat(We);
          }, writeDoubleField: function(Ee, We) {
            this.writeTag(Ee, e.Fixed64), this.writeDouble(We);
          }, writeBooleanField: function(Ee, We) {
            this.writeVarintField(Ee, !!We);
          } }, Sm;
        }
        var _p = N(b0());
        const Tm = 3;
        function Xx(a, e, r) {
          e.glyphs = [], a === 1 && r.readMessage(Yx, e);
        }
        function Yx(a, e, r) {
          if (a === 3) {
            const { id: s, bitmap: h, width: o, height: f, left: b, top: O, advance: H } = r.readMessage(Kx, {});
            e.glyphs.push({ id: s, bitmap: new tu({ width: o + 2 * Tm, height: f + 2 * Tm }, h), metrics: { width: o, height: f, left: b, top: O, advance: H } });
          } else a === 4 ? e.ascender = r.readSVarint() : a === 5 && (e.descender = r.readSVarint());
        }
        function Kx(a, e, r) {
          a === 1 ? e.id = r.readVarint() : a === 2 ? e.bitmap = r.readBytes() : a === 3 ? e.width = r.readVarint() : a === 4 ? e.height = r.readVarint() : a === 5 ? e.left = r.readSVarint() : a === 6 ? e.top = r.readSVarint() : a === 7 && (e.advance = r.readVarint());
        }
        const w0 = Tm, Ml = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
        class Pd {
          constructor() {
            this.scale = 1, this.fontStack = "", this.image = null;
          }
          static forText(e, r) {
            const s = new Pd();
            return s.scale = e || 1, s.fontStack = r, s;
          }
          static forImage(e) {
            const r = new Pd();
            return r.image = e, r;
          }
        }
        class Jf {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(e, r) {
            const s = new Jf();
            for (let h = 0; h < e.sections.length; h++) {
              const o = e.sections[h];
              o.image ? s.addImageSection(o) : s.addTextSection(o, r);
            }
            return s;
          }
          length() {
            return this.text.length;
          }
          getSection(e) {
            return this.sections[this.sectionIndex[e]];
          }
          getSections() {
            return this.sections;
          }
          getSectionIndex(e) {
            return this.sectionIndex[e];
          }
          getCodePoint(e) {
            return this.text.codePointAt(e);
          }
          verticalizePunctuation(e) {
            this.text = function(r, s) {
              let h = "";
              for (let o = 0; o < r.length; o++) {
                const f = r.charCodeAt(o + 1) || null, b = r.charCodeAt(o - 1) || null;
                h += !s && (f && Sa(f) && !Id[r[o + 1]] || b && Sa(b) && !Id[r[o - 1]]) || !Id[r[o]] ? r[o] : Id[r[o]];
              }
              return h;
            }(this.text, e);
          }
          trim() {
            let e = 0;
            for (let s = 0; s < this.text.length && gp[this.text.charCodeAt(s)]; s++) e++;
            let r = this.text.length;
            for (let s = this.text.length - 1; s >= 0 && s >= e && gp[this.text.charCodeAt(s)]; s--) r--;
            this.text = this.text.substring(e, r), this.sectionIndex = this.sectionIndex.slice(e, r);
          }
          substring(e, r) {
            const s = new Jf();
            return s.text = this.text.substring(e, r), s.sectionIndex = this.sectionIndex.slice(e, r), s.sections = this.sections, s;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((e, r) => Math.max(e, this.sections[r].scale), 0);
          }
          addTextSection(e, r) {
            this.text += e.text, this.sections.push(Pd.forText(e.scale, e.fontStack || r));
            const s = this.sections.length - 1;
            for (let h = 0; h < e.text.length; ++h) this.sectionIndex.push(s);
          }
          addImageSection(e) {
            const r = e.image && e.image.namePrimary ? e.image.getPrimary() : null;
            if (!r) return void Se("Can't add FormattedSection with an empty image.");
            const s = this.getNextImageSectionCharCode();
            s ? (this.text += String.fromCodePoint(s), this.sections.push(Pd.forImage(r)), this.sectionIndex.push(this.sections.length - 1)) : Se("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Cm(a, e, r, s, h, o, f, b, O, H, y, B, G, L, F) {
          const Y = Jf.fromFeature(a, h);
          B === Ml.vertical && Y.verticalizePunctuation(G);
          let ce = [];
          const _e = function(lt, yt, Bt, zt, Dt, ni) {
            if (!lt) return [];
            const Gt = [], si = function(gi, Si, pi, zi, Gi, Oi) {
              let lr = 0;
              for (let ar = 0; ar < gi.length(); ar++) {
                const Qi = gi.getSection(ar);
                lr += S0(gi.getCodePoint(ar), Qi, zi, Gi, Si, Oi);
              }
              return lr / Math.max(1, Math.ceil(lr / pi));
            }(lt, yt, Bt, zt, Dt, ni), ci = lt.text.indexOf("") >= 0;
            let li = 0;
            for (let gi = 0; gi < lt.length(); gi++) {
              const Si = lt.getSection(gi), pi = lt.getCodePoint(gi);
              if (gp[pi] || (li += S0(pi, Si, zt, Dt, yt, ni)), gi < lt.length() - 1) {
                const zi = !((fi = pi) < 11904 || !(wr["Bopomofo Extended"](fi) || wr.Bopomofo(fi) || wr["CJK Compatibility Forms"](fi) || wr["CJK Compatibility Ideographs"](fi) || wr["CJK Compatibility"](fi) || wr["CJK Radicals Supplement"](fi) || wr["CJK Strokes"](fi) || wr["CJK Symbols and Punctuation"](fi) || wr["CJK Unified Ideographs Extension A"](fi) || wr["CJK Unified Ideographs"](fi) || wr["Enclosed CJK Letters and Months"](fi) || wr["Halfwidth and Fullwidth Forms"](fi) || wr.Hiragana(fi) || wr["Ideographic Description Characters"](fi) || wr["Kangxi Radicals"](fi) || wr["Katakana Phonetic Extensions"](fi) || wr.Katakana(fi) || wr["Vertical Forms"](fi) || wr["Yi Radicals"](fi) || wr["Yi Syllables"](fi)));
                (Jx[pi] || zi || Si.image) && Gt.push(T0(gi + 1, li, si, Gt, Qx(pi, lt.getCodePoint(gi + 1), zi && ci), !1));
              }
            }
            var fi;
            return C0(T0(lt.length(), li, si, Gt, 0, !0));
          }(Y, H, o, e, s, L), { processBidirectionalText: ze, processStyledBidirectionalText: Ne } = Zs;
          if (ze && Y.sections.length === 1) {
            const lt = ze(Y.toString(), _e);
            for (const yt of lt) {
              const Bt = new Jf();
              Bt.text = yt, Bt.sections = Y.sections;
              for (let zt = 0; zt < yt.length; zt++) Bt.sectionIndex.push(0);
              ce.push(Bt);
            }
          } else if (Ne) {
            const lt = Ne(Y.text, Y.sectionIndex, _e);
            for (const yt of lt) {
              const Bt = new Jf();
              Bt.text = yt[0], Bt.sectionIndex = yt[1], Bt.sections = Y.sections, ce.push(Bt);
            }
          } else ce = function(lt, yt) {
            const Bt = [], zt = lt.text;
            let Dt = 0;
            for (const ni of yt) Bt.push(lt.substring(Dt, ni)), Dt = ni;
            return Dt < zt.length && Bt.push(lt.substring(Dt, zt.length)), Bt;
          }(Y, _e);
          const Ee = [], We = { positionedLines: Ee, text: Y.toString(), top: y[1], bottom: y[1], left: y[0], right: y[0], writingMode: B, iconsInText: !1, verticalizable: !1, hasBaseline: !1 };
          return function(lt, yt, Bt, zt, Dt, ni, Gt, si, ci, li, fi, gi) {
            let Si = 0, pi = 0, zi = 0;
            const Gi = si === "right" ? 1 : si === "left" ? 0 : 0.5;
            let Oi = !1;
            for (const hr of Dt) {
              const pr = hr.getSections();
              for (const Ur of pr) {
                if (Ur.image) continue;
                const Xr = yt[Ur.fontStack];
                if (Xr && (Oi = Xr.ascender !== void 0 && Xr.descender !== void 0, !Oi)) break;
              }
              if (!Oi) break;
            }
            let lr = 0;
            for (const hr of Dt) {
              hr.trim();
              const pr = hr.getMaxScale(), Ur = (pr - 1) * Ns, Xr = { positionedGlyphs: [], lineOffset: 0 };
              lt.positionedLines[lr] = Xr;
              const Yr = Xr.positionedGlyphs;
              let Kr = 0;
              if (!hr.length()) {
                pi += ni, ++lr;
                continue;
              }
              let sn = 0, cn = 0;
              for (let In = 0; In < hr.length(); In++) {
                const Gr = hr.getSection(In), Sn = hr.getSectionIndex(In), An = hr.getCodePoint(In);
                let Jn = Gr.scale, Oa = null, Za = null, Da = null, Ma = Ns, Fa = 0;
                const Ja = !(ci === Ml.horizontal || !fi && !Ss(An) || fi && (gp[An] || (ar = An, wr.Arabic(ar) || wr["Arabic Supplement"](ar) || wr["Arabic Extended-A"](ar) || wr["Arabic Presentation Forms-A"](ar) || wr["Arabic Presentation Forms-B"](ar))));
                if (Gr.image) {
                  const Us = zt[Gr.image.serialize()];
                  if (!Us) continue;
                  Da = Gr.image.id, lt.iconsInText = lt.iconsInText || !0, Za = Us.paddedRect;
                  const Xn = Us.displaySize;
                  Jn = Jn * Ns / gi, Oa = { width: Xn[0], height: Xn[1], left: 0, top: -w0, advance: Ja ? Xn[1] : Xn[0], localGlyph: !1 }, Fa = Oi ? -Oa.height * Jn : pr * Ns - 17 - Xn[1] * Jn, Ma = Oa.advance;
                  const Do = (Ja ? Xn[0] : Xn[1]) * Jn - Ns * pr;
                  Do > 0 && Do > Kr && (Kr = Do);
                } else {
                  const Us = Bt[Gr.fontStack];
                  if (!Us) continue;
                  Us[An] && (Za = Us[An]);
                  const Xn = yt[Gr.fontStack];
                  if (!Xn) continue;
                  const Do = Xn.glyphs[An];
                  if (!Do) continue;
                  if (Oa = Do.metrics, Ma = An !== 8203 ? Ns : 0, Oi) {
                    const Wu = Xn.ascender !== void 0 ? Math.abs(Xn.ascender) : 0, ru = Xn.descender !== void 0 ? Math.abs(Xn.descender) : 0, nu = (Wu + ru) * Jn;
                    sn < nu && (sn = nu, cn = (Wu - ru) / 2 * Jn), Fa = -Wu * Jn;
                  } else Fa = (pr - Jn) * Ns - 17;
                }
                Ja ? (lt.verticalizable = !0, Yr.push({ glyph: An, imageName: Da, x: Si, y: pi + Fa, vertical: Ja, scale: Jn, localGlyph: Oa.localGlyph, fontStack: Gr.fontStack, sectionIndex: Sn, metrics: Oa, rect: Za }), Si += Ma * Jn + li) : (Yr.push({ glyph: An, imageName: Da, x: Si, y: pi + Fa, vertical: Ja, scale: Jn, localGlyph: Oa.localGlyph, fontStack: Gr.fontStack, sectionIndex: Sn, metrics: Oa, rect: Za }), Si += Oa.advance * Jn + li);
              }
              Yr.length !== 0 && (zi = Math.max(Si - li, zi), Oi ? A0(Yr, Gi, Kr, cn, ni * pr / 2) : A0(Yr, Gi, Kr, 0, ni / 2)), Si = 0;
              const Un = ni * pr + Kr;
              Xr.lineOffset = Math.max(Kr, Ur), pi += Un, ++lr;
            }
            var ar;
            const Qi = pi, { horizontalAlign: qi, verticalAlign: xr } = Am(Gt);
            (function(hr, pr, Ur, Xr, Yr, Kr) {
              const sn = (pr - Ur) * Yr, cn = -Kr * Xr;
              for (const Un of hr) for (const In of Un.positionedGlyphs) In.x += sn, In.y += cn;
            })(lt.positionedLines, Gi, qi, xr, zi, Qi), lt.top += -xr * Qi, lt.bottom = lt.top + Qi, lt.left += -qi * zi, lt.right = lt.left + zi, lt.hasBaseline = Oi;
          }(We, e, r, s, ce, f, b, O, B, H, G, F), !function(lt) {
            for (const yt of lt) if (yt.positionedGlyphs.length !== 0) return !1;
            return !0;
          }(Ee) && We;
        }
        const gp = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, Jx = { 10: !0, 32: !0, 38: !0, 40: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 };
        function S0(a, e, r, s, h, o) {
          if (e.image) {
            const f = s[e.image.serialize()];
            return f ? f.displaySize[0] * e.scale * Ns / o + h : 0;
          }
          {
            const f = r[e.fontStack], b = f && f.glyphs[a];
            return b ? b.metrics.advance * e.scale + h : 0;
          }
        }
        function E0(a, e, r, s) {
          const h = Math.pow(a - e, 2);
          return s ? a < e ? h / 2 : 2 * h : h + Math.abs(r) * r;
        }
        function Qx(a, e, r) {
          let s = 0;
          return a === 10 && (s -= 1e4), r && (s += 150), a !== 40 && a !== 65288 || (s += 50), e !== 41 && e !== 65289 || (s += 50), s;
        }
        function T0(a, e, r, s, h, o) {
          let f = null, b = E0(e, r, h, o);
          for (const O of s) {
            const H = E0(e - O.x, r, h, o) + O.badness;
            H <= b && (f = O, b = H);
          }
          return { index: a, x: e, priorBreak: f, badness: b };
        }
        function C0(a) {
          return a ? C0(a.priorBreak).concat(a.index) : [];
        }
        function Am(a) {
          let e = 0.5, r = 0.5;
          switch (a) {
            case "right":
            case "top-right":
            case "bottom-right":
              e = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e = 0;
          }
          switch (a) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r = 0;
          }
          return { horizontalAlign: e, verticalAlign: r };
        }
        function A0(a, e, r, s, h) {
          if (!(e || r || s || h)) return;
          const o = a.length - 1, f = a[o], b = (f.x + f.metrics.advance * f.scale) * e;
          for (let O = 0; O <= o; O++) a[O].x -= b, a[O].y += r + s + h;
        }
        function eb(a, e, r, s) {
          const { horizontalAlign: h, verticalAlign: o } = Am(s), f = r[0] - a.displaySize[0] * h, b = r[1] - a.displaySize[1] * o;
          return { imagePrimary: a, imageSecondary: e, top: b, bottom: b + a.displaySize[1], left: f, right: f + a.displaySize[0] };
        }
        function M0(a, e, r, s, h, o) {
          const f = a.imagePrimary;
          let b;
          if (f.content) {
            const ce = f.content, _e = f.pixelRatio || 1;
            b = [ce[0] / _e, ce[1] / _e, f.displaySize[0] - ce[2] / _e, f.displaySize[1] - ce[3] / _e];
          }
          const O = e.left * o, H = e.right * o;
          let y, B, G, L;
          r === "width" || r === "both" ? (L = h[0] + O - s[3], B = h[0] + H + s[1]) : (L = h[0] + (O + H - f.displaySize[0]) / 2, B = L + f.displaySize[0]);
          const F = e.top * o, Y = e.bottom * o;
          return r === "height" || r === "both" ? (y = h[1] + F - s[0], G = h[1] + Y + s[2]) : (y = h[1] + (F + Y - f.displaySize[1]) / 2, G = y + f.displaySize[1]), { imagePrimary: f, imageSecondary: void 0, top: y, right: B, bottom: G, left: L, collisionPadding: b };
        }
        class sh extends At {
          constructor(e, r, s, h, o) {
            super(e, r), this.angle = h, this.z = s, o !== void 0 && (this.segment = o);
          }
          clone() {
            return new sh(this.x, this.y, this.z, this.angle, this.segment);
          }
        }
        function I0(a, e, r, s, h) {
          if (e.segment === void 0) return !0;
          let o = e, f = e.segment + 1, b = 0;
          for (; b > -r / 2; ) {
            if (f--, f < 0) return !1;
            b -= a[f].dist(o), o = a[f];
          }
          b += a[f].dist(a[f + 1]), f++;
          const O = [];
          let H = 0;
          for (; b < r / 2; ) {
            const y = a[f], B = a[f + 1];
            if (!B) return !1;
            let G = a[f - 1].angleTo(y) - y.angleTo(B);
            for (G = Math.abs((G + 3 * Math.PI) % (2 * Math.PI) - Math.PI), O.push({ distance: b, angleDelta: G }), H += G; b - O[0].distance > s; ) H -= O.shift().angleDelta;
            if (H > h) return !1;
            f++, b += y.dist(B);
          }
          return !0;
        }
        function P0(a) {
          let e = 0;
          for (let r = 0; r < a.length - 1; r++) e += a[r].dist(a[r + 1]);
          return e;
        }
        function R0(a, e, r) {
          return a ? 0.6 * e * r : 0;
        }
        function k0(a, e) {
          return Math.max(a ? a.right - a.left : 0, e ? e.right - e.left : 0);
        }
        function tb(a, e, r, s, h, o) {
          const f = R0(r, h, o), b = k0(r, s) * o;
          let O = 0;
          const H = P0(a) / 2;
          for (let y = 0; y < a.length - 1; y++) {
            const B = a[y], G = a[y + 1], L = B.dist(G);
            if (O + L > H) {
              const F = (H - O) / L, Y = Tr(B.x, G.x, F), ce = Tr(B.y, G.y, F), _e = new sh(Y, ce, 0, G.angleTo(B), y);
              return !f || I0(a, _e, b, f, e) ? _e : void 0;
            }
            O += L;
          }
        }
        function ib(a, e, r, s, h, o, f, b, O) {
          const H = R0(s, o, f), y = k0(s, h), B = y * f, G = a[0].x === 0 || a[0].x === O || a[0].y === 0 || a[0].y === O;
          return e - B < e / 4 && (e = B + e / 4), L0(a, G ? e / 2 * b % e : (y / 2 + 2 * o) * f * b % e, e, H, r, B, G, !1, O);
        }
        function L0(a, e, r, s, h, o, f, b, O) {
          const H = o / 2, y = P0(a);
          let B = 0, G = e - r, L = [];
          for (let F = 0; F < a.length - 1; F++) {
            const Y = a[F], ce = a[F + 1], _e = Y.dist(ce), ze = ce.angleTo(Y);
            for (; G + r < B + _e; ) {
              G += r;
              const Ne = (G - B) / _e, Ee = Tr(Y.x, ce.x, Ne), We = Tr(Y.y, ce.y, Ne);
              if (Ee >= 0 && Ee < O && We >= 0 && We < O && G - H >= 0 && G + H <= y) {
                const lt = new sh(Ee, We, 0, ze, F);
                s && !I0(a, lt, o, s, h) || L.push(lt);
              }
            }
            B += _e;
          }
          return b || L.length || f || (L = L0(a, B / 2, r, s, h, o, f, !0, O)), L;
        }
        function O0(a, e, r, s, h) {
          const o = [];
          for (let f = 0; f < a.length; f++) {
            const b = a[f];
            let O;
            for (let H = 0; H < b.length - 1; H++) {
              let y = b[H], B = b[H + 1];
              y.x < e && B.x < e || (y.x < e ? y = new At(e, y.y + (e - y.x) / (B.x - y.x) * (B.y - y.y))._round() : B.x < e && (B = new At(e, y.y + (e - y.x) / (B.x - y.x) * (B.y - y.y))._round()), y.y < r && B.y < r || (y.y < r ? y = new At(y.x + (r - y.y) / (B.y - y.y) * (B.x - y.x), r)._round() : B.y < r && (B = new At(y.x + (r - y.y) / (B.y - y.y) * (B.x - y.x), r)._round()), y.x >= s && B.x >= s || (y.x >= s ? y = new At(s, y.y + (s - y.x) / (B.x - y.x) * (B.y - y.y))._round() : B.x >= s && (B = new At(s, y.y + (s - y.x) / (B.x - y.x) * (B.y - y.y))._round()), y.y >= h && B.y >= h || (y.y >= h ? y = new At(y.x + (h - y.y) / (B.y - y.y) * (B.x - y.x), h)._round() : B.y >= h && (B = new At(y.x + (h - y.y) / (B.y - y.y) * (B.x - y.x), h)._round()), O && y.equals(O[O.length - 1]) || (O = [y], o.push(O)), O.push(B)))));
            }
          }
          return o;
        }
        function D0(a) {
          let e = 0, r = 0;
          for (const f of a) e += f.w * f.h, r = Math.max(r, f.w);
          a.sort((f, b) => b.h - f.h);
          const s = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), r), h: 1 / 0 }];
          let h = 0, o = 0;
          for (const f of a) for (let b = s.length - 1; b >= 0; b--) {
            const O = s[b];
            if (!(f.w > O.w || f.h > O.h)) {
              if (f.x = O.x, f.y = O.y, o = Math.max(o, f.y + f.h), h = Math.max(h, f.x + f.w), f.w === O.w && f.h === O.h) {
                const H = s.pop();
                b < s.length && (s[b] = H);
              } else f.h === O.h ? (O.x += f.w, O.w -= f.w) : f.w === O.w ? (O.y += f.h, O.h -= f.h) : (s.push({ x: O.x + f.w, y: O.y, w: O.w - f.w, h: f.h }), O.y += f.h, O.h -= f.h);
              break;
            }
          }
          return { w: h, h: o, fill: e / (h * o) || 0 };
        }
        ur(sh, "Anchor");
        const Rd = 1;
        class kd {
          static getImagePositionScale(e, r, s) {
            return r && e && e.options && e.options.transform ? { x: e.options.transform.a, y: e.options.transform.d } : { x: s, y: s };
          }
          constructor(e, { pixelRatio: r, version: s, stretchX: h, stretchY: o, content: f, sdf: b, usvg: O }, H, y) {
            this.paddedRect = e, this.pixelRatio = r, this.stretchX = h, this.stretchY = o, this.content = f, this.version = s, this.padding = H, this.sdf = b, this.scale = kd.getImagePositionScale(y, O, r);
          }
          get tl() {
            return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * this.padding) / this.scale.x, (this.paddedRect.h - 2 * this.padding) / this.scale.y];
          }
        }
        class z0 {
          constructor(e, r, s) {
            const h = {}, o = {};
            this.haveRenderCallbacks = [];
            const f = [];
            this.addImages(e, h, Rd, f), this.addImages(r, o, 2, f);
            const { w: b, h: O } = D0(f), H = new ds({ width: b || 1, height: O || 1 });
            for (const y in e) {
              const B = e[y], G = h[y].paddedRect;
              ds.copy(B.data, H, { x: 0, y: 0 }, { x: G.x + Rd, y: G.y + Rd }, B.data, s, B.sdf);
            }
            for (const y in r) {
              const B = r[y], G = o[y].paddedRect;
              let L = o[y].padding;
              const F = G.x + L, Y = G.y + L, ce = B.data.width, _e = B.data.height;
              L = L > 1 ? L - 1 : L, ds.copy(B.data, H, { x: 0, y: 0 }, { x: F, y: Y }, B.data, s), ds.copy(B.data, H, { x: 0, y: _e - L }, { x: F, y: Y - L }, { width: ce, height: L }, s), ds.copy(B.data, H, { x: 0, y: 0 }, { x: F, y: Y + _e }, { width: ce, height: L }, s), ds.copy(B.data, H, { x: ce - L, y: 0 }, { x: F - L, y: Y }, { width: L, height: _e }, s), ds.copy(B.data, H, { x: 0, y: 0 }, { x: F + ce, y: Y }, { width: L, height: _e }, s), ds.copy(B.data, H, { x: ce - L, y: _e - L }, { x: F - L, y: Y - L }, { width: L, height: L }, s), ds.copy(B.data, H, { x: 0, y: _e - L }, { x: F + ce, y: Y - L }, { width: L, height: L }, s), ds.copy(B.data, H, { x: 0, y: 0 }, { x: F + ce, y: Y + _e }, { width: L, height: L }, s), ds.copy(B.data, H, { x: ce - L, y: 0 }, { x: F - L, y: Y + _e }, { width: L, height: L }, s);
            }
            this.lut = s, this.image = H, this.iconPositions = h, this.patternPositions = o;
          }
          addImages(e, r, s, h) {
            for (const o in e) {
              const f = e[o], b = { x: 0, y: 0, w: f.data.width + 2 * s, h: f.data.height + 2 * s };
              h.push(b);
              const O = bs.deserializeFromString(o);
              r[o] = new kd(b, f, s, O), f.hasRenderCallback && this.haveRenderCallbacks.push(O.id);
            }
          }
          patchUpdatedImages(e, r, s) {
            this.haveRenderCallbacks = this.haveRenderCallbacks.filter((h) => e.hasImage(h, s)), e.dispatchRenderCallbacks(this.haveRenderCallbacks, s);
            for (const h in e.getUpdatedImages(s)) {
              for (const o of Object.keys(this.iconPositions)) bs.deserializeId(o) === h && this.patchUpdatedImage(this.iconPositions[o], e.getImage(h, s), r);
              for (const o of Object.keys(this.patternPositions)) bs.deserializeId(o) === h && this.patchUpdatedImage(this.patternPositions[o], e.getImage(h, s), r);
            }
          }
          patchUpdatedImage(e, r, s) {
            if (!e || !r || e.version === r.version) return;
            e.version = r.version;
            const [h, o] = e.tl, f = e.sdf;
            if (this.lut || f) {
              const b = { width: r.data.width, height: r.data.height }, O = new ds(b);
              ds.copy(r.data, O, { x: 0, y: 0 }, { x: 0, y: 0 }, b, this.lut, f), s.update(O, { position: { x: h, y: o } });
            } else s.update(r.data, { position: { x: h, y: o } });
          }
        }
        ur(kd, "ImagePosition"), ur(z0, "ImageAtlas");
        const Ld = 1e20;
        function B0(a, e, r, s, h, o, f, b, O) {
          for (let H = e; H < e + s; H++) F0(a, r * o + H, o, h, f, b, O);
          for (let H = r; H < r + h; H++) F0(a, H * o + e, 1, s, f, b, O);
        }
        function F0(a, e, r, s, h, o, f) {
          o[0] = 0, f[0] = -Ld, f[1] = Ld, h[0] = a[e];
          for (let b = 1, O = 0, H = 0; b < s; b++) {
            h[b] = a[e + b * r];
            const y = b * b;
            do {
              const B = o[O];
              H = (h[b] - h[B] + y - B * B) / (b - B) / 2;
            } while (H <= f[O] && --O > -1);
            O++, o[O] = b, f[O] = H, f[O + 1] = Ld;
          }
          for (let b = 0, O = 0; b < s; b++) {
            for (; f[O + 1] < b; ) O++;
            const H = o[O], y = b - H;
            a[e + b * r] = h[H] + y * y;
          }
        }
        const ju = 2, Mm = { none: 0, ideographs: 1, all: 2 };
        class Qf {
          constructor(e, r, s) {
            this.requestManager = e, this.localGlyphMode = r, this.localFontFamily = s, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
          }
          setURL(e, r) {
            this.urls[r] = e;
          }
          getGlyphs(e, r, s) {
            const h = [], o = this.urls[r] || $e.GLYPHS_URL;
            for (const f in e) for (const b of e[f]) h.push({ stack: f, id: b });
            _(h, ({ stack: f, id: b }, O) => {
              let H = this.entries[f];
              H || (H = this.entries[f] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
              let y = H.glyphs[b];
              if (y !== void 0) return void O(null, { stack: f, id: b, glyph: y });
              if (y = this._tinySDF(H, f, b), y) return H.glyphs[b] = y, void O(null, { stack: f, id: b, glyph: y });
              const B = Math.floor(b / 256);
              if (256 * B > 65535) return Se("glyphs > 65535 not supported"), void O(null, { stack: f, id: b, glyph: y });
              if (H.ranges[B]) return void O(null, { stack: f, id: b, glyph: y });
              let G = H.requests[B];
              G || (G = H.requests[B] = [], Qf.loadGlyphRange(f, B, o, this.requestManager, (L, F) => {
                if (F) {
                  H.ascender = F.ascender, H.descender = F.descender;
                  for (const Y in F.glyphs) this._doesCharSupportLocalGlyph(+Y) || (H.glyphs[+Y] = F.glyphs[+Y]);
                  H.ranges[B] = !0;
                }
                for (const Y of G) Y(L, F);
                delete H.requests[B];
              })), G.push((L, F) => {
                L ? O(L) : F && O(null, { stack: f, id: b, glyph: F.glyphs[b] || null });
              });
            }, (f, b) => {
              if (f) s(f);
              else if (b) {
                const O = {};
                for (const { stack: H, id: y, glyph: B } of b) O[H] === void 0 && (O[H] = {}), O[H].glyphs === void 0 && (O[H].glyphs = {}), O[H].glyphs[y] = B && { id: B.id, bitmap: B.bitmap.clone(), metrics: B.metrics }, O[H].ascender = this.entries[H].ascender, O[H].descender = this.entries[H].descender;
                s(null, O);
              }
            });
          }
          _doesCharSupportLocalGlyph(e) {
            return this.localGlyphMode !== Mm.none && (this.localGlyphMode === Mm.all ? !!this.localFontFamily : !!this.localFontFamily && (wr["CJK Unified Ideographs"](e) || wr["Hangul Syllables"](e) || wr.Hiragana(e) || wr.Katakana(e) || wr["CJK Symbols and Punctuation"](e) || wr["CJK Unified Ideographs Extension A"](e) || wr["CJK Unified Ideographs Extension B"](e) || wr.Osage(e)));
          }
          _tinySDF(e, r, s) {
            const h = this.localFontFamily;
            if (!h || !this._doesCharSupportLocalGlyph(s)) return;
            let o = e.tinySDF;
            if (!o) {
              let Y = "400";
              /bold/i.test(r) ? Y = "900" : /medium/i.test(r) ? Y = "500" : /light/i.test(r) && (Y = "200"), o = e.tinySDF = new Qf.TinySDF({ fontFamily: h, fontWeight: Y, fontSize: 24 * ju, buffer: 3 * ju, radius: 8 * ju }), o.fontWeight = Y;
            }
            if (this.localGlyphs[o.fontWeight][s]) return this.localGlyphs[o.fontWeight][s];
            const f = String.fromCodePoint(s), { data: b, width: O, height: H, glyphWidth: y, glyphHeight: B, glyphLeft: G, glyphTop: L, glyphAdvance: F } = o.draw(f);
            return this.localGlyphs[o.fontWeight][s] = { id: s, bitmap: new tu({ width: O, height: H }, b), metrics: { width: y / ju, height: B / ju, left: G / ju, top: L / ju - 27, advance: F / ju, localGlyph: !0 } };
          }
        }
        Qf.loadGlyphRange = function(a, e, r, s, h) {
          const o = 256 * e, f = o + 255, b = s.transformRequest(s.normalizeGlyphsURL(r).replace("{fontstack}", a).replace("{range}", `${o}-${f}`), Mr.Glyphs);
          Vn(b, (O, H) => {
            if (O) h(O);
            else if (H) {
              const y = {}, B = function(G) {
                return new _p(G).readFields(Xx, {});
              }(H);
              for (const G of B.glyphs) y[G.id] = G;
              h(null, { glyphs: y, ascender: B.ascender, descender: B.descender });
            }
          });
        }, Qf.TinySDF = class {
          constructor({ fontSize: a = 24, buffer: e = 3, radius: r = 8, cutoff: s = 0.25, fontFamily: h = "sans-serif", fontWeight: o = "normal", fontStyle: f = "normal" } = {}) {
            this.buffer = e, this.cutoff = s, this.radius = r;
            const b = this.size = a + 4 * e, O = this._createCanvas(b), H = this.ctx = O.getContext("2d", { willReadFrequently: !0 });
            H.font = `${f} ${o} ${a}px ${h}`, H.textBaseline = "alphabetic", H.textAlign = "left", H.fillStyle = "black", this.gridOuter = new Float64Array(b * b), this.gridInner = new Float64Array(b * b), this.f = new Float64Array(b), this.z = new Float64Array(b + 1), this.v = new Uint16Array(b);
          }
          _createCanvas(a) {
            const e = document.createElement("canvas");
            return e.width = e.height = a, e;
          }
          draw(a) {
            const { width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: s, actualBoundingBoxLeft: h, actualBoundingBoxRight: o } = this.ctx.measureText(a), f = Math.ceil(r), b = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o - h))), O = Math.min(this.size - this.buffer, f + Math.ceil(s)), H = b + 2 * this.buffer, y = O + 2 * this.buffer, B = Math.max(H * y, 0), G = new Uint8ClampedArray(B), L = { data: G, width: H, height: y, glyphWidth: b, glyphHeight: O, glyphTop: f, glyphLeft: 0, glyphAdvance: e };
            if (b === 0 || O === 0) return L;
            const { ctx: F, buffer: Y, gridInner: ce, gridOuter: _e } = this;
            F.clearRect(Y, Y, b, O), F.fillText(a, Y, Y + f);
            const ze = F.getImageData(Y, Y, b, O);
            _e.fill(Ld, 0, B), ce.fill(0, 0, B);
            for (let Ne = 0; Ne < O; Ne++) for (let Ee = 0; Ee < b; Ee++) {
              const We = ze.data[4 * (Ne * b + Ee) + 3] / 255;
              if (We === 0) continue;
              const lt = (Ne + Y) * H + Ee + Y;
              if (We === 1) _e[lt] = 0, ce[lt] = Ld;
              else {
                const yt = 0.5 - We;
                _e[lt] = yt > 0 ? yt * yt : 0, ce[lt] = yt < 0 ? yt * yt : 0;
              }
            }
            B0(_e, 0, 0, H, y, H, this.f, this.v, this.z), B0(ce, Y, Y, b, O, H, this.f, this.v, this.z);
            for (let Ne = 0; Ne < B; Ne++) {
              const Ee = Math.sqrt(_e[Ne]) - Math.sqrt(ce[Ne]);
              G[Ne] = Math.round(255 - 255 * (Ee / this.radius + this.cutoff));
            }
            return L;
          }
        };
        const Vh = Rd;
        function N0(a, e) {
          return a + e[1] - e[0];
        }
        function U0(a, e, r, s, h = 1) {
          const o = [], f = a.imagePrimary, b = f.pixelRatio, O = f.paddedRect.w - 2 * Vh, H = f.paddedRect.h - 2 * Vh, y = (a.right - a.left) * h, B = (a.bottom - a.top) * h, G = f.stretchX || [[0, O]], L = f.stretchY || [[0, H]], F = G.reduce(N0, 0), Y = L.reduce(N0, 0), ce = O - F, _e = H - Y;
          let ze = 0, Ne = F, Ee = 0, We = Y, lt = 0, yt = ce, Bt = 0, zt = _e;
          if (f.content && s) {
            const ni = f.content;
            ze = vp(G, 0, ni[0]), Ee = vp(L, 0, ni[1]), Ne = vp(G, ni[0], ni[2]), We = vp(L, ni[1], ni[3]), lt = ni[0] - ze, Bt = ni[1] - Ee, yt = ni[2] - ni[0] - Ne, zt = ni[3] - ni[1] - We;
          }
          const Dt = (ni, Gt, si, ci) => {
            const li = yp(ni.stretch - ze, Ne, y, a.left * h), fi = xp(ni.fixed - lt, yt, ni.stretch, F), gi = yp(Gt.stretch - Ee, We, B, a.top * h), Si = xp(Gt.fixed - Bt, zt, Gt.stretch, Y), pi = yp(si.stretch - ze, Ne, y, a.left * h), zi = xp(si.fixed - lt, yt, si.stretch, F), Gi = yp(ci.stretch - Ee, We, B, a.top * h), Oi = xp(ci.fixed - Bt, zt, ci.stretch, Y), lr = new At(li, gi), ar = new At(pi, gi), Qi = new At(pi, Gi), qi = new At(li, Gi), xr = new At(fi / b, Si / b), hr = new At(zi / b, Oi / b), pr = e * Math.PI / 180;
            if (pr) {
              const cn = Math.sin(pr), Un = Math.cos(pr), In = [Un, -cn, cn, Un];
              lr._matMult(In), ar._matMult(In), qi._matMult(In), Qi._matMult(In);
            }
            const Ur = ni.stretch + ni.fixed, Xr = si.stretch + si.fixed, Yr = Gt.stretch + Gt.fixed, Kr = ci.stretch + ci.fixed, sn = a.imageSecondary;
            return { tl: lr, tr: ar, bl: qi, br: Qi, texPrimary: { x: f.paddedRect.x + Vh + Ur, y: f.paddedRect.y + Vh + Yr, w: Xr - Ur, h: Kr - Yr }, texSecondary: sn ? { x: sn.paddedRect.x + Vh + Ur, y: sn.paddedRect.y + Vh + Yr, w: Xr - Ur, h: Kr - Yr } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: xr, pixelOffsetBR: hr, minFontScaleX: yt / b / y, minFontScaleY: zt / b / B, isSDF: r };
          };
          if (s && (f.stretchX || f.stretchY)) {
            const ni = V0(G, ce, F), Gt = V0(L, _e, Y);
            for (let si = 0; si < ni.length - 1; si++) {
              const ci = ni[si], li = ni[si + 1];
              for (let fi = 0; fi < Gt.length - 1; fi++) o.push(Dt(ci, Gt[fi], li, Gt[fi + 1]));
            }
          } else o.push(Dt({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: O + 1 }, { fixed: 0, stretch: H + 1 }));
          return o;
        }
        function vp(a, e, r) {
          let s = 0;
          for (const h of a) s += Math.max(e, Math.min(r, h[1])) - Math.max(e, Math.min(r, h[0]));
          return s;
        }
        function V0(a, e, r) {
          const s = [{ fixed: -Vh, stretch: 0 }];
          for (const [h, o] of a) {
            const f = s[s.length - 1];
            s.push({ fixed: h - f.stretch, stretch: f.stretch }), s.push({ fixed: h - f.stretch, stretch: f.stretch + (o - h) });
          }
          return s.push({ fixed: e + Vh, stretch: r }), s;
        }
        function yp(a, e, r, s) {
          return a / e * r + s;
        }
        function xp(a, e, r, s) {
          return a - e * r / s;
        }
        function rb(a, e, r, s) {
          const h = e + a.positionedLines[s].lineOffset;
          return s === 0 ? r + h / 2 : r + (h + (e + a.positionedLines[s - 1].lineOffset)) / 2;
        }
        function nb(a, e = 1, r = !1) {
          let s = 1 / 0, h = 1 / 0, o = -1 / 0, f = -1 / 0;
          const b = a[0];
          for (let L = 0; L < b.length; L++) {
            const F = b[L];
            (!L || F.x < s) && (s = F.x), (!L || F.y < h) && (h = F.y), (!L || F.x > o) && (o = F.x), (!L || F.y > f) && (f = F.y);
          }
          const O = Math.min(o - s, f - h);
          let H = O / 2;
          const y = new $a([], ab);
          if (O === 0) return new At(s, h);
          for (let L = s; L < o; L += O) for (let F = h; F < f; F += O) y.push(new ed(L + H, F + H, H, a));
          let B = function(L) {
            let F = 0, Y = 0, ce = 0;
            const _e = L[0];
            for (let ze = 0, Ne = _e.length, Ee = Ne - 1; ze < Ne; Ee = ze++) {
              const We = _e[ze], lt = _e[Ee], yt = We.x * lt.y - lt.x * We.y;
              Y += (We.x + lt.x) * yt, ce += (We.y + lt.y) * yt, F += 3 * yt;
            }
            return new ed(Y / F, ce / F, 0, L);
          }(a), G = y.length;
          for (; y.length; ) {
            const L = y.pop();
            (L.d > B.d || !B.d) && (B = L, r && console.log("found best %d after %d probes", Math.round(1e4 * L.d) / 1e4, G)), L.max - B.d <= e || (H = L.h / 2, y.push(new ed(L.p.x - H, L.p.y - H, H, a)), y.push(new ed(L.p.x + H, L.p.y - H, H, a)), y.push(new ed(L.p.x - H, L.p.y + H, H, a)), y.push(new ed(L.p.x + H, L.p.y + H, H, a)), G += 4);
          }
          return r && (console.log(`num probes: ${G}`), console.log(`best distance: ${B.d}`)), B.p;
        }
        function ab(a, e) {
          return e.max - a.max;
        }
        class ed {
          constructor(e, r, s, h) {
            this.p = new At(e, r), this.h = s, this.d = function(o, f) {
              let b = !1, O = 1 / 0;
              for (let H = 0; H < f.length; H++) {
                const y = f[H];
                for (let B = 0, G = y.length, L = G - 1; B < G; L = B++) {
                  const F = y[B], Y = y[L];
                  F.y > o.y != Y.y > o.y && o.x < (Y.x - F.x) * (o.y - F.y) / (Y.y - F.y) + F.x && (b = !b), O = Math.min(O, Xt(o, F, Y));
                }
              }
              return (b ? 1 : -1) * Math.sqrt(O);
            }(this.p, h), this.max = this.d + this.h * Math.SQRT2;
          }
        }
        const Im = Number.POSITIVE_INFINITY, sb = Math.sqrt(2);
        function j0(a, [e, r]) {
          let s = 0, h = 0;
          if (r === Im) {
            e < 0 && (e = 0);
            const o = e / sb;
            switch (a) {
              case "top-right":
              case "top-left":
                h = o - 7;
                break;
              case "bottom-right":
              case "bottom-left":
                h = 7 - o;
                break;
              case "bottom":
                h = 7 - e;
                break;
              case "top":
                h = e - 7;
            }
            switch (a) {
              case "top-right":
              case "bottom-right":
                s = -o;
                break;
              case "top-left":
              case "bottom-left":
                s = o;
                break;
              case "left":
                s = e;
                break;
              case "right":
                s = -e;
            }
          } else {
            switch (e = Math.abs(e), r = Math.abs(r), a) {
              case "top-right":
              case "top-left":
              case "top":
                h = r - 7;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                h = 7 - r;
            }
            switch (a) {
              case "top-right":
              case "bottom-right":
              case "right":
                s = -e;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                s = e;
            }
          }
          return [s, h];
        }
        function Pm(a) {
          switch (a) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function ob(a, e, r, s, h, o, f, b, O, H, y, B, G, L, F) {
          let Y = o.textMaxSize.evaluate(e, {}, B);
          Y === void 0 ? Y = f * o.textScaleFactor : Y *= o.textScaleFactor;
          const ce = a.layers[0].layout, _e = ce.get("icon-offset").evaluate(e, {}, B), ze = H0(r.horizontal) || r.vertical, Ne = G.name === "globe", Ee = Ns, We = f * o.textScaleFactor / Ee, lt = a.tilePixelRatio * Y / Ee, yt = (li = a.overscaling, a.zoom > 18 && li > 2 && (li >>= 1), Math.max(tr / (512 * li), 1) * ce.get("symbol-spacing")), Bt = ce.get("text-padding") * a.tilePixelRatio, zt = ce.get("icon-padding") * a.tilePixelRatio, Dt = Ye(ce.get("text-max-angle")), ni = ce.get("text-rotation-alignment") === "map" && ce.get("symbol-placement") !== "point", Gt = ce.get("icon-rotation-alignment") === "map" && ce.get("symbol-placement") !== "point", si = ce.get("symbol-placement"), ci = yt / 2;
          var li;
          const fi = ce.get("icon-text-fit").evaluate(e, {}, B), gi = ce.get("icon-text-fit-padding").evaluate(e, {}, B), Si = fi !== "none";
          let pi;
          a.hasAnyIconTextFit === !1 && Si && (a.hasAnyIconTextFit = !0), s && Si && (a.allowVerticalPlacement && r.vertical && (pi = M0(s, r.vertical, fi, gi, _e, We)), ze && (s = M0(s, ze, fi, gi, _e, We)));
          const zi = (Gi, Oi, lr) => {
            if (Oi.x < 0 || Oi.x >= tr || Oi.y < 0 || Oi.y >= tr) return;
            let ar = null;
            if (Ne) {
              const { x: Qi, y: qi, z: xr } = G.projectTilePoint(Oi.x, Oi.y, lr);
              ar = { anchor: new sh(Qi, qi, xr, 0, void 0), up: G.upVector(lr, Oi.x, Oi.y) };
            }
            (function(Qi, qi, xr, hr, pr, Ur, Xr, Yr, Kr, sn, cn, Un, In, Gr, Sn, An, Jn, Oa, Za, Da, Ma, Fa, Ja, Us, Xn, Do, Wu) {
              const ru = Qi.addToLineVertexArray(qi, hr);
              let nu, Cf, Wh, Af, Jd, E1, T1, C1 = 0, A1 = 0, M1 = 0, I1 = 0, h_ = -1, f_ = -1;
              const Ac = {};
              let P1 = La("");
              const Mf = xr ? xr.anchor : qi, d_ = Kr.layout.get("icon-text-fit").evaluate(Ma, {}, Xn) !== "none";
              let p_ = 0, m_ = 0;
              if (Kr._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [p_, m_] = Kr.layout.get("text-offset").evaluate(Ma, {}, Xn).map((Pl) => Pl * Ns) : (p_ = Kr.layout.get("text-radial-offset").evaluate(Ma, {}, Xn) * Ns, m_ = Im), Qi.allowVerticalPlacement && pr.vertical) {
                const Pl = pr.vertical;
                if (Sn) E1 = Rm(Pl), Yr && (T1 = Rm(Yr));
                else {
                  const zo = Kr.layout.get("text-rotate").evaluate(Ma, {}, Xn) + 90;
                  Wh = bp(sn, Mf, qi, cn, Un, In, Pl, Gr, zo, An), Yr && (Af = bp(sn, Mf, qi, cn, Un, In, Yr, Oa, zo));
                }
              }
              if (Ur) {
                const Pl = Qi.iconSizeData, zo = Kr.layout.get("icon-rotate").evaluate(Ma, {}, Xn), Qd = U0(Ur, zo, Ja, d_, Fa.iconScaleFactor), g_ = Yr ? U0(Yr, zo, Ja, d_, Fa.iconScaleFactor) : void 0;
                Cf = bp(sn, Mf, qi, cn, Un, In, Ur, Oa, zo, null), C1 = 4 * Qd.length;
                let If = null;
                Pl.kind === "source" ? (If = [Vu * Kr.layout.get("icon-size").evaluate(Ma, {}, Xn) * Fa.iconScaleFactor], If[0] > jh && Se(`${Qi.layerIds[0]}: Value for "icon-size" is >= ${Od}. Reduce your "icon-size".`)) : Pl.kind === "composite" && (If = [Vu * Fa.compositeIconSizes[0].evaluate(Ma, {}, Xn) * Fa.iconScaleFactor, Vu * Fa.compositeIconSizes[1].evaluate(Ma, {}, Xn) * Fa.iconScaleFactor], (If[0] > jh || If[1] > jh) && Se(`${Qi.layerIds[0]}: Value for "icon-size" is >= ${Od}. Reduce your "icon-size".`)), Qi.addSymbols(Qi.icon, Qd, If, Da, Za, Ma, !1, xr, qi, ru.lineStartIndex, ru.lineLength, -1, Us, Xn, Do, Wu), h_ = Qi.icon.placedSymbolArray.length - 1, g_ && (A1 = 4 * g_.length, Qi.addSymbols(Qi.icon, g_, If, Da, Za, Ma, Ml.vertical, xr, qi, ru.lineStartIndex, ru.lineLength, -1, Us, Xn, Do, Wu), f_ = Qi.icon.placedSymbolArray.length - 1);
              }
              for (const Pl in pr.horizontal) {
                const zo = pr.horizontal[Pl];
                nu || (P1 = La(zo.text), Sn ? Jd = Rm(zo) : nu = bp(sn, Mf, qi, cn, Un, In, zo, Gr, Kr.layout.get("text-rotate").evaluate(Ma, {}, Xn), An));
                const Qd = zo.positionedLines.length === 1;
                if (M1 += G0(Qi, xr, qi, zo, Xr, Kr, Sn, Ma, An, ru, pr.vertical ? Ml.horizontal : Ml.horizontalOnly, Qd ? Object.keys(pr.horizontal) : [Pl], Ac, h_, Fa, Us, Xn, Do), Qd) break;
              }
              pr.vertical && (I1 += G0(Qi, xr, qi, pr.vertical, Xr, Kr, Sn, Ma, An, ru, Ml.vertical, ["vertical"], Ac, f_, Fa, Us, Xn, Do));
              let Zh = -1;
              const __ = (Pl, zo) => Pl ? Math.max(Pl, zo) : zo;
              Zh = __(Jd, Zh), Zh = __(E1, Zh), Zh = __(T1, Zh);
              const Uw = Zh > -1 ? 1 : 0;
              Qi.glyphOffsetArray.length >= 65535 && Se("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Ma.sortKey !== void 0 && Qi.addToSortKeyRanges(Qi.symbolInstances.length, Ma.sortKey), Qi.symbolInstances.emplaceBack(qi.x, qi.y, Mf.x, Mf.y, Mf.z, Ac.right >= 0 ? Ac.right : -1, Ac.center >= 0 ? Ac.center : -1, Ac.left >= 0 ? Ac.left : -1, Ac.vertical >= 0 ? Ac.vertical : -1, h_, f_, P1, nu !== void 0 ? nu : Qi.collisionBoxArray.length, nu !== void 0 ? nu + 1 : Qi.collisionBoxArray.length, Wh !== void 0 ? Wh : Qi.collisionBoxArray.length, Wh !== void 0 ? Wh + 1 : Qi.collisionBoxArray.length, Cf !== void 0 ? Cf : Qi.collisionBoxArray.length, Cf !== void 0 ? Cf + 1 : Qi.collisionBoxArray.length, Af || Qi.collisionBoxArray.length, Af ? Af + 1 : Qi.collisionBoxArray.length, cn, M1, I1, C1, A1, Uw, 0, p_, m_, Zh, 0, d_ ? 1 : 0);
            })(a, Oi, ar, Gi, r, s, h, pi, a.layers[0], a.collisionBoxArray, e.index, e.sourceLayerIndex, a.index, Bt, ni, O, 0, zt, Gt, _e, e, o, H, y, B, L, F);
          };
          if (si === "line") for (const Gi of O0(e.geometry, 0, 0, tr, tr)) {
            const Oi = ib(Gi, yt, Dt, r.vertical || ze, s, Ee, lt, a.overscaling, tr);
            for (const lr of Oi) ze && lb(a, ze.text, ci, lr) || zi(Gi, lr, B);
          }
          else if (si === "line-center") {
            for (const Gi of e.geometry) if (Gi.length > 1) {
              const Oi = tb(Gi, Dt, r.vertical || ze, s, Ee, lt);
              Oi && zi(Gi, Oi, B);
            }
          } else if (e.type === "Polygon") for (const Gi of yr(e.geometry, 0)) {
            const Oi = nb(Gi, 16);
            zi(Gi[0], new sh(Oi.x, Oi.y, 0, 0, void 0), B);
          }
          else if (e.type === "LineString") for (const Gi of e.geometry) zi(Gi, new sh(Gi[0].x, Gi[0].y, 0, 0, void 0), B);
          else if (e.type === "Point") for (const Gi of e.geometry) for (const Oi of Gi) zi([Oi], new sh(Oi.x, Oi.y, 0, 0, void 0), B);
        }
        const Od = 255, jh = Od * Vu;
        function G0(a, e, r, s, h, o, f, b, O, H, y, B, G, L, F, Y, ce, _e) {
          const ze = function(We, lt, yt, Bt, zt, Dt, ni, Gt) {
            const si = [];
            if (lt.positionedLines.length === 0) return si;
            const ci = Bt.layout.get("text-rotate").evaluate(Dt, {}) * Math.PI / 180, li = function(zi) {
              const Gi = zi[0], Oi = zi[1], lr = Gi * Oi;
              return lr > 0 ? [Gi, -Oi] : lr < 0 ? [-Gi, Oi] : Gi === 0 ? [Oi, Gi] : [Oi, -Gi];
            }(yt);
            let fi = Math.abs(lt.top - lt.bottom);
            for (const zi of lt.positionedLines) fi -= zi.lineOffset;
            const gi = lt.positionedLines.length, Si = fi / gi;
            let pi = lt.top - yt[1];
            for (let zi = 0; zi < gi; ++zi) {
              const Gi = lt.positionedLines[zi];
              pi = rb(lt, Si, pi, zi);
              for (const Oi of Gi.positionedGlyphs) {
                if (!Oi.rect) continue;
                const lr = Oi.rect || {};
                let ar = w0 + 1, Qi = !0, qi = 1, xr = 0;
                if (Oi.imageName) {
                  const Da = ni[Ua.build(Oi.imageName).getSerializedPrimary()];
                  if (!Da) continue;
                  if (Da.sdf) {
                    Se("SDF images are not supported in formatted text and will be ignored.");
                    continue;
                  }
                  Qi = !1, qi = Da.pixelRatio, ar = Rd / qi;
                }
                const hr = (zt || Gt) && Oi.vertical, pr = Oi.metrics.advance * Oi.scale / 2, Ur = Oi.metrics, Xr = Oi.rect;
                if (Xr === null) continue;
                Gt && lt.verticalizable && (xr = Oi.imageName ? pr - Oi.metrics.width * Oi.scale / 2 : 0);
                const Yr = zt ? [Oi.x + pr, Oi.y] : [0, 0];
                let Kr = [0, 0], sn = [0, 0], cn = !1;
                zt || (hr ? (sn = [Oi.x + pr + li[0], Oi.y + li[1] - xr], cn = !0) : Kr = [Oi.x + pr + yt[0], Oi.y + yt[1] - xr]);
                const Un = Xr.w * Oi.scale / (qi * (Oi.localGlyph ? ju : 1)), In = Xr.h * Oi.scale / (qi * (Oi.localGlyph ? ju : 1));
                let Gr, Sn, An, Jn;
                if (hr) {
                  const Da = Oi.y - pi, Ma = new At(-pr, pr - Da), Fa = -Math.PI / 2, Ja = new At(...sn);
                  Gr = new At(-pr + Kr[0], Kr[1]), Gr._rotateAround(Fa, Ma)._add(Ja), Gr.x += -Da + pr, Gr.y -= (Ur.left - ar) * Oi.scale;
                  const Us = Oi.imageName ? Ur.advance * Oi.scale : Ns * Oi.scale, Xn = String.fromCodePoint(Oi.glyph);
                  Wx(Xn) ? Gr.x += (1 - ar) * Oi.scale : Zx(Xn) ? Gr.x += Us - Ur.height * Oi.scale + (-ar - 1) * Oi.scale : Gr.x += Oi.imageName || Ur.width + 2 * ar === Xr.w && Ur.height + 2 * ar === Xr.h ? (Us - In) / 2 : (Us - (Ur.height + 2 * ar) * Oi.scale) / 2, Sn = new At(Gr.x, Gr.y - Un), An = new At(Gr.x + In, Gr.y), Jn = new At(Gr.x + In, Gr.y - Un);
                } else {
                  const Da = (Ur.left - ar) * Oi.scale - pr + Kr[0], Ma = (-Ur.top - ar) * Oi.scale + Kr[1], Fa = Da + Un, Ja = Ma + In;
                  Gr = new At(Da, Ma), Sn = new At(Fa, Ma), An = new At(Da, Ja), Jn = new At(Fa, Ja);
                }
                if (ci) {
                  let Da;
                  Da = zt ? new At(0, 0) : cn ? new At(li[0], li[1]) : new At(yt[0], yt[1]), Gr._rotateAround(ci, Da), Sn._rotateAround(ci, Da), An._rotateAround(ci, Da), Jn._rotateAround(ci, Da);
                }
                const Oa = new At(0, 0), Za = new At(0, 0);
                si.push({ tl: Gr, tr: Sn, bl: An, br: Jn, texPrimary: lr, texSecondary: void 0, writingMode: lt.writingMode, glyphOffset: Yr, sectionIndex: Oi.sectionIndex, isSDF: Qi, pixelOffsetTL: Oa, pixelOffsetBR: Za, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
            return si;
          }(0, s, O, o, f, b, h, a.allowVerticalPlacement), Ne = a.textSizeData;
          let Ee = null;
          Ne.kind === "source" ? (Ee = [Vu * o.layout.get("text-size").evaluate(b, {}, ce) * F.textScaleFactor], Ee[0] > jh && Se(`${a.layerIds[0]}: Value for "text-size" is >= ${Od}. Reduce your "text-size".`)) : Ne.kind === "composite" && (Ee = [Vu * F.compositeTextSizes[0].evaluate(b, {}, ce) * F.textScaleFactor, Vu * F.compositeTextSizes[1].evaluate(b, {}, ce) * F.textScaleFactor], (Ee[0] > jh || Ee[1] > jh) && Se(`${a.layerIds[0]}: Value for "text-size" is >= ${Od}. Reduce your "text-size".`)), a.addSymbols(a.text, ze, Ee, O, f, b, y, e, r, H.lineStartIndex, H.lineLength, L, Y, ce, _e, !1);
          for (const We of B) G[We] = a.text.placedSymbolArray.length - 1;
          return 4 * ze.length;
        }
        function H0(a) {
          for (const e in a) return a[e];
          return null;
        }
        function bp(a, e, r, s, h, o, f, b, O, H) {
          let y = f.top, B = f.bottom, G = f.left, L = f.right;
          const F = f.collisionPadding;
          if (F && (G -= F[0], y -= F[1], L += F[2], B += F[3]), O) {
            const Y = new At(G, y), ce = new At(L, y), _e = new At(G, B), ze = new At(L, B), Ne = Ye(O);
            let Ee = new At(0, 0);
            H && (Ee = new At(H[0], H[1])), Y._rotateAround(Ne, Ee), ce._rotateAround(Ne, Ee), _e._rotateAround(Ne, Ee), ze._rotateAround(Ne, Ee), G = Math.min(Y.x, ce.x, _e.x, ze.x), L = Math.max(Y.x, ce.x, _e.x, ze.x), y = Math.min(Y.y, ce.y, _e.y, ze.y), B = Math.max(Y.y, ce.y, _e.y, ze.y);
          }
          return a.emplaceBack(e.x, e.y, e.z, r.x, r.y, G, y, L, B, b, s, h, o), a.length - 1;
        }
        function Rm(a) {
          a.collisionPadding && (a.top -= a.collisionPadding[1], a.bottom += a.collisionPadding[3]);
          const e = a.bottom - a.top;
          return e > 0 ? Math.max(10, e) : null;
        }
        function lb(a, e, r, s) {
          const h = a.compareText;
          if (e in h) {
            const o = h[e];
            for (let f = o.length - 1; f >= 0; f--) if (s.dist(o[f]) < r) return !0;
          } else h[e] = [];
          return h[e].push(s), !1;
        }
        function q0(a, e) {
          const r = a.fovAboveCenter, s = a.elevation ? a.elevation.getMinElevationBelowMSL() * e : 0, h = (a._camera.position[2] * a.worldSize - s) / Math.cos(a._pitch), o = Math.sin(r) * h / Math.sin(Math.max(Math.PI / 2 - a._pitch - r, 0.01));
          let f = Math.sin(a._pitch) * o + h;
          const b = h * (1 / a._horizonShift);
          if (!a.elevation || a.elevation.exaggeration() === 0) {
            let O = Math.max(a.zoom - 17, 0);
            a.isOrthographic && (O /= 10), f *= 1 + O;
          }
          return Math.min(1.01 * f, b);
        }
        function Dd(a, e) {
          if (!e.isReprojectedInTileSpace) return { scale: 1 << a.z, x: a.x, y: a.y, x2: a.x + 1, y2: a.y + 1, projection: e };
          const r = Math.pow(2, -a.z), s = a.x * r, h = (a.x + 1) * r, o = a.y * r, f = (a.y + 1) * r, b = Qs(s), O = Qs(h), H = Pr(o), y = Pr(f), B = e.project(b, H), G = e.project(O, H), L = e.project(O, y), F = e.project(b, y);
          let Y = Math.min(B.x, G.x, L.x, F.x), ce = Math.min(B.y, G.y, L.y, F.y), _e = Math.max(B.x, G.x, L.x, F.x), ze = Math.max(B.y, G.y, L.y, F.y);
          const Ne = r / 16;
          function Ee(lt, yt, Bt, zt, Dt, ni) {
            const Gt = (Bt + Dt) / 2, si = (zt + ni) / 2, ci = e.project(Qs(Gt), Pr(si)), li = Math.max(0, Y - ci.x, ce - ci.y, ci.x - _e, ci.y - ze);
            Y = Math.min(Y, ci.x), _e = Math.max(_e, ci.x), ce = Math.min(ce, ci.y), ze = Math.max(ze, ci.y), li > Ne && (Ee(lt, ci, Bt, zt, Gt, si), Ee(ci, yt, Gt, si, Dt, ni));
          }
          Ee(B, G, s, o, h, o), Ee(G, L, h, o, h, f), Ee(L, F, h, f, s, f), Ee(F, B, s, f, s, o), Y -= Ne, ce -= Ne, _e += Ne, ze += Ne;
          const We = 1 / Math.max(_e - Y, ze - ce);
          return { scale: We, x: Y * We, y: ce * We, x2: _e * We, y2: ze * We, projection: e };
        }
        function W0(a, { x: e, y: r }, s = 0) {
          return new At(((e - s) * a.scale - a.x) * tr, (r * a.scale - a.y) * tr);
        }
        const ub = rt.mat4.identity(new Float32Array(16));
        class Gh {
          constructor(e) {
            this.spec = e, this.name = e.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
          }
          project(e, r) {
            return { x: 0, y: 0, z: 0 };
          }
          unproject(e, r) {
            return new hn(0, 0);
          }
          projectTilePoint(e, r, s) {
            return { x: e, y: r, z: 0 };
          }
          locationPoint(e, r, s = !0) {
            return e._coordinatePoint(e.locationCoordinate(r), s);
          }
          pixelsPerMeter(e, r) {
            return Zn(1, e) * r;
          }
          pixelSpaceConversion(e, r, s) {
            return 1;
          }
          farthestPixelDistance(e) {
            return q0(e, e.pixelsPerMeter);
          }
          pointCoordinate(e, r, s, h) {
            const o = e.horizonLineFromTop(!1), f = new At(r, Math.max(o, s));
            return e.rayIntersectionCoordinate(e.pointRayIntersection(f, h));
          }
          pointCoordinate3D(e, r, s) {
            const h = new At(r, s);
            if (e.elevation) return e.elevation.pointCoordinate(h);
            {
              const o = this.pointCoordinate(e, h.x, h.y, 0);
              return [o.x, o.y, o.z];
            }
          }
          isPointAboveHorizon(e, r) {
            if (e.elevation && e.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(e, r.x, r.y);
            const s = e.horizonLineFromTop();
            return r.y < s;
          }
          createInversionMatrix(e, r) {
            return ub;
          }
          createTileMatrix(e, r, s) {
            let h, o, f;
            const b = s.canonical, O = rt.mat4.identity(new Float64Array(16));
            if (this.isReprojectedInTileSpace) {
              const H = Dd(b, this);
              h = 1, o = H.x + s.wrap * H.scale, f = H.y, rt.mat4.scale(O, O, [h / H.scale, h / H.scale, e.pixelsPerMeter / r]);
            } else h = r / e.zoomScale(b.z), o = (b.x + Math.pow(2, b.z) * s.wrap) * h, f = b.y * h;
            return rt.mat4.translate(O, O, [o, f, 0]), rt.mat4.scale(O, O, [h / tr, h / tr, 1]), O;
          }
          upVector(e, r, s) {
            return [0, 0, 1];
          }
          upVectorScale(e, r, s) {
            return { metersToTile: 1 };
          }
        }
        class cb extends Gh {
          constructor(e) {
            super(e), this.range = [4, 7], this.center = e.center || [-96, 37.5];
            const [r, s] = this.parallels = e.parallels || [29.5, 45.5], h = Math.sin(Ye(r));
            this.n = (h + Math.sin(Ye(s))) / 2, this.c = 1 + h * (2 * this.n - h), this.r0 = Math.sqrt(this.c) / this.n;
          }
          project(e, r) {
            const { n: s, c: h, r0: o } = this, f = Ye(e - this.center[0]), b = Ye(r), O = Math.sqrt(h - 2 * s * Math.sin(b)) / s;
            return { x: O * Math.sin(f * s), y: O * Math.cos(f * s) - o, z: 0 };
          }
          unproject(e, r) {
            const { n: s, c: h, r0: o } = this, f = o + r;
            let b = Math.atan2(e, Math.abs(f)) * Math.sign(f);
            f * s < 0 && (b -= Math.PI * Math.sign(e) * Math.sign(f));
            const O = Ye(this.center[0]) * s;
            b = l(b, -Math.PI - O, Math.PI - O);
            const H = pe(De(b / s) + this.center[0], -180, 180), y = Math.asin(pe((h - (e * e + f * f) * s * s) / (2 * s), -1, 1)), B = pe(De(y), -la, la);
            return new hn(H, B);
          }
        }
        const zd = 1.340264, Bd = -0.081106, Fd = 893e-6, Nd = 3796e-6, wp = Math.sqrt(3) / 2;
        class hb extends Gh {
          project(e, r) {
            r = r / 180 * Math.PI, e = e / 180 * Math.PI;
            const s = Math.asin(wp * Math.sin(r)), h = s * s, o = h * h * h;
            return { x: 0.5 * (e * Math.cos(s) / (wp * (zd + 3 * Bd * h + o * (7 * Fd + 9 * Nd * h))) / Math.PI + 0.5), y: 1 - 0.5 * (s * (zd + Bd * h + o * (Fd + Nd * h)) / Math.PI + 1), z: 0 };
          }
          unproject(e, r) {
            e = (2 * e - 0.5) * Math.PI;
            let s = r = (2 * (1 - r) - 1) * Math.PI, h = s * s, o = h * h * h;
            for (let y, B, G, L = 0; L < 12 && (B = s * (zd + Bd * h + o * (Fd + Nd * h)) - r, G = zd + 3 * Bd * h + o * (7 * Fd + 9 * Nd * h), y = B / G, s = pe(s - y, -Math.PI / 3, Math.PI / 3), h = s * s, o = h * h * h, !(Math.abs(y) < 1e-12)); ++L) ;
            const f = wp * e * (zd + 3 * Bd * h + o * (7 * Fd + 9 * Nd * h)) / Math.cos(s), b = Math.asin(Math.sin(s) / wp), O = pe(180 * f / Math.PI, -180, 180), H = pe(180 * b / Math.PI, -la, la);
            return new hn(O, H);
          }
        }
        class fb extends Gh {
          constructor(e) {
            super(e), this.wrap = !0, this.supportsWorldCopies = !0;
          }
          project(e, r) {
            return { x: 0.5 + e / 360, y: 0.5 - r / 360, z: 0 };
          }
          unproject(e, r) {
            const s = 360 * (e - 0.5), h = pe(360 * (0.5 - r), -la, la);
            return new hn(s, h);
          }
        }
        const td = Math.PI / 2;
        function Sp(a) {
          return Math.tan((td + a) / 2);
        }
        class db extends Gh {
          constructor(e) {
            super(e), this.center = e.center || [0, 30];
            const [r, s] = this.parallels = e.parallels || [30, 30];
            let h = Ye(r), o = Ye(s);
            this.southernCenter = h + o < 0, this.southernCenter && (h = -h, o = -o);
            const f = Math.cos(h), b = Sp(h);
            this.n = h === o ? Math.sin(h) : Math.log(f / Math.cos(o)) / Math.log(Sp(o) / b), this.f = f * Math.pow(Sp(h), this.n) / this.n;
          }
          project(e, r) {
            r = Ye(r), this.southernCenter && (r = -r), e = Ye(e - this.center[0]);
            const s = 1e-6, { n: h, f: o } = this;
            o > 0 ? r < -td + s && (r = -td + s) : r > td - s && (r = td - s);
            const f = o / Math.pow(Sp(r), h);
            let b = f * Math.sin(h * e), O = o - f * Math.cos(h * e);
            return b = 0.5 * (b / Math.PI + 0.5), O = 0.5 * (O / Math.PI + 0.5), { x: b, y: this.southernCenter ? O : 1 - O, z: 0 };
          }
          unproject(e, r) {
            e = (2 * e - 0.5) * Math.PI, this.southernCenter && (r = 1 - r), r = (2 * (1 - r) - 0.5) * Math.PI;
            const { n: s, f: h } = this, o = h - r, f = Math.sign(o), b = Math.sign(s) * Math.sqrt(e * e + o * o);
            let O = Math.atan2(e, Math.abs(o)) * f;
            o * s < 0 && (O -= Math.PI * Math.sign(e) * f);
            const H = pe(De(O / s) + this.center[0], -180, 180), y = pe(De(2 * Math.atan(Math.pow(h / b, 1 / s)) - td), -la, la);
            return new hn(H, this.southernCenter ? -y : y);
          }
        }
        class Z0 extends Gh {
          constructor(e) {
            super(e), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
          }
          project(e, r) {
            return { x: il(e), y: Js(r), z: 0 };
          }
          unproject(e, r) {
            const s = Qs(e), h = Pr(r);
            return new hn(s, h);
          }
        }
        const $0 = Ye(la);
        class pb extends Gh {
          project(e, r) {
            const s = (r = Ye(r)) * r, h = s * s;
            return { x: 0.5 * ((e = Ye(e)) * (0.8707 - 0.131979 * s + h * (h * (3971e-6 * s - 1529e-6 * h) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (r * (1.007226 + s * (0.015085 + h * (0.028874 * s - 0.044475 - 5916e-6 * h))) / Math.PI + 1), z: 0 };
          }
          unproject(e, r) {
            e = (2 * e - 0.5) * Math.PI;
            let s = r = (2 * (1 - r) - 1) * Math.PI, h = 25, o = 0, f = s * s;
            do {
              f = s * s;
              const H = f * f;
              o = (s * (1.007226 + f * (0.015085 + H * (0.028874 * f - 0.044475 - 5916e-6 * H))) - r) / (1.007226 + f * (0.045255 + H * (0.259866 * f - 0.311325 - 5916e-6 * 11 * H))), s = pe(s - o, -$0, $0);
            } while (Math.abs(o) > 1e-6 && --h > 0);
            f = s * s;
            const b = pe(De(e / (0.8707 + f * (f * (f * f * f * (3971e-6 - 1529e-6 * f) - 0.013791) - 0.131979))), -180, 180), O = De(s);
            return new hn(b, O);
          }
        }
        const X0 = Ye(la);
        class mb extends Gh {
          project(e, r) {
            r = Ye(r), e = Ye(e);
            const s = Math.cos(r), h = 2 / Math.PI, o = Math.acos(s * Math.cos(e / 2)), f = Math.sin(o) / o, b = 0.5 * (e * h + 2 * s * Math.sin(e / 2) / f) || 0, O = 0.5 * (r + Math.sin(r) / f) || 0;
            return { x: 0.5 * (b / Math.PI + 0.5), y: 1 - 0.5 * (O / Math.PI + 1), z: 0 };
          }
          unproject(e, r) {
            let s = e = (2 * e - 0.5) * Math.PI, h = r = (2 * (1 - r) - 1) * Math.PI, o = 25;
            const f = 1e-6;
            let b = 0, O = 0;
            do {
              const H = Math.cos(h), y = Math.sin(h), B = 2 * y * H, G = y * y, L = H * H, F = Math.cos(s / 2), Y = Math.sin(s / 2), ce = 2 * F * Y, _e = Y * Y, ze = 1 - L * F * F, Ne = ze ? 1 / ze : 0, Ee = ze ? Math.acos(H * F) * Math.sqrt(1 / ze) : 0, We = 0.5 * (2 * Ee * H * Y + 2 * s / Math.PI) - e, lt = 0.5 * (Ee * y + h) - r, yt = 0.5 * Ne * (L * _e + Ee * H * F * G) + 1 / Math.PI, Bt = Ne * (ce * B / 4 - Ee * y * Y), zt = 0.125 * Ne * (B * Y - Ee * y * L * ce), Dt = 0.5 * Ne * (G * F + Ee * _e * H) + 0.5, ni = Bt * zt - Dt * yt;
              b = (lt * Bt - We * Dt) / ni, O = (We * zt - lt * yt) / ni, s = pe(s - b, -Math.PI, Math.PI), h = pe(h - O, -X0, X0);
            } while ((Math.abs(b) > f || Math.abs(O) > f) && --o > 0);
            return new hn(De(s), De(h));
          }
        }
        class Y0 extends Gh {
          constructor(e) {
            super(e), this.center = e.center || [0, 0], this.parallels = e.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(Ye(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
          }
          project(e, r) {
            const { scale: s, cosPhi: h } = this;
            return { x: Ye(e) * h * s + 0.5, y: -Math.sin(Ye(r)) / h * s + 0.5, z: 0 };
          }
          unproject(e, r) {
            const { scale: s, cosPhi: h } = this, o = -(r - 0.5) / s, f = pe(De((e - 0.5) / s) / h, -180, 180), b = Math.asin(pe(o * h, -1, 1)), O = pe(De(b), -la, la);
            return new hn(f, O);
          }
        }
        class _b extends Z0 {
          constructor(e) {
            super(e), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
          }
          projectTilePoint(e, r, s) {
            const h = Cn(e, r, s), o = Ha(Ra(s));
            return rt.vec3.transformMat4(h, h, o), { x: h[0], y: h[1], z: h[2] };
          }
          locationPoint(e, r) {
            const s = Du(r.lat, r.lng), h = rt.vec3.normalize([], s), o = e.elevation ? e.elevation.getAtPointOrZero(e.locationCoordinate(r), e._centerAltitude) : e._centerAltitude, f = Zn(1, 0) * tr * o;
            rt.vec3.scaleAndAdd(s, s, h, f);
            const b = rt.mat4.identity(new Float64Array(16));
            return rt.mat4.multiply(b, e.pixelMatrix, e.globeMatrix), rt.vec3.transformMat4(s, s, b), new At(s[0], s[1]);
          }
          pixelsPerMeter(e, r) {
            return Zn(1, 0) * r;
          }
          pixelSpaceConversion(e, r, s) {
            const h = Zn(1, e) * r, o = Tr(Zn(1, 45) * r, h, s);
            return this.pixelsPerMeter(e, r) / o;
          }
          createTileMatrix(e, r, s) {
            const h = kn(Ra(s.canonical));
            return rt.mat4.multiply(new Float64Array(16), e.globeMatrix, h);
          }
          createInversionMatrix(e, r) {
            const { center: s } = e, h = Ha(Ra(r));
            return rt.mat4.rotateY(h, h, Ye(s.lng)), rt.mat4.rotateX(h, h, Ye(s.lat)), rt.mat4.scale(h, h, [e._pixelsPerMercatorPixel, e._pixelsPerMercatorPixel, 1]), Float32Array.from(h);
          }
          pointCoordinate(e, r, s, h) {
            return gn(e, r, s, !0) || new n(0, 0);
          }
          pointCoordinate3D(e, r, s) {
            const h = this.pointCoordinate(e, r, s, 0);
            return [h.x, h.y, h.z];
          }
          isPointAboveHorizon(e, r) {
            return !gn(e, r.x, r.y, !1);
          }
          farthestPixelDistance(e) {
            const r = function(h, o) {
              const f = h.cameraToCenterDistance, b = h._centerAltitude * o, O = h._camera, H = h._camera.forward(), y = rt.vec3.add([], rt.vec3.scale([], H, -f), [0, 0, b]), B = h.worldSize / (2 * Math.PI), G = [0, 0, -B], L = h.width / h.height, F = Math.tan(h.fovAboveCenter), Y = rt.vec3.scale([], O.up(), F), ce = rt.vec3.scale([], O.right(), F * L), _e = rt.vec3.normalize([], rt.vec3.add([], rt.vec3.add([], H, Y), ce)), ze = [];
              let Ne;
              if (new Fr(y, _e).closestPointOnSphere(G, B, ze)) {
                const Ee = rt.vec3.add([], ze, G), We = rt.vec3.sub([], Ee, y);
                Ne = Math.cos(h.fovAboveCenter) * rt.vec3.length(We);
              } else {
                const Ee = rt.vec3.sub([], y, G), We = rt.vec3.sub([], G, y);
                rt.vec3.normalize(We, We);
                const lt = rt.vec3.length(Ee) - B;
                Ne = Math.sqrt(lt * (lt + 2 * B));
                const yt = Math.acos(Ne / (B + lt)) - Math.acos(rt.vec3.dot(H, We));
                Ne *= Math.cos(yt);
              }
              return 1.01 * Ne;
            }(e, this.pixelsPerMeter(e.center.lat, e.worldSize)), s = Bs(e.zoom);
            if (s > 0) {
              const h = q0(e, Zn(1, e.center.lat) * e.worldSize), o = e.worldSize / (2 * Math.PI), f = Math.max(e.width, e.height) / e.worldSize * Math.PI;
              return Tr(r, h + o * (1 - Math.cos(f)), Math.pow(s, 10));
            }
            return r;
          }
          upVector(e, r, s) {
            return Cn(r, s, e, 1);
          }
          upVectorScale(e) {
            return { metersToTile: nn(ln(Ra(e))) };
          }
        }
        function K0(a) {
          const e = a.parallels, r = !!e && Math.abs(e[0] + e[1]) < 0.01;
          switch (a.name) {
            case "mercator":
              return new Z0(a);
            case "equirectangular":
              return new fb(a);
            case "naturalEarth":
              return new pb(a);
            case "equalEarth":
              return new hb(a);
            case "winkelTripel":
              return new mb(a);
            case "albers":
              return r ? new Y0(a) : new cb(a);
            case "lambertConformalConic":
              return r ? new Y0(a) : new db(a);
            case "globe":
              return new _b(a);
          }
          throw new Error(`Invalid projection name: ${a.name}`);
        }
        const gb = Yf.VectorTileFeature.types, vb = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Ep(a, e, r, s, h, o, f, b, O, H, y, B, G) {
          const L = b ? Math.min(jh, Math.round(b[0])) : 0, F = b ? Math.min(jh, Math.round(b[1])) : 0;
          a.emplaceBack(e, r, Math.round(32 * s), Math.round(32 * h), o, f, (L << 1) + (O ? 1 : 0), F, 16 * H, 16 * y, 256 * B, 256 * G);
        }
        function Tp(a, e, r) {
          a.emplaceBack(e, r);
        }
        function Cp(a, e, r, s, h, o, f) {
          a.emplaceBack(e, r, s, h, o, f);
        }
        function Ap(a, e, r, s, h) {
          a.emplaceBack(e, r, s, h), a.emplaceBack(e, r, s, h), a.emplaceBack(e, r, s, h), a.emplaceBack(e, r, s, h);
        }
        function yb(a) {
          for (const e of a.sections) if (yh(e.text)) return !0;
          return !1;
        }
        class km {
          constructor(e) {
            this.layoutVertexArray = new qc(), this.indexArray = new Ya(), this.programConfigurations = e, this.segments = new Ea(), this.dynamicLayoutVertexArray = new wl(), this.opacityVertexArray = new Eo(), this.placedSymbolArray = new cf(), this.iconTransitioningVertexArray = new rs(), this.globeExtVertexArray = new Wc(), this.zOffsetVertexArray = new hc();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0 && this.iconTransitioningVertexArray.length === 0;
          }
          upload(e, r, s, h, o) {
            this.isEmpty() || (s && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, zx.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, r), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, Fx.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, vb, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = e.createVertexBuffer(this.iconTransitioningVertexArray, Ux.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, Bx.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || o) && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, Nx.members, !0)), this.opacityVertexBuffer.itemSize = 1), (s || h) && this.programConfigurations.upload(e));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
          }
        }
        ur(km, "SymbolBuffers");
        class Lm {
          constructor(e, r, s) {
            this.layoutVertexArray = new e(), this.layoutAttributes = r, this.indexArray = new s(), this.segments = new Ea(), this.collisionVertexArray = new Ch(), this.collisionVertexArrayExt = new wl();
          }
          upload(e) {
            this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, Vx.members, !0), this.collisionVertexBufferExt = e.createVertexBuffer(this.collisionVertexArrayExt, jx.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
          }
        }
        ur(Lm, "CollisionBuffers");
        class Mp {
          constructor(e) {
            this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.lut = e.lut, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((f) => f.fqid), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = rt.mat4.identity([]), this.placementViewportMatrix = rt.mat4.identity([]);
            const r = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = wm(this.zoom, r["text-size"]), this.iconSizeData = wm(this.zoom, r["icon-size"]);
            const s = this.layers[0].layout, h = s.get("symbol-sort-key"), o = s.get("symbol-z-order");
            this.canOverlap = s.get("text-allow-overlap") || s.get("icon-allow-overlap") || s.get("text-ignore-placement") || s.get("icon-ignore-placement"), this.sortFeaturesByKey = o !== "viewport-y" && h.constantOr(1) !== void 0, this.sortFeaturesByY = (o === "viewport-y" || o === "auto" && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = s.get("text-writing-mode").map((f) => Ml[f]), this.stateDependentLayerIds = this.layers.filter((f) => f.isStateDependent()).map((f) => f.id), this.sourceID = e.sourceID, this.projection = e.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = s.get("symbol-z-elevate"), this.activeReplacements = [], this.replacementUpdateTime = 0;
          }
          createArrays() {
            this.text = new km(new Cl(this.layers, { zoom: this.zoom, lut: this.lut }, (e) => e.startsWith("text") || e.startsWith("symbol"))), this.icon = new km(new Cl(this.layers, { zoom: this.zoom, lut: this.lut }, (e) => e.startsWith("icon") || e.startsWith("symbol"))), this.glyphOffsetArray = new Ff(), this.lineVertexArray = new df(), this.symbolInstances = new ff();
          }
          calculateGlyphDependencies(e, r, s, h, o) {
            for (const f of e) {
              const b = f.codePointAt(0);
              if (b === void 0) break;
              if (r[b] = !0, h && o && b <= 65535) {
                const O = Id[f];
                O && (r[O.charCodeAt(0)] = !0);
              }
            }
          }
          updateFootprints(e, r) {
          }
          updateReplacement(e, r) {
            if (r.updateTime === this.replacementUpdateTime) return !1;
            this.replacementUpdateTime = r.updateTime;
            const s = r.getReplacementRegionsForTile(e.toUnwrapped(), !0);
            return !pm(this.activeReplacements, s) && (this.activeReplacements = s, !0);
          }
          populate(e, r, s, h) {
            const o = this.layers[0], f = o.layout, b = this.projection.name === "globe", O = f.get("text-font"), H = f.get("text-field"), y = f.get("icon-image"), [B, G] = f.get("icon-size-scale-range"), L = pe(r.scaleFactor || 1, B, G), F = (H.value.kind !== "constant" || H.value.value instanceof Na && !H.value.value.isEmpty() || H.value.value.toString().length > 0) && (O.value.kind !== "constant" || O.value.value.length > 0), Y = y.value.kind !== "constant" || !!y.value.value || Object.keys(y.parameters).length > 0, ce = f.get("symbol-sort-key");
            if (this.features = [], !F && !Y) return;
            const _e = r.iconDependencies, ze = r.glyphDependencies, Ne = r.availableImages, Ee = new Tn(this.zoom);
            for (const { feature: We, id: lt, index: yt, sourceLayerIndex: Bt } of e) {
              const zt = o._featureFilter.needGeometry, Dt = ve(We, zt);
              if (!o._featureFilter.filter(Ee, Dt, s)) continue;
              if (zt || (Dt.geometry = oe(We, s, h)), b && We.type !== 1 && s.z <= 5) {
                const li = Dt.geometry, fi = 0.98078528056, gi = (Si, pi) => {
                  const zi = Cn(Si.x, Si.y, s, 1), Gi = Cn(pi.x, pi.y, s, 1);
                  return rt.vec3.dot(zi, Gi) < fi;
                };
                for (let Si = 0; Si < li.length; Si++) li[Si] = C(li[Si], gi);
              }
              let ni, Gt;
              if (F) {
                const li = o.getValueAndResolveTokens("text-field", Dt, s, Ne), fi = Na.factory(li);
                yb(fi) && (this.hasRTLText = !0), (!this.hasRTLText || Eu() === "unavailable" || this.hasRTLText && Zs.isParsed()) && (ni = qx(fi, o, Dt));
              }
              if (Y) {
                const li = o.getValueAndResolveTokens("icon-image", Dt, s, Ne);
                Gt = li instanceof Ua ? li : Ua.build(li);
              }
              if (!ni && !Gt) continue;
              const si = this.sortFeaturesByKey ? ce.evaluate(Dt, {}, s) : void 0, ci = { id: lt, text: ni, icon: Gt, index: yt, sourceLayerIndex: Bt, geometry: Dt.geometry, properties: We.properties, type: gb[We.type], sortKey: si };
              if (this.features.push(ci), Gt) {
                const li = bm(this.iconSizeData, this.layers[0]._unevaluatedLayout._values["icon-size"], s, this.zoom, ci) * L * this.pixelRatio, fi = Gt.getPrimary().scaleSelf(li);
                if (_e[fi.id] = _e[fi.id] || [], _e[fi.id].push(fi), Gt.nameSecondary) {
                  const gi = Gt.getSecondary().scaleSelf(li);
                  _e[gi.id] = _e[gi.id] || [], _e[gi.id].push(gi);
                }
              }
              if (ni) {
                const li = O.evaluate(Dt, {}, s).join(","), fi = f.get("text-rotation-alignment") === "map" && f.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Ml.vertical) >= 0;
                for (const gi of ni.sections) if (gi.image) {
                  const Si = gi.image.getPrimary().scaleSelf(this.pixelRatio);
                  _e[Si.id] = _e[Si.id] || [], _e[Si.id].push(Si);
                } else {
                  const Si = Vc(ni.toString()), pi = gi.fontStack || li, zi = ze[pi] = ze[pi] || {};
                  this.calculateGlyphDependencies(gi.text, zi, fi, this.allowVerticalPlacement, Si);
                }
              }
            }
            f.get("symbol-placement") === "line" && (this.features = function(We) {
              const lt = {}, yt = {}, Bt = [];
              let zt = 0;
              function Dt(ci) {
                Bt.push(We[ci]), zt++;
              }
              function ni(ci, li, fi) {
                const gi = yt[ci];
                return delete yt[ci], yt[li] = gi, Bt[gi].geometry[0].pop(), Bt[gi].geometry[0] = Bt[gi].geometry[0].concat(fi[0]), gi;
              }
              function Gt(ci, li, fi) {
                const gi = lt[li];
                return delete lt[li], lt[ci] = gi, Bt[gi].geometry[0].shift(), Bt[gi].geometry[0] = fi[0].concat(Bt[gi].geometry[0]), gi;
              }
              function si(ci, li, fi) {
                const gi = fi ? li[0][li[0].length - 1] : li[0][0];
                return `${ci}:${gi.x}:${gi.y}`;
              }
              for (let ci = 0; ci < We.length; ci++) {
                const li = We[ci], fi = li.geometry, gi = li.text ? li.text.toString() : null;
                if (!gi) {
                  Dt(ci);
                  continue;
                }
                const Si = si(gi, fi), pi = si(gi, fi, !0);
                if (Si in yt && pi in lt && yt[Si] !== lt[pi]) {
                  const zi = Gt(Si, pi, fi), Gi = ni(Si, pi, Bt[zi].geometry);
                  delete lt[Si], delete yt[pi], yt[si(gi, Bt[Gi].geometry, !0)] = Gi, Bt[zi].geometry = null;
                } else Si in yt ? ni(Si, pi, fi) : pi in lt ? Gt(Si, pi, fi) : (Dt(ci), lt[Si] = zt - 1, yt[pi] = zt - 1);
              }
              return Bt.filter((ci) => ci.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((We, lt) => We.sortKey - lt.sortKey);
          }
          update(e, r, s, h, o, f, b) {
            this.text.programConfigurations.updatePaintArrays(e, r, o, s, h, f, b), this.icon.programConfigurations.updatePaintArrays(e, r, o, s, h, f, b);
          }
          updateZOffset() {
            const e = (o, f, b) => {
              s += f, s > o.length && o.resize(s);
              for (let O = -f; O < 0; O++) o.emplace(O + s, b);
            }, r = (o, f, b) => {
              h += f, h > o.length && o.resize(h);
              for (let O = -f; O < 0; O++) o.emplace(O + h, b);
            };
            if (!this.zOffsetBuffersNeedUpload) return;
            this.zOffsetBuffersNeedUpload = !1;
            let s = 0, h = 0;
            for (let o = 0; o < this.symbolInstances.length; o++) {
              const f = this.symbolInstances.get(o), { numHorizontalGlyphVertices: b, numVerticalGlyphVertices: O, numIconVertices: H } = f, y = f.zOffset, B = H > 0;
              if ((b > 0 || O > 0) && (e(this.text.zOffsetVertexArray, b, y), e(this.text.zOffsetVertexArray, O, y)), B) {
                const { placedIconSymbolIndex: G, verticalPlacedIconSymbolIndex: L } = f;
                G >= 0 && r(this.icon.zOffsetVertexArray, H, y), L >= 0 && r(this.icon.zOffsetVertexArray, f.numVerticalIconVertices, y);
              }
            }
            this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(e) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          getProjection() {
            return this.projectionInstance || (this.projectionInstance = K0(this.projection)), this.projectionInstance;
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(e, r) {
            const s = this.lineVertexArray.length;
            if (e.segment !== void 0) for (const { x: h, y: o } of r) this.lineVertexArray.emplaceBack(h, o);
            return { lineStartIndex: s, lineLength: this.lineVertexArray.length - s };
          }
          addSymbols(e, r, s, h, o, f, b, O, H, y, B, G, L, F, Y, ce) {
            const _e = e.indexArray, ze = e.layoutVertexArray, Ne = e.globeExtVertexArray, Ee = e.segments.prepareSegment(4 * r.length, ze, _e, this.canOverlap ? f.sortKey : void 0), We = this.glyphOffsetArray.length, lt = Ee.vertexLength, yt = this.allowVerticalPlacement && b === Ml.vertical ? Math.PI / 2 : 0, Bt = f.text && f.text.sections;
            for (let Dt = 0; Dt < r.length; Dt++) {
              const { tl: ni, tr: Gt, bl: si, br: ci, texPrimary: li, texSecondary: fi, pixelOffsetTL: gi, pixelOffsetBR: Si, minFontScaleX: pi, minFontScaleY: zi, glyphOffset: Gi, isSDF: Oi, sectionIndex: lr } = r[Dt], ar = Ee.vertexLength, Qi = Gi[1];
              if (Ep(ze, H.x, H.y, ni.x, Qi + ni.y, li.x, li.y, s, Oi, gi.x, gi.y, pi, zi), Ep(ze, H.x, H.y, Gt.x, Qi + Gt.y, li.x + li.w, li.y, s, Oi, Si.x, gi.y, pi, zi), Ep(ze, H.x, H.y, si.x, Qi + si.y, li.x, li.y + li.h, s, Oi, gi.x, Si.y, pi, zi), Ep(ze, H.x, H.y, ci.x, Qi + ci.y, li.x + li.w, li.y + li.h, s, Oi, Si.x, Si.y, pi, zi), O) {
                const { x: qi, y: xr, z: hr } = O.anchor, [pr, Ur, Xr] = O.up;
                Cp(Ne, qi, xr, hr, pr, Ur, Xr), Cp(Ne, qi, xr, hr, pr, Ur, Xr), Cp(Ne, qi, xr, hr, pr, Ur, Xr), Cp(Ne, qi, xr, hr, pr, Ur, Xr), Ap(e.dynamicLayoutVertexArray, qi, xr, hr, yt);
              } else Ap(e.dynamicLayoutVertexArray, H.x, H.y, H.z, yt);
              if (ce) {
                const qi = fi || li;
                Tp(e.iconTransitioningVertexArray, qi.x, qi.y), Tp(e.iconTransitioningVertexArray, qi.x + qi.w, qi.y), Tp(e.iconTransitioningVertexArray, qi.x, qi.y + qi.h), Tp(e.iconTransitioningVertexArray, qi.x + qi.w, qi.y + qi.h);
              }
              _e.emplaceBack(ar, ar + 1, ar + 2), _e.emplaceBack(ar + 1, ar + 2, ar + 3), Ee.vertexLength += 4, Ee.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Gi[0]), Dt !== r.length - 1 && lr === r[Dt + 1].sectionIndex || e.programConfigurations.populatePaintArrays(ze.length, f, f.index, {}, L, F, Y, Bt && Bt[lr]);
            }
            const zt = O ? O.anchor : H;
            e.placedSymbolArray.emplaceBack(zt.x, zt.y, zt.z, H.x, H.y, We, this.glyphOffsetArray.length - We, lt, y, B, H.segment, s ? s[0] : 0, s ? s[1] : 0, h[0], h[1], b, 0, !1, 0, G, 0);
          }
          _commitLayoutVertex(e, r, s, h, o, f, b) {
            e.emplaceBack(r, s, h, o, f, Math.round(b.x), Math.round(b.y));
          }
          _addCollisionDebugVertices(e, r, s, h, o, f, b) {
            const O = s.segments.prepareSegment(4, s.layoutVertexArray, s.indexArray), H = O.vertexLength, y = b.tileAnchorX, B = b.tileAnchorY;
            for (let L = 0; L < 4; L++) s.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
            this._commitDebugCollisionVertexUpdate(s.collisionVertexArrayExt, r, e.padding, b.zOffset), this._commitLayoutVertex(s.layoutVertexArray, h, o, f, y, B, new At(e.x1, e.y1)), this._commitLayoutVertex(s.layoutVertexArray, h, o, f, y, B, new At(e.x2, e.y1)), this._commitLayoutVertex(s.layoutVertexArray, h, o, f, y, B, new At(e.x2, e.y2)), this._commitLayoutVertex(s.layoutVertexArray, h, o, f, y, B, new At(e.x1, e.y2)), O.vertexLength += 4;
            const G = s.indexArray;
            G.emplaceBack(H, H + 1), G.emplaceBack(H + 1, H + 2), G.emplaceBack(H + 2, H + 3), G.emplaceBack(H + 3, H), O.primitiveLength += 4;
          }
          _addTextDebugCollisionBoxes(e, r, s, h, o, f) {
            for (let b = h; b < o; b++) {
              const O = s.get(b), H = this.getSymbolInstanceTextSize(e, f, r, b);
              this._addCollisionDebugVertices(O, H, this.textCollisionBox, O.projectedAnchorX, O.projectedAnchorY, O.projectedAnchorZ, f);
            }
          }
          _addIconDebugCollisionBoxes(e, r, s, h, o, f) {
            for (let b = h; b < o; b++) {
              const O = s.get(b), H = this.getSymbolInstanceIconSize(e, r, f.placedIconSymbolIndex);
              this._addCollisionDebugVertices(O, H, this.iconCollisionBox, O.projectedAnchorX, O.projectedAnchorY, O.projectedAnchorZ, f);
            }
          }
          generateCollisionDebugBuffers(e, r, s) {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Lm(cc, v0.members, rs), this.iconCollisionBox = new Lm(cc, v0.members, rs);
            const h = Kf(this.iconSizeData, e), o = Kf(this.textSizeData, e, s);
            for (let f = 0; f < this.symbolInstances.length; f++) {
              const b = this.symbolInstances.get(f);
              this._addTextDebugCollisionBoxes(o, e, r, b.textBoxStartIndex, b.textBoxEndIndex, b), this._addTextDebugCollisionBoxes(o, e, r, b.verticalTextBoxStartIndex, b.verticalTextBoxEndIndex, b), this._addIconDebugCollisionBoxes(h, e, r, b.iconBoxStartIndex, b.iconBoxEndIndex, b), this._addIconDebugCollisionBoxes(h, e, r, b.verticalIconBoxStartIndex, b.verticalIconBoxEndIndex, b);
            }
          }
          getSymbolInstanceTextSize(e, r, s, h) {
            const o = this.text.placedSymbolArray.get(r.rightJustifiedTextSymbolIndex >= 0 ? r.rightJustifiedTextSymbolIndex : r.centerJustifiedTextSymbolIndex >= 0 ? r.centerJustifiedTextSymbolIndex : r.leftJustifiedTextSymbolIndex >= 0 ? r.leftJustifiedTextSymbolIndex : r.verticalPlacedTextSymbolIndex >= 0 ? r.verticalPlacedTextSymbolIndex : h), f = mp(this.textSizeData, e, o) / Ns;
            return this.tilePixelRatio * f;
          }
          getSymbolInstanceIconSize(e, r, s) {
            const h = this.icon.placedSymbolArray.get(s), o = mp(this.iconSizeData, e, h);
            return this.tilePixelRatio * o;
          }
          _commitDebugCollisionVertexUpdate(e, r, s, h) {
            e.emplaceBack(r, -s, -s, h), e.emplaceBack(r, s, -s, h), e.emplaceBack(r, s, s, h), e.emplaceBack(r, -s, s, h);
          }
          _updateTextDebugCollisionBoxes(e, r, s, h, o, f, b) {
            for (let O = h; O < o; O++) {
              const H = s.get(O), y = this.getSymbolInstanceTextSize(e, f, r, O);
              this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, y, H.padding, f.zOffset);
            }
          }
          _updateIconDebugCollisionBoxes(e, r, s, h, o, f, b) {
            for (let O = h; O < o; O++) {
              const H = s.get(O), y = this.getSymbolInstanceIconSize(e, r, f.placedIconSymbolIndex);
              this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, y, H.padding, f.zOffset);
            }
          }
          updateCollisionDebugBuffers(e, r, s, h) {
            if (!this.hasDebugData()) return;
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
            const o = Kf(this.iconSizeData, e, h), f = Kf(this.textSizeData, e, s);
            for (let b = 0; b < this.symbolInstances.length; b++) {
              const O = this.symbolInstances.get(b);
              this._updateTextDebugCollisionBoxes(f, e, r, O.textBoxStartIndex, O.textBoxEndIndex, O, s), this._updateTextDebugCollisionBoxes(f, e, r, O.verticalTextBoxStartIndex, O.verticalTextBoxEndIndex, O, s), this._updateIconDebugCollisionBoxes(o, e, r, O.iconBoxStartIndex, O.iconBoxEndIndex, O, h), this._updateIconDebugCollisionBoxes(o, e, r, O.verticalIconBoxStartIndex, O.verticalIconBoxEndIndex, O, h);
            }
            this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
          }
          _deserializeCollisionBoxesForSymbol(e, r, s, h, o, f, b, O, H) {
            const y = {};
            if (r < s) {
              const { x1: B, y1: G, x2: L, y2: F, padding: Y, projectedAnchorX: ce, projectedAnchorY: _e, projectedAnchorZ: ze, tileAnchorX: Ne, tileAnchorY: Ee, featureIndex: We } = e.get(r);
              y.textBox = { x1: B, y1: G, x2: L, y2: F, padding: Y, projectedAnchorX: ce, projectedAnchorY: _e, projectedAnchorZ: ze, tileAnchorX: Ne, tileAnchorY: Ee }, y.textFeatureIndex = We;
            }
            if (h < o) {
              const { x1: B, y1: G, x2: L, y2: F, padding: Y, projectedAnchorX: ce, projectedAnchorY: _e, projectedAnchorZ: ze, tileAnchorX: Ne, tileAnchorY: Ee, featureIndex: We } = e.get(h);
              y.verticalTextBox = { x1: B, y1: G, x2: L, y2: F, padding: Y, projectedAnchorX: ce, projectedAnchorY: _e, projectedAnchorZ: ze, tileAnchorX: Ne, tileAnchorY: Ee }, y.verticalTextFeatureIndex = We;
            }
            if (f < b) {
              const { x1: B, y1: G, x2: L, y2: F, padding: Y, projectedAnchorX: ce, projectedAnchorY: _e, projectedAnchorZ: ze, tileAnchorX: Ne, tileAnchorY: Ee, featureIndex: We } = e.get(f);
              y.iconBox = { x1: B, y1: G, x2: L, y2: F, padding: Y, projectedAnchorX: ce, projectedAnchorY: _e, projectedAnchorZ: ze, tileAnchorX: Ne, tileAnchorY: Ee }, y.iconFeatureIndex = We;
            }
            if (O < H) {
              const { x1: B, y1: G, x2: L, y2: F, padding: Y, projectedAnchorX: ce, projectedAnchorY: _e, projectedAnchorZ: ze, tileAnchorX: Ne, tileAnchorY: Ee, featureIndex: We } = e.get(O);
              y.verticalIconBox = { x1: B, y1: G, x2: L, y2: F, padding: Y, projectedAnchorX: ce, projectedAnchorY: _e, projectedAnchorZ: ze, tileAnchorX: Ne, tileAnchorY: Ee }, y.verticalIconFeatureIndex = We;
            }
            return y;
          }
          deserializeCollisionBoxes(e) {
            this.collisionArrays = [];
            for (let r = 0; r < this.symbolInstances.length; r++) {
              const s = this.symbolInstances.get(r);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, s.textBoxStartIndex, s.textBoxEndIndex, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s.iconBoxStartIndex, s.iconBoxEndIndex, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          hasIconTextFit() {
            return this.hasAnyIconTextFit;
          }
          addIndicesForPlacedSymbol(e, r) {
            const s = e.placedSymbolArray.get(r), h = s.vertexStartIndex + 4 * s.numGlyphs;
            for (let o = s.vertexStartIndex; o < h; o += 4) e.indexArray.emplaceBack(o, o + 1, o + 2), e.indexArray.emplaceBack(o + 1, o + 2, o + 3);
          }
          getSortedSymbolIndexes(e) {
            if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const r = Math.sin(e), s = Math.cos(e), h = [], o = [], f = [];
            for (let b = 0; b < this.symbolInstances.length; ++b) {
              f.push(b);
              const O = this.symbolInstances.get(b);
              h.push(0 | Math.round(r * O.tileAnchorX + s * O.tileAnchorY)), o.push(O.featureIndex);
            }
            return f.sort((b, O) => h[b] - h[O] || o[O] - o[b]), f;
          }
          getSortedIndexesByZOffset() {
            if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
            if (!this.symbolInstanceIndexesSortedZOffset) {
              this.symbolInstanceIndexesSortedZOffset = [];
              for (let e = 0; e < this.symbolInstances.length; ++e) this.symbolInstanceIndexesSortedZOffset.push(e);
            }
            return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((e, r) => this.symbolInstances.get(r).zOffset - this.symbolInstances.get(e).zOffset);
          }
          addToSortKeyRanges(e, r) {
            const s = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            s && s.sortKey === r ? s.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: r, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
          }
          sortFeatures(e) {
            if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const r of this.symbolInstanceIndexes) {
                const s = this.symbolInstances.get(r);
                this.featureSortOrder.push(s.featureIndex);
                const { rightJustifiedTextSymbolIndex: h, centerJustifiedTextSymbolIndex: o, leftJustifiedTextSymbolIndex: f, verticalPlacedTextSymbolIndex: b, placedIconSymbolIndex: O, verticalPlacedIconSymbolIndex: H } = s;
                h >= 0 && this.addIndicesForPlacedSymbol(this.text, h), o >= 0 && o !== h && this.addIndicesForPlacedSymbol(this.text, o), f >= 0 && f !== o && f !== h && this.addIndicesForPlacedSymbol(this.text, f), b >= 0 && this.addIndicesForPlacedSymbol(this.text, b), O >= 0 && this.addIndicesForPlacedSymbol(this.icon, O), H >= 0 && this.addIndicesForPlacedSymbol(this.icon, H);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let J0, Q0, Om;
        ur(Mp, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Mp.addDynamicAttributes = Ap;
        class ev {
          constructor(e) {
            this.type = e.property.overrides ? e.property.overrides.runtimeType : hi, this.defaultValue = e;
          }
          evaluate(e) {
            if (e.formattedSection) {
              const r = this.defaultValue.property.overrides;
              if (r && r.hasOverride(e.formattedSection)) return r.getOverride(e.formattedSection);
            }
            return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(e) {
            this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        ur(ev, "FormatSectionOverride", { omit: ["defaultValue"] });
        const Dm = () => Om || (Om = { layout: J0 || (J0 = new Wn({ "symbol-placement": new Ji(Ei.layout_symbol["symbol-placement"]), "symbol-spacing": new Ji(Ei.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ji(Ei.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new or(Ei.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ji(Ei.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new Ji(Ei.layout_symbol["symbol-z-elevate"]), "symbol-elevation-reference": new Ji(Ei.layout_symbol["symbol-elevation-reference"]), "icon-allow-overlap": new Ji(Ei.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Ji(Ei.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ji(Ei.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ji(Ei.layout_symbol["icon-rotation-alignment"]), "icon-size": new or(Ei.layout_symbol["icon-size"]), "icon-size-scale-range": new Ji(Ei.layout_symbol["icon-size-scale-range"]), "icon-text-fit": new or(Ei.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new or(Ei.layout_symbol["icon-text-fit-padding"]), "icon-image": new or(Ei.layout_symbol["icon-image"]), "icon-rotate": new or(Ei.layout_symbol["icon-rotate"]), "icon-padding": new Ji(Ei.layout_symbol["icon-padding"]), "icon-keep-upright": new Ji(Ei.layout_symbol["icon-keep-upright"]), "icon-offset": new or(Ei.layout_symbol["icon-offset"]), "icon-anchor": new or(Ei.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ji(Ei.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ji(Ei.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ji(Ei.layout_symbol["text-rotation-alignment"]), "text-field": new or(Ei.layout_symbol["text-field"]), "text-font": new or(Ei.layout_symbol["text-font"]), "text-size": new or(Ei.layout_symbol["text-size"]), "text-size-scale-range": new Ji(Ei.layout_symbol["text-size-scale-range"]), "text-max-width": new or(Ei.layout_symbol["text-max-width"]), "text-line-height": new or(Ei.layout_symbol["text-line-height"]), "text-letter-spacing": new or(Ei.layout_symbol["text-letter-spacing"]), "text-justify": new or(Ei.layout_symbol["text-justify"]), "text-radial-offset": new or(Ei.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ji(Ei.layout_symbol["text-variable-anchor"]), "text-anchor": new or(Ei.layout_symbol["text-anchor"]), "text-max-angle": new Ji(Ei.layout_symbol["text-max-angle"]), "text-writing-mode": new Ji(Ei.layout_symbol["text-writing-mode"]), "text-rotate": new or(Ei.layout_symbol["text-rotate"]), "text-padding": new Ji(Ei.layout_symbol["text-padding"]), "text-keep-upright": new Ji(Ei.layout_symbol["text-keep-upright"]), "text-transform": new or(Ei.layout_symbol["text-transform"]), "text-offset": new or(Ei.layout_symbol["text-offset"]), "text-allow-overlap": new Ji(Ei.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Ji(Ei.layout_symbol["text-ignore-placement"]), "text-optional": new Ji(Ei.layout_symbol["text-optional"]), visibility: new Ji(Ei.layout_symbol.visibility) })), paint: Q0 || (Q0 = new Wn({ "icon-opacity": new or(Ei.paint_symbol["icon-opacity"]), "icon-occlusion-opacity": new or(Ei.paint_symbol["icon-occlusion-opacity"]), "icon-emissive-strength": new or(Ei.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new or(Ei.paint_symbol["text-emissive-strength"]), "icon-color": new or(Ei.paint_symbol["icon-color"]), "icon-halo-color": new or(Ei.paint_symbol["icon-halo-color"]), "icon-halo-width": new or(Ei.paint_symbol["icon-halo-width"]), "icon-halo-blur": new or(Ei.paint_symbol["icon-halo-blur"]), "icon-translate": new Ji(Ei.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ji(Ei.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new or(Ei.paint_symbol["icon-image-cross-fade"]), "text-opacity": new or(Ei.paint_symbol["text-opacity"]), "text-occlusion-opacity": new or(Ei.paint_symbol["text-occlusion-opacity"]), "text-color": new or(Ei.paint_symbol["text-color"], { runtimeType: _r, getOverride: (a) => a.textColor, hasOverride: (a) => !!a.textColor }), "text-halo-color": new or(Ei.paint_symbol["text-halo-color"]), "text-halo-width": new or(Ei.paint_symbol["text-halo-width"]), "text-halo-blur": new or(Ei.paint_symbol["text-halo-blur"]), "text-translate": new Ji(Ei.paint_symbol["text-translate"]), "text-translate-anchor": new Ji(Ei.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new Ji(Ei.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new Ji(Ei.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new Ji(Ei.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new Ji(Ei.paint_symbol["icon-color-brightness-max"]), "symbol-z-offset": new or(Ei.paint_symbol["symbol-z-offset"]), "icon-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "icon-halo-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "text-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "text-halo-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, Om);
        class Ip extends bn {
          constructor(e, r, s, h) {
            super(e, Dm(), r, s, h), this._colorAdjustmentMatrix = rt.mat4.identity([]), this.hasInitialOcclusionOpacityProperties = e.paint !== void 0 && ("icon-occlusion-opacity" in e.paint || "text-occlusion-opacity" in e.paint);
          }
          recalculate(e, r) {
            super.recalculate(e, r), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
            const s = this.layout.get("text-writing-mode");
            if (s) {
              const h = [];
              for (const o of s) h.indexOf(o) < 0 && h.push(o);
              this.layout._values["text-writing-mode"] = h;
            } else this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"];
            this._setPaintOverrides();
          }
          getColorAdjustmentMatrix(e, r, s, h) {
            return this._saturation === e && this._contrast === r && this._brightnessMin === s && this._brightnessMax === h || (this._colorAdjustmentMatrix = function(o, f, b, O) {
              o = ae(o), f = nt(f);
              const H = rt.mat4.create(), y = o / 3, B = 1 - 2 * y, G = [B, y, y, 0, y, B, y, 0, y, y, B, 0, 0, 0, 0, 1], L = 0.5 - 0.5 * f, F = O - b;
              return rt.mat4.multiply(H, [F, 0, 0, 0, 0, F, 0, 0, 0, 0, F, 0, b, b, b, 1], [f, 0, 0, 0, 0, f, 0, 0, 0, 0, f, 0, L, L, L, 1]), rt.mat4.multiply(H, H, G), H;
            }(e, r, s, h), this._saturation = e, this._contrast = r, this._brightnessMin = s, this._brightnessMax = h), this._colorAdjustmentMatrix;
          }
          getValueAndResolveTokens(e, r, s, h) {
            const o = this.layout.get(e).evaluate(r, {}, s, h), f = this._unevaluatedLayout._values[e];
            return f.isDataDriven() || yu(f.value) || !o ? o : function(b, O) {
              return O.replace(/{([^{}]+)}/g, (H, y) => y in b ? String(b[y]) : "");
            }(r.properties, o);
          }
          createBucket(e) {
            return new Mp(e);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return !1;
          }
          _setPaintOverrides() {
            for (const e of Dm().paint.overridableProperties) {
              if (!Ip.hasPaintOverride(this.layout, e)) continue;
              const r = this.paint.get(e), s = new ev(r), h = new vu(s, r.property.specification, this.scope, this.options);
              let o = null;
              o = r.value.kind === "constant" || r.value.kind === "source" ? new xu("source", h) : new bu("composite", h, r.value.zoomStops, r.value._interpolationType), this.paint._values[e] = new ql(r.property, o, r.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(e, r, s) {
            return !(!this.layout || r.isDataDriven() || s.isDataDriven()) && Ip.hasPaintOverride(this.layout, e);
          }
          static hasPaintOverride(e, r) {
            const s = e.get("text-field"), h = Dm().paint.properties[r];
            let o = !1;
            const f = (b) => {
              for (const O of b) if (h.overrides && h.overrides.hasOverride(O)) return void (o = !0);
            };
            if (s.value.kind === "constant" && s.value.value instanceof Na) f(s.value.value.sections);
            else if (s.value.kind === "source") {
              const b = (H) => {
                o || (H instanceof ta && Nn(H.value) === Ia ? f(H.value.sections) : H instanceof aa ? f(H.sections) : H.eachChild(b));
              }, O = s.value;
              O._styleExpression && b(O._styleExpression.expression);
            }
            return o;
          }
          getProgramIds() {
            return ["symbol"];
          }
          getDefaultProgramParams(e, r, s) {
            return { config: new Tl(this, { zoom: r, lut: s }), overrideFog: !1 };
          }
        }
        let tv, iv, rv, nv;
        var zm = dn([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        function Bm(a) {
          switch (a) {
            case WebGL2RenderingContext.RGBA8:
              return WebGL2RenderingContext.RGBA;
            case WebGL2RenderingContext.DEPTH_COMPONENT16:
              return WebGL2RenderingContext.DEPTH_COMPONENT;
            case WebGL2RenderingContext.DEPTH24_STENCIL8:
              return WebGL2RenderingContext.DEPTH_STENCIL;
            case WebGL2RenderingContext.R8:
            case WebGL2RenderingContext.R32F:
              return WebGL2RenderingContext.RED;
          }
        }
        function Fm(a) {
          switch (a) {
            case WebGL2RenderingContext.RGBA8:
              return WebGL2RenderingContext.UNSIGNED_BYTE;
            case WebGL2RenderingContext.DEPTH_COMPONENT16:
              return WebGL2RenderingContext.UNSIGNED_SHORT;
            case WebGL2RenderingContext.DEPTH24_STENCIL8:
              return WebGL2RenderingContext.UNSIGNED_INT_24_8;
            case WebGL2RenderingContext.R8:
              return WebGL2RenderingContext.UNSIGNED_BYTE;
            case WebGL2RenderingContext.R32F:
              return WebGL2RenderingContext.FLOAT;
          }
        }
        class Nm {
          constructor(e, r, s, h) {
            this.context = e, this.format = s, this.useMipmap = h && h.useMipmap, this.texture = e.gl.createTexture(), this.update(r, { premultiply: h && h.premultiply });
          }
          update(e, r) {
            const s = e && e instanceof HTMLVideoElement && e.width === 0 ? e.videoWidth : e.width, h = e && e instanceof HTMLVideoElement && e.height === 0 ? e.videoHeight : e.height, { context: o } = this, { gl: f } = o, { x: b, y: O } = r && r.position ? r.position : { x: 0, y: 0 }, H = b + s, y = O + h;
            !this.size || this.size[0] === H && this.size[1] === y || (f.bindTexture(f.TEXTURE_2D, null), f.deleteTexture(this.texture), this.texture = f.createTexture(), this.size = null), f.bindTexture(f.TEXTURE_2D, this.texture), o.pixelStoreUnpackFlipY.set(!1), o.pixelStoreUnpack.set(1), o.pixelStoreUnpackPremultiplyAlpha.set(this.format === f.RGBA8 && (!r || r.premultiply !== !1));
            const B = e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ImageBitmap && e instanceof ImageBitmap;
            if (!this.size && H > 0 && y > 0) {
              const G = this.useMipmap ? Math.floor(Math.log2(Math.max(H, y))) + 1 : 1;
              f.texStorage2D(f.TEXTURE_2D, G, this.format, H, y), this.size = [H, y];
            }
            if (this.size) if (B) f.texSubImage2D(f.TEXTURE_2D, 0, b, O, Bm(this.format), Fm(this.format), e);
            else {
              const G = e.data;
              G && f.texSubImage2D(f.TEXTURE_2D, 0, b, O, s, h, Bm(this.format), Fm(this.format), G);
            }
            this.useMipmap && f.generateMipmap(f.TEXTURE_2D);
          }
          bind(e, r, s = !1) {
            const { context: h } = this, { gl: o } = h;
            o.bindTexture(o.TEXTURE_2D, this.texture), e !== this.minFilter && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, e), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, this.useMipmap && !s ? e === o.NEAREST ? o.NEAREST_MIPMAP_NEAREST : o.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), r !== this.wrapS && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, r), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, r), this.wrapS = r);
          }
          bindExtraParam(e, r, s, h) {
            const { context: o } = this, { gl: f } = o;
            f.bindTexture(f.TEXTURE_2D, this.texture), r !== this.magFilter && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, r), this.magFilter = r), e !== this.minFilter && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, this.useMipmap ? e === f.NEAREST ? f.NEAREST_MIPMAP_NEAREST : f.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), s !== this.wrapS && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, s), this.wrapS = s), h !== this.wrapT && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, h), this.wrapT = h);
          }
          destroy() {
            const { gl: e } = this.context;
            e.deleteTexture(this.texture), this.texture = null;
          }
        }
        class Pp {
          constructor(e, r) {
            this.context = e, this.texture = r;
          }
          bind(e, r) {
            const { context: s } = this, { gl: h } = s;
            h.bindTexture(h.TEXTURE_2D, this.texture), e !== this.minFilter && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, e), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, e), this.minFilter = e), r !== this.wrapS && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, r), h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, r), this.wrapS = r);
          }
        }
        function Rp(a, e, r, s, h, o, f, b) {
          const O = [a, e, 1, r, s, 1, h, o, 1], H = [f, b, 1], y = rt.mat3.adjoint([], O), [B, G, L] = rt.vec3.transformMat3(H, H, y);
          return rt.mat3.multiply(O, O, [B, 0, 0, 0, G, 0, 0, 0, L]);
        }
        function av(a, e, r, s, h, o, f, b) {
          const O = function(H, y, B, G, L, F, Y, ce) {
            const _e = Rp(0, 0, 1, 0, 1, 1, 0, 1), ze = Rp(H, y, B, G, L, F, Y, ce), Ne = rt.mat3.adjoint([], _e);
            return rt.mat3.multiply(ze, ze, Ne);
          }(a, e, r, s, h, o, f, b);
          return [O[2] / O[8] / tr, O[5] / O[8] / tr];
        }
        function kp(a) {
          return [a[0], Math.min(Math.max(a[1], -la), la)];
        }
        class sv extends tn {
          constructor(e, r, s, h) {
            super(), this.id = e, this.dispatcher = s, this.coordinates = r.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(h), this.options = r, this._dirty = !1;
          }
          load(e, r) {
            if (this._loaded = r || !1, this.fire(new mn("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url) return e && (this.coordinates = e), this._loaded = !0, void this._finishLoading();
            this._imageRequest = Ta(this.map._requestManager.transformRequest(this.url, Mr.Image), (s, h) => {
              this._imageRequest = null, this._loaded = !0, s ? this.fire(new eo(s)) : h && (this.image = h instanceof HTMLImageElement ? Ct.getImageData(h) : h, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, e && (this.coordinates = e), this._finishLoading());
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e) {
            return e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e.url, this.load(e.coordinates, this._loaded), this) : this;
          }
          setTexture(e) {
            if (!(e.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
            return this.texture = new Pp(this.map.painter.context, e.handle), this.width = e.dimensions[0], this.height = e.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new mn("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e) {
            this.map = e, this.load();
          }
          onRemove(e) {
            this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof Pp || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
          }
          setCoordinates(e) {
            if (this.coordinates = e, this._boundsArray = void 0, this._unsupportedCoords = !1, !e.length) return this;
            this.onNorthPole = !1, this.onSouthPole = !1;
            let r = e[0][1], s = e[0][1];
            for (const o of e) o[1] > s && (s = o[1]), o[1] < r && (r = o[1]);
            const h = (s + r) / 2;
            if (h > la ? this.onNorthPole = !0 : h < -la && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {
              const o = e.map(n.fromLngLat);
              this.tileID = function(f) {
                let b = 1 / 0, O = 1 / 0, H = -1 / 0, y = -1 / 0;
                for (const Y of f) b = Math.min(b, Y.x), O = Math.min(O, Y.y), H = Math.max(H, Y.x), y = Math.max(y, Y.y);
                const B = Math.max(H - b, y - O), G = Math.max(0, Math.floor(-Math.log(B) / Math.LN2)), L = Math.pow(2, G);
                let F = Math.floor((b + H) / 2 * L);
                return F > 1 && (F -= 1), new Ui(G, F, Math.floor((O + y) / 2 * L));
              }(o), this.minzoom = this.maxzoom = this.tileID.z;
            }
            return this.fire(new mn("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          _clear() {
            this._boundsArray = void 0, this._unsupportedCoords = !1;
          }
          _prepareData(e) {
            for (const _e in this.tiles) {
              const ze = this.tiles[_e];
              ze.state !== "loaded" && (ze.state = "loaded", ze.texture = this.texture);
            }
            if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
            const r = Dd(new Ui(0, 0, 0), this.map.transform.projection), s = [r.projection.project(this.coordinates[0][0], this.coordinates[0][1]), r.projection.project(this.coordinates[1][0], this.coordinates[1][1]), r.projection.project(this.coordinates[2][0], this.coordinates[2][1]), r.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
            if (!function(_e) {
              const ze = _e[1].x - _e[0].x, Ne = _e[1].y - _e[0].y, Ee = _e[2].x - _e[1].x, We = _e[2].y - _e[1].y, lt = _e[3].x - _e[2].x, yt = _e[3].y - _e[2].y, Bt = _e[0].x - _e[3].x, zt = _e[0].y - _e[3].y, Dt = ze * We - Ee * Ne, ni = Ee * yt - lt * We, Gt = lt * zt - Bt * yt, si = Bt * Ne - ze * zt;
              return Dt > 0 && ni > 0 && Gt > 0 && si > 0 || Dt < 0 && ni < 0 && Gt < 0 && si < 0;
            }(s)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = !0);
            const h = Dd(this.tileID, this.map.transform.projection), [o, f, b, O] = this.coordinates.map((_e) => {
              const ze = h.projection.project(_e[0], _e[1]);
              return W0(h, ze)._round();
            });
            this.perspectiveTransform = av(o.x, o.y, f.x, f.y, b.x, b.y, O.x, O.y);
            const H = this._boundsArray = new pa();
            H.emplaceBack(o.x, o.y, 0, 0), H.emplaceBack(f.x, f.y, tr, 0), H.emplaceBack(O.x, O.y, 0, tr), H.emplaceBack(b.x, b.y, tr, tr), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = e.createVertexBuffer(H, zm.members), this.boundsSegments = Ea.simpleSegment(0, 0, 4, 2);
            const y = [], B = [kp((G = this.coordinates)[0]), kp(G[1]), kp(G[2]), kp(G[3])];
            var G;
            const [L, F, Y, ce] = function(_e) {
              let ze = _e[0][0], Ne = ze, Ee = _e[0][1], We = Ee;
              for (let lt = 1; lt < _e.length; lt++) _e[lt][0] < ze ? ze = _e[lt][0] : _e[lt][0] > Ne && (Ne = _e[lt][0]), _e[lt][1] < Ee ? Ee = _e[lt][1] : _e[lt][1] > We && (We = _e[lt][1]);
              return [ze, Ee, Ne - ze, We - Ee];
            }(B);
            {
              const _e = new pa(), [ze, Ne, Ee, We] = function(gi) {
                let Si = gi[0].x, pi = Si, zi = gi[0].y, Gi = zi;
                for (let Oi = 1; Oi < gi.length; Oi++) gi[Oi].x < Si ? Si = gi[Oi].x : gi[Oi].x > pi && (pi = gi[Oi].x), gi[Oi].y < zi ? zi = gi[Oi].y : gi[Oi].y > Gi && (Gi = gi[Oi].y);
                return [Si, zi, pi - Si, Gi - zi];
              }(s), lt = (gi) => [(gi.x - ze) / Ee, (gi.y - Ne) / We], [yt, Bt, zt, Dt] = s.map(lt), ni = function(gi, Si, pi, zi, Gi, Oi, lr, ar) {
                const Qi = Rp(0, 0, 1, 0, 1, 1, 0, 1), qi = Rp(gi, Si, pi, zi, Gi, Oi, lr, ar), xr = rt.mat3.adjoint([], qi);
                return rt.mat3.multiply(Qi, Qi, xr);
              }(yt[0], yt[1], Bt[0], Bt[1], zt[0], zt[1], Dt[0], Dt[1]);
              this.elevatedGlobePerspectiveTransform = av(yt[0], yt[1], Bt[0], Bt[1], zt[0], zt[1], Dt[0], Dt[1]);
              const Gt = (gi, Si) => {
                y.push(gi.lng);
                const pi = Math.round((gi.lng - L) / Y * tr), zi = Math.round((gi.lat - F) / ce * tr), Gi = lt(Si), Oi = rt.vec3.transformMat3([], [Gi[0], Gi[1], 1], ni), lr = Math.round(Oi[0] / Oi[2] * tr), ar = Math.round(Oi[1] / Oi[2] * tr);
                _e.emplaceBack(pi, zi, lr, ar);
              }, si = s[3].x - s[0].x, ci = s[3].y - s[0].y, li = s[2].x - s[1].x, fi = s[2].y - s[1].y;
              for (let gi = 0; gi < 65; gi++) {
                const Si = gi / 64, pi = [s[0].x + Si * si, s[0].y + Si * ci], zi = [s[1].x + Si * li, s[1].y + Si * fi], Gi = zi[0] - pi[0], Oi = zi[1] - pi[1];
                for (let lr = 0; lr < 65; lr++) {
                  const ar = lr / 64, Qi = { x: pi[0] + Gi * ar, y: pi[1] + Oi * ar, z: 0 };
                  Gt(r.projection.unproject(Qi.x, Qi.y), Qi);
                }
              }
              this.elevatedGlobeVertexBuffer = e.createVertexBuffer(_e, zm.members);
            }
            {
              this.maxLongitudeTriangleSize = 0;
              let _e = [], ze = new Ya();
              const Ne = (Ee, We, lt) => {
                ze.emplaceBack(Ee, We, lt);
                const yt = y[Ee], Bt = y[We], zt = y[lt], Dt = Math.min(Math.min(yt, Bt), zt), ni = Math.max(Math.max(yt, Bt), zt) - Dt;
                ni > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = ni), _e.push(Dt + ni / 2);
              };
              for (let Ee = 0; Ee < 64; Ee++) for (let We = 0; We < 64; We++) {
                const lt = 65 * Ee + We, yt = lt + 1, Bt = lt + 65, zt = Bt + 1;
                Ne(lt, Bt, yt), Ne(yt, Bt, zt);
              }
              [_e, ze] = function(Ee, We) {
                const lt = Array.from({ length: Ee.length }, (zt, Dt) => Dt);
                lt.sort((zt, Dt) => Ee[zt] - Ee[Dt]);
                const yt = [], Bt = new Ya();
                for (let zt = 0; zt < lt.length; zt++) {
                  const Dt = lt[zt];
                  yt.push(Ee[Dt]);
                  const ni = 3 * Dt, Gt = ni + 1;
                  Bt.emplaceBack(We.uint16[ni], We.uint16[Gt], We.uint16[Gt + 1]);
                }
                return [yt, Bt];
              }(_e, ze), this.elevatedGlobeTrianglesCenterLongitudes = _e, this.elevatedGlobeIndexBuffer = e.createIndexBuffer(ze);
            }
            this.elevatedGlobeSegments = Ea.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, Y / tr, 0, ce / tr, 0, 0, F, L, 0]);
          }
          prepare() {
            const e = Object.keys(this.tiles).length !== 0;
            if (this.tileID && !e) return;
            const r = this.map.painter.context, s = r.gl;
            !this._dirty || this.texture instanceof Pp || (this.texture ? this.texture.update(this.image) : (this.texture = new Nm(r, this.image, s.RGBA8), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE)), this._dirty = !1), e && this._prepareData(r);
          }
          loadTile(e, r) {
            this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, r(null)) : (e.state = "errored", r(null));
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
          getSegmentsForLongitude(e) {
            const r = this.elevatedGlobeSegments;
            if (!this.elevatedGlobeTrianglesCenterLongitudes || !r) return null;
            const s = this.elevatedGlobeTrianglesCenterLongitudes;
            let h = (o = e + 180) + 360 * Math.round((s[0] - o) / 360);
            var o;
            const f = new Ea(), b = (B, G) => {
              f.segments.push({ vertexOffset: 0, primitiveOffset: B, vertexLength: r.segments[0].vertexLength, primitiveLength: G, sortKey: void 0, vaos: {} });
            }, O = 0.51 * this.maxLongitudeTriangleSize;
            if (Math.abs(s[0] - h) <= O) {
              const B = He(s, 0, s.length, h + O);
              return B === s.length || b(B, z(s, B + 1, s.length, h + 360 - O) - B), f;
            }
            h < s[0] && (h += 360);
            const H = z(s, 0, s.length, h - O);
            if (H === s.length) return b(0, s.length), f;
            b(0, H - 0);
            const y = He(s, H + 1, s.length, h + O);
            return y !== s.length && b(y, s.length - y), f;
          }
        }
        const xb = (Math.pow(256, 2) - 1) / 16907520;
        class ov extends bn {
          constructor(e, r, s, h) {
            super(e, { layout: rv || (rv = new Wn({ visibility: new Ji(Ei.layout_raster.visibility) })), paint: nv || (nv = new Wn({ "raster-opacity": new Ji(Ei.paint_raster["raster-opacity"]), "raster-color": new So(Ei.paint_raster["raster-color"]), "raster-color-mix": new Ji(Ei.paint_raster["raster-color-mix"]), "raster-color-range": new Ji(Ei.paint_raster["raster-color-range"]), "raster-hue-rotate": new Ji(Ei.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ji(Ei.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ji(Ei.paint_raster["raster-brightness-max"]), "raster-saturation": new Ji(Ei.paint_raster["raster-saturation"]), "raster-contrast": new Ji(Ei.paint_raster["raster-contrast"]), "raster-resampling": new Ji(Ei.paint_raster["raster-resampling"]), "raster-fade-duration": new Ji(Ei.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new Ji(Ei.paint_raster["raster-emissive-strength"]), "raster-array-band": new Ji(Ei.paint_raster["raster-array-band"]), "raster-elevation": new Ji(Ei.paint_raster["raster-elevation"]), "raster-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, r, s, h), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
          }
          getProgramIds() {
            return ["raster"];
          }
          hasColorMap() {
            return !!this._transitionablePaint._values["raster-color"].value.value;
          }
          tileCoverLift() {
            return this.paint.get("raster-elevation");
          }
          isDraped(e) {
            return !(e && e._source instanceof sv && (e._source.onNorthPole || e._source.onSouthPole)) && this.paint.get("raster-elevation") === 0;
          }
          _handleSpecialPaintPropertyUpdate(e) {
            e !== "raster-color" && e !== "raster-color-range" || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
          }
          updateColorRamp(e) {
            if (!this.hasColorMap() || !this._curRampRange) return;
            const r = this._transitionablePaint._values["raster-color"].value.expression, [s, h] = e || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
            isNaN(s) && isNaN(h) || s === this._curRampRange[0] && h === this._curRampRange[1] || (this.colorRamp = Fh({ expression: r, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: s, end: h }], resolution: 256 }), this.colorRampTexture = null, this._curRampRange = [s, h]);
          }
        }
        let lv, uv, cv, hv, fv;
        class dv extends bn {
          constructor(e, r, s, h) {
            super(e, { layout: lv || (lv = new Wn({ visibility: new Ji(Ei["layout_raster-particle"].visibility) })), paint: uv || (uv = new Wn({ "raster-particle-array-band": new Ji(Ei["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new Ji(Ei["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new So(Ei["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new Ji(Ei["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new Ji(Ei["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new Ji(Ei["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new Ji(Ei["paint_raster-particle"]["raster-particle-reset-rate-factor"]), "raster-particle-elevation": new Ji(Ei["paint_raster-particle"]["raster-particle-elevation"]), "raster-particle-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, r, s, h), this._updateColorRamp(), this.lastInvalidatedAt = Ct.now();
          }
          onRemove(e) {
            this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
          }
          hasColorMap() {
            return !!this._transitionablePaint._values["raster-particle-color"].value.value;
          }
          getProgramIds() {
            return ["rasterParticle"];
          }
          hasOffscreenPass() {
            return this.visibility !== "none";
          }
          isDraped(e) {
            return !1;
          }
          _handleSpecialPaintPropertyUpdate(e) {
            e !== "raster-particle-color" && e !== "raster-particle-max-speed" || (this._updateColorRamp(), this._invalidateAnimationState()), e === "raster-particle-count" && this._invalidateAnimationState();
          }
          _updateColorRamp() {
            if (!this.hasColorMap()) return;
            const e = this._transitionablePaint._values["raster-particle-color"].value.expression, r = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
            this.colorRamp = Fh({ expression: e, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: r }], resolution: 256 }), this.colorRampTexture = null;
          }
          _invalidateAnimationState() {
            this.lastInvalidatedAt = Ct.now();
          }
          tileCoverLift() {
            return this.paint.get("raster-particle-elevation");
          }
        }
        class bb extends bn {
          constructor(e, r) {
            super(e, {}, r, null), this.implementation = e, e.slot && (this.slot = e.slot);
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          isDraped(e) {
            return this.implementation.renderToTile !== void 0;
          }
          shouldRedrape() {
            return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
          }
          onAdd(e) {
            this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl);
          }
          onRemove(e) {
            this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl);
          }
        }
        function Um(a, e, r) {
          const s = [0, 0, 1], h = rt.quat.identity([]);
          return rt.quat.rotateY(h, h, r ? -Ye(a) + Math.PI : Ye(a)), rt.quat.rotateX(h, h, -Ye(e)), rt.vec3.transformQuat(s, s, h), rt.vec3.normalize(s, s);
        }
        function pv(a, e) {
          const r = Lp(a.projection, a.zoom, a.width, a.height), s = function(o, f, b, O, H) {
            const y = new hn(b.lng - 180 * Hh, b.lat), B = new hn(b.lng + 180 * Hh, b.lat), G = o.project(y.lng, y.lat), L = o.project(B.lng, B.lat), F = -Math.atan2(L.y - G.y, L.x - G.x), Y = n.fromLngLat(b);
            Y.y = pe(Y.y, -1 + Hh, 1 - Hh);
            const ce = Y.toLngLat(), _e = o.project(ce.lng, ce.lat), ze = n.fromLngLat(ce);
            ze.x += Hh;
            const Ne = ze.toLngLat(), Ee = o.project(Ne.lng, Ne.lat), We = _v(Ee.x - _e.x, Ee.y - _e.y, F), lt = n.fromLngLat(ce);
            lt.y += Hh;
            const yt = lt.toLngLat(), Bt = o.project(yt.lng, yt.lat), zt = _v(Bt.x - _e.x, Bt.y - _e.y, F), Dt = Math.abs(We.x) / Math.abs(zt.y), ni = rt.mat4.identity([]);
            rt.mat4.rotateZ(ni, ni, -F * (1 - (H ? 0 : O)));
            const Gt = rt.mat4.identity([]);
            return rt.mat4.scale(Gt, Gt, [1, 1 - (1 - Dt) * O, 1]), Gt[4] = -zt.x / zt.y * O, rt.mat4.rotateZ(Gt, Gt, F), rt.mat4.multiply(Gt, ni, Gt), Gt;
          }(a.projection, 0, a.center, r, e), h = mv(a);
          return rt.mat4.scale(s, s, [h, h, 1]), s;
        }
        function mv(a) {
          const e = a.projection, r = Lp(a.projection, a.zoom, a.width, a.height), s = Vm(e, a.center), h = Vm(e, hn.convert(e.center));
          return Math.pow(2, s * r + (1 - r) * h);
        }
        function Lp(a, e, r, s, h = 1 / 0) {
          const o = a.range;
          if (!o) return 0;
          const f = Math.min(h, Math.max(r, s)), b = Math.log(f / 1024) / Math.LN2;
          return xt(o[0] + b, o[1] + b, e);
        }
        const Hh = 1 / 4e4;
        function Vm(a, e) {
          const r = pe(e.lat, -la, la), s = new hn(e.lng - 180 * Hh, r), h = new hn(e.lng + 180 * Hh, r), o = a.project(s.lng, r), f = a.project(h.lng, r), b = n.fromLngLat(s), O = n.fromLngLat(h), H = f.x - o.x, y = f.y - o.y, B = O.x - b.x, G = O.y - b.y, L = Math.sqrt((B * B + G * G) / (H * H + y * y));
          return Math.log(L) / Math.LN2;
        }
        function _v(a, e, r) {
          const s = Math.cos(r), h = Math.sin(r);
          return { x: a * s - e * h, y: a * h + e * s };
        }
        function gv(a, e, r) {
          rt.mat4.identity(a), rt.mat4.rotateZ(a, a, Ye(e[2])), rt.mat4.rotateX(a, a, Ye(e[0])), rt.mat4.rotateY(a, a, Ye(e[1])), rt.mat4.scale(a, a, r), rt.mat4.multiply(a, a, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        function Op(a, e, r, s, h, o, f, b) {
          const O = [r[0] - e[0], r[1] - e[1], 0], H = [s[0] - e[0], s[1] - e[1], 0];
          if (rt.vec3.length(O) < 1e-12 || rt.vec3.length(H) < 1e-12) return rt.quat.identity(a);
          const y = rt.vec3.cross([], O, H);
          rt.vec3.normalize(y, y), rt.vec3.subtract(H, s, e), O[2] = (o - h) * b, H[2] = (f - h) * b;
          const B = O;
          return rt.vec3.cross(B, O, H), rt.vec3.normalize(B, B), rt.quat.rotationTo(a, y, B);
        }
        function jm(a, e, r = !1) {
          const s = Bs(e.zoom), h = function(o, f, b) {
            const O = f.worldSize, H = [o[12], o[13], o[14]], y = Pr(H[1] / O), B = Qs(H[0] / O), G = rt.mat4.identity([]), L = Zn(1, y) * O, F = Zn(1, 0) * O * wc(y, f.zoom), Y = 1 / fs(O);
            let ce = F * Y;
            if (b) {
              const Ee = Lp(f.projection, f.zoom, f.width, f.height, 1024);
              ce = Y * f.projection.pixelSpaceConversion(f.center.lat, O, Ee);
            }
            const _e = Du(y, B);
            rt.vec3.add(_e, _e, rt.vec3.scale([], rt.vec3.normalize([], _e), L * ce * H[2]));
            const ze = function(Ee) {
              const We = [Ee[0], Ee[1], Ee[2]];
              let lt = [0, 1, 0];
              const yt = rt.vec3.cross([], lt, We);
              return rt.vec3.cross(lt, We, yt), rt.vec3.squaredLength(lt) === 0 && (lt = [0, 1, 0], rt.vec3.cross(yt, We, lt)), rt.vec3.normalize(yt, yt), rt.vec3.normalize(lt, lt), rt.vec3.normalize(We, We), [yt[0], yt[1], yt[2], 0, lt[0], lt[1], lt[2], 0, We[0], We[1], We[2], 0, Ee[0], Ee[1], Ee[2], 1];
            }(_e);
            rt.mat4.scale(G, G, [ce, ce, ce * L]), rt.mat4.translate(G, G, [-H[0], -H[1], -H[2]]);
            const Ne = rt.mat4.multiply([], f.globeMatrix, ze);
            return rt.mat4.multiply(Ne, Ne, G), rt.mat4.multiply(Ne, Ne, o), Ne;
          }(a, e, r);
          if (s > 0) {
            const o = function(f, b) {
              const O = b.worldSize, H = Zn(1, 0) * O * wc(b.center.lat, b.zoom) / fs(O), y = Zn(1, b.center.lat) * O, B = rt.mat4.identity([]);
              return rt.mat4.rotateY(B, B, Ye(b.center.lng)), rt.mat4.rotateX(B, B, Ye(b.center.lat)), rt.mat4.translate(B, B, [0, 0, vs]), rt.mat4.scale(B, B, [H, H, H * y]), rt.mat4.translate(B, B, [b.point.x - 0.5 * O, b.point.y - 0.5 * O, 0]), rt.mat4.multiply(B, B, f), rt.mat4.multiply(B, b.globeMatrix, B);
            }(a, e);
            return function(f, b, O) {
              const H = (F, Y, ce) => {
                const _e = rt.vec3.length(F), ze = rt.vec3.length(Y), Ne = Aa(F, Y, ce);
                return rt.vec3.scale(Ne, Ne, 1 / rt.vec3.length(Ne) * Tr(_e, ze, ce));
              }, y = H([f[0], f[1], f[2]], [b[0], b[1], b[2]], O), B = H([f[4], f[5], f[6]], [b[4], b[5], b[6]], O), G = H([f[8], f[9], f[10]], [b[8], b[9], b[10]], O), L = Aa([f[12], f[13], f[14]], [b[12], b[13], b[14]], O);
              return [y[0], y[1], y[2], 0, B[0], B[1], B[2], 0, G[0], G[1], G[2], 0, L[0], L[1], L[2], 1];
            }(h, o, s);
          }
          return h;
        }
        function vv(a, e, r, s) {
          const h = mr.projectAabbCorners(s, r);
          let o = Number.MAX_VALUE, f = -1;
          for (let H = 0; H < h.length; ++H) {
            const y = h[H];
            y[0] = (0.5 * y[0] + 0.5) * e.width, y[1] = (0.5 - 0.5 * y[1]) * e.height, y[2] < o && (f = H, o = y[2]);
          }
          const b = (H) => new At(h[H][0], h[H][1]);
          let O;
          switch (f) {
            case 0:
            case 6:
              O = [b(1), b(5), b(4), b(7), b(3), b(2), b(1)];
              break;
            case 1:
            case 7:
              O = [b(0), b(4), b(5), b(6), b(2), b(3), b(0)];
              break;
            case 3:
            case 5:
              O = [b(1), b(0), b(4), b(7), b(6), b(2), b(1)];
              break;
            default:
              O = [b(1), b(5), b(6), b(7), b(3), b(0), b(1)];
          }
          if (st(a, O)) return o;
        }
        const wb = dn([{ name: "a_pos_3f", components: 3, type: "Float32" }]), Sb = dn([{ name: "a_color_3f", components: 3, type: "Float32" }]), Eb = dn([{ name: "a_color_4f", components: 4, type: "Float32" }]), Tb = dn([{ name: "a_uv_2f", components: 2, type: "Float32" }]), Cb = dn([{ name: "a_normal_3f", components: 3, type: "Float32" }]), Ab = dn([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), Mb = dn([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]), yv = { None: 0, Model: 1, Symbol: 2, FillExtrusion: 4, All: 7 };
        class Dp {
          constructor(e, r, s, h) {
            this.message = (e ? `${e}: ` : "") + s, h && (this.identifier = h), r != null && r.__line__ && (this.line = r.__line__);
          }
        }
        function xv(a, e) {
          const r = a.indexOf("://") === -1;
          try {
            return new URL(a, r && e ? "http://example.com" : void 0), !0;
          } catch {
            return !1;
          }
        }
        class bv {
          constructor(e, r) {
            this.feature = e, this.instancedDataOffset = r, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
          }
        }
        class wv {
          constructor() {
            this.instancedDataArray = new pc(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
          }
        }
        class Gm {
          constructor(e) {
            this.zoom = e.zoom, this.canonical = e.canonical, this.layers = e.layers, this.layerIds = this.layers.map((r) => r.fqid), this.projection = e.projection, this.index = e.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((r) => r.isStateDependent()).map((r) => r.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0;
          }
          updateFootprints(e, r) {
          }
          populate(e, r, s, h) {
            this.tileToMeter = t(s);
            const o = this.layers[0]._featureFilter.needGeometry;
            this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
            for (const { feature: f, id: b, index: O, sourceLayerIndex: H } of e) {
              const y = b ?? (f.properties && f.properties.hasOwnProperty("id") ? f.properties.id : void 0), B = ve(f, o);
              if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), B, s)) continue;
              const G = { id: y, sourceLayerIndex: H, index: O, geometry: o ? B.geometry : oe(f, s, h), properties: f.properties, type: f.type, patterns: {} }, L = this.addFeature(G, G.geometry, B);
              L && r.featureIndex.insert(f, G.geometry, O, H, this.index, this.instancesPerModel[L].instancedDataArray.length, tr / 32);
            }
            this.lookup = null;
          }
          update(e, r, s, h) {
            for (const o in this.instancesPerModel) {
              const f = this.instancesPerModel[o];
              for (const b in e) f.idToFeaturesIndex.hasOwnProperty(b) && (this.evaluate(f.features[f.idToFeaturesIndex[b]], e[b], f, !0), this.uploaded = !1);
            }
            this.maxHeight = 0;
          }
          updateZoomBasedPaintProperties() {
            if (!this.hasZoomDependentProperties) return !1;
            let e = !1;
            for (const r in this.instancesPerModel) {
              const s = this.instancesPerModel[r];
              for (const h of s.features) {
                const o = this.layers[0], f = h.feature, b = this.canonical, O = o.paint.get("model-rotation").evaluate(f, {}, b), H = o.paint.get("model-scale").evaluate(f, {}, b), y = o.paint.get("model-translation").evaluate(f, {}, b);
                rt.vec3.exactEquals(h.rotation, O) && rt.vec3.exactEquals(h.scale, H) && rt.vec3.exactEquals(h.translation, y) || (this.evaluate(h, h.featureStates, s, !0), e = !0);
              }
            }
            return e;
          }
          updateReplacement(e, r, s, h) {
            if (r.updateTime === this.replacementUpdateTime) return !1;
            this.replacementUpdateTime = r.updateTime;
            const o = r.getReplacementRegionsForTile(e.toUnwrapped(), !0);
            if (pm(this.activeReplacements, o)) return !1;
            this.activeReplacements = o;
            let f = !1;
            for (const b in this.instancesPerModel) {
              const O = this.instancesPerModel[b], H = O.instancedDataArray;
              for (const y of O.features) {
                const B = y.instancedDataOffset, G = y.instancedDataCount;
                for (let L = 0; L < G; L++) {
                  const F = 16 * (L + B);
                  let Y = H.float32[F + 0];
                  const ce = Y > tr;
                  Y = ce ? Y - tr : Y;
                  const _e = Math.floor(Y), ze = H.float32[F + 1];
                  let Ne = !1;
                  for (const Ee of this.activeReplacements) if (!zg(Ee, s, yv.Model, h) && !(Ee.min.x > _e || _e > Ee.max.x || Ee.min.y > ze || ze > Ee.max.y) && (Ne = jg(Vg(_e, ze, e.canonical, Ee.footprintTileId.canonical), Ee.footprint), Ne)) break;
                  H.float32[F] = Ne ? Y + tr : Y, f = f || Ne !== ce;
                }
              }
            }
            return f;
          }
          isEmpty() {
            for (const e in this.instancesPerModel) if (this.instancesPerModel[e].instancedDataArray.length !== 0) return !1;
            return !0;
          }
          uploadPending() {
            return !this.uploaded;
          }
          upload(e) {
            if (!this.uploaded) for (const r in this.instancesPerModel) {
              const s = this.instancesPerModel[r];
              s.instancedDataArray.length < 0 || s.instancedDataArray.length === 0 || (s.instancedDataBuffer ? s.instancedDataBuffer.updateData(s.instancedDataArray) : s.instancedDataBuffer = e.createVertexBuffer(s.instancedDataArray, Ab.members, !0, void 0, this.instanceCount));
            }
            this.uploaded = !0;
          }
          destroy() {
            for (const r in this.instancesPerModel) {
              const s = this.instancesPerModel[r];
              s.instancedDataArray.length !== 0 && s.instancedDataBuffer && s.instancedDataBuffer.destroy();
            }
            const e = this.layers[0].modelManager;
            if (e && this.modelUris) for (const r of this.modelUris) e.removeModel(r, "");
          }
          addFeature(e, r, s) {
            const h = this.layers[0], o = h.layout.get("model-id").evaluate(s, {}, this.canonical);
            if (!o) return Se(`modelId is not evaluated for layer ${h.id} and it is not going to get rendered.`), o;
            xv(o, !1) && (this.modelUris.includes(o) || this.modelUris.push(o)), this.instancesPerModel[o] || (this.instancesPerModel[o] = new wv());
            const f = this.instancesPerModel[o], b = f.instancedDataArray, O = new bv(s, b.length);
            for (const H of r) for (const y of H) {
              if (y.x < 0 || y.x >= tr || y.y < 0 || y.y >= tr) continue;
              const B = (this.lookupDim - 1) / tr, G = this.lookupDim * (y.y * B | 0) + y.x * B | 0;
              if (this.lookup) {
                if (this.lookup[G] !== 0) continue;
                this.lookup[G] = 1;
              }
              this.instanceCount++;
              const L = b.length;
              b.resize(L + 1), f.instancesEvaluatedElevation.push(0), b.float32[16 * L] = y.x, b.float32[16 * L + 1] = y.y;
            }
            return O.instancedDataCount = f.instancedDataArray.length - O.instancedDataOffset, O.instancedDataCount > 0 && (e.id && (f.idToFeaturesIndex[e.id] = f.features.length), f.features.push(O), this.evaluate(O, {}, f, !1)), o;
          }
          getModelUris() {
            return this.modelUris;
          }
          evaluate(e, r, s, h) {
            const o = this.layers[0], f = e.feature, b = this.canonical, O = e.rotation = o.paint.get("model-rotation").evaluate(f, r, b), H = e.scale = o.paint.get("model-scale").evaluate(f, r, b), y = e.translation = o.paint.get("model-translation").evaluate(f, r, b), B = o.paint.get("model-color").evaluate(f, r, b);
            B.a = o.paint.get("model-color-mix-intensity").evaluate(f, r, b);
            const G = [];
            this.maxVerticalOffset < y[2] && (this.maxVerticalOffset = y[2]), this.maxScale = Math.max(Math.max(this.maxScale, H[0]), Math.max(H[1], H[2])), gv(G, O, H);
            const L = Math.round(100 * B.a) + B.b / 1.05;
            for (let F = 0; F < e.instancedDataCount; ++F) {
              const Y = e.instancedDataOffset + F, ce = 16 * Y, _e = s.instancedDataArray.float32;
              let ze = 0;
              h && (ze = _e[ce + 6] - s.instancesEvaluatedElevation[Y]);
              const Ne = 0 | _e[ce + 1];
              _e[ce] = (0 | _e[ce]) + B.r / 1.05, _e[ce + 1] = Ne + B.g / 1.05, _e[ce + 2] = L, _e[ce + 3] = 1 / (b.z > 10 ? this.tileToMeter : t(b, Ne)), _e[ce + 4] = y[0], _e[ce + 5] = y[1], _e[ce + 6] = y[2] + ze, _e[ce + 7] = G[0], _e[ce + 8] = G[1], _e[ce + 9] = G[2], _e[ce + 10] = G[4], _e[ce + 11] = G[5], _e[ce + 12] = G[6], _e[ce + 13] = G[8], _e[ce + 14] = G[9], _e[ce + 15] = G[10], s.instancesEvaluatedElevation[Y] = y[2];
            }
          }
        }
        let Sv, Ev;
        ur(Gm, "ModelBucket", { omit: ["layers"] }), ur(wv, "PerModelAttributes"), ur(bv, "ModelFeature");
        const wf = 64, id = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
        function Tv(a, e, r, s, h, o, f, b, O, H = !1) {
          const y = r.zoom, B = r.project(s), G = wc(s.lat, y), L = 1 / G;
          rt.mat4.identity(a), rt.mat4.translate(a, a, [B.x + f[0] * L, B.y + f[1] * L, f[2]]);
          let F = 1, Y = 1;
          const ce = r.worldSize;
          if (H) {
            if (r.projection.name === "mercator") {
              let Ee = 0;
              r.elevation && (Ee = r.elevation.getAtPointOrZero(new n(B.x / ce, B.y / ce), 0));
              const We = rt.vec4.transformMat4([], [B.x, B.y, Ee, 1], r.projMatrix)[3] / r.cameraToCenterDistance;
              F = We, Y = We * wc(r.center.lat, y);
            } else if (r.projection.name === "globe") {
              const Ee = jm(a, r), We = rt.mat4.multiply([], r.projMatrix, Ee), lt = [0, 0, 0, 1];
              rt.vec4.transformMat4(lt, lt, We);
              const yt = lt[3] / r.cameraToCenterDistance, Bt = Bs(y), zt = r.projection.pixelsPerMeter(s.lat, ce) * wc(s.lat, y), Dt = r.projection.pixelsPerMeter(r.center.lat, ce) * wc(r.center.lat, y);
              F = yt / Tr(zt, zh(r.center.lat), Bt), Y = yt * G / zt, F *= Dt, Y *= Dt;
            }
          } else F = L;
          rt.mat4.scale(a, a, [F, F, Y]);
          const _e = [...a], ze = e.orientation, Ne = [];
          if (gv(Ne, [ze[0] + h[0], ze[1] + h[1], ze[2] + h[2]], o), rt.mat4.multiply(a, _e, Ne), b && r.elevation) {
            let Ee = 0;
            const We = [];
            if (O && r.elevation) {
              Ee = function(Bt, zt, Dt, ni, Gt) {
                const si = zt.elevation;
                if (!si) return 0;
                const ci = mr.projectAabbCorners(Dt, ni), li = Zn(1, Gt.lat) * zt.worldSize, fi = function(xr, hr) {
                  const pr = [0, 0, 1], Ur = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
                  for (const Xr of Ur) {
                    const Yr = xr[Xr.corners[0]], Kr = xr[Xr.corners[1]], sn = xr[Xr.corners[2]], cn = [Kr[0] - Yr[0], Kr[1] - Yr[1], hr * (Kr[2] - Yr[2])], Un = rt.vec3.cross(cn, cn, [sn[0] - Yr[0], sn[1] - Yr[1], hr * (sn[2] - Yr[2])]);
                    rt.vec3.normalize(Un, Un), Xr.dotProductWithUp = rt.vec3.dot(Un, pr);
                  }
                  return Ur.sort((Xr, Yr) => Xr.dotProductWithUp - Yr.dotProductWithUp), Ur[0].corners;
                }(ci, li), gi = ci[fi[0]], Si = ci[fi[1]], pi = ci[fi[2]], zi = ci[fi[3]], Gi = si.getAtPointOrZero(new n(gi[0] / zt.worldSize, gi[1] / zt.worldSize), 0), Oi = si.getAtPointOrZero(new n(Si[0] / zt.worldSize, Si[1] / zt.worldSize), 0), lr = si.getAtPointOrZero(new n(pi[0] / zt.worldSize, pi[1] / zt.worldSize), 0), ar = si.getAtPointOrZero(new n(zi[0] / zt.worldSize, zi[1] / zt.worldSize), 0), Qi = (Gi + ar) / 2, qi = (Oi + lr) / 2;
                return Qi > qi ? Oi < lr ? Op(Bt, Si, zi, gi, Oi, ar, Gi, li) : Op(Bt, pi, gi, zi, lr, Gi, ar, li) : Gi < ar ? Op(Bt, gi, Si, pi, Gi, Oi, lr, li) : Op(Bt, zi, pi, Si, ar, lr, Oi, li), Math.max(Qi, qi);
              }(We, r, e.aabb, a, s);
              const lt = rt.mat4.fromQuat([], We), yt = rt.mat4.multiply([], lt, Ne);
              rt.mat4.multiply(a, _e, yt);
            } else Ee = r.elevation.getAtPointOrZero(new n(B.x / ce, B.y / ce), 0);
            Ee !== 0 && (a[14] += Ee);
          }
        }
        function Ud(a, e, r = !1) {
          a.uploaded || (a.gfxTexture = new Nm(e, a.image, r ? e.gl.R8 : e.gl.RGBA8, { useMipmap: a.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST }), a.uploaded = !0, a.image = null);
        }
        function Ib(a, e, r) {
          a.indexBuffer = e.createIndexBuffer(a.indexArray, !1, !0), a.vertexBuffer = e.createVertexBuffer(a.vertexArray, wb.members, !1, !0), a.normalArray && (a.normalBuffer = e.createVertexBuffer(a.normalArray, Cb.members, !1, !0)), a.texcoordArray && (a.texcoordBuffer = e.createVertexBuffer(a.texcoordArray, Tb.members, !1, !0)), a.colorArray && (a.colorBuffer = e.createVertexBuffer(a.colorArray, (a.colorArray.bytesPerElement === 12 ? Sb : Eb).members, !1, !0)), a.featureArray && (a.pbrBuffer = e.createVertexBuffer(a.featureArray, Mb.members, !0)), a.segments = Ea.simpleSegment(0, 0, a.vertexArray.length, a.indexArray.length);
          const s = a.material;
          s.pbrMetallicRoughness.baseColorTexture && Ud(s.pbrMetallicRoughness.baseColorTexture, e), s.pbrMetallicRoughness.metallicRoughnessTexture && Ud(s.pbrMetallicRoughness.metallicRoughnessTexture, e), s.normalTexture && Ud(s.normalTexture, e), s.occlusionTexture && Ud(s.occlusionTexture, e, r), s.emissionTexture && Ud(s.emissionTexture, e);
        }
        function Hm(a, e, r) {
          if (a.meshes) for (const s of a.meshes) Ib(s, e, r);
          if (a.children) for (const s of a.children) Hm(s, e, r);
        }
        function zp(a) {
          if (a.meshes) for (const e of a.meshes) e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();
          if (a.children) for (const e of a.children) zp(e);
        }
        function qm(a) {
          if (a.meshes) for (const r of a.meshes) r.vertexBuffer && (r.vertexBuffer.destroy(), r.indexBuffer.destroy(), r.normalBuffer && r.normalBuffer.destroy(), r.texcoordBuffer && r.texcoordBuffer.destroy(), r.colorBuffer && r.colorBuffer.destroy(), r.pbrBuffer && r.pbrBuffer.destroy(), r.segments.destroy(), r.material && ((e = r.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));
          var e;
          if (a.children) for (const r of a.children) qm(r);
        }
        class rd {
          constructor(e, r, s) {
            this._demTile = e, this._dem = this._demTile.dem, this._scale = r, this._offset = s;
          }
          static create(e, r, s) {
            const h = s || e.findDEMTileFor(r);
            if (!h || !h.dem) return;
            const o = h.dem, f = h.tileID, b = 1 << r.canonical.z - f.canonical.z;
            return new rd(h, o.dim / tr / b, [(r.canonical.x / b - f.canonical.x) * o.dim, (r.canonical.y / b - f.canonical.y) * o.dim]);
          }
          tileCoordToPixel(e, r) {
            const s = r * this._scale + this._offset[1], h = Math.floor(e * this._scale + this._offset[0]), o = Math.floor(s);
            return new At(h, o);
          }
          getElevationAt(e, r, s, h) {
            const o = e * this._scale + this._offset[0], f = r * this._scale + this._offset[1], b = Math.floor(o), O = Math.floor(f), H = this._dem;
            return h = !!h, s ? Tr(Tr(H.get(b, O, h), H.get(b, O + 1, h), f - O), Tr(H.get(b + 1, O, h), H.get(b + 1, O + 1, h), f - O), o - b) : H.get(b, O, h);
          }
          getElevationAtPixel(e, r, s) {
            return this._dem.get(e, r, !!s);
          }
          getMeterToDEM(e) {
            return (1 << this._demTile.tileID.canonical.z) * Zn(1, e) * this._dem.stride;
          }
        }
        const Wm = new Float32Array(262144), Sf = new Uint8Array(262144);
        function Cv(a) {
          let e = 0;
          if (a.meshes) for (const r of a.meshes) e = Math.max(e, r.aabb.max[2]);
          if (a.children) for (const r of a.children) e = Math.max(e, Cv(r));
          return e;
        }
        function Av(a, e, r) {
          if (a.meshes) for (const s of a.meshes) {
            if (s.aabb.min[0] === 1 / 0) continue;
            const h = mr.applyTransform(s.aabb, a.matrix);
            r.insert(e, h.min[0], h.min[1], h.max[0], h.max[1]);
          }
          if (a.children) for (const s of a.children) Av(s, e, r);
        }
        const Mv = ["", "wall", "door", "roof", "window", "lamp", "logo"];
        class Iv {
          constructor(e) {
            this.node = e, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = !1, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = { type: "Point", id: e.id, geometry: [], properties: { height: Cv(e) } }, this.aabb = this._getLocalBounds(), this.state = null;
          }
          _getLocalBounds() {
            if (!this.node.meshes) return new mr([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
            if (!this.aabb) {
              let e = 0;
              const r = new mr([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
              for (const s of this.node.meshes) this.node.lightMeshIndex !== e && (s.transformedAabb = mr.applyTransformFast(s.aabb, this.node.matrix), r.encapsulate(s.transformedAabb)), e++;
              this.aabb = r;
            }
            return this.aabb;
          }
        }
        class Bp {
          constructor(e, r, s, h, o, f, b) {
            this.id = s, this.layers = e, this.layerIds = this.layers.map((O) => O.fqid), this.stateDependentLayerIds = this.layers.filter((O) => O.isStateDependent()).map((O) => O.id), this.modelTraits |= id.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, h && (this.modelTraits |= id.HasMapboxMeshFeatures), o && (this.modelTraits |= id.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = f, this.dirty = !0, this.needsUpload = !1, this.nodesInfo = [];
            for (const O of r) this.nodesInfo.push(new Iv(O)), Av(O, b.featureIndexArray.length, b.grid), b.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, b.bucketLayerIDs.length - 1, 0);
            this.states = {};
          }
          updateFootprints(e, r) {
            for (const s of this.getNodesInfo()) {
              const h = s.node;
              h.footprint && r.push({ footprint: h.footprint, id: e });
            }
          }
          update(e) {
            const r = Object.keys(e).length !== 0;
            if (r && !this.stateDependentLayers.length) return;
            const s = r ? this.stateDependentLayers : this.layers;
            if (!St(e, this.states)) for (const h of s) this.evaluate(h, e);
            this.states = structuredClone(e);
          }
          populate() {
            console.log("populate 3D model bucket");
          }
          uploadPending() {
            return !this.uploaded || this.needsUpload;
          }
          upload(e) {
            if (!this.needsUpload) return;
            const r = this.getNodesInfo();
            for (const s of r) {
              const h = s.node;
              this.uploaded ? this.updatePbrBuffer(h) : Hm(h, e, !0);
            }
            for (const s of r) zp(s.node);
            this.uploaded = !0, this.needsUpload = !1;
          }
          updatePbrBuffer(e) {
            let r = !1;
            if (!e.meshes) return r;
            for (const s of e.meshes) s.pbrBuffer && (s.pbrBuffer.updateData(s.featureArray), r = !0);
            return r;
          }
          needsReEvaluation(e, r, s) {
            const h = e.transform.projectionOptions, o = e.style.getBrightness(), f = this.brightness !== o;
            if (!this.uploaded || this.dirty || h.name !== this.projection.name || Vd(s.paint.get("model-color").value, f) || Vd(s.paint.get("model-color-mix-intensity").value, f) || Vd(s.paint.get("model-roughness").value, f) || Vd(s.paint.get("model-emissive-strength").value, f) || Vd(s.paint.get("model-height-based-emissive-strength-multiplier").value, f)) {
              this.projection = h, this.brightness = o;
              const b = this.getNodesInfo();
              for (const O of b) O.state = null;
              return !0;
            }
            return !1;
          }
          evaluateScale(e, r) {
            if (e.transform.zoom === this.zoom) return;
            this.zoom = e.transform.zoom;
            const s = this.getNodesInfo(), h = this.id.canonical;
            for (const o of s) {
              const f = o.feature;
              o.evaluatedScale = r.paint.get("model-scale").evaluate(f, {}, h);
            }
          }
          evaluate(e, r) {
            const s = this.getNodesInfo();
            for (const h of s) {
              if (!h.node.meshes) continue;
              const o = h.feature, f = r && r[o.id];
              if (St(f, h.state)) continue;
              h.state = structuredClone(f);
              const b = h.node.meshes && h.node.meshes[0].featureData, O = h.evaluatedColor[2], H = h.evaluatedRMEA[2], y = this.id.canonical;
              if (h.hasTranslucentParts = !1, b) {
                for (let B = 0; B < Mv.length; B++) {
                  const G = Mv[B];
                  G.length && (o.properties.part = G);
                  const L = e.paint.get("model-color").evaluate(o, f, y).toRenderColor(null), F = e.paint.get("model-color-mix-intensity").evaluate(o, f, y);
                  h.evaluatedColor[B] = [L.r, L.g, L.b, F], h.evaluatedRMEA[B][0] = e.paint.get("model-roughness").evaluate(o, f, y), h.evaluatedRMEA[B][2] = e.paint.get("model-emissive-strength").evaluate(o, f, y), h.evaluatedRMEA[B][3] = L.a, h.emissionHeightBasedParams[B] = e.paint.get("model-height-based-emissive-strength-multiplier").evaluate(o, f, y), !h.hasTranslucentParts && L.a < 1 && (h.hasTranslucentParts = !0);
                }
                delete o.properties.part, Rb(h, O !== h.evaluatedColor[2] || H !== h.evaluatedRMEA[2], this.modelTraits);
              } else h.evaluatedRMEA[0][2] = e.paint.get("model-emissive-strength").evaluate(o, f, y);
              h.evaluatedScale = e.paint.get("model-scale").evaluate(o, f, y), this.updatePbrBuffer(h.node) || (this.needsUpload = !0);
            }
            this.dirty = !1;
          }
          elevationUpdate(e, r, s, h) {
            const o = e.findDEMTileFor(s);
            if (o && (o.tileID.canonical !== this.terrainTile || r !== this.terrainExaggeration)) {
              if (o.dem && o.tileID.overscaledZ !== this.elevationReadFromZ) {
                this.elevationReadFromZ = o.tileID.overscaledZ;
                const f = rd.create(e, s, o);
                if (!f) return;
                this.modelTraits & id.HasMapboxMeshFeatures && this.updateDEM(e, f, s, h);
                for (const b of this.getNodesInfo()) {
                  const O = b.node;
                  if (!O.footprint || !O.footprint.vertices || !O.footprint.vertices.length) continue;
                  const H = O.footprint.vertices;
                  let y = f.getElevationAt(H[0].x, H[0].y, !0, !0);
                  for (let B = 1; B < H.length; B++) y = Math.min(y, f.getElevationAt(H[B].x, H[B].y, !0, !0));
                  O.elevation = y;
                }
              }
              this.terrainTile = o.tileID.canonical, this.terrainExaggeration = r;
            }
          }
          updateDEM(e, r, s, h) {
            let o = r._dem._modifiedForSources[h];
            if (o === void 0 && (r._dem._modifiedForSources[h] = [], o = r._dem._modifiedForSources[h]), o.includes(s.canonical)) return;
            const f = r._dem.dim;
            o.push(s.canonical);
            let b = !1;
            for (const O of this.getNodesInfo()) {
              const H = O.node;
              if (!H.footprint || !H.footprint.grid) continue;
              const y = H.footprint.grid, B = r.tileCoordToPixel(y.min.x, y.min.y), G = r.tileCoordToPixel(y.max.x, y.max.y), L = Math.min(Math.min(f - G.y, B.x), Math.min(B.y, f - G.x));
              if (L < 0) continue;
              const F = pe(L, 2, 5);
              let Y = Math.max(0, B.x - F), ce = Math.max(0, B.y - F), _e = Math.min(G.x + F, f - 1), ze = Math.min(G.y + F, f - 1);
              for (let lt = ce; lt <= ze; ++lt) for (let yt = Y; yt <= _e; ++yt) Sf[lt * f + yt] = 255;
              let Ne = 0, Ee = 0;
              for (let lt = 0; lt < y.cellsY; ++lt) for (let yt = 0; yt < y.cellsX; ++yt) {
                if (!y.cells[lt * y.cellsX + yt]) continue;
                const Bt = r.tileCoordToPixel(y.min.x + yt / y.xScale, y.min.y + lt / y.yScale), zt = r.tileCoordToPixel(y.min.x + (yt + 1) / y.xScale, y.min.y + (lt + 1) / y.yScale);
                for (let Dt = Bt.y; Dt <= Math.min(zt.y + 1, f - 1); ++Dt) for (let ni = Bt.x; ni <= Math.min(zt.x + 1, f - 1); ++ni) Sf[Dt * f + ni] === 255 && (Sf[Dt * f + ni] = 0, Ne += r.getElevationAtPixel(ni, Dt), Ee++);
              }
              const We = Ne / Ee;
              Y = Math.max(1, B.x - F), ce = Math.max(1, B.y - F), _e = Math.min(G.x + F, f - 2), ze = Math.min(G.y + F, f - 2), b = !0;
              for (let lt = ce; lt <= ze; ++lt) for (let yt = Y; yt <= _e; ++yt) Sf[lt * f + yt] === 0 && (Wm[lt * f + yt] = r._dem.set(yt, lt, We));
              for (let lt = 1; lt < F; ++lt) {
                Y = Math.max(1, B.x - lt), ce = Math.max(1, B.y - lt), _e = Math.min(G.x + lt, f - 2), ze = Math.min(G.y + lt, f - 2);
                for (let yt = ce; yt <= ze; ++yt) for (let Bt = Y; Bt <= _e; ++Bt) {
                  const zt = yt * f + Bt;
                  if (Sf[zt] === 255) {
                    let Dt = 0, ni = 0, Gt = -1, si = -1;
                    for (let ci = -1; ci <= 1; ++ci) for (let li = -1; li <= 1; ++li) {
                      const fi = (yt + ci) * f + Bt + li;
                      if (Sf[fi] >= lt) continue;
                      const gi = Wm[fi], Si = Math.abs(gi);
                      Si > ni && (Dt = gi, ni = Si, Gt = li, si = ci);
                    }
                    if (ni > 0.1) {
                      const ci = 1 - (lt + 0.5 * Math.abs(Gt * si)) / F;
                      let li = r._dem.get(Bt, yt) + Dt * ci;
                      const fi = r._dem.get(Bt + Gt, yt + si), gi = r._dem.get(Bt - Gt, yt - si, !0);
                      (li - fi) * (li - gi) > 0 && (li = (fi + gi) / 2), Wm[zt] = r._dem.set(Bt, yt, li), Sf[zt] = lt;
                    }
                  }
                }
              }
            }
            b && (r._demTile.needsDEMTextureUpload = !0, r._dem._timestamp = Ct.now());
          }
          getNodesInfo() {
            return this.nodesInfo;
          }
          destroy() {
            const e = this.getNodesInfo();
            for (const r of e) zp(r.node), qm(r.node);
          }
          isEmpty() {
            return !this.nodesInfo.length;
          }
          updateReplacement(e, r) {
            if (r.updateTime === this.replacementUpdateTime) return;
            this.replacementUpdateTime = r.updateTime;
            const s = r.getReplacementRegionsForTile(e.toUnwrapped()), h = this.getNodesInfo();
            for (let o = 0; o < this.nodesInfo.length; o++) {
              const f = h[o].node;
              h[o].hiddenByReplacement = !!f.footprint && !s.find((b) => b.footprint === f.footprint);
            }
          }
          getHeightAtTileCoord(e, r) {
            const s = this.getNodesInfo(), h = [], o = [0, 0, 0], f = rt.mat4.identity([]);
            for (let b = 0; b < this.nodesInfo.length; b++) {
              const O = s[b], H = O.node.meshes[0], y = H.transformedAabb;
              if (e < y.min[0] || r < y.min[1] || e > y.max[0] || r > y.max[1]) continue;
              if (O.node.hidden === !0) return { height: 1 / 0, maxHeight: O.feature.properties.height, hidden: !1, verticalScale: O.evaluatedScale[2] };
              rt.mat4.invert(f, O.node.matrix), o[0] = e, o[1] = r, rt.vec3.transformMat4(o, o, f);
              const B = (o[0] - H.aabb.min[0]) / (H.aabb.max[0] - H.aabb.min[0]) * wf | 0, G = Math.min(63, (o[1] - H.aabb.min[1]) / (H.aabb.max[1] - H.aabb.min[1]) * wf | 0) * wf + Math.min(63, B), L = H.heightmap[G];
              if (!(L < 0 && O.node.footprint))
                return O.hiddenByReplacement ? void 0 : { height: L, maxHeight: O.feature.properties.height, hidden: !1, verticalScale: O.evaluatedScale[2] };
              if (O.node.footprint.grid.query(new At(e, r), new At(e, r), h), h.length > 0) return { height: void 0, maxHeight: O.feature.properties.height, hidden: O.hiddenByReplacement, verticalScale: O.evaluatedScale[2] };
            }
          }
        }
        function Vd(a, e) {
          return !a.isLightConstant && e;
        }
        function Pb(a, e, r, s, h, o, f, b) {
          let O = (61440 & e | (61440 & e) >> 4) >> 8, H = (3840 & e | (3840 & e) >> 4) >> 4, y = 240 & e | (240 & e) >> 4;
          r[3] > 0 && (O = Tr(O, 255 * r[0], r[3]), H = Tr(H, 255 * r[1], r[3]), y = Tr(y, 255 * r[2], r[3]));
          const B = O << 8 | H, G = y << 8 | Math.floor(255 * s[3]), L = function(lt) {
            const yt = pe(lt, 0, 2);
            return Math.min(Math.round(0.5 * yt * 255), 255);
          }(s[2]) << 8 | 15 * s[0] << 4 | 15 * s[1], F = pe(h[0], 0, 1), Y = pe(h[1], 0, 1), ce = pe(h[2], 0, 1), _e = pe(h[3], 0, 1);
          let ze, Ne, Ee, We;
          if (F !== Y && f !== o && Y !== F) {
            const lt = f - o;
            Ne = 1 / (lt * (Y - F)), Ee = -(o + lt * F) / (lt * (Y - F));
            const yt = pe(h[4], -1, 1);
            We = Math.pow(10, yt), ze = 255 * ce << 8 | 255 * _e;
          } else ze = 65535, Ne = 0, Ee = 1, We = 1;
          if (a.emplaceBack(B, G, L, ze, Ne, Ee, We), b) {
            const lt = b.length;
            b.clear();
            for (let yt = 0; yt < lt; yt++) b.emplaceBack(B, G, L, ze, Ne, Ee, We);
          }
        }
        function Rb(a, e, r) {
          const s = a.node;
          let h = 0;
          const o = r & id.HasMeshoptCompression;
          for (const f of s.meshes) {
            if (s.lights && s.lightMeshIndex === h || !f.featureData) continue;
            f.featureArray = new ku(), f.featureArray.reserve(f.featureData.length);
            let b = e;
            for (const O of f.featureData) {
              const H = o ? 65535 & O : O >> 16 & 65535, y = o ? O >> 16 & 65535 : 65535 & O, B = (15 & y) < 8 ? 15 & y : 0, G = a.evaluatedRMEA[B], L = a.evaluatedColor[B], F = a.emissionHeightBasedParams[B];
              let Y;
              if (b && B === 2 && s.lights && (Y = new ku(), Y.resize(10 * s.lights.length)), Pb(f.featureArray, H, L, G, F, f.aabb.min[2], f.aabb.max[2], Y), Y && b) {
                b = !1;
                const ce = s.meshes[s.lightMeshIndex];
                ce.featureArray = Y, ce.featureArray._trim();
              }
            }
            f.featureArray._trim(), h++;
          }
        }
        function Pv(a, e, r, s) {
          const h = 1 << a.z;
          e.lat = Pr((s / tr + a.y) / h), e.lng = Qs((r / tr + a.x) / h);
        }
        ur(Bp, "Tiled3dModelBucket", { omit: ["layers"] }), ur(Iv, "Tiled3dModelFeature");
        const kb = { circle: class extends bn {
          constructor(a, e, r, s) {
            super(a, { layout: ji || (ji = new Wn({ "circle-sort-key": new or(Ei.layout_circle["circle-sort-key"]), "circle-elevation-reference": new Ji(Ei.layout_circle["circle-elevation-reference"]), visibility: new Ji(Ei.layout_circle.visibility) })), paint: yi || (yi = new Wn({ "circle-radius": new or(Ei.paint_circle["circle-radius"]), "circle-color": new or(Ei.paint_circle["circle-color"]), "circle-blur": new or(Ei.paint_circle["circle-blur"]), "circle-opacity": new or(Ei.paint_circle["circle-opacity"]), "circle-translate": new Ji(Ei.paint_circle["circle-translate"]), "circle-translate-anchor": new Ji(Ei.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ji(Ei.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ji(Ei.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new or(Ei.paint_circle["circle-stroke-width"]), "circle-stroke-color": new or(Ei.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new or(Ei.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new Ji(Ei.paint_circle["circle-emissive-strength"]), "circle-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "circle-stroke-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, r, s);
          }
          createBucket(a) {
            return new ft(a);
          }
          queryRadius(a) {
            const e = a;
            return Pi("circle-radius", this, e) + Pi("circle-stroke-width", this, e) + Ri(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(a, e, r, s, h, o, f, b) {
            const O = Ai(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), o.angle, a.pixelToTileUnitsFactor), H = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r);
            return rh(a, s, o, f, b, this.paint.get("circle-pitch-alignment") === "map", this.paint.get("circle-pitch-scale") === "map", O, H);
          }
          getProgramIds() {
            return ["circle"];
          }
          getDefaultProgramParams(a, e, r) {
            const s = Sc(this);
            return { config: new Tl(this, { zoom: e, lut: r }), defines: s, overrideFog: !1 };
          }
        }, heatmap: class extends bn {
          createBucket(a) {
            return new op(a);
          }
          constructor(a, e, r, s) {
            super(a, { layout: Nu || (Nu = new Wn({ visibility: new Ji(Ei.layout_heatmap.visibility) })), paint: yf || (yf = new Wn({ "heatmap-radius": new or(Ei.paint_heatmap["heatmap-radius"]), "heatmap-weight": new or(Ei.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ji(Ei.paint_heatmap["heatmap-intensity"]), "heatmap-color": new So(Ei.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ji(Ei.paint_heatmap["heatmap-opacity"]), "heatmap-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, r, s), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(a) {
            a === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Fh({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
          }
          queryRadius(a) {
            return Pi("heatmap-radius", this, a);
          }
          queryIntersectsFeature(a, e, r, s, h, o, f, b) {
            const O = this.paint.get("heatmap-radius").evaluate(e, r);
            return rh(a, s, o, f, b, !0, !0, new At(0, 0), O);
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
          getProgramIds() {
            return ["heatmap", "heatmapTexture"];
          }
          getDefaultProgramParams(a, e, r) {
            return a === "heatmap" ? { config: new Tl(this, { zoom: e, lut: r }), overrideFog: !1 } : {};
          }
        }, hillshade: class extends bn {
          constructor(a, e, r, s) {
            super(a, { layout: Ec || (Ec = new Wn({ visibility: new Ji(Ei.layout_hillshade.visibility) })), paint: xf || (xf = new Wn({ "hillshade-illumination-direction": new Ji(Ei.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Ji(Ei.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ji(Ei.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ji(Ei.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ji(Ei.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ji(Ei.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new Ji(Ei.paint_hillshade["hillshade-emissive-strength"]), "hillshade-shadow-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-highlight-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-accent-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, r, s);
          }
          shouldRedrape() {
            return this.hasOffscreenPass() && this.paint.get("hillshade-illumination-anchor") === "viewport";
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
          getProgramIds() {
            return ["hillshade", "hillshadePrepare"];
          }
          getDefaultProgramParams(a, e, r) {
            return { overrideFog: !1 };
          }
        }, fill: class extends bn {
          constructor(a, e, r, s) {
            super(a, { layout: Vi || (Vi = new Wn({ "fill-sort-key": new or(Ei.layout_fill["fill-sort-key"]), visibility: new Ji(Ei.layout_fill.visibility), "fill-elevation-reference": new Ji(Ei.layout_fill["fill-elevation-reference"]) })), paint: Li || (Li = new Wn({ "fill-antialias": new Ji(Ei.paint_fill["fill-antialias"]), "fill-opacity": new or(Ei.paint_fill["fill-opacity"]), "fill-color": new or(Ei.paint_fill["fill-color"]), "fill-outline-color": new or(Ei.paint_fill["fill-outline-color"]), "fill-translate": new Ji(Ei.paint_fill["fill-translate"]), "fill-translate-anchor": new Ji(Ei.paint_fill["fill-translate-anchor"]), "fill-pattern": new or(Ei.paint_fill["fill-pattern"]), "fill-emissive-strength": new Ji(Ei.paint_fill["fill-emissive-strength"]), "fill-z-offset": new or(Ei.paint_fill["fill-z-offset"]), "fill-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "fill-outline-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, r, s);
          }
          getProgramIds() {
            const a = this.paint.get("fill-pattern"), e = a && a.constantOr(1), r = [e ? "fillPattern" : "fill"];
            return this.paint.get("fill-antialias") && r.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r;
          }
          getDefaultProgramParams(a, e, r) {
            return { config: new Tl(this, { zoom: e, lut: r }), overrideFog: !1 };
          }
          recalculate(a, e) {
            super.recalculate(a, e);
            const r = this.paint._values["fill-outline-color"];
            r.value.kind === "constant" && r.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(a) {
            return new qa(a);
          }
          queryRadius() {
            return Ri(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(a, e, r, s, h, o) {
            return !a.queryGeometry.isAboveHorizon && gt(mi(a.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), o.angle, a.pixelToTileUnitsFactor), s);
          }
          isTileClipped() {
            return !0;
          }
          is3D() {
            return this.paint.get("fill-z-offset").constantOr(1) !== 0;
          }
        }, "fill-extrusion": class extends bn {
          constructor(a, e, r, s) {
            super(a, { layout: r0 || (r0 = new Wn({ visibility: new Ji(Ei["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new Ji(Ei["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) })), paint: n0 || (n0 = new Wn({ "fill-extrusion-opacity": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new or(Ei["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new or(Ei["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new or(Ei["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new or(Ei["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-height-alignment": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-height-alignment"]), "fill-extrusion-base-alignment": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-base-alignment"]), "fill-extrusion-vertical-gradient": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new or(Ei["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new or(Ei["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new or(Ei["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]), "fill-extrusion-line-width": new or(Ei["paint_fill-extrusion"]["fill-extrusion-line-width"]), "fill-extrusion-cast-shadows": new Ji(Ei["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]), "fill-extrusion-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "fill-extrusion-flood-light-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, r, s), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
          }
          createBucket(a) {
            return new pp(a);
          }
          queryRadius() {
            return Ri(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          hasShadowPass() {
            return this.paint.get("fill-extrusion-cast-shadows");
          }
          cutoffRange() {
            return this.paint.get("fill-extrusion-cutoff-fade-range");
          }
          canCastShadows() {
            return !0;
          }
          getProgramIds() {
            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
          }
          queryIntersectsFeature(a, e, r, s, h, o, f, b, O) {
            const H = Ai(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o.angle, a.pixelToTileUnitsFactor), y = this.paint.get("fill-extrusion-height").evaluate(e, r), B = this.paint.get("fill-extrusion-base").evaluate(e, r), G = [0, 0], L = b && o.elevation, F = o.elevation ? o.elevation.exaggeration() : 1, Y = a.tile.getBucket(this);
            if (L && Y instanceof pp) {
              const Ee = Y.centroidVertexArray, We = O + 1;
              We < Ee.length && (G[0] = Ee.geta_centroid_pos0(We), G[1] = Ee.geta_centroid_pos1(We));
            }
            if (G[0] === 0 && G[1] === 1) return !1;
            o.projection.name === "globe" && (s = i0([s], [new At(0, 0), new At(tr, tr)], a.tileID.canonical).map((Ee) => Ee.polygon).flat());
            const ce = L ? b : null, [_e, ze] = function(Ee, We, lt, yt, Bt, zt, Dt, ni, Gt, si, ci) {
              return Ee.projection.name === "globe" ? function(li, fi, gi, Si, pi, zi, Gi, Oi, lr, ar, Qi) {
                const qi = [], xr = [], hr = li.projection.upVectorScale(Qi, li.center.lat, li.worldSize).metersToTile, pr = [0, 0, 0, 1], Ur = [0, 0, 0, 1], Xr = (Kr, sn, cn, Un) => {
                  Kr[0] = sn, Kr[1] = cn, Kr[2] = Un, Kr[3] = 1;
                }, Yr = t0();
                gi > 0 && (gi += Yr), Si += Yr;
                for (const Kr of fi) {
                  const sn = [], cn = [];
                  for (const Un of Kr) {
                    const In = Un.x + pi.x, Gr = Un.y + pi.y, Sn = li.projection.projectTilePoint(In, Gr, Qi), An = li.projection.upVector(Qi, Un.x, Un.y);
                    let Jn = gi, Oa = Si;
                    if (Gi) {
                      const Za = s0(In, Gr, gi, Si, Gi, Oi, lr, ar);
                      Jn += Za.base, Oa += Za.top;
                    }
                    gi !== 0 ? Xr(pr, Sn.x + An[0] * hr * Jn, Sn.y + An[1] * hr * Jn, Sn.z + An[2] * hr * Jn) : Xr(pr, Sn.x, Sn.y, Sn.z), Xr(Ur, Sn.x + An[0] * hr * Oa, Sn.y + An[1] * hr * Oa, Sn.z + An[2] * hr * Oa), rt.vec3.transformMat4(pr, pr, zi), rt.vec3.transformMat4(Ur, Ur, zi), sn.push(new bf(pr[0], pr[1], pr[2])), cn.push(new bf(Ur[0], Ur[1], Ur[2]));
                  }
                  qi.push(sn), xr.push(cn);
                }
                return [qi, xr];
              }(Ee, We, lt, yt, Bt, zt, Dt, ni, Gt, si, ci) : Dt ? function(li, fi, gi, Si, pi, zi, Gi, Oi, lr) {
                const ar = [], Qi = [], qi = [0, 0, 0, 1];
                for (const xr of li) {
                  const hr = [], pr = [];
                  for (const Ur of xr) {
                    const Xr = Ur.x + Si.x, Yr = Ur.y + Si.y, Kr = s0(Xr, Yr, fi, gi, zi, Gi, Oi, lr);
                    qi[0] = Xr, qi[1] = Yr, qi[2] = Kr.base, qi[3] = 1, rt.vec4.transformMat4(qi, qi, pi), qi[3] = Math.max(qi[3], 1e-5);
                    const sn = new bf(qi[0] / qi[3], qi[1] / qi[3], qi[2] / qi[3]);
                    qi[0] = Xr, qi[1] = Yr, qi[2] = Kr.top, qi[3] = 1, rt.vec4.transformMat4(qi, qi, pi), qi[3] = Math.max(qi[3], 1e-5);
                    const cn = new bf(qi[0] / qi[3], qi[1] / qi[3], qi[2] / qi[3]);
                    hr.push(sn), pr.push(cn);
                  }
                  ar.push(hr), Qi.push(pr);
                }
                return [ar, Qi];
              }(We, lt, yt, Bt, zt, Dt, ni, Gt, si) : function(li, fi, gi, Si, pi) {
                const zi = [], Gi = [], Oi = pi[8] * fi, lr = pi[9] * fi, ar = pi[10] * fi, Qi = pi[11] * fi, qi = pi[8] * gi, xr = pi[9] * gi, hr = pi[10] * gi, pr = pi[11] * gi;
                for (const Ur of li) {
                  const Xr = [], Yr = [];
                  for (const Kr of Ur) {
                    const sn = Kr.x + Si.x, cn = Kr.y + Si.y, Un = pi[0] * sn + pi[4] * cn + pi[12], In = pi[1] * sn + pi[5] * cn + pi[13], Gr = pi[2] * sn + pi[6] * cn + pi[14], Sn = pi[3] * sn + pi[7] * cn + pi[15], An = Un + Oi, Jn = In + lr, Oa = Gr + ar, Za = Math.max(Sn + Qi, 1e-5), Da = Un + qi, Ma = In + xr, Fa = Gr + hr, Ja = Math.max(Sn + pr, 1e-5);
                    Xr.push(new bf(An / Za, Jn / Za, Oa / Za)), Yr.push(new bf(Da / Ja, Ma / Ja, Fa / Ja));
                  }
                  zi.push(Xr), Gi.push(Yr);
                }
                return [zi, Gi];
              }(We, lt, yt, Bt, zt);
            }(o, s, B, y, H, f, ce, G, F, o.center.lat, a.tileID.canonical), Ne = a.queryGeometry;
            return function(Ee, We, lt) {
              let yt = 1 / 0;
              gt(lt, We) && (yt = a0(lt, We[0]));
              for (let Bt = 0; Bt < We.length; Bt++) {
                const zt = We[Bt], Dt = Ee[Bt];
                for (let ni = 0; ni < zt.length - 1; ni++) {
                  const Gt = zt[ni], si = [Gt, zt[ni + 1], Dt[ni + 1], Dt[ni], Gt];
                  st(lt, si) && (yt = Math.min(yt, a0(lt, si)));
                }
              }
              return yt !== 1 / 0 && yt;
            }(_e, ze, Ne.isPointQuery() ? Ne.screenBounds : Ne.screenGeometry);
          }
        }, line: class extends bn {
          constructor(a, e, r, s) {
            const h = _0();
            super(a, h, e, r, s), h.layout && (this.layout = new Wl(h.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = !1, this.hasNonElevatedBuckets = !1;
          }
          _handleSpecialPaintPropertyUpdate(a) {
            if (a === "line-gradient") {
              const e = this._transitionablePaint._values["line-gradient"].value.expression;
              this.stepInterpolant = e._styleExpression && e._styleExpression.expression instanceof fu, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          widthExpression() {
            return this._transitionablePaint._values["line-width"].value.expression;
          }
          recalculate(a, e) {
            super.recalculate(a, e), this.paint._values["line-floorwidth"] = (() => {
              if (Md) return Md;
              const r = _0();
              return Md = new Dx(r.paint.properties["line-width"].specification), Md.useIntegerZoom = !0, Md;
            })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, a);
          }
          createBucket(a) {
            return new vm(a);
          }
          getProgramIds() {
            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
          }
          getDefaultProgramParams(a, e, r) {
            const s = p0(this);
            return { config: new Tl(this, { zoom: e, lut: r }), defines: s, overrideFog: !1 };
          }
          queryRadius(a) {
            const e = a, r = g0(Pi("line-width", this, e), Pi("line-gap-width", this, e)), s = Pi("line-offset", this, e);
            return r / 2 + Math.abs(s) + Ri(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(a, e, r, s, h, o) {
            if (a.queryGeometry.isAboveHorizon) return !1;
            const f = mi(a.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o.angle, a.pixelToTileUnitsFactor), b = a.pixelToTileUnitsFactor / 2 * g0(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)), O = this.paint.get("line-offset").evaluate(e, r);
            return O && (s = function(H, y) {
              const B = [], G = new At(0, 0);
              for (let L = 0; L < H.length; L++) {
                const F = H[L], Y = [];
                for (let ce = 0; ce < F.length; ce++) {
                  const _e = F[ce], ze = F[ce + 1], Ne = ce === 0 ? G : _e.sub(F[ce - 1])._unit()._perp(), Ee = ce === F.length - 1 ? G : ze.sub(_e)._unit()._perp(), We = Ne._add(Ee)._unit();
                  We._mult(1 / (We.x * Ee.x + We.y * Ee.y)), Y.push(We._mult(y)._add(_e));
                }
                B.push(Y);
              }
              return B;
            }(s, O * a.pixelToTileUnitsFactor)), function(H, y, B) {
              for (let G = 0; G < y.length; G++) {
                const L = y[G];
                if (H.length >= 3) {
                  for (let F = 0; F < L.length; F++) if (Zt(H, L[F])) return !0;
                }
                if (Rt(H, L, B)) return !0;
              }
              return !1;
            }(f, s, b);
          }
          isTileClipped() {
            return !0;
          }
          isDraped(a) {
            return !this.hasElevatedBuckets;
          }
        }, symbol: Ip, background: class extends bn {
          constructor(a, e, r, s) {
            super(a, { layout: tv || (tv = new Wn({ visibility: new Ji(Ei.layout_background.visibility) })), paint: iv || (iv = new Wn({ "background-pitch-alignment": new Ji(Ei.paint_background["background-pitch-alignment"]), "background-color": new Ji(Ei.paint_background["background-color"]), "background-pattern": new Ji(Ei.paint_background["background-pattern"]), "background-opacity": new Ji(Ei.paint_background["background-opacity"]), "background-emissive-strength": new Ji(Ei.paint_background["background-emissive-strength"]), "background-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, r, s);
          }
          getProgramIds() {
            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
          }
          getDefaultProgramParams(a, e, r) {
            return { overrideFog: !1 };
          }
          is3D() {
            return this.paint.get("background-pitch-alignment") === "viewport";
          }
        }, raster: ov, "raster-particle": dv, sky: class extends bn {
          constructor(a, e, r, s) {
            super(a, { layout: cv || (cv = new Wn({ visibility: new Ji(Ei.layout_sky.visibility) })), paint: hv || (hv = new Wn({ "sky-type": new Ji(Ei.paint_sky["sky-type"]), "sky-atmosphere-sun": new Ji(Ei.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Ji(Ei.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Ji(Ei.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Ji(Ei.paint_sky["sky-gradient-radius"]), "sky-gradient": new So(Ei.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Ji(Ei.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Ji(Ei.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Ji(Ei.paint_sky["sky-opacity"]), "sky-gradient-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-halo-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, r, s), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(a) {
            a === "sky-gradient" ? this._updateColorRamp() : a !== "sky-atmosphere-sun" && a !== "sky-atmosphere-halo-color" && a !== "sky-atmosphere-color" && a !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = !0);
          }
          _updateColorRamp() {
            this.colorRamp = Fh({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
          }
          needsSkyboxCapture(a) {
            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
            if (!this.paint.get("sky-atmosphere-sun")) {
              const e = a.style.light.properties.get("position");
              return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
            }
            return !1;
          }
          getCenter(a, e) {
            if (this.paint.get("sky-type") === "atmosphere") {
              const s = this.paint.get("sky-atmosphere-sun"), h = !s, o = a.style.light, f = o.properties.get("position");
              return h && o.properties.get("anchor") === "viewport" && Se("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), h ? Um(f.azimuthal, 90 - f.polar, e) : Um(s[0], 90 - s[1], e);
            }
            const r = this.paint.get("sky-gradient-center");
            return Um(r[0], 90 - r[1], e);
          }
          isSky() {
            return !0;
          }
          markSkyboxValid(a) {
            this._skyboxInvalidated = !1, this._lightPosition = a.style.light.properties.get("position");
          }
          hasOffscreenPass() {
            return !0;
          }
          getProgramIds() {
            const a = this.paint.get("sky-type");
            return a === "atmosphere" ? ["skyboxCapture", "skybox"] : a === "gradient" ? ["skyboxGradient"] : null;
          }
        }, slot: class extends bn {
          constructor(a, e, r, s) {
            super(a, { paint: fv || (fv = new Wn({})) }, e, null);
          }
        }, model: class extends bn {
          constructor(a, e, r, s) {
            super(a, { layout: Sv || (Sv = new Wn({ visibility: new Ji(Ei.layout_model.visibility), "model-id": new or(Ei.layout_model["model-id"]) })), paint: Ev || (Ev = new Wn({ "model-opacity": new or(Ei.paint_model["model-opacity"]), "model-rotation": new or(Ei.paint_model["model-rotation"]), "model-scale": new or(Ei.paint_model["model-scale"]), "model-translation": new or(Ei.paint_model["model-translation"]), "model-color": new or(Ei.paint_model["model-color"]), "model-color-mix-intensity": new or(Ei.paint_model["model-color-mix-intensity"]), "model-type": new Ji(Ei.paint_model["model-type"]), "model-cast-shadows": new Ji(Ei.paint_model["model-cast-shadows"]), "model-receive-shadows": new Ji(Ei.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new Ji(Ei.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new or(Ei.paint_model["model-emissive-strength"]), "model-roughness": new or(Ei.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new or(Ei.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new Ji(Ei.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new Ji(Ei.paint_model["model-front-cutoff"]), "model-color-use-theme": new or({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, r, s), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
          }
          createBucket(a) {
            return new Gm(a);
          }
          getProgramIds() {
            return ["model"];
          }
          is3D() {
            return !0;
          }
          hasShadowPass() {
            return !0;
          }
          canCastShadows() {
            return !0;
          }
          hasLightBeamPass() {
            return !0;
          }
          cutoffRange() {
            return this.paint.get("model-cutoff-fade-range");
          }
          queryRadius(a) {
            return a instanceof Bp ? tr - 1 : 0;
          }
          queryIntersectsFeature(a, e, r, s, h, o) {
            if (!this.modelManager) return !1;
            const f = this.modelManager, b = a.tile.getBucket(this);
            if (!(b && b instanceof Gm)) return !1;
            for (const O in b.instancesPerModel) {
              const H = b.instancesPerModel[O], y = e.id !== void 0 ? e.id : e.properties && e.properties.hasOwnProperty("id") ? e.properties.id : void 0;
              if (H.idToFeaturesIndex.hasOwnProperty(y)) {
                const B = H.features[H.idToFeaturesIndex[y]], G = f.getModel(O, this.scope);
                if (!G) return !1;
                let L = rt.mat4.create();
                const F = new hn(0, 0), Y = b.canonical;
                let ce = Number.MAX_VALUE;
                for (let _e = 0; _e < B.instancedDataCount; ++_e) {
                  const ze = 16 * (B.instancedDataOffset + _e), Ne = H.instancedDataArray.float32, Ee = [Ne[ze + 4], Ne[ze + 5], Ne[ze + 6]];
                  Pv(Y, F, Ne[ze], 0 | Ne[ze + 1]), Tv(L, G, o, F, B.rotation, B.scale, Ee, !1, !1, !1), o.projection.name === "globe" && (L = jm(L, o));
                  const We = rt.mat4.multiply([], o.projMatrix, L), lt = a.queryGeometry, yt = vv(lt.isPointQuery() ? lt.screenBounds : lt.screenGeometry, o, We, G.aabb);
                  yt != null && (ce = Math.min(yt, ce));
                }
                return ce !== Number.MAX_VALUE && ce;
              }
            }
            return !1;
          }
          _handleOverridablePaintPropertyUpdate(a, e, r) {
            return !(!this.layout || e.isDataDriven() || r.isDataDriven() || a !== "model-color" && a !== "model-color-mix-intensity" && a !== "model-rotation" && a !== "model-scale" && a !== "model-translation" && a !== "model-emissive-strength");
          }
          _isPropertyZoomDependent(a) {
            const e = this._transitionablePaint._values[a];
            return e != null && e.value != null && e.value.expression != null && e.value.expression instanceof bu;
          }
          isZoomDependent() {
            return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
          }
        }, clip: class extends bn {
          constructor(a, e, r, s) {
            super(a, { layout: Wi || (Wi = new Wn({ "clip-layer-types": new Ji(Ei.layout_clip["clip-layer-types"]), "clip-layer-scope": new Ji(Ei.layout_clip["clip-layer-scope"]) })), paint: Cr || (Cr = new Wn({})) }, e, r, s);
          }
          recalculate(a, e) {
            super.recalculate(a, e);
          }
          createBucket(a) {
            return new un(a);
          }
          isTileClipped() {
            return !0;
          }
          is3D() {
            return !0;
          }
        } };
        class Lb {
          constructor(e) {
            this._callback = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._callback();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
              this._triggered = !1, this._callback();
            }, 0));
          }
          remove() {
            this._channel = void 0, this._callback = () => {
            };
          }
        }
        class Ob {
          constructor() {
            this.tasks = {}, this.taskQueue = [], Te(["process"], this), this.invoker = new Lb(this.process), this.nextId = 0;
          }
          add(e, r) {
            const s = this.nextId++, h = function({ type: o, isSymbolTile: f, zoom: b }) {
              return b = b || 0, o === "message" ? 0 : o !== "maybePrepare" || f ? o !== "parseTile" || f ? o === "parseTile" && f ? 300 - b : o === "maybePrepare" && f ? 400 - b : 500 : 200 - b : 100 - b;
            }(r);
            if (h === 0) {
              try {
                e();
              } finally {
              }
              return null;
            }
            return this.tasks[s] = { fn: e, metadata: r, priority: h, id: s }, this.taskQueue.push(s), this.invoker.trigger(), { cancel: () => {
              delete this.tasks[s];
            } };
          }
          process() {
            try {
              if (this.taskQueue = this.taskQueue.filter((s) => !!this.tasks[s]), !this.taskQueue.length) return;
              const e = this.pick();
              if (e === null) return;
              const r = this.tasks[e];
              if (delete this.tasks[e], this.taskQueue.length && this.invoker.trigger(), !r) return;
              r.fn();
            } finally {
            }
          }
          pick() {
            let e = null, r = 1 / 0;
            for (let h = 0; h < this.taskQueue.length; h++) {
              const o = this.tasks[this.taskQueue[h]];
              o.priority < r && (r = o.priority, e = h);
            }
            if (e === null) return null;
            const s = this.taskQueue[e];
            return this.taskQueue.splice(e, 1), s;
          }
          remove() {
            this.invoker.remove();
          }
        }
        class Rv {
          constructor(e, r, s) {
            this.target = e, this.parent = r, this.mapId = s, this.callbacks = {}, this.cancelCallbacks = {}, Te(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.scheduler = new Ob();
          }
          send(e, r, s, h, o = !1, f) {
            const b = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            s && (s.metadata = f, this.callbacks[b] = s);
            const O = /* @__PURE__ */ new Set();
            return this.target.postMessage({ id: b, type: e, hasCallback: !!s, targetMapId: h, mustQueue: o, sourceMapId: this.mapId, data: ws(r, O) }, O), { cancel: () => {
              s && delete this.callbacks[b], this.target.postMessage({ id: b, type: "<cancel>", targetMapId: h, sourceMapId: this.mapId });
            } };
          }
          receive(e) {
            const r = e.data, s = r.id;
            if (s && (!r.targetMapId || this.mapId === r.targetMapId)) if (r.type === "<cancel>") {
              const h = this.cancelCallbacks[s];
              delete this.cancelCallbacks[s], h && h.cancel();
            } else if (r.mustQueue || Ze()) {
              const h = this.callbacks[s], o = this.scheduler.add(() => this.processTask(s, r), h && h.metadata || { type: "message" });
              o && (this.cancelCallbacks[s] = o);
            } else this.processTask(s, r);
          }
          processTask(e, r) {
            if (delete this.cancelCallbacks[e], r.type === "<response>") {
              const s = this.callbacks[e];
              delete this.callbacks[e], s && (r.error ? s(so(r.error)) : s(null, so(r.data)));
            } else {
              const s = /* @__PURE__ */ new Set(), h = r.hasCallback ? (f, b) => {
                this.target.postMessage({ id: e, type: "<response>", sourceMapId: this.mapId, error: f ? ws(f) : null, data: ws(b, s) }, s);
              } : () => {
              }, o = so(r.data);
              if (this.parent[r.type]) this.parent[r.type](r.sourceMapId, o, h);
              else if (this.parent.getWorkerSource) {
                const f = r.type.split(".");
                this.parent.getWorkerSource(r.sourceMapId, f[0], o.source, o.scope)[f[1]](o, h);
              } else h(new Error(`Could not find function ${r.type}`));
            }
          }
          remove() {
            this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
          }
        }
        var jd = { workerUrl: "", workerClass: null, workerParams: void 0 };
        const Zm = "mapboxgl_preloaded_worker_pool";
        class Ef {
          constructor() {
            this.active = {};
          }
          acquire(e, r = Ef.workerCount) {
            if (!this.workers) for (this.workers = []; this.workers.length < r; ) this.workers.push(jd.workerClass != null ? new jd.workerClass() : new self.Worker(jd.workerUrl, jd.workerParams));
            return this.active[e] = !0, this.workers.slice();
          }
          release(e) {
            delete this.active[e], this.workers && this.numActive() === 0 && (this.workers.forEach((r) => {
              r.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[Zm];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        Ef.workerCount = 2;
        class nd {
          constructor(e, r, s = "Worker", h = Ef.workerCount) {
            this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = ne();
            const o = this.workerPool.acquire(this.id, h);
            for (let f = 0; f < o.length; f++) {
              const b = new nd.Actor(o[f], r, this.id);
              b.name = `${s} ${f}`, this.actors.push(b);
            }
            this.ready = !1, this.broadcast("checkIfReady", null, () => {
              this.ready = !0;
            });
          }
          broadcast(e, r, s) {
            _(this.actors, (h, o) => {
              h.send(e, r, o);
            }, s = s || function() {
            });
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            this.actors.forEach((e) => {
              e.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }
        }
        let Gd, $m;
        function Fp() {
          return Gd || (Gd = new Ef()), Gd;
        }
        nd.Actor = Rv;
        const Xm = new Wr(0, 0, 0);
        var Ym = ((a) => (a[a.PATH_RULE_UNSPECIFIED = 0] = "PATH_RULE_UNSPECIFIED", a[a.PATH_RULE_NON_ZERO = 1] = "PATH_RULE_NON_ZERO", a[a.PATH_RULE_EVEN_ODD = 2] = "PATH_RULE_EVEN_ODD", a))(Ym || {}), Np = ((a) => (a[a.LINE_CAP_UNSPECIFIED = 0] = "LINE_CAP_UNSPECIFIED", a[a.LINE_CAP_BUTT = 1] = "LINE_CAP_BUTT", a[a.LINE_CAP_ROUND = 2] = "LINE_CAP_ROUND", a[a.LINE_CAP_SQUARE = 3] = "LINE_CAP_SQUARE", a))(Np || {}), Hd = ((a) => (a[a.LINE_JOIN_UNSPECIFIED = 0] = "LINE_JOIN_UNSPECIFIED", a[a.LINE_JOIN_MITER = 1] = "LINE_JOIN_MITER", a[a.LINE_JOIN_MITER_CLIP = 2] = "LINE_JOIN_MITER_CLIP", a[a.LINE_JOIN_ROUND = 3] = "LINE_JOIN_ROUND", a[a.LINE_JOIN_BEVEL = 4] = "LINE_JOIN_BEVEL", a))(Hd || {}), kv = ((a) => (a[a.PAINT_ORDER_UNSPECIFIED = 0] = "PAINT_ORDER_UNSPECIFIED", a[a.PAINT_ORDER_FILL_AND_STROKE = 1] = "PAINT_ORDER_FILL_AND_STROKE", a[a.PAINT_ORDER_STROKE_AND_FILL = 2] = "PAINT_ORDER_STROKE_AND_FILL", a))(kv || {}), ad = ((a) => (a[a.PATH_COMMAND_UNSPECIFIED = 0] = "PATH_COMMAND_UNSPECIFIED", a[a.PATH_COMMAND_MOVE = 1] = "PATH_COMMAND_MOVE", a[a.PATH_COMMAND_LINE = 2] = "PATH_COMMAND_LINE", a[a.PATH_COMMAND_QUAD = 3] = "PATH_COMMAND_QUAD", a[a.PATH_COMMAND_CUBIC = 4] = "PATH_COMMAND_CUBIC", a[a.PATH_COMMAND_CLOSE = 5] = "PATH_COMMAND_CLOSE", a))(ad || {}), Lv = ((a) => (a[a.MASK_TYPE_UNSPECIFIED = 0] = "MASK_TYPE_UNSPECIFIED", a[a.MASK_TYPE_LUMINANCE = 1] = "MASK_TYPE_LUMINANCE", a[a.MASK_TYPE_ALPHA = 2] = "MASK_TYPE_ALPHA", a))(Lv || {});
        function Db(a, e, r) {
          a === 1 && e.icons.push(function(s, h) {
            return function(o) {
              if (o.usvg_tree.height || (o.usvg_tree.height = o.usvg_tree.width), !o.metadata) return o;
              const { metadata: f } = o;
              if (f.content_area) {
                const { content_area: b } = f;
                b.top == null && (b.top = b.left), b.width == null && (b.width = o.usvg_tree.width), b.height == null && (b.height = b.width);
              }
              return f.stretch_x && f.stretch_x.length && Ov(f, "x"), f.stretch_y && f.stretch_y.length && Ov(f, "y"), o;
            }(s.readFields(zb, { name: void 0 }, h));
          }(r, r.readVarint() + r.pos));
        }
        function Ov(a, e) {
          const r = [], s = a[`stretch_${e}`];
          let h = null;
          for (let o = 0; o < s.length; o++) h === null ? h = r.length === 0 ? s[0] : r[r.length - 1][1] + s[o] : (r.push([h, h + s[o]]), h = null);
          a[`stretch_${e}_areas`] = r;
        }
        function zb(a, e, r) {
          a === 1 ? e.name = r.readString() : a === 2 ? e.metadata = function(s, h) {
            return s.readFields(Bb, { stretch_x: null, stretch_y: null, stretch_x_areas: null, stretch_y_areas: null, variables: [] }, h);
          }(r, r.readVarint() + r.pos) : a === 3 && (e.usvg_tree = function(s, h) {
            return s.readFields(Ub, { width: 20, children: [], linear_gradients: [], radial_gradients: [], clip_paths: [], masks: [] }, h);
          }(r, r.readVarint() + r.pos), e.data = "usvg_tree");
        }
        function Bb(a, e, r) {
          a === 1 ? e.stretch_x = r.readPackedVarint() : a === 2 ? e.stretch_y = r.readPackedVarint() : a === 3 ? e.content_area = function(s, h) {
            return s.readFields(Fb, { left: 0 }, h);
          }(r, r.readVarint() + r.pos) : a === 4 && e.variables.push(function(s, h) {
            return s.readFields(Nb, { name: void 0 }, h);
          }(r, r.readVarint() + r.pos));
        }
        function Fb(a, e, r) {
          a === 1 ? e.left = r.readVarint() : a === 2 ? e.width = r.readVarint() : a === 3 ? e.top = r.readVarint() : a === 4 && (e.height = r.readVarint());
        }
        function Nb(a, e, r) {
          a === 1 ? e.name = r.readString() : a === 2 && (e.rgb_color = jp(r.readVarint()), e.value = "rgb_color");
        }
        function Ub(a, e, r) {
          a === 1 ? e.width = e.height = r.readVarint() : a === 2 ? e.height = r.readVarint() : a === 3 ? e.children.push(Up(r, r.readVarint() + r.pos)) : a === 4 ? e.linear_gradients.push(function(s, h) {
            return s.readFields(Zb, { spread_method: 1, stops: [], x1: 0, y1: 0, x2: 1, y2: 0 }, h);
          }(r, r.readVarint() + r.pos)) : a === 5 ? e.radial_gradients.push(function(s, h) {
            return s.readFields(Xb, { spread_method: 1, stops: [], cx: 0.5, cy: 0.5, r: 0.5, fx: 0.5, fy: 0.5, fr: 0 }, h);
          }(r, r.readVarint() + r.pos)) : a === 7 ? e.clip_paths.push(function(s, h) {
            return s.readFields(Yb, { children: [] }, h);
          }(r, r.readVarint() + r.pos)) : a === 8 && e.masks.push(function(s, h) {
            const o = s.readFields(Kb, { left: 0, width: 20, mask_type: 1, children: [] }, h);
            return o.height == null && (o.height = o.width), o.top == null && (o.top = o.left), o;
          }(r, r.readVarint() + r.pos));
        }
        function Up(a, e) {
          return a.readFields(Vb, {}, e);
        }
        function Vb(a, e, r) {
          a === 1 ? (e.group = function(s, h) {
            return s.readFields(jb, { opacity: 255, children: [] }, h);
          }(r, r.readVarint() + r.pos), e.node = "group") : a === 2 && (e.path = function(s, h) {
            return s.readFields(Hb, { paint_order: 1, commands: [], step: 1, diffs: [], rule: 1 }, h);
          }(r, r.readVarint() + r.pos), e.node = "path");
        }
        function jb(a, e, r) {
          a === 1 ? e.transform = Vp(r, r.readVarint() + r.pos) : a === 2 ? e.opacity = r.readVarint() : a === 5 ? e.clip_path_idx = r.readVarint() : a === 6 ? e.mask_idx = r.readVarint() : a === 7 && e.children.push(Up(r, r.readVarint() + r.pos));
        }
        function Vp(a, e) {
          return a.readFields(Gb, { sx: 1, ky: 0, kx: 0, sy: 1, tx: 0, ty: 0 }, e);
        }
        function Gb(a, e, r) {
          a === 1 ? e.sx = r.readFloat() : a === 2 ? e.ky = r.readFloat() : a === 3 ? e.kx = r.readFloat() : a === 4 ? e.sy = r.readFloat() : a === 5 ? e.tx = r.readFloat() : a === 6 && (e.ty = r.readFloat());
        }
        function Hb(a, e, r) {
          a === 1 ? e.fill = function(s, h) {
            return s.readFields(qb, { rgb_color: Xm, paint: "rgb_color", opacity: 255 }, h);
          }(r, r.readVarint() + r.pos) : a === 2 ? e.stroke = function(s, h) {
            return s.readFields(Wb, { rgb_color: Xm, paint: "rgb_color", dasharray: [], dashoffset: 0, miterlimit: 4, opacity: 255, width: 1, linecap: 1, linejoin: 1 }, h);
          }(r, r.readVarint() + r.pos) : a === 3 ? e.paint_order = r.readVarint() : a === 5 ? r.readPackedVarint(e.commands) : a === 6 ? e.step = r.readFloat() : a === 7 ? r.readPackedSVarint(e.diffs) : a === 8 && (e.rule = r.readVarint());
        }
        function qb(a, e, r) {
          a === 1 ? (e.rgb_color = jp(r.readVarint()), e.paint = "rgb_color") : a === 2 ? (e.linear_gradient_idx = r.readVarint(), e.paint = "linear_gradient_idx") : a === 3 ? (e.radial_gradient_idx = r.readVarint(), e.paint = "radial_gradient_idx") : a === 5 && (e.opacity = r.readVarint());
        }
        function jp(a) {
          return new Wr((a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (255 & a) / 255, 1);
        }
        function Wb(a, e, r) {
          a === 1 ? (e.rgb_color = jp(r.readVarint()), e.paint = "rgb_color") : a === 2 ? (e.linear_gradient_idx = r.readVarint(), e.paint = "linear_gradient_idx") : a === 3 ? (e.radial_gradient_idx = r.readVarint(), e.paint = "radial_gradient_idx") : a === 5 ? r.readPackedFloat(e.dasharray) : a === 6 ? e.dashoffset = r.readFloat() : a === 7 ? e.miterlimit = r.readFloat() : a === 8 ? e.opacity = r.readVarint() : a === 9 ? e.width = r.readFloat() : a === 10 ? e.linecap = r.readVarint() : a === 11 && (e.linejoin = r.readVarint());
        }
        function Zb(a, e, r) {
          a === 1 ? e.transform = Vp(r, r.readVarint() + r.pos) : a === 2 ? e.spread_method = r.readVarint() : a === 3 ? e.stops.push(Dv(r, r.readVarint() + r.pos)) : a === 4 ? e.x1 = r.readFloat() : a === 5 ? e.y1 = r.readFloat() : a === 6 ? e.x2 = r.readFloat() : a === 7 && (e.y2 = r.readFloat());
        }
        function Dv(a, e) {
          return a.readFields($b, { offset: 0, opacity: 255, rgb_color: Xm }, e);
        }
        function $b(a, e, r) {
          a === 1 ? e.offset = r.readFloat() : a === 2 ? e.opacity = r.readVarint() : a === 3 && (e.rgb_color = jp(r.readVarint()));
        }
        function Xb(a, e, r) {
          a === 1 ? e.transform = Vp(r, r.readVarint() + r.pos) : a === 2 ? e.spread_method = r.readVarint() : a === 3 ? e.stops.push(Dv(r, r.readVarint() + r.pos)) : a === 4 ? e.cx = r.readFloat() : a === 5 ? e.cy = r.readFloat() : a === 6 ? e.r = r.readFloat() : a === 7 ? e.fx = r.readFloat() : a === 8 ? e.fy = r.readFloat() : a === 9 && (e.fr = r.readFloat());
        }
        function Yb(a, e, r) {
          a === 1 ? e.transform = Vp(r, r.readVarint() + r.pos) : a === 2 ? e.clip_path_idx = r.readVarint() : a === 3 && e.children.push(Up(r, r.readVarint() + r.pos));
        }
        function Kb(a, e, r) {
          a === 1 ? e.left = e.top = r.readFloat() : a === 2 ? e.width = e.height = r.readFloat() : a === 3 ? e.top = r.readFloat() : a === 4 ? e.height = r.readFloat() : a === 5 ? e.mask_type = r.readVarint() : a === 6 ? e.mask_idx = r.readVarint() : a === 7 && e.children.push(Up(r, r.readVarint() + r.pos));
        }
        class Jb {
          static calculate(e, r) {
            const s = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map();
            if (Object.keys(e).length === 0) return s;
            r.forEach((o) => {
              h.set(o.name, o.rgb_color || new Wr(0, 0, 0));
            });
            for (const [o, f] of Object.entries(e)) h.has(o) ? s.set(h.get(o).toStringPremultipliedAlpha(), f) : console.warn(`Ignoring unknown image variable "${o}"`);
            return s;
          }
        }
        function sd(a, e = 255, r) {
          const s = e / 255, h = a.toStringPremultipliedAlpha(), o = r.has(h) ? r.get(h).clone() : a.clone();
          return o.a = s, o.toString();
        }
        function qd(a, e) {
          if (!tt()) {
            const r = document.createElement("canvas");
            return r.width = a, r.height = e, r;
          }
          return new OffscreenCanvas(a, e);
        }
        function Qb(a, e) {
          const r = Jb.calculate(e.params, a.metadata ? a.metadata.variables : []), s = a.usvg_tree, h = s.width, o = s.height, f = e.transform ? e.transform : new DOMMatrix(), b = Math.max(1, Math.round(h * f.a)), O = Math.max(1, Math.round(o * f.d)), H = new DOMMatrix([b / h, 0, 0, O / o, 0, 0]), y = qd(b, O).getContext("2d");
          return Km(y, H, s, s, r), y.getImageData(0, 0, b, O);
        }
        function Km(a, e, r, s, h) {
          for (const o of s.children) zv(a, e, r, o, h);
        }
        function zv(a, e, r, s, h) {
          s.group ? (a.save(), function(o, f, b, O, H) {
            const y = O.mask_idx != null ? b.masks[O.mask_idx] : null, B = O.clip_path_idx != null ? b.clip_paths[O.clip_path_idx] : null;
            if (O.transform && (f = Gp(O.transform).preMultiplySelf(f)), !function(F, Y, ce) {
              return F.opacity !== 255 || Y || ce;
            }(O, B != null, y != null)) return void Km(o, f, b, O, H);
            const G = qd(o.canvas.width, o.canvas.height), L = G.getContext("2d");
            Km(L, f, b, O, H), B && Gv(L, f, b, B), y && Hv(L, f, b, y, H), o.globalAlpha = O.opacity / 255, o.drawImage(G, 0, 0);
          }(a, e, r, s.group, h), a.restore()) : s.path && (a.save(), function(o, f, b, O, H) {
            const y = qv(O);
            o.setTransform(f), O.paint_order === kv.PAINT_ORDER_FILL_AND_STROKE ? (Bv(o, b, O, y, H), Nv(o, b, O, y, H)) : (Nv(o, b, O, y, H), Bv(o, b, O, y, H));
          }(a, e, r, s.path, h), a.restore());
        }
        function Bv(a, e, r, s, h) {
          const o = r.fill;
          if (!o) return;
          const f = o.opacity / 255;
          switch (o.paint) {
            case "rgb_color":
              a.fillStyle = sd(o.rgb_color, o.opacity, h);
              break;
            case "linear_gradient_idx":
              a.fillStyle = Uv(a, e.linear_gradients[o.linear_gradient_idx], f, h);
              break;
            case "radial_gradient_idx":
              a.fillStyle = Vv(a, e.radial_gradients[o.radial_gradient_idx], f, h);
          }
          a.fill(s, Fv(r));
        }
        function Fv(a) {
          return a.rule === Ym.PATH_RULE_NON_ZERO ? "nonzero" : a.rule === Ym.PATH_RULE_EVEN_ODD ? "evenodd" : void 0;
        }
        function Nv(a, e, r, s, h) {
          const o = r.stroke;
          if (!o) return;
          a.lineWidth = o.width, a.miterLimit = o.miterlimit, a.setLineDash(o.dasharray), a.lineDashOffset = o.dashoffset;
          const f = o.opacity / 255;
          switch (o.paint) {
            case "rgb_color":
              a.strokeStyle = sd(o.rgb_color, o.opacity, h);
              break;
            case "linear_gradient_idx":
              a.strokeStyle = Uv(a, e.linear_gradients[o.linear_gradient_idx], f, h);
              break;
            case "radial_gradient_idx":
              a.strokeStyle = Vv(a, e.radial_gradients[o.radial_gradient_idx], f, h);
          }
          switch (o.linejoin) {
            case Hd.LINE_JOIN_MITER_CLIP:
            case Hd.LINE_JOIN_MITER:
              a.lineJoin = "miter";
              break;
            case Hd.LINE_JOIN_ROUND:
              a.lineJoin = "round";
              break;
            case Hd.LINE_JOIN_BEVEL:
              a.lineJoin = "bevel";
          }
          switch (o.linecap) {
            case Np.LINE_CAP_BUTT:
              a.lineCap = "butt";
              break;
            case Np.LINE_CAP_ROUND:
              a.lineCap = "round";
              break;
            case Np.LINE_CAP_SQUARE:
              a.lineCap = "square";
          }
          a.stroke(s);
        }
        function Uv(a, e, r, s) {
          if (e.stops.length === 1) {
            const G = e.stops[0];
            return sd(G.rgb_color, G.opacity * r, s);
          }
          const h = Gp(e.transform), { x1: o, y1: f, x2: b, y2: O } = e, H = h.transformPoint(new DOMPoint(o, f)), y = h.transformPoint(new DOMPoint(b, O)), B = a.createLinearGradient(H.x, H.y, y.x, y.y);
          for (const G of e.stops) B.addColorStop(G.offset, sd(G.rgb_color, G.opacity * r, s));
          return B;
        }
        function Vv(a, e, r, s) {
          if (e.stops.length === 1) {
            const G = e.stops[0];
            return sd(G.rgb_color, G.opacity * r, s);
          }
          const h = Gp(e.transform), { fx: o, fy: f, cx: b, cy: O } = e, H = h.transformPoint(new DOMPoint(o, f)), y = h.transformPoint(new DOMPoint(b, O)), B = a.createRadialGradient(H.x, H.y, 0, y.x, y.y, e.r * ((h.a + h.d) / 2));
          for (const G of e.stops) B.addColorStop(G.offset, sd(G.rgb_color, G.opacity * r, s));
          return B;
        }
        function jv(a, e, r, s) {
          const h = s.transform ? Gp(s.transform).preMultiplySelf(e) : e, o = qd(a.canvas.width, a.canvas.height), f = o.getContext("2d");
          for (const O of s.children) if (O.group) jv(f, h, r, O.group);
          else if (O.path) {
            const H = O.path, y = new Path2D();
            y.addPath(qv(H), h), f.fill(y, Fv(H));
          }
          const b = s.clip_path_idx != null ? r.clip_paths[s.clip_path_idx] : null;
          b && Gv(f, h, r, b), a.globalCompositeOperation = "source-over", a.drawImage(o, 0, 0);
        }
        function Gv(a, e, r, s) {
          const h = qd(a.canvas.width, a.canvas.height);
          jv(h.getContext("2d"), e, r, s), a.globalCompositeOperation = "destination-in", a.drawImage(h, 0, 0);
        }
        function Hv(a, e, r, s, h) {
          if (s.children.length === 0) return;
          const o = s.mask_idx != null ? r.masks[s.mask_idx] : null;
          o && Hv(a, e, r, o, h);
          const f = a.canvas.width, b = a.canvas.height, O = qd(f, b), H = O.getContext("2d"), y = s.width, B = s.height, G = s.left, L = s.top, F = new Path2D(), Y = new Path2D();
          Y.rect(G, L, y, B), F.addPath(Y, e), H.clip(F);
          for (const ze of s.children) zv(H, e, r, ze, h);
          const ce = H.getImageData(0, 0, f, b), _e = ce.data;
          if (s.mask_type === Lv.MASK_TYPE_LUMINANCE) for (let ze = 0; ze < _e.length; ze += 4) _e[ze + 3] = _e[ze + 3] / 255 * (0.2126 * _e[ze] + 0.7152 * _e[ze + 1] + 0.0722 * _e[ze + 2]);
          H.putImageData(ce, 0, 0), a.globalCompositeOperation = "destination-in", a.drawImage(O, 0, 0);
        }
        function Gp(a) {
          return a ? new DOMMatrix([a.sx, a.ky, a.kx, a.sy, a.tx, a.ty]) : new DOMMatrix();
        }
        function qv(a) {
          const e = new Path2D(), r = a.step;
          let s = a.diffs[0] * r, h = a.diffs[1] * r;
          e.moveTo(s, h);
          for (let o = 0, f = 2; o < a.commands.length; o++) switch (a.commands[o]) {
            case ad.PATH_COMMAND_MOVE:
              s += a.diffs[f++] * r, h += a.diffs[f++] * r, e.moveTo(s, h);
              break;
            case ad.PATH_COMMAND_LINE:
              s += a.diffs[f++] * r, h += a.diffs[f++] * r, e.lineTo(s, h);
              break;
            case ad.PATH_COMMAND_QUAD: {
              const b = s + a.diffs[f++] * r, O = h + a.diffs[f++] * r;
              s = b + a.diffs[f++] * r, h = O + a.diffs[f++] * r, e.quadraticCurveTo(b, O, s, h);
              break;
            }
            case ad.PATH_COMMAND_CUBIC: {
              const b = s + a.diffs[f++] * r, O = h + a.diffs[f++] * r, H = b + a.diffs[f++] * r, y = O + a.diffs[f++] * r;
              s = H + a.diffs[f++] * r, h = y + a.diffs[f++] * r, e.bezierCurveTo(b, O, H, y, s, h);
              break;
            }
            case ad.PATH_COMMAND_CLOSE:
              e.closePath();
          }
          return e;
        }
        class Jm {
          constructor(e) {
            this.capacity = e, this.cache = /* @__PURE__ */ new Map();
          }
          get(e) {
            if (!this.cache.has(e)) return;
            const r = this.cache.get(e);
            return this.cache.delete(e), this.cache.set(e, r), r;
          }
          put(e, r) {
            this.cache.has(e) ? this.cache.delete(e) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(e, r);
          }
          delete(e) {
            this.cache.delete(e);
          }
        }
        class Qm {
          constructor() {
            this.cacheMap = /* @__PURE__ */ new Map(), this.cacheDependenciesMap = /* @__PURE__ */ new Map();
          }
          static _getImage(e) {
            return new ds(e, e.data);
          }
          getFromCache(e, r, s) {
            return this.cacheMap.has(s) || this.cacheMap.set(s, new Jm(150)), this.cacheMap.get(s).get(Os(e.serialize(), r));
          }
          setInCache(e, r, s, h) {
            this.cacheDependenciesMap.has(h) || this.cacheDependenciesMap.set(h, /* @__PURE__ */ new Map()), this.cacheMap.has(h) || this.cacheMap.set(h, new Jm(150));
            const o = this.cacheDependenciesMap.get(h);
            o.get(Os(e.id, s)) || o.set(Os(e.id, s), /* @__PURE__ */ new Set());
            const f = this.cacheMap.get(h), b = e.serialize();
            o.get(Os(e.id, s)).add(b), f.put(Os(e.serialize(), s), r);
          }
          removeImagesFromCacheByIds(e, r, s = "") {
            if (!this.cacheMap.has(s) || !this.cacheDependenciesMap.has(s)) return;
            const h = this.cacheMap.get(s), o = this.cacheDependenciesMap.get(s);
            for (const f of e) if (o.has(Os(f, r))) {
              for (const b of o.get(Os(f, r))) h.delete(b);
              o.delete(Os(f, r));
            }
          }
          rasterize(e, r, s, h, o = Qb) {
            const f = this.getFromCache(e, s, h);
            if (f) return f.clone();
            const b = o(r.icon, e.options), O = Qm._getImage(b);
            return this.setInCache(e, O, s, h), O.clone();
          }
        }
        class Wv {
          constructor(e) {
            this.size = e, this.minimums = [], this.maximums = [], this.leaves = [];
          }
          getElevation(e, r) {
            const s = this.toIdx(e, r);
            return { min: this.minimums[s], max: this.maximums[s] };
          }
          isLeaf(e, r) {
            return this.leaves[this.toIdx(e, r)];
          }
          toIdx(e, r) {
            return r * this.size + e;
          }
        }
        function Zv(a, e, r, s) {
          let h = 0, o = Number.MAX_VALUE;
          for (let f = 0; f < 3; f++) if (Math.abs(s[f]) < 1e-15) {
            if (r[f] < a[f] || r[f] > e[f]) return null;
          } else {
            const b = 1 / s[f];
            let O = (a[f] - r[f]) * b, H = (e[f] - r[f]) * b;
            if (O > H) {
              const y = O;
              O = H, H = y;
            }
            if (O > h && (h = O), H < o && (o = H), h > o) return null;
          }
          return h;
        }
        function $v(a, e, r, s, h, o, f, b, O, H, y) {
          const B = s - a, G = h - e, L = o - r, F = f - a, Y = b - e, ce = O - r, _e = y[1] * ce - y[2] * Y, ze = y[2] * F - y[0] * ce, Ne = y[0] * Y - y[1] * F, Ee = B * _e + G * ze + L * Ne;
          if (Math.abs(Ee) < 1e-15) return null;
          const We = 1 / Ee, lt = H[0] - a, yt = H[1] - e, Bt = H[2] - r, zt = (lt * _e + yt * ze + Bt * Ne) * We;
          if (zt < 0 || zt > 1) return null;
          const Dt = yt * L - Bt * G, ni = Bt * B - lt * L, Gt = lt * G - yt * B, si = (y[0] * Dt + y[1] * ni + y[2] * Gt) * We;
          return si < 0 || zt + si > 1 ? null : (F * Dt + Y * ni + ce * Gt) * We;
        }
        function Xv(a, e, r) {
          return (a - e) / (r - e);
        }
        function Yv(a, e, r, s, h, o, f, b, O) {
          const H = 1 << r, y = o - s, B = f - h, G = (a + 1) / H * y + s, L = (e + 0) / H * B + h, F = (e + 1) / H * B + h;
          b[0] = (a + 0) / H * y + s, b[1] = L, O[0] = G, O[1] = F;
        }
        class Kv {
          constructor(e) {
            if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = e, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;
            const r = function(o) {
              const f = Math.ceil(Math.log2(o.dim / 8)), b = [];
              let O = Math.ceil(Math.pow(2, f));
              const H = 1 / O, y = (L, F, Y, ce, _e) => {
                const ze = ce ? 1 : 0, Ne = (L + 1) * Y - ze, Ee = F * Y, We = (F + 1) * Y - ze;
                _e[0] = L * Y, _e[1] = Ee, _e[2] = Ne, _e[3] = We;
              };
              let B = new Wv(O);
              const G = [];
              for (let L = 0; L < O * O; L++) {
                y(L % O, Math.floor(L / O), H, !1, G);
                const F = qh(G[0], G[1], o), Y = qh(G[2], G[1], o), ce = qh(G[2], G[3], o), _e = qh(G[0], G[3], o);
                B.minimums.push(Math.min(F, Y, ce, _e)), B.maximums.push(Math.max(F, Y, ce, _e)), B.leaves.push(1);
              }
              for (b.push(B), O /= 2; O >= 1; O /= 2) {
                const L = b[b.length - 1];
                B = new Wv(O);
                for (let F = 0; F < O * O; F++) {
                  y(F % O, Math.floor(F / O), 2, !0, G);
                  const Y = L.getElevation(G[0], G[1]), ce = L.getElevation(G[2], G[1]), _e = L.getElevation(G[2], G[3]), ze = L.getElevation(G[0], G[3]), Ne = L.isLeaf(G[0], G[1]), Ee = L.isLeaf(G[2], G[1]), We = L.isLeaf(G[2], G[3]), lt = L.isLeaf(G[0], G[3]), yt = Math.min(Y.min, ce.min, _e.min, ze.min), Bt = Math.max(Y.max, ce.max, _e.max, ze.max), zt = Ne && Ee && We && lt;
                  B.maximums.push(Bt), B.minimums.push(yt), B.leaves.push(Bt - yt <= 5 && zt ? 1 : 0);
                }
                b.push(B);
              }
              return b;
            }(this.dem), s = r.length - 1, h = r[s];
            this._addNode(h.minimums[0], h.maximums[0], h.leaves[0]), this._construct(r, 0, 0, s, 0);
          }
          raycastRoot(e, r, s, h, o, f, b = 1) {
            return Zv([e, r, -100], [s, h, this.maximums[0] * b], o, f);
          }
          raycast(e, r, s, h, o, f, b = 1) {
            if (!this.nodeCount) return null;
            const O = this.raycastRoot(e, r, s, h, o, f, b);
            if (O == null) return null;
            const H = [], y = [], B = [], G = [], L = [{ idx: 0, t: O, nodex: 0, nodey: 0, depth: 0 }];
            for (; L.length > 0; ) {
              const { idx: F, t: Y, nodex: ce, nodey: _e, depth: ze } = L.pop();
              if (this.leaves[F]) {
                Yv(ce, _e, ze, e, r, s, h, B, G);
                const Ee = 1 << ze, We = (ce + 0) / Ee, lt = (ce + 1) / Ee, yt = (_e + 0) / Ee, Bt = (_e + 1) / Ee, zt = qh(We, yt, this.dem) * b, Dt = qh(lt, yt, this.dem) * b, ni = qh(lt, Bt, this.dem) * b, Gt = qh(We, Bt, this.dem) * b, si = $v(B[0], B[1], zt, G[0], B[1], Dt, G[0], G[1], ni, o, f), ci = $v(G[0], G[1], ni, B[0], G[1], Gt, B[0], B[1], zt, o, f), li = Math.min(si !== null ? si : Number.MAX_VALUE, ci !== null ? ci : Number.MAX_VALUE);
                if (li !== Number.MAX_VALUE) return li;
                {
                  const fi = rt.vec3.scaleAndAdd([], o, f, Y);
                  if (Jv(zt, Dt, Gt, ni, Xv(fi[0], B[0], G[0]), Xv(fi[1], B[1], G[1])) >= fi[2]) return Y;
                }
                continue;
              }
              let Ne = 0;
              for (let Ee = 0; Ee < this._siblingOffset.length; Ee++) {
                Yv((ce << 1) + this._siblingOffset[Ee][0], (_e << 1) + this._siblingOffset[Ee][1], ze + 1, e, r, s, h, B, G), B[2] = -100, G[2] = this.maximums[this.childOffsets[F] + Ee] * b;
                const We = Zv(B, G, o, f);
                if (We != null) {
                  const lt = We;
                  H[Ee] = lt;
                  let yt = !1;
                  for (let Bt = 0; Bt < Ne && !yt; Bt++) lt >= H[y[Bt]] && (y.splice(Bt, 0, Ee), yt = !0);
                  yt || (y[Ne] = Ee), Ne++;
                }
              }
              for (let Ee = 0; Ee < Ne; Ee++) {
                const We = y[Ee];
                L.push({ idx: this.childOffsets[F] + We, t: H[We], nodex: (ce << 1) + this._siblingOffset[We][0], nodey: (_e << 1) + this._siblingOffset[We][1], depth: ze + 1 });
              }
            }
            return null;
          }
          _addNode(e, r, s) {
            return this.minimums.push(e), this.maximums.push(r), this.leaves.push(s), this.childOffsets.push(0), this.nodeCount++;
          }
          _construct(e, r, s, h, o) {
            if (e[h].isLeaf(r, s) === 1) return;
            this.childOffsets[o] || (this.childOffsets[o] = this.nodeCount);
            const f = h - 1, b = e[f];
            let O = 0, H = 0;
            for (let y = 0; y < this._siblingOffset.length; y++) {
              const B = 2 * r + this._siblingOffset[y][0], G = 2 * s + this._siblingOffset[y][1], L = b.getElevation(B, G), F = b.isLeaf(B, G), Y = this._addNode(L.min, L.max, F);
              F && (O |= 1 << y), H || (H = Y);
            }
            for (let y = 0; y < this._siblingOffset.length; y++) O & 1 << y || this._construct(e, 2 * r + this._siblingOffset[y][0], 2 * s + this._siblingOffset[y][1], f, H + y);
          }
        }
        function Jv(a, e, r, s, h, o) {
          return Tr(Tr(a, r, o), Tr(e, s, o), h);
        }
        function qh(a, e, r) {
          const s = r.dim, h = pe(a * s - 0.5, 0, s - 1), o = pe(e * s - 0.5, 0, s - 1), f = Math.floor(h), b = Math.floor(o), O = Math.min(f + 1, s - 1), H = Math.min(b + 1, s - 1);
          return Jv(r.get(f, b), r.get(O, b), r.get(f, H), r.get(O, H), h - f, o - b);
        }
        const ew = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
        function tw(a, e, r) {
          return (256 * a * 256 + 256 * e + r) / 10 - 1e4;
        }
        function iw(a, e, r) {
          return 256 * a + e + r / 256 - 32768;
        }
        class Hp {
          get tree() {
            return this._tree || this._buildQuadTree(), this._tree;
          }
          constructor(e, r, s, h = !1) {
            if (this.uid = e, r.height !== r.width) throw new RangeError("DEM tiles must be square");
            if (s && s !== "mapbox" && s !== "terrarium") return void Se(`"${s}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
            this.stride = r.height;
            const o = this.dim = r.height - 2, f = new Uint32Array(r.data.buffer);
            if (this.pixels = new Uint8Array(r.data.buffer), this.floatView = new Float32Array(r.data.buffer), this.borderReady = h, this._modifiedForSources = {}, !h) {
              for (let O = 0; O < o; O++) f[this._idx(-1, O)] = f[this._idx(0, O)], f[this._idx(o, O)] = f[this._idx(o - 1, O)], f[this._idx(O, -1)] = f[this._idx(O, 0)], f[this._idx(O, o)] = f[this._idx(O, o - 1)];
              f[this._idx(-1, -1)] = f[this._idx(0, 0)], f[this._idx(o, -1)] = f[this._idx(o - 1, 0)], f[this._idx(-1, o)] = f[this._idx(0, o - 1)], f[this._idx(o, o)] = f[this._idx(o - 1, o - 1)];
            }
            const b = s === "terrarium" ? iw : tw;
            for (let O = 0; O < f.length; ++O) {
              const H = 4 * O;
              this.floatView[O] = b(this.pixels[H], this.pixels[H + 1], this.pixels[H + 2]);
            }
            this._timestamp = Ct.now();
          }
          _buildQuadTree() {
            this._tree = new Kv(this);
          }
          get(e, r, s = !1) {
            s && (e = pe(e, -1, this.dim), r = pe(r, -1, this.dim));
            const h = this._idx(e, r);
            return this.floatView[h];
          }
          set(e, r, s) {
            const h = this._idx(e, r), o = this.floatView[h];
            return this.floatView[h] = s, s - o;
          }
          static getUnpackVector(e) {
            return ew[e];
          }
          _idx(e, r) {
            if (e < -1 || e >= this.dim + 1 || r < -1 || r >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (r + 1) * this.stride + (e + 1);
          }
          static pack(e, r) {
            const s = [0, 0, 0, 0], h = Hp.getUnpackVector(r);
            let o = Math.floor((e + h[3]) / h[2]);
            return s[2] = o % 256, o = Math.floor(o / 256), s[1] = o % 256, o = Math.floor(o / 256), s[0] = o, s;
          }
          getPixels() {
            return new wd({ width: this.stride, height: this.stride }, this.pixels);
          }
          backfillBorder(e, r, s) {
            if (this.dim !== e.dim) throw new Error("dem dimension mismatch");
            let h = r * this.dim, o = r * this.dim + this.dim, f = s * this.dim, b = s * this.dim + this.dim;
            switch (r) {
              case -1:
                h = o - 1;
                break;
              case 1:
                o = h + 1;
            }
            switch (s) {
              case -1:
                f = b - 1;
                break;
              case 1:
                b = f + 1;
            }
            const O = -r * this.dim, H = -s * this.dim;
            for (let y = f; y < b; y++) for (let B = h; B < o; B++) {
              const G = 4 * this._idx(B, y), L = 4 * this._idx(B + O, y + H);
              this.pixels[G + 0] = e.pixels[L + 0], this.pixels[G + 1] = e.pixels[L + 1], this.pixels[G + 2] = e.pixels[L + 2], this.pixels[G + 3] = e.pixels[L + 3];
            }
          }
          onDeserialize() {
            this._tree && (this._tree.dem = this);
          }
        }
        function rw(a, e, r) {
          a === 1 ? e.headerLength = r.readFixed32() : a === 2 ? e.x = r.readVarint() : a === 3 ? e.y = r.readVarint() : a === 4 ? e.z = r.readVarint() : a === 5 && e.layers.push(function(s, h) {
            return s.readFields(lw, { version: 0, name: "", units: "", tileSize: 0, buffer: 0, pixelFormat: 0, dataIndex: [] }, h);
          }(r, r.readVarint() + r.pos));
        }
        function nw(a, e, r) {
          a === 1 ? (e.delta_filter = function(s, h) {
            return s.readFields(aw, { blockSize: 0 }, h);
          }(r, r.readVarint() + r.pos), e.filter = "delta_filter") : a === 2 ? (r.readVarint(), e.filter = "zigzag_filter") : a === 3 ? (r.readVarint(), e.filter = "bitshuffle_filter") : a === 4 && (r.readVarint(), e.filter = "byteshuffle_filter");
        }
        function aw(a, e, r) {
          a === 1 && (e.blockSize = r.readVarint());
        }
        function sw(a, e, r) {
          a === 1 ? (r.readVarint(), e.codec = "gzip_data") : a === 2 ? (r.readVarint(), e.codec = "jpeg_image") : a === 3 ? (r.readVarint(), e.codec = "webp_image") : a === 4 && (r.readVarint(), e.codec = "png_image");
        }
        function ow(a, e, r) {
          let s = 0, h = 0;
          a === 1 ? e.firstByte = r.readFixed64() : a === 2 ? e.lastByte = r.readFixed64() : a === 3 ? e.filters.push(function(o, f) {
            return o.readFields(nw, {}, f);
          }(r, r.readVarint() + r.pos)) : a === 4 ? e.codec = function(o, f) {
            return o.readFields(sw, {}, f);
          }(r, r.readVarint() + r.pos) : a === 5 ? h = r.readFloat() : a === 6 ? s = r.readFloat() : a === 7 ? e.bands.push(r.readString()) : a === 8 ? e.offset = r.readDouble() : a === 9 && (e.scale = r.readDouble()), e.offset === 0 && (e.offset = h), e.scale === 0 && (e.scale = s);
        }
        function lw(a, e, r) {
          a === 1 ? e.version = r.readVarint() : a === 2 ? e.name = r.readString() : a === 3 ? e.units = r.readString() : a === 4 ? e.tileSize = r.readVarint() : a === 5 ? e.buffer = r.readVarint() : a === 6 ? e.pixelFormat = r.readVarint() : a === 7 && e.dataIndex.push(function(s, h) {
            return s.readFields(ow, { firstByte: 0, lastByte: 0, filters: [], codec: null, offset: 0, scale: 0, bands: [] }, h);
          }(r, r.readVarint() + r.pos));
        }
        function uw(a, e, r) {
          if (a === 2) (function(s, h, o) {
            s.readFields(cw, o, h);
          })(r, r.readVarint() + r.pos, e);
          else if (a === 3) throw new Error("Not implemented");
        }
        function cw(a, e, r) {
          if (a === 1) {
            let s = 0;
            const h = r.readVarint() + r.pos;
            for (; r.pos < h; ) e[s++] = r.readVarint();
          }
        }
        function hw(a, e) {
          if (e.length !== 4) throw new Error(`Expected data of dimension 4 but got ${e.length}.`);
          let r = e[3];
          for (let s = 2; s >= 1; s--) {
            const h = s === 1 ? 1 : 0, o = s === 2 ? 1 : 0;
            for (let f = 0; f < e[0]; f++) {
              const b = e[1] * f;
              for (let O = h; O < e[1]; O++) {
                const H = e[2] * (O + b);
                for (let y = o; y < e[2]; y++) {
                  const B = e[3] * (y + H);
                  for (let G = 0; G < e[3]; G++) {
                    const L = B + G;
                    a[L] += a[L - r];
                  }
                }
              }
            }
            r *= e[s];
          }
          return a;
        }
        function fw(a) {
          for (let e = 0, r = a.length; e < r; e++) a[e] = a[e] >>> 1 ^ -(1 & a[e]);
          return a;
        }
        function dw(a, e) {
          switch (e) {
            case "uint32":
              return a;
            case "uint16":
              for (let r = 0; r < a.length; r += 2) {
                const s = a[r], h = a[r + 1];
                a[r] = (240 & s) >> 4 | (61440 & s) >> 8 | (240 & h) << 4 | 61440 & h, a[r + 1] = 15 & s | (3840 & s) >> 4 | (15 & h) << 8 | (3840 & h) << 4;
              }
              return a;
            case "uint8":
              for (let r = 0; r < a.length; r += 4) {
                const s = a[r], h = a[r + 1], o = a[r + 2], f = a[r + 3];
                a[r + 0] = (192 & s) >> 6 | (192 & h) >> 4 | (192 & o) >> 2 | 192 & f, a[r + 1] = (48 & s) >> 4 | (48 & h) >> 2 | 48 & o | (48 & f) << 2, a[r + 2] = (12 & s) >> 2 | 12 & h | (12 & o) << 2 | (12 & f) << 4, a[r + 3] = 3 & s | (3 & h) << 2 | (3 & o) << 4 | (3 & f) << 6;
              }
              return a;
            default:
              throw new Error(`Invalid pixel format, "${e}"`);
          }
        }
        ur(Hp, "DEMData"), ur(Kv, "DemMinMaxQuadTree", { omit: ["dem"] });
        var Il = Uint8Array, Wd = Uint16Array, pw = Int32Array, Qv = new Il([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), e1 = new Il([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), mw = new Il([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), t1 = function(a, e) {
          for (var r = new Wd(31), s = 0; s < 31; ++s) r[s] = e += 1 << a[s - 1];
          var h = new pw(r[30]);
          for (s = 1; s < 30; ++s) for (var o = r[s]; o < r[s + 1]; ++o) h[o] = o - r[s] << 5 | s;
          return { b: r, r: h };
        }, i1 = t1(Qv, 2), r1 = i1.b, _w = i1.r;
        r1[28] = 258, _w[258] = 28;
        for (var gw = t1(e1, 0).b, n1 = new Wd(32768), Wa = 0; Wa < 32768; ++Wa) {
          var od = (43690 & Wa) >> 1 | (21845 & Wa) << 1;
          n1[Wa] = ((65280 & (od = (61680 & (od = (52428 & od) >> 2 | (13107 & od) << 2)) >> 4 | (3855 & od) << 4)) >> 8 | (255 & od) << 8) >> 1;
        }
        var Zd = function(a, e, r) {
          for (var s = a.length, h = 0, o = new Wd(e); h < s; ++h) a[h] && ++o[a[h] - 1];
          var f, b = new Wd(e);
          for (h = 1; h < e; ++h) b[h] = b[h - 1] + o[h - 1] << 1;
          f = new Wd(1 << e);
          var O = 15 - e;
          for (h = 0; h < s; ++h) if (a[h]) for (var H = h << 4 | a[h], y = e - a[h], B = b[a[h] - 1]++ << y, G = B | (1 << y) - 1; B <= G; ++B) f[n1[B] >> O] = H;
          return f;
        }, $d = new Il(288);
        for (Wa = 0; Wa < 144; ++Wa) $d[Wa] = 8;
        for (Wa = 144; Wa < 256; ++Wa) $d[Wa] = 9;
        for (Wa = 256; Wa < 280; ++Wa) $d[Wa] = 7;
        for (Wa = 280; Wa < 288; ++Wa) $d[Wa] = 8;
        var a1 = new Il(32);
        for (Wa = 0; Wa < 32; ++Wa) a1[Wa] = 5;
        var vw = Zd($d, 9), yw = Zd(a1, 5), e_ = function(a) {
          for (var e = a[0], r = 1; r < a.length; ++r) a[r] > e && (e = a[r]);
          return e;
        }, Gu = function(a, e, r) {
          var s = e / 8 | 0;
          return (a[s] | a[s + 1] << 8) >> (7 & e) & r;
        }, t_ = function(a, e) {
          var r = e / 8 | 0;
          return (a[r] | a[r + 1] << 8 | a[r + 2] << 16) >> (7 & e);
        }, xw = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], Hu = function(a, e, r) {
          var s = new Error(e || xw[a]);
          if (s.code = a, Error.captureStackTrace && Error.captureStackTrace(s, Hu), !r) throw s;
          return s;
        }, bw = new Il(0), ww = typeof TextDecoder < "u" && new TextDecoder();
        try {
          ww.decode(bw, { stream: !0 });
        } catch {
        }
        const Sw = { gzip_data: "gzip" };
        class iu extends Error {
          constructor(e) {
            super(e), this.name = "MRTError";
          }
        }
        const Ew = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, s1 = { uint32: 1, uint16: 2, uint8: 4 }, Tw = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
        let i_;
        class r_ {
          constructor(e = 5) {
            this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = e;
          }
          getLayer(e) {
            const r = this.layers[e];
            if (!r) throw new iu(`Layer '${e}' not found`);
            return r;
          }
          getHeaderLength(e) {
            const r = new Uint8Array(e), s = new DataView(e);
            if (r[0] !== 13) throw new iu("File is not a valid MRT.");
            return s.getUint32(1, !0);
          }
          parseHeader(e) {
            const r = new Uint8Array(e), s = this.getHeaderLength(e);
            if (r.length < s) throw new iu(`Expected header with length >= ${s} but got buffer of length ${r.length}`);
            const h = function(o, f) {
              return o.readFields(rw, { headerLength: 0, x: 0, y: 0, z: 0, layers: [] }, void 0);
            }(new i_(r.subarray(0, s)));
            if (!isNaN(this.x) && (this.x !== h.x || this.y !== h.y || this.z !== h.z)) throw new iu(`Invalid attempt to parse header ${h.z}/${h.x}/${h.y} for tile ${this.z}/${this.x}/${this.y}`);
            this.x = h.x, this.y = h.y, this.z = h.z;
            for (const o of h.layers) this.layers[o.name] = new Cw(o, { cacheSize: this._cacheSize });
            return this;
          }
          createDecodingTask(e) {
            const r = [], s = this.getLayer(e.layerName);
            for (let h of e.blockIndices) {
              const o = s.dataIndex[h], f = o.firstByte - e.firstByte, b = o.lastByte - e.firstByte;
              if (s._blocksInProgress.has(h)) continue;
              const O = { layerName: s.name, firstByte: f, lastByte: b, pixelFormat: s.pixelFormat, blockIndex: h, blockShape: [o.bands.length].concat(s.bandShape), buffer: s.buffer, codec: o.codec.codec, filters: o.filters.map((H) => H.filter) };
              s._blocksInProgress.add(h), r.push(O);
            }
            return new o1(r, () => {
              r.forEach((h) => s._blocksInProgress.delete(h.blockIndex));
            }, (h, o) => {
              if (r.forEach((f) => s._blocksInProgress.delete(f.blockIndex)), h) throw h;
              o.forEach((f) => {
                this.getLayer(f.layerName).processDecodedData(f);
              });
            });
          }
        }
        class Cw {
          constructor({ version: e, name: r, units: s, tileSize: h, pixelFormat: o, buffer: f, dataIndex: b }, O) {
            if (this.version = e, this.version !== 1) throw new iu(`Cannot parse raster layer encoded with MRT version ${e}`);
            this.name = r, this.units = s, this.tileSize = h, this.buffer = f, this.pixelFormat = Ew[o], this.dataIndex = b, this.bandShape = [h + 2 * f, h + 2 * f, s1[this.pixelFormat]], this._decodedBlocks = new Jm(O ? O.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
          }
          get dimension() {
            return s1[this.pixelFormat];
          }
          get cacheSize() {
            return this._decodedBlocks.capacity;
          }
          getBandList() {
            return this.dataIndex.map(({ bands: e }) => e).flat();
          }
          processDecodedData(e) {
            const r = e.blockIndex.toString();
            this._decodedBlocks.get(r) || this._decodedBlocks.put(r, e.data);
          }
          getBlockForBand(e) {
            let r = 0;
            switch (typeof e) {
              case "string":
                for (const [s, h] of this.dataIndex.entries()) {
                  for (const [o, f] of h.bands.entries()) if (f === e) return { bandIndex: r + o, blockIndex: s, blockBandIndex: o };
                  r += h.bands.length;
                }
                break;
              case "number":
                for (const [s, h] of this.dataIndex.entries()) {
                  if (e >= r && e < r + h.bands.length) return { bandIndex: e, blockIndex: s, blockBandIndex: e - r };
                  r += h.bands.length;
                }
                break;
              default:
                throw new iu(`Invalid band \`${JSON.stringify(e)}\`. Expected string or integer.`);
            }
            throw new iu(`Band not found: ${JSON.stringify(e)}`);
          }
          getDataRange(e) {
            let r = 1 / 0, s = -1 / 0;
            const h = [], o = /* @__PURE__ */ new Set();
            for (const f of e) {
              const { blockIndex: b } = this.getBlockForBand(f);
              if (b < 0) throw new iu(`Invalid band: ${JSON.stringify(f)}`);
              const O = this.dataIndex[b];
              h.includes(b) || h.push(b), o.add(b), r = Math.min(r, O.firstByte), s = Math.max(s, O.lastByte);
            }
            if (o.size > this.cacheSize) throw new iu(`Number of blocks to decode (${o.size}) exceeds cache size (${this.cacheSize}).`);
            return { layerName: this.name, firstByte: r, lastByte: s, blockIndices: h };
          }
          hasBand(e) {
            const { blockIndex: r } = this.getBlockForBand(e);
            return r >= 0;
          }
          hasDataForBand(e) {
            const { blockIndex: r } = this.getBlockForBand(e);
            return r >= 0 && !!this._decodedBlocks.get(r.toString());
          }
          getBandView(e) {
            const { blockIndex: r, blockBandIndex: s } = this.getBlockForBand(e), h = this._decodedBlocks.get(r.toString());
            if (!h) throw new iu(`Data for band ${JSON.stringify(e)} of layer "${this.name}" not decoded.`);
            const o = this.dataIndex[r], f = this.bandShape.reduce((H, y) => H * y, 1), b = s * f, O = h.subarray(b, b + f);
            return { data: O, bytes: new Uint8Array(O.buffer).subarray(O.byteOffset, O.byteOffset + O.byteLength), tileSize: this.tileSize, buffer: this.buffer, pixelFormat: this.pixelFormat, dimension: this.dimension, offset: o.offset, scale: o.scale };
          }
        }
        r_.setPbf = function(a) {
          i_ = a;
        };
        class o1 {
          constructor(e, r, s) {
            this.tasks = e, this._onCancel = r, this._onComplete = s, this._finalized = !1;
          }
          cancel() {
            this._finalized || (this._onCancel(), this._finalized = !0);
          }
          complete(e, r) {
            this._finalized || (this._onComplete(e, r), this._finalized = !0);
          }
        }
        r_.performDecoding = function(a, e) {
          const r = new Uint8Array(a);
          return Promise.all(e.tasks.map((s) => {
            const { layerName: h, firstByte: o, lastByte: f, pixelFormat: b, blockShape: O, blockIndex: H, filters: y, codec: B } = s, G = r.subarray(o, f + 1), L = new Uint32Array(O[0] * O[1] * O[2]);
            let F;
            if (B !== "gzip_data") throw new iu(`Unhandled codec: ${B}`);
            return F = function(Y, ce) {
              if (!globalThis.DecompressionStream && ce === "gzip_data") return Promise.resolve(((Ee = function(yt) {
                yt[0] == 31 && yt[1] == 139 && yt[2] == 8 || Hu(6, "invalid gzip data");
                var Bt = yt[3], zt = 10;
                4 & Bt && (zt += 2 + (yt[10] | yt[11] << 8));
                for (var Dt = (Bt >> 3 & 1) + (Bt >> 4 & 1); Dt > 0; Dt -= !yt[zt++]) ;
                return zt + (2 & Bt);
              }(Ne = Y)) + 8 > Ne.length && Hu(6, "invalid gzip data"), function(yt, Bt, zt, Dt) {
                var ni = yt.length;
                if (!ni || Bt.f && !Bt.l) return zt || new Il(0);
                var Gt = !zt, si = Gt || Bt.i != 2, ci = Bt.i;
                Gt && (zt = new Il(3 * ni));
                var li, fi, gi = function(Wh) {
                  var Af = zt.length;
                  if (Wh > Af) {
                    var Jd = new Il(Math.max(2 * Af, Wh));
                    Jd.set(zt), zt = Jd;
                  }
                }, Si = Bt.f || 0, pi = Bt.p || 0, zi = Bt.b || 0, Gi = Bt.l, Oi = Bt.d, lr = Bt.m, ar = Bt.n, Qi = 8 * ni;
                do {
                  if (!Gi) {
                    Si = Gu(yt, pi, 1);
                    var qi = Gu(yt, pi + 1, 3);
                    if (pi += 3, !qi) {
                      var xr = yt[(Gr = 4 + ((pi + 7) / 8 | 0)) - 4] | yt[Gr - 3] << 8, hr = Gr + xr;
                      if (hr > ni) {
                        ci && Hu(0);
                        break;
                      }
                      si && gi(zi + xr), zt.set(yt.subarray(Gr, hr), zi), Bt.b = zi += xr, Bt.p = pi = 8 * hr, Bt.f = Si;
                      continue;
                    }
                    if (qi == 1) Gi = vw, Oi = yw, lr = 9, ar = 5;
                    else if (qi == 2) {
                      var pr = Gu(yt, pi, 31) + 257, Ur = Gu(yt, pi + 10, 15) + 4, Xr = pr + Gu(yt, pi + 5, 31) + 1;
                      pi += 14;
                      for (var Yr = new Il(Xr), Kr = new Il(19), sn = 0; sn < Ur; ++sn) Kr[mw[sn]] = Gu(yt, pi + 3 * sn, 7);
                      pi += 3 * Ur;
                      var cn = e_(Kr), Un = (1 << cn) - 1, In = Zd(Kr, cn);
                      for (sn = 0; sn < Xr; ) {
                        var Gr, Sn = In[Gu(yt, pi, Un)];
                        if (pi += 15 & Sn, (Gr = Sn >> 4) < 16) Yr[sn++] = Gr;
                        else {
                          var An = 0, Jn = 0;
                          for (Gr == 16 ? (Jn = 3 + Gu(yt, pi, 3), pi += 2, An = Yr[sn - 1]) : Gr == 17 ? (Jn = 3 + Gu(yt, pi, 7), pi += 3) : Gr == 18 && (Jn = 11 + Gu(yt, pi, 127), pi += 7); Jn--; ) Yr[sn++] = An;
                        }
                      }
                      var Oa = Yr.subarray(0, pr), Za = Yr.subarray(pr);
                      lr = e_(Oa), ar = e_(Za), Gi = Zd(Oa, lr), Oi = Zd(Za, ar);
                    } else Hu(1);
                    if (pi > Qi) {
                      ci && Hu(0);
                      break;
                    }
                  }
                  si && gi(zi + 131072);
                  for (var Da = (1 << lr) - 1, Ma = (1 << ar) - 1, Fa = pi; ; Fa = pi) {
                    var Ja = (An = Gi[t_(yt, pi) & Da]) >> 4;
                    if ((pi += 15 & An) > Qi) {
                      ci && Hu(0);
                      break;
                    }
                    if (An || Hu(2), Ja < 256) zt[zi++] = Ja;
                    else {
                      if (Ja == 256) {
                        Fa = pi, Gi = null;
                        break;
                      }
                      var Us = Ja - 254;
                      Ja > 264 && (Us = Gu(yt, pi, (1 << (Wu = Qv[sn = Ja - 257])) - 1) + r1[sn], pi += Wu);
                      var Xn = Oi[t_(yt, pi) & Ma], Do = Xn >> 4;
                      if (Xn || Hu(3), pi += 15 & Xn, Za = gw[Do], Do > 3) {
                        var Wu = e1[Do];
                        Za += t_(yt, pi) & (1 << Wu) - 1, pi += Wu;
                      }
                      if (pi > Qi) {
                        ci && Hu(0);
                        break;
                      }
                      si && gi(zi + 131072);
                      var ru = zi + Us;
                      if (zi < Za) {
                        var nu = 0 - Za, Cf = Math.min(Za, ru);
                        for (nu + zi < 0 && Hu(3); zi < Cf; ++zi) zt[zi] = (void 0)[nu + zi];
                      }
                      for (; zi < ru; ++zi) zt[zi] = zt[zi - Za];
                    }
                  }
                  Bt.l = Gi, Bt.p = Fa, Bt.b = zi, Bt.f = Si, Gi && (Si = 1, Bt.m = lr, Bt.d = Oi, Bt.n = ar);
                } while (!Si);
                return zi != zt.length && Gt ? (li = zt, ((fi = zi) == null || fi > li.length) && (fi = li.length), new Il(li.subarray(0, fi))) : zt.subarray(0, zi);
              }(Ne.subarray(Ee, -8), { i: 2 }, new Il(((_e = Ne)[(ze = _e.length) - 4] | _e[ze - 3] << 8 | _e[ze - 2] << 16 | _e[ze - 1] << 24) >>> 0))));
              var _e, ze, Ne, Ee;
              const We = Sw[ce];
              if (!We) throw new Error(`Unhandled codec: ${ce}`);
              const lt = new globalThis.DecompressionStream(We);
              return new Response(new Blob([Y]).stream().pipeThrough(lt)).arrayBuffer().then((yt) => new Uint8Array(yt));
            }(G, B).then((Y) => (function(ce, _e) {
              ce.readFields(uw, _e);
            }(new i_(Y), L), new Tw[b](L.buffer))), F.then((Y) => {
              for (let ce = y.length - 1; ce >= 0; ce--) switch (y[ce]) {
                case "delta_filter":
                  hw(Y, O);
                  break;
                case "zigzag_filter":
                  fw(Y);
                  break;
                case "bitshuffle_filter":
                  dw(Y, b);
                  break;
                default:
                  throw new iu(`Unhandled filter "${y[ce]}"`);
              }
              return { layerName: h, blockIndex: H, data: Y };
            }).catch((Y) => {
              throw Y;
            });
          }));
        }, ur(o1, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] });
        let Xd, n_, qu, ld, a_, ud = null;
        function l1() {
          return Ze() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : n_ || $e.DRACO_URL;
        }
        function u1() {
          if (Ze() && self.worker && self.worker.meshoptUrl) return self.worker.meshoptUrl;
          if (ld) return ld;
          const a = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
          if (typeof WebAssembly != "object") throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
          return ld = WebAssembly.validate(a) ? $e.MESHOPT_SIMD_URL : $e.MESHOPT_URL, ld;
        }
        const qp = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, Aw = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", 5123: "DT_UINT16", 5125: "DT_UINT32", 5126: "DT_FLOAT32" }, Yd = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
        function c1(a, e, r) {
          const s = r.json.bufferViews.length, h = r.buffers.length;
          e.bufferView = s, r.json.bufferViews[s] = { buffer: h, byteLength: a.byteLength }, r.buffers[h] = a;
        }
        const s_ = "KHR_draco_mesh_compression";
        function Mw(a, e) {
          const r = a.extensions && a.extensions[s_];
          if (!r) return;
          const s = new qu.Decoder(), h = p1(e, r.bufferView), o = new qu.Mesh();
          if (!s.DecodeArrayToMesh(h, h.byteLength, o)) throw new Error("Failed to decode Draco mesh");
          const f = e.json.accessors[a.indices], b = qp[f.componentType], O = f.count * b.BYTES_PER_ELEMENT, H = qu._malloc(O);
          b === Uint16Array ? s.GetTrianglesUInt16Array(o, O, H) : s.GetTrianglesUInt32Array(o, O, H), c1(qu.memory.buffer.slice(H, H + O), f, e), qu._free(H);
          for (const y of Object.keys(r.attributes)) {
            const B = s.GetAttributeByUniqueId(o, r.attributes[y]), G = e.json.accessors[a.attributes[y]], L = Aw[G.componentType], F = G.count * Yd[G.type] * qp[G.componentType].BYTES_PER_ELEMENT, Y = qu._malloc(F);
            s.GetAttributeDataArrayForAllPoints(o, B, qu[L], F, Y), c1(qu.memory.buffer.slice(Y, Y + F), G, e), qu._free(Y);
          }
          s.destroy(), o.destroy(), delete a.extensions[s_];
        }
        const Wp = "EXT_meshopt_compression";
        function Iw(a, e) {
          if (!a.extensions || !a.extensions[Wp]) return;
          const r = a.extensions[Wp], s = new Uint8Array(e.buffers[r.buffer], r.byteOffset || 0, r.byteLength || 0), h = new Uint8Array(r.count * r.byteStride);
          a_.decodeGltfBuffer(h, r.count, r.byteStride, s, r.mode, r.filter), a.buffer = e.buffers.length, a.byteOffset = 0, e.buffers[a.buffer] = h.buffer, delete a.extensions[Wp];
        }
        const h1 = 1179937895, f1 = new TextDecoder("utf8");
        function d1(a, e) {
          return new URL(a, e).href;
        }
        function Pw(a, e, r, s) {
          return fetch(d1(a.uri, s)).then((h) => h.arrayBuffer()).then((h) => {
            e.buffers[r] = h;
          });
        }
        function p1(a, e) {
          const r = a.json.bufferViews[e];
          return new Uint8Array(a.buffers[r.buffer], r.byteOffset || 0, r.byteLength);
        }
        function Rw(a, e, r, s) {
          if (a.uri) {
            const h = d1(a.uri, s);
            return fetch(h).then((o) => o.blob()).then((o) => createImageBitmap(o)).then((o) => {
              e.images[r] = o;
            });
          }
          if (a.bufferView !== void 0) {
            const h = p1(e, a.bufferView), o = new Blob([h], { type: a.mimeType });
            return createImageBitmap(o).then((f) => {
              e.images[r] = f;
            });
          }
        }
        function m1(a, e = 0, r) {
          const s = { json: null, images: [], buffers: [] };
          if (new Uint32Array(a, e, 1)[0] === h1) {
            const y = new Uint32Array(a, e);
            let B = 2;
            const G = (y[B++] >> 2) - 3, L = y[B++] >> 2;
            if (B++, s.json = JSON.parse(f1.decode(y.subarray(B, B + L))), B += L, B < G) {
              const F = y[B++];
              B++;
              const Y = e + (B << 2);
              s.buffers[0] = a.slice(Y, Y + F);
            }
          } else s.json = JSON.parse(f1.decode(new Uint8Array(a, e)));
          const { buffers: h, images: o, meshes: f, extensionsUsed: b, bufferViews: O } = s.json;
          let H = Promise.resolve();
          if (h) {
            const y = [];
            for (let B = 0; B < h.length; B++) {
              const G = h[B];
              G.uri ? y.push(Pw(G, s, B, r)) : s.buffers[B] || (s.buffers[B] = null);
            }
            H = Promise.all(y);
          }
          return H.then(() => {
            const y = [], B = b && b.includes(s_), G = b && b.includes(Wp);
            if (B && y.push(function() {
              if (!qu) return Xd ?? (Xd = function(L) {
                let F, Y = null;
                function ce() {
                  F = new Uint8Array(Y.buffer);
                }
                function _e() {
                  throw new Error("Unexpected Draco error.");
                }
                const ze = { a: { a: _e, d: function(Ne, Ee, We) {
                  return F.copyWithin(Ne, Ee, Ee + We);
                }, c: function(Ne) {
                  const Ee = F.length, We = Math.max(Ne >>> 0, Math.ceil(1.2 * Ee)), lt = Math.ceil((We - Ee) / 65536);
                  try {
                    return Y.grow(lt), ce(), !0;
                  } catch {
                    return !1;
                  }
                }, b: _e } };
                return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(L, ze) : L.then((Ne) => Ne.arrayBuffer()).then((Ne) => WebAssembly.instantiate(Ne, ze))).then((Ne) => {
                  const { Rb: Ee, Qb: We, P: lt, T: yt, X: Bt, Ja: zt, La: Dt, Qa: ni, Va: Gt, Wa: si, eb: ci, jb: li, f: fi, e: gi, yb: Si, zb: pi, Ab: zi, Bb: Gi, Db: Oi, Gb: lr } = Ne.instance.exports;
                  Y = gi;
                  const ar = /* @__PURE__ */ (() => {
                    let Qi = 0, qi = 0, xr = 0, hr = 0;
                    return (pr) => {
                      xr && (Ee(hr), Ee(Qi), qi += xr, xr = Qi = 0), Qi || (qi += 128, Qi = We(qi));
                      const Ur = pr.length + 7 & -8;
                      let Xr = Qi;
                      Ur >= qi && (xr = Ur, Xr = hr = We(Ur));
                      for (let Yr = 0; Yr < pr.length; Yr++) F[Xr + Yr] = pr[Yr];
                      return Xr;
                    };
                  })();
                  return ce(), fi(), { memory: gi, _free: Ee, _malloc: We, Mesh: class {
                    constructor() {
                      this.ptr = lt();
                    }
                    destroy() {
                      yt(this.ptr);
                    }
                  }, Decoder: class {
                    constructor() {
                      this.ptr = zt();
                    }
                    destroy() {
                      li(this.ptr);
                    }
                    DecodeArrayToMesh(Qi, qi, xr) {
                      const hr = ar(Qi), pr = Dt(this.ptr, hr, qi, xr.ptr);
                      return !!Bt(pr);
                    }
                    GetAttributeByUniqueId(Qi, qi) {
                      return { ptr: ni(this.ptr, Qi.ptr, qi) };
                    }
                    GetTrianglesUInt16Array(Qi, qi, xr) {
                      Gt(this.ptr, Qi.ptr, qi, xr);
                    }
                    GetTrianglesUInt32Array(Qi, qi, xr) {
                      si(this.ptr, Qi.ptr, qi, xr);
                    }
                    GetAttributeDataArrayForAllPoints(Qi, qi, xr, hr, pr) {
                      ci(this.ptr, Qi.ptr, qi.ptr, xr, hr, pr);
                    }
                  }, DT_INT8: Si(), DT_UINT8: pi(), DT_INT16: zi(), DT_UINT16: Gi(), DT_UINT32: Oi(), DT_FLOAT32: lr() };
                });
              }(fetch(l1())), Xd.then((L) => {
                qu = L, Xd = void 0;
              }));
            }()), G && y.push(function() {
              if (a_) return;
              const L = function(F) {
                let Y;
                const ce = WebAssembly.instantiateStreaming(F, {}).then((Ne) => {
                  Y = Ne.instance, Y.exports.__wasm_call_ctors();
                }), _e = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, ze = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" };
                return { ready: ce, supported: !0, decodeGltfBuffer(Ne, Ee, We, lt, yt, Bt) {
                  (function(zt, Dt, ni, Gt, si, ci, li) {
                    const fi = zt.exports.sbrk, gi = Gt + 3 & -4, Si = fi(gi * si), pi = fi(ci.length), zi = new Uint8Array(zt.exports.memory.buffer);
                    zi.set(ci, pi);
                    const Gi = Dt(Si, Gt, si, pi, ci.length);
                    if (Gi === 0 && li && li(Si, gi, si), ni.set(zi.subarray(Si, Si + Gt * si)), fi(Si - fi(0)), Gi !== 0) throw new Error(`Malformed buffer data: ${Gi}`);
                  })(Y, Y.exports[ze[yt]], Ne, Ee, We, lt, Y.exports[_e[Bt]]);
                } };
              }(fetch(u1()));
              return L.ready.then(() => {
                a_ = L;
              });
            }()), o) for (let L = 0; L < o.length; L++) y.push(Rw(o[L], s, L, r));
            return (y.length ? Promise.all(y) : Promise.resolve()).then(() => {
              if (B && f) for (const { primitives: L } of f) for (const F of L) Mw(F, s);
              if (G && f && O) for (const L of O) Iw(L, s);
              return s;
            });
          });
        }
        function Tf(a, e) {
          const r = a.json.bufferViews[e.bufferView], s = qp[e.componentType];
          return new s(a.buffers[r.buffer], (e.byteOffset || 0) + (r.byteOffset || 0), e.count * (r.byteStride && r.byteStride !== Yd[e.type] * s.BYTES_PER_ELEMENT ? r.byteStride / s.BYTES_PER_ELEMENT : Yd[e.type]));
        }
        function o_(a, e, r, s) {
          const h = qp[e.componentType], o = function(y) {
            switch (y) {
              case Int8Array:
                return 1 / 127;
              case Uint8Array:
                return 1 / 255;
              case Int16Array:
                return 1 / 32767;
              case Uint16Array:
                return 1 / 65535;
              default:
                return 1;
            }
          }(h), f = a.json.bufferViews[e.bufferView], b = f.byteStride ? f.byteStride / h.BYTES_PER_ELEMENT : Yd[e.type], O = r.float32, H = O.length / r.capacity;
          for (let y = 0, B = 0; y < e.count * b; y += b, B += H) for (let G = 0; G < H; G++) O[B + G] = s[y + G] * o;
          r._trim();
        }
        function kw(a, e, r) {
          const s = a.indices, h = a.attributes, o = {};
          o.indexArray = new Ya();
          const f = e.json.accessors[s], b = f.count / 3;
          o.indexArray.reserve(b);
          const O = Tf(e, f);
          for (let G = 0; G < b; G++) o.indexArray.emplaceBack(O[3 * G], O[3 * G + 1], O[3 * G + 2]);
          o.indexArray._trim(), o.vertexArray = new $s();
          const H = e.json.accessors[h.POSITION];
          o.vertexArray.reserve(H.count);
          const y = Tf(e, H);
          for (let G = 0; G < H.count; G++) o.vertexArray.emplaceBack(y[3 * G], y[3 * G + 1], y[3 * G + 2]);
          if (o.vertexArray._trim(), o.aabb = new mr(H.min, H.max), o.centroid = function(G, L) {
            const F = [0, 0, 0], Y = G.length;
            if (Y > 0) {
              for (let ce = 0; ce < Y; ce++) {
                const _e = 3 * G[ce];
                F[0] += L[_e], F[1] += L[_e + 1], F[2] += L[_e + 2];
              }
              F[0] /= Y, F[1] /= Y, F[2] /= Y;
            }
            return F;
          }(O, y), h.COLOR_0 !== void 0) {
            const G = e.json.accessors[h.COLOR_0], L = Yd[G.type], F = Tf(e, G);
            o.colorArray = L === 3 ? new $s() : new wl(), o.colorArray.resize(G.count), o_(e, G, o.colorArray, F);
          }
          if (h.NORMAL !== void 0) {
            o.normalArray = new $s();
            const G = e.json.accessors[h.NORMAL];
            o.normalArray.resize(G.count);
            const L = Tf(e, G);
            o_(e, G, o.normalArray, L);
          }
          if (h.TEXCOORD_0 !== void 0 && r.length > 0) {
            o.texcoordArray = new Ru();
            const G = e.json.accessors[h.TEXCOORD_0];
            o.texcoordArray.resize(G.count);
            const L = Tf(e, G);
            o_(e, G, o.texcoordArray, L);
          }
          if (h._FEATURE_ID_RGBA4444 !== void 0) {
            const G = e.json.accessors[h._FEATURE_ID_RGBA4444];
            e.json.extensionsUsed && e.json.extensionsUsed.includes("EXT_meshopt_compression") && (o.featureData = Tf(e, G));
          }
          h._FEATURE_RGBA4444 !== void 0 && (o.featureData = new Uint32Array(Tf(e, e.json.accessors[h._FEATURE_RGBA4444]).buffer));
          const B = a.material;
          return o.material = function(G, L) {
            const { emissiveFactor: F = [0, 0, 0], alphaMode: Y = "OPAQUE", alphaCutoff: ce = 0.5, normalTexture: _e, occlusionTexture: ze, emissiveTexture: Ne, doubleSided: Ee } = G, { baseColorFactor: We = [1, 1, 1, 1], metallicFactor: lt = 1, roughnessFactor: yt = 1, baseColorTexture: Bt, metallicRoughnessTexture: zt } = G.pbrMetallicRoughness || {}, Dt = ze ? L[ze.index] : void 0;
            if (ze && ze.extensions && ze.extensions.KHR_texture_transform && Dt) {
              const ni = ze.extensions.KHR_texture_transform;
              Dt.offsetScale = [ni.offset[0], ni.offset[1], ni.scale[0], ni.scale[1]];
            }
            return { pbrMetallicRoughness: { baseColorFactor: new Wr(...We), metallicFactor: lt, roughnessFactor: yt, baseColorTexture: Bt ? L[Bt.index] : void 0, metallicRoughnessTexture: zt ? L[zt.index] : void 0 }, doubleSided: Ee, emissiveFactor: F, alphaMode: Y, alphaCutoff: ce, normalTexture: _e ? L[_e.index] : void 0, occlusionTexture: Dt, emissionTexture: Ne ? L[Ne.index] : void 0, defined: G.defined === void 0 };
          }(B !== void 0 ? e.json.materials[B] : { defined: !1 }, r), o;
        }
        function _1(a, e, r) {
          const { matrix: s, rotation: h, translation: o, scale: f, mesh: b, extras: O, children: H } = a, y = {};
          if (y.matrix = s || rt.mat4.fromRotationTranslationScale([], h || [0, 0, 0, 1], o || [0, 0, 0], f || [1, 1, 1]), b !== void 0) {
            y.meshes = r[b];
            const B = y.anchor = [0, 0];
            for (const G of y.meshes) {
              const { min: L, max: F } = G.aabb;
              B[0] += L[0] + F[0], B[1] += L[1] + F[1];
            }
            B[0] = Math.floor(B[0] / y.meshes.length / 2), B[1] = Math.floor(B[1] / y.meshes.length / 2);
          }
          if (O && (O.id && (y.id = O.id), O.lights && (y.lights = function(B) {
            if (!B.length) return [];
            const G = function(_e) {
              const ze = atob(_e), Ne = new Uint8Array(ze.length);
              for (let Ee = 0; Ee < ze.length; Ee++) Ne[Ee] = ze.codePointAt(Ee);
              return Ne;
            }(B), L = [], F = G.length / 24, Y = new Uint16Array(G.buffer), ce = new Float32Array(G.buffer);
            for (let _e = 0; _e < F; _e++) {
              const ze = Y[2 * _e * 6] / 30, Ne = Y[2 * _e * 6 + 1] / 30, Ee = Y[2 * _e * 6 + 10] / 100, We = ce[6 * _e + 1], lt = ce[6 * _e + 2], yt = ce[6 * _e + 3], Bt = ce[6 * _e + 4], zt = yt - We, Dt = Bt - lt, ni = Math.hypot(zt, Dt);
              L.push({ pos: [We + 0.5 * zt, lt + 0.5 * Dt, Ne], normal: [Dt / ni, -zt / ni, 0], width: ni, height: ze, depth: Ee, points: [We, lt, yt, Bt] });
            }
            return L;
          }(O.lights))), H) {
            const B = [];
            for (const G of H) B.push(_1(e.json.nodes[G], e, r));
            y.children = B;
          }
          return y;
        }
        function Lw(a) {
          if (a.vertices.length === 0 || a.indices.length === 0) return null;
          const e = new Zr(a.vertices, a.indices, 8, 256), [r, s] = [e.min.clone(), e.max.clone()];
          return { vertices: a.vertices, indices: a.indices, grid: e, min: r, max: s };
        }
        function Ow(a) {
          if (!a.extras || !a.extras.ground) return null;
          const e = a.extras.ground;
          if (!e || !Array.isArray(e) || e.length === 0) return null;
          const r = e[0];
          if (!r || !Array.isArray(r) || r.length === 0) return null;
          const s = [];
          for (const f of r) {
            if (!Array.isArray(f) || f.length !== 2) continue;
            const b = f[0], O = f[1];
            typeof b == "number" && typeof O == "number" && s.push(new At(b, O));
          }
          if (s.length < 3) return null;
          s.length > 1 && s[s.length - 1].equals(s[0]) && s.pop();
          let h = 0;
          for (let f = 0; f < s.length; f++) {
            const b = s[f], O = s[(f + 1) % s.length], H = s[(f + 2) % s.length];
            h += (b.x - O.x) * (H.y - O.y) - (H.x - O.x) * (b.y - O.y);
          }
          h > 0 && s.reverse();
          const o = Nh(s.flatMap((f) => [f.x, f.y]), []);
          return o.length === 0 ? null : { vertices: s, indices: o };
        }
        function Dw(a, e) {
          const r = [], s = [];
          let h = 0;
          const o = [];
          for (const f of a) {
            h = r.length;
            const b = f.vertexArray.float32, O = f.indexArray.uint16;
            for (let H = 0; H < f.vertexArray.length; H++) o[0] = b[3 * H + 0], o[1] = b[3 * H + 1], o[2] = b[3 * H + 2], rt.vec3.transformMat4(o, o, e), r.push(new At(o[0], o[1]));
            for (let H = 0; H < 3 * f.indexArray.length; H++) s.push(O[H] + h);
          }
          if (s.length % 3 != 0) return null;
          for (let f = 0; f < s.length; f += 3) {
            const b = r[s[f + 0]], O = r[s[f + 1]], H = r[s[f + 2]];
            (b.x - O.x) * (H.y - O.y) - (H.x - O.x) * (b.y - O.y) > 0 && ([s[f + 1], s[f + 2]] = [s[f + 2], s[f + 1]]);
          }
          return { vertices: r, indices: s };
        }
        function g1(a) {
          const e = function(O, H) {
            const y = [], B = WebGL2RenderingContext;
            if (O.json.textures) for (const G of O.json.textures) {
              const L = { magFilter: B.LINEAR, minFilter: B.NEAREST, wrapS: B.REPEAT, wrapT: B.REPEAT };
              G.sampler !== void 0 && Object.assign(L, O.json.samplers[G.sampler]), y.push({ image: H[G.source], sampler: L, uploaded: !1 });
            }
            return y;
          }(a, a.images), r = function(O, H) {
            const y = [];
            for (const B of O.json.meshes) {
              const G = [];
              for (const L of B.primitives) G.push(kw(L, O, H));
              y.push(G);
            }
            return y;
          }(a, e), { scenes: s, scene: h, nodes: o } = a.json, f = s ? s[h || 0].nodes : o, b = [];
          for (const O of f) b.push(_1(o[O], a, r));
          return function(O, H, y) {
            const B = {}, G = /* @__PURE__ */ new Set();
            for (let L = 0; L < O.length; L++) {
              const F = y[H[L]];
              if (!F.extras) continue;
              const Y = F.extras["mapbox:footprint:version"], ce = F.extras["mapbox:footprint:id"];
              (Y || ce) && G.add(L), Y === "1.0.0" && ce && (B[ce] = L);
            }
            for (let L = 0; L < O.length; L++) {
              if (G.has(L)) continue;
              const F = O[L], Y = y[H[L]];
              if (!Y.extras) continue;
              let ce = null;
              F.id in B && (ce = Dw(O[B[F.id]].meshes, F.matrix)), ce || (ce = Ow(Y)), ce && (F.footprint = Lw(ce));
            }
            if (G.size > 0) {
              const L = Array.from(G.values()).sort((F, Y) => F - Y);
              for (let F = L.length - 1; F >= 0; F--) O.splice(L[F], 1);
            }
          }(b, f, a.json.nodes), b;
        }
        function zw(a) {
          a.heightmap = new Float32Array(4096), a.heightmap.fill(-1);
          const e = a.vertexArray.float32, r = a.aabb.min[0] - 1, s = a.aabb.min[1] - 1, h = wf / (a.aabb.max[0] - r + 2), o = wf / (a.aabb.max[1] - s + 2);
          for (let f = 0; f < e.length; f += 3) {
            const b = e[f + 2], O = (e[f + 0] - r) * h | 0, H = (e[f + 1] - s) * o | 0;
            b > a.heightmap[H * wf + O] && (a.heightmap[H * wf + O] = b);
          }
        }
        function Bw(a, e) {
          const r = {};
          r.indexArray = new Ya(), r.indexArray.reserve(4 * a.length), r.vertexArray = new $s(), r.vertexArray.reserve(10 * a.length), r.colorArray = new wl(), r.vertexArray.reserve(10 * a.length);
          let s = 0;
          for (const f of a) {
            const b = Math.min(10, Math.max(4, 1.3 * f.height)) * e, O = [-f.normal[1], f.normal[0], 0], H = Math.min(0.29, 0.1 * f.width / f.depth), y = f.width - 2 * f.depth * e * (H + 0.01), B = rt.vec3.scaleAndAdd([], f.pos, O, y / 2), G = rt.vec3.scaleAndAdd([], f.pos, O, -y / 2), L = [B[0], B[1], B[2] + f.height], F = [G[0], G[1], G[2] + f.height], Y = rt.vec3.scaleAndAdd([], f.normal, O, H);
            rt.vec3.scale(Y, Y, b);
            const ce = rt.vec3.scaleAndAdd([], f.normal, O, -H);
            rt.vec3.scale(ce, ce, b), rt.vec3.add(Y, B, Y), rt.vec3.add(ce, G, ce), B[2] += 0.1, G[2] += 0.1, r.vertexArray.emplaceBack(Y[0], Y[1], Y[2]), r.vertexArray.emplaceBack(ce[0], ce[1], ce[2]), r.vertexArray.emplaceBack(B[0], B[1], B[2]), r.vertexArray.emplaceBack(G[0], G[1], G[2]), r.vertexArray.emplaceBack(L[0], L[1], L[2]), r.vertexArray.emplaceBack(F[0], F[1], F[2]), r.vertexArray.emplaceBack(B[0], B[1], B[2]), r.vertexArray.emplaceBack(G[0], G[1], G[2]), r.vertexArray.emplaceBack(Y[0], Y[1], Y[2]), r.vertexArray.emplaceBack(ce[0], ce[1], ce[2]);
            const _e = y / b / 2;
            r.colorArray.emplaceBack(-_e - H, -1, _e, 0.8), r.colorArray.emplaceBack(_e + H, -1, _e, 0.8), r.colorArray.emplaceBack(-_e, 0, _e, 1.3), r.colorArray.emplaceBack(_e, 0, _e, 1.3), r.colorArray.emplaceBack(_e + H, -0.8, _e, 0.7), r.colorArray.emplaceBack(_e + H, -0.8, _e, 0.7), r.colorArray.emplaceBack(0, 0, _e, 1.3), r.colorArray.emplaceBack(0, 0, _e, 1.3), r.colorArray.emplaceBack(_e + H, -1.2, _e, 0.8), r.colorArray.emplaceBack(_e + H, -1.2, _e, 0.8), r.indexArray.emplaceBack(6 + s, 4 + s, 8 + s), r.indexArray.emplaceBack(7 + s, 9 + s, 5 + s), r.indexArray.emplaceBack(0 + s, 1 + s, 2 + s), r.indexArray.emplaceBack(1 + s, 3 + s, 2 + s), s += 10;
          }
          const h = { defined: !0, emissiveFactor: [0, 0, 0] }, o = {};
          return o.baseColorFactor = Wr.white, h.pbrMetallicRoughness = o, r.material = h, r.aabb = new mr([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), r;
        }
        class v1 {
          constructor(e) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let r = 0; r < e.length; r++) {
              const s = e[r];
              this._stringToNumber[s] = r, this._numberToString[r] = s;
            }
          }
          encode(e) {
            return this._stringToNumber[e];
          }
          decode(e) {
            return this._numberToString[e];
          }
        }
        const Fw = ["id", "tile", "layer", "source", "sourceLayer", "state"];
        class cd {
          constructor(e, r, s, h, o) {
            this.type = "Feature", this._vectorTileFeature = e, this._z = r, this._x = s, this._y = h, this.properties = e.properties, this.id = o;
          }
          clone() {
            const e = new cd(this._vectorTileFeature, this._z, this._x, this._y, this.id);
            return this.state && (e.state = Object.assign({}, this.state)), this.layer && (e.layer = Object.assign({}, this.layer)), this.source && (e.source = this.source), this.sourceLayer && (e.sourceLayer = this.sourceLayer), e;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
          }
          set geometry(e) {
            this._geometry = e;
          }
          toJSON() {
            const e = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
            for (const r of Fw) this[r] !== void 0 && (e[r] = this[r]);
            return e;
          }
        }
        class y1 {
          constructor(e, r) {
            this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new Xo(tr, 16, 0), this.featureIndexArray = new Kc(), this.promoteId = r, this.is3DTile = !1, this.serializedLayersCache = /* @__PURE__ */ new Map();
          }
          insert(e, r, s, h, o, f = 0, b = 0) {
            const O = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(s, h, o, f);
            const H = this.grid;
            for (let y = 0; y < r.length; y++) {
              const B = r[y], G = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let L = 0; L < B.length; L++) {
                const F = B[L];
                G[0] = Math.min(G[0], F.x), G[1] = Math.min(G[1], F.y), G[2] = Math.max(G[2], F.x), G[3] = Math.max(G[3], F.y);
              }
              b !== 0 && (G[0] -= b, G[1] -= b, G[2] += b, G[3] += b), G[0] < tr && G[1] < tr && G[2] >= 0 && G[3] >= 0 && H.insert(O, G[0], G[1], G[2], G[3]);
            }
          }
          loadVTLayers() {
            if (!this.vtLayers) {
              this.vtLayers = new Yf.VectorTile(new _p(this.rawTileData)).layers, this.sourceLayerCoder = new v1(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
              for (const e in this.vtLayers) this.vtFeatures[e] = [];
            }
            return this.vtLayers;
          }
          query(e, r) {
            const { tilespaceGeometry: s, transform: h, tileTransform: o, pixelPosMatrix: f, availableImages: b } = r;
            this.loadVTLayers(), this.serializedLayersCache.clear();
            const O = s.bufferedTilespaceBounds, H = this.grid.query(O.min.x, O.min.y, O.max.x, O.max.y, (L, F, Y, ce) => Jt(s.bufferedTilespaceGeometry, L, F, Y, ce));
            H.sort(Nw);
            let y = null;
            h.elevation && H.length > 0 && (y = rd.create(h.elevation, this.tileID));
            const B = {};
            let G;
            for (let L = 0; L < H.length; L++) {
              const F = H[L];
              if (F === G) continue;
              G = F;
              const Y = this.featureIndexArray.get(F);
              let ce = null;
              this.is3DTile ? this.loadMatchingModelFeature(B, Y, e, s, h) : this.loadMatchingFeature(B, Y, e, b, (_e, ze, Ne, Ee = 0) => (ce || (ce = oe(_e, this.tileID.canonical, o)), ze.queryIntersectsFeature(s, _e, Ne, ce, this.z, h, f, y, Ee)));
            }
            return B;
          }
          loadMatchingFeature(e, r, s, h, o) {
            const { featureIndex: f, bucketIndex: b, sourceLayerIndex: O, layoutVertexArrayOffset: H } = r, y = this.bucketLayerIDs[b], B = s.layers, G = Object.keys(B);
            if (G.length && !function(_e, ze) {
              for (let Ne = 0; Ne < _e.length; Ne++) if (ze.indexOf(_e[Ne]) >= 0) return !0;
              return !1;
            }(G, y)) return;
            const L = s.sourceCache, F = this.sourceLayerCoder.decode(O), Y = this.vtLayers[F].feature(f), ce = this.getId(Y, F);
            for (let _e = 0; _e < y.length; _e++) {
              const ze = y[_e];
              if (!B[ze]) continue;
              const { styleLayer: Ne, targets: Ee } = B[ze];
              let We = {};
              ce !== void 0 && (We = L.getFeatureState(Ne.sourceLayer, ce));
              const lt = !o || o(Y, Ne, We, H);
              if (!lt) continue;
              const yt = new cd(Y, this.z, this.x, this.y, ce);
              yt.tile = this.tileID.canonical, yt.state = We;
              let Bt = this.serializedLayersCache.get(ze);
              Bt || (Bt = Ne.serialize(), Bt.id = ze, this.serializedLayersCache.set(ze, Bt)), yt.source = Bt.source, yt.sourceLayer = Bt["source-layer"], yt.layer = I({}, Bt), yt.layer.paint = x1(Bt.paint, Ne.paint, Y, We, h), yt.layer.layout = x1(Bt.layout, Ne.layout, Y, We, h);
              let zt = !1;
              for (const Dt of Ee) {
                this.updateFeatureProperties(yt, Dt);
                const { filter: ni } = Dt;
                if (ni) {
                  if (Y.properties = yt.properties, ni.needGeometry) {
                    const Gt = ve(Y, !0);
                    if (!ni.filter(new Tn(this.tileID.overscaledZ), Gt, this.tileID.canonical)) continue;
                  } else if (!ni.filter(new Tn(this.tileID.overscaledZ), Y)) continue;
                }
                zt = !0, Dt.targetId && this.addFeatureVariant(yt, Dt);
              }
              zt && this.appendToResult(e, ze, f, yt, lt);
            }
          }
          loadMatchingModelFeature(e, r, s, h, o) {
            const f = this.bucketLayerIDs[0][0], b = s.layers;
            if (!b[f]) return;
            const { styleLayer: O, targets: H } = b[f];
            if (O.type !== "model") return;
            const y = h.tile, B = r.featureIndex, G = y.getBucket(O);
            if (!(G && G instanceof Bp)) return;
            const L = function(Bt, zt, Dt, ni) {
              const Gt = Bt.getNodesInfo()[zt];
              if (Gt.hiddenByReplacement || !Gt.node.meshes) return;
              let si = Number.MAX_VALUE;
              const ci = Gt.node, li = Dt.tile, fi = ni.calculatePosMatrix(li.tileID.toUnwrapped(), ni.worldSize), gi = Gt.evaluatedScale;
              let Si = 0;
              ni.elevation && ci.elevation && (Si = ci.elevation * ni.elevation.exaggeration()), rt.mat4.translate(fi, fi, [(ci.anchor ? ci.anchor[0] : 0) * (gi[0] - 1), (ci.anchor ? ci.anchor[1] : 0) * (gi[1] - 1), Si]), rt.mat4.scale(fi, fi, gi);
              const pi = Dt.queryGeometry, zi = pi.isPointQuery() ? pi.screenBounds : pi.screenGeometry, Gi = function(lr) {
                const ar = rt.mat4.multiply([], fi, lr.matrix);
                rt.mat4.multiply(ar, ni.expandedFarZProjMatrix, ar);
                for (let Qi = 0; Qi < lr.meshes.length; ++Qi) {
                  const qi = lr.meshes[Qi];
                  if (Qi === lr.lightMeshIndex) continue;
                  const xr = vv(zi, ni, ar, qi.aabb);
                  xr != null && (si = Math.min(xr, si));
                }
                if (lr.children) for (const Qi of lr.children) Gi(Qi);
              };
              if (Gi(ci), si === Number.MAX_VALUE) return;
              const Oi = new hn(0, 0);
              return Pv(li.tileID.canonical, Oi, Gt.node.anchor[0], Gt.node.anchor[1]), { intersectionZ: si, position: Oi, feature: Gt.feature };
            }(G, B, h, o);
            if (!L) return;
            const { z: F, x: Y, y: ce } = y.tileID.canonical, { feature: _e, intersectionZ: ze, position: Ne } = L;
            let Ee = {};
            _e.id !== void 0 && (Ee = s.sourceCache.getFeatureState(O.sourceLayer, _e.id));
            const We = new cd({}, F, Y, ce, _e.id);
            We.tile = this.tileID.canonical, We.state = Ee, We.properties = _e.properties, We.geometry = { type: "Point", coordinates: [Ne.lng, Ne.lat] };
            let lt = this.serializedLayersCache.get(f);
            lt || (lt = O.serialize(), lt.id = f, this.serializedLayersCache.set(f, lt)), We.source = lt.source, We.sourceLayer = lt["source-layer"], We.layer = I({}, lt);
            let yt = !1;
            for (const Bt of H) {
              this.updateFeatureProperties(We, Bt);
              const { filter: zt } = Bt;
              if (zt) {
                if (_e.properties = We.properties, zt.needGeometry) {
                  if (!zt.filter(new Tn(this.tileID.overscaledZ), _e, this.tileID.canonical)) continue;
                } else if (!zt.filter(new Tn(this.tileID.overscaledZ), _e)) continue;
              }
              yt = !0, Bt.targetId && this.addFeatureVariant(We, Bt);
            }
            yt && this.appendToResult(e, f, B, We, ze);
          }
          updateFeatureProperties(e, r, s) {
            if (r.properties) {
              const h = {};
              for (const o in r.properties) {
                const f = r.properties[o].evaluate({ zoom: this.z }, e._vectorTileFeature, e.state, e.tile, s);
                f != null && (h[o] = f);
              }
              e.properties = h;
            }
          }
          addFeatureVariant(e, r, s) {
            const h = { target: r.target, namespace: r.namespace, uniqueFeatureID: r.uniqueFeatureID };
            r.properties && (h.properties = e.properties), e.variants = e.variants || {}, e.variants[r.targetId] = e.variants[r.targetId] || [], e.variants[r.targetId].push(h);
          }
          appendToResult(e, r, s, h, o) {
            let f = e[r];
            f === void 0 && (f = e[r] = []), f.push({ featureIndex: s, feature: h, intersectionZ: o });
          }
          lookupSymbolFeatures(e, r, s, h, o) {
            const f = {};
            this.loadVTLayers();
            for (const b of e) this.loadMatchingFeature(f, { bucketIndex: r, sourceLayerIndex: s, featureIndex: b, layoutVertexArrayOffset: 0 }, h, o);
            return f;
          }
          loadFeature(e) {
            const { featureIndex: r, sourceLayerIndex: s } = e;
            this.loadVTLayers();
            const h = this.sourceLayerCoder.decode(s), o = this.vtFeatures[h];
            if (o[r]) return o[r];
            const f = this.vtLayers[h].feature(r);
            return o[r] = f, f;
          }
          hasLayer(e) {
            for (const r of this.bucketLayerIDs) for (const s of r) if (e === s) return !0;
            return !1;
          }
          getId(e, r) {
            let s = e.id;
            if (this.promoteId) {
              const h = Array.isArray(this.promoteId) || typeof this.promoteId != "object" ? this.promoteId : this.promoteId[r];
              if (h != null) if (Array.isArray(h)) {
                if (!this.promoteIdExpression) {
                  const o = Ws(h);
                  if (o.result !== "success") {
                    const f = o.value.map((b) => `${b.key}: ${b.message}`).join(", ");
                    return void Se(`Failed to create expression for promoteId: ${f}`);
                  }
                  this.promoteIdExpression = o.value;
                }
                this.promoteIdExpression._evaluator || (this.promoteIdExpression._evaluator = new Mc()), s = this.promoteIdExpression.evaluate({ zoom: 0 }, e);
              } else s = e.properties[h];
              typeof s == "boolean" && (s = Number(s));
            }
            return s;
          }
        }
        function x1(a, e, r, s, h) {
          return Me(a, (o, f) => {
            const b = e instanceof Wl ? e.get(f) : null;
            return b && b.evaluate ? b.evaluate(r, s, h) : b;
          });
        }
        function Nw(a, e) {
          return e - a;
        }
        ur(y1, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
        const b1 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class l_ {
          static from(e) {
            if (!(e instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [r, s] = new Uint8Array(e, 0, 2);
            if (r !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const h = s >> 4;
            if (h !== 1) throw new Error(`Got v${h} data when expected v1.`);
            const o = b1[15 & s];
            if (!o) throw new Error("Unrecognized array type.");
            const [f] = new Uint16Array(e, 2, 1), [b] = new Uint32Array(e, 4, 1);
            return new l_(b, f, o, e);
          }
          constructor(e, r = 64, s = Float64Array, h) {
            if (isNaN(e) || e < 0) throw new Error(`Unpexpected numItems value: ${e}.`);
            this.numItems = +e, this.nodeSize = Math.min(Math.max(+r, 2), 65535), this.ArrayType = s, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
            const o = b1.indexOf(this.ArrayType), f = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, b = e * this.IndexArrayType.BYTES_PER_ELEMENT, O = (8 - b % 8) % 8;
            if (o < 0) throw new Error(`Unexpected typed array class: ${s}.`);
            h && h instanceof ArrayBuffer ? (this.data = h, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + b + O, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + f + b + O), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + b + O, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + o]), new Uint16Array(this.data, 2, 1)[0] = r, new Uint32Array(this.data, 4, 1)[0] = e);
          }
          add(e, r) {
            const s = this._pos >> 1;
            return this.ids[s] = s, this.coords[this._pos++] = e, this.coords[this._pos++] = r, s;
          }
          finish() {
            const e = this._pos >> 1;
            if (e !== this.numItems) throw new Error(`Added ${e} items when expected ${this.numItems}.`);
            return u_(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(e, r, s, h) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: o, coords: f, nodeSize: b } = this, O = [0, o.length - 1, 0], H = [];
            for (; O.length; ) {
              const y = O.pop() || 0, B = O.pop() || 0, G = O.pop() || 0;
              if (B - G <= b) {
                for (let ce = G; ce <= B; ce++) {
                  const _e = f[2 * ce], ze = f[2 * ce + 1];
                  _e >= e && _e <= s && ze >= r && ze <= h && H.push(o[ce]);
                }
                continue;
              }
              const L = G + B >> 1, F = f[2 * L], Y = f[2 * L + 1];
              F >= e && F <= s && Y >= r && Y <= h && H.push(o[L]), (y === 0 ? e <= F : r <= Y) && (O.push(G), O.push(L - 1), O.push(1 - y)), (y === 0 ? s >= F : h >= Y) && (O.push(L + 1), O.push(B), O.push(1 - y));
            }
            return H;
          }
          within(e, r, s) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: h, coords: o, nodeSize: f } = this, b = [0, h.length - 1, 0], O = [], H = s * s;
            for (; b.length; ) {
              const y = b.pop() || 0, B = b.pop() || 0, G = b.pop() || 0;
              if (B - G <= f) {
                for (let ce = G; ce <= B; ce++) S1(o[2 * ce], o[2 * ce + 1], e, r) <= H && O.push(h[ce]);
                continue;
              }
              const L = G + B >> 1, F = o[2 * L], Y = o[2 * L + 1];
              S1(F, Y, e, r) <= H && O.push(h[L]), (y === 0 ? e - s <= F : r - s <= Y) && (b.push(G), b.push(L - 1), b.push(1 - y)), (y === 0 ? e + s >= F : r + s >= Y) && (b.push(L + 1), b.push(B), b.push(1 - y));
            }
            return O;
          }
        }
        function u_(a, e, r, s, h, o) {
          if (h - s <= r) return;
          const f = s + h >> 1;
          w1(a, e, f, s, h, o), u_(a, e, r, s, f - 1, 1 - o), u_(a, e, r, f + 1, h, 1 - o);
        }
        function w1(a, e, r, s, h, o) {
          for (; h > s; ) {
            if (h - s > 600) {
              const H = h - s + 1, y = r - s + 1, B = Math.log(H), G = 0.5 * Math.exp(2 * B / 3), L = 0.5 * Math.sqrt(B * G * (H - G) / H) * (y - H / 2 < 0 ? -1 : 1);
              w1(a, e, r, Math.max(s, Math.floor(r - y * G / H + L)), Math.min(h, Math.floor(r + (H - y) * G / H + L)), o);
            }
            const f = e[2 * r + o];
            let b = s, O = h;
            for (Kd(a, e, s, r), e[2 * h + o] > f && Kd(a, e, s, h); b < O; ) {
              for (Kd(a, e, b, O), b++, O--; e[2 * b + o] < f; ) b++;
              for (; e[2 * O + o] > f; ) O--;
            }
            e[2 * s + o] === f ? Kd(a, e, s, O) : (O++, Kd(a, e, O, h)), O <= r && (s = O + 1), r <= O && (h = O - 1);
          }
        }
        function Kd(a, e, r, s) {
          c_(a, r, s), c_(e, 2 * r, 2 * s), c_(e, 2 * r + 1, 2 * s + 1);
        }
        function c_(a, e, r) {
          const s = a[e];
          a[e] = a[r], a[r] = s;
        }
        function S1(a, e, r, s) {
          const h = a - r, o = e - s;
          return h * h + o * o;
        }
        i.$ = Hc, i.A = Ua, i.B = 2, i.C = kd, i.D = nd, i.E = tn, i.F = D0, i.G = class extends Dp {
        }, i.H = ts, i.I = Qm, i.J = be, i.K = Ko, i.L = bo, i.M = xo, i.N = ra, i.O = yu, i.P = At, i.Q = Ro, i.R = Mr, i.S = rf, i.T = Nm, i.U = Ws, i.V = Dp, i.W = Zo, i.X = Dl, i.Y = ml, i.Z = ms, i._ = fa, i.a = function(a) {
          return $e.API_CDN_URL_REGEX.test(a);
        }, i.a$ = cd, i.a0 = hs, i.a1 = wa, i.a2 = function(a) {
          const e = a.value;
          let r = [];
          if (!e) return r;
          const s = ts(e);
          return s !== "string" ? (r = r.concat([new Dp(a.key, e, `string expected, "${s}" found`)]), r) : (xv(e, !0) || (r = r.concat([new Dp(a.key, e, `invalid url "${e}"`)])), r);
        }, i.a3 = Ei, i.a4 = Tu, i.a5 = Wn, i.a6 = Ji, i.a7 = class {
          constructor(a) {
            this.specification = a;
          }
          possiblyEvaluate(a, e) {
            return Be(a.expression.evaluate(e));
          }
          interpolate(a, e, r) {
            return { x: Tr(a.x, e.x, r), y: Tr(a.y, e.y, r), z: Tr(a.z, e.z, r), azimuthal: Tr(a.azimuthal, e.azimuthal, r), polar: Tr(a.polar, e.polar, r) };
          }
        }, i.a8 = Tn, i.a9 = bu, i.aA = Js, i.aB = class {
          constructor(a) {
            this.entries = {}, this.scheduler = a;
          }
          request(a, e, r, s) {
            const h = this.entries[a] = this.entries[a] || { callbacks: [] };
            if (h.result) {
              const [o, f] = h.result;
              return this.scheduler ? this.scheduler.add(() => {
                s(o, f);
              }, e) : s(o, f), () => {
              };
            }
            return h.callbacks.push(s), h.cancel || (h.cancel = r((o, f) => {
              h.result = [o, f];
              for (const b of h.callbacks) this.scheduler ? this.scheduler.add(() => {
                b(o, f);
              }, e) : b(o, f);
              setTimeout(() => delete this.entries[a], 3e3);
            })), () => {
              h.result || (h.callbacks = h.callbacks.filter((o) => o !== s), h.callbacks.length || (h.cancel(), delete this.entries[a]));
            };
          }
        }, i.aC = Os, i.aD = function(a, e, r) {
          const s = JSON.stringify(a.request);
          return a.data && (this.deduped.entries[s] = { result: [null, a.data] }), this.deduped.request(s, { type: "parseTile", isSymbolTile: a.isSymbolTile, zoom: a.tileZoom }, (h) => {
            const o = Vn(a.request, (f, b, O, H) => {
              f ? h(f) : b && h(null, { vectorTile: r ? void 0 : new Yf.VectorTile(new _p(b)), rawData: b, cacheControl: O, expires: H });
            });
            return () => {
              o.cancel(), h();
            };
          }, e);
        }, i.aE = function(a) {
          Hi++, Hi > Wt && (a.getActor().send("enforceCacheSizeLimit", Pt), Hi = 0);
        }, i.aF = function(a) {
          return a <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
        }, i.aG = Zi, i.aH = ov, i.aI = dv, i.aJ = sv, i.aK = function(a, e) {
          const r = document.createElement("video");
          r.muted = !0, r.onloadstart = function() {
            e(null, r);
          };
          for (let s = 0; s < a.length; s++) {
            const h = document.createElement("source");
            Yn(a[s]) || (r.crossOrigin = "Anonymous"), h.src = a[s], r.appendChild(h);
          }
          return { cancel: () => {
          } };
        }, i.aL = Pp, i.aM = function(a) {
          return fetch(a).then((e) => e.arrayBuffer()).then((e) => m1(e, 0, a));
        }, i.aN = g1, i.aO = class {
          constructor(a, e, r, s) {
            this.id = a, this.position = e != null ? new hn(e[0], e[1]) : new hn(0, 0), this.orientation = r ?? [0, 0, 0], this.nodes = s, this.uploaded = !1, this.aabb = new mr([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
          }
          _applyTransformations(a, e) {
            if (rt.mat4.multiply(a.matrix, e, a.matrix), a.meshes) for (const r of a.meshes) {
              const s = mr.applyTransformFast(r.aabb, a.matrix);
              this.aabb.encapsulate(s);
            }
            if (a.children) for (const r of a.children) this._applyTransformations(r, a.matrix);
          }
          computeBoundsAndApplyParent() {
            const a = rt.mat4.identity([]);
            for (const e of this.nodes) this._applyTransformations(e, a);
          }
          computeModelMatrix(a, e, r, s, h, o, f = !1) {
            Tv(this.matrix, this, a.transform, this.position, e, r, s, h, o, f);
          }
          upload(a) {
            if (!this.uploaded) {
              for (const e of this.nodes) Hm(e, a);
              for (const e of this.nodes) zp(e);
              this.uploaded = !0;
            }
          }
          destroy() {
            for (const a of this.nodes) qm(a);
          }
        }, i.aP = Te, i.aQ = Dd, i.aR = Qs, i.aS = Pr, i.aT = pa, i.aU = Ya, i.aV = ne, i.aW = Ph, i.aX = Mp, i.aY = function() {
          Zs.isLoading() || Zs.isLoaded() || Eu() !== "deferred" || lc();
        }, i.aZ = of, i.a_ = ve, i.aa = n, i.ab = rt, i.ac = xt, i.ad = Wl, i.ae = Bs, i.af = Tr, i.ag = tr, i.ah = Is, i.ai = Ye, i.aj = Wr, i.ak = class {
          constructor(a) {
            this.specification = a;
          }
          possiblyEvaluate(a, e) {
            return function([r, s]) {
              const h = Be([1, r, s]);
              return { x: h.x, y: h.y, z: h.z };
            }(a.expression.evaluate(e));
          }
          interpolate(a, e, r) {
            return { x: Tr(a.x, e.x, r), y: Tr(a.y, e.y, r), z: Tr(a.z, e.z, r) };
          }
        }, i.al = function(a, e, r = 0, s = !0) {
          const h = new At(r, r), o = a.sub(h), f = e.add(h), b = [o, new At(f.x, o.y), f, new At(o.x, f.y)];
          return s && b.push(o.clone()), b;
        }, i.am = function(a, e) {
          const r = [];
          for (let s = 0; s < a.length; s++) {
            const h = l(s - 1, -1, a.length - 1), o = l(s + 1, -1, a.length - 1), f = a[s], b = a[o], O = a[h].sub(f).unit(), H = b.sub(f).unit(), y = H.angleWithSep(O.x, O.y), B = O.add(H).unit().mult(-1 * e / Math.sin(y / 2));
            r.push(f.add(B));
          }
          return r;
        }, i.an = W0, i.ao = Jt, i.ap = function(a, e, r = 0) {
          return rt.vec3.fromValues(((e.x - r) * a.scale - a.x) * tr, (e.y * a.scale - a.y) * tr, zu(e.z, e.y));
        }, i.aq = Fr, i.ar = c0, i.as = function(a) {
          let e = 1 / 0, r = 1 / 0, s = -1 / 0, h = -1 / 0;
          for (const o of a) e = Math.min(e, o.x), r = Math.min(r, o.y), s = Math.max(s, o.x), h = Math.max(h, o.y);
          return { min: new At(e, r), max: new At(s, h) };
        }, i.at = il, i.au = Zt, i.av = p, i.aw = pe, i.ax = vs, i.ay = function(a, e) {
          const r = {};
          for (let s = 0; s < e.length; s++) {
            const h = e[s];
            h in a && (r[h] = a[h]);
          }
          return r;
        }, i.az = Al, i.b = function(a) {
          return $e.API_FONTS_REGEX.test(a);
        }, i.b$ = Lp, i.b0 = fe, i.b1 = vm, i.b2 = qa, i.b3 = oe, i.b4 = Ds, i.b5 = dc, i.b6 = Ar, i.b7 = Ea, i.b8 = Nh, i.b9 = zm, i.bA = jg, i.bB = Pm, i.bC = j0, i.bD = Am, i.bE = l_, i.bF = l, i.bG = Xe, i.bH = Zn, i.bI = function(a, e, r) {
          a[4 * e + 0] = r[0], a[4 * e + 1] = r[1], a[4 * e + 2] = r[2], a[4 * e + 3] = r[3];
        }, i.bJ = yc, i.bK = Xs, i.bL = gc, i.bM = ma, i.bN = el, i.bO = hn, i.bP = K0, i.bQ = Fi, i.bR = Jr, i.bS = mv, i.bT = Ui, i.bU = as, i.bV = function(a, e, r, s, h, o, f, b, O) {
          if (O.name === "globe") return as(a, e, new Ui(r, s, h), !1);
          const H = Dd({ z: r, x: s, y: h }, O);
          return new mr([(o + H.x / H.scale) * e, e * (H.y / H.scale), f], [(o + H.x2 / H.scale) * e, e * (H.y2 / H.scale), b]);
        }, i.bW = function(a, e, r) {
          let s = 0;
          for (let h = 0; h < 2; ++h)
            a[h] > 0 && (s += (a[h] - 0) * (a[h] - 0)), e[h] < 0 && (s += (0 - e[h]) * (0 - e[h]));
          return s;
        }, i.bX = la, i.bY = eh, i.bZ = function(a) {
          const e = rt.mat4.identity(new Float64Array(16));
          rt.mat4.multiply(e, a.pixelMatrix, a.globeMatrix);
          const r = [0, Ys, 0], s = [0, Ts, 0];
          return rt.vec3.transformMat4(r, r, e), rt.vec3.transformMat4(s, s, e), [r[0] > 0 && r[0] <= a.width && r[1] > 0 && r[1] <= a.height && !po(a, new hn(a.center.lat, 90)), s[0] > 0 && s[0] <= a.width && s[1] > 0 && s[1] <= a.height && !po(a, new hn(a.center.lat, -90))];
        }, i.b_ = function(a, e) {
          const { scale: r } = a.tileTransform, s = r * tr / (a.tileSize * Math.pow(2, e.zoom - a.tileID.overscaledZ + a.tileID.canonical.z));
          return rt.mat2.scale(new Float32Array(4), e.inverseAdjustmentMatrix, [s, s]);
        }, i.ba = function(a, e) {
          const r = Bs(e.zoom);
          if (r === 0) return Ra(a);
          const s = On(a), h = Rn(s), o = il(s.getWest()) * e.worldSize, f = il(s.getEast()) * e.worldSize, b = Js(s.getNorth()) * e.worldSize, O = Js(s.getSouth()) * e.worldSize, H = [o, b, 0], y = [f, b, 0], B = [o, O, 0], G = [f, O, 0], L = rt.mat4.invert([], e.globeMatrix);
          return rt.vec3.transformMat4(H, H, L), rt.vec3.transformMat4(y, y, L), rt.vec3.transformMat4(B, B, L), rt.vec3.transformMat4(G, G, L), h[0] = Aa(h[0], B, r), h[1] = Aa(h[1], G, r), h[2] = Aa(h[2], y, r), h[3] = Aa(h[3], H, r), mr.fromPoints(h);
        }, i.bb = Ha, i.bc = Cn, i.bd = Aa, i.be = oa, i.bf = Er, i.bg = r_, i.bh = _p, i.bi = Vn, i.bj = function(a) {
          const e = [];
          for (const r in a) e.push(a[r]);
          return e;
        }, i.bk = function(a, e) {
          const r = [];
          for (const s in a) s in e || r.push(s);
          return r;
        }, i.bl = _, i.bm = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], i.bn = St, i.bo = function(a, e) {
          const { x: r, y: s } = a.point, h = Ka(r, s, a.worldSize / a._pixelsPerMercatorPixel, 0, 0);
          return rt.mat4.multiply(h, h, kn(Ra(e)));
        }, i.bp = Kf, i.bq = Ml, i.br = mp, i.bs = function(a, e, r, s, h) {
          const o = 5 * e + 2;
          a.float32[o + 0] = r, a.float32[o + 1] = s, a.float32[o + 2] = h;
        }, i.bt = Ap, i.bu = O0, i.bv = st, i.bw = Ns, i.bx = zg, i.by = yv, i.bz = Vg, i.c = Nt, i.c$ = (a, e, r, s, h, o, f, b) => {
          const O = a.transform, H = O.pitch < 15 ? h0(0.07, 0.7, pe((14 - O.zoom) / 5, 0, 1)) : 0.07, y = r.paint.get("line-trim-color-use-theme").constantOr("default") === "none";
          return { u_matrix: d0(a, e, r, s), u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: O.calculatePixelsToTileUnitsMatrix(e), u_device_pixel_ratio: h, u_width_scale: o, u_floor_width_scale: f, u_image: 0, u_tile_units_to_pixels: f0(e, O), u_units_to_pixels: [1 / O.pixelsToGLUnits[0], 1 / O.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: b, u_trim_fade_range: r.paint.get("line-trim-fade-range"), u_trim_color: r.paint.get("line-trim-color").toRenderColor(y ? null : r.lut).toArray01(), u_emissive_strength: r.paint.get("line-emissive-strength"), u_zbias_factor: H, u_tile_to_meter: t(e.tileID.canonical, 0) };
        }, i.c0 = pv, i.c1 = function(a) {
          const e = pv(a, !0);
          return rt.mat2.invert([], [e[0], e[1], e[4], e[5]]);
        }, i.c2 = an, i.c3 = function(a) {
          const { x: e, y: r } = a.point, { lng: s, lat: h } = a._center;
          return Ka(e, r, a.worldSize, s, h);
        }, i.c4 = De, i.c5 = ir, i.c6 = Ql, i.c7 = function(a) {
          const e = Math.round((a + 45 + 360) % 360 / 90) % 4;
          return Re[e];
        }, i.c8 = 45, i.c9 = Dh, i.cA = class extends To {
          constructor(a) {
            super(a), this.current = Lh;
          }
          set(a, e, r) {
            if (this.fetchUniformLocation(a, e)) {
              for (let s = 0; s < 9; s++) if (r[s] !== this.current[s]) {
                this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);
                break;
              }
            }
          }
        }, i.cB = _t, i.cC = function(a, e, r) {
          const s = Bs(r.zoom), h = a.style.map._antialias, o = a.terrain && a.terrain.exaggeration() > 0;
          return s === 0 && !h && !o;
        }, i.cD = function(a) {
          const e = a.pixelsPerMeter, r = e / Zn(1, a.center.lat), s = rt.mat4.identity(new Float64Array(16));
          return rt.mat4.translate(s, s, [a.point.x, a.point.y, 0]), rt.mat4.scale(s, s, [r, r, e]), Float32Array.from(s);
        }, i.cE = On, i.cF = function(a) {
          const e = la - 5;
          a = pe(a, -e, e) / e * 90;
          const r = Math.pow(Math.abs(Math.sin(Ye(a))), 3);
          return Math.round(r * (bc.length - 1));
        }, i.cG = function(a, e, r, s) {
          const h = e.getNorth(), o = e.getSouth(), f = e.getWest(), b = e.getEast(), O = 1 << a.z, H = b - f, y = h - o, B = H / Ou, G = -y / bc[r], L = [0, B, 0, G, 0, 0, h, f, 0];
          if (a.z > 0) {
            const F = 180 / s;
            rt.mat3.multiply(L, L, [F / H + 1, 0, 0, 0, F / y + 1, 0, -0.5 * F / B, 0.5 * F / G, 1]);
          }
          return L[2] = O, L[5] = a.x, L[8] = a.y, L;
        }, i.cH = Ra, i.cI = function(a, e, r) {
          const s = rt.mat4.identity(new Float64Array(16)), h = (e / (1 << a) - 0.5) * Math.PI * 2;
          return rt.mat4.rotateY(s, r.globeMatrix, h), Float32Array.from(s);
        }, i.cJ = class {
          isDataAvailableAtPoint(a) {
            const e = this._source();
            if (this.isUsingMockSource() || !e || a.y < 0 || a.y > 1) return !1;
            const r = e.getSource().maxzoom, s = 1 << r, h = Math.floor(a.x), o = Math.floor((a.x - h) * s), f = Math.floor(a.y * s), b = this.findDEMTileFor(new Zi(r, h, r, o, f));
            return !(!b || !b.dem);
          }
          getAtPointOrZero(a, e = 0) {
            return this.getAtPoint(a, e) || 0;
          }
          getAtPoint(a, e, r = !0) {
            if (this.isUsingMockSource()) return null;
            e == null && (e = null);
            const s = this._source();
            if (!s || a.y < 0 || a.y > 1) return e;
            const h = s.getSource().maxzoom, o = 1 << h, f = Math.floor(a.x), b = a.x - f, O = new Zi(h, f, h, Math.floor(b * o), Math.floor(a.y * o)), H = this.findDEMTileFor(O);
            if (!H || !H.dem) return e;
            const y = H.dem, B = 1 << H.tileID.canonical.z, G = (b * B - H.tileID.canonical.x) * y.dim, L = (a.y * B - H.tileID.canonical.y) * y.dim, F = Math.floor(G), Y = Math.floor(L);
            return (r ? this.exaggeration() : 1) * Tr(Tr(y.get(F, Y), y.get(F, Y + 1), L - Y), Tr(y.get(F + 1, Y), y.get(F + 1, Y + 1), L - Y), G - F);
          }
          getAtTileOffset(a, e, r) {
            const s = 1 << a.canonical.z;
            return this.getAtPointOrZero(new n(a.wrap + (a.canonical.x + e / tr) / s, (a.canonical.y + r / tr) / s));
          }
          getAtTileOffsetFunc(a, e, r, s) {
            return (h) => {
              const o = this.getAtTileOffset(a, h.x, h.y), f = s.upVector(a.canonical, h.x, h.y), b = s.upVectorScale(a.canonical, e, r).metersToTile;
              return rt.vec3.scale(f, f, o * b), f;
            };
          }
          getForTilePoints(a, e, r, s) {
            if (this.isUsingMockSource()) return !1;
            const h = rd.create(this, a, s);
            return !!h && (e.forEach((o) => {
              o[2] = this.exaggeration() * h.getElevationAt(o[0], o[1], r);
            }), !0);
          }
          getMinMaxForTile(a) {
            if (this.isUsingMockSource()) return null;
            const e = this.findDEMTileFor(a);
            if (!e || !e.dem) return null;
            const r = e.dem.tree, s = e.tileID, h = 1 << a.canonical.z - s.canonical.z;
            let o = a.canonical.x / h - s.canonical.x, f = a.canonical.y / h - s.canonical.y, b = 0;
            for (let O = 0; O < a.canonical.z - s.canonical.z && !r.leaves[b]; O++) {
              o *= 2, f *= 2;
              const H = 2 * Math.floor(f) + Math.floor(o);
              b = r.childOffsets[b] + H, o %= 1, f %= 1;
            }
            return { min: this.exaggeration() * r.minimums[b], max: this.exaggeration() * r.maximums[b] };
          }
          getMinElevationBelowMSL() {
            throw new Error("Pure virtual method called.");
          }
          raycast(a, e, r) {
            throw new Error("Pure virtual method called.");
          }
          pointCoordinate(a) {
            throw new Error("Pure virtual method called.");
          }
          _source() {
            throw new Error("Pure virtual method called.");
          }
          isUsingMockSource() {
            throw new Error("Pure virtual method called.");
          }
          exaggeration() {
            throw new Error("Pure virtual method called.");
          }
          findDEMTileFor(a) {
            throw new Error("Pure virtual method called.");
          }
          get visibleDemTiles() {
            throw new Error("Getter must be implemented in subclass.");
          }
          getMinMaxForVisibleTiles() {
            const a = this.visibleDemTiles;
            if (a.length === 0) return null;
            let e = !1, r = Number.MAX_VALUE, s = Number.MIN_VALUE;
            for (const h of a) {
              const o = this.getMinMaxForTile(h.tileID);
              o && (r = Math.min(r, o.min), s = Math.max(s, o.max), e = !0);
            }
            return e ? { min: r, max: s } : null;
          }
        }, i.cK = wd, i.cL = nn, i.cM = function(a, e) {
          return [Math.pow(a[0], 2.2) * e, Math.pow(a[1], 2.2) * e, Math.pow(a[2], 2.2) * e];
        }, i.cN = fo, i.cO = ae, i.cP = nt, i.cQ = 256, i.cR = function(a, e) {
          const r = [0, 0, 0], s = Ha(Ra(e.canonical));
          return rt.vec3.transformMat4(r, r, s), rt.vec3.transformMat4(r, r, a), r;
        }, i.cS = (a) => ({ u_camera_to_center_distance: new ma(a), u_extrude_scale: new Es(a), u_device_pixel_ratio: new ma(a), u_matrix: new yc(a), u_inv_rot_matrix: new yc(a), u_merc_center: new Xs(a), u_tile_id: new gc(a), u_zoom_transition: new ma(a), u_up_dir: new gc(a), u_emissive_strength: new ma(a) }), i.cT = (a) => ({ u_matrix: new yc(a), u_pixels_to_tile_units: new Es(a), u_device_pixel_ratio: new ma(a), u_width_scale: new ma(a), u_floor_width_scale: new ma(a), u_units_to_pixels: new Xs(a), u_dash_image: new el(a), u_gradient_image: new el(a), u_image_height: new ma(a), u_texsize: new Xs(a), u_tile_units_to_pixels: new ma(a), u_alpha_discard_threshold: new ma(a), u_trim_offset: new Xs(a), u_trim_fade_range: new Xs(a), u_trim_color: new vc(a), u_emissive_strength: new ma(a), u_zbias_factor: new ma(a), u_tile_to_meter: new ma(a) }), i.cU = (a) => ({ u_matrix: new yc(a), u_texsize: new Xs(a), u_pixels_to_tile_units: new Es(a), u_device_pixel_ratio: new ma(a), u_width_scale: new ma(a), u_floor_width_scale: new ma(a), u_image: new el(a), u_units_to_pixels: new Xs(a), u_tile_units_to_pixels: new ma(a), u_alpha_discard_threshold: new ma(a), u_trim_offset: new Xs(a), u_trim_fade_range: new Xs(a), u_trim_color: new vc(a), u_emissive_strength: new ma(a), u_zbias_factor: new ma(a), u_tile_to_meter: new ma(a) }), i.cV = Zc, i.cW = Gx, i.cX = Hx, i.cY = Sc, i.cZ = (a, e, r, s, h, o) => {
          const f = a.transform, b = f.projection.name === "globe";
          let O;
          if (o.paint.get("circle-pitch-alignment") === "map") if (b) {
            const y = fo(f.zoom, e.canonical) * f._pixelsPerMercatorPixel;
            O = Float32Array.from([y, 0, 0, y]);
          } else O = f.calculatePixelsToTileUnitsMatrix(r);
          else O = new Float32Array([f.pixelsToGLUnits[0], 0, 0, f.pixelsToGLUnits[1]]);
          const H = { u_camera_to_center_distance: a.transform.getCameraToCenterDistance(f.projection), u_matrix: a.translatePosMatrix(e.projMatrix, r, o.paint.get("circle-translate"), o.paint.get("circle-translate-anchor")), u_device_pixel_ratio: Ct.devicePixelRatio, u_extrude_scale: O, u_inv_rot_matrix: Fu, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: o.paint.get("circle-emissive-strength") };
          if (b) {
            H.u_inv_rot_matrix = s, H.u_merc_center = h, H.u_tile_id = [e.canonical.x, e.canonical.y, 1 << e.canonical.z], H.u_zoom_transition = Bs(f.zoom);
            const y = h[0] * tr, B = h[1] * tr;
            H.u_up_dir = f.projection.upVector(new Ui(0, 0, 0), y, B);
          }
          return H;
        }, i.c_ = p0, i.ca = vc, i.cb = function(a, e, r) {
          const s = Math.sqrt(a * a + e * e + r * r), h = s > 0 ? Math.acos(r / s) * kt : 0;
          let o = a !== 0 || e !== 0 ? Math.atan2(-e, -a) * kt + 90 : 0;
          return o < 0 && (o += 360), [s, o, h];
        }, i.cc = t, i.cd = mr, i.ce = Be, i.cf = function(a) {
          return [Math.pow(a[0], 1 / 2.2), Math.pow(a[1], 1 / 2.2), Math.pow(a[2], 1 / 2.2)];
        }, i.cg = function(a, e) {
          return a.readFields(Db, { icons: [] }, e);
        }, i.ch = function(a) {
          return a({ pluginStatus: Ls, pluginURL: co }), Yo.on("pluginStateChange", a), a;
        }, i.ci = Fp, i.cj = Qf, i.ck = Mm, i.cl = xn, i.cm = jc, i.cn = Ut, i.co = La, i.cp = Qe, i.cq = function(a) {
          const e = a.indexOf(uc);
          return e >= 0 ? a.slice(0, e) : a;
        }, i.cr = function(a) {
          return a.indexOf(uc) >= 0;
        }, i.cs = function(a) {
          const e = a.indexOf(uc);
          return e >= 0 ? a.slice(e + 1) : "";
        }, i.ct = function(a) {
          const e = [], r = a.id;
          return r === void 0 && e.push({ message: `layers.${r}: missing required property "id"` }), a.render === void 0 && e.push({ message: `layers.${r}: missing required method "render"` }), a.renderingMode && a.renderingMode !== "2d" && a.renderingMode !== "3d" && e.push({ message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"` }), e;
        }, i.cu = function(a, e, r, s) {
          return a.type === "custom" ? new bb(a, e) : new kb[a.type](a, e, r, s);
        }, i.cv = Ge, i.cw = class extends cd {
          constructor(a, e) {
            super(a._vectorTileFeature, a._z, a._x, a._y, a.id), a.state && (this.state = Object.assign({}, a.state)), this.target = e.target, this.namespace = e.namespace, e.properties && (this.properties = e.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = a.source, this.sourceLayer = a.sourceLayer, this.layer = a.layer);
          }
          toJSON() {
            const a = super.toJSON();
            return a.target = this.target, a.namespace = this.namespace, a;
          }
        }, i.cx = Yo, i.cy = En, i.cz = _f, i.d = function(a) {
          return $e.API_TILEJSON_REGEX.test(a);
        }, i.d$ = y1, i.d0 = (a, e, r, s, h, o, f, b, O) => {
          const H = a.transform, y = H.calculatePixelsToTileUnitsMatrix(e), B = r.paint.get("line-trim-color-use-theme").constantOr("default") === "none", G = H.pitch < 15 ? h0(0.07, 0.7, pe((14 - H.zoom) / 5, 0, 1)) : 0.07;
          return { u_matrix: d0(a, e, r, s), u_pixels_to_tile_units: y, u_device_pixel_ratio: o, u_width_scale: f, u_floor_width_scale: b, u_units_to_pixels: [1 / H.pixelsToGLUnits[0], 1 / H.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: h, u_texsize: m0(r) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: f0(e, a.transform), u_alpha_discard_threshold: 0, u_trim_offset: O, u_trim_fade_range: r.paint.get("line-trim-fade-range"), u_trim_color: r.paint.get("line-trim-color").toRenderColor(B ? null : r.lut).toArray01(), u_emissive_strength: r.paint.get("line-emissive-strength"), u_zbias_factor: G, u_tile_to_meter: t(e.tileID.canonical, 0) };
        }, i.d1 = ue, i.d2 = Fh, i.d3 = t0, i.d4 = cr, i.d5 = pp, i.d6 = Uh, i.d7 = 450, i.d8 = 7, i.d9 = xb, i.dA = Ie, i.dB = u, i.dC = Du, i.dD = function([a, e, r]) {
          const s = Math.hypot(a, e, r), h = Math.atan2(a, r), o = 0.5 * Math.PI - Math.acos(-e / s);
          return new hn(De(h), De(o));
        }, i.dE = Vm, i.dF = function(a) {
          const e = a.navigator ? a.navigator.userAgent : null;
          return !!function(r) {
            if (Je == null) {
              const s = r.navigator ? r.navigator.userAgent : null;
              Je = !!r.safari || !(!s || !(/\b(iPad|iPhone|iPod)\b/.test(s) || s.match("Safari") && !s.match("Chrome")));
            }
            return Je;
          }(a) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, i.dG = function(a, e) {
          Pt = a, Wt = e;
        }, i.dH = po, i.dI = Fs, i.dJ = function(a) {
          const e = [0, 0, 0], r = rt.mat4.identity(new Float64Array(16));
          return rt.mat4.multiply(r, a.pixelMatrix, a.globeMatrix), rt.vec3.transformMat4(e, e, r), new At(e[0], e[1]);
        }, i.dK = function(a, e, r = !1) {
          if (Ls === Su || Ls === oc || Ls === xh) throw new Error("setRTLTextPlugin cannot be called multiple times.");
          co = Ct.resolveURL(a), Ls = Su, uo = e, sf(), r || lc();
        }, i.dL = Eu, i.dM = function() {
          Fp().acquire(Zm);
        }, i.dN = function() {
          const a = Gd;
          a && (a.isPreloaded() && a.numActive() === 1 ? (a.release(Zm), Gd = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, i.dO = Ef, i.dP = function(a) {
          const e = Di();
          if (!e) return;
          const r = e.delete(ti);
          a && r.catch(a).then(() => a());
        }, i.dQ = jd, i.dR = l1, i.dS = function(a) {
          n_ = Ct.resolveURL(a), ud || (ud = new nd(Fp(), new tn())), ud.broadcast("setDracoUrl", n_);
        }, i.dT = u1, i.dU = function(a) {
          ld = Ct.resolveURL(a), ud || (ud = new nd(Fp(), new tn())), ud.broadcast("setMeshoptUrl", ld);
        }, i.dV = ur, i.dW = tu, i.dX = ju, i.dY = Yf, i.dZ = class {
          constructor(a, e) {
            this.pos = a, this.dir = e;
          }
          intersectsPlane(a, e, r) {
            const s = rt.vec2.dot(e, this.dir);
            if (Math.abs(s) < 1e-6) return !1;
            const h = ((a[0] - this.pos[0]) * e[0] + (a[1] - this.pos[1]) * e[1]) / s;
            return r[0] = this.pos[0] + this.dir[0] * h, r[1] = this.pos[1] + this.dir[1] * h, !0;
          }
        }, i.d_ = v1, i.da = dn, i.db = Ih, i.dc = 256, i.dd = kn, i.de = $s, i.df = Sl, i.dg = $c, i.dh = function(a, e, r, s, h) {
          return pe((a - e) / (r - e) * (h - s) + s, s, h);
        }, i.di = yo, i.dj = wc, i.dk = class {
          constructor(a, e, r, s) {
            this.context = a, this.format = s, this.size = r, this.texture = a.gl.createTexture();
            const [h, o, f] = this.size, { gl: b } = a;
            b.bindTexture(b.TEXTURE_3D, this.texture), a.pixelStoreUnpackFlipY.set(!1), a.pixelStoreUnpack.set(1), a.pixelStoreUnpackPremultiplyAlpha.set(!1), b.texImage3D(b.TEXTURE_3D, 0, this.format, h, o, f, 0, Bm(this.format), Fm(this.format), e.data);
          }
          bind(a, e) {
            const { context: r } = this, { gl: s } = r;
            s.bindTexture(s.TEXTURE_3D, this.texture), a !== this.minFilter && (s.texParameteri(s.TEXTURE_3D, s.TEXTURE_MAG_FILTER, a), s.texParameteri(s.TEXTURE_3D, s.TEXTURE_MIN_FILTER, a), this.minFilter = a), e !== this.wrapS && (s.texParameteri(s.TEXTURE_3D, s.TEXTURE_WRAP_S, e), s.texParameteri(s.TEXTURE_3D, s.TEXTURE_WRAP_T, e), this.wrapS = e);
          }
          destroy() {
            const { gl: a } = this.context;
            a.deleteTexture(this.texture), this.texture = null;
          }
        }, i.dl = jm, i.dm = [1, 1, 1], i.dn = rd, i.dp = id, i.dq = rs, i.dr = Ru, i.ds = eu, i.dt = Xl, i.du = ko, i.dv = class {
          constructor() {
            this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = { min: new At(1 / 0, 1 / 0), max: new At(-1 / 0, -1 / 0) };
          }
          clear() {
            this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
          }
          get updateTime() {
            return this._updateTime;
          }
          getReplacementRegionsForTile(a, e = !1) {
            const r = Fg(new At(0, 0), new At(tr, tr), a), s = [];
            if (e && !dm(r, this._globalClipBounds)) return s;
            for (const h of this._activeRegions) {
              if (h.hiddenByOverlap || !dm(r, h)) continue;
              const o = _x(h.min, h.max, a);
              s.push({ min: o.min, max: o.max, sourceId: this._sourceIds[h.priority], footprint: h.footprint, footprintTileId: h.tileId, order: h.order, clipMask: h.clipMask, clipScope: h.clipScope });
            }
            return s;
          }
          setSources(a) {
            this._setSources(a.map((e) => ({ getSourceId: () => e.cache.id, getFootprints: () => {
              const r = [];
              for (const s of e.cache.getVisibleCoordinates()) {
                const h = e.cache.getTile(s).buckets[e.layer];
                h && h.updateFootprints(s.toUnwrapped(), r);
              }
              return r;
            }, getOrder: () => e.order, getClipMask: () => e.clipMask, getClipScope: () => e.clipScope })));
          }
          _addSource(a) {
            const e = a.getFootprints();
            if (e.length === 0) return;
            const r = a.getOrder(), s = a.getClipMask(), h = a.getClipScope();
            for (const o of e) {
              if (!o.footprint) continue;
              const f = Fg(o.footprint.min, o.footprint.max, o.id);
              this._activeRegions.push({ min: f.min, max: f.max, hiddenByOverlap: !1, priority: this._sourceIds.length, tileId: o.id, footprint: o.footprint, order: r, clipMask: s, clipScope: h });
            }
            this._sourceIds.push(a.getSourceId());
          }
          _computeReplacement() {
            this._activeRegions.sort((e, r) => e.priority - r.priority || fp(e.min, r.min) || fp(e.max, r.max) || e.order - r.order || e.clipMask - r.clipMask || function(s, h) {
              const o = (f, b) => f + b;
              return s.length - h.length || s.reduce(o, "").localeCompare(h.reduce(o, ""));
            }(e.clipScope, r.clipScope));
            let a = this._activeRegions.length !== this._prevRegions.length;
            if (!a) {
              let e = 0;
              for (; !a && e !== this._activeRegions.length; ) {
                const r = this._activeRegions[e], s = this._prevRegions[e];
                a = r.priority !== s.priority || !Bg(r, s) || r.order !== s.order || r.clipMask !== s.clipMask || !St(r.clipScope, s.clipScope), ++e;
              }
            }
            if (a) {
              ++this._updateTime;
              for (const r of this._activeRegions) r.order !== hp && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, r.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, r.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, r.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, r.max.y));
              const e = (r) => {
                const s = this._activeRegions;
                if (r >= s.length) return r;
                const h = s[r].priority;
                for (; r < s.length && s[r].priority === h; ) ++r;
                return r;
              };
              if (this._sourceIds.length > 1) {
                let r = 0, s = e(r);
                for (; r !== s; ) {
                  let h = r;
                  const o = r;
                  for (; h !== s; ) {
                    const f = this._activeRegions[h];
                    f.hiddenByOverlap = !1;
                    for (let b = 0; b < o; b++) {
                      const O = this._activeRegions[b];
                      if (!O.hiddenByOverlap && f.order === hp && dm(f, O) && (f.hiddenByOverlap = Ug(f.footprint, f.tileId, O.footprint, O.tileId), f.hiddenByOverlap)) break;
                    }
                    ++h;
                  }
                  r = s, s = e(r);
                }
              }
            }
          }
          _setSources(a) {
            [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
            for (let e = a.length - 1; e >= 0; e--) this._addSource(a[e]);
            this._computeReplacement();
          }
        }, i.dw = class {
          constructor(a) {
            this._createGrid(a), this._createPoles(a);
          }
          destroy() {
            this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
            for (const a of this._poleSegments) a.destroy();
            for (const a of this._gridSegments) a.withSkirts.destroy(), a.withoutSkirts.destroy();
          }
          _fillGridMeshWithLods(a, e) {
            const r = new Ds(), s = new Ya(), h = [], o = a + 1 + 2, f = e[0] + 1, b = e[0] + 1 + (1 + e.length), O = (H, y, B) => {
              let G = H === o - 1 ? H - 2 : H === 0 ? H : H - 1;
              return G += B ? 24575 : 0, [G, y];
            };
            for (let H = 0; H < o; ++H) r.emplaceBack(...O(H, 0, !0));
            for (let H = 0; H < f; ++H) for (let y = 0; y < o; ++y) r.emplaceBack(...O(y, H, (y === 0 || y === o - 1) && !0));
            for (let H = 0; H < e.length; ++H) {
              const y = e[H];
              for (let B = 0; B < o; ++B) r.emplaceBack(...O(B, y, !0));
            }
            for (let H = 0; H < e.length; ++H) {
              const y = s.length, B = e[H] + 1 + 2, G = new Ya();
              for (let Y = 0; Y < B - 1; Y++) {
                const ce = Y === B - 2, _e = ce ? o * (b - e.length + H - Y) : o;
                for (let ze = 0; ze < o - 1; ze++) {
                  const Ne = Y * o + ze;
                  Y === 0 || ce || ze === 0 || ze === o - 2 ? (G.emplaceBack(Ne + 1, Ne, Ne + _e), G.emplaceBack(Ne + _e, Ne + _e + 1, Ne + 1)) : (s.emplaceBack(Ne + 1, Ne, Ne + _e), s.emplaceBack(Ne + _e, Ne + _e + 1, Ne + 1));
                }
              }
              const L = Ea.simpleSegment(0, y, r.length, s.length - y);
              for (let Y = 0; Y < G.uint16.length; Y += 3) s.emplaceBack(G.uint16[Y], G.uint16[Y + 1], G.uint16[Y + 2]);
              const F = Ea.simpleSegment(0, y, r.length, s.length - y);
              h.push({ withoutSkirts: L, withSkirts: F });
            }
            return { vertices: r, indices: s, segments: h };
          }
          _createGrid(a) {
            const e = this._fillGridMeshWithLods(Ou, bc);
            this._gridSegments = e.segments, this._gridBuffer = a.createVertexBuffer(e.vertices, Ar.members), this._gridIndexBuffer = a.createIndexBuffer(e.indices, !0);
          }
          _createPoles(a) {
            const e = new Ya();
            for (let f = 0; f <= Ou; f++) e.emplaceBack(0, f + 1, f + 2);
            this._poleIndexBuffer = a.createIndexBuffer(e, !0);
            const r = new Sl(), s = new Sl(), h = new Sl(), o = new Sl();
            this._poleSegments = [];
            for (let f = 0, b = 0; f < Ql; f++) {
              const O = 360 / (1 << f);
              r.emplaceBack(0, -vs, 0, 0.5, 0), s.emplaceBack(0, -vs, 0, 0.5, 1), h.emplaceBack(0, -vs, 0, 0.5, 0.5), o.emplaceBack(0, -vs, 0, 0.5, 0.5);
              for (let H = 0; H <= Ou; H++) {
                let y = H / Ou, B = 0;
                const G = Tr(0, O, y), [L, F, Y] = Ks(Bu, Oo, G, vs);
                r.emplaceBack(L, F, Y, y, B), s.emplaceBack(L, F, Y, y, 1 - B);
                const ce = Ye(G);
                y = 0.5 + 0.5 * Math.sin(ce), B = 0.5 + 0.5 * Math.cos(ce), h.emplaceBack(L, F, Y, y, B), o.emplaceBack(L, F, Y, y, 1 - B);
              }
              this._poleSegments.push(Ea.simpleSegment(b, 0, 66, 64)), b += 66;
            }
            this._poleNorthVertexBuffer = a.createVertexBuffer(r, Or, !1), this._poleSouthVertexBuffer = a.createVertexBuffer(s, Or, !1), this._texturedPoleNorthVertexBuffer = a.createVertexBuffer(h, Or, !1), this._texturedPoleSouthVertexBuffer = a.createVertexBuffer(o, Or, !1);
          }
          getGridBuffers(a, e) {
            return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[a].withSkirts : this._gridSegments[a].withoutSkirts];
          }
          getPoleBuffers(a, e) {
            return [e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[a]];
          }
        }, i.dx = hp, i.dy = et, i.dz = function() {
          return !!document.fullscreenElement || !!document.webkitFullscreenElement;
        }, i.e = $e, i.e0 = o0, i.e1 = Me, i.e2 = bs, i.e3 = z0, i.e4 = function(a, e, r, s, h, o, f, b, O, H, y = 1, B, G) {
          a.createArrays(), a.tilePixelRatio = tr / (512 * a.overscaling), a.compareText = {}, a.iconsNeedLinear = !1;
          const L = a.layers[0].layout, F = a.layers[0]._unevaluatedLayout._values, Y = {};
          Y.scaleFactor = y, Y.textSizeScaleRange = L.get("text-size-scale-range"), Y.iconSizeScaleRange = L.get("icon-size-scale-range");
          const [ce, _e] = Y.textSizeScaleRange, [ze, Ne] = Y.iconSizeScaleRange;
          if (Y.textScaleFactor = pe(Y.scaleFactor, ce, _e), Y.iconScaleFactor = pe(Y.scaleFactor, ze, Ne), a.textSizeData.kind === "composite") {
            const { minZoom: yt, maxZoom: Bt } = a.textSizeData;
            Y.compositeTextSizes = [F["text-size"].possiblyEvaluate(new Tn(yt), b), F["text-size"].possiblyEvaluate(new Tn(Bt), b)];
          }
          if (a.iconSizeData.kind === "composite") {
            const { minZoom: yt, maxZoom: Bt } = a.iconSizeData;
            Y.compositeIconSizes = [F["icon-size"].possiblyEvaluate(new Tn(yt), b), F["icon-size"].possiblyEvaluate(new Tn(Bt), b)];
          }
          Y.layoutTextSize = F["text-size"].possiblyEvaluate(new Tn(O + 1), b), Y.layoutIconSize = F["icon-size"].possiblyEvaluate(new Tn(O + 1), b), Y.textMaxSize = F["text-size"].possiblyEvaluate(new Tn(18), b);
          const Ee = L.get("text-rotation-alignment") === "map" && L.get("symbol-placement") !== "point", We = L.get("text-size");
          let lt = !1;
          for (const yt of a.features) if (yt.icon && yt.icon.nameSecondary) {
            lt = !0;
            break;
          }
          for (const yt of a.features) {
            const Bt = L.get("text-font").evaluate(yt, {}, b).join(","), zt = We.evaluate(yt, {}, b) * Y.textScaleFactor, Dt = Y.layoutTextSize.evaluate(yt, {}, b) * Y.textScaleFactor, ni = (Y.layoutIconSize.evaluate(yt, {}, b), { horizontal: {}, vertical: void 0 }), Gt = yt.text;
            let si, ci = [0, 0];
            if (Gt) {
              const gi = Gt.toString(), Si = L.get("text-letter-spacing").evaluate(yt, {}, b) * Ns, pi = L.get("text-line-height").evaluate(yt, {}, b) * Ns, zi = nf(gi) ? Si : 0, Gi = L.get("text-anchor").evaluate(yt, {}, b), Oi = L.get("text-variable-anchor");
              if (!Oi) {
                const xr = L.get("text-radial-offset").evaluate(yt, {}, b);
                ci = xr ? j0(Gi, [xr * Ns, Im]) : L.get("text-offset").evaluate(yt, {}, b).map((hr) => hr * Ns);
              }
              let lr = Ee ? "center" : L.get("text-justify").evaluate(yt, {}, b);
              const ar = L.get("symbol-placement") === "point", Qi = ar ? L.get("text-max-width").evaluate(yt, {}, b) * Ns : 1 / 0, qi = (xr) => {
                a.allowVerticalPlacement && Vc(gi) && (ni.vertical = Cm(Gt, e, r, h, Bt, Qi, pi, Gi, xr, zi, ci, Ml.vertical, !0, Dt, zt));
              };
              if (!Ee && Oi) {
                const xr = lr === "auto" ? Oi.map((pr) => Pm(pr)) : [lr];
                let hr = !1;
                for (let pr = 0; pr < xr.length; pr++) {
                  const Ur = xr[pr];
                  if (!ni.horizontal[Ur]) if (hr) ni.horizontal[Ur] = ni.horizontal[0];
                  else {
                    const Xr = Cm(Gt, e, r, h, Bt, Qi, pi, "center", Ur, zi, ci, Ml.horizontal, !1, Dt, zt);
                    Xr && (ni.horizontal[Ur] = Xr, hr = Xr.positionedLines.length === 1);
                  }
                }
                qi("left");
              } else {
                if (lr === "auto" && (lr = Pm(Gi)), ar || L.get("text-writing-mode").indexOf("horizontal") >= 0 || !Vc(gi)) {
                  const xr = Cm(Gt, e, r, h, Bt, Qi, pi, Gi, lr, zi, ci, Ml.horizontal, !1, Dt, zt);
                  xr && (ni.horizontal[lr] = xr);
                }
                qi(ar ? "left" : lr);
              }
            }
            let li = !1;
            if (yt.icon && yt.icon.namePrimary) {
              const gi = bm(a.iconSizeData, F["icon-size"], b, a.zoom, yt) * Y.iconScaleFactor * B, Si = yt.icon.getPrimary().scaleSelf(gi).serialize(), pi = s[Si];
              pi && (si = eb(h[Si], yt.icon.nameSecondary ? h[yt.icon.getSecondary().scaleSelf(gi).serialize()] : void 0, L.get("icon-offset").evaluate(yt, {}, b), L.get("icon-anchor").evaluate(yt, {}, b)), li = pi.sdf, a.sdfIcons === void 0 ? a.sdfIcons = pi.sdf : a.sdfIcons !== pi.sdf && Se("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (pi.pixelRatio !== a.pixelRatio || L.get("icon-rotate").constantOr(1) !== 0) && (a.iconsNeedLinear = !0));
            }
            const fi = H0(ni.horizontal) || ni.vertical;
            a.iconsInText || (a.iconsInText = !!fi && fi.iconsInText), (fi || si) && ob(a, yt, ni, si, s, Y, Dt, 0, ci, li, f, b, H, G, lt);
          }
          o && a.generateCollisionDebugBuffers(O, a.collisionBoxArray, Y.textScaleFactor);
        }, i.e5 = Hp, i.e6 = Qt, i.e7 = kg, i.e8 = b0, i.e9 = N, i.ea = function(a) {
          let e = 0;
          if (new Uint32Array(a, 0, 1)[0] !== h1) {
            const r = new Uint32Array(a, 0, 7), [, , s, h, o, f] = r;
            e = r.byteLength + h + o + f + o, (s !== a.byteLength || e >= a.byteLength) && Se("Invalid b3dm header information.");
          }
          return m1(a, e);
        }, i.eb = function(a, e) {
          const r = g1(a);
          for (const s of r) {
            for (const h of s.meshes) zw(h);
            s.lights && (s.lightMeshIndex = s.meshes.length, s.meshes.push(Bw(s.lights, e)));
          }
          return r;
        }, i.ec = Bp, i.ed = Rv, i.ee = Zs, i.ef = function(a) {
          Bi(), oi != null && oi.then((e) => {
            e.keys().then((r) => {
              for (let s = 0; s < r.length - a; s++) e.delete(r[s]);
            });
          });
        }, i.f = function(a) {
          return a.indexOf("mapbox:") === 0;
        }, i.g = function(a, e) {
          return En(I(a, { method: "GET" }), e);
        }, i.h = Et, i.i = function(a) {
          return $e.API_STYLE_REGEX.test(a) && !Nt(a);
        }, i.j = function(a) {
          return decodeURIComponent(atob(a).split("").map((e) => "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2)).join(""));
        }, i.k = function(a) {
          return btoa(encodeURIComponent(a).replace(/%([0-9A-F]{2})/g, (e, r) => String.fromCharCode(+("0x" + r))));
        }, i.l = I, i.m = nr, i.n = function(a, e) {
          return En(I(a, { type: "json" }), e);
        }, i.o = Ta, i.p = function(a, e) {
          return En(I(a, { method: "POST" }), e);
        }, i.q = Ct, i.r = ds, i.s = function(a) {
          try {
            const e = self[a];
            return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;
          } catch {
            return !1;
          }
        }, i.t = tt, i.u = function() {
          return function a(e) {
            return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, a);
          }();
        }, i.v = function(a) {
          return !!a && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(a);
        }, i.w = Se, i.x = function() {
          return $m || ($m = new Ef()), $m;
        }, i.y = eo, i.z = mn;
      }), q(["./shared"], function(i) {
        function N(Mt) {
          const Ae = Mt ? Mt.url.toString() : void 0;
          return Ae ? performance.getEntriesByName(Ae) : [];
        }
        function Z(Mt) {
          if (typeof Mt == "number" || typeof Mt == "boolean" || typeof Mt == "string" || Mt == null) return JSON.stringify(Mt);
          if (Array.isArray(Mt)) {
            let Fe = "[";
            for (const tt of Mt) Fe += `${Z(tt)},`;
            return `${Fe}]`;
          }
          let Ae = "{";
          for (const Fe of Object.keys(Mt).sort()) Ae += `${Fe}:${Z(Mt[Fe])},`;
          return `${Ae}}`;
        }
        function R(Mt) {
          let Ae = "";
          for (const Fe of i.bm) (Mt.type !== "model" || Fe !== "minzoom" && Fe !== "maxzoom") && (Ae += `/${Z(Mt[Fe])}`);
          return Ae;
        }
        class A {
          constructor(Ae) {
            this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, Ae && this.replace(Ae);
          }
          replace(Ae, Fe) {
            this._layerConfigs = {}, this._layers = {}, this.update(Ae, [], Fe);
          }
          update(Ae, Fe, tt) {
            this._options = tt;
            for (const It of Ae) this._layerConfigs[It.id] = It, (this._layers[It.id] = i.cu(It, this.scope, null, this._options)).compileFilter(tt), this.keyCache[It.id] && delete this.keyCache[It.id];
            for (const It of Fe) delete this.keyCache[It], delete this._layerConfigs[It], delete this._layers[It];
            this.familiesBySource = {};
            const Ct = function(It, Ut) {
              const ti = {};
              for (let Wt = 0; Wt < It.length; Wt++) {
                const ei = It[Wt];
                let oi = Ut && Ut[ei.id];
                !oi && (oi = R(ei), ei.type === "line" && ei.paint) && function Di(Bi) {
                  return typeof Bi == "string" && Bi === "line-progress" || (Array.isArray(Bi) ? Bi.some(Di) : !(!Bi || typeof Bi != "object") && Object.values(Bi).some(Di));
                }(ei.paint["line-width"]) && (oi += `/${Z(ei.paint["line-width"])}`), Ut && (Ut[ei.id] = oi);
                let _i = ti[oi];
                _i || (_i = ti[oi] = []), _i.push(ei);
              }
              const Pt = [];
              for (const Wt in ti) Pt.push(ti[Wt]);
              return Pt;
            }(i.bj(this._layerConfigs), this.keyCache);
            for (const It of Ct) {
              const Ut = It.map((_i) => this._layers[_i.id]), ti = Ut[0];
              if (ti.visibility === "none") continue;
              const Pt = ti.source || "";
              let Wt = this.familiesBySource[Pt];
              Wt || (Wt = this.familiesBySource[Pt] = {});
              const ei = ti.sourceLayer || "_geojsonTileLayer";
              let oi = Wt[ei];
              oi || (oi = Wt[ei] = []), oi.push(Ut);
            }
          }
        }
        const M = 1 * i.dX;
        class x {
          constructor(Ae) {
            const Fe = {}, tt = [];
            for (const ti in Ae) {
              const Pt = Ae[ti], Wt = Fe[ti] = {};
              for (const ei in Pt.glyphs) {
                const oi = Pt.glyphs[+ei];
                if (!oi || oi.bitmap.width === 0 || oi.bitmap.height === 0) continue;
                const _i = oi.metrics.localGlyph ? M : 1, Di = { x: 0, y: 0, w: oi.bitmap.width + 2 * _i, h: oi.bitmap.height + 2 * _i };
                tt.push(Di), Wt[ei] = Di;
              }
            }
            const { w: Ct, h: It } = i.F(tt), Ut = new i.dW({ width: Ct || 1, height: It || 1 });
            for (const ti in Ae) {
              const Pt = Ae[ti];
              for (const Wt in Pt.glyphs) {
                const ei = Pt.glyphs[+Wt];
                if (!ei || ei.bitmap.width === 0 || ei.bitmap.height === 0) continue;
                const oi = Fe[ti][Wt], _i = ei.metrics.localGlyph ? M : 1;
                i.dW.copy(ei.bitmap, Ut, { x: 0, y: 0 }, { x: oi.x + _i, y: oi.y + _i }, ei.bitmap);
              }
            }
            this.image = Ut, this.positions = Fe;
          }
        }
        i.dV(x, "GlyphAtlas");
        const m = "3d_elevation_id", w = "hd_road_elevation";
        class k {
          constructor() {
            this._valid = !1;
          }
          reset(Ae) {
            return this.feature = Ae, this._valid = !0, this._geometry = Ae.loadGeometry(), this._geometry.length !== 0 && this._geometry[0].length !== 0 || (this._valid = !1), this;
          }
          geometry(Ae, Fe) {
            return this._valid && Ae(Fe(this._geometry)), this;
          }
          require(Ae, Fe, tt) {
            return this.get(Ae, !0, Fe, tt);
          }
          optional(Ae, Fe, tt) {
            return this.get(Ae, !1, Fe, tt);
          }
          success() {
            return this._valid;
          }
          get(Ae, Fe, tt, Ct) {
            const It = this.feature.properties.hasOwnProperty(Ae) ? +this.feature.properties[Ae] : void 0;
            return this._valid && It !== void 0 ? tt(Ct ? Ct(It) : It) : Fe && (this._valid = !1), this;
          }
        }
        class E {
          constructor(Ae, Fe) {
            this.featureFunc = Ae, this.vertexFunc = Fe;
          }
          parseFeature(Ae, Fe, tt) {
            return this.featureFunc(Ae, Fe, tt);
          }
          parseVertex(Ae, Fe, tt) {
            return this.vertexFunc(Ae, Fe, tt);
          }
        }
        const P = new E((Mt, Ae, Fe) => Mt.reset(Ae).require(m, (tt) => {
          Fe.id = tt;
        }).optional("fixed_height_relative", (tt) => {
          Fe.constantHeight = tt;
        }, U.decodeRelativeHeight).geometry((tt) => {
          Fe.bounds = tt;
        }, U.computeBounds).success(), (Mt, Ae, Fe) => Mt.reset(Ae).require(m, (tt) => {
          Fe.id = tt;
        }).require("elevation_idx", (tt) => {
          Fe.idx = tt;
        }).require("extent", (tt) => {
          Fe.extent = tt;
        }).require("height_relative", (tt) => {
          Fe.height = tt;
        }, U.decodeRelativeHeight).geometry((tt) => {
          Fe.position = tt;
        }, U.getPoint).success()), S = new E((Mt, Ae, Fe) => Mt.reset(Ae).require(m, (tt) => {
          Fe.id = tt;
        }).optional("fixed_height", (tt) => {
          Fe.constantHeight = tt;
        }, U.decodeMetricHeight).geometry((tt) => {
          Fe.bounds = tt;
        }, U.computeBounds).success(), (Mt, Ae, Fe) => Mt.reset(Ae).require(m, (tt) => {
          Fe.id = tt;
        }).require("elevation_idx", (tt) => {
          Fe.idx = tt;
        }).require("extent", (tt) => {
          Fe.extent = tt;
        }).require("height", (tt) => {
          Fe.height = tt;
        }, U.decodeMetricHeight).geometry((tt) => {
          Fe.position = tt;
        }, U.getPoint).success());
        class U {
          static computeBounds(Ae) {
            const Fe = new i.P(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), tt = new i.P(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
            for (const Ct of Ae[0]) Fe.x > Ct.x && (Fe.x = Ct.x), Fe.y > Ct.y && (Fe.y = Ct.y), tt.x < Ct.x && (tt.x = Ct.x), tt.y < Ct.y && (tt.y = Ct.y);
            return { min: Fe, max: tt };
          }
          static getPoint(Ae) {
            return i.ab.vec2.fromValues(Ae[0][0].x, Ae[0][0].y);
          }
          static decodeRelativeHeight(Ae) {
            return 1e-4 * Ae * 5;
          }
          static decodeMetricHeight(Ae) {
            return 1e-4 * Ae;
          }
          static parse(Ae) {
            const Fe = [], tt = [], Ct = Ae.length, It = new k();
            for (let ti = 0; ti < Ct; ti++) {
              const Pt = Ae.feature(ti), Wt = Pt.properties.hasOwnProperty("version") ? String(Pt.properties.version) : void 0, ei = (Ut = Wt) ? Ut === "1.0.1" ? S : void 0 : P;
              if (ei === void 0) {
                i.w(`Unknown elevation feature version number ${Wt || "(unknown)"}`);
                continue;
              }
              const oi = Pt.properties.hasOwnProperty("type") ? Pt.properties.type : void 0;
              if (oi) {
                if (i.dY.VectorTileFeature.types[Pt.type] === "Point" && oi === "curve_point") {
                  const _i = {};
                  ei.parseVertex(It, Pt, _i) && Fe.push(_i);
                } else if (i.dY.VectorTileFeature.types[Pt.type] === "Polygon" && oi === "curve_meta") {
                  const _i = {};
                  ei.parseFeature(It, Pt, _i) && tt.push(_i);
                }
              }
            }
            var Ut;
            return { vertices: Fe, features: tt };
          }
        }
        class j {
          constructor(Ae, Fe, tt, Ct, It, Ut) {
            if (this.vertices = new Array(), this.vertexProps = new Array(), this.edges = new Array(), this.edgeProps = new Array(), this.id = Ae, this.heightRange = { min: tt, max: tt }, this.safeArea = Fe, this.constantHeight = tt, this.constantHeight == null && (this.constantHeight != null || Ct.length !== 0)) {
              this.vertices = Ct, this.edges = It, this.edges = this.edges.filter((ti) => ti.a < this.vertices.length && ti.b < this.vertices.length && !i.ab.vec2.exactEquals(this.vertices[ti.a].position, this.vertices[ti.b].position)), this.heightRange = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
              for (const ti of this.vertices) this.vertexProps.push({ dir: i.ab.vec2.fromValues(0, 0) }), this.heightRange.min = Math.min(this.heightRange.min, ti.height), this.heightRange.max = Math.max(this.heightRange.max, ti.height);
              for (const ti of this.edges) {
                const Pt = this.vertices[ti.a].position, Wt = this.vertices[ti.b].position, ei = i.ab.vec2.subtract(i.ab.vec2.create(), Wt, Pt), oi = i.ab.vec2.length(ei), _i = i.ab.vec2.scale(i.ab.vec2.create(), ei, 1 / oi);
                this.edgeProps.push({ vec: ei, dir: _i, len: oi });
                const Di = this.vertexProps[ti.a].dir, Bi = this.vertexProps[ti.b].dir;
                i.ab.vec2.add(Di, Di, _i), i.ab.vec2.add(Bi, Bi, _i);
              }
              for (const ti of this.vertexProps) ti.dir[0] === 0 && ti.dir[1] === 0 || i.ab.vec2.normalize(ti.dir, ti.dir);
              this.tessellate(Ut);
            }
          }
          pointElevation(Ae) {
            if (this.constantHeight != null) return this.constantHeight;
            const Fe = this.getClosestEdge(Ae);
            if (Fe == null) return 0;
            const [tt, Ct] = Fe;
            return (1 - (It = Ct)) * this.vertices[this.edges[tt].a].height + It * this.vertices[this.edges[tt].b].height;
            var It;
          }
          getClosestEdge(Ae) {
            if (this.edges.length === 0) return;
            let Fe = 0, tt = Number.POSITIVE_INFINITY, Ct = 0;
            const It = i.ab.vec2.fromValues(Ae.x, Ae.y);
            for (let Ut = 0; Ut < this.edges.length; Ut++) {
              const ti = this.edges[Ut], Pt = this.edgeProps[Ut].dir, Wt = new i.dZ(It, this.edgeProps[Ut].dir), ei = this.vertices[ti.a].position, oi = this.vertices[ti.b].position, _i = i.ab.vec2.create(), Di = i.ab.vec2.create(), Bi = Wt.intersectsPlane(ei, this.vertexProps[ti.a].dir, _i), Hi = Wt.intersectsPlane(oi, this.vertexProps[ti.b].dir, Di);
              if (!Bi || !Hi) continue;
              const nr = i.ab.vec2.subtract(i.ab.vec2.create(), Di, _i), rr = i.ab.vec2.subtract(i.ab.vec2.create(), It, _i), dr = i.ab.vec2.dot(nr, nr), Rr = dr > 0 ? i.ab.vec2.dot(rr, nr) / dr : 0, Br = i.aw(Rr, 0, 1), Ki = Math.abs((Rr - Br) * this.edgeProps[Ut].len), Ir = i.ab.vec2.subtract(i.ab.vec2.create(), It, ei), Mr = Ki + Math.abs(i.ab.vec2.dot(Ir, i.ab.vec2.fromValues(Pt[1], -Pt[0])));
              Mr < tt && (Fe = Ut, tt = Mr, Ct = Br);
            }
            return [Fe, Ct];
          }
          tessellate(Ae) {
            for (let Fe = this.edges.length - 1; Fe >= 0; --Fe) {
              const tt = this.edges[Fe].a, Ct = this.edges[Fe].b, { position: It, height: Ut, extent: ti } = this.vertices[tt], { position: Pt, height: Wt, extent: ei } = this.vertices[Ct], oi = this.vertexProps[tt].dir, _i = this.vertexProps[Ct].dir, Di = i.ab.vec3.fromValues(It[0] / Ae, It[1] / Ae, Ut), Bi = i.ab.vec3.fromValues(Pt[0] / Ae, Pt[1] / Ae, Wt), Hi = i.ab.vec3.fromValues(oi[1], -oi[0], 0);
              i.ab.vec3.scale(Hi, Hi, ti);
              const nr = i.ab.vec3.fromValues(_i[1], -_i[0], 0);
              if (i.ab.vec3.scale(nr, nr, ei), this.distSqLines(i.ab.vec3.fromValues(Di[0] + 0.5 * Hi[0], Di[1] + 0.5 * Hi[1], Di[2] + 0.5 * Hi[2]), i.ab.vec3.fromValues(Bi[0] - 0.5 * nr[0], Bi[1] - 0.5 * nr[1], Bi[2] - 0.5 * nr[2]), i.ab.vec3.fromValues(Di[0] - 0.5 * Hi[0], Di[1] - 0.5 * Hi[1], Di[2] - 0.5 * Hi[2]), i.ab.vec3.fromValues(Bi[0] + 0.5 * nr[0], Bi[1] + 0.5 * nr[1], Bi[2] + 0.5 * nr[2])) <= 0.05 * 0.05) continue;
              const rr = this.vertices.length, dr = i.ab.vec2.add(i.ab.vec2.create(), It, Pt);
              this.vertices.push({ position: i.ab.vec2.scale(dr, dr, 0.5), height: 0.5 * (Ut + Wt), extent: 0.5 * (ti + ei) });
              const Rr = i.ab.vec2.add(i.ab.vec2.create(), oi, _i);
              this.vertexProps.push({ dir: i.ab.vec2.normalize(Rr, Rr) }), this.edges.splice(Fe, 1), this.edgeProps.splice(Fe, 1), this.edges.push({ a: tt, b: rr }), this.edges.push({ a: rr, b: Ct });
              const Br = i.ab.vec2.subtract(i.ab.vec2.create(), this.vertices[rr].position, It), Ki = i.ab.vec2.length(Br), Ir = { vec: Br, dir: i.ab.vec2.scale(i.ab.vec2.create(), Br, 1 / Ki), len: Ki };
              this.edgeProps.push(Ir), this.edgeProps.push(Ir);
            }
          }
          distSqLines(Ae, Fe, tt, Ct) {
            const It = i.ab.vec3.subtract(i.ab.vec3.create(), Fe, Ae), Ut = i.ab.vec3.subtract(i.ab.vec3.create(), Ct, tt), ti = i.ab.vec3.subtract(i.ab.vec3.create(), Ae, tt), Pt = i.ab.vec3.dot(It, It), Wt = i.ab.vec3.dot(It, Ut), ei = i.ab.vec3.dot(It, ti), oi = i.ab.vec3.dot(Ut, Ut), _i = i.ab.vec3.dot(Ut, ti), Di = Pt * oi - Wt * Wt;
            if (Di === 0) {
              const dr = i.ab.vec3.dot(ti, Ut) / i.ab.vec3.dot(Ut, Ut), Rr = i.ab.vec3.lerp(i.ab.vec3.create(), tt, Ct, dr);
              return i.ab.vec3.squaredDistance(Rr, Ae);
            }
            const Bi = (Wt * _i - ei * oi) / Di, Hi = (Pt * _i - Wt * ei) / Di, nr = i.ab.vec3.lerp(i.ab.vec3.create(), Ae, Fe, Bi), rr = i.ab.vec3.lerp(i.ab.vec3.create(), tt, Ct, Hi);
            return i.ab.vec3.squaredDistance(nr, rr);
          }
        }
        class T {
          static parseFrom(Ae, Fe) {
            const tt = U.parse(Ae);
            if (!tt) return [];
            let { vertices: Ct, features: It } = tt;
            const Ut = 1 / i.cc(Fe);
            It.sort((ei, oi) => ei.id - oi.id), Ct.sort((ei, oi) => ei.id - oi.id || ei.idx - oi.idx), Ct = Ct.filter((ei, oi, _i) => oi === _i.findIndex((Di) => Di.id === ei.id && Di.idx === ei.idx));
            const ti = new Array();
            let Pt = 0;
            const Wt = Ct.length;
            for (const ei of It) {
              if (ei.constantHeight) {
                ti.push(new j(ei.id, ei.bounds, ei.constantHeight));
                continue;
              }
              for (; Pt !== Wt && Ct[Pt].id < ei.id; ) Pt++;
              if (Pt === Wt || Ct[Pt].id !== ei.id) continue;
              const oi = new Array(), _i = new Array(), Di = Pt;
              for (; Pt !== Wt && Ct[Pt].id === ei.id; ) {
                const Bi = Ct[Pt];
                if (oi.push({ position: Bi.position, height: Bi.height, extent: Bi.extent }), Pt !== Di && Ct[Pt - 1].idx === Bi.idx - 1) {
                  const Hi = Pt - Di;
                  _i.push({ a: Hi - 1, b: Hi });
                }
                Pt++;
              }
              ti.push(new j(ei.id, ei.bounds, void 0, oi, _i, Ut));
            }
            return ti;
          }
        }
        i.dV(j, "ElevationFeature");
        class W {
          constructor(Ae) {
            this.tileID = new i.aG(Ae.tileID.overscaledZ, Ae.tileID.wrap, Ae.tileID.canonical.z, Ae.tileID.canonical.x, Ae.tileID.canonical.y), this.tileZoom = Ae.tileZoom, this.uid = Ae.uid, this.zoom = Ae.zoom, this.lut = Ae.lut, this.canonical = Ae.tileID.canonical, this.pixelRatio = Ae.pixelRatio, this.tileSize = Ae.tileSize, this.source = Ae.source, this.scope = Ae.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = Ae.showCollisionBoxes, this.collectResourceTiming = !!Ae.request && Ae.request.collectResourceTiming, this.promoteId = Ae.promoteId, this.isSymbolTile = Ae.isSymbolTile, this.tileTransform = i.aQ(Ae.tileID.canonical, Ae.projection), this.projection = Ae.projection, this.worldview = Ae.worldview, this.localizableLayerIds = Ae.localizableLayerIds, this.brightness = Ae.brightness, this.extraShadowCaster = !!Ae.extraShadowCaster, this.tessellationStep = Ae.tessellationStep, this.scaleFactor = Ae.scaleFactor;
          }
          parse(Ae, Fe, tt, Ct, It) {
            this.status = "parsing", this.data = Ae, this.collisionBoxArray = new i.aW();
            const Ut = new i.d_(Object.keys(Ae.layers).sort()), ti = new i.d$(this.tileID, this.promoteId);
            ti.bucketLayerIDs = [];
            const Pt = {}, Wt = new i.e0(256, 256), ei = { featureIndex: ti, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: Wt, availableImages: tt, brightness: this.brightness, scaleFactor: this.scaleFactor, elevationFeatures: void 0 }, oi = Fe.familiesBySource[this.source];
            for (const dr in oi) {
              const Rr = Ae.layers[dr];
              if (!Rr) continue;
              let Br = !1, Ki = !1, Ir = !1;
              for (const En of oi[dr]) En[0].type === "symbol" ? Br = !0 : Ki = !0, En[0].is3D() && En[0].type !== "model" && (Ir = !0);
              if (this.extraShadowCaster && !Ir || this.isSymbolTile === !0 && !Br || this.isSymbolTile === !1 && !Ki) continue;
              Rr.version === 1 && i.w(`Vector tile source "${this.source}" layer "${dr}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const Mr = Ut.encode(dr), wn = [];
              let xn = !1;
              for (let En = 0, Vn = 0; En < Rr.length; En++) {
                const Yn = Rr.feature(En), ka = ti.getId(Yn, dr);
                if (this.localizableLayerIds && this.localizableLayerIds.has(dr)) {
                  const ea = Yn.properties ? Yn.properties.worldview : null;
                  if (this.worldview && typeof ea == "string") if (ea === "all") Yn.properties.$localized = !0;
                  else {
                    if (!ea.split(",").includes(this.worldview)) continue;
                    Yn.properties.$localized = !0, Yn.properties.worldview = this.worldview;
                  }
                }
                !xn && Yn.properties && Yn.properties.hasOwnProperty(m) && (xn = !0), wn.push({ feature: Yn, id: ka, index: Vn, sourceLayerIndex: Mr }), Vn++;
              }
              xn && Ae.layers.hasOwnProperty(w) && (ei.elevationFeatures = T.parseFrom(Ae.layers[w], this.canonical));
              for (const En of oi[dr]) {
                const Vn = En[0];
                (!this.extraShadowCaster || Vn.is3D() && Vn.type !== "model") && (this.isSymbolTile !== void 0 && Vn.type === "symbol" !== this.isSymbolTile || Vn.minzoom && this.zoom < Math.floor(Vn.minzoom) || Vn.maxzoom && this.zoom >= Vn.maxzoom || Vn.visibility !== "none" && (J(En, this.zoom, ei.brightness, tt), (Pt[Vn.id] = Vn.createBucket({ index: ti.bucketLayerIDs.length, layers: En, zoom: this.zoom, lut: this.lut, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Mr, sourceID: this.source, projection: this.projection.spec, tessellationStep: this.tessellationStep })).populate(wn, ei, this.tileID.canonical, this.tileTransform), ti.bucketLayerIDs.push(En.map((Yn) => i.aC(Yn.id, Yn.scope)))));
              }
            }
            let _i, Di, Bi, Hi;
            Wt.trim();
            const nr = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, rr = () => {
              if (_i) return this.status = "done", It(_i);
              if (this.extraShadowCaster) this.status = "done", It(null, { buckets: i.bj(Pt).filter((dr) => !dr.isEmpty()), featureIndex: ti, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: ei.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
              else if (Di && Bi && Hi) {
                const dr = new x(Di), Rr = new i.e3(Bi, Hi, this.lut);
                for (const Br in Pt) {
                  const Ki = Pt[Br];
                  Ki instanceof i.aX ? (J(Ki.layers, this.zoom, ei.brightness, tt), i.e4(Ki, Di, dr.positions, Bi, Rr.iconPositions, this.showCollisionBoxes, tt, this.tileID.canonical, this.tileZoom, this.projection, this.scaleFactor, this.pixelRatio, this.brightness)) : Ki.hasPattern && (Ki instanceof i.b1 || Ki instanceof i.b2 || Ki instanceof i.d5) && (J(Ki.layers, this.zoom, ei.brightness, tt), Ki.addFeatures(ei, this.tileID.canonical, Rr.patternPositions, tt, this.tileTransform, this.brightness));
                }
                this.status = "done", It(null, { buckets: i.bj(Pt).filter((Br) => !Br.isEmpty()), featureIndex: ti, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: dr.image, lineAtlas: Wt, imageAtlas: Rr, brightness: ei.brightness });
              }
            };
            if (!this.extraShadowCaster) {
              const dr = i.e1(ei.glyphDependencies, (Ki) => Object.keys(Ki).map(Number));
              Object.keys(dr).length ? Ct.send("getGlyphs", { uid: this.uid, stacks: dr, scope: this.scope }, (Ki, Ir) => {
                _i || (_i = Ki, Di = Ir, rr());
              }, void 0, !1, nr) : Di = {};
              const Rr = Object.keys(ei.iconDependencies);
              Rr.length ? Ct.send("getImages", { icons: Rr, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (Ki, Ir) => {
                if (_i) return;
                _i = Ki;
                const Mr = {};
                Object.values(Ir).some((wn) => wn.usvg) ? this.rasterize(Ct, Mr, Ir, ei.iconDependencies, () => {
                  Bi = Mr, rr();
                }) : (this.fillImageMap(Mr, ei.iconDependencies, Ir), Bi = Mr, rr());
              }, void 0, !1, nr) : Bi = {};
              const Br = Object.keys(ei.patternDependencies);
              Br.length ? Ct.send("getImages", { icons: Br, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (Ki, Ir) => {
                if (!_i) {
                  _i = Ki;
                  const Mr = {};
                  Object.values(Ir).some((wn) => wn.usvg) ? this.rasterize(Ct, Mr, Ir, ei.patternDependencies, () => {
                    Hi = Mr, rr();
                  }) : (this.fillImageMap(Mr, ei.patternDependencies, Ir), Hi = Mr, rr());
                }
              }, void 0, !1, nr) : Hi = {};
            }
            rr();
          }
          fillImageMap(Ae, Fe, tt) {
            for (const Ct in tt) {
              const It = Fe[Ct] || [];
              for (const Ut of It) tt[Ut.id].usvg || (Ae[Ut.serialize()] = tt[Ut.id]);
            }
          }
          getImageTaskQueue(Ae, Fe, tt) {
            const Ct = {};
            for (const It in Fe) {
              const Ut = tt[It] || [];
              for (const ti of Ut) {
                const Pt = ti.serialize();
                Fe[ti.id].usvg ? Ct[Pt] || (Ct[Pt] = ti) : Ae[Pt] = Fe[ti.id];
              }
            }
            return Ct;
          }
          rasterize(Ae, Fe, tt, Ct, It) {
            const Ut = this.getImageTaskQueue(Fe, tt, Ct);
            this.rasterizeTask = Ae.send("rasterizeImages", { scope: this.scope, imageTasks: Ut }, (ti, Pt) => {
              if (!ti) for (const Wt in Pt) {
                const { id: ei } = i.e2.deserializeFromString(Wt);
                Fe[Wt] = Object.assign({}, tt[ei], { data: Pt[Wt] });
              }
              It();
            });
          }
          cancelRasterize() {
            this.rasterizeTask && this.rasterizeTask.cancel();
          }
        }
        function J(Mt, Ae, Fe, tt) {
          const Ct = new i.a8(Ae, { brightness: Fe });
          for (const It of Mt) It.recalculate(Ct, tt);
        }
        class ee extends i.E {
          constructor(Ae, Fe, tt, Ct, It, Ut) {
            super(), this.actor = Ae, this.layerIndex = Fe, this.availableImages = tt, this.loadVectorData = It || i.aD, this.loading = {}, this.loaded = {}, this.deduped = new i.aB(Ae.scheduler), this.isSpriteLoaded = Ct, this.scheduler = Ae.scheduler, this.brightness = Ut;
          }
          loadTile(Ae, Fe) {
            const tt = Ae.uid, Ct = Ae && Ae.request, It = Ct && Ct.collectResourceTiming, Ut = this.loading[tt] = new W(Ae);
            Ut.abort = this.loadVectorData(Ae, (ti, Pt) => {
              const Wt = !this.loading[tt];
              if (delete this.loading[tt], Ut.cancelRasterize(), Wt || ti || !Pt) return Ut.status = "done", Wt || (this.loaded[tt] = Ut), Fe(ti);
              const ei = Pt.rawData, oi = {};
              Pt.expires && (oi.expires = Pt.expires), Pt.cacheControl && (oi.cacheControl = Pt.cacheControl), Ut.vectorTile = Pt.vectorTile || new i.dY.VectorTile(new i.bh(ei));
              const _i = () => {
                Ut.parse(Ut.vectorTile, this.layerIndex, this.availableImages, this.actor, (Di, Bi) => {
                  if (Di || !Bi) return Fe(Di);
                  const Hi = {};
                  if (It) {
                    const nr = N(Ct);
                    nr.length > 0 && (Hi.resourceTiming = JSON.parse(JSON.stringify(nr)));
                  }
                  Fe(null, i.l({ rawTileData: ei.slice(0) }, Bi, oi, Hi));
                });
              };
              this.isSpriteLoaded ? _i() : this.once("isSpriteLoaded", () => {
                this.scheduler ? this.scheduler.add(_i, { type: "parseTile", isSymbolTile: Ae.isSymbolTile, zoom: Ae.tileZoom }) : _i();
              }), this.loaded = this.loaded || {}, this.loaded[tt] = Ut;
            });
          }
          reloadTile(Ae, Fe) {
            const tt = this.loaded, Ct = Ae.uid;
            if (tt && tt[Ct]) {
              const It = tt[Ct];
              It.scaleFactor = Ae.scaleFactor, It.showCollisionBoxes = Ae.showCollisionBoxes, It.projection = Ae.projection, It.brightness = Ae.brightness, It.tileTransform = i.aQ(Ae.tileID.canonical, Ae.projection), It.extraShadowCaster = Ae.extraShadowCaster, It.lut = Ae.lut;
              const Ut = (ti, Pt) => {
                const Wt = It.reloadCallback;
                Wt && (delete It.reloadCallback, It.parse(It.vectorTile, this.layerIndex, this.availableImages, this.actor, Wt)), Fe(ti, Pt);
              };
              It.status === "parsing" ? It.reloadCallback = Ut : It.status === "done" && (It.vectorTile ? It.parse(It.vectorTile, this.layerIndex, this.availableImages, this.actor, Ut) : Ut());
            } else Fe(null, void 0);
          }
          abortTile(Ae, Fe) {
            const tt = Ae.uid, Ct = this.loading[tt];
            Ct && (Ct.abort && Ct.abort(), delete this.loading[tt]), Fe();
          }
          removeTile(Ae, Fe) {
            const tt = this.loaded, Ct = Ae.uid;
            tt && tt[Ct] && delete tt[Ct], Fe();
          }
        }
        class te {
          loadTile(Ae, Fe) {
            const { uid: tt, encoding: Ct, rawImageData: It, padding: Ut } = Ae, ti = ImageBitmap && It instanceof ImageBitmap ? this.getImageData(It, Ut) : It;
            Fe(null, new i.e5(tt, ti, Ct, Ut < 1));
          }
          getImageData(Ae, Fe) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(Ae.width, Ae.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: !0 })), this.offscreenCanvas.width = Ae.width, this.offscreenCanvas.height = Ae.height, this.offscreenCanvasContext.drawImage(Ae, 0, 0, Ae.width, Ae.height);
            const tt = this.offscreenCanvasContext.getImageData(-Fe, -Fe, Ae.width + 2 * Fe, Ae.height + 2 * Fe);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), tt;
          }
        }
        i.bg.setPbf(i.bh);
        class le {
          decodeRasterArray({ task: Ae, buffer: Fe }, tt) {
            i.bg.performDecoding(Fe, Ae).then((Ct) => {
              tt(null, Ct);
            }, (Ct) => {
              tt(Ct);
            });
          }
        }
        const me = i.dY.VectorTileFeature.prototype.toGeoJSON;
        class ke {
          constructor(Ae) {
            this._feature = Ae, this.extent = i.ag, this.type = Ae.type, this.properties = Ae.tags, "id" in Ae && !isNaN(Ae.id) && (this.id = parseInt(Ae.id, 10));
          }
          loadGeometry() {
            if (this._feature.type === 1) {
              const Ae = [];
              for (const Fe of this._feature.geometry) Ae.push([new i.P(Fe[0], Fe[1])]);
              return Ae;
            }
            {
              const Ae = [];
              for (const Fe of this._feature.geometry) {
                const tt = [];
                for (const Ct of Fe) tt.push(new i.P(Ct[0], Ct[1]));
                Ae.push(tt);
              }
              return Ae;
            }
          }
          toGeoJSON(Ae, Fe, tt) {
            return me.call(this, Ae, Fe, tt);
          }
        }
        class ge {
          constructor(Ae) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = i.ag, this.length = Ae.length, this._features = Ae;
          }
          feature(Ae) {
            return new ke(this._features[Ae]);
          }
        }
        const Ve = 64 / 4096, Oe = 128;
        class Ue {
          constructor() {
            this.features = /* @__PURE__ */ new Map();
          }
          clear() {
            this.features.clear();
          }
          load(Ae = [], Fe) {
            for (const tt of Ae) {
              const Ct = tt.id;
              if (Ct == null) continue;
              let It = this.features.get(Ct);
              It && this.updateCache(It, Fe), tt.geometry ? (It = Ce(tt), this.updateCache(It, Fe), this.features.set(Ct, It)) : this.features.delete(Ct), this.updateCache(It, Fe);
            }
          }
          updateCache(Ae, Fe) {
            for (const { canonical: tt, uid: Ct } of Object.values(Fe)) {
              const { z: It, x: Ut, y: ti } = tt;
              we(Ae, Math.pow(2, It), Ut, ti) && delete Fe[Ct];
            }
          }
          getTile(Ae, Fe, tt) {
            const Ct = Math.pow(2, Ae), It = [];
            for (const Ut of this.features.values()) we(Ut, Ct, Fe, tt) && It.push(pt(Ut, Ct, Fe, tt));
            return { features: It };
          }
          getFeatures() {
            return [...this.features.values()];
          }
        }
        function we({ minX: Mt, minY: Ae, maxX: Fe, maxY: tt }, Ct, It, Ut) {
          return Mt < (It + 1 + Ve) / Ct && Ae < (Ut + 1 + Ve) / Ct && Fe > (It - Ve) / Ct && tt > (Ut - Ve) / Ct;
        }
        function Ce(Mt) {
          const { id: Ae, geometry: Fe, properties: tt } = Mt;
          if (!Fe) return;
          if (Fe.type === "GeometryCollection") throw new Error("GeometryCollection not supported in dynamic mode.");
          const { type: Ct, coordinates: It } = Fe, Ut = { id: Ae, type: 1, geometry: [], tags: tt, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }, ti = Ut.geometry;
          if (Ct === "Point") it(It, ti, Ut);
          else if (Ct === "MultiPoint") for (const Pt of It) it(Pt, ti, Ut);
          else if (Ct === "LineString") Ut.type = 2, ut(It, ti, Ut);
          else if (Ct === "MultiLineString") Ut.type = 2, bt(It, ti, Ut);
          else if (Ct === "Polygon") Ut.type = 3, bt(It, ti, Ut, !0);
          else {
            if (Ct !== "MultiPolygon") throw new Error("Input data is not a valid GeoJSON object.");
            Ut.type = 3;
            for (const Pt of It) bt(Pt, ti, Ut, !0);
          }
          return Ut;
        }
        function it([Mt, Ae], Fe, tt) {
          const Ct = i.at(Mt);
          let It = i.aA(Ae);
          It = It < 0 ? 0 : It > 1 ? 1 : It, Fe.push(Ct, It), tt.minX = Math.min(tt.minX, Ct), tt.minY = Math.min(tt.minY, It), tt.maxX = Math.max(tt.maxX, Ct), tt.maxY = Math.max(tt.maxY, It);
        }
        function ut(Mt, Ae, Fe, tt = !1, Ct = !1) {
          const It = [];
          for (const Ut of Mt) it(Ut, It, Fe);
          Ae.push(It), tt && function(Ut, ti) {
            let Pt = 0;
            for (let Wt = 0, ei = Ut.length, oi = ei - 2; Wt < ei; oi = Wt, Wt += 2) Pt += (Ut[Wt] - Ut[oi]) * (Ut[Wt + 1] + Ut[oi + 1]);
            if (Pt > 0 === ti) for (let Wt = 0, ei = Ut.length; Wt < ei / 2; Wt += 2) {
              const oi = Ut[Wt], _i = Ut[Wt + 1];
              Ut[Wt] = Ut[ei - 2 - Wt], Ut[Wt + 1] = Ut[ei - 1 - Wt], Ut[ei - 2 - Wt] = oi, Ut[ei - 1 - Wt] = _i;
            }
          }(It, Ct);
        }
        function bt(Mt, Ae, Fe, tt = !1) {
          for (let Ct = 0; Ct < Mt.length; Ct++) ut(Mt[Ct], Ae, Fe, tt, Ct === 0);
        }
        function pt(Mt, Ae, Fe, tt) {
          const { id: Ct, type: It, geometry: Ut, tags: ti } = Mt, Pt = [];
          if (It === 1) (function(Wt, ei, oi, _i, Di) {
            for (let Bi = 0; Bi < Wt.length; Bi += 2) {
              const Hi = Math.round(i.ag * (Wt[Bi + 0] * ei - oi)), nr = Math.round(i.ag * (Wt[Bi + 1] * ei - _i));
              Di.push([Hi, nr]);
            }
          })(Ut, Ae, Fe, tt, Pt);
          else for (const Wt of Ut) Ke(Wt, Ae, Fe, tt, Pt);
          return { id: Ct, type: It, geometry: Pt, tags: ti };
        }
        function Ke(Mt, Ae, Fe, tt, Ct) {
          const It = -Oe, Ut = i.ag + Oe;
          let ti;
          for (let Pt = 0; Pt < Mt.length - 2; Pt += 2) {
            let Wt = Math.round(i.ag * (Mt[Pt + 0] * Ae - Fe)), ei = Math.round(i.ag * (Mt[Pt + 1] * Ae - tt)), oi = Math.round(i.ag * (Mt[Pt + 2] * Ae - Fe)), _i = Math.round(i.ag * (Mt[Pt + 3] * Ae - tt));
            const Di = oi - Wt, Bi = _i - ei;
            Wt < It && oi < It || (Wt < It ? (ei += Math.round(Bi * ((It - Wt) / Di)), Wt = It) : oi < It && (_i = ei + Math.round(Bi * ((It - Wt) / Di)), oi = It), ei < It && _i < It || (ei < It ? (Wt += Math.round(Di * ((It - ei) / Bi)), ei = It) : _i < It && (oi = Wt + Math.round(Di * ((It - ei) / Bi)), _i = It), Wt >= Ut && oi >= Ut || (Wt >= Ut ? (ei += Math.round(Bi * ((Ut - Wt) / Di)), Wt = Ut) : oi >= Ut && (_i = ei + Math.round(Bi * ((Ut - Wt) / Di)), oi = Ut), ei >= Ut && _i >= Ut || (ei >= Ut ? (Wt += Math.round(Di * ((Ut - ei) / Bi)), ei = Ut) : _i >= Ut && (oi = Wt + Math.round(Di * ((Ut - ei) / Bi)), _i = Ut), ti && Wt === ti[ti.length - 1][0] && ei === ti[ti.length - 1][1] || (ti = [[Wt, ei]], Ct.push(ti)), ti.push([oi, _i])))));
          }
        }
        var dt, ct, wt, Ht = { exports: {} }, $t = function() {
          if (wt) return Ht.exports;
          wt = 1;
          var Mt = i.e8(), Ae = function() {
            if (ct) return dt;
            ct = 1;
            var ei = i.e6(), oi = i.e7().VectorTileFeature;
            function _i(Bi, Hi) {
              this.options = Hi || {}, this.features = Bi, this.length = Bi.length;
            }
            function Di(Bi, Hi) {
              this.id = typeof Bi.id == "number" ? Bi.id : void 0, this.type = Bi.type, this.rawGeometry = Bi.type === 1 ? [Bi.geometry] : Bi.geometry, this.properties = Bi.tags, this.extent = Hi || 4096;
            }
            return dt = _i, _i.prototype.feature = function(Bi) {
              return new Di(this.features[Bi], this.options.extent);
            }, Di.prototype.loadGeometry = function() {
              var Bi = this.rawGeometry;
              this.geometry = [];
              for (var Hi = 0; Hi < Bi.length; Hi++) {
                for (var nr = Bi[Hi], rr = [], dr = 0; dr < nr.length; dr++) rr.push(new ei(nr[dr][0], nr[dr][1]));
                this.geometry.push(rr);
              }
              return this.geometry;
            }, Di.prototype.bbox = function() {
              this.geometry || this.loadGeometry();
              for (var Bi = this.geometry, Hi = 1 / 0, nr = -1 / 0, rr = 1 / 0, dr = -1 / 0, Rr = 0; Rr < Bi.length; Rr++) for (var Br = Bi[Rr], Ki = 0; Ki < Br.length; Ki++) {
                var Ir = Br[Ki];
                Hi = Math.min(Hi, Ir.x), nr = Math.max(nr, Ir.x), rr = Math.min(rr, Ir.y), dr = Math.max(dr, Ir.y);
              }
              return [Hi, rr, nr, dr];
            }, Di.prototype.toGeoJSON = oi.prototype.toGeoJSON, dt;
          }();
          function Fe(ei) {
            var oi = new Mt();
            return function(_i, Di) {
              for (var Bi in _i.layers) Di.writeMessage(3, tt, _i.layers[Bi]);
            }(ei, oi), oi.finish();
          }
          function tt(ei, oi) {
            var _i;
            oi.writeVarintField(15, ei.version || 1), oi.writeStringField(1, ei.name || ""), oi.writeVarintField(5, ei.extent || 4096);
            var Di = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (_i = 0; _i < ei.length; _i++) Di.feature = ei.feature(_i), oi.writeMessage(2, Ct, Di);
            var Bi = Di.keys;
            for (_i = 0; _i < Bi.length; _i++) oi.writeStringField(3, Bi[_i]);
            var Hi = Di.values;
            for (_i = 0; _i < Hi.length; _i++) oi.writeMessage(4, Wt, Hi[_i]);
          }
          function Ct(ei, oi) {
            var _i = ei.feature;
            _i.id !== void 0 && oi.writeVarintField(1, _i.id), oi.writeMessage(2, It, ei), oi.writeVarintField(3, _i.type), oi.writeMessage(4, Pt, _i);
          }
          function It(ei, oi) {
            var _i = ei.feature, Di = ei.keys, Bi = ei.values, Hi = ei.keycache, nr = ei.valuecache;
            for (var rr in _i.properties) {
              var dr = _i.properties[rr], Rr = Hi[rr];
              if (dr !== null) {
                Rr === void 0 && (Di.push(rr), Hi[rr] = Rr = Di.length - 1), oi.writeVarint(Rr);
                var Br = typeof dr;
                Br !== "string" && Br !== "boolean" && Br !== "number" && (dr = JSON.stringify(dr));
                var Ki = Br + ":" + dr, Ir = nr[Ki];
                Ir === void 0 && (Bi.push(dr), nr[Ki] = Ir = Bi.length - 1), oi.writeVarint(Ir);
              }
            }
          }
          function Ut(ei, oi) {
            return (oi << 3) + (7 & ei);
          }
          function ti(ei) {
            return ei << 1 ^ ei >> 31;
          }
          function Pt(ei, oi) {
            for (var _i = ei.loadGeometry(), Di = ei.type, Bi = 0, Hi = 0, nr = _i.length, rr = 0; rr < nr; rr++) {
              var dr = _i[rr], Rr = 1;
              Di === 1 && (Rr = dr.length), oi.writeVarint(Ut(1, Rr));
              for (var Br = Di === 3 ? dr.length - 1 : dr.length, Ki = 0; Ki < Br; Ki++) {
                Ki === 1 && Di !== 1 && oi.writeVarint(Ut(2, Br - 1));
                var Ir = dr[Ki].x - Bi, Mr = dr[Ki].y - Hi;
                oi.writeVarint(ti(Ir)), oi.writeVarint(ti(Mr)), Bi += Ir, Hi += Mr;
              }
              Di === 3 && oi.writeVarint(Ut(7, 1));
            }
          }
          function Wt(ei, oi) {
            var _i = typeof ei;
            _i === "string" ? oi.writeStringField(1, ei) : _i === "boolean" ? oi.writeBooleanField(7, ei) : _i === "number" && (ei % 1 != 0 ? oi.writeDoubleField(3, ei) : ei < 0 ? oi.writeSVarintField(6, ei) : oi.writeVarintField(5, ei));
          }
          return Ht.exports = Fe, Ht.exports.fromVectorTileJs = Fe, Ht.exports.fromGeojsonVt = function(ei, oi) {
            oi = oi || {};
            var _i = {};
            for (var Di in ei) _i[Di] = new Ae(ei[Di].features, oi), _i[Di].name = Di, _i[Di].version = oi.version, _i[Di].extent = oi.extent;
            return Fe({ layers: _i });
          }, Ht.exports.GeoJSONWrapper = Ae, Ht.exports;
        }(), rt = i.e9($t);
        const ri = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (Mt) => Mt }, wi = Math.fround || (Qt = new Float32Array(1), (Mt) => (Qt[0] = +Mt, Qt[0]));
        var Qt;
        const At = 3, St = 5, Lt = 6;
        class kt {
          constructor(Ae) {
            this.options = Object.assign(Object.create(ri), Ae), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(Ae) {
            const { log: Fe, minZoom: tt, maxZoom: Ct } = this.options;
            Fe && console.time("total time");
            const It = `prepare ${Ae.length} points`;
            Fe && console.time(It), this.points = Ae;
            const Ut = [];
            for (let Pt = 0; Pt < Ae.length; Pt++) {
              const Wt = Ae[Pt];
              if (!Wt.geometry) continue;
              const [ei, oi] = Wt.geometry.coordinates, _i = wi(Re(ei)), Di = wi(_t(oi));
              Ut.push(_i, Di, 1 / 0, Pt, -1, 1), this.options.reduce && Ut.push(0);
            }
            let ti = this.trees[Ct + 1] = this._createTree(Ut);
            Fe && console.timeEnd(It);
            for (let Pt = Ct; Pt >= tt; Pt--) {
              const Wt = +Date.now();
              ti = this.trees[Pt] = this._createTree(this._cluster(ti, Pt)), Fe && console.log("z%d: %d clusters in %dms", Pt, ti.numItems, +Date.now() - Wt);
            }
            return Fe && console.timeEnd("total time"), this;
          }
          getClusters(Ae, Fe) {
            let tt = ((Ae[0] + 180) % 360 + 360) % 360 - 180;
            const Ct = Math.max(-90, Math.min(90, Ae[1]));
            let It = Ae[2] === 180 ? 180 : ((Ae[2] + 180) % 360 + 360) % 360 - 180;
            const Ut = Math.max(-90, Math.min(90, Ae[3]));
            if (Ae[2] - Ae[0] >= 360) tt = -180, It = 180;
            else if (tt > It) {
              const oi = this.getClusters([tt, Ct, 180, Ut], Fe), _i = this.getClusters([-180, Ct, It, Ut], Fe);
              return oi.concat(_i);
            }
            const ti = this.trees[this._limitZoom(Fe)], Pt = ti.range(Re(tt), _t(Ut), Re(It), _t(Ct)), Wt = ti.data, ei = [];
            for (const oi of Pt) {
              const _i = this.stride * oi;
              ei.push(Wt[_i + St] > 1 ? Ye(Wt, _i, this.clusterProps) : this.points[Wt[_i + At]]);
            }
            return ei;
          }
          getChildren(Ae) {
            const Fe = this._getOriginId(Ae), tt = this._getOriginZoom(Ae), Ct = "No cluster with the specified id.", It = this.trees[tt];
            if (!It) throw new Error(Ct);
            const Ut = It.data;
            if (Fe * this.stride >= Ut.length) throw new Error(Ct);
            const ti = this.options.radius / (this.options.extent * Math.pow(2, tt - 1)), Pt = It.within(Ut[Fe * this.stride], Ut[Fe * this.stride + 1], ti), Wt = [];
            for (const ei of Pt) {
              const oi = ei * this.stride;
              Ut[oi + 4] === Ae && Wt.push(Ut[oi + St] > 1 ? Ye(Ut, oi, this.clusterProps) : this.points[Ut[oi + At]]);
            }
            if (Wt.length === 0) throw new Error(Ct);
            return Wt;
          }
          getLeaves(Ae, Fe, tt) {
            const Ct = [];
            return this._appendLeaves(Ct, Ae, Fe = Fe || 10, tt = tt || 0, 0), Ct;
          }
          getTile(Ae, Fe, tt) {
            const Ct = this.trees[this._limitZoom(Ae)], It = Math.pow(2, Ae), { extent: Ut, radius: ti } = this.options, Pt = ti / Ut, Wt = (tt - Pt) / It, ei = (tt + 1 + Pt) / It, oi = { features: [] };
            return this._addTileFeatures(Ct.range((Fe - Pt) / It, Wt, (Fe + 1 + Pt) / It, ei), Ct.data, Fe, tt, It, oi), Fe === 0 && this._addTileFeatures(Ct.range(1 - Pt / It, Wt, 1, ei), Ct.data, It, tt, It, oi), Fe === It - 1 && this._addTileFeatures(Ct.range(0, Wt, Pt / It, ei), Ct.data, -1, tt, It, oi), oi.features.length ? oi : null;
          }
          getClusterExpansionZoom(Ae) {
            let Fe = this._getOriginZoom(Ae) - 1;
            for (; Fe <= this.options.maxZoom; ) {
              const tt = this.getChildren(Ae);
              if (Fe++, tt.length !== 1) break;
              Ae = tt[0].properties.cluster_id;
            }
            return Fe;
          }
          _appendLeaves(Ae, Fe, tt, Ct, It) {
            const Ut = this.getChildren(Fe);
            for (const ti of Ut) {
              const Pt = ti.properties;
              if (Pt && Pt.cluster ? It + Pt.point_count <= Ct ? It += Pt.point_count : It = this._appendLeaves(Ae, Pt.cluster_id, tt, Ct, It) : It < Ct ? It++ : Ae.push(ti), Ae.length === tt) break;
            }
            return It;
          }
          _createTree(Ae) {
            const Fe = new i.bE(Ae.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let tt = 0; tt < Ae.length; tt += this.stride) Fe.add(Ae[tt], Ae[tt + 1]);
            return Fe.finish(), Fe.data = Ae, Fe;
          }
          _addTileFeatures(Ae, Fe, tt, Ct, It, Ut) {
            for (const ti of Ae) {
              const Pt = ti * this.stride, Wt = Fe[Pt + St] > 1;
              let ei, oi, _i;
              if (Wt) ei = De(Fe, Pt, this.clusterProps), oi = Fe[Pt], _i = Fe[Pt + 1];
              else {
                const Hi = this.points[Fe[Pt + At]];
                ei = Hi.properties;
                const [nr, rr] = Hi.geometry.coordinates;
                oi = Re(nr), _i = _t(rr);
              }
              const Di = { type: 1, geometry: [[Math.round(this.options.extent * (oi * It - tt)), Math.round(this.options.extent * (_i * It - Ct))]], tags: ei };
              let Bi;
              Bi = Wt || this.options.generateId ? Fe[Pt + At] : this.points[Fe[Pt + At]].id, Bi !== void 0 && (Di.id = Bi), Ut.features.push(Di);
            }
          }
          _limitZoom(Ae) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+Ae), this.options.maxZoom + 1));
          }
          _cluster(Ae, Fe) {
            const { radius: tt, extent: Ct, reduce: It, minPoints: Ut } = this.options, ti = tt / (Ct * Math.pow(2, Fe)), Pt = Ae.data, Wt = [], ei = this.stride;
            for (let oi = 0; oi < Pt.length; oi += ei) {
              if (Pt[oi + 2] <= Fe) continue;
              Pt[oi + 2] = Fe;
              const _i = Pt[oi], Di = Pt[oi + 1], Bi = Ae.within(Pt[oi], Pt[oi + 1], ti), Hi = Pt[oi + St];
              let nr = Hi;
              for (const rr of Bi) {
                const dr = rr * ei;
                Pt[dr + 2] > Fe && (nr += Pt[dr + St]);
              }
              if (nr > Hi && nr >= Ut) {
                let rr, dr = _i * Hi, Rr = Di * Hi, Br = -1;
                const Ki = (oi / ei << 5) + (Fe + 1) + this.points.length;
                for (const Ir of Bi) {
                  const Mr = Ir * ei;
                  if (Pt[Mr + 2] <= Fe) continue;
                  Pt[Mr + 2] = Fe;
                  const wn = Pt[Mr + St];
                  dr += Pt[Mr] * wn, Rr += Pt[Mr + 1] * wn, Pt[Mr + 4] = Ki, It && (rr || (rr = this._map(Pt, oi, !0), Br = this.clusterProps.length, this.clusterProps.push(rr)), It(rr, this._map(Pt, Mr)));
                }
                Pt[oi + 4] = Ki, Wt.push(dr / nr, Rr / nr, 1 / 0, Ki, -1, nr), It && Wt.push(Br);
              } else {
                for (let rr = 0; rr < ei; rr++) Wt.push(Pt[oi + rr]);
                if (nr > 1) for (const rr of Bi) {
                  const dr = rr * ei;
                  if (!(Pt[dr + 2] <= Fe)) {
                    Pt[dr + 2] = Fe;
                    for (let Rr = 0; Rr < ei; Rr++) Wt.push(Pt[dr + Rr]);
                  }
                }
              }
            }
            return Wt;
          }
          _getOriginId(Ae) {
            return Ae - this.points.length >> 5;
          }
          _getOriginZoom(Ae) {
            return (Ae - this.points.length) % 32;
          }
          _map(Ae, Fe, tt) {
            if (Ae[Fe + St] > 1) {
              const Ut = this.clusterProps[Ae[Fe + Lt]];
              return tt ? Object.assign({}, Ut) : Ut;
            }
            const Ct = this.points[Ae[Fe + At]].properties, It = this.options.map(Ct);
            return tt && It === Ct ? Object.assign({}, It) : It;
          }
        }
        function Ye(Mt, Ae, Fe) {
          return { type: "Feature", id: Mt[Ae + At], properties: De(Mt, Ae, Fe), geometry: { type: "Point", coordinates: [(tt = Mt[Ae], 360 * (tt - 0.5)), et(Mt[Ae + 1])] } };
          var tt;
        }
        function De(Mt, Ae, Fe) {
          const tt = Mt[Ae + St], Ct = tt >= 1e4 ? `${Math.round(tt / 1e3)}k` : tt >= 1e3 ? Math.round(tt / 100) / 10 + "k" : tt, It = Mt[Ae + Lt], Ut = It === -1 ? {} : Object.assign({}, Fe[It]);
          return Object.assign(Ut, { cluster: !0, cluster_id: Mt[Ae + At], point_count: tt, point_count_abbreviated: Ct });
        }
        function Re(Mt) {
          return Mt / 360 + 0.5;
        }
        function _t(Mt) {
          const Ae = Math.sin(Mt * Math.PI / 180), Fe = 0.5 - 0.25 * Math.log((1 + Ae) / (1 - Ae)) / Math.PI;
          return Fe < 0 ? 0 : Fe > 1 ? 1 : Fe;
        }
        function et(Mt) {
          const Ae = (180 - 360 * Mt) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(Ae)) / Math.PI - 90;
        }
        function Ie(Mt, Ae, Fe, tt) {
          let Ct = tt;
          const It = Ae + (Fe - Ae >> 1);
          let Ut, ti = Fe - Ae;
          const Pt = Mt[Ae], Wt = Mt[Ae + 1], ei = Mt[Fe], oi = Mt[Fe + 1];
          for (let _i = Ae + 3; _i < Fe; _i += 3) {
            const Di = pe(Mt[_i], Mt[_i + 1], Pt, Wt, ei, oi);
            if (Di > Ct) Ut = _i, Ct = Di;
            else if (Di === Ct) {
              const Bi = Math.abs(_i - It);
              Bi < ti && (Ut = _i, ti = Bi);
            }
          }
          Ct > tt && (Ut - Ae > 3 && Ie(Mt, Ae, Ut, tt), Mt[Ut + 2] = Ct, Fe - Ut > 3 && Ie(Mt, Ut, Fe, tt));
        }
        function pe(Mt, Ae, Fe, tt, Ct, It) {
          let Ut = Ct - Fe, ti = It - tt;
          if (Ut !== 0 || ti !== 0) {
            const Pt = ((Mt - Fe) * Ut + (Ae - tt) * ti) / (Ut * Ut + ti * ti);
            Pt > 1 ? (Fe = Ct, tt = It) : Pt > 0 && (Fe += Ut * Pt, tt += ti * Pt);
          }
          return Ut = Mt - Fe, ti = Ae - tt, Ut * Ut + ti * ti;
        }
        function xt(Mt, Ae, Fe, tt) {
          const Ct = { id: Mt ?? null, type: Ae, geometry: Fe, tags: tt, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (Ae === "Point" || Ae === "MultiPoint" || Ae === "LineString") l(Ct, Fe);
          else if (Ae === "Polygon") l(Ct, Fe[0]);
          else if (Ae === "MultiLineString") for (const It of Fe) l(Ct, It);
          else if (Ae === "MultiPolygon") for (const It of Fe) l(Ct, It[0]);
          return Ct;
        }
        function l(Mt, Ae) {
          for (let Fe = 0; Fe < Ae.length; Fe += 3) Mt.minX = Math.min(Mt.minX, Ae[Fe]), Mt.minY = Math.min(Mt.minY, Ae[Fe + 1]), Mt.maxX = Math.max(Mt.maxX, Ae[Fe]), Mt.maxY = Math.max(Mt.maxY, Ae[Fe + 1]);
        }
        function _(Mt, Ae, Fe, tt) {
          if (!Ae.geometry) return;
          const Ct = Ae.geometry.coordinates;
          if (Ct && Ct.length === 0) return;
          const It = Ae.geometry.type, Ut = Math.pow(Fe.tolerance / ((1 << Fe.maxZoom) * Fe.extent), 2);
          let ti = [], Pt = Ae.id;
          if (Fe.promoteId ? Pt = Ae.properties[Fe.promoteId] : Fe.generateId && (Pt = tt || 0), It === "Point") I(Ct, ti);
          else if (It === "MultiPoint") for (const Wt of Ct) I(Wt, ti);
          else if (It === "LineString") X(Ct, ti, Ut, !1);
          else if (It === "MultiLineString") {
            if (Fe.lineMetrics) {
              for (const Wt of Ct) ti = [], X(Wt, ti, Ut, !1), Mt.push(xt(Pt, "LineString", ti, Ae.properties));
              return;
            }
            ne(Ct, ti, Ut, !1);
          } else if (It === "Polygon") ne(Ct, ti, Ut, !0);
          else {
            if (It !== "MultiPolygon") {
              if (It === "GeometryCollection") {
                for (const Wt of Ae.geometry.geometries) _(Mt, { id: Pt, geometry: Wt, properties: Ae.properties }, Fe, tt);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const Wt of Ct) {
              const ei = [];
              ne(Wt, ei, Ut, !0), ti.push(ei);
            }
          }
          Mt.push(xt(Pt, It, ti, Ae.properties));
        }
        function I(Mt, Ae) {
          Ae.push(ue(Mt[0]), Te(Mt[1]), 0);
        }
        function X(Mt, Ae, Fe, tt) {
          let Ct, It, Ut = 0;
          for (let Pt = 0; Pt < Mt.length; Pt++) {
            const Wt = ue(Mt[Pt][0]), ei = Te(Mt[Pt][1]);
            Ae.push(Wt, ei, 0), Pt > 0 && (Ut += tt ? (Ct * ei - Wt * It) / 2 : Math.sqrt(Math.pow(Wt - Ct, 2) + Math.pow(ei - It, 2))), Ct = Wt, It = ei;
          }
          const ti = Ae.length - 3;
          Ae[2] = 1, Ie(Ae, 0, ti, Fe), Ae[ti + 2] = 1, Ae.size = Math.abs(Ut), Ae.start = 0, Ae.end = Ae.size;
        }
        function ne(Mt, Ae, Fe, tt) {
          for (let Ct = 0; Ct < Mt.length; Ct++) {
            const It = [];
            X(Mt[Ct], It, Fe, tt), Ae.push(It);
          }
        }
        function ue(Mt) {
          return Mt / 360 + 0.5;
        }
        function Te(Mt) {
          const Ae = Math.sin(Mt * Math.PI / 180), Fe = 0.5 - 0.25 * Math.log((1 + Ae) / (1 - Ae)) / Math.PI;
          return Fe < 0 ? 0 : Fe > 1 ? 1 : Fe;
        }
        function ye(Mt, Ae, Fe, tt, Ct, It, Ut, ti) {
          if (tt /= Ae, It >= (Fe /= Ae) && Ut < tt) return Mt;
          if (Ut < Fe || It >= tt) return null;
          const Pt = [];
          for (const Wt of Mt) {
            const ei = Wt.geometry;
            let oi = Wt.type;
            const _i = Ct === 0 ? Wt.minX : Wt.minY, Di = Ct === 0 ? Wt.maxX : Wt.maxY;
            if (_i >= Fe && Di < tt) {
              Pt.push(Wt);
              continue;
            }
            if (Di < Fe || _i >= tt) continue;
            let Bi = [];
            if (oi === "Point" || oi === "MultiPoint") Me(ei, Bi, Fe, tt, Ct);
            else if (oi === "LineString") Ge(ei, Bi, Fe, tt, Ct, !1, ti.lineMetrics);
            else if (oi === "MultiLineString") re(ei, Bi, Fe, tt, Ct, !1);
            else if (oi === "Polygon") re(ei, Bi, Fe, tt, Ct, !0);
            else if (oi === "MultiPolygon") for (const Hi of ei) {
              const nr = [];
              re(Hi, nr, Fe, tt, Ct, !0), nr.length && Bi.push(nr);
            }
            if (Bi.length) {
              if (ti.lineMetrics && oi === "LineString") {
                for (const Hi of Bi) Pt.push(xt(Wt.id, oi, Hi, Wt.tags));
                continue;
              }
              oi !== "LineString" && oi !== "MultiLineString" || (Bi.length === 1 ? (oi = "LineString", Bi = Bi[0]) : oi = "MultiLineString"), oi !== "Point" && oi !== "MultiPoint" || (oi = Bi.length === 3 ? "Point" : "MultiPoint"), Pt.push(xt(Wt.id, oi, Bi, Wt.tags));
            }
          }
          return Pt.length ? Pt : null;
        }
        function Me(Mt, Ae, Fe, tt, Ct) {
          for (let It = 0; It < Mt.length; It += 3) {
            const Ut = Mt[It + Ct];
            Ut >= Fe && Ut <= tt && Se(Ae, Mt[It], Mt[It + 1], Mt[It + 2]);
          }
        }
        function Ge(Mt, Ae, Fe, tt, Ct, It, Ut) {
          let ti = Qe(Mt);
          const Pt = Ct === 0 ? Pe : at;
          let Wt, ei, oi = Mt.start;
          for (let nr = 0; nr < Mt.length - 3; nr += 3) {
            const rr = Mt[nr], dr = Mt[nr + 1], Rr = Mt[nr + 2], Br = Mt[nr + 3], Ki = Mt[nr + 4], Ir = Ct === 0 ? rr : dr, Mr = Ct === 0 ? Br : Ki;
            let wn = !1;
            Ut && (Wt = Math.sqrt(Math.pow(rr - Br, 2) + Math.pow(dr - Ki, 2))), Ir < Fe ? Mr > Fe && (ei = Pt(ti, rr, dr, Br, Ki, Fe), Ut && (ti.start = oi + Wt * ei)) : Ir > tt ? Mr < tt && (ei = Pt(ti, rr, dr, Br, Ki, tt), Ut && (ti.start = oi + Wt * ei)) : Se(ti, rr, dr, Rr), Mr < Fe && Ir >= Fe && (ei = Pt(ti, rr, dr, Br, Ki, Fe), wn = !0), Mr > tt && Ir <= tt && (ei = Pt(ti, rr, dr, Br, Ki, tt), wn = !0), !It && wn && (Ut && (ti.end = oi + Wt * ei), Ae.push(ti), ti = Qe(Mt)), Ut && (oi += Wt);
          }
          let _i = Mt.length - 3;
          const Di = Mt[_i], Bi = Mt[_i + 1], Hi = Ct === 0 ? Di : Bi;
          Hi >= Fe && Hi <= tt && Se(ti, Di, Bi, Mt[_i + 2]), _i = ti.length - 3, It && _i >= 3 && (ti[_i] !== ti[0] || ti[_i + 1] !== ti[1]) && Se(ti, ti[0], ti[1], ti[2]), ti.length && Ae.push(ti);
        }
        function Qe(Mt) {
          const Ae = [];
          return Ae.size = Mt.size, Ae.start = Mt.start, Ae.end = Mt.end, Ae;
        }
        function re(Mt, Ae, Fe, tt, Ct, It) {
          for (const Ut of Mt) Ge(Ut, Ae, Fe, tt, Ct, It, !1);
        }
        function Se(Mt, Ae, Fe, tt) {
          Mt.push(Ae, Fe, tt);
        }
        function Pe(Mt, Ae, Fe, tt, Ct, It) {
          const Ut = (It - Ae) / (tt - Ae);
          return Se(Mt, It, Fe + (Ct - Fe) * Ut, 1), Ut;
        }
        function at(Mt, Ae, Fe, tt, Ct, It) {
          const Ut = (It - Fe) / (Ct - Fe);
          return Se(Mt, Ae + (tt - Ae) * Ut, It, 1), Ut;
        }
        function Be(Mt, Ae) {
          const Fe = [];
          for (let tt = 0; tt < Mt.length; tt++) {
            const Ct = Mt[tt], It = Ct.type;
            let Ut;
            if (It === "Point" || It === "MultiPoint" || It === "LineString") Ut = Ze(Ct.geometry, Ae);
            else if (It === "MultiLineString" || It === "Polygon") {
              Ut = [];
              for (const ti of Ct.geometry) Ut.push(Ze(ti, Ae));
            } else if (It === "MultiPolygon") {
              Ut = [];
              for (const ti of Ct.geometry) {
                const Pt = [];
                for (const Wt of ti) Pt.push(Ze(Wt, Ae));
                Ut.push(Pt);
              }
            }
            Fe.push(xt(Ct.id, It, Ut, Ct.tags));
          }
          return Fe;
        }
        function Ze(Mt, Ae) {
          const Fe = [];
          Fe.size = Mt.size, Mt.start !== void 0 && (Fe.start = Mt.start, Fe.end = Mt.end);
          for (let tt = 0; tt < Mt.length; tt += 3) Fe.push(Mt[tt] + Ae, Mt[tt + 1], Mt[tt + 2]);
          return Fe;
        }
        function fe(Mt, Ae) {
          if (Mt.transformed) return Mt;
          const Fe = 1 << Mt.z, tt = Mt.x, Ct = Mt.y;
          for (const It of Mt.features) {
            const Ut = It.geometry, ti = It.type;
            if (It.geometry = [], ti === 1) for (let Pt = 0; Pt < Ut.length; Pt += 2) It.geometry.push(Je(Ut[Pt], Ut[Pt + 1], Ae, Fe, tt, Ct));
            else for (let Pt = 0; Pt < Ut.length; Pt++) {
              const Wt = [];
              for (let ei = 0; ei < Ut[Pt].length; ei += 2) Wt.push(Je(Ut[Pt][ei], Ut[Pt][ei + 1], Ae, Fe, tt, Ct));
              It.geometry.push(Wt);
            }
          }
          return Mt.transformed = !0, Mt;
        }
        function Je(Mt, Ae, Fe, tt, Ct, It) {
          return [Math.round(Fe * (Mt * tt - Ct)), Math.round(Fe * (Ae * tt - It))];
        }
        function Xe(Mt, Ae, Fe, tt, Ct) {
          const It = Ae === Ct.maxZoom ? 0 : Ct.tolerance / ((1 << Ae) * Ct.extent), Ut = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Mt.length, source: null, x: Fe, y: tt, z: Ae, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const ti of Mt) z(Ut, ti, It, Ct);
          return Ut;
        }
        function z(Mt, Ae, Fe, tt) {
          const Ct = Ae.geometry, It = Ae.type, Ut = [];
          if (Mt.minX = Math.min(Mt.minX, Ae.minX), Mt.minY = Math.min(Mt.minY, Ae.minY), Mt.maxX = Math.max(Mt.maxX, Ae.maxX), Mt.maxY = Math.max(Mt.maxY, Ae.maxY), It === "Point" || It === "MultiPoint") for (let ti = 0; ti < Ct.length; ti += 3) Ut.push(Ct[ti], Ct[ti + 1]), Mt.numPoints++, Mt.numSimplified++;
          else if (It === "LineString") He(Ut, Ct, Mt, Fe, !1, !1);
          else if (It === "MultiLineString" || It === "Polygon") for (let ti = 0; ti < Ct.length; ti++) He(Ut, Ct[ti], Mt, Fe, It === "Polygon", ti === 0);
          else if (It === "MultiPolygon") for (let ti = 0; ti < Ct.length; ti++) {
            const Pt = Ct[ti];
            for (let Wt = 0; Wt < Pt.length; Wt++) He(Ut, Pt[Wt], Mt, Fe, !0, Wt === 0);
          }
          if (Ut.length) {
            let ti = Ae.tags || null;
            if (It === "LineString" && tt.lineMetrics) {
              ti = {};
              for (const Wt in Ae.tags) ti[Wt] = Ae.tags[Wt];
              ti.mapbox_clip_start = Ct.start / Ct.size, ti.mapbox_clip_end = Ct.end / Ct.size;
            }
            const Pt = { geometry: Ut, type: It === "Polygon" || It === "MultiPolygon" ? 3 : It === "LineString" || It === "MultiLineString" ? 2 : 1, tags: ti };
            Ae.id !== null && (Pt.id = Ae.id), Mt.features.push(Pt);
          }
        }
        function He(Mt, Ae, Fe, tt, Ct, It) {
          const Ut = tt * tt;
          if (tt > 0 && Ae.size < (Ct ? Ut : tt)) return void (Fe.numPoints += Ae.length / 3);
          const ti = [];
          for (let Pt = 0; Pt < Ae.length; Pt += 3) (tt === 0 || Ae[Pt + 2] > Ut) && (Fe.numSimplified++, ti.push(Ae[Pt], Ae[Pt + 1])), Fe.numPoints++;
          Ct && function(Pt, Wt) {
            let ei = 0;
            for (let oi = 0, _i = Pt.length, Di = _i - 2; oi < _i; Di = oi, oi += 2) ei += (Pt[oi] - Pt[Di]) * (Pt[oi + 1] + Pt[Di + 1]);
            if (ei > 0 === Wt) for (let oi = 0, _i = Pt.length; oi < _i / 2; oi += 2) {
              const Di = Pt[oi], Bi = Pt[oi + 1];
              Pt[oi] = Pt[_i - 2 - oi], Pt[oi + 1] = Pt[_i - 1 - oi], Pt[_i - 2 - oi] = Di, Pt[_i - 1 - oi] = Bi;
            }
          }(ti, It), Mt.push(ti);
        }
        const nt = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
        class ae {
          constructor(Ae, Fe) {
            const tt = (Fe = this.options = function(It, Ut) {
              for (const ti in Ut) It[ti] = Ut[ti];
              return It;
            }(Object.create(nt), Fe)).debug;
            if (tt && console.time("preprocess data"), Fe.maxZoom < 0 || Fe.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (Fe.promoteId && Fe.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let Ct = function(It, Ut) {
              const ti = [];
              if (It.type === "FeatureCollection") for (let Pt = 0; Pt < It.features.length; Pt++) _(ti, It.features[Pt], Ut, Pt);
              else _(ti, It.type === "Feature" ? It : { geometry: It }, Ut);
              return ti;
            }(Ae, Fe);
            this.tiles = {}, this.tileCoords = [], tt && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", Fe.indexMaxZoom, Fe.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), Ct = function(It, Ut) {
              const ti = Ut.buffer / Ut.extent;
              let Pt = It;
              const Wt = ye(It, 1, -1 - ti, ti, 0, -1, 2, Ut), ei = ye(It, 1, 1 - ti, 2 + ti, 0, -1, 2, Ut);
              return (Wt || ei) && (Pt = ye(It, 1, -ti, 1 + ti, 0, -1, 2, Ut) || [], Wt && (Pt = Be(Wt, 1).concat(Pt)), ei && (Pt = Pt.concat(Be(ei, -1)))), Pt;
            }(Ct, Fe), Ct.length && this.splitTile(Ct, 0, 0, 0), tt && (Ct.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(Ae, Fe, tt, Ct, It, Ut, ti) {
            const Pt = [Ae, Fe, tt, Ct], Wt = this.options, ei = Wt.debug;
            for (; Pt.length; ) {
              Ct = Pt.pop(), tt = Pt.pop(), Fe = Pt.pop(), Ae = Pt.pop();
              const oi = 1 << Fe, _i = $e(Fe, tt, Ct);
              let Di = this.tiles[_i];
              if (!Di && (ei > 1 && console.time("creation"), Di = this.tiles[_i] = Xe(Ae, Fe, tt, Ct, Wt), this.tileCoords.push({ z: Fe, x: tt, y: Ct }), ei)) {
                ei > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", Fe, tt, Ct, Di.numFeatures, Di.numPoints, Di.numSimplified), console.timeEnd("creation"));
                const wn = `z${Fe}`;
                this.stats[wn] = (this.stats[wn] || 0) + 1, this.total++;
              }
              if (Di.source = Ae, It == null) {
                if (Fe === Wt.indexMaxZoom || Di.numPoints <= Wt.indexMaxPoints) continue;
              } else {
                if (Fe === Wt.maxZoom || Fe === It) continue;
                if (It != null) {
                  const wn = It - Fe;
                  if (tt !== Ut >> wn || Ct !== ti >> wn) continue;
                }
              }
              if (Di.source = null, Ae.length === 0) continue;
              ei > 1 && console.time("clipping");
              const Bi = 0.5 * Wt.buffer / Wt.extent, Hi = 0.5 - Bi, nr = 0.5 + Bi, rr = 1 + Bi;
              let dr = null, Rr = null, Br = null, Ki = null, Ir = ye(Ae, oi, tt - Bi, tt + nr, 0, Di.minX, Di.maxX, Wt), Mr = ye(Ae, oi, tt + Hi, tt + rr, 0, Di.minX, Di.maxX, Wt);
              Ae = null, Ir && (dr = ye(Ir, oi, Ct - Bi, Ct + nr, 1, Di.minY, Di.maxY, Wt), Rr = ye(Ir, oi, Ct + Hi, Ct + rr, 1, Di.minY, Di.maxY, Wt), Ir = null), Mr && (Br = ye(Mr, oi, Ct - Bi, Ct + nr, 1, Di.minY, Di.maxY, Wt), Ki = ye(Mr, oi, Ct + Hi, Ct + rr, 1, Di.minY, Di.maxY, Wt), Mr = null), ei > 1 && console.timeEnd("clipping"), Pt.push(dr || [], Fe + 1, 2 * tt, 2 * Ct), Pt.push(Rr || [], Fe + 1, 2 * tt, 2 * Ct + 1), Pt.push(Br || [], Fe + 1, 2 * tt + 1, 2 * Ct), Pt.push(Ki || [], Fe + 1, 2 * tt + 1, 2 * Ct + 1);
            }
          }
          getTile(Ae, Fe, tt) {
            Ae = +Ae, Fe = +Fe, tt = +tt;
            const Ct = this.options, { extent: It, debug: Ut } = Ct;
            if (Ae < 0 || Ae > 24) return null;
            const ti = 1 << Ae, Pt = $e(Ae, Fe = Fe + ti & ti - 1, tt);
            if (this.tiles[Pt]) return fe(this.tiles[Pt], It);
            Ut > 1 && console.log("drilling down to z%d-%d-%d", Ae, Fe, tt);
            let Wt, ei = Ae, oi = Fe, _i = tt;
            for (; !Wt && ei > 0; ) ei--, oi >>= 1, _i >>= 1, Wt = this.tiles[$e(ei, oi, _i)];
            return Wt && Wt.source ? (Ut > 1 && (console.log("found parent tile z%d-%d-%d", ei, oi, _i), console.time("drilling down")), this.splitTile(Wt.source, ei, oi, _i, Ae, Fe, tt), Ut > 1 && console.timeEnd("drilling down"), this.tiles[Pt] ? fe(this.tiles[Pt], It) : null) : null;
          }
        }
        function $e(Mt, Ae, Fe) {
          return 32 * ((1 << Mt) * Fe + Ae) + Mt;
        }
        function Et(Mt, Ae) {
          const Fe = Mt.tileID.canonical;
          if (!this._geoJSONIndex) return void Ae(null, null);
          const tt = this._geoJSONIndex.getTile(Fe.z, Fe.x, Fe.y);
          if (!tt) return void Ae(null, null);
          const Ct = new ge(tt.features);
          let It = rt(Ct);
          It.byteOffset === 0 && It.byteLength === It.buffer.byteLength || (It = new Uint8Array(It)), Ae(null, { vectorTile: Ct, rawData: It.buffer });
        }
        class Nt extends ee {
          constructor(Ae, Fe, tt, Ct, It, Ut) {
            super(Ae, Fe, tt, Ct, Et, Ut), It && (this.loadGeoJSON = It), this._dynamicIndex = new Ue();
          }
          loadData(Ae, Fe) {
            const tt = Ae && Ae.request, Ct = tt && tt.collectResourceTiming;
            this.loadGeoJSON(Ae, (It, Ut) => {
              if (It || !Ut) return Fe(It);
              if (typeof Ut != "object") return Fe(new Error(`Input data given to '${Ae.source}' is not a valid GeoJSON object.`));
              {
                try {
                  if (Ae.filter) {
                    const Pt = i.U(Ae.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                    if (Pt.result === "error") throw new Error(Pt.value.map((Wt) => `${Wt.key}: ${Wt.message}`).join(", "));
                    Ut.features = Ut.features.filter((Wt) => Pt.value.evaluate({ zoom: 0 }, Wt));
                  }
                  Ae.dynamic ? (Ut.type === "Feature" && (Ut = { type: "FeatureCollection", features: [Ut] }), Ae.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(Ut.features, this.loaded), Ae.cluster && (Ut.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = Ae.cluster ? new kt(function({ superclusterOptions: Pt, clusterProperties: Wt }) {
                    if (!Wt || !Pt) return Pt;
                    const ei = {}, oi = {}, _i = { accumulated: null, zoom: 0 }, Di = { properties: null }, Bi = Object.keys(Wt);
                    for (const Hi of Bi) {
                      const [nr, rr] = Wt[Hi], dr = i.U(rr), Rr = i.U(typeof nr == "string" ? [nr, ["accumulated"], ["get", Hi]] : nr);
                      ei[Hi] = dr.value, oi[Hi] = Rr.value;
                    }
                    return Pt.map = (Hi) => {
                      Di.properties = Hi;
                      const nr = {};
                      for (const rr of Bi) nr[rr] = ei[rr].evaluate(_i, Di);
                      return nr;
                    }, Pt.reduce = (Hi, nr) => {
                      Di.properties = nr;
                      for (const rr of Bi) _i.accumulated = Hi[rr], Hi[rr] = oi[rr].evaluate(_i, Di);
                    }, Pt;
                  }(Ae)).load(Ut.features) : Ae.dynamic ? this._dynamicIndex : function(Pt, Wt) {
                    return new ae(Pt, Wt);
                  }(Ut, Ae.geojsonVtOptions);
                } catch (Pt) {
                  return Fe(Pt);
                }
                const ti = {};
                if (Ct) {
                  const Pt = N(tt);
                  Pt && (ti.resourceTiming = {}, ti.resourceTiming[Ae.source] = JSON.parse(JSON.stringify(Pt)));
                }
                Fe(null, ti);
              }
            });
          }
          reloadTile(Ae, Fe) {
            const tt = this.loaded;
            return tt && tt[Ae.uid] ? Ae.partial ? Fe(null, void 0) : super.reloadTile(Ae, Fe) : this.loadTile(Ae, Fe);
          }
          loadGeoJSON(Ae, Fe) {
            if (Ae.request) i.n(Ae.request, Fe);
            else {
              if (typeof Ae.data != "string") return Fe(new Error(`Input data given to '${Ae.source}' is not a valid GeoJSON object.`));
              try {
                return Fe(null, JSON.parse(Ae.data));
              } catch {
                return Fe(new Error(`Input data given to '${Ae.source}' is not a valid GeoJSON object.`));
              }
            }
          }
          getClusterExpansionZoom(Ae, Fe) {
            try {
              Fe(null, this._geoJSONIndex.getClusterExpansionZoom(Ae.clusterId));
            } catch (tt) {
              Fe(tt);
            }
          }
          getClusterChildren(Ae, Fe) {
            try {
              Fe(null, this._geoJSONIndex.getChildren(Ae.clusterId));
            } catch (tt) {
              Fe(tt);
            }
          }
          getClusterLeaves(Ae, Fe) {
            try {
              Fe(null, this._geoJSONIndex.getLeaves(Ae.clusterId, Ae.limit, Ae.offset));
            } catch (tt) {
              Fe(tt);
            }
          }
        }
        class Yt {
          constructor(Ae, Fe) {
            this.tileID = new i.aG(Ae.tileID.overscaledZ, Ae.tileID.wrap, Ae.tileID.canonical.z, Ae.tileID.canonical.x, Ae.tileID.canonical.y), this.tileZoom = Ae.tileZoom, this.uid = Ae.uid, this.zoom = Ae.zoom, this.canonical = Ae.tileID.canonical, this.pixelRatio = Ae.pixelRatio, this.tileSize = Ae.tileSize, this.source = Ae.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = Ae.projection, this.brightness = Fe;
          }
          parse(Ae, Fe, tt, Ct) {
            this.status = "parsing";
            const It = new i.aG(tt.tileID.overscaledZ, tt.tileID.wrap, tt.tileID.canonical.z, tt.tileID.canonical.x, tt.tileID.canonical.y), Ut = [], ti = Fe.familiesBySource[tt.source], Pt = new i.d$(It, tt.promoteId);
            return Pt.bucketLayerIDs = [], Pt.is3DTile = !0, i.ea(Ae).then((Wt) => {
              if (!Wt) return Ct(new Error("Could not parse tile"));
              const ei = i.eb(Wt, 1 / i.cc(tt.tileID.canonical)), oi = Wt.json.extensionsUsed && Wt.json.extensionsUsed.includes("MAPBOX_mesh_features") || Wt.json.asset.extras && Wt.json.asset.extras.MAPBOX_mesh_features, _i = Wt.json.extensionsUsed && Wt.json.extensionsUsed.includes("EXT_meshopt_compression"), Di = new i.a8(this.zoom, { brightness: this.brightness });
              for (const Bi in ti) for (const Hi of ti[Bi]) {
                const nr = Hi[0];
                Pt.bucketLayerIDs.push(Hi.map((dr) => i.aC(dr.id, dr.scope))), nr.recalculate(Di, []);
                const rr = new i.ec(Hi, ei, It, oi, _i, this.brightness, Pt);
                oi || (rr.needsUpload = !0), Ut.push(rr), rr.evaluate(nr);
              }
              this.status = "done", Ct(null, { buckets: Ut, featureIndex: Pt, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: null });
            }).catch((Wt) => Ct(new Error(Wt.message)));
          }
        }
        class Ft {
          constructor(Ae, Fe, tt, Ct, It, Ut) {
            this.actor = Ae, this.layerIndex = Fe, this.availableImages = tt, this.brightness = Ut, this.loading = {}, this.loaded = {};
          }
          loadTile(Ae, Fe) {
            const tt = Ae.uid, Ct = this.loading[tt] = new Yt(Ae, this.brightness);
            i.bi(Ae.request, (It, Ut) => {
              const ti = !this.loading[tt];
              return delete this.loading[tt], ti || It ? (Ct.status = "done", ti || (this.loaded[tt] = Ct), Fe(It)) : Ut && Ut.byteLength !== 0 ? void Ct.parse(Ut, this.layerIndex, Ae, (Pt, Wt) => {
                Ct.status = "done", this.loaded = this.loaded || {}, this.loaded[tt] = Ct, Pt || !Wt ? Fe(Pt) : Fe(null, Wt);
              }) : (Ct.status = "done", this.loaded[tt] = Ct, Fe());
            });
          }
          reloadTile(Ae, Fe) {
            const tt = this.loaded, Ct = Ae.uid;
            if (tt && tt[Ct]) {
              const It = tt[Ct];
              It.projection = Ae.projection, It.brightness = Ae.brightness;
              const Ut = (ti, Pt) => {
                It.reloadCallback && (delete It.reloadCallback, this.loadTile(Ae, Fe)), Fe(ti, Pt);
              };
              It.status === "parsing" ? It.reloadCallback = Ut : It.status === "done" && this.loadTile(Ae, Fe);
            }
          }
          abortTile(Ae, Fe) {
            const tt = Ae.uid;
            this.loading[tt] && delete this.loading[tt], Fe();
          }
          removeTile(Ae, Fe) {
            const tt = this.loaded, Ct = Ae.uid;
            tt && tt[Ct] && delete tt[Ct], Fe();
          }
        }
        class ai {
          constructor(Ae) {
            this.self = Ae, this.actor = new i.ed(Ae, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new i.I(), this.projections = {}, this.defaultProjection = i.bP({ name: "mercator" }), this.workerSourceTypes = { vector: ee, geojson: Nt, "batched-model": Ft }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (Fe, tt) => {
              if (this.workerSourceTypes[Fe]) throw new Error(`Worker source with name "${Fe}" already registered.`);
              this.workerSourceTypes[Fe] = tt;
            }, this.self.registerRTLTextPlugin = (Fe) => {
              if (i.ee.isParsed()) throw new Error("RTL text plugin already registered.");
              i.ee.applyArabicShaping = Fe.applyArabicShaping, i.ee.processBidirectionalText = Fe.processBidirectionalText, i.ee.processStyledBidirectionalText = Fe.processStyledBidirectionalText;
            };
          }
          clearCaches(Ae, Fe, tt) {
            delete this.layerIndexes[Ae], delete this.availableImages[Ae], delete this.workerSources[Ae], delete this.demWorkerSources[Ae], delete this.rasterArrayWorkerSource, tt();
          }
          checkIfReady(Ae, Fe, tt) {
            tt();
          }
          setReferrer(Ae, Fe) {
            this.referrer = Fe;
          }
          spriteLoaded(Ae, { scope: Fe, isLoaded: tt }) {
            if (this.isSpriteLoaded[Ae] || (this.isSpriteLoaded[Ae] = {}), this.isSpriteLoaded[Ae][Fe] = tt, this.workerSources[Ae] && this.workerSources[Ae][Fe]) for (const Ct in this.workerSources[Ae][Fe]) {
              const It = this.workerSources[Ae][Fe][Ct];
              for (const Ut in It) {
                const ti = It[Ut];
                ti instanceof ee && (ti.isSpriteLoaded = tt, ti.fire(new i.z("isSpriteLoaded")));
              }
            }
          }
          setImages(Ae, { scope: Fe, images: tt }, Ct) {
            if (this.availableImages[Ae] || (this.availableImages[Ae] = {}), this.availableImages[Ae][Fe] = tt, this.workerSources[Ae] && this.workerSources[Ae][Fe]) {
              for (const It in this.workerSources[Ae][Fe]) {
                const Ut = this.workerSources[Ae][Fe][It];
                for (const ti in Ut) Ut[ti].availableImages = tt;
              }
              Ct();
            } else Ct();
          }
          setProjection(Ae, Fe) {
            this.projections[Ae] = i.bP(Fe);
          }
          setBrightness(Ae, Fe, tt) {
            this.brightness = Fe, tt();
          }
          setLayers(Ae, Fe, tt) {
            this.getLayerIndex(Ae, Fe.scope).replace(Fe.layers, Fe.options), tt();
          }
          updateLayers(Ae, Fe, tt) {
            this.getLayerIndex(Ae, Fe.scope).update(Fe.layers, Fe.removedIds, Fe.options), tt();
          }
          loadTile(Ae, Fe, tt) {
            Fe.projection = this.projections[Ae] || this.defaultProjection, this.getWorkerSource(Ae, Fe.type, Fe.source, Fe.scope).loadTile(Fe, tt);
          }
          loadDEMTile(Ae, Fe, tt) {
            this.getDEMWorkerSource(Ae, Fe.source, Fe.scope).loadTile(Fe, tt);
          }
          decodeRasterArray(Ae, Fe, tt) {
            this.getRasterArrayWorkerSource().decodeRasterArray(Fe, tt);
          }
          reloadTile(Ae, Fe, tt) {
            Fe.projection = this.projections[Ae] || this.defaultProjection, this.getWorkerSource(Ae, Fe.type, Fe.source, Fe.scope).reloadTile(Fe, tt);
          }
          abortTile(Ae, Fe, tt) {
            this.getWorkerSource(Ae, Fe.type, Fe.source, Fe.scope).abortTile(Fe, tt);
          }
          removeTile(Ae, Fe, tt) {
            this.getWorkerSource(Ae, Fe.type, Fe.source, Fe.scope).removeTile(Fe, tt);
          }
          removeSource(Ae, Fe, tt) {
            if (!(this.workerSources[Ae] && this.workerSources[Ae][Fe.scope] && this.workerSources[Ae][Fe.scope][Fe.type] && this.workerSources[Ae][Fe.scope][Fe.type][Fe.source])) return;
            const Ct = this.workerSources[Ae][Fe.scope][Fe.type][Fe.source];
            delete this.workerSources[Ae][Fe.scope][Fe.type][Fe.source], Ct.removeSource !== void 0 ? Ct.removeSource(Fe, tt) : tt();
          }
          loadWorkerSource(Ae, Fe, tt) {
            try {
              this.self.importScripts(Fe.url), tt();
            } catch (Ct) {
              tt(Ct.toString());
            }
          }
          syncRTLPluginState(Ae, Fe, tt) {
            try {
              i.ee.setState(Fe);
              const Ct = i.ee.getPluginURL();
              if (i.ee.isLoaded() && !i.ee.isParsed() && Ct != null) {
                this.self.importScripts(Ct);
                const It = i.ee.isParsed();
                tt(It ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${Ct}`), It);
              }
            } catch (Ct) {
              tt(Ct.toString());
            }
          }
          setDracoUrl(Ae, Fe) {
            this.dracoUrl = Fe;
          }
          getAvailableImages(Ae, Fe) {
            this.availableImages[Ae] || (this.availableImages[Ae] = {});
            let tt = this.availableImages[Ae][Fe];
            return tt || (tt = []), tt;
          }
          getLayerIndex(Ae, Fe) {
            this.layerIndexes[Ae] || (this.layerIndexes[Ae] = {});
            let tt = this.layerIndexes[Ae][Fe];
            return tt || (tt = this.layerIndexes[Ae][Fe] = new A(), tt.scope = Fe), tt;
          }
          getWorkerSource(Ae, Fe, tt, Ct) {
            return this.workerSources[Ae] || (this.workerSources[Ae] = {}), this.workerSources[Ae][Ct] || (this.workerSources[Ae][Ct] = {}), this.workerSources[Ae][Ct][Fe] || (this.workerSources[Ae][Ct][Fe] = {}), this.isSpriteLoaded[Ae] || (this.isSpriteLoaded[Ae] = {}), this.workerSources[Ae][Ct][Fe][tt] || (this.workerSources[Ae][Ct][Fe][tt] = new this.workerSourceTypes[Fe]({ send: (It, Ut, ti, Pt, Wt, ei) => {
              this.actor.send(It, Ut, ti, Ae, Wt, ei);
            }, scheduler: this.actor.scheduler }, this.getLayerIndex(Ae, Ct), this.getAvailableImages(Ae, Ct), this.isSpriteLoaded[Ae][Ct], void 0, this.brightness)), this.workerSources[Ae][Ct][Fe][tt];
          }
          rasterizeImages(Ae, Fe, tt) {
            const { imageTasks: Ct, scope: It } = Fe, Ut = {};
            for (const ti in Ct) {
              const { image: Pt, imageIdWithOptions: Wt } = Ct[ti];
              Ut[ti] = this.imageRasterizer.rasterize(Wt, Pt, It, Ae);
            }
            tt(void 0, Ut);
          }
          removeRasterizedImages(Ae, Fe, tt) {
            const { imageIds: Ct, scope: It } = Fe;
            this.imageRasterizer.removeImagesFromCacheByIds(Ct, It, Ae), tt();
          }
          getDEMWorkerSource(Ae, Fe, tt) {
            return this.demWorkerSources[Ae] || (this.demWorkerSources[Ae] = {}), this.demWorkerSources[Ae][tt] || (this.demWorkerSources[Ae][tt] = {}), this.demWorkerSources[Ae][tt][Fe] || (this.demWorkerSources[Ae][tt][Fe] = new te()), this.demWorkerSources[Ae][tt][Fe];
          }
          getRasterArrayWorkerSource() {
            return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new le()), this.rasterArrayWorkerSource;
          }
          enforceCacheSizeLimit(Ae, Fe) {
            i.ef(Fe);
          }
          getWorkerPerformanceMetrics(Ae, Fe, tt) {
            tt(void 0, void 0);
          }
        }
        return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope && (self.worker = new ai(self)), ai;
      }), q(["./shared"], function(i) {
        var N = "3.10.0";
        const Z = { create: "create", load: "load", fullLoad: "fullLoad" }, R = { mark(u) {
          performance.mark(u);
        }, measure(u, t, n) {
          performance.measure(u, t, n);
        } };
        function A(u) {
          const t = u.name.split("?")[0];
          return i.a(t) && t.includes("mapbox-gl.js") ? "javascript" : i.a(t) && t.includes("mapbox-gl.css") ? "css" : i.b(t) ? "fontRange" : i.c(t) ? "sprite" : i.i(t) ? "style" : i.d(t) ? "tilejson" : "other";
        }
        var M, x = {}, m = function() {
          if (M) return x;
          function u(c) {
            return !t(c);
          }
          function t(c) {
            return typeof window > "u" || typeof document > "u" ? "not a browser" : function() {
              if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
              var v, C, V = new Blob([""], { type: "text/javascript" }), K = URL.createObjectURL(V);
              try {
                C = new Worker(K), v = !0;
              } catch {
                v = !1;
              }
              return C && C.terminate(), URL.revokeObjectURL(K), v;
            }() ? function() {
              var v = document.createElement("canvas");
              v.width = v.height = 1;
              var C = v.getContext("2d");
              if (!C) return !1;
              var V = C.getImageData(0, 0, 1, 1);
              return V && V.width === v.width;
            }() ? (n[p = c && c.failIfMajorPerformanceCaveat] === void 0 && (n[p] = function(v) {
              var C, V = function(K) {
                var se = document.createElement("canvas"), oe = Object.create(u.webGLContextAttributes);
                return oe.failIfMajorPerformanceCaveat = K, se.getContext("webgl2", oe);
              }(v);
              if (!V) return !1;
              try {
                C = V.createShader(V.VERTEX_SHADER);
              } catch {
                return !1;
              }
              return !(!C || V.isContextLost()) && (V.shaderSource(C, "void main() {}"), V.compileShader(C), V.getShaderParameter(C, V.COMPILE_STATUS) === !0);
            }(p)), n[p] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
            var p;
          }
          M = 1, x.supported = u, x.notSupportedReason = t;
          var n = {};
          return u.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 }, x;
        }();
        function w(u, t, n) {
          const c = document.createElement(u);
          return t != null && (c.className = t), n && n.appendChild(c), c;
        }
        function k(u, t, n) {
          const c = document.createElementNS("http://www.w3.org/2000/svg", u);
          for (const p of Object.keys(t)) c.setAttributeNS(null, p, String(t[p]));
          return n && n.appendChild(c), c;
        }
        const E = typeof document < "u" ? document.documentElement && document.documentElement.style : null, P = E && E.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect";
        let S;
        function U() {
          E && P && (S = E[P], E[P] = "none");
        }
        function j() {
          E && P && (E[P] = S);
        }
        function T(u) {
          u.preventDefault(), u.stopPropagation(), window.removeEventListener("click", T, !0);
        }
        function W() {
          window.addEventListener("click", T, !0), window.setTimeout(() => {
            window.removeEventListener("click", T, !0);
          }, 0);
        }
        function J(u, t) {
          const n = u.getBoundingClientRect();
          return le(u, n, t);
        }
        function ee(u, t) {
          const n = u.getBoundingClientRect(), c = [];
          for (let p = 0; p < t.length; p++) c.push(le(u, n, t[p]));
          return c;
        }
        function te(u) {
          return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && u.button === 2 && u.ctrlKey ? 0 : u.button;
        }
        function le(u, t, n) {
          const c = u.offsetWidth === t.width ? 1 : u.offsetWidth / t.width;
          return new i.P((n.clientX - t.left) * c, (n.clientY - t.top) * c);
        }
        const me = "01", ke = "NO_ACCESS_TOKEN";
        class ge {
          constructor(t, n, c) {
            this._transformRequestFn = t, this._customAccessToken = n, this._silenceAuthErrors = !!c, this._createSkuToken();
          }
          _createSkuToken() {
            const t = function() {
              let n = "";
              for (let c = 0; c < 10; c++) n += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
              return { token: ["1", me, n].join(""), tokenExpiresAt: Date.now() + 432e5 };
            }();
            this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;
          }
          _isSkuTokenExpired() {
            return Date.now() > this._skuTokenExpiresAt;
          }
          transformRequest(t, n) {
            return this._transformRequestFn && this._transformRequestFn(t, n) || { url: t };
          }
          normalizeStyleURL(t, n) {
            if (!i.f(t)) return t;
            const c = Oe(t);
            return c.params.push(`sdk=js-${N}`), c.path = `/styles/v1${c.path}`, this._makeAPIURL(c, this._customAccessToken || n);
          }
          normalizeGlyphsURL(t, n) {
            if (!i.f(t)) return t;
            const c = Oe(t);
            return c.path = `/fonts/v1${c.path}`, this._makeAPIURL(c, this._customAccessToken || n);
          }
          normalizeModelURL(t, n) {
            if (!i.f(t)) return t;
            const c = Oe(t);
            return c.path = `/models/v1${c.path}`, this._makeAPIURL(c, this._customAccessToken || n);
          }
          normalizeSourceURL(t, n, c, p) {
            if (!i.f(t)) return t;
            const v = Oe(t);
            return v.path = `/v4/${v.authority}.json`, v.params.push("secure"), c && v.params.push(`language=${c}`), p && v.params.push(`worldview=${p}`), this._makeAPIURL(v, this._customAccessToken || n);
          }
          normalizeIconsetURL(t, n) {
            const c = Oe(t);
            return i.f(t) ? (c.path = `/styles/v1${c.path}/iconset.pbf`, this._makeAPIURL(c, this._customAccessToken || n)) : Ue(c);
          }
          normalizeSpriteURL(t, n, c, p) {
            const v = Oe(t);
            return i.f(t) ? (v.path = `/styles/v1${v.path}/sprite${n}${c}`, this._makeAPIURL(v, this._customAccessToken || p)) : (v.path += `${n}${c}`, Ue(v));
          }
          normalizeTileURL(t, n, c) {
            if (this._isSkuTokenExpired() && this._createSkuToken(), t && !i.f(t)) return t;
            const p = Oe(t);
            p.path = p.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${n || c && p.authority !== "raster" && c === 512 ? "@2x" : ""}${i.m.supported ? ".webp" : "$1"}`), p.authority === "raster" ? p.path = `/${i.e.RASTER_URL_PREFIX}${p.path}` : p.authority === "rasterarrays" ? p.path = `/${i.e.RASTERARRAYS_URL_PREFIX}${p.path}` : p.authority === "3dtiles" ? p.path = `/${i.e.TILES3D_URL_PREFIX}${p.path}` : (p.path = p.path.replace(/^.+\/v4\//, "/"), p.path = `/${i.e.TILE_URL_VERSION}${p.path}`);
            const v = this._customAccessToken || function(C) {
              for (const V of C) {
                const K = V.match(/^access_token=(.*)$/);
                if (K) return K[1];
              }
              return null;
            }(p.params) || i.e.ACCESS_TOKEN;
            return i.e.REQUIRE_ACCESS_TOKEN && v && this._skuToken && p.params.push(`sku=${this._skuToken}`), this._makeAPIURL(p, v);
          }
          canonicalizeTileURL(t, n) {
            const c = Oe(t);
            if (!c.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !c.path.match(/\.[\w]+$/)) return t;
            let p = "mapbox://";
            c.path.match(/^\/raster\/v1\//) ? p += `raster/${c.path.replace(`/${i.e.RASTER_URL_PREFIX}/`, "")}` : c.path.match(/^\/rasterarrays\/v1\//) ? p += `rasterarrays/${c.path.replace(`/${i.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : p += `tiles/${c.path.replace(`/${i.e.TILE_URL_VERSION}/`, "")}`;
            let v = c.params;
            return n && (v = v.filter((C) => !C.match(/^access_token=/))), v.length && (p += `?${v.join("&")}`), p;
          }
          canonicalizeTileset(t, n) {
            const c = !!n && i.f(n), p = [];
            for (const v of t.tiles || []) i.h(v) ? p.push(this.canonicalizeTileURL(v, c)) : p.push(v);
            return p;
          }
          _makeAPIURL(t, n) {
            const c = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", p = Oe(i.e.API_URL);
            if (t.protocol = p.protocol, t.authority = p.authority, t.protocol === "http") {
              const v = t.params.indexOf("secure");
              v >= 0 && t.params.splice(v, 1);
            }
            if (p.path !== "/" && (t.path = `${p.path}${t.path}`), !i.e.REQUIRE_ACCESS_TOKEN) return Ue(t);
            if (n = n || i.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
              if (!n) throw new Error(`An API access token is required to use Mapbox GL. ${c}`);
              if (n[0] === "s") throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${c}`);
            }
            return t.params = t.params.filter((v) => v.indexOf("access_token") === -1), t.params.push(`access_token=${n || ""}`), Ue(t);
          }
        }
        const Ve = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function Oe(u) {
          const t = u.match(Ve);
          if (!t) throw new Error("Unable to parse URL object");
          return { protocol: t[1], authority: t[2], path: t[3] || "/", params: t[4] ? t[4].split("&") : [] };
        }
        function Ue(u) {
          const t = u.params.length ? `?${u.params.join("&")}` : "";
          return `${u.protocol}://${u.authority}${u.path}${t}`;
        }
        const we = "mapbox.eventData";
        function Ce(u) {
          if (!u) return null;
          const t = u.split(".");
          if (!t || t.length !== 3) return null;
          try {
            return JSON.parse(i.j(t[1]));
          } catch {
            return null;
          }
        }
        class it {
          constructor(t) {
            this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
          }
          getStorageKey(t) {
            const n = Ce(i.e.ACCESS_TOKEN);
            let c = "";
            return c = n && n.u ? i.k(n.u) : i.e.ACCESS_TOKEN || "", t ? `${we}.${t}:${c}` : `${we}:${c}`;
          }
          fetchEventData() {
            const t = i.s("localStorage"), n = this.getStorageKey(), c = this.getStorageKey("uuid");
            if (t) try {
              const p = localStorage.getItem(n);
              p && (this.eventData = JSON.parse(p));
              const v = localStorage.getItem(c);
              v && (this.anonId = v);
            } catch {
              i.w("Unable to read from LocalStorage");
            }
          }
          saveEventData() {
            const t = i.s("localStorage"), n = this.getStorageKey(), c = this.getStorageKey("uuid"), p = this.anonId;
            if (t && p) try {
              localStorage.setItem(c, p), Object.keys(this.eventData).length >= 1 && localStorage.setItem(n, JSON.stringify(this.eventData));
            } catch {
              i.w("Unable to write to LocalStorage");
            }
          }
          processRequests(t) {
          }
          postEvent(t, n, c, p) {
            if (!i.e.EVENTS_URL) return;
            const v = Oe(i.e.EVENTS_URL);
            v.params.push(`access_token=${p || i.e.ACCESS_TOKEN || ""}`);
            const C = { event: this.type, created: new Date(t).toISOString() }, V = n ? i.l(C, n) : C, K = { url: Ue(v), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([V]) };
            this.pendingRequest = i.p(K, (se) => {
              this.pendingRequest = null, c(se), this.saveEventData(), this.processRequests(p);
            });
          }
          queueRequest(t, n) {
            this.queue.push(t), this.processRequests(n);
          }
        }
        const ut = new class extends it {
          constructor(u) {
            super("appUserTurnstile"), this._customAccessToken = u;
          }
          postTurnstileEvent(u, t) {
            i.e.EVENTS_URL && i.e.ACCESS_TOKEN && Array.isArray(u) && u.some((n) => i.f(n) || i.h(n)) && this.queueRequest(Date.now(), t);
          }
          processRequests(u) {
            if (this.pendingRequest || this.queue.length === 0) return;
            this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
            const t = Ce(i.e.ACCESS_TOKEN), n = t ? t.u : i.e.ACCESS_TOKEN;
            let c = n !== this.eventData.tokenU;
            i.v(this.anonId) || (this.anonId = i.u(), c = !0);
            const p = this.queue.shift();
            if (this.eventData.lastSuccess) {
              const v = new Date(this.eventData.lastSuccess), C = new Date(p), V = (p - this.eventData.lastSuccess) / 864e5;
              c = c || V >= 1 || V < -1 || v.getDate() !== C.getDate();
            } else c = !0;
            c ? this.postEvent(p, { sdkIdentifier: "mapbox-gl-js", sdkVersion: N, skuId: me, "enabled.telemetry": !1, userId: this.anonId }, (v) => {
              v || (this.eventData.lastSuccess = p, this.eventData.tokenU = n);
            }, u) : this.processRequests();
          }
        }(), bt = ut.postTurnstileEvent.bind(ut), pt = new class extends it {
          constructor() {
            super("map.load"), this.success = {}, this.skuToken = "";
          }
          postMapLoadEvent(u, t, n, c) {
            this.skuToken = t, this.errorCb = c, i.e.EVENTS_URL && (n || i.e.ACCESS_TOKEN ? this.queueRequest({ id: u, timestamp: Date.now() }, n) : this.errorCb(new Error(ke)));
          }
          processRequests(u) {
            if (this.pendingRequest || this.queue.length === 0) return;
            const { id: t, timestamp: n } = this.queue.shift();
            t && this.success[t] || (this.anonId || this.fetchEventData(), i.v(this.anonId) || (this.anonId = i.u()), this.postEvent(n, { sdkIdentifier: "mapbox-gl-js", sdkVersion: N, skuId: me, skuToken: this.skuToken, userId: this.anonId }, (c) => {
              c ? this.errorCb(c) : t && (this.success[t] = !0);
            }, u));
          }
          remove() {
            this.errorCb = null;
          }
        }(), Ke = pt.postMapLoadEvent.bind(pt), dt = new class extends it {
          constructor() {
            super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
          }
          getMapInstanceId(u) {
            let t = this.mapInstanceIdMap.get(u);
            return t || (t = i.u(), this.mapInstanceIdMap.set(u, t)), t;
          }
          getEventId(u) {
            const t = this.eventIdPerMapInstanceMap.get(u) || 0;
            return this.eventIdPerMapInstanceMap.set(u, t + 1), t;
          }
          postStyleLoadEvent(u, t) {
            const { map: n, style: c, importedStyles: p } = t;
            if (!i.e.EVENTS_URL || !u && !i.e.ACCESS_TOKEN) return;
            const v = this.getMapInstanceId(n), C = { mapInstanceId: v, eventId: this.getEventId(v), style: c };
            p.length && (C.importedStyles = p), this.queueRequest({ timestamp: Date.now(), payload: C }, u);
          }
          processRequests(u) {
            if (this.pendingRequest || this.queue.length === 0) return;
            const { timestamp: t, payload: n } = this.queue.shift();
            this.postEvent(t, n, () => {
            }, u);
          }
        }(), ct = dt.postStyleLoadEvent.bind(dt), wt = new class extends it {
          constructor() {
            super("gljs.performance");
          }
          postPerformanceEvent(u, t) {
            i.e.EVENTS_URL && (u || i.e.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: t }, u);
          }
          processRequests(u) {
            if (this.pendingRequest || this.queue.length === 0) return;
            const { timestamp: t, performanceData: n } = this.queue.shift(), c = function(p) {
              const v = performance.getEntriesByType("resource"), C = performance.getEntriesByType("mark"), V = function(Le) {
                const ft = {};
                if (Le) {
                  for (const st in Le) if (st !== "other") for (const vt of Le[st]) {
                    const gt = `${st}ResolveRangeMin`, Rt = `${st}ResolveRangeMax`, qt = `${st}RequestCount`, jt = `${st}RequestCachedCount`;
                    ft[gt] = Math.min(ft[gt] || 1 / 0, vt.startTime), ft[Rt] = Math.max(ft[Rt] || -1 / 0, vt.responseEnd);
                    const ii = (Xt) => {
                      ft[Xt] === void 0 && (ft[Xt] = 0), ++ft[Xt];
                    };
                    vt.transferSize !== void 0 && vt.transferSize === 0 && ii(jt), ii(qt);
                  }
                }
                return ft;
              }(function(Le, ft) {
                const st = {};
                if (Le) for (const vt of Le) {
                  const gt = ft(vt);
                  st[gt] === void 0 && (st[gt] = []), st[gt].push(vt);
                }
                return st;
              }(v, A)), K = window.devicePixelRatio, se = navigator.connection || navigator.mozConnection || navigator.webkitConnection, oe = se ? se.effectiveType : void 0, ve = { counters: [], metadata: [], attributes: [] }, xe = (Le, ft, st) => {
                st != null && Le.push({ name: ft, value: st.toString() });
              };
              for (const Le in V) xe(ve.counters, Le, V[Le]);
              if (p.interactionRange[0] !== 1 / 0 && p.interactionRange[1] !== -1 / 0 && (xe(ve.counters, "interactionRangeMin", p.interactionRange[0]), xe(ve.counters, "interactionRangeMax", p.interactionRange[1])), C) for (const Le of Object.keys(Z)) {
                const ft = Z[Le], st = C.find((vt) => vt.name === ft);
                st && xe(ve.counters, ft, st.startTime);
              }
              return xe(ve.counters, "visibilityHidden", p.visibilityHidden), xe(ve.attributes, "style", function(Le) {
                if (Le) for (const ft of Le) {
                  const st = ft.name.split("?")[0];
                  if (i.i(st)) {
                    const vt = st.split("/").slice(-2);
                    if (vt.length === 2) return `mapbox://styles/${vt[0]}/${vt[1]}`;
                  }
                }
              }(v)), xe(ve.attributes, "terrainEnabled", p.terrainEnabled ? "true" : "false"), xe(ve.attributes, "fogEnabled", p.fogEnabled ? "true" : "false"), xe(ve.attributes, "projection", p.projection), xe(ve.attributes, "zoom", p.zoom), xe(ve.metadata, "devicePixelRatio", K), xe(ve.metadata, "connectionEffectiveType", oe), xe(ve.metadata, "navigatorUserAgent", navigator.userAgent), xe(ve.metadata, "screenWidth", window.screen.width), xe(ve.metadata, "screenHeight", window.screen.height), xe(ve.metadata, "windowWidth", window.innerWidth), xe(ve.metadata, "windowHeight", window.innerHeight), xe(ve.metadata, "mapWidth", p.width / K), xe(ve.metadata, "mapHeight", p.height / K), xe(ve.metadata, "webglRenderer", p.renderer), xe(ve.metadata, "webglVendor", p.vendor), xe(ve.metadata, "sdkVersion", N), xe(ve.metadata, "sdkIdentifier", "mapbox-gl-js"), ve;
            }(n);
            for (const p of c.metadata) ;
            for (const p of c.counters) ;
            for (const p of c.attributes) ;
            this.postEvent(t, c, () => {
            }, u);
          }
        }(), Ht = wt.postPerformanceEvent.bind(wt), $t = new class extends it {
          constructor() {
            super("map.auth"), this.success = {}, this.skuToken = "";
          }
          getSession(u, t, n, c) {
            if (!i.e.API_URL || !i.e.SESSION_PATH) return;
            const p = Oe(i.e.API_URL + i.e.SESSION_PATH);
            p.params.push(`sku=${t || ""}`), p.params.push(`access_token=${c || i.e.ACCESS_TOKEN || ""}`);
            const v = { url: Ue(p), headers: { "Content-Type": "text/plain" } };
            this.pendingRequest = i.g(v, (C) => {
              this.pendingRequest = null, n(C), this.saveEventData(), this.processRequests(c);
            });
          }
          getSessionAPI(u, t, n, c) {
            this.skuToken = t, this.errorCb = c, i.e.SESSION_PATH && i.e.API_URL && (n || i.e.ACCESS_TOKEN ? this.queueRequest({ id: u, timestamp: Date.now() }, n) : this.errorCb(new Error(ke)));
          }
          processRequests(u) {
            if (this.pendingRequest || this.queue.length === 0) return;
            const { id: t, timestamp: n } = this.queue.shift();
            t && this.success[t] || this.getSession(n, this.skuToken, (c) => {
              c ? this.errorCb(c) : t && (this.success[t] = !0);
            }, u);
          }
          remove() {
            this.errorCb = null;
          }
        }(), rt = $t.getSessionAPI.bind($t), ri = /* @__PURE__ */ new Set();
        function wi(u, t) {
          t ? ri.add(u) : ri.delete(u);
        }
        class Qt {
          constructor() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = /* @__PURE__ */ new Set();
          }
          isDirty() {
            return this._changed;
          }
          setDirty() {
            this._changed = !0;
          }
          getUpdatedSourceCaches() {
            return this._updatedSourceCaches;
          }
          updateSourceCache(t, n) {
            this._updatedSourceCaches[t] = n, this.setDirty();
          }
          discardSourceCacheUpdate(t) {
            delete this._updatedSourceCaches[t];
          }
          updateLayer(t) {
            const n = t.scope;
            this._updatedLayers[n] = this._updatedLayers[n] || /* @__PURE__ */ new Set(), this._updatedLayers[n].add(t.id), this.setDirty();
          }
          removeLayer(t) {
            const n = t.scope;
            this._removedLayers[n] = this._removedLayers[n] || {}, this._updatedLayers[n] = this._updatedLayers[n] || /* @__PURE__ */ new Set(), this._removedLayers[n][t.id] = t, this._updatedLayers[n].delete(t.id), this._updatedPaintProps.delete(t.fqid), this.setDirty();
          }
          getRemovedLayer(t) {
            return this._removedLayers[t.scope] ? this._removedLayers[t.scope][t.id] : null;
          }
          discardLayerRemoval(t) {
            this._removedLayers[t.scope] && delete this._removedLayers[t.scope][t.id];
          }
          getLayerUpdatesByScope() {
            const t = {};
            for (const n in this._updatedLayers) t[n] = t[n] || {}, t[n].updatedIds = Array.from(this._updatedLayers[n].values());
            for (const n in this._removedLayers) t[n] = t[n] || {}, t[n].removedIds = Object.keys(this._removedLayers[n]);
            return t;
          }
          getUpdatedPaintProperties() {
            return this._updatedPaintProps;
          }
          updatePaintProperties(t) {
            this._updatedPaintProps.add(t.fqid), this.setDirty();
          }
          getUpdatedImages() {
            return Array.from(this._updatedImages.values());
          }
          updateImage(t) {
            this._updatedImages.add(t), this.setDirty();
          }
          resetUpdatedImages() {
            this._updatedImages.clear();
          }
          reset() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
          }
        }
        function At(u) {
          const { userImage: t } = u;
          return !!(t && t.render && t.render()) && (u.data.replace(new Uint8Array(t.data.buffer)), !0);
        }
        class St extends i.E {
          constructor(t) {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = !0, this.spriteFormat = t, t !== "raster" && i.t() && (this.imageRasterizerDispatcher = new i.D(i.x(), this, "Image Rasterizer Worker", 1));
          }
          get imageRasterizer() {
            return this._imageRasterizer || (this._imageRasterizer = new i.I()), this._imageRasterizer;
          }
          createScope(t) {
            this.images[t] = {}, this.loaded[t] = !1, this.updatedImages[t] = {}, this.patterns[t] = {}, this.callbackDispatchedThisFrame[t] = {}, this.atlasImage[t] = new i.r({ width: 1, height: 1 });
          }
          isLoaded() {
            for (const t in this.loaded) if (!this.loaded[t]) return !1;
            return !0;
          }
          setLoaded(t, n) {
            if (this.loaded[n] !== t && (this.loaded[n] = t, t)) {
              for (const { ids: c, callback: p } of this.requestors) this._notify(c, n, p);
              this.requestors = [];
            }
          }
          hasImage(t, n) {
            return !!this.getImage(t, n);
          }
          getImage(t, n) {
            return this.images[n][t];
          }
          addImage(t, n, c) {
            this._validate(t, c) && (this.images[n][t] = c);
          }
          _validate(t, n) {
            let c = !0;
            return this._validateStretch(n.stretchX, n.data && n.data.width) || (this.fire(new i.y(new Error(`Image "${t}" has invalid "stretchX" value`))), c = !1), this._validateStretch(n.stretchY, n.data && n.data.height) || (this.fire(new i.y(new Error(`Image "${t}" has invalid "stretchY" value`))), c = !1), this._validateContent(n.content, n) || (this.fire(new i.y(new Error(`Image "${t}" has invalid "content" value`))), c = !1), c;
          }
          _validateStretch(t, n) {
            if (!t) return !0;
            let c = 0;
            for (const p of t) {
              if (p[0] < c || p[1] < p[0] || n < p[1]) return !1;
              c = p[1];
            }
            return !0;
          }
          _validateContent(t, n) {
            return t ? t.length !== 4 || !n.usvg && (t[0] < 0 || n.data.width < t[0] || t[1] < 0 || n.data.height < t[1] || t[2] < 0 || n.data.width < t[2] || t[3] < 0 || n.data.height < t[3]) ? !1 : !(t[2] < t[0] || t[3] < t[1]) : !0;
          }
          updateImage(t, n, c) {
            c.version = this.images[n][t].version + 1, this.images[n][t] = c, this.updatedImages[n][t] = !0, this.removeFromImageRasterizerCache(t, n);
          }
          removeFromImageRasterizerCache(t, n) {
            this.spriteFormat !== "raster" && (i.t() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", { imageIds: [t], scope: n }) : this.imageRasterizer.removeImagesFromCacheByIds([t], n));
          }
          removeImage(t, n) {
            const c = this.images[n][t];
            delete this.images[n][t], delete this.patterns[n][t], this.removeFromImageRasterizerCache(t, n), c.userImage && c.userImage.onRemove && c.userImage.onRemove();
          }
          listImages(t) {
            return Object.keys(this.images[t]);
          }
          getImages(t, n, c) {
            let p = !0;
            const v = !!this.loaded[n];
            if (!v) for (const C of t) this.images[n][C] || (p = !1);
            v || p ? this._notify(t, n, c) : this.requestors.push({ ids: t, scope: n, callback: c });
          }
          rasterizeImages({ scope: t, imageTasks: n }, c) {
            const p = {};
            for (const v in n) {
              const C = n[v], V = this.getImage(C.id, t);
              V && (p[v] = { image: V, imageIdWithOptions: C });
            }
            i.t() ? this.imageRasterizerDispatcher.getActor().send("rasterizeImages", { imageTasks: p, scope: t }, c) : this.rasterizeImagesInMainThread({ imageTasks: p, scope: t }, c);
          }
          rasterizeImagesInMainThread(t, n) {
            const { imageTasks: c, scope: p } = t, v = {};
            for (const C in c) {
              const { image: V, imageIdWithOptions: K } = c[C];
              v[C] = this.imageRasterizer.rasterize(K, V, p, "");
            }
            n(void 0, v);
          }
          getUpdatedImages(t) {
            return this.updatedImages[t];
          }
          _notify(t, n, c) {
            const p = {};
            for (const v of t) {
              this.images[n][v] || this.fire(new i.z("styleimagemissing", { id: v }));
              const C = this.images[n][v];
              C ? p[v] = { data: C.usvg ? null : C.data.clone(), pixelRatio: C.pixelRatio, sdf: C.sdf, usvg: C.usvg, version: C.version, stretchX: C.stretchX, stretchY: C.stretchY, content: C.content, hasRenderCallback: !!(C.userImage && C.userImage.render) } : i.w(`Image "${v}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            c(null, p);
          }
          getPixelSize(t) {
            const { width: n, height: c } = this.atlasImage[t];
            return { width: n, height: c };
          }
          getPattern(t, n, c) {
            const p = this.patterns[n][t], v = this.getImage(t, n);
            if (!v) return null;
            if (p && p.position.version === v.version) return p.position;
            if (p) p.position.version = v.version;
            else {
              v.usvg && !v.data && (v.data = this.imageRasterizer.rasterize(i.A.from(t).getPrimary(), v, n, ""));
              const C = { w: v.data.width + 2 * i.B, h: v.data.height + 2 * i.B, x: 0, y: 0 }, V = new i.C(C, v, i.B);
              this.patterns[n][t] = { bin: C, position: V };
            }
            return this._updatePatternAtlas(n, c), this.patterns[n][t].position;
          }
          bind(t, n) {
            const c = t.gl;
            let p = this.atlasTexture[n];
            p ? this.dirty && (p.update(this.atlasImage[n]), this.dirty = !1) : (p = new i.T(t, this.atlasImage[n], c.RGBA8), this.atlasTexture[n] = p), p.bind(c.LINEAR, c.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas(t, n) {
            const c = [];
            for (const V in this.patterns[t]) c.push(this.patterns[t][V].bin);
            const { w: p, h: v } = i.F(c), C = this.atlasImage[t];
            C.resize({ width: p || 1, height: v || 1 });
            for (const V in this.patterns[t]) {
              const { bin: K, position: se } = this.patterns[t][V];
              let oe = se.padding;
              const ve = K.x + oe, xe = K.y + oe, Le = this.images[t][V].data, ft = Le.width, st = Le.height;
              oe = oe > 1 ? oe - 1 : oe, i.r.copy(Le, C, { x: 0, y: 0 }, { x: ve, y: xe }, { width: ft, height: st }, n), i.r.copy(Le, C, { x: 0, y: st - oe }, { x: ve, y: xe - oe }, { width: ft, height: oe }, n), i.r.copy(Le, C, { x: 0, y: 0 }, { x: ve, y: xe + st }, { width: ft, height: oe }, n), i.r.copy(Le, C, { x: ft - oe, y: 0 }, { x: ve - oe, y: xe }, { width: oe, height: st }, n), i.r.copy(Le, C, { x: 0, y: 0 }, { x: ve + ft, y: xe }, { width: oe, height: st }, n), i.r.copy(Le, C, { x: ft - oe, y: st - oe }, { x: ve - oe, y: xe - oe }, { width: oe, height: oe }, n), i.r.copy(Le, C, { x: 0, y: st - oe }, { x: ve + ft, y: xe - oe }, { width: oe, height: oe }, n), i.r.copy(Le, C, { x: 0, y: 0 }, { x: ve + ft, y: xe + st }, { width: oe, height: oe }, n), i.r.copy(Le, C, { x: ft - oe, y: 0 }, { x: ve - oe, y: xe + st }, { width: oe, height: oe }, n);
            }
            this.dirty = !0;
          }
          beginFrame() {
            for (const t in this.images) this.callbackDispatchedThisFrame[t] = {};
          }
          dispatchRenderCallbacks(t, n) {
            for (const c of t) {
              if (this.callbackDispatchedThisFrame[n][c]) continue;
              this.callbackDispatchedThisFrame[n][c] = !0;
              const p = this.images[n][c];
              At(p) && this.updateImage(c, n, p);
            }
          }
        }
        function Lt(u) {
          const t = u.key, n = u.value, c = u.valueSpec || {}, p = u.objectElementValidators || {}, v = u.style, C = u.styleSpec;
          let V = [];
          const K = i.H(n);
          if (K !== "object") return [new i.V(t, n, `object expected, ${K} found`)];
          for (const se in n) {
            const oe = se.split(".")[0];
            let ve;
            p[oe] ? ve = p[oe] : c[oe] ? ve = Se : p["*"] ? ve = p["*"] : c["*"] && (ve = Se), ve ? V = V.concat(ve({ key: (t && `${t}.`) + se, value: n[se], valueSpec: c[oe] || c["*"], style: v, styleSpec: C, object: n, objectKey: se }, n)) : V.push(new i.G(t, n[se], `unknown property "${se}"`));
          }
          for (const se in c) p[se] || c[se].required && c[se].default === void 0 && n[se] === void 0 && V.push(new i.V(t, n, `missing required property "${se}"`));
          return V;
        }
        function kt(u) {
          const t = u.value, n = u.valueSpec, c = u.style, p = u.styleSpec, v = u.key, C = u.arrayElementValidator || Se;
          if (i.H(t) !== "array") return [new i.V(v, t, `array expected, ${i.H(t)} found`)];
          if (n.length && t.length !== n.length) return [new i.V(v, t, `array length ${n.length} expected, length ${t.length} found`)];
          if (n["min-length"] && t.length < n["min-length"]) return [new i.V(v, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
          let V = { type: n.value, values: n.values, minimum: n.minimum, maximum: n.maximum, function: void 0 };
          p.$version < 7 && (V.function = n.function), i.H(n.value) === "object" && (V = n.value);
          let K = [];
          for (let se = 0; se < t.length; se++) K = K.concat(C({ array: t, arrayIndex: se, value: t[se], valueSpec: V, style: c, styleSpec: p, key: `${v}[${se}]` }, !0));
          return K;
        }
        function Ye(u) {
          const t = u.key, n = u.value, c = u.valueSpec;
          let p = i.H(n);
          if (p === "number" && n != n && (p = "NaN"), p !== "number") return [new i.V(t, n, `number expected, ${p} found`)];
          if ("minimum" in c) {
            let v = c.minimum;
            if (i.H(c.minimum) === "array" && (v = c.minimum[u.arrayIndex]), n < v) return [new i.V(t, n, `${n} is less than the minimum value ${v}`)];
          }
          if ("maximum" in c) {
            let v = c.maximum;
            if (i.H(c.maximum) === "array" && (v = c.maximum[u.arrayIndex]), n > v) return [new i.V(t, n, `${n} is greater than the maximum value ${v}`)];
          }
          return [];
        }
        function De(u) {
          const t = u.valueSpec, n = i.K(u.value.type);
          let c, p, v, C = {};
          const V = n !== "categorical" && u.value.property === void 0, K = !V, se = i.H(u.value.stops) === "array" && i.H(u.value.stops[0]) === "array" && i.H(u.value.stops[0][0]) === "object", oe = Lt({ key: u.key, value: u.value, valueSpec: u.styleSpec.function, style: u.style, styleSpec: u.styleSpec, objectElementValidators: { stops: function(Le) {
            if (n === "identity") return [new i.V(Le.key, Le.value, 'identity function may not have a "stops" property')];
            let ft = [];
            const st = Le.value;
            return ft = ft.concat(kt({ key: Le.key, value: st, valueSpec: Le.valueSpec, style: Le.style, styleSpec: Le.styleSpec, arrayElementValidator: ve })), i.H(st) === "array" && st.length === 0 && ft.push(new i.V(Le.key, st, "array must have at least one stop")), ft;
          }, default: function(Le) {
            return Se({ key: Le.key, value: Le.value, valueSpec: t, style: Le.style, styleSpec: Le.styleSpec });
          } } });
          return n === "identity" && V && oe.push(new i.V(u.key, u.value, 'missing required property "property"')), n === "identity" || u.value.stops || oe.push(new i.V(u.key, u.value, 'missing required property "stops"')), n === "exponential" && u.valueSpec.expression && !i.L(u.valueSpec) && oe.push(new i.V(u.key, u.value, "exponential functions not supported")), u.styleSpec.$version >= 8 && (K && !i.M(u.valueSpec) ? oe.push(new i.V(u.key, u.value, "property functions not supported")) : V && !i.N(u.valueSpec) && oe.push(new i.V(u.key, u.value, "zoom functions not supported"))), n !== "categorical" && !se || u.value.property !== void 0 || oe.push(new i.V(u.key, u.value, '"property" property is required')), oe;
          function ve(Le) {
            let ft = [];
            const st = Le.value, vt = Le.key;
            if (i.H(st) !== "array") return [new i.V(vt, st, `array expected, ${i.H(st)} found`)];
            if (st.length !== 2) return [new i.V(vt, st, `array length 2 expected, length ${st.length} found`)];
            if (se) {
              if (i.H(st[0]) !== "object") return [new i.V(vt, st, `object expected, ${i.H(st[0])} found`)];
              if (st[0].zoom === void 0) return [new i.V(vt, st, "object stop key must have zoom")];
              if (st[0].value === void 0) return [new i.V(vt, st, "object stop key must have value")];
              const gt = i.K(st[0].zoom);
              if (typeof gt != "number") return [new i.V(vt, st[0].zoom, "stop zoom values must be numbers")];
              if (v && v > gt) return [new i.V(vt, st[0].zoom, "stop zoom values must appear in ascending order")];
              gt !== v && (v = gt, p = void 0, C = {}), ft = ft.concat(Lt({ key: `${vt}[0]`, value: st[0], valueSpec: { zoom: {} }, style: Le.style, styleSpec: Le.styleSpec, objectElementValidators: { zoom: Ye, value: xe } }));
            } else ft = ft.concat(xe({ key: `${vt}[0]`, value: st[0], valueSpec: {}, style: Le.style, styleSpec: Le.styleSpec }, st));
            return i.O(i.Q(st[1])) ? ft.concat([new i.V(`${vt}[1]`, st[1], "expressions are not allowed in function stops.")]) : ft.concat(Se({ key: `${vt}[1]`, value: st[1], valueSpec: t, style: Le.style, styleSpec: Le.styleSpec }));
          }
          function xe(Le, ft) {
            const st = i.H(Le.value), vt = i.K(Le.value), gt = Le.value !== null ? Le.value : ft;
            if (c) {
              if (st !== c) return [new i.V(Le.key, gt, `${st} stop domain type must match previous stop domain type ${c}`)];
            } else c = st;
            if (st !== "number" && st !== "string" && st !== "boolean" && typeof vt != "number" && typeof vt != "string" && typeof vt != "boolean") return [new i.V(Le.key, gt, "stop domain value must be a number, string, or boolean")];
            if (st !== "number" && n !== "categorical") {
              let Rt = `number expected, ${st} found`;
              return i.M(t) && n === void 0 && (Rt += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new i.V(Le.key, gt, Rt)];
            }
            return n !== "categorical" || st !== "number" || typeof vt == "number" && isFinite(vt) && Math.floor(vt) === vt ? n !== "categorical" && st === "number" && typeof vt == "number" && typeof p == "number" && p !== void 0 && vt < p ? [new i.V(Le.key, gt, "stop domain values must appear in ascending order")] : (p = vt, n === "categorical" && vt in C ? [new i.V(Le.key, gt, "stop domain values must be unique")] : (C[vt] = !0, [])) : [new i.V(Le.key, gt, `integer expected, found ${String(vt)}`)];
          }
        }
        function Re(u) {
          const t = (u.expressionContext === "property" ? i.S : i.U)(i.Q(u.value), u.valueSpec);
          if (t.result === "error") return t.value.map((c) => new i.V(`${u.key}${c.key}`, u.value, c.message));
          const n = t.value.expression || t.value._styleExpression.expression;
          if (u.expressionContext === "property" && u.propertyKey === "text-font" && !n.outputDefined()) return [new i.V(u.key, u.value, `Invalid data expression for "${u.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (u.expressionContext === "property" && u.propertyType === "layout" && !i.W(n)) return [new i.V(u.key, u.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (u.expressionContext === "filter") return _t(n, u);
          if (u.expressionContext && u.expressionContext.indexOf("cluster") === 0) {
            if (!i.X(n, ["zoom", "feature-state"])) return [new i.V(u.key, u.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (u.expressionContext === "cluster-initial" && !i.Y(n)) return [new i.V(u.key, u.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function _t(u, t) {
          const n = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
          if (t.valueSpec && t.valueSpec.expression) for (const p of t.valueSpec.expression.parameters) n.delete(p);
          if (n.size === 0) return [];
          const c = [];
          return u instanceof i.Z && n.has(u.name) ? [new i.V(t.key, t.value, `["${u.name}"] expression is not supported in a filter for a ${t.object.type} layer with id: ${t.object.id}`)] : (u.eachChild((p) => {
            c.push(..._t(p, t));
          }), c);
        }
        function et(u) {
          const t = u.key, n = u.value, c = u.valueSpec, p = [];
          return Array.isArray(c.values) ? c.values.indexOf(i.K(n)) === -1 && p.push(new i.V(t, n, `expected one of [${c.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(c.values).indexOf(i.K(n)) === -1 && p.push(new i.V(t, n, `expected one of [${Object.keys(c.values).join(", ")}], ${JSON.stringify(n)} found`)), p;
        }
        function Ie(u) {
          return i.$(i.Q(u.value)) ? Re(i.J({}, u, { expressionContext: "filter", valueSpec: u.styleSpec[`filter_${u.layerType || "fill"}`] })) : pe(u);
        }
        function pe(u) {
          const t = u.value, n = u.key;
          if (i.H(t) !== "array") return [new i.V(n, t, `array expected, ${i.H(t)} found`)];
          const c = u.styleSpec;
          let p, v = [];
          if (t.length < 1) return [new i.V(n, t, "filter array must have at least 1 element")];
          switch (v = v.concat(et({ key: `${n}[0]`, value: t[0], valueSpec: c.filter_operator, style: u.style, styleSpec: u.styleSpec })), i.K(t[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              t.length >= 2 && i.K(t[1]) === "$type" && v.push(new i.V(n, t, `"$type" cannot be use with operator "${t[0]}"`));
            case "==":
            case "!=":
              t.length !== 3 && v.push(new i.V(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
            case "in":
            case "!in":
              t.length >= 2 && (p = i.H(t[1]), p !== "string" && v.push(new i.V(`${n}[1]`, t[1], `string expected, ${p} found`)));
              for (let C = 2; C < t.length; C++) p = i.H(t[C]), i.K(t[1]) === "$type" ? v = v.concat(et({ key: `${n}[${C}]`, value: t[C], valueSpec: c.geometry_type, style: u.style, styleSpec: u.styleSpec })) : p !== "string" && p !== "number" && p !== "boolean" && v.push(new i.V(`${n}[${C}]`, t[C], `string, number, or boolean expected, ${p} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let C = 1; C < t.length; C++) v = v.concat(pe({ key: `${n}[${C}]`, value: t[C], style: u.style, styleSpec: u.styleSpec }));
              break;
            case "has":
            case "!has":
              p = i.H(t[1]), t.length !== 2 ? v.push(new i.V(n, t, `filter array for "${t[0]}" operator must have 2 elements`)) : p !== "string" && v.push(new i.V(`${n}[1]`, t[1], `string expected, ${p} found`));
          }
          return v;
        }
        function xt(u, t) {
          const n = u.key, c = u.style, p = u.layer, v = u.styleSpec, C = u.value, V = u.objectKey, K = v[`${t}_${u.layerType}`];
          if (!K) return [];
          const se = V.match(/^(.*)-use-theme$/);
          if (t === "paint" && se && K[se[1]]) return i.O(C) ? [].concat(Se({ key: u.key, value: C, valueSpec: { type: "string", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, style: c, styleSpec: v, expressionContext: "property", propertyType: t, propertyKey: V })) : Se({ key: n, value: C, valueSpec: { type: "string" }, style: c, styleSpec: v });
          const oe = V.match(/^(.*)-transition$/);
          if (t === "paint" && oe && K[oe[1]] && K[oe[1]].transition) return Se({ key: n, value: C, valueSpec: v.transition, style: c, styleSpec: v });
          const ve = u.valueSpec || K[V];
          if (!ve) return [new i.G(n, C, `unknown property "${V}"`)];
          let xe;
          if (i.H(C) === "string" && i.M(ve) && !ve.tokens && (xe = /^{([^}]+)}$/.exec(C))) {
            const ft = `\`{ "type": "identity", "property": ${xe ? JSON.stringify(xe[1]) : '"_"'} }\``;
            return [new i.V(n, C, `"${V}" does not support interpolation syntax
Use an identity property function instead: ${ft}.`)];
          }
          const Le = [];
          if (u.layerType === "symbol") V !== "text-field" || !c || c.glyphs || c.imports || Le.push(new i.V(n, C, 'use of "text-field" requires a style "glyphs" property')), V === "text-font" && i.a0(i.Q(C)) && i.K(C.type) === "identity" && Le.push(new i.V(n, C, '"text-font" does not support identity functions'));
          else if (u.layerType === "model" && t === "paint" && p && p.layout && p.layout.hasOwnProperty("model-id") && i.M(ve) && (i.a1(ve) || i.N(ve))) {
            const ft = i.S(i.Q(C), ve), st = ft.value.expression || ft.value._styleExpression.expression;
            st && !i.X(st, ["measure-light"]) && (V === "model-emissive-strength" && i.Y(st) && i.W(st) || Le.push(new i.V(n, C, `${V} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
          }
          return Le.concat(Se({ key: u.key, value: C, valueSpec: ve, style: c, styleSpec: v, expressionContext: "property", propertyType: t, propertyKey: V }));
        }
        function l(u) {
          return xt(u, "paint");
        }
        function _(u) {
          return xt(u, "layout");
        }
        function I(u) {
          let t = [];
          const n = u.value, c = u.key, p = u.style, v = u.styleSpec;
          n.type || n.ref || t.push(new i.V(c, n, 'either "type" or "ref" is required'));
          let C = i.K(n.type);
          const V = i.K(n.ref);
          if (n.id) {
            const K = i.K(n.id);
            for (let se = 0; se < u.arrayIndex; se++) {
              const oe = p.layers[se];
              i.K(oe.id) === K && t.push(new i.V(c, n.id, `duplicate layer id "${n.id}", previously used at line ${oe.id.__line__}`));
            }
          }
          if ("ref" in n) {
            let K;
            ["type", "source", "source-layer", "filter", "layout"].forEach((se) => {
              se in n && t.push(new i.V(c, n[se], `"${se}" is prohibited for ref layers`));
            }), p.layers.forEach((se) => {
              i.K(se.id) === V && (K = se);
            }), K ? K.ref ? t.push(new i.V(c, n.ref, "ref cannot reference another ref layer")) : C = i.K(K.type) : typeof V == "string" && t.push(new i.V(c, n.ref, `ref layer "${V}" not found`));
          } else if (C !== "background" && C !== "sky" && C !== "slot") if (n.source) {
            const K = p.sources && p.sources[n.source], se = K && i.K(K.type);
            K ? se === "vector" && C === "raster" ? t.push(new i.V(c, n.source, `layer "${n.id}" requires a raster source`)) : se === "raster" && C !== "raster" ? t.push(new i.V(c, n.source, `layer "${n.id}" requires a vector source`)) : se !== "vector" || n["source-layer"] ? se === "raster-dem" && C !== "hillshade" ? t.push(new i.V(c, n.source, "raster-dem source can only be used with layer type 'hillshade'.")) : se !== "raster-array" || ["raster", "raster-particle"].includes(C) ? C !== "line" || !n.paint || !n.paint["line-gradient"] && !n.paint["line-trim-offset"] || se === "geojson" && K.lineMetrics ? C === "raster-particle" && se !== "raster-array" && t.push(new i.V(c, n.source, `layer "${n.id}" requires a 'raster-array' source.`)) : t.push(new i.V(c, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new i.V(c, n.source, "raster-array source can only be used with layer type 'raster'.")) : t.push(new i.V(c, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new i.V(c, n.source, `source "${n.source}" not found`));
          } else t.push(new i.V(c, n, 'missing required property "source"'));
          return t = t.concat(Lt({ key: c, value: n, valueSpec: v.layer, style: u.style, styleSpec: u.styleSpec, objectElementValidators: { "*": () => [], type: () => Se({ key: `${c}.type`, value: n.type, valueSpec: v.layer.type, style: u.style, styleSpec: u.styleSpec, object: n, objectKey: "type" }), filter: (K) => Ie(i.J({ layerType: C }, K)), layout: (K) => Lt({ layer: n, key: K.key, value: K.value, valueSpec: {}, style: K.style, styleSpec: K.styleSpec, objectElementValidators: { "*": (se) => _(i.J({ layerType: C }, se)) } }), paint: (K) => Lt({ layer: n, key: K.key, value: K.value, valueSpec: {}, style: K.style, styleSpec: K.styleSpec, objectElementValidators: { "*": (se) => l(i.J({ layerType: C, layer: n }, se)) } }) } })), t;
        }
        function X(u) {
          const t = u.value, n = u.key, c = i.H(t);
          return c !== "string" ? [new i.V(n, t, `string expected, ${c} found`)] : [];
        }
        const ne = { promoteId: function u({ key: t, value: n }) {
          if (i.H(n) === "string") return X({ key: t, value: n });
          if (Array.isArray(n)) {
            const c = [], p = i.Q(n), v = i.U(p);
            return v.result === "error" && v.value.forEach((C) => {
              c.push(new i.V(`${t}${C.key}`, null, `${C.message}`));
            }), i.X(v.value.expression, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]) || c.push(new i.V(`${t}`, null, "promoteId expression should be only feature dependent")), c;
          }
          {
            const c = [];
            for (const p in n) c.push(...u({ key: `${t}.${p}`, value: n[p] }));
            return c;
          }
        } };
        function ue(u) {
          const t = u.value, n = u.key, c = u.styleSpec, p = u.style;
          if (!t.type) return [new i.V(n, t, '"type" is required')];
          const v = i.K(t.type);
          let C = [];
          switch (["vector", "raster", "raster-dem", "raster-array"].includes(v) && (t.url || t.tiles || C.push(new i.G(n, t, 'Either "url" or "tiles" is required.'))), v) {
            case "vector":
            case "raster":
            case "raster-dem":
            case "raster-array":
              return C = C.concat(Lt({ key: n, value: t, valueSpec: c[`source_${v.replace("-", "_")}`], style: u.style, styleSpec: c, objectElementValidators: ne })), C;
            case "geojson":
              if (C = Lt({ key: n, value: t, valueSpec: c.source_geojson, style: p, styleSpec: c, objectElementValidators: ne }), t.cluster) for (const V in t.clusterProperties) {
                const [K, se] = t.clusterProperties[V], oe = typeof K == "string" ? [K, ["accumulated"], ["get", V]] : K;
                C.push(...Re({ key: `${n}.${V}.map`, value: se, expressionContext: "cluster-map" })), C.push(...Re({ key: `${n}.${V}.reduce`, value: oe, expressionContext: "cluster-reduce" }));
              }
              return C;
            case "video":
              return Lt({ key: n, value: t, valueSpec: c.source_video, style: p, styleSpec: c });
            case "image":
              return Lt({ key: n, value: t, valueSpec: c.source_image, style: p, styleSpec: c });
            case "canvas":
              return [new i.V(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return et({ key: `${n}.type`, value: t.type, valueSpec: { values: Te(c) }, style: p, styleSpec: c });
          }
        }
        function Te(u) {
          return u.source.reduce((t, n) => {
            const c = u[n];
            return c.type.type === "enum" && (t = t.concat(Object.keys(c.type.values))), t;
          }, []);
        }
        function ye(u) {
          const t = u.value, n = u.styleSpec, c = n.light, p = u.style;
          let v = [];
          const C = i.H(t);
          if (t === void 0) return v;
          if (C !== "object") return v = v.concat([new i.V("light", t, `object expected, ${C} found`)]), v;
          for (const V in t) {
            const K = V.match(/^(.*)-transition$/), se = V.match(/^(.*)-use-theme$/);
            v = v.concat(se && c[se[1]] ? Se({ key: V, value: t[V], valueSpec: { type: "string" }, style: p, styleSpec: n }) : K && c[K[1]] && c[K[1]].transition ? Se({ key: V, value: t[V], valueSpec: n.transition, style: p, styleSpec: n }) : c[V] ? Se({ key: V, value: t[V], valueSpec: c[V], style: p, styleSpec: n }) : [new i.V(V, t[V], `unknown property "${V}"`)]);
          }
          return v;
        }
        function Me(u) {
          const t = u.value;
          let n = [];
          if (!t) return n;
          const c = i.H(t);
          if (c !== "object") return n = n.concat([new i.V("light-3d", t, `object expected, ${c} found`)]), n;
          const p = u.styleSpec, v = p["light-3d"], C = u.key, V = u.style, K = u.style.lights;
          for (const ve of ["type", "id"]) if (!(ve in t)) return n = n.concat([new i.V("light-3d", t, `missing property ${ve} on light`)]), n;
          if (t.type && K) for (let ve = 0; ve < u.arrayIndex; ve++) {
            const xe = i.K(t.type), Le = K[ve];
            i.K(Le.type) === xe && n.push(new i.V(C, t.id, `duplicate light type "${t.type}", previously defined at line ${Le.id.__line__}`));
          }
          const se = `properties_light_${t.type}`;
          if (!(se in p)) return n = n.concat([new i.V("light-3d", t, `Invalid light type ${t.type}`)]), n;
          const oe = p[se];
          for (const ve in t) if (ve === "properties") {
            const xe = t[ve], Le = i.H(xe);
            if (Le !== "object") return n = n.concat([new i.V("properties", xe, `object expected, ${Le} found`)]), n;
            for (const ft in xe) n = n.concat(oe[ft] ? Se({ key: ft, value: xe[ft], valueSpec: oe[ft], style: V, styleSpec: p }) : [new i.G(u.key, xe[ft], `unknown property "${ft}"`)]);
          } else {
            const xe = ve.match(/^(.*)-transition$/), Le = ve.match(/^(.*)-use-theme$/);
            n = n.concat(Le && v[Le[1]] ? Se({ key: ve, value: t[ve], valueSpec: { type: "string" }, style: V, styleSpec: p }) : xe && v[xe[1]] && v[xe[1]].transition ? Se({ key: ve, value: t[ve], valueSpec: p.transition, style: V, styleSpec: p }) : v[ve] ? Se({ key: ve, value: t[ve], valueSpec: v[ve], style: V, styleSpec: p }) : [new i.G(ve, t[ve], `unknown property "${ve}"`)]);
          }
          return n;
        }
        function Ge(u) {
          const t = u.value, n = u.key, c = u.style, p = u.styleSpec, v = p.terrain;
          let C = [];
          const V = i.H(t);
          if (t === void 0 || V === "null") return C;
          if (V !== "object") return C = C.concat([new i.V("terrain", t, `object expected, ${V} found`)]), C;
          for (const K in t) {
            const se = K.match(/^(.*)-transition$/), oe = K.match(/^(.*)-use-theme$/);
            C = C.concat(oe && v[oe[1]] ? Se({ key: K, value: t[K], valueSpec: { type: "string" }, style: c, styleSpec: p }) : se && v[se[1]] && v[se[1]].transition ? Se({ key: K, value: t[K], valueSpec: p.transition, style: c, styleSpec: p }) : v[K] ? Se({ key: K, value: t[K], valueSpec: v[K], style: c, styleSpec: p }) : [new i.G(K, t[K], `unknown property "${K}"`)]);
          }
          if (t.source) {
            const K = c.sources && c.sources[t.source], se = K && i.K(K.type);
            K ? se !== "raster-dem" && C.push(new i.V(n, t.source, `terrain cannot be used with a source of type ${String(se)}, it only be used with a "raster-dem" source type`)) : C.push(new i.V(n, t.source, `source "${t.source}" not found`));
          } else C.push(new i.V(n, t, 'terrain is missing required property "source"'));
          return C;
        }
        function Qe(u) {
          const t = u.value, n = u.style, c = u.styleSpec, p = c.fog;
          let v = [];
          const C = i.H(t);
          if (t === void 0) return v;
          if (C !== "object") return v = v.concat([new i.V("fog", t, `object expected, ${C} found`)]), v;
          for (const V in t) {
            const K = V.match(/^(.*)-transition$/), se = V.match(/^(.*)-use-theme$/);
            v = v.concat(se && p[se[1]] ? Se({ key: V, value: t[V], valueSpec: { type: "string" }, style: n, styleSpec: c }) : K && p[K[1]] && p[K[1]].transition ? Se({ key: V, value: t[V], valueSpec: c.transition, style: n, styleSpec: c }) : p[V] ? Se({ key: V, value: t[V], valueSpec: p[V], style: n, styleSpec: c }) : [new i.G(V, t[V], `unknown property "${V}"`)]);
          }
          return v;
        }
        const re = { "*": () => [], array: kt, boolean: function(u) {
          const t = u.value, n = u.key, c = i.H(t);
          return c !== "boolean" ? [new i.V(n, t, `boolean expected, ${c} found`)] : [];
        }, number: Ye, color: function(u) {
          const t = u.key, n = u.value, c = i.H(n);
          return c !== "string" ? [new i.V(t, n, `color expected, ${c} found`)] : i._.parseCSSColor(n) === null ? [new i.V(t, n, `color expected, "${n}" found`)] : [];
        }, enum: et, filter: Ie, function: De, layer: I, object: Lt, source: ue, model: i.a2, light: ye, "light-3d": Me, terrain: Ge, fog: Qe, string: X, formatted: function(u) {
          return X(u).length === 0 ? [] : Re(u);
        }, resolvedImage: function(u) {
          return X(u).length === 0 ? [] : Re(u);
        }, projection: function(u) {
          const t = u.value, n = u.styleSpec, c = n.projection, p = u.style;
          let v = [];
          const C = i.H(t);
          if (C === "object") for (const V in t) v = v.concat(Se({ key: V, value: t[V], valueSpec: c[V], style: p, styleSpec: n }));
          else C !== "string" && (v = v.concat([new i.V("projection", t, `object or string expected, ${C} found`)]));
          return v;
        }, import: function(u) {
          const { value: t, styleSpec: n } = u, { data: c, ...p } = t;
          Object.defineProperty(p, "__line__", { value: t.__line__, enumerable: !1 });
          let v = Lt(i.J({}, u, { value: p, valueSpec: n.import }));
          return i.K(p.id) === "" && v.push(new i.V(`${u.key}.id`, p, "import id can't be an empty string")), c && (v = v.concat(at(c, n, { key: `${u.key}.data` }))), v;
        } };
        function Se(u, t = !1) {
          const n = u.value, c = u.valueSpec, p = u.styleSpec;
          if (c.expression && i.a0(i.K(n))) return De(u);
          if (c.expression && i.O(i.Q(n))) return Re(u);
          if (c.type && re[c.type]) {
            const v = re[c.type](u);
            return t === !0 && v.length > 0 && i.H(u.value) === "array" ? Re(u) : v;
          }
          return Lt(i.J({}, u, { valueSpec: c.type ? p[c.type] : c }));
        }
        function Pe(u) {
          const t = u.value, n = u.key, c = X(u);
          return c.length || (t.indexOf("{fontstack}") === -1 && c.push(new i.V(n, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && c.push(new i.V(n, t, '"glyphs" url must include a "{range}" token'))), c;
        }
        function at(u, t = i.a3, n = {}) {
          return Se({ key: n.key || "", value: u, valueSpec: t.$root, styleSpec: t, style: u, objectElementValidators: { glyphs: Pe, "*": () => [] } });
        }
        function Be(u, t = i.a3) {
          return Ft(at(u, t));
        }
        const Ze = (u) => Ft(ue(u)), fe = (u) => Ft(ye(u)), Je = (u) => Ft(Me(u)), Xe = (u) => Ft(Ge(u)), z = (u) => Ft(Qe(u)), He = (u) => Ft(function(t) {
          const n = t.value, c = t.style, p = t.styleSpec, v = p.snow;
          let C = [];
          const V = i.H(n);
          if (n === void 0) return C;
          if (V !== "object") return C = C.concat([new i.V("snow", n, `object expected, ${V} found`)]), C;
          for (const K in n) {
            const se = K.match(/^(.*)-transition$/);
            C = C.concat(se && v[se[1]] && v[se[1]].transition ? Se({ key: K, value: n[K], valueSpec: p.transition, style: c, styleSpec: p }) : v[K] ? Se({ key: K, value: n[K], valueSpec: v[K], style: c, styleSpec: p }) : [new i.G(K, n[K], `unknown property "${K}"`)]);
          }
          return C;
        }(u)), nt = (u) => Ft(function(t) {
          const n = t.value, c = t.style, p = t.styleSpec, v = p.rain;
          let C = [];
          const V = i.H(n);
          if (n === void 0) return C;
          if (V !== "object") return C = C.concat([new i.V("rain", n, `object expected, ${V} found`)]), C;
          for (const K in n) {
            const se = K.match(/^(.*)-transition$/);
            C = C.concat(se && v[se[1]] && v[se[1]].transition ? Se({ key: K, value: n[K], valueSpec: p.transition, style: c, styleSpec: p }) : v[K] ? Se({ key: K, value: n[K], valueSpec: v[K], style: c, styleSpec: p }) : [new i.G(K, n[K], `unknown property "${K}"`)]);
          }
          return C;
        }(u)), ae = (u) => Ft(I(u)), $e = (u) => Ft(Ie(u)), Et = (u) => Ft(l(u)), Nt = (u) => Ft(_(u)), Yt = (u) => Ft(i.a2(u));
        function Ft(u) {
          return u.slice().sort((t, n) => t.line && n.line ? t.line - n.line : 0);
        }
        function ai(u, t) {
          let n = !1;
          if (t && t.length) for (const c of t) c instanceof i.G ? i.w(c.message) : (u.fire(new i.y(new Error(c.message))), n = !0);
          return n;
        }
        let Mt;
        class Ae extends i.E {
          constructor(t, n = "flat") {
            super(), this._transitionable = new i.a4(Mt || (Mt = new i.a5({ anchor: new i.a6(i.a3.light.anchor), position: new i.a7(i.a3.light.position), color: new i.a6(i.a3.light.color), intensity: new i.a6(i.a3.light.intensity) }))), this.setLight(t, n), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(t, n, c = {}) {
            this._validate(fe, t, c) || (this._transitionable.setTransitionOrValue(t), this.id = n);
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, n, c) {
            return (!c || c.validate !== !1) && ai(this, t.call(Be, i.l({ value: n, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
          }
        }
        let Fe = class extends i.E {
          constructor(u, t, n, c) {
            super(), this.scope = n, this._transitionable = new i.a4(new i.a5({ source: new i.a6(i.a3.terrain.source), exaggeration: new i.a6(i.a3.terrain.exaggeration) }), n, c), this._transitionable.setTransitionOrValue(u, c), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = t;
          }
          get() {
            return this._transitionable.serialize();
          }
          set(u, t) {
            this._transitionable.setTransitionOrValue(u, t);
          }
          updateTransitions(u) {
            this._transitioning = this._transitionable.transitioned(u, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(u) {
            this.properties = this._transitioning.possiblyEvaluate(u);
          }
          getExaggeration(u) {
            return this._transitioning.possiblyEvaluate(new i.a8(u)).get("exaggeration");
          }
          getAttenuationRange() {
            if (!this.isZoomDependent()) return null;
            const u = this._transitionable._values.exaggeration;
            if (!u) return null;
            const t = u.value.expression;
            if (!t) return null;
            let n = -1, c = -1, p = 1;
            for (const v of t.zoomStops) p = t.evaluate(new i.a8(v)), p > 0.01 ? (n = v, c = -1) : c = v;
            return p < 0.01 && n > 0 && c > n ? [n, c] : null;
          }
          isZoomDependent() {
            const u = this._transitionable._values.exaggeration;
            return u != null && u.value != null && u.value.expression != null && u.value.expression instanceof i.a9;
          }
        };
        const tt = 45, Ct = 65, It = 0.05;
        function Ut(u, t, n, c) {
          const p = i.ac(tt, Ct, n), [v, C] = ti(u, c);
          let V = 1 - Math.min(1, Math.exp((t - v) / (C - v) * -6));
          return V *= V * V, V = Math.min(1, 1.00747 * V), V * p * u.alpha;
        }
        function ti(u, t) {
          const n = 0.5 / Math.tan(0.5 * t);
          return [u.range[0] + n, u.range[1] + n];
        }
        function Pt(u, t, n, c, p) {
          const v = i.ab.vec3.transformMat4([], [t, n, c], p.mercatorFogMatrix);
          return Ut(u, i.ab.vec3.length(v), p.pitch, p._fov);
        }
        function Wt(u, t, n, c, p, v, C) {
          const V = [[n, c, 0], [p, c, 0], [p, v, 0], [n, v, 0]];
          let K = Number.MAX_VALUE, se = -Number.MAX_VALUE;
          for (const oe of V) {
            const ve = i.ab.vec3.transformMat4([], oe, t), xe = i.ab.vec3.length(ve);
            K = Math.min(K, xe), se = Math.max(se, xe);
          }
          return [Ut(u, K, C.pitch, C._fov), Ut(u, se, C.pitch, C._fov)];
        }
        class ei extends i.E {
          constructor(t, n, c, p) {
            super();
            const v = new i.a5({ range: new i.a6(i.a3.fog.range), color: new i.a6(i.a3.fog.color), "color-use-theme": new i.a6({ type: "string", "property-type": "data-constant", default: "default" }), "high-color": new i.a6(i.a3.fog["high-color"]), "high-color-use-theme": new i.a6({ type: "string", "property-type": "data-constant", default: "default" }), "space-color": new i.a6(i.a3.fog["space-color"]), "space-color-use-theme": new i.a6({ type: "string", "property-type": "data-constant", default: "default" }), "horizon-blend": new i.a6(i.a3.fog["horizon-blend"]), "star-intensity": new i.a6(i.a3.fog["star-intensity"]), "vertical-range": new i.a6(i.a3.fog["vertical-range"]) });
            this._transitionable = new i.a4(v, c, new Map(p)), this.set(t, p), this._transitioning = this._transitionable.untransitioned(), this._transform = n, this.properties = new i.ad(v), this.scope = c;
          }
          get state() {
            const t = this._transform, n = t.projection.name === "globe", c = i.ae(t.zoom), p = this.properties.get("range"), v = [0.5, 3];
            return { range: n ? [i.af(v[0], p[0], c), i.af(v[1], p[1], c)] : p, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(t, n, c = {}) {
            if (this._validate(z, t, c)) return;
            const p = i.l({}, t);
            for (const v of Object.keys(i.a3.fog)) p[v] === void 0 && (p[v] = i.a3.fog[v].default);
            this._options = p, this._transitionable.setTransitionOrValue(this._options, n);
          }
          getOpacity(t) {
            if (!this._transform.projection.supportsFog) return 0;
            const n = this.properties && this.properties.get("color") || 1;
            return (this._transform.projection.name === "globe" ? 1 : i.ac(tt, Ct, t)) * n.a;
          }
          getOpacityAtLatLng(t, n) {
            return this._transform.projection.supportsFog ? function(c, p, v) {
              const C = i.aa.fromLngLat(p), V = v.elevation ? v.elevation.getAtPointOrZero(C) : 0;
              return Pt(c, C.x, C.y, V, v);
            }(this.state, t, n) : 0;
          }
          getOpacityForTile(t) {
            if (!this._transform.projection.supportsFog) return [1, 1];
            const n = this._transform.calculateFogTileMatrix(t.toUnwrapped());
            return Wt(this.state, n, 0, 0, i.ag, i.ag, this._transform);
          }
          getOpacityForBounds(t, n, c, p, v) {
            return this._transform.projection.supportsFog ? Wt(this.state, t, n, c, p, v, this._transform) : [1, 1];
          }
          getFovAdjustedRange(t) {
            return this._transform.projection.supportsFog ? ti(this.state, t) : [0, 1];
          }
          isVisibleOnFrustum(t) {
            if (!this._transform.projection.supportsFog) return !1;
            const n = [4, 5, 6, 7];
            for (const c of n) {
              const p = t.points[c];
              let v;
              if (p[2] >= 0) v = p;
              else {
                const C = t.points[c - 4];
                v = i.ah(C, p, C[2] / (C[2] - p[2]));
              }
              if (Pt(this.state, v[0], v[1], 0, this._transform) >= It) return !0;
            }
            return !1;
          }
          updateConfig(t) {
            this._transitionable.setTransitionOrValue(this._options, new Map(t));
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          _validate(t, n, c) {
            return (!c || c.validate !== !1) && ai(this, t.call(Be, i.l({ value: n, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
          }
        }
        let oi, _i, Di, Bi, Hi = class extends i.E {
          constructor(u, t, n, c) {
            super();
            const p = oi || (oi = new i.a5({ density: new i.a6(i.a3.snow.density), intensity: new i.a6(i.a3.snow.intensity), color: new i.a6(i.a3.snow.color), opacity: new i.a6(i.a3.snow.opacity), vignette: new i.a6(i.a3.snow.vignette), "vignette-color": new i.a6(i.a3.snow["vignette-color"]), "center-thinning": new i.a6(i.a3.snow["center-thinning"]), direction: new i.a6(i.a3.snow.direction), "flake-size": new i.a6(i.a3.snow["flake-size"]) }));
            this._transitionable = new i.a4(p, n, new Map(c)), this.set(u, c), this._transitioning = this._transitionable.untransitioned(), this.properties = new i.ad(p), this.scope = n;
          }
          get state() {
            const u = this.properties.get("opacity"), t = this.properties.get("color"), n = this.properties.get("direction"), c = i.ai(n[0]), p = -Math.max(i.ai(n[1]), 0.01), v = [Math.cos(c) * Math.cos(p), Math.sin(c) * Math.cos(p), Math.sin(p)], C = this.properties.get("vignette"), V = this.properties.get("vignette-color");
            return V.a = C, { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new i.aj(t.r, t.g, t.b, t.a * u), direction: v, centerThinning: this.properties.get("center-thinning"), flakeSize: this.properties.get("flake-size"), vignetteColor: V };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(u, t, n = {}) {
            if (this._validate(He, u, n)) return;
            const c = i.l({}, u);
            for (const p of Object.keys(i.a3.snow)) c[p] === void 0 && (c[p] = i.a3.snow[p].default);
            this._options = c, this._transitionable.setTransitionOrValue(this._options, t);
          }
          updateConfig(u) {
            this._transitionable.setTransitionOrValue(this._options, new Map(u));
          }
          updateTransitions(u) {
            this._transitioning = this._transitionable.transitioned(u, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(u) {
            this.properties = this._transitioning.possiblyEvaluate(u);
          }
          _validate(u, t, n) {
            return (!n || n.validate !== !1) && ai(this, u.call(Be, i.l({ value: t, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
          }
        }, nr = class extends i.E {
          constructor(u, t, n, c) {
            super();
            const p = _i || (_i = new i.a5({ density: new i.a6(i.a3.rain.density), intensity: new i.a6(i.a3.rain.intensity), color: new i.a6(i.a3.rain.color), opacity: new i.a6(i.a3.rain.opacity), vignette: new i.a6(i.a3.rain.vignette), "vignette-color": new i.a6(i.a3.rain["vignette-color"]), "center-thinning": new i.a6(i.a3.rain["center-thinning"]), direction: new i.a6(i.a3.rain.direction), "droplet-size": new i.a6(i.a3.rain["droplet-size"]), "distortion-strength": new i.a6(i.a3.rain["distortion-strength"]) }));
            this._transitionable = new i.a4(p, n, new Map(c)), this.set(u, c), this._transitioning = this._transitionable.untransitioned(), this.properties = new i.ad(p), this.scope = n;
          }
          get state() {
            const u = this.properties.get("opacity"), t = this.properties.get("color"), n = this.properties.get("direction"), c = i.ai(n[0]), p = -Math.max(i.ai(n[1]), 0.01), v = [Math.cos(c) * Math.cos(p), Math.sin(c) * Math.cos(p), Math.sin(p)], C = this.properties.get("vignette-color");
            return C.a = this.properties.get("vignette"), { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new i.aj(t.r, t.g, t.b, t.a * u), direction: v, centerThinning: this.properties.get("center-thinning"), dropletSize: this.properties.get("droplet-size"), distortionStrength: this.properties.get("distortion-strength"), vignetteColor: C };
          }
          get() {
            return this._transitionable.serialize();
          }
          set(u, t, n = {}) {
            if (this._validate(nt, u, n)) return;
            const c = i.l({}, u);
            for (const p of Object.keys(i.a3.rain)) c[p] === void 0 && (c[p] = i.a3.rain[p].default);
            this._options = c, this._transitionable.setTransitionOrValue(this._options, t);
          }
          updateConfig(u) {
            this._transitionable.setTransitionOrValue(this._options, new Map(u));
          }
          updateTransitions(u) {
            this._transitioning = this._transitionable.transitioned(u, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(u) {
            this.properties = this._transitioning.possiblyEvaluate(u);
          }
          _validate(u, t, n) {
            return (!n || n.validate !== !1) && ai(this, u.call(Be, i.l({ value: t, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
          }
        };
        class rr extends i.E {
          constructor(t, n, c, p) {
            super(), this.scope = c, this._options = t, this.properties = new i.ad(n), this._transitionable = new i.a4(n, c, new Map(p)), this._transitionable.setTransitionOrValue(t.properties), this._transitioning = this._transitionable.untransitioned();
          }
          updateConfig(t) {
            this._transitionable.setTransitionOrValue(this._options.properties, new Map(t));
          }
          updateTransitions(t) {
            this._transitioning = this._transitionable.transitioned(t, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(t) {
            this.properties = this._transitioning.possiblyEvaluate(t);
          }
          get() {
            return this._options.properties = this._transitionable.serialize(), this._options;
          }
          set(t, n) {
            this._options = t, this._transitionable.setTransitionOrValue(t.properties, n);
          }
          shadowsEnabled() {
            return !!this.properties && this.properties.get("cast-shadows") === !0;
          }
        }
        class dr {
          constructor(t, n, c, p) {
            this.screenBounds = t, this.cameraPoint = n, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = c, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, p);
          }
          static createFromScreenPoints(t, n) {
            let c, p;
            if (t instanceof i.P || typeof t[0] == "number") {
              const v = i.P.convert(t);
              c = [v], p = n.isPointAboveHorizon(v);
            } else {
              const v = i.P.convert(t[0]), C = i.P.convert(t[1]);
              c = [v, C], p = i.al(v, C).every((V) => n.isPointAboveHorizon(V));
            }
            return new dr(c, n.getCameraPoint(), p, n);
          }
          isPointQuery() {
            return this.screenBounds.length === 1;
          }
          bufferedScreenGeometry(t) {
            return i.al(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], t);
          }
          bufferedCameraGeometry(t) {
            const n = this.screenBounds[0], c = this.screenBounds.length === 1 ? this.screenBounds[0].add(new i.P(1, 1)) : this.screenBounds[1], p = i.al(n, c, 0, !1);
            return this.cameraPoint.y > c.y && (this.cameraPoint.x > n.x && this.cameraPoint.x < c.x ? p.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= c.x ? p[2] = this.cameraPoint : this.cameraPoint.x <= n.x && (p[3] = this.cameraPoint)), i.am(p, t);
          }
          bufferedCameraGeometryGlobe(t) {
            const n = this.screenBounds[0], c = this.screenBounds.length === 1 ? this.screenBounds[0].add(new i.P(1, 1)) : this.screenBounds[1], p = i.al(n, c, t), v = this.cameraPoint.clone();
            switch (3 * ((v.y > n.y) + (v.y > c.y)) + ((v.x > n.x) + (v.x > c.x))) {
              case 0:
                p[0] = v, p[4] = v.clone();
                break;
              case 1:
                p.splice(1, 0, v);
                break;
              case 2:
                p[1] = v;
                break;
              case 3:
                p.splice(4, 0, v);
                break;
              case 5:
                p.splice(2, 0, v);
                break;
              case 6:
                p[3] = v;
                break;
              case 7:
                p.splice(3, 0, v);
                break;
              case 8:
                p[2] = v;
            }
            return p;
          }
          containsTile(t, n, c, p = 0) {
            const v = t.queryPadding / n._pixelsPerMercatorPixel + 1, C = c ? this._bufferedCameraMercator(v, n) : this._bufferedScreenMercator(v, n);
            let V = t.tileID.wrap + (C.unwrapped ? p : 0);
            const K = C.polygon.map((vt) => i.an(t.tileTransform, vt, V));
            if (!i.ao(K, 0, 0, i.ag, i.ag)) return;
            V = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? p : 0);
            const se = this.screenGeometryMercator.polygon.map((vt) => i.ap(t.tileTransform, vt, V)), oe = se.map((vt) => new i.P(vt[0], vt[1])), ve = n.getFreeCameraOptions().position || new i.aa(0, 0, 0), xe = i.ap(t.tileTransform, ve, V), Le = se.map((vt) => {
              const gt = i.ab.vec3.sub(vt, vt, xe);
              return i.ab.vec3.normalize(gt, gt), new i.aq(xe, gt);
            }), ft = i.ar(t, 1, n.zoom) * n._pixelsPerMercatorPixel;
            return { queryGeometry: this, tilespaceGeometry: oe, tilespaceRays: Le, bufferedTilespaceGeometry: K, bufferedTilespaceBounds: (st = i.as(K), st.min.x = i.aw(st.min.x, 0, i.ag), st.min.y = i.aw(st.min.y, 0, i.ag), st.max.x = i.aw(st.max.x, 0, i.ag), st.max.y = i.aw(st.max.y, 0, i.ag), st), tile: t, tileID: t.tileID, pixelToTileUnitsFactor: ft };
            var st;
          }
          _bufferedScreenMercator(t, n) {
            const c = Ki(t);
            if (this._screenRaycastCache[c]) return this._screenRaycastCache[c];
            {
              let p;
              return p = n.projection.name === "globe" ? this._projectAndResample(this.bufferedScreenGeometry(t), n) : { polygon: this.bufferedScreenGeometry(t).map((v) => n.pointCoordinate3D(v)), unwrapped: !0 }, this._screenRaycastCache[c] = p, p;
            }
          }
          _bufferedCameraMercator(t, n) {
            const c = Ki(t);
            if (this._cameraRaycastCache[c]) return this._cameraRaycastCache[c];
            {
              let p;
              return p = n.projection.name === "globe" ? this._projectAndResample(this.bufferedCameraGeometryGlobe(t), n) : { polygon: this.bufferedCameraGeometry(t).map((v) => n.pointCoordinate3D(v)), unwrapped: !0 }, this._cameraRaycastCache[c] = p, p;
            }
          }
          _projectAndResample(t, n) {
            const c = function(v, C) {
              const V = i.ab.mat4.multiply([], C.pixelMatrix, C.globeMatrix), K = [0, -i.ax, 0, 1], se = [0, i.ax, 0, 1], oe = [0, 0, 0, 1];
              i.ab.vec4.transformMat4(K, K, V), i.ab.vec4.transformMat4(se, se, V), i.ab.vec4.transformMat4(oe, oe, V);
              const ve = new i.P(K[0] / K[3], K[1] / K[3]), xe = new i.P(se[0] / se[3], se[1] / se[3]), Le = i.au(v, ve) && K[3] < oe[3], ft = i.au(v, xe) && se[3] < oe[3];
              if (!Le && !ft) return null;
              const st = function(Kt, Zt, Jt) {
                for (let ui = 1; ui < Kt.length; ui++) {
                  const Ti = Br(Zt.pointCoordinate3D(Kt[ui - 1]).x), xi = Br(Zt.pointCoordinate3D(Kt[ui]).x);
                  if (Jt < 0) {
                    if (Ti < xi) return { idx: ui, t: -Ti / (xi - 1 - Ti) };
                  } else if (xi < Ti) return { idx: ui, t: (1 - Ti) / (xi + 1 - Ti) };
                }
                return null;
              }(v, C, Le ? -1 : 1);
              if (!st) return null;
              const { idx: vt, t: gt } = st;
              let Rt = vt > 1 ? Rr(v.slice(0, vt), C) : [], qt = vt < v.length ? Rr(v.slice(vt), C) : [];
              Rt = Rt.map((Kt) => new i.P(Br(Kt.x), Kt.y)), qt = qt.map((Kt) => new i.P(Br(Kt.x), Kt.y));
              const jt = [...Rt];
              jt.length === 0 && jt.push(qt[qt.length - 1]);
              const ii = i.af(jt[jt.length - 1].y, (qt.length === 0 ? Rt[0] : qt[0]).y, gt);
              let Xt;
              return Xt = Le ? [new i.P(0, ii), new i.P(0, 0), new i.P(1, 0), new i.P(1, ii)] : [new i.P(1, ii), new i.P(1, 1), new i.P(0, 1), new i.P(0, ii)], jt.push(...Xt), qt.length === 0 ? jt.push(Rt[0]) : jt.push(...qt), { polygon: jt.map((Kt) => new i.aa(Kt.x, Kt.y)), unwrapped: !1 };
            }(t, n);
            if (c) return c;
            const p = function(v, C) {
              let V = !1, K = -1 / 0, se = 0;
              for (let ve = 0; ve < v.length - 1; ve++) v[ve].x > K && (K = v[ve].x, se = ve);
              for (let ve = 0; ve < v.length - 1; ve++) {
                const xe = (se + ve) % (v.length - 1), Le = v[xe], ft = v[xe + 1];
                Math.abs(Le.x - ft.x) > 0.5 && (Le.x < ft.x ? (Le.x += 1, xe === 0 && (v[v.length - 1].x += 1)) : (ft.x += 1, xe + 1 === v.length - 1 && (v[0].x += 1)), V = !0);
              }
              const oe = i.at(C.center.lng);
              return V && oe < Math.abs(oe - 1) && v.forEach((ve) => {
                ve.x -= 1;
              }), { polygon: v, unwrapped: V };
            }(Rr(t, n).map((v) => new i.P(Br(v.x), v.y)), n);
            return { polygon: p.polygon.map((v) => new i.aa(v.x, v.y)), unwrapped: p.unwrapped };
          }
        }
        function Rr(u, t) {
          return i.av(u, (n) => {
            const c = t.pointCoordinate3D(n);
            n.x = c.x, n.y = c.y;
          }, 1 / 256);
        }
        function Br(u) {
          return u < 0 ? 1 + u % 1 : u % 1;
        }
        function Ki(u) {
          return 100 * u | 0;
        }
        function Ir(u, t, n, c, p) {
          const v = function(V, K) {
            if (V) return p(V);
            if (K) {
              if (u.url && K.tiles && u.tiles && delete u.tiles, K.variants) {
                if (!Array.isArray(K.variants)) return p(new Error("variants must be an array"));
                for (const oe of K.variants) {
                  if (oe == null || typeof oe != "object" || oe.constructor !== Object) return p(new Error("variant must be an object"));
                  if (!Array.isArray(oe.capabilities)) return p(new Error("capabilities must be an array"));
                  if (oe.capabilities.length === 1 && oe.capabilities[0] === "meshopt") {
                    K = i.l(K, oe);
                    break;
                  }
                }
              }
              const se = i.ay(i.l({}, K, u), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding", "vector_layers", "raster_layers", "worldview_options", "worldview_default", "worldview"]);
              se.tiles = t.canonicalizeTileset(se, u.url), p(null, se);
            }
          }, C = function(V, K, se) {
            if (!V) return null;
            if (!K && !se) return V;
            se = se || V.worldview_default;
            const oe = Object.values(V.language || {});
            if (oe.length === 0) return null;
            const ve = Object.values(V.worldview || {});
            if (ve.length === 0) return null;
            const xe = oe.every((ft) => ft === K), Le = ve.every((ft) => ft === se);
            return xe && Le ? V : K in (V.language_options || {}) || se in (V.worldview_options || {}) ? null : V.language_options && V.worldview_options ? V : null;
          }(u.data, n, c);
          return C ? i.q.frame(() => v(null, C)) : u.url ? i.n(t.transformRequest(t.normalizeSourceURL(u.url, null, n, c), i.R.Source), v) : i.q.frame(() => {
            const { data: V, ...K } = u;
            v(null, K);
          });
        }
        class Mr {
          constructor(t, n, c) {
            this.bounds = i.az.convert(this.validateBounds(t)), this.minzoom = n || 0, this.maxzoom = c || 24;
          }
          validateBounds(t) {
            return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];
          }
          contains(t) {
            const n = Math.pow(2, t.z), c = Math.floor(i.at(this.bounds.getWest()) * n), p = Math.floor(i.aA(this.bounds.getNorth()) * n), v = Math.ceil(i.at(this.bounds.getEast()) * n), C = Math.ceil(i.aA(this.bounds.getSouth()) * n);
            return t.x >= c && t.x < v && t.y >= p && t.y < C;
          }
        }
        class wn extends i.E {
          constructor(t, n, c, p) {
            if (super(), this.id = t, this.dispatcher = c, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, i.l(this, i.ay(n, ["url", "scheme", "tileSize", "promoteId"])), this._options = i.l({ type: "vector" }, n), this._collectResourceTiming = !!n.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(p), this._tileWorkers = {}, this._deduped = new i.aB();
          }
          load(t) {
            this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" }));
            const n = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, c = this.map.getWorldview();
            this._tileJSONRequest = Ir(this._options, this.map._requestManager, n, c, (p, v) => {
              if (this._tileJSONRequest = null, this._loaded = !0, p) n && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${n}`), c && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${c}`), this.fire(new i.y(p));
              else if (v) {
                if (i.l(this, v), this.hasWorldviews = !!v.worldview_options, v.worldview_default && (this.worldviewDefault = v.worldview_default), v.vector_layers) {
                  this.vectorLayers = v.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = /* @__PURE__ */ new Set();
                  for (const C of v.vector_layers) this.vectorLayerIds.push(C.id), v.worldview && v.worldview[C.source] && this.localizableLayerIds.add(C.id);
                }
                v.bounds && (this.tileBounds = new Mr(v.bounds, this.minzoom, this.maxzoom)), bt(v.tiles, this.map._requestManager._customAccessToken), this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }));
              }
              t && t(p);
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const t = i.aC(this.id, this.scope);
            this.load(() => this.map.style.clearSource(t));
          }
          setTiles(t) {
            return this._options.tiles = t, this.reload(), this;
          }
          setUrl(t) {
            return this.url = t, this._options.url = t, this.reload(), this;
          }
          onRemove(t) {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return i.l({}, this._options);
          }
          loadTile(t, n) {
            const c = t.tileID.canonical.url(this.tiles, this.scheme), p = this.map._requestManager.normalizeTileURL(c), v = this.map._requestManager.transformRequest(p, i.R.Tile), C = this.map.style ? this.map.style.getLut(this.scope) : null, V = C ? { image: C.image.clone() } : null, K = { request: v, data: void 0, uid: t.uid, tileID: t.tileID, tileZoom: t.tileZoom, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, lut: V, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: i.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t.isExtraShadowCaster, tessellationStep: this.map._tessellationStep, scaleFactor: this.map.getScaleFactor() };
            if (this.hasWorldviews && i.f(c) && (K.worldview = this.map.getWorldview() || this.worldviewDefault, K.localizableLayerIds = this.localizableLayerIds), K.request.collectResourceTiming = this._collectResourceTiming, t.actor && t.state !== "expired") t.state === "loading" ? t.reloadCallback = n : t.request = t.actor.send("reloadTile", K, se.bind(this));
            else if (t.actor = this._tileWorkers[p] = this._tileWorkers[p] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send("loadTile", K, se.bind(this), void 0, !0);
            else {
              const oe = i.aD.call({ deduped: this._deduped }, K, (ve, xe) => {
                ve || !xe ? se.call(this, ve) : (K.data = { cacheControl: xe.cacheControl, expires: xe.expires, rawData: xe.rawData.slice(0) }, t.actor && t.actor.send("loadTile", K, se.bind(this), void 0, !0));
              }, !0);
              t.request = { cancel: oe };
            }
            function se(oe, ve) {
              return delete t.request, t.aborted ? n(null) : oe && oe.status !== 404 ? n(oe) : (ve && ve.resourceTiming && (t.resourceTiming = ve.resourceTiming), this.map._refreshExpiredTiles && ve && t.setExpiryData(ve), t.loadVectorData(ve, this.map.painter), i.aE(this.dispatcher), n(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));
            }
          }
          abortTile(t) {
            t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send("abortTile", { uid: t.uid, type: this.type, source: this.id, scope: this.scope });
          }
          unloadTile(t, n) {
            t.actor && t.actor.send("removeTile", { uid: t.uid, type: this.type, source: this.id, scope: this.scope }), t.destroy();
          }
          hasTransition() {
            return !1;
          }
          afterUpdate() {
            this._tileWorkers = {};
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class xn extends i.E {
          constructor(t, n, c, p) {
            super(), this.id = t, this.dispatcher = c, this.setEventedParent(p), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = i.l({ type: "raster" }, n), i.l(this, i.ay(n, ["url", "scheme", "tileSize"]));
          }
          load(t) {
            this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" })), this._tileJSONRequest = Ir(this._options, this.map._requestManager, null, null, (n, c) => {
              this._tileJSONRequest = null, this._loaded = !0, n ? this.fire(new i.y(n)) : c && (i.l(this, c), c.raster_layers && (this.rasterLayers = c.raster_layers, this.rasterLayerIds = this.rasterLayers.map((p) => p.id)), c.bounds && (this.tileBounds = new Mr(c.bounds, this.minzoom, this.maxzoom)), bt(c.tiles), this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }))), t && t(n);
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(t) {
            this.map = t, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const t = i.aC(this.id, this.scope);
            this.load(() => this.map.style.clearSource(t));
          }
          setTiles(t) {
            return this._options.tiles = t, this.reload(), this;
          }
          setUrl(t) {
            return this.url = t, this._options.url = t, this.reload(), this;
          }
          onRemove(t) {
            this.cancelTileJSONRequest();
          }
          serialize() {
            return i.l({}, this._options);
          }
          hasTile(t) {
            return !this.tileBounds || this.tileBounds.contains(t.canonical);
          }
          loadTile(t, n) {
            const c = i.q.devicePixelRatio >= 2, p = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), c, this.tileSize);
            t.request = i.o(this.map._requestManager.transformRequest(p, i.R.Tile), (v, C, V, K) => (delete t.request, t.aborted ? (t.state = "unloaded", n(null)) : v ? (t.state = "errored", n(v)) : C ? (this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: V, expires: K }), t.setTexture(C, this.map.painter), t.state = "loaded", i.aE(this.dispatcher), void n(null)) : n(null)));
          }
          abortTile(t, n) {
            t.request && (t.request.cancel(), delete t.request), n && n();
          }
          unloadTile(t, n) {
            t.texture && t.texture instanceof i.T ? (t.destroy(!0), t.texture && t.texture instanceof i.T && this.map.painter.saveTileTexture(t.texture)) : t.destroy(), n && n();
          }
          hasTransition() {
            return !1;
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
        }
        class En extends xn {
          constructor(t, n, c, p) {
            super(t, n, c, p), this.type = "raster-array", this.maxzoom = 22, this._options = i.l({ type: "raster-array" }, n);
          }
          triggerRepaint(t) {
            const n = this.map.painter._terrain, c = this.map.style.getSourceCache(this.id);
            n && n.enabled && c && n._clearRenderCacheForTile(c.id, t.tileID), this.map.triggerRepaint();
          }
          loadTile(t, n) {
            const c = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), p = this.map._requestManager.transformRequest(c, i.R.Tile);
            t.requestParams = p, t.actor || (t.actor = this.dispatcher.getActor()), t.request = t.fetchHeader(void 0, (v, C, V, K) => {
              if (delete t.request, t.aborted) return t.state = "unloaded", n(null);
              if (v)
                return v.code === 20 ? void 0 : (t.state = "errored", n(v));
              this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: V, expires: K }), t.state = "empty", n(null);
            });
          }
          unloadTile(t, n) {
            const c = t.texture;
            c && c instanceof i.T ? (t.destroy(!0), this.map.painter.saveTileTexture(c)) : (t.destroy(), t.flushQueues(), t._isHeaderLoaded = !1, delete t._mrt, delete t.textureDescriptor), t.fbo && (t.fbo.destroy(), delete t.fbo), delete t.request, delete t.requestParams, delete t.neighboringTiles, t.state = "unloaded";
          }
          prepareTile(t, n, c) {
            t._isHeaderLoaded && (t.state !== "empty" && (t.state = "reloading"), t.fetchBand(n, c, (p, v) => {
              if (p) return t.state = "errored", this.fire(new i.y(p)), void this.triggerRepaint(t);
              v && (t.setTexture(v, this.map.painter), t.state = "loaded", this.triggerRepaint(t));
            }));
          }
          getInitialBand(t) {
            if (!this.rasterLayers) return 0;
            const n = this.rasterLayers.find(({ id: v }) => v === t), c = n && n.fields, p = c && c.bands && c.bands;
            return p ? p[0] : 0;
          }
          getTextureDescriptor(t, n, c) {
            if (!t) return;
            const p = n.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
            if (!p) return;
            let v = null;
            n instanceof i.aH ? v = n.paint.get("raster-array-band") : n instanceof i.aI && (v = n.paint.get("raster-particle-array-band"));
            const C = v || this.getInitialBand(p);
            if (C != null) if (t.textureDescriptor) {
              if (!t.updateNeeded(p, C) || c) return Object.assign({}, t.textureDescriptor, { texture: t.texture });
            } else this.prepareTile(t, p, C);
          }
        }
        const Vn = { vector: wn, raster: xn, "raster-dem": class extends xn {
          constructor(u, t, n, c) {
            super(u, t, n, c), this.type = "raster-dem", this.maxzoom = 22, this._options = i.l({ type: "raster-dem" }, t), this.encoding = t.encoding || "mapbox";
          }
          loadTile(u, t) {
            const n = this.map._requestManager.normalizeTileURL(u.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
            function c(p, v) {
              p && (u.state = "errored", t(p)), v && (u.dem = v, u.dem.onDeserialize(), u.needsHillshadePrepare = !0, u.needsDEMTextureUpload = !0, u.state = "loaded", t(null));
            }
            u.request = i.o(this.map._requestManager.transformRequest(n, i.R.Tile), (function(p, v, C, V) {
              if (delete u.request, u.aborted) u.state = "unloaded", t(null);
              else if (p) u.state = "errored", t(p);
              else if (v) {
                this.map._refreshExpiredTiles && u.setExpiryData({ cacheControl: C, expires: V });
                const K = ImageBitmap && v instanceof ImageBitmap && i.t(), se = 1 - (v.width - i.aF(v.width)) / 2;
                se < 1 || u.neighboringTiles || (u.neighboringTiles = this._getNeighboringTiles(u.tileID));
                const oe = K ? v : i.q.getImageData(v, se), ve = { uid: u.uid, coord: u.tileID, source: this.id, scope: this.scope, rawImageData: oe, encoding: this.encoding, padding: se };
                u.actor && u.state !== "expired" || (u.actor = this.dispatcher.getActor(), u.actor.send("loadDEMTile", ve, c.bind(this), void 0, !0));
              }
            }).bind(this));
          }
          _getNeighboringTiles(u) {
            const t = u.canonical, n = Math.pow(2, t.z), c = (t.x - 1 + n) % n, p = t.x === 0 ? u.wrap - 1 : u.wrap, v = (t.x + 1 + n) % n, C = t.x + 1 === n ? u.wrap + 1 : u.wrap, V = {};
            return V[new i.aG(u.overscaledZ, p, t.z, c, t.y).key] = { backfilled: !1 }, V[new i.aG(u.overscaledZ, C, t.z, v, t.y).key] = { backfilled: !1 }, t.y > 0 && (V[new i.aG(u.overscaledZ, p, t.z, c, t.y - 1).key] = { backfilled: !1 }, V[new i.aG(u.overscaledZ, u.wrap, t.z, t.x, t.y - 1).key] = { backfilled: !1 }, V[new i.aG(u.overscaledZ, C, t.z, v, t.y - 1).key] = { backfilled: !1 }), t.y + 1 < n && (V[new i.aG(u.overscaledZ, p, t.z, c, t.y + 1).key] = { backfilled: !1 }, V[new i.aG(u.overscaledZ, u.wrap, t.z, t.x, t.y + 1).key] = { backfilled: !1 }, V[new i.aG(u.overscaledZ, C, t.z, v, t.y + 1).key] = { backfilled: !1 }), V;
          }
        }, "raster-array": En, geojson: class extends i.E {
          constructor(u, t, n, c) {
            super(), this.id = u, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = n.getActor(), this.setEventedParent(c), this._data = t.data, this._options = i.l({}, t), this._collectResourceTiming = t.collectResourceTiming, t.maxzoom !== void 0 && (this.maxzoom = t.maxzoom), t.minzoom !== void 0 && (this.minzoom = t.minzoom), t.type && (this.type = t.type), t.attribution && (this.attribution = t.attribution), this.promoteId = t.promoteId;
            const p = i.ag / this.tileSize;
            this.workerOptions = i.l({ source: this.id, scope: this.scope, cluster: t.cluster || !1, geojsonVtOptions: { buffer: (t.buffer !== void 0 ? t.buffer : 128) * p, tolerance: (t.tolerance !== void 0 ? t.tolerance : 0.375) * p, extent: i.ag, maxZoom: this.maxzoom, lineMetrics: t.lineMetrics || !1, generateId: t.generateId || !1 }, superclusterOptions: { maxZoom: t.clusterMaxZoom !== void 0 ? t.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, t.clusterMinPoints || 2), extent: i.ag, radius: (t.clusterRadius !== void 0 ? t.clusterRadius : 50) * p, log: !1, generateId: t.generateId || !1 }, clusterProperties: t.clusterProperties, filter: t.filter, dynamic: t.dynamic }, t.workerOptions);
          }
          onAdd(u) {
            this.map = u, this.setData(this._data);
          }
          setData(u) {
            return this._data = u, this._updateWorkerData(), this;
          }
          updateData(u) {
            if (!this._options.dynamic) return this.fire(new i.y(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
            if (typeof u != "string" && (u.type === "Feature" && (u = { type: "FeatureCollection", features: [u] }), u.type !== "FeatureCollection")) return this.fire(new i.y(new Error("Data to update should be a feature or a feature collection.")));
            if (this._coalesce && typeof u != "string" && typeof this._data != "string" && this._data.type === "FeatureCollection") {
              const t = /* @__PURE__ */ new Map();
              for (const n of this._data.features) t.set(n.id, n);
              for (const n of u.features) t.set(n.id, n);
              this._data.features = [...t.values()];
            } else this._data = u;
            return this._updateWorkerData(!0), this;
          }
          getClusterExpansionZoom(u, t) {
            return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: u, source: this.id, scope: this.scope }, t), this;
          }
          getClusterChildren(u, t) {
            return this.actor.send("geojson.getClusterChildren", { clusterId: u, source: this.id, scope: this.scope }, t), this;
          }
          getClusterLeaves(u, t, n, c) {
            return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: u, limit: t, offset: n }, c), this;
          }
          _updateWorkerData(u = !1) {
            if (this._pendingLoad) return void (this._coalesce = !0);
            this.fire(new i.z("dataloading", { dataType: "source" })), this._loaded = !1;
            const t = i.l({ append: u }, this.workerOptions);
            t.scope = this.scope;
            const n = this._data;
            typeof n == "string" ? (t.request = this.map._requestManager.transformRequest(i.q.resolveURL(n), i.R.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(n), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, (c, p) => {
              if (this._loaded = !0, this._pendingLoad = null, c) this.fire(new i.y(c));
              else {
                const v = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                this._collectResourceTiming && p && p.resourceTiming && p.resourceTiming[this.id] && (v.resourceTiming = p.resourceTiming[this.id]), u && (this._partialReload = !0), this.fire(new i.z("data", v)), this._partialReload = !1, this._metadataFired = !0;
              }
              this._coalesce && (this._updateWorkerData(u), this._coalesce = !1);
            });
          }
          loaded() {
            return this._loaded;
          }
          reload() {
            const u = i.aC(this.id, this.scope);
            this.map.style.clearSource(u), this._updateWorkerData();
          }
          loadTile(u, t) {
            const n = u.actor ? "reloadTile" : "loadTile";
            u.actor = this.actor;
            const c = this.map.style ? this.map.style.getLut(this.scope) : null, p = c ? { image: c.image.clone() } : null, v = this._partialReload, C = { type: this.type, uid: u.uid, tileID: u.tileID, tileZoom: u.tileZoom, zoom: u.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, lut: p, scope: this.scope, pixelRatio: i.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0, scaleFactor: this.map.getScaleFactor(), partial: v };
            u.request = this.actor.send(n, C, (V, K) => v && !K ? (u.state = "loaded", t(null)) : (delete u.request, u.destroy(), u.aborted ? t(null) : V ? t(V) : (u.loadVectorData(K, this.map.painter, n === "reloadTile"), t(null))), void 0, n === "loadTile");
          }
          abortTile(u) {
            u.request && (u.request.cancel(), delete u.request), u.aborted = !0;
          }
          unloadTile(u, t) {
            this.actor.send("removeTile", { uid: u.uid, type: this.type, source: this.id, scope: this.scope }), u.destroy();
          }
          onRemove(u) {
            this._pendingLoad && this._pendingLoad.cancel();
          }
          serialize() {
            return i.l({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return !1;
          }
        }, video: class extends i.aJ {
          constructor(u, t, n, c) {
            super(u, t, n, c), this.roundZoom = !0, this.type = "video", this.options = t;
          }
          load() {
            this._loaded = !1;
            const u = this.options;
            this.urls = [];
            for (const t of u.urls) this.urls.push(this.map._requestManager.transformRequest(t, i.R.Source).url);
            i.aK(this.urls, (t, n) => {
              this._loaded = !0, t ? this.fire(new i.y(t)) : n && (this.video = n, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading());
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(u) {
            if (this.video) {
              const t = this.video.seekable;
              u < t.start(0) || u > t.end(0) ? this.fire(new i.y(new i.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${t.start(0)} and ${t.end(0)}-second mark.`))) : this.video.currentTime = u;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(u) {
            this.map || (this.map = u, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const u = this.map.painter.context, t = u.gl;
            this.texture ? this.video.paused || (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, t.RGBA, t.UNSIGNED_BYTE, this.video)) : (this.texture = new i.T(u, this.video, t.RGBA8), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(u);
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }, image: i.aJ, model: class extends i.E {
          constructor(u, t, n, c) {
            super(), this.id = u, this.type = "model", this.models = [], this._loaded = !1, this._options = t;
          }
          load() {
            const u = [];
            for (const t in this._options.models) {
              const n = this._options.models[t], c = i.aM(this.map._requestManager.transformRequest(n.uri, i.R.Model).url).then((p) => {
                if (!p) return;
                const v = i.aN(p), C = new i.aO(t, n.position, n.orientation, v);
                C.computeBoundsAndApplyParent(), this.models.push(C);
              }).catch((p) => {
                this.fire(new i.y(new Error(`Could not load model ${t} from ${n.uri}: ${p.message}`)));
              });
              u.push(c);
            }
            return Promise.allSettled(u).then(() => {
              this._loaded = !0, this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" }));
            }).catch((t) => {
              this.fire(new i.y(new Error(`Could not load models: ${t.message}`)));
            });
          }
          onAdd(u) {
            this.map = u, this.load();
          }
          hasTransition() {
            return !1;
          }
          loaded() {
            return this._loaded;
          }
          getModels() {
            return this.models;
          }
          loadTile(u, t) {
          }
          serialize() {
            return { type: "model" };
          }
        }, "batched-model": class extends i.E {
          constructor(u, t, n, c) {
            super(), this.type = "batched-model", this.id = u, this.tileSize = 512, this._options = t, this.tiles = this._options.tiles, this.maxzoom = t.maxzoom || 19, this.minzoom = t.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = n, this.reparseOverscaled = !1, this.scheme = "xyz", this._loaded = !1, this.setEventedParent(c);
          }
          onAdd(u) {
            this.map = u, this.load();
          }
          reload() {
            this.cancelTileJSONRequest();
            const u = i.aC(this.id, this.scope);
            this.load(() => this.map.style.clearSource(u));
          }
          cancelTileJSONRequest() {
            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
          }
          load(u) {
            this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" }));
            const t = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, n = this.map.getWorldview();
            this._tileJSONRequest = Ir(this._options, this.map._requestManager, t, n, (c, p) => {
              this._tileJSONRequest = null, this._loaded = !0, c ? (t && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t}`), n && n.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${n}`), this.fire(new i.y(c))) : p && (i.l(this, p), p.bounds && (this.tileBounds = new Mr(p.bounds, this.minzoom, this.maxzoom)), bt(p.tiles, this.map._requestManager._customAccessToken), this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }))), u && u(c);
            });
          }
          hasTransition() {
            return !1;
          }
          hasTile(u) {
            return !this.tileBounds || this.tileBounds.contains(u.canonical);
          }
          loaded() {
            return this._loaded;
          }
          loadTile(u, t) {
            const n = this.map._requestManager.normalizeTileURL(u.tileID.canonical.url(this.tiles, this.scheme)), c = { request: this.map._requestManager.transformRequest(n, i.R.Tile), data: void 0, uid: u.uid, tileID: u.tileID, tileZoom: u.tileZoom, zoom: u.tileID.overscaledZ, tileSize: this.tileSize * u.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: u.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, lut: null, maxZoom: null, promoteId: null, pixelRatio: null, scaleFactor: null };
            if (u.actor && u.state !== "expired") if (u.state === "loading") u.reloadCallback = t;
            else {
              if (u.buckets) {
                const v = Object.values(u.buckets);
                for (const C of v) C.dirty = !0;
                return void (u.state = "loaded");
              }
              u.request = u.actor.send("reloadTile", c, p.bind(this));
            }
            else u.actor = this.dispatcher.getActor(), u.request = u.actor.send("loadTile", c, p.bind(this), void 0, !0);
            function p(v, C) {
              return u.aborted ? t(null) : v && v.status !== 404 ? t(v) : (this.map._refreshExpiredTiles && C && u.setExpiryData(C), u.loadModelData(C, this.map.painter), u.state = "loaded", void t(null));
            }
          }
          serialize() {
            return i.l({}, this._options);
          }
        }, canvas: class extends i.aJ {
          constructor(u, t, n, c) {
            super(u, t, n, c), t.coordinates ? Array.isArray(t.coordinates) && t.coordinates.length === 4 && !t.coordinates.some((p) => !Array.isArray(p) || p.length !== 2 || p.some((v) => typeof v != "number")) || this.fire(new i.y(new i.V(`sources.${u}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new i.y(new i.V(`sources.${u}`, null, 'missing required property "coordinates"'))), t.animate && typeof t.animate != "boolean" && this.fire(new i.y(new i.V(`sources.${u}`, null, 'optional "animate" property must be a boolean value'))), t.canvas ? typeof t.canvas == "string" || t.canvas instanceof HTMLCanvasElement || this.fire(new i.y(new i.V(`sources.${u}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new i.y(new i.V(`sources.${u}`, null, 'missing required property "canvas"'))), this.options = t, this.animate = t.animate === void 0 || t.animate;
          }
          load() {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new i.y(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(u) {
            this.map = u, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove(u) {
            this.pause();
          }
          prepare() {
            let u = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, u = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, u = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const t = this.map.painter.context;
            this.texture ? !u && !this._playing || this.texture instanceof i.aL || this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new i.T(t, this.canvas, t.gl.RGBA8, { premultiply: !0 }), this._prepareData(t);
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const u of [this.canvas.width, this.canvas.height]) if (isNaN(u) || u <= 0) return !0;
            return !1;
          }
        }, custom: class extends i.E {
          constructor(u, t, n, c) {
            super(), this.id = u, this.type = "custom", this._dataType = "raster", this._dispatcher = n, this._implementation = t, this.setEventedParent(c), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new i.y(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new i.y(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new Mr(this._implementation.bounds, this.minzoom, this.maxzoom)), t.update = this._update.bind(this), t.clearTiles = this._clearTiles.bind(this), t.coveringTiles = this._coveringTiles.bind(this), i.l(this, i.ay(t, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
          }
          serialize() {
            return i.ay(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
          }
          load() {
            this._loaded = !0, this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }));
          }
          loaded() {
            return this._loaded;
          }
          onAdd(u) {
            this.map = u, this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(u), this.load();
          }
          onRemove(u) {
            this._implementation.onRemove && this._implementation.onRemove(u);
          }
          hasTile(u) {
            if (this._implementation.hasTile) {
              const { x: t, y: n, z: c } = u.canonical;
              return this._implementation.hasTile({ x: t, y: n, z: c });
            }
            return !this.tileBounds || this.tileBounds.contains(u.canonical);
          }
          loadTile(u, t) {
            const { x: n, y: c, z: p } = u.tileID.canonical, v = new AbortController();
            u.request = Promise.resolve(this._implementation.loadTile({ x: n, y: c, z: p }, { signal: v.signal })).then((function(C) {
              return delete u.request, u.aborted ? (u.state = "unloaded", t(null)) : C === void 0 ? (u.state = "errored", t(null)) : C === null ? (this.loadTileData(u, { width: this.tileSize, height: this.tileSize, data: null }), u.state = "loaded", t(null)) : function(V) {
                return V instanceof ImageData || V instanceof HTMLCanvasElement || V instanceof ImageBitmap || V instanceof HTMLImageElement;
              }(C) ? (this.loadTileData(u, C), u.state = "loaded", void t(null)) : (u.state = "errored", t(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
            }).bind(this)).catch((C) => {
              C.code !== 20 && (u.state = "errored", t(C));
            }), u.request.cancel = () => v.abort();
          }
          loadTileData(u, t) {
            u.setTexture(t, this.map.painter);
          }
          unloadTile(u, t) {
            if (u.texture && u.texture instanceof i.T ? (u.destroy(!0), u.texture && u.texture instanceof i.T && this.map.painter.saveTileTexture(u.texture)) : u.destroy(), this._implementation.unloadTile) {
              const { x: n, y: c, z: p } = u.tileID.canonical;
              this._implementation.unloadTile({ x: n, y: c, z: p });
            }
            t && t();
          }
          abortTile(u, t) {
            u.request && u.request.cancel && (u.request.cancel(), delete u.request), t && t();
          }
          hasTransition() {
            return !1;
          }
          _coveringTiles() {
            return this.map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((u) => ({ x: u.canonical.x, y: u.canonical.y, z: u.canonical.z }));
          }
          _clearTiles() {
            const u = i.aC(this.id, this.scope);
            this.map.style.clearSource(u);
          }
          _update() {
            this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }));
          }
        } }, Yn = function(u, t, n, c) {
          const p = new Vn[t.type](u, t, n, c);
          if (p.id !== u) throw new Error(`Expected Source id to be ${u} instead of ${p.id}`);
          return i.aP(["load", "abort", "unload", "serialize", "prepare"], p), p;
        };
        function ka(u, t, n = "") {
          return `${n}:${t.id || ""}:${t.layer.id}:${function(c) {
            if ("layerId" in c) return `layer:${c.layerId}`;
            {
              const { featuresetId: p, importId: v } = c;
              return `featureset:${p}${v ? `:import:${v}` : ""}`;
            }
          }(u.target)}`;
        }
        function ea(u, t, n, c = "") {
          if (u.uniqueFeatureID) {
            const p = ka(u, t, c);
            if (n.has(p)) return !0;
            n.add(p);
          }
          return !1;
        }
        function ga(u, t, n, c, p = !1) {
          const v = t.sourceCache.transform, C = t.sourceCache.tilesIn(u, t.has3DLayers, p);
          C.sort(Bo);
          const V = [];
          for (const K of C) {
            const se = K.tile.queryRenderedFeatures(t, K, n, c, v, p);
            Object.keys(se).length && V.push({ wrappedTileID: K.tile.tileID.wrapped().key, queryResults: se });
          }
          return V.length === 0 ? {} : function(K) {
            const se = {}, oe = {};
            for (const ve of K) {
              const xe = ve.queryResults, Le = ve.wrappedTileID, ft = oe[Le] = oe[Le] || {};
              for (const st in xe) {
                const vt = xe[st], gt = ft[st] = ft[st] || {}, Rt = se[st] = se[st] || [];
                for (const qt of vt) gt[qt.featureIndex] || (gt[qt.featureIndex] = !0, Rt.push(qt));
              }
            }
            return se;
          }(V);
        }
        function Ta(u, t, n, c, p) {
          const v = {}, C = c.queryRenderedSymbols(u), V = [];
          for (const K of Object.keys(C).map(Number)) V.push(p[K]);
          V.sort(Bo);
          for (const K of V) {
            const se = K.featureIndex.lookupSymbolFeatures(C[K.bucketInstanceId], K.bucketIndex, K.sourceLayerIndex, t, n);
            for (const oe in se) {
              const ve = v[oe] = v[oe] || [], xe = se[oe];
              xe.sort((Le, ft) => {
                const st = K.featureSortOrder;
                if (st) {
                  const vt = st.indexOf(Le.featureIndex);
                  return st.indexOf(ft.featureIndex) - vt;
                }
                return ft.featureIndex - Le.featureIndex;
              });
              for (const Le of xe) ve.push(Le);
            }
          }
          return v;
        }
        function ha(u, t) {
          const n = u.getRenderableIds().map((v) => u.getTileByID(v)), c = [], p = {};
          for (let v = 0; v < n.length; v++) {
            const C = n[v], V = C.tileID.canonical.key;
            p[V] || (p[V] = !0, C.querySourceFeatures(c, t));
          }
          return c;
        }
        function Bo(u, t) {
          const n = u.tileID, c = t.tileID;
          return n.overscaledZ - c.overscaledZ || n.canonical.y - c.canonical.y || n.wrap - c.wrap || n.canonical.x - c.canonical.x;
        }
        function Ao(u, t) {
          const n = {};
          if (!t) return n;
          for (const c of u) {
            const p = c.layerIds.map((v) => t.getLayer(v)).filter(Boolean);
            if (p.length !== 0) {
              c.layers = p, c.stateDependentLayerIds && (c.stateDependentLayers = c.stateDependentLayerIds.map((v) => p.filter((C) => C.id === v)[0]));
              for (const v of p) n[v.fqid] = c;
            }
          }
          return n;
        }
        const za = 32, ss = 33, os = new Uint16Array(8184);
        for (let u = 0; u < 2046; u++) {
          let t = u + 2, n = 0, c = 0, p = 0, v = 0, C = 0, V = 0;
          for (1 & t ? p = v = C = za : n = c = V = za; (t >>= 1) > 1; ) {
            const se = n + p >> 1, oe = c + v >> 1;
            1 & t ? (p = n, v = c, n = C, c = V) : (n = p, c = v, p = C, v = V), C = se, V = oe;
          }
          const K = 4 * u;
          os[K + 0] = n, os[K + 1] = c, os[K + 2] = p, os[K + 3] = v;
        }
        const Ms = new Uint16Array(2178), La = new Uint8Array(1089), mn = new Uint16Array(1089);
        function eo(u) {
          return u === 0 ? -0.03125 : u === 32 ? 0.03125 : 0;
        }
        const mo = { type: 2, extent: i.ag, loadGeometry: () => [[new i.P(0, 0), new i.P(i.ag + 1, 0), new i.P(i.ag + 1, i.ag + 1), new i.P(0, i.ag + 1), new i.P(0, 0)]] };
        class Ba {
          constructor(t, n, c, p, v) {
            this.tileID = t, this.uid = i.aV(), this.uses = 0, this.tileSize = n, this.tileZoom = c, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = v, p && p.style && (this._lastUpdatedBrightness = p.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", p && p.transform && (this.projection = p.transform.projection);
          }
          registerFadeDuration(t) {
            const n = t + this.timeAdded;
            n < i.q.now() || this.fadeEndTime && n < this.fadeEndTime || (this.fadeEndTime = n);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          get tileTransform() {
            return this._tileTransform || (this._tileTransform = i.aQ(this.tileID.canonical, this.projection)), this._tileTransform;
          }
          loadVectorData(t, n, c) {
            if (this.unloadVectorData(), this.state = "loaded", t) {
              t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = Ao(t.buckets, n.style), this.hasSymbolBuckets = !1;
              for (const p in this.buckets) {
                const v = this.buckets[p];
                if (v instanceof i.aX) {
                  if (this.hasSymbolBuckets = !0, !c) break;
                  v.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const p in this.buckets) {
                const v = this.buckets[p];
                if (v instanceof i.aX && v.hasRTLText) {
                  this.hasRTLText = !0, i.aY();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const p in this.buckets) {
                const v = this.buckets[p], C = n.style.getOwnLayer(p);
                if (!C) continue;
                const V = C.queryRadius(v);
                this.queryPadding = Math.max(this.queryPadding, V);
              }
              t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas), this._lastUpdatedBrightness = t.brightness;
            } else this.collisionBoxArray = new i.aW();
          }
          unloadVectorData() {
            if (this.hasData()) {
              for (const t in this.buckets) this.buckets[t].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
            }
          }
          loadModelData(t, n, c) {
            t && (t.resourceTiming && (this.resourceTiming = t.resourceTiming), this.buckets = Object.assign({}, this.buckets, Ao(t.buckets, n.style)), t.featureIndex && (this.latestFeatureIndex = t.featureIndex));
          }
          getBucket(t) {
            return this.buckets[t.fqid];
          }
          upload(t) {
            for (const p in this.buckets) {
              const v = this.buckets[p];
              v.uploadPending() && v.upload(t);
            }
            const n = t.gl, c = this.imageAtlas;
            if (c && !c.uploaded) {
              const p = !!Object.keys(c.patternPositions).length;
              this.imageAtlasTexture = new i.T(t, c.image, n.RGBA8, { useMipmap: p }), this.imageAtlas.uploaded = !0;
            }
            this.glyphAtlasImage && (this.glyphAtlasTexture = new i.T(t, this.glyphAtlasImage, n.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new i.T(t, this.lineAtlas.image, n.R8), this.lineAtlas.uploaded = !0);
          }
          prepare(t, n, c) {
            if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture, c), !n || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
            const p = n.style.getBrightness();
            (this._lastUpdatedBrightness || p) && (this._lastUpdatedBrightness && p && Math.abs(this._lastUpdatedBrightness - p) < 1e-3 || (this.updateBuckets(n, this._lastUpdatedBrightness !== p), this._lastUpdatedBrightness = p));
          }
          queryRenderedFeatures(t, n, c, p, v, C) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};
            const V = function(K, se) {
              const oe = i.ab.mat4.fromScaling([], [0.5 * K.width, 0.5 * -K.height, 1]);
              return i.ab.mat4.translate(oe, oe, [1, -1, 0]), i.ab.mat4.multiply(oe, oe, K.calculateProjMatrix(se.toUnwrapped())), Float32Array.from(oe);
            }(v, this.tileID);
            return this.latestFeatureIndex.query(t, { tilespaceGeometry: n, pixelPosMatrix: V, transform: p, availableImages: c, tileTransform: this.tileTransform });
          }
          querySourceFeatures(t, n) {
            const c = this.latestFeatureIndex;
            if (!c || !c.rawTileData) return;
            const p = c.loadVTLayers(), v = n ? n.sourceLayer : "", C = p._geojsonTileLayer || p[v];
            if (!C) return;
            const V = i.aZ(n && n.filter), { z: K, x: se, y: oe } = this.tileID.canonical, ve = { z: K, x: se, y: oe };
            for (let xe = 0; xe < C.length; xe++) {
              const Le = C.feature(xe);
              if (V.needGeometry) {
                const vt = i.a_(Le, !0);
                if (!V.filter(new i.a8(this.tileID.overscaledZ), vt, this.tileID.canonical)) continue;
              } else if (!V.filter(new i.a8(this.tileID.overscaledZ), Le)) continue;
              const ft = c.getId(Le, v), st = new i.a$(Le, K, se, oe, ft);
              st.tile = ve, t.push(st);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(t) {
            const n = this.expirationTime;
            if (t.cacheControl) {
              const c = i.b0(t.cacheControl);
              c["max-age"] && (this.expirationTime = Date.now() + 1e3 * c["max-age"]);
            } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
            if (this.expirationTime) {
              const c = Date.now();
              let p = !1;
              if (this.expirationTime > c) p = !1;
              else if (n) if (this.expirationTime < n) p = !0;
              else {
                const v = this.expirationTime - n;
                v ? this.expirationTime = c + Math.max(v, 3e4) : p = !0;
              }
              else p = !0;
              p ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          refreshFeatureState(t) {
            this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && t && this.updateBuckets(t);
          }
          updateBuckets(t, n) {
            if (!this.latestFeatureIndex || !t.style) return;
            const c = this.latestFeatureIndex.loadVTLayers(), p = t.style.listImages(), v = t.style.getBrightness();
            for (const C in this.buckets) {
              if (!t.style.hasLayer(C)) continue;
              const V = this.buckets[C], K = V.layers[0], se = K.sourceLayer || "_geojsonTileLayer", oe = c[se], ve = t.style.getLayerSourceCache(K);
              let xe = {};
              ve && (xe = ve._state.getState(se, void 0));
              const Le = this.imageAtlas && this.imageAtlas.patternPositions || {}, ft = Object.keys(xe).length > 0 && !n;
              ft && !V.stateDependentLayers.length && !n || V.update(xe, oe, p, Le, ft ? V.stateDependentLayers : V.layers, n, v), (V instanceof i.b1 || V instanceof i.b2) && t._terrain && t._terrain.enabled && ve && V.programConfigurations.needsUpload && t._terrain._clearRenderCacheForTile(ve.id, this.tileID);
              const st = t && t.style && t.style.getOwnLayer(C);
              st && (this.queryPadding = Math.max(this.queryPadding, st.queryRadius(V)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < i.q.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(t) {
            this.symbolFadeHoldUntil = i.q.now() + t;
          }
          setTexture(t, n) {
            const c = n.context, p = c.gl;
            this.texture = this.texture || n.getTileTexture(t.width), this.texture && this.texture instanceof i.T ? this.texture.update(t) : (this.texture = new i.T(c, t, p.RGBA8, { useMipmap: !0 }), this.texture.bind(p.LINEAR, p.CLAMP_TO_EDGE));
          }
          setDependencies(t, n) {
            const c = {};
            for (const p of n) c[p] = !0;
            this.dependencies[t] = c;
          }
          hasDependency(t, n) {
            for (const c of t) {
              const p = this.dependencies[c];
              if (p) {
                for (const v of n) if (p[v]) return !0;
              }
            }
            return !1;
          }
          clearQueryDebugViz() {
          }
          _makeDebugTileBoundsBuffers(t, n) {
            if (!n || n.name === "mercator" || this._tileDebugBuffer) return;
            const c = i.b3(mo, this.tileID.canonical, this.tileTransform)[0], p = new i.b4(), v = new i.b5();
            for (let C = 0; C < c.length; C++) {
              const { x: V, y: K } = c[C];
              p.emplaceBack(V, K), v.emplaceBack(C);
            }
            v.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(v), this._tileDebugBuffer = t.createVertexBuffer(p, i.b6.members), this._tileDebugSegments = i.b7.simpleSegment(0, 0, p.length, v.length);
          }
          _makeTileBoundsBuffers(t, n) {
            if (this._tileBoundsBuffer || !n || n.name === "mercator") return;
            const c = i.b3(mo, this.tileID.canonical, this.tileTransform)[0];
            let p, v;
            if (this.isRaster) {
              const C = function(V, K) {
                const se = i.aQ(V, K), oe = Math.pow(2, V.z);
                for (let vt = 0; vt < ss; vt++) for (let gt = 0; gt < ss; gt++) {
                  const Rt = i.aR((V.x + (gt + eo(gt)) / za) / oe), qt = i.aS((V.y + (vt + eo(vt)) / za) / oe), jt = K.project(Rt, qt), ii = vt * ss + gt;
                  Ms[2 * ii + 0] = Math.round((jt.x * se.scale - se.x) * i.ag), Ms[2 * ii + 1] = Math.round((jt.y * se.scale - se.y) * i.ag);
                }
                La.fill(0), mn.fill(0);
                for (let vt = 2045; vt >= 0; vt--) {
                  const gt = 4 * vt, Rt = os[gt + 0], qt = os[gt + 1], jt = os[gt + 2], ii = os[gt + 3], Xt = Rt + jt >> 1, Kt = qt + ii >> 1, Zt = Xt + Kt - qt, Jt = Kt + Rt - Xt, ui = qt * ss + Rt, Ti = ii * ss + jt, xi = Kt * ss + Xt, Pi = Math.hypot((Ms[2 * ui + 0] + Ms[2 * Ti + 0]) / 2 - Ms[2 * xi + 0], (Ms[2 * ui + 1] + Ms[2 * Ti + 1]) / 2 - Ms[2 * xi + 1]) >= 16;
                  La[xi] = La[xi] || (Pi ? 1 : 0), vt < 1022 && (La[xi] = La[xi] || La[(qt + Jt >> 1) * ss + (Rt + Zt >> 1)] || La[(ii + Jt >> 1) * ss + (jt + Zt >> 1)]);
                }
                const ve = new i.aT(), xe = new i.aU();
                let Le = 0;
                function ft(vt, gt) {
                  const Rt = gt * ss + vt;
                  return mn[Rt] === 0 && (ve.emplaceBack(Ms[2 * Rt + 0], Ms[2 * Rt + 1], vt * i.ag / za, gt * i.ag / za), mn[Rt] = ++Le), mn[Rt] - 1;
                }
                function st(vt, gt, Rt, qt, jt, ii) {
                  const Xt = vt + Rt >> 1, Kt = gt + qt >> 1;
                  if (Math.abs(vt - jt) + Math.abs(gt - ii) > 1 && La[Kt * ss + Xt]) st(jt, ii, vt, gt, Xt, Kt), st(Rt, qt, jt, ii, Xt, Kt);
                  else {
                    const Zt = ft(vt, gt), Jt = ft(Rt, qt), ui = ft(jt, ii);
                    xe.emplaceBack(Zt, Jt, ui);
                  }
                }
                return st(0, 0, za, za, za, 0), st(za, za, 0, 0, 0, za), { vertices: ve, indices: xe };
              }(this.tileID.canonical, n);
              p = C.vertices, v = C.indices;
            } else {
              p = new i.aT(), v = new i.aU();
              for (const { x: V, y: K } of c) p.emplaceBack(V, K, 0, 0);
              const C = i.b8(p.int16, void 0, 4);
              for (let V = 0; V < C.length; V += 3) v.emplaceBack(C[V], C[V + 1], C[V + 2]);
            }
            this._tileBoundsBuffer = t.createVertexBuffer(p, i.b9.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(v), this._tileBoundsSegments = i.b7.simpleSegment(0, 0, p.length, v.length);
          }
          _makeGlobeTileDebugBuffers(t, n) {
            const c = n.projection;
            if (!c || c.name !== "globe" || n.freezeTileCoverage) return;
            const p = this.tileID.canonical, v = i.ba(p, n), C = i.bb(v), V = i.ae(n.zoom);
            let K;
            V > 0 && (K = i.ab.mat4.invert(new Float64Array(16), n.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, p, n, C, K, V), this._makeGlobeTileDebugTextBuffer(t, p, n, C, K, V);
          }
          _globePoint(t, n, c, p, v, C, V) {
            let K = i.bc(t, n, c);
            if (C) {
              const se = 1 << c.z, oe = i.at(p.center.lng), ve = i.aA(p.center.lat), xe = (c.x + 0.5) / se - oe;
              let Le = 0;
              xe > 0.5 ? Le = -1 : xe < -0.5 && (Le = 1);
              let ft = (t / i.ag + c.x) / se + Le, st = (n / i.ag + c.y) / se;
              ft = (ft - oe) * p._pixelsPerMercatorPixel + oe, st = (st - ve) * p._pixelsPerMercatorPixel + ve;
              const vt = [ft * p.worldSize, st * p.worldSize, 0];
              i.ab.vec3.transformMat4(vt, vt, C), K = i.bd(K, vt, V);
            }
            return i.ab.vec3.transformMat4(K, K, v);
          }
          _makeGlobeTileDebugBorderBuffer(t, n, c, p, v, C) {
            const V = new i.b4(), K = new i.b5(), se = new i.be(), oe = (xe, Le, ft, st, vt) => {
              const gt = (ft - xe) / (vt - 1), Rt = (st - Le) / (vt - 1), qt = V.length;
              for (let jt = 0; jt < vt; jt++) {
                const ii = xe + jt * gt, Xt = Le + jt * Rt;
                V.emplaceBack(ii, Xt);
                const Kt = this._globePoint(ii, Xt, n, c, p, v, C);
                se.emplaceBack(Kt[0], Kt[1], Kt[2]), K.emplaceBack(qt + jt);
              }
            }, ve = i.ag;
            oe(0, 0, ve, 0, 16), oe(ve, 0, ve, ve, 16), oe(ve, ve, 0, ve, 16), oe(0, ve, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(K), this._tileDebugBuffer = t.createVertexBuffer(V, i.b6.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(se, i.bf.members), this._tileDebugSegments = i.b7.simpleSegment(0, 0, V.length, K.length);
          }
          _makeGlobeTileDebugTextBuffer(t, n, c, p, v, C) {
            const V = i.ag / 4, K = new i.b4(), se = new i.aU(), oe = new i.be(), ve = 25;
            se.reserve(32), K.reserve(ve), oe.reserve(ve);
            const xe = (Le, ft) => ve * Le + ft;
            for (let Le = 0; Le < ve; Le++) {
              const ft = Le * V;
              for (let st = 0; st < ve; st++) {
                const vt = st * V;
                K.emplaceBack(vt, ft);
                const gt = this._globePoint(vt, ft, n, c, p, v, C);
                oe.emplaceBack(gt[0], gt[1], gt[2]);
              }
            }
            for (let Le = 0; Le < 4; Le++) for (let ft = 0; ft < 4; ft++) {
              const st = xe(Le, ft), vt = xe(Le, ft + 1), gt = xe(Le + 1, ft), Rt = xe(Le + 1, ft + 1);
              se.emplaceBack(st, vt, gt), se.emplaceBack(gt, vt, Rt);
            }
            this._tileDebugTextIndexBuffer = t.createIndexBuffer(se), this._tileDebugTextBuffer = t.createVertexBuffer(K, i.b6.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(oe, i.bf.members), this._tileDebugTextSegments = i.b7.simpleSegment(0, 0, ve, 32);
          }
          destroy(t = !1) {
            for (const n in this.buckets) this.buckets[n].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t && this.texture && this.texture instanceof i.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        i.bg.setPbf(i.bh);
        class tn extends Ba {
          constructor(t, n, c, p, v) {
            super(t, n, c, p, v), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = !1;
          }
          setTexture(t, n) {
            const c = n.context, p = c.gl;
            this.texture = this.texture || n.getTileTexture(t.width), this.texture && this.texture instanceof i.T ? this.texture.update(t, { premultiply: !1 }) : this.texture = new i.T(c, t, p.RGBA8, { premultiply: !1 });
          }
          flushQueues() {
            for (; this._workQueue.length; ) this._workQueue.pop()();
            for (; this._fetchQueue.length; ) this._fetchQueue.pop()();
          }
          fetchHeader(t = 16384, n) {
            const c = this._mrt = new i.bg(30), p = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t - 1) } });
            return this.entireBuffer = null, this.request = i.bi(p, (v, C, V, K) => {
              if (v) n(v);
              else try {
                const se = c.getHeaderLength(C);
                if (se > t) return void (this.request = this.fetchHeader(se, n));
                c.parseHeader(C), this._isHeaderLoaded = !0;
                let oe = 0;
                for (const ve of Object.values(c.layers)) oe = Math.max(oe, ve.dataIndex[ve.dataIndex.length - 1].last_byte);
                C.byteLength >= oe && (this.entireBuffer = C), n(null, this.entireBuffer || C, V, K);
              } catch (se) {
                n(se);
              }
            }), this.request;
          }
          fetchBand(t, n, c) {
            const p = this._mrt;
            if (!this._isHeaderLoaded || !p) return void c(new Error("Tile header is not ready"));
            const v = this.actor;
            if (!v) return void c(new Error("Can't fetch tile band without an actor"));
            let C;
            const V = (ve, xe) => {
              C.complete(ve, xe), ve ? c(ve) : (this.updateTextureDescriptor(t, n), c(null, this.textureDescriptor && this.textureDescriptor.img));
            }, K = (ve, xe) => {
              if (ve) return c(ve);
              const Le = v.send("decodeRasterArray", { buffer: xe, task: C }, V, void 0, !0);
              this._workQueue.push(() => {
                Le && Le.cancel(), C.cancel();
              });
            }, se = p.getLayer(t);
            if (!se) return void c(new Error(`Unknown sourceLayer "${t}"`));
            if (se.hasDataForBand(n)) return this.updateTextureDescriptor(t, n), void c(null, this.textureDescriptor ? this.textureDescriptor.img : null);
            const oe = se.getDataRange([n]);
            if (C = p.createDecodingTask(oe), !C || C.tasks.length) if (this.flushQueues(), this.entireBuffer) K(null, this.entireBuffer.slice(oe.firstByte, oe.lastByte + 1));
            else {
              const ve = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${oe.firstByte}-${oe.lastByte}` } }), xe = i.bi(ve, K);
              this._fetchQueue.push(() => {
                xe.cancel(), C.cancel();
              });
            }
            else c(null);
          }
          updateNeeded(t, n) {
            return (!this.textureDescriptor || this.textureDescriptor.band !== n || this.textureDescriptor.layer !== t) && this.state !== "errored";
          }
          updateTextureDescriptor(t, n) {
            if (!this._mrt) return;
            const c = this._mrt.getLayer(t);
            if (!c || !c.hasBand(n) || !c.hasDataForBand(n)) return;
            const { bytes: p, tileSize: v, buffer: C, offset: V, scale: K } = c.getBandView(n), se = v + 2 * C, oe = { data: p, width: se, height: se }, ve = this.texture;
            ve && ve instanceof i.T && ve.update(oe, { premultiply: !1 }), this.textureDescriptor = { layer: t, band: n, img: oe, buffer: C, offset: V, tileSize: v, format: c.pixelFormat, mix: [K, 256 * K, 65536 * K, 16777216 * K] };
          }
        }
        class ys {
          constructor(t, n) {
            this.max = t, this.onRemove = n, this.reset();
          }
          reset() {
            for (const t in this.data) for (const n of this.data[t]) n.timeout && clearTimeout(n.timeout), this.onRemove(n.value);
            return this.data = {}, this.order = [], this;
          }
          add(t, n, c) {
            const p = t.wrapped().key;
            this.data[p] === void 0 && (this.data[p] = []);
            const v = { value: n, timeout: void 0 };
            if (c !== void 0 && (v.timeout = setTimeout(() => {
              this.remove(t, v);
            }, c)), this.data[p].push(v), this.order.push(p), this.order.length > this.max) {
              const C = this._getAndRemoveByKey(this.order[0]);
              C && this.onRemove(C);
            }
            return this;
          }
          has(t) {
            return t.wrapped().key in this.data;
          }
          getAndRemove(t) {
            return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
          }
          _getAndRemoveByKey(t) {
            const n = this.data[t].shift();
            return n.timeout && clearTimeout(n.timeout), this.data[t].length === 0 && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), n.value;
          }
          getByKey(t) {
            const n = this.data[t];
            return n ? n[0].value : null;
          }
          get(t) {
            return this.has(t) ? this.data[t.wrapped().key][0].value : null;
          }
          remove(t, n) {
            if (!this.has(t)) return this;
            const c = t.wrapped().key, p = n === void 0 ? 0 : this.data[c].indexOf(n), v = this.data[c][p];
            return this.data[c].splice(p, 1), v.timeout && clearTimeout(v.timeout), this.data[c].length === 0 && delete this.data[c], this.onRemove(v.value), this.order.splice(this.order.indexOf(c), 1), this;
          }
          setMaxSize(t) {
            for (this.max = t; this.order.length > this.max; ) {
              const n = this._getAndRemoveByKey(this.order[0]);
              n && this.onRemove(n);
            }
            return this;
          }
          filter(t) {
            const n = [];
            for (const c in this.data) for (const p of this.data[c]) t(p.value) || n.push(p);
            for (const c of n) this.remove(c.value.tileID, c);
          }
        }
        class Qa {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(t, n, c) {
            const p = String(n);
            if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][p] = this.stateChanges[t][p] || {}, i.l(this.stateChanges[t][p], c), this.deletedStates[t] === null) {
              this.deletedStates[t] = {};
              for (const v in this.state[t]) v !== p && (this.deletedStates[t][v] = null);
            } else if (this.deletedStates[t] && this.deletedStates[t][p] === null) {
              this.deletedStates[t][p] = {};
              for (const v in this.state[t][p]) c[v] || (this.deletedStates[t][p][v] = null);
            } else for (const v in c) this.deletedStates[t] && this.deletedStates[t][p] && this.deletedStates[t][p][v] === null && delete this.deletedStates[t][p][v];
          }
          removeFeatureState(t, n, c) {
            if (this.deletedStates[t] === null) return;
            const p = String(n);
            if (this.deletedStates[t] = this.deletedStates[t] || {}, c && n !== void 0) this.deletedStates[t][p] !== null && (this.deletedStates[t][p] = this.deletedStates[t][p] || {}, this.deletedStates[t][p][c] = null);
            else if (n !== void 0) if (this.stateChanges[t] && this.stateChanges[t][p]) for (c in this.deletedStates[t][p] = {}, this.stateChanges[t][p]) this.deletedStates[t][p][c] = null;
            else this.deletedStates[t][p] = null;
            else this.deletedStates[t] = null;
          }
          getState(t, n) {
            const c = this.state[t] || {}, p = this.stateChanges[t] || {}, v = this.deletedStates[t];
            if (v === null) return {};
            if (n !== void 0) {
              const V = String(n), K = i.l({}, c[V], p[V]);
              if (v) {
                const se = v[n];
                if (se === null) return {};
                for (const oe in se) delete K[oe];
              }
              return K;
            }
            const C = i.l({}, c, p);
            if (v) for (const V in v) delete C[V];
            return C;
          }
          initializeTileState(t, n) {
            t.refreshFeatureState(n);
          }
          coalesceChanges(t, n) {
            const c = {};
            for (const p in this.stateChanges) {
              this.state[p] = this.state[p] || {};
              const v = {};
              for (const C in this.stateChanges[p]) this.state[p][C] || (this.state[p][C] = {}), i.l(this.state[p][C], this.stateChanges[p][C]), v[C] = this.state[p][C];
              c[p] = v;
            }
            for (const p in this.deletedStates) {
              this.state[p] = this.state[p] || {};
              const v = {};
              if (this.deletedStates[p] === null) for (const C in this.state[p]) v[C] = {}, this.state[p][C] = {};
              else for (const C in this.deletedStates[p]) {
                if (this.deletedStates[p][C] === null) this.state[p][C] = {};
                else if (this.state[p][C]) for (const V of Object.keys(this.deletedStates[p][C])) delete this.state[p][C][V];
                v[C] = this.state[p][C];
              }
              c[p] = c[p] || {}, i.l(c[p], v);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(c).length !== 0) for (const p in t) t[p].refreshFeatureState(n);
          }
        }
        class fa extends i.E {
          constructor(t, n, c) {
            super(), this.id = t, this._onlySymbols = c, n.on("data", (p) => {
              p.dataType === "source" && p.sourceDataType === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && p.dataType === "source" && p.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform));
            }), n.on("error", () => {
              this._sourceErrored = !0;
            }), this._source = n, this._tiles = {}, this._cache = new ys(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = n.minTileCacheSize, this._maxTileCacheSize = n.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Qa(), this._isRaster = this._source.type === "raster" || this._source.type === "raster-dem" || this._source.type === "raster-array" || this._source.type === "custom" && this._source._dataType === "raster";
          }
          onAdd(t) {
            this.map = t, this._minTileCacheSize = this._minTileCacheSize === void 0 && t ? t._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = this._maxTileCacheSize === void 0 && t ? t._maxTileCacheSize : this._maxTileCacheSize;
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            for (const t in this._tiles) {
              const n = this._tiles[t];
              if (n.state !== "loaded" && n.state !== "errored") return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const t = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);
          }
          _loadTile(t, n) {
            return t.isSymbolTile = this._onlySymbols, t.isExtraShadowCaster = this._shadowCasterTiles[t.tileID.key], this._source.loadTile(t, n);
          }
          _unloadTile(t) {
            if (this._source.unloadTile) return this._source.unloadTile(t);
          }
          _abortTile(t) {
            if (this._source.abortTile) return this._source.abortTile(t);
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(t) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const n in this._tiles) {
              const c = this._tiles[n];
              c.upload(t), c.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
            }
          }
          getIds() {
            return i.bj(this._tiles).map((t) => t.tileID).sort(Wr).map((t) => t.key);
          }
          getRenderableIds(t, n) {
            const c = [];
            for (const p in this._tiles) this._isIdRenderable(+p, t, n) && c.push(this._tiles[p]);
            return t ? c.sort((p, v) => {
              const C = p.tileID, V = v.tileID, K = new i.P(C.canonical.x, C.canonical.y)._rotate(this.transform.angle), se = new i.P(V.canonical.x, V.canonical.y)._rotate(this.transform.angle);
              return C.overscaledZ - V.overscaledZ || se.y - K.y || se.x - K.x;
            }).map((p) => p.tileID.key) : c.map((p) => p.tileID).sort(Wr).map((p) => p.key);
          }
          hasRenderableParent(t) {
            const n = this.findLoadedParent(t, 0);
            return !!n && this._isIdRenderable(n.tileID.key);
          }
          _isIdRenderable(t, n, c) {
            return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (n || !this._tiles[t].holdingForFade()) && (c || !this._shadowCasterTiles[t]);
          }
          reload() {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const t in this._tiles) this._tiles[t].state !== "errored" && this._reloadTile(+t, "reloading");
            }
          }
          _reloadTile(t, n) {
            const c = this._tiles[t];
            c && (c.state !== "loading" && (c.state = n), this._loadTile(c, this._tileLoaded.bind(this, c, t, n)));
          }
          _tileLoaded(t, n, c, p) {
            if (p) if (t.state = "errored", p.status !== 404) this._source.fire(new i.y(p, { tile: t }));
            else {
              if (this._source.fire(new i.z("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id, tile: t })), !(t.tileID.key in this._loadedParentTiles)) return;
              if (this._source.type === "raster-dem" && this.usedForTerrain && this.map.painter.terrain) {
                const v = this.map.painter.terrain;
                this.update(this.transform, v.getScaledDemTileSize(), !0), v.resetTileLookupCache(this.id);
              } else this.update(this.transform);
            }
            else t.timeAdded = i.q.now(), c === "expired" && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(n, t), this._source.type === "raster-dem" && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new i.z("data", { dataType: "source", tile: t, coord: t.tileID, sourceCacheId: this.id }));
          }
          _backfillDEM(t) {
            const n = this.getRenderableIds();
            for (let p = 0; p < n.length; p++) {
              const v = n[p];
              if (t.neighboringTiles && t.neighboringTiles[v]) {
                const C = this.getTileByID(v);
                c(t, C), c(C, t);
              }
            }
            function c(p, v) {
              if (!p.dem || p.dem.borderReady) return;
              p.needsHillshadePrepare = !0, p.needsDEMTextureUpload = !0;
              let C = v.tileID.canonical.x - p.tileID.canonical.x;
              const V = v.tileID.canonical.y - p.tileID.canonical.y, K = Math.pow(2, p.tileID.canonical.z), se = v.tileID.key;
              C === 0 && V === 0 || Math.abs(V) > 1 || (Math.abs(C) > 1 && (Math.abs(C + K) === 1 ? C += K : Math.abs(C - K) === 1 && (C -= K)), v.dem && p.dem && (p.dem.backfillBorder(v.dem, C, V), p.neighboringTiles && p.neighboringTiles[se] && (p.neighboringTiles[se].backfilled = !0)));
            }
          }
          getTile(t) {
            return this.getTileByID(t.key);
          }
          getTileByID(t) {
            return this._tiles[t];
          }
          _retainLoadedChildren(t, n, c, p) {
            for (const v in this._tiles) {
              let C = this._tiles[v];
              if (p[v] || !C.hasData() || C.tileID.overscaledZ <= n || C.tileID.overscaledZ > c) continue;
              let V = C.tileID;
              for (; C && C.tileID.overscaledZ > n + 1; ) {
                const se = C.tileID.scaledTo(C.tileID.overscaledZ - 1);
                C = this._tiles[se.key], C && C.hasData() && (V = se);
              }
              let K = V;
              for (; K.overscaledZ > n; ) if (K = K.scaledTo(K.overscaledZ - 1), t[K.key]) {
                p[V.key] = V;
                break;
              }
            }
          }
          findLoadedParent(t, n) {
            if (t.key in this._loadedParentTiles) {
              const c = this._loadedParentTiles[t.key];
              return c && c.tileID.overscaledZ >= n ? c : null;
            }
            for (let c = t.overscaledZ - 1; c >= n; c--) {
              const p = t.scaledTo(c), v = this._getLoadedTile(p);
              if (v) return v;
            }
          }
          _getLoadedTile(t) {
            const n = this._tiles[t.key];
            return n && n.hasData() ? n : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key);
          }
          updateCacheSize(t, n) {
            n = n || this._source.tileSize;
            const c = Math.ceil(t.width / n) + 1, p = Math.ceil(t.height / n) + 1, v = Math.floor(c * p * 5), C = typeof this._minTileCacheSize == "number" ? Math.max(this._minTileCacheSize, v) : v, V = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, C) : C;
            this._cache.setMaxSize(V);
          }
          handleWrapJump(t) {
            const n = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
            if (this._prevLng = t, n) {
              const c = {};
              for (const p in this._tiles) {
                const v = this._tiles[p];
                v.tileID = v.tileID.unwrapTo(v.tileID.wrap + n), c[v.tileID.key] = v;
              }
              this._tiles = c;
              for (const p in this._timers) clearTimeout(this._timers[p]), delete this._timers[p];
              for (const p in this._tiles) this._setTileReloadTimer(+p, this._tiles[p]);
            }
          }
          update(t, n, c, p) {
            if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage || this.usedForTerrain && !c) return;
            this.updateCacheSize(t, n), this.transform.projection.name !== "globe" && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
            const v = this._source.type === "batched-model";
            let C, V = this._source.maxzoom;
            const K = this.map && this.map.painter ? this.map.painter._terrain : null;
            if (K && K.sourceCache === this && K.attenuationRange()) {
              const ve = K.attenuationRange()[0], xe = Math.floor(ve) - Math.log2(K.getDemUpscale());
              V > xe && (V = xe);
            }
            if (this.used || this.usedForTerrain) {
              if (this._source.tileID) C = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((ve) => new i.aG(ve.canonical.z, ve.wrap, ve.canonical.z, ve.canonical.x, ve.canonical.y));
              else if (this.tileCoverLift !== 0) {
                const ve = t.clone();
                ve.tileCoverLift = this.tileCoverLift, C = ve.coveringTiles({ tileSize: n || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: V, roundZoom: this._source.roundZoom && !c, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: v }), this._source.minzoom <= 1 && t.projection.name === "globe" && (C.push(new i.aG(1, 0, 1, 0, 0)), C.push(new i.aG(1, 0, 1, 1, 0)), C.push(new i.aG(1, 0, 1, 0, 1)), C.push(new i.aG(1, 0, 1, 1, 1)));
              } else if (C = t.coveringTiles({ tileSize: n || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: V, roundZoom: this._source.roundZoom && !c, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: v }), this._source.hasTile) {
                const ve = this._source.hasTile.bind(this._source);
                C = C.filter((xe) => ve(xe));
              }
            } else C = [];
            if (C.length > 0 && this.castsShadows && p && this.transform.projection.name !== "globe" && !this.usedForTerrain && !es(this._source.type)) {
              const ve = t.coveringZoomLevel({ tileSize: n || this._source.tileSize, roundZoom: this._source.roundZoom && !c }), xe = Math.min(ve, this._source.maxzoom);
              if (v) {
                const Le = t.extendTileCover(C, xe);
                for (const ft of Le) C.push(ft);
              } else {
                const Le = t.extendTileCover(C, xe, p);
                for (const ft of Le) this._shadowCasterTiles[ft.key] = !0, C.push(ft);
              }
            }
            const se = this._updateRetainedTiles(C);
            if (es(this._source.type) && C.length !== 0) {
              const ve = {}, xe = {}, Le = Object.keys(se);
              for (const st of Le) {
                const vt = se[st], gt = this._tiles[st];
                if (!gt || gt.fadeEndTime && gt.fadeEndTime <= i.q.now()) continue;
                const Rt = this.findLoadedParent(vt, Math.max(vt.overscaledZ - fa.maxOverzooming, this._source.minzoom));
                Rt && (this._addTile(Rt.tileID), ve[Rt.tileID.key] = Rt.tileID), xe[st] = vt;
              }
              const ft = C[C.length - 1].overscaledZ;
              for (const st in this._tiles) {
                const vt = this._tiles[st];
                if (se[st] || !vt.hasData()) continue;
                let gt = vt.tileID;
                for (; gt.overscaledZ > ft; ) {
                  gt = gt.scaledTo(gt.overscaledZ - 1);
                  const Rt = this._tiles[gt.key];
                  if (Rt && Rt.hasData() && xe[gt.key]) {
                    se[st] = vt.tileID;
                    break;
                  }
                }
              }
              for (const st in ve) se[st] || (this._coveredTiles[st] = !0, se[st] = ve[st]);
            }
            for (const ve in se) this._tiles[ve].clearFadeHold();
            const oe = i.bk(this._tiles, se);
            for (const ve of oe) {
              const xe = this._tiles[ve];
              xe.hasSymbolBuckets && !xe.holdingForFade() ? xe.setHoldDuration(this.map._fadeDuration) : xe.hasSymbolBuckets && !xe.symbolFadeFinished() || this._removeTile(+ve);
            }
            this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
          }
          releaseSymbolFadeTiles() {
            for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(+t);
          }
          _updateRetainedTiles(t) {
            const n = {};
            if (t.length === 0) return n;
            const c = {}, p = t.reduce((se, oe) => Math.min(se, oe.overscaledZ), 1 / 0), v = t[0].overscaledZ, C = Math.max(v - fa.maxOverzooming, this._source.minzoom), V = Math.max(v + fa.maxUnderzooming, this._source.minzoom), K = {};
            for (const se of t) {
              const oe = this._addTile(se);
              n[se.key] = se, oe.hasData() || p < this._source.maxzoom && (K[se.key] = se);
            }
            this._retainLoadedChildren(K, p, V, n);
            for (const se of t) {
              let oe = this._tiles[se.key];
              if (oe.hasData()) continue;
              if (se.canonical.z >= this._source.maxzoom) {
                const xe = se.children(this._source.maxzoom)[0], Le = this.getTile(xe);
                if (Le && Le.hasData()) {
                  n[xe.key] = xe;
                  continue;
                }
              } else {
                const xe = se.children(this._source.maxzoom);
                if (n[xe[0].key] && n[xe[1].key] && n[xe[2].key] && n[xe[3].key]) continue;
              }
              let ve = oe.wasRequested();
              for (let xe = se.overscaledZ - 1; xe >= C; --xe) {
                const Le = se.scaledTo(xe);
                if (c[Le.key] || (c[Le.key] = !0, oe = this.getTile(Le), !oe && ve && (oe = this._addTile(Le)), oe && (n[Le.key] = Le, ve = oe.wasRequested(), oe.hasData()))) break;
              }
            }
            return n;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const t in this._tiles) {
              const n = [];
              let c, p = this._tiles[t].tileID;
              for (; p.overscaledZ > 0; ) {
                if (p.key in this._loadedParentTiles) {
                  c = this._loadedParentTiles[p.key];
                  break;
                }
                n.push(p.key);
                const v = p.scaledTo(p.overscaledZ - 1);
                if (c = this._getLoadedTile(v), c) break;
                p = v;
              }
              for (const v of n) this._loadedParentTiles[v] = c;
            }
          }
          _addTile(t) {
            let n = this._tiles[t.key];
            if (n) return n.isExtraShadowCaster !== !0 || this._shadowCasterTiles[t.key] || this._reloadTile(t.key, "reloading"), n;
            n = this._cache.getAndRemove(t), n && (this._setTileReloadTimer(t.key, n), n.tileID = t, this._state.initializeTileState(n, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, n)));
            const c = !!n;
            if (!c) {
              const p = this.map ? this.map.painter : null, v = this._source.tileSize * t.overscaleFactor();
              n = this._source.type === "raster-array" ? new tn(t, v, this.transform.tileZoom, p, this._isRaster) : new Ba(t, v, this.transform.tileZoom, p, this._isRaster), this._loadTile(n, this._tileLoaded.bind(this, n, t.key, n.state));
            }
            return n ? (n.uses++, this._tiles[t.key] = n, c || this._source.fire(new i.z("dataloading", { tile: n, coord: n.tileID, dataType: "source" })), n) : null;
          }
          _setTileReloadTimer(t, n) {
            t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
            const c = n.getExpiryTimeout();
            c && (this._timers[t] = setTimeout(() => {
              this._reloadTile(t, "expired"), delete this._timers[t];
            }, c));
          }
          _removeTile(t) {
            const n = this._tiles[t];
            n && (n.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), n.uses > 0 || (n.hasData() && n.state !== "reloading" || n.state === "empty" ? this._cache.add(n.tileID, n, n.getExpiryTimeout()) : (n.aborted = !0, this._abortTile(n), this._unloadTile(n))));
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const t in this._tiles) this._removeTile(+t);
            this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
          }
          tilesIn(t, n, c) {
            const p = [], v = this.transform;
            if (!v) return p;
            const C = v.projection.name === "globe", V = i.at(v.center.lng);
            for (const K in this._tiles) {
              const se = this._tiles[K];
              if (c && se.clearQueryDebugViz(), se.holdingForFade()) continue;
              let oe;
              if (C) {
                const ve = se.tileID.canonical;
                if (ve.z === 0) {
                  const xe = [Math.abs(i.aw(V, ...Tr(ve, -1)) - V), Math.abs(i.aw(V, ...Tr(ve, 1)) - V)];
                  oe = [0, 2 * xe.indexOf(Math.min(...xe)) - 1];
                } else {
                  const xe = [Math.abs(i.aw(V, ...Tr(ve, -1)) - V), Math.abs(i.aw(V, ...Tr(ve, 0)) - V), Math.abs(i.aw(V, ...Tr(ve, 1)) - V)];
                  oe = [xe.indexOf(Math.min(...xe)) - 1];
                }
              } else oe = [0];
              for (const ve of oe) {
                const xe = t.containsTile(se, v, n, ve);
                xe && p.push(xe);
              }
            }
            return p;
          }
          getShadowCasterCoordinates() {
            return this._getRenderableCoordinates(!1, !0);
          }
          getVisibleCoordinates(t) {
            return this._getRenderableCoordinates(t);
          }
          _getRenderableCoordinates(t, n) {
            const c = this.getRenderableIds(t, n).map((v) => this._tiles[v].tileID), p = this.transform.projection.name === "globe";
            for (const v of c) v.projMatrix = this.transform.calculateProjMatrix(v.toUnwrapped()), v.expandedProjMatrix = p ? this.transform.calculateProjMatrix(v.toUnwrapped(), !1, !0) : v.projMatrix;
            return c;
          }
          sortCoordinatesByDistance(t) {
            const n = t.slice(), c = this.transform._camera.position, p = this.transform._camera.forward(), v = {};
            for (const C of n) {
              const V = 1 / (1 << C.canonical.z);
              v[C.key] = ((C.canonical.x + 0.5) * V + C.wrap - c[0]) * p[0] + ((C.canonical.y + 0.5) * V - c[1]) * p[1] - c[2] * p[2];
            }
            return n.sort((C, V) => v[C.key] - v[V.key]), n;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (es(this._source.type)) for (const t in this._tiles) {
              const n = this._tiles[t];
              if (n.fadeEndTime !== void 0 && n.fadeEndTime >= i.q.now()) return !0;
            }
            return !1;
          }
          setFeatureState(t, n, c) {
            this._state.updateState(t = t || "_geojsonTileLayer", n, c);
          }
          removeFeatureState(t, n, c) {
            this._state.removeFeatureState(t = t || "_geojsonTileLayer", n, c);
          }
          getFeatureState(t, n) {
            return this._state.getState(t = t || "_geojsonTileLayer", n);
          }
          setDependencies(t, n, c) {
            const p = this._tiles[t];
            p && p.setDependencies(n, c);
          }
          reloadTilesForDependencies(t, n) {
            for (const c in this._tiles) this._tiles[c].hasDependency(t, n) && this._reloadTile(+c, "reloading");
            this._cache.filter((c) => !c.hasDependency(t, n));
          }
          _preloadTiles(t, n) {
            if (!this._sourceLoaded) {
              const K = () => {
                this._sourceLoaded && (this._source.off("data", K), this._preloadTiles(t, n));
              };
              return void this._source.on("data", K);
            }
            const c = /* @__PURE__ */ new Map(), p = Array.isArray(t) ? t : [t], v = this.map.painter.terrain, C = this.usedForTerrain && v ? v.getScaledDemTileSize() : this._source.tileSize;
            for (const K of p) {
              const se = K.coveringTiles({ tileSize: C, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
              for (const oe of se) c.set(oe.key, oe);
              this.usedForTerrain && K.updateElevation(!1);
            }
            const V = Array.from(c.values());
            i.bl(V, (K, se) => {
              const oe = new Ba(K, this._source.tileSize * K.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
              this._loadTile(oe, (ve) => {
                this._source.type === "raster-dem" && oe.dem && this._backfillDEM(oe), se(ve, oe);
              });
            }, n);
          }
        }
        function Wr(u, t) {
          const n = Math.abs(2 * u.wrap) - +(u.wrap < 0), c = Math.abs(2 * t.wrap) - +(t.wrap < 0);
          return u.overscaledZ - t.overscaledZ || c - n || t.canonical.y - u.canonical.y || t.canonical.x - u.canonical.x;
        }
        function es(u) {
          return u === "raster" || u === "image" || u === "video" || u === "custom";
        }
        function Tr(u, t) {
          const n = 1 << u.z;
          return [u.x / n + t, (u.x + 1) / n + t];
        }
        fa.maxOverzooming = 10, fa.maxUnderzooming = 3;
        class Is {
          constructor(t) {
            this.style = t, this.layersGotHidden = !1, this.layers = [];
          }
          processLayersChanged() {
            this.layers = [];
            const t = !1, n = !1;
            for (const c in this.style._mergedLayers) {
              const p = this.style._mergedLayers[c];
              if (p.type === "fill-extrusion") this.layers.push({ layer: p, visible: t, visibilityChanged: n });
              else if (p.type === "model") {
                const v = this.style.getLayerSource(p);
                v && v.type === "batched-model" && this.layers.push({ layer: p, visible: t, visibilityChanged: n });
              }
            }
          }
          onNewFrame(t) {
            this.layersGotHidden = !1;
            for (const n of this.layers) {
              const c = n.layer;
              let p = !1;
              c.type === "fill-extrusion" ? p = !c.isHidden(t) && c.paint.get("fill-extrusion-opacity") > 0 : c.type === "model" && (p = !c.isHidden(t) && c.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !p && n.visible, n.visible = p;
            }
          }
          updateZOffset(t, n) {
            this.currentBuildingBuckets = [];
            for (const p of this.layers) {
              const v = p.layer, C = this.style.getLayerSourceCache(v);
              let V = 1;
              v.type === "fill-extrusion" && (V = p.visible ? v.paint.get("fill-extrusion-vertical-scale") : 0);
              let K = C ? C.getTile(n) : null;
              if (!K && C && n.canonical.z > C.getSource().minzoom) {
                let se = n.scaledTo(Math.min(C.getSource().maxzoom, n.overscaledZ - 1));
                for (; se.overscaledZ >= C.getSource().minzoom && (K = C.getTile(se), !K && se.overscaledZ !== 0); ) se = se.scaledTo(se.overscaledZ - 1);
              }
              this.currentBuildingBuckets.push({ bucket: K ? K.getBucket(v) : null, tileID: K ? K.tileID : n, verticalScale: V });
            }
            t.hasAnyZOffset = !1;
            let c = !1;
            for (let p = 0; p < t.symbolInstances.length; p++) {
              const v = t.symbolInstances.get(p), C = v.zOffset, V = this._getHeightAtTileOffset(n, v.tileAnchorX, v.tileAnchorY);
              v.zOffset = V !== Number.NEGATIVE_INFINITY ? V : C, c || C === v.zOffset || (c = !0), t.hasAnyZOffset || v.zOffset === 0 || (t.hasAnyZOffset = !0);
            }
            c && (t.zOffsetBuffersNeedUpload = !0, t.zOffsetSortDirty = !0);
          }
          _mapCoordToOverlappingTile(t, n, c, p) {
            let v = n, C = c;
            if (t.canonical.z !== p.canonical.z) {
              const V = p.canonical, K = 1 / (1 << t.canonical.z - V.z);
              v = (n + t.canonical.x * i.ag) * K - V.x * i.ag | 0, C = (c + t.canonical.y * i.ag) * K - V.y * i.ag | 0;
            }
            return { tileX: v, tileY: C };
          }
          _getHeightAtTileOffset(t, n, c) {
            let p, v;
            for (let C = 0; C < this.layers.length; ++C) {
              if (this.layers[C].layer.type !== "fill-extrusion") continue;
              const { bucket: V, tileID: K, verticalScale: se } = this.currentBuildingBuckets[C];
              if (!V) continue;
              const { tileX: oe, tileY: ve } = this._mapCoordToOverlappingTile(t, n, c, K), xe = V.getHeightAtTileCoord(oe, ve);
              xe && xe.height !== void 0 && (xe.hidden ? p = xe.height : v = Math.max(xe.height * se, v || 0));
            }
            if (v !== void 0) return v;
            for (let C = 0; C < this.layers.length; ++C) {
              const V = this.layers[C];
              if (V.layer.type !== "model" || !V.visible) continue;
              const { bucket: K, tileID: se } = this.currentBuildingBuckets[C];
              if (!K) continue;
              const { tileX: oe, tileY: ve } = this._mapCoordToOverlappingTile(t, n, c, se), xe = K.getHeightAtTileCoord(oe, ve);
              if (xe && !xe.hidden) return xe.height === void 0 && p !== void 0 ? Math.min(xe.maxHeight, p) * xe.verticalScale : xe.height ? xe.height * xe.verticalScale : Number.NEGATIVE_INFINITY;
            }
            return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
          }
        }
        function D(u, t) {
          const n = {};
          for (const c in u) c !== "ref" && (n[c] = u[c]);
          return i.bm.forEach((c) => {
            c in t && (n[c] = t[c]);
          }), n;
        }
        function be(u) {
          u = u.slice();
          const t = /* @__PURE__ */ Object.create(null);
          for (let n = 0; n < u.length; n++) t[u[n].id] = u[n];
          for (let n = 0; n < u.length; n++) "ref" in u[n] && (u[n] = D(u[n], t[u[n].ref]));
          return u;
        }
        const ht = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setSnow: "setSnow", setRain: "setRain", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport" };
        function Ot(u, t, n) {
          n.push({ command: ht.addSource, args: [u, t[u]] });
        }
        function hi(u, t, n) {
          t.push({ command: ht.removeSource, args: [u] }), n[u] = !0;
        }
        function di(u, t, n, c) {
          hi(u, n, c), Ot(u, t, n);
        }
        function ki(u, t, n) {
          let c;
          for (c in u[n]) if (u[n].hasOwnProperty(c) && c !== "data" && !i.bn(u[n][c], t[n][c])) return !1;
          for (c in t[n]) if (t[n].hasOwnProperty(c) && c !== "data" && !i.bn(u[n][c], t[n][c])) return !1;
          return !0;
        }
        function er(u, t, n, c, p, v) {
          let C;
          for (C in t = t || {}, u = u || {}) u.hasOwnProperty(C) && (i.bn(u[C], t[C]) || n.push({ command: v, args: [c, C, t[C], p] }));
          for (C in t) t.hasOwnProperty(C) && !u.hasOwnProperty(C) && (i.bn(u[C], t[C]) || n.push({ command: v, args: [c, C, t[C], p] }));
        }
        function _r(u) {
          return u.id;
        }
        function en(u, t) {
          return u[t.id] = t, u;
        }
        class br {
          constructor(t, n) {
            this.reset(t, n);
          }
          reset(t, n) {
            this.points = t || [], this._distances = [0];
            for (let c = 1; c < this.points.length; c++) this._distances[c] = this._distances[c - 1] + this.points[c].dist(this.points[c - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(n || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(t) {
            if (this.points.length === 1) return this.points[0];
            t = i.aw(t, 0, 1);
            let n = 1, c = this._distances[n];
            const p = t * this.paddedLength + this.padding;
            for (; c < p && n < this._distances.length; ) c = this._distances[++n];
            const v = n - 1, C = this._distances[v], V = c - C, K = V > 0 ? (p - C) / V : 0;
            return this.points[v].mult(1 - K).add(this.points[n].mult(K));
          }
        }
        class Gn {
          constructor(t, n, c) {
            const p = this.boxCells = [], v = this.circleCells = [];
            this.xCellCount = Math.ceil(t / c), this.yCellCount = Math.ceil(n / c);
            for (let C = 0; C < this.xCellCount * this.yCellCount; C++) p.push([]), v.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = n, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / n, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(t, n, c, p, v) {
            this._forEachCell(n, c, p, v, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(n), this.bboxes.push(c), this.bboxes.push(p), this.bboxes.push(v);
          }
          insertCircle(t, n, c, p) {
            this._forEachCell(n - p, c - p, n + p, c + p, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(n), this.circles.push(c), this.circles.push(p);
          }
          _insertBoxCell(t, n, c, p, v, C) {
            this.boxCells[v].push(C);
          }
          _insertCircleCell(t, n, c, p, v, C) {
            this.circleCells[v].push(C);
          }
          _query(t, n, c, p, v, C) {
            if (c < 0 || t > this.width || p < 0 || n > this.height) return !v && [];
            const V = [];
            if (t <= 0 && n <= 0 && this.width <= c && this.height <= p) {
              if (v) return !0;
              for (let K = 0; K < this.boxKeys.length; K++) V.push({ key: this.boxKeys[K], x1: this.bboxes[4 * K], y1: this.bboxes[4 * K + 1], x2: this.bboxes[4 * K + 2], y2: this.bboxes[4 * K + 3] });
              for (let K = 0; K < this.circleKeys.length; K++) {
                const se = this.circles[3 * K], oe = this.circles[3 * K + 1], ve = this.circles[3 * K + 2];
                V.push({ key: this.circleKeys[K], x1: se - ve, y1: oe - ve, x2: se + ve, y2: oe + ve });
              }
              return C ? V.filter(C) : V;
            }
            return this._forEachCell(t, n, c, p, this._queryCell, V, { hitTest: v, seenUids: { box: {}, circle: {} } }, C), v ? V.length > 0 : V;
          }
          _queryCircle(t, n, c, p, v) {
            const C = t - c, V = t + c, K = n - c, se = n + c;
            if (V < 0 || C > this.width || se < 0 || K > this.height) return !p && [];
            const oe = [];
            return this._forEachCell(C, K, V, se, this._queryCellCircle, oe, { hitTest: p, circle: { x: t, y: n, radius: c }, seenUids: { box: {}, circle: {} } }, v), p ? oe.length > 0 : oe;
          }
          query(t, n, c, p, v) {
            return this._query(t, n, c, p, !1, v);
          }
          hitTest(t, n, c, p, v) {
            return this._query(t, n, c, p, !0, v);
          }
          hitTestCircle(t, n, c, p) {
            return this._queryCircle(t, n, c, !0, p);
          }
          _queryCell(t, n, c, p, v, C, V, K) {
            const se = V.seenUids, oe = this.boxCells[v];
            if (oe !== null) {
              const xe = this.bboxes;
              for (const Le of oe) if (!se.box[Le]) {
                se.box[Le] = !0;
                const ft = 4 * Le;
                if (t <= xe[ft + 2] && n <= xe[ft + 3] && c >= xe[ft + 0] && p >= xe[ft + 1] && (!K || K(this.boxKeys[Le]))) {
                  if (V.hitTest) return C.push(!0), !0;
                  C.push({ key: this.boxKeys[Le], x1: xe[ft], y1: xe[ft + 1], x2: xe[ft + 2], y2: xe[ft + 3] });
                }
              }
            }
            const ve = this.circleCells[v];
            if (ve !== null) {
              const xe = this.circles;
              for (const Le of ve) if (!se.circle[Le]) {
                se.circle[Le] = !0;
                const ft = 3 * Le;
                if (this._circleAndRectCollide(xe[ft], xe[ft + 1], xe[ft + 2], t, n, c, p) && (!K || K(this.circleKeys[Le]))) {
                  if (V.hitTest) return C.push(!0), !0;
                  {
                    const st = xe[ft], vt = xe[ft + 1], gt = xe[ft + 2];
                    C.push({ key: this.circleKeys[Le], x1: st - gt, y1: vt - gt, x2: st + gt, y2: vt + gt });
                  }
                }
              }
            }
          }
          _queryCellCircle(t, n, c, p, v, C, V, K) {
            const se = V.circle, oe = V.seenUids, ve = this.boxCells[v];
            if (ve !== null) {
              const Le = this.bboxes;
              for (const ft of ve) if (!oe.box[ft]) {
                oe.box[ft] = !0;
                const st = 4 * ft;
                if (this._circleAndRectCollide(se.x, se.y, se.radius, Le[st + 0], Le[st + 1], Le[st + 2], Le[st + 3]) && (!K || K(this.boxKeys[ft]))) return C.push(!0), !0;
              }
            }
            const xe = this.circleCells[v];
            if (xe !== null) {
              const Le = this.circles;
              for (const ft of xe) if (!oe.circle[ft]) {
                oe.circle[ft] = !0;
                const st = 3 * ft;
                if (this._circlesCollide(Le[st], Le[st + 1], Le[st + 2], se.x, se.y, se.radius) && (!K || K(this.circleKeys[ft]))) return C.push(!0), !0;
              }
            }
          }
          _forEachCell(t, n, c, p, v, C, V, K) {
            const se = this._convertToXCellCoord(t), oe = this._convertToYCellCoord(n), ve = this._convertToXCellCoord(c), xe = this._convertToYCellCoord(p);
            for (let Le = se; Le <= ve; Le++) for (let ft = oe; ft <= xe; ft++) if (v.call(this, t, n, c, p, this.xCellCount * ft + Le, C, V, K)) return;
          }
          _convertToXCellCoord(t) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));
          }
          _convertToYCellCoord(t) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));
          }
          _circlesCollide(t, n, c, p, v, C) {
            const V = p - t, K = v - n, se = c + C;
            return se * se > V * V + K * K;
          }
          _circleAndRectCollide(t, n, c, p, v, C, V) {
            const K = (C - p) / 2, se = Math.abs(t - (p + K));
            if (se > K + c) return !1;
            const oe = (V - v) / 2, ve = Math.abs(n - (v + oe));
            if (ve > oe + c) return !1;
            if (se <= K || ve <= oe) return !0;
            const xe = se - K, Le = ve - oe;
            return xe * xe + Le * Le <= c * c;
          }
        }
        const Ia = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, ls = Math.tan(85 * Math.PI / 180);
        function Hn(u, t, n, c, p, v, C) {
          const V = i.ab.mat4.create();
          if (n) if (v.name === "globe") {
            const K = i.bo(p, t);
            i.ab.mat4.multiply(V, V, K);
          } else {
            const K = i.ab.mat2.invert([], C);
            V[0] = K[0], V[1] = K[1], V[4] = K[2], V[5] = K[3], c || i.ab.mat4.rotateZ(V, V, p.angle);
          }
          else i.ab.mat4.multiply(V, p.labelPlaneMatrix, u);
          return V;
        }
        function Dn(u, t, n, c, p, v, C) {
          const V = Hn(u, t, n, c, p, v, C);
          return v.name === "globe" && n || (V[2] = V[6] = V[10] = V[14] = 0), V;
        }
        function xs(u, t, n, c, p, v, C) {
          if (n) {
            if (v.name === "globe") {
              const V = Hn(u, t, n, c, p, v, C);
              return i.ab.mat4.invert(V, V), i.ab.mat4.multiply(V, u, V), V;
            }
            {
              const V = i.ab.mat4.clone(u), K = i.ab.mat4.identity([]);
              return K[0] = C[0], K[1] = C[1], K[4] = C[2], K[5] = C[3], i.ab.mat4.multiply(V, V, K), c || i.ab.mat4.rotateZ(V, V, -p.angle), V;
            }
          }
          return p.glCoordMatrix;
        }
        function va(u, t, n, c) {
          const p = [u, t, n, 1];
          n ? i.ab.vec4.transformMat4(p, p, c) : qn(p, p, c);
          const v = p[3];
          return p[0] /= v, p[1] /= v, p[2] /= v, p;
        }
        function sl(u, t) {
          return Math.min(0.5 + u / t * 0.5, 1.5);
        }
        function Fo(u, t) {
          const n = u[0] / u[3], c = u[1] / u[3];
          return n >= -t[0] && n <= t[0] && c >= -t[1] && c <= t[1];
        }
        function No(u, t, n, c, p, v, C, V, K, se) {
          const oe = n.transform, ve = c ? u.textSizeData : u.iconSizeData, xe = i.bp(ve, n.transform.zoom), Le = oe.projection.name === "globe", ft = [256 / n.width * 2 + 1, 256 / n.height * 2 + 1], st = c ? u.text.dynamicLayoutVertexArray : u.icon.dynamicLayoutVertexArray;
          st.clear();
          let vt = null;
          Le && (vt = c ? u.text.globeExtVertexArray : u.icon.globeExtVertexArray);
          const gt = u.lineVertexArray, Rt = c ? u.text.placedSymbolArray : u.icon.placedSymbolArray, qt = n.transform.width / n.transform.height;
          let jt, ii = !1;
          for (let Xt = 0; Xt < Rt.length; Xt++) {
            const Kt = Rt.get(Xt), { numGlyphs: Zt, writingMode: Jt } = Kt;
            if (Jt !== i.bq.vertical || ii || jt === i.bq.horizontal || (ii = !0), jt = Jt, (Kt.hidden || Jt === i.bq.vertical) && !ii) {
              Nn(Zt, st);
              continue;
            }
            ii = !1;
            const ui = new i.P(Kt.tileAnchorX, Kt.tileAnchorY);
            let { x: Ti, y: xi, z: Pi } = oe.projection.projectTilePoint(ui.x, ui.y, se.canonical);
            if (K) {
              const [Fi, Zi, ir] = K(ui);
              Ti += Fi, xi += Zi, Pi += ir;
            }
            const Ri = [Ti, xi, Pi, 1];
            if (i.ab.vec4.transformMat4(Ri, Ri, t), !Fo(Ri, ft)) {
              Nn(Zt, st);
              continue;
            }
            const mi = Ri[3], Ai = sl(n.transform.getCameraToCenterDistance(oe.projection), mi), ji = i.br(ve, xe, Kt), yi = C ? ji / Ai : ji * Ai, Ni = va(Ti, xi, Pi, p);
            if (Ni[3] <= 0) {
              Nn(Zt, st);
              continue;
            }
            let Mi = {};
            const Yi = C ? null : K, Ui = bs(Kt, yi, !1, V, t, p, v, u.glyphOffsetArray, gt, st, vt, Ni, ui, Mi, qt, Yi, oe.projection, se, C);
            ii = Ui.useVertical, Yi && Ui.needsFlipping && (Mi = {}), (Ui.notEnoughRoom || ii || Ui.needsFlipping && bs(Kt, yi, !0, V, t, p, v, u.glyphOffsetArray, gt, st, vt, Ni, ui, Mi, qt, Yi, oe.projection, se, C).notEnoughRoom) && Nn(Zt, st);
          }
          c ? (u.text.dynamicLayoutVertexBuffer.updateData(st), vt && u.text.globeExtVertexBuffer && u.text.globeExtVertexBuffer.updateData(vt)) : (u.icon.dynamicLayoutVertexBuffer.updateData(st), vt && u.icon.globeExtVertexBuffer && u.icon.globeExtVertexBuffer.updateData(vt));
        }
        function Vs(u, t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st) {
          const { lineStartIndex: vt, glyphStartIndex: gt, segment: Rt } = V, qt = gt + V.numGlyphs, jt = vt + V.lineLength, ii = t.getoffsetX(gt), Xt = t.getoffsetX(qt - 1), Kt = js(u * ii, n, c, p, v, C, Rt, vt, jt, K, se, oe, ve, xe, !0, Le, ft, st);
          if (!Kt) return null;
          const Zt = js(u * Xt, n, c, p, v, C, Rt, vt, jt, K, se, oe, ve, xe, !0, Le, ft, st);
          return Zt ? { first: Kt, last: Zt } : null;
        }
        function Na(u, t, n, c) {
          return u === i.bq.horizontal && Math.abs(c) > Math.abs(n) ? { useVertical: !0 } : u === i.bq.vertical ? c > 0 ? { needsFlipping: !0 } : null : t !== Ia.unknown && function(p, v) {
            return p === 0 || Math.abs(v / p) > ls;
          }(n, c) ? t === Ia.flipRequired ? { needsFlipping: !0 } : null : n < 0 ? { needsFlipping: !0 } : null;
        }
        function bs(u, t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st, vt, gt, Rt) {
          const qt = t / 24, jt = u.lineOffsetX * qt, ii = u.lineOffsetY * qt, { lineStartIndex: Xt, glyphStartIndex: Kt, numGlyphs: Zt, segment: Jt, writingMode: ui, flipState: Ti } = u, xi = Xt + u.lineLength, Pi = (Ri) => {
            if (oe) {
              const [yi, Ni, Mi] = Ri.up, Yi = se.length;
              i.bs(oe, Yi + 0, yi, Ni, Mi), i.bs(oe, Yi + 1, yi, Ni, Mi), i.bs(oe, Yi + 2, yi, Ni, Mi), i.bs(oe, Yi + 3, yi, Ni, Mi);
            }
            const [mi, Ai, ji] = Ri.point;
            i.bt(se, mi, Ai, ji, Ri.angle);
          };
          if (Zt > 1) {
            const Ri = Vs(qt, V, jt, ii, n, ve, xe, u, K, v, Le, st, !1, vt, gt, Rt);
            if (!Ri) return { notEnoughRoom: !0 };
            if (c && !n) {
              let [mi, Ai, ji] = Ri.first.point, [yi, Ni, Mi] = Ri.last.point;
              [mi, Ai] = va(mi, Ai, ji, C), [yi, Ni] = va(yi, Ni, Mi, C);
              const Yi = Na(ui, Ti, (yi - mi) * ft, Ni - Ai);
              if (u.flipState = Yi && Yi.needsFlipping ? Ia.flipRequired : Ia.flipNotRequired, Yi) return Yi;
            }
            Pi(Ri.first);
            for (let mi = Kt + 1; mi < Kt + Zt - 1; mi++) {
              const Ai = js(qt * V.getoffsetX(mi), jt, ii, n, ve, xe, Jt, Xt, xi, K, v, Le, st, !1, !1, vt, gt, Rt);
              if (!Ai) return se.length -= 4 * (mi - Kt), { notEnoughRoom: !0 };
              Pi(Ai);
            }
            Pi(Ri.last);
          } else {
            if (c && !n) {
              const mi = va(xe.x, xe.y, 0, p), Ai = Xt + Jt + 1, ji = new i.P(K.getx(Ai), K.gety(Ai)), yi = va(ji.x, ji.y, 0, p), Ni = yi[3] > 0 ? yi : ol(xe, ji, mi, 1, p, void 0, vt, gt.canonical), Mi = Na(ui, Ti, (Ni[0] - mi[0]) * ft, Ni[1] - mi[1]);
              if (u.flipState = Mi && Mi.needsFlipping ? Ia.flipRequired : Ia.flipNotRequired, Mi) return Mi;
            }
            const Ri = js(qt * V.getoffsetX(Kt), jt, ii, n, ve, xe, Jt, Xt, xi, K, v, Le, st, !1, !1, vt, gt, Rt);
            if (!Ri) return { notEnoughRoom: !0 };
            Pi(Ri);
          }
          return {};
        }
        function Ua(u, t, n, c, p) {
          const { x: v, y: C, z: V } = c.projectTilePoint(u.x, u.y, t);
          if (!p) return va(v, C, V, n);
          const [K, se, oe] = p(u);
          return va(v + K, C + se, V + oe, n);
        }
        function ol(u, t, n, c, p, v, C, V) {
          const K = Ua(u.sub(t)._unit()._add(u), V, p, C, v);
          return i.ab.vec3.sub(K, n, K), i.ab.vec3.normalize(K, K), i.ab.vec3.scaleAndAdd(K, n, K, c);
        }
        function js(u, t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st, vt, gt) {
          const Rt = c ? u - t : u + t;
          let qt = Rt > 0 ? 1 : -1, jt = 0;
          c && (qt *= -1, jt = Math.PI), qt < 0 && (jt += Math.PI);
          let ii = V + C + (qt > 0 ? 0 : 1) | 0, Xt = p, Kt = p, Zt = 0, Jt = 0;
          const ui = Math.abs(Rt), Ti = [], xi = [];
          let Pi = v, Ri = Pi;
          const mi = () => ol(Ri, Pi, Kt, ui - Zt + 1, oe, xe, st, vt.canonical);
          for (; Zt + Jt <= ui; ) {
            if (ii += qt, ii < V || ii >= K) return null;
            if (Kt = Xt, Ri = Pi, Ti.push(Kt), Le && xi.push(Ri), Pi = new i.P(se.getx(ii), se.gety(ii)), Xt = ve[ii], !Xt) {
              const Zi = Ua(Pi, vt.canonical, oe, st, xe);
              Xt = Zi[3] > 0 ? ve[ii] = Zi : mi();
            }
            Zt += Jt, Jt = i.ab.vec3.distance(Kt, Xt);
          }
          ft && xe && (ve[ii] && (Xt = mi(), Jt = i.ab.vec3.distance(Kt, Xt)), ve[ii] = Xt);
          const Ai = (ui - Zt) / Jt, ji = Pi.sub(Ri)._mult(Ai)._add(Ri), yi = i.ab.vec3.sub([], Xt, Kt), Ni = i.ab.vec3.scaleAndAdd([], Kt, yi, Ai);
          let Mi = [0, 0, 1], Yi = yi[0], Ui = yi[1];
          if (gt && (Mi = st.upVector(vt.canonical, ji.x, ji.y), Mi[0] !== 0 || Mi[1] !== 0 || Mi[2] !== 1)) {
            const Zi = [Mi[2], 0, -Mi[0]], ir = i.ab.vec3.cross([], Mi, Zi);
            i.ab.vec3.normalize(Zi, Zi), i.ab.vec3.normalize(ir, ir), Yi = i.ab.vec3.dot(yi, Zi), Ui = i.ab.vec3.dot(yi, ir);
          }
          if (n) {
            const Zi = i.ab.vec3.cross([], Mi, yi);
            i.ab.vec3.normalize(Zi, Zi), i.ab.vec3.scaleAndAdd(Ni, Ni, Zi, n * qt);
          }
          const Fi = jt + Math.atan2(Ui, Yi);
          return Ti.push(Ni), Le && xi.push(ji), { point: Ni, angle: Fi, path: Ti, tilePath: xi, up: Mi };
        }
        function Nn(u, t) {
          const n = t.length, c = n + 4 * u;
          t.resize(c), t.float32.fill(-1 / 0, 4 * n, 4 * c);
        }
        function qn(u, t, n) {
          const c = t[0], p = t[1];
          return u[0] = n[0] * c + n[4] * p + n[12], u[1] = n[1] * c + n[5] * p + n[13], u[3] = n[3] * c + n[7] * p + n[15], u;
        }
        const ta = 100;
        class ia {
          constructor(t, n, c = new Gn(t.width + 200, t.height + 200, 25), p = new Gn(t.width + 200, t.height + 200, 25)) {
            this.transform = t, this.grid = c, this.ignoredGrid = p, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + ta, this.screenBottomBoundary = t.height + ta, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.fogState = n;
          }
          placeCollisionBox(t, n, c, p, v, C, V, K) {
            let se = c.projectedAnchorX, oe = c.projectedAnchorY, ve = c.projectedAnchorZ;
            const xe = c.elevation, Le = c.tileID, ft = t.getProjection();
            if (xe && Le) {
              const [Xt, Kt, Zt] = ft.upVector(Le.canonical, c.tileAnchorX, c.tileAnchorY), Jt = ft.upVectorScale(Le.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
              se += Xt * xe * Jt, oe += Kt * xe * Jt, ve += Zt * xe * Jt;
            }
            const st = this.projectAndGetPerspectiveRatio(V, se, oe, ve, c.tileID, ft.name === "globe" || !!xe || this.transform.pitch > 0, ft), vt = C * st.perspectiveRatio, gt = (c.x1 * n + p.x - c.padding) * vt + st.point.x, Rt = (c.y1 * n + p.y - c.padding) * vt + st.point.y, qt = (c.x2 * n + p.x + c.padding) * vt + st.point.x, jt = (c.y2 * n + p.y + c.padding) * vt + st.point.y, ii = st.perspectiveRatio <= 0.55 || st.occluded;
            return !this.isInsideGrid(gt, Rt, qt, jt) || !v && this.grid.hitTest(gt, Rt, qt, jt, K) || ii ? { box: [], offscreen: !1, occluded: st.occluded } : { box: [gt, Rt, qt, jt], offscreen: this.isOffscreen(gt, Rt, qt, jt), occluded: !1 };
          }
          placeCollisionCircles(t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st) {
            const vt = [], gt = this.transform.elevation, Rt = t.getProjection(), qt = gt ? gt.getAtTileOffsetFunc(st, this.transform.center.lat, this.transform.worldSize, Rt) : null, jt = new i.P(c.tileAnchorX, c.tileAnchorY);
            let { x: ii, y: Xt, z: Kt } = Rt.projectTilePoint(jt.x, jt.y, st.canonical);
            if (qt) {
              const [ji, yi, Ni] = qt(jt);
              ii += ji, Xt += yi, Kt += Ni;
            }
            const Zt = Rt.name === "globe", Jt = this.projectAndGetPerspectiveRatio(V, ii, Xt, Kt, st, Zt || !!gt || this.transform.pitch > 0, Rt), { perspectiveRatio: ui } = Jt, Ti = (ve ? C / ui : C * ui) / i.bw, xi = va(ii, Xt, Kt, K), Pi = Jt.signedDistanceFromCamera > 0 ? Vs(Ti, v, c.lineOffsetX * Ti, c.lineOffsetY * Ti, !1, xi, jt, c, p, K, {}, gt && !ve ? qt : null, ve && !!gt, Rt, st, ve) : null;
            let Ri = !1, mi = !1, Ai = !0;
            if (Pi && !Jt.occluded) {
              const ji = 0.5 * Le * ui + ft, yi = new i.P(-100, -100), Ni = new i.P(this.screenRightBoundary, this.screenBottomBoundary), Mi = new br(), { first: Yi, last: Ui } = Pi, Fi = Yi.path.length;
              let Zi = [];
              for (let fr = Fi - 1; fr >= 1; fr--) Zi.push(Yi.path[fr]);
              for (let fr = 1; fr < Ui.path.length; fr++) Zi.push(Ui.path[fr]);
              const ir = 2.5 * ji;
              se && (Zi = Zi.map(([fr, Or, Er], Ar) => (qt && !Zt && (Er = qt(Ar < Fi - 1 ? Yi.tilePath[Fi - 1 - Ar] : Ui.tilePath[Ar - Fi + 2])[2]), va(fr, Or, Er, se))), Zi.some((fr) => fr[3] <= 0) && (Zi = []));
              let cr = [];
              if (Zi.length > 0) {
                let fr = 1 / 0, Or = -1 / 0, Er = 1 / 0, Ar = -1 / 0;
                for (const Fr of Zi) fr = Math.min(fr, Fr[0]), Er = Math.min(Er, Fr[1]), Or = Math.max(Or, Fr[0]), Ar = Math.max(Ar, Fr[1]);
                Or >= yi.x && fr <= Ni.x && Ar >= yi.y && Er <= Ni.y && (cr = [Zi.map((Fr) => new i.P(Fr[0], Fr[1]))], (fr < yi.x || Or > Ni.x || Er < yi.y || Ar > Ni.y) && (cr = i.bu(cr, yi.x, yi.y, Ni.x, Ni.y)));
              }
              for (const fr of cr) {
                Mi.reset(fr, 0.25 * ji);
                let Or = 0;
                Or = Mi.length <= 0.5 * ji ? 1 : Math.ceil(Mi.paddedLength / ir) + 1;
                for (let Er = 0; Er < Or; Er++) {
                  const Ar = Er / Math.max(Or - 1, 1), Fr = Mi.lerp(Ar), an = Fr.x + ta, yn = Fr.y + ta;
                  vt.push(an, yn, ji, 0);
                  const $n = an - ji, fn = yn - ji, Nr = an + ji, Jr = yn + ji;
                  if (Ai = Ai && this.isOffscreen($n, fn, Nr, Jr), mi = mi || this.isInsideGrid($n, fn, Nr, Jr), !n && this.grid.hitTestCircle(an, yn, ji, xe) && (Ri = !0, !oe)) return { circles: [], offscreen: !1, collisionDetected: Ri, occluded: !1 };
                }
              }
            }
            return { circles: !oe && Ri || !mi ? [] : vt, offscreen: Ai, collisionDetected: Ri, occluded: Jt.occluded };
          }
          queryRenderedSymbols(t) {
            if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const n = [];
            let c = 1 / 0, p = 1 / 0, v = -1 / 0, C = -1 / 0;
            for (const oe of t) {
              const ve = new i.P(oe.x + ta, oe.y + ta);
              c = Math.min(c, ve.x), p = Math.min(p, ve.y), v = Math.max(v, ve.x), C = Math.max(C, ve.y), n.push(ve);
            }
            const V = this.grid.query(c, p, v, C).concat(this.ignoredGrid.query(c, p, v, C)), K = {}, se = {};
            for (const oe of V) {
              const ve = oe.key;
              if (K[ve.bucketInstanceId] === void 0 && (K[ve.bucketInstanceId] = {}), K[ve.bucketInstanceId][ve.featureIndex]) continue;
              const xe = [new i.P(oe.x1, oe.y1), new i.P(oe.x2, oe.y1), new i.P(oe.x2, oe.y2), new i.P(oe.x1, oe.y2)];
              i.bv(n, xe) && (K[ve.bucketInstanceId][ve.featureIndex] = !0, se[ve.bucketInstanceId] === void 0 && (se[ve.bucketInstanceId] = []), se[ve.bucketInstanceId].push(ve.featureIndex));
            }
            return se;
          }
          insertCollisionBox(t, n, c, p, v) {
            (n ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: c, featureIndex: p, collisionGroupID: v }, t[0], t[1], t[2], t[3]);
          }
          insertCollisionCircles(t, n, c, p, v) {
            const C = n ? this.ignoredGrid : this.grid, V = { bucketInstanceId: c, featureIndex: p, collisionGroupID: v };
            for (let K = 0; K < t.length; K += 4) C.insertCircle(V, t[K], t[K + 1], t[K + 2]);
          }
          projectAndGetPerspectiveRatio(t, n, c, p, v, C, V) {
            const K = [n, c, p, 1];
            let se = !1;
            p || this.transform.pitch > 0 ? (i.ab.vec4.transformMat4(K, K, t), this.fogState && v && V.name !== "globe" && (se = function(xe, Le, ft, st, vt, gt) {
              const Rt = gt.calculateFogTileMatrix(vt), qt = [Le, ft, st];
              return i.ab.vec3.transformMat4(qt, qt, Rt), Ut(xe, i.ab.vec3.length(qt), gt.pitch, gt._fov);
            }(this.fogState, n, c, p, v.toUnwrapped(), this.transform) > 0.9)) : qn(K, K, t);
            const oe = K[3];
            return { point: new i.P((K[0] / oe + 1) / 2 * this.transform.width + ta, (-K[1] / oe + 1) / 2 * this.transform.height + ta), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(V) / oe * 0.5, 1.5), signedDistanceFromCamera: oe, occluded: C && K[2] > oe || se };
          }
          isOffscreen(t, n, c, p) {
            return c < ta || t >= this.screenRightBoundary || p < ta || n > this.screenBottomBoundary;
          }
          isInsideGrid(t, n, c, p) {
            return c >= 0 && t < this.gridRightBoundary && p >= 0 && n < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const t = i.ab.mat4.identity([]);
            return i.ab.mat4.translate(t, t, [-100, -100, 0]), t;
          }
        }
        function ps(u, t, n) {
          const c = t.createTileMatrix(u, u.worldSize, n.toUnwrapped());
          return i.ab.mat4.multiply(new Float32Array(16), u.projMatrix, c);
        }
        function Gs(u, t, n) {
          if (t.projection.name === n.projection.name) return u.projMatrix;
          const c = n.clone();
          return c.setProjection(t.projection), ps(c, t.getProjection(), u);
        }
        function aa(u, t, n) {
          return t.name === n.projection.name ? u.projMatrix : ps(n, t, u);
        }
        class ll {
          constructor(t, n, c, p) {
            this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? n : -n))) : p && c ? 1 : 0, this.placed = c;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class ts {
          constructor(t, n, c, p, v, C = !1) {
            this.text = new ll(t ? t.text : null, n, c, v), this.icon = new ll(t ? t.icon : null, n, p, v), this.clipped = C;
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class to {
          constructor(t, n, c, p = !1) {
            this.text = t, this.icon = n, this.skipFade = c, this.clipped = p;
          }
        }
        class _o {
          constructor() {
            this.invProjMatrix = i.ab.mat4.create(), this.viewportMatrix = i.ab.mat4.create(), this.circles = [];
          }
        }
        class Yh {
          constructor(t, n, c, p, v) {
            this.bucketInstanceId = t, this.featureIndex = n, this.sourceLayerIndex = c, this.bucketIndex = p, this.tileID = v;
          }
        }
        class Mc {
          constructor(t) {
            this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(t) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[t]) {
              const n = ++this.maxGroupID;
              this.collisionGroups[t] = { ID: n, predicate: (c) => c.collisionGroupID === n };
            }
            return this.collisionGroups[t];
          }
        }
        function ms(u, t, n, c, p) {
          const { horizontalAlign: v, verticalAlign: C } = i.bD(u), V = -(v - 0.5) * t, K = -(C - 0.5) * n, se = i.bC(u, c);
          return new i.P(V + se[0] * p, K + se[1] * p);
        }
        function au(u, t, n, c, p) {
          const v = new i.P(u, t);
          return n && v._rotate(c ? p : -p), v;
        }
        class Zu {
          constructor(t, n, c, p, v, C) {
            this.transform = t.clone(), this.projection = t.projection.name, this.collisionIndex = new ia(this.transform, v), this.buildingIndex = C, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = n, this.retainedQueryData = {}, this.collisionGroups = new Mc(c), this.collisionCircleArrays = {}, this.prevPlacement = p, p && (p.prevPlacement = void 0), this.placedOrientations = {};
          }
          getBucketParts(t, n, c, p, v = 1) {
            const C = c.getBucket(n), V = c.latestFeatureIndex;
            if (!C || !V || n.fqid !== C.layerIds[0]) return;
            const K = C.layers[0].layout, se = C.layers[0].paint, oe = c.collisionBoxArray, ve = Math.pow(2, this.transform.zoom - c.tileID.overscaledZ), xe = c.tileSize / i.ag, Le = c.tileID.toUnwrapped();
            this.transform.setProjection(C.projection);
            const ft = (st = c.tileID, vt = C.getProjection(), gt = this.transform, vt.name === this.projection ? gt.calculateProjMatrix(st.toUnwrapped()) : ps(gt, vt, st));
            var st, vt, gt;
            const Rt = K.get("text-pitch-alignment") === "map", qt = K.get("text-rotation-alignment") === "map";
            n.compileFilter(n.options);
            const jt = n.dynamicFilter(), ii = n.dynamicFilterNeedsFeature(), Xt = this.transform.calculatePixelsToTileUnitsMatrix(c), Kt = Dn(ft, c.tileID.canonical, Rt, qt, this.transform, C.getProjection(), Xt);
            let Zt = null;
            if (Rt) {
              const ji = xs(ft, c.tileID.canonical, Rt, qt, this.transform, C.getProjection(), Xt);
              Zt = i.ab.mat4.multiply([], this.transform.labelPlaneMatrix, ji);
            }
            let Jt = null;
            jt && c.latestFeatureIndex && (Jt = { unwrappedTileID: Le, dynamicFilter: jt, dynamicFilterNeedsFeature: ii }), this.retainedQueryData[C.bucketInstanceId] = new Yh(C.bucketInstanceId, V, C.sourceLayerIndex, C.index, c.tileID);
            const [ui, Ti] = C.layers[0].layout.get("text-size-scale-range"), xi = i.aw(v, ui, Ti), [Pi, Ri] = K.get("icon-size-scale-range"), mi = i.aw(v, Pi, Ri), Ai = { bucket: C, layout: K, paint: se, posMatrix: ft, textLabelPlaneMatrix: Kt, labelToScreenMatrix: Zt, clippingData: Jt, scale: ve, textPixelRatio: xe, holdingForFade: c.holdingForFade(), collisionBoxArray: oe, partiallyEvaluatedTextSize: i.bp(C.textSizeData, this.transform.zoom, xi), partiallyEvaluatedIconSize: i.bp(C.iconSizeData, this.transform.zoom, mi), collisionGroup: this.collisionGroups.get(C.sourceID), latestFeatureIndex: c.latestFeatureIndex };
            if (p) for (const ji of C.sortKeyRanges) {
              const { sortKey: yi, symbolInstanceStart: Ni, symbolInstanceEnd: Mi } = ji;
              t.push({ sortKey: yi, symbolInstanceStart: Ni, symbolInstanceEnd: Mi, parameters: Ai });
            }
            else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: C.symbolInstances.length, parameters: Ai });
          }
          attemptAnchorPlacement(t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st, vt, gt, Rt) {
            const { textOffset0: qt, textOffset1: jt, crossTileID: ii } = xe, Xt = [qt, jt], Kt = ms(t, c, p, Xt, v), Zt = this.collisionIndex.placeCollisionBox(ft, v, n, au(Kt.x, Kt.y, C, V, this.transform.angle), ve, K, se, oe.predicate);
            if (vt) {
              const Jt = ft.getSymbolInstanceIconSize(Rt, this.transform.zoom, xe.placedIconSymbolIndex);
              if (this.collisionIndex.placeCollisionBox(ft, Jt, vt, au(Kt.x, Kt.y, C, V, this.transform.angle), ve, K, se, oe.predicate).box.length === 0) return;
            }
            if (Zt.box.length > 0) {
              let Jt;
              return this.prevPlacement && this.prevPlacement.variableOffsets[ii] && this.prevPlacement.placements[ii] && this.prevPlacement.placements[ii].text && (Jt = this.prevPlacement.variableOffsets[ii].anchor), this.variableOffsets[ii] = { textOffset: Xt, width: c, height: p, anchor: t, textScale: v, prevAnchor: Jt }, this.markUsedJustification(ft, t, xe, st), ft.allowVerticalPlacement && (this.markUsedOrientation(ft, st, xe), this.placedOrientations[ii] = st), { shift: Kt, placedGlyphBoxes: Zt };
            }
          }
          placeLayerBucketPart(t, n, c, p, v = 1) {
            const { bucket: C, layout: V, paint: K, posMatrix: se, textLabelPlaneMatrix: oe, labelToScreenMatrix: ve, clippingData: xe, textPixelRatio: Le, holdingForFade: ft, collisionBoxArray: st, partiallyEvaluatedTextSize: vt, partiallyEvaluatedIconSize: gt, collisionGroup: Rt, latestFeatureIndex: qt } = t.parameters, jt = V.get("text-optional"), ii = V.get("icon-optional"), Xt = V.get("text-allow-overlap"), Kt = V.get("icon-allow-overlap"), Zt = V.get("text-rotation-alignment") === "map", Jt = V.get("text-pitch-alignment") === "map", ui = V.get("symbol-z-elevate"), Ti = K.get("symbol-z-offset"), xi = V.get("symbol-elevation-reference") === "sea", [Pi, Ri] = V.get("text-size-scale-range"), [mi, Ai] = V.get("icon-size-scale-range"), ji = i.aw(v, Pi, Ri), yi = i.aw(v, mi, Ai);
            this.transform.setProjection(C.projection);
            let Ni = Xt && (Kt || !C.hasIconData() || ii), Mi = Kt && (Xt || !C.hasTextData() || jt);
            const Yi = !Ti.isConstant();
            !C.collisionArrays && st && C.deserializeCollisionBoxes(st), c && p && C.updateCollisionDebugBuffers(this.transform.zoom, st, ji, yi);
            const Ui = (Fi, Zi, ir) => {
              const { crossTileID: cr, numVerticalGlyphVertices: fr } = Fi;
              let Or = null;
              if (xe && xe.dynamicFilterNeedsFeature || Yi) {
                const Rn = this.retainedQueryData[C.bucketInstanceId];
                Or = qt.loadFeature({ featureIndex: Fi.featureIndex, bucketIndex: Rn.bucketIndex, sourceLayerIndex: Rn.sourceLayerIndex, layoutVertexArrayOffset: 0 });
              }
              if (xe && !(0, xe.dynamicFilter)({ zoom: this.transform.zoom, pitch: this.transform.pitch }, Or, this.retainedQueryData[C.bucketInstanceId].tileID.canonical, new i.P(Fi.tileAnchorX, Fi.tileAnchorY), this.transform.calculateDistanceTileData(xe.unwrappedTileID))) return this.placements[cr] = new to(!1, !1, !1, !0), void n.add(cr);
              const Er = Ti.evaluate(Or, {});
              if (n.has(cr)) return;
              if (ft) return void (this.placements[cr] = new to(!1, !1, !1));
              let Ar = !1, Fr = !1, an = !0, yn = !1, $n = !1, fn = null, Nr = { box: null, offscreen: null, occluded: null }, Jr = { box: null, offscreen: null, occluded: null }, mr = null, nn = null, pn = null, gn = 0, na = 0, ua = 0;
              ir.textFeatureIndex ? gn = ir.textFeatureIndex : Fi.useRuntimeCollisionCircles && (gn = Fi.featureIndex), ir.verticalTextFeatureIndex && (na = ir.verticalTextFeatureIndex);
              const Ra = (Rn) => {
                Rn.tileID = this.retainedQueryData[C.bucketInstanceId].tileID;
                const Cn = this.transform.elevation;
                Rn.elevation = xi ? Er : Er + (Cn ? Cn.getAtTileOffset(Rn.tileID, Rn.tileAnchorX, Rn.tileAnchorY) : 0), Rn.elevation += Fi.zOffset;
              }, Aa = ir.textBox;
              if (Aa) {
                Ra(Aa);
                const Rn = (ln) => {
                  let ca = i.bq.horizontal;
                  if (C.allowVerticalPlacement && !ln && this.prevPlacement) {
                    const Ha = this.prevPlacement.placedOrientations[cr];
                    Ha && (this.placedOrientations[cr] = Ha, ca = Ha, this.markUsedOrientation(C, ca, Fi));
                  }
                  return ca;
                }, Cn = (ln, ca) => {
                  if (C.allowVerticalPlacement && fr > 0 && ir.verticalTextBox) {
                    for (const Ha of C.writingModes) if (Ha === i.bq.vertical ? (Nr = ca(), Jr = Nr) : Nr = ln(), Nr && Nr.box && Nr.box.length) break;
                  } else Nr = ln();
                };
                if (V.get("text-variable-anchor")) {
                  let ln = V.get("text-variable-anchor");
                  if (this.prevPlacement && this.prevPlacement.variableOffsets[cr]) {
                    const kn = this.prevPlacement.variableOffsets[cr];
                    ln.indexOf(kn.anchor) > 0 && (ln = ln.filter((fs) => fs !== kn.anchor), ln.unshift(kn.anchor));
                  }
                  const ca = (kn, fs, fo) => {
                    const Ka = C.getSymbolInstanceTextSize(vt, Fi, this.transform.zoom, Zi), Bs = (kn.x2 - kn.x1) * Ka + 2 * kn.padding, Fs = (kn.y2 - kn.y1) * Ka + 2 * kn.padding, po = Fi.hasIconTextFit && !Kt ? fs : null;
                    po && Ra(po);
                    let Bn = { box: [], offscreen: !1, occluded: !1 };
                    const Bu = Xt ? 2 * ln.length : ln.length;
                    for (let Oo = 0; Oo < Bu; ++Oo) {
                      const Fu = this.attemptAnchorPlacement(ln[Oo % ln.length], kn, Bs, Fs, Ka, Zt, Jt, Le, se, Rt, Oo >= ln.length, Fi, Zi, C, fo, po, vt, gt);
                      if (Fu && (Bn = Fu.placedGlyphBoxes, Bn && Bn.box && Bn.box.length)) {
                        Ar = !0, fn = Fu.shift;
                        break;
                      }
                    }
                    return Bn;
                  };
                  Cn(() => ca(Aa, ir.iconBox, i.bq.horizontal), () => {
                    const kn = ir.verticalTextBox;
                    return kn && Ra(kn), C.allowVerticalPlacement && !(Nr && Nr.box && Nr.box.length) && fr > 0 && kn ? ca(kn, ir.verticalIconBox, i.bq.vertical) : { box: null, offscreen: null, occluded: null };
                  }), Nr && (Ar = Nr.box, an = Nr.offscreen, yn = Nr.occluded);
                  const Ha = Rn(!(!Nr || !Nr.box));
                  if (!Ar && this.prevPlacement) {
                    const kn = this.prevPlacement.variableOffsets[cr];
                    kn && (this.variableOffsets[cr] = kn, this.markUsedJustification(C, kn.anchor, Fi, Ha));
                  }
                } else {
                  const ln = (ca, Ha) => {
                    const kn = C.getSymbolInstanceTextSize(vt, Fi, this.transform.zoom, Zi, v), fs = this.collisionIndex.placeCollisionBox(C, kn, ca, new i.P(0, 0), Xt, Le, se, Rt.predicate);
                    return fs && fs.box && fs.box.length && (this.markUsedOrientation(C, Ha, Fi), this.placedOrientations[cr] = Ha), fs;
                  };
                  Cn(() => ln(Aa, i.bq.horizontal), () => {
                    const ca = ir.verticalTextBox;
                    return C.allowVerticalPlacement && fr > 0 && ca ? (Ra(ca), ln(ca, i.bq.vertical)) : { box: null, offscreen: null, occluded: null };
                  }), Rn(!!(Nr && Nr.box && Nr.box.length));
                }
              }
              if (mr = Nr, Ar = mr && mr.box && mr.box.length > 0, an = mr && mr.offscreen, yn = mr && mr.occluded, Fi.useRuntimeCollisionCircles) {
                const Rn = C.text.placedSymbolArray.get(Fi.centerJustifiedTextSymbolIndex >= 0 ? Fi.centerJustifiedTextSymbolIndex : Fi.verticalPlacedTextSymbolIndex), Cn = i.br(C.textSizeData, vt, Rn), ln = V.get("text-padding");
                nn = this.collisionIndex.placeCollisionCircles(C, Xt, Rn, C.lineVertexArray, C.glyphOffsetArray, Cn, se, oe, ve, c, Jt, Rt.predicate, Fi.collisionCircleDiameter * Cn / i.bw, ln, this.retainedQueryData[C.bucketInstanceId].tileID), Ar = Xt || nn.circles.length > 0 && !nn.collisionDetected, an = an && nn.offscreen, yn = nn.occluded;
              }
              if (ir.iconFeatureIndex && (ua = ir.iconFeatureIndex), ir.iconBox) {
                const Rn = (Cn) => {
                  Ra(Cn);
                  const ln = Fi.hasIconTextFit && fn ? au(fn.x, fn.y, Zt, Jt, this.transform.angle) : new i.P(0, 0), ca = C.getSymbolInstanceIconSize(gt, this.transform.zoom, Fi.placedIconSymbolIndex);
                  return this.collisionIndex.placeCollisionBox(C, ca, Cn, ln, Kt, Le, se, Rt.predicate);
                };
                Jr && Jr.box && Jr.box.length && ir.verticalIconBox ? (pn = Rn(ir.verticalIconBox), Fr = pn.box.length > 0) : (pn = Rn(ir.iconBox), Fr = pn.box.length > 0), an = an && pn.offscreen, $n = pn.occluded;
              }
              const ns = jt || Fi.numHorizontalGlyphVertices === 0 && fr === 0, as = ii || Fi.numIconVertices === 0;
              if (ns || as ? as ? ns || (Fr = Fr && Ar) : Ar = Fr && Ar : Fr = Ar = Fr && Ar, Ar && mr && mr.box && this.collisionIndex.insertCollisionBox(mr.box, V.get("text-ignore-placement"), C.bucketInstanceId, Jr && Jr.box && na ? na : gn, Rt.ID), Fr && pn && this.collisionIndex.insertCollisionBox(pn.box, V.get("icon-ignore-placement"), C.bucketInstanceId, ua, Rt.ID), nn && (Ar && this.collisionIndex.insertCollisionCircles(nn.circles, V.get("text-ignore-placement"), C.bucketInstanceId, gn, Rt.ID), c)) {
                const Rn = C.bucketInstanceId;
                let Cn = this.collisionCircleArrays[Rn];
                Cn === void 0 && (Cn = this.collisionCircleArrays[Rn] = new _o());
                for (let ln = 0; ln < nn.circles.length; ln += 4) Cn.circles.push(nn.circles[ln + 0]), Cn.circles.push(nn.circles[ln + 1]), Cn.circles.push(nn.circles[ln + 2]), Cn.circles.push(nn.collisionDetected ? 1 : 0);
              }
              const On = C.projection.name !== "globe";
              Ni = Ni && (On || !yn), Mi = Mi && (On || !$n), this.placements[cr] = new to(Ar || Ni, Fr || Mi, an || C.justReloaded), n.add(cr);
            };
            if (ui && this.buildingIndex && (this.buildingIndex.updateZOffset(C, this.retainedQueryData[C.bucketInstanceId].tileID), C.updateZOffset()), C.sortFeaturesByY) {
              const Fi = C.getSortedSymbolIndexes(this.transform.angle);
              for (let Zi = Fi.length - 1; Zi >= 0; --Zi) {
                const ir = Fi[Zi];
                Ui(C.symbolInstances.get(ir), ir, C.collisionArrays[ir]);
              }
              C.hasAnyZOffset && i.w(`${C.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
            } else if (C.hasAnyZOffset) {
              const Fi = C.getSortedIndexesByZOffset();
              for (let Zi = 0; Zi < Fi.length; ++Zi) {
                const ir = Fi[Zi];
                Ui(C.symbolInstances.get(ir), ir, C.collisionArrays[ir]);
              }
            } else for (let Fi = t.symbolInstanceStart; Fi < t.symbolInstanceEnd; Fi++) Ui(C.symbolInstances.get(Fi), Fi, C.collisionArrays[Fi]);
            if (c && C.bucketInstanceId in this.collisionCircleArrays) {
              const Fi = this.collisionCircleArrays[C.bucketInstanceId];
              i.ab.mat4.invert(Fi.invProjMatrix, se), Fi.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            C.justReloaded = !1;
          }
          markUsedJustification(t, n, c, p) {
            const { leftJustifiedTextSymbolIndex: v, centerJustifiedTextSymbolIndex: C, rightJustifiedTextSymbolIndex: V, verticalPlacedTextSymbolIndex: K, crossTileID: se } = c, oe = i.bB(n), ve = p === i.bq.vertical ? K : oe === "left" ? v : oe === "center" ? C : oe === "right" ? V : -1;
            v >= 0 && (t.text.placedSymbolArray.get(v).crossTileID = ve >= 0 && v !== ve ? 0 : se), C >= 0 && (t.text.placedSymbolArray.get(C).crossTileID = ve >= 0 && C !== ve ? 0 : se), V >= 0 && (t.text.placedSymbolArray.get(V).crossTileID = ve >= 0 && V !== ve ? 0 : se), K >= 0 && (t.text.placedSymbolArray.get(K).crossTileID = ve >= 0 && K !== ve ? 0 : se);
          }
          markUsedOrientation(t, n, c) {
            const p = n === i.bq.horizontal || n === i.bq.horizontalOnly ? n : 0, v = n === i.bq.vertical ? n : 0, { leftJustifiedTextSymbolIndex: C, centerJustifiedTextSymbolIndex: V, rightJustifiedTextSymbolIndex: K, verticalPlacedTextSymbolIndex: se } = c, oe = t.text.placedSymbolArray;
            C >= 0 && (oe.get(C).placedOrientation = p), V >= 0 && (oe.get(V).placedOrientation = p), K >= 0 && (oe.get(K).placedOrientation = p), se >= 0 && (oe.get(se).placedOrientation = v);
          }
          commit(t) {
            this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const n = this.prevPlacement;
            let c = !1;
            this.prevZoomAdjustment = n ? n.zoomAdjustment(this.transform.zoom) : 0;
            const p = n ? n.symbolFadeChange(t) : 1, v = n ? n.opacities : {}, C = n ? n.variableOffsets : {}, V = n ? n.placedOrientations : {};
            for (const K in this.placements) {
              const se = this.placements[K], oe = v[K];
              oe ? (this.opacities[K] = new ts(oe, p, se.text, se.icon, null, se.clipped), c = c || se.text !== oe.text.placed || se.icon !== oe.icon.placed) : (this.opacities[K] = new ts(null, p, se.text, se.icon, se.skipFade, se.clipped), c = c || se.text || se.icon);
            }
            for (const K in v) {
              const se = v[K];
              if (!this.opacities[K]) {
                const oe = new ts(se, p, !1, !1);
                oe.isHidden() || (this.opacities[K] = oe, c = c || se.text.placed || se.icon.placed);
              }
            }
            for (const K in C) this.variableOffsets[K] || !this.opacities[K] || this.opacities[K].isHidden() || (this.variableOffsets[K] = C[K]);
            for (const K in V) this.placedOrientations[K] || !this.opacities[K] || this.opacities[K].isHidden() || (this.placedOrientations[K] = V[K]);
            c ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = n ? n.lastPlacementChangeTime : t);
          }
          updateLayerOpacities(t, n, c, p) {
            const v = /* @__PURE__ */ new Set();
            for (const C of n) {
              const V = C.getBucket(t);
              V && C.latestFeatureIndex && t.fqid === V.layerIds[0] && (this.updateBucketOpacities(V, v, C, C.collisionBoxArray, c, p, C.tileID, t.scope), V.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(V, C.tileID), V.updateZOffset()));
            }
          }
          updateBucketOpacities(t, n, c, p, v, C, V, K) {
            t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
            const se = t.layers[0].layout, oe = t.layers[0].paint, ve = !!t.layers[0].dynamicFilter(), xe = new ts(null, 0, !1, !1, !0), Le = se.get("text-allow-overlap"), ft = se.get("icon-allow-overlap"), st = se.get("text-variable-anchor"), vt = se.get("text-rotation-alignment") === "map", gt = se.get("text-pitch-alignment") === "map", Rt = oe.get("symbol-z-offset"), qt = se.get("symbol-elevation-reference") === "sea", jt = !Rt.isConstant(), ii = new ts(null, 0, Le && (ft || !t.hasIconData() || se.get("icon-optional")), ft && (Le || !t.hasTextData() || se.get("text-optional")), !0);
            !t.collisionArrays && p && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(p);
            const Xt = (Zt, Jt, ui) => {
              for (let Ti = 0; Ti < Jt / 4; Ti++) Zt.opacityVertexArray.emplaceBack(ui);
            };
            let Kt = 0;
            C && t.updateReplacement(V, C);
            for (let Zt = 0; Zt < t.symbolInstances.length; Zt++) {
              const Jt = t.symbolInstances.get(Zt), { numHorizontalGlyphVertices: ui, numVerticalGlyphVertices: Ti, crossTileID: xi, numIconVertices: Pi, tileAnchorX: Ri, tileAnchorY: mi } = Jt;
              let Ai = null;
              const ji = this.retainedQueryData[t.bucketInstanceId];
              jt && Jt && ji && (Ai = c.latestFeatureIndex.loadFeature({ featureIndex: Jt.featureIndex, bucketIndex: ji.bucketIndex, sourceLayerIndex: ji.sourceLayerIndex, layoutVertexArrayOffset: 0 }));
              const yi = Rt.evaluate(Ai, {}), Ni = n.has(xi);
              let Mi = this.opacities[xi];
              Ni ? Mi = xe : Mi || (Mi = ii, this.opacities[xi] = Mi), n.add(xi);
              const Yi = ui > 0 || Ti > 0, Ui = Pi > 0, Fi = this.placedOrientations[xi], Zi = Fi === i.bq.vertical, ir = Fi === i.bq.horizontal || Fi === i.bq.horizontalOnly;
              !Yi && !Ui || Mi.isHidden() || Kt++;
              let cr = !1;
              if ((Yi || Ui) && C) for (const fr of t.activeReplacements) {
                if (i.bx(fr, v, i.by.Symbol, K) || fr.min.x > Ri || Ri > fr.max.x || fr.min.y > mi || mi > fr.max.y) continue;
                const Or = i.bz(Ri, mi, V.canonical, fr.footprintTileId.canonical);
                if (cr = i.bA(Or, fr.footprint), cr) break;
              }
              if (Yi) {
                const fr = cr ? io : $u(Mi.text);
                Xt(t.text, ui, Zi ? io : fr), Xt(t.text, Ti, ir ? io : fr);
                const Or = Mi.text.isHidden(), { leftJustifiedTextSymbolIndex: Er, centerJustifiedTextSymbolIndex: Ar, rightJustifiedTextSymbolIndex: Fr, verticalPlacedTextSymbolIndex: an } = Jt, yn = t.text.placedSymbolArray, $n = Or || Zi ? 1 : 0;
                Er >= 0 && (yn.get(Er).hidden = $n), Ar >= 0 && (yn.get(Ar).hidden = $n), Fr >= 0 && (yn.get(Fr).hidden = $n), an >= 0 && (yn.get(an).hidden = Or || ir ? 1 : 0);
                const fn = this.variableOffsets[xi];
                fn && this.markUsedJustification(t, fn.anchor, Jt, Fi);
                const Nr = this.placedOrientations[xi];
                Nr && (this.markUsedJustification(t, "left", Jt, Nr), this.markUsedOrientation(t, Nr, Jt));
              }
              if (Ui) {
                const fr = cr ? io : $u(Mi.icon), { placedIconSymbolIndex: Or, verticalPlacedIconSymbolIndex: Er } = Jt, Ar = t.icon.placedSymbolArray, Fr = Mi.icon.isHidden() ? 1 : 0;
                Or >= 0 && (Xt(t.icon, Pi, Zi ? io : fr), Ar.get(Or).hidden = Fr), Er >= 0 && (Xt(t.icon, Jt.numVerticalIconVertices, ir ? io : fr), Ar.get(Er).hidden = Fr);
              }
              if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
                const fr = t.collisionArrays[Zt];
                if (fr) {
                  let Or = new i.P(0, 0), Er = !0;
                  if (fr.textBox || fr.verticalTextBox) {
                    if (st) {
                      const Fr = this.variableOffsets[xi];
                      Fr ? (Or = ms(Fr.anchor, Fr.width, Fr.height, Fr.textOffset, Fr.textScale), vt && Or._rotate(gt ? this.transform.angle : -this.transform.angle)) : Er = !1;
                    }
                    ve && (Er = !Mi.clipped), fr.textBox && su(t.textCollisionBox.collisionVertexArray, Mi.text.placed, !Er || Zi, yi, qt, Or.x, Or.y), fr.verticalTextBox && su(t.textCollisionBox.collisionVertexArray, Mi.text.placed, !Er || ir, yi, qt, Or.x, Or.y);
                  }
                  const Ar = Er && !!(!ir && fr.verticalIconBox);
                  fr.iconBox && su(t.iconCollisionBox.collisionVertexArray, Mi.icon.placed, Ar, yi, qt, Jt.hasIconTextFit ? Or.x : 0, Jt.hasIconTextFit ? Or.y : 0), fr.verticalIconBox && su(t.iconCollisionBox.collisionVertexArray, Mi.icon.placed, !Ar, yi, qt, Jt.hasIconTextFit ? Or.x : 0, Jt.hasIconTextFit ? Or.y : 0);
                }
              }
            }
            if (t.fullyClipped = Kt === 0, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {
              const Zt = this.collisionCircleArrays[t.bucketInstanceId];
              t.placementInvProjMatrix = Zt.invProjMatrix, t.placementViewportMatrix = Zt.viewportMatrix, t.collisionCircleArray = Zt.circles, delete this.collisionCircleArrays[t.bucketInstanceId];
            }
          }
          symbolFadeChange(t) {
            return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(t) {
            return Math.max(0, (this.transform.zoom - t) / 1.5);
          }
          hasTransitions(t) {
            return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(t, n) {
            const c = this.zoomAtLastRecencyCheck === n ? 1 - this.zoomAdjustment(n) : 1;
            return this.zoomAtLastRecencyCheck = n, this.commitTime + this.fadeDuration * c > t;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function su(u, t, n, c, p, v, C) {
          u.emplaceBack(t ? 1 : 0, n ? 1 : 0, v || 0, C || 0, c, p ? 1 : 0), u.emplaceBack(t ? 1 : 0, n ? 1 : 0, v || 0, C || 0, c, p ? 1 : 0), u.emplaceBack(t ? 1 : 0, n ? 1 : 0, v || 0, C || 0, c, p ? 1 : 0), u.emplaceBack(t ? 1 : 0, n ? 1 : 0, v || 0, C || 0, c, p ? 1 : 0);
        }
        const ou = Math.pow(2, 25), Kh = Math.pow(2, 24), ul = Math.pow(2, 17), Ca = Math.pow(2, 16), kl = Math.pow(2, 9), lu = Math.pow(2, 8), Ll = Math.pow(2, 1);
        function $u(u) {
          if (u.opacity === 0 && !u.placed) return 0;
          if (u.opacity === 1 && u.placed) return 4294967295;
          const t = u.placed ? 1 : 0, n = Math.floor(127 * u.opacity);
          return n * ou + t * Kh + n * ul + t * Ca + n * kl + t * lu + n * Ll + t;
        }
        const io = 0;
        class ro {
          constructor(t) {
            this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && t.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
          }
          continuePlacement(t, n, c, p, v, C) {
            const V = this._bucketParts;
            for (; this._currentTileIndex < t.length; ) if (n.getBucketParts(V, p, t[this._currentTileIndex], this._sortAcrossTiles, C), this._currentTileIndex++, v()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, V.sort((K, se) => K.sortKey - se.sortKey)); this._currentPartIndex < V.length; ) {
              const K = V[this._currentPartIndex];
              if (n.placeLayerBucketPart(K, this._seenCrossTileIDs, c, K.symbolInstanceStart === 0, C), this._currentPartIndex++, v()) return !0;
            }
            return !1;
          }
        }
        class Ol {
          constructor(t, n, c, p, v, C, V, K, se) {
            this.placement = new Zu(t, v, C, V, K, se), this._currentPlacementIndex = n.length - 1, this._forceFullPlacement = c, this._showCollisionBoxes = p, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(t, n, c, p, v) {
            const C = i.q.now(), V = () => {
              const K = i.q.now() - C;
              return !this._forceFullPlacement && K > 2;
            };
            for (; this._currentPlacementIndex >= 0; ) {
              const K = n[t[this._currentPlacementIndex]], se = this.placement.collisionIndex.transform.zoom;
              if (K.type === "symbol" && (!K.minzoom || K.minzoom <= se) && (!K.maxzoom || K.maxzoom > se)) {
                const oe = K, ve = oe.layout.get("symbol-z-elevate"), xe = oe.layout.get("symbol-sort-key").constantOr(1) !== void 0, Le = oe.layout.get("symbol-z-order"), ft = Le === "viewport-y" || Le === "auto" && !(Le !== "viewport-y" && xe), st = oe.layout.get("text-allow-overlap") || oe.layout.get("icon-allow-overlap") || oe.layout.get("text-ignore-placement") || oe.layout.get("icon-ignore-placement"), vt = ft && st, gt = this._inProgressLayer = this._inProgressLayer || new ro(oe), Rt = i.aC(K.source, K.scope);
                if (gt.continuePlacement(ve || vt ? p[Rt] : c[Rt], this.placement, this._showCollisionBoxes, K, V, v)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(t) {
            return this.placement.commit(t), this.placement;
          }
        }
        const Xu = 512 / i.ag / 2;
        class Ic {
          constructor(t, n, c) {
            this.tileID = t, this.bucketInstanceId = c, this.index = new i.bE(n.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
            const p = t.canonical.x * i.ag, v = t.canonical.y * i.ag;
            for (let C = 0; C < n.length; C++) {
              const { key: V, crossTileID: K, tileAnchorX: se, tileAnchorY: oe } = n.get(C), ve = Math.floor((p + se) * Xu), xe = Math.floor((v + oe) * Xu);
              this.index.add(ve, xe), this.keys.push(V), this.crossTileIDs.push(K);
            }
            this.index.finish();
          }
          findMatches(t, n, c) {
            const p = this.tileID.canonical.z < n.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - n.canonical.z), v = Xu / Math.pow(2, n.canonical.z - this.tileID.canonical.z), C = n.canonical.x * i.ag, V = n.canonical.y * i.ag;
            for (let K = 0; K < t.length; K++) {
              const se = t.get(K);
              if (se.crossTileID) continue;
              const { key: oe, tileAnchorX: ve, tileAnchorY: xe } = se, Le = Math.floor((C + ve) * v), ft = Math.floor((V + xe) * v), st = this.index.range(Le - p, ft - p, Le + p, ft + p);
              for (const vt of st) {
                const gt = this.crossTileIDs[vt];
                if (this.keys[vt] === oe && !c.has(gt)) {
                  c.add(gt), se.crossTileID = gt;
                  break;
                }
              }
            }
          }
        }
        class Pn {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class Pc {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(t) {
            const n = Math.round((t - this.lng) / 360);
            if (n !== 0) for (const c in this.indexes) {
              const p = this.indexes[c], v = {};
              for (const C in p) {
                const V = p[C];
                V.tileID = V.tileID.unwrapTo(V.tileID.wrap + n), v[V.tileID.key] = V;
              }
              this.indexes[c] = v;
            }
            this.lng = t;
          }
          addBucket(t, n, c) {
            if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
              if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === n.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
            }
            for (let v = 0; v < n.symbolInstances.length; v++) n.symbolInstances.get(v).crossTileID = 0;
            this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = /* @__PURE__ */ new Set());
            const p = this.usedCrossTileIDs[t.overscaledZ];
            for (const v in this.indexes) {
              const C = this.indexes[v];
              if (Number(v) > t.overscaledZ) for (const V in C) {
                const K = C[V];
                K.tileID.isChildOf(t) && K.findMatches(n.symbolInstances, t, p);
              }
              else {
                const V = C[t.scaledTo(Number(v)).key];
                V && V.findMatches(n.symbolInstances, t, p);
              }
            }
            for (let v = 0; v < n.symbolInstances.length; v++) {
              const C = n.symbolInstances.get(v);
              C.crossTileID || (C.crossTileID = c.generate(), p.add(C.crossTileID));
            }
            return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new Ic(t, n.symbolInstances, n.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(t, n) {
            for (const c of n.crossTileIDs) this.usedCrossTileIDs[t].delete(c);
          }
          removeStaleBuckets(t) {
            let n = !1;
            for (const c in this.indexes) {
              const p = this.indexes[c];
              for (const v in p) t[p[v].bucketInstanceId] || (this.removeBucketCrossTileIDs(c, p[v]), delete p[v], n = !0);
            }
            return n;
          }
        }
        class Yu {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new Pn(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(t, n, c, p) {
            let v = this.layerIndexes[t.fqid];
            v === void 0 && (v = this.layerIndexes[t.fqid] = new Pc());
            let C = !1;
            const V = {};
            p.name !== "globe" && v.handleWrapJump(c);
            for (const K of n) {
              const se = K.getBucket(t);
              se && t.fqid === se.layerIds[0] && (se.bucketInstanceId || (se.bucketInstanceId = ++this.maxBucketInstanceId), v.addBucket(K.tileID, se, this.crossTileIDs) && (C = !0), V[se.bucketInstanceId] = !0);
            }
            return v.removeStaleBuckets(V) && (C = !0), C;
          }
          pruneUnusedLayers(t) {
            const n = {};
            t.forEach((c) => {
              n[c] = !0;
            });
            for (const c in this.layerIndexes) n[c] || delete this.layerIndexes[c];
          }
        }
        const Uo = 771;
        class zr {
          constructor(t, n, c, p) {
            this.blendFunction = t, this.blendColor = n, this.mask = c, this.blendEquation = p;
          }
        }
        zr.Replace = [1, 0, 1, 0], zr.disabled = new zr(zr.Replace, i.aj.transparent, [!1, !1, !1, !1]), zr.unblended = new zr(zr.Replace, i.aj.transparent, [!0, !0, !0, !0]), zr.alphaBlended = new zr([1, Uo, 1, Uo], i.aj.transparent, [!0, !0, !0, !0]), zr.alphaBlendedNonPremultiplied = new zr([770, Uo, 770, Uo], i.aj.transparent, [!0, !0, !0, !0]), zr.multiply = new zr([774, 0, 774, 0], i.aj.transparent, [!0, !0, !0, !0]);
        class Sr {
          constructor(t, n, c) {
            this.func = t, this.mask = n, this.range = c;
          }
        }
        Sr.ReadOnly = !1, Sr.ReadWrite = !0, Sr.disabled = new Sr(519, Sr.ReadOnly, [0, 1]);
        const _n = 7680;
        class Lr {
          constructor(t, n, c, p, v, C) {
            this.test = t, this.ref = n, this.mask = c, this.fail = p, this.depthFail = v, this.pass = C;
          }
        }
        Lr.disabled = new Lr({ func: 519, mask: 0 }, 0, 0, _n, _n, _n);
        const zn = 1029, cl = 2305;
        class kr {
          constructor(t, n, c) {
            this.enable = t, this.mode = n, this.frontFace = c;
          }
        }
        function sa(u, t) {
          const n = i.bG(u, 3);
          i.ab.mat4.fromQuat(u, t), i.bI(u, 3, n);
        }
        function us(u, t) {
          const n = i.ab.quat.identity([]);
          return i.ab.quat.rotateZ(n, n, -t), i.ab.quat.rotateX(n, n, -u), n;
        }
        function hl(u, t) {
          const n = [u[0], u[1], 0], c = [t[0], t[1], 0];
          if (i.ab.vec3.length(n) >= 1e-15) {
            const C = i.ab.vec3.normalize([], n);
            i.ab.vec3.scale(c, C, i.ab.vec3.dot(c, C)), t[0] = c[0], t[1] = c[1];
          }
          const p = i.ab.vec3.cross([], t, u);
          if (i.ab.vec3.len(p) < 1e-15) return null;
          const v = Math.atan2(-p[1], p[0]);
          return us(Math.atan2(Math.sqrt(u[0] * u[0] + u[1] * u[1]), -u[2]), v);
        }
        kr.disabled = new kr(!1, zn, cl), kr.backCCW = new kr(!0, zn, cl), kr.backCW = new kr(!0, zn, 2304), kr.frontCW = new kr(!0, 1028, 2304), kr.frontCCW = new kr(!0, 1028, cl);
        class uu {
          constructor(t, n) {
            this.position = t, this.orientation = n;
          }
          get position() {
            return this._position;
          }
          set position(t) {
            if (t) {
              const n = t instanceof i.aa ? t : new i.aa(t[0], t[1], t[2]);
              this._renderWorldCopies && (n.x = i.bF(n.x, 0, 1)), this._position = n;
            } else this._position = null;
          }
          lookAtPoint(t, n) {
            if (this.orientation = null, !this.position) return;
            const c = this.position, p = this._elevation ? this._elevation.getAtPointOrZero(i.aa.fromLngLat(t)) : 0, v = i.aa.fromLngLat(t, p), C = [v.x - c.x, v.y - c.y, v.z - c.z];
            n || (n = [0, 0, 1]), n[2] = Math.abs(n[2]), this.orientation = hl(C, n);
          }
          setPitchBearing(t, n) {
            this.orientation = us(i.ai(t), i.ai(-n));
          }
        }
        class Pa {
          constructor(t, n) {
            this._transform = i.ab.mat4.identity([]), this.orientation = n, this.position = t;
          }
          get mercatorPosition() {
            const t = this.position;
            return new i.aa(t[0], t[1], t[2]);
          }
          get position() {
            const t = i.bG(this._transform, 3);
            return [t[0], t[1], t[2]];
          }
          set position(t) {
            var n;
            t && i.bI(this._transform, 3, [(n = t)[0], n[1], n[2], 1]);
          }
          get orientation() {
            return this._orientation;
          }
          set orientation(t) {
            this._orientation = t || i.ab.quat.identity([]), t && sa(this._transform, this._orientation);
          }
          getPitchBearing() {
            const t = this.forward(), n = this.right();
            return { bearing: Math.atan2(-n[1], n[0]), pitch: Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]) };
          }
          setPitchBearing(t, n) {
            this._orientation = us(t, n), sa(this._transform, this._orientation);
          }
          forward() {
            const t = i.bG(this._transform, 2);
            return [-t[0], -t[1], -t[2]];
          }
          up() {
            const t = i.bG(this._transform, 1);
            return [-t[0], -t[1], -t[2]];
          }
          right() {
            const t = i.bG(this._transform, 0);
            return [t[0], t[1], t[2]];
          }
          getCameraToWorld(t, n) {
            const c = new Float64Array(16);
            return i.ab.mat4.invert(c, this.getWorldToCamera(t, n)), c;
          }
          getCameraToWorldMercator() {
            return this._transform;
          }
          getWorldToCameraPosition(t, n, c) {
            const p = this.position;
            i.ab.vec3.scale(p, p, -t);
            const v = new Float64Array(16);
            return i.ab.mat4.fromScaling(v, [c, c, c]), i.ab.mat4.translate(v, v, p), v[10] *= n, v;
          }
          getWorldToCamera(t, n) {
            const c = new Float64Array(16), p = new Float64Array(4), v = this.position;
            return i.ab.quat.conjugate(p, this._orientation), i.ab.vec3.scale(v, v, -t), i.ab.mat4.fromQuat(c, p), i.ab.mat4.translate(c, c, v), c[1] *= -1, c[5] *= -1, c[9] *= -1, c[13] *= -1, c[8] *= n, c[9] *= n, c[10] *= n, c[11] *= n, c;
          }
          getCameraToClipPerspective(t, n, c, p) {
            const v = new Float64Array(16);
            return i.ab.mat4.perspective(v, t, n, c, p), v;
          }
          getCameraToClipOrthographic(t, n, c, p, v, C) {
            const V = new Float64Array(16);
            return i.ab.mat4.ortho(V, t, n, c, p, v, C), V;
          }
          getDistanceToElevation(t, n = !1) {
            const c = t === 0 ? 0 : i.bH(t, n ? i.aS(this.position[1]) : this.position[1]), p = this.forward();
            return (c - this.position[2]) / p[2];
          }
          clone() {
            return new Pa([...this.position], [...this.orientation]);
          }
        }
        const $a = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, LUT: 10, ShadowMap0: 11 };
        class tr {
          constructor(t = 0, n = 0, c = 0, p = 0) {
            if (isNaN(t) || t < 0 || isNaN(n) || n < 0 || isNaN(c) || c < 0 || isNaN(p) || p < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t, this.bottom = n, this.left = c, this.right = p;
          }
          interpolate(t, n, c) {
            return n.top != null && t.top != null && (this.top = i.af(t.top, n.top, c)), n.bottom != null && t.bottom != null && (this.bottom = i.af(t.bottom, n.bottom, c)), n.left != null && t.left != null && (this.left = i.af(t.left, n.left, c)), n.right != null && t.right != null && (this.right = i.af(t.right, n.right, c)), this;
          }
          getCenter(t, n) {
            const c = i.aw((this.left + t - this.right) / 2, 0, t), p = i.aw((this.top + n - this.bottom) / 2, 0, n);
            return new i.P(c, p);
          }
          equals(t) {
            return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;
          }
          clone() {
            return new tr(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        const fl = (u, t, n) => (1 - n) * u + n * t, Mo = (u) => u * u * u * u * u;
        class Vo {
          constructor(t, n, c, p, v, C, V) {
            this.tileSize = 512, this._renderWorldCopies = v === void 0 || v, this._minZoom = t || 0, this._maxZoom = n || 22, this._minPitch = c ?? 0, this._maxPitch = p ?? 60, this.setProjection(C), this.setMaxBounds(V), this.width = 0, this.height = 0, this._center = new i.bO(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new tr(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Pa(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = !1;
          }
          clone() {
            const t = new Vo(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
            return t._elevation = this._elevation, t._centerAltitude = this._centerAltitude, t._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, t.tileSize = this.tileSize, t.mercatorFromTransition = this.mercatorFromTransition, t.width = this.width, t.height = this.height, t.cameraElevationReference = this.cameraElevationReference, t._center = this._center, t._setZoom(this.zoom), t._seaLevelZoom = this._seaLevelZoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._nearZ = this._nearZ, t._farZ = this._farZ, t._averageElevation = this._averageElevation, t._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, t._unmodified = this._unmodified, t._edgeInsets = this._edgeInsets.clone(), t._camera = this._camera.clone(), t._calcMatrices(), t.freezeTileCoverage = this.freezeTileCoverage, t.frustumCorners = this.frustumCorners, t;
          }
          get isOrthographic() {
            return this.projection.name !== "globe" && this._orthographicProjectionAtLowPitch && this.pitch < 15;
          }
          get elevation() {
            return this._elevation;
          }
          set elevation(t) {
            this._elevation !== t && (this._elevation = t, this._updateCameraOnTerrain(), this._calcMatrices());
          }
          get depthOcclusionForSymbolsAndCircles() {
            return this.projection.name !== "globe" && !this.isOrthographic;
          }
          updateElevation(t, n = !1) {
            const c = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
            (this._seaLevelZoom == null || c) && this._updateCameraOnTerrain(), (t || c) && this._constrainCamera(n), this._calcMatrices();
          }
          getProjection() {
            return i.ay(this.projection, ["name", "center", "parallels"]);
          }
          setProjection(t) {
            this.projectionOptions = t || { name: "mercator" };
            const n = this.projection ? this.getProjection() : void 0;
            this.projection = i.bP(this.projectionOptions);
            const c = this.getProjection(), p = !i.bn(n, c);
            return p && this._calcMatrices(), this.mercatorFromTransition = !1, p;
          }
          setOrthographicProjectionAtLowPitch(t) {
            return this._orthographicProjectionAtLowPitch !== t && (this._orthographicProjectionAtLowPitch = t, this._calcMatrices(), !0);
          }
          setMercatorFromTransition() {
            const t = this.projection.name;
            this.mercatorFromTransition = !0, this.projectionOptions = { name: "mercator" }, this.projection = i.bP({ name: "mercator" });
            const n = t !== this.projection.name;
            return n && this._calcMatrices(), n;
          }
          get minZoom() {
            return this._minZoom;
          }
          set minZoom(t) {
            this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          set maxZoom(t) {
            this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t));
          }
          get minPitch() {
            return this._minPitch;
          }
          set minPitch(t) {
            this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          set maxPitch(t) {
            this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies && this.projection.supportsWorldCopies === !0;
          }
          set renderWorldCopies(t) {
            t === void 0 ? t = !0 : t === null && (t = !1), this._renderWorldCopies = t;
          }
          get worldSize() {
            return this.tileSize * this.scale;
          }
          get cameraWorldSizeForFog() {
            const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
          }
          get cameraWorldSize() {
            const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
            return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
          }
          get pixelsPerMeter() {
            return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
          }
          get cameraPixelsPerMeter() {
            return i.bH(1, this.center.lat) * this.cameraWorldSizeForFog;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new i.P(this.width, this.height);
          }
          get bearing() {
            return i.bF(this.rotation, -180, 180);
          }
          set bearing(t) {
            this.rotation = t;
          }
          get rotation() {
            return -this.angle / Math.PI * 180;
          }
          set rotation(t) {
            const n = -t * Math.PI / 180;
            this.angle !== n && (this._unmodified = !1, this.angle = n, this._calcMatrices(), this.rotationMatrix = i.ab.mat2.create(), i.ab.mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
          }
          get pitch() {
            return this._pitch / Math.PI * 180;
          }
          set pitch(t) {
            const n = i.aw(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== n && (this._unmodified = !1, this._pitch = n, this._calcMatrices());
          }
          get aspect() {
            return this.width / this.height;
          }
          get fov() {
            return this._fov / Math.PI * 180;
          }
          get fovX() {
            return this._fov;
          }
          get fovY() {
            const t = 1 / Math.tan(0.5 * this.fovX);
            return 2 * Math.atan(1 / this.aspect / t);
          }
          set fov(t) {
            t = Math.max(0.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = i.ai(t), this._calcMatrices());
          }
          get averageElevation() {
            return this._averageElevation;
          }
          set averageElevation(t) {
            this._averageElevation = t, this._calcFogMatrices(), this._distanceTileDataCache = {};
          }
          get zoom() {
            return this._zoom;
          }
          set zoom(t) {
            const n = Math.min(Math.max(t, this.minZoom), this.maxZoom);
            this._zoom !== n && (this._unmodified = !1, this._setZoom(n), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
          }
          _setZoom(t) {
            this._zoom = t, this.scale = this.zoomScale(t), this.tileZoom = Math.floor(t), this.zoomFraction = t - this.tileZoom;
          }
          get tileCoverLift() {
            return this._tileCoverLift;
          }
          set tileCoverLift(t) {
            this._tileCoverLift !== t && (this._tileCoverLift = t);
          }
          _updateCameraOnTerrain() {
            const t = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, n = this.elevation && t === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
            if (!this._elevation || t === Number.NEGATIVE_INFINITY && (!n || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
            const c = this._elevation;
            n || this._centerAltitude && this._centerAltitudeValidForExaggeration && c.exaggeration() && this._centerAltitudeValidForExaggeration !== c.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * c.exaggeration(), this._centerAltitudeValidForExaggeration = c.exaggeration()) : (this._centerAltitude = t || 0, this._centerAltitudeValidForExaggeration = c.exaggeration()), this._updateSeaLevelZoom();
          }
          _updateSeaLevelZoom() {
            this._centerAltitudeValidForExaggeration !== void 0 && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
          }
          sampleAverageElevation() {
            if (!this._elevation) return 0;
            const t = this._elevation, n = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], c = this.horizonLineFromTop();
            let p = 0, v = 0;
            for (let C = 0; C < n.length; C++) {
              const V = new i.P(n[C][0] * this.width, c + n[C][1] * (this.height - c)), K = t.pointCoordinate(V);
              if (!K) continue;
              const se = 1 / Math.hypot(K[0] - this._camera.position[0], K[1] - this._camera.position[1]);
              p += K[3] * se, v += se;
            }
            return v === 0 ? NaN : p / v;
          }
          get center() {
            return this._center;
          }
          set center(t) {
            t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
          }
          _updateZoomFromElevation() {
            if (this._seaLevelZoom == null || !this._elevation) return;
            const t = this._seaLevelZoom, n = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), c = this.pixelsPerMeter / this.worldSize * n, p = this._mercatorZfromZoom(t), v = this._mercatorZfromZoom(this._maxZoom), C = Math.max(p - c, v);
            this._setZoom(this._zoomFromMercatorZ(C));
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          set padding(t) {
            this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());
          }
          computeZoomRelativeTo(t) {
            const n = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));
            let c;
            c = t.z < this._camera.position[2] ? [n.x, n.y, n.z] : [t.x, t.y, t.z];
            const p = i.ab.vec3.length(i.ab.vec3.sub([], this._camera.position, c));
            return i.aw(this._zoomFromMercatorZ(p), this._minZoom, this._maxZoom);
          }
          setFreeCameraOptions(t) {
            if (!this.height || !t.position && !t.orientation) return;
            this._updateCameraState();
            let n = !1;
            if (t.orientation && !i.ab.quat.exactEquals(t.orientation, this._camera.orientation) && (n = this._setCameraOrientation(t.orientation)), t.position) {
              const c = [t.position.x, t.position.y, t.position.z];
              i.ab.vec3.exactEquals(c, this._camera.position) || (this._setCameraPosition(c), n = !0);
            }
            n && (this._updateStateFromCamera(), this.recenterOnTerrain());
          }
          getFreeCameraOptions() {
            this._updateCameraState();
            const t = this._camera.position, n = new uu();
            return n.position = new i.aa(t[0], t[1], t[2]), n.orientation = this._camera.orientation, n._elevation = this.elevation, n._renderWorldCopies = this.renderWorldCopies, n;
          }
          _setCameraOrientation(t) {
            if (!i.ab.quat.length(t)) return !1;
            i.ab.quat.normalize(t, t);
            const n = i.ab.vec3.transformQuat([], [0, 0, -1], t), c = i.ab.vec3.transformQuat([], [0, -1, 0], t);
            if (c[2] < 0) return !1;
            const p = hl(n, c);
            return !!p && (this._camera.orientation = p, !0);
          }
          _setCameraPosition(t) {
            const n = this.zoomScale(this.minZoom) * this.tileSize, c = this.zoomScale(this.maxZoom) * this.tileSize, p = this.cameraToCenterDistance;
            t[2] = i.aw(t[2], p / c, p / n), this._camera.position = t;
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }
          get fovAboveCenter() {
            return this._fov * (0.5 + this.centerOffset.y / this.height);
          }
          isPaddingEqual(t) {
            return this._edgeInsets.equals(t);
          }
          interpolatePadding(t, n, c) {
            this._unmodified = !1, this._edgeInsets.interpolate(t, n, c), this._constrain(), this._calcMatrices();
          }
          coveringZoomLevel(t) {
            const n = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
            return Math.max(0, n);
          }
          getVisibleUnwrappedCoordinates(t) {
            const n = [new i.bQ(0, t)];
            if (this.renderWorldCopies) {
              const c = this.pointCoordinate(new i.P(0, 0)), p = this.pointCoordinate(new i.P(this.width, 0)), v = this.pointCoordinate(new i.P(this.width, this.height)), C = this.pointCoordinate(new i.P(0, this.height)), V = Math.floor(Math.min(c.x, p.x, v.x, C.x)), K = Math.floor(Math.max(c.x, p.x, v.x, C.x)), se = 1;
              for (let oe = V - se; oe <= K + se; oe++) oe !== 0 && n.push(new i.bQ(oe, t));
            }
            return n;
          }
          isLODDisabled(t) {
            return (!t || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
          }
          extendTileCover(t, n, c) {
            let p = [];
            const v = c !== void 0, C = !v;
            if (C && this.zoom < n || v && c[0] === 0 && c[1] === 0) return p;
            const V = /* @__PURE__ */ new Set(), K = (oe, ve, xe, Le, ft) => {
              const st = i.c5(ve, oe, xe, Le, ft);
              V.has(st) || (p.push(new i.aG(oe, ve, xe, Le, ft)), V.add(st));
            };
            for (let oe = 0; oe < t.length; oe++) {
              const ve = t[oe];
              if (C && ve.canonical.z !== n) continue;
              const xe = ve.canonical, Le = ve.overscaledZ, ft = ve.wrap, st = 1 << xe.z, vt = xe.x + 1 < st, gt = xe.x > 0, Rt = xe.y + 1 < st, qt = xe.y > 0, jt = ve.wrap - (gt ? 0 : 1), ii = ve.wrap + (vt ? 0 : 1), Xt = gt ? xe.x - 1 : st - 1, Kt = vt ? xe.x + 1 : 0;
              if (v) c[0] < 0 ? (K(Le, ii, xe.z, Kt, xe.y), c[1] < 0 && Rt && (K(Le, ft, xe.z, xe.x, xe.y + 1), K(Le, ii, xe.z, Kt, xe.y + 1)), c[1] > 0 && qt && (K(Le, ft, xe.z, xe.x, xe.y - 1), K(Le, ii, xe.z, Kt, xe.y - 1))) : c[0] > 0 ? (K(Le, jt, xe.z, Xt, xe.y), c[1] < 0 && Rt && (K(Le, ft, xe.z, xe.x, xe.y + 1), K(Le, jt, xe.z, Xt, xe.y + 1)), c[1] > 0 && qt && (K(Le, ft, xe.z, xe.x, xe.y - 1), K(Le, jt, xe.z, Xt, xe.y - 1))) : c[1] < 0 && Rt ? K(Le, ft, xe.z, xe.x, xe.y + 1) : qt && K(Le, ft, xe.z, xe.x, xe.y - 1);
              else {
                const Zt = ve.visibleQuadrants;
                1 & Zt && (K(Le, jt, xe.z, Xt, xe.y), qt && (K(Le, ft, xe.z, xe.x, xe.y - 1), K(Le, jt, xe.z, Xt, xe.y - 1))), 2 & Zt && (K(Le, ii, xe.z, Kt, xe.y), qt && (K(Le, ft, xe.z, xe.x, xe.y - 1), K(Le, ii, xe.z, Kt, xe.y - 1))), 4 & Zt && (K(Le, jt, xe.z, Xt, xe.y), Rt && (K(Le, ft, xe.z, xe.x, xe.y + 1), K(Le, jt, xe.z, Xt, xe.y + 1))), 8 & Zt && (K(Le, ii, xe.z, Kt, xe.y), Rt && (K(Le, ft, xe.z, xe.x, xe.y + 1), K(Le, ii, xe.z, Kt, xe.y + 1)));
              }
            }
            const se = [];
            for (const oe of p) p.some((ve) => oe.isChildOf(ve)) || se.push(oe);
            if (p = se.filter((oe) => !t.some((ve) => !!(oe.overscaledZ < n && ve.isChildOf(oe)) || oe.equals(ve) || oe.isChildOf(ve))), C) {
              const oe = 1 << n, ve = this.projection.name === "globe" ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), xe = [oe * ve.x, oe * ve.y], Le = 4, ft = Le * Le;
              p = p.filter((st) => {
                const vt = st.canonical.x + 0.5 - xe[0], gt = st.canonical.y + 0.5 - xe[1];
                return vt * vt + gt * gt < ft;
              });
            }
            return p;
          }
          coveringTiles(t) {
            let n = this.coveringZoomLevel(t);
            const c = n, p = this.elevation && this.elevation.exaggeration(), v = p && !t.isTerrainDEM, C = this.projection.name === "mercator";
            if (t.minzoom !== void 0 && n < t.minzoom) return [];
            t.maxzoom !== void 0 && n > t.maxzoom && (n = t.maxzoom);
            const V = this.locationCoordinate(this.center), K = this.center.lat, se = 1 << n, oe = [se * V.x, se * V.y, 0], ve = this.projection.name === "globe", xe = !ve, Le = i.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, n, xe), ft = ve ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), st = se * i.bH(1, this.center.lat), vt = this._camera.position[2] / i.bH(1, this.center.lat), gt = [se * ft.x, se * ft.y, vt * (xe ? 1 : st)], Rt = ve || p, qt = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : 0.502), jt = this.isLODDisabled(!0) ? n : 0;
            let ii;
            if (this._elevation && t.isTerrainDEM) ii = 1e4 * this._elevation.exaggeration();
            else if (this._elevation) {
              const yi = this._elevation.getMinMaxForVisibleTiles();
              ii = yi ? yi.max : this._centerAltitude;
            } else ii = this._centerAltitude;
            const Xt = t.isTerrainDEM ? -ii : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, Kt = this.projection.isReprojectedInTileSpace ? i.bS(this) : 1, Zt = (yi) => {
              const Mi = new i.aa(yi.x + 25e-6, yi.y, yi.z), Yi = new i.aa(yi.x, yi.y + 25e-6, yi.z), Ui = yi.toLngLat(), Fi = Mi.toLngLat(), Zi = Yi.toLngLat(), ir = this.locationCoordinate(Ui), cr = this.locationCoordinate(Fi), fr = this.locationCoordinate(Zi), Or = Math.hypot(cr.x - ir.x, cr.y - ir.y), Er = Math.hypot(fr.x - ir.x, fr.y - ir.y);
              return Math.sqrt(Or * Er) * Kt / 25e-6;
            }, Jt = (yi) => {
              const Ni = ii, Mi = Xt;
              return { aabb: i.bV(this, se, 0, 0, 0, yi, Mi, Ni, this.projection), zoom: 0, x: 0, y: 0, minZ: Mi, maxZ: Ni, wrap: yi, fullyVisible: !1 };
            }, ui = [];
            let Ti = [];
            const xi = n, Pi = t.reparseOverscaled ? c : n, Ri = (vt - this._centerAltitude) * st, mi = (yi) => {
              if (!this._elevation || !yi.tileID || !C) return;
              const Ni = this._elevation.getMinMaxForTile(yi.tileID), Mi = yi.aabb;
              Ni ? (Mi.min[2] = Ni.min, Mi.max[2] = Ni.max, Mi.center[2] = (Mi.min[2] + Mi.max[2]) / 2) : (yi.shouldSplit = ji(yi), yi.shouldSplit || (Mi.min[2] = Mi.max[2] = Mi.center[2] = this._centerAltitude));
            }, Ai = (yi, Ni) => {
              if (0.707 * Ni < yi) return 1;
              const Mi = Ni / yi;
              return Mi / (1.4144271570014144 + (Math.pow(1.1, Mi - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
            }, ji = (yi) => {
              if (yi.zoom < jt) return !0;
              if (yi.zoom === xi) return !1;
              if (yi.shouldSplit != null) return yi.shouldSplit;
              const Ni = yi.aabb.distanceX(gt), Mi = yi.aabb.distanceY(gt);
              let Yi = Ri, Ui = 1;
              if (ve) {
                Yi = yi.aabb.distanceZ(gt);
                const Er = Math.pow(2, yi.zoom), Ar = i.aS((yi.y + 1) / Er), Fr = i.aS(yi.y / Er), an = Math.min(Math.max(K, Ar), Fr), yn = i.c9(an) / i.c9(K);
                if (Ui = an === K ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, yn / this._mercatorScaleRatio), this.zoom <= i.c6 && yi.zoom === xi - 1 && yn >= 0.9) return !0;
              } else if (v && (Yi = yi.aabb.distanceZ(gt) * st), this.projection.isReprojectedInTileSpace && c <= 5) {
                const Er = Math.pow(2, yi.zoom), Ar = Zt(new i.aa((yi.x + 0.5) / Er, (yi.y + 0.5) / Er));
                Ui = Ar > 0.85 ? 1 : Ar;
              }
              if (!C) {
                const Er = Math.sqrt(Ni * Ni + Mi * Mi + Yi * Yi);
                let Ar = (1 << xi - yi.zoom) * qt * Ui;
                return Ar *= Ai(Math.max(Yi, Ri), Er), Er < Ar;
              }
              let Fi = Number.MAX_VALUE, Zi = 0;
              const ir = yi.aabb.getCorners(), cr = [];
              for (const Er of ir) {
                i.ab.vec3.sub(cr, Er, gt), ve || (v ? cr[2] *= st : cr[2] = Ri);
                const Ar = i.ab.vec3.dot(cr, this._camera.forward());
                Ar < Fi && (Fi = Ar, Zi = Math.abs(cr[2]));
              }
              let fr = (1 << xi - yi.zoom) * qt * Ui;
              if (fr *= Ai(Math.max(Zi, Ri), Fi), Fi < fr) return !0;
              const Or = yi.aabb.closestPoint(oe);
              return Or[0] === oe[0] && Or[1] === oe[1];
            };
            if (this.renderWorldCopies) for (let yi = 1; yi <= 3; yi++) ui.push(Jt(-yi)), ui.push(Jt(yi));
            for (ui.push(Jt(0)); ui.length > 0; ) {
              const yi = ui.pop(), Ni = yi.x, Mi = yi.y;
              let Yi = yi.fullyVisible;
              const Ui = () => this.projection.name === "globe" && (yi.y === 0 || yi.y === (1 << yi.zoom) - 1);
              if (!Yi) {
                let Fi = Rt ? yi.aabb.intersects(Le) : yi.aabb.intersectsFlat(Le);
                if (Fi === 0 && Ui()) {
                  const Zi = new i.bT(yi.zoom, Ni, Mi);
                  Fi = i.bU(this, se, Zi, !0).intersects(Le);
                }
                if (Fi === 0) continue;
                Yi = Fi === 2;
              }
              if (yi.zoom !== xi && ji(yi)) for (let Fi = 0; Fi < 4; Fi++) {
                const Zi = (Ni << 1) + Fi % 2, ir = (Mi << 1) + (Fi >> 1), cr = { aabb: C ? yi.aabb.quadrant(Fi) : i.bV(this, se, yi.zoom + 1, Zi, ir, yi.wrap, yi.minZ, yi.maxZ, this.projection), zoom: yi.zoom + 1, x: Zi, y: ir, wrap: yi.wrap, fullyVisible: Yi, tileID: void 0, shouldSplit: void 0, minZ: yi.minZ, maxZ: yi.maxZ };
                v && !ve && (cr.tileID = new i.aG(yi.zoom + 1 === xi ? Pi : yi.zoom + 1, yi.wrap, yi.zoom + 1, Zi, ir), mi(cr)), ui.push(cr);
              }
              else {
                const Fi = yi.zoom === xi ? Pi : yi.zoom;
                if (t.minzoom && t.minzoom > Fi) continue;
                let Zi = 0;
                if (!Yi) {
                  let Or = Rt ? yi.aabb.intersectsPrecise(Le) : yi.aabb.intersectsPreciseFlat(Le);
                  if (Or === 0 && Ui()) {
                    const Er = new i.bT(yi.zoom, Ni, Mi);
                    Or = i.bU(this, se, Er, !0).intersectsPrecise(Le);
                  }
                  if (Or === 0) continue;
                  if (t.calculateQuadrantVisibility) if (Le.containsPoint(yi.aabb.center)) Zi = 15;
                  else for (let Er = 0; Er < 4; Er++) yi.aabb.quadrant(Er).intersects(Le) !== 0 && (Zi |= 1 << Er);
                }
                const ir = oe[0] - (0.5 + Ni + (yi.wrap << yi.zoom)) * (1 << n - yi.zoom), cr = oe[1] - 0.5 - Mi, fr = yi.tileID ? yi.tileID : new i.aG(Fi, yi.wrap, yi.zoom, Ni, Mi);
                t.calculateQuadrantVisibility && (fr.visibleQuadrants = Zi), Ti.push({ tileID: fr, distanceSq: ir * ir + cr * cr });
              }
            }
            if (this.fogCullDistSq) {
              const yi = this.fogCullDistSq, Ni = this.horizonLineFromTop();
              Ti = Ti.filter((Mi) => {
                const Yi = [0, 0, 0, 1], Ui = [i.ag, i.ag, 0, 1], Fi = this.calculateFogTileMatrix(Mi.tileID.toUnwrapped());
                i.ab.vec4.transformMat4(Yi, Yi, Fi), i.ab.vec4.transformMat4(Ui, Ui, Fi);
                const Zi = i.ab.vec4.min([], Yi, Ui), ir = i.ab.vec4.max([], Yi, Ui), cr = i.bW(Zi, ir);
                if (cr === 0) return !0;
                let fr = !1;
                const Or = this._elevation;
                if (Or && cr > yi && Ni !== 0) {
                  const Er = this.calculateProjMatrix(Mi.tileID.toUnwrapped());
                  let Ar;
                  t.isTerrainDEM || (Ar = Or.getMinMaxForTile(Mi.tileID)), Ar || (Ar = { min: Xt, max: ii });
                  const Fr = i.c7(this.rotation), an = [Fr[0] * i.ag, Fr[1] * i.ag, Ar.max];
                  i.ab.vec3.transformMat4(an, an, Er), fr = (1 - an[1]) * this.height * 0.5 < Ni;
                }
                return cr < yi || fr;
              });
            }
            return Ti.sort((yi, Ni) => yi.distanceSq - Ni.distanceSq).map((yi) => yi.tileID);
          }
          resize(t, n) {
            this.width = t, this.height = n, this.pixelsToGLUnits = [2 / t, -2 / n], this._constrain(), this._calcMatrices();
          }
          get unmodified() {
            return this._unmodified;
          }
          zoomScale(t) {
            return Math.pow(2, t);
          }
          scaleZoom(t) {
            return Math.log(t) / Math.LN2;
          }
          project(t) {
            const n = i.aw(t.lat, -i.bX, i.bX), c = this.projection.project(t.lng, n);
            return new i.P(c.x * this.worldSize, c.y * this.worldSize);
          }
          unproject(t) {
            return this.projection.unproject(t.x / this.worldSize, t.y / this.worldSize);
          }
          get point() {
            return this.project(this.center);
          }
          get pointMerc() {
            return this.point._div(this.worldSize);
          }
          get pixelsPerMeterRatio() {
            return this.pixelsPerMeter / i.bH(1, this.center.lat) / this.worldSize;
          }
          setLocationAtPoint(t, n) {
            let c, p;
            const v = this.centerPoint;
            if (this.projection.name === "globe") {
              const V = this.worldSize;
              c = (n.x - v.x) / V, p = (n.y - v.y) / V;
            } else {
              const V = this.pointCoordinate(n), K = this.pointCoordinate(v);
              c = V.x - K.x, p = V.y - K.y;
            }
            const C = this.locationCoordinate(t);
            this.setLocation(new i.aa(C.x - c, C.y - p));
          }
          setLocation(t) {
            this.center = this.coordinateLocation(t), this.projection.wrap && (this.center = this.center.wrap());
          }
          locationPoint(t) {
            return this.projection.locationPoint(this, t);
          }
          locationPoint3D(t) {
            return this.projection.locationPoint(this, t, !0);
          }
          pointLocation(t) {
            return this.coordinateLocation(this.pointCoordinate(t));
          }
          pointLocation3D(t) {
            return this.coordinateLocation(this.pointCoordinate3D(t));
          }
          locationCoordinate(t, n) {
            const c = n ? i.bH(n, t.lat) : void 0, p = this.projection.project(t.lng, t.lat);
            return new i.aa(p.x, p.y, c);
          }
          coordinateLocation(t) {
            return this.projection.unproject(t.x, t.y);
          }
          pointRayIntersection(t, n) {
            const c = n ?? this._centerAltitude, p = [t.x, t.y, 0, 1], v = [t.x, t.y, 1, 1];
            i.ab.vec4.transformMat4(p, p, this.pixelMatrixInverse), i.ab.vec4.transformMat4(v, v, this.pixelMatrixInverse);
            const C = v[3];
            i.ab.vec4.scale(p, p, 1 / p[3]), i.ab.vec4.scale(v, v, 1 / C);
            const V = p[2], K = v[2];
            return { p0: p, p1: v, t: V === K ? 0 : (c - V) / (K - V) };
          }
          screenPointToMercatorRay(t) {
            const n = [t.x, t.y, 0, 1], c = [t.x, t.y, 1, 1];
            return i.ab.vec4.transformMat4(n, n, this.pixelMatrixInverse), i.ab.vec4.transformMat4(c, c, this.pixelMatrixInverse), i.ab.vec4.scale(n, n, 1 / n[3]), i.ab.vec4.scale(c, c, 1 / c[3]), n[2] = i.bH(n[2], this._center.lat) * this.worldSize, c[2] = i.bH(c[2], this._center.lat) * this.worldSize, i.ab.vec4.scale(n, n, 1 / this.worldSize), i.ab.vec4.scale(c, c, 1 / this.worldSize), new i.aq([n[0], n[1], n[2]], i.ab.vec3.normalize([], i.ab.vec3.sub([], c, n)));
          }
          rayIntersectionCoordinate(t) {
            const { p0: n, p1: c, t: p } = t, v = i.bH(n[2], this._center.lat), C = i.bH(c[2], this._center.lat);
            return new i.aa(i.af(n[0], c[0], p) / this.worldSize, i.af(n[1], c[1], p) / this.worldSize, i.af(v, C, p));
          }
          pointCoordinate(t, n = this._centerAltitude) {
            return this.projection.pointCoordinate(this, t.x, t.y, n);
          }
          pointCoordinate3D(t) {
            if (!this.elevation) return this.pointCoordinate(t);
            let n = this.projection.pointCoordinate3D(this, t.x, t.y);
            if (n) return new i.aa(n[0], n[1], n[2]);
            let c = 0, p = this.horizonLineFromTop();
            if (t.y > p) return this.pointCoordinate(t);
            const v = 0.02 * p, C = t.clone();
            for (let V = 0; V < 10 && p - c > v; V++) {
              C.y = i.af(c, p, 0.66);
              const K = this.projection.pointCoordinate3D(this, C.x, C.y);
              K ? (p = C.y, n = K) : c = C.y;
            }
            return n ? new i.aa(n[0], n[1], n[2]) : this.pointCoordinate(t);
          }
          isPointAboveHorizon(t) {
            return this.projection.isPointAboveHorizon(this, t);
          }
          isPointOnSurface(t) {
            if (t.y < 0 || t.y > this.height || t.x < 0 || t.x > this.width) return !1;
            if (this.elevation || this.zoom >= i.bY) return !this.isPointAboveHorizon(t);
            const n = this.pointCoordinate(t);
            return n.y >= 0 && n.y <= 1;
          }
          _coordinatePoint(t, n) {
            const c = n && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude, p = [t.x * this.worldSize, t.y * this.worldSize, c + t.toAltitude(), 1];
            return i.ab.vec4.transformMat4(p, p, this.pixelMatrix), p[3] > 0 ? new i.P(p[0] / p[3], p[1] / p[3]) : new i.P(Number.MAX_VALUE, Number.MAX_VALUE);
          }
          _getBoundsNonRectangular() {
            const { top: t, left: n } = this._edgeInsets, c = this.height - this._edgeInsets.bottom, p = this.width - this._edgeInsets.right, v = this.pointLocation3D(new i.P(n, t)), C = this.pointLocation3D(new i.P(p, t)), V = this.pointLocation3D(new i.P(p, c)), K = this.pointLocation3D(new i.P(n, c));
            let se = Math.min(v.lng, C.lng, V.lng, K.lng), oe = Math.max(v.lng, C.lng, V.lng, K.lng), ve = Math.min(v.lat, C.lat, V.lat, K.lat), xe = Math.max(v.lat, C.lat, V.lat, K.lat);
            const Le = Math.pow(2, -this.zoom) / 16 * 270, ft = this.projection.name === "globe" ? 1 : 4, st = (vt, gt, Rt, qt, jt) => {
              const ii = (vt + Rt) / 2, Xt = (gt + qt) / 2, Kt = new i.P(ii, Xt), { lng: Zt, lat: Jt } = this.pointLocation3D(Kt), ui = Math.max(0, se - Zt, ve - Jt, Zt - oe, Jt - xe);
              se = Math.min(se, Zt), oe = Math.max(oe, Zt), ve = Math.min(ve, Jt), xe = Math.max(xe, Jt), (jt < ft || ui > Le) && (st(vt, gt, ii, Xt, jt + 1), st(ii, Xt, Rt, qt, jt + 1));
            };
            if (st(n, t, p, t, 1), st(p, t, p, c, 1), st(p, c, n, c, 1), st(n, c, n, t, 1), this.projection.name === "globe") {
              const [vt, gt] = i.bZ(this);
              vt ? (xe = 90, oe = 180, se = -180) : gt && (ve = -90, oe = 180, se = -180);
            }
            return new i.az(new i.bO(se, ve), new i.bO(oe, xe));
          }
          _getBoundsRectangular(t, n) {
            const { top: c, left: p } = this._edgeInsets, v = this.height - this._edgeInsets.bottom, C = this.width - this._edgeInsets.right, V = new i.P(p, c), K = new i.P(C, c), se = new i.P(C, v), oe = new i.P(p, v);
            let ve = this.pointCoordinate(V, t), xe = this.pointCoordinate(K, t);
            const Le = this.pointCoordinate(se, n), ft = this.pointCoordinate(oe, n), st = (vt, gt) => (gt.y - vt.y) / (gt.x - vt.x);
            return ve.y > 1 && xe.y >= 0 ? ve = new i.aa((1 - ft.y) / st(ft, ve) + ft.x, 1) : ve.y < 0 && xe.y <= 1 && (ve = new i.aa(-ft.y / st(ft, ve) + ft.x, 0)), xe.y > 1 && ve.y >= 0 ? xe = new i.aa((1 - Le.y) / st(Le, xe) + Le.x, 1) : xe.y < 0 && ve.y <= 1 && (xe = new i.aa(-Le.y / st(Le, xe) + Le.x, 0)), new i.az().extend(this.coordinateLocation(ve)).extend(this.coordinateLocation(xe)).extend(this.coordinateLocation(ft)).extend(this.coordinateLocation(Le));
          }
          _getBoundsRectangularTerrain() {
            const t = this.elevation;
            if (!t.visibleDemTiles.length || t.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
            const n = t.visibleDemTiles.reduce((c, p) => {
              if (p.dem) {
                const v = p.dem.tree;
                c.min = Math.min(c.min, v.minimums[0]), c.max = Math.max(c.max, v.maximums[0]);
              }
              return c;
            }, { min: Number.MAX_VALUE, max: 0 });
            return this._getBoundsRectangular(n.min * t.exaggeration(), n.max * t.exaggeration());
          }
          getBounds() {
            return this.projection.name === "mercator" || this.projection.name === "equirectangular" ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
          }
          horizonLineFromTop(t = !0) {
            const n = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, c = this.height / 2 - n * (1 - this._horizonShift);
            return t ? Math.max(0, c) : c;
          }
          getMaxBounds() {
            return this.maxBounds;
          }
          setMaxBounds(t) {
            this.maxBounds = t, this.minLat = -i.bX, this.maxLat = i.bX, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = i.at(this.minLng) * this.tileSize, this.worldMaxX = i.at(this.maxLng) * this.tileSize, this.worldMinY = i.aA(this.maxLat) * this.tileSize, this.worldMaxY = i.aA(this.minLat) * this.tileSize, this._constrain();
          }
          calculatePosMatrix(t, n) {
            return this.projection.createTileMatrix(this, n, t);
          }
          calculateDistanceTileData(t) {
            const n = t.key, c = this._distanceTileDataCache;
            if (c[n]) return c[n];
            const p = t.canonical, v = 1 / this.height, C = this.cameraWorldSize, V = C / this.zoomScale(p.z), K = (p.x + Math.pow(2, p.z) * t.wrap) * V, se = p.y * V, oe = this.point;
            oe.x *= C / this.worldSize, oe.y *= C / this.worldSize;
            const ve = this.angle, xe = Math.sin(-ve), Le = -Math.cos(-ve);
            return c[n] = { bearing: [xe, Le], center: [(oe.x - K) * v, (oe.y - se) * v], scale: V / i.ag * v }, c[n];
          }
          calculateFogTileMatrix(t) {
            const n = t.key, c = this._fogTileMatrixCache;
            if (c[n]) return c[n];
            const p = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);
            return i.ab.mat4.multiply(p, this.worldToFogMatrix, p), c[n] = new Float32Array(p), c[n];
          }
          calculateProjMatrix(t, n = !1, c = !1) {
            const p = t.key;
            let v;
            if (v = c ? this._expandedProjMatrixCache : n ? this._alignedProjMatrixCache : this._projMatrixCache, v[p]) return v[p];
            const C = this.calculatePosMatrix(t, this.worldSize);
            let V;
            return V = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : c ? this.expandedFarZProjMatrix : n ? this.alignedProjMatrix : this.projMatrix, i.ab.mat4.multiply(C, V, C), v[p] = new Float32Array(C), v[p];
          }
          calculatePixelsToTileUnitsMatrix(t) {
            const n = t.tileID.key, c = this._pixelsToTileUnitsCache;
            if (c[n]) return c[n];
            const p = i.b_(t, this);
            return c[n] = p, c[n];
          }
          customLayerMatrix() {
            return this.mercatorMatrix.slice();
          }
          globeToMercatorMatrix() {
            if (this.projection.name === "globe") {
              const t = 1 / this.worldSize, n = i.ab.mat4.fromScaling([], [t, t, t]);
              return i.ab.mat4.multiply(n, n, this.globeMatrix), n;
            }
          }
          recenterOnTerrain() {
            if (!this._elevation || this.projection.name === "globe") return;
            const t = this._elevation;
            this._updateCameraState();
            const n = i.bH(1, this._center.lat) * this.worldSize, c = this._computeCameraPosition(n), p = this._camera.forward(), v = i.bH(1, this._center.lat);
            c[2] /= v, p[2] /= v, i.ab.vec3.normalize(p, p);
            const C = t.raycast(c, p, t.exaggeration());
            if (C) {
              const V = i.ab.vec3.scaleAndAdd([], c, p, C), K = new i.aa(V[0], V[1], i.bH(V[2], i.aS(V[1]))), se = (K.z + i.ab.vec3.length([K.x - c[0], K.y - c[1], K.z - c[2] * v])) * this._pixelsPerMercatorPixel;
              this._seaLevelZoom = this._zoomFromMercatorZ(se), this._centerAltitude = K.toAltitude(), this._center = this.coordinateLocation(K), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
            }
          }
          _constrainCamera(t = !1) {
            if (!this._elevation) return;
            const n = this._elevation, c = i.bH(1, this._center.lat) * this.worldSize, p = this._computeCameraPosition(c), v = n.getAtPointOrZero(new i.aa(...p)), C = this.pixelsPerMeter / this.worldSize * v, V = this._minimumHeightOverTerrain(), K = p[2] - C;
            if (K <= V) if (K < 0 || t) {
              const se = this.locationCoordinate(this._center, this._centerAltitude), oe = [p[0], p[1], se.z - p[2]], ve = i.ab.vec3.length(oe);
              oe[2] -= (V - K) / this._pixelsPerMercatorPixel;
              const xe = i.ab.vec3.length(oe);
              if (xe === 0) return;
              i.ab.vec3.scale(oe, oe, ve / xe * this._pixelsPerMercatorPixel), this._camera.position = [p[0], p[1], se.z * this._pixelsPerMercatorPixel - oe[2]], this._updateStateFromCamera();
            } else this._isCameraConstrained = !0;
          }
          _constrain() {
            if (!this.center || !this.width || !this.height || this._constraining) return;
            this._constraining = !0;
            const t = this.projection.name === "globe" || this.mercatorFromTransition;
            if (this.projection.isReprojectedInTileSpace || t) {
              const xe = this.center;
              return xe.lat = i.aw(xe.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (xe.lng = i.aw(xe.lng, this.minLng, this.maxLng)), this.center = xe, void (this._constraining = !1);
            }
            const n = this._unmodified, { x: c, y: p } = this.point;
            let v = 0, C = c, V = p;
            const K = this.width / 2, se = this.height / 2, oe = this.worldMinY * this.scale, ve = this.worldMaxY * this.scale;
            if (p - se < oe && (V = oe + se), p + se > ve && (V = ve - se), ve - oe < this.height && (v = Math.max(v, this.height / (ve - oe)), V = (ve + oe) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
              const xe = this.worldMinX * this.scale, Le = this.worldMaxX * this.scale, ft = this.worldSize / 2 - (xe + Le) / 2;
              C = (c + ft + this.worldSize) % this.worldSize - ft, C - K < xe && (C = xe + K), C + K > Le && (C = Le - K), Le - xe < this.width && (v = Math.max(v, this.width / (Le - xe)), C = (Le + xe) / 2);
            }
            C === c && V === p || (this.center = this.unproject(new i.P(C, V))), v && (this.zoom += this.scaleZoom(v)), this._constrainCamera(), this._unmodified = n, this._constraining = !1;
          }
          _minZoomForBounds() {
            let t = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
            return this.maxBounds && (t = Math.max(t, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), t;
          }
          _maxCameraBoundsDistance() {
            return this._mercatorZfromZoom(this._minZoomForBounds());
          }
          _calcMatrices() {
            if (!this.height) return;
            const t = this.centerOffset, n = this.projection.name === "globe", c = this.pixelsPerMeter;
            this.projection.name === "globe" && (this._mercatorScaleRatio = i.bH(1, this.center.lat) / i.bH(1, i.c8));
            const p = i.b$(this.projection, this.zoom, this.width, this.height, 1024);
            this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, p), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
            const v = this.projection.zAxisUnit === "meters" ? c : 1, C = this._camera.getWorldToCamera(this.worldSize, v);
            let V;
            const K = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
            if (K[8] = 2 * -t.x / this.width, K[9] = 2 * t.y / this.height, this.isOrthographic) {
              let Jt = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), ui = Jt * this.aspect, Ti = -ui, xi = -Jt;
              ui -= t.x, Ti -= t.x, Jt += t.y, xi += t.y, V = this._camera.getCameraToClipOrthographic(Ti, ui, xi, Jt, this._nearZ, this._farZ), ((Pi, Ri, mi, Ai) => {
                for (let ji = 0; ji < 16; ji++) Pi[ji] = fl(Ri[ji], mi[ji], Ai);
              })(V, V, K, Mo(this.pitch >= 15 ? 1 : this.pitch / 15));
            } else V = K;
            const se = i.ab.mat4.mul([], K, C);
            let oe = i.ab.mat4.mul([], V, C);
            if (this.projection.isReprojectedInTileSpace) {
              const Jt = this.locationCoordinate(this.center), ui = i.ab.mat4.identity([]);
              i.ab.mat4.translate(ui, ui, [Jt.x * this.worldSize, Jt.y * this.worldSize, 0]), i.ab.mat4.multiply(ui, ui, i.c0(this)), i.ab.mat4.translate(ui, ui, [-Jt.x * this.worldSize, -Jt.y * this.worldSize, 0]), i.ab.mat4.multiply(oe, oe, ui), i.ab.mat4.multiply(se, se, ui), this.inverseAdjustmentMatrix = i.c1(this);
            } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
            if (this.mercatorMatrix = i.ab.mat4.scale([], oe, [this.worldSize, this.worldSize, this.worldSize / v, 1]), this.projMatrix = oe, this.invProjMatrix = i.ab.mat4.invert(new Float64Array(16), this.projMatrix), n) {
              const Jt = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
              Jt[8] = 2 * -t.x / this.width, Jt[9] = 2 * t.y / this.height, this.expandedFarZProjMatrix = i.ab.mat4.mul([], Jt, C);
            } else this.expandedFarZProjMatrix = this.projMatrix;
            const ve = i.ab.mat4.invert([], V);
            this.frustumCorners = i.c2.fromInvProjectionMatrix(ve, this.horizonLineFromTop(), this.height), this.cameraFrustum = i.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !n);
            const xe = new Float32Array(16);
            i.ab.mat4.identity(xe), i.ab.mat4.scale(xe, xe, [1, -1, 1]), i.ab.mat4.rotateX(xe, xe, this._pitch), i.ab.mat4.rotateZ(xe, xe, this.angle);
            const Le = i.ab.mat4.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
            this.starsProjMatrix = i.ab.mat4.clone(Le);
            const ft = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
            Le[8] = 2 * -t.x / this.width, Le[9] = 2 * (t.y + ft) / this.height, this.skyboxMatrix = i.ab.mat4.multiply(xe, Le, xe);
            const st = this.point, vt = st.x, gt = st.y, Rt = this.width % 2 / 2, qt = this.height % 2 / 2, jt = Math.cos(this.angle), ii = Math.sin(this.angle), Xt = vt - Math.round(vt) + jt * Rt + ii * qt, Kt = gt - Math.round(gt) + jt * qt + ii * Rt, Zt = new Float64Array(oe);
            if (i.ab.mat4.translate(Zt, Zt, [Xt > 0.5 ? Xt - 1 : Xt, Kt > 0.5 ? Kt - 1 : Kt, 0]), this.alignedProjMatrix = Zt, oe = i.ab.mat4.create(), i.ab.mat4.scale(oe, oe, [this.width / 2, -this.height / 2, 1]), i.ab.mat4.translate(oe, oe, [1, -1, 0]), this.labelPlaneMatrix = oe, oe = i.ab.mat4.create(), i.ab.mat4.scale(oe, oe, [1, -1, 1]), i.ab.mat4.translate(oe, oe, [-1, -1, 0]), i.ab.mat4.scale(oe, oe, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = oe, this.pixelMatrix = i.ab.mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, se), this._calcFogMatrices(), this._distanceTileDataCache = {}, oe = i.ab.mat4.invert(new Float64Array(16), this.pixelMatrix), !oe) throw new Error("failed to invert matrix");
            if (this.pixelMatrixInverse = oe, this.projection.name === "globe" || this.mercatorFromTransition) {
              this.globeMatrix = i.c3(this);
              const Jt = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
              this.globeCenterInViewSpace = i.ab.vec3.transformMat4(Jt, Jt, C), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
            } else this.globeMatrix = oe;
            this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
          }
          _calcFogMatrices() {
            this._fogTileMatrixCache = {};
            const t = this.cameraWorldSizeForFog, n = this.cameraPixelsPerMeter, c = this._camera.position, p = 1 / this.height / this._pixelsPerMercatorPixel, v = [t, t, n];
            i.ab.vec3.scale(v, v, p), i.ab.vec3.scale(c, c, -1), i.ab.vec3.multiply(c, c, v);
            const C = i.ab.mat4.create();
            i.ab.mat4.translate(C, C, c), i.ab.mat4.scale(C, C, v), this.mercatorFogMatrix = C, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, n, p);
          }
          _computeCameraPosition(t) {
            const n = (t = t || this.pixelsPerMeter) / this.pixelsPerMeter, c = this._camera.forward(), p = this.point, v = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * n - t / this.worldSize * this._centerAltitude;
            return [p.x / this.worldSize - c[0] * v, p.y / this.worldSize - c[1] * v, t / this.worldSize * this._centerAltitude - c[2] * v];
          }
          _updateCameraState() {
            this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
          }
          _translateCameraConstrained(t) {
            const n = this._maxCameraBoundsDistance() * Math.cos(this._pitch), c = this._camera.position[2], p = t[2];
            let v = 1;
            this.projection.wrap && (this.center = this.center.wrap()), p > 0 && (v = Math.min((n - c) / p, 1)), this._camera.position = i.ab.vec3.scaleAndAdd([], this._camera.position, t, v), this._updateStateFromCamera();
          }
          _updateStateFromCamera() {
            const t = this._camera.position, n = this._camera.forward(), { pitch: c, bearing: p } = this._camera.getPitchBearing(), v = i.bH(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, C = this._mercatorZfromZoom(this._maxZoom) * Math.cos(i.ai(this._maxPitch)), V = Math.max((t[2] - v) / Math.cos(c), C), K = this._zoomFromMercatorZ(V);
            i.ab.vec3.scaleAndAdd(t, t, n, V), this._pitch = i.aw(c, i.ai(this.minPitch), i.ai(this.maxPitch)), this.angle = i.bF(p, -Math.PI, Math.PI), this._setZoom(i.aw(K, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new i.aa(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
          }
          _worldSizeFromZoom(t) {
            return Math.pow(2, t) * this.tileSize;
          }
          _mercatorZfromZoom(t) {
            return this.cameraToCenterDistance / this._worldSizeFromZoom(t);
          }
          _minimumHeightOverTerrain() {
            const t = Math.min(this._seaLevelZoom != null ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
            return this._mercatorZfromZoom(t);
          }
          _zoomFromMercatorZ(t) {
            return this.scaleZoom(this.cameraToCenterDistance / (t * this.tileSize));
          }
          zoomFromMercatorZAdjusted(t) {
            let n = 0, c = i.bY, p = 0, v = 1 / 0;
            for (; c - n > 1e-6 && c > n; ) {
              const C = n + 0.5 * (c - n), V = this.tileSize * Math.pow(2, C), K = this.getCameraToCenterDistance(this.projection, C, V), se = this.scaleZoom(K / (t * this.tileSize)), oe = Math.abs(C - se);
              oe < v && (v = oe, p = C), C < se ? n = C : c = C;
            }
            return p;
          }
          _terrainEnabled() {
            return !(!this._elevation || !this.projection.supportsTerrain && (i.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
          }
          anyCornerOffEdge(t, n) {
            const c = Math.min(t.x, n.x), p = Math.max(t.x, n.x), v = Math.min(t.y, n.y), C = Math.max(t.y, n.y);
            if (v < this.horizonLineFromTop(!1)) return !0;
            if (this.projection.name !== "mercator") return !1;
            const V = [new i.P(c, v), new i.P(p, C), new i.P(c, C), new i.P(p, v)], K = this.renderWorldCopies ? -3 : 0, se = this.renderWorldCopies ? 4 : 1;
            for (const oe of V) {
              const ve = this.pointRayIntersection(oe);
              if (ve.t < 0) return !0;
              const xe = this.rayIntersectionCoordinate(ve);
              if (xe.x < K || xe.y < 0 || xe.x > se || xe.y > 1) return !0;
            }
            return !1;
          }
          isHorizonVisible() {
            return this.pitch + i.c4(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new i.P(0, 0), new i.P(this.width, this.height));
          }
          zoomDeltaToMovement(t, n) {
            const c = i.ab.vec3.length(i.ab.vec3.sub([], this._camera.position, t)), p = this._zoomFromMercatorZ(c) + n;
            return c - this._mercatorZfromZoom(p);
          }
          getCameraPoint() {
            if (this.projection.name === "globe") {
              const t = function([n, c, p], v) {
                const C = [n, c, p, 1];
                i.ab.vec4.transformMat4(C, C, v);
                const V = C[3] = Math.max(C[3], 1e-6);
                return C[0] /= V, C[1] /= V, C[2] /= V, C;
              }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
              return new i.P(t[0], t[1]);
            }
            {
              const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new i.P(0, t));
            }
          }
          getCameraToCenterDistance(t, n = this.zoom, c = this.worldSize) {
            const p = i.b$(t, n, this.width, this.height, 1024), v = t.pixelSpaceConversion(this.center.lat, c, p);
            let C = 0.5 / Math.tan(0.5 * this._fov) * this.height * v;
            return this.isOrthographic && (C = fl(1, C, Mo(this.pitch >= 15 ? 1 : this.pitch / 15))), C;
          }
          getWorldToCameraMatrix() {
            const t = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === "meters" ? this.pixelsPerMeter : 1);
            return this.projection.name === "globe" && i.ab.mat4.multiply(t, t, this.globeMatrix), t;
          }
          getFrustum(t) {
            return i.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t, this.projection.zAxisUnit === "meters");
          }
        }
        const Ps = (u, t) => {
          if (t > 0 && u.terrain && i.w("Cutoff is currently disabled on terrain"), t <= 0 || u.terrain) return { shouldRenderCutoff: !1, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
          const n = u.transform, c = Math.max(Math.abs(n._zoom - (u.minCutoffZoom - 1)), 1), p = n.isLODDisabled(!1) ? i.ac(60, 45, n.pitch) : i.ac(30, 15, n.pitch), v = n._farZ - n._nearZ, C = t * n.height, V = ((1 - (K = p)) * n.cameraToCenterDistance + K * (n._farZ + C)) * c;
          var K;
          return { shouldRenderCutoff: p < 1, uniformValues: { u_cutoff_params: [n._nearZ, n._farZ, (V - n._nearZ) / v, (V - C - n._nearZ) / v] } };
        }, ya = { cascadeCount: 2, normalOffset: 3, shadowMapResolution: 2048 };
        class xa {
          constructor(t, n) {
            this.aabb = t, this.lastCascade = n;
          }
        }
        class jo {
          add(t, n) {
            const c = this.receivers[t.key];
            c !== void 0 ? (c.aabb.min[0] = Math.min(c.aabb.min[0], n.min[0]), c.aabb.min[1] = Math.min(c.aabb.min[1], n.min[1]), c.aabb.min[2] = Math.min(c.aabb.min[2], n.min[2]), c.aabb.max[0] = Math.max(c.aabb.max[0], n.max[0]), c.aabb.max[1] = Math.max(c.aabb.max[1], n.max[1]), c.aabb.max[2] = Math.max(c.aabb.max[2], n.max[2])) : this.receivers[t.key] = new xa(n, null);
          }
          clear() {
            this.receivers = {};
          }
          get(t) {
            return this.receivers[t.key];
          }
          computeRequiredCascades(t, n, c) {
            const p = i.cd.fromPoints(t.points);
            let v = 0;
            for (const C in this.receivers) {
              const V = this.receivers[C];
              if (!V || !p.intersectsAabb(V.aabb)) continue;
              V.aabb.min = p.closestPoint(V.aabb.min), V.aabb.max = p.closestPoint(V.aabb.max);
              const K = V.aabb.getCorners();
              for (let se = 0; se < c.length; se++) {
                let oe = !0;
                for (const ve of K) {
                  const xe = [ve[0] * n, ve[1] * n, ve[2]];
                  if (i.ab.vec3.transformMat4(xe, xe, c[se].matrix), xe[0] < -1 || xe[0] > 1 || xe[1] < -1 || xe[1] > 1) {
                    oe = !1;
                    break;
                  }
                }
                if (V.lastCascade = se, v = Math.max(v, se), oe) break;
              }
            }
            return v + 1;
          }
        }
        class dl {
          constructor(t) {
            this.painter = t, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new jo(), this._depthMode = new Sr(t.context.gl.LEQUAL, Sr.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = !1, this.useNormalOffset = !1, t.tp.registerParameter(this, ["Shadows"], "_forceDisable", { label: "forceDisable" }, () => {
              this.painter.style.map.triggerRepaint();
            }), t.tp.registerParameter(ya, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), t.tp.registerParameter(ya, ["Shadows"], "normalOffset", { min: 0, max: 10, step: 0.05 }), t.tp.registerParameter(ya, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 }), t.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", { readonly: !0, label: "numCascadesToRender" });
          }
          destroy() {
            for (const t of this._cascades) t.texture.destroy(), t.framebuffer.destroy();
            this._cascades = [];
          }
          updateShadowParameters(t, n) {
            const c = this.painter;
            if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !n || !n.properties) return;
            const p = n.properties.get("shadow-intensity");
            if (!n.shadowsEnabled() || p <= 0 || (this._shadowLayerCount = c.style.order.reduce((ft, st) => {
              const vt = c.style._mergedLayers[st];
              return ft + (vt.hasShadowPass() && !vt.isHidden(t.zoom) ? 1 : 0);
            }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled)) return;
            const v = c.context, C = ya.shadowMapResolution, V = ya.shadowMapResolution;
            if (this._cascades.length === 0 || ya.shadowMapResolution !== this._cascades[0].texture.size[0]) {
              this._cascades = [];
              for (let ft = 0; ft < ya.cascadeCount; ++ft) {
                const st = c._shadowMapDebug, vt = v.gl, gt = v.createFramebuffer(C, V, st, "texture"), Rt = new i.T(v, { width: C, height: V, data: null }, vt.DEPTH_COMPONENT16);
                if (gt.depthAttachment.set(Rt.texture), st) {
                  const qt = new i.T(v, { width: C, height: V, data: null }, vt.RGBA8);
                  gt.colorAttachment.set(qt.texture);
                }
                this._cascades.push({ framebuffer: gt, texture: Rt, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new i.bR(), scale: 0 });
              }
            }
            this.shadowDirection = no(n);
            let K = 0;
            if (t.elevation) {
              const ft = t.elevation, st = [1e4, -1e4];
              ft.visibleDemTiles.filter((vt) => vt.dem).forEach((vt) => {
                const gt = vt.dem.tree;
                st[0] = Math.min(st[0], gt.minimums[0]), st[1] = Math.max(st[1], gt.maximums[0]);
              }), st[0] !== 1e4 && (K = (st[1] - st[0]) * ft.exaggeration());
            }
            const se = 1.5 * t.cameraToCenterDistance, oe = 3 * se, ve = new Float64Array(16);
            for (let ft = 0; ft < this._cascades.length; ++ft) {
              const st = this._cascades[ft];
              let vt = t.height / 50, gt = 1;
              ya.cascadeCount === 1 ? gt = oe : ft === 0 ? gt = se : (vt = se, gt = oe);
              const [Rt, qt] = oh(t, this.shadowDirection, vt, gt, ya.shadowMapResolution, K);
              st.scale = t.scale, st.matrix = Rt, st.boundingSphereRadius = qt, i.ab.mat4.invert(ve, st.matrix), st.frustum = i.bR.fromInvProjectionMatrix(ve, 1, 0, !0), st.far = gt;
            }
            const xe = this._cascades.length - 1;
            this._uniformValues.u_fade_range = [0.75 * this._cascades[xe].far, this._cascades[xe].far], this._uniformValues.u_shadow_intensity = p, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / ya.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = ya.shadowMapResolution, this._uniformValues.u_shadowmap_0 = $a.ShadowMap0, this._uniformValues.u_shadowmap_1 = $a.ShadowMap0 + 1, this._groundShadowTiles = c.transform.coveringTiles({ tileSize: 512, renderWorldCopies: !0 });
            const Le = c.transform.elevation;
            for (const ft of this._groundShadowTiles) {
              let st = { min: 0, max: 0 };
              if (Le) {
                const vt = Le.getMinMaxForTile(ft);
                vt && (st = vt);
              }
              this.addShadowReceiver(ft.toUnwrapped(), st.min, st.max);
            }
          }
          get enabled() {
            return this._enabled && !this._forceDisable;
          }
          set enabled(t) {
            this._enabled = t;
          }
          drawShadowPass(t, n) {
            if (!this.enabled) return;
            const c = this.painter, p = c.context;
            this._numCascadesToRender = this._receivers.computeRequiredCascades(c.transform.getFrustum(0), c.transform.worldSize, this._cascades), p.viewport.set([0, 0, ya.shadowMapResolution, ya.shadowMapResolution]);
            for (let v = 0; v < this._numCascadesToRender; ++v) {
              c.currentShadowCascade = v, p.bindFramebuffer.set(this._cascades[v].framebuffer.framebuffer), p.clear({ color: i.aj.white, depth: 1 });
              for (const C of t.order) {
                const V = t._mergedLayers[C];
                if (!V.hasShadowPass() || V.isHidden(c.transform.zoom)) continue;
                const K = t.getLayerSourceCache(V), se = K ? n[K.id] : void 0;
                (V.type === "model" || se && se.length) && c.renderLayer(c, K, V, se);
              }
            }
            c.currentShadowCascade = 0;
          }
          drawGroundShadows() {
            if (!this.enabled) return;
            const t = this.painter, n = t.style, c = t.context, p = n.directionalLight, v = n.ambientLight;
            if (!p || !v) return;
            const C = [], V = Ps(t, t.longestCutoffRange);
            V.shouldRenderCutoff && C.push("RENDER_CUTOFF"), C.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && C.push("NORMAL_OFFSET");
            const K = pl(n, p, v), se = new Sr(c.gl.LEQUAL, Sr.ReadOnly, t.depthRangeFor3D);
            for (const oe of this._groundShadowTiles) {
              const ve = oe.toUnwrapped(), xe = t.isTileAffectedByFog(oe), Le = t.getOrCreateProgram("groundShadow", { defines: C, overrideFog: xe });
              this.setupShadows(ve, Le), t.uploadCommonUniforms(c, Le, ve, null, V);
              const ft = { u_matrix: t.transform.calculateProjMatrix(ve), u_ground_shadow_factor: K };
              Le.draw(t, c.gl.TRIANGLES, se, Lr.disabled, zr.multiply, kr.disabled, ft, "ground_shadow", t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments, {}, t.transform.zoom, null, null);
            }
          }
          getShadowPassColorMode() {
            return this.painter._shadowMapDebug ? zr.unblended : zr.disabled;
          }
          getShadowPassDepthMode() {
            return this._depthMode;
          }
          getShadowCastingLayerCount() {
            return this._shadowLayerCount;
          }
          calculateShadowPassMatrixFromTile(t) {
            const n = this.painter.transform, c = n.calculatePosMatrix(t, n.worldSize);
            return i.ab.mat4.multiply(c, this._cascades[this.painter.currentShadowCascade].matrix, c), Float32Array.from(c);
          }
          calculateShadowPassMatrixFromMatrix(t) {
            return i.ab.mat4.multiply(t, this._cascades[this.painter.currentShadowCascade].matrix, t), Float32Array.from(t);
          }
          setupShadows(t, n, c, p = 0) {
            if (!this.enabled) return;
            const v = this.painter.transform, C = this.painter.context, V = C.gl, K = this._uniformValues, se = new Float64Array(16), oe = v.calculatePosMatrix(t, v.worldSize);
            for (let ve = 0; ve < this._cascades.length; ve++) i.ab.mat4.multiply(se, this._cascades[ve].matrix, oe), K[ve === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(se), C.activeTexture.set(V.TEXTURE0 + $a.ShadowMap0 + ve), this._cascades[ve].texture.bind(V.NEAREST, V.CLAMP_TO_EDGE);
            if (this.useNormalOffset = !!c, this.useNormalOffset) {
              const ve = i.cc(t.canonical), xe = 2 / v.tileSize * i.ag / ya.shadowMapResolution, Le = xe * this._cascades[0].boundingSphereRadius, ft = xe * this._cascades[this._cascades.length - 1].boundingSphereRadius, st = (c === "vector-tile" ? 1 : 3) / Math.pow(2, p - t.canonical.z - (1 - v.zoom + Math.floor(v.zoom)));
              K.u_shadow_normal_offset = [ve, Le * st, ft * st], K.u_shadow_bias = [6e-5, 12e-4, 0.012];
            } else K.u_shadow_bias = [36e-5, 12e-4, 0.012];
            n.setShadowUniformValues(C, K);
          }
          setupShadowsFromMatrix(t, n, c = !1) {
            if (!this.enabled) return;
            const p = this.painter.context, v = p.gl, C = this._uniformValues, V = new Float64Array(16);
            for (let K = 0; K < ya.cascadeCount; K++) i.ab.mat4.multiply(V, this._cascades[K].matrix, t), C[K === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(V), p.activeTexture.set(v.TEXTURE0 + $a.ShadowMap0 + K), this._cascades[K].texture.bind(v.NEAREST, v.CLAMP_TO_EDGE);
            if (this.useNormalOffset = c, c) {
              const K = ya.normalOffset;
              C.u_shadow_normal_offset = [1, K, K], C.u_shadow_bias = [6e-5, 12e-4, 0.012];
            } else C.u_shadow_bias = [36e-5, 12e-4, 0.012];
            n.setShadowUniformValues(p, C);
          }
          getShadowUniformValues() {
            return this._uniformValues;
          }
          getCurrentCascadeFrustum() {
            return this._cascades[this.painter.currentShadowCascade].frustum;
          }
          computeSimplifiedTileShadowVolume(t, n, c, p) {
            if (p[2] >= 0) return {};
            const v = function(K, se, oe) {
              const ve = oe / (1 << K.canonical.z);
              return new i.cd([K.canonical.x * ve + K.wrap * oe, K.canonical.y * ve + K.wrap * oe, 0], [(K.canonical.x + 1) * ve + K.wrap * oe, (K.canonical.y + 1) * ve + K.wrap * oe, se]);
            }(t, n, c).getCorners(), C = n / -p[2];
            p[0] < 0 ? (i.ab.vec3.add(v[0], v[0], [p[0] * C, 0, 0]), i.ab.vec3.add(v[3], v[3], [p[0] * C, 0, 0])) : p[0] > 0 && (i.ab.vec3.add(v[1], v[1], [p[0] * C, 0, 0]), i.ab.vec3.add(v[2], v[2], [p[0] * C, 0, 0])), p[1] < 0 ? (i.ab.vec3.add(v[0], v[0], [0, p[1] * C, 0]), i.ab.vec3.add(v[1], v[1], [0, p[1] * C, 0])) : p[1] > 0 && (i.ab.vec3.add(v[2], v[2], [0, p[1] * C, 0]), i.ab.vec3.add(v[3], v[3], [0, p[1] * C, 0]));
            const V = {};
            return V.vertices = v, V.planes = [Go(v[1], v[0], v[4]), Go(v[2], v[1], v[5]), Go(v[3], v[2], v[6]), Go(v[0], v[3], v[7])], V;
          }
          addShadowReceiver(t, n, c) {
            this._receivers.add(t, i.cd.fromTileIdAndHeight(t, n, c));
          }
          getMaxCascadeForTile(t) {
            const n = this._receivers.get(t);
            return n && n.lastCascade ? n.lastCascade : 0;
          }
        }
        function Go(u, t, n) {
          const c = i.ab.vec3.sub([], n, t), p = i.ab.vec3.sub([], u, t), v = i.ab.vec3.cross([], c, p), C = i.ab.vec3.length(v);
          return C === 0 ? [0, 0, 1, 0] : (i.ab.vec3.scale(v, v, 1 / C), [v[0], v[1], v[2], -i.ab.vec3.dot(v, t)]);
        }
        function no(u) {
          const t = u.properties.get("direction"), n = i.cb(t.x, t.y, t.z);
          n[2] = i.aw(n[2], 0, 75);
          const c = i.ce([n[0], n[1], n[2]]);
          return i.ab.vec3.fromValues(c.x, c.y, c.z);
        }
        function pl(u, t, n) {
          const c = t.properties.get("color-use-theme") === "none", p = t.properties.get("color"), v = t.properties.get("intensity"), C = t.properties.get("direction"), V = [C.x, C.y, C.z], K = n.properties.get("color-use-theme") === "none", se = n.properties.get("color"), oe = n.properties.get("intensity"), ve = Math.max(i.ab.vec3.dot([0, 0, 1], V), 0), xe = [0, 0, 0];
          i.ab.vec3.scale(xe, se.toRenderColor(K ? null : u.getLut(t.scope)).toArray01Linear().slice(0, 3), oe);
          const Le = [0, 0, 0];
          return i.ab.vec3.scale(Le, p.toRenderColor(c ? null : u.getLut(n.scope)).toArray01Linear().slice(0, 3), ve * v), i.cf([xe[0] > 0 ? xe[0] / (xe[0] + Le[0]) : 0, xe[1] > 0 ? xe[1] / (xe[1] + Le[1]) : 0, xe[2] > 0 ? xe[2] / (xe[2] + Le[2]) : 0]);
        }
        function oh(u, t, n, c, p, v) {
          const C = u.zoom, V = u.scale, K = u.worldSize, se = 1 / K, oe = u.aspect, ve = Math.sqrt(1 + oe * oe) * Math.tan(0.5 * u.fovX), xe = ve * ve, Le = c - n, ft = c + n;
          let st, vt;
          xe > Le / ft ? (st = c, vt = c * ve) : (st = 0.5 * ft * (1 + xe), vt = 0.5 * Math.sqrt(Le * Le + 2 * (c * c + n * n) * xe + ft * ft * xe * xe));
          const gt = u.projection.pixelsPerMeter(u.center.lat, K), Rt = u._camera.getCameraToWorldMercator(), qt = [0, 0, -st * se];
          i.ab.vec3.transformMat4(qt, qt, Rt);
          let jt = vt * se;
          const ii = u._edgeInsets;
          if (!(ii.left === 0 && ii.top === 0 && ii.right === 0 && ii.bottom === 0 || ii.left === ii.right && ii.top === ii.bottom)) {
            const Yi = u._camera.getWorldToCamera(u.worldSize, u.projection.zAxisUnit === "meters" ? gt : 1), Ui = u._camera.getCameraToClipPerspective(u._fov, u.width / u.height, n, c);
            Ui[8] = 2 * -u.centerOffset.x / u.width, Ui[9] = 2 * u.centerOffset.y / u.height;
            const Fi = new Float64Array(16);
            i.ab.mat4.mul(Fi, Ui, Yi);
            const Zi = new Float64Array(16);
            i.ab.mat4.invert(Zi, Fi);
            const ir = i.bR.fromInvProjectionMatrix(Zi, K, C, !0);
            for (const cr of ir.points) {
              const fr = ((Xt = cr)[0] /= V, Xt[1] /= V, Xt[2] = i.bH(Xt[2], u._center.lat), Xt);
              jt = Math.max(jt, i.ab.vec3.len(i.ab.vec3.subtract([], qt, fr)));
            }
          }
          var Xt;
          jt *= p / (p - 1);
          const Kt = Math.acos(t[2]), Zt = Math.atan2(-t[0], -t[1]), Jt = new Pa();
          Jt.position = qt, Jt.setPitchBearing(Kt, Zt);
          const ui = Jt.getWorldToCamera(K, gt), Ti = jt * K, xi = Math.min(u._mercatorZfromZoom(17) * K * -2, -2 * Ti), Pi = Jt.getCameraToClipOrthographic(-Ti, Ti, -Ti, Ti, xi, (Ti + v * gt) / t[2]), Ri = new Float64Array(16);
          i.ab.mat4.multiply(Ri, Pi, ui);
          const mi = i.ab.vec3.fromValues(Math.floor(1e6 * qt[0]) / 1e6 * K, Math.floor(1e6 * qt[1]) / 1e6 * K, 0), Ai = 0.5 * p, ji = [0, 0, 0];
          i.ab.vec3.transformMat4(ji, mi, Ri), i.ab.vec3.scale(ji, ji, Ai);
          const yi = [Math.floor(ji[0]), Math.floor(ji[1]), Math.floor(ji[2])], Ni = [0, 0, 0];
          i.ab.vec3.sub(Ni, ji, yi), i.ab.vec3.scale(Ni, Ni, -1 / Ai);
          const Mi = new Float64Array(16);
          return i.ab.mat4.identity(Mi), i.ab.mat4.translate(Mi, Mi, Ni), i.ab.mat4.multiply(Ri, Mi, Ri), [Ri, Ti];
        }
        class Ho extends i.E {
          constructor(t) {
            super(), this.requestManager = t, this.models = { "": {} }, this.modelUris = { "": {} }, this.numModelsLoading = {};
          }
          loadModel(t, n) {
            return i.aM(this.requestManager.transformRequest(n, i.R.Model).url).then((c) => {
              if (!c) return;
              const p = i.aN(c), v = new i.aO(t, void 0, void 0, p);
              return v.computeBoundsAndApplyParent(), v;
            }).catch((c) => {
              if (c && c.status === 404) return null;
              this.fire(new i.y(new Error(`Could not load model ${t} from ${n}: ${c.message}`)));
            });
          }
          load(t, n, c = { keepNumReferences: !1 }) {
            this.models[n] || (this.models[n] = {});
            const p = Object.keys(t);
            this.numModelsLoading[n] = (this.numModelsLoading[n] || 0) + p.length;
            const v = [];
            for (const C of p) v.push(this.loadModel(C, t[C]));
            Promise.allSettled(v).then((C) => {
              for (let V = 0; V < C.length; V++) {
                const { status: K, value: se } = C[V];
                if (K === "fulfilled" && se) {
                  const oe = this.models[n][p[V]];
                  this.models[n][p[V]] = { model: se, numReferences: c.keepNumReferences && oe ? oe.numReferences : 1 };
                }
              }
              this.numModelsLoading[n] -= p.length, this.fire(new i.z("data", { dataType: "style" }));
            }).catch((C) => {
              this.fire(new i.y(new Error(`Could not load models: ${C.message}`)));
            });
          }
          isLoaded() {
            for (const t in this.numModelsLoading) if (this.numModelsLoading[t] > 0) return !1;
            return !0;
          }
          hasModel(t, n) {
            return !!this.getModel(t, n);
          }
          getModel(t, n) {
            return this.models[n] || (this.models[n] = {}), this.models[n][t] ? this.models[n][t].model : void 0;
          }
          addModel(t, n, c) {
            this.models[c] || (this.models[c] = {}), this.modelUris[c] || (this.modelUris[c] = {}), this.hasModel(t, c) && this.models[c][t].numReferences++, this.modelUris[c][t] = this.requestManager.normalizeModelURL(n), this.load({ [t]: this.modelUris[c][t] }, c);
          }
          addModels(t, n) {
            this.models[n] || (this.models[n] = {}), this.modelUris[n] || (this.modelUris[n] = {});
            const c = this.modelUris[n];
            for (const p in t) this.models[n][p] = {}, c[p] = this.requestManager.normalizeModelURL(t[p]);
            this.load(c, n, { keepNumReferences: !0 });
          }
          reloadModels(t) {
            this.load(this.modelUris[t], t);
          }
          addModelsFromBucket(t, n) {
            this.models[n] || (this.models[n] = {}), this.modelUris[n] || (this.modelUris[n] = {});
            const c = {};
            for (const p of t) this.hasModel(p, n) ? this.models[n][p].numReferences++ : (this.modelUris[n][p] = this.requestManager.normalizeModelURL(p), c[p] = this.modelUris[n][p]);
            this.load(c, n);
          }
          removeModel(t, n) {
            if (this.models[n] && this.models[n][t] && (this.models[n][t].numReferences--, this.models[n][t].numReferences === 0)) {
              const c = this.models[n][t].model;
              delete this.models[n][t], delete this.modelUris[n][t], c.destroy();
            }
          }
          listModels(t) {
            return this.models[t] || (this.models[t] = {}), Object.keys(this.models[t]);
          }
          upload(t, n) {
            this.models[n] || (this.models[n] = {});
            for (const c in this.models[n]) this.models[n][c].model && this.models[n][c].model.upload(t.context);
          }
        }
        const Ku = new i.a5({ data: new i.a6(i.a3.colorTheme.data) }), lh = { "mbx-indoor-active-floorplans": { default: ["literal", []] }, "mbx-indoor-underground": { default: ["literal", !1] }, "mbx-indoor-loaded-levels": { default: ["literal", []] }, "mbx-indoor-level-height": { default: ["literal", {}] }, "mbx-indoor-level-base": { default: ["literal", {}] }, "mbx-indoor-level-selected": { default: ["literal", {}] }, "mbx-indoor-level-overlapped": { default: ["literal", {}] } };
        function Rc(u) {
          return u = u || {}, Object.assign(u, lh);
        }
        class Ju extends i.E {
          constructor(t) {
            super(), this.mergeFloors = !0, this._scope = void 0, this._queryFeatureSetId = void 0, this._buildingEntryFeatureSetId = void 0, this._selectedFloorplan = void 0, this._indoorData = void 0, this._selectedLevel = void 0, this._floorplanStates = {}, i.aP(["_onLoad", "_onMove", "_checkFloorplanVisible"], this), this._map = t, this._checkFloorplanVisible(!0), this._map.on("load", this._onLoad), this._map.on("move", this._onMove);
          }
          destroy() {
            this._map.indoor.off("load", this._onLoad), this._map.indoor.off("move", this._onMove), this._map = void 0;
          }
          _onLoad() {
            this._map.style.forEachFragmentStyle((t) => {
              t.stylesheet.indoor && (this._queryFeatureSetId ? this.fire(new i.y(new Error("Multiple indoor map styles detected, simultaneous usage is not allowed currently."))) : (this._queryFeatureSetId = t.stylesheet.indoor.floorplanFeaturesetId, this._buildingEntryFeatureSetId = t.stylesheet.indoor.buildingFeaturesetId, this._scope = t.scope));
            }), this._queryFeatureSetId && this._buildingEntryFeatureSetId && this._map.addInteraction("mbx-indoor-buildingclick", { type: "click", target: { featuresetId: this._buildingEntryFeatureSetId, importId: this._scope }, handler: (t) => (t.feature && t.feature.properties.floorplan && this.selectFloorplan(t.feature.properties.floorplan), !0) }), this._checkFloorplanVisible(!0);
          }
          _onMove() {
            this._checkFloorplanVisible(!1);
          }
          _checkFloorplanVisible(t) {
            if (!this._queryFeatureSetId || !this._map.isStyleLoaded() || this._map.transform.zoom < 13) return;
            this._indoorData && !function(C, V) {
              const [K, se] = C, { center: oe, radius: ve } = V, [xe, Le] = oe, ft = Math.abs(K - xe);
              return Math.sqrt((ft > 180 ? 360 - ft : ft) ** 2 + (se - Le) ** 2) <= ve;
            }([this._map.getCenter().lng, this._map.getCenter().lat], this._indoorData.circumCircle) && (this._indoorData = void 0, this._selectedFloorplan = void 0, this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", ["literal", []]), this.fire(new i.z("floorplangone")));
            const n = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, c = new i.P(this._map.transform.width / 2, this._map.transform.height / 2), p = [new i.P(0, 0), new i.P(this._map.transform.width, this._map.transform.height)], v = this._map.queryRenderedFeatures(t ? p : c, n);
            v.length > 0 && (this._selectedFloorplan && v[0].properties.id === this._selectedFloorplan.properties.id || (this._selectedFloorplan = v[0], this._floorplanSelected(!1)));
          }
          _floorplanSelected(t) {
            this._indoorData = JSON.parse(this._selectedFloorplan.properties["indoor-data"]), this._indoorData.id = this._selectedFloorplan.properties.id, this._indoorData.circumCircle = function(v) {
              const [[C, V], [K, se]] = v, oe = (K - C + 360) % 360, ve = oe > 180 ? 360 - oe : oe;
              return { center: [(C + ve / 2 + 360) % 360, (V + se) / 2], radius: Math.sqrt(ve ** 2 + (se - V) ** 2) / 2 };
            }(this._indoorData.extent), this._floorplanStates[this._indoorData.id] || (this._floorplanStates[this._indoorData.id] = {});
            const n = this._floorplanStates[this._indoorData.id].selectedBuilding, c = this._floorplanStates[this._indoorData.id].selectedLevel;
            let p;
            if (this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", this._indoorData.floorplanIDs), this._selectedLevel) for (const v of this._indoorData.levels) v.id === this._selectedLevel.id && (p = v.id);
            if (this.fire(new i.z("floorplanselected", { buildings: this._indoorData.buildings, levels: this._indoorData.levels, selectedLevelId: p })), n) {
              const v = this._indoorData.buildings.find((C) => C.id === n);
              this._buildingSelected(v, !1);
            } else this._indoorData.buildings.length > 0 && this._buildingSelected(this._indoorData.buildings[0], !1);
            if (c) {
              const v = this._indoorData.levels.find((C) => C.id === c);
              this._updateLevels(v, t);
            } else t && this._indoorData["default-levels"].length > 0 && this.selectLevel(this._indoorData["default-levels"][0]);
          }
          _buildingSelected(t, n) {
            n && t && t.extent && this._map.fitBounds(t.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), this._floorplanStates[this._indoorData.id].selectedBuilding = t ? t.id : void 0;
            const c = this._indoorData.levels.filter((p) => t.levels.includes(p.id));
            this.fire(new i.z("buildingselected", { buildingId: t.id, levels: c }));
          }
          _levelSelected(t) {
            if (t === "overview") this._updateLevels(void 0, !0);
            else {
              const n = this._indoorData.levels.find((c) => c.id === t);
              this._updateLevels(n, !0);
            }
            this.fire(new i.z("levelselected", { levelId: t === "overview" ? void 0 : t }));
          }
          _updateLevels(t, n) {
            if (!t) return this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", []]), this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._floorplanStates[this._indoorData.id].selectedLevel = void 0, void (n && this._indoorData.extent && this._map.fitBounds(this._indoorData.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }));
            function c(se) {
              const oe = se.indexOf("/floor/");
              if (oe === -1) return se;
              const ve = oe + 7, xe = se.indexOf("/", ve);
              return xe === -1 ? se.slice(ve) : se.slice(ve, xe);
            }
            this._selectedLevel = t, this._floorplanStates[this._indoorData.id].selectedLevel = t ? t.id : void 0;
            const p = [], v = {}, C = {}, V = {}, K = {};
            for (const se of this._indoorData.levels) if (p.push(se.id), v[se.id] = se.height, C[se.id] = se.base, t) {
              if (this.mergeFloors) {
                const oe = c(t.id), ve = c(se.id);
                V[se.id] = ve === oe ? "true" : "false";
              } else V[se.id] = se.id === t.id ? "true" : "false";
              K[se.id] = se.base < t.base ? "true" : "false";
            } else K[se.id] = !0;
            if (this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", p]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-height", ["literal", v]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-base", ["literal", C]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", ["literal", V]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-overlapped", ["literal", K]), t && (this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !!t.isUnderground), n && t.extent)) {
              const se = this._map.cameraForBounds(t.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), oe = this._map.getZoom(), ve = se.zoom ? Math.abs(oe - se.zoom) : 0;
              this._map.fitBounds(t.extent, ve >= 1 ? { pitch: this._map.getPitch(), bearing: this._map.getBearing() } : { pitch: this._map.getPitch(), bearing: this._map.getBearing(), zoom: oe });
            }
          }
          selectFloorplan(t) {
            const n = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, c = [new i.P(0, 0), new i.P(this._map.transform.width, this._map.transform.height)], p = this._map.queryRenderedFeatures(c, n);
            if (p.length > 0) {
              for (const v of p) if (JSON.parse(v.properties["indoor-data"]).floorplanIDs.includes(t)) {
                this._selectedFloorplan = v, this._floorplanSelected(!0);
                break;
              }
            }
          }
          selectBuilding(t) {
            const n = this._indoorData.buildings.find((c) => c.id === t);
            this._buildingSelected(n, !0);
          }
          selectLevel(t) {
            this._levelSelected(t);
          }
        }
        function kc(u) {
          if (!u.metadata || !u.metadata.content_area) return;
          const t = i.q.devicePixelRatio, { left: n, top: c, width: p, height: v } = u.metadata.content_area, C = n * t, V = c * t;
          return [C, V, C + p * t, V + v * t];
        }
        function Qu(u) {
          if (u) return u.map(([t, n]) => [t * i.q.devicePixelRatio, n * i.q.devicePixelRatio]);
        }
        const ba = (u, t) => ai(u, t && t.filter((n) => n.identifier !== "source.canvas")), vi = i.ay(ht, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setSnow", "setRain", "setProjection", "setCamera", "addImport", "removeImport", "updateImport"]), Ci = i.ay(ht, ["setCenter", "setZoom", "setBearing", "setPitch"]), Xi = /* @__PURE__ */ new Set(["background", "sky", "slot", "custom"]), sr = { version: 8, layers: [], sources: {} }, rn = { duration: 300, delay: 0 };
        class Hr extends i.E {
          constructor(t, n = {}) {
            super(), this.map = t, this.scope = n.scope || "", this.globalId = null, this.fragments = [], this.importDepth = n.importDepth || 0, this.importsCache = n.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = n.resolvedImports || /* @__PURE__ */ new Set(), this.transition = i.l({}, rn), this._buildingIndex = new Is(this), this.crossTileSymbolIndex = new Yu(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = n.styleChanges || new Qt(), this.dispatcher = n.dispatcher ? n.dispatcher : new i.D(i.ci(), this), n.imageManager ? this.imageManager = n.imageManager : (this.imageManager = new St(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = n.glyphManager ? n.glyphManager : new i.cj(t._requestManager, n.localFontFamily ? i.ck.all : n.localIdeographFontFamily ? i.ck.ideographs : i.ck.none, n.localFontFamily || n.localIdeographFontFamily), n.modelManager ? this.modelManager = n.modelManager : (this.modelManager = new Ho(t._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._order = [], this._markersNeedUpdate = !1, this.options = n.configOptions ? n.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = n.configDependentLayers ? n.configDependentLayers : /* @__PURE__ */ new Set(), this._config = n.config, this._styleColorTheme = { lut: null, lutLoading: !1, lutLoadingCorrelationID: 0, colorTheme: null, colorThemeOverride: n.colorThemeOverride }, this._styleColorThemeForScope = {}, this._initialConfig = n.initialConfig, this.dispatcher.broadcast("setReferrer", i.cl());
            const c = this;
            this._rtlTextPluginCallback = Hr.registerForPluginStateChange((p) => {
              c.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: p.pluginStatus, pluginURL: p.pluginURL }, (v, C) => {
                if (i.cm(v), C && C.every((V) => V)) for (const V in c._sourceCaches) {
                  const K = c._sourceCaches[V], se = K.getSource().type;
                  se !== "vector" && se !== "geojson" || K.reload();
                }
              });
            }), this.on("data", (p) => {
              if (p.dataType !== "source" || p.sourceDataType !== "metadata") return;
              const v = this.getOwnSource(p.sourceId);
              if (v && v.vectorLayerIds) for (const C in this._layers) {
                const V = this._layers[C];
                V.source === v.id && this._validateLayer(V);
              }
            });
          }
          load(t) {
            return t ? (typeof t == "string" ? this.loadURL(t) : this.loadJSON(t), this) : this;
          }
          _getGlobalId(t) {
            if (!t) return null;
            if (typeof t == "string") {
              if (i.f(t)) return t;
              const n = i.cn(t);
              if (!n.startsWith("http")) try {
                return new URL(n, location.href).toString();
              } catch {
                return n;
              }
              return n;
            }
            return `json://${i.co(JSON.stringify(t))}`;
          }
          _diffStyle(t, n, c) {
            this.globalId = this._getGlobalId(t);
            const p = (v, C) => {
              try {
                C(null, this.setState(v, c));
              } catch (V) {
                C(V, !1);
              }
            };
            if (typeof t == "string") {
              const v = this.map._requestManager.normalizeStyleURL(t), C = this.map._requestManager.transformRequest(v, i.R.Style);
              i.n(C, (V, K) => {
                V ? this.fire(new i.y(V)) : K && p(K, n);
              });
            } else typeof t == "object" && p(t, n);
          }
          loadURL(t, n = {}) {
            this.fire(new i.z("dataloading", { dataType: "style" }));
            const c = typeof n.validate == "boolean" ? n.validate : !i.f(t);
            this.globalId = this._getGlobalId(t), t = this.map._requestManager.normalizeStyleURL(t, n.accessToken), this.resolvedImports.add(t);
            const p = this.importsCache.get(t);
            if (p) return this._load(p, c);
            const v = this.map._requestManager.transformRequest(t, i.R.Style);
            this._request = i.n(v, (C, V) => {
              if (this._request = null, C) this.fire(new i.y(C));
              else if (V) return this.importsCache.set(t, V), this._load(V, c);
            });
          }
          loadJSON(t, n = {}) {
            this.fire(new i.z("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t), this._request = i.q.frame(() => {
              this._request = null, this._load(t, n.validate !== !1);
            });
          }
          loadEmpty() {
            this.fire(new i.z("dataloading", { dataType: "style" })), this._load(sr, !1);
          }
          _loadImports(t, n, c) {
            if (this.importDepth >= 4) return i.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
            const p = [];
            for (const v of t) {
              const C = this._createFragmentStyle(v), V = new Promise((oe) => {
                C.once("style.import.load", oe), C.once("error", oe);
              }).then(() => this.mergeAll());
              if (p.push(V), this.resolvedImports.has(v.url)) {
                C.loadEmpty();
                continue;
              }
              const K = v.data || this.importsCache.get(v.url);
              K ? (C.loadJSON(K, { validate: n }), this._isInternalStyle(K) && (C.globalId = null)) : v.url ? C.loadURL(v.url, { validate: n }) : C.loadEmpty();
              const se = { style: C, id: v.id, config: v.config };
              if (c) {
                const oe = this.fragments.findIndex(({ id: ve }) => ve === c);
                this.fragments = this.fragments.slice(0, oe).concat(se).concat(this.fragments.slice(oe));
              } else this.fragments.push(se);
            }
            return Promise.allSettled(p);
          }
          getImportGlobalIds(t = this, n = /* @__PURE__ */ new Set()) {
            for (const c of t.fragments) c.style.globalId && n.add(c.style.globalId), this.getImportGlobalIds(c.style, n);
            return [...n.values()];
          }
          _createFragmentStyle(t) {
            const n = this.scope ? i.aC(t.id, this.scope) : t.id;
            let c;
            const p = this._initialConfig && this._initialConfig[n];
            (t.config || p) && (c = i.l({}, t.config, p));
            const v = new Hr(this.map, { scope: n, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: c, configOptions: this.options, colorThemeOverride: t["color-theme"], configDependentLayers: this._configDependentLayers });
            return v.setEventedParent(this.map, { style: v }), v;
          }
          _reloadImports() {
            this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
          }
          _isInternalStyle(t) {
            return this.isRootStyle() && (t.fragment || !!t.schema && t.fragment !== !1);
          }
          _load(t, n) {
            const c = t.indoor ? Rc(t.schema) : t.schema;
            if (this._isInternalStyle(t)) {
              const C = i.l({}, sr, { imports: [{ id: "basemap", data: t, url: "" }] });
              return void this._load(C, n);
            }
            if (this.updateConfig(this._config, c), n && ba(this, Be(t))) return;
            this._loaded = !0, this.stylesheet = i.cp(t);
            const p = () => {
              for (const se in t.sources) this.addSource(se, t.sources[se], { validate: !1, isInitialLoad: !0 });
              t.sprite ? this._loadIconset(t.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 })), this.glyphManager.setURL(t.glyphs, this.scope);
              const C = be(this.stylesheet.layers);
              if (this._order = C.map((se) => se.id), this.stylesheet.light && i.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) if (this.stylesheet.lights.length === 1 && this.stylesheet.lights[0].type === "flat") {
                const se = this.stylesheet.lights[0];
                this.light = new Ae(se.properties, se.id);
              } else this.setLights(this.stylesheet.lights);
              this.light || (this.light = new Ae(this.stylesheet.light)), this._layers = {};
              for (const se of C) {
                const oe = i.cu(se, this.scope, this._styleColorTheme.lut, this.options);
                oe.configDependencies.size !== 0 && this._configDependentLayers.add(oe.fqid), oe.setEventedParent(this, { layer: { id: oe.id } }), this._layers[oe.id] = oe;
                const ve = this.getOwnLayerSourceCache(oe), xe = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                ve && oe.canCastShadows() && xe && (ve.castsShadows = !0);
              }
              this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
              const V = this.stylesheet.terrain;
              V && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(V, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new i.z("data", { dataType: "style" }));
              const K = this.isRootStyle();
              t.imports ? this._loadImports(t.imports, n).then(() => {
                this._reloadImports(), this.fire(new i.z(K ? "style.load" : "style.import.load"));
              }) : (this._reloadImports(), this.fire(new i.z(K ? "style.load" : "style.import.load")));
            };
            this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
            const v = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
            if (v) {
              const C = this._evaluateColorThemeData(v);
              this._loadColorTheme(C).then(() => {
                p();
              }).catch((V) => {
                i.w(`Couldn't load color theme from the stylesheet: ${V}`), p();
              });
            } else this._styleColorTheme.lut = null, p();
          }
          isRootStyle() {
            return this.importDepth === 0;
          }
          mergeAll() {
            let t, n, c, p, v, C, V, K, se, oe;
            const ve = {};
            this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((xe) => {
              if (xe.stylesheet) {
                if (xe.light != null && (t = xe.light), xe.stylesheet.lights) for (const Le of xe.stylesheet.lights) Le.type === "ambient" && xe.ambientLight != null && (n = xe.ambientLight), Le.type === "directional" && xe.directionalLight != null && (c = xe.directionalLight);
                p = this._prioritizeTerrain(p, xe.terrain, xe.stylesheet.terrain), xe.stylesheet.fog && xe.fog != null && (v = xe.fog), xe.stylesheet.snow && xe.snow != null && (C = xe.snow), xe.stylesheet.rain && xe.rain != null && (V = xe.rain), xe.stylesheet.camera != null && (oe = xe.stylesheet.camera), xe.stylesheet.projection != null && (K = xe.stylesheet.projection), xe.stylesheet.transition != null && (se = xe.stylesheet.transition), ve[xe.scope] = xe._styleColorTheme;
              }
            }), this.light = t, this.ambientLight = n, this.directionalLight = c, this.fog = v, this.snow = C, this.rain = V, this._styleColorThemeForScope = ve, p === null ? delete this.terrain : this.terrain = p, this.camera = oe || { "camera-projection": "perspective" }, this.projection = K || { name: "mercator" }, this.transition = i.l({}, rn, se), this.mergeSources(), this.mergeLayers();
          }
          forEachFragmentStyle(t) {
            const n = (c) => {
              for (const p of c.fragments) n(p.style);
              t(c);
            };
            n(this);
          }
          _prioritizeTerrain(t, n, c) {
            const p = t && t.drapeRenderMode === 0;
            return c === null ? n && n.drapeRenderMode === 0 ? n : p ? t : null : n != null && (!t || p || n && n.drapeRenderMode === 1) ? n : t;
          }
          mergeTerrain() {
            let t;
            this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((n) => {
              t = this._prioritizeTerrain(t, n.terrain, n.stylesheet.terrain);
            }), t === null ? delete this.terrain : this.terrain = t;
          }
          mergeProjection() {
            let t;
            this.forEachFragmentStyle((n) => {
              n.stylesheet.projection != null && (t = n.stylesheet.projection);
            }), this.projection = t || { name: "mercator" };
          }
          mergeSources() {
            const t = {}, n = {}, c = {};
            this.forEachFragmentStyle((p) => {
              for (const v in p._sourceCaches) {
                const C = i.aC(v, p.scope);
                t[C] = p._sourceCaches[v];
              }
              for (const v in p._otherSourceCaches) {
                const C = i.aC(v, p.scope);
                n[C] = p._otherSourceCaches[v];
              }
              for (const v in p._symbolSourceCaches) {
                const C = i.aC(v, p.scope);
                c[C] = p._symbolSourceCaches[v];
              }
            }), this._mergedSourceCaches = t, this._mergedOtherSourceCaches = n, this._mergedSymbolSourceCaches = c;
          }
          mergeLayers() {
            const t = {}, n = [], c = {};
            this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle((v) => {
              for (const C of v._order) {
                const V = v._layers[C];
                if (V.type === "slot") {
                  const K = i.cq(C);
                  if (t[K]) continue;
                  t[K] = [];
                }
                V.slot && t[V.slot] ? t[V.slot].push(V) : n.push(V);
              }
            }), this._mergedOrder = [];
            const p = (v = []) => {
              for (const C of v) if (C.type === "slot") {
                const V = i.cq(C.id);
                t[V] && p(t[V]), this._mergedSlots.push(V);
              } else {
                const V = i.aC(C.id, C.scope);
                this._mergedOrder.push(V), c[V] = C, C.is3D() && (this._has3DLayers = !0), C.type === "circle" && (this._hasCircleLayers = !0), C.type === "symbol" && (this._hasSymbolLayers = !0), C.type === "clip" && (this._clipLayerPresent = !0);
              }
            };
            p(n), this._mergedOrder.sort((v, C) => {
              const V = c[v], K = c[C];
              return V.hasInitialOcclusionOpacityProperties ? K.is3D() ? 1 : 0 : V.is3D() && K.hasInitialOcclusionOpacityProperties ? -1 : 0;
            }), this._mergedLayers = c, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
          }
          terrainSetForDrapingOnly() {
            return !!this.terrain && this.terrain.drapeRenderMode === 0;
          }
          getCamera() {
            return this.stylesheet.camera;
          }
          setCamera(t) {
            return this.stylesheet.camera = i.l({}, this.stylesheet.camera, t), this.camera = this.stylesheet.camera, this;
          }
          _evaluateColorThemeData(t) {
            return t.data ? function(n, c, p) {
              const v = i.l({}, c);
              for (const V of Object.keys(i.a3.colorTheme)) v[V] === void 0 && (v[V] = i.a3.colorTheme[V].default);
              const C = new i.a4(Ku, n, new Map(p));
              return C.setTransitionOrValue(v, p), C.untransitioned().possiblyEvaluate(new i.a8(0));
            }(this.scope, t, this.options).get("data") : null;
          }
          _loadColorTheme(t) {
            this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;
            const n = this._styleColorTheme.lutLoadingCorrelationID;
            return new Promise((c, p) => {
              const v = "data:image/png;base64,";
              if (!t || t.length === 0) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void c();
              let C = t;
              C.startsWith(v) || (C = v + C);
              const V = "mapbox-reserved-lut", K = new Image();
              K.src = C, K.onerror = () => {
                this._styleColorTheme.lutLoading = !1, p(new Error("Failed to load image data"));
              }, K.onload = () => {
                if (this._styleColorTheme.lutLoadingCorrelationID !== n) return void c();
                this._styleColorTheme.lutLoading = !1;
                const { width: se, height: oe, data: ve } = i.q.getImageData(K);
                if (oe > 32) return void p(new Error("The height of the image must be less than or equal to 32 pixels."));
                if (se !== oe * oe) return void p(new Error("The width of the image must be equal to the height squared."));
                this.getImage(V) && this.removeImage(V), this.addImage(V, { data: new i.r({ width: se, height: oe }, ve), pixelRatio: 1, sdf: !1, usvg: !1, version: 0 });
                const xe = this.imageManager.getImage(V, this.scope);
                xe ? (this._styleColorTheme.lut = { image: xe.data, data: t }, c()) : p(new Error("Missing LUT image."));
              };
            });
          }
          getLut(t) {
            const n = this._styleColorThemeForScope[t];
            return n ? n.lut : null;
          }
          setProjection(t) {
            t ? this.stylesheet.projection = t : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
          }
          applyProjectionUpdate() {
            this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
          }
          _updateMapProjection() {
            this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
          }
          _loadSprite(t) {
            this._spriteRequest = function(n, c, p) {
              let v, C, V;
              const K = i.q.devicePixelRatio > 1 ? "@2x" : "";
              let se = i.n(c.transformRequest(c.normalizeSpriteURL(n, K, ".json"), i.R.SpriteJSON), (xe, Le) => {
                se = null, V || (V = xe, v = Le, ve());
              }), oe = i.o(c.transformRequest(c.normalizeSpriteURL(n, K, ".png"), i.R.SpriteImage), (xe, Le) => {
                oe = null, V || (V = xe, C = Le, ve());
              });
              function ve() {
                if (V) p(V);
                else if (v && C) {
                  const xe = i.q.getImageData(C), Le = {};
                  for (const ft in v) {
                    const { width: st, height: vt, x: gt, y: Rt, sdf: qt, pixelRatio: jt, stretchX: ii, stretchY: Xt, content: Kt } = v[ft], Zt = new i.r({ width: st, height: vt });
                    i.r.copy(xe, Zt, { x: gt, y: Rt }, { x: 0, y: 0 }, { width: st, height: vt }, null), Le[ft] = { data: Zt, pixelRatio: jt, sdf: qt, stretchX: ii, stretchY: Xt, content: Kt, usvg: !1 };
                  }
                  p(null, Le);
                }
              }
              return { cancel() {
                se && (se.cancel(), se = null), oe && (oe.cancel(), oe = null);
              } };
            }(t, this.map._requestManager, (n, c) => {
              if (this._spriteRequest = null, n) this.fire(new i.y(n));
              else if (c) for (const p in c) this.imageManager.addImage(p, this.scope, c[p]);
              this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 }), this.fire(new i.z("data", { dataType: "style" }));
            });
          }
          _loadIconset(t) {
            if (!i.f(t) && this.map._spriteFormat !== "icon_set" || this.map._spriteFormat === "raster") return void this._loadSprite(t);
            const n = this.map._spriteFormat === "auto";
            var c, p;
            this._spriteRequest = (p = (v, C) => {
              if (this._spriteRequest = null, v) n ? this._loadSprite(t) : this.fire(new i.y(v));
              else if (C) for (const V in C) this.imageManager.addImage(V, this.scope, C[V]);
              this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 }), this.fire(new i.z("data", { dataType: "style" }));
            }, i.bi((c = this.map._requestManager).transformRequest(c.normalizeIconsetURL(t), i.R.Iconset), (v, C) => {
              if (v) return void p(v);
              const V = {}, K = i.cg(new i.bh(C));
              for (const se of K.icons) {
                const oe = { version: 1, pixelRatio: i.q.devicePixelRatio, content: kc(se), stretchX: se.metadata ? Qu(se.metadata.stretch_x_areas) : void 0, stretchY: se.metadata ? Qu(se.metadata.stretch_y_areas) : void 0, sdf: !1, usvg: !0, icon: se };
                V[se.name] = oe;
              }
              p(null, V);
            }));
          }
          _validateLayer(t) {
            const n = this.getOwnSource(t.source);
            if (!n) return;
            const c = t.sourceLayer;
            c && (n.type === "geojson" || n.vectorLayerIds && n.vectorLayerIds.indexOf(c) === -1) && this.fire(new i.y(new Error(`Source layer "${c}" does not exist on source "${n.id}" as specified by style layer "${t.id}"`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;
            for (const t in this._sourceCaches) if (!this._sourceCaches[t].loaded()) return !1;
            if (!this.imageManager.isLoaded() || !this.modelManager.isLoaded() || this._styleColorTheme.lutLoading) return !1;
            for (const { style: t } of this.fragments) if (!t.loaded()) return !1;
            return !0;
          }
          _serializeImports() {
            if (this.stylesheet.imports) return this.stylesheet.imports.map((t, n) => {
              const c = this.fragments[n];
              return c && c.style && (t.data = c.style.serialize()), t;
            });
          }
          _serializeSources() {
            const t = {};
            for (const n in this._sourceCaches) {
              const c = this._sourceCaches[n].getSource();
              t[c.id] || (t[c.id] = c.serialize());
            }
            return t;
          }
          _serializeLayers(t) {
            const n = [];
            for (const c of t) {
              const p = this._layers[c];
              p && p.type !== "custom" && n.push(p.serialize());
            }
            return n;
          }
          hasLightTransitions() {
            return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
          }
          hasFogTransition() {
            return !!this.fog && this.fog.hasTransition();
          }
          hasSnowTransition() {
            return !!this.snow && this.snow.hasTransition();
          }
          hasRainTransition() {
            return !!this.rain && this.rain.hasTransition();
          }
          hasTransitions() {
            if (this.hasLightTransitions() || this.hasFogTransition() || this.hasSnowTransition() || this.hasRainTransition()) return !0;
            for (const t in this._sourceCaches) if (this._sourceCaches[t].hasTransition()) return !0;
            for (const t in this._layers) if (this._layers[t].hasTransition()) return !0;
            return !1;
          }
          get order() {
            return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
          }
          _getOrder(t) {
            return t ? this.order : this._mergedOrder;
          }
          isLayerDraped(t) {
            return !!this.terrain && t.isDraped(this.getLayerSourceCache(t));
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading");
          }
          _checkLayer(t) {
            const n = this.getOwnLayer(t);
            if (n) return n;
            this.fire(new i.y(new Error(`The layer '${t}' does not exist in the map's style.`)));
          }
          _checkSource(t) {
            const n = this.getOwnSource(t);
            if (n) return n;
            this.fire(new i.y(new Error(`The source '${t}' does not exist in the map's style.`)));
          }
          precompilePrograms(t, n) {
            const c = this.map.painter;
            if (c) for (let p = t.minzoom || 0; p < (t.maxzoom || 25.5); p++) {
              const v = t.getProgramIds();
              if (v) for (const C of v) {
                const V = t.getDefaultProgramParams(C, n.zoom, this._styleColorTheme.lut);
                V && (c.style = this, this.fog && (c._fogVisible = !0, V.overrideFog = !0, c.getOrCreateProgram(C, V)), c._fogVisible = !1, V.overrideFog = !1, c.getOrCreateProgram(C, V), (this.stylesheet.terrain || this.stylesheet.projection && this.stylesheet.projection.name === "globe") && (V.overrideRtt = !0, c.getOrCreateProgram(C, V)));
              }
            }
          }
          update(t) {
            if (!this._loaded) return;
            this.ambientLight && this.ambientLight.recalculate(t), this.directionalLight && this.directionalLight.recalculate(t);
            const n = this.calculateLightsBrightness();
            t.brightness = n || 0, n !== this._brightness && (this._brightness = n, this.dispatcher.broadcast("setBrightness", n));
            const c = this._changes.isDirty();
            let p = !1;
            if (this._changes.isDirty()) {
              const C = this._changes.getLayerUpdatesByScope();
              for (const V in C) {
                const { updatedIds: K, removedIds: se } = C[V];
                (K || se) && (this._updateWorkerLayers(V, K, se), p = !0);
              }
              this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t), this.light && this.light.updateTransitions(t), this.ambientLight && this.ambientLight.updateTransitions(t), this.directionalLight && this.directionalLight.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this.snow && this.snow.updateTransitions(t), this.rain && this.rain.updateTransitions(t), this._changes.reset();
            }
            const v = {};
            for (const C in this._mergedSourceCaches) {
              const V = this._mergedSourceCaches[C];
              v[C] = V.used, V.used = !1, V.tileCoverLift = 0;
            }
            for (const C of this._mergedOrder) {
              const V = this._mergedLayers[C];
              if (V.recalculate(t, this._availableImages), !V.isHidden(t.zoom)) {
                const K = this.getLayerSourceCache(V);
                K && (K.used = !0, K.tileCoverLift = Math.max(K.tileCoverLift, V.tileCoverLift()));
              }
              !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(() => {
                this.precompilePrograms(V, t);
              }) : this.precompilePrograms(V, t));
            }
            this._shouldPrecompile && (this._precompileDone = !0), this.terrain && p && this.mergeLayers();
            for (const C in v) {
              const V = this._mergedSourceCaches[C];
              v[C] !== V.used && V.getSource().fire(new i.z("data", { sourceDataType: "visibility", dataType: "source", sourceId: V.getSource().id }));
            }
            this.light && this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.snow && this.snow.recalculate(t), this.rain && this.rain.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), c && this.fire(new i.z("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const t = this._changes.getUpdatedImages();
            if (t.length) {
              for (const n in this._sourceCaches) this._sourceCaches[n].reloadTilesForDependencies(["icons", "patterns"], t);
              this._changes.resetUpdatedImages();
            }
          }
          _updateWorkerLayers(t, n, c) {
            const p = this.getFragmentStyle(t);
            p && this.dispatcher.broadcast("updateLayers", { layers: n ? p._serializeLayers(n) : [], scope: t, removedIds: c || [], options: p.options });
          }
          setState(t, n) {
            if (this._checkLoaded(), ba(this, Be(t))) return !1;
            (t = i.cp(t)).layers = be(t.layers);
            const c = function(C, V) {
              if (!C) return [{ command: ht.setStyle, args: [V] }];
              let K = [];
              try {
                if (!i.bn(C.version, V.version)) return [{ command: ht.setStyle, args: [V] }];
                if (i.bn(C.center, V.center) || K.push({ command: ht.setCenter, args: [V.center] }), i.bn(C.zoom, V.zoom) || K.push({ command: ht.setZoom, args: [V.zoom] }), i.bn(C.bearing, V.bearing) || K.push({ command: ht.setBearing, args: [V.bearing] }), i.bn(C.pitch, V.pitch) || K.push({ command: ht.setPitch, args: [V.pitch] }), i.bn(C.sprite, V.sprite) || K.push({ command: ht.setSprite, args: [V.sprite] }), i.bn(C.glyphs, V.glyphs) || K.push({ command: ht.setGlyphs, args: [V.glyphs] }), i.bn(C.imports, V.imports) || function(Le = [], ft = [], st) {
                  ft = ft || [];
                  const vt = (Le = Le || []).map(_r), gt = ft.map(_r), Rt = Le.reduce(en, {}), qt = ft.reduce(en, {}), jt = vt.slice();
                  let ii, Xt, Kt, Zt;
                  for (ii = 0, Xt = 0; ii < vt.length; ii++) Kt = vt[ii], qt.hasOwnProperty(Kt) ? Xt++ : (st.push({ command: ht.removeImport, args: [Kt] }), jt.splice(jt.indexOf(Kt, Xt), 1));
                  for (ii = 0, Xt = 0; ii < gt.length; ii++) Kt = gt[gt.length - 1 - ii], jt[jt.length - 1 - ii] !== Kt && (Rt.hasOwnProperty(Kt) ? (st.push({ command: ht.removeImport, args: [Kt] }), jt.splice(jt.lastIndexOf(Kt, jt.length - Xt), 1)) : Xt++, Zt = jt[jt.length - ii], st.push({ command: ht.addImport, args: [qt[Kt], Zt] }), jt.splice(jt.length - ii, 0, Kt));
                  for (const Jt of ft) {
                    const ui = Rt[Jt.id];
                    ui && !i.bn(ui, Jt) && st.push({ command: ht.updateImport, args: [Jt.id, Jt] });
                  }
                }(C.imports, V.imports, K), i.bn(C.transition, V.transition) || K.push({ command: ht.setTransition, args: [V.transition] }), i.bn(C.light, V.light) || K.push({ command: ht.setLight, args: [V.light] }), i.bn(C.fog, V.fog) || K.push({ command: ht.setFog, args: [V.fog] }), i.bn(C.snow, V.snow) || K.push({ command: ht.setSnow, args: [V.snow] }), i.bn(C.rain, V.rain) || K.push({ command: ht.setRain, args: [V.rain] }), i.bn(C.projection, V.projection) || K.push({ command: ht.setProjection, args: [V.projection] }), i.bn(C.lights, V.lights) || K.push({ command: ht.setLights, args: [V.lights] }), i.bn(C.camera, V.camera) || K.push({ command: ht.setCamera, args: [V.camera] }), !i.bn(C["color-theme"], V["color-theme"])) return [{ command: ht.setStyle, args: [V] }];
                const se = {}, oe = [];
                (function(Le, ft, st, vt) {
                  let gt;
                  for (gt in ft = ft || {}, Le = Le || {}) Le.hasOwnProperty(gt) && (ft.hasOwnProperty(gt) || hi(gt, st, vt));
                  for (gt in ft) {
                    if (!ft.hasOwnProperty(gt)) continue;
                    const Rt = ft[gt];
                    Le.hasOwnProperty(gt) ? i.bn(Le[gt], Rt) || (Le[gt].type === "geojson" && Rt.type === "geojson" && ki(Le, ft, gt) ? st.push({ command: ht.setGeoJSONSourceData, args: [gt, Rt.data] }) : di(gt, ft, st, vt)) : Ot(gt, ft, st);
                  }
                })(C.sources, V.sources, oe, se);
                const ve = [];
                C.layers && C.layers.forEach((Le) => {
                  Le.source && se[Le.source] ? K.push({ command: ht.removeLayer, args: [Le.id] }) : ve.push(Le);
                });
                let xe = C.terrain;
                xe && se[xe.source] && (K.push({ command: ht.setTerrain, args: [void 0] }), xe = void 0), K = K.concat(oe), i.bn(xe, V.terrain) || K.push({ command: ht.setTerrain, args: [V.terrain] }), function(Le, ft, st) {
                  ft = ft || [];
                  const vt = (Le = Le || []).map(_r), gt = ft.map(_r), Rt = Le.reduce(en, {}), qt = ft.reduce(en, {}), jt = vt.slice(), ii = /* @__PURE__ */ Object.create(null);
                  let Xt, Kt, Zt, Jt, ui, Ti, xi;
                  for (Xt = 0, Kt = 0; Xt < vt.length; Xt++) Zt = vt[Xt], qt.hasOwnProperty(Zt) ? Kt++ : (st.push({ command: ht.removeLayer, args: [Zt] }), jt.splice(jt.indexOf(Zt, Kt), 1));
                  for (Xt = 0, Kt = 0; Xt < gt.length; Xt++) Zt = gt[gt.length - 1 - Xt], jt[jt.length - 1 - Xt] !== Zt && (Rt.hasOwnProperty(Zt) ? (st.push({ command: ht.removeLayer, args: [Zt] }), jt.splice(jt.lastIndexOf(Zt, jt.length - Kt), 1)) : Kt++, Ti = jt[jt.length - Xt], st.push({ command: ht.addLayer, args: [qt[Zt], Ti] }), jt.splice(jt.length - Xt, 0, Zt), ii[Zt] = !0);
                  for (Xt = 0; Xt < gt.length; Xt++) if (Zt = gt[Xt], Jt = Rt[Zt], ui = qt[Zt], !ii[Zt] && !i.bn(Jt, ui)) if (i.bn(Jt.source, ui.source) && i.bn(Jt["source-layer"], ui["source-layer"]) && i.bn(Jt.type, ui.type)) {
                    for (xi in er(Jt.layout, ui.layout, st, Zt, null, ht.setLayoutProperty), er(Jt.paint, ui.paint, st, Zt, null, ht.setPaintProperty), i.bn(Jt.slot, ui.slot) || st.push({ command: ht.setSlot, args: [Zt, ui.slot] }), i.bn(Jt.filter, ui.filter) || st.push({ command: ht.setFilter, args: [Zt, ui.filter] }), i.bn(Jt.minzoom, ui.minzoom) && i.bn(Jt.maxzoom, ui.maxzoom) || st.push({ command: ht.setLayerZoomRange, args: [Zt, ui.minzoom, ui.maxzoom] }), Jt) Jt.hasOwnProperty(xi) && xi !== "layout" && xi !== "paint" && xi !== "filter" && xi !== "metadata" && xi !== "minzoom" && xi !== "maxzoom" && xi !== "slot" && (xi.indexOf("paint.") === 0 ? er(Jt[xi], ui[xi], st, Zt, xi.slice(6), ht.setPaintProperty) : i.bn(Jt[xi], ui[xi]) || st.push({ command: ht.setLayerProperty, args: [Zt, xi, ui[xi]] }));
                    for (xi in ui) ui.hasOwnProperty(xi) && !Jt.hasOwnProperty(xi) && xi !== "layout" && xi !== "paint" && xi !== "filter" && xi !== "metadata" && xi !== "minzoom" && xi !== "maxzoom" && xi !== "slot" && (xi.indexOf("paint.") === 0 ? er(Jt[xi], ui[xi], st, Zt, xi.slice(6), ht.setPaintProperty) : i.bn(Jt[xi], ui[xi]) || st.push({ command: ht.setLayerProperty, args: [Zt, xi, ui[xi]] }));
                  } else st.push({ command: ht.removeLayer, args: [Zt] }), Ti = jt[jt.lastIndexOf(Zt) + 1], st.push({ command: ht.addLayer, args: [ui, Ti] });
                }(ve, V.layers, K);
              } catch (se) {
                console.warn("Unable to compute style diff:", se), K = [{ command: ht.setStyle, args: [V] }];
              }
              return K;
            }(this.serialize(), t).filter((C) => !(C.command in Ci));
            if (c.length === 0) return !1;
            const p = c.filter((C) => !(C.command in vi));
            if (p.length > 0) throw new Error(`Unimplemented: ${p.map((C) => C.command).join(", ")}.`);
            const v = [];
            return c.forEach((C) => {
              v.push(this[C.command].apply(this, C.args));
            }), n && Promise.all(v).then(n), this.stylesheet = t, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), !0;
          }
          addImage(t, n) {
            return this.getImage(t) ? this.fire(new i.y(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t, this.scope, n), this._afterImageUpdated(t), this);
          }
          updateImage(t, n, c = !1) {
            this.imageManager.updateImage(t, this.scope, n), c && this._afterImageUpdated(t);
          }
          getImage(t) {
            return this.imageManager.getImage(t, this.scope);
          }
          removeImage(t) {
            return this.getImage(t) ? (this.imageManager.removeImage(t, this.scope), this._afterImageUpdated(t), this) : this.fire(new i.y(new Error("No image with this name exists.")));
          }
          _afterImageUpdated(t) {
            this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.fire(new i.z("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this._availableImages.slice();
          }
          addModel(t, n, c = {}) {
            return this._checkLoaded(), this._validate(Yt, `models.${t}`, n, null, c) || (this.modelManager.addModel(t, n, this.scope), this._changes.setDirty()), this;
          }
          hasModel(t) {
            return this.modelManager.hasModel(t, this.scope);
          }
          removeModel(t) {
            return this.hasModel(t) ? (this.modelManager.removeModel(t, this.scope), this) : this.fire(new i.y(new Error("No model with this ID exists.")));
          }
          listModels() {
            return this._checkLoaded(), this.modelManager.listModels(this.scope);
          }
          addSource(t, n, c = {}) {
            if (this._checkLoaded(), this.getOwnSource(t) !== void 0) throw new Error(`There is already a source with ID "${t}".`);
            if (!n.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(n).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(n.type) >= 0 && this._validate(Ze, `sources.${t}`, n, null, c)) return;
            this.map && this.map._collectResourceTiming && (n.collectResourceTiming = !0);
            const p = Yn(t, n, this.dispatcher, this);
            p.scope = this.scope, p.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(p.id), source: p.serialize(), sourceId: p.id }));
            const v = (C) => {
              const V = (C ? "symbol:" : "other:") + p.id, K = i.aC(V, this.scope), se = this._sourceCaches[V] = new fa(K, p, C);
              (C ? this._symbolSourceCaches : this._otherSourceCaches)[p.id] = se, se.onAdd(this.map);
            };
            v(!1), n.type !== "vector" && n.type !== "geojson" || v(!0), p.onAdd && p.onAdd(this.map), c.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
          }
          removeSource(t) {
            this._checkLoaded();
            const n = this.getOwnSource(t);
            if (!n) throw new Error("There is no source with this ID");
            for (const p in this._layers) if (this._layers[p].source === t) return this.fire(new i.y(new Error(`Source "${t}" cannot be removed while layer "${p}" is using it.`)));
            if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t) return this.fire(new i.y(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));
            const c = this.getOwnSourceCaches(t);
            for (const p of c) {
              const v = i.cq(p.id);
              delete this._sourceCaches[v], this._changes.discardSourceCacheUpdate(p.id), p.fire(new i.z("data", { sourceDataType: "metadata", dataType: "source", sourceId: p.getSource().id })), p.setEventedParent(null), p.clearTiles();
            }
            return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], this.mergeSources(), n.setEventedParent(null), n.onRemove && n.onRemove(this.map), this._changes.setDirty(), this;
          }
          setGeoJSONSourceData(t, n) {
            this._checkLoaded(), this.getOwnSource(t).setData(n), this._changes.setDirty();
          }
          getOwnSource(t) {
            const n = this.getOwnSourceCache(t);
            return n && n.getSource();
          }
          getOwnSources() {
            const t = [];
            for (const n in this._otherSourceCaches) {
              const c = this.getOwnSourceCache(n);
              c && t.push(c.getSource());
            }
            return t;
          }
          areTilesLoaded() {
            const t = this._mergedSourceCaches;
            for (const n in t) {
              const c = t[n]._tiles;
              for (const p in c) {
                const v = c[p];
                if (v.state !== "loaded" && v.state !== "errored") return !1;
              }
            }
            return !0;
          }
          setLights(t) {
            if (this._checkLoaded(), !t) return delete this.ambientLight, void delete this.directionalLight;
            const n = this._getTransitionParameters();
            for (const p of t) {
              if (this._validate(Je, "lights", p)) return;
              switch (p.type) {
                case "ambient":
                  if (this.ambientLight) {
                    const v = this.ambientLight;
                    v.set(p), v.updateTransitions(n);
                  } else this.ambientLight = new rr(p, Di || (Di = new i.a5({ color: new i.a6(i.a3.properties_light_ambient.color), "color-use-theme": new i.a6({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new i.a6(i.a3.properties_light_ambient.intensity) })), this.scope, this.options);
                  break;
                case "directional":
                  if (this.directionalLight) {
                    const v = this.directionalLight;
                    v.set(p), v.updateTransitions(n);
                  } else this.directionalLight = new rr(p, Bi || (Bi = new i.a5({ direction: new i.ak(i.a3.properties_light_directional.direction), color: new i.a6(i.a3.properties_light_directional.color), "color-use-theme": new i.a6({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new i.a6(i.a3.properties_light_directional.intensity), "cast-shadows": new i.a6(i.a3.properties_light_directional["cast-shadows"]), "shadow-quality": new i.a6(i.a3.properties_light_directional["shadow-quality"]), "shadow-intensity": new i.a6(i.a3.properties_light_directional["shadow-intensity"]) })), this.scope, this.options);
              }
            }
            const c = new i.a8(this.z || 0, n);
            this.ambientLight && this.ambientLight.recalculate(c), this.directionalLight && this.directionalLight.recalculate(c), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
          }
          calculateLightsBrightness() {
            const t = this.directionalLight, n = this.ambientLight;
            if (!t || !n) return;
            const c = (xe) => 0.2126 * (xe[0] <= 0.03928 ? xe[0] / 12.92 : Math.pow((xe[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (xe[1] <= 0.03928 ? xe[1] / 12.92 : Math.pow((xe[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (xe[2] <= 0.03928 ? xe[2] / 12.92 : Math.pow((xe[2] + 0.055) / 1.055, 2.4)), p = t.properties.get("color").toRenderColor(null).toArray01(), v = t.properties.get("intensity"), C = t.properties.get("direction"), V = 1 - i.cb(C.x, C.y, C.z)[2] / 90, K = c(p) * v * V, se = n.properties.get("color").toRenderColor(null).toArray01(), oe = n.properties.get("intensity"), ve = c(se) * oe;
            return Number(((K + ve) / 2).toFixed(6));
          }
          getBrightness() {
            return this._brightness;
          }
          getLights() {
            if (!this.enable3dLights()) return null;
            const t = [];
            return this.directionalLight && t.push(this.directionalLight.get()), this.ambientLight && t.push(this.ambientLight.get()), t;
          }
          enable3dLights() {
            return !!this.ambientLight && !!this.directionalLight;
          }
          getFragmentStyle(t) {
            if (!t) return this;
            if (i.cr(t)) {
              const n = i.cs(t), c = this.fragments.find(({ id: v }) => v === n);
              if (!c) throw new Error(`Style import '${t}' not found`);
              const p = i.cq(t);
              return c.style.getFragmentStyle(p);
            }
            {
              const n = this.fragments.find(({ id: c }) => c === t);
              return n ? n.style : void 0;
            }
          }
          setFeaturesetSelectors(t) {
            if (!t) return;
            const n = {}, c = (p, v = "") => `${p}::${v}`;
            this._featuresetSelectors = {};
            for (const p in t) {
              const v = this._featuresetSelectors[p] = [];
              for (const C of t[p].selectors) {
                if (C.featureNamespace) {
                  const K = this.getOwnLayer(C.layer);
                  if (!K) {
                    i.w(`Layer is undefined for selector: ${C.layer}`);
                    continue;
                  }
                  const se = c(K.source, K.sourceLayer);
                  if (se in n && n[se] !== C.featureNamespace) {
                    i.w(`"featureNamespace ${C.featureNamespace} of featureset ${p}'s selector is not associated to the same source, skip this selector`);
                    continue;
                  }
                  n[se] = C.featureNamespace;
                }
                let V;
                if (C.properties) for (const K in C.properties) {
                  const se = i.U(C.properties[K]);
                  se.result === "success" && (V = V || {}, V[K] = se.value);
                }
                v.push({ layerId: C.layer, namespace: C.featureNamespace, properties: V, uniqueFeatureID: C._uniqueFeatureID });
              }
            }
          }
          getFeaturesetDescriptors(t) {
            const n = this.getFragmentStyle(t);
            if (!n || !n.stylesheet.featuresets) return [];
            const c = [];
            for (const p in n.stylesheet.featuresets) c.push({ featuresetId: p, importId: n.scope ? n.scope : void 0 });
            return c;
          }
          getFeaturesetLayers(t, n) {
            const c = this.getFragmentStyle(n), p = c.stylesheet.featuresets;
            if (!p || !p[t]) return this.fire(new i.y(new Error(`The featureset '${t}' does not exist in the map's style and cannot be queried.`))), [];
            const v = [];
            for (const C of p[t].selectors) {
              const V = c.getOwnLayer(C.layer);
              V && v.push(V);
            }
            return v;
          }
          getConfigProperty(t, n) {
            const c = this.getFragmentStyle(t);
            if (!c) return null;
            const p = i.aC(n, c.scope), v = c.options.get(p), C = v ? v.value || v.default : null;
            return C ? C.serialize() : null;
          }
          setConfigProperty(t, n, c) {
            const p = this.getFragmentStyle(t);
            if (!p) return;
            const v = p.stylesheet.indoor ? Rc(p.stylesheet.schema) : p.stylesheet.schema;
            if (!v || !v[n]) return;
            const C = i.U(c);
            if (C.result !== "success") return void ba(this, C.value);
            const V = C.value.expression, K = i.aC(n, p.scope), se = p.options.get(K);
            if (!se) return;
            let oe;
            const { minValue: ve, maxValue: xe, stepValue: Le, type: ft, values: st } = v[n], vt = i.U(v[n].default);
            vt.result === "success" && (oe = vt.value.expression), oe ? (this.options.set(K, Object.assign({}, se, { value: V, default: oe, minValue: ve, maxValue: xe, stepValue: Le, type: ft, values: st })), this.updateConfigDependencies(n)) : this.fire(new i.y(new Error(`No schema defined for the config option "${n}" in the "${t}" fragment.`)));
          }
          getConfig(t) {
            const n = this.getFragmentStyle(t);
            if (!n) return null;
            const c = n.stylesheet.schema;
            if (!c) return null;
            const p = {};
            for (const v in c) {
              const C = i.aC(v, n.scope), V = n.options.get(C), K = V ? V.value || V.default : null;
              p[v] = K ? K.serialize() : null;
            }
            return p;
          }
          setConfig(t, n) {
            const c = this.getFragmentStyle(t);
            c && (c.updateConfig(n, c.stylesheet.schema), this.updateConfigDependencies());
          }
          getSchema(t) {
            const n = this.getFragmentStyle(t);
            return n ? n.stylesheet.schema : null;
          }
          setSchema(t, n) {
            const c = this.getFragmentStyle(t);
            c && (c.stylesheet.schema = n, c.updateConfig(c._config, n), this.updateConfigDependencies());
          }
          updateConfig(t, n) {
            if (this._config = t, t || n) if (n) for (const c in n) {
              let p, v;
              const C = i.U(n[c].default);
              if (C.result === "success" && (p = C.value.expression), t && t[c] !== void 0) {
                const xe = i.U(t[c]);
                xe.result === "success" && (v = xe.value.expression);
              }
              const { minValue: V, maxValue: K, stepValue: se, type: oe, values: ve } = n[c];
              if (p) {
                const xe = i.aC(c, this.scope);
                this.options.set(xe, { default: p, value: v, minValue: V, maxValue: K, stepValue: se, type: oe, values: ve });
              } else this.fire(new i.y(new Error(`No schema defined for config option "${c}".`)));
            }
            else this.fire(new i.y(new Error("Attempting to set config for a style without schema.")));
          }
          updateConfigDependencies(t) {
            for (const n of this._configDependentLayers) {
              const c = this.getLayer(n);
              if (c) {
                if (t && !c.configDependencies.has(t)) continue;
                c.possiblyEvaluateVisibility(), this._updateLayer(c);
              }
            }
            this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle((n) => {
              const c = n._styleColorTheme.colorThemeOverride ? n._styleColorTheme.colorThemeOverride : n._styleColorTheme.colorTheme;
              if (c) {
                const p = n._evaluateColorThemeData(c);
                (!n._styleColorTheme.lut && p !== "" || n._styleColorTheme.lut && p !== n._styleColorTheme.lut.data) && n.setColorTheme(c);
              }
            }), this._changes.setDirty();
          }
          addLayer(t, n, c = {}) {
            this._checkLoaded();
            const p = t.id;
            if (this._layers[p]) return void this.fire(new i.y(new Error(`Layer with id "${p}" already exists on this map`)));
            let v;
            if (t.type === "custom") {
              if (ba(this, i.ct(t))) return;
              v = i.cu(t, this.scope, this._styleColorTheme.lut, this.options);
            } else {
              if (typeof t.source == "object" && (this.addSource(p, t.source), t = i.cp(t), t = i.l(t, { source: p })), this._validate(ae, `layers.${p}`, t, { arrayIndex: -1 }, c)) return;
              v = i.cu(t, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(v), v.setEventedParent(this, { layer: { id: p } });
            }
            v.configDependencies.size !== 0 && this._configDependentLayers.add(v.fqid);
            let C = this._order.length;
            if (n) {
              const oe = this._order.indexOf(n);
              if (oe === -1) return void this.fire(new i.y(new Error(`Layer with id "${n}" does not exist on this map.`)));
              v.slot === this._layers[n].slot ? C = oe : i.w(`Layer with id "${n}" has a different slot. Layers can only be rearranged within the same slot.`);
            }
            this._order.splice(C, 0, p), this._layerOrderChanged = !0, this._layers[p] = v;
            const V = this.getOwnLayerSourceCache(v), K = !!this.directionalLight && this.directionalLight.shadowsEnabled();
            V && v.canCastShadows() && K && (V.castsShadows = !0);
            const se = this._changes.getRemovedLayer(v);
            if (se && v.source && V && v.type !== "custom") {
              this._changes.discardLayerRemoval(v);
              const oe = i.aC(v.source, v.scope);
              se.type !== v.type ? this._changes.updateSourceCache(oe, "clear") : (this._changes.updateSourceCache(oe, "reload"), V.pause());
            }
            this._updateLayer(v), v.onAdd && v.onAdd(this.map), v.scope = this.scope, this.mergeLayers();
          }
          moveLayer(t, n) {
            this._checkLoaded();
            const c = this._checkLayer(t);
            if (!c || t === n) return;
            const p = this._order.indexOf(t);
            this._order.splice(p, 1);
            let v = this._order.length;
            if (n) {
              const C = this._order.indexOf(n);
              if (C === -1) return void this.fire(new i.y(new Error(`Layer with id "${n}" does not exist on this map.`)));
              c.slot === this._layers[n].slot ? v = C : i.w(`Layer with id "${n}" has a different slot. Layers can only be rearranged within the same slot.`);
            }
            this._order.splice(v, 0, t), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers();
          }
          removeLayer(t) {
            this._checkLoaded();
            const n = this._checkLayer(t);
            if (!n) return;
            n.setEventedParent(null);
            const c = this._order.indexOf(t);
            this._order.splice(c, 1), delete this._layers[t], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(n.fqid), this._changes.removeLayer(n);
            const p = this.getOwnLayerSourceCache(n);
            if (p && p.castsShadows) {
              let v = !1;
              for (const C in this._layers) if (this._layers[C].source === n.source && this._layers[C].canCastShadows()) {
                v = !0;
                break;
              }
              p.castsShadows = v;
            }
            n.onRemove && n.onRemove(this.map), this.mergeLayers();
          }
          getOwnLayer(t) {
            return this._layers[t];
          }
          hasLayer(t) {
            return t in this._mergedLayers;
          }
          hasLayerType(t) {
            for (const n in this._layers) if (this._layers[n].type === t) return !0;
            return !1;
          }
          setLayerZoomRange(t, n, c) {
            this._checkLoaded();
            const p = this._checkLayer(t);
            p && (p.minzoom === n && p.maxzoom === c || (n != null && (p.minzoom = n), c != null && (p.maxzoom = c), this._updateLayer(p)));
          }
          getSlots() {
            return this._checkLoaded(), this._mergedSlots;
          }
          setSlot(t, n) {
            this._checkLoaded();
            const c = this._checkLayer(t);
            c && c.slot !== n && (c.slot = n, this._updateLayer(c));
          }
          setFilter(t, n, c = {}) {
            this._checkLoaded();
            const p = this._checkLayer(t);
            if (p && !i.bn(p.filter, n)) return n == null ? (p.filter = void 0, void this._updateLayer(p)) : void (this._validate($e, `layers.${p.id}.filter`, n, { layerType: p.type }, c) || (p.filter = i.cp(n), this._updateLayer(p)));
          }
          getFilter(t) {
            const n = this._checkLayer(t);
            if (n) return i.cp(n.filter);
          }
          setLayoutProperty(t, n, c, p = {}) {
            this._checkLoaded();
            const v = this._checkLayer(t);
            if (v && !i.bn(v.getLayoutProperty(n), c)) {
              if (c != null && (!p || p.validate !== !1) && ba(v, Nt.call(Be, { key: `layers.${t}.layout.${n}`, layerType: v.type, objectKey: n, value: c, styleSpec: i.a3, style: { glyphs: !0, sprite: !0 } }))) return;
              v.setLayoutProperty(n, c), v.configDependencies.size !== 0 && this._configDependentLayers.add(v.fqid), this._updateLayer(v);
            }
          }
          getLayoutProperty(t, n) {
            const c = this._checkLayer(t);
            if (c) return c.getLayoutProperty(n);
          }
          setPaintProperty(t, n, c, p = {}) {
            this._checkLoaded();
            const v = this._checkLayer(t);
            if (!v || i.bn(v.getPaintProperty(n), c) || c != null && (!p || p.validate !== !1) && ba(v, Et.call(Be, { key: `layers.${t}.paint.${n}`, layerType: v.type, objectKey: n, value: c, styleSpec: i.a3 }))) return;
            const C = v.setPaintProperty(n, c);
            v.configDependencies.size !== 0 && this._configDependentLayers.add(v.fqid), C && this._updateLayer(v), this._changes.updatePaintProperties(v);
          }
          getPaintProperty(t, n) {
            const c = this._checkLayer(t);
            if (c) return c.getPaintProperty(n);
          }
          setFeatureState(t, n) {
            if (this._checkLoaded(), "target" in t) {
              if ("featuresetId" in t.target) {
                const { featuresetId: K, importId: se } = t.target, oe = this.getFragmentStyle(se), ve = oe.getFeaturesetLayers(K);
                for (const { source: xe, sourceLayer: Le } of ve) oe.setFeatureState({ id: t.id, source: xe, sourceLayer: Le }, n);
              } else if ("layerId" in t.target) {
                const { layerId: K } = t.target, se = this.getLayer(K);
                this.setFeatureState({ id: t.id, source: se.source, sourceLayer: se.sourceLayer }, n);
              }
              return;
            }
            const c = t.source, p = t.sourceLayer, v = this._checkSource(c);
            if (!v) return;
            const C = v.type;
            if (C === "geojson" && p) return void this.fire(new i.y(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
            if (C === "vector" && !p) return void this.fire(new i.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
            t.id === void 0 && this.fire(new i.y(new Error("The feature id parameter must be provided.")));
            const V = this.getOwnSourceCaches(c);
            for (const K of V) K.setFeatureState(p, t.id, n);
          }
          removeFeatureState(t, n) {
            if (this._checkLoaded(), "target" in t) {
              if ("featuresetId" in t.target) {
                const { featuresetId: K, importId: se } = t.target, oe = this.getFragmentStyle(se), ve = oe.getFeaturesetLayers(K);
                for (const { source: xe, sourceLayer: Le } of ve) oe.removeFeatureState({ id: t.id, source: xe, sourceLayer: Le }, n);
              } else if ("layerId" in t.target) {
                const { layerId: K } = t.target, se = this.getLayer(K);
                this.removeFeatureState({ id: t.id, source: se.source, sourceLayer: se.sourceLayer }, n);
              }
              return;
            }
            const c = t.source, p = this._checkSource(c);
            if (!p) return;
            const v = p.type, C = v === "vector" ? t.sourceLayer : void 0;
            if (v === "vector" && !C) return void this.fire(new i.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
            if (n && typeof t.id != "string" && typeof t.id != "number") return void this.fire(new i.y(new Error("A feature id is required to remove its specific state property.")));
            const V = this.getOwnSourceCaches(c);
            for (const K of V) K.removeFeatureState(C, t.id, n);
          }
          getFeatureState(t) {
            if (this._checkLoaded(), "target" in t) {
              let v;
              if ("featuresetId" in t.target) {
                const { featuresetId: C, importId: V } = t.target, K = this.getFragmentStyle(V), se = K.getFeaturesetLayers(C);
                for (const { source: oe, sourceLayer: ve } of se) {
                  const xe = K.getFeatureState({ id: t.id, source: oe, sourceLayer: ve });
                  if (xe && !v) v = xe;
                  else if (!i.bn(v, xe)) return void this.fire(new i.y(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
                }
              } else if ("layerId" in t.target) {
                const { layerId: C } = t.target, V = this.getLayer(C);
                v = this.getFeatureState({ id: t.id, source: V.source, sourceLayer: V.sourceLayer });
              }
              return v;
            }
            const n = t.source, c = t.sourceLayer, p = this._checkSource(n);
            if (p) {
              if (p.type !== "vector" || c) return t.id === void 0 && this.fire(new i.y(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(n)[0].getFeatureState(c, t.id);
              this.fire(new i.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
          }
          setTransition(t) {
            return this.stylesheet.transition = i.l({}, this.stylesheet.transition, t), this.transition = this.stylesheet.transition, this;
          }
          getTransition() {
            return i.l({}, this.stylesheet.transition);
          }
          serialize() {
            this._checkLoaded();
            const t = this.getTerrain(), n = t && this.terrain && this.terrain.scope === this.scope ? t : this.stylesheet.terrain;
            return i.cv({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: n, fog: this.stylesheet.fog, snow: this.stylesheet.snow, rain: this.stylesheet.rain, center: this.stylesheet.center, "color-theme": this.stylesheet["color-theme"], zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (c) => c !== void 0);
          }
          _updateFilteredLayers(t) {
            for (const n of Object.values(this._mergedLayers)) t(n) && this._updateLayer(n);
          }
          _updateLayer(t) {
            this._changes.updateLayer(t);
            const n = this.getLayerSourceCache(t), c = i.aC(t.source, t.scope), p = this._changes.getUpdatedSourceCaches();
            t.source && !p[c] && n && n.getSource().type !== "raster" && (this._changes.updateSourceCache(c, "reload"), n.pause()), t.invalidateCompiledFilter();
          }
          _flattenAndSortRenderedFeatures(t) {
            const n = (V) => this._mergedLayers[V].is3D(), c = this.order, p = {}, v = [];
            for (let V = c.length - 1; V >= 0; V--) {
              const K = c[V];
              if (n(K)) {
                p[K] = V;
                for (const se of t) {
                  const oe = se[K];
                  if (oe) for (const ve of oe) v.push(ve);
                }
              }
            }
            v.sort((V, K) => K.intersectionZ - V.intersectionZ);
            const C = [];
            for (let V = c.length - 1; V >= 0; V--) {
              const K = c[V];
              if (n(K)) for (let se = v.length - 1; se >= 0; se--) {
                const oe = v[se].feature;
                if (oe.layer && p[oe.layer.id] < V) break;
                C.push(oe), v.pop();
              }
              else for (const se of t) {
                const oe = se[K];
                if (oe) for (const ve of oe) C.push(ve.feature);
              }
            }
            return C;
          }
          queryRenderedFeatures(t, n, c) {
            let p;
            n && !Array.isArray(n) && n.filter && (this._validate($e, "queryRenderedFeatures.filter", n.filter, null, n), p = i.aZ(n.filter));
            const v = {}, C = (oe) => {
              if (Xi.has(oe.type)) return;
              const ve = this.getOwnLayerSourceCache(oe), xe = v[ve.id] = v[ve.id] || { sourceCache: ve, layers: {}, has3DLayers: !1 };
              oe.is3D() && (xe.has3DLayers = !0), xe.layers[oe.fqid] = xe.layers[oe.fqid] || { styleLayer: oe, targets: [] }, xe.layers[oe.fqid].targets.push({ filter: p });
            };
            if (n && n.layers) {
              if (!Array.isArray(n.layers)) return this.fire(new i.y(new Error("parameters.layers must be an Array."))), [];
              for (const oe of n.layers) {
                const ve = this._layers[oe];
                if (!ve) return this.fire(new i.y(new Error(`The layer '${oe}' does not exist in the map's style and cannot be queried for features.`))), [];
                C(ve);
              }
            } else for (const oe in this._layers) C(this._layers[oe]);
            const V = this._queryRenderedFeatures(t, v, c), K = this._flattenAndSortRenderedFeatures(V), se = [];
            for (const oe of K) i.cs(oe.layer.id) === this.scope && se.push(oe);
            return se;
          }
          queryRenderedFeatureset(t, n, c) {
            let p;
            n && !Array.isArray(n) && n.filter && (this._validate($e, "queryRenderedFeatures.filter", n.filter, null, n), p = i.aZ(n.filter));
            const v = "mock", C = [];
            if (n && n.target) C.push(Object.assign({}, n, { targetId: v, filter: p }));
            else {
              const oe = this.getFeaturesetDescriptors();
              for (const ve of oe) C.push({ targetId: v, filter: p, target: ve });
              for (const { style: ve } of this.fragments) {
                const xe = ve.getFeaturesetDescriptors();
                for (const Le of xe) C.push({ targetId: v, filter: p, target: Le });
              }
            }
            const V = this.queryRenderedTargets(t, C, c), K = [], se = /* @__PURE__ */ new Set();
            for (const oe of V) for (const ve of oe.variants[v]) ea(ve, oe, se) || K.push(new i.cw(oe, ve));
            return K;
          }
          queryRenderedTargets(t, n, c) {
            const p = {}, v = (V, K, se, oe) => {
              const ve = p[K.id] = p[K.id] || { sourceCache: K, layers: {}, has3DLayers: !1 };
              if (ve.layers[V.fqid] = ve.layers[V.fqid] || { styleLayer: V, targets: [] }, V.is3D() && (ve.has3DLayers = !0), !oe) return se.uniqueFeatureID = !1, void ve.layers[V.fqid].targets.push(se);
              ve.layers[V.fqid].targets.push(Object.assign({}, se, { namespace: oe.namespace, properties: oe.properties, uniqueFeatureID: oe.uniqueFeatureID }));
            };
            for (const V of n) if ("featuresetId" in V.target) {
              const { featuresetId: K, importId: se } = V.target, oe = this.getFragmentStyle(se);
              if (!oe || !oe._featuresetSelectors) continue;
              const ve = oe._featuresetSelectors[K];
              if (!ve) {
                this.fire(new i.y(new Error(`The featureset '${K}' does not exist in the map's style and cannot be queried for features.`)));
                continue;
              }
              for (const xe of ve) {
                const Le = oe.getOwnLayer(xe.layerId);
                Le && !Xi.has(Le.type) && v(Le, oe.getOwnLayerSourceCache(Le), V, xe);
              }
            } else if ("layerId" in V.target) {
              const { layerId: K } = V.target, se = this.getLayer(K);
              if (!se || Xi.has(se.type)) continue;
              v(se, this.getLayerSourceCache(se), V);
            }
            const C = this._queryRenderedFeatures(t, p, c);
            return this._flattenAndSortRenderedFeatures(C);
          }
          _queryRenderedFeatures(t, n, c) {
            const p = [], v = !!this.map._showQueryGeometry, C = dr.createFromScreenPoints(t, c);
            for (const V in n) {
              const K = ga(C, n[V], this._availableImages, c, v);
              Object.keys(K).length && p.push(K);
            }
            if (this.placement) for (const V in n) {
              if (!n[V].sourceCache._onlySymbols) continue;
              const K = Ta(C.screenGeometry, n[V], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData);
              Object.keys(K).length && p.push(K);
            }
            return p;
          }
          querySourceFeatures(t, n) {
            const c = n && n.filter;
            c && this._validate($e, "querySourceFeatures.filter", c, null, n);
            let p = [];
            const v = this.getOwnSourceCaches(t);
            for (const C of v) p = p.concat(ha(C, n));
            return p;
          }
          addSourceType(t, n, c) {
            return Hr.getSourceType(t) ? c(new Error(`A source type called "${t}" already exists.`)) : (Hr.setSourceType(t, n), n.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t, url: n.workerSourceURL }, c) : c(null, null));
          }
          getFlatLight() {
            return this.light.getLight();
          }
          setFlatLight(t, n, c = {}) {
            this._checkLoaded();
            const p = this.light.getLight();
            let v = !1;
            for (const V in t) if (!i.bn(t[V], p[V])) {
              v = !0;
              break;
            }
            if (!v) return;
            const C = this._getTransitionParameters();
            this.light.setLight(t, n, c), this.light.updateTransitions(C);
          }
          getTerrain() {
            return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null;
          }
          setTerrainForDraping() {
            this.setTerrain({ source: "", exaggeration: 0 }, 0);
          }
          checkCanvasFingerprintNoise() {
            this.disableElevatedTerrain === void 0 && (this.disableElevatedTerrain = i.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && i.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
          }
          setTerrain(t, n = 1) {
            if (this._checkLoaded(), !t) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), n === 0 && delete this.terrain, t === null ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
            this.checkCanvasFingerprintNoise();
            let c = t;
            const p = t.source == null;
            if (n === 1) {
              if (this.disableElevatedTerrain) return;
              if (typeof c.source == "object") {
                const V = "terrain-dem-src";
                this.addSource(V, c.source), c = i.cp(c), c = i.l(c, { source: V });
              }
              const v = i.l({}, c), C = {};
              if (this.terrain && p) {
                v.source = this.terrain.get().source;
                const V = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                V && (C.style = V.serialize());
              }
              if (this._validate(Xe, "terrain", v, C)) return;
            }
            if (!this.terrain || this.terrain.scope !== this.scope && !p || this.terrain && n !== this.terrain.drapeRenderMode) {
              if (!c) return;
              this._createTerrain(c, n), this.fire(new i.z("data", { dataType: "style" }));
            } else {
              const v = this.terrain, C = v.get();
              for (const V of Object.keys(i.a3.terrain)) !c.hasOwnProperty(V) && i.a3.terrain[V].default && (c[V] = i.a3.terrain[V].default);
              for (const V in t) if (!i.bn(t[V], C[V])) {
                v.set(t, this.options), this.stylesheet.terrain = t;
                const K = this._getTransitionParameters({ duration: 0 });
                v.updateTransitions(K), this.fire(new i.z("data", { dataType: "style" }));
                break;
              }
            }
            this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
          }
          _createFog(t) {
            const n = this.fog = new ei(t, this.map.transform, this.scope, this.options);
            this.stylesheet.fog = n.get();
            const c = this._getTransitionParameters({ duration: 0 });
            n.updateTransitions(c);
          }
          _createSnow(t) {
            const n = this.snow = new Hi(t, this.map.transform, this.scope, this.options);
            this.stylesheet.snow = n.get();
            const c = this._getTransitionParameters({ duration: 0 });
            n.updateTransitions(c);
          }
          _createRain(t) {
            const n = this.rain = new nr(t, this.map.transform, this.scope, this.options);
            this.stylesheet.rain = n.get();
            const c = this._getTransitionParameters({ duration: 0 });
            n.updateTransitions(c);
          }
          _updateMarkersOpacity() {
            this.map._markers.length !== 0 && this.map._requestDomTask(() => {
              for (const t of this.map._markers) t._evaluateOpacity();
            });
          }
          getFog() {
            return this.fog ? this.fog.get() : null;
          }
          setFog(t) {
            if (this._checkLoaded(), !t) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
            if (this.fog) {
              const n = this.fog;
              if (!i.bn(n.get(), t)) {
                n.set(t, this.options), this.stylesheet.fog = n.get();
                const c = this._getTransitionParameters({ duration: 0 });
                n.updateTransitions(c);
              }
            } else this._createFog(t);
            this._markersNeedUpdate = !0;
          }
          getSnow() {
            return this.snow ? this.snow.get() : null;
          }
          setSnow(t) {
            if (this._checkLoaded(), !t) return delete this.snow, void delete this.stylesheet.snow;
            if (this.snow) {
              const n = this.snow;
              if (!i.bn(n.get(), t)) {
                n.set(t, this.options), this.stylesheet.snow = n.get();
                const c = this._getTransitionParameters({ duration: 0 });
                n.updateTransitions(c);
              }
            } else this._createSnow(t);
            this._markersNeedUpdate = !0;
          }
          getRain() {
            return this.rain ? this.rain.get() : null;
          }
          setRain(t) {
            if (this._checkLoaded(), !t) return delete this.rain, void delete this.stylesheet.rain;
            if (this.rain) {
              const n = this.rain;
              if (!i.bn(n.get(), t)) {
                n.set(t, this.options), this.stylesheet.rain = n.get();
                const c = this._getTransitionParameters({ duration: 0 });
                n.updateTransitions(c);
              }
            } else this._createRain(t);
            this._markersNeedUpdate = !0;
          }
          _reloadColorTheme() {
            const t = () => {
              for (const p in this._layers) this._layers[p].lut = this._styleColorTheme.lut;
              for (const p in this._sourceCaches) this._sourceCaches[p].clearTiles();
            }, n = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
            if (!n) return this._styleColorTheme.lut = null, void t();
            const c = this._evaluateColorThemeData(n);
            this._loadColorTheme(c).then(() => {
              this.fire(new i.z("colorthemeset")), t();
            }).catch((p) => {
              i.w(`Couldn't set color theme: ${p}`);
            });
          }
          setColorTheme(t) {
            this._checkLoaded(), this._styleColorTheme.colorThemeOverride && i.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t, this._reloadColorTheme();
          }
          setImportColorTheme(t, n) {
            const c = this.getFragmentStyle(t);
            c && (c._styleColorTheme.colorThemeOverride = n, c._reloadColorTheme());
          }
          _getTransitionParameters(t) {
            return { now: i.q.now(), transition: i.l(this.transition, t) };
          }
          updateDrapeFirstLayers() {
            if (!this.terrain) return;
            const t = [], n = [];
            for (const c of this._mergedOrder) this.isLayerDraped(this._mergedLayers[c]) ? t.push(c) : n.push(c);
            this._drapedFirstOrder = [], this._drapedFirstOrder.push(...t), this._drapedFirstOrder.push(...n);
          }
          _createTerrain(t, n) {
            const c = this.terrain = new Fe(t, n, this.scope, this.options);
            n === 1 && (this.stylesheet.terrain = t), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
            const p = this._getTransitionParameters({ duration: 0 });
            c.updateTransitions(p);
          }
          _force3DLayerUpdate() {
            for (const t in this._layers) {
              const n = this._layers[t];
              n.type === "fill-extrusion" && this._updateLayer(n);
            }
          }
          _forceSymbolLayerUpdate() {
            for (const t in this._layers) {
              const n = this._layers[t];
              n.type === "symbol" && this._updateLayer(n);
            }
          }
          _validate(t, n, c, p, v = {}) {
            if (v && v.validate === !1) return !1;
            const C = i.l({}, this.serialize());
            return ba(this, t.call(Be, i.l({ key: n, style: C, value: c, styleSpec: i.a3 }, p)));
          }
          _remove() {
            this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), i.cx.off("pluginStateChange", this._rtlTextPluginCallback);
            for (const t in this._mergedLayers) this._mergedLayers[t].setEventedParent(null);
            for (const t in this._mergedSourceCaches) this._mergedSourceCaches[t].clearTiles(), this._mergedSourceCaches[t].setEventedParent(null);
            this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
          }
          clearSource(t) {
            const n = this.getSourceCaches(t);
            for (const c of n) c.clearTiles();
          }
          clearSources() {
            for (const t in this._mergedSourceCaches) this._mergedSourceCaches[t].clearTiles();
          }
          reloadSource(t) {
            const n = this.getSourceCaches(t);
            for (const c of n) c.resume(), c.reload();
          }
          reloadSources() {
            for (const t of this.getSources()) t.reload && t.reload();
          }
          reloadModels() {
            this.modelManager.reloadModels(""), this.forEachFragmentStyle((t) => {
              t.modelManager.reloadModels(t.scope);
            });
          }
          updateSources(t) {
            let n;
            this.directionalLight && (n = no(this.directionalLight));
            for (const c in this._mergedSourceCaches) this._mergedSourceCaches[c].update(t, void 0, void 0, n);
          }
          _generateCollisionBoxes() {
            for (const t in this._sourceCaches) {
              const n = this._sourceCaches[t];
              n.resume(), n.reload();
            }
          }
          _updatePlacement(t, n, c, p, v, C, V = !1) {
            let K = !1, se = !1;
            const oe = {}, ve = {};
            for (const xe of this._mergedOrder) {
              const Le = this._mergedLayers[xe];
              if (Le.type !== "symbol") continue;
              const ft = i.aC(Le.source, Le.scope);
              let st = oe[ft];
              if (!st) {
                const gt = this.getLayerSourceCache(Le);
                if (!gt) continue;
                const Rt = gt.getRenderableIds(!0).map((qt) => gt.getTileByID(qt));
                ve[ft] = Rt.slice(), st = oe[ft] = Rt.sort((qt, jt) => jt.tileID.overscaledZ - qt.tileID.overscaledZ || (qt.tileID.isLessThan(jt.tileID) ? -1 : 1));
              }
              const vt = this.crossTileSymbolIndex.addLayer(Le, st, n.center.lng, n.projection);
              K = K || vt;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), V = V || this._layerOrderChanged || p === 0, this._layerOrderChanged && this.fire(new i.z("neworder")), (V || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(i.q.now(), n.zoom)) && (this.pauseablePlacement = new Ol(n, this._mergedOrder, V, c, p, v, this.placement, this.fog && n.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, oe, ve, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(i.q.now()), se = !0), K && this.pauseablePlacement.placement.setStale()), se || K) {
              this._buildingIndex.onNewFrame(n.zoom);
              for (let xe = 0; xe < this._mergedOrder.length; xe++) {
                const Le = this._mergedLayers[this._mergedOrder[xe]];
                if (Le.type !== "symbol") continue;
                const ft = this.isLayerClipped(Le);
                this.placement.updateLayerOpacities(Le, oe[i.aC(Le.source, Le.scope)], xe, ft ? C : null);
              }
            }
            return { needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(i.q.now()) };
          }
          _releaseSymbolFadeTiles() {
            for (const t in this._sourceCaches) this._sourceCaches[t].releaseSymbolFadeTiles();
          }
          addImport(t, n) {
            this._checkLoaded();
            const c = this.stylesheet.imports = this.stylesheet.imports || [];
            if (c.findIndex(({ id: v }) => v === t.id) !== -1) return void this.fire(new i.y(new Error(`Import with id '${t.id}' already exists in the map's style.`)));
            if (!n) return c.push(t), this._loadImports([t], !0);
            const p = c.findIndex(({ id: v }) => v === n);
            return p === -1 && this.fire(new i.y(new Error(`Import with id "${n}" does not exist on this map.`))), this.stylesheet.imports = c.slice(0, p).concat(t).concat(c.slice(p)), this._loadImports([t], !0, n);
          }
          updateImport(t, n) {
            this._checkLoaded();
            const c = this.stylesheet.imports || [], p = this.getImportIndex(t);
            return p === -1 ? this : typeof n == "string" ? (this.setImportUrl(t, n), this) : (n.url && n.url !== c[p].url && this.setImportUrl(t, n.url), i.bn(n.config, c[p].config) || this.setImportConfig(t, n.config, n.data.schema), i.bn(n.data, c[p].data) || this.setImportData(t, n.data), this);
          }
          moveImport(t, n) {
            this._checkLoaded();
            let c = this.stylesheet.imports || [];
            const p = this.getImportIndex(t);
            if (p === -1) return this;
            const v = this.getImportIndex(n);
            if (v === -1) return this;
            const C = c[p], V = this.fragments[p];
            return c = c.filter(({ id: K }) => K !== t), this.fragments = this.fragments.filter(({ id: K }) => K !== t), this.stylesheet.imports = c.slice(0, v).concat(C).concat(c.slice(v)), this.fragments = this.fragments.slice(0, v).concat(V).concat(this.fragments.slice(v)), this.mergeLayers(), this;
          }
          setImportUrl(t, n) {
            this._checkLoaded();
            const c = this.stylesheet.imports || [], p = this.getImportIndex(t);
            if (p === -1) return this;
            c[p].url = n;
            const v = this.fragments[p];
            return v.style = this._createFragmentStyle(c[p]), v.style.on("style.import.load", () => this.mergeAll()), v.style.loadURL(n), this;
          }
          setImportData(t, n) {
            this._checkLoaded();
            const c = this.getImportIndex(t), p = this.stylesheet.imports || [];
            return c === -1 ? this : n ? (this.fragments[c].style.setState(n), this._reloadImports(), this) : (delete p[c].data, this.setImportUrl(t, p[c].url));
          }
          setImportConfig(t, n, c) {
            this._checkLoaded();
            const p = this.getImportIndex(t), v = this.stylesheet.imports || [];
            if (p === -1) return this;
            n ? v[p].config = n : delete v[p].config;
            const C = this.fragments[p];
            c && C.style.stylesheet && (C.style.stylesheet.schema = c);
            const V = C.style.stylesheet && C.style.stylesheet.schema;
            return C.config = n, C.style.updateConfig(n, V), this.updateConfigDependencies(), this;
          }
          removeImport(t) {
            this._checkLoaded();
            const n = this.stylesheet.imports || [], c = this.getImportIndex(t);
            c !== -1 && (n.splice(c, 1), this.fragments[c].style._remove(), this.fragments.splice(c, 1), this._reloadImports());
          }
          getImportIndex(t) {
            const n = (this.stylesheet.imports || []).findIndex((c) => c.id === t);
            return n === -1 && this.fire(new i.y(new Error(`Import '${t}' does not exist in the map's style and cannot be updated.`))), n;
          }
          getLayer(t) {
            return this._mergedLayers[t];
          }
          getSources() {
            const t = [];
            for (const n in this._mergedOtherSourceCaches) {
              const c = this._mergedOtherSourceCaches[n];
              c && t.push(c.getSource());
            }
            return t;
          }
          getSource(t, n) {
            const c = this.getSourceCache(t, n);
            return c && c.getSource();
          }
          getLayerSource(t) {
            const n = this.getLayerSourceCache(t);
            return n && n.getSource();
          }
          getSourceCache(t, n) {
            const c = i.aC(t, n);
            return this._mergedOtherSourceCaches[c];
          }
          getLayerSourceCache(t) {
            const n = i.aC(t.source, t.scope);
            return t.type === "symbol" ? this._mergedSymbolSourceCaches[n] : this._mergedOtherSourceCaches[n];
          }
          getSourceCaches(t) {
            if (t == null) return Object.values(this._mergedSourceCaches);
            const n = [];
            return this._mergedOtherSourceCaches[t] && n.push(this._mergedOtherSourceCaches[t]), this._mergedSymbolSourceCaches[t] && n.push(this._mergedSymbolSourceCaches[t]), n;
          }
          updateSourceCaches() {
            const t = this._changes.getUpdatedSourceCaches();
            for (const n in t) {
              const c = t[n];
              c === "reload" ? this.reloadSource(n) : c === "clear" && this.clearSource(n);
            }
          }
          updateLayers(t) {
            const n = this._changes.getUpdatedPaintProperties();
            for (const c of n) {
              const p = this.getLayer(c);
              p && p.updateTransitions(t);
            }
          }
          getImages(t, n, c) {
            this.imageManager.getImages(n.icons, n.scope, c), this._updateTilesForChangedImages();
            const p = (v) => {
              v && v.setDependencies(n.tileID.key, n.type, n.icons);
            };
            p(this._otherSourceCaches[n.source]), p(this._symbolSourceCaches[n.source]);
          }
          rasterizeImages(t, n, c) {
            this.imageManager.rasterizeImages(n, c);
          }
          getGlyphs(t, n, c) {
            this.glyphManager.getGlyphs(n.stacks, n.scope, c);
          }
          getResource(t, n, c) {
            return i.cy(n, c);
          }
          getOwnSourceCache(t) {
            return this._otherSourceCaches[t];
          }
          getOwnLayerSourceCache(t) {
            return t.type === "symbol" ? this._symbolSourceCaches[t.source] : this._otherSourceCaches[t.source];
          }
          getOwnSourceCaches(t) {
            const n = [];
            return this._otherSourceCaches[t] && n.push(this._otherSourceCaches[t]), this._symbolSourceCaches[t] && n.push(this._symbolSourceCaches[t]), n;
          }
          _isSourceCacheLoaded(t) {
            const n = this.getOwnSourceCaches(t);
            return n.length === 0 ? (this.fire(new i.y(new Error(`There is no source with ID '${t}'`))), !1) : n.every((c) => c.loaded());
          }
          has3DLayers() {
            return this._has3DLayers;
          }
          hasSymbolLayers() {
            return this._hasSymbolLayers;
          }
          hasCircleLayers() {
            return this._hasCircleLayers;
          }
          isLayerClipped(t, n) {
            if (!this._clipLayerPresent && t.type !== "fill-extrusion") return !1;
            const c = t.type === "fill-extrusion" && t.sourceLayer === "building";
            if (t.is3D()) {
              if (c || n && n.type === "batched-model" || t.type === "model") return !0;
            } else if (t.type === "symbol") return !0;
            return !1;
          }
          _clearWorkerCaches() {
            this.dispatcher.broadcast("clearCaches");
          }
          destroy() {
            this._clearWorkerCaches(), this.fragments.forEach((t) => {
              t.style._remove();
            }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
          }
        }
        Hr.getSourceType = function(u) {
          return Vn[u];
        }, Hr.setSourceType = function(u, t) {
          Vn[u] = t;
        }, Hr.registerForPluginStateChange = i.ch;
        var on = `
#define EPSILON 0.0000001
#define PI 3.141592653589793
#ifdef RENDER_CUTOFF
float cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}
#endif`, Mn = `
out vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
#ifdef INDICATOR_CUTOUT
uniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;
#endif
vec4 applyCutout(vec4 color,float height) {
#ifdef INDICATOR_CUTOUT
float verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);
#else
return color;
#endif
}
#ifdef DEBUG_WIREFRAME
#define HANDLE_WIREFRAME_DEBUG \\
glFragColor=vec4(0.7,0.0,0.0,0.7); \\
gl_FragDepth=gl_FragCoord.z-0.0001;
#else
#define HANDLE_WIREFRAME_DEBUG
#endif
#ifdef RENDER_CUTOFF
uniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;
#endif
vec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}`, Va = `
#define EXTENT 8192.0
#define RAD_TO_DEG 180.0/PI
#define DEG_TO_RAD PI/180.0
#define GLOBE_RADIUS EXTENT/PI/2.0
float wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}
#ifdef PROJECTION_GLOBE_VIEW
vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {
#ifndef PROJECTED_POS_ON_VIEWPORT
float tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;
#else
return vec3(0.0);
#endif
}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(
unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}
#ifdef RENDER_CUTOFF
uniform vec4 u_cutoff_params;out float v_cutoff_opacity;
#endif
const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)
{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}`, cs = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", go = `
#define ELEVATION_SCALE 7.0
#define ELEVATION_OFFSET 450.0
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(
mix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}
#else
vec3 elevationVector(vec2 pos) { return vec3(0,0,1); }
#endif
#ifdef TERRAIN
uniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}float prevElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}
#ifdef TERRAIN_VERTEX_MORPHING
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}
#else
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
return currentElevation(apos);}
#endif
vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}
#else
float elevation(vec2 pos) { return 0.0; }
#endif
#ifdef DEPTH_OCCLUSION
uniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;
#ifdef DEPTH_D24
float unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}
#else
highp float unpack_depth_rgba(vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;
#ifdef DEPTH_D24
float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);
#else
float depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));
#endif
return coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;
#ifdef DEPTH_D24
highp vec4 depth=vec4(
texture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r
);depth=unpack_depth4(depth);
#else
highp vec4 depth=vec4(
unpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))
);
#endif
return depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));
#endif
res+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}
#else
bool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }
#endif//DEPTH_OCCLUSION`, qo = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}
#endif`, Wo = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}
#endif`, ml = `#ifdef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)
);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)
);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}
#endif`, Zo = `#ifdef RASTER_ARRAY
uniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}
#endif
uniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}`, cu = `#ifdef RENDER_SHADOWS
uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}
#endif//RENDER_SHADOWS`, Dl = `#ifdef RENDER_SHADOWS
#ifdef DEPTH_TEXTURE
uniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;
#else
uniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;
#endif
uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_1,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_0,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;
#ifdef TEXTURE_GATHER
highp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));
#else
highp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(
shadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)
);
#endif
vec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {
#ifdef SHADOWS_SINGLE_CASCADE
light_view_pos0.xyz/=light_view_pos0.w;vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);
#else
light_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));
#endif
}highp float calculate_shadow_bias(float NDotL) {
#ifdef NORMAL_OFFSET
return 0.5*u_shadow_bias.x;
#else
return 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));
#endif
}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)
{highp vec2 biasUV=vec2(
pos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}
#endif`;
        const $o = [];
        zl(on, $o), zl(Va, $o), zl(Mn, $o);
        const hu = { "_prelude_fog.vertex.glsl": qo, "_prelude_terrain.vertex.glsl": go, "_prelude_shadow.vertex.glsl": cu, "_prelude_fog.fragment.glsl": Wo, "_prelude_shadow.fragment.glsl": Dl, "_prelude_lighting.glsl": `
#ifdef LIGHTING_3D_MODE
uniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}
#endif//LIGHTING_3D_MODE`, "_prelude_raster_array.glsl": ml, "_prelude_raster_particle.glsl": Zo }, ec = {};
        Qr("", go), Qr(Wo, qo), Qr(Dl, cu), Qr(ml, ""), Qr(Zo, "");
        const Lc = Qr(Mn, Va), tc = on;
        var fu = { background: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec4 u_color;uniform float u_opacity;
#ifdef LIGHTING_3D_MODE
in vec4 v_color;
#endif
void main() {vec4 out_color;
#ifdef LIGHTING_3D_MODE
out_color=v_color;
#else
out_color=u_color;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_lighting.glsl"
in vec2 a_pos;uniform mat4 u_matrix;
#ifdef LIGHTING_3D_MODE
uniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), backgroundPattern: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), circle: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
uniform float u_emissive_strength;void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? 
smoothstep(0.0,-antialiased_blur,1.0-extrude_length) : 
smoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(
antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)
);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_apply_premultiplied(out_color,v_fog_pos);
#endif
glFragColor=out_color*(v_visibility*opacity_t);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define NUM_VISIBILITY_RINGS 2
#define INV_SQRT2 0.70710678
#define ELEVATION_BIAS 0.0001
#define NUM_SAMPLES_PER_RING 16
uniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
#ifdef ELEVATED_ROADS
in float a_circle_z_offset;
#endif
out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
vec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {
#if defined(TERRAIN)
return elevation(pos)+ELEVATION_BIAS;
#else
return 0.0;
#endif
}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);
#ifdef PITCH_WITH_MAP
#ifdef PROJECTION_GLOBE_VIEW
return u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );
#else
return u_matrix*( world_center+vec4(sample_offset,0,0) );
#endif
#else
return projected_center+vec4(sample_offset,0,0);
#endif
}float get_sample_step() {
#ifdef PITCH_WITH_MAP
return 2.0*PI/float(NUM_SAMPLES_PER_RING);
#else
return PI/float(NUM_SAMPLES_PER_RING);
#endif
}void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);
#else 
surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);
#endif
#ifdef ELEVATED_ROADS
world_center.z+=a_circle_z_offset+ELEVATION_BIAS;
#endif
vec4 projected_center=u_matrix*world_center;float view_scale=0.0;
#ifdef PITCH_WITH_MAP
#ifdef SCALE_WITH_MAP
view_scale=1.0;
#else
view_scale=projected_center.w/u_camera_to_center_distance;
#endif
#else
#ifdef SCALE_WITH_MAP
view_scale=u_camera_to_center_distance;
#else
view_scale=projected_center.w;
#endif
#endif
gl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;
#ifdef TERRAIN
float step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;
#ifdef PITCH_WITH_MAP
float cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;
#else
occlusion_world_center=world_center;occlusion_projected_center=projected_center;
#endif
for(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);
#else
visibility=1.0;
#endif
#ifdef PROJECTION_GLOBE_VIEW
visibility=1.0;
#endif
v_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);
#ifdef FOG
v_fog_pos=fog_position(world_center.xyz);
#endif
}`), clippingMask: Qr("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Qr(`#include "_prelude_fog.fragment.glsl"
uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);
#ifdef FOG
if (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#else
pos=vec3(tilePos+extrude,elevation(tilePos));
#endif
gl_Position=u_matrix*vec4(pos,1);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), heatmapTexture: Qr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(0.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Qr("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", `#include "_prelude_terrain.vertex.glsl"
in vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}`), collisionCircle: Qr("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", `in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(
mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}`), debug: Qr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", `#include "_prelude_terrain.vertex.glsl"
in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;
#endif
out vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
gl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);
#else
gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);
#endif
}`), fill: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
vec4 out_color=color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=opacity;
#ifdef INDICATOR_CUTOUT
if (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=z_offset;
#endif
}`), fillOutline: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillOutlinePattern: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
in highp vec2 v_pos;in highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;out highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillPattern: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillExtrusion: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec4 v_color;in vec4 v_flat;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;
#endif
uniform lowp float u_opacity;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec2 v_ao;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
in vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
in highp vec3 v_normal;
#endif
uniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
in float v_flood_radius;in float v_has_floodlight;
#endif
in float v_height;
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float emissive_strength
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
vec3 normal=normalize(v_normal);
#endif
float z;vec4 color=v_color;
#ifdef ZERO_ROOF_RADIUS
z=float(normal.z > 0.00001);
#ifdef LIGHTING_3D_MODE
normal=mix(normal,vec3(0.0,0.0,1.0),z);
#else
color=mix(v_color,v_roof_color,z);
#endif
#endif
float h=max(0.0,v_height);float ao_shade=1.0;
#ifdef FAUX_AO
float intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;
#ifdef ZERO_ROOF_RADIUS
concave*=(1.0-z);
#endif
float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
color.rgb*=mix(ao_shade,1.0,v_has_floodlight);
#else
color.rgb*=ao_shade;
#endif
#else
color.rgb*=ao_shade;
#endif
#endif
#ifdef LIGHTING_3D_MODE
float flood_radiance=0.0;
#ifdef FLOOD_LIGHT
flood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;
#endif
#ifdef RENDER_SHADOWS
#ifdef FLOOD_LIGHT
float ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);
#else
float shadowed_lighting_factor;
#ifdef RENDER_CUTOFF
shadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}
#else
shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);
#endif
color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);
#endif
#else
color.rgb=apply_lighting(color.rgb,normal);
#ifdef FLOOD_LIGHT
color.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);
#endif
#endif
color.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));
#endif
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,h);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
uniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
out vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
out highp vec3 v_normal;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec2 v_ao;
#endif
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
out float v_flood_radius;out float v_has_floodlight;
#endif
out float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define highp float flood_light_wall_radius
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize highp float flood_light_wall_radius
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp float emissive_strength
base*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
v_normal=normal;
#endif
base=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
h=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float cutoff=1.0;vec3 scaled_pos=pos;
#ifdef RENDER_CUTOFF
vec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=pos;vec3 shd_pos1=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);
#endif
float NdotL=0.0;float colorvalue=0.0;
#ifndef LIGHTING_3D_MODE
colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#endif
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
float is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;
#endif
v_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);
#else
v_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
float roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), fillExtrusionDepth: Qr(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp vec4 color
out highp float v_depth;void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp vec4 color
base*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
pos=vec3(pos_nx.xy,t > 0.0 ? height : base);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}`), fillExtrusionPattern: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
in vec3 v_normal;
#endif
in highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define highp float pixel_ratio
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize highp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;
#else
out_color=out_color*v_lighting;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,height);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
out highp vec2 v_pos;out vec4 v_lighting;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
out vec3 v_normal;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define highp float pixel_ratio
#pragma mapbox: define highp float line_width
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize highp float pixel_ratio
#pragma mapbox: initialize highp float line_width
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=z;vec3 p;float c_ele;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);
#else
p=vec3(pos_nx.xy,z);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0
? pos_nx.xy
: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_normal=normal;
#else
v_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;
#endif 
#ifdef FOG
v_fog_pos=fog_position(p);
#endif
}`), groundShadow: Qr(`#include "_prelude_shadow.fragment.glsl"
precision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#ifdef FOG
in float v_fog_opacity;
#endif
void main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);
#ifdef RENDER_CUTOFF
shadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));
#endif
#ifdef FOG
shadow=mix(shadow,vec3(1.0),v_fog_opacity);
#endif
#ifdef INDICATOR_CUTOUT
shadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);
#endif
glFragColor=vec4(shadow,1.0);}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;
#ifdef FOG
out float v_fog_opacity;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);
#ifdef FOG
v_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);
#endif
}`), fillExtrusionGroundEffect: Qr(`uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;
#ifdef SDF_SUBPASS
in highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}
#ifdef FOG
in highp float v_fog;
#endif
#endif
void main() {
#ifdef CLEAR_SUBPASS
vec4 color=vec4(1.0);
#ifdef CLEAR_FROM_TEXTURE
color=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));
#endif
glFragColor=color;
#else
#ifdef SDF_SUBPASS
highp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;
#ifdef FOG
fog=v_fog;
#endif
#ifdef RENDER_CUTOFF
fog*=v_cutoff_opacity;
#endif
glFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));
#else
vec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);
#ifdef OVERDRAW_INSPECTOR
color=vec4(1.0);
#endif
glFragColor=color;
#endif
HANDLE_WIREFRAME_DEBUG;
#endif
}`, `#include "_prelude_fog.vertex.glsl"
in highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;
#ifdef SDF_SUBPASS
out highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;
#ifdef FOG
out highp float v_fog;
#endif
#endif
uniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;
#pragma mapbox: define highp float flood_light_ground_radius
const float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {
#pragma mapbox: initialize highp float flood_light_ground_radius
vec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;
#ifdef SDF_SUBPASS
v_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);
#ifdef FOG
v_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);
#endif
#endif
float hidden_by_landmark=0.0;
#ifdef HAS_CENTROID
hidden_by_landmark=a_hidden_by_landmark;
#endif
float isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
}`), hillshadePrepare: Qr(`precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(
(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)
)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(
deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef LIGHTING_3D_MODE
glFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);
#endif
#ifdef FOG
glFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), line: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform sampler2D u_dash_image;in vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform sampler2D u_gradient_image;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
float linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);
#ifdef RENDER_LINE_DASH
float sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);
#endif
highp vec4 out_color;
#ifdef RENDER_LINE_GRADIENT
out_color=texture(u_gradient_image,v_uv.xy);
#else
out_color=color;
#endif
float trim_alpha=1.0;
#ifdef RENDER_LINE_TRIM_OFFSET
highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}
#endif
if (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}
#ifdef RENDER_LINE_BORDER
float edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
out_color.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=(alpha*opacity);
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define EXTRUDE_SCALE 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)
in vec3 a_z_offset_width;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
in highp vec3 a_packed;
#endif
#ifdef RENDER_LINE_DASH
in float a_linesofar;
#endif
uniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform float u_image_height;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;
#ifdef VARIABLE_LINE_WIDTH
float left=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);halfwidth=(u_width_scale*(left==1.0 ? a_z_offset_width.y : a_z_offset_width.z))/2.0;
#else
halfwidth=(u_width_scale*width)/2.0;
#endif
offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
highp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];
#ifdef RENDER_LINE_GRADIENT
highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);
#else
v_uv=vec3(a_uv_x,0.0,line_progress);
#endif
#endif
#ifdef RENDER_LINE_DASH
float scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);
#endif
v_width2=vec2(outset,inset);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`), linePattern: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec3 v_uv;
#endif
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef LINE_JOIN_NONE
in vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
uniform float u_emissive_strength;
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define mediump float pixel_ratio
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize mediump float pixel_ratio
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);
#ifdef RENDER_LINE_TRIM_OFFSET
highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}
#endif
#ifdef LINE_JOIN_NONE
highp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}
#endif
#ifdef LIGHTING_3D_MODE
color=apply_lighting_with_emission_ground(color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
color.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,v_z_offset);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
in vec3 a_z_offset_width;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec3 a_packed;
#endif
in highp float a_linesofar;
#ifdef LINE_JOIN_NONE
in highp vec3 a_pattern_data;out vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
out highp vec3 v_uv;
#endif
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
#pragma mapbox: define mediump float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define mediump float floorwidth
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define mediump float pixel_ratio
void main() {
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
#pragma mapbox: initialize mediump float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize mediump float floorwidth
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize mediump float pixel_ratio
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
highp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);
#ifdef LINE_JOIN_NONE
v_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`), raster: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_raster_array.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
in float v_split_fade;
#endif
uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;
#ifndef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;
#endif
#ifdef RASTER_COLOR
uniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;
#endif
void main() {vec4 color0,color1,color;vec2 value;
#ifdef RASTER_COLOR
#ifdef RASTER_ARRAY
#ifdef RASTER_ARRAY_LINEAR
value=mix(
raTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#else
value=mix(
raTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#endif
if (value.y > 0.0) value.x/=value.y;
#else
color=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);
#endif
color=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;
#else
color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);
#endif
color.a*=u_opacity;
#ifdef GLOBE_POLES
color.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);
#endif
vec3 rgb=color.rgb;rgb=vec3(
dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef PROJECTION_GLOBE_VIEW
glFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));
#endif
#ifdef RENDER_CUTOFF
glFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;in vec2 a_texture_pos;
#endif
out vec2 v_pos0;out vec2 v_pos1;out float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
out float v_split_fade;
#endif
void main() {vec2 uv;
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);
#endif
#else
float w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    
v_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;
#ifdef RENDER_CUTOFF
v_depth=gl_Position.z;
#endif
}`), rasterParticle: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
uv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), rasterParticleDraw: Qr("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", `#include "_prelude_raster_particle.glsl"
in float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(
mod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}`), rasterParticleTexture: Qr("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: Qr(`#include "_prelude_raster_particle.glsl"
uniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(
linearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)
);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}`, "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbol: Qr(`#include "_prelude_lighting.glsl"
#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;
#ifdef ICON_TRANSITION
uniform float u_icon_transition;
#endif
#ifdef COLOR_ADJUSTMENT
uniform mat4 u_color_adj_mat;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
in vec2 v_tex_a;
#ifdef ICON_TRANSITION
in vec2 v_tex_b;
#endif
in float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
in float is_sdf;in vec2 v_tex_a_icon;
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
vec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];
#ifdef RENDER_TEXT_AND_SYMBOL
if (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
return;}
#endif
#ifdef RENDER_SDF
float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;
#else
#ifdef ICON_TRANSITION
vec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);
#else
out_color=texture(u_texture,v_tex_a);
#endif
#ifdef COLOR_ADJUSTMENT
out_color=u_color_adj_mat*out_color;
#endif
#endif
out_color*=opacity*fade_opacity;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,emissive_strength);
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
in vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;
#ifdef Z_OFFSET
in float a_auto_z_offset;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_globe_anchor;in vec3 a_globe_normal;
#endif
#ifdef ICON_TRANSITION
in vec2 a_texb;
#endif
#ifdef OCCLUSION_QUERIES
in float a_occlusion_query_opacity;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
out vec2 v_tex_a;
#ifdef ICON_TRANSITION
out vec2 v_tex_b;
#endif
out float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
out float is_sdf;out vec2 v_tex_a_icon;
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
#pragma mapbox: define lowp float occlusion_opacity
#pragma mapbox: define lowp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
#pragma mapbox: initialize lowp float occlusion_opacity
#pragma mapbox: initialize lowp float z_offset
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);
#ifdef Z_OFFSET
e+=a_auto_z_offset;
#endif
vec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;
#else
offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;
#endif
vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
#ifdef PROJECTED_POS_ON_VIEWPORT
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);
#else
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    
#endif
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
#ifdef Z_OFFSET
z+=u_pitch_with_map ? a_auto_z_offset+(u_elevation_from_sea ? z_offset : z_offset) : 0.0;
#else
z+=u_pitch_with_map ? (u_elevation_from_sea ? z_offset : z_offset) : 0.0;
#endif
float occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));
#ifdef DEPTH_OCCLUSION
float depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;
#endif
#ifdef OCCLUSION_QUERIES
float occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;
#endif
float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);
#endif
float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;
#ifdef RENDER_TEXT_AND_SYMBOL
is_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;
#endif
#ifdef ICON_TRANSITION
v_tex_b=a_texb/u_texsize;
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=e;
#endif
}`), terrainRaster: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;in vec2 v_pos0;
#ifdef FOG
in float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#endif
uniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;
#ifdef LIGHTING_3D_MODE
const vec3 normal=vec3(0.0,0.0,1.0);
#ifdef RENDER_SHADOWS
float cutoffOpacity=1.0;
#ifdef RENDER_CUTOFF
cutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);
#endif
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
vec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;
#else
float lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));
#endif
#else
float lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;
#endif
#endif
#else
color=image_color;
#endif
#ifdef FOG
#ifdef ZERO_EXAGGERATION
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#else
color=fog_dither(fog_apply_from_vert(color,v_fog_opacity));
#endif
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;
#ifdef FOG
out float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;
#endif
void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);
#ifdef FOG
#ifdef ZERO_EXAGGERATION
v_fog_pos=fog_position(decodedPos);
#else
v_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));
#endif
#endif
#ifdef RENDER_SHADOWS
vec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);
#endif
}`), terrainDepth: Qr("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}`), skybox: Qr(`#include "_prelude_fog.fragment.glsl"
in lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(
cos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;
#ifdef FOG
sky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);
#endif
sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, cs), skyboxGradient: Qr(`#include "_prelude_fog.fragment.glsl"
in highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));
#ifdef FOG
color.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;
#endif
color*=u_opacity;glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, cs), skyboxCapture: Qr(`
in highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;
#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)
#define BETA_M                  vec3(21e-6,21e-6,21e-6)
#define MIE_G                   0.76
#define DENSITY_HEIGHT_SCALE_R  8000.0
#define DENSITY_HEIGHT_SCALE_M  1200.0
#define PLANET_RADIUS           6360e3
#define ATMOSPHERE_RADIUS       6420e3
#define SAMPLE_STEPS            10
#define DENSITY_STEPS           4
float ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}`, "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;
#ifndef FOG
uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;
#endif
void main() {vec4 color;
#ifdef CUSTOM_ANTIALIASING
highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
raster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);
#else
raster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;
#else
color=apply_lighting_ground(color);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;
#endif
out vec2 v_pos0;void main() {
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;vec2 uv=a_uv;
#else
float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);
#endif
v_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;
#ifdef GLOBE_POLES
vec3 up_vector=globe_derived_up_vector;
#else
vec3 up_vector=elevationVector(tile_pos);
#endif
float height=elevation(tile_pos);globe_pos+=up_vector*height;
#ifndef GLOBE_POLES
globe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;
#endif
#ifdef GLOBE_POLES
vec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);
#else
vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);
#endif
gl_Position=u_proj_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
}`), globeAtmosphere: Qr(`#include "_prelude_fog.fragment.glsl"
uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;
#ifdef PROJECTION_GLOBE_VIEW
globe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {
#ifdef ALPHA_PASS
glFragColor=vec4(0,0,0,0);return;
#else
#ifdef NATIVE
glFragColor=vec4(1,1,1,1);
#else
glFragColor=vec4(0,0,0,1);
#endif
return;
#endif
}
#endif
highp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?
0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;
#ifdef PROJECTION_GLOBE_VIEW
highp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?
PI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);
#else
horizon_angle=horizon_angle_mercator;
#endif
horizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;
#ifdef ALPHA_PASS
float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);
#else
vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);
#endif
}`, `in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(
mix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}`), model: Qr(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;
#endif
#ifdef OCCLUSION_TEXTURE_TRANSFORM
uniform vec4 u_occlusionTextureTransform;
#endif
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#ifdef HAS_ATTRIBUTE_a_pbr
in lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;
#endif
#ifdef HAS_TEXTURE_u_baseColorTexture
uniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;
#endif
#ifdef HAS_TEXTURE_u_metallicRoughnessTexture
uniform sampler2D u_metallicRoughnessTexture;
#endif
#ifdef HAS_TEXTURE_u_occlusionTexture
uniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;
#endif
#ifdef HAS_TEXTURE_u_normalTexture
uniform sampler2D u_normalTexture;
#endif
#ifdef HAS_TEXTURE_u_emissionTexture
uniform sampler2D u_emissionTexture;
#endif
#ifdef APPLY_LUT_ON_GPU
uniform highp sampler3D u_lutTexture;
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
in highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;
#ifdef DEPTH_D24
highp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}
#else
highp float unpack_depth_rgba(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depthTexture,coord).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));
#endif
return v_depth > depth+0.0005;}
#endif
#define saturate(_x) clamp(_x,0.,1.)
vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)
{
#ifdef LIGHTING_3D_MODE
vec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));
#endif
return apply_lighting(albedo,transformed_normal,lighting_factor);
#else
vec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;
#endif
}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;
#ifdef HAS_ATTRIBUTE_a_color_3f
albedo*=vec4(color_3f,1.0);
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#else
#ifdef HAS_ATTRIBUTE_a_color_4f
albedo*=color_4f;
#endif
#endif
#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)
vec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}
#ifdef UNPREMULT_TEXTURE_IN_SHADER
if(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;
#endif
if(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}
#endif
vec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);
#ifdef APPLY_LUT_ON_GPU
color=applyLUT(u_lutTexture,color);
#endif
return color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {
#ifdef HAS_TEXTURE_u_normalTexture
highp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;
#else
return mat3(1.0);
#endif
}highp vec3 getNormal(){highp vec3 n;
#ifdef HAS_ATTRIBUTE_a_normal_3f
n=normalize(normal_3f);
#else
highp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;
#endif
#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
vec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);
#endif
return n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;
#ifdef HAS_ATTRIBUTE_a_pbr
mat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;
#endif
#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) 
vec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;
#endif
const float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)
{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)
{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)
{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)
{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)
{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)
{
#ifdef LIGHTING_3D_MODE
return mat.diffuseColor;
#else
return mat.diffuseColor/PI;
#endif
}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)
{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)
{vec3 env_light=vec3(0.65,0.65,0.65);
#ifdef LIGHTING_3D_MODE
float ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;
#endif
vec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)
{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=NdotL;
#endif
vec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;
#if !defined(LIGHTING_3D_MODE)
const vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);
#endif
color*=intensityFactor;return color;}void main() {
#ifdef TERRAIN_FRAGMENT_OCCLUSION
if (isOccluded()) {discard;}
#endif
vec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;
#ifdef LIGHTING_3D_MODE
lightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;
#endif
vec4 finalColor;
#ifdef DIFFUSE_SHADED
vec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);
#ifdef HAS_TEXTURE_u_occlusionTexture
float ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;
#endif
finalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;
#else
Material mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;
#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
#ifdef OCCLUSION_TEXTURE_TRANSFORM
vec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;
#else
vec2 uv=uv_2f;
#endif
ao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;
#endif
vec4 emissive=u_emissiveFactor;
#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
emissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);
#endif
#ifdef APPLY_LUT_ON_GPU
float emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;
#endif
color+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;
#ifdef HAS_ATTRIBUTE_a_pbr
float resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;
#ifdef APPLY_LUT_ON_GPU
color_mix=applyLUT(u_lutTexture,color_mix);
#endif
color=mix(color,color_mix,min(1.0,resEmission));
#ifdef HAS_ATTRIBUTE_a_color_4f
float distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);
#endif
#endif
vec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);
#endif
#ifdef FOG
finalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));
#endif
#ifdef RENDER_CUTOFF
finalColor*=v_cutoff_opacity;
#endif
#ifdef INDICATOR_CUTOUT
finalColor=applyCutout(finalColor,v_position_height.w);
#endif
glFragColor=finalColor;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec3 a_pos_3f;
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr
#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength
uniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_normal_matrix;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;
#endif
out vec4 v_position_height;out lowp vec4 v_color_mix;
#ifdef TERRAIN_FRAGMENT_OCCLUSION
out highp float v_depth;
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
out lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;
#endif
vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute-custom highp vec4 pbr
#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength
highp mat4 normal_matrix;
#ifdef INSTANCED_ARRAYS
normal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
normal_matrix=u_normal_matrix;
#endif
vec3 local_pos;mat3 rs;
#ifdef MODEL_POSITION_ON_GPU
vec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;
#else
local_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);
#endif
v_position_height.w=a_pos_3f.z;
#ifdef HAS_ATTRIBUTE_a_pbr
vec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;
#endif
#ifdef FOG
v_fog_pos=fog_position(local_pos);
#endif
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
float x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);
#else
normal_3f=vec3(normal_matrix*vec4(normal_3f,0));
#endif
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#ifdef HAS_ATTRIBUTE_a_color_4f
v_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);
#endif
#endif
#ifdef RENDER_SHADOWS
vec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);
#ifdef NORMAL_OFFSET
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
vec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#else
vec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#endif
#endif
#endif
v_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;
#endif
}`), modelDepth: Qr(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;
#ifdef MODEL_POSITION_ON_GPU
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_instance;
#endif
uniform highp mat4 u_node_matrix;
#endif
void main() {
#ifdef MODEL_POSITION_ON_GPU
highp mat4 instance;
#ifdef INSTANCED_ARRAYS
instance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
instance=u_instance;
#endif
vec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);
#else
gl_Position=u_matrix*vec4(a_pos_3f,1);
#endif
v_depth=gl_Position.z/gl_Position.w;}`), stars: Qr(`in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)
{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}`, `
in vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}`), snowParticle: Qr("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; 
uniform float u_horizontalOscillationRate; 
uniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}`), rainParticle: Qr("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity; 
uniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; 
pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}`), vignette: Qr("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"), occlusion: Qr("uniform vec4 u_color;void main() {glFragColor=u_color;}", `#include "_prelude_terrain.vertex.glsl"
in highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;
#ifdef TERRAIN
float e=elevation(world_pos.xy);world_pos.z+=e;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}`) };
        function zl(u, t) {
          const n = u.replace(/\s*\/\/[^\n]*\n/g, `
`).split(`
`);
          for (let c of n) if (c = c.trim(), c[0] === "#" && c.includes("if") && !c.includes("endif")) {
            c = c.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const p = c.split(" ");
            for (const v of p) t.includes(v) || t.push(v);
          }
        }
        function Qr(u, t) {
          const n = /#include\s+"([^"]+)"/g, c = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
          let p = t.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
          p && (p = p.map((se) => {
            const oe = se.split(" ");
            return oe[oe.length - 1];
          }), p = [...new Set(p)]);
          const v = {}, C = [], V = [];
          if (u = u.replace(n, (se, oe) => (V.push(oe), "")), (t = t.replace(n, (se, oe) => (C.push(oe), ""))).includes("flat out")) return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
          let K = [...$o];
          zl(u, K), zl(t, K);
          for (const se of [...C, ...V]) hu[se] || console.error(`Undefined include: ${se}`), ec[se] || (ec[se] = [], zl(hu[se], ec[se])), K = [...K, ...ec[se]];
          return { fragmentSource: u = u.replace(c, (se, oe, ve, xe, Le) => (v[Le] = !0, oe === "define" ? `
#ifndef HAS_UNIFORM_u_${Le}
in ${ve} ${xe} ${Le};
#else
uniform ${ve} ${xe} u_${Le};
#endif
` : oe === "initialize" ? `
#ifdef HAS_UNIFORM_u_${Le}
    ${ve} ${xe} ${Le} = u_${Le};
#endif
` : oe === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${Le}
    in ${ve} ${xe} ${Le};
#endif
` : oe === "initialize-attribute" ? "" : void 0)), vertexSource: t = t.replace(c, (se, oe, ve, xe, Le) => {
            const ft = xe === "float" ? "vec2" : xe, st = Le.match(/color/) ? "color" : ft;
            return oe === "define-attribute-vertex-shader-only" ? `
#ifdef HAS_ATTRIBUTE_a_${Le}
in ${ve} ${xe} a_${Le};
#endif
` : v[Le] ? oe === "define" ? `
#ifndef HAS_UNIFORM_u_${Le}
uniform lowp float u_${Le}_t;
in ${ve} ${ft} a_${Le};
out ${ve} ${xe} ${Le};
#else
uniform ${ve} ${xe} u_${Le};
#endif
` : oe === "initialize" ? st === "vec4" ? `
#ifndef HAS_UNIFORM_u_${Le}
    ${Le} = a_${Le};
#else
    ${ve} ${xe} ${Le} = u_${Le};
#endif
` : `
#ifndef HAS_UNIFORM_u_${Le}
    ${Le} = unpack_mix_${st}(a_${Le}, u_${Le}_t);
#else
    ${ve} ${xe} ${Le} = u_${Le};
#endif
` : oe === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${Le}
    in ${ve} ${xe} a_${Le};
    out ${ve} ${xe} ${Le};
#endif
` : oe === "initialize-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${Le}
    ${Le} = a_${Le};
#endif
` : void 0 : oe === "define" ? `
#ifndef HAS_UNIFORM_u_${Le}
uniform lowp float u_${Le}_t;
in ${ve} ${ft} a_${Le};
#else
uniform ${ve} ${xe} u_${Le};
#endif
` : oe === "define-instanced" ? st === "mat4" ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${Le}0;
in vec4 a_${Le}1;
in vec4 a_${Le}2;
in vec4 a_${Le}3;
#else
uniform ${ve} ${xe} u_${Le};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${ve} ${ft} a_${Le};
#else
uniform ${ve} ${xe} u_${Le};
#endif
` : oe === "initialize-attribute-custom" ? `
#ifdef HAS_ATTRIBUTE_a_${Le}
    ${ve} ${xe} ${Le} = a_${Le};
#endif
` : st === "vec4" ? `
#ifndef HAS_UNIFORM_u_${Le}
    ${ve} ${xe} ${Le} = a_${Le};
#else
    ${ve} ${xe} ${Le} = u_${Le};
#endif
` : `
#ifndef HAS_UNIFORM_u_${Le}
    ${ve} ${xe} ${Le} = unpack_mix_${st}(a_${Le}, u_${Le}_t);
#else
    ${ve} ${xe} ${Le} = u_${Le};
#endif
`;
          }), staticAttributes: p, usedDefines: K, vertexIncludes: C, fragmentIncludes: V };
        }
        class uh {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
          }
          bind(t, n, c, p, v, C, V, K) {
            this.context = t;
            let se = this.boundPaintVertexBuffers.length !== p.length;
            for (let ve = 0; !se && ve < p.length; ve++) this.boundPaintVertexBuffers[ve] !== p[ve] && (se = !0);
            let oe = this.boundDynamicVertexBuffers.length !== V.length;
            for (let ve = 0; !oe && ve < V.length; ve++) this.boundDynamicVertexBuffers[ve] !== V[ve] && (oe = !0);
            if (!this.vao || this.boundProgram !== n || this.boundLayoutVertexBuffer !== c || se || oe || this.boundIndexBuffer !== v || this.boundVertexOffset !== C) this.freshBind(n, c, p, v, C, V, K);
            else {
              t.bindVertexArrayOES.set(this.vao);
              for (const ve of V) ve && (ve.bind(), K && ve.instanceCount && ve.setVertexAttribDivisor(t.gl, n, K));
              v && v.dynamicDraw && v.bind();
            }
          }
          freshBind(t, n, c, p, v, C, V) {
            const K = t.numAttributes, se = this.context, oe = se.gl;
            this.vao && this.destroy(), this.vao = se.gl.createVertexArray(), se.bindVertexArrayOES.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = n, this.boundPaintVertexBuffers = c, this.boundIndexBuffer = p, this.boundVertexOffset = v, this.boundDynamicVertexBuffers = C, n.enableAttributes(oe, t), n.bind(), n.setVertexAttribPointers(oe, t, v);
            for (const ve of c) ve.enableAttributes(oe, t), ve.bind(), ve.setVertexAttribPointers(oe, t, v);
            for (const ve of C) ve && (ve.enableAttributes(oe, t), ve.bind(), ve.setVertexAttribPointers(oe, t, v), V && ve.instanceCount && ve.setVertexAttribDivisor(oe, t, V));
            p && p.bind(), se.currentNumAttributes = K;
          }
          destroy() {
            this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        function Bl(u, t) {
          const n = Math.pow(2, t.canonical.z), c = t.canonical.y;
          return [new i.aa(0, c / n).toLngLat().lat, new i.aa(0, (c + 1) / n).toLngLat().lat];
        }
        function Rf(u, t, n, c, p, v, C) {
          const V = u.context, K = V.gl, se = n.hillshadeFBO;
          if (!se) return;
          u.prepareDrawTile();
          const oe = u.isTileAffectedByFog(t), ve = u.getOrCreateProgram("hillshade", { overrideFog: oe });
          V.activeTexture.set(K.TEXTURE0), K.bindTexture(K.TEXTURE_2D, se.colorAttachment.get());
          const xe = ((vt, gt, Rt, qt) => {
            const jt = Rt.paint.get("hillshade-shadow-color"), ii = Rt.paint.get("hillshade-shadow-color-use-theme").constantOr("default") === "none", Xt = Rt.paint.get("hillshade-highlight-color"), Kt = Rt.paint.get("hillshade-highlight-color-use-theme").constantOr("default") === "none", Zt = Rt.paint.get("hillshade-accent-color"), Jt = Rt.paint.get("hillshade-accent-color-use-theme").constantOr("default") === "none", ui = Rt.paint.get("hillshade-emissive-strength");
            let Ti = i.ai(Rt.paint.get("hillshade-illumination-direction"));
            if (Rt.paint.get("hillshade-illumination-anchor") === "viewport") Ti -= vt.transform.angle;
            else if (vt.style && vt.style.enable3dLights() && vt.style.directionalLight) {
              const Pi = vt.style.directionalLight.properties.get("direction"), Ri = i.cb(Pi.x, Pi.y, Pi.z);
              Ti = i.ai(Ri[1]);
            }
            const xi = !vt.options.moving;
            return { u_matrix: qt || vt.transform.calculateProjMatrix(gt.tileID.toUnwrapped(), xi), u_image: 0, u_latrange: Bl(0, gt.tileID), u_light: [Rt.paint.get("hillshade-exaggeration"), Ti], u_shadow: jt.toRenderColor(ii ? null : Rt.lut), u_highlight: Xt.toRenderColor(Kt ? null : Rt.lut), u_emissive_strength: ui, u_accent: Zt.toRenderColor(Jt ? null : Rt.lut) };
          })(u, n, c, u.terrain ? t.projMatrix : null);
          u.uploadCommonUniforms(V, ve, t.toUnwrapped());
          const { tileBoundsBuffer: Le, tileBoundsIndexBuffer: ft, tileBoundsSegments: st } = u.getTileBoundsBuffers(n);
          ve.draw(u, K.TRIANGLES, p, v, C, kr.disabled, xe, c.id, Le, ft, st);
        }
        function kf(u, t, n) {
          if (!t.needsDEMTextureUpload) return;
          const c = u.context, p = c.gl;
          c.pixelStoreUnpackPremultiplyAlpha.set(!1), t.demTexture = t.demTexture || u.getTileTexture(n.stride);
          const v = n.getPixels();
          t.demTexture ? t.demTexture.update(v, { premultiply: !1 }) : t.demTexture = new i.T(c, v, p.R32F, { premultiply: !1 }), t.needsDEMTextureUpload = !1;
        }
        function Oc(u, t, n) {
          const c = u.context, p = c.gl;
          if (!t.dem) return;
          const v = t.dem;
          if (c.activeTexture.set(p.TEXTURE1), kf(u, t, v), !t.demTexture) return;
          t.demTexture.bind(p.NEAREST, p.CLAMP_TO_EDGE);
          const C = v.dim;
          c.activeTexture.set(p.TEXTURE0);
          let V = t.hillshadeFBO;
          if (!V) {
            const xe = new i.T(c, { width: C, height: C, data: null }, p.RGBA8);
            xe.bind(p.LINEAR, p.CLAMP_TO_EDGE), V = t.hillshadeFBO = c.createFramebuffer(C, C, !0, "renderbuffer"), V.colorAttachment.set(xe.texture);
          }
          c.bindFramebuffer.set(V.framebuffer), c.viewport.set([0, 0, C, C]);
          const { tileBoundsBuffer: K, tileBoundsIndexBuffer: se, tileBoundsSegments: oe } = u.getMercatorTileBoundsBuffers(), ve = [];
          u.linearFloatFilteringSupported() && ve.push("TERRAIN_DEM_FLOAT_FORMAT"), u.getOrCreateProgram("hillshadePrepare", { defines: ve }).draw(u, p.TRIANGLES, Sr.disabled, Lr.disabled, zr.unblended, kr.disabled, ((xe, Le) => {
            const ft = Le.stride, st = i.ab.mat4.create();
            return i.ab.mat4.ortho(st, 0, i.ag, -i.ag, 0, 0, 1), i.ab.mat4.translate(st, st, [0, -i.ag, 0]), { u_matrix: st, u_image: 1, u_dimension: [ft, ft], u_zoom: xe.overscaledZ };
          })(t.tileID, v), n.id, K, se, oe), t.needsHillshadePrepare = !1;
        }
        class jn {
          constructor(t) {
            this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(t) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class ch extends jn {
          getDefault() {
            return i.aj.transparent;
          }
          set(t) {
            const n = this.current;
            (t.r !== n.r || t.g !== n.g || t.b !== n.b || t.a !== n.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
          }
        }
        class hh extends jn {
          getDefault() {
            return 1;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);
          }
        }
        class da extends jn {
          getDefault() {
            return 0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);
          }
        }
        class Dc extends jn {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(t) {
            const n = this.current;
            (t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || t[3] !== n[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
          }
        }
        class zc extends jn {
          getDefault() {
            return !0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);
          }
        }
        class ic extends jn {
          getDefault() {
            return 255;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);
          }
        }
        class Lf extends jn {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(t) {
            const n = this.current;
            (t.func !== n.func || t.ref !== n.ref || t.mask !== n.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);
          }
        }
        class du extends jn {
          getDefault() {
            const t = this.gl;
            return [t.KEEP, t.KEEP, t.KEEP];
          }
          set(t) {
            const n = this.current;
            (t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);
          }
        }
        class _l extends jn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            t ? n.enable(n.STENCIL_TEST) : n.disable(n.STENCIL_TEST), this.current = t, this.dirty = !1;
          }
        }
        class Bc extends jn {
          getDefault() {
            return [0, 1];
          }
          set(t) {
            const n = this.current;
            (t[0] !== n[0] || t[1] !== n[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);
          }
        }
        class is extends jn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            t ? n.enable(n.DEPTH_TEST) : n.disable(n.DEPTH_TEST), this.current = t, this.dirty = !1;
          }
        }
        class fh extends jn {
          getDefault() {
            return this.gl.LESS;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);
          }
        }
        class dh extends jn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            t ? n.enable(n.BLEND) : n.disable(n.BLEND), this.current = t, this.dirty = !1;
          }
        }
        class ph extends jn {
          getDefault() {
            const t = this.gl;
            return [t.ONE, t.ZERO, t.ONE, t.ZERO];
          }
          set(t) {
            const n = this.current;
            (t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || t[3] !== n[3] || this.dirty) && (this.gl.blendFuncSeparate(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
          }
        }
        class mh extends jn {
          getDefault() {
            return i.aj.transparent;
          }
          set(t) {
            const n = this.current;
            (t.r !== n.r || t.g !== n.g || t.b !== n.b || t.a !== n.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
          }
        }
        class rc extends jn {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.blendEquationSeparate(t, t), this.current = t, this.dirty = !1);
          }
        }
        class pu extends jn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            t ? n.enable(n.CULL_FACE) : n.disable(n.CULL_FACE), this.current = t, this.dirty = !1;
          }
        }
        class Fc extends jn {
          getDefault() {
            return this.gl.BACK;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);
          }
        }
        class Nc extends jn {
          getDefault() {
            return this.gl.CCW;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);
          }
        }
        let nc = class extends jn {
          getDefault() {
            return null;
          }
          set(u) {
            (u !== this.current || this.dirty) && (this.gl.useProgram(u), this.current = u, this.dirty = !1);
          }
        };
        class _h extends jn {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(t) {
            (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);
          }
        }
        class Of extends jn {
          getDefault() {
            const t = this.gl;
            return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
          }
          set(t) {
            const n = this.current;
            (t[0] !== n[0] || t[1] !== n[1] || t[2] !== n[2] || t[3] !== n[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
          }
        }
        class mu extends jn {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindFramebuffer(n.FRAMEBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class _d extends jn {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindRenderbuffer(n.RENDERBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class gd extends jn {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindTexture(n.TEXTURE_2D, t), this.current = t, this.dirty = !1;
          }
        }
        class Jh extends jn {
          getDefault() {
            return null;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.bindBuffer(n.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class Fl extends jn {
          getDefault() {
            return null;
          }
          set(t) {
            const n = this.gl;
            n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class Df extends jn {
          getDefault() {
            return null;
          }
          set(t) {
            this.gl && (t !== this.current || this.dirty) && (this.gl.bindVertexArray(t), this.current = t, this.dirty = !1);
          }
        }
        class ac extends jn {
          getDefault() {
            return 4;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;
          }
        }
        class vo extends jn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;
          }
        }
        class _u extends jn {
          getDefault() {
            return !1;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            const n = this.gl;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;
          }
        }
        class yo extends jn {
          constructor(t, n) {
            super(t), this.context = t, this.parent = n;
          }
          getDefault() {
            return null;
          }
        }
        class Nl extends yo {
          setDirty() {
            this.dirty = !0;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
          }
        }
        class Qh extends yo {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferRenderbuffer(n.FRAMEBUFFER, this.attachment(), n.RENDERBUFFER, t), this.current = t, this.dirty = !1;
          }
        }
        class zf extends yo {
          attachment() {
            return this.gl.DEPTH_ATTACHMENT;
          }
          set(t) {
            if (t === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const n = this.gl;
            n.framebufferTexture2D(n.FRAMEBUFFER, this.attachment(), n.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
          }
        }
        class Ul extends Qh {
          attachment() {
            return this.gl.DEPTH_STENCIL_ATTACHMENT;
          }
        }
        const gu = (u, t, n) => ({ u_matrix: u, u_image0: 0, u_skirt_height: t, u_ground_shadow_factor: n }), ao = (u, t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st) => ({ u_proj_matrix: Float32Array.from(u), u_globe_matrix: t, u_normalize_matrix: Float32Array.from(c), u_merc_matrix: n, u_zoom_transition: p, u_merc_center: v, u_image0: 0, u_frustum_tl: C, u_frustum_tr: V, u_frustum_br: K, u_frustum_bl: se, u_globe_pos: oe, u_globe_radius: ve, u_viewport: xe, u_grid_matrix: st ? Float32Array.from(st) : new Float32Array(9), u_skirt_height: Le, u_far_z_cutoff: ft });
        function sc(u, t) {
          return u != null && t != null && !(!u.hasData() || !t.hasData()) && u.demTexture != null && t.demTexture != null && u.tileID.key !== t.tileID.key;
        }
        const Rs = new class {
          constructor() {
            this.operations = {};
          }
          newMorphing(u, t, n, c, p) {
            if (u in this.operations) {
              const v = this.operations[u];
              v.to.tileID.key !== n.tileID.key && (v.queued = n);
            } else this.operations[u] = { startTime: c, phase: 0, duration: p, from: t, to: n, queued: null };
          }
          getMorphValuesForProxy(u) {
            if (!(u in this.operations)) return null;
            const t = this.operations[u];
            return { from: t.from, to: t.to, phase: t.phase };
          }
          update(u) {
            for (const t in this.operations) {
              const n = this.operations[t];
              for (n.phase = (u - n.startTime) / n.duration; n.phase >= 1 || !this._validOp(n); ) if (!this._nextOp(n, u)) {
                delete this.operations[t];
                break;
              }
            }
          }
          _nextOp(u, t) {
            return !!u.queued && (u.from = u.to, u.to = u.queued, u.queued = null, u.phase = 0, u.startTime = t, !0);
          }
          _validOp(u) {
            return u.from.hasData() && u.to.hasData();
          }
        }(), gl = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
        function xo(u, t, n) {
          if (t === 0) return 0;
          const c = t < 1 && n === 514 ? 0.25 / t : 1;
          return 6 * Math.pow(1.5, 22 - u) * Math.max(t, 1) * c;
        }
        function wa(u, t) {
          const n = 1 << u.z;
          return !t && (u.x === 0 || u.x === n - 1) || u.y === 0 || u.y === n - 1;
        }
        const ra = (u) => ({ u_matrix: u });
        function bo(u, t, n, c, p) {
          if (p > 0) {
            const v = i.q.now(), C = (v - u.timeAdded) / p, V = t ? (v - t.timeAdded) / p : -1, K = n.getSource(), se = c.coveringZoomLevel({ tileSize: K.tileSize, roundZoom: K.roundZoom }), oe = !t || Math.abs(t.tileID.overscaledZ - se) > Math.abs(u.tileID.overscaledZ - se), ve = oe && u.refreshedUponExpiration ? 1 : i.aw(oe ? C : 1 - V, 0, 1);
            return u.refreshedUponExpiration && C >= 1 && (u.refreshedUponExpiration = !1), t ? { opacity: 1, mix: 1 - ve } : { opacity: ve, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        class hs extends fa {
          constructor(t) {
            const n = { type: "raster-dem", maxzoom: t.transform.maxZoom }, c = new i.D(i.ci(), null), p = Yn("mock-dem", n, c, t.style);
            super("mock-dem", p, !1), p.setEventedParent(this), this._sourceLoaded = !0;
          }
          _loadTile(t, n) {
            t.state = "loaded", n(null);
          }
        }
        class Hs extends fa {
          constructor(t) {
            const n = Yn("proxy", { type: "geojson", maxzoom: t.transform.maxZoom }, new i.D(i.ci(), null), t.style);
            super("proxy", n, !1), n.setEventedParent(this), this.map = this.getSource().map = t, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
          update(t, n, c) {
            if (t.freezeTileCoverage) return;
            this.transform = t;
            const p = t.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((v, C) => {
              if (v[C.key] = "", !this._tiles[C.key]) {
                const V = new Ba(C, this._source.tileSize * C.overscaleFactor(), t.tileZoom);
                V.state = "loaded", this._tiles[C.key] = V;
              }
              return v;
            }, {});
            for (const v in this._tiles) v in p || (this.freeFBO(v), this._tiles[v].unloadVectorData(), delete this._tiles[v]);
          }
          freeFBO(t) {
            const n = this.proxyCachedFBO[t];
            if (n !== void 0) {
              const c = Object.values(n);
              this.renderCachePool.push(...c), delete this.proxyCachedFBO[t];
            }
          }
          deallocRenderCache() {
            this.renderCache.forEach((t) => t.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
          }
        }
        class vl extends i.aG {
          constructor(t, n, c) {
            super(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y), this.proxyTileKey = n, this.projMatrix = c;
          }
        }
        class Io extends i.cJ {
          constructor(t, n) {
            super(), this._debugParams = { sortTilesHiZFirst: !0, disableRenderCache: !1 }, t.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
              this._style.map.triggerRepaint();
            }), t.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
              this._style.map.triggerRepaint();
            }), t.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
              this.invalidateRenderCache = !0, this._style.map.triggerRepaint();
            }), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
            const [c, p, v] = function(K) {
              const se = new i.b4(), oe = new i.aU(), ve = 131;
              se.reserve(17161), oe.reserve(33800);
              const xe = i.ag / 128, Le = i.ag + xe / 2, ft = Le + xe;
              for (let vt = -xe; vt < ft; vt += xe) for (let gt = -xe; gt < ft; gt += xe) {
                const Rt = gt < 0 || gt > Le || vt < 0 || vt > Le ? 24575 : 0, qt = i.aw(Math.round(gt), 0, i.ag), jt = i.aw(Math.round(vt), 0, i.ag);
                se.emplaceBack(qt + Rt, jt);
              }
              const st = (vt, gt) => {
                const Rt = gt * ve + vt;
                oe.emplaceBack(Rt + 1, Rt, Rt + ve), oe.emplaceBack(Rt + ve, Rt + ve + 1, Rt + 1);
              };
              for (let vt = 1; vt < 129; vt++) for (let gt = 1; gt < 129; gt++) st(gt, vt);
              return [0, 129].forEach((vt) => {
                for (let gt = 0; gt < 130; gt++) st(gt, vt), st(vt, gt);
              }), [se, oe, 32768];
            }(), C = t.context;
            this.gridBuffer = C.createVertexBuffer(c, i.b6.members), this.gridIndexBuffer = C.createIndexBuffer(p), this.gridSegments = i.b7.simpleSegment(0, 0, c.length, p.length), this.gridNoSkirtSegments = i.b7.simpleSegment(0, 0, c.length, v), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Hs(n.map), this.orthoMatrix = i.ab.mat4.create(), i.ab.mat4.ortho(this.orthoMatrix, this.painter.transform.projection.name === "globe" ? 0.015 : 0, i.ag, 0, i.ag, 0, 1);
            const V = C.gl;
            this._overlapStencilMode = new Lr({ func: V.GEQUAL, mask: 255 }, 0, 255, V.KEEP, V.KEEP, V.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = n, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new hs(n.map), this._pendingGroundEffectLayers = [];
          }
          set style(t) {
            t.on("data", this._onStyleDataEvent.bind(this)), this._style = t, this._style.map.on("moveend", () => {
              this._clearLineLayersFromRenderCache();
            });
          }
          update(t, n, c) {
            if (t && t.terrain) {
              this._style !== t && (this.style = t, this._evaluationZoom = void 0);
              const p = t.terrain.properties, v = t.terrain.drapeRenderMode === 0, C = t.terrain.isZoomDependent();
              this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = i.q.now();
              const V = t.terrain && t.terrain.scope, K = p.get("source"), se = v ? this._mockSourceCache : t.getSourceCache(K, V);
              if (!se) return void i.w(`Couldn't find terrain source "${K}".`);
              if (this.sourceCache = se, this._attenuationRange = t.terrain.getAttenuationRange(), this._exaggeration = C ? this.calculateExaggeration(n) : p.get("exaggeration"), !n.projection.requiresDraping && C && this._exaggeration === 0) return void this._disable();
              this.enabled = !0;
              const oe = () => {
                this.sourceCache.used && i.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                const ve = this.getScaledDemTileSize();
                this.sourceCache.update(n, ve, !0), this.resetTileLookupCache(this.sourceCache.id);
              };
              this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, oe(), this._initializing = !0), oe(), n.updateElevation(!0, c), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(n), this._emptyDEMTextureDirty = !0, this._previousZoom = n.zoom;
            } else this._disable();
          }
          calculateExaggeration(t) {
            if (this._attenuationRange && t.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t.zoom);
            const n = this._previousCameraAltitude, c = t.getFreeCameraOptions().position.z / t.pixelsPerMeter * t.worldSize;
            this._previousCameraAltitude = c;
            const p = n != null ? c - n : Number.MAX_VALUE;
            if (Math.abs(p) < 2) return this._exaggeration;
            const v = t.zoom, C = this._style.terrain;
            if (!this._previousUpdateTimestamp) return C.getExaggeration(v);
            let V = v - this._previousZoom;
            const K = this._previousUpdateTimestamp;
            let se = v;
            this._evaluationZoom != null && (se = this._evaluationZoom, Math.abs(v - se) > 0.5 && (V = 0.5 * (v - se + V)), V * p < 0 && (se += V)), this._evaluationZoom = se;
            const oe = C.getExaggeration(se), ve = oe === C.getExaggeration(Math.max(0, se - 0.1));
            if (ve && Math.abs(oe - this._exaggeration) < 0.01) return oe;
            let xe = Math.min(0.1, 375e-5 * (this._updateTimestamp - K));
            return (ve || oe < 0.1 || Math.abs(V) < 1e-4) && (xe = Math.min(0.2, 4 * xe)), i.af(this._exaggeration, oe, xe);
          }
          resetTileLookupCache(t) {
            this._findCoveringTileCache[t] = {};
          }
          attenuationRange() {
            return this._attenuationRange;
          }
          getDemUpscale() {
            return this.proxySourceCache.getSource().tileSize / 128;
          }
          getScaledDemTileSize() {
            return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
          }
          _onStyleDataEvent(t) {
            t.coord && t.dataType === "source" ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord) : t.dataType === "style" && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
          }
          _disable() {
            if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const t in this._style._mergedSourceCaches) this._style._mergedSourceCaches[t].usedForTerrain = !1;
          }
          destroy() {
            this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((t) => t.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
          }
          _source() {
            return this.enabled ? this.sourceCache : null;
          }
          isUsingMockSource() {
            return this.sourceCache === this._mockSourceCache;
          }
          exaggeration() {
            return this.enabled ? this._exaggeration : 0;
          }
          get visibleDemTiles() {
            return this._visibleDemTiles;
          }
          get drapeBufferSize() {
            const t = 2 * this.proxySourceCache.getSource().tileSize;
            return [t, t];
          }
          set useVertexMorphing(t) {
            this._useVertexMorphing = t;
          }
          updateTileBinding(t) {
            if (!this.enabled) return;
            this.prevTerrainTileForTile = this.terrainTileForTile;
            const n = this.proxySourceCache, c = this.painter.transform;
            this._initializing && (this._initializing = c._centerAltitude === 0 && this.getAtPointOrZero(i.aa.fromLngLat(c.center), -1) === -1, this._emptyDEMTextureDirty = !this._initializing);
            const p = this.proxyCoords = n.getIds().map((K) => {
              const se = n.getTileByID(K).tileID;
              return se.projMatrix = c.calculateProjMatrix(se.toUnwrapped()), se;
            });
            (function(K, se) {
              const oe = se.transform.pointCoordinate(se.transform.getCameraPoint()), ve = new i.P(oe.x, oe.y);
              K.sort((xe, Le) => {
                if (Le.overscaledZ - xe.overscaledZ) return Le.overscaledZ - xe.overscaledZ;
                const ft = new i.P(xe.canonical.x + (1 << xe.canonical.z) * xe.wrap, xe.canonical.y), st = new i.P(Le.canonical.x + (1 << Le.canonical.z) * Le.wrap, Le.canonical.y), vt = ve.mult(1 << xe.canonical.z);
                return vt.x -= 0.5, vt.y -= 0.5, vt.distSqr(ft) - vt.distSqr(st);
              });
            })(p, this.painter);
            const v = this.proxyToSource || {};
            this.proxyToSource = {}, p.forEach((K) => {
              this.proxyToSource[K.key] = {};
            }), this.terrainTileForTile = {};
            const C = this._style._mergedSourceCaches;
            for (const K in C) {
              const se = C[K];
              if (!se.used || (se !== this.sourceCache && this.resetTileLookupCache(se.id), this._setupProxiedCoordsForOrtho(se, t[K], v), se.usedForTerrain)) continue;
              const oe = t[K];
              se.getSource().reparseOverscaled && this._assignTerrainTiles(oe);
            }
            this.proxiedCoords[n.id] = p.map((K) => new vl(K, K.key, this.orthoMatrix)), this._assignTerrainTiles(p), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(v), this.renderingToTexture = !1;
            const V = {};
            this._visibleDemTiles = [];
            for (const K of this.proxyCoords) {
              const se = this.terrainTileForTile[K.key];
              if (!se) continue;
              const oe = se.tileID.key;
              oe in V || (this._visibleDemTiles.push(se), V[oe] = oe);
            }
          }
          _assignTerrainTiles(t) {
            this._initializing || t.forEach((n) => {
              if (this.terrainTileForTile[n.key]) return;
              const c = this._findTileCoveringTileID(n, this.sourceCache);
              c && (this.terrainTileForTile[n.key] = c);
            });
          }
          _prepareDEMTextures() {
            const t = this.painter.context, n = t.gl;
            for (const c in this.terrainTileForTile) {
              const p = this.terrainTileForTile[c], v = p.dem;
              !v || p.demTexture && !p.needsDEMTextureUpload || (t.activeTexture.set(n.TEXTURE1), kf(this.painter, p, v));
            }
          }
          _prepareDemTileUniforms(t, n, c, p) {
            if (!n || n.demTexture == null) return !1;
            const v = t.tileID.canonical, C = Math.pow(2, n.tileID.canonical.z - v.z), V = p || "";
            return c[`u_dem_tl${V}`] = [v.x * C % 1, v.y * C % 1], c[`u_dem_scale${V}`] = C, !0;
          }
          get emptyDEMTexture() {
            return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
          }
          _getLoadedAreaMinimum() {
            if (!this.enabled) return 0;
            let t = 0;
            const n = this._visibleDemTiles.reduce((c, p) => {
              if (!p.dem) return c;
              const v = p.dem.tree.minimums[0];
              return v > 0 && t++, c + v;
            }, 0);
            return t ? n / t : 0;
          }
          _updateEmptyDEMTexture() {
            const t = this.painter.context, n = t.gl;
            t.activeTexture.set(n.TEXTURE2);
            const c = this._getLoadedAreaMinimum(), p = new i.cK({ width: 1, height: 1 }, new Float32Array([c]));
            this._emptyDEMTextureDirty = !1;
            let v = this._emptyDEMTexture;
            return v ? v.update(p, { premultiply: !1 }) : v = this._emptyDEMTexture = new i.T(t, p, n.R32F, { premultiply: !1 }), v;
          }
          setupElevationDraw(t, n, c) {
            const p = this.painter.context, v = p.gl, C = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 };
            C.u_exaggeration = this.exaggeration();
            let V = null, K = null, se = 1;
            if (c && c.morphing && this._useVertexMorphing) {
              const Le = c.morphing.srcDemTile, ft = c.morphing.dstDemTile;
              se = c.morphing.phase, Le && ft && (this._prepareDemTileUniforms(t, Le, C, "_prev") && (K = Le), this._prepareDemTileUniforms(t, ft, C) && (V = ft));
            }
            const oe = (Le) => Le && Le.demTexture && this.painter.linearFloatFilteringSupported() ? v.LINEAR : v.NEAREST;
            let ve = null;
            var xe;
            if (this.enabled ? K && V ? (ve = V.demTexture, p.activeTexture.set(v.TEXTURE4), K.demTexture.bind(oe(K), v.CLAMP_TO_EDGE), C.u_dem_lerp = se) : (V = this.terrainTileForTile[t.tileID.key], ve = this._prepareDemTileUniforms(t, V, C) ? V.demTexture : this.emptyDEMTexture) : ve = this.emptyDEMTexture, p.activeTexture.set(v.TEXTURE2), ve && (C.u_dem_size = (xe = ve).size[0] === 1 ? 1 : xe.size[0] - 2, ve.bind(oe(V), v.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(c && c.useDepthForOcclusion, n, C), c && c.useMeterToDem && V) {
              const Le = (1 << V.tileID.canonical.z) * i.bH(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
              C.u_meter_to_dem = Le;
            }
            if (c && c.labelPlaneMatrixInv && (C.u_label_plane_matrix_inv = c.labelPlaneMatrixInv), n.setTerrainUniformValues(p, C), this.painter.transform.projection.name === "globe") {
              const Le = this.globeUniformValues(this.painter.transform, t.tileID.canonical, c && c.useDenormalizedUpVectorScale);
              n.setGlobeUniformValues(p, Le);
            }
          }
          globeUniformValues(t, n, c) {
            const p = t.projection;
            return { u_tile_tl_up: p.upVector(n, 0, 0), u_tile_tr_up: p.upVector(n, i.ag, 0), u_tile_br_up: p.upVector(n, i.ag, i.ag), u_tile_bl_up: p.upVector(n, 0, i.ag), u_tile_up_scale: c ? i.cL(1) : p.upVectorScale(n, t.center.lat, t.worldSize).metersToTile };
          }
          renderToBackBuffer(t) {
            const n = this.painter, c = this.painter.context;
            t.length !== 0 && (c.bindFramebuffer.set(null), c.viewport.set([0, 0, n.width, n.height]), n.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(p, v, C, V, K) {
              if (p.transform.projection.name === "globe") (function(se, oe, ve, xe, Le) {
                const ft = se.context, st = ft.gl;
                let vt, gt;
                const Rt = se.transform, qt = i.cC(se, ft, Rt), jt = (Pi, Ri) => {
                  if (gt === Ri) return;
                  const mi = [gl[Ri], "PROJECTION_GLOBE_VIEW"];
                  qt && mi.push("CUSTOM_ANTIALIASING");
                  const Ai = se.isTileAffectedByFog(Pi);
                  vt = se.getOrCreateProgram("globeRaster", { defines: mi, overrideFog: Ai }), gt = Ri;
                }, ii = se.colorModeForRenderPass(), Xt = new Sr(st.LEQUAL, Sr.ReadWrite, se.depthRangeFor3D);
                Rs.update(Le);
                const Kt = i.cD(Rt), Zt = [i.at(Rt.center.lng), i.aA(Rt.center.lat)], Jt = se.globeSharedBuffers, ui = [Rt.width * i.q.devicePixelRatio, Rt.height * i.q.devicePixelRatio], Ti = Float32Array.from(Rt.globeMatrix), xi = { useDenormalizedUpVectorScale: !0 };
                {
                  const Pi = se.transform, Ri = xo(Pi.zoom, oe.exaggeration(), oe.sourceCache._source.tileSize);
                  gt = -1;
                  const mi = st.TRIANGLES;
                  for (const Ai of xe) {
                    const ji = ve.getTile(Ai), yi = Lr.disabled, Ni = oe.prevTerrainTileForTile[Ai.key], Mi = oe.terrainTileForTile[Ai.key];
                    sc(Ni, Mi) && Rs.newMorphing(Ai.key, Ni, Mi, Le, 250), ft.activeTexture.set(st.TEXTURE0), ji.texture && ji.texture.bind(st.LINEAR, st.CLAMP_TO_EDGE);
                    const Yi = Rs.getMorphValuesForProxy(Ai.key), Ui = Yi ? 1 : 0;
                    Yi && i.J(xi, { morphing: { srcDemTile: Yi.from, dstDemTile: Yi.to, phase: i.cB(Yi.phase) } });
                    const Fi = i.cE(Ai.canonical), Zi = i.cF(Fi.getCenter().lat), ir = i.cG(Ai.canonical, Fi, Zi, Pi.worldSize / Pi._pixelsPerMercatorPixel), cr = i.bb(i.cH(Ai.canonical)), fr = ao(Pi.expandedFarZProjMatrix, Ti, Kt, cr, i.ae(Pi.zoom), Zt, Pi.frustumCorners.TL, Pi.frustumCorners.TR, Pi.frustumCorners.BR, Pi.frustumCorners.BL, Pi.globeCenterInViewSpace, Pi.globeRadius, ui, Ri, Pi._farZ, ir);
                    if (jt(Ai, Ui), vt && (oe.setupElevationDraw(ji, vt, xi), se.uploadCommonUniforms(ft, vt, Ai.toUnwrapped()), Jt)) {
                      const [Or, Er, Ar] = Jt.getGridBuffers(Zi, Ri !== 0);
                      vt.draw(se, mi, Xt, yi, ii, kr.backCCW, fr, "globe_raster", Or, Er, Ar);
                    }
                  }
                }
                if (Jt && (se.renderDefaultNorthPole || se.renderDefaultSouthPole)) {
                  const Pi = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  qt && Pi.push("CUSTOM_ANTIALIASING"), vt = se.getOrCreateProgram("globeRaster", { defines: Pi });
                  for (const Ri of xe) {
                    const { x: mi, y: Ai, z: ji } = Ri.canonical, yi = Ai === 0, Ni = Ai === (1 << ji) - 1, [Mi, Yi, Ui, Fi] = Jt.getPoleBuffers(ji, !1);
                    if (Fi && (yi || Ni)) {
                      const Zi = ve.getTile(Ri);
                      ft.activeTexture.set(st.TEXTURE0), Zi.texture && Zi.texture.bind(st.LINEAR, st.CLAMP_TO_EDGE);
                      let ir = i.cI(ji, mi, Rt);
                      const cr = i.bb(i.cH(Ri.canonical)), fr = (Or, Er) => Or.draw(se, st.TRIANGLES, Xt, Lr.disabled, ii, kr.disabled, ao(Rt.expandedFarZProjMatrix, ir, ir, cr, 0, Zt, Rt.frustumCorners.TL, Rt.frustumCorners.TR, Rt.frustumCorners.BR, Rt.frustumCorners.BL, Rt.globeCenterInViewSpace, Rt.globeRadius, ui, 0, Rt._farZ), "globe_pole_raster", Er, Ui, Fi);
                      oe.setupElevationDraw(Zi, vt, xi), se.uploadCommonUniforms(ft, vt, Ri.toUnwrapped()), yi && se.renderDefaultNorthPole && fr(vt, Mi), Ni && se.renderDefaultSouthPole && (ir = i.ab.mat4.scale(i.ab.mat4.create(), ir, [1, -1, 1]), fr(vt, Yi));
                    }
                  }
                }
              })(p, v, C, V, K);
              else {
                const se = p.context, oe = se.gl;
                let ve, xe;
                const Le = p.shadowRenderer, ft = Ps(p, p.longestCutoffRange), st = (ii) => {
                  if (xe === ii) return;
                  const Xt = [];
                  Xt.push(gl[ii]), ft.shouldRenderCutoff && Xt.push("RENDER_CUTOFF"), Le && (Xt.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), Le.useNormalOffset && Xt.push("NORMAL_OFFSET")), ve = p.getOrCreateProgram("terrainRaster", { defines: Xt }), xe = ii;
                }, vt = p.colorModeForRenderPass(), gt = new Sr(oe.LEQUAL, Sr.ReadWrite, p.depthRangeFor3D);
                Rs.update(K);
                const Rt = p.transform, qt = xo(Rt.zoom, v.exaggeration(), v.sourceCache._source.tileSize);
                let jt = [0, 0, 0];
                if (Le) {
                  const ii = p.style.directionalLight, Xt = p.style.ambientLight;
                  ii && Xt && (jt = pl(p.style, ii, Xt));
                }
                {
                  xe = -1;
                  const ii = oe.TRIANGLES, [Xt, Kt] = [v.gridIndexBuffer, v.gridSegments];
                  for (const Zt of V) {
                    const Jt = C.getTile(Zt), ui = Lr.disabled, Ti = v.prevTerrainTileForTile[Zt.key], xi = v.terrainTileForTile[Zt.key];
                    sc(Ti, xi) && Rs.newMorphing(Zt.key, Ti, xi, K, 250), se.activeTexture.set(oe.TEXTURE0), Jt.texture && Jt.texture.bind(oe.LINEAR, oe.CLAMP_TO_EDGE);
                    const Pi = Rs.getMorphValuesForProxy(Zt.key), Ri = Pi ? 1 : 0;
                    let mi;
                    Pi && (mi = { morphing: { srcDemTile: Pi.from, dstDemTile: Pi.to, phase: i.cB(Pi.phase) } });
                    const Ai = gu(Zt.projMatrix, wa(Zt.canonical, Rt.renderWorldCopies) ? qt / 10 : qt, jt);
                    if (st(Ri), !ve) continue;
                    v.setupElevationDraw(Jt, ve, mi);
                    const ji = Zt.toUnwrapped();
                    Le && Le.setupShadows(ji, ve), p.uploadCommonUniforms(se, ve, ji, null, ft), ve.draw(p, ii, gt, ui, vt, kr.backCCW, Ai, "terrain_raster", v.gridBuffer, Xt, Kt);
                  }
                }
              }
            }(n, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, n.gpuTimingDeferredRenderEnd(), t.splice(0, t.length));
          }
          renderBatch(t) {
            if (this._drapedRenderBatches.length === 0) return t + 1;
            this.renderingToTexture = !0;
            const n = this.painter, c = this.painter.context, p = this.proxySourceCache, v = this.proxiedCoords[p.id], C = this._drapedRenderBatches.shift(), V = n.style.order, K = [];
            let se = 0;
            for (const oe of v) {
              const ve = p.getTileByID(oe.proxyTileKey), xe = p.proxyCachedFBO[oe.key] ? p.proxyCachedFBO[oe.key][t] : void 0, Le = xe !== void 0 ? p.renderCache[xe] : this.pool[se++], ft = xe !== void 0;
              if (ve.texture = Le.tex, ft && !Le.dirty) {
                K.push(ve.tileID);
                continue;
              }
              let st;
              c.bindFramebuffer.set(Le.fb.framebuffer), this.renderedToTile = !1, Le.dirty && (c.clear({ color: i.aj.transparent, stencil: 0 }), Le.dirty = !1);
              for (let vt = C.start; vt <= C.end; ++vt) {
                const gt = n.style._mergedLayers[V[vt]];
                if (gt.isHidden(n.transform.zoom)) continue;
                const Rt = n.style.getLayerSourceCache(gt), qt = Rt ? this.proxyToSource[oe.key][Rt.id] : [oe];
                if (!qt) continue;
                const jt = qt;
                c.viewport.set([0, 0, Le.fb.width, Le.fb.height]), st !== (Rt ? Rt.id : null) && (this._setupStencil(Le, qt, gt, Rt), st = Rt ? Rt.id : null), n.renderLayer(n, Rt, gt, jt);
              }
              if (this._drapedRenderBatches.length === 0) for (const vt of this._pendingGroundEffectLayers) {
                const gt = n.style._mergedLayers[V[vt]];
                if (gt.isHidden(n.transform.zoom)) continue;
                const Rt = n.style.getLayerSourceCache(gt), qt = Rt ? this.proxyToSource[oe.key][Rt.id] : [oe];
                if (!qt) continue;
                const jt = qt;
                c.viewport.set([0, 0, Le.fb.width, Le.fb.height]), st !== (Rt ? Rt.id : null) && (this._setupStencil(Le, qt, gt, Rt), st = Rt ? Rt.id : null), n.renderLayer(n, Rt, gt, jt);
              }
              this.renderedToTile ? (Le.dirty = !0, K.push(ve.tileID)) : ft || --se, se === 5 && (se = 0, this.renderToBackBuffer(K));
            }
            return this.renderToBackBuffer(K), this.renderingToTexture = !1, c.bindFramebuffer.set(null), c.viewport.set([0, 0, n.width, n.height]), C.end + 1;
          }
          postRender() {
          }
          isLayerOrderingCorrect(t) {
            const n = t.order.length;
            let c = -1, p = n;
            for (let v = 0; v < n; ++v) this._style.isLayerDraped(t._mergedLayers[t.order[v]]) ? c = Math.max(c, v) : p = Math.min(p, v);
            return p > c;
          }
          getMinElevationBelowMSL() {
            let t = 0;
            return this._visibleDemTiles.filter((n) => n.dem).forEach((n) => {
              t = Math.min(t, n.dem.tree.minimums[0]);
            }), t === 0 ? t : (t - 30) * this._exaggeration;
          }
          raycast(t, n, c) {
            if (!this._visibleDemTiles) return null;
            const p = this._visibleDemTiles.filter((v) => v.dem).map((v) => {
              const C = v.tileID, V = 1 << C.overscaledZ, { x: K, y: se } = C.canonical, oe = K / V, ve = (K + 1) / V, xe = se / V, Le = (se + 1) / V;
              return { minx: oe, miny: xe, maxx: ve, maxy: Le, t: v.dem.tree.raycastRoot(oe, xe, ve, Le, t, n, c), tile: v };
            });
            p.sort((v, C) => (v.t !== null ? v.t : Number.MAX_VALUE) - (C.t !== null ? C.t : Number.MAX_VALUE));
            for (const v of p) {
              if (v.t == null) return null;
              const C = v.tile.dem.tree.raycast(v.minx, v.miny, v.maxx, v.maxy, t, n, c);
              if (C != null) return C;
            }
            return null;
          }
          _createFBO() {
            const t = this.painter.context, n = t.gl, c = this.drapeBufferSize;
            t.activeTexture.set(n.TEXTURE0);
            const p = new i.T(t, { width: c[0], height: c[1], data: null }, n.RGBA8);
            p.bind(n.LINEAR, n.CLAMP_TO_EDGE);
            const v = t.createFramebuffer(c[0], c[1], !0, null);
            return v.colorAttachment.set(p.texture), v.depthAttachment = new Ul(t, v.framebuffer), this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, c[0], c[1]), this._stencilRef = 0, v.depthAttachment.set(this._sharedDepthStencil), t.clear({ stencil: 0 })) : v.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && n.texParameterf(n.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), { fb: v, tex: p, dirty: !1 };
          }
          _initFBOPool() {
            for (; this.pool.length < Math.min(5, this.proxyCoords.length); ) this.pool.push(this._createFBO());
          }
          _shouldDisableRenderCache() {
            if (this._debugParams.disableRenderCache || this._style.hasLightTransitions()) return !0;
            for (const t in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t].hasTransition()) return !0;
            return this._style.order.some((t) => {
              const n = this._style._mergedLayers[t], c = n.isHidden(this.painter.transform.zoom);
              return n.type === "hillshade" || n.type === "custom" ? !c && n.shouldRedrape() : !c && n.hasTransition();
            });
          }
          _clearLineLayersFromRenderCache() {
            let t = !1;
            for (const c of this._style.getSources()) if (c instanceof wn) {
              t = !0;
              break;
            }
            if (!t) return;
            const n = {};
            for (let c = 0; c < this._style.order.length; ++c) {
              const p = this._style._mergedLayers[this._style.order[c]], v = this._style.getLayerSourceCache(p);
              if (v && !n[v.id] && !p.isHidden(this.painter.transform.zoom) && p.type === "line" && p.widthExpression() instanceof i.a9) {
                n[v.id] = !0;
                for (const C of this.proxyCoords) {
                  const V = this.proxyToSource[C.key][v.id];
                  if (V) for (const K of V) this._clearRenderCacheForTile(v.id, K);
                }
              }
            }
          }
          _clearRasterLayersFromRenderCache() {
            let t = !1;
            for (const c in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[c]._source instanceof xn) {
              t = !0;
              break;
            }
            if (!t) return;
            const n = {};
            for (let c = 0; c < this._style.order.length; ++c) {
              const p = this._style._mergedLayers[this._style.order[c]], v = this._style.getLayerSourceCache(p);
              if (!v || n[v.id] || p.isHidden(this.painter.transform.zoom) || p.type !== "raster") continue;
              const C = p.paint.get("raster-fade-duration");
              for (const V of this.proxyCoords) {
                const K = this.proxyToSource[V.key][v.id];
                if (K) for (const se of K) {
                  const oe = bo(v.getTile(se), v.findLoadedParent(se, 0), v, this.painter.transform, C);
                  (oe.opacity !== 1 || oe.mix !== 0) && this._clearRenderCacheForTile(v.id, se);
                }
              }
            }
          }
          _setupDrapedRenderBatches() {
            this._style.updateDrapeFirstLayers();
            const t = this._style.order, n = t.length;
            if (n === 0) return;
            const c = [];
            this._pendingGroundEffectLayers = [];
            let p, v = 0, C = this._style._mergedLayers[t[v]];
            for (; !this._style.isLayerDraped(C) && C.isHidden(this.painter.transform.zoom) && ++v < n; ) C = this._style._mergedLayers[t[v]];
            for (; v < n; ++v) {
              const V = this._style._mergedLayers[t[v]];
              V.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(V) ? p === void 0 && (p = v) : (V.type === "fill-extrusion" && this._pendingGroundEffectLayers.push(v), p !== void 0 && (c.push({ start: p, end: v - 1 }), p = void 0)));
            }
            if (p !== void 0 && c.push({ start: p, end: v - 1 }), c.length !== 0) {
              const V = c[c.length - 1];
              this._pendingGroundEffectLayers.every((K) => K > V.end) || i.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
            }
            this._drapedRenderBatches = c;
          }
          _setupRenderCache(t) {
            const n = this.proxySourceCache;
            if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
              if (this.invalidateRenderCache = !1, n.renderCache.length > n.renderCachePool.length) {
                const C = Object.values(n.proxyCachedFBO);
                n.proxyCachedFBO = {};
                for (let V = 0; V < C.length; ++V) {
                  const K = Object.values(C[V]);
                  n.renderCachePool.push(...K);
                }
              }
              return;
            }
            this._clearRasterLayersFromRenderCache();
            const c = this.proxyCoords, p = this._tilesDirty;
            for (let C = c.length - 1; C >= 0; C--) {
              const V = c[C];
              if (n.getTileByID(V.key), n.proxyCachedFBO[V.key] !== void 0) {
                const K = t[V.key], se = this.proxyToSource[V.key];
                let oe = 0;
                for (const ve in se) {
                  const xe = se[ve], Le = K[ve];
                  if (!Le || Le.length !== xe.length || xe.some((ft, st) => ft !== Le[st] || p[ve] && p[ve].hasOwnProperty(ft.key))) {
                    oe = -1;
                    break;
                  }
                  ++oe;
                }
                for (const ve in n.proxyCachedFBO[V.key]) n.renderCache[n.proxyCachedFBO[V.key][ve]].dirty = oe < 0 || oe !== Object.values(K).length;
              }
            }
            const v = [...this._drapedRenderBatches];
            v.sort((C, V) => V.end - V.start - (C.end - C.start));
            for (const C of v) for (const V of c) {
              if (n.proxyCachedFBO[V.key]) continue;
              let K = n.renderCachePool.pop();
              K === void 0 && n.renderCache.length < 50 && (K = n.renderCache.length, n.renderCache.push(this._createFBO())), K !== void 0 && (n.proxyCachedFBO[V.key] = {}, n.proxyCachedFBO[V.key][C.start] = K, n.renderCache[K].dirty = !0);
            }
            this._tilesDirty = {};
          }
          _setupStencil(t, n, c, p) {
            if (!p || !this._sourceTilesOverlap[p.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
            const v = this.painter.context, C = v.gl;
            if (n.length <= 1) return void (this._overlapStencilType = !1);
            let V;
            if (c.isTileClipped()) V = n.length, this._overlapStencilMode.test = { func: C.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
            else {
              if (!(n[0].overscaledZ > n[n.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
              V = 1, this._overlapStencilMode.test = { func: C.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
            }
            this._stencilRef + V > 255 && (v.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += V, this._overlapStencilMode.ref = this._stencilRef, c.isTileClipped() && this._renderTileClippingMasks(n, this._overlapStencilMode.ref);
          }
          clipOrMaskOverlapStencilType() {
            return this._overlapStencilType === "Clip" || this._overlapStencilType === "Mask";
          }
          stencilModeForRTTOverlap(t) {
            return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : Lr.disabled;
          }
          _renderTileClippingMasks(t, n) {
            const c = this.painter, p = this.painter.context, v = p.gl;
            c._tileClippingMaskIDs = {}, p.setColorMode(zr.disabled), p.setDepthMode(Sr.disabled);
            const C = c.getOrCreateProgram("clippingMask");
            for (const V of t) {
              const K = c._tileClippingMaskIDs[V.key] = --n;
              C.draw(c, v.TRIANGLES, Sr.disabled, new Lr({ func: v.ALWAYS, mask: 0 }, K, 255, v.KEEP, v.KEEP, v.REPLACE), zr.disabled, kr.disabled, ra(V.projMatrix), "$clipping", c.tileExtentBuffer, c.quadTriangleIndexBuffer, c.tileExtentSegments);
            }
          }
          pointCoordinate(t) {
            const n = this.painter.transform;
            if (t.x < 0 || t.x > n.width || t.y < 0 || t.y > n.height) return null;
            const c = [t.x, t.y, 1, 1];
            i.ab.vec4.transformMat4(c, c, n.pixelMatrixInverse), i.ab.vec4.scale(c, c, 1 / c[3]), c[0] /= n.worldSize, c[1] /= n.worldSize;
            const p = n._camera.position, v = i.bH(1, n.center.lat), C = [p[0], p[1], p[2] / v, 0], V = i.ab.vec3.subtract([], c.slice(0, 3), C);
            i.ab.vec3.normalize(V, V);
            const K = this.raycast(C, V, this._exaggeration);
            return K !== null && K ? (i.ab.vec3.scaleAndAdd(C, C, V, K), C[3] = C[2], C[2] *= v, C) : null;
          }
          _setupProxiedCoordsForOrtho(t, n, c) {
            if (t.getSource() instanceof i.aJ) return this._setupProxiedCoordsForImageSource(t, n, c);
            this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};
            const p = this.proxiedCoords[t.id] = [], v = this.proxyCoords;
            for (let K = 0; K < v.length; K++) {
              const se = v[K], oe = this._findTileCoveringTileID(se, t);
              if (oe) {
                const ve = this._createProxiedId(se, oe, c[se.key] && c[se.key][t.id]);
                p.push(ve), this.proxyToSource[se.key][t.id] = [ve];
              }
            }
            let C = !1;
            const V = /* @__PURE__ */ new Set();
            for (let K = 0; K < n.length; K++) {
              const se = t.getTile(n[K]);
              if (!se || !se.hasData()) continue;
              const oe = this._findTileCoveringTileID(se.tileID, this.proxySourceCache);
              if (oe && oe.tileID.canonical.z !== se.tileID.canonical.z) {
                const ve = this.proxyToSource[oe.tileID.key][t.id], xe = this._createProxiedId(oe.tileID, se, c[oe.tileID.key] && c[oe.tileID.key][t.id]);
                ve ? ve.splice(ve.length - 1, 0, xe) : this.proxyToSource[oe.tileID.key][t.id] = [xe];
                const Le = this.proxyToSource[oe.tileID.key][t.id];
                V.has(Le) || V.add(Le), p.push(xe), C = !0;
              }
            }
            if (this._sourceTilesOverlap[t.id] = C, C && this._debugParams.sortTilesHiZFirst) for (const K of V) K.sort((se, oe) => oe.overscaledZ - se.overscaledZ);
          }
          _setupProxiedCoordsForImageSource(t, n, c) {
            if (!t.getSource().loaded()) return;
            const p = this.proxiedCoords[t.id] = [], v = this.proxyCoords, C = t.getSource(), V = C.tileID;
            if (!V) return;
            const K = new i.P(V.x, V.y)._div(1 << V.z), se = C.coordinates.map(i.aa.fromLngLat).reduce((ve, xe) => (ve.min.x = Math.min(ve.min.x, xe.x - K.x), ve.min.y = Math.min(ve.min.y, xe.y - K.y), ve.max.x = Math.max(ve.max.x, xe.x - K.x), ve.max.y = Math.max(ve.max.y, xe.y - K.y), ve), { min: new i.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new i.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), oe = (ve, xe) => {
              const Le = ve.wrap + ve.canonical.x / (1 << ve.canonical.z), ft = ve.canonical.y / (1 << ve.canonical.z), st = i.ag / (1 << ve.canonical.z), vt = xe.wrap + xe.canonical.x / (1 << xe.canonical.z), gt = xe.canonical.y / (1 << xe.canonical.z);
              return Le + st < vt + se.min.x || Le > vt + se.max.x || ft + st < gt + se.min.y || ft > gt + se.max.y;
            };
            for (let ve = 0; ve < v.length; ve++) {
              const xe = v[ve];
              for (let Le = 0; Le < n.length; Le++) {
                const ft = t.getTile(n[Le]);
                if (!ft || !ft.hasData() || oe(xe, ft.tileID)) continue;
                const st = this._createProxiedId(xe, ft, c[xe.key] && c[xe.key][t.id]), vt = this.proxyToSource[xe.key][t.id];
                vt ? vt.push(st) : this.proxyToSource[xe.key][t.id] = [st], p.push(st);
              }
            }
          }
          _createProxiedId(t, n, c) {
            let p = this.orthoMatrix;
            if (c) {
              const v = c.find((C) => C.key === n.tileID.key);
              if (v) return v;
            }
            if (n.tileID.key !== t.key) {
              const v = t.canonical.z - n.tileID.canonical.z;
              let C, V, K;
              p = i.ab.mat4.create();
              const se = n.tileID.wrap - t.wrap << t.overscaledZ;
              v > 0 ? (C = i.ag >> v, V = C * ((n.tileID.canonical.x << v) - t.canonical.x + se), K = C * ((n.tileID.canonical.y << v) - t.canonical.y)) : (C = i.ag << -v, V = i.ag * (n.tileID.canonical.x - (t.canonical.x + se << -v)), K = i.ag * (n.tileID.canonical.y - (t.canonical.y << -v))), i.ab.mat4.ortho(p, 0, C, 0, C, 0, 1), i.ab.mat4.translate(p, p, [V, K, 0]);
            }
            return new vl(n.tileID, t.key, p);
          }
          _findTileCoveringTileID(t, n) {
            let c = n.getTile(t);
            if (c && c.hasData()) return c;
            const p = this._findCoveringTileCache[n.id], v = p[t.key];
            if (c = v ? n.getTileByID(v) : null, c && c.hasData() || v === null) return c;
            let C = c ? c.tileID : t, V = C.overscaledZ;
            const K = n.getSource().minzoom, se = [];
            if (!v) {
              const ve = n.getSource().maxzoom;
              if (t.canonical.z >= ve) {
                const xe = t.canonical.z - ve;
                n.getSource().reparseOverscaled ? (V = Math.max(t.canonical.z + 2, n.transform.tileZoom), C = new i.aG(V, t.wrap, ve, t.canonical.x >> xe, t.canonical.y >> xe)) : xe !== 0 && (V = ve, C = new i.aG(V, t.wrap, ve, t.canonical.x >> xe, t.canonical.y >> xe));
              }
              C.key !== t.key && (se.push(C.key), c = n.getTile(C));
            }
            const oe = (ve) => {
              se.forEach((xe) => {
                p[xe] = ve;
              }), se.length = 0;
            };
            for (V -= 1; V >= K && (!c || !c.hasData()); V--) {
              c && oe(c.tileID.key);
              const ve = C.calculateScaledKey(V);
              if (c = n.getTileByID(ve), c && c.hasData()) break;
              const xe = p[ve];
              if (xe === null) break;
              xe === void 0 ? se.push(ve) : c = n.getTileByID(xe);
            }
            return oe(c ? c.tileID.key : null), c && c.hasData() ? c : null;
          }
          findDEMTileFor(t) {
            return this.enabled ? this._findTileCoveringTileID(t, this.sourceCache) : null;
          }
          prepareDrawTile() {
            this.renderedToTile = !0;
          }
          _clearRenderCacheForTile(t, n) {
            let c = this._tilesDirty[t];
            c || (c = this._tilesDirty[t] = {}), c[n.key] = !0;
          }
        }
        function qs(u, t, n) {
          const c = function(V, K, se) {
            const oe = i.ab.vec3.dot(K, V), ve = i.ab.vec3.dot(se, [0.2126, 0.7152, 0.0722]), xe = (ft, st, vt) => (1 - vt) * ft + vt * st, Le = xe(1 - 0.3 * Math.min(ve, 1), 1, Math.min(oe + 1, 1));
            return xe(0.92, 1, Math.asin(i.aw(K[2], -1, 1)) / Math.PI + 0.5) * Le;
          }(u, [0, 0, 1], t), p = [0, 0, 0];
          i.ab.vec3.scale(p, n.slice(0, 3), c);
          const v = [0, 0, 0];
          i.ab.vec3.scale(v, t.slice(0, 3), u[2]);
          const C = [0, 0, 0];
          return i.ab.vec3.add(C, p, v), i.cf(C);
        }
        const gh = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], ef = ["stars", "rainParticle", "snowParticle", "fillExtrusion", "fillExtrusionGroundEffect", "model", "symbol"];
        class tf {
          static cacheKey(t, n, c, p) {
            let v = `${n}${p ? p.cacheKey : ""}`;
            for (const C of c) t.usedDefines.includes(C) && (v += `/${C}`);
            return v;
          }
          constructor(t, n, c, p, v, C) {
            const V = t.gl;
            this.program = V.createProgram(), this.configuration = p, this.name = n, this.fixedDefines = [...C];
            const K = p ? p.getBinderAttributes() : [], se = (c.staticAttributes || []).concat(K);
            let oe = p ? p.defines() : [];
            oe = oe.concat(C.map((vt) => `#define ${vt}`));
            const ve = `#version 300 es
`;
            let xe = ve + oe.concat("precision mediump float;", tc, Lc.fragmentSource).join(`
`);
            for (const vt of c.fragmentIncludes) xe += `
${hu[vt]}`;
            xe += `
${c.fragmentSource}`;
            let Le = ve + oe.concat("precision highp float;", tc, Lc.vertexSource).join(`
`);
            for (const vt of c.vertexIncludes) Le += `
${hu[vt]}`;
            this.forceManualRenderingForInstanceIDShaders = t.forceManualRenderingForInstanceIDShaders && c.vertexSource.indexOf("gl_InstanceID") !== -1, this.forceManualRenderingForInstanceIDShaders && (Le += `
uniform int u_instanceID;
`), Le += `
${c.vertexSource}`, this.forceManualRenderingForInstanceIDShaders && (Le = Le.replaceAll("gl_InstanceID", "u_instanceID"));
            const ft = V.createShader(V.FRAGMENT_SHADER);
            if (V.isContextLost()) return void (this.failedToCreate = !0);
            V.shaderSource(ft, xe), V.compileShader(ft), V.attachShader(this.program, ft);
            const st = V.createShader(V.VERTEX_SHADER);
            if (V.isContextLost()) this.failedToCreate = !0;
            else {
              V.shaderSource(st, Le), V.compileShader(st), V.attachShader(this.program, st), this.attributes = {}, this.numAttributes = se.length;
              for (let vt = 0; vt < this.numAttributes; vt++) if (se[vt]) {
                const gt = se[vt].startsWith("a_") ? se[vt] : `a_${se[vt]}`;
                V.bindAttribLocation(this.program, vt, gt), this.attributes[gt] = vt;
              }
              V.linkProgram(this.program), V.deleteShader(st), V.deleteShader(ft), this.fixedUniforms = v(t), this.binderUniforms = p ? p.getUniforms(t) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = ((vt) => ({ u_instanceID: new i.bN(vt) }))(t)), (C.includes("TERRAIN") || n.indexOf("symbol") !== -1 || n.indexOf("circle") !== -1) && (this.terrainUniforms = ((vt) => ({ u_dem: new i.bN(vt), u_dem_prev: new i.bN(vt), u_dem_tl: new i.bK(vt), u_dem_scale: new i.bM(vt), u_dem_tl_prev: new i.bK(vt), u_dem_scale_prev: new i.bM(vt), u_dem_size: new i.bM(vt), u_dem_lerp: new i.bM(vt), u_exaggeration: new i.bM(vt), u_depth: new i.bN(vt), u_depth_size_inv: new i.bK(vt), u_depth_range_unpack: new i.bK(vt), u_occluder_half_size: new i.bM(vt), u_occlusion_depth_offset: new i.bM(vt), u_meter_to_dem: new i.bM(vt), u_label_plane_matrix_inv: new i.bJ(vt) }))(t)), C.includes("GLOBE") && (this.globeUniforms = ((vt) => ({ u_tile_tl_up: new i.bL(vt), u_tile_tr_up: new i.bL(vt), u_tile_br_up: new i.bL(vt), u_tile_bl_up: new i.bL(vt), u_tile_up_scale: new i.bM(vt) }))(t)), C.includes("FOG") && (this.fogUniforms = ((vt) => ({ u_fog_matrix: new i.bJ(vt), u_fog_range: new i.bK(vt), u_fog_color: new i.ca(vt), u_fog_horizon_blend: new i.bM(vt), u_fog_vertical_limit: new i.bK(vt), u_fog_temporal_offset: new i.bM(vt), u_frustum_tl: new i.bL(vt), u_frustum_tr: new i.bL(vt), u_frustum_br: new i.bL(vt), u_frustum_bl: new i.bL(vt), u_globe_pos: new i.bL(vt), u_globe_radius: new i.bM(vt), u_globe_transition: new i.bM(vt), u_is_globe: new i.bN(vt), u_viewport: new i.bK(vt) }))(t)), C.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((vt) => ({ u_cutoff_params: new i.ca(vt) }))(t)), C.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((vt) => ({ u_lighting_ambient_color: new i.bL(vt), u_lighting_directional_dir: new i.bL(vt), u_lighting_directional_color: new i.bL(vt), u_ground_radiance: new i.bL(vt) }))(t)), C.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((vt) => ({ u_light_matrix_0: new i.bJ(vt), u_light_matrix_1: new i.bJ(vt), u_fade_range: new i.bK(vt), u_shadow_normal_offset: new i.bL(vt), u_shadow_intensity: new i.bM(vt), u_shadow_texel_size: new i.bM(vt), u_shadow_map_resolution: new i.bM(vt), u_shadow_direction: new i.bL(vt), u_shadow_bias: new i.bL(vt), u_shadowmap_0: new i.bN(vt), u_shadowmap_1: new i.bN(vt) }))(t));
            }
          }
          setTerrainUniformValues(t, n) {
            if (!this.terrainUniforms) return;
            const c = this.terrainUniforms;
            if (!this.failedToCreate) {
              t.program.set(this.program);
              for (const p in n) c[p] && c[p].set(this.program, p, n[p]);
            }
          }
          setGlobeUniformValues(t, n) {
            if (!this.globeUniforms) return;
            const c = this.globeUniforms;
            if (!this.failedToCreate) {
              t.program.set(this.program);
              for (const p in n) c[p] && c[p].set(this.program, p, n[p]);
            }
          }
          setFogUniformValues(t, n) {
            if (!this.fogUniforms) return;
            const c = this.fogUniforms;
            if (!this.failedToCreate) {
              t.program.set(this.program);
              for (const p in n) c[p].set(this.program, p, n[p]);
            }
          }
          setCutoffUniformValues(t, n) {
            if (!this.cutoffUniforms) return;
            const c = this.cutoffUniforms;
            if (!this.failedToCreate) {
              t.program.set(this.program);
              for (const p in n) c[p].set(this.program, p, n[p]);
            }
          }
          setLightsUniformValues(t, n) {
            if (!this.lightsUniforms) return;
            const c = this.lightsUniforms;
            if (!this.failedToCreate) {
              t.program.set(this.program);
              for (const p in n) c[p].set(this.program, p, n[p]);
            }
          }
          setShadowUniformValues(t, n) {
            if (this.failedToCreate || !this.shadowUniforms) return;
            const c = this.shadowUniforms;
            t.program.set(this.program);
            for (const p in n) c[p].set(this.program, p, n[p]);
          }
          _drawDebugWireframe(t, n, c, p, v, C, V, K, se, oe) {
            const ve = t.options.wireframe;
            if (ve.terrain === !1 && ve.layers2D === !1 && ve.layers3D === !1) return;
            const xe = t.context;
            if (!(!(!ve.terrain || this.name !== "terrainRaster" && this.name !== "globeRaster") || !(!ve.layers2D || t._terrain && t._terrain.renderingToTexture || !gh.includes(this.name)) || !(!ve.layers3D || !ef.includes(this.name)))) return;
            const Le = xe.gl, ft = t.wireframeDebugCache.getLinesFromTrianglesBuffer(t.frameCounter, v, xe);
            if (!ft) return;
            const st = [...this.fixedDefines];
            st.push("DEBUG_WIREFRAME");
            const vt = t.getOrCreateProgram(this.name, { config: this.configuration, defines: st });
            xe.program.set(vt.program);
            const gt = (jt, ii, Xt) => {
              if (ii[jt] && Xt[jt]) for (const Kt in ii[jt]) Xt[jt][Kt] && Xt[jt][Kt].set(Xt.program, Kt, ii[jt][Kt].current);
            };
            se && se.setUniforms(vt.program, xe, vt.binderUniforms, V, { zoom: K }), gt("fixedUniforms", this, vt), gt("terrainUniforms", this, vt), gt("globeUniforms", this, vt), gt("fogUniforms", this, vt), gt("lightsUniforms", this, vt), gt("shadowUniforms", this, vt), ft.bind(), xe.setColorMode(new zr([Le.ONE, Le.ONE_MINUS_SRC_ALPHA, Le.ZERO, Le.ONE], i.aj.transparent, [!0, !0, !0, !1])), xe.setDepthMode(new Sr(n.func === Le.LESS ? Le.LEQUAL : n.func, Sr.ReadOnly, n.range)), xe.setStencilMode(Lr.disabled);
            const Rt = 3 * C.primitiveLength * 2, qt = 3 * C.primitiveOffset * 2 * 2;
            if (this.forceManualRenderingForInstanceIDShaders) {
              const jt = oe || 1;
              for (let ii = 0; ii < jt; ++ii) vt.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", ii), Le.drawElements(Le.LINES, Rt, Le.UNSIGNED_SHORT, qt);
            } else oe && oe > 1 ? Le.drawElementsInstanced(Le.LINES, Rt, Le.UNSIGNED_SHORT, qt, oe) : Le.drawElements(Le.LINES, Rt, Le.UNSIGNED_SHORT, qt);
            v.bind(), xe.program.set(this.program), xe.setDepthMode(n), xe.setStencilMode(c), xe.setColorMode(p);
          }
          checkUniforms(t, n, c) {
            if (this.fixedDefines.includes(n)) {
              for (const p of Object.keys(c)) if (!c[p].initialized) throw new Error(`Program '${this.name}', from draw '${t}': uniform ${p} not set but required by ${n} being defined`);
            }
          }
          draw(t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st, vt) {
            const gt = t.context, Rt = gt.gl;
            if (this.failedToCreate) return;
            gt.program.set(this.program), gt.setDepthMode(c), gt.setStencilMode(p), gt.setColorMode(v), gt.setCullFace(C);
            for (const ii of Object.keys(this.fixedUniforms)) this.fixedUniforms[ii].set(this.program, ii, V[ii]);
            ft && ft.setUniforms(this.program, gt, this.binderUniforms, xe, { zoom: Le });
            const qt = { [Rt.POINTS]: 1, [Rt.LINES]: 2, [Rt.TRIANGLES]: 3, [Rt.LINE_STRIP]: 1 }[n];
            this.checkUniforms(K, "RENDER_SHADOWS", this.shadowUniforms);
            const jt = vt && vt > 0 ? 1 : void 0;
            for (const ii of ve.get()) {
              const Xt = ii.vaos || (ii.vaos = {});
              if ((Xt[K] || (Xt[K] = new uh())).bind(gt, this, se, ft ? ft.getPaintVertexBuffers() : [], oe, ii.vertexOffset, st || [], jt), this.forceManualRenderingForInstanceIDShaders) {
                const Kt = vt || 1;
                for (let Zt = 0; Zt < Kt; ++Zt) this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", Zt), oe ? Rt.drawElements(n, ii.primitiveLength * qt, Rt.UNSIGNED_SHORT, ii.primitiveOffset * qt * 2) : Rt.drawArrays(n, ii.vertexOffset, ii.vertexLength);
              } else vt && vt > 1 ? Rt.drawElementsInstanced(n, ii.primitiveLength * qt, Rt.UNSIGNED_SHORT, ii.primitiveOffset * qt * 2, vt) : oe ? Rt.drawElements(n, ii.primitiveLength * qt, Rt.UNSIGNED_SHORT, ii.primitiveOffset * qt * 2) : Rt.drawArrays(n, ii.vertexOffset, ii.vertexLength);
              n === Rt.TRIANGLES && oe && this._drawDebugWireframe(t, c, p, v, oe, ii, xe, Le, ft, vt);
            }
          }
        }
        function vu(u, t) {
          const n = Math.pow(2, t.tileID.overscaledZ), c = t.tileSize * Math.pow(2, u.transform.tileZoom) / n, p = c * (t.tileID.canonical.x + t.tileID.wrap * n), v = c * t.tileID.canonical.y;
          return { u_image: 0, u_texsize: t.imageAtlasTexture ? t.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / i.ar(t, 1, u.transform.tileZoom), u_pixel_coord_upper: [p >> 16, v >> 16], u_pixel_coord_lower: [65535 & p, 65535 & v] };
        }
        const yu = { terrain: 0, flat: 1 }, Ws = i.ab.mat4.create(), xu = (u, t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st, vt, gt) => {
          const Rt = t.style.light, qt = Rt.properties.get("position"), jt = [qt.x, qt.y, qt.z], ii = i.ab.mat3.create();
          Rt.properties.get("anchor") === "viewport" && (i.ab.mat3.fromRotation(ii, -t.transform.angle), i.ab.vec3.transformMat3(jt, jt, ii));
          const Xt = Rt.properties.get("color"), Kt = t.transform, Zt = { u_matrix: u, u_lightpos: jt, u_lightintensity: Rt.properties.get("intensity"), u_lightcolor: [Xt.r, Xt.g, Xt.b], u_vertical_gradient: +n, u_opacity: c, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Ws, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_height_type: yu[se], u_base_type: yu[oe], u_ao: p, u_edge_radius: v, u_width_scale: C, u_flood_light_color: ft, u_vertical_scale: st, u_flood_light_intensity: vt, u_ground_shadow_factor: gt };
          return Kt.projection.name === "globe" && (Zt.u_tile_id = [V.canonical.x, V.canonical.y, 1 << V.canonical.z], Zt.u_zoom_transition = ve, Zt.u_inv_rot_matrix = Le, Zt.u_merc_center = xe, Zt.u_up_dir = Kt.projection.upVector(new i.bT(0, 0, 0), xe[0] * i.ag, xe[1] * i.ag), Zt.u_height_lift = K), Zt;
        }, bu = (u, t, n, c, p, v) => ({ u_matrix: u, u_edge_radius: t, u_width_scale: n, u_vertical_scale: c, u_height_type: yu[p], u_base_type: yu[v] }), rf = (u, t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st, vt) => {
          const gt = xu(u, t, n, c, p, v, C, V, se, oe, ve, xe, Le, ft, st, vt, 1, [0, 0, 0]), Rt = { u_height_factor: -Math.pow(2, V.overscaledZ) / K.tileSize / 8 };
          return i.l(gt, vu(t, K), Rt);
        }, Uc = (u, t) => ({ u_matrix: u, u_emissive_strength: t }), wo = (u, t, n, c) => i.l(Uc(u, t), vu(n, c)), Vl = (u, t, n) => ({ u_matrix: u, u_world: n, u_emissive_strength: t }), wu = (u, t, n, c, p) => i.l(wo(u, t, n, c), { u_world: p }), vh = (u, t, n, c) => {
          const p = i.ag / n.tileSize;
          return { u_matrix: u, u_camera_to_center_distance: t.getCameraToCenterDistance(c), u_extrude_scale: [t.pixelsToGLUnits[0] / p, t.pixelsToGLUnits[1] / p] };
        }, Xo = (u, t, n = 1) => ({ u_matrix: u, u_color: t.toRenderColor(null), u_overlay: 0, u_overlay_scale: n }), ks = i.ab.mat4.create(), ur = (u, t, n, c, p, v, C) => {
          const V = u.transform, K = V.projection.name === "globe", se = K ? i.cN(V.zoom, t.canonical) * V._pixelsPerMercatorPixel : i.ar(n, 1, v), oe = { u_matrix: t.projMatrix, u_extrude_scale: se, u_intensity: C, u_inv_rot_matrix: ks, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (K) {
            oe.u_inv_rot_matrix = c, oe.u_merc_center = p, oe.u_tile_id = [t.canonical.x, t.canonical.y, 1 << t.canonical.z], oe.u_zoom_transition = i.ae(V.zoom);
            const ve = p[0] * i.ag, xe = p[1] * i.ag;
            oe.u_up_dir = V.projection.upVector(new i.bT(0, 0, 0), ve, xe);
          }
          return oe;
        };
        function yl(u, [t, n, c, p], [v, C]) {
          if (v === C) return [0, 0, 0, 0];
          const V = 255 * (u - 1) / (u * (C - v));
          return [t * V, n * V, c * V, p * V];
        }
        function Po(u, t, [n, c]) {
          return n === c ? 0 : 0.5 / u + (t - n) * (u - 1) / (u * (c - n));
        }
        const ws = (u, t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st, vt, gt, Rt, qt, jt) => ({ u_matrix: u, u_normalize_matrix: t, u_globe_matrix: n, u_merc_matrix: c, u_grid_matrix: p, u_tl_parent: v, u_scale_parent: se, u_fade_t: oe.mix, u_opacity: oe.opacity * ve.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: ve.paint.get("raster-brightness-min"), u_brightness_high: ve.paint.get("raster-brightness-max"), u_saturation_factor: i.cO(ve.paint.get("raster-saturation")), u_contrast_factor: i.cP(ve.paint.get("raster-contrast")), u_spin_weights: so(ve.paint.get("raster-hue-rotate")), u_perspective_transform: xe, u_raster_elevation: Le, u_zoom_transition: C, u_merc_center: V, u_cutoff_params: K, u_colorization_mix: yl(i.cQ, st, gt), u_colorization_offset: Po(i.cQ, vt, gt), u_color_ramp: ft, u_texture_offset: [qt / (Rt + 2 * qt), Rt / (Rt + 2 * qt)], u_texture_res: [Rt + 2 * qt, Rt + 2 * qt], u_emissive_strength: jt });
        function so(u) {
          u *= Math.PI / 180;
          const t = Math.sin(u), n = Math.cos(u);
          return [(2 * n + 1) / 3, (-Math.sqrt(3) * t - n + 1) / 3, (Math.sqrt(3) * t - n + 1) / 3];
        }
        const wr = 0.05, Vc = (u, t, n, c, p, v, C, V, K, se, oe, ve) => ({ u_matrix: u, u_normalize_matrix: t, u_globe_matrix: n, u_merc_matrix: c, u_grid_matrix: p, u_tl_parent: v, u_scale_parent: se, u_fade_t: oe.mix, u_opacity: oe.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: ve, u_zoom_transition: C, u_merc_center: V, u_cutoff_params: K }), nf = (u, t, n, c, p, v, C, V, K, se) => ({ u_particle_texture: u, u_particle_texture_side_len: t, u_tile_offset: n, u_velocity: c, u_color_ramp: v, u_velocity_res: p, u_max_speed: C, u_uv_offset: V, u_data_scale: [255 * K[0], 255 * K[1]], u_data_offset: se, u_particle_pos_scale: 1.1, u_particle_pos_offset: [wr, wr] }), oo = (u, t, n, c, p, v, C, V, K, se) => ({ u_particle_texture: u, u_particle_texture_side_len: t, u_velocity: n, u_velocity_res: c, u_max_speed: p, u_speed_factor: v, u_reset_rate: C, u_rand_seed: Math.random(), u_uv_offset: V, u_data_scale: [255 * K[0], 255 * K[1]], u_data_offset: se, u_particle_pos_scale: 1.1, u_particle_pos_offset: [wr, wr] }), Ss = i.ab.mat4.create(), Sa = (u, t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st, vt, gt, Rt, qt, jt, ii) => {
          const Xt = p.transform, Kt = { u_is_size_zoom_constant: +(u === "constant" || u === "source"), u_is_size_feature_constant: +(u === "constant" || u === "camera"), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: Xt.getCameraToCenterDistance(Rt), u_rotate_symbol: +n, u_aspect_ratio: Xt.width / Xt.height, u_fade_change: p.options.fadeDuration ? p.symbolFadeChange : 1, u_matrix: v, u_label_plane_matrix: C, u_coord_matrix: V, u_is_text: +se, u_elevation_from_sea: K ? 1 : 0, u_pitch_with_map: +c, u_texsize: oe, u_texsize_icon: ve, u_texture: 0, u_texture_icon: 1, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Ss, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: Ss, u_up_vector: [0, -1, 0], u_color_adj_mat: qt, u_icon_transition: jt || 0, u_gamma_scale: c ? p.transform.getCameraToCenterDistance(Rt) * Math.cos(p.terrain ? 0 : p.transform._pitch) : 1, u_device_pixel_ratio: i.q.devicePixelRatio, u_is_halo: +xe, u_scale_factor: ii || 1 };
          return Rt.name === "globe" && (Kt.u_tile_id = [Le.canonical.x, Le.canonical.y, 1 << Le.canonical.z], Kt.u_zoom_transition = ft, Kt.u_inv_rot_matrix = vt, Kt.u_merc_center = st, Kt.u_camera_forward = Xt._camera.forward(), Kt.u_ecef_origin = i.cR(Xt.globeMatrix, Le.toUnwrapped()), Kt.u_tile_matrix = Float32Array.from(Xt.globeMatrix), Kt.u_up_vector = gt), Kt;
        }, lo = (u, t, n, c) => ({ u_matrix: u, u_emissive_strength: t, u_opacity: n, u_color: c }), af = (u, t, n, c, p, v, C, V, K) => i.l(function(se, oe, ve, xe, Le, ft) {
          const { width: st, height: vt } = xe.imageManager.getPixelSize(oe), gt = Math.pow(2, ft.tileID.overscaledZ), Rt = ft.tileSize * Math.pow(2, xe.transform.tileZoom) / gt, qt = Rt * (ft.tileID.canonical.x + ft.tileID.wrap * gt), jt = Rt * ft.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl: ve.tl, u_pattern_br: ve.br, u_texsize: [st, vt], u_pattern_size: ve.displaySize, u_pattern_units_to_pixels: Le ? [xe.transform.width, -1 * xe.transform.height] : [1 / i.ar(ft, 1, xe.transform.tileZoom), 1 / i.ar(ft, 1, xe.transform.tileZoom)], u_pixel_coord_upper: [qt >> 16, jt >> 16], u_pixel_coord_lower: [65535 & qt, 65535 & jt] };
        }(0, v, C, c, V, K), { u_matrix: u, u_emissive_strength: t, u_opacity: n }), yh = new Float32Array(i.ab.mat4.identity([])), Su = (u, t, n, c, p, v, C, V, K, se, oe, ve, xe, Le = [0, 0, 0], ft) => {
          const st = p.style.light, vt = st.properties.get("position"), gt = [-vt.x, -vt.y, vt.z], Rt = i.ab.mat3.create();
          st.properties.get("anchor") === "viewport" && (i.ab.mat3.fromRotation(Rt, -p.transform.angle), i.ab.vec3.transformMat3(gt, gt, Rt));
          const qt = oe.alphaMode === "MASK", jt = st.properties.get("color").toRenderColor(null), ii = xe.paint.get("model-ambient-occlusion-intensity"), Xt = xe.paint.get("model-color").constantOr(i.aj.white).toRenderColor(null), Kt = xe.paint.get("model-color-mix-intensity").constantOr(0);
          return { u_matrix: u, u_lighting_matrix: t, u_normal_matrix: n, u_node_matrix: c || yh, u_lightpos: gt, u_lightintensity: st.properties.get("intensity"), u_lightcolor: [jt.r, jt.g, jt.b], u_camera_pos: Le, u_opacity: v, u_baseTextureIsAlpha: 0, u_alphaMask: +qt, u_alphaCutoff: oe.alphaCutoff, u_baseColorFactor: [C.r, C.g, C.b, C.a], u_emissiveFactor: [V[0], V[1], V[2], 1], u_metallicFactor: K, u_roughnessFactor: se, u_baseColorTexture: $a.BaseColor, u_metallicRoughnessTexture: $a.MetallicRoughness, u_normalTexture: $a.Normal, u_occlusionTexture: $a.Occlusion, u_emissionTexture: $a.Emission, u_lutTexture: $a.LUT, u_color_mix: [Xt.r, Xt.g, Xt.b, Kt], u_aoIntensity: ii, u_emissive_strength: ve, u_occlusionTextureTransform: ft || [0, 0, 0, 0] };
        }, oc = (u, t = yh, n = yh) => ({ u_matrix: u, u_instance: t, u_node_matrix: n }), xh = { fillExtrusion: (u) => ({ u_matrix: new i.bJ(u), u_lightpos: new i.bL(u), u_lightintensity: new i.bM(u), u_lightcolor: new i.bL(u), u_vertical_gradient: new i.bM(u), u_opacity: new i.bM(u), u_edge_radius: new i.bM(u), u_width_scale: new i.bM(u), u_ao: new i.bK(u), u_height_type: new i.bN(u), u_base_type: new i.bN(u), u_tile_id: new i.bL(u), u_zoom_transition: new i.bM(u), u_inv_rot_matrix: new i.bJ(u), u_merc_center: new i.bK(u), u_up_dir: new i.bL(u), u_height_lift: new i.bM(u), u_flood_light_color: new i.bL(u), u_vertical_scale: new i.bM(u), u_flood_light_intensity: new i.bM(u), u_ground_shadow_factor: new i.bL(u) }), fillExtrusionDepth: (u) => ({ u_matrix: new i.bJ(u), u_edge_radius: new i.bM(u), u_width_scale: new i.bM(u), u_vertical_scale: new i.bM(u), u_height_type: new i.bN(u), u_base_type: new i.bN(u) }), fillExtrusionPattern: (u) => ({ u_matrix: new i.bJ(u), u_lightpos: new i.bL(u), u_lightintensity: new i.bM(u), u_lightcolor: new i.bL(u), u_vertical_gradient: new i.bM(u), u_height_factor: new i.bM(u), u_edge_radius: new i.bM(u), u_width_scale: new i.bM(u), u_ao: new i.bK(u), u_height_type: new i.bN(u), u_base_type: new i.bN(u), u_tile_id: new i.bL(u), u_zoom_transition: new i.bM(u), u_inv_rot_matrix: new i.bJ(u), u_merc_center: new i.bK(u), u_up_dir: new i.bL(u), u_height_lift: new i.bM(u), u_image: new i.bN(u), u_texsize: new i.bK(u), u_pixel_coord_upper: new i.bK(u), u_pixel_coord_lower: new i.bK(u), u_tile_units_to_pixels: new i.bM(u), u_opacity: new i.bM(u) }), fillExtrusionGroundEffect: (u) => ({ u_matrix: new i.bJ(u), u_opacity: new i.bM(u), u_ao_pass: new i.bM(u), u_meter_to_tile: new i.bM(u), u_ao: new i.bK(u), u_flood_light_intensity: new i.bM(u), u_flood_light_color: new i.bL(u), u_attenuation: new i.bM(u), u_edge_radius: new i.bM(u), u_fb: new i.bN(u), u_fb_size: new i.bM(u), u_dynamic_offset: new i.bM(u) }), fill: (u) => ({ u_matrix: new i.bJ(u), u_emissive_strength: new i.bM(u) }), fillPattern: (u) => ({ u_matrix: new i.bJ(u), u_emissive_strength: new i.bM(u), u_image: new i.bN(u), u_texsize: new i.bK(u), u_pixel_coord_upper: new i.bK(u), u_pixel_coord_lower: new i.bK(u), u_tile_units_to_pixels: new i.bM(u) }), fillOutline: (u) => ({ u_matrix: new i.bJ(u), u_emissive_strength: new i.bM(u), u_world: new i.bK(u) }), fillOutlinePattern: (u) => ({ u_matrix: new i.bJ(u), u_emissive_strength: new i.bM(u), u_world: new i.bK(u), u_image: new i.bN(u), u_texsize: new i.bK(u), u_pixel_coord_upper: new i.bK(u), u_pixel_coord_lower: new i.bK(u), u_tile_units_to_pixels: new i.bM(u) }), circle: i.cS, collisionBox: (u) => ({ u_matrix: new i.bJ(u), u_camera_to_center_distance: new i.bM(u), u_extrude_scale: new i.bK(u) }), collisionCircle: (u) => ({ u_matrix: new i.bJ(u), u_inv_matrix: new i.bJ(u), u_camera_to_center_distance: new i.bM(u), u_viewport_size: new i.bK(u) }), debug: (u) => ({ u_color: new i.cz(u), u_matrix: new i.bJ(u), u_overlay: new i.bN(u), u_overlay_scale: new i.bM(u) }), clippingMask: (u) => ({ u_matrix: new i.bJ(u) }), heatmap: (u) => ({ u_extrude_scale: new i.bM(u), u_intensity: new i.bM(u), u_matrix: new i.bJ(u), u_inv_rot_matrix: new i.bJ(u), u_merc_center: new i.bK(u), u_tile_id: new i.bL(u), u_zoom_transition: new i.bM(u), u_up_dir: new i.bL(u) }), heatmapTexture: (u) => ({ u_image: new i.bN(u), u_color_ramp: new i.bN(u), u_opacity: new i.bM(u) }), hillshade: (u) => ({ u_matrix: new i.bJ(u), u_image: new i.bN(u), u_latrange: new i.bK(u), u_light: new i.bK(u), u_shadow: new i.cz(u), u_highlight: new i.cz(u), u_emissive_strength: new i.bM(u), u_accent: new i.cz(u) }), hillshadePrepare: (u) => ({ u_matrix: new i.bJ(u), u_image: new i.bN(u), u_dimension: new i.bK(u), u_zoom: new i.bM(u) }), line: i.cT, linePattern: i.cU, raster: (u) => ({ u_matrix: new i.bJ(u), u_normalize_matrix: new i.bJ(u), u_globe_matrix: new i.bJ(u), u_merc_matrix: new i.bJ(u), u_grid_matrix: new i.cA(u), u_tl_parent: new i.bK(u), u_scale_parent: new i.bM(u), u_fade_t: new i.bM(u), u_opacity: new i.bM(u), u_image0: new i.bN(u), u_image1: new i.bN(u), u_brightness_low: new i.bM(u), u_brightness_high: new i.bM(u), u_saturation_factor: new i.bM(u), u_contrast_factor: new i.bM(u), u_spin_weights: new i.bL(u), u_perspective_transform: new i.bK(u), u_raster_elevation: new i.bM(u), u_zoom_transition: new i.bM(u), u_merc_center: new i.bK(u), u_cutoff_params: new i.ca(u), u_colorization_mix: new i.ca(u), u_colorization_offset: new i.bM(u), u_color_ramp: new i.bN(u), u_texture_offset: new i.bK(u), u_texture_res: new i.bK(u), u_emissive_strength: new i.bM(u) }), rasterParticle: (u) => ({ u_matrix: new i.bJ(u), u_normalize_matrix: new i.bJ(u), u_globe_matrix: new i.bJ(u), u_merc_matrix: new i.bJ(u), u_grid_matrix: new i.cA(u), u_tl_parent: new i.bK(u), u_scale_parent: new i.bM(u), u_fade_t: new i.bM(u), u_opacity: new i.bM(u), u_image0: new i.bN(u), u_image1: new i.bN(u), u_raster_elevation: new i.bM(u), u_zoom_transition: new i.bM(u), u_merc_center: new i.bK(u), u_cutoff_params: new i.ca(u) }), rasterParticleTexture: (u) => ({ u_texture: new i.bN(u), u_opacity: new i.bM(u) }), rasterParticleDraw: (u) => ({ u_particle_texture: new i.bN(u), u_particle_texture_side_len: new i.bM(u), u_tile_offset: new i.bK(u), u_velocity: new i.bN(u), u_color_ramp: new i.bN(u), u_velocity_res: new i.bK(u), u_max_speed: new i.bM(u), u_uv_offset: new i.bK(u), u_data_scale: new i.bK(u), u_data_offset: new i.bM(u), u_particle_pos_scale: new i.bM(u), u_particle_pos_offset: new i.bK(u) }), rasterParticleUpdate: (u) => ({ u_particle_texture: new i.bN(u), u_particle_texture_side_len: new i.bM(u), u_velocity: new i.bN(u), u_velocity_res: new i.bK(u), u_max_speed: new i.bM(u), u_speed_factor: new i.bM(u), u_reset_rate: new i.bM(u), u_rand_seed: new i.bM(u), u_uv_offset: new i.bK(u), u_data_scale: new i.bK(u), u_data_offset: new i.bM(u), u_particle_pos_scale: new i.bM(u), u_particle_pos_offset: new i.bK(u) }), symbol: (u) => ({ u_is_size_zoom_constant: new i.bN(u), u_is_size_feature_constant: new i.bN(u), u_size_t: new i.bM(u), u_size: new i.bM(u), u_camera_to_center_distance: new i.bM(u), u_rotate_symbol: new i.bN(u), u_aspect_ratio: new i.bM(u), u_fade_change: new i.bM(u), u_matrix: new i.bJ(u), u_label_plane_matrix: new i.bJ(u), u_coord_matrix: new i.bJ(u), u_is_text: new i.bN(u), u_elevation_from_sea: new i.bN(u), u_pitch_with_map: new i.bN(u), u_texsize: new i.bK(u), u_texsize_icon: new i.bK(u), u_texture: new i.bN(u), u_texture_icon: new i.bN(u), u_gamma_scale: new i.bM(u), u_device_pixel_ratio: new i.bM(u), u_tile_id: new i.bL(u), u_zoom_transition: new i.bM(u), u_inv_rot_matrix: new i.bJ(u), u_merc_center: new i.bK(u), u_camera_forward: new i.bL(u), u_tile_matrix: new i.bJ(u), u_up_vector: new i.bL(u), u_ecef_origin: new i.bL(u), u_is_halo: new i.bN(u), u_icon_transition: new i.bM(u), u_color_adj_mat: new i.bJ(u), u_scale_factor: new i.bM(u) }), background: (u) => ({ u_matrix: new i.bJ(u), u_emissive_strength: new i.bM(u), u_opacity: new i.bM(u), u_color: new i.cz(u) }), backgroundPattern: (u) => ({ u_matrix: new i.bJ(u), u_emissive_strength: new i.bM(u), u_opacity: new i.bM(u), u_image: new i.bN(u), u_pattern_tl: new i.bK(u), u_pattern_br: new i.bK(u), u_texsize: new i.bK(u), u_pattern_size: new i.bK(u), u_pixel_coord_upper: new i.bK(u), u_pixel_coord_lower: new i.bK(u), u_pattern_units_to_pixels: new i.bK(u) }), terrainRaster: (u) => ({ u_matrix: new i.bJ(u), u_image0: new i.bN(u), u_skirt_height: new i.bM(u), u_ground_shadow_factor: new i.bL(u) }), skybox: (u) => ({ u_matrix: new i.bJ(u), u_sun_direction: new i.bL(u), u_cubemap: new i.bN(u), u_opacity: new i.bM(u), u_temporal_offset: new i.bM(u) }), skyboxGradient: (u) => ({ u_matrix: new i.bJ(u), u_color_ramp: new i.bN(u), u_center_direction: new i.bL(u), u_radius: new i.bM(u), u_opacity: new i.bM(u), u_temporal_offset: new i.bM(u) }), skyboxCapture: (u) => ({ u_matrix_3f: new i.cA(u), u_sun_direction: new i.bL(u), u_sun_intensity: new i.bM(u), u_color_tint_r: new i.ca(u), u_color_tint_m: new i.ca(u), u_luminance: new i.bM(u) }), globeRaster: (u) => ({ u_proj_matrix: new i.bJ(u), u_globe_matrix: new i.bJ(u), u_normalize_matrix: new i.bJ(u), u_merc_matrix: new i.bJ(u), u_zoom_transition: new i.bM(u), u_merc_center: new i.bK(u), u_image0: new i.bN(u), u_grid_matrix: new i.cA(u), u_skirt_height: new i.bM(u), u_far_z_cutoff: new i.bM(u), u_frustum_tl: new i.bL(u), u_frustum_tr: new i.bL(u), u_frustum_br: new i.bL(u), u_frustum_bl: new i.bL(u), u_globe_pos: new i.bL(u), u_globe_radius: new i.bM(u), u_viewport: new i.bK(u) }), globeAtmosphere: (u) => ({ u_frustum_tl: new i.bL(u), u_frustum_tr: new i.bL(u), u_frustum_br: new i.bL(u), u_frustum_bl: new i.bL(u), u_horizon: new i.bM(u), u_transition: new i.bM(u), u_fadeout_range: new i.bM(u), u_color: new i.ca(u), u_high_color: new i.ca(u), u_space_color: new i.ca(u), u_temporal_offset: new i.bM(u), u_horizon_angle: new i.bM(u) }), model: (u) => ({ u_matrix: new i.bJ(u), u_lighting_matrix: new i.bJ(u), u_normal_matrix: new i.bJ(u), u_node_matrix: new i.bJ(u), u_lightpos: new i.bL(u), u_lightintensity: new i.bM(u), u_lightcolor: new i.bL(u), u_camera_pos: new i.bL(u), u_opacity: new i.bM(u), u_baseColorFactor: new i.ca(u), u_emissiveFactor: new i.ca(u), u_metallicFactor: new i.bM(u), u_roughnessFactor: new i.bM(u), u_baseTextureIsAlpha: new i.bN(u), u_alphaMask: new i.bN(u), u_alphaCutoff: new i.bM(u), u_baseColorTexture: new i.bN(u), u_metallicRoughnessTexture: new i.bN(u), u_normalTexture: new i.bN(u), u_occlusionTexture: new i.bN(u), u_emissionTexture: new i.bN(u), u_lutTexture: new i.bN(u), u_color_mix: new i.ca(u), u_aoIntensity: new i.bM(u), u_emissive_strength: new i.bM(u), u_occlusionTextureTransform: new i.ca(u) }), modelDepth: (u) => ({ u_matrix: new i.bJ(u), u_instance: new i.bJ(u), u_node_matrix: new i.bJ(u) }), groundShadow: (u) => ({ u_matrix: new i.bJ(u), u_ground_shadow_factor: new i.bL(u) }), stars: (u) => ({ u_matrix: new i.bJ(u), u_up: new i.bL(u), u_right: new i.bL(u), u_intensity_multiplier: new i.bM(u) }), snowParticle: (u) => ({ u_modelview: new i.bJ(u), u_projection: new i.bJ(u), u_time: new i.bM(u), u_cam_pos: new i.bL(u), u_velocityConeAperture: new i.bM(u), u_velocity: new i.bM(u), u_horizontalOscillationRadius: new i.bM(u), u_horizontalOscillationRate: new i.bM(u), u_boxSize: new i.bM(u), u_billboardSize: new i.bM(u), u_simpleShapeParameters: new i.bK(u), u_screenSize: new i.bK(u), u_thinningCenterPos: new i.bK(u), u_thinningShape: new i.bL(u), u_thinningAffectedRatio: new i.bM(u), u_thinningParticleOffset: new i.bM(u), u_particleColor: new i.ca(u), u_direction: new i.bL(u) }), rainParticle: (u) => ({ u_modelview: new i.bJ(u), u_projection: new i.bJ(u), u_time: new i.bM(u), u_cam_pos: new i.bL(u), u_texScreen: new i.bN(u), u_velocityConeAperture: new i.bM(u), u_velocity: new i.bM(u), u_boxSize: new i.bM(u), u_rainDropletSize: new i.bK(u), u_distortionStrength: new i.bM(u), u_rainDirection: new i.bL(u), u_color: new i.ca(u), u_screenSize: new i.bK(u), u_thinningCenterPos: new i.bK(u), u_thinningShape: new i.bL(u), u_thinningAffectedRatio: new i.bM(u), u_thinningParticleOffset: new i.bM(u), u_shapeDirectionalPower: new i.bM(u), u_shapeNormalPower: new i.bM(u), u_mode: new i.bM(u) }), vignette: (u) => ({ u_vignetteShape: new i.bL(u), u_vignetteColor: new i.ca(u) }), occlusion: (u) => ({ u_matrix: new i.bJ(u), u_anchorPos: new i.bL(u), u_screenSizePx: new i.bK(u), u_occluderSizePx: new i.bK(u), u_color: new i.ca(u) }) };
        class uo {
          constructor(t, n, c, p) {
            this.id = uo.uniqueIdxCounter, uo.uniqueIdxCounter++, this.context = t;
            const v = t.gl;
            this.buffer = v.createBuffer(), this.dynamicDraw = !!c, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), v.bufferData(v.ELEMENT_ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? v.DYNAMIC_DRAW : v.STATIC_DRAW), this.dynamicDraw || p || n.destroy();
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(t) {
            this.id = uo.uniqueIdxCounter, uo.uniqueIdxCounter++;
            const n = this.context.gl;
            this.context.unbindVAO(), this.bind(), n.bufferSubData(n.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        uo.uniqueIdxCounter = 0;
        const Ls = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class co {
          constructor(t, n, c, p, v, C) {
            this.length = n.length, this.attributes = c, this.itemSize = n.bytesPerElement, this.dynamicDraw = p, this.instanceCount = C, this.context = t;
            const V = t.gl;
            this.buffer = V.createBuffer(), t.bindVertexBuffer.set(this.buffer), V.bufferData(V.ARRAY_BUFFER, n.arrayBuffer, this.dynamicDraw ? V.DYNAMIC_DRAW : V.STATIC_DRAW), this.dynamicDraw || v || n.destroy();
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(t) {
            const n = this.context.gl;
            this.bind(), n.bufferSubData(n.ARRAY_BUFFER, 0, t.arrayBuffer);
          }
          enableAttributes(t, n) {
            for (let c = 0; c < this.attributes.length; c++) {
              const p = n.attributes[this.attributes[c].name];
              p !== void 0 && t.enableVertexAttribArray(p);
            }
          }
          setVertexAttribPointers(t, n, c) {
            for (let p = 0; p < this.attributes.length; p++) {
              const v = this.attributes[p], C = n.attributes[v.name];
              C !== void 0 && t.vertexAttribPointer(C, v.components, t[Ls[v.type]], !1, this.itemSize, v.offset + this.itemSize * (c || 0));
            }
          }
          setVertexAttribDivisor(t, n, c) {
            for (let p = 0; p < this.attributes.length; p++) {
              const v = n.attributes[this.attributes[p].name];
              v !== void 0 && this.instanceCount && this.instanceCount > 0 && t.vertexAttribDivisor(v, c);
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class jc {
          constructor(t, n, c, p, v) {
            this.context = t, this.width = n, this.height = c;
            const C = this.framebuffer = t.gl.createFramebuffer();
            p && (this.colorAttachment = new Nl(t, C)), v && (this.depthAttachmentType = v, this.depthAttachment = v === "renderbuffer" ? new Qh(t, C) : new zf(t, C));
          }
          destroy() {
            const t = this.context.gl;
            if (this.colorAttachment) {
              const n = this.colorAttachment.get();
              n && t.deleteTexture(n);
            }
            if (this.depthAttachment && this.depthAttachmentType) if (this.depthAttachmentType === "renderbuffer") {
              const n = this.depthAttachment.get();
              n && t.deleteRenderbuffer(n);
            } else {
              const n = this.depthAttachment.get();
              n && t.deleteTexture(n);
            }
            t.deleteFramebuffer(this.framebuffer);
          }
        }
        class sf {
          constructor(t, n) {
            this.gl = t, this.clearColor = new ch(this), this.clearDepth = new hh(this), this.clearStencil = new da(this), this.colorMask = new Dc(this), this.depthMask = new zc(this), this.stencilMask = new ic(this), this.stencilFunc = new Lf(this), this.stencilOp = new du(this), this.stencilTest = new _l(this), this.depthRange = new Bc(this), this.depthTest = new is(this), this.depthFunc = new fh(this), this.blend = new dh(this), this.blendFunc = new ph(this), this.blendColor = new mh(this), this.blendEquation = new rc(this), this.cullFace = new pu(this), this.cullFaceSide = new Fc(this), this.frontFace = new Nc(this), this.program = new nc(this), this.activeTexture = new _h(this), this.viewport = new Of(this), this.bindFramebuffer = new mu(this), this.bindRenderbuffer = new _d(this), this.bindTexture = new gd(this), this.bindVertexBuffer = new Jh(this), this.bindElementBuffer = new Fl(this), this.bindVertexArrayOES = new Df(this), this.pixelStoreUnpack = new ac(this), this.pixelStoreUnpackPremultiplyAlpha = new vo(this), this.pixelStoreUnpackFlipY = new _u(this), this.options = n ? Object.assign({}, n) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = t.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = t.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = t.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = n && !!n.forceManualRenderingForInstanceIDShaders || this.renderer && this.renderer.indexOf("PowerVR") !== -1, this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = t.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.maxPointSize = t.getParameter(t.ALIASED_POINT_SIZE_RANGE)[1];
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(t, n, c) {
            return new uo(this, t, n, c);
          }
          createVertexBuffer(t, n, c, p, v) {
            return new co(this, t, n, c, p, v);
          }
          createRenderbuffer(t, n, c) {
            const p = this.gl, v = p.createRenderbuffer();
            return this.bindRenderbuffer.set(v), p.renderbufferStorage(p.RENDERBUFFER, t, n, c), this.bindRenderbuffer.set(null), v;
          }
          createFramebuffer(t, n, c, p) {
            return new jc(this, t, n, c, p);
          }
          clear({ color: t, depth: n, stencil: c, colorMask: p }) {
            const v = this.gl;
            let C = 0;
            t && (C |= v.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set(p || [!0, !0, !0, !0])), n !== void 0 && (C |= v.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(n), this.depthMask.set(!0)), c !== void 0 && (C |= v.STENCIL_BUFFER_BIT, this.clearStencil.set(c), this.stencilMask.set(255)), v.clear(C);
          }
          setCullFace(t) {
            t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));
          }
          setDepthMode(t) {
            t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);
          }
          setStencilMode(t) {
            t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(t) {
            i.bn(t.blendFunction, zr.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor), t.blendEquation ? this.blendEquation.set(t.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t.mask);
          }
          unbindVAO() {
            this.bindVertexArrayOES.set(null);
          }
        }
        let Yo;
        function Eu(u, t, n, c, p, v, C) {
          const V = u.context, K = V.gl, se = u.transform, oe = u.getOrCreateProgram("collisionBox"), ve = [];
          let xe = 0, Le = 0;
          for (let jt = 0; jt < c.length; jt++) {
            const ii = c[jt], Xt = t.getTile(ii), Kt = Xt.getBucket(n);
            if (!Kt) continue;
            const Zt = Gs(ii, Kt, se);
            let Jt = Zt;
            p[0] === 0 && p[1] === 0 || (Jt = u.translatePosMatrix(Zt, Xt, p, v));
            const ui = C ? Kt.textCollisionBox : Kt.iconCollisionBox, Ti = Kt.collisionCircleArray;
            if (Ti.length > 0) {
              const xi = i.ab.mat4.create(), Pi = Jt;
              i.ab.mat4.mul(xi, Kt.placementInvProjMatrix, se.glCoordMatrix), i.ab.mat4.mul(xi, xi, Kt.placementViewportMatrix), ve.push({ circleArray: Ti, circleOffset: Le, transform: Pi, invTransform: xi, projection: Kt.getProjection() }), xe += Ti.length / 4, Le = xe;
            }
            ui && (u.terrain && u.terrain.setupElevationDraw(Xt, oe), oe.draw(u, K.LINES, Sr.disabled, Lr.disabled, u.colorModeForRenderPass(), kr.disabled, vh(Jt, se, Xt, Kt.getProjection()), n.id, ui.layoutVertexBuffer, ui.indexBuffer, ui.segments, null, se.zoom, null, [ui.collisionVertexBuffer, ui.collisionVertexBufferExt]));
          }
          if (!C || !ve.length) return;
          const ft = u.getOrCreateProgram("collisionCircle"), st = new i.cV();
          st.resize(4 * xe), st._trim();
          let vt = 0;
          for (const jt of ve) for (let ii = 0; ii < jt.circleArray.length / 4; ii++) {
            const Xt = 4 * ii, Kt = jt.circleArray[Xt + 0], Zt = jt.circleArray[Xt + 1], Jt = jt.circleArray[Xt + 2], ui = jt.circleArray[Xt + 3];
            st.emplace(vt++, Kt, Zt, Jt, ui, 0), st.emplace(vt++, Kt, Zt, Jt, ui, 1), st.emplace(vt++, Kt, Zt, Jt, ui, 2), st.emplace(vt++, Kt, Zt, Jt, ui, 3);
          }
          (!Yo || Yo.length < 2 * xe) && (Yo = function(jt) {
            const ii = 2 * jt, Xt = new i.aU();
            Xt.resize(ii), Xt._trim();
            for (let Kt = 0; Kt < ii; Kt++) {
              const Zt = 6 * Kt;
              Xt.uint16[Zt + 0] = 4 * Kt + 0, Xt.uint16[Zt + 1] = 4 * Kt + 1, Xt.uint16[Zt + 2] = 4 * Kt + 2, Xt.uint16[Zt + 3] = 4 * Kt + 2, Xt.uint16[Zt + 4] = 4 * Kt + 3, Xt.uint16[Zt + 5] = 4 * Kt + 0;
            }
            return Xt;
          }(xe));
          const gt = V.createIndexBuffer(Yo, !0), Rt = V.createVertexBuffer(st, i.cW.members, !0);
          for (const jt of ve) {
            const ii = { u_matrix: jt.transform, u_inv_matrix: jt.invTransform, u_camera_to_center_distance: (qt = se).getCameraToCenterDistance(jt.projection), u_viewport_size: [qt.width, qt.height] };
            ft.draw(u, K.TRIANGLES, Sr.disabled, Lr.disabled, u.colorModeForRenderPass(), kr.disabled, ii, n.id, Rt, gt, i.b7.simpleSegment(0, 2 * jt.circleOffset, jt.circleArray.length, jt.circleArray.length / 2), null, se.zoom);
          }
          var qt;
          Rt.destroy(), gt.destroy();
        }
        const lc = i.ab.mat4.create();
        function Zs(u) {
          const t = u._camera.getWorldToCamera(u.worldSize, 1), n = i.ab.mat4.multiply([], t, u.globeMatrix);
          i.ab.mat4.invert(n, n);
          const c = [0, 0, 0], p = [0, 1, 0, 0];
          return i.ab.vec4.transformMat4(p, p, n), c[0] = p[0], c[1] = p[1], c[2] = p[2], i.ab.vec3.normalize(c, c), c;
        }
        function Tn({ width: u, height: t, anchor: n, textOffset: c, textScale: p }, v) {
          const { horizontalAlign: C, verticalAlign: V } = i.bD(n), K = -(C - 0.5) * u, se = -(V - 0.5) * t, oe = i.bC(n, c);
          return new i.P((K / p + oe[0]) * v, (se / p + oe[1]) * v);
        }
        function Gc(u, t, n, c, p, v, C, V, K, se, oe) {
          const ve = u.text.placedSymbolArray, xe = u.text.dynamicLayoutVertexArray, Le = u.icon.dynamicLayoutVertexArray, ft = {}, st = u.getProjection(), vt = aa(V, st, v), gt = v.elevation, Rt = st.upVectorScale(V.canonical, v.center.lat, v.worldSize).metersToTile;
          xe.clear();
          for (let qt = 0; qt < ve.length; qt++) {
            const jt = ve.get(qt), { tileAnchorX: ii, tileAnchorY: Xt, numGlyphs: Kt } = jt, Zt = jt.hidden || !jt.crossTileID || u.allowVerticalPlacement && !jt.placedOrientation ? null : c[jt.crossTileID];
            if (Zt) {
              let Jt = 0, ui = 0, Ti = 0;
              if (gt) {
                const Mi = gt ? gt.getAtTileOffset(V, ii, Xt) : 0, [Yi, Ui, Fi] = st.upVector(V.canonical, ii, Xt);
                Jt = Mi * Yi * Rt, ui = Mi * Ui * Rt, Ti = Mi * Fi * Rt;
              }
              let [xi, Pi, Ri, mi] = va(jt.projectedAnchorX + Jt, jt.projectedAnchorY + ui, jt.projectedAnchorZ + Ti, n ? vt : C);
              const Ai = sl(v.getCameraToCenterDistance(st), mi);
              let ji = p.evaluateSizeForFeature(u.textSizeData, se, jt) * Ai / i.bw;
              n && (ji *= u.tilePixelRatio / K);
              const yi = Tn(Zt, ji);
              n ? ({ x: xi, y: Pi, z: Ri } = st.projectTilePoint(ii + yi.x, Xt + yi.y, V.canonical), [xi, Pi, Ri] = va(xi + Jt, Pi + ui, Ri + Ti, C)) : (t && yi._rotate(-v.angle), xi += yi.x, Pi += yi.y, Ri = 0);
              const Ni = u.allowVerticalPlacement && jt.placedOrientation === i.bq.vertical ? Math.PI / 2 : 0;
              for (let Mi = 0; Mi < Kt; Mi++) i.bt(xe, xi, Pi, Ri, Ni);
              oe && jt.associatedIconIndex >= 0 && (ft[jt.associatedIconIndex] = { x: xi, y: Pi, z: Ri, angle: Ni });
            } else Nn(Kt, xe);
          }
          if (oe) {
            Le.clear();
            const qt = u.icon.placedSymbolArray;
            for (let jt = 0; jt < qt.length; jt++) {
              const ii = qt.get(jt), { numGlyphs: Xt } = ii, Kt = ft[jt];
              if (ii.hidden || !Kt) Nn(Xt, Le);
              else {
                const { x: Zt, y: Jt, z: ui, angle: Ti } = Kt;
                for (let xi = 0; xi < Xt; xi++) i.bt(Le, Zt, Jt, ui, Ti);
              }
            }
            u.icon.dynamicLayoutVertexBuffer.updateData(Le);
          }
          u.text.dynamicLayoutVertexBuffer.updateData(xe);
        }
        function jl(u, t, n, c, p, v, C = {}) {
          const V = n.paint.get("icon-translate"), K = n.paint.get("text-translate"), se = n.paint.get("icon-translate-anchor"), oe = n.paint.get("text-translate-anchor"), ve = n.layout.get("icon-rotation-alignment"), xe = n.layout.get("text-rotation-alignment"), Le = n.layout.get("icon-pitch-alignment"), ft = n.layout.get("text-pitch-alignment"), st = n.layout.get("icon-keep-upright"), vt = n.layout.get("text-keep-upright"), gt = n.paint.get("icon-color-saturation"), Rt = n.paint.get("icon-color-contrast"), qt = n.paint.get("icon-color-brightness-min"), jt = n.paint.get("icon-color-brightness-max"), ii = n.layout.get("symbol-elevation-reference") === "sea", Xt = u.context, Kt = Xt.gl, Zt = u.transform, Jt = ve === "map", ui = xe === "map", Ti = Le === "map", xi = ft === "map", Pi = n.layout.get("symbol-sort-key").constantOr(1) !== void 0;
          let Ri = !1;
          const mi = u.depthModeForSublayer(0, Sr.ReadOnly), Ai = [i.at(Zt.center.lng), i.aA(Zt.center.lat)], ji = n.layout.get("text-variable-anchor"), yi = Zt.projection.name === "globe", Ni = [], Mi = [0, -1, 0];
          for (const Yi of c) {
            const Ui = t.getTile(Yi), Fi = Ui.getBucket(n);
            if (!Fi || Fi.projection.name === "mercator" && yi || Fi.fullyClipped) continue;
            const Zi = Fi.projection.name === "globe", ir = Zi ? i.ae(Zt.zoom) : 0, cr = aa(Yi, Fi.getProjection(), Zt), fr = Zt.calculatePixelsToTileUnitsMatrix(Ui), Or = ji && Fi.hasTextData(), Er = Fi.hasIconTextFit() && Or && Fi.hasIconData(), Ar = Fi.getProjection().createInversionMatrix(Zt, Yi.canonical), Fr = (pn) => {
              Zt.depthOcclusionForSymbolsAndCircles && (n.hasInitialOcclusionOpacityProperties || u.terrain) && (pn.push("DEPTH_D24"), pn.push("DEPTH_OCCLUSION"));
            }, an = () => {
              const pn = Jt && n.layout.get("symbol-placement") !== "point", gn = [];
              Fr(gn);
              const na = pn || Er, ua = n.paint.get("icon-image-cross-fade").constantOr(0);
              u.terrainRenderModeElevated() && Ti && gn.push("PITCH_WITH_MAP_TERRAIN"), Zi && (gn.push("PROJECTION_GLOBE_VIEW"), na && gn.push("PROJECTED_POS_ON_VIEWPORT")), ua > 0 && gn.push("ICON_TRANSITION"), Fi.icon.zOffsetVertexBuffer && gn.push("Z_OFFSET"), gt === 0 && Rt === 0 && qt === 0 && jt === 1 || gn.push("COLOR_ADJUSTMENT"), Fi.sdfIcons && gn.push("RENDER_SDF");
              const Ra = Fi.icon.programConfigurations.get(n.id), Aa = u.getOrCreateProgram("symbol", { config: Ra, defines: gn }), ns = Ui.imageAtlasTexture ? Ui.imageAtlasTexture.size : [0, 0], as = Fi.iconSizeData, On = i.bp(as, Zt.zoom), Rn = Ti || Zt.pitch !== 0, Cn = Hn(cr, Ui.tileID.canonical, Ti, Jt, Zt, Fi.getProjection(), fr), ln = xs(cr, Ui.tileID.canonical, Ti, Jt, Zt, Fi.getProjection(), fr), ca = u.translatePosMatrix(ln, Ui, V, se, !0), Ha = u.translatePosMatrix(cr, Ui, V, se), kn = na ? lc : Cn, fs = Jt && !Ti && !pn;
              let fo = Mi;
              !yi && !Zt.mercatorFromTransition || Jt || (fo = Zs(Zt));
              const Ka = Zi ? fo : Mi, Bs = n.getColorAdjustmentMatrix(gt, Rt, qt, jt), Fs = Sa(as.kind, On, fs, Ti, u, Ha, kn, ca, ii, !1, ns, [0, 0], !0, Yi, ir, Ai, Ar, Ka, Fi.getProjection(), Bs, ua), po = Ui.imageAtlasTexture ? Ui.imageAtlasTexture : null, Bn = n.layout.get("icon-size").constantOr(0) !== 1 || Fi.iconsNeedLinear, Bu = Fi.sdfIcons || u.options.rotating || u.options.zooming || Bn || Rn ? Kt.LINEAR : Kt.NEAREST, Oo = Fi.sdfIcons && n.paint.get("icon-halo-width").constantOr(1) !== 0, Fu = u.terrain && Ti && pn ? i.ab.mat4.invert(i.ab.mat4.create(), Cn) : lc;
              if (pn && Fi.icon) {
                const Sc = Zt.elevation, rh = Sc ? Sc.getAtTileOffsetFunc(Yi, Zt.center.lat, Zt.worldSize, Fi.getProjection()) : null, Bh = Dn(cr, Ui.tileID.canonical, Ti, Jt, Zt, Fi.getProjection(), fr);
                No(Fi, cr, u, !1, Bh, ln, Ti, st, rh, Yi);
              }
              return { program: Aa, buffers: Fi.icon, uniformValues: Fs, atlasTexture: po, atlasTextureIcon: null, atlasInterpolation: Bu, atlasInterpolationIcon: null, isSDF: Fi.sdfIcons, hasHalo: Oo, tile: Ui, labelPlaneMatrixInv: Fu };
            }, yn = () => {
              const pn = ui && n.layout.get("symbol-placement") !== "point", gn = [], na = pn || ji || Er;
              u.terrainRenderModeElevated() && xi && gn.push("PITCH_WITH_MAP_TERRAIN"), Zi && (gn.push("PROJECTION_GLOBE_VIEW"), na && gn.push("PROJECTED_POS_ON_VIEWPORT")), Fi.text.zOffsetVertexBuffer && gn.push("Z_OFFSET"), Fi.iconsInText && gn.push("RENDER_TEXT_AND_SYMBOL"), gn.push("RENDER_SDF"), Fr(gn);
              const ua = Fi.text.programConfigurations.get(n.id), Ra = u.getOrCreateProgram("symbol", { config: ua, defines: gn });
              let Aa, ns = [0, 0], as = null;
              const On = Fi.textSizeData;
              Fi.iconsInText && (ns = Ui.imageAtlasTexture ? Ui.imageAtlasTexture.size : [0, 0], as = Ui.imageAtlasTexture ? Ui.imageAtlasTexture : null, Aa = xi || Zt.pitch !== 0 || u.options.rotating || u.options.zooming || On.kind === "composite" || On.kind === "camera" ? Kt.LINEAR : Kt.NEAREST);
              const Rn = Ui.glyphAtlasTexture ? Ui.glyphAtlasTexture.size : [0, 0], Cn = n.layout.get("text-size-scale-range"), ln = i.aw(u.scaleFactor, Cn[0], Cn[1]), ca = i.bp(On, Zt.zoom, ln), Ha = Hn(cr, Ui.tileID.canonical, xi, ui, Zt, Fi.getProjection(), fr), kn = xs(cr, Ui.tileID.canonical, xi, ui, Zt, Fi.getProjection(), fr), fs = u.translatePosMatrix(kn, Ui, K, oe, !0), fo = u.translatePosMatrix(cr, Ui, K, oe), Ka = na ? lc : Ha, Bs = ui && !xi && !pn;
              let Fs = Mi;
              !yi && !Zt.mercatorFromTransition || ui || (Fs = Zs(Zt));
              const po = Sa(On.kind, ca, Bs, xi, u, fo, Ka, fs, ii, !0, Rn, ns, !0, Yi, ir, Ai, Ar, Zi ? Fs : Mi, Fi.getProjection(), null, null, ln), Bn = Ui.glyphAtlasTexture ? Ui.glyphAtlasTexture : null, Bu = Kt.LINEAR, Oo = n.paint.get("text-halo-width").constantOr(1) !== 0, Fu = u.terrain && xi && pn ? i.ab.mat4.invert(i.ab.mat4.create(), Ha) : lc;
              if (pn && Fi.text) {
                const Sc = Zt.elevation, rh = Sc ? Sc.getAtTileOffsetFunc(Yi, Zt.center.lat, Zt.worldSize, Fi.getProjection()) : null, Bh = Dn(cr, Ui.tileID.canonical, xi, ui, Zt, Fi.getProjection(), fr);
                No(Fi, cr, u, !0, Bh, kn, xi, vt, rh, Yi);
              }
              return { program: Ra, buffers: Fi.text, uniformValues: po, atlasTexture: Bn, atlasTextureIcon: as, atlasInterpolation: Bu, atlasInterpolationIcon: Aa, isSDF: !0, hasHalo: Oo, tile: Ui, labelPlaneMatrixInv: Fu };
            }, $n = Fi.icon.segments.get().length, fn = Fi.text.segments.get().length, Nr = $n && !C.onlyText ? an() : null, Jr = fn && !C.onlyIcons ? yn() : null, mr = n.paint.get("icon-opacity").constantOr(1), nn = n.paint.get("text-opacity").constantOr(1);
            if (Pi && Fi.canOverlap) {
              Ri = !0;
              const pn = mr && !C.onlyText ? Fi.icon.segments.get() : [], gn = nn && !C.onlyIcons ? Fi.text.segments.get() : [];
              for (const na of pn) Ni.push({ segments: new i.b7([na]), sortKey: na.sortKey, state: Nr });
              for (const na of gn) Ni.push({ segments: new i.b7([na]), sortKey: na.sortKey, state: Jr });
            } else C.onlyText || Ni.push({ segments: mr ? Fi.icon.segments : new i.b7([]), sortKey: 0, state: Nr }), C.onlyIcons || Ni.push({ segments: nn ? Fi.text.segments : new i.b7([]), sortKey: 0, state: Jr });
          }
          Ri && Ni.sort((Yi, Ui) => Yi.sortKey - Ui.sortKey);
          for (const Yi of Ni) {
            const Ui = Yi.state;
            if (Ui) if (u.terrain ? u.terrain.setupElevationDraw(Ui.tile, Ui.program, { useDepthForOcclusion: Zt.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: Ui.labelPlaneMatrixInv }) : u.setupDepthForOcclusion(Zt.depthOcclusionForSymbolsAndCircles, Ui.program), Xt.activeTexture.set(Kt.TEXTURE0), Ui.atlasTexture && Ui.atlasTexture.bind(Ui.atlasInterpolation, Kt.CLAMP_TO_EDGE, !0), Ui.atlasTextureIcon && (Xt.activeTexture.set(Kt.TEXTURE1), Ui.atlasTextureIcon && Ui.atlasTextureIcon.bind(Ui.atlasInterpolationIcon, Kt.CLAMP_TO_EDGE, !0)), u.uploadCommonLightUniforms(u.context, Ui.program), Ui.hasHalo) {
              const Fi = Ui.uniformValues;
              Fi.u_is_halo = 1, Tu(Ui.buffers, Yi.segments, n, u, Ui.program, mi, p, v, Fi, 2), Fi.u_is_halo = 0;
            } else {
              if (Ui.isSDF) {
                const Fi = Ui.uniformValues;
                Ui.hasHalo && (Fi.u_is_halo = 1, Tu(Ui.buffers, Yi.segments, n, u, Ui.program, mi, p, v, Fi, 1)), Fi.u_is_halo = 0;
              }
              Tu(Ui.buffers, Yi.segments, n, u, Ui.program, mi, p, v, Ui.uniformValues, 1);
            }
          }
        }
        function Tu(u, t, n, c, p, v, C, V, K, se) {
          const oe = [u.dynamicLayoutVertexBuffer, u.opacityVertexBuffer, u.iconTransitioningVertexBuffer, u.globeExtVertexBuffer, u.zOffsetVertexBuffer];
          p.draw(c, c.context.gl.TRIANGLES, v, C, V, kr.disabled, K, n.id, u.layoutVertexBuffer, u.indexBuffer, t, n.paint, c.transform.zoom, u.programConfigurations.get(n.id), oe, se);
        }
        function Gl(u, t, n, c, p, v, C) {
          const V = u.context.gl, K = n.paint.get("fill-pattern"), se = n.is3D(), oe = se ? u.stencilModeFor3D() : Lr.disabled, ve = K && K.constantOr(1);
          let xe, Le, ft, st, vt;
          C ? (Le = ve && !n.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", xe = V.LINES) : (Le = ve ? "fillPattern" : "fill", xe = V.TRIANGLES);
          for (const gt of c) {
            const Rt = t.getTile(gt);
            if (ve && !Rt.patternsLoaded()) continue;
            const qt = Rt.getBucket(n);
            if (!qt) continue;
            u.prepareDrawTile();
            const jt = qt.programConfigurations.get(n.id), ii = u.isTileAffectedByFog(gt), Xt = u.getOrCreateProgram(Le, { config: jt, overrideFog: ii });
            ve && (u.context.activeTexture.set(V.TEXTURE0), Rt.imageAtlasTexture && Rt.imageAtlasTexture.bind(V.LINEAR, V.CLAMP_TO_EDGE), jt.updatePaintBuffers());
            const Kt = K.constantOr(null);
            if (Kt && Rt.imageAtlas) {
              const ui = Rt.imageAtlas, Ti = i.A.from(Kt).getPrimary().scaleSelf(i.q.devicePixelRatio).serialize(), xi = ui.patternPositions[Ti];
              xi && jt.setConstantPatternPositions(xi);
            }
            const Zt = u.translatePosMatrix(gt.projMatrix, Rt, n.paint.get("fill-translate"), n.paint.get("fill-translate-anchor")), Jt = n.paint.get("fill-emissive-strength");
            if (C) {
              st = qt.indexBuffer2, vt = qt.segments2;
              const ui = u.terrain && u.terrain.renderingToTexture ? u.terrain.drapeBufferSize : [V.drawingBufferWidth, V.drawingBufferHeight];
              ft = Le === "fillOutlinePattern" && ve ? wu(Zt, Jt, u, Rt, ui) : Vl(Zt, Jt, ui);
            } else st = qt.indexBuffer, vt = qt.segments, ft = ve ? wo(Zt, Jt, u, Rt) : Uc(Zt, Jt);
            u.uploadCommonUniforms(u.context, Xt, gt.toUnwrapped()), Xt.draw(u, xe, p, se ? oe : u.stencilModeForClipping(gt), v, kr.disabled, ft, n.id, qt.layoutVertexBuffer, st, vt, n.paint, u.transform.zoom, jt, void 0);
          }
        }
        function Cu(u, t, n, c, p, v, C, V) {
          n.resetLayerRenderingStats(u);
          const K = u.context, se = K.gl, oe = u.transform, ve = n.paint.get("fill-extrusion-pattern"), xe = ve.constantOr(1), Le = n.paint.get("fill-extrusion-opacity"), ft = u.style.enable3dLights(), st = n.paint.get(ft && !xe ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), vt = [n.paint.get("fill-extrusion-ambient-occlusion-intensity"), st], gt = n.layout.get("fill-extrusion-edge-radius"), Rt = gt > 0 && !n.paint.get("fill-extrusion-rounded-roof"), qt = Rt ? 0 : gt, jt = oe.projection.name === "globe" ? i.d3() : 0, ii = oe.projection.name === "globe", Xt = ii ? i.ae(oe.zoom) : 0, Kt = [i.at(oe.center.lng), i.aA(oe.center.lat)], Zt = n.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none", Jt = n.paint.get("fill-extrusion-flood-light-color").toRenderColor(Zt ? null : n.lut).toArray01().slice(0, 3), ui = n.paint.get("fill-extrusion-flood-light-intensity"), Ti = n.paint.get("fill-extrusion-vertical-scale"), xi = n.paint.get("fill-extrusion-line-width").constantOr(1) !== 0, Pi = n.paint.get("fill-extrusion-height-alignment"), Ri = n.paint.get("fill-extrusion-base-alignment"), mi = Ps(u, n.paint.get("fill-extrusion-cutoff-fade-range")), Ai = [];
          let ji;
          ii && Ai.push("PROJECTION_GLOBE_VIEW"), vt[0] > 0 && Ai.push("FAUX_AO"), Rt && Ai.push("ZERO_ROOF_RADIUS"), V && Ai.push("HAS_CENTROID"), ui > 0 && Ai.push("FLOOD_LIGHT"), mi.shouldRenderCutoff && Ai.push("RENDER_CUTOFF"), xi && Ai.push("RENDER_WALL_MODE");
          const yi = u.renderPass === "shadow", Ni = u.shadowRenderer, Mi = yi && !!Ni;
          u.shadowRenderer && (u.shadowRenderer.useNormalOffset = !0);
          let Yi = [0, 0, 0];
          if (Ni) {
            const Zi = u.style.directionalLight, ir = u.style.ambientLight;
            Zi && ir && (Yi = pl(u.style, Zi, ir)), yi || (Ai.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), Ni.useNormalOffset && Ai.push("NORMAL_OFFSET")), ji = Ai.concat(["SHADOWS_SINGLE_CASCADE"]);
          }
          const Ui = Mi ? "fillExtrusionDepth" : xe ? "fillExtrusionPattern" : "fillExtrusion", Fi = n.getLayerRenderingStats();
          for (const Zi of c) {
            const ir = t.getTile(Zi), cr = ir.getBucket(n);
            if (!cr || cr.projection.name !== oe.projection.name) continue;
            let fr = !1;
            Ni && (fr = Ni.getMaxCascadeForTile(Zi.toUnwrapped()) === 0);
            const Or = u.isTileAffectedByFog(Zi), Er = cr.programConfigurations.get(n.id), Ar = u.getOrCreateProgram(Ui, { config: Er, defines: fr ? ji : Ai, overrideFog: Or });
            if (u.terrain && u.terrain.setupElevationDraw(ir, Ar, { useMeterToDem: !0 }), !cr.centroidVertexBuffer) {
              const Jr = Ar.attributes.a_centroid_pos;
              Jr !== void 0 && se.vertexAttrib2f(Jr, 0, 0);
            }
            !yi && Ni && Ni.setupShadows(ir.tileID.toUnwrapped(), Ar, "vector-tile", ir.tileID.overscaledZ), xe && (u.context.activeTexture.set(se.TEXTURE0), ir.imageAtlasTexture && ir.imageAtlasTexture.bind(se.LINEAR, se.CLAMP_TO_EDGE), Er.updatePaintBuffers());
            const Fr = ve.constantOr(null);
            if (Fr && ir.imageAtlas) {
              const Jr = ir.imageAtlas, mr = i.A.from(Fr).getPrimary().scaleSelf(i.q.devicePixelRatio), nn = Jr.patternPositions[mr.serialize()];
              nn && Er.setConstantPatternPositions(nn);
            }
            const an = n.paint.get("fill-extrusion-vertical-gradient"), yn = 1 / cr.tileToMeter;
            let $n;
            if (yi && Ni) {
              if (So(ir.tileID, cr, u)) continue;
              const Jr = Ni.calculateShadowPassMatrixFromTile(ir.tileID.toUnwrapped());
              $n = bu(Jr, qt, yn, Ti, Pi, Ri);
            } else {
              const Jr = u.translatePosMatrix(Zi.expandedProjMatrix, ir, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor")), mr = oe.projection.createInversionMatrix(oe, Zi.canonical);
              $n = xe ? rf(Jr, u, an, Le, vt, qt, yn, Zi, ir, jt, Pi, Ri, Xt, Kt, mr, Jt, Ti) : xu(Jr, u, an, Le, vt, qt, yn, Zi, jt, Pi, Ri, Xt, Kt, mr, Jt, Ti, ui, Yi);
            }
            u.uploadCommonUniforms(K, Ar, Zi.toUnwrapped(), null, mi);
            let fn = cr.segments;
            if (oe.projection.name === "mercator" && !yi && (fn = cr.getVisibleSegments(ir.tileID, u.terrain, u.transform.getFrustum(0)), !fn.get().length)) continue;
            if (Fi) if (yi) for (const Jr of fn.get()) Fi.numRenderedVerticesInShadowPass += Jr.primitiveLength;
            else for (const Jr of fn.get()) Fi.numRenderedVerticesInTransparentPass += Jr.primitiveLength;
            const Nr = [];
            (u.terrain || V) && Nr.push(cr.centroidVertexBuffer), ii && Nr.push(cr.layoutVertexExtBuffer), xi && Nr.push(cr.wallVertexBuffer), Ar.draw(u, K.gl.TRIANGLES, p, v, C, kr.backCCW, $n, n.id, cr.layoutVertexBuffer, cr.indexBuffer, fn, n.paint, u.transform.zoom, Er, Nr);
          }
          u.shadowRenderer && (u.shadowRenderer.useNormalOffset = !1);
        }
        function Hl(u, t, n, c, p, v, C, V, K, se, oe, ve, xe, Le, ft, st, vt, gt, Rt) {
          const qt = u.context, jt = qt.gl, ii = u.transform, Xt = u.transform.zoom, Kt = [], Zt = Ps(u, n.paint.get("fill-extrusion-cutoff-fade-range"));
          se === "clear" ? (Kt.push("CLEAR_SUBPASS"), Rt && (Kt.push("CLEAR_FROM_TEXTURE"), qt.activeTexture.set(jt.TEXTURE0), Rt.bind(jt.LINEAR, jt.CLAMP_TO_EDGE))) : se === "sdf" && Kt.push("SDF_SUBPASS"), vt && Kt.push("HAS_CENTROID"), Zt.shouldRenderCutoff && Kt.push("RENDER_CUTOFF");
          const Jt = n.layout.get("fill-extrusion-edge-radius"), ui = (Ti, xi, Pi, Ri, mi) => {
            const Ai = xi.programConfigurations.get(n.id), ji = u.isTileAffectedByFog(Ti), yi = u.getOrCreateProgram("fillExtrusionGroundEffect", { config: Ai, defines: Kt, overrideFog: ji }), Ni = /* @__PURE__ */ ((Yi, Ui, Fi, Zi, ir, cr, fr, Or, Er, Ar, Fr) => ({ u_matrix: Ui, u_opacity: Fi, u_ao_pass: Zi ? 1 : 0, u_meter_to_tile: ir, u_ao: cr, u_flood_light_intensity: fr, u_flood_light_color: Or, u_attenuation: Er, u_edge_radius: Ar, u_fb: 0, u_fb_size: Fr, u_dynamic_offset: 1 }))(0, Ri, oe, K, mi, [ve, xe * mi], Le, ft, st, Xt >= 17 ? 0 : Jt * mi, Rt ? Rt.size[0] : 0), Mi = [];
            vt && Mi.push(xi.hiddenByLandmarkVertexBuffer), u.uploadCommonUniforms(qt, yi, Ti.toUnwrapped(), null, Zt), yi.draw(u, qt.gl.TRIANGLES, p, v, C, V, Ni, n.id, xi.vertexBuffer, xi.indexBuffer, Pi, n.paint, Xt, Ai, Mi);
          };
          for (const Ti of c) {
            const xi = t.getTile(Ti), Pi = xi.getBucket(n);
            if (!Pi || Pi.projection.name !== ii.projection.name || !Pi.groundEffect || Pi.groundEffect && !Pi.groundEffect.hasData()) continue;
            const Ri = Pi.groundEffect, mi = 1 / Pi.tileToMeter;
            {
              const Ai = u.translatePosMatrix(Ti.projMatrix, xi, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor")), ji = Ri.getDefaultSegment();
              ui(Ti, Ri, ji, Ai, mi);
            }
            if (gt) for (let Ai = 0; Ai < 4; Ai++) {
              const ji = i.d4[Ai](Ti), yi = t.getTile(ji);
              if (!yi) continue;
              const Ni = yi.getBucket(n);
              if (!Ni || Ni.projection.name !== ii.projection.name || !Ni.groundEffect || Ni.groundEffect && !Ni.groundEffect.hasData()) continue;
              const Mi = Ni.groundEffect;
              let Yi, Ui;
              Ai === 0 ? (Yi = [-i.ag, 0, 0], Ui = 1) : Ai === 1 ? (Yi = [i.ag, 0, 0], Ui = 0) : Ai === 2 ? (Yi = [0, -i.ag, 0], Ui = 3) : (Yi = [0, i.ag, 0], Ui = 2);
              const Fi = Mi.regionSegments[Ui];
              if (!Fi) continue;
              const Zi = new Float32Array(16);
              i.ab.mat4.translate(Zi, Ti.projMatrix, Yi), ui(Ti, Mi, Fi, u.translatePosMatrix(Zi, xi, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor")), mi);
            }
          }
        }
        function ql(u, t, n, c, p, v, C) {
          c.centroidVertexArray.length === 0 && c.createCentroidsBuffer();
          const V = v ? v.findDEMTileFor(n) : null;
          if (!(V && V.dem || C)) return;
          v && V && V.dem && c.selfDEMTileTimestamp !== V.dem._timestamp && (c.borderDoneWithNeighborZ = [-1, -1, -1, -1], c.selfDEMTileTimestamp = V.dem._timestamp);
          const K = (gt) => new i.P(Math.ceil((gt + i.d7) * i.d8), 0), se = (gt) => {
            const Rt = t.getSource().minzoom, qt = (ii) => {
              const Xt = t.getTileByID(ii);
              if (Xt && Xt.hasData()) return Xt.getBucket(p);
            }, jt = [0, -1, 1];
            for (const ii of jt) {
              if (gt.overscaledZ + ii < Rt) continue;
              const Xt = qt(gt.calculateScaledKey(gt.overscaledZ + ii));
              if (Xt) return Xt;
            }
          }, oe = [0, 0, 0], ve = (gt, Rt) => (oe[0] = Math.min(gt.min.y, Rt.min.y), oe[1] = Math.max(gt.max.y, Rt.max.y), oe[2] = i.ag - Rt.min.x > gt.max.x ? Rt.min.x - i.ag : gt.max.x, oe), xe = (gt, Rt) => (oe[0] = Math.min(gt.min.x, Rt.min.x), oe[1] = Math.max(gt.max.x, Rt.max.x), oe[2] = i.ag - Rt.min.y > gt.max.y ? Rt.min.y - i.ag : gt.max.y, oe), Le = [(gt, Rt) => ve(gt, Rt), (gt, Rt) => ve(Rt, gt), (gt, Rt) => xe(gt, Rt), (gt, Rt) => xe(Rt, gt)], ft = (gt, Rt, qt, jt, ii, Xt, Kt) => {
            if (!v) return 0;
            const Zt = [[Xt ? qt : gt, Xt ? gt : qt, 0], [Xt ? qt : Rt, Xt ? Rt : qt, 0]], Jt = Kt < 0 ? i.ag + Kt : Kt, ui = [Xt ? Jt : (gt + Rt) / 2, Xt ? (gt + Rt) / 2 : Jt, 0];
            return qt === 0 && Kt < 0 || qt !== 0 && Kt > 0 ? v.getForTilePoints(ii, [ui], !0, jt) : Zt.push(ui), v.getForTilePoints(n, Zt, !0, V), Math.max(Zt[0][2], Zt[1][2], ui[2]) / v.exaggeration();
          };
          for (let gt = 0; gt < 4; gt++) {
            const Rt = c.borderFeatureIndices[gt];
            if (Rt.length === 0) continue;
            const qt = i.d4[gt](n), jt = se(qt);
            if (!(jt && jt instanceof i.d5)) continue;
            const ii = v ? v.findDEMTileFor(qt) : null;
            if (!(ii && ii.dem || C) || (v && ii && ii.dem && c.borderDEMTileTimestamp[gt] !== ii.dem._timestamp && (c.borderDoneWithNeighborZ[gt] = -1, c.borderDEMTileTimestamp[gt] = ii.dem._timestamp), c.borderDoneWithNeighborZ[gt] === jt.canonical.z)) continue;
            jt.centroidVertexArray.length === 0 && jt.createCentroidsBuffer();
            const Xt = (gt < 2 ? 1 : 5) - gt, Kt = jt.borderDoneWithNeighborZ[Xt] !== c.canonical.z, Zt = jt.borderFeatureIndices[Xt];
            let Jt = 0;
            if (c.canonical.z !== jt.canonical.z) {
              for (const ui of Rt) c.showCentroid(c.featuresOnBorder[ui]);
              if (Kt) for (const ui of Zt) jt.showCentroid(jt.featuresOnBorder[ui]);
              c.borderDoneWithNeighborZ[gt] = jt.canonical.z, jt.borderDoneWithNeighborZ[Xt] = c.canonical.z;
            }
            for (const ui of Rt) {
              const Ti = c.featuresOnBorder[ui], xi = c.centroidData[Ti.centroidDataIndex], Pi = Ti.borders[gt];
              let Ri;
              for (; Jt < Zt.length; ) {
                Ri = jt.featuresOnBorder[Zt[Jt]];
                const mi = Ri.borders[Xt];
                if (mi[1] > Pi[0] + 3 || mi[0] > Pi[0] - 3) break;
                jt.showCentroid(Ri), Jt++;
              }
              if (Ri && Jt < Zt.length) {
                const mi = Jt;
                let Ai = 0;
                for (; !(Ri.borders[Xt][0] > Pi[1] - 3) && (Ai++, ++Jt !== Zt.length); ) Ri = jt.featuresOnBorder[Zt[Jt]];
                Ri = jt.featuresOnBorder[Zt[mi]];
                let ji = !1;
                if (Ai >= 1) {
                  const Mi = Ri.borders[Xt];
                  Math.abs(Pi[0] - Mi[0]) < 3 && Math.abs(Pi[1] - Mi[1]) < 3 && (Ai = 1, ji = !0, Jt = mi + 1);
                } else if (Ai === 0) {
                  c.showCentroid(Ti);
                  continue;
                }
                const yi = jt.centroidData[Ri.centroidDataIndex];
                C && ji && (((st = xi).flags | (vt = yi).flags) & i.d6 ? (st.flags |= i.d6, vt.flags |= i.d6) : (st.flags &= ~i.d6, vt.flags &= ~i.d6));
                const Ni = Ti.intersectsCount() > 1 || Ri.intersectsCount() > 1;
                if (Ai > 1) Jt = mi, xi.centroidXY = yi.centroidXY = new i.P(0, 0);
                else if (ii && ii.dem && !Ni) {
                  const Mi = Le[gt](xi, yi), Yi = gt % 2 ? i.ag - 1 : 0, Ui = ft(Mi[0], Math.min(i.ag - 1, Mi[1]), Yi, ii, qt, gt < 2, Mi[2]);
                  xi.centroidXY = yi.centroidXY = K(Ui);
                } else Ni ? xi.centroidXY = yi.centroidXY = new i.P(0, 0) : (xi.centroidXY = c.encodeBorderCentroid(Ti), yi.centroidXY = jt.encodeBorderCentroid(Ri));
                c.writeCentroidToBuffer(xi), jt.writeCentroidToBuffer(yi);
              } else c.showCentroid(Ti);
            }
            c.borderDoneWithNeighborZ[gt] = jt.canonical.z, jt.borderDoneWithNeighborZ[Xt] = c.canonical.z;
          }
          var st, vt;
          (c.needsCentroidUpdate || !c.centroidVertexBuffer && c.centroidVertexArray.length !== 0) && c.uploadCentroid(u);
        }
        const Wl = [1, 0, 0], Ji = [0, 1, 0], or = [0, 0, 1];
        function So(u, t, n) {
          const c = n.transform, p = n.shadowRenderer;
          if (!p) return !0;
          const v = u.toUnwrapped(), C = c.tileSize * p._cascades[n.currentShadowCascade].scale;
          let V = t.maxHeight;
          if (c.elevation) {
            const st = c.elevation.getMinMaxForTile(u);
            st && (V += st.max);
          }
          const K = [...p.shadowDirection];
          K[2] = -K[2];
          const se = p.computeSimplifiedTileShadowVolume(v, V, C, K);
          if (!se) return !1;
          const oe = [Wl, Ji, or, K, [K[0], 0, K[2]], [0, K[1], K[2]]], ve = c.projection.name === "globe", xe = c.scaleZoom(C), Le = i.bR.fromInvProjectionMatrix(c.invProjMatrix, c.worldSize, xe, !ve), ft = p.getCurrentCascadeFrustum();
          return Le.intersectsPrecise(se.vertices, se.planes, oe) === 0 || ft.intersectsPrecise(se.vertices, se.planes, oe) === 0;
        }
        function Wn(u) {
          return [u[0] * i.d9, u[1] * i.d9, u[2] * i.d9, 0];
        }
        function Ei(u, t, n, c, p, v, C, V, K) {
          const se = c.getSource(), oe = n.globeSharedBuffers;
          if (!oe) return;
          let ve, xe, Le;
          if (t && (ve = c.getTile(t)), se instanceof i.aJ ? (xe = se.texture, Le = i.cI(0, 0, n.transform)) : ve && t && (xe = ve.texture, Le = i.cI(t.canonical.z, t.canonical.x, n.transform)), !xe || !Le) return;
          u || (Le = i.ab.mat4.scale(i.ab.mat4.create(), Le, [1, -1, 1]));
          const ft = n.context, st = ft.gl, vt = p.paint.get("raster-resampling") === "nearest" ? st.NEAREST : st.LINEAR, gt = n.colorModeForDrapableLayerRenderPass(v), Rt = C.defines;
          Rt.push("GLOBE_POLES");
          const qt = new Sr(st.LEQUAL, Sr.ReadWrite, n.depthRangeFor3D), jt = Float32Array.from(n.transform.expandedFarZProjMatrix), ii = Float32Array.from(i.bb(i.cH(new i.bT(0, 0, 0))));
          n.terrain && n.terrain.prepareDrawTile(), ft.activeTexture.set(st.TEXTURE0), xe.bind(vt, st.CLAMP_TO_EDGE), ft.activeTexture.set(st.TEXTURE1), xe.bind(vt, st.CLAMP_TO_EDGE), xe.useMipmap && ft.extTextureFilterAnisotropic && n.transform.pitch > 20 && st.texParameterf(st.TEXTURE_2D, ft.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, ft.extTextureFilterAnisotropicMax);
          const [Xt, Kt, Zt, Jt] = t ? oe.getPoleBuffers(t.canonical.z, !1) : oe.getPoleBuffers(0, !0), ui = p.paint.get("raster-elevation");
          let Ti;
          u ? (Ti = Xt, n.renderDefaultNorthPole = ui !== 0) : (Ti = Kt, n.renderDefaultSouthPole = ui !== 0);
          const xi = Wn(C.mix), Pi = ((mi, Ai, ji, yi, Ni, Mi, Yi, Ui, Fi, Zi, ir, cr, fr) => ws(mi, Ai, ji, new Float32Array(16), new Float32Array(9), [0, 0], yi, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, Mi, [0, 0], Ui, 2, Zi, ir, cr, 1, 0, fr))(jt, ii, Le, i.ae(n.transform.zoom), 0, p, 0, ui, 0, xi, C.offset, C.range, v), Ri = n.getOrCreateProgram("raster", { defines: Rt });
          n.uploadCommonUniforms(ft, Ri, null), Ri.draw(n, st.TRIANGLES, qt, K, gt, V, Pi, p.id, Ti, Zt, Jt);
        }
        function Ko(u) {
          const t = u._nearZ, n = u.projection.farthestPixelDistance(u), c = n - t, p = 0.2 * u.height, v = t + p;
          return [t, n, (v - p - t) / c, (v - t) / c];
        }
        function Ro(u, t, n, c) {
          if (u) return t instanceof En && u instanceof tn ? t.getTextureDescriptor(u, n, !0) : { texture: u.texture, mix: Wn(c.mix), offset: c.offset, buffer: 0, tileSize: 1 };
        }
        var Hc = i.da([{ name: "a_index", type: "Int16", components: 1 }]);
        class of {
          constructor(t, n, c, p) {
            const v = { width: c[0], height: c[1], data: null }, C = t.gl;
            this.targetColorTexture = new i.T(t, v, C.RGBA8, { useMipmap: !1 }), this.backgroundColorTexture = new i.T(t, v, C.RGBA8, { useMipmap: !1 }), this.context = t, this.updateParticleTexture(n, p), this.lastInvalidatedAt = 0;
          }
          updateParticleTexture(t, n) {
            if (this.particleTextureDimension === n.width) return;
            (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
            const c = this.context.gl, p = n.width * n.height;
            this.particleTexture0 = new i.T(this.context, n, c.RGBA8, { premultiply: !1, useMipmap: !1 }), this.particleTexture1 = new i.T(this.context, n, c.RGBA8, { premultiply: !1, useMipmap: !1 });
            const v = new i.db();
            v.reserve(p);
            for (let C = 0; C < p; C++) v.emplaceBack(C);
            this.particleIndexBuffer = this.context.createVertexBuffer(v, Hc.members, !0), this.particleSegment = i.b7.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = n.width;
          }
          update(t) {
            return !(this.lastInvalidatedAt < t && (this.lastInvalidatedAt = i.q.now(), 1));
          }
          destroy() {
            this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
          }
        }
        function Jo(u, t, n) {
          if (!u) return null;
          const c = t.getTextureDescriptor(u, n, !0);
          if (!c) return null;
          let { texture: p, mix: v, offset: C, tileSize: V, buffer: K, format: se } = c;
          if (!p || !se) return null;
          let oe = !1;
          return se === "uint32" && (oe = !0, v[3] = 0, v = yl(i.dc, v, [0, n.paint.get("raster-particle-max-speed")]), C = Po(i.dc, C, [0, n.paint.get("raster-particle-max-speed")])), { texture: p, textureOffset: [K / (V + 2 * K), V / (V + 2 * K)], tileSize: V, scalarData: oe, scale: v, offset: C, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[se]] };
        }
        function xl(u) {
          const t = u._nearZ, n = u.projection.farthestPixelDistance(u), c = n - t, p = 0.2 * u.height, v = t + p;
          return [t, n, (v - p - t) / c, (v - t) / c];
        }
        const bl = new i.aj(1, 0, 0, 1), Bf = new i.aj(0, 1, 0, 1), bh = new i.aj(0, 0, 1, 1), lf = new i.aj(1, 0, 1, 1), Zl = new i.aj(0, 1, 1, 1);
        function _s(u, t, n, c, p, v, C) {
          const V = u.context, K = u.transform, se = V.gl, oe = K.projection.name === "globe", ve = oe ? ["PROJECTION_GLOBE_VIEW"] : [];
          let xe = i.ab.mat4.clone(n.projMatrix);
          if (oe && i.ae(K.zoom) > 0) {
            const xi = i.ba(n.canonical, K), Pi = i.dd(xi);
            xe = i.ab.mat4.multiply(new Float32Array(16), K.globeMatrix, Pi), i.ab.mat4.multiply(xe, K.projMatrix, xe);
          }
          const Le = i.ab.mat4.create();
          Le[12] += 2 * p / (i.q.devicePixelRatio * K.width), Le[13] += 2 * v / (i.q.devicePixelRatio * K.height), i.ab.mat4.multiply(xe, Le, xe);
          const ft = u.getOrCreateProgram("debug", { defines: ve }), st = t.getTileByID(n.key);
          u.terrain && u.terrain.setupElevationDraw(st, ft);
          const vt = Sr.disabled, gt = Lr.disabled, Rt = u.colorModeForRenderPass(), qt = "$debug";
          V.activeTexture.set(se.TEXTURE0), u.emptyTexture.bind(se.LINEAR, se.CLAMP_TO_EDGE), oe ? st._makeGlobeTileDebugBuffers(u.context, K) : st._makeDebugTileBoundsBuffers(u.context, K.projection);
          const jt = st._tileDebugBuffer || u.debugBuffer, ii = st._tileDebugIndexBuffer || u.debugIndexBuffer, Xt = st._tileDebugSegments || u.debugSegments;
          if (ft.draw(u, se.LINE_STRIP, vt, gt, Rt, kr.disabled, Xo(xe, c), qt, jt, ii, Xt, null, null, null, [st._globeTileDebugBorderBuffer]), C) {
            const xi = st.latestRawTileData, Pi = Math.floor((xi && xi.byteLength || 0) / 1024);
            let Ri = n.canonical.toString();
            n.overscaledZ !== n.canonical.z && (Ri += ` => ${n.overscaledZ}`), Ri += ` ${st.state}`, Ri += ` ${Pi}kb`, function(mi, Ai) {
              mi.initDebugOverlayCanvas();
              const ji = mi.debugOverlayCanvas, yi = mi.context.gl, Ni = mi.debugOverlayCanvas.getContext("2d");
              Ni.clearRect(0, 0, ji.width, ji.height), Ni.shadowColor = "white", Ni.shadowBlur = 2, Ni.lineWidth = 1.5, Ni.strokeStyle = "white", Ni.textBaseline = "top", Ni.font = "bold 36px Open Sans, sans-serif", Ni.fillText(Ai, 5, 5), Ni.strokeText(Ai, 5, 5), mi.debugOverlayTexture.update(ji), mi.debugOverlayTexture.bind(yi.LINEAR, yi.CLAMP_TO_EDGE);
            }(u, Ri);
          }
          const Kt = t.getTile(n).tileSize, Zt = 512 / Math.min(Kt, 512) * (n.overscaledZ / K.zoom) * 0.5, Jt = st._tileDebugTextBuffer || u.debugBuffer, ui = st._tileDebugTextIndexBuffer || u.quadTriangleIndexBuffer, Ti = st._tileDebugTextSegments || u.debugSegments;
          ft.draw(u, se.TRIANGLES, vt, gt, zr.alphaBlended, kr.disabled, Xo(xe, i.aj.transparent, Zt), qt, Jt, ui, Ti, null, null, null, [st._globeTileDebugTextBuffer]);
        }
        function Au(u, t, n, c) {
          ho(u, 0, t + n / 2, u.transform.width, n, c);
        }
        function Mu(u, t, n, c) {
          ho(u, t - n / 2, 0, n, u.transform.height, c);
        }
        function ho(u, t, n, c, p, v) {
          const C = u.context, V = C.gl;
          V.enable(V.SCISSOR_TEST), V.scissor(t * i.q.devicePixelRatio, n * i.q.devicePixelRatio, c * i.q.devicePixelRatio, p * i.q.devicePixelRatio), C.clear({ color: v }), V.disable(V.SCISSOR_TEST);
        }
        const uc = i.da([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: Os } = uc;
        function Qo(u, t, n, c) {
          u.emplaceBack(t, n, c);
        }
        class wh {
          constructor(t) {
            this.vertexArray = new i.de(), this.indices = new i.aU(), Qo(this.vertexArray, -1, -1, 1), Qo(this.vertexArray, 1, -1, 1), Qo(this.vertexArray, -1, 1, 1), Qo(this.vertexArray, 1, 1, 1), Qo(this.vertexArray, -1, -1, -1), Qo(this.vertexArray, 1, -1, -1), Qo(this.vertexArray, -1, 1, -1), Qo(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, Os), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = i.b7.simpleSegment(0, 0, 36, 12);
          }
        }
        function bn(u, t, n, c, p, v) {
          const C = u.context.gl, V = t.paint.get("sky-atmosphere-color"), K = t.paint.get("sky-atmosphere-halo-color"), se = t.paint.get("sky-atmosphere-sun-intensity"), oe = ((ve, xe, Le, ft, st) => ({ u_matrix_3f: ve, u_sun_direction: xe, u_sun_intensity: Le, u_color_tint_r: [ft.r, ft.g, ft.b, ft.a], u_color_tint_m: [st.r, st.g, st.b, st.a], u_luminance: 5e-5 }))(i.ab.mat3.fromMat4(i.ab.mat3.create(), c), p, se, V, K);
          C.framebufferTexture2D(C.FRAMEBUFFER, C.COLOR_ATTACHMENT0, C.TEXTURE_CUBE_MAP_POSITIVE_X + v, t.skyboxTexture, 0), n.draw(u, C.TRIANGLES, Sr.disabled, Lr.disabled, zr.unblended, kr.frontCW, oe, "skyboxCapture", t.skyboxGeometry.vertexBuffer, t.skyboxGeometry.indexBuffer, t.skyboxGeometry.segment);
        }
        const Sh = i.da([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
        class Iu {
          constructor(t) {
            const n = new i.df();
            n.emplaceBack(-1, 1, 1, 0, 0), n.emplaceBack(1, 1, 1, 1, 0), n.emplaceBack(1, -1, 1, 1, 1), n.emplaceBack(-1, -1, 1, 0, 1);
            const c = new i.aU();
            c.emplaceBack(0, 1, 2), c.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(n, Sh.members), this.indexBuffer = t.createIndexBuffer(c), this.segments = i.b7.simpleSegment(0, 0, 4, 2);
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
          }
        }
        const Ln = i.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
        class dn {
          constructor() {
            this.starsCount = 16e3, this.sizeMultiplier = 0.15, this.sizeRange = 100, this.intensityRange = 200;
          }
        }
        class Eh {
          constructor(t) {
            this.colorModeAlphaBlendedWriteRGB = new zr([1, Uo, 1, Uo], i.aj.transparent, [!0, !0, !0, !1]), this.colorModeWriteAlpha = new zr([1, 0, 1, 0], i.aj.transparent, [!1, !1, !1, !0]), this.params = new dn(), this.updateNeeded = !0, t.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }, () => {
              this.updateNeeded = !0;
            }), t.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: 0.01, max: 2, step: 0.01 }), t.tp.registerParameter(this.params, ["Stars"], "sizeRange", { min: 0, max: 200, step: 1 }, () => {
              this.updateNeeded = !0;
            }), t.tp.registerParameter(this.params, ["Stars"], "intensityRange", { min: 0, max: 200, step: 1 }, () => {
              this.updateNeeded = !0;
            });
          }
          update(t) {
            const n = t.context;
            if (!this.atmosphereBuffer || this.updateNeeded) {
              this.updateNeeded = !1, this.atmosphereBuffer = new Iu(n);
              const c = this.params.sizeRange, p = this.params.intensityRange, v = function(oe) {
                const ve = i.di(30), xe = [];
                for (let Le = 0; Le < oe; ++Le) {
                  const ft = 2 * Math.PI * ve(), st = Math.acos(1 - 2 * ve()) - 0.5 * Math.PI;
                  xe.push(i.ab.vec3.fromValues(Math.cos(st) * Math.cos(ft), Math.cos(st) * Math.sin(ft), Math.sin(st)));
                }
                return xe;
              }(this.params.starsCount), C = i.di(300), V = new i.dg(), K = new i.aU();
              let se = 0;
              for (let oe = 0; oe < v.length; ++oe) {
                const ve = i.ab.vec3.scale([], v[oe], 200), xe = Math.max(0, 1 + 0.01 * c * (1 * C() - 0.5)), Le = Math.max(0, 1 + 0.01 * p * (1 * C() - 0.5));
                V.emplaceBack(ve[0], ve[1], ve[2], -1, -1, xe, Le), V.emplaceBack(ve[0], ve[1], ve[2], 1, -1, xe, Le), V.emplaceBack(ve[0], ve[1], ve[2], 1, 1, xe, Le), V.emplaceBack(ve[0], ve[1], ve[2], -1, 1, xe, Le), K.emplaceBack(se + 0, se + 1, se + 2), K.emplaceBack(se + 0, se + 2, se + 3), se += 4;
              }
              this.starsVx = n.createVertexBuffer(V, Ln.members), this.starsIdx = n.createIndexBuffer(K), this.starsSegments = i.b7.simpleSegment(0, 0, V.length, K.length);
            }
          }
          destroy() {
            this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
          }
          drawAtmosphereGlow(t, n) {
            const c = t.context, p = c.gl, v = t.transform, C = new Sr(p.LEQUAL, Sr.ReadOnly, [0, 1]), V = i.ae(v.zoom), K = t.style.getLut(n.scope), se = n.properties.get("color-use-theme") === "none", oe = n.properties.get("color").toRenderColor(se ? null : K).toArray01(), ve = n.properties.get("high-color-use-theme") === "none", xe = n.properties.get("high-color").toRenderColor(ve ? null : K).toArray01(), Le = n.properties.get("space-color-use-theme") === "none", ft = n.properties.get("space-color").toRenderColor(Le ? null : K).toArray01PremultipliedAlpha(), st = 5e-4, vt = i.dh(n.properties.get("horizon-blend"), 0, 1, st, 0.25), gt = i.cC(t, c, v) && vt === st ? v.worldSize / (2 * Math.PI * 1.025) - 1 : v.globeRadius, Rt = t.frameCounter / 1e3 % 1, qt = i.ab.vec3.length(v.globeCenterInViewSpace), jt = Math.sqrt(Math.pow(qt, 2) - Math.pow(gt, 2)), ii = Math.acos(jt / qt), Xt = (Kt) => {
              const Zt = v.projection.name === "globe" ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
              Kt && Zt.push("ALPHA_PASS");
              const Jt = t.getOrCreateProgram("globeAtmosphere", { defines: Zt }), ui = /* @__PURE__ */ ((xi, Pi, Ri, mi, Ai, ji, yi, Ni, Mi, Yi, Ui, Fi) => ({ u_frustum_tl: xi, u_frustum_tr: Pi, u_frustum_br: Ri, u_frustum_bl: mi, u_horizon: Ai, u_transition: ji, u_fadeout_range: yi, u_color: Ni, u_high_color: Mi, u_space_color: Yi, u_temporal_offset: Ui, u_horizon_angle: Fi }))(v.frustumCorners.TL, v.frustumCorners.TR, v.frustumCorners.BR, v.frustumCorners.BL, v.frustumCorners.horizon, V, vt, oe, xe, ft, Rt, ii);
              t.uploadCommonUniforms(c, Jt);
              const Ti = this.atmosphereBuffer;
              Ti && Jt.draw(t, p.TRIANGLES, C, Lr.disabled, Kt ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, kr.backCW, ui, Kt ? "atmosphere_glow_alpha" : "atmosphere_glow", Ti.vertexBuffer, Ti.indexBuffer, Ti.segments);
            };
            Xt(!1), Xt(!0);
          }
          drawStars(t, n) {
            const c = i.aw(n.properties.get("star-intensity"), 0, 1);
            if (c === 0) return;
            const p = t.context, v = p.gl, C = t.transform, V = t.getOrCreateProgram("stars"), K = i.ab.quat.identity([]);
            i.ab.quat.rotateX(K, K, -C._pitch), i.ab.quat.rotateZ(K, K, -C.angle), i.ab.quat.rotateX(K, K, i.ai(C._center.lat)), i.ab.quat.rotateY(K, K, -i.ai(C._center.lng));
            const se = i.ab.mat4.fromQuat(new Float32Array(16), K), oe = i.ab.mat4.multiply([], C.starsProjMatrix, se), ve = i.ab.mat3.fromMat4([], se), xe = i.ab.mat3.invert([], ve), Le = [0, 1, 0];
            i.ab.vec3.transformMat3(Le, Le, xe), i.ab.vec3.scale(Le, Le, this.params.sizeMultiplier);
            const ft = [1, 0, 0];
            i.ab.vec3.transformMat3(ft, ft, xe), i.ab.vec3.scale(ft, ft, this.params.sizeMultiplier);
            const st = (vt = Le, gt = ft, Rt = c, { u_matrix: Float32Array.from(oe), u_up: vt, u_right: gt, u_intensity_multiplier: Rt });
            var vt, gt, Rt;
            t.uploadCommonUniforms(p, V), this.starsVx && this.starsIdx && V.draw(t, v.TRIANGLES, Sr.disabled, Lr.disabled, this.colorModeAlphaBlendedWriteRGB, kr.disabled, st, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
          }
        }
        function Ds(u, t) {
          const n = [...u], c = t.cameraWorldSizeForFog / t.worldSize, p = i.ab.mat4.identity([]);
          return i.ab.mat4.scale(p, p, [c, c, 1]), i.ab.mat4.multiply(n, p, n), i.ab.mat4.multiply(n, t.worldToFogMatrix, n), n;
        }
        function oa(u, t, n, c, p) {
          const v = n.material, C = c.context, { baseColorTexture: V, metallicRoughnessTexture: K } = v.pbrMetallicRoughness, { normalTexture: se, occlusionTexture: oe, emissionTexture: ve } = v;
          function xe(ft, st, vt) {
            if (ft && (u.push(st), C.activeTexture.set(C.gl.TEXTURE0 + vt), ft.gfxTexture)) {
              const { minFilter: gt, magFilter: Rt, wrapS: qt, wrapT: jt } = ft.sampler;
              ft.gfxTexture.bindExtraParam(gt, Rt, qt, jt);
            }
          }
          xe(V, "HAS_TEXTURE_u_baseColorTexture", $a.BaseColor), xe(K, "HAS_TEXTURE_u_metallicRoughnessTexture", $a.MetallicRoughness), xe(se, "HAS_TEXTURE_u_normalTexture", $a.Normal), xe(oe, "HAS_TEXTURE_u_occlusionTexture", $a.Occlusion), xe(ve, "HAS_TEXTURE_u_emissionTexture", $a.Emission), p && (p.texture || (p.texture = new i.dk(c.context, p.image, [p.image.height, p.image.height, p.image.height], C.gl.RGBA8)), C.activeTexture.set(C.gl.TEXTURE0 + $a.LUT), p.texture && p.texture.bind(C.gl.LINEAR, C.gl.CLAMP_TO_EDGE), u.push("APPLY_LUT_ON_GPU")), n.texcoordBuffer && (u.push("HAS_ATTRIBUTE_a_uv_2f"), t.push(n.texcoordBuffer)), n.colorBuffer && (u.push(n.colorBuffer.itemSize === 12 ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), t.push(n.colorBuffer)), n.normalBuffer && (u.push("HAS_ATTRIBUTE_a_normal_3f"), t.push(n.normalBuffer)), n.pbrBuffer && (u.push("HAS_ATTRIBUTE_a_pbr"), u.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), t.push(n.pbrBuffer)), v.alphaMode !== "OPAQUE" && v.alphaMode !== "MASK" || u.push("UNPREMULT_TEXTURE_IN_SHADER"), v.defined || u.push("DIFFUSE_SHADED");
          const Le = c.shadowRenderer;
          Le && (u.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), Le.useNormalOffset && u.push("NORMAL_OFFSET"));
        }
        function pa(u, t, n, c, p, v) {
          const C = n.paint.get("model-opacity").constantOr(1), V = t.context, K = new Sr(t.context.gl.LEQUAL, Sr.ReadWrite, t.depthRangeFor3D), se = t.transform, oe = u.mesh, ve = oe.material, xe = ve.pbrMetallicRoughness, Le = t.style.fog;
          let ft;
          ft = t.transform.projection.zAxisUnit === "pixels" ? [...u.nodeModelMatrix] : i.ab.mat4.multiply([], c.zScaleMatrix, u.nodeModelMatrix), i.ab.mat4.multiply(ft, c.negCameraPosMatrix, ft);
          const st = i.ab.mat4.invert([], ft);
          i.ab.mat4.transpose(st, st);
          const vt = n.paint.get("model-color-use-theme").constantOr("default") === "none", gt = n.paint.get("model-emissive-strength").constantOr(0), Rt = Su(new Float32Array(u.worldViewProjection), new Float32Array(ft), new Float32Array(st), null, t, C, xe.baseColorFactor.toRenderColor(null), ve.emissiveFactor, xe.metallicFactor, xe.roughnessFactor, ve, gt, n), qt = { defines: [] }, jt = [], ii = t.shadowRenderer;
          ii && (ii.useNormalOffset = !1), oa(qt.defines, jt, oe, t, vt ? null : n.lut);
          let Xt = null;
          if (Le) {
            const Jt = Ds(u.nodeModelMatrix, t.transform);
            if (Xt = new Float32Array(Jt), se.projection.name !== "globe") {
              const ui = oe.aabb.min, Ti = oe.aabb.max, [xi, Pi] = Le.getOpacityForBounds(Jt, ui[0], ui[1], Ti[0], Ti[1]);
              qt.overrideFog = xi >= It || Pi >= It;
            }
          }
          const Kt = Ps(t, n.paint.get("model-cutoff-fade-range"));
          Kt.shouldRenderCutoff && qt.defines.push("RENDER_CUTOFF");
          const Zt = t.getOrCreateProgram("model", qt);
          t.uploadCommonUniforms(V, Zt, null, Xt, Kt), t.renderPass !== "shadow" && ii && ii.setupShadowsFromMatrix(u.nodeModelMatrix, Zt), Zt.draw(t, V.gl.TRIANGLES, K, p, v, oe.material.doubleSided ? kr.disabled : kr.backCCW, Rt, n.id, oe.vertexBuffer, oe.indexBuffer, oe.segments, n.paint, t.transform.zoom, void 0, jt);
        }
        function ja(u, t, n, c, p, v, C) {
          let V;
          V = u.projection.name === "globe" ? i.dl(n, u) : [...n], i.ab.mat4.multiply(V, V, t.matrix);
          const K = i.ab.mat4.multiply([], c, V);
          if (t.meshes) for (const se of t.meshes) {
            if (se.material.alphaMode !== "BLEND") {
              C.push({ mesh: se, depth: 0, modelIndex: p, worldViewProjection: K, nodeModelMatrix: V });
              continue;
            }
            const oe = i.ab.vec3.transformMat4([], se.centroid, K);
            !u.isOrthographic && oe[2] <= 0 || v.push({ mesh: se, depth: oe[2], modelIndex: p, worldViewProjection: K, nodeModelMatrix: V });
          }
          if (t.children) for (const se of t.children) ja(u, se, n, c, p, v, C);
        }
        function $l(u, t, n, c) {
          const p = n.shadowRenderer;
          if (!p) return;
          const v = p.getShadowPassDepthMode(), C = p.getShadowPassColorMode(), V = p.calculateShadowPassMatrixFromMatrix(t), K = oc(V);
          n.getOrCreateProgram("modelDepth", { defines: n._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(n, n.context.gl.TRIANGLES, v, Lr.disabled, C, kr.backCCW, K, c.id, u.vertexBuffer, u.indexBuffer, u.segments, c.paint, n.transform.zoom, void 0, void 0);
        }
        function $s(u, t, n) {
          const c = t.updateZoomBasedPaintProperties(), p = function(v, C, V) {
            let K, se, oe, ve = v.terrain ? v.terrain.exaggeration() : 0;
            if (v.terrain && ve > 0) {
              const xe = v.terrain, Le = xe.findDEMTileFor(V);
              Le && Le.dem ? K = i.dn.create(xe, V, Le) : ve = 0;
            }
            if (ve === 0 && (C.terrainElevationMin = 0, C.terrainElevationMax = 0), ve === C.validForExaggeration && (ve === 0 || K && K._demTile && K._demTile.tileID === C.validForDEMTile.id && K._dem._timestamp === C.validForDEMTile.timestamp)) return !1;
            for (const xe in C.instancesPerModel) {
              const Le = C.instancesPerModel[xe];
              for (let ft = 0; ft < Le.instancedDataArray.length; ++ft) {
                const st = (K ? ve * K.getElevationAt(0 | Le.instancedDataArray.float32[16 * ft], 0 | Le.instancedDataArray.float32[16 * ft + 1], !0, !0) : 0) + Le.instancesEvaluatedElevation[ft];
                Le.instancedDataArray.float32[16 * ft + 6] = st, se = se ? Math.min(C.terrainElevationMin, st) : st, oe = oe ? Math.max(C.terrainElevationMax, st) : st;
              }
            }
            return C.terrainElevationMin = se || 0, C.terrainElevationMax = oe || 0, C.validForExaggeration = ve, C.validForDEMTile = K && K._demTile ? { id: K._demTile.tileID, timestamp: K._dem._timestamp } : { id: void 0, timestamp: 0 }, !0;
          }(u, t, n);
          (c || p) && (t.uploaded = !1, t.upload(u.context));
        }
        const Ga = { shadowUniformsInitialized: !1, useSingleShadowCascade: !1, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new i.cd([0, 0, 0], [i.ag, i.ag, 0]) };
        function Th(u, t) {
          const n = 1 << u.canonical.z, c = t.getFreeCameraOptions().position, p = t.elevation, v = u.canonical.x / n, C = (u.canonical.x + 1) / n, V = u.canonical.y / n, K = (u.canonical.y + 1) / n;
          let se = t._centerAltitude;
          if (p) {
            const Le = p.getMinMaxForTile(u);
            Le && Le.max > se && (se = Le.max);
          }
          const oe = i.aw(c.x, v, C) - c.x, ve = i.aw(c.y, V, K) - c.y, xe = i.bH(se, t.center.lat) - c.z;
          return t._zoomFromMercatorZ(Math.sqrt(oe * oe + ve * ve + xe * xe));
        }
        function Xa(u, t, n, c, p, v, C) {
          const V = u.context, K = u.renderPass === "shadow", se = u.shadowRenderer, oe = K && se ? se.getShadowPassDepthMode() : new Sr(V.gl.LEQUAL, Sr.ReadWrite, u.depthRangeFor3D), ve = u.isTileAffectedByFog(v);
          if (n.meshes) for (const xe of n.meshes) {
            const Le = ["MODEL_POSITION_ON_GPU"], ft = [];
            let st, vt, gt;
            c.instancedDataArray.length > 20 && Le.push("INSTANCED_ARRAYS");
            const Rt = Ps(u, t.paint.get("model-cutoff-fade-range"));
            if (Rt.shouldRenderCutoff && Le.push("RENDER_CUTOFF"), K && se) st = u.getOrCreateProgram("modelDepth", { defines: Le }), vt = oc(C.shadowTileMatrix, C.shadowTileMatrix, Float32Array.from(n.matrix)), gt = se.getShadowPassColorMode();
            else {
              oa(Le, ft, xe, u, t.paint.get("model-color-use-theme").constantOr("default") === "none" ? null : t.lut), st = u.getOrCreateProgram("model", { defines: Le, overrideFog: ve });
              const jt = xe.material, ii = jt.pbrMetallicRoughness, Xt = t.paint.get("model-opacity").constantOr(1), Kt = t.paint.get("model-emissive-strength").constantOr(0);
              vt = Su(v.expandedProjMatrix, Float32Array.from(n.matrix), new Float32Array(16), null, u, Xt, ii.baseColorFactor.toRenderColor(null), jt.emissiveFactor, ii.metallicFactor, ii.roughnessFactor, jt, Kt, t, p), se && (C.shadowUniformsInitialized ? st.setShadowUniformValues(V, se.getShadowUniformValues()) : (se.setupShadows(v.toUnwrapped(), st, "model-tile", v.overscaledZ), C.shadowUniformsInitialized = !0)), gt = Rt.shouldRenderCutoff || Xt < 1 || jt.alphaMode !== "OPAQUE" ? zr.alphaBlended : zr.unblended;
            }
            u.uploadCommonUniforms(V, st, v.toUnwrapped(), null, Rt);
            const qt = xe.material.doubleSided ? kr.disabled : kr.backCCW;
            if (c.instancedDataArray.length > 20) ft.push(c.instancedDataBuffer), st.draw(u, V.gl.TRIANGLES, oe, Lr.disabled, gt, qt, vt, t.id, xe.vertexBuffer, xe.indexBuffer, xe.segments, t.paint, u.transform.zoom, void 0, ft, c.instancedDataArray.length);
            else {
              const jt = K ? "u_instance" : "u_normal_matrix";
              for (let ii = 0; ii < c.instancedDataArray.length; ++ii) vt[jt] = new Float32Array(c.instancedDataArray.arrayBuffer, 64 * ii, 16), st.draw(u, V.gl.TRIANGLES, oe, Lr.disabled, gt, qt, vt, t.id, xe.vertexBuffer, xe.indexBuffer, xe.segments, t.paint, u.transform.zoom, void 0, ft);
            }
          }
          if (n.children) for (const xe of n.children) Xa(u, t, xe, c, p, v, C);
        }
        const qc = [1, -1, 1];
        function Wc(u, t, n, c) {
          if (!n.modelManager) return !0;
          const p = n.modelManager;
          if (!n.shadowRenderer) return !0;
          const v = n.shadowRenderer, C = t.aabb;
          let V = !0, K = u.maxHeight;
          if (K === 0) {
            let oe = 0;
            for (const ve in u.instancesPerModel) {
              const xe = p.getModel(ve, c);
              xe ? oe = Math.max(oe, Math.max(Math.max(xe.aabb.max[0], xe.aabb.max[1]), xe.aabb.max[2])) : V = !1;
            }
            K = u.maxScale * oe * 1.41 + u.maxVerticalOffset, V && (u.maxHeight = K);
          }
          C.max[2] = K, C.min[2] += u.terrainElevationMin, C.max[2] += u.terrainElevationMax, i.ab.vec3.transformMat4(C.min, C.min, t.tileMatrix), i.ab.vec3.transformMat4(C.max, C.max, t.tileMatrix);
          const se = C.intersects(v.getCurrentCascadeFrustum());
          return n.currentShadowCascade === 0 && (u.isInsideFirstShadowMapFrustum = se === 2), se === 0;
        }
        function wl(u, t) {
          const n = u.uniformValues.u_cutoff_params[0], c = u.uniformValues.u_cutoff_params[1], p = u.uniformValues.u_cutoff_params[2], v = u.uniformValues.u_cutoff_params[3];
          return c === n || v === p ? 1 : i.aw(((t - n) / (c - n) - p) / (v - p), 0, 1);
        }
        function Eo(u, t, n, c) {
          if (t.pitch < 20) return 1;
          const p = t.getWorldToCameraMatrix();
          i.ab.mat4.multiply(p, p, u);
          const v = i.ab.vec4.fromValues(n.min[0], n.min[1], n.min[2], 1);
          let C = i.ab.vec4.transformMat4(i.ab.vec4.create(), v, p), V = C, K = C;
          v[1] = n.max[1], C = i.ab.vec4.transformMat4(i.ab.vec4.create(), v, p), V = C[1] < V[1] ? C : V, K = C[1] > K[1] ? C : K, v[0] = n.max[0], C = i.ab.vec4.transformMat4(i.ab.vec4.create(), v, p), V = C[1] < V[1] ? C : V, K = C[1] > K[1] ? C : K, v[1] = n.min[1], C = i.ab.vec4.transformMat4(i.ab.vec4.create(), v, p), V = C[1] < V[1] ? C : V, K = C[1] > K[1] ? C : K;
          const se = i.aw(c[0], 0, 1), oe = 100 * t.pixelsPerMeter * i.aw(c[1], 0, 1), ve = i.aw(c[2], 0, 1), xe = i.ab.vec4.lerp(i.ab.vec4.create(), V, K, se), Le = Math.tan(0.5 * t.fovX), ft = -xe[2] * Le;
          if (oe === 0) return xe[1] < -Math.abs(ft) ? ve : 1;
          const st = (-Math.abs(ft) - xe[1]) / oe, vt = (Rt, qt, jt) => (1 - jt) * Rt + jt * qt, gt = i.aw(vt(1, ve, st), ve, 1);
          return vt(1, gt, i.aw((t.pitch - 20) / 20, 0, 1));
        }
        class rs {
        }
        class Pu {
          constructor() {
            this._storage = /* @__PURE__ */ new Map();
          }
          getLinesFromTrianglesBuffer(t, n, c) {
            {
              const ve = this._storage.get(n.id);
              if (ve) return ve.lastUsedFrameIdx = t, ve.buf;
            }
            const p = c.gl, v = p.getBufferParameter(p.ELEMENT_ARRAY_BUFFER, p.BUFFER_SIZE), C = new ArrayBuffer(v), V = new Int16Array(C);
            p.getBufferSubData(p.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(C));
            const K = new i.dq();
            for (let ve = 0; ve < v / 2; ve += 3) {
              const xe = V[ve], Le = V[ve + 1], ft = V[ve + 2];
              K.emplaceBack(xe, Le), K.emplaceBack(Le, ft), K.emplaceBack(ft, xe);
            }
            const se = c.bindVertexArrayOES.current, oe = new rs();
            return oe.buf = new uo(c, K), oe.lastUsedFrameIdx = t, this._storage.set(n.id, oe), c.bindVertexArrayOES.set(se), oe.buf;
          }
          update(t) {
            for (const [n, c] of this._storage) t - c.lastUsedFrameIdx > 30 && (c.buf.destroy(), this._storage.delete(n));
          }
          destroy() {
            for (const [t, n] of this._storage) n.buf.destroy(), this._storage.delete(t);
          }
        }
        class cc {
          constructor(t) {
            this.occluderSize = 30, this.depthOffset = -1e-4, t.registerParameter(this, ["Occlusion"], "occluderSize", { min: 1, max: 100, step: 1 }), t.registerParameter(this, ["Occlusion"], "depthOffset", { min: -0.05, max: 0, step: 1e-5 });
          }
        }
        const Zc = i.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_rainParticleData", components: 4 }]);
        class Ch {
          registerParameter() {
          }
          registerButton() {
          }
          registerBinding() {
          }
          refreshUI() {
          }
        }
        class Ya {
          constructor(t, n) {
            this.revealStart = 11, this.revealRange = 2, t.registerParameter(this, [...n, "Reveal"], "revealStart", { min: 0, max: 17, step: 0.05 }), t.registerParameter(this, [...n, "Reveal"], "revealRange", { min: 0.1, max: 5.1, step: 0.05 });
          }
        }
        const Ah = i.da([{ type: "Float32", name: "a_pos_2f", components: 2 }]);
        class Mh {
          destroy() {
            this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();
          }
          draw(t, n) {
            const c = t.getOrCreateProgram("vignette");
            if (!this.vignetteVx || !this.vignetteIdx) {
              const C = new i.dr(), V = new i.aU();
              C.emplaceBack(-1, -1), C.emplaceBack(1, -1), C.emplaceBack(1, 1), C.emplaceBack(-1, 1), V.emplaceBack(0, 1, 2), V.emplaceBack(0, 2, 3), this.vignetteVx = t.context.createVertexBuffer(C, Ah.members), this.vignetteIdx = t.context.createIndexBuffer(V);
            }
            const p = i.b7.simpleSegment(0, 0, 4, 6);
            if (this.vignetteVx && this.vignetteIdx) {
              t.uploadCommonUniforms(t.context, c);
              const C = { u_vignetteShape: (v = { vignetteShape: [n.start, n.range, Math.pow(10, n.fadePower)], vignetteColor: [n.color.r, n.color.g, n.color.b, n.color.a * n.strength] }).vignetteShape, u_vignetteColor: v.vignetteColor };
              c.draw(t, t.context.gl.TRIANGLES, Sr.disabled, Lr.disabled, zr.alphaBlended, kr.disabled, C, "vignette", this.vignetteVx, this.vignetteIdx, p, {});
            }
            var v;
          }
        }
        class hc {
          constructor() {
            this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
          }
          update(t, n) {
            const c = t.getFreeCameraOptions().position, p = c.toAltitude(), v = c.toLngLat(), C = i.ai(v.lng), V = i.ai(v.lat), K = t.pixelsPerMeter / n, se = C * i.ds, oe = i.ds * Math.log(Math.tan(Math.PI / 4 + V / 2));
            if (this._offsetXPrev === void 0) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
            else {
              const ve = -this._offsetYPrev + oe, xe = -this._elevationPrev + p;
              this._accumulatedOffsetX += (-this._offsetXPrev + se) * K, this._accumulatedOffsetY += ve * K, this._accumulatedElevation += xe * K, this._offsetXPrev = se, this._offsetYPrev = oe, this._elevationPrev = p;
            }
          }
          getPosition() {
            return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation];
          }
        }
        function Sl(u, t) {
          return [-(u[0] - Math.floor(u[0] / t) * t), -(u[1] - Math.floor(u[1] / t) * t), -(u[2] - Math.floor(u[2] / t) * t)];
        }
        function $c(u) {
          const t = i.di(1323123451230), n = [];
          for (let c = 0; c < u; ++c) {
            const p = 2 * t() - 1, v = 2 * t() - 1, C = 2 * t() - 1;
            n.push(i.ab.vec3.fromValues(p, v, C));
          }
          return n;
        }
        function ko(u, t, n, c, p) {
          const v = i.aw((p - n) / (c - n), 0, 1);
          return (1 - v) * u + v * t;
        }
        class Xl {
          constructor(t) {
            this._movement = new hc(), this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new Mh(), this._ppmScaleFactor = t;
          }
          destroy() {
            this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();
          }
          updateOnRender(t, n) {
            const c = t.transform;
            this._movement.update(c, this._ppmScaleFactor);
            const p = c.starsProjMatrix, v = i.ab.quat.identity([]);
            i.ab.quat.rotateX(v, v, i.ai(90) - c._pitch), i.ab.quat.rotateZ(v, v, -c.angle);
            const C = i.ab.mat4.fromQuat(new Float32Array(16), v), V = i.ab.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), K = i.ab.mat4.transpose([], V), se = i.ab.mat4.multiply([], K, C), oe = Date.now() / 1e3;
            return this._accumulatedTimeFromStart += (oe - this._prevTime) * n, this._prevTime = oe, { projectionMatrix: p, modelviewMatrix: se };
          }
        }
        class Ru extends Xl {
          constructor(t) {
            super(4.25), this._params = { overrideStyleParameters: !1, intensity: 0.5, timeFactor: 1, velocityConeAperture: 0, velocity: 300, boxSize: 2500, dropletSizeX: 1, dropletSizeYScale: 10, distortionStrength: 70, screenThinning: { intensity: 0.57, start: 0.46, range: 1.17, fadePower: 0.17, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 0.66, g: 0.68, b: 0.74, a: 0.7 }, direction: { x: -50, y: -35 }, shapeDirPower: 2, shapeNormalPower: 1 }, this._revealParams = new Ya(t.tp, ["Precipitation", "Rain"]), this._vignetteParams = { strength: 1, start: 0.7, range: 1, fadePower: 0.4, color: { r: 0.27, g: 0.27, b: 0.27, a: 1 } }, this.particlesCount = 16e3;
          }
          update(t) {
            const n = t.context;
            if (!this.particlesVx) {
              const c = $c(this.particlesCount), p = new i.dt(), v = new i.aU();
              let C = 0;
              const V = i.di(1323123451230);
              for (let K = 0; K < c.length; ++K) {
                const se = c[K], oe = [2 * V() - 1, V(), V(), V()];
                p.emplaceBack(se[0], se[1], se[2], -1, -1, ...oe), p.emplaceBack(se[0], se[1], se[2], 1, -1, ...oe), p.emplaceBack(se[0], se[1], se[2], 1, 1, ...oe), p.emplaceBack(se[0], se[1], se[2], -1, 1, ...oe), v.emplaceBack(C + 0, C + 1, C + 2), v.emplaceBack(C + 0, C + 2, C + 3), C += 4;
              }
              this.particlesVx = n.createVertexBuffer(p, Zc.members), this.particlesIdx = n.createIndexBuffer(v);
            }
          }
          draw(t) {
            if (!this._params.overrideStyleParameters && !t.style.rain) return;
            const n = this._params.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, c = t.transform.zoom;
            if (n.revealStart > c) return;
            const p = ko(0, 1, n.revealStart, n.revealStart + n.revealRange, c);
            if (!this.particlesVx || !this.particlesIdx) return;
            const v = structuredClone(this._params);
            let C = [-v.direction.x, v.direction.y, -100];
            i.ab.vec3.normalize(C, C);
            const V = structuredClone(this._vignetteParams);
            V.strength *= p, v.overrideStyleParameters || (v.intensity = t.style.rain.state.density, v.timeFactor = t.style.rain.state.intensity, v.color = structuredClone(t.style.rain.state.color), C = structuredClone(t.style.rain.state.direction), v.screenThinning.intensity = t.style.rain.state.centerThinning, v.dropletSizeX = t.style.rain.state.dropletSize[0], v.dropletSizeYScale = t.style.rain.state.dropletSize[1] / t.style.rain.state.dropletSize[0], v.distortionStrength = 100 * t.style.rain.state.distortionStrength, V.strength = 1, V.color = structuredClone(t.style.rain.state.vignetteColor));
            const K = this.updateOnRender(t, v.timeFactor), se = t.context, oe = se.gl, ve = t.transform;
            this.screenTexture && this.screenTexture.size[0] === t.width && this.screenTexture.size[1] === t.height || (this.screenTexture = new i.T(se, { width: t.width, height: t.height, data: null }, oe.RGBA8)), v.distortionStrength > 0 && (se.activeTexture.set(oe.TEXTURE0), this.screenTexture.bind(oe.LINEAR, oe.CLAMP_TO_EDGE), oe.copyTexSubImage2D(oe.TEXTURE_2D, 0, 0, 0, 0, 0, t.width, t.height));
            const xe = t.getOrCreateProgram("rainParticle");
            t.uploadCommonUniforms(se, xe), se.activeTexture.set(oe.TEXTURE0), this.screenTexture.bind(oe.LINEAR, oe.CLAMP_TO_EDGE);
            const Le = [v.color.r, v.color.g, v.color.b, v.color.a], ft = (st, vt) => {
              const gt = Sl(this._movement.getPosition(), st), Rt = v.dropletSizeX, qt = v.dropletSizeX * v.dropletSizeYScale, jt = t.width / 2, ii = t.height / 2, Xt = ko(0, v.screenThinning.start, 0, 1, v.screenThinning.intensity), Kt = ko(1e-3, v.screenThinning.range, 0, 1, v.screenThinning.intensity), Zt = ko(0, v.screenThinning.particleOffset, 0, 1, v.screenThinning.intensity), Jt = (ui = { modelview: K.modelviewMatrix, projection: K.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: gt, velocityConeAperture: v.velocityConeAperture, velocity: v.velocity, boxSize: st, rainDropletSize: [Rt, qt], distortionStrength: v.distortionStrength, rainDirection: C, color: Le, screenSize: [ve.width, ve.height], thinningCenterPos: [jt, ii], thinningShape: [Xt, Kt, Math.pow(10, v.screenThinning.fadePower)], thinningAffectedRatio: v.screenThinning.affectedRatio, thinningParticleOffset: Zt, shapeDirectionalPower: v.shapeDirPower, shapeNormalPower: v.shapeNormalPower, mode: vt ? 0 : 1 }, { u_modelview: Float32Array.from(ui.modelview), u_projection: Float32Array.from(ui.projection), u_time: ui.time, u_cam_pos: ui.camPos, u_texScreen: 0, u_velocityConeAperture: ui.velocityConeAperture, u_velocity: ui.velocity, u_boxSize: ui.boxSize, u_rainDropletSize: ui.rainDropletSize, u_distortionStrength: ui.distortionStrength, u_rainDirection: ui.rainDirection, u_color: ui.color, u_screenSize: ui.screenSize, u_thinningCenterPos: ui.thinningCenterPos, u_thinningShape: ui.thinningShape, u_thinningAffectedRatio: ui.thinningAffectedRatio, u_thinningParticleOffset: ui.thinningParticleOffset, u_shapeDirectionalPower: ui.shapeDirectionalPower, u_shapeNormalPower: ui.shapeNormalPower, u_mode: ui.mode });
              var ui;
              const Ti = Math.round(v.intensity * this.particlesCount), xi = i.b7.simpleSegment(0, 0, 4 * Ti, 2 * Ti);
              xe.draw(t, oe.TRIANGLES, Sr.disabled, Lr.disabled, zr.alphaBlended, kr.disabled, Jt, "rain_particles", this.particlesVx, this.particlesIdx, xi, {});
            };
            v.distortionStrength > 0 && ft(v.boxSize, !0), ft(v.boxSize, !1), this._vignette.draw(t, V);
          }
        }
        const fc = i.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_snowParticleData", components: 4 }, { type: "Float32", name: "a_snowParticleDataHorizontalOscillation", components: 2 }]);
        class dc extends Xl {
          constructor(t) {
            super(2.25), this._params = { overrideStyleParameters: !1, intensity: 0.85, timeFactor: 0.75, velocityConeAperture: 70, velocity: 40, horizontalOscillationRadius: 4, horizontalOscillationRate: 1.5, boxSize: 2e3, billboardSize: 2, shapeFadeStart: 0.27, shapeFadePower: 0.21, screenThinning: { intensity: 0.4, start: 0.15, range: 1.4, fadePower: 0.24, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 1, g: 1, b: 1, a: 1 }, direction: { x: -50, y: -35 } }, this._revealParams = new Ya(t.tp, ["Precipitation", "Snow"]), this._vignetteParams = { strength: 0.3, start: 0.78, range: 0.46, fadePower: 0.2, color: { r: 1, g: 1, b: 1, a: 1 } }, this.particlesCount = 16e3;
          }
          update(t) {
            const n = t.context;
            if (!this.particlesVx) {
              const c = $c(this.particlesCount), p = new i.du(), v = new i.aU();
              let C = 0;
              const V = i.di(1323123451230);
              for (let K = 0; K < c.length; ++K) {
                const se = c[K], oe = V(), ve = V(), xe = V(), Le = [K / c.length, oe, ve, xe], ft = [V(), V()];
                p.emplaceBack(se[0], se[1], se[2], -1, -1, ...Le, ...ft), p.emplaceBack(se[0], se[1], se[2], 1, -1, ...Le, ...ft), p.emplaceBack(se[0], se[1], se[2], 1, 1, ...Le, ...ft), p.emplaceBack(se[0], se[1], se[2], -1, 1, ...Le, ...ft), v.emplaceBack(C + 0, C + 1, C + 2), v.emplaceBack(C + 0, C + 2, C + 3), C += 4;
              }
              this.particlesVx = n.createVertexBuffer(p, fc.members), this.particlesIdx = n.createIndexBuffer(v);
            }
          }
          draw(t) {
            if (!this._params.overrideStyleParameters && !t.style.snow) return;
            const n = structuredClone(this._params);
            let c = [-n.direction.x, n.direction.y, -100];
            i.ab.vec3.normalize(c, c);
            const p = structuredClone(this._vignetteParams), v = n.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, C = t.transform.zoom;
            if (v.revealStart > C) return;
            const V = ko(0, 1, v.revealStart, v.revealStart + v.revealRange, C);
            p.strength *= V, n.overrideStyleParameters || (n.intensity = t.style.snow.state.density, n.timeFactor = t.style.snow.state.intensity, n.color = structuredClone(t.style.snow.state.color), c = structuredClone(t.style.snow.state.direction), n.screenThinning.intensity = t.style.snow.state.centerThinning, n.billboardSize = 2.79 * t.style.snow.state.flakeSize, p.strength = 1, p.color = structuredClone(t.style.snow.state.vignetteColor));
            const K = this.updateOnRender(t, n.timeFactor);
            if (!this.particlesVx || !this.particlesIdx) return;
            const se = t.context, oe = se.gl, ve = t.transform, xe = t.getOrCreateProgram("snowParticle");
            t.uploadCommonUniforms(se, xe), ((Le, ft, st) => {
              const vt = Sl(this._movement.getPosition(), Le), gt = ve.width / 2, Rt = ve.height / 2, qt = ko(0, st.screenThinning.start, 0, 1, st.screenThinning.intensity), jt = ko(1e-3, st.screenThinning.range, 0, 1, st.screenThinning.intensity), ii = ko(0, st.screenThinning.particleOffset, 0, 1, st.screenThinning.intensity), Xt = (Kt = { modelview: K.modelviewMatrix, projection: K.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: vt, velocityConeAperture: st.velocityConeAperture, velocity: st.velocity, horizontalOscillationRadius: st.horizontalOscillationRadius, horizontalOscillationRate: st.horizontalOscillationRate, boxSize: Le, billboardSize: 1 * st.billboardSize, simpleShapeParameters: [st.shapeFadeStart, st.shapeFadePower], screenSize: [ve.width, ve.height], thinningCenterPos: [gt, Rt], thinningShape: [qt, jt, Math.pow(10, st.screenThinning.fadePower)], thinningAffectedRatio: st.screenThinning.affectedRatio, thinningParticleOffset: ii, color: [st.color.r, st.color.g, st.color.b, st.color.a], direction: c }, { u_modelview: Float32Array.from(Kt.modelview), u_projection: Float32Array.from(Kt.projection), u_time: Kt.time, u_cam_pos: Kt.camPos, u_velocityConeAperture: Kt.velocityConeAperture, u_velocity: Kt.velocity, u_horizontalOscillationRadius: Kt.horizontalOscillationRadius, u_horizontalOscillationRate: Kt.horizontalOscillationRate, u_boxSize: Kt.boxSize, u_billboardSize: Kt.billboardSize, u_simpleShapeParameters: Kt.simpleShapeParameters, u_screenSize: Kt.screenSize, u_thinningCenterPos: Kt.thinningCenterPos, u_thinningShape: Kt.thinningShape, u_thinningAffectedRatio: Kt.thinningAffectedRatio, u_thinningParticleOffset: Kt.thinningParticleOffset, u_particleColor: Kt.color, u_direction: Kt.direction });
              var Kt;
              const Zt = Math.round(st.intensity * this.particlesCount), Jt = i.b7.simpleSegment(0, 0, 4 * Zt, 2 * Zt);
              this.particlesVx && this.particlesIdx && xe.draw(t, oe.TRIANGLES, Sr.disabled, Lr.disabled, zr.alphaBlended, kr.disabled, Xt, "snow_particles", this.particlesVx, this.particlesIdx, Jt, {});
            })(n.boxSize, 0, n), this._vignette.draw(t, p);
          }
        }
        const pc = { symbol: function(u, t, n, c, p) {
          if (u.renderPass !== "translucent") return;
          const v = Lr.disabled, C = u.colorModeForRenderPass(), V = n.layout.get("text-variable-anchor"), K = n.layout.get("text-size-scale-range"), se = i.aw(u.scaleFactor, K[0], K[1]);
          V && function(xe, Le, ft, st, vt, gt, Rt, qt) {
            const jt = Le.transform, ii = vt === "map", Xt = gt === "map";
            for (const Kt of xe) {
              const Zt = st.getTile(Kt), Jt = Zt.getBucket(ft);
              if (!Jt || !Jt.text || !Jt.text.segments.get().length) continue;
              const ui = i.bp(Jt.textSizeData, jt.zoom, qt), Ti = aa(Kt, Jt.getProjection(), jt), xi = jt.calculatePixelsToTileUnitsMatrix(Zt), Pi = Hn(Ti, Zt.tileID.canonical, Xt, ii, jt, Jt.getProjection(), xi), Ri = Jt.hasIconTextFit() && Jt.hasIconData();
              if (ui) {
                const mi = Math.pow(2, jt.zoom - Zt.tileID.overscaledZ);
                Gc(Jt, ii, Xt, Rt, i.cX, jt, Pi, Kt, mi, ui, Ri);
              }
            }
          }(c, u, n, t, n.layout.get("text-rotation-alignment"), n.layout.get("text-pitch-alignment"), p, se);
          const oe = n.paint.get("icon-opacity").constantOr(1) !== 0, ve = n.paint.get("text-opacity").constantOr(1) !== 0;
          n.layout.get("symbol-sort-key").constantOr(1) !== void 0 && (oe || ve) ? jl(u, t, n, c, v, C) : (oe && jl(u, t, n, c, v, C, { onlyIcons: !0 }), ve && jl(u, t, n, c, v, C, { onlyText: !0 })), t.map.showCollisionBoxes && (Eu(u, t, n, c, n.paint.get("text-translate"), n.paint.get("text-translate-anchor"), !0), Eu(u, t, n, c, n.paint.get("icon-translate"), n.paint.get("icon-translate-anchor"), !1));
        }, circle: function(u, t, n, c) {
          if (u.renderPass !== "translucent") return;
          const p = n.paint.get("circle-opacity"), v = n.paint.get("circle-stroke-width"), C = n.paint.get("circle-stroke-opacity"), V = n.layout.get("circle-sort-key").constantOr(1) !== void 0, K = n.paint.get("circle-emissive-strength");
          if (p.constantOr(1) === 0 && (v.constantOr(1) === 0 || C.constantOr(1) === 0)) return;
          const se = u.context, oe = se.gl, ve = u.transform, xe = u.depthModeForSublayer(0, Sr.ReadOnly), Le = Lr.disabled, ft = u.colorModeForDrapableLayerRenderPass(K), st = ve.projection.name === "globe", vt = [i.at(ve.center.lng), i.aA(ve.center.lat)], gt = [];
          for (let qt = 0; qt < c.length; qt++) {
            const jt = c[qt], ii = t.getTile(jt), Xt = ii.getBucket(n);
            if (!Xt || Xt.projection.name !== ve.projection.name) continue;
            const Kt = Xt.programConfigurations.get(n.id), Zt = i.cY(n), Jt = u.isTileAffectedByFog(jt);
            st && Zt.push("PROJECTION_GLOBE_VIEW"), Zt.push("DEPTH_D24"), u.terrain && ve.depthOcclusionForSymbolsAndCircles && Zt.push("DEPTH_OCCLUSION");
            const ui = u.getOrCreateProgram("circle", { config: Kt, defines: Zt, overrideFog: Jt }), Ti = Xt.layoutVertexBuffer, xi = Xt.globeExtVertexBuffer, Pi = Xt.indexBuffer, Ri = ve.projection.createInversionMatrix(ve, jt.canonical), mi = { programConfiguration: Kt, program: ui, layoutVertexBuffer: Ti, globeExtVertexBuffer: xi, indexBuffer: Pi, uniformValues: i.cZ(u, jt, ii, Ri, vt, n), tile: ii };
            if (V) {
              const Ai = Xt.segments.get();
              for (const ji of Ai) gt.push({ segments: new i.b7([ji]), sortKey: ji.sortKey, state: mi });
            } else gt.push({ segments: Xt.segments, sortKey: 0, state: mi });
          }
          V && gt.sort((qt, jt) => qt.sortKey - jt.sortKey);
          const Rt = { useDepthForOcclusion: ve.depthOcclusionForSymbolsAndCircles };
          for (const qt of gt) {
            const { programConfiguration: jt, program: ii, layoutVertexBuffer: Xt, globeExtVertexBuffer: Kt, indexBuffer: Zt, uniformValues: Jt, tile: ui } = qt.state, Ti = qt.segments;
            u.terrain && u.terrain.setupElevationDraw(ui, ii, Rt), u.uploadCommonUniforms(se, ii, ui.tileID.toUnwrapped()), ii.draw(u, oe.TRIANGLES, xe, Le, ft, kr.disabled, Jt, n.id, Xt, Zt, Ti, n.paint, ve.zoom, jt, [Kt]);
          }
        }, heatmap: function(u, t, n, c) {
          if (n.paint.get("heatmap-opacity") !== 0) if (u.renderPass === "offscreen") {
            const p = u.context, v = p.gl, C = Lr.disabled, V = new zr([v.ONE, v.ONE, v.ONE, v.ONE], i.aj.transparent, [!0, !0, !0, !0]);
            (function(Le, ft, st, vt) {
              const gt = Le.gl, Rt = ft.width * vt, qt = ft.height * vt;
              Le.activeTexture.set(gt.TEXTURE1), Le.viewport.set([0, 0, Rt, qt]);
              let jt = st.heatmapFbo;
              if (!jt || jt && (jt.width !== Rt || jt.height !== qt)) {
                jt && jt.destroy();
                const ii = gt.createTexture();
                gt.bindTexture(gt.TEXTURE_2D, ii), gt.texParameteri(gt.TEXTURE_2D, gt.TEXTURE_WRAP_S, gt.CLAMP_TO_EDGE), gt.texParameteri(gt.TEXTURE_2D, gt.TEXTURE_WRAP_T, gt.CLAMP_TO_EDGE), gt.texParameteri(gt.TEXTURE_2D, gt.TEXTURE_MIN_FILTER, gt.LINEAR), gt.texParameteri(gt.TEXTURE_2D, gt.TEXTURE_MAG_FILTER, gt.LINEAR), jt = st.heatmapFbo = Le.createFramebuffer(Rt, qt, !0, null), function(Xt, Kt, Zt, Jt, ui, Ti) {
                  const xi = Xt.gl;
                  xi.texImage2D(xi.TEXTURE_2D, 0, Xt.extRenderToTextureHalfFloat ? xi.RGBA16F : xi.RGBA, ui, Ti, 0, xi.RGBA, Xt.extRenderToTextureHalfFloat ? xi.HALF_FLOAT : xi.UNSIGNED_BYTE, null), Jt.colorAttachment.set(Zt);
                }(Le, 0, ii, jt, Rt, qt);
              } else gt.bindTexture(gt.TEXTURE_2D, jt.colorAttachment.get()), Le.bindFramebuffer.set(jt.framebuffer);
            })(p, u, n, u.transform.projection.name === "globe" ? 0.5 : 0.25), p.clear({ color: i.aj.transparent });
            const K = u.transform, se = K.projection.name === "globe", oe = se ? ["PROJECTION_GLOBE_VIEW"] : [], ve = se ? kr.frontCCW : kr.disabled, xe = [i.at(K.center.lng), i.aA(K.center.lat)];
            for (let Le = 0; Le < c.length; Le++) {
              const ft = c[Le];
              if (t.hasRenderableParent(ft)) continue;
              const st = t.getTile(ft), vt = st.getBucket(n);
              if (!vt || vt.projection.name !== K.projection.name) continue;
              const gt = u.isTileAffectedByFog(ft), Rt = vt.programConfigurations.get(n.id), qt = u.getOrCreateProgram("heatmap", { config: Rt, defines: oe, overrideFog: gt }), { zoom: jt } = u.transform;
              u.terrain && u.terrain.setupElevationDraw(st, qt), u.uploadCommonUniforms(p, qt, ft.toUnwrapped());
              const ii = K.projection.createInversionMatrix(K, ft.canonical);
              qt.draw(u, v.TRIANGLES, Sr.disabled, C, V, ve, ur(u, ft, st, ii, xe, jt, n.paint.get("heatmap-intensity")), n.id, vt.layoutVertexBuffer, vt.indexBuffer, vt.segments, n.paint, u.transform.zoom, Rt, se ? [vt.globeExtVertexBuffer] : null);
            }
            p.viewport.set([0, 0, u.width, u.height]);
          } else u.renderPass === "translucent" && (u.context.setColorMode(u.colorModeForRenderPass()), function(p, v) {
            const C = p.context, V = C.gl, K = v.heatmapFbo;
            if (!K) return;
            C.activeTexture.set(V.TEXTURE0), V.bindTexture(V.TEXTURE_2D, K.colorAttachment.get()), C.activeTexture.set(V.TEXTURE1);
            let se = v.colorRampTexture;
            se || (se = v.colorRampTexture = new i.T(C, v.colorRamp, V.RGBA8)), se.bind(V.LINEAR, V.CLAMP_TO_EDGE), p.getOrCreateProgram("heatmapTexture").draw(p, V.TRIANGLES, Sr.disabled, Lr.disabled, p.colorModeForRenderPass(), kr.disabled, ((oe, ve, xe, Le) => ({ u_image: 0, u_color_ramp: 1, u_opacity: ve.paint.get("heatmap-opacity") }))(0, v), v.id, p.viewportBuffer, p.quadTriangleIndexBuffer, p.viewportSegments, v.paint, p.transform.zoom);
          }(u, n));
        }, line: function(u, t, n, c) {
          if (u.renderPass !== "translucent") return;
          const p = n.paint.get("line-opacity"), v = n.paint.get("line-width");
          if (p.constantOr(1) === 0 || v.constantOr(1) === 0) return;
          const C = n.paint.get("line-emissive-strength"), V = n.paint.get("line-occlusion-opacity"), K = n.layout.get("line-elevation-reference"), se = n.layout.get("line-width-unit") === "meters", oe = K === "sea", ve = u.context, xe = ve.gl;
          if (n.hasElevatedBuckets && u.transform.projection.name === "globe") return;
          const Le = n.layout.get("line-cross-slope"), ft = Le !== void 0, st = Le < 1, vt = u.colorModeForDrapableLayerRenderPass(C), gt = u.terrain && u.terrain.renderingToTexture, Rt = gt ? 1 : i.q.devicePixelRatio, qt = n.paint.get("line-dasharray"), jt = qt.constantOr(1), ii = n.layout.get("line-cap"), Xt = qt.constantOr(null), Kt = ii.constantOr(null), Zt = n.paint.get("line-pattern"), Jt = Zt.constantOr(1), ui = Zt.constantOr(null), Ti = n.paint.get("line-opacity").constantOr(1);
          let xi = !Jt && Ti !== 1 || u.depthOcclusion && V > 0 && V < 1;
          const Pi = n.paint.get("line-gradient"), Ri = Jt ? "linePattern" : "line", mi = i.c_(n);
          let Ai;
          if (gt && u.terrain && u.terrain.clipOrMaskOverlapStencilType() && (xi = !1), V !== 0 && u.depthOcclusion) {
            const yi = n.paint._values["line-opacity"];
            yi && yi.value && yi.value.kind === "constant" ? Ai = yi.value : i.w(`Occlusion opacity for layer ${n.id} is supported only when line-opacity isn't data-driven.`);
          }
          v.value.kind !== "constant" && v.value.isLineProgressConstant === !1 && mi.push("VARIABLE_LINE_WIDTH");
          const ji = (yi, Ni, Mi, Yi, Ui) => {
            for (const Fi of yi) {
              const Zi = t.getTile(Fi);
              if (Jt && !Zi.patternsLoaded()) continue;
              const ir = Zi.getBucket(n);
              if (!ir || ir.hasZOffset && !Ui || !ir.hasZOffset && Ui) continue;
              u.prepareDrawTile();
              const cr = ir.programConfigurations.get(n.id), fr = u.isTileAffectedByFog(Fi), Or = u.getOrCreateProgram(Ri, { config: cr, defines: Ni, overrideFog: fr, overrideRtt: !Ui && void 0 });
              if (ui && Zi.imageAtlas) {
                const Nr = i.A.from(ui).getPrimary().scaleSelf(Rt).serialize(), Jr = Zi.imageAtlas.patternPositions[Nr];
                Jr && cr.setConstantPatternPositions(Jr);
              }
              if (!Jt && Xt && Kt && Zi.lineAtlas) {
                const Nr = Zi.lineAtlas.getDash(Xt, Kt);
                Nr && cr.setConstantPatternPositions(Nr);
              }
              let [Er, Ar] = n.paint.get("line-trim-offset");
              (Kt === "round" || Kt === "square") && Er !== Ar && (Er === 0 && (Er -= 1), Ar === 1 && (Ar += 1));
              const Fr = gt ? Fi.projMatrix : null, an = se ? 1 / ir.tileToMeter / i.ar(Zi, 1, u.transform.zoom) : 1, yn = se ? 1 / ir.tileToMeter / i.ar(Zi, 1, Math.floor(u.transform.zoom)) : 1, $n = Jt ? i.c$(u, Zi, n, Fr, Rt, an, yn, [Er, Ar]) : i.d0(u, Zi, n, Fr, ir.lineClipsArray.length, Rt, an, yn, [Er, Ar]);
              if (Pi) {
                const Nr = ir.gradients[n.id];
                let Jr = Nr.texture;
                if (n.gradientVersion !== Nr.version) {
                  let mr = 256;
                  if (n.stepInterpolant) {
                    const nn = t.getSource().maxzoom, pn = Fi.canonical.z === nn ? Math.ceil(1 << u.transform.maxZoom - Fi.canonical.z) : 1;
                    mr = i.aw(i.d1(ir.maxLineLength / i.ag * 1024 * pn), 256, ve.maxTextureSize);
                  }
                  Nr.gradient = i.d2({ expression: n.gradientExpression(), evaluationKey: "lineProgress", resolution: mr, image: Nr.gradient || void 0, clips: ir.lineClipsArray }), Nr.texture ? Nr.texture.update(Nr.gradient) : Nr.texture = new i.T(ve, Nr.gradient, xe.RGBA8), Nr.version = n.gradientVersion, Jr = Nr.texture;
                }
                ve.activeTexture.set(xe.TEXTURE1), Jr.bind(n.stepInterpolant ? xe.NEAREST : xe.LINEAR, xe.CLAMP_TO_EDGE);
              }
              jt && (ve.activeTexture.set(xe.TEXTURE0), Zi.lineAtlasTexture && Zi.lineAtlasTexture.bind(xe.LINEAR, xe.REPEAT), cr.updatePaintBuffers()), Jt && (ve.activeTexture.set(xe.TEXTURE0), Zi.imageAtlasTexture && Zi.imageAtlasTexture.bind(xe.LINEAR, xe.CLAMP_TO_EDGE), cr.updatePaintBuffers()), Ui && !oe && u.terrain.setupElevationDraw(Zi, Or), u.uploadCommonUniforms(ve, Or, Fi.toUnwrapped());
              const fn = (Nr) => {
                Ai != null && (Ai.value = Ti * V), Or.draw(u, xe.TRIANGLES, Mi, Nr, vt, kr.disabled, $n, n.id, ir.layoutVertexBuffer, ir.indexBuffer, ir.segments, n.paint, u.transform.zoom, cr, [ir.layoutVertexBuffer2, ir.patternVertexBuffer, ir.zOffsetVertexBuffer]), Ai != null && (Ai.value = Ti);
              };
              if (xi && !Ui) {
                const Nr = u.stencilModeForClipping(Fi).ref;
                Nr === 0 && gt && ve.clear({ stencil: 0 });
                const Jr = { func: xe.EQUAL, mask: 255 };
                $n.u_alpha_discard_threshold = 0.8, fn(new Lr(Jr, Nr, 255, xe.KEEP, xe.KEEP, xe.INVERT)), $n.u_alpha_discard_threshold = 0, fn(new Lr(Jr, Nr, 255, xe.KEEP, xe.KEEP, xe.KEEP));
              } else xi && Ui && ($n.u_alpha_discard_threshold = 1e-3), fn(Ui ? Yi : u.stencilModeForClipping(Fi));
            }
          };
          if (n.hasNonElevatedBuckets) {
            const yi = !gt && u.terrain;
            V !== 0 && yi ? i.w(`Occlusion opacity for layer ${n.id} is supported on terrain only if the layer has line-z-offset enabled.`) : yi ? i.w(`Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${n.id}.`) : ji(c, mi, u.depthModeForSublayer(0, Sr.ReadOnly), Lr.disabled, !1);
          }
          if (n.hasElevatedBuckets) {
            mi.push("ELEVATED"), ft && mi.push(st ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), oe && mi.push("ELEVATION_REFERENCE_SEA");
            const yi = xi ? u.stencilModeFor3D() : Lr.disabled, Ni = new Sr(u.depthOcclusion ? xe.GREATER : xe.LEQUAL, Sr.ReadOnly, u.depthRangeFor3D);
            u.forceTerrainMode = !0, ji(c, mi, Ni, yi, !0), u.forceTerrainMode = !1;
          }
          xi && (u.resetStencilClippingMasks(), gt && ve.clear({ stencil: 0 })), V === 0 || u.depthOcclusion || gt || u.layersWithOcclusionOpacity.push(u.currentLayer);
        }, fill: function(u, t, n, c) {
          const p = n.paint.get("fill-color"), v = n.paint.get("fill-opacity"), C = n.is3D(), V = new Sr(u.context.gl.LEQUAL, Sr.ReadWrite, u.depthRangeFor3D);
          if (v.constantOr(1) === 0) return;
          const K = n.paint.get("fill-emissive-strength"), se = u.colorModeForDrapableLayerRenderPass(K), oe = n.paint.get("fill-pattern"), ve = u.opaquePassEnabledForLayer() && !oe.constantOr(1) && p.constantOr(i.aj.transparent).a === 1 && v.constantOr(0) === 1 ? "opaque" : "translucent";
          if (u.renderPass === ve) {
            const xe = C ? V : u.depthModeForSublayer(1, u.renderPass === "opaque" ? Sr.ReadWrite : Sr.ReadOnly);
            Gl(u, t, n, c, xe, se, !1);
          }
          if (!C && u.renderPass === "translucent" && n.paint.get("fill-antialias")) {
            const xe = C ? V : u.depthModeForSublayer(n.getPaintProperty("fill-outline-color") ? 2 : 0, Sr.ReadOnly);
            Gl(u, t, n, c, xe, se, !0);
          }
        }, "fill-extrusion": function(u, t, n, c) {
          const p = n.paint.get("fill-extrusion-opacity"), v = u.context, C = v.gl, V = u.terrain, K = V && V.renderingToTexture;
          if (p === 0) return;
          const se = u.conflationActive && u.style.isLayerClipped(n, t.getSource()), oe = u.style.order.indexOf(n.fqid);
          if (se && function(ve, xe, Le, ft, st) {
            for (const vt of ft) {
              const gt = xe.getTile(vt).getBucket(Le);
              gt && (gt.updateReplacement(vt, ve.replacementSource, st), gt.uploadCentroid(ve.context));
            }
          }(u, t, n, c, oe), V || se) for (const ve of c) {
            const xe = t.getTile(ve).getBucket(n);
            xe && ql(u.context, t, ve, xe, n, V, se);
          }
          if (u.renderPass === "shadow" && u.shadowRenderer) {
            const ve = u.shadowRenderer;
            if (V && p < 0.65 && n._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof i.a9) return;
            const xe = ve.getShadowPassDepthMode(), Le = ve.getShadowPassColorMode();
            Cu(u, t, n, c, xe, Lr.disabled, Le, se);
          } else if (u.renderPass === "translucent") {
            const ve = !n.paint.get("fill-extrusion-pattern").constantOr(1), xe = n.paint.get("fill-extrusion-color").constantOr(i.aj.white);
            if (!K && xe.a !== 0) {
              const Le = new Sr(u.context.gl.LEQUAL, Sr.ReadWrite, u.depthRangeFor3D);
              p === 1 && ve ? Cu(u, t, n, c, Le, Lr.disabled, zr.unblended, se) : (Cu(u, t, n, c, Le, Lr.disabled, zr.disabled, se), Cu(u, t, n, c, Le, u.stencilModeFor3D(), u.colorModeForRenderPass(), se), u.resetStencilClippingMasks());
            }
            if (u.style.enable3dLights() && ve && (!V && u.transform.projection.name !== "globe" || K)) {
              const Le = n.paint.get("fill-extrusion-opacity"), ft = n.paint.get("fill-extrusion-ambient-occlusion-intensity"), st = n.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), vt = n.paint.get("fill-extrusion-flood-light-intensity"), gt = n.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none", Rt = n.paint.get("fill-extrusion-flood-light-color").toRenderColor(gt ? null : n.lut).toArray01().slice(0, 3), qt = ft > 0 && st > 0, jt = vt > 0, ii = (Kt, Zt, Jt) => (1 - Jt) * Kt + Jt * Zt, Xt = (Kt) => {
                const Zt = u.depthModeForSublayer(1, Sr.ReadOnly, C.LEQUAL, !0), Jt = n.paint.get(Kt ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), ui = ii(0.1, 3, Jt), Ti = u._showOverdrawInspector;
                if (!Ti) {
                  const xi = new Lr({ func: C.ALWAYS, mask: 255 }, 255, 255, C.KEEP, C.KEEP, C.REPLACE), Pi = new zr([C.ONE, C.ONE, C.ONE, C.ONE], i.aj.transparent, [!1, !1, !1, !0], C.MIN);
                  Hl(u, t, n, c, Zt, xi, Pi, kr.disabled, Kt, "sdf", Le, ft, st, vt, Rt, ui, se, !1);
                }
                {
                  const xi = Ti ? Lr.disabled : new Lr({ func: C.EQUAL, mask: 255 }, 255, 255, C.KEEP, C.DECR, C.DECR), Pi = Ti ? u.colorModeForRenderPass() : new zr([C.ONE_MINUS_DST_ALPHA, C.DST_ALPHA, C.ONE, C.ONE], i.aj.transparent, [!0, !0, !0, !0]);
                  Hl(u, t, n, c, Zt, xi, Pi, kr.disabled, Kt, "color", Le, ft, st, vt, Rt, ui, se, !1);
                }
              };
              if (K) {
                const Kt = (Zt, Jt, ui) => {
                  const Ti = u.depthModeForSublayer(1, Sr.ReadOnly, C.LEQUAL, !1), xi = n.paint.get(Zt ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), Pi = ii(0.1, 3, xi);
                  {
                    const Ri = new zr([C.ONE, C.ONE, C.ONE, C.ONE], i.aj.transparent, [!1, !1, !1, !0]);
                    Hl(u, t, n, c, Ti, Lr.disabled, Ri, kr.disabled, Zt, "clear", Le, ft, st, vt, Rt, Pi, se, Jt);
                  }
                  {
                    const Ri = new Lr({ func: C.ALWAYS, mask: 255 }, 255, 255, C.KEEP, C.KEEP, C.REPLACE), mi = new zr([C.ONE, C.ONE, C.ONE, C.ONE], i.aj.transparent, [!1, !1, !1, !0], C.MIN);
                    Hl(u, t, n, c, Ti, Ri, mi, kr.disabled, Zt, "sdf", Le, ft, st, vt, Rt, Pi, se, Jt);
                  }
                  {
                    const Ri = Zt ? C.ZERO : C.ONE_MINUS_DST_ALPHA, mi = new Lr({ func: C.EQUAL, mask: 255 }, 255, 255, C.KEEP, C.DECR, C.DECR), Ai = new zr([Ri, C.DST_ALPHA, C.ONE_MINUS_DST_ALPHA, C.ZERO], i.aj.transparent, [!0, !0, !0, !0]);
                    Hl(u, t, n, c, Ti, mi, Ai, kr.disabled, Zt, "color", Le, ft, st, vt, Rt, Pi, se, Jt);
                  }
                  {
                    const Ri = new zr([C.ONE, C.ONE, C.ONE, Zt ? C.ZERO : C.ONE], i.aj.transparent, [!1, !1, !1, !0], Zt ? C.FUNC_ADD : C.MAX);
                    Hl(u, t, n, c, Ti, Lr.disabled, Ri, kr.disabled, Zt, "clear", Le, ft, st, vt, Rt, Pi, se, Jt, ui);
                  }
                };
                if (qt || jt) {
                  let Zt;
                  if (u.prepareDrawTile(), V) {
                    const Jt = V.drapeBufferSize[0], ui = V.drapeBufferSize[1];
                    Zt = V.framebufferCopyTexture, Zt && (!Zt || Zt.size[0] === Jt && Zt.size[1] === ui) || (Zt && Zt.destroy(), Zt = V.framebufferCopyTexture = new i.T(v, new i.r({ width: Jt, height: ui }), C.RGBA8)), Zt.bind(C.LINEAR, C.CLAMP_TO_EDGE), C.copyTexSubImage2D(C.TEXTURE_2D, 0, 0, 0, 0, 0, Jt, ui);
                  }
                  qt && Kt(!0, !1, Zt), jt && Kt(!1, !0, Zt);
                }
              } else qt && Xt(!0), jt && Xt(!1), (qt || jt) && u.resetStencilClippingMasks();
            }
          }
        }, hillshade: function(u, t, n, c) {
          if (u.renderPass !== "offscreen" && u.renderPass !== "translucent" || u.style.disableElevatedTerrain) return;
          const p = u.context, v = u.terrain && u.terrain.renderingToTexture, [C, V] = u.renderPass !== "translucent" || v ? [{}, c] : u.stencilConfigForOverlap(c);
          for (const K of V) {
            const se = t.getTile(K);
            if (se.needsHillshadePrepare && u.renderPass === "offscreen") Oc(u, se, n);
            else if (u.renderPass === "translucent") {
              const oe = u.depthModeForSublayer(0, Sr.ReadOnly), ve = n.paint.get("hillshade-emissive-strength"), xe = u.colorModeForDrapableLayerRenderPass(ve), Le = v && u.terrain ? u.terrain.stencilModeForRTTOverlap(K) : C[K.overscaledZ];
              Rf(u, K, se, n, oe, Le, xe);
            }
          }
          p.viewport.set([0, 0, u.width, u.height]), u.resetStencilClippingMasks();
        }, raster: function(u, t, n, c, p, v) {
          if (u.renderPass !== "translucent" || n.paint.get("raster-opacity") === 0) return;
          const C = u.transform.projection.name === "globe", V = n.paint.get("raster-elevation") !== 0, K = V && C;
          if (u.renderElevatedRasterBackface && !K) return;
          const se = u.context, oe = se.gl, ve = t.getSource(), xe = function(Xt, Kt, Zt, Jt) {
            const ui = Kt.paint.get("raster-color"), Ti = Xt.type === "raster-array", xi = [], Pi = Kt.paint.get("raster-resampling"), Ri = Kt.paint.get("raster-color-mix");
            let mi = Kt.paint.get("raster-color-range");
            const Ai = [Ri[0], Ri[1], Ri[2], 0], ji = Ri[3];
            let yi = Pi === "nearest" ? Jt.NEAREST : Jt.LINEAR;
            if (Ti && (xi.push("RASTER_ARRAY"), ui || xi.push("RASTER_COLOR"), Pi === "linear" && xi.push("RASTER_ARRAY_LINEAR"), yi = Jt.NEAREST, !mi && Xt.rasterLayers)) {
              const Ni = Xt.rasterLayers.find(({ id: Mi }) => Mi === Kt.sourceLayer);
              Ni && Ni.fields && Ni.fields.range && (mi = Ni.fields.range);
            }
            if (mi = mi || [0, 1], ui) {
              xi.push("RASTER_COLOR"), Zt.activeTexture.set(Jt.TEXTURE2), Kt.updateColorRamp(mi);
              let Ni = Kt.colorRampTexture;
              Ni || (Ni = Kt.colorRampTexture = new i.T(Zt, Kt.colorRamp, Jt.RGBA8)), Ni.bind(Jt.LINEAR, Jt.CLAMP_TO_EDGE);
            }
            return { mix: Ai, range: mi, offset: ji, defines: xi, resampling: yi };
          }(ve, n, se, oe);
          if (ve instanceof i.aJ && !c.length && !C) return;
          const Le = n.paint.get("raster-emissive-strength"), ft = u.colorModeForDrapableLayerRenderPass(Le), st = u.terrain && u.terrain.renderingToTexture, vt = !u.options.moving, gt = n.paint.get("raster-resampling") === "nearest" ? oe.NEAREST : oe.LINEAR;
          if (ve instanceof i.aJ && !c.length && (ve.onNorthPole || ve.onSouthPole)) {
            const Xt = V ? u.stencilModeFor3D() : Lr.disabled;
            return void Ei(!!ve.onNorthPole, null, u, t, n, Le, xe, kr.disabled, Xt);
          }
          if (!c.length) return;
          const [Rt, qt] = ve instanceof i.aJ || st ? [{}, c] : u.stencilConfigForOverlap(c), jt = qt[qt.length - 1].overscaledZ;
          K && xe.defines.push("PROJECTION_GLOBE_VIEW"), V && xe.defines.push("RENDER_CUTOFF");
          const ii = (Xt, Kt, Zt) => {
            for (const Jt of Xt) {
              const ui = Jt.toUnwrapped(), Ti = t.getTile(Jt);
              if (st && (!Ti || !Ti.hasData())) continue;
              se.activeTexture.set(oe.TEXTURE0);
              const xi = Ro(Ti, ve, n, xe);
              if (!xi || !xi.texture) continue;
              const { texture: Pi, mix: Ri, offset: mi, tileSize: Ai, buffer: ji } = xi;
              let yi, Ni;
              st ? (yi = Sr.disabled, Ni = Jt.projMatrix) : V ? (yi = new Sr(oe.LEQUAL, Sr.ReadWrite, u.depthRangeFor3D), Ni = C ? Float32Array.from(u.transform.expandedFarZProjMatrix) : u.transform.calculateProjMatrix(ui, vt)) : (yi = u.depthModeForSublayer(Jt.overscaledZ - jt, n.paint.get("raster-opacity") === 1 ? Sr.ReadWrite : Sr.ReadOnly, oe.LESS), Ni = u.transform.calculateProjMatrix(ui, vt));
              const Mi = u.terrain && st ? u.terrain.stencilModeForRTTOverlap(Jt) : Rt[Jt.overscaledZ], Yi = v ? 0 : n.paint.get("raster-fade-duration");
              Ti.registerFadeDuration(Yi);
              const Ui = t.findLoadedParent(Jt, 0), Fi = bo(Ti, Ui, t, u.transform, Yi);
              let Zi, ir;
              u.terrain && u.terrain.prepareDrawTile(), se.activeTexture.set(oe.TEXTURE0), Pi.bind(gt, oe.CLAMP_TO_EDGE), se.activeTexture.set(oe.TEXTURE1), Ui ? (Ui.texture && Ui.texture.bind(gt, oe.CLAMP_TO_EDGE), Zi = Math.pow(2, Ui.tileID.overscaledZ - Ti.tileID.overscaledZ), ir = [Ti.tileID.canonical.x * Zi % 1, Ti.tileID.canonical.y * Zi % 1]) : Pi.bind(gt, oe.CLAMP_TO_EDGE), Pi.useMipmap && se.extTextureFilterAnisotropic && u.transform.pitch > 20 && oe.texParameterf(oe.TEXTURE_2D, se.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, se.extTextureFilterAnisotropicMax);
              const cr = u.transform;
              let fr;
              const Or = V ? Ko(cr) : [0, 0, 0, 0];
              let Er, Ar, Fr, an, yn, $n = 0;
              if (K && ve instanceof i.aJ && ve.coordinates.length > 3) Er = Float32Array.from(i.bb(i.cH(new i.bT(0, 0, 0)))), Ar = Float32Array.from(cr.globeMatrix), Fr = Float32Array.from(i.cD(cr)), an = [i.at(cr.center.lng), i.aA(cr.center.lat)], fr = ve.elevatedGlobePerspectiveTransform, yn = ve.elevatedGlobeGridMatrix || new Float32Array(9);
              else if (K) {
                const mr = i.cE(Jt.canonical);
                $n = i.cF(mr.getCenter().lat), Er = Float32Array.from(i.bb(i.cH(Jt.canonical))), Ar = Float32Array.from(cr.globeMatrix), Fr = Float32Array.from(i.cD(cr)), an = [i.at(cr.center.lng), i.aA(cr.center.lat)], fr = [0, 0], yn = Float32Array.from(i.cG(Jt.canonical, mr, $n, cr.worldSize / cr._pixelsPerMercatorPixel));
              } else fr = ve instanceof i.aJ ? ve.perspectiveTransform : [0, 0], Er = new Float32Array(16), Ar = new Float32Array(9), Fr = new Float32Array(16), an = [0, 0], yn = new Float32Array(9);
              const fn = ws(Ni, Er, Ar, Fr, yn, ir || [0, 0], i.ae(u.transform.zoom), an, Or, Zi || 1, Fi, n, fr, V ? n.paint.get("raster-elevation") : 0, 2, Ri, mi, xe.range, Ai, ji, Le), Nr = u.isTileAffectedByFog(Jt), Jr = u.getOrCreateProgram("raster", { defines: xe.defines, overrideFog: Nr });
              if (u.uploadCommonUniforms(se, Jr, ui), ve instanceof i.aJ) {
                const mr = ve.elevatedGlobeVertexBuffer, nn = ve.elevatedGlobeIndexBuffer;
                if (st || !C) ve.boundsBuffer && ve.boundsSegments && Jr.draw(u, oe.TRIANGLES, yi, Lr.disabled, ft, kr.disabled, fn, n.id, ve.boundsBuffer, u.quadTriangleIndexBuffer, ve.boundsSegments);
                else if (mr && nn) {
                  const pn = cr.zoom <= i.c6 ? ve.elevatedGlobeSegments : ve.getSegmentsForLongitude(cr.center.lng);
                  pn && Jr.draw(u, oe.TRIANGLES, yi, Lr.disabled, ft, Kt, fn, n.id, mr, nn, pn);
                }
              } else if (K) {
                yi = new Sr(oe.LEQUAL, Sr.ReadOnly, u.depthRangeFor3D);
                const mr = u.globeSharedBuffers;
                if (mr) {
                  const [nn, pn, gn] = mr.getGridBuffers($n, !1);
                  Jr.draw(u, oe.TRIANGLES, yi, Zt || Mi, u.colorModeForRenderPass(), Kt, fn, n.id, nn, pn, gn);
                }
              } else {
                const { tileBoundsBuffer: mr, tileBoundsIndexBuffer: nn, tileBoundsSegments: pn } = u.getTileBoundsBuffers(Ti);
                Jr.draw(u, oe.TRIANGLES, yi, Mi, ft, kr.disabled, fn, n.id, mr, nn, pn);
              }
            }
            if (!(ve instanceof i.aJ) && K) for (const Jt of Xt) {
              const ui = Jt.canonical.y === (1 << Jt.canonical.z) - 1;
              Jt.canonical.y === 0 && Ei(!0, Jt, u, t, n, Le, xe, Kt, Zt || Lr.disabled), ui && Ei(!1, Jt, u, t, n, Le, xe, Kt === kr.frontCW ? kr.backCW : kr.frontCW, Zt || Lr.disabled);
            }
          };
          K ? ii(qt, u.renderElevatedRasterBackface ? kr.backCW : kr.frontCW, u.stencilModeFor3D()) : ii(qt, kr.disabled, void 0), u.resetStencilClippingMasks();
        }, "raster-particle": function(u, t, n, c, p, v) {
          u.renderPass === "offscreen" && function(C, V, K, se) {
            if (!se.length) return;
            const oe = C.context, ve = oe.gl, xe = V.getSource();
            if (!(xe instanceof En)) return;
            const Le = Math.ceil(Math.sqrt(K.paint.get("raster-particle-count")));
            let ft = K.particlePositionRGBAImage;
            if (!ft || ft.width !== Le) {
              const qt = function(jt) {
                const ii = jt * jt, Xt = new Uint8Array(4 * ii), Kt = function(Jt) {
                  return Jt |= 0, Jt = Math.imul(2747636419 ^ Jt, 2654435769), Jt = Math.imul(Jt ^ Jt >>> 16, 2654435769), ((Jt = Math.imul(Jt ^ Jt >>> 16, 2654435769)) >>> 0) / 4294967296;
                }, Zt = 1 / 1.1;
                for (let Jt = 0; Jt < ii; Jt++) {
                  const ui = Zt * (Kt(2 * Jt + 0) + wr), Ti = Zt * (Kt(2 * Jt + 1) + wr), xi = 255 * ui % 1, Pi = 255 * Ti % 1, Ri = xi, mi = Ti - Pi / 255, Ai = Pi;
                  Xt[4 * Jt + 0] = 255 * (ui - xi / 255), Xt[4 * Jt + 1] = 255 * Ri, Xt[4 * Jt + 2] = 255 * mi, Xt[4 * Jt + 3] = 255 * Ai;
                }
                return Xt;
              }(Le);
              ft = K.particlePositionRGBAImage = new i.r({ width: Le, height: Le }, qt);
            }
            let st = K.particleFramebuffer;
            st ? st.width !== Le && (st.destroy(), st = K.particleFramebuffer = oe.createFramebuffer(Le, Le, !0, null)) : st = K.particleFramebuffer = oe.createFramebuffer(Le, Le, !0, null);
            const vt = [];
            for (const qt of se) {
              const jt = V.getTile(qt);
              if (!(jt instanceof tn)) continue;
              const ii = Jo(jt, xe, K);
              if (!ii) continue;
              const Xt = [jt.tileSize, jt.tileSize];
              let Kt = K.tileFramebuffer;
              Kt || (Kt = K.tileFramebuffer = oe.createFramebuffer(Xt[0], Xt[1], !0, null));
              let Zt = jt.rasterParticleState;
              Zt || (Zt = jt.rasterParticleState = new of(oe, qt, Xt, ft));
              const Jt = Zt.update(K.lastInvalidatedAt);
              Zt.particleTextureDimension !== Le && Zt.updateParticleTexture(qt, ft);
              const ui = Zt.targetColorTexture;
              Zt.targetColorTexture = Zt.backgroundColorTexture, Zt.backgroundColorTexture = ui;
              const Ti = Zt.particleTexture0;
              Zt.particleTexture0 = Zt.particleTexture1, Zt.particleTexture1 = Ti, vt.push([qt, ii, Zt, Jt]);
            }
            if (vt.length === 0) return;
            const gt = i.q.now(), Rt = K.previousDrawTimestamp ? 1e-3 * (gt - K.previousDrawTimestamp) : 0.0167;
            if (K.previousDrawTimestamp = gt, K.hasColorMap()) {
              oe.activeTexture.set(ve.TEXTURE0 + 2);
              let qt = K.colorRampTexture;
              qt || (qt = K.colorRampTexture = new i.T(oe, K.colorRamp, ve.RGBA8)), qt.bind(ve.LINEAR, ve.CLAMP_TO_EDGE);
            }
            oe.bindFramebuffer.set(K.tileFramebuffer.framebuffer), function(qt, jt, ii) {
              const Xt = qt.context, Kt = Xt.gl, Zt = jt.tileFramebuffer;
              Xt.activeTexture.set(Kt.TEXTURE0);
              const Jt = { u_texture: 0, u_opacity: 1.05 * (Ti = jt.paint.get("raster-particle-fade-opacity-factor")) / (Ti + 0.05) }, ui = qt.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: !1 });
              var Ti;
              for (const xi of ii) {
                const [, , Pi, Ri] = xi;
                Zt.colorAttachment.set(Pi.targetColorTexture.texture), Xt.viewport.set([0, 0, Zt.width, Zt.height]), Xt.clear({ color: i.aj.transparent }), Ri && (Pi.backgroundColorTexture.bind(Kt.NEAREST, Kt.CLAMP_TO_EDGE), ui.draw(qt, Kt.TRIANGLES, Sr.disabled, Lr.disabled, zr.alphaBlended, kr.disabled, Jt, jt.id, qt.viewportBuffer, qt.quadTriangleIndexBuffer, qt.viewportSegments));
              }
            }(C, K, vt), function(qt, jt, ii, Xt) {
              const Kt = qt.context, Zt = Kt.gl, Jt = ii.tileFramebuffer, ui = qt.transform.projection.name === "globe", Ti = ii.paint.get("raster-particle-max-speed");
              for (const xi of Xt) {
                const [Pi, Ri, mi] = xi;
                Kt.activeTexture.set(Zt.TEXTURE0 + 0), Ri.texture.bind(Zt.LINEAR, Zt.CLAMP_TO_EDGE), Jt.colorAttachment.set(mi.targetColorTexture.texture);
                const Ai = qt.getOrCreateProgram("rasterParticleDraw", { defines: Ri.defines, overrideFog: !1 });
                Kt.activeTexture.set(Zt.TEXTURE0 + 1);
                const ji = Ri.scalarData ? [] : [0, 1, 2, 3].map((Mi) => i.d4[Mi](Pi));
                ji.push(Pi);
                const yi = Pi.canonical.x, Ni = Pi.canonical.y;
                for (const Mi of ji) {
                  const Yi = jt.getTile(ui ? Mi.wrapped() : Mi);
                  if (!Yi) continue;
                  const Ui = Yi.rasterParticleState;
                  if (!Ui) continue;
                  const Fi = Mi.canonical.x + (1 << Mi.canonical.z) * (Mi.wrap - Pi.wrap), Zi = Mi.canonical.y;
                  Ui.particleTexture0.bind(Zt.NEAREST, Zt.CLAMP_TO_EDGE);
                  const ir = nf(1, Ui.particleTexture0.size[0], [Fi - yi, Zi - Ni], 0, Ri.texture.size, 2, Ti, Ri.textureOffset, Ri.scale, Ri.offset);
                  Ai.draw(qt, Zt.POINTS, Sr.disabled, Lr.disabled, zr.alphaBlended, kr.disabled, ir, ii.id, Ui.particleIndexBuffer, void 0, Ui.particleSegment);
                }
              }
            }(C, V, K, vt), oe.bindFramebuffer.set(K.particleFramebuffer.framebuffer), function(qt, jt, ii, Xt) {
              const Kt = qt.context, Zt = Kt.gl, Jt = jt.paint.get("raster-particle-max-speed"), ui = Xt * jt.paint.get("raster-particle-speed-factor") * 0.15, Ti = function(Pi) {
                return Math.pow(Pi, 6);
              }(0.01 + 1 * jt.paint.get("raster-particle-reset-rate-factor")), xi = jt.particleFramebuffer;
              Kt.viewport.set([0, 0, xi.width, xi.height]);
              for (const Pi of ii) {
                const [, Ri, mi] = Pi;
                Kt.activeTexture.set(Zt.TEXTURE0 + 0), Ri.texture.bind(Zt.LINEAR, Zt.CLAMP_TO_EDGE), Kt.activeTexture.set(Zt.TEXTURE0 + 1);
                const Ai = mi.particleTexture0;
                Ai.bind(Zt.NEAREST, Zt.CLAMP_TO_EDGE);
                const ji = oo(1, Ai.size[0], 0, Ri.texture.size, Jt, ui, Ti, Ri.textureOffset, Ri.scale, Ri.offset);
                xi.colorAttachment.set(mi.particleTexture1.texture), Kt.clear({ color: i.aj.transparent }), qt.getOrCreateProgram("rasterParticleUpdate", { defines: Ri.defines }).draw(qt, Zt.TRIANGLES, Sr.disabled, Lr.disabled, zr.unblended, kr.disabled, ji, jt.id, qt.viewportBuffer, qt.quadTriangleIndexBuffer, qt.viewportSegments);
              }
            }(C, K, vt, Rt);
          }(u, t, n, c), u.renderPass === "translucent" && (function(C, V, K, se, oe) {
            const ve = C.context, xe = ve.gl, Le = V.getSource().tileSize, ft = 5 * (1 - i.ac(i.bY, i.bY + 1, C.transform.zoom)) * Le + K.paint.get("raster-particle-elevation"), st = !C.options.moving, vt = C.transform.projection.name === "globe";
            if (!se.length) return;
            const [gt, Rt] = C.stencilConfigForOverlap(se), qt = [];
            vt && qt.push("PROJECTION_GLOBE_VIEW");
            const jt = C.stencilModeFor3D();
            for (const ii of Rt) {
              const Xt = ii.toUnwrapped(), Kt = V.getTile(ii);
              if (!Kt.rasterParticleState) continue;
              const Zt = Kt.rasterParticleState, Jt = 100;
              Kt.registerFadeDuration(Jt);
              const ui = V.findLoadedParent(ii, 0), Ti = bo(Kt, ui, V, C.transform, Jt);
              let xi, Pi;
              C.terrain && C.terrain.prepareDrawTile(), ve.activeTexture.set(xe.TEXTURE0), Zt.targetColorTexture.bind(xe.LINEAR, xe.CLAMP_TO_EDGE), ve.activeTexture.set(xe.TEXTURE1), ui && ui.rasterParticleState ? (ui.rasterParticleState.targetColorTexture.bind(xe.LINEAR, xe.CLAMP_TO_EDGE), xi = Math.pow(2, ui.tileID.overscaledZ - Kt.tileID.overscaledZ), Pi = [Kt.tileID.canonical.x * xi % 1, Kt.tileID.canonical.y * xi % 1]) : Zt.targetColorTexture.bind(xe.LINEAR, xe.CLAMP_TO_EDGE);
              const Ri = vt ? Float32Array.from(C.transform.expandedFarZProjMatrix) : C.transform.calculateProjMatrix(Xt, st), mi = C.transform, Ai = xl(mi), ji = i.cE(ii.canonical), yi = i.cF(ji.getCenter().lat);
              let Ni, Mi, Yi, Ui, Fi;
              vt ? (Ni = Float32Array.from(i.bb(i.cH(ii.canonical))), Mi = Float32Array.from(mi.globeMatrix), Yi = Float32Array.from(i.cD(mi)), Ui = [i.at(mi.center.lng), i.aA(mi.center.lat)], Fi = Float32Array.from(i.cG(ii.canonical, ji, yi, mi.worldSize / mi._pixelsPerMercatorPixel))) : (Ni = new Float32Array(16), Mi = new Float32Array(9), Yi = new Float32Array(16), Ui = [0, 0], Fi = new Float32Array(9));
              const Zi = Vc(Ri, Ni, Mi, Yi, Fi, Pi || [0, 0], i.ae(C.transform.zoom), Ui, Ai, xi || 1, Ti, ft), ir = C.isTileAffectedByFog(ii), cr = C.getOrCreateProgram("rasterParticle", { defines: qt, overrideFog: ir });
              if (C.uploadCommonUniforms(ve, cr, Xt), vt) {
                const fr = new Sr(xe.LEQUAL, Sr.ReadOnly, C.depthRangeFor3D), Or = 0, Er = C.globeSharedBuffers;
                if (Er) {
                  const [Ar, Fr, an] = Er.getGridBuffers(yi, Or !== 0);
                  cr.draw(C, xe.TRIANGLES, fr, jt, zr.alphaBlended, C.renderElevatedRasterBackface ? kr.frontCCW : kr.backCCW, Zi, K.id, Ar, Fr, an);
                }
              } else {
                const fr = C.depthModeForSublayer(0, Sr.ReadOnly), Or = gt[ii.overscaledZ], { tileBoundsBuffer: Er, tileBoundsIndexBuffer: Ar, tileBoundsSegments: Fr } = C.getTileBoundsBuffers(Kt);
                cr.draw(C, xe.TRIANGLES, fr, Or, zr.alphaBlended, kr.disabled, Zi, K.id, Er, Ar, Fr);
              }
            }
            C.resetStencilClippingMasks();
          }(u, t, n, c), u.style.map.triggerRepaint());
        }, background: function(u, t, n, c) {
          const p = n.paint.get("background-color"), v = n.paint.get("background-color-use-theme").constantOr("default") === "none", C = n.paint.get("background-opacity"), V = n.paint.get("background-emissive-strength"), K = n.paint.get("background-pitch-alignment") === "viewport";
          if (C === 0) return;
          const se = u.context, oe = se.gl, ve = u.transform, xe = ve.tileSize, Le = n.paint.get("background-pattern");
          let ft;
          if (Le !== void 0 && (Le === null || (ft = u.imageManager.getPattern(Le.toString(), n.scope, u.style.getLut(n.scope)), !ft)))
            return;
          const st = !Le && p.a === 1 && C === 1 && u.opaquePassEnabledForLayer() ? "opaque" : "translucent";
          if (u.renderPass !== st) return;
          const vt = Lr.disabled, gt = u.depthModeForSublayer(0, st === "opaque" ? Sr.ReadWrite : Sr.ReadOnly), Rt = u.colorModeForDrapableLayerRenderPass(V), qt = Le ? "backgroundPattern" : "background";
          let jt, ii = c;
          if (ii || (jt = u.getBackgroundTiles(), ii = Object.values(jt).map((Xt) => Xt.tileID)), Le && (se.activeTexture.set(oe.TEXTURE0), u.imageManager.bind(u.context, n.scope)), K) {
            const Xt = u.getOrCreateProgram(qt, { overrideFog: !1, overrideRtt: !0 }), Kt = new Float32Array(i.ab.mat4.identity([])), Zt = new i.aG(0, 0, 0, 0, 0), Jt = Le ? af(Kt, V, C, u, 0, n.scope, ft, K, { tileID: Zt, tileSize: xe }) : lo(Kt, V, C, p.toRenderColor(v ? null : n.lut));
            Xt.draw(u, oe.TRIANGLES, gt, vt, Rt, kr.disabled, Jt, n.id, u.viewportBuffer, u.quadTriangleIndexBuffer, u.viewportSegments);
          } else for (const Xt of ii) {
            const Kt = u.isTileAffectedByFog(Xt), Zt = u.getOrCreateProgram(qt, { overrideFog: Kt }), Jt = Xt.toUnwrapped(), ui = c ? Xt.projMatrix : u.transform.calculateProjMatrix(Jt);
            u.prepareDrawTile();
            const Ti = t ? t.getTile(Xt) : jt ? jt[Xt.key] : new Ba(Xt, xe, ve.zoom, u), xi = Le ? af(ui, V, C, u, 0, n.scope, ft, K, { tileID: Xt, tileSize: xe }) : lo(ui, V, C, p.toRenderColor(v ? null : n.lut));
            u.uploadCommonUniforms(se, Zt, Jt);
            const { tileBoundsBuffer: Pi, tileBoundsIndexBuffer: Ri, tileBoundsSegments: mi } = u.getTileBoundsBuffers(Ti);
            Zt.draw(u, oe.TRIANGLES, gt, vt, Rt, kr.disabled, xi, n.id, Pi, Ri, mi);
          }
        }, sky: function(u, t, n) {
          const c = u._atmosphere ? i.ae(u.transform.zoom) : 1, p = n.paint.get("sky-opacity") * c;
          if (p === 0) return;
          const v = u.context, C = n.paint.get("sky-type"), V = new Sr(v.gl.LEQUAL, Sr.ReadOnly, [0, 1]), K = u.frameCounter / 1e3 % 1;
          C === "atmosphere" ? u.renderPass === "offscreen" ? n.needsSkyboxCapture(u) && (function(se, oe, ve, xe) {
            const Le = se.context, ft = Le.gl;
            let st = oe.skyboxFbo;
            if (!st) {
              st = oe.skyboxFbo = Le.createFramebuffer(32, 32, !0, null), oe.skyboxGeometry = new wh(Le), oe.skyboxTexture = Le.gl.createTexture(), ft.bindTexture(ft.TEXTURE_CUBE_MAP, oe.skyboxTexture), ft.texParameteri(ft.TEXTURE_CUBE_MAP, ft.TEXTURE_WRAP_S, ft.CLAMP_TO_EDGE), ft.texParameteri(ft.TEXTURE_CUBE_MAP, ft.TEXTURE_WRAP_T, ft.CLAMP_TO_EDGE), ft.texParameteri(ft.TEXTURE_CUBE_MAP, ft.TEXTURE_MIN_FILTER, ft.LINEAR), ft.texParameteri(ft.TEXTURE_CUBE_MAP, ft.TEXTURE_MAG_FILTER, ft.LINEAR);
              for (let qt = 0; qt < 6; ++qt) ft.texImage2D(ft.TEXTURE_CUBE_MAP_POSITIVE_X + qt, 0, ft.RGBA, 32, 32, 0, ft.RGBA, ft.UNSIGNED_BYTE, null);
            }
            Le.bindFramebuffer.set(st.framebuffer), Le.viewport.set([0, 0, 32, 32]);
            const vt = oe.getCenter(se, !0), gt = se.getOrCreateProgram("skyboxCapture"), Rt = new Float64Array(16);
            i.ab.mat4.identity(Rt), i.ab.mat4.rotateY(Rt, Rt, 0.5 * -Math.PI), bn(se, oe, gt, Rt, vt, 0), i.ab.mat4.identity(Rt), i.ab.mat4.rotateY(Rt, Rt, 0.5 * Math.PI), bn(se, oe, gt, Rt, vt, 1), i.ab.mat4.identity(Rt), i.ab.mat4.rotateX(Rt, Rt, 0.5 * -Math.PI), bn(se, oe, gt, Rt, vt, 2), i.ab.mat4.identity(Rt), i.ab.mat4.rotateX(Rt, Rt, 0.5 * Math.PI), bn(se, oe, gt, Rt, vt, 3), i.ab.mat4.identity(Rt), bn(se, oe, gt, Rt, vt, 4), i.ab.mat4.identity(Rt), i.ab.mat4.rotateY(Rt, Rt, Math.PI), bn(se, oe, gt, Rt, vt, 5), Le.viewport.set([0, 0, se.width, se.height]);
          }(u, n), n.markSkyboxValid(u)) : u.renderPass === "sky" && function(se, oe, ve, xe, Le) {
            const ft = se.context, st = ft.gl, vt = se.transform, gt = se.getOrCreateProgram("skybox");
            ft.activeTexture.set(st.TEXTURE0), st.bindTexture(st.TEXTURE_CUBE_MAP, oe.skyboxTexture);
            const Rt = /* @__PURE__ */ ((qt, jt, ii, Xt, Kt) => ({ u_matrix: qt, u_sun_direction: jt, u_cubemap: 0, u_opacity: Xt, u_temporal_offset: Kt }))(vt.skyboxMatrix, oe.getCenter(se, !1), 0, xe, Le);
            se.uploadCommonUniforms(ft, gt), gt.draw(se, st.TRIANGLES, ve, Lr.disabled, se.colorModeForRenderPass(), kr.backCW, Rt, "skybox", oe.skyboxGeometry.vertexBuffer, oe.skyboxGeometry.indexBuffer, oe.skyboxGeometry.segment);
          }(u, n, V, p, K) : C === "gradient" && u.renderPass === "sky" && function(se, oe, ve, xe, Le) {
            const ft = se.context, st = ft.gl, vt = se.transform, gt = se.getOrCreateProgram("skyboxGradient");
            oe.skyboxGeometry || (oe.skyboxGeometry = new wh(ft)), ft.activeTexture.set(st.TEXTURE0);
            let Rt = oe.colorRampTexture;
            Rt || (Rt = oe.colorRampTexture = new i.T(ft, oe.colorRamp, st.RGBA8)), Rt.bind(st.LINEAR, st.CLAMP_TO_EDGE);
            const qt = ((jt, ii, Xt, Kt, Zt) => ({ u_matrix: jt, u_color_ramp: 0, u_center_direction: ii, u_radius: i.ai(Xt), u_opacity: Kt, u_temporal_offset: Zt }))(vt.skyboxMatrix, oe.getCenter(se, !1), oe.paint.get("sky-gradient-radius"), xe, Le);
            se.uploadCommonUniforms(ft, gt), gt.draw(se, st.TRIANGLES, ve, Lr.disabled, se.colorModeForRenderPass(), kr.backCW, qt, "skyboxGradient", oe.skyboxGeometry.vertexBuffer, oe.skyboxGeometry.indexBuffer, oe.skyboxGeometry.segment);
          }(u, n, V, p, K);
        }, debug: function(u, t, n, c, p, v) {
          for (let C = 0; C < n.length; C++) if (p) {
            const se = new i.aj(c.r * 0.8, c.g * 0.8, c.b * 0.8, 1);
            _s(u, t, n[C], c, -1, -1, v), _s(u, t, n[C], c, -1, 1, v), _s(u, t, n[C], c, 1, 1, v), _s(u, t, n[C], c, 1, -1, v), _s(u, t, n[C], se, 0, 0, v);
          } else _s(u, t, n[C], c, 0, 0, v);
        }, custom: function(u, t, n, c) {
          const p = u.context, v = n.implementation;
          if (!u.transform.projection.unsupportedLayers || !u.transform.projection.unsupportedLayers.includes("custom") || u.terrain && (u.terrain.renderingToTexture || u.renderPass === "offscreen") && n.isDraped(t)) {
            if (u.renderPass === "offscreen") {
              const C = v.prerender;
              if (C) {
                if (u.setCustomLayerDefaults(), p.setColorMode(u.colorModeForRenderPass()), u.transform.projection.name === "globe") {
                  const V = u.transform.pointMerc;
                  C.call(v, p.gl, u.transform.customLayerMatrix(), u.transform.getProjection(), u.transform.globeToMercatorMatrix(), i.ae(u.transform.zoom), [V.x, V.y], u.transform.pixelsPerMeterRatio);
                } else C.call(v, p.gl, u.transform.customLayerMatrix());
                p.setDirty(), u.setBaseState();
              }
            } else if (u.renderPass === "translucent") {
              if (u.terrain && u.terrain.renderingToTexture) {
                const V = v.renderToTile;
                if (V) {
                  const K = c[0].canonical, se = new i.aa(K.x + c[0].wrap * (1 << K.z), K.y, K.z);
                  p.setDepthMode(Sr.disabled), p.setStencilMode(Lr.disabled), p.setColorMode(u.colorModeForRenderPass()), u.setCustomLayerDefaults(), V.call(v, p.gl, se), p.setDirty(), u.setBaseState();
                }
                return;
              }
              u.setCustomLayerDefaults(), p.setColorMode(u.colorModeForRenderPass()), p.setStencilMode(Lr.disabled);
              const C = v.renderingMode === "3d" ? new Sr(u.context.gl.LEQUAL, Sr.ReadWrite, u.depthRangeFor3D) : u.depthModeForSublayer(0, Sr.ReadOnly);
              if (p.setDepthMode(C), u.transform.projection.name === "globe") {
                const V = u.transform.pointMerc;
                v.render(p.gl, u.transform.customLayerMatrix(), u.transform.getProjection(), u.transform.globeToMercatorMatrix(), i.ae(u.transform.zoom), [V.x, V.y], u.transform.pixelsPerMeterRatio);
              } else v.render(p.gl, u.transform.customLayerMatrix());
              p.setDirty(), u.setBaseState(), p.bindFramebuffer.set(null);
            }
          } else i.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
        }, model: function(u, t, n, c) {
          if (u.renderPass === "opaque") return;
          const p = n.paint.get("model-opacity").constantOr(1);
          if (p === 0) return;
          const v = n.paint.get("model-cast-shadows");
          if (u.renderPass === "shadow" && (!v || u.terrain && p < 0.65 && n._transitionablePaint._values["model-opacity"].value.expression instanceof i.a9))
            return;
          const C = u.shadowRenderer, V = n.paint.get("model-receive-shadows");
          C && (C.useNormalOffset = !0, V || (C.enabled = !1));
          const K = () => {
            C && (C.useNormalOffset = !0, V || (C.enabled = !0));
          }, se = t.getSource();
          if (u.renderPass === "light-beam" && se.type !== "batched-model") return;
          if (se.type === "vector" || se.type === "geojson") return function(gt, Rt, qt, jt, ii) {
            const Xt = gt.transform;
            if (Xt.projection.name !== "mercator") return void i.w(`Drawing 3D models for ${Xt.projection.name} projection is not yet implemented`);
            const Kt = Xt.getFreeCameraOptions().position;
            if (!gt.modelManager) return;
            const Zt = gt.modelManager;
            qt.modelManager = Zt;
            const Jt = gt.shadowRenderer;
            if (!qt._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
            const ui = qt._unevaluatedLayout._values["model-id"], Ti = Object.assign({}, qt.layout.get("model-id").parameters), xi = gt.style.order.indexOf(qt.fqid);
            for (const Pi of jt) {
              const Ri = Rt.getTile(Pi).getBucket(qt);
              if (!Ri || Ri.projection.name !== Xt.projection.name) continue;
              const mi = Ri.getModelUris();
              mi && !Ri.modelsRequested && (Zt.addModelsFromBucket(mi, ii), Ri.modelsRequested = !0);
              const Ai = Th(Pi, Xt);
              Ti.zoom = Ai;
              const ji = ui.possiblyEvaluate(Ti);
              if ($s(gt, Ri, Pi), Ga.shadowUniformsInitialized = !1, Ga.useSingleShadowCascade = !!Jt && Jt.getMaxCascadeForTile(Pi.toUnwrapped()) === 0, gt.renderPass === "shadow" && Jt) {
                if (gt.currentShadowCascade === 1 && Ri.isInsideFirstShadowMapFrustum) continue;
                const Mi = Xt.calculatePosMatrix(Pi.toUnwrapped(), Xt.worldSize);
                if (Ga.tileMatrix.set(Mi), Ga.shadowTileMatrix = Float32Array.from(Jt.calculateShadowPassMatrixFromMatrix(Mi)), Ga.aabb.min.fill(0), Ga.aabb.max[0] = Ga.aabb.max[1] = i.ag, Ga.aabb.max[2] = 0, Wc(Ri, Ga, gt, qt.scope)) continue;
              }
              const yi = 1 << Pi.canonical.z, Ni = [((Kt.x - Pi.wrap) * yi - Pi.canonical.x) * i.ag, (Kt.y * yi - Pi.canonical.y) * i.ag, Kt.z * yi * i.ag];
              gt.conflationActive && Object.keys(Ri.instancesPerModel).length > 0 && gt.style.isLayerClipped(qt, Rt.getSource()) && Ri.updateReplacement(Pi, gt.replacementSource, xi, ii) && (Ri.uploaded = !1, Ri.upload(gt.context));
              for (let Mi in Ri.instancesPerModel) {
                const Yi = Ri.instancesPerModel[Mi];
                Yi.features.length > 0 && (Mi = ji.evaluate(Yi.features[0].feature, {}));
                const Ui = Zt.getModel(Mi, ii);
                if (Ui && Ui.uploaded) for (const Fi of Ui.nodes) Xa(gt, qt, Fi, Yi, Ni, Pi, Ga);
              }
            }
          }(u, t, n, c, se.type === "vector" ? n.scope : ""), void K();
          if (!se.loaded()) return;
          if (se.type === "batched-model") return function(gt, Rt, qt, jt) {
            qt.resetLayerRenderingStats(gt);
            const ii = gt.context, Xt = gt.transform, Kt = gt.style.fog, Zt = gt.shadowRenderer;
            if (Xt.projection.name !== "mercator") return void i.w(`Drawing 3D landmark models for ${Xt.projection.name} projection is not yet implemented`);
            const Jt = gt.transform.getFreeCameraOptions().position, ui = i.ab.vec3.scale([], [Jt.x, Jt.y, Jt.z], gt.transform.worldSize), Ti = i.ab.vec3.negate([], ui), xi = i.ab.mat4.identity([]), Pi = i.dj(Xt.center.lat, Xt.zoom), Ri = i.ab.mat4.fromScaling([], [1, 1, 1 / Pi]);
            i.ab.mat4.translate(xi, xi, Ti);
            const mi = qt.paint.get("model-opacity").constantOr(1), Ai = new Sr(ii.gl.LEQUAL, Sr.ReadWrite, gt.depthRangeFor3D), ji = new Sr(ii.gl.LEQUAL, Sr.ReadOnly, gt.depthRangeFor3D), yi = new i.cd([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), Ni = gt.renderPass === "shadow", Mi = Ni && Zt ? Zt.getCurrentCascadeFrustum() : Xt.getFrustum(Xt.scaleZoom(Xt.worldSize)), Yi = qt.paint.get("model-front-cutoff"), Ui = Yi[2] < 1, Fi = Ps(gt, qt.paint.get("model-cutoff-fade-range")), Zi = qt.getLayerRenderingStats();
            (function(ir, cr, fr, Or) {
              const Er = ir.terrain ? ir.terrain.exaggeration() : 0, Ar = ir.transform.zoom;
              for (const Fr of Or) {
                const an = cr.getTile(Fr).getBucket(fr);
                an && (ir.conflationActive && an.updateReplacement(Fr, ir.replacementSource), an.evaluateScale(ir, fr), ir.terrain && Er > 0 && an.elevationUpdate(ir.terrain, Er, Fr, fr.source), an.needsReEvaluation(ir, Ar, fr) && an.evaluate(fr));
              }
            })(gt, Rt, qt, jt), function() {
              let ir, cr, fr;
              Ui ? (ir = jt.length - 1, cr = -1, fr = -1) : (ir = 0, cr = jt.length, fr = 1);
              const Or = new Float64Array(16), Er = i.ab.vec3.create(), Ar = new i.P(0, 0);
              for (let Fr = ir; Fr !== cr; Fr += fr) {
                const an = jt[Fr], yn = Rt.getTile(an).getBucket(qt);
                if (!yn || !yn.uploaded) continue;
                let $n = !1;
                Zt && ($n = Zt.getMaxCascadeForTile(an.toUnwrapped()) === 0);
                const fn = Xt.calculatePosMatrix(an.toUnwrapped(), Xt.worldSize), Nr = yn.modelTraits;
                !Ni && Ui && (i.ab.mat4.invert(Or, fn), i.ab.vec3.transformMat4(Er, ui, Or), Ar.x = Er[0], Ar.y = Er[1]);
                const Jr = [];
                for (const mr of yn.getNodesInfo()) {
                  if (mr.hiddenByReplacement || !mr.node.meshes) continue;
                  const nn = mr.node;
                  let pn = 0;
                  gt.terrain && nn.elevation && (pn = nn.elevation * gt.terrain.exaggeration());
                  const gn = (() => {
                    const ln = mr.aabb;
                    return yi.min = [...ln.min], yi.max = [...ln.max], yi.min[2] += pn, yi.max[2] += pn, i.ab.vec3.transformMat4(yi.min, yi.min, fn), i.ab.vec3.transformMat4(yi.max, yi.max, fn), yi;
                  })(), na = mr.evaluatedScale;
                  if (na[0] <= 1 && na[1] <= 1 && na[2] <= 1 && gn.intersects(Mi) === 0) continue;
                  if (!Ni && Ui) {
                    const ln = 0.16666666666666666;
                    mr.cameraCollisionOpacity = ui[0] > gn.min[0] && ui[0] < gn.max[0] && ui[1] > gn.min[1] && ui[1] < gn.max[1] && ui[2] * Pi < gn.max[2] && nn.footprint && i.bA(Ar, nn.footprint) ? Math.max(mr.cameraCollisionOpacity - ln, 0) : Math.min(1, mr.cameraCollisionOpacity + ln);
                  }
                  const ua = [...fn], Ra = nn.anchor ? nn.anchor[0] : 0, Aa = nn.anchor ? nn.anchor[1] : 0;
                  i.ab.mat4.translate(ua, ua, [Ra * (na[0] - 1), Aa * (na[1] - 1), pn]), i.ab.vec3.exactEquals(na, i.dm) || i.ab.mat4.scale(ua, ua, na);
                  const ns = i.ab.mat4.multiply([], ua, nn.matrix), as = i.ab.mat4.multiply([], Xt.expandedFarZProjMatrix, ns), On = i.ab.mat4.multiply([], Xt.expandedFarZProjMatrix, ua), Rn = i.ab.vec4.transformMat4([], [Ra, Aa, pn, 1], as)[2];
                  nn.hidden = !1;
                  let Cn = mi;
                  Ni || (Ui && (Cn *= mr.cameraCollisionOpacity, Cn *= Eo(ua, Xt, mr.aabb, Yi)), Cn *= wl(Fi, Rn)), Cn !== 0 ? Jr.push({ nodeInfo: mr, depth: Rn, opacity: Cn, wvpForNode: as, wvpForTile: On, nodeModelMatrix: ns, tileModelMatrix: ua }) : nn.hidden = !0;
                }
                Ni || Jr.sort((mr, nn) => !Ui || mr.opacity === 1 && nn.opacity === 1 ? mr.depth < nn.depth ? -1 : 1 : mr.opacity === 1 ? -1 : nn.opacity === 1 ? 1 : mr.depth > nn.depth ? -1 : 1);
                for (const mr of Jr) {
                  const nn = mr.nodeInfo, pn = nn.node;
                  let gn = i.ab.mat4.multiply([], Ri, mr.tileModelMatrix);
                  i.ab.mat4.multiply(gn, xi, gn);
                  const na = i.ab.mat4.invert([], gn);
                  i.ab.mat4.transpose(na, na), i.ab.mat4.scale(na, na, qc), gn = i.ab.mat4.multiply(gn, gn, pn.matrix);
                  const ua = gt.renderPass === "light-beam", Ra = qt.paint.get("model-color-use-theme").constantOr("default") === "none", Aa = Nr & i.dp.HasMapboxMeshFeatures, ns = Aa ? 0 : nn.evaluatedRMEA[0][2];
                  for (let as = 0; as < pn.meshes.length; ++as) {
                    const On = pn.meshes[as], Rn = as === pn.lightMeshIndex;
                    let Cn = mr.wvpForNode;
                    if (Rn) {
                      if (!ua && !gt.terrain && gt.shadowRenderer) {
                        gt.currentLayer < gt.firstLightBeamLayer && (gt.firstLightBeamLayer = gt.currentLayer);
                        continue;
                      }
                      Cn = mr.wvpForTile;
                    } else if (ua) continue;
                    const ln = { defines: [] }, ca = [];
                    if (!Ni && Zt && (Zt.useNormalOffset = !!On.normalBuffer), oa(ln.defines, ca, On, gt, Ra ? null : qt.lut), Aa || ln.defines.push("DIFFUSE_SHADED"), $n && ln.defines.push("SHADOWS_SINGLE_CASCADE"), Zi && (Ni ? Zi.numRenderedVerticesInShadowPass += On.vertexArray.length : Zi.numRenderedVerticesInTransparentPass += On.vertexArray.length), Ni) {
                      $l(On, mr.nodeModelMatrix, gt, qt);
                      continue;
                    }
                    let Ha = null;
                    if (Kt) {
                      const Fs = Ds(mr.nodeModelMatrix, gt.transform);
                      if (Ha = new Float32Array(Fs), Xt.projection.name !== "globe") {
                        const po = On.aabb.min, Bn = On.aabb.max, [Bu, Oo] = Kt.getOpacityForBounds(Fs, po[0], po[1], Bn[0], Bn[1]);
                        ln.overrideFog = Bu >= It || Oo >= It;
                      }
                    }
                    const kn = On.material;
                    let fs;
                    kn.occlusionTexture && kn.occlusionTexture.offsetScale && (fs = kn.occlusionTexture.offsetScale, ln.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                    const fo = gt.getOrCreateProgram("model", ln);
                    !Ni && Zt && Zt.setupShadowsFromMatrix(mr.tileModelMatrix, fo, Zt.useNormalOffset), gt.uploadCommonUniforms(ii, fo, null, Ha);
                    const Ka = kn.pbrMetallicRoughness;
                    Ka.metallicFactor = 0.9, Ka.roughnessFactor = 0.5;
                    const Bs = Su(new Float32Array(Cn), new Float32Array(gn), new Float32Array(na), new Float32Array(pn.matrix), gt, mr.opacity, Ka.baseColorFactor.toRenderColor(null), kn.emissiveFactor, Ka.metallicFactor, Ka.roughnessFactor, kn, ns, qt, [0, 0, 0], fs);
                    !Rn && (nn.hasTranslucentParts || mr.opacity < 1) && fo.draw(gt, ii.gl.TRIANGLES, Ai, Lr.disabled, zr.disabled, kr.backCCW, Bs, qt.id, On.vertexBuffer, On.indexBuffer, On.segments, qt.paint, gt.transform.zoom, void 0, ca), fo.draw(gt, ii.gl.TRIANGLES, Rn ? ji : Ai, Lr.disabled, Rn || mr.opacity < 1 || nn.hasTranslucentParts ? zr.alphaBlended : zr.unblended, kr.backCCW, Bs, qt.id, On.vertexBuffer, On.indexBuffer, On.segments, qt.paint, gt.transform.zoom, void 0, ca);
                  }
                }
              }
            }();
          }(u, t, n, c), void K();
          if (se.type !== "model") return;
          const oe = se.getModels(), ve = [], xe = u.transform.getFreeCameraOptions().position, Le = i.ab.vec3.scale([], [xe.x, xe.y, xe.z], u.transform.worldSize);
          i.ab.vec3.negate(Le, Le);
          const ft = [], st = [];
          let vt = 0;
          for (const gt of oe) {
            const Rt = n.paint.get("model-rotation").constantOr(null), qt = n.paint.get("model-scale").constantOr(null), jt = n.paint.get("model-translation").constantOr(null);
            gt.computeModelMatrix(u, Rt, qt, jt, !0, !0, !1);
            const ii = i.ab.mat4.identity([]), Xt = i.dj(gt.position.lat, u.transform.zoom), Kt = i.ab.mat4.fromScaling([], [1, 1, 1 / Xt]);
            i.ab.mat4.translate(ii, ii, Le), ve.push({ zScaleMatrix: Kt, negCameraPosMatrix: ii });
            for (const Zt of gt.nodes) ja(u.transform, Zt, gt.matrix, u.transform.expandedFarZProjMatrix, vt, ft, st);
            vt++;
          }
          if (ft.sort((gt, Rt) => Rt.depth - gt.depth), u.renderPass !== "shadow") {
            if (p === 1) for (const gt of st) pa(gt, u, n, ve[gt.modelIndex], Lr.disabled, u.colorModeForRenderPass());
            else {
              for (const gt of st) pa(gt, u, n, ve[gt.modelIndex], Lr.disabled, zr.disabled);
              for (const gt of st) pa(gt, u, n, ve[gt.modelIndex], u.stencilModeFor3D(), u.colorModeForRenderPass());
              u.resetStencilClippingMasks();
            }
            for (const gt of ft) pa(gt, u, n, ve[gt.modelIndex], Lr.disabled, u.colorModeForRenderPass());
            K();
          } else {
            for (const gt of st) $l(gt.mesh, gt.nodeModelMatrix, u, n);
            for (const gt of ft) $l(gt.mesh, gt.nodeModelMatrix, u, n);
            K();
          }
        } }, ku = { line: function(u, t, n) {
          if (u.hasElevatedBuckets = !1, u.hasNonElevatedBuckets = !1, u._unevaluatedLayout.getValue("line-elevation-reference") !== void 0 || u._unevaluatedLayout.getValue("line-z-offset") !== void 0) {
            if (t) {
              const c = t.getVisibleCoordinates();
              for (const p of c) {
                const v = t.getTile(p).getBucket(u);
                if (v && (v.hasZOffset ? u.hasElevatedBuckets = !0 : u.hasNonElevatedBuckets = !0, u.hasElevatedBuckets && u.hasNonElevatedBuckets)) break;
              }
            }
          } else u.hasNonElevatedBuckets = !0;
        }, model: function(u, t, n) {
          const c = t.getSource();
          if (!c.loaded()) return;
          if (c.type === "vector" || c.type === "geojson") return void (n.modelManager && n.modelManager.upload(n, c.type === "vector" ? u.scope : ""));
          if (c.type === "batched-model" || c.type !== "model") return;
          const p = c.getModels();
          for (const v of p) v.upload(n.context);
        }, raster: function(u, t, n) {
          const c = t.getSource();
          if (!(c instanceof En && c.loaded())) return;
          const p = u.sourceLayer || c.rasterLayerIds && c.rasterLayerIds[0];
          if (!p) return;
          const v = u.paint.get("raster-array-band") || c.getInitialBand(p);
          if (v == null) return;
          const C = t.getIds().map((V) => t.getTileByID(V));
          for (const V of C) V.updateNeeded(p, v) && c.prepareTile(V, p, v);
        }, "raster-particle": function(u, t, n) {
          const c = t.getSource();
          if (!(c instanceof En && c.loaded())) return;
          const p = u.sourceLayer || c.rasterLayerIds && c.rasterLayerIds[0];
          if (!p) return;
          const v = u.paint.get("raster-particle-array-band") || c.getInitialBand(p);
          if (v == null) return;
          const C = t.getIds().map((V) => t.getTileByID(V));
          for (const V of C) V.updateNeeded(p, v) && c.prepareTile(V, p, v);
        } };
        class Ih {
          constructor(t, n, c, p, v) {
            this.context = new sf(t, n), this.transform = c, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = v, this._timeStamp = i.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = { forceEnablePrecipitation: !1, showTerrainProxyTiles: !1, fpsWindow: 30, continousRedraw: !1, enabledLayers: {} };
            const C = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
            for (const K of C) this._debugParams.enabledLayers[K] = !0;
            v.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
              this.style.map.triggerRepaint();
            }), v.registerParameter(this._debugParams, ["Precipitation"], "forceEnablePrecipitation"), v.registerParameter(this._debugParams, ["FPS"], "fpsWindow", { min: 1, max: 100, step: 1 }), v.registerBinding(this._debugParams, ["FPS"], "continousRedraw", { readonly: !0, label: "continuous redraw" }), v.registerBinding(this, ["FPS"], "_averageFPS", { readonly: !0, label: "value" }), v.registerBinding(this, ["FPS"], "_averageFPS", { readonly: !0, label: "graph", view: "graph", min: 0, max: 200 });
            for (const K of C) v.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], K);
            this.occlusionParams = new cc(v), this.setup(), this.numSublayers = fa.maxUnderzooming + fa.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new i.dv(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new dl(this), this._wireframeDebugCache = new Pu(), this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];
            const V = new i.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0));
            this.emptyDepthTexture = new i.T(this.context, V, t.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = p;
          }
          updateTerrain(t, n) {
            const c = !!t && !!t.terrain && this.transform.projection.supportsTerrain;
            if (!(c || this._terrain && this._terrain.enabled)) return;
            this._terrain || (this._terrain = new Io(this, t));
            const p = this._terrain;
            this.transform.elevation = c ? p : null, p.update(t, this.transform, n), this.transform.elevation && !p.enabled && (this.transform.elevation = null);
          }
          _updateFog(t) {
            const n = t.fog;
            if (!n || this.transform.projection.name === "globe" || n.getOpacity(this.transform.pitch) < 1 || n.properties.get("horizon-blend") < 0.03) return void (this.transform.fogCullDistSq = null);
            const [c, p] = n.getFovAdjustedRange(this.transform._fov);
            if (c > p) return void (this.transform.fogCullDistSq = null);
            const v = c + 0.78 * (p - c);
            this.transform.fogCullDistSq = v * v;
          }
          get terrain() {
            return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
          }
          get forceTerrainMode() {
            return this._forceTerrainMode;
          }
          set forceTerrainMode(t) {
            t && !this._terrain && (this._terrain = new Io(this, this.style)), this._forceTerrainMode = t;
          }
          get shadowRenderer() {
            return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
          }
          get wireframeDebugCache() {
            return this._wireframeDebugCache;
          }
          resize(t, n) {
            if (this.width = t * i.q.devicePixelRatio, this.height = n * i.q.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const c of this.style.order) this.style._mergedLayers[c].resize();
          }
          setup() {
            const t = this.context, n = new i.b4();
            n.emplaceBack(0, 0), n.emplaceBack(i.ag, 0), n.emplaceBack(0, i.ag), n.emplaceBack(i.ag, i.ag), this.tileExtentBuffer = t.createVertexBuffer(n, i.b6.members), this.tileExtentSegments = i.b7.simpleSegment(0, 0, 4, 2);
            const c = new i.b4();
            c.emplaceBack(0, 0), c.emplaceBack(i.ag, 0), c.emplaceBack(0, i.ag), c.emplaceBack(i.ag, i.ag), this.debugBuffer = t.createVertexBuffer(c, i.b6.members), this.debugSegments = i.b7.simpleSegment(0, 0, 4, 5);
            const p = new i.b4();
            p.emplaceBack(-1, -1), p.emplaceBack(1, -1), p.emplaceBack(-1, 1), p.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(p, i.b6.members), this.viewportSegments = i.b7.simpleSegment(0, 0, 4, 2);
            const v = new i.aT();
            v.emplaceBack(0, 0, 0, 0), v.emplaceBack(i.ag, 0, i.ag, 0), v.emplaceBack(0, i.ag, 0, i.ag), v.emplaceBack(i.ag, i.ag, i.ag, i.ag), this.mercatorBoundsBuffer = t.createVertexBuffer(v, i.b9.members), this.mercatorBoundsSegments = i.b7.simpleSegment(0, 0, 4, 2);
            const C = new i.aU();
            C.emplaceBack(0, 1, 2), C.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(C);
            const V = new i.b5();
            for (const se of [0, 1, 3, 2, 0]) V.emplaceBack(se);
            this.debugIndexBuffer = t.createIndexBuffer(V), this.emptyTexture = new i.T(t, new i.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA8), this.identityMat = i.ab.mat4.create();
            const K = this.context.gl;
            this.stencilClearMode = new Lr({ func: K.ALWAYS, mask: 0 }, 0, 255, K.ZERO, K.ZERO, K.ZERO), this.loadTimeStamps.push(performance.now());
          }
          getMercatorTileBoundsBuffers() {
            return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
          }
          getTileBoundsBuffers(t) {
            return t._makeTileBoundsBuffers(this.context, this.transform.projection), t._tileBoundsBuffer ? { tileBoundsBuffer: t._tileBoundsBuffer, tileBoundsIndexBuffer: t._tileBoundsIndexBuffer, tileBoundsSegments: t._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
          }
          clearStencil() {
            const t = this.context.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, t.TRIANGLES, Sr.disabled, this.stencilClearMode, zr.disabled, kr.disabled, ra(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          resetStencilClippingMasks() {
            this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
          }
          _renderTileClippingMasks(t, n, c) {
            if (!n || this.currentStencilSource === n.id || !t.isTileClipped() || !c || c.length === 0) return;
            if (this._tileClippingMaskIDs && !this.terrain) {
              let V = !1;
              for (const K of c) if (this._tileClippingMaskIDs[K.key] === void 0) {
                V = !0;
                break;
              }
              if (!V) return;
            }
            this.currentStencilSource = n.id;
            const p = this.context, v = p.gl;
            this.nextStencilID + c.length > 256 && this.clearStencil(), p.setColorMode(zr.disabled), p.setDepthMode(Sr.disabled);
            const C = this.getOrCreateProgram("clippingMask");
            this._tileClippingMaskIDs = {};
            for (const V of c) {
              const K = n.getTile(V), se = this._tileClippingMaskIDs[V.key] = this.nextStencilID++, { tileBoundsBuffer: oe, tileBoundsIndexBuffer: ve, tileBoundsSegments: xe } = this.getTileBoundsBuffers(K);
              C.draw(this, v.TRIANGLES, Sr.disabled, new Lr({ func: v.ALWAYS, mask: 0 }, se, 255, v.KEEP, v.KEEP, v.REPLACE), zr.disabled, kr.disabled, ra(V.projMatrix), "$clipping", oe, ve, xe);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const t = this.nextStencilID++, n = this.context.gl;
            return new Lr({ func: n.NOTEQUAL, mask: 255 }, t, 255, n.KEEP, n.KEEP, n.REPLACE);
          }
          stencilModeForClipping(t) {
            if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t);
            const n = this.context.gl;
            return new Lr({ func: n.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, n.KEEP, n.KEEP, n.REPLACE);
          }
          stencilConfigForOverlap(t) {
            const n = this.context.gl, c = t.sort((C, V) => V.overscaledZ - C.overscaledZ), p = c[c.length - 1].overscaledZ, v = c[0].overscaledZ - p + 1;
            if (v > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + v > 256 && this.clearStencil();
              const C = {};
              for (let V = 0; V < v; V++) C[V + p] = new Lr({ func: n.GEQUAL, mask: 255 }, V + this.nextStencilID, 255, n.KEEP, n.KEEP, n.REPLACE);
              return this.nextStencilID += v, [C, c];
            }
            return [{ [p]: Lr.disabled }, c];
          }
          colorModeForRenderPass() {
            const t = this.context.gl;
            return this._showOverdrawInspector ? new zr([t.CONSTANT_COLOR, t.ONE, t.CONSTANT_COLOR, t.ONE], new i.aj(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? zr.unblended : zr.alphaBlended;
          }
          colorModeForDrapableLayerRenderPass(t) {
            const n = this.context.gl;
            return this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture && this.renderPass === "translucent" ? new zr([n.ONE, n.ONE_MINUS_SRC_ALPHA, n.CONSTANT_ALPHA, n.ONE_MINUS_SRC_ALPHA], new i.aj(0, 0, 0, t === void 0 ? 0 : t), [!0, !0, !0, !0]) : this.colorModeForRenderPass();
          }
          depthModeForSublayer(t, n, c, p = !1) {
            if (this.depthOcclusion) return new Sr(this.context.gl.GREATER, Sr.ReadOnly, this.depthRangeFor3D);
            if (!this.opaquePassEnabledForLayer() && !p) return Sr.disabled;
            const v = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
            return new Sr(c || this.context.gl.LEQUAL, n, [v, v]);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          blitDepth() {
            const t = this.context.gl, n = Math.ceil(this.width), c = Math.ceil(this.height), p = this.context.bindFramebuffer.get(), v = t.getParameter(t.TEXTURE_BINDING_2D);
            this.depthFBO && this.depthFBO.width === n && this.depthFBO.height === c || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), n !== 0 && c !== 0 && (this.depthFBO = new jc(this.context, n, c, !1, "texture"), this.depthTexture = new i.T(this.context, { width: n, height: c, data: null }, t.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(p), t.bindTexture(t.TEXTURE_2D, v), this.depthFBO && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t.blitFramebuffer(0, 0, n, c, 0, 0, n, c, t.DEPTH_BUFFER_BIT, t.NEAREST), t.bindFramebuffer(t.FRAMEBUFFER, this.context.bindFramebuffer.current));
          }
          updateAverageFPS() {
            this._fpsHistory.push(this._dt === 0 ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((t, n) => t + n / this._fpsHistory.length, 0));
          }
          render(t, n) {
            const c = i.q.now();
            this._dt = c - this._timeStamp, this._timeStamp = c, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t.map.repaint, this.style = t, this.options = n;
            const p = this.style._mergedLayers, v = !(!this.terrain || !this.terrain.enabled), C = () => this.style._getOrder(v).filter((mi) => {
              const Ai = p[mi];
              return !(Ai.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[Ai.type];
            });
            let V = C(), K = !1, se = !1;
            for (const mi of V) {
              const Ai = p[mi];
              Ai.type === "circle" && (K = !0), Ai.type === "symbol" && (Ai.hasInitialOcclusionOpacityProperties ? se = !0 : K = !0);
            }
            let oe = V.map((mi) => p[mi]);
            const ve = this.style._mergedSourceCaches;
            this.imageManager = t.imageManager, this.modelManager = t.modelManager, this.symbolFadeChange = t.placement.symbolFadeChange(i.q.now()), this.imageManager.beginFrame();
            let xe = 0, Le = !1;
            for (const mi in ve) {
              const Ai = ve[mi];
              Ai.used && (Ai.prepare(this.context), Ai.getSource().usedInConflation && ++xe);
            }
            let ft = !1;
            for (const mi of oe) mi.isHidden(this.transform.zoom) || (mi.type === "clip" && (ft = !0), this.prepareLayer(mi));
            const st = {}, vt = {}, gt = {}, Rt = {}, qt = {};
            for (const mi in ve) {
              const Ai = ve[mi];
              st[mi] = Ai.getVisibleCoordinates(), vt[mi] = st[mi].slice().reverse(), gt[mi] = Ai.getVisibleCoordinates(!0).reverse(), Rt[mi] = Ai.getShadowCasterCoordinates(), qt[mi] = Ai.sortCoordinatesByDistance(st[mi]);
            }
            const jt = (mi) => {
              const Ai = this.style.getLayerSourceCache(mi);
              return Ai && Ai.used ? Ai.getSource() : null;
            };
            if (xe || ft || this._clippingActiveLastFrame) {
              const mi = [], Ai = [];
              let ji = 0;
              for (const yi of oe) this.isSourceForClippingOrConflation(yi, jt(yi)) && (mi.push(yi), Ai.push(ji)), ji++;
              if (ft || mi.length > 1 || this._clippingActiveLastFrame) {
                ft = !1;
                const yi = [];
                for (let Ni = 0; Ni < mi.length; Ni++) {
                  const Mi = mi[Ni], Yi = Ai[Ni], Ui = this.style.getLayerSourceCache(Mi);
                  if (!Ui || !Ui.used || !Ui.getSource().usedInConflation && Mi.type !== "clip") continue;
                  let Fi = i.dx, Zi = i.by.None;
                  const ir = [];
                  let cr = !0;
                  if (Mi.type === "clip") {
                    Fi = Yi;
                    for (const fr of Mi.layout.get("clip-layer-types")) Zi |= fr === "model" ? i.by.Model : fr === "symbol" ? i.by.Symbol : i.by.FillExtrusion;
                    for (const fr of Mi.layout.get("clip-layer-scope")) ir.push(fr);
                    Mi.isHidden(this.transform.zoom) ? cr = !1 : ft = !0;
                  }
                  cr && yi.push({ layer: Mi.fqid, cache: Ui, order: Fi, clipMask: Zi, clipScope: ir });
                }
                this.replacementSource.setSources(yi), Le = !0;
              }
            }
            this._clippingActiveLastFrame = ft, Le || this.replacementSource.clear(), this.conflationActive = Le, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
            for (let mi = 0; mi < oe.length; mi++) {
              const Ai = oe[mi], ji = Ai.cutoffRange();
              if (this.longestCutoffRange = Math.max(ji, this.longestCutoffRange), ji > 0) {
                const yi = jt(Ai);
                yi && (this.minCutoffZoom = Math.max(yi.minzoom, this.minCutoffZoom)), Ai.minzoom && (this.minCutoffZoom = Math.max(Ai.minzoom, this.minCutoffZoom));
              }
              Ai.is3D() && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = mi), this._lastOcclusionLayer = mi);
            }
            const ii = this.style && this.style.fog;
            ii ? (this._fogVisible = ii.getOpacity(this.transform.pitch) !== 0, this._fogVisible && this.transform.projection.name !== "globe" && (this._fogVisible = ii.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(gt), this.opaquePassCutoff = 0, V = C(), oe = V.map((mi) => p[mi]));
            const Xt = this._shadowRenderer;
            if (Xt) {
              Xt.updateShadowParameters(this.transform, this.style.directionalLight);
              for (const mi in ve) for (const Ai of st[mi]) {
                let ji = { min: 0, max: 0 };
                this.terrain && (ji = this.terrain.getMinMaxForTile(Ai) || ji), Xt.addShadowReceiver(Ai.toUnwrapped(), ji.min, ji.max);
              }
            }
            this.transform.projection.name !== "globe" || this.globeSharedBuffers || (this.globeSharedBuffers = new i.dw(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new Eh(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
            const Kt = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), Zt = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
            if (Kt && !this._snow && (this._snow = new dc(this)), !Kt && this._snow && (this._snow.destroy(), delete this._snow), Zt && !this._rain && (this._rain = new Ru(this)), !Zt && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), !ri.has(this.context.gl)) return;
            this.renderPass = "offscreen";
            for (const mi of oe) {
              const Ai = t.getLayerSourceCache(mi);
              if (!mi.hasOffscreenPass() || mi.isHidden(this.transform.zoom)) continue;
              const ji = Ai ? vt[Ai.id] : void 0;
              (mi.type === "custom" || mi.type === "raster" || mi.type === "raster-particle" || mi.isSky() || ji && ji.length) && this.renderLayer(this, Ai, mi, ji);
            }
            this.depthRangeFor3D = [0, 1 - (oe.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, Rt)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
            const Jt = this.transform.projection.name === "globe" || this.transform.isHorizonVisible(), ui = (() => {
              if (n.showOverdrawInspector) return i.aj.black;
              const mi = this.style.fog;
              if (mi && this.transform.projection.supportsFog) {
                const Ai = this.style.getLut(mi.scope);
                if (!Jt) {
                  const ji = mi.properties.get("color-use-theme") === "none", yi = mi.properties.get("color").toRenderColor(ji ? null : Ai).toArray01();
                  return new i.aj(...yi);
                }
                if (Jt) {
                  const ji = mi.properties.get("space-color-use-theme") === "none", yi = mi.properties.get("space-color").toRenderColor(ji ? null : Ai).toArray01();
                  return new i.aj(...yi);
                }
              }
              return i.aj.transparent;
            })();
            if (this.context.clear({ color: ui, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = n.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && Jt && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for (this.currentLayer = V.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const mi = oe[this.currentLayer], Ai = t.getLayerSourceCache(mi);
              if (mi.isSky()) continue;
              const ji = Ai ? (mi.is3D() ? qt : vt)[Ai.id] : void 0;
              this._renderTileClippingMasks(mi, Ai, ji), this.renderLayer(this, Ai, mi, ji);
            }
            if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && Jt && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || i.ae(this.transform.zoom) > 0) && (this.transform.projection.name === "globe" || this.transform.isHorizonVisible())) for (this.currentLayer = 0; this.currentLayer < V.length; this.currentLayer++) {
              const mi = oe[this.currentLayer], Ai = t.getLayerSourceCache(mi);
              mi.isSky() && this.renderLayer(this, Ai, mi, Ai ? vt[Ai.id] : void 0);
            }
            function Ti(mi, Ai) {
              let ji;
              return Ai && (ji = (mi.type === "symbol" ? gt : mi.is3D() ? qt : vt)[Ai.id]), ji;
            }
            if (this.renderPass = "translucent", this.transform.projection.name === "globe") {
              for (this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < V.length; ) {
                const mi = oe[this.currentLayer];
                if (mi.type === "raster" || mi.type === "raster-particle") {
                  const Ai = t.getLayerSourceCache(mi);
                  this.renderLayer(this, Ai, mi, Ti(mi, Ai));
                }
                ++this.currentLayer;
              }
              this.renderElevatedRasterBackface = !1;
            }
            this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
            let xi = 0;
            Xt && (xi = Xt.getShadowCastingLayerCount());
            let Pi = !1, Ri = -1;
            for (let mi = 0; mi < V.length; ++mi) {
              const Ai = oe[mi];
              Ai.isHidden(this.transform.zoom) || Ai.is3D() && (Ri = mi);
            }
            for (se && Ri === -1 && (K = !0); this.currentLayer < V.length; ) {
              const mi = oe[this.currentLayer], Ai = t.getLayerSourceCache(mi);
              if (mi.isSky()) ++this.currentLayer;
              else if (this.terrain && this.style.isLayerDraped(mi)) {
                if (mi.isHidden(this.transform.zoom)) {
                  ++this.currentLayer;
                  continue;
                }
                this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
              } else {
                if (K && !Pi && this.terrain && !this.transform.isOrthographic && (Pi = !0, this.blitDepth()), se && Ri !== -1 && this.currentLayer === Ri + 1 && !this.transform.isOrthographic && this.blitDepth(), mi.is3D() || this.terrain || this._renderTileClippingMasks(mi, Ai, Ai ? st[Ai.id] : void 0), this.renderLayer(this, Ai, mi, Ti(mi, Ai)), !this.terrain && Xt && xi > 0 && mi.hasShadowPass() && --xi == 0 && (Xt.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                  const ji = this.currentLayer;
                  for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= ji; this.currentLayer++) {
                    const yi = oe[this.currentLayer];
                    if (!yi.hasLightBeamPass()) continue;
                    const Ni = t.getLayerSourceCache(yi);
                    this.renderLayer(this, Ni, yi, Ni ? vt[Ni.id] : void 0);
                  }
                  this.currentLayer = ji, this.renderPass = "translucent";
                }
                if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                  const ji = this.currentLayer;
                  this.depthOcclusion = !0;
                  for (const yi of this.layersWithOcclusionOpacity) {
                    this.currentLayer = yi;
                    const Ni = oe[this.currentLayer], Mi = t.getLayerSourceCache(Ni), Yi = Mi ? vt[Mi.id] : void 0;
                    Ni.is3D() || this.terrain || this._renderTileClippingMasks(Ni, Mi, Mi ? st[Mi.id] : void 0), this.renderLayer(this, Mi, Ni, Yi);
                  }
                  this.depthOcclusion = !1, this.currentLayer = ji, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
                }
                ++this.currentLayer;
              }
            }
            if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
              let mi = null;
              oe.forEach((Ai) => {
                const ji = t.getLayerSourceCache(Ai);
                ji && !Ai.isHidden(this.transform.zoom) && ji.getVisibleCoordinates().length && (!mi || mi.getSource().maxzoom < ji.getSource().maxzoom) && (mi = ji);
              }), mi && this.options.showTileBoundaries && pc.debug(this, mi, mi.getVisibleCoordinates(), i.aj.red, !1, this.options.showParseStatus);
            }
            this.terrain && this._debugParams.showTerrainProxyTiles && pc.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new i.aj(1, 0.8, 0.1, 1), !0, this.options.showParseStatus), this.options.showPadding && function(mi) {
              const Ai = mi.transform.padding;
              Au(mi, mi.transform.height - (Ai.top || 0), 3, bl), Au(mi, Ai.bottom || 0, 3, Bf), Mu(mi, Ai.left || 0, 3, bh), Mu(mi, mi.transform.width - (Ai.right || 0), 3, lf);
              const ji = mi.transform.centerPoint;
              (function(yi, Ni, Mi, Yi) {
                ho(yi, Ni - 1, Mi - 10, 2, 20, Yi), ho(yi, Ni - 10, Mi - 1, 20, 2, Yi);
              })(mi, ji.x, mi.transform.height - ji.y, Zl);
            }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), Le || (this.conflationActive = !1);
          }
          prepareLayer(t) {
            this.gpuTimingStart(t);
            const { unsupportedLayers: n } = this.transform.projection, c = !n || !n.includes(t.type);
            if (ku[t.type] && (c || this.terrain && t.type === "custom")) {
              const p = this.style.getLayerSourceCache(t);
              ku[t.type](t, p, this);
            }
            this.gpuTimingEnd();
          }
          renderLayer(t, n, c, p) {
            c.isHidden(this.transform.zoom) || (c.type === "background" || c.type === "sky" || c.type === "custom" || c.type === "model" || c.type === "raster" || c.type === "raster-particle" || p && p.length) && (this.id = c.id, this.gpuTimingStart(c), t.transform.projection.unsupportedLayers && t.transform.projection.unsupportedLayers.includes(c.type) && (!t.terrain || c.type !== "custom") || c.type === "clip" || pc[c.type](t, n, c, p, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
          }
          gpuTimingStart(t) {
            if (!this.options.gpuTiming) return;
            const n = this.context.extTimerQuery, c = this.context.gl;
            let p = this.gpuTimers[t.id];
            p || (p = this.gpuTimers[t.id] = { calls: 0, cpuTime: 0, query: c.createQuery() }), p.calls++, c.beginQuery(n.TIME_ELAPSED_EXT, p.query);
          }
          gpuTimingDeferredRenderStart() {
            if (this.options.gpuTimingDeferredRender) {
              const t = this.context.extTimerQuery, n = this.context.gl, c = n.createQuery();
              this.deferredRenderGpuTimeQueries.push(c), n.beginQuery(t.TIME_ELAPSED_EXT, c);
            }
          }
          gpuTimingDeferredRenderEnd() {
            this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
          }
          gpuTimingEnd() {
            this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
          }
          collectGpuTimers() {
            const t = this.gpuTimers;
            return this.gpuTimers = {}, t;
          }
          collectDeferredRenderGpuQueries() {
            const t = this.deferredRenderGpuTimeQueries;
            return this.deferredRenderGpuTimeQueries = [], t;
          }
          queryGpuTimers(t) {
            const n = {};
            for (const c in t) {
              const p = t[c], v = this.context.extTimerQuery, C = v.getQueryParameter(p.query, this.context.gl.QUERY_RESULT) / 1e6;
              v.deleteQueryEXT(p.query), n[c] = C;
            }
            return n;
          }
          queryGpuTimeDeferredRender(t) {
            if (!this.options.gpuTimingDeferredRender) return 0;
            const n = this.context.gl;
            let c = 0;
            for (const p of t) c += n.getQueryParameter(p, n.QUERY_RESULT) / 1e6, n.deleteQuery(p);
            return c;
          }
          translatePosMatrix(t, n, c, p, v) {
            if (!c[0] && !c[1]) return t;
            const C = v ? p === "map" ? this.transform.angle : 0 : p === "viewport" ? -this.transform.angle : 0;
            if (C) {
              const se = Math.sin(C), oe = Math.cos(C);
              c = [c[0] * oe - c[1] * se, c[0] * se + c[1] * oe];
            }
            const V = [v ? c[0] : i.ar(n, c[0], this.transform.zoom), v ? c[1] : i.ar(n, c[1], this.transform.zoom), 0], K = new Float32Array(16);
            return i.ab.mat4.translate(K, t, V), K;
          }
          saveTileTexture(t) {
            const n = t.size[0], c = this._tileTextures[n];
            c ? c.push(t) : this._tileTextures[n] = [t];
          }
          getTileTexture(t) {
            const n = this._tileTextures[t];
            return n && n.length > 0 ? n.pop() : null;
          }
          terrainRenderModeElevated() {
            return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
          }
          linearFloatFilteringSupported() {
            return this.context.extTextureFloatLinear != null;
          }
          currentGlobalDefines(t, n, c) {
            const p = c === void 0 ? this.terrain && this.terrain.renderingToTexture : c, v = [];
            return this.style && this.style.enable3dLights() && (t === "globeRaster" || t === "terrainRaster" ? (v.push("LIGHTING_3D_MODE"), v.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : p || v.push("LIGHTING_3D_MODE")), this.renderPass === "shadow" && (this._shadowMapDebug || v.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (v.push("TERRAIN"), this.linearFloatFilteringSupported() && v.push("TERRAIN_DEM_FLOAT_FORMAT")), this.transform.projection.name === "globe" && v.push("GLOBE"), !this._fogVisible || p || n !== void 0 && !n || v.push("FOG", "FOG_DITHERING"), p && v.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && v.push("OVERDRAW_INSPECTOR"), v;
          }
          getOrCreateProgram(t, n) {
            this.cache = this.cache || {};
            const c = n && n.defines || [], p = n && n.config, v = this.currentGlobalDefines(t, n && n.overrideFog, n && n.overrideRtt).concat(c), C = tf.cacheKey(fu[t], t, v, p);
            return this.cache[C] || (this.cache[C] = new tf(this.context, t, fu[t], p, xh[t], v)), this.cache[C];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const t = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new i.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
          }
          destroy() {
            this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
          }
          prepareDrawTile() {
            this.terrain && this.terrain.prepareDrawTile();
          }
          uploadCommonLightUniforms(t, n) {
            if (this.style.enable3dLights()) {
              const c = this.style.directionalLight, p = this.style.ambientLight;
              if (c && p) {
                const v = ((C, V, K) => {
                  const se = C.properties.get("direction"), oe = C.properties.get("color-use-theme") === "none", ve = C.properties.get("color").toRenderColor(oe ? null : K.getLut(C.scope)).toArray01(), xe = C.properties.get("intensity"), Le = V.properties.get("color-use-theme") === "none", ft = V.properties.get("color").toRenderColor(Le ? null : K.getLut(V.scope)).toArray01(), st = V.properties.get("intensity"), vt = [se.x, se.y, se.z], gt = i.cM(ft, st), Rt = i.cM(ve, xe);
                  return { u_lighting_ambient_color: gt, u_lighting_directional_dir: vt, u_lighting_directional_color: Rt, u_ground_radiance: qs(vt, Rt, gt) };
                })(c, p, this.style);
                n.setLightsUniformValues(t, v);
              }
            }
          }
          uploadCommonUniforms(t, n, c, p, v) {
            if (this.uploadCommonLightUniforms(t, n), this.terrain && this.terrain.renderingToTexture) return;
            const C = this.style.fog;
            if (C) {
              const V = C.getOpacity(this.transform.pitch), K = ((se, oe, ve, xe, Le, ft, st, vt, gt, Rt, qt, jt) => {
                const ii = se.transform, Xt = oe.properties.get("color-use-theme") === "none", Kt = oe.properties.get("color").toRenderColor(Xt ? null : se.style.getLut(oe.scope)).toArray01();
                Kt[3] = xe;
                const Zt = se.frameCounter / 1e3 % 1, [Jt, ui] = oe.properties.get("vertical-range");
                return { u_fog_matrix: ve ? ii.calculateFogTileMatrix(ve) : jt || se.identityMat, u_fog_range: oe.getFovAdjustedRange(ii._fov), u_fog_color: Kt, u_fog_horizon_blend: oe.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(Jt, ui), ui], u_fog_temporal_offset: Zt, u_frustum_tl: Le, u_frustum_tr: ft, u_frustum_br: st, u_frustum_bl: vt, u_globe_pos: gt, u_globe_radius: Rt, u_viewport: qt, u_globe_transition: i.ae(ii.zoom), u_is_globe: +(ii.projection.name === "globe") };
              })(this, C, c, V, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * i.q.devicePixelRatio, this.transform.height * i.q.devicePixelRatio], p);
              n.setFogUniformValues(t, K);
            }
            v && n.setCutoffUniformValues(t, v.uniformValues);
          }
          setTileLoadedFlag(t) {
            this.tileLoaded = t;
          }
          saveCanvasCopy() {
            const t = this.canvasCopy();
            t && (this.frameCopies.push(t), this.tileLoaded = !1);
          }
          canvasCopy() {
            const t = this.context.gl, n = t.createTexture();
            return t.bindTexture(t.TEXTURE_2D, n), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, 0, 0, t.drawingBufferWidth, t.drawingBufferHeight, 0), n;
          }
          getCanvasCopiesAndTimestamps() {
            return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
          }
          averageElevationNeedsEasing() {
            if (!this.transform._elevation) return !1;
            const t = this.style && this.style.fog;
            return !!t && t.getOpacity(this.transform.pitch) !== 0;
          }
          getBackgroundTiles() {
            const t = this._backgroundTiles, n = this._backgroundTiles = {}, c = this.transform.coveringTiles({ tileSize: 512 });
            for (const p of c) n[p.key] = t[p.key] || new Ba(p, 512, this.transform.tileZoom, this);
            return n;
          }
          clearBackgroundTiles() {
            this._backgroundTiles = {};
          }
          isSourceForClippingOrConflation(t, n) {
            return !(!t.is3D() || t.type !== "clip" && (t.minzoom && t.minzoom > this.transform.zoom || (this.style._clipLayerPresent || t.sourceLayer !== "building") && (!n || n.type !== "batched-model")));
          }
          isTileAffectedByFog(t) {
            if (!this.style || !this.style.fog) return !1;
            if (this.transform.projection.name === "globe") return !0;
            let n = this._cachedTileFogOpacities[t.key];
            return n || (this._cachedTileFogOpacities[t.key] = n = this.style.fog.getOpacityForTile(t)), n[0] >= It || n[1] >= It;
          }
          setupDepthForOcclusion(t, n, c) {
            const p = this.context, v = p.gl, C = !!c;
            var V;
            c || (c = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 }), p.activeTexture.set(v.TEXTURE3), t && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(v.NEAREST, v.CLAMP_TO_EDGE), c.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], c.u_depth_range_unpack = [2 / ((V = this.depthRangeFor3D)[1] - V[0]), -1 - 2 * V[0] / (V[1] - V[0])], c.u_occluder_half_size = 0.5 * this.occlusionParams.occluderSize, c.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(v.NEAREST, v.CLAMP_TO_EDGE), p.activeTexture.set(v.TEXTURE0), C || n.setTerrainUniformValues(p, c);
          }
        }
        function Xc(u, t) {
          let n = !1, c = null;
          const p = () => {
            c = null, n && (u(), c = setTimeout(p, t), n = !1);
          };
          return () => (n = !0, c || p(), c);
        }
        class uf {
          constructor(t) {
            this._hashName = t && encodeURIComponent(t), i.aP(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Xc(this._updateHashUnthrottled.bind(this), 300);
          }
          addTo(t) {
            return this._map = t, window.addEventListener("hashchange", this._onHashChange, !1), t.on("moveend", this._updateHash), this;
          }
          remove() {
            return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
          }
          getHashString() {
            const t = this._map;
            if (!t) return "";
            const n = Ph(t);
            if (this._hashName) {
              const c = this._hashName;
              let p = !1;
              const v = location.hash.slice(1).split("&").map((C) => {
                const V = C.split("=")[0];
                return V === c ? (p = !0, `${V}=${n}`) : C;
              }).filter((C) => C);
              return p || v.push(`${c}=${n}`), `#${v.join("&")}`;
            }
            return `#${n}`;
          }
          _getCurrentHash() {
            const t = location.hash.replace("#", "");
            if (this._hashName) {
              let n;
              return t.split("&").map((c) => c.split("=")).forEach((c) => {
                c[0] === this._hashName && (n = c);
              }), (n && n[1] || "").split("/");
            }
            return t.split("/");
          }
          _onHashChange() {
            const t = this._map;
            if (!t) return !1;
            const n = this._getCurrentHash();
            if (n.length >= 3 && !n.some((c) => isNaN(c))) {
              const c = t.dragRotate.isEnabled() && t.touchZoomRotate.isEnabled() ? +(n[3] || 0) : t.getBearing();
              return t.jumpTo({ center: [+n[2], +n[1]], zoom: +n[0], bearing: c, pitch: +(n[4] || 0) }), !0;
            }
            return !1;
          }
          _updateHashUnthrottled() {
            history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
          }
        }
        function Ph(u, t) {
          const n = u.getCenter(), c = Math.round(100 * u.getZoom()) / 100, p = Math.ceil((c * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), v = Math.pow(10, p), C = Math.round(n.lng * v) / v, V = Math.round(n.lat * v) / v, K = u.getBearing(), se = u.getPitch();
          let oe = t ? `/${C}/${V}/${c}` : `${c}/${V}/${C}`;
          return (K || se) && (oe += "/" + Math.round(10 * K) / 10), se && (oe += `/${Math.round(se)}`), oe;
        }
        const Lu = { linearity: 0.3, easing: i.dy(0, 0, 0.3, 1) }, cf = i.l({ deceleration: 2500, maxSpeed: 1400 }, Lu), hf = i.l({ deceleration: 20, maxSpeed: 1400 }, Lu), ff = i.l({ deceleration: 1e3, maxSpeed: 360 }, Lu), Ff = i.l({ deceleration: 1e3, maxSpeed: 90 }, Lu);
        class df {
          constructor(t) {
            this._map = t, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(t) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: i.q.now(), settings: t });
          }
          _drainInertiaBuffer() {
            const t = this._inertiaBuffer, n = i.q.now();
            for (; t.length > 0 && n - t[0].time > 160; ) t.shift();
          }
          _onMoveEnd(t) {
            if (this._map._prefersReducedMotion() || (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)) return;
            const n = { zoom: 0, bearing: 0, pitch: 0, pan: new i.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: v } of this._inertiaBuffer) n.zoom += v.zoomDelta || 0, n.bearing += v.bearingDelta || 0, n.pitch += v.pitchDelta || 0, v.panDelta && n.pan._add(v.panDelta), v.around && (n.around = v.around), v.pinchAround && (n.pinchAround = v.pinchAround);
            const c = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, p = {};
            if (n.pan.mag()) {
              const v = Kc(n.pan.mag(), c, i.l({}, cf, t || {}));
              p.offset = n.pan.mult(v.amount / n.pan.mag()), p.center = this._map.transform.center, Yc(p, v);
            }
            if (n.zoom) {
              const v = Kc(n.zoom, c, hf);
              p.zoom = this._map.transform.zoom + v.amount, Yc(p, v);
            }
            if (n.bearing) {
              const v = Kc(n.bearing, c, ff);
              p.bearing = this._map.transform.bearing + i.aw(v.amount, -179, 179), Yc(p, v);
            }
            if (n.pitch) {
              const v = Kc(n.pitch, c, Ff);
              p.pitch = this._map.transform.pitch + v.amount, Yc(p, v);
            }
            if (p.zoom || p.bearing) {
              const v = n.pinchAround === void 0 ? n.around : n.pinchAround;
              p.around = v ? this._map.unproject(v) : this._map.getCenter();
            }
            return this.clear(), p.noMoveStart = !0, p;
          }
        }
        function Yc(u, t) {
          (!u.duration || u.duration < t.duration) && (u.duration = t.duration, u.easing = t.easing);
        }
        function Kc(u, t, n) {
          const { maxSpeed: c, linearity: p, deceleration: v } = n, C = i.aw(u * p / (t / 1e3), -c, c), V = Math.abs(C) / (v * p);
          return { easing: n.easing, duration: 1e3 * V, amount: C * (V / 2) };
        }
        class zs extends i.z {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, n, c, p = {}) {
            const v = J(n.getCanvasContainer(), c), C = n.unproject(v);
            super(t, i.l({ point: v, lngLat: C, originalEvent: c }, p)), this._defaultPrevented = !1, this.target = n;
          }
        }
        class mc extends i.z {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, n, c) {
            const p = t === "touchend" ? c.changedTouches : c.touches, v = ee(n.getCanvasContainer(), p), C = v.map((K) => n.unproject(K)), V = v.reduce((K, se, oe, ve) => K.add(se.div(ve.length)), new i.P(0, 0));
            super(t, { points: v, point: V, lngLats: C, lngLat: n.unproject(V), originalEvent: c }), this._defaultPrevented = !1;
          }
        }
        class pf extends i.z {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(t, n) {
            super("wheel", { originalEvent: n }), this._defaultPrevented = !1;
          }
        }
        class Rh {
          constructor(t, n) {
            this._map = t, this._clickTolerance = n.clickTolerance;
          }
          reset() {
            this._mousedownPos = void 0;
          }
          wheel(t) {
            return this._firePreventable(new pf(this._map, t));
          }
          mousedown(t, n) {
            return this._mousedownPos = n, this._firePreventable(new zs(t.type, this._map, t));
          }
          mouseup(t) {
            this._map.fire(new zs(t.type, this._map, t));
          }
          preclick(t) {
            const n = i.l({}, t);
            n.type = "preclick", this._map.fire(new zs(n.type, this._map, n));
          }
          click(t, n) {
            this._mousedownPos && this._mousedownPos.dist(n) >= this._clickTolerance || (this.preclick(t), this._map.fire(new zs(t.type, this._map, t)));
          }
          dblclick(t) {
            return this._firePreventable(new zs(t.type, this._map, t));
          }
          mouseover(t) {
            this._map.fire(new zs(t.type, this._map, t));
          }
          mouseout(t) {
            this._map.fire(new zs(t.type, this._map, t));
          }
          touchstart(t) {
            return this._firePreventable(new mc(t.type, this._map, t));
          }
          touchmove(t) {
            this._map.fire(new mc(t.type, this._map, t));
          }
          touchend(t) {
            this._map.fire(new mc(t.type, this._map, t));
          }
          touchcancel(t) {
            this._map.fire(new mc(t.type, this._map, t));
          }
          _firePreventable(t) {
            if (this._map.fire(t), t.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class vd {
          constructor(t) {
            this._map = t;
          }
          reset() {
            this._delayContextMenu = !1, this._contextMenuEvent = void 0;
          }
          mousemove(t) {
            this._map.fire(new zs(t.type, this._map, t));
          }
          mousedown() {
            this._delayContextMenu = !0;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new zs("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(t) {
            this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new zs(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class Ea {
          constructor(t, n) {
            this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = n.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(t, n) {
            this.isEnabled() && t.shiftKey && t.button === 0 && (U(), this._startPos = this._lastPos = n, this._active = !0);
          }
          mousemoveWindow(t, n) {
            if (!this._active) return;
            const c = n, p = this._startPos, v = this._lastPos;
            if (!p || !v || v.equals(c) || !this._box && c.dist(p) < this._clickTolerance) return;
            this._lastPos = c, this._box || (this._box = w("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t));
            const C = Math.min(p.x, c.x), V = Math.max(p.x, c.x), K = Math.min(p.y, c.y), se = Math.max(p.y, c.y);
            this._map._requestDomTask(() => {
              this._box && (this._box.style.transform = `translate(${C}px,${K}px)`, this._box.style.width = V - C + "px", this._box.style.height = se - K + "px");
            });
          }
          mouseupWindow(t, n) {
            if (!this._active) return;
            const c = this._startPos, p = n;
            if (c && t.button === 0) {
              if (this.reset(), W(), c.x !== p.x || c.y !== p.y) return this._map.fire(new i.z("boxzoomend", { originalEvent: t })), { cameraAnimation: (v) => v.fitScreenCoordinates(c, p, this._map.getBearing(), { linear: !1 }) };
              this._fireEvent("boxzoomcancel", t);
            }
          }
          keydown(t) {
            this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t));
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), j(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(t, n) {
            return this._map.fire(new i.z(t, { originalEvent: n }));
          }
        }
        function kh(u, t) {
          const n = {};
          for (let c = 0; c < u.length; c++) n[u[c].identifier] = t[c];
          return n;
        }
        class Lo {
          constructor(t) {
            this.reset(), this.numTouches = t.numTouches;
          }
          reset() {
            this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
          }
          touchstart(t, n, c) {
            (this.centroid || c.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === 0 && (this.startTime = t.timeStamp), c.length === this.numTouches && (this.centroid = function(p) {
              const v = new i.P(0, 0);
              for (const C of p) v._add(C);
              return v.div(p.length);
            }(n), this.touches = kh(c, n)));
          }
          touchmove(t, n, c) {
            if (this.aborted || !this.centroid) return;
            const p = kh(c, n);
            for (const v in this.touches) {
              const C = p[v];
              (!C || C.dist(this.touches[v]) > 30) && (this.aborted = !0);
            }
          }
          touchend(t, n, c) {
            if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), c.length === 0) {
              const p = !this.aborted && this.centroid;
              if (this.reset(), p) return p;
            }
          }
        }
        class Jc {
          constructor(t) {
            this.singleTap = new Lo(t), this.numTaps = t.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
          }
          touchstart(t, n, c) {
            this.singleTap.touchstart(t, n, c);
          }
          touchmove(t, n, c) {
            this.singleTap.touchmove(t, n, c);
          }
          touchend(t, n, c) {
            const p = this.singleTap.touchend(t, n, c);
            if (p) {
              const v = t.timeStamp - this.lastTime < 500, C = !this.lastTap || this.lastTap.dist(p) < 30;
              if (v && C || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = p, this.count === this.numTaps) return this.reset(), p;
            }
          }
        }
        class Yl {
          constructor() {
            this._zoomIn = new Jc({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Jc({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(t, n, c) {
            this._zoomIn.touchstart(t, n, c), this._zoomOut.touchstart(t, n, c);
          }
          touchmove(t, n, c) {
            this._zoomIn.touchmove(t, n, c), this._zoomOut.touchmove(t, n, c);
          }
          touchend(t, n, c) {
            const p = this._zoomIn.touchend(t, n, c), v = this._zoomOut.touchend(t, n, c);
            return p ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (C) => C.easeTo({ duration: 300, zoom: C.getZoom() + 1, around: C.unproject(p) }, { originalEvent: t }) }) : v ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (C) => C.easeTo({ duration: 300, zoom: C.getZoom() - 1, around: C.unproject(v) }, { originalEvent: t }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        const mf = { 0: 1, 2: 2 };
        class _c {
          constructor(t) {
            this.reset(), this._clickTolerance = t.clickTolerance || 1;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
          }
          _correctButton(t, n) {
            return !1;
          }
          _move(t, n) {
            return {};
          }
          mousedown(t, n) {
            if (this._lastPoint) return;
            const c = te(t);
            this._correctButton(t, c) && (this._lastPoint = n, this._eventButton = c);
          }
          mousemoveWindow(t, n) {
            const c = this._lastPoint;
            if (c) {
              if (t.preventDefault(), this._eventButton != null && function(p, v) {
                const C = mf[v];
                return p.buttons === void 0 || (p.buttons & C) !== C;
              }(t, this._eventButton)) this.reset();
              else if (this._moved || !(n.dist(c) < this._clickTolerance)) return this._moved = !0, this._lastPoint = n, this._move(c, n);
            }
          }
          mouseupWindow(t) {
            this._lastPoint && te(t) === this._eventButton && (this._moved && W(), this.reset());
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Qc extends _c {
          mousedown(t, n) {
            super.mousedown(t, n), this._lastPoint && (this._active = !0);
          }
          _correctButton(t, n) {
            return n === 0 && !t.ctrlKey;
          }
          _move(t, n) {
            return { around: n, panDelta: n.sub(t) };
          }
        }
        class To extends _c {
          _correctButton(t, n) {
            return n === 0 && t.ctrlKey || n === 2;
          }
          _move(t, n) {
            const c = 0.8 * (n.x - t.x);
            if (c) return this._active = !0, { bearingDelta: c };
          }
          contextmenu(t) {
            t.preventDefault();
          }
        }
        class el extends _c {
          _correctButton(t, n) {
            return n === 0 && t.ctrlKey || n === 2;
          }
          _move(t, n) {
            const c = -0.5 * (n.y - t.y);
            if (c) return this._active = !0, { pitchDelta: c };
          }
          contextmenu(t) {
            t.preventDefault();
          }
        }
        class ma {
          constructor(t, n) {
            this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = n.clickTolerance || 1, this.reset(), i.aP(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new i.P(0, 0);
          }
          touchstart(t, n, c) {
            return this._calculateTransform(t, n, c);
          }
          touchmove(t, n, c) {
            if (this._active && !(c.length < this._minTouches)) {
              if (this._map._cooperativeGestures && !this._map.isMoving()) {
                if (c.length === 1 && !i.dz()) return void this._showTouchPanBlockerAlert();
                this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              return t.cancelable && t.preventDefault(), this._calculateTransform(t, n, c);
            }
          }
          touchend(t, n, c) {
            this._calculateTransform(t, n, c), this._active && c.length < this._minTouches && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(t, n, c) {
            c.length > 0 && (this._active = !0);
            const p = kh(c, n), v = new i.P(0, 0), C = new i.P(0, 0);
            let V = 0;
            for (const se in p) {
              const oe = p[se], ve = this._touches[se];
              ve && (v._add(oe), C._add(oe.sub(ve)), V++, p[se] = oe);
            }
            if (this._touches = p, V < this._minTouches || !C.mag()) return;
            const K = C.div(V);
            return this._sum._add(K), this._sum.mag() < this._clickTolerance ? void 0 : { around: v.div(V), panDelta: K };
          }
          enable() {
            this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
          }
          disable() {
            this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          _addTouchPanBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = w("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showTouchPanBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
            }, 500);
          }
        }
        class Xs {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, this._firstTwoTouches = void 0;
          }
          _start(t) {
          }
          _move(t, n, c) {
            return {};
          }
          touchstart(t, n, c) {
            this._firstTwoTouches || c.length < 2 || (this._firstTwoTouches = [c[0].identifier, c[1].identifier], this._start([n[0], n[1]]));
          }
          touchmove(t, n, c) {
            const p = this._firstTwoTouches;
            if (!p) return;
            t.preventDefault();
            const [v, C] = p, V = gc(c, n, v), K = gc(c, n, C);
            if (!V || !K) return;
            const se = this._aroundCenter ? null : V.add(K).div(2);
            return this._move([V, K], se, t);
          }
          touchend(t, n, c) {
            if (!this._firstTwoTouches) return;
            const [p, v] = this._firstTwoTouches, C = gc(c, n, p), V = gc(c, n, v);
            C && V || (this._active && W(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(t) {
            this._enabled = !0, this._aroundCenter = !!t && t.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        function gc(u, t, n) {
          for (let c = 0; c < u.length; c++) if (u[c].identifier === n) return t[c];
        }
        function vc(u, t) {
          return Math.log(u / t) / Math.LN2;
        }
        class _f extends Xs {
          reset() {
            super.reset(), this._distance = 0, this._startDistance = 0;
          }
          _start(t) {
            this._startDistance = this._distance = t[0].dist(t[1]);
          }
          _move(t, n) {
            const c = this._distance;
            if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(vc(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: vc(this._distance, c), pinchAround: n };
          }
        }
        function gf(u, t) {
          return 180 * u.angleWith(t) / Math.PI;
        }
        class yc extends Xs {
          reset() {
            super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
          }
          _start(t) {
            this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);
          }
          _move(t, n) {
            const c = this._vector;
            if (this._vector = t[0].sub(t[1]), c && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, { bearingDelta: gf(this._vector, c), pinchAround: n };
          }
          _isBelowThreshold(t) {
            this._minDiameter = Math.min(this._minDiameter, t.mag());
            const n = 25 / (Math.PI * this._minDiameter) * 360, c = this._startVector;
            if (!c) return !1;
            const p = gf(t, c);
            return Math.abs(p) < n;
          }
        }
        function Lh(u) {
          return Math.abs(u.y) > Math.abs(u.x);
        }
        class yd extends Xs {
          constructor(t) {
            super(), this._map = t;
          }
          reset() {
            super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
          }
          _start(t) {
            this._lastPoints = t, Lh(t[0].sub(t[1])) && (this._valid = !1);
          }
          _move(t, n, c) {
            const p = this._lastPoints;
            if (!p) return;
            const v = t[0].sub(p[0]), C = t[1].sub(p[1]);
            return this._map._cooperativeGestures && !i.dz() && c.touches.length < 3 || (this._valid = this.gestureBeginsVertically(v, C, c.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, { pitchDelta: (v.y + C.y) / 2 * -0.5 });
          }
          gestureBeginsVertically(t, n, c) {
            if (this._valid !== void 0) return this._valid;
            const p = t.mag() >= 2, v = n.mag() >= 2;
            if (!p && !v) return;
            if (!p || !v) return this._firstMove == null && (this._firstMove = c), c - this._firstMove < 100 && void 0;
            const C = t.y > 0 == n.y > 0;
            return Lh(t) && Lh(n) && C;
          }
        }
        const Es = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class gs {
          constructor() {
            const t = Es;
            this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = !1;
          }
          keydown(t) {
            if (t.altKey || t.ctrlKey || t.metaKey) return;
            let n = 0, c = 0, p = 0, v = 0, C = 0;
            switch (t.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                n = 1;
                break;
              case 189:
              case 109:
              case 173:
                n = -1;
                break;
              case 37:
                t.shiftKey ? c = -1 : (t.preventDefault(), v = -1);
                break;
              case 39:
                t.shiftKey ? c = 1 : (t.preventDefault(), v = 1);
                break;
              case 38:
                t.shiftKey ? p = 1 : (t.preventDefault(), C = -1);
                break;
              case 40:
                t.shiftKey ? p = -1 : (t.preventDefault(), C = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (c = 0, p = 0), { cameraAnimation: (V) => {
              const K = V.getZoom();
              V.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Kl, zoom: n ? Math.round(K) + n * (t.shiftKey ? 2 : 1) : K, bearing: V.getBearing() + c * this._bearingStep, pitch: V.getPitch() + p * this._pitchStep, offset: [-v * this._panStep, -C * this._panStep], center: V.getCenter() }, { originalEvent: t });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function Kl(u) {
          return u * (2 - u);
        }
        const Jl = 4.000244140625, tl = 1 / 450;
        class Co {
          constructor(t, n) {
            this._map = t, this._el = t.getCanvasContainer(), this._handler = n, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = tl, i.aP(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
          }
          setZoomRate(t) {
            this._defaultZoomRate = t;
          }
          setWheelZoomRate(t) {
            this._wheelZoomRate = t;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(t) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!t && t.around === "center", this._map._cooperativeGestures && this._addScrollZoomBlocker());
          }
          disable() {
            this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
          }
          wheel(t) {
            if (!this.isEnabled()) return;
            if (this._map._cooperativeGestures) {
              if (!(t.ctrlKey || t.metaKey || this.isZooming() || i.dz())) return void this._showBlockerAlert();
              this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            let n = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
            const c = i.q.now(), p = c - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = c, n !== 0 && n % Jl == 0 ? this._type = "wheel" : n !== 0 && Math.abs(n) < 4 ? this._type = "trackpad" : p > 400 ? (this._type = null, this._lastValue = n, this._timeout = window.setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(p * n) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, n += this._lastValue)), t.shiftKey && n && (n /= 4), this._type && (this._lastWheelEvent = t, this._delta -= n, this._active || this._start(t)), t.preventDefault();
          }
          _onTimeout(t) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t);
          }
          _start(t) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const n = J(this._el, t);
            this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : n, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const t = this._map.transform;
            this._type === "wheel" && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
            const n = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;
            if (this._delta !== 0) {
              const se = this._type === "wheel" && Math.abs(this._delta) > Jl ? this._wheelZoomRate : this._defaultZoomRate;
              let oe = 2 / (1 + Math.exp(-Math.abs(this._delta * se)));
              this._delta < 0 && oe !== 0 && (oe = 1 / oe);
              const ve = n(), xe = Math.pow(2, ve), Le = typeof this._targetZoom == "number" ? t.zoomScale(this._targetZoom) : xe;
              this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(Le * oe))), this._type === "wheel" && (this._startZoom = ve, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
            }
            const c = typeof this._targetZoom == "number" ? this._targetZoom : n(), p = this._startZoom, v = this._easing;
            let C, V = !1;
            if (this._type === "wheel" && p && v) {
              const se = Math.min((i.q.now() - this._lastWheelEventTime) / 200, 1), oe = v(se);
              C = i.af(p, c, oe), se < 1 ? this._frameId || (this._frameId = !0) : V = !0;
            } else C = c, V = !0;
            this._active = !0, V && (this._active = !1, this._finishTimeout = window.setTimeout(() => {
              this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
            }, 200));
            let K = C - n();
            return K * this._lastDelta < 0 && (K = 0), { noInertia: !0, needsRenderFrame: !V, zoomDelta: K, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(t) {
            let n = i.dA;
            if (this._prevEase) {
              const c = this._prevEase, p = (i.q.now() - c.start) / c.duration, v = c.easing(p + 0.01) - c.easing(p), C = 0.27 / Math.sqrt(v * v + 1e-4) * 0.01, V = Math.sqrt(0.0729 - C * C);
              n = i.dy(C, V, 0.25, 1);
            }
            return this._prevEase = { start: i.q.now(), duration: t, easing: n }, n;
          }
          blur() {
            this.reset();
          }
          reset() {
            this._active = !1;
          }
          _addScrollZoomBlocker() {
            this._map && !this._alertContainer && (this._alertContainer = w("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
          }
          _showBlockerAlert() {
            this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
              this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
            }, 200);
          }
        }
        class El {
          constructor(t, n) {
            this._clickZoom = t, this._tapZoom = n;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class Tl {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1;
          }
          blur() {
            this.reset();
          }
          dblclick(t, n) {
            return t.preventDefault(), { cameraAnimation: (c) => {
              c.easeTo({ duration: 300, zoom: c.getZoom() + (t.shiftKey ? -1 : 1), around: c.unproject(n) }, { originalEvent: t });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Cl {
          constructor() {
            this._tap = new Jc({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
          }
          touchstart(t, n, c) {
            this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? c.length > 0 && (this._swipePoint = n[0], this._swipeTouch = c[0].identifier) : this._tap.touchstart(t, n, c));
          }
          touchmove(t, n, c) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (c[0].identifier !== this._swipeTouch) return;
                const p = n[0], v = p.y - this._swipePoint.y;
                return this._swipePoint = p, t.preventDefault(), this._active = !0, { zoomDelta: v / 128 };
              }
            } else this._tap.touchmove(t, n, c);
          }
          touchend(t, n, c) {
            this._tapTime ? this._swipePoint && c.length === 0 && this.reset() : this._tap.touchend(t, n, c) && (this._tapTime = t.timeStamp);
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class vf {
          constructor(t, n, c) {
            this._el = t, this._mousePan = n, this._touchPan = c;
          }
          enable(t) {
            this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Nf {
          constructor(t, n, c) {
            this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = n, this._mousePitch = c;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          }
        }
        class Uf {
          constructor(t, n, c, p) {
            this._el = t, this._touchZoom = n, this._touchRotate = c, this._tapDragZoom = p, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(t) {
            this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        const xc = (u) => u.zoom || u.drag || u.pitch || u.rotate;
        class Oh extends i.z {
        }
        class vs {
          constructor() {
            this.constants = [1, 1, 0.01], this.radius = 0;
          }
          setup(t, n) {
            const c = i.ab.vec3.sub([], n, t);
            this.radius = i.ab.vec3.length(c[2] < 0 ? i.ab.vec3.div([], c, this.constants) : [c[0], c[1], 0]);
          }
          projectRay(t) {
            i.ab.vec3.div(t, t, this.constants), i.ab.vec3.normalize(t, t), i.ab.vec3.mul(t, t, this.constants);
            const n = i.ab.vec3.scale([], t, this.radius);
            if (n[2] > 0) {
              const c = i.ab.vec3.scale([], [0, 0, 1], i.ab.vec3.dot(n, [0, 0, 1])), p = i.ab.vec3.scale([], i.ab.vec3.normalize([], [n[0], n[1], 0]), this.radius), v = i.ab.vec3.add([], n, i.ab.vec3.scale([], i.ab.vec3.sub([], i.ab.vec3.add([], p, c), n), 2));
              n[0] = v[0], n[1] = v[1];
            }
            return n;
          }
        }
        function Ql(u) {
          return u.panDelta && u.panDelta.mag() || u.zoomDelta || u.bearingDelta || u.pitchDelta;
        }
        class eh {
          constructor(t, n) {
            this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new df(t), this._bearingSnap = n.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new vs(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(n), i.aP(["handleEvent", "handleWindowEvent"], this);
            const c = this._el;
            this._listeners = [[c, "touchstart", { passive: !0 }], [c, "touchmove", { passive: !1 }], [c, "touchend", void 0], [c, "touchcancel", void 0], [c, "mousedown", void 0], [c, "mousemove", void 0], [c, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [c, "mouseover", void 0], [c, "mouseout", void 0], [c, "dblclick", void 0], [c, "click", void 0], [c, "keydown", { capture: !1 }], [c, "keyup", void 0], [c, "wheel", { passive: !1 }], [c, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [p, v, C] of this._listeners) {
              const V = p === document ? this.handleWindowEvent : this.handleEvent;
              p.addEventListener(v, V, C);
            }
          }
          destroy() {
            for (const [t, n, c] of this._listeners) {
              const p = t === document ? this.handleWindowEvent : this.handleEvent;
              t.removeEventListener(n, p, c);
            }
          }
          _addDefaultHandlers(t) {
            const n = this._map, c = n.getCanvasContainer();
            this._add("mapEvent", new Rh(n, t));
            const p = n.boxZoom = new Ea(n, t);
            this._add("boxZoom", p);
            const v = new Yl(), C = new Tl();
            n.doubleClickZoom = new El(C, v), this._add("tapZoom", v), this._add("clickZoom", C);
            const V = new Cl();
            this._add("tapDragZoom", V);
            const K = n.touchPitch = new yd(n);
            this._add("touchPitch", K);
            const se = new To(t), oe = new el(t);
            n.dragRotate = new Nf(t, se, oe), this._add("mouseRotate", se, ["mousePitch"]), this._add("mousePitch", oe, ["mouseRotate"]);
            const ve = new Qc(t), xe = new ma(n, t);
            n.dragPan = new vf(c, ve, xe), this._add("mousePan", ve), this._add("touchPan", xe, ["touchZoom", "touchRotate"]);
            const Le = new yc(), ft = new _f();
            n.touchZoomRotate = new Uf(c, ft, Le, V), this._add("touchRotate", Le, ["touchPan", "touchZoom"]), this._add("touchZoom", ft, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new vd(n));
            const st = n.scrollZoom = new Co(n, this);
            this._add("scrollZoom", st, ["mousePan"]);
            const vt = n.keyboard = new gs();
            this._add("keyboard", vt);
            for (const gt of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) t.interactive && t[gt] && n[gt].enable(t[gt]);
          }
          _add(t, n, c) {
            this._handlers.push({ handlerName: t, handler: n, allowed: c }), this._handlersById[t] = n;
          }
          stop(t) {
            if (!this._updatingCamera) {
              for (const { handler: n } of this._handlers) n.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [], this._originalZoom = void 0;
            }
          }
          isActive() {
            for (const { handler: t } of this._handlers) if (t.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!xc(this._eventsInProgress) || this.isZooming();
          }
          _isDragging() {
            return !!this._eventsInProgress.drag;
          }
          _blockedByActive(t, n, c) {
            for (const p in t) if (p !== c && (!n || n.indexOf(p) < 0)) return !0;
            return !1;
          }
          handleWindowEvent(t) {
            this.handleEvent(t, `${t.type}Window`);
          }
          _getMapTouches(t) {
            const n = [];
            for (const c of t) this._el.contains(c.target) && n.push(c);
            return n;
          }
          handleEvent(t, n) {
            this._updatingCamera = !0;
            const c = t.type === "renderFrame", p = c ? void 0 : t, v = { needsRenderFrame: !1 }, C = {}, V = {}, K = t.touches ? this._getMapTouches(t.touches) : void 0, se = K ? ee(this._el, K) : c ? void 0 : J(this._el, t);
            for (const { handlerName: xe, handler: Le, allowed: ft } of this._handlers) {
              if (!Le.isEnabled()) continue;
              let st;
              this._blockedByActive(V, ft, xe) ? Le.reset() : Le[n || t.type] && (st = Le[n || t.type](t, se, K), this.mergeHandlerResult(v, C, st, xe, p), st && st.needsRenderFrame && this._triggerRenderFrame()), (st || Le.isActive()) && (V[xe] = Le);
            }
            const oe = {};
            for (const xe in this._previousActiveHandlers) V[xe] || (oe[xe] = p);
            this._previousActiveHandlers = V, (Object.keys(oe).length || Ql(v)) && (this._changes.push([v, C, oe]), this._triggerRenderFrame()), (Object.keys(V).length || Ql(v)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: ve } = v;
            ve && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], ve(this._map));
          }
          mergeHandlerResult(t, n, c, p, v) {
            if (!c) return;
            i.l(t, c);
            const C = { handlerName: p, originalEvent: c.originalEvent || v };
            c.zoomDelta !== void 0 && (n.zoom = C), c.panDelta !== void 0 && (n.drag = C), c.pitchDelta !== void 0 && (n.pitch = C), c.bearingDelta !== void 0 && (n.rotate = C);
          }
          _applyChanges() {
            const t = {}, n = {}, c = {};
            for (const [p, v, C] of this._changes) p.panDelta && (t.panDelta = (t.panDelta || new i.P(0, 0))._add(p.panDelta)), p.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + p.zoomDelta), p.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + p.bearingDelta), p.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + p.pitchDelta), p.around !== void 0 && (t.around = p.around), p.aroundCoord !== void 0 && (t.aroundCoord = p.aroundCoord), p.pinchAround !== void 0 && (t.pinchAround = p.pinchAround), p.noInertia && (t.noInertia = p.noInertia), i.l(n, v), i.l(c, C);
            this._updateMapTransform(t, n, c), this._changes = [];
          }
          _updateMapTransform(t, n, c) {
            const p = this._map, v = p.transform, C = (Rt) => [Rt.x, Rt.y, Rt.z];
            if (((Rt) => {
              const qt = this._eventsInProgress.drag;
              return qt && !this._handlersById[qt.handlerName].isActive();
            })() && !Ql(t)) {
              const Rt = v.zoom;
              v.cameraElevationReference = "sea", this._originalZoom != null && v._orthographicProjectionAtLowPitch && v.projection.name !== "globe" && v.pitch === 0 ? (v.cameraElevationReference = "ground", v.zoom = this._originalZoom) : (v.recenterOnTerrain(), v.cameraElevationReference = "ground"), Rt !== v.zoom && this._map._update(!0);
            }
            if (v._isCameraConstrained && p._stop(!0), !Ql(t)) return void this._fireEvents(n, c, !0);
            let { panDelta: V, zoomDelta: K, bearingDelta: se, pitchDelta: oe, around: ve, aroundCoord: xe, pinchAround: Le } = t;
            v._isCameraConstrained && (K > 0 && (K = 0), v._isCameraConstrained = !1), Le !== void 0 && (ve = Le), (K || ((Rt) => n[Rt] && !this._eventsInProgress[Rt])("drag")) && ve && (this._dragOrigin = C(v.pointCoordinate3D(ve)), this._originalZoom = v.zoom, this._trackingEllipsoid.setup(v._camera.position, this._dragOrigin)), v.cameraElevationReference = "sea", p._stop(!0), ve = ve || p.transform.centerPoint, se && (v.bearing += se), oe && (v.pitch += oe), v._updateCameraState();
            const ft = [0, 0, 0];
            if (V) if (v.projection.name === "mercator") {
              const Rt = this._trackingEllipsoid.projectRay(v.screenPointToMercatorRay(ve).dir), qt = this._trackingEllipsoid.projectRay(v.screenPointToMercatorRay(ve.sub(V)).dir);
              ft[0] = qt[0] - Rt[0], ft[1] = qt[1] - Rt[1];
            } else {
              const Rt = v.pointCoordinate(ve);
              if (v.projection.name === "globe") {
                V = V.rotate(-v.angle);
                const qt = v._pixelsPerMercatorPixel / v.worldSize;
                ft[0] = -V.x * i.dB(i.aS(Rt.y)) * qt, ft[1] = -V.y * i.dB(v.center.lat) * qt;
              } else {
                const qt = v.pointCoordinate(ve.sub(V));
                Rt && qt && (ft[0] = qt.x - Rt.x, ft[1] = qt.y - Rt.y);
              }
            }
            const st = v.zoom, vt = [0, 0, 0];
            if (K) {
              const Rt = C(xe || v.pointCoordinate3D(ve)), qt = { dir: i.ab.vec3.normalize([], i.ab.vec3.sub([], Rt, v._camera.position)) };
              if (qt.dir[2] < 0) {
                const jt = v.zoomDeltaToMovement(Rt, K);
                i.ab.vec3.scale(vt, qt.dir, jt);
              }
            }
            const gt = i.ab.vec3.add(ft, ft, vt);
            v._translateCameraConstrained(gt), K && Math.abs(v.zoom - st) > 1e-4 && v.recenterOnTerrain(), v.cameraElevationReference = "ground", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(n, c, !0);
          }
          _fireEvents(t, n, c) {
            const p = xc(this._eventsInProgress), v = xc(t), C = {};
            for (const oe in t) {
              const { originalEvent: ve } = t[oe];
              this._eventsInProgress[oe] || (C[`${oe}start`] = ve), this._eventsInProgress[oe] = t[oe];
            }
            !p && v && this._fireEvent("movestart", v.originalEvent);
            for (const oe in C) this._fireEvent(oe, C[oe]);
            v && this._fireEvent("move", v.originalEvent);
            for (const oe in t) {
              const { originalEvent: ve } = t[oe];
              this._fireEvent(oe, ve);
            }
            const V = {};
            let K;
            for (const oe in this._eventsInProgress) {
              const { handlerName: ve, originalEvent: xe } = this._eventsInProgress[oe];
              this._handlersById[ve].isActive() || (delete this._eventsInProgress[oe], K = n[ve] || xe, V[`${oe}end`] = K);
            }
            for (const oe in V) this._fireEvent(oe, V[oe]);
            const se = xc(this._eventsInProgress);
            if (c && (p || v) && !se) {
              this._updatingCamera = !0;
              const oe = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), ve = (xe) => xe !== 0 && -this._bearingSnap < xe && xe < this._bearingSnap;
              oe ? (ve(oe.bearing || this._map.getBearing()) && (oe.bearing = 0), this._map.easeTo(oe, { originalEvent: K })) : (this._map.fire(new i.z("moveend", { originalEvent: K })), ve(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
            }
          }
          _fireEvent(t, n) {
            this._map.fire(new i.z(t, n ? { originalEvent: n } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t) => {
              this._frameId = void 0, this.handleEvent(new Oh("renderFrame", { timeStamp: t })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        const Vf = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class Ou extends i.E {
          constructor(t, n) {
            super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = n.bearingSnap, this._respectPrefersReducedMotion = n.respectPrefersReducedMotion !== !1, i.aP(["_renderFrameCallback"], this);
          }
          getCenter() {
            return new i.bO(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(t, n) {
            return this.jumpTo({ center: t }, n);
          }
          panBy(t, n, c) {
            return t = i.P.convert(t).mult(-1), this.panTo(this.transform.center, i.l({ offset: t }, n), c);
          }
          panTo(t, n, c) {
            return this.easeTo(i.l({ center: t }, n), c);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(t, n) {
            return this.jumpTo({ zoom: t }, n), this;
          }
          zoomTo(t, n, c) {
            return this.easeTo(i.l({ zoom: t }, n), c);
          }
          zoomIn(t, n) {
            return this.zoomTo(this.getZoom() + 1, t, n), this;
          }
          zoomOut(t, n) {
            return this.zoomTo(this.getZoom() - 1, t, n), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(t, n) {
            return this.jumpTo({ bearing: t }, n), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(t, n) {
            return this.jumpTo({ padding: t }, n), this;
          }
          rotateTo(t, n, c) {
            return this.easeTo(i.l({ bearing: t }, n), c);
          }
          resetNorth(t, n) {
            return this.rotateTo(0, i.l({ duration: 1e3 }, t), n), this;
          }
          resetNorthPitch(t, n) {
            return this.easeTo(i.l({ bearing: 0, pitch: 0, duration: 1e3 }, t), n), this;
          }
          snapToNorth(t, n) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, n) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(t, n) {
            return this.jumpTo({ pitch: t }, n), this;
          }
          cameraForBounds(t, n) {
            t = i.az.convert(t);
            const c = n && n.bearing || 0, p = n && n.pitch || 0, v = t.getNorthWest(), C = t.getSouthEast();
            return this._cameraForBounds(this.transform, v, C, c, p, n);
          }
          _extendPadding(t) {
            const n = { top: 0, right: 0, bottom: 0, left: 0 };
            return t == null ? i.l({}, n, this.transform.padding) : typeof t == "number" ? { top: t, bottom: t, right: t, left: t } : i.l({}, n, t);
          }
          _extendCameraOptions(t) {
            return (t = i.l({ offset: [0, 0], maxZoom: this.transform.maxZoom }, t)).padding = this._extendPadding(t.padding), t;
          }
          _minimumAABBFrustumDistance(t, n) {
            const c = n.max[0] - n.min[0], p = n.max[1] - n.min[1];
            return c / p > t.aspect ? c / (2 * Math.tan(0.5 * t.fovX) * t.aspect) : p / (2 * Math.tan(0.5 * t.fovY) * t.aspect);
          }
          _cameraForBoundsOnGlobe(t, n, c, p, v, C) {
            const V = t.clone(), K = this._extendCameraOptions(C);
            V.bearing = p, V.pitch = v;
            const se = i.bO.convert(n), oe = i.bO.convert(c), ve = 0.5 * (se.lat + oe.lat), xe = 0.5 * (se.lng + oe.lng), Le = i.dC(ve, xe), ft = i.ab.vec3.normalize([], Le), st = i.ab.vec3.normalize([], i.ab.vec3.cross([], ft, [0, 1, 0])), vt = i.ab.vec3.cross([], st, ft), gt = [st[0], st[1], st[2], 0, vt[0], vt[1], vt[2], 0, ft[0], ft[1], ft[2], 0, 0, 0, 0, 1], Rt = [Le, i.dC(se.lat, se.lng), i.dC(oe.lat, se.lng), i.dC(oe.lat, oe.lng), i.dC(se.lat, oe.lng), i.dC(ve, se.lng), i.dC(ve, oe.lng), i.dC(se.lat, xe), i.dC(oe.lat, xe)];
            let qt = i.cd.fromPoints(Rt.map((Mi) => [i.ab.vec3.dot(st, Mi), i.ab.vec3.dot(vt, Mi), i.ab.vec3.dot(ft, Mi)]));
            const jt = i.ab.vec3.transformMat4([], qt.center, gt);
            i.ab.vec3.squaredLength(jt) === 0 && i.ab.vec3.set(jt, 0, 0, 1), i.ab.vec3.normalize(jt, jt), i.ab.vec3.scale(jt, jt, i.ax), V.center = i.dD(jt);
            const ii = V.getWorldToCameraMatrix(), Xt = i.ab.mat4.invert(new Float64Array(16), ii);
            qt = i.cd.applyTransform(qt, i.ab.mat4.multiply([], ii, gt));
            const Kt = this._extendAABB(qt, V, K, p);
            if (!Kt) return void i.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            qt = Kt, i.ab.vec3.transformMat4(jt, jt, ii);
            const Zt = 0.5 * (qt.max[2] - qt.min[2]), Jt = this._minimumAABBFrustumDistance(V, qt), ui = i.ab.vec3.scale([], [0, 0, 1], Zt), Ti = i.ab.vec3.add(ui, jt, ui), xi = Jt + (V.pitch === 0 ? 0 : i.ab.vec3.distance(jt, Ti)), Pi = V.globeCenterInViewSpace, Ri = i.ab.vec3.sub([], jt, [Pi[0], Pi[1], Pi[2]]);
            i.ab.vec3.normalize(Ri, Ri), i.ab.vec3.scale(Ri, Ri, xi);
            const mi = i.ab.vec3.add([], jt, Ri);
            i.ab.vec3.transformMat4(mi, mi, Xt);
            const Ai = i.ds / i.ax, ji = i.ab.vec3.length(mi), yi = i.bH(Math.max(ji * Ai - i.ds, Number.EPSILON), 0), Ni = Math.min(V.zoomFromMercatorZAdjusted(yi), K.maxZoom);
            return Ni > 0.5 * (i.c6 + i.bY) ? (V.setProjection({ name: "mercator" }), V.zoom = Ni, this._cameraForBounds(V, n, c, p, v, C)) : { center: V.center, zoom: Ni, bearing: p, pitch: v };
          }
          _extendAABB(t, n, c, p) {
            const v = 0.5 * ((c.padding.left || 0) + (c.padding.right || 0)), C = 0.5 * ((c.padding.top || 0) + (c.padding.bottom || 0)), V = C, K = v, se = v, oe = C, ve = n.width - (K + se), xe = n.height - (V + oe), Le = i.ab.vec3.sub([], t.max, t.min), ft = Math.min(ve / Le[0], xe / Le[1]), st = Math.min(n.scaleZoom(n.scale * ft), c.maxZoom);
            if (isNaN(st)) return null;
            const vt = n.scale / n.zoomScale(st), gt = new i.cd([t.min[0] - K * vt, t.min[1] - oe * vt, t.min[2]], [t.max[0] + se * vt, t.max[1] + V * vt, t.max[2]]), Rt = (typeof c.offset.x == "number" && typeof c.offset.y == "number" ? new i.P(c.offset.x, c.offset.y) : i.P.convert(c.offset)).rotate(-i.ai(p));
            return gt.center[0] -= Rt.x * vt, gt.center[1] += Rt.y * vt, gt;
          }
          queryTerrainElevation(t, n) {
            const c = this.transform.elevation;
            return c ? (n = i.l({}, { exaggerated: !0 }, n), c.getAtPoint(i.aa.fromLngLat(t), null, n.exaggerated)) : null;
          }
          _cameraForBounds(t, n, c, p, v, C) {
            if (t.projection.name === "globe") return this._cameraForBoundsOnGlobe(t, n, c, p, v, C);
            const V = t.clone(), K = this._extendCameraOptions(C);
            V.bearing = p, V.pitch = v;
            const se = i.bO.convert(n), oe = i.bO.convert(c), ve = new i.bO(se.lng, oe.lat), xe = new i.bO(oe.lng, se.lat), Le = V.project(se), ft = V.project(oe), st = this.queryTerrainElevation(se), vt = this.queryTerrainElevation(oe), gt = this.queryTerrainElevation(ve), Rt = this.queryTerrainElevation(xe), qt = [[Le.x, Le.y, Math.min(st || 0, vt || 0, gt || 0, Rt || 0)], [ft.x, ft.y, Math.max(st || 0, vt || 0, gt || 0, Rt || 0)]];
            let jt = i.cd.fromPoints(qt);
            const ii = V.getWorldToCameraMatrix(), Xt = i.ab.mat4.invert(new Float64Array(16), ii);
            jt = i.cd.applyTransform(jt, ii);
            const Kt = this._extendAABB(jt, V, K, p);
            if (!Kt) return void i.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            jt = Kt;
            const Zt = 0.5 * i.ab.vec3.sub([], jt.max, jt.min)[2], Jt = this._minimumAABBFrustumDistance(V, jt), ui = [0, 0, 1, 0];
            i.ab.vec4.transformMat4(ui, ui, ii), i.ab.vec4.normalize(ui, ui);
            const Ti = i.ab.vec3.scale([], ui, Jt + Zt), xi = i.ab.vec3.add([], jt.center, Ti);
            i.ab.vec3.transformMat4(jt.center, jt.center, Xt), i.ab.vec3.transformMat4(xi, xi, Xt);
            const Pi = V.unproject(new i.P(jt.center[0], jt.center[1])), Ri = i.dE(V.projection, Pi), mi = Math.pow(2, Ri), Ai = Math.min(V._zoomFromMercatorZ(xi[2] * V.pixelsPerMeter * mi / V.worldSize), K.maxZoom);
            return V.mercatorFromTransition && Ai < 0.5 * (i.c6 + i.bY) ? (V.setProjection({ name: "globe" }), V.zoom = Ai, this._cameraForBounds(V, n, c, p, v, C)) : { center: Pi, zoom: Ai, bearing: p, pitch: v };
          }
          fitBounds(t, n, c) {
            const p = this.cameraForBounds(t, n);
            return this._fitInternal(p, n, c);
          }
          fitScreenCoordinates(t, n, c, p, v) {
            const C = i.P.convert(t), V = i.P.convert(n), K = new i.P(Math.min(C.x, V.x), Math.min(C.y, V.y)), se = new i.P(Math.max(C.x, V.x), Math.max(C.y, V.y));
            if (this.transform.projection.name === "mercator" && this.transform.anyCornerOffEdge(C, V)) return this;
            const oe = this.transform.pointLocation3D(K), ve = this.transform.pointLocation3D(se), xe = this.transform.pointLocation3D(new i.P(K.x, se.y)), Le = this.transform.pointLocation3D(new i.P(se.x, K.y)), ft = [Math.min(oe.lng, ve.lng, xe.lng, Le.lng), Math.min(oe.lat, ve.lat, xe.lat, Le.lat)], st = [Math.max(oe.lng, ve.lng, xe.lng, Le.lng), Math.max(oe.lat, ve.lat, xe.lat, Le.lat)], vt = p && p.pitch ? p.pitch : this.getPitch(), gt = this._cameraForBounds(this.transform, ft, st, c, vt, p);
            return this._fitInternal(gt, p, v);
          }
          _fitInternal(t, n, c) {
            return t ? (n = i.l(t, n)).linear ? this.easeTo(n, c) : this.flyTo(n, c) : this;
          }
          jumpTo(t, n) {
            this.stop();
            const c = t.preloadOnly ? this.transform.clone() : this.transform;
            let p = !1, v = !1, C = !1;
            "zoom" in t && c.zoom !== +t.zoom && (p = !0, c.zoom = +t.zoom), t.center !== void 0 && (c.center = i.bO.convert(t.center)), "bearing" in t && c.bearing !== +t.bearing && (v = !0, c.bearing = +t.bearing), "pitch" in t && c.pitch !== +t.pitch && (C = !0, c.pitch = +t.pitch);
            const V = typeof t.padding == "number" ? this._extendPadding(t.padding) : t.padding;
            if (t.padding != null && !c.isPaddingEqual(V)) if (t.retainPadding === !1) {
              const K = c.clone();
              K.padding = V, c.setLocationAtPoint(c.center, K.centerPoint);
            } else c.padding = V;
            return t.preloadOnly ? (this._preloadTiles(c), this) : (this.fire(new i.z("movestart", n)).fire(new i.z("move", n)), p && this.fire(new i.z("zoomstart", n)).fire(new i.z("zoom", n)).fire(new i.z("zoomend", n)), v && this.fire(new i.z("rotatestart", n)).fire(new i.z("rotate", n)).fire(new i.z("rotateend", n)), C && this.fire(new i.z("pitchstart", n)).fire(new i.z("pitch", n)).fire(new i.z("pitchend", n)), this.fire(new i.z("moveend", n)));
          }
          getFreeCameraOptions() {
            return this.transform.projection.supportsFreeCamera || i.w(Vf), this.transform.getFreeCameraOptions();
          }
          setFreeCameraOptions(t, n) {
            const c = this.transform;
            if (!c.projection.supportsFreeCamera) return i.w(Vf), this;
            this.stop();
            const p = c.zoom, v = c.pitch, C = c.bearing;
            c.setFreeCameraOptions(t);
            const V = p !== c.zoom, K = v !== c.pitch, se = C !== c.bearing;
            return this.fire(new i.z("movestart", n)).fire(new i.z("move", n)), V && this.fire(new i.z("zoomstart", n)).fire(new i.z("zoom", n)).fire(new i.z("zoomend", n)), se && this.fire(new i.z("rotatestart", n)).fire(new i.z("rotate", n)).fire(new i.z("rotateend", n)), K && this.fire(new i.z("pitchstart", n)).fire(new i.z("pitch", n)).fire(new i.z("pitchend", n)), this.fire(new i.z("moveend", n)), this;
          }
          easeTo(t, n) {
            this._stop(!1, t.easeId), ((t = i.l({ offset: [0, 0], duration: 500, easing: i.dA }, t)).animate === !1 || this._prefersReducedMotion(t)) && (t.duration = 0);
            const c = this.transform, p = this.getZoom(), v = this.getBearing(), C = this.getPitch(), V = this.getPadding(), K = "zoom" in t ? +t.zoom : p, se = "bearing" in t ? this._normalizeBearing(t.bearing, v) : v, oe = "pitch" in t ? +t.pitch : C, ve = this._extendPadding(t.padding), xe = i.P.convert(t.offset);
            let Le, ft, st;
            if (c.projection.name === "globe") {
              const ui = i.aa.fromLngLat(c.center), Ti = xe.rotate(-c.angle);
              ui.x += Ti.x / c.worldSize, ui.y += Ti.y / c.worldSize;
              const xi = ui.toLngLat(), Pi = i.bO.convert(t.center || xi);
              this._normalizeCenter(Pi), Le = c.centerPoint.add(Ti), ft = new i.P(ui.x, ui.y).mult(c.worldSize), st = new i.P(i.at(Pi.lng), i.aA(Pi.lat)).mult(c.worldSize).sub(ft);
            } else {
              Le = c.centerPoint.add(xe);
              const ui = c.pointLocation(Le), Ti = i.bO.convert(t.center || ui);
              this._normalizeCenter(Ti), ft = c.project(ui), st = c.project(Ti).sub(ft);
            }
            const vt = c.zoomScale(K - p);
            let gt, Rt;
            t.around && (gt = i.bO.convert(t.around), Rt = c.locationPoint(gt));
            const qt = this._zooming || K !== p, jt = this._rotating || v !== se, ii = this._pitching || oe !== C, Xt = !c.isPaddingEqual(ve), Kt = t.retainPadding === !1 ? c.clone() : c, Zt = (ui) => (Ti) => {
              if (qt && (ui.zoom = i.af(p, K, Ti)), jt && (ui.bearing = i.af(v, se, Ti)), ii && (ui.pitch = i.af(C, oe, Ti)), Xt && (Kt.interpolatePadding(V, ve, Ti), Le = Kt.centerPoint.add(xe)), gt) ui.setLocationAtPoint(gt, Rt);
              else {
                const xi = ui.zoomScale(ui.zoom - p), Pi = K > p ? Math.min(2, vt) : Math.max(0.5, vt), Ri = Math.pow(Pi, 1 - Ti), mi = ui.unproject(ft.add(st.mult(Ti * Ri)).mult(xi));
                ui.setLocationAtPoint(ui.renderWorldCopies ? mi.wrap() : mi, Le);
              }
              return t.preloadOnly || this._fireMoveEvents(n), ui;
            };
            if (t.preloadOnly) {
              const ui = this._emulate(Zt, t.duration, c);
              return this._preloadTiles(ui), this;
            }
            const Jt = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
            return this._zooming = qt, this._rotating = jt, this._pitching = ii, this._padding = Xt, this._easeId = t.easeId, this._prepareEase(n, t.noMoveStart, Jt), this._ease(Zt(c), (ui) => {
              c.cameraElevationReference === "sea" && c.recenterOnTerrain(), this._afterEase(n, ui);
            }, t), this;
          }
          _prepareEase(t, n, c = {}) {
            this._moving = !0, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && this.transform.pitch === 0 && this.transform.projection.name !== "globe" && (this.transform.cameraElevationReference = "ground"), n || c.moving || this.fire(new i.z("movestart", t)), this._zooming && !c.zooming && this.fire(new i.z("zoomstart", t)), this._rotating && !c.rotating && this.fire(new i.z("rotatestart", t)), this._pitching && !c.pitching && this.fire(new i.z("pitchstart", t));
          }
          _fireMoveEvents(t) {
            this.fire(new i.z("move", t)), this._zooming && this.fire(new i.z("zoom", t)), this._rotating && this.fire(new i.z("rotate", t)), this._pitching && this.fire(new i.z("pitch", t));
          }
          _afterEase(t, n) {
            if (this._easeId && n && this._easeId === n) return;
            this._easeId = void 0, this.transform.cameraElevationReference = "ground";
            const c = this._zooming, p = this._rotating, v = this._pitching;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, c && this.fire(new i.z("zoomend", t)), p && this.fire(new i.z("rotateend", t)), v && this.fire(new i.z("pitchend", t)), this.fire(new i.z("moveend", t));
          }
          flyTo(t, n) {
            if (this._prefersReducedMotion(t)) {
              const Mi = i.ay(t, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
              return this.jumpTo(Mi, n);
            }
            this.stop(), t = i.l({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: i.dA }, t);
            const c = this.transform, p = this.getZoom(), v = this.getBearing(), C = this.getPitch(), V = this.getPadding(), K = "zoom" in t ? i.aw(+t.zoom, c.minZoom, c.maxZoom) : p, se = "bearing" in t ? this._normalizeBearing(t.bearing, v) : v, oe = "pitch" in t ? +t.pitch : C, ve = this._extendPadding(t.padding), xe = c.zoomScale(K - p), Le = i.P.convert(t.offset);
            let ft = c.centerPoint.add(Le);
            const st = c.pointLocation(ft), vt = i.bO.convert(t.center || st);
            this._normalizeCenter(vt);
            const gt = c.project(st), Rt = c.project(vt).sub(gt);
            let qt = t.curve;
            const jt = Math.max(c.width, c.height), ii = jt / xe, Xt = Rt.mag();
            if ("minZoom" in t) {
              const Mi = i.aw(Math.min(t.minZoom, p, K), c.minZoom, c.maxZoom), Yi = jt / c.zoomScale(Mi - p);
              qt = Math.sqrt(Yi / Xt * 2);
            }
            const Kt = qt * qt;
            function Zt(Mi) {
              const Yi = (ii * ii - jt * jt + (Mi ? -1 : 1) * Kt * Kt * Xt * Xt) / (2 * (Mi ? ii : jt) * Kt * Xt);
              return Math.log(Math.sqrt(Yi * Yi + 1) - Yi);
            }
            function Jt(Mi) {
              return (Math.exp(Mi) - Math.exp(-Mi)) / 2;
            }
            function ui(Mi) {
              return (Math.exp(Mi) + Math.exp(-Mi)) / 2;
            }
            const Ti = Zt(0);
            let xi = function(Mi) {
              return ui(Ti) / ui(Ti + qt * Mi);
            }, Pi = function(Mi) {
              return jt * ((ui(Ti) * (Jt(Yi = Ti + qt * Mi) / ui(Yi)) - Jt(Ti)) / Kt) / Xt;
              var Yi;
            }, Ri = (Zt(1) - Ti) / qt;
            if (Math.abs(Xt) < 1e-6 || !isFinite(Ri)) {
              if (Math.abs(jt - ii) < 1e-6) return this.easeTo(t, n);
              const Mi = ii < jt ? -1 : 1;
              Ri = Math.abs(Math.log(ii / jt)) / qt, Pi = function() {
                return 0;
              }, xi = function(Yi) {
                return Math.exp(Mi * qt * Yi);
              };
            }
            t.duration = "duration" in t ? +t.duration : 1e3 * Ri / ("screenSpeed" in t ? +t.screenSpeed / qt : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);
            const mi = v !== se, Ai = oe !== C, ji = !c.isPaddingEqual(ve), yi = t.retainPadding === !1 ? c.clone() : c, Ni = (Mi) => (Yi) => {
              const Ui = Yi * Ri, Fi = 1 / xi(Ui);
              Mi.zoom = Yi === 1 ? K : p + Mi.scaleZoom(Fi), mi && (Mi.bearing = i.af(v, se, Yi)), Ai && (Mi.pitch = i.af(C, oe, Yi)), ji && (yi.interpolatePadding(V, ve, Yi), ft = yi.centerPoint.add(Le));
              const Zi = Yi === 1 ? vt : Mi.unproject(gt.add(Rt.mult(Pi(Ui))).mult(Fi));
              return Mi.setLocationAtPoint(Mi.renderWorldCopies ? Zi.wrap() : Zi, ft), Mi._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(n), Mi;
            };
            if (t.preloadOnly) {
              const Mi = this._emulate(Ni, t.duration, c);
              return this._preloadTiles(Mi), this;
            }
            return this._zooming = !0, this._rotating = mi, this._pitching = Ai, this._padding = ji, this._prepareEase(n, !1), this._ease(Ni(c), () => this._afterEase(n), t), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _requestRenderFrame(t) {
          }
          _cancelRenderFrame(t) {
          }
          _stop(t, n) {
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
              const c = this._onEaseEnd;
              this._onEaseEnd = void 0, c.call(this, n);
            }
            if (!t) {
              const c = this.handlers;
              c && c.stop(!1);
            }
            return this;
          }
          _ease(t, n, c) {
            c.animate === !1 || c.duration === 0 ? (t(1), n()) : (this._easeStart = i.q.now(), this._easeOptions = c, this._onEaseFrame = t, this._onEaseEnd = n, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _renderFrameCallback() {
            const t = Math.min((i.q.now() - this._easeStart) / this._easeOptions.duration, 1), n = this._onEaseFrame;
            n && n(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }
          _normalizeBearing(t, n) {
            t = i.bF(t, -180, 180);
            const c = Math.abs(t - n);
            return Math.abs(t - 360 - n) < c && (t -= 360), Math.abs(t + 360 - n) < c && (t += 360), t;
          }
          _normalizeCenter(t) {
            const n = this.transform;
            if (n.maxBounds || n.projection.name !== "globe" && !n.renderWorldCopies) return;
            const c = t.lng - n.center.lng;
            t.lng += c > 180 ? -360 : c < -180 ? 360 : 0;
          }
          _prefersReducedMotion(t) {
            return this._respectPrefersReducedMotion && i.q.prefersReducedMotion && !(t && t.essential);
          }
          _emulate(t, n, c) {
            const p = Math.ceil(15 * n / 1e3), v = [], C = t(c.clone());
            for (let V = 0; V <= p; V++) {
              const K = C(V / p);
              v.push(K.clone());
            }
            return v;
          }
          _preloadTiles(t, n) {
          }
        }
        class bc {
          constructor(t = {}) {
            this.options = t, i.aP(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(t) {
            const n = this.options && this.options.compact, c = t._getUIString("AttributionControl.ToggleAttribution");
            this._map = t, this._container = w("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = w("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", c);
            const p = w("span", "mapboxgl-ctrl-icon", this._compactButton);
            return p.setAttribute("aria-hidden", "true"), p.setAttribute("title", c), this._innerContainer = w("div", "mapboxgl-ctrl-attrib-inner", this._container), n && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), n === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
          }
          _toggleAttribution() {
            this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
          }
          _updateEditLink() {
            let t = this._editLink;
            t || (t = this._editLink = this._container.querySelector(".mapbox-improve-map"));
            const n = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || i.e.ACCESS_TOKEN }];
            if (t) {
              const c = n.reduce((p, v, C) => (v.value && (p += `${v.key}=${v.value}${C < n.length - 1 ? "&" : ""}`), p), "?");
              t.href = `${i.e.FEEDBACK_URL}/${c}#${Ph(this._map, !0)}`, t.rel = "noopener nofollow";
            }
          }
          _updateData(t) {
            !t || t.sourceDataType !== "metadata" && t.sourceDataType !== "visibility" && t.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let t = [];
            if (this._map.style.stylesheet) {
              const p = this._map.style.stylesheet;
              this.styleOwner = p.owner, this.styleId = p.id;
            }
            const n = this._map.style._mergedSourceCaches;
            for (const p in n) {
              const v = n[p];
              if (v.used) {
                const C = v.getSource();
                C.attribution && t.indexOf(C.attribution) < 0 && t.push(C.attribution);
              }
            }
            t.sort((p, v) => p.length - v.length), t = t.filter((p, v) => {
              for (let C = v + 1; C < t.length; C++) if (t[C].indexOf(p) >= 0) return !1;
              return !0;
            }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = [...this.options.customAttribution, ...t] : t.unshift(this.options.customAttribution));
            const c = t.join(" | ");
            c !== this._attribHTML && (this._attribHTML = c, t.length ? (this._innerContainer.innerHTML = c, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
          }
          _updateCompact() {
            this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
          }
        }
        class Ys {
          constructor() {
            i.aP(["_updateLogo", "_updateCompact"], this);
          }
          onAdd(t) {
            this._map = t, this._container = w("div", "mapboxgl-ctrl");
            const n = w("a", "mapboxgl-ctrl-logo");
            return n.target = "_blank", n.rel = "noopener nofollow", n.href = "https://www.mapbox.com/", n.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), n.setAttribute("rel", "noopener nofollow"), this._container.appendChild(n), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _updateLogo(t) {
            t && t.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
          }
          _logoRequired() {
            if (!this._map.style) return !0;
            const t = this._map.style._sourceCaches;
            if (Object.entries(t).length === 0) return !0;
            for (const n in t) {
              const c = t[n].getSource();
              if (c.hasOwnProperty("mapbox_logo") && !c.mapbox_logo) return !1;
            }
            return !0;
          }
          _updateCompact() {
            const t = this._container.children;
            if (t.length) {
              const n = t[0];
              this._map.getCanvasContainer().offsetWidth < 250 ? n.classList.add("mapboxgl-compact") : n.classList.remove("mapboxgl-compact");
            }
          }
        }
        class Ts {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(t) {
            const n = ++this._id;
            return this._queue.push({ callback: t, id: n, cancelled: !1 }), n;
          }
          remove(t) {
            const n = this._currentlyRunning, c = n ? this._queue.concat(n) : this._queue;
            for (const p of c) if (p.id === t) return void (p.cancelled = !0);
          }
          run(t = 0) {
            const n = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const c of n) if (!c.cancelled && (c.callback(t), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        class Ks {
          constructor(t) {
            this.jumpTo(t);
          }
          getValue(t) {
            if (t <= this._startTime) return this._start;
            if (t >= this._endTime) return this._end;
            const n = i.cB((t - this._startTime) / (this._endTime - this._startTime));
            return this._start * (1 - n) + this._end * n;
          }
          isEasing(t) {
            return t >= this._startTime && t <= this._endTime;
          }
          jumpTo(t) {
            this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = t, this._end = t;
          }
          easeTo(t, n, c) {
            this._start = this.getValue(n), this._end = t, this._startTime = n, this._endTime = n + c;
          }
        }
        const Du = { "AttributionControl.ToggleAttribution": "Toggle attribution", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox homepage", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use  + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" };
        class eu extends i.z {
          constructor(t, n, c, p) {
            const { point: v, lngLat: C, originalEvent: V, target: K } = t;
            super(t.type, { point: v, lngLat: C, originalEvent: V, target: K }), this.preventDefault = () => {
              t.preventDefault();
            }, this.id = n, this.interaction = c, this.feature = p;
          }
        }
        class th {
          constructor(t) {
            this.map = t, this.interactionsByType = /* @__PURE__ */ new Map(), this.delegatedInteractions = /* @__PURE__ */ new Map(), this.typeById = /* @__PURE__ */ new Map(), this.filters = /* @__PURE__ */ new Map(), this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = /* @__PURE__ */ new Map(), this.prevHoveredFeatures = /* @__PURE__ */ new Map();
          }
          add(t, n) {
            if (this.typeById.has(t)) throw new Error(`Interaction id "${t}" already exists.`);
            const c = n.filter;
            let p = n.type;
            c && this.filters.set(t, i.aZ(c)), p === "mouseover" && (p = "mouseenter"), p === "mouseout" && (p = "mouseleave");
            const v = this.interactionsByType.get(p) || /* @__PURE__ */ new Map();
            p === "mouseenter" || p === "mouseleave" ? (this.delegatedInteractions.size === 0 && (this.map.on("mousemove", this.handleMove), this.map.on("mouseout", this.handleOut)), this.delegatedInteractions.set(t, n)) : v.size === 0 && this.map.on(p, this.handleType), v.size === 0 && this.interactionsByType.set(p, v), v.set(t, n), this.typeById.set(t, p);
          }
          get(t) {
            const n = this.typeById.get(t);
            if (!n) return;
            const c = this.interactionsByType.get(n);
            return c ? c.get(t) : void 0;
          }
          remove(t) {
            const n = this.typeById.get(t);
            if (!n) return;
            this.typeById.delete(t), this.filters.delete(t);
            const c = this.interactionsByType.get(n);
            c && (c.delete(t), n === "mouseenter" || n === "mouseleave" ? (this.delegatedInteractions.delete(t), this.delegatedInteractions.size === 0 && (this.map.off("mousemove", this.handleMove), this.map.off("mouseout", this.handleOut))) : c.size === 0 && this.map.off(n, this.handleType));
          }
          queryTargets(t, n) {
            const c = [];
            for (const [p, v] of n) v.target && c.push({ targetId: p, target: v.target, filter: this.filters.get(p) });
            return this.map.style.queryRenderedTargets(t, c, this.map.transform);
          }
          handleMove(t) {
            this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = /* @__PURE__ */ new Map();
            const n = this.queryTargets(t.point, Array.from(this.delegatedInteractions).reverse());
            n.length && (t.type = "mouseenter", this.handleType(t, n));
            const c = /* @__PURE__ */ new Map();
            for (const [p, { feature: v }] of this.prevHoveredFeatures) this.hoveredFeatures.has(p) || c.set(v.id, v);
            c.size && (t.type = "mouseleave", this.handleType(t, Array.from(c.values())));
          }
          handleOut(t) {
            const n = Array.from(this.hoveredFeatures.values()).map(({ feature: c }) => c);
            n.length && (t.type = "mouseleave", this.handleType(t, n)), this.hoveredFeatures.clear();
          }
          handleType(t, n) {
            const c = Array.from(this.interactionsByType.get(t.type)).reverse(), p = !!n;
            n = n || this.queryTargets(t.point, c);
            const v = t.type === "mouseenter";
            let C = !1;
            const V = /* @__PURE__ */ new Set();
            for (const K of n) {
              for (const [se, oe] of c) {
                if (!oe.target) continue;
                const ve = K.variants ? K.variants[se] : null;
                if (ve) {
                  for (const xe of ve) {
                    if (ea(xe, K, V, se)) continue;
                    const Le = new i.cw(K, xe), ft = ka(xe, K, se);
                    p && (Le.state = this.map.getFeatureState(Le));
                    const st = v ? this.prevHoveredFeatures.get(ft) : null, vt = new eu(t, se, oe, Le), gt = st ? st.stop : oe.handler(vt);
                    if (v && this.hoveredFeatures.set(ft, { feature: K, stop: gt }), gt !== !1) {
                      C = !0;
                      break;
                    }
                  }
                  if (C) break;
                }
              }
              if (C) break;
            }
            if (!C) for (const [K, se] of c) {
              const { handler: oe, target: ve } = se;
              if (!ve && oe(new eu(t, K, se, null)) !== !1) break;
            }
          }
        }
        function hn(u, t) {
          if (Array.isArray(u) && Array.isArray(t)) {
            const n = new Set(u), c = new Set(t);
            return n.size === c.size && u.every((p) => c.has(p));
          }
          return i.bn(u, t);
        }
        const Al = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, performanceMetricsCollection: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, antialias: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: !0, crossSourceCollisions: !0, collectResourceTiming: !1, testMode: !1, precompilePrograms: !0, scaleFactor: 1, spriteFormat: "auto" }, ih = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
        class Cs {
          constructor(t, n, c = !1) {
            this._clickTolerance = 10, this.element = n, this.mouseRotate = new To({ clickTolerance: t.dragRotate._mouseRotate._clickTolerance }), this.map = t, c && (this.mousePitch = new el({ clickTolerance: t.dragRotate._mousePitch._clickTolerance })), i.aP(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), n.addEventListener("mousedown", this.mousedown), n.addEventListener("touchstart", this.touchstart, { passive: !1 }), n.addEventListener("touchmove", this.touchmove), n.addEventListener("touchend", this.touchend), n.addEventListener("touchcancel", this.reset);
          }
          down(t, n) {
            this.mouseRotate.mousedown(t, n), this.mousePitch && this.mousePitch.mousedown(t, n), U();
          }
          move(t, n) {
            const c = this.map, p = this.mouseRotate.mousemoveWindow(t, n), v = p && p.bearingDelta;
            if (v && c.setBearing(c.getBearing() + v), this.mousePitch) {
              const C = this.mousePitch.mousemoveWindow(t, n), V = C && C.pitchDelta;
              V && c.setPitch(c.getPitch() + V);
            }
          }
          off() {
            const t = this.element;
            t.removeEventListener("mousedown", this.mousedown), t.removeEventListener("touchstart", this.touchstart, { passive: !1 }), t.removeEventListener("touchmove", this.touchmove), t.removeEventListener("touchend", this.touchend), t.removeEventListener("touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            j(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
          }
          mousedown(t) {
            this.down(i.l({}, t, { ctrlKey: !0, preventDefault: () => t.preventDefault() }), J(this.element, t)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
          }
          mousemove(t) {
            this.move(t, J(this.element, t));
          }
          mouseup(t) {
            this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp();
          }
          touchstart(t) {
            t.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = ee(this.element, t.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: () => t.preventDefault() }, this._startPos));
          }
          touchmove(t) {
            t.targetTouches.length !== 1 ? this.reset() : (this._lastPos = ee(this.element, t.targetTouches)[0], this.move({ preventDefault: () => t.preventDefault() }, this._lastPos));
          }
          touchend(t) {
            t.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }
          reset() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }
        }
        function Dh(u, t, n) {
          if (u = new i.bO(u.lng, u.lat), t) {
            const c = new i.bO(u.lng - 360, u.lat), p = new i.bO(u.lng + 360, u.lat), v = 360 * Math.ceil(Math.abs(u.lng - n.center.lng) / 360), C = n.locationPoint(u).distSqr(t), V = t.x < 0 || t.y < 0 || t.x > n.width || t.y > n.height;
            n.locationPoint(c).distSqr(t) < C && (V || Math.abs(c.lng - n.center.lng) < v) ? u = c : n.locationPoint(p).distSqr(t) < C && (V || Math.abs(p.lng - n.center.lng) < v) && (u = p);
          }
          for (; Math.abs(u.lng - n.center.lng) > 180; ) {
            const c = n.locationPoint(u);
            if (c.x >= 0 && c.y >= 0 && c.x <= n.width && c.y <= n.height) break;
            u.lng > n.center.lng ? u.lng -= 360 : u.lng += 360;
          }
          return u;
        }
        const il = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        class Js extends i.E {
          constructor(t, n) {
            if (super(), (t instanceof HTMLElement || n) && (t = i.l({ element: t }, n)), i.aP(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment || "auto", this._updateMoving = () => this._update(!0), this._occludedOpacity = t && t.occludedOpacity || 0.2, t && t.element) this._element = t.element, this._offset = i.P.convert(t && t.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = w("div");
              const v = 41, C = 27, V = k("svg", { display: "block", height: v * this._scale + "px", width: C * this._scale + "px", viewBox: `0 0 ${C} ${v}` }, this._element), K = k("radialGradient", { id: "shadowGradient" }, k("defs", {}, V));
              k("stop", { offset: "10%", "stop-opacity": 0.4 }, K), k("stop", { offset: "100%", "stop-opacity": 0.05 }, K), k("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, V), k("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, V), k("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, V), k("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, V), this._offset = i.P.convert(t && t.offset || [0, -14]);
            }
            this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (v) => {
              v.preventDefault();
            }), this._element.addEventListener("mousedown", (v) => {
              v.preventDefault();
            });
            const c = this._element.classList;
            for (const v in il) c.remove(`mapboxgl-marker-anchor-${v}`);
            c.add(`mapboxgl-marker-anchor-${this._anchor}`);
            const p = t && t.className ? t.className.trim().split(/\s+/) : [];
            c.add(...p), this._popup = null;
          }
          addTo(t) {
            return t === this._map || (this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._updateMoving), t.on("moveend", this._update), t.on("remove", this._clearFadeTimer), t._addMarker(this), this.setDraggable(this._draggable), this._update(), t.on("click", this._onMapClick)), this;
          }
          remove() {
            const t = this._map;
            return t && (t.off("click", this._onMapClick), t.off("move", this._updateMoving), t.off("moveend", this._update), t.off("mousedown", this._addDragHandler), t.off("touchstart", this._addDragHandler), t.off("mouseup", this._onUp), t.off("touchend", this._onUp), t.off("mousemove", this._onMove), t.off("touchmove", this._onMove), t.off("remove", this._clearFadeTimer), t._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(t) {
            return this._lngLat = i.bO.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(t) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
              if (!("offset" in t.options)) {
                const p = Math.sqrt(Math.pow(13.5, 2) / 2);
                t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [p, -1 * (38.1 - 13.5 + p)], "bottom-right": [-p, -1 * (38.1 - 13.5 + p)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = t, t._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
            }
            return this;
          }
          _onKeyPress(t) {
            const n = t.code, c = t.charCode || t.keyCode;
            n !== "Space" && n !== "Enter" && c !== 32 && c !== 13 || this.togglePopup();
          }
          _onMapClick(t) {
            const n = t.originalEvent.target, c = this._element;
            this._popup && (n === c || c.contains(n)) && this.togglePopup();
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const t = this._popup;
            return t ? (t.isOpen() ? (t.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (t.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
          }
          _behindTerrain() {
            const t = this._map, n = this._pos;
            if (!t || !n) return !1;
            const c = t.unproject(n), p = t.getFreeCameraOptions();
            if (!p.position) return !1;
            const v = p.position.toLngLat();
            return v.distanceTo(c) < 0.9 * v.distanceTo(this._lngLat);
          }
          _evaluateOpacity() {
            const t = this._map;
            if (!t) return;
            const n = this._pos;
            if (!n || n.x < 0 || n.x > t.transform.width || n.y < 0 || n.y > t.transform.height) return void this._clearFadeTimer();
            const c = t.unproject(n);
            let p;
            t._showingGlobe() && i.dH(t.transform, this._lngLat) ? p = 0 : (p = 1 - t._queryFogOpacity(c), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (p *= this._occludedOpacity)), this._element.style.opacity = `${p}`, this._element.style.pointerEvents = p > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(p), this._fadeTimer = null;
          }
          _clearFadeTimer() {
            this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
          }
          _updateDOM() {
            const t = this._pos;
            if (!t || !this._map) return;
            const n = this._offset.mult(this._scale);
            this._element.style.transform = `
            translate(${t.x}px,${t.y}px)
            ${il[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${n.x}px,${n.y}px)
        `;
          }
          _calculateXYTransform() {
            const t = this._pos, n = this._map, c = this.getPitchAlignment();
            if (!n || !t || c !== "map") return "";
            if (!n._showingGlobe()) {
              const K = n.getPitch();
              return K ? `rotateX(${K}deg)` : "";
            }
            const p = i.c4(i.dI(n.transform, this._lngLat)), v = t.sub(i.dJ(n.transform)), C = Math.abs(v.x) + Math.abs(v.y);
            if (C === 0) return "";
            const V = p / C;
            return `rotateX(${-v.y * V}deg) rotateY(${v.x * V}deg)`;
          }
          _calculateZTransform() {
            const t = this._pos, n = this._map;
            if (!n || !t) return "";
            let c = 0;
            const p = this.getRotationAlignment();
            if (p === "map") if (n._showingGlobe()) {
              const v = n.project(new i.bO(this._lngLat.lng, this._lngLat.lat + 1e-3)), C = n.project(new i.bO(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(v);
              c = i.c4(Math.atan2(C.y, C.x)) - 90;
            } else c = -n.getBearing();
            else if (p === "horizon") {
              const v = i.ac(4, 6, n.getZoom()), C = i.dJ(n.transform);
              C.y += v * n.transform.height;
              const V = t.sub(C), K = i.c4(Math.atan2(V.y, V.x));
              c = (K > 90 ? K - 270 : K + 90) * (1 - v);
            }
            return c += this._rotation, c ? `rotateZ(${c}deg)` : "";
          }
          _update(t) {
            cancelAnimationFrame(this._updateFrameId);
            const n = this._map;
            n && (n.transform.renderWorldCopies && (this._lngLat = Dh(this._lngLat, this._pos, n.transform)), this._pos = n.project(this._lngLat), t === !0 ? this._updateFrameId = requestAnimationFrame(() => {
              this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
            }) : this._pos = this._pos.round(), n._requestDomTask(() => {
              this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (n._showingGlobe() || n.getTerrain() || n.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
            }));
          }
          getOffset() {
            return this._offset;
          }
          setOffset(t) {
            return this._offset = i.P.convert(t), this._update(), this;
          }
          addClassName(t) {
            return this._element.classList.add(t), this;
          }
          removeClassName(t) {
            return this._element.classList.remove(t), this;
          }
          toggleClassName(t) {
            return this._element.classList.toggle(t);
          }
          _onMove(t) {
            const n = this._map;
            if (!n) return;
            const c = this._pointerdownPos, p = this._positionDelta;
            if (c && p) {
              if (!this._isDragging) {
                const v = this._clickTolerance || n._clickTolerance;
                if (t.point.dist(c) < v) return;
                this._isDragging = !0;
              }
              this._pos = t.point.sub(p), this._lngLat = n.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new i.z("dragstart"))), this.fire(new i.z("drag"));
            }
          }
          _onUp() {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
            const t = this._map;
            t && (t.off("mousemove", this._onMove), t.off("touchmove", this._onMove)), this._state === "active" && this.fire(new i.z("dragend")), this._state = "inactive";
          }
          _addDragHandler(t) {
            const n = this._map, c = this._pos;
            n && c && this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(c), this._pointerdownPos = t.point, this._state = "pending", n.on("mousemove", this._onMove), n.on("touchmove", this._onMove), n.once("mouseup", this._onUp), n.once("touchend", this._onUp));
          }
          setDraggable(t) {
            this._draggable = !!t;
            const n = this._map;
            return n && (t ? (n.on("mousedown", this._addDragHandler), n.on("touchstart", this._addDragHandler)) : (n.off("mousedown", this._addDragHandler), n.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(t) {
            return this._rotation = t || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(t) {
            return this._rotationAlignment = t || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment === "auto" || this._rotationAlignment === "horizon" && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
          }
          setPitchAlignment(t) {
            return this._pitchAlignment = t || "auto", this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment === "auto" ? this.getRotationAlignment() : this._pitchAlignment;
          }
          setOccludedOpacity(t) {
            return this._occludedOpacity = t || 0.2, this._update(), this;
          }
          getOccludedOpacity() {
            return this._occludedOpacity;
          }
        }
        const Zn = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0, showUserHeading: !1 }, Qs = { maxWidth: 100, unit: "metric" }, Pr = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, zu = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, la = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function zh(u = new i.P(0, 0), t = "bottom") {
          if (typeof u == "number") {
            const n = Math.round(Math.sqrt(0.5 * Math.pow(u, 2)));
            switch (t) {
              case "top":
                return new i.P(0, u);
              case "top-left":
                return new i.P(n, n);
              case "top-right":
                return new i.P(-n, n);
              case "bottom":
                return new i.P(0, -u);
              case "bottom-left":
                return new i.P(n, -n);
              case "bottom-right":
                return new i.P(-n, -n);
              case "left":
                return new i.P(u, 0);
              case "right":
                return new i.P(-u, 0);
            }
            return new i.P(0, 0);
          }
          return u instanceof i.P || Array.isArray(u) ? i.P.convert(u) : i.P.convert(u[t] || [0, 0]);
        }
        return { version: N, supported: m.supported, setRTLTextPlugin: i.dK, getRTLTextPluginStatus: i.dL, Map: class extends Ou {
          constructor(u) {
            R.mark(Z.create);
            const t = u;
            if ((u = i.l({}, Al, u)).minZoom != null && u.maxZoom != null && u.minZoom > u.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (u.minPitch != null && u.maxPitch != null && u.minPitch > u.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (u.minPitch != null && u.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (u.maxPitch != null && u.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (u.antialias && i.dF(window) && (u.antialias = !1, i.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Vo(u.minZoom, u.maxZoom, u.minPitch, u.maxPitch, u.renderWorldCopies), u), this._repaint = !!u.repaint, this._interactive = u.interactive, this._minTileCacheSize = u.minTileCacheSize, this._maxTileCacheSize = u.maxTileCacheSize, this._failIfMajorPerformanceCaveat = u.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = u.preserveDrawingBuffer, this._antialias = u.antialias, this._trackResize = u.trackResize, this._bearingSnap = u.bearingSnap, this._refreshExpiredTiles = u.refreshExpiredTiles, this._fadeDuration = u.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = u.crossSourceCollisions, this._collectResourceTiming = u.collectResourceTiming, this._language = this._parseLanguage(u.language), this._worldview = u.worldview, this._renderTaskQueue = new Ts(), this._domRenderTaskQueue = new Ts(), this._controls = [], this._markers = [], this._popups = [], this._mapId = i.aV(), this._locale = i.l({}, Du, u.locale), this._clickTolerance = u.clickTolerance, this._cooperativeGestures = u.cooperativeGestures, this._performanceMetricsCollection = u.performanceMetricsCollection, this._tessellationStep = u.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = u.precompilePrograms, this._scaleFactorChanged = !1, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new Ks(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = u.scaleFactor, this._requestManager = new ge(u.transformRequest, u.accessToken, u.testMode), this._silenceAuthErrors = !!u.testMode, this._contextCreateOptions = u.contextCreateOptions ? Object.assign({}, u.contextCreateOptions) : {}, typeof u.container == "string") {
              const n = document.getElementById(u.container);
              if (!n) throw new Error(`Container '${u.container.toString()}' not found.`);
              this._container = n;
            } else {
              if (!(u.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = u.container;
            }
            if (this._container.childNodes.length > 0 && i.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), u.maxBounds && this.setMaxBounds(u.maxBounds), this._spriteFormat = u.spriteFormat, i.aP(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp || (this._tp = new Ch()), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", { noSave: !0 }), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", { noSave: !0 }, () => {
              this._update();
            }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._tp.registerParameter(this, ["Scaling"], "_scaleFactor", { min: 0.1, max: 10, step: 0.1 }, () => {
              this.setScaleFactor(this._scaleFactor);
            }), this._setupPainter(), this.painter === void 0) throw new Error("Failed to initialize WebGL.");
            if (this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, !1), window.addEventListener("resize", this._onWindowResize, !1), window.addEventListener("orientationchange", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener("visibilitychange", this._onVisibilityChange, !1), this.handlers = new eh(this, u), this._localFontFamily = u.localFontFamily, this._localIdeographFontFamily = u.localIdeographFontFamily, (u.style || !u.testMode) && this.setStyle(u.style || i.e.DEFAULT_STYLE, { config: u.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), u.projection && this.setProjection(u.projection), this.indoor = new Ju(this), u.hash && (this._hash = new uf(typeof u.hash == "string" && u.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
              t.center == null && t.zoom == null || (this.transform._unmodified = !1), this.jumpTo({ center: u.center, zoom: u.zoom, bearing: u.bearing, pitch: u.pitch });
              const n = u.bounds;
              n && (this.resize(), this.fitBounds(n, i.l({}, u.fitBoundsOptions, { duration: 0 })));
            }
            this.resize(), u.attributionControl && this.addControl(new bc({ customAttribution: u.customAttribution })), this._logoControl = new Ys(), this.addControl(this._logoControl, u.logoPosition), this.on("style.load", () => {
              this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
            }), this.on("data", (n) => {
              this._update(n.dataType === "style"), this.fire(new i.z(`${n.dataType}data`, n));
            }), this.on("dataloading", (n) => {
              this.fire(new i.z(`${n.dataType}dataloading`, n));
            }), this._interactions = new th(this);
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(u, t) {
            if (t === void 0 && (t = u.getDefaultPosition ? u.getDefaultPosition() : "top-right"), !u || !u.onAdd) return this.fire(new i.y(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const n = u.onAdd(this);
            this._controls.push(u);
            const c = this._controlPositions[t];
            return t.indexOf("bottom") !== -1 ? c.insertBefore(n, c.firstChild) : c.appendChild(n), this;
          }
          removeControl(u) {
            if (!u || !u.onRemove) return this.fire(new i.y(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const t = this._controls.indexOf(u);
            return t > -1 && this._controls.splice(t, 1), u.onRemove(this), this;
          }
          hasControl(u) {
            return this._controls.indexOf(u) > -1;
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          resize(u) {
            if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
            this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
            const t = !this._moving;
            return t && this.fire(new i.z("movestart", u)).fire(new i.z("move", u)), this.fire(new i.z("resize", u)), t && this.fire(new i.z("moveend", u)), this;
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds() || null;
          }
          setMaxBounds(u) {
            return this.transform.setMaxBounds(i.az.convert(u)), this._update();
          }
          setMinZoom(u) {
            if ((u = u ?? -2) >= -2 && u <= this.transform.maxZoom) return this.transform.minZoom = u, this._update(), this.getZoom() < u ? this.setZoom(u) : this.fire(new i.z("zoomstart")).fire(new i.z("zoom")).fire(new i.z("zoomend")), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(u) {
            if ((u = u ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = u, this._update(), this.getZoom() > u ? this.setZoom(u) : this.fire(new i.z("zoomstart")).fire(new i.z("zoom")).fire(new i.z("zoomend")), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(u) {
            if ((u = u ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (u >= 0 && u <= this.transform.maxPitch) return this.transform.minPitch = u, this._update(), this.getPitch() < u ? this.setPitch(u) : this.fire(new i.z("pitchstart")).fire(new i.z("pitch")).fire(new i.z("pitchend")), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(u) {
            if ((u = u ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
            if (u >= this.transform.minPitch) return this.transform.maxPitch = u, this._update(), this.getPitch() > u ? this.setPitch(u) : this.fire(new i.z("pitchstart")).fire(new i.z("pitch")).fire(new i.z("pitchend")), this;
            throw new Error("maxPitch must be greater than or equal to minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getScaleFactor() {
            return this._scaleFactor;
          }
          setScaleFactor(u) {
            return this._scaleFactor = u, this.painter.scaleFactor = u, this._tp.refreshUI(), this._scaleFactorChanged = !0, this.style._updateFilteredLayers((t) => t.type === "symbol"), this._update(!0), this;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(u) {
            return this.transform.renderWorldCopies = u, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
          }
          getLanguage() {
            return this._language;
          }
          _parseLanguage(u) {
            return u === "auto" ? navigator.language : Array.isArray(u) ? u.length === 0 ? void 0 : u.map((t) => t === "auto" ? navigator.language : t) : u;
          }
          setLanguage(u) {
            const t = this._parseLanguage(u);
            if (!this.style || t === this._language) return this;
            this._language = t, this.style.reloadSources();
            for (const n of this._controls) n._setLanguage && n._setLanguage(this._language);
            return this;
          }
          getWorldview() {
            return this._worldview;
          }
          setWorldview(u) {
            return this.style && u !== this._worldview ? (this._worldview = u, this.style.reloadSources(), this) : this;
          }
          getProjection() {
            return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
          }
          _showingGlobe() {
            return this.transform.projection.name === "globe";
          }
          setProjection(u) {
            return this._lazyInitEmptyStyle(), u ? typeof u == "string" && (u = { name: u }) : u = null, this._useExplicitProjection = !!u, this._prioritizeAndUpdateProjection(u, this.style.projection);
          }
          _updateProjectionTransition() {
            if (this.getProjection().name !== "globe") return;
            const u = this.transform, t = u.projection.name;
            let n;
            t === "globe" && u.zoom >= i.bY ? (u.setMercatorFromTransition(), n = !0) : t === "mercator" && u.zoom < i.bY && (u.setProjection({ name: "globe" }), n = !0), n && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
          }
          _prioritizeAndUpdateProjection(u, t) {
            return this._updateProjection(u || t || { name: "mercator" });
          }
          _updateProjection(u) {
            let t;
            return t = u.name === "globe" && this.transform.zoom >= i.bY ? this.transform.setMercatorFromTransition() : this.transform.setProjection(u), this.style.applyProjectionUpdate(), t && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;
          }
          project(u) {
            return this.transform.locationPoint3D(i.bO.convert(u));
          }
          unproject(u) {
            return this.transform.pointLocation3D(i.P.convert(u));
          }
          isMoving() {
            return this._moving || this.handlers && this.handlers.isMoving() || !1;
          }
          isZooming() {
            return this._zooming || this.handlers && this.handlers.isZooming() || !1;
          }
          isRotating() {
            return this._rotating || this.handlers && this.handlers.isRotating() || !1;
          }
          _isDragging() {
            return this.handlers && this.handlers._isDragging() || !1;
          }
          _createDelegatedListener(u, t, n) {
            const c = (p) => {
              let v = [];
              if (Array.isArray(t)) {
                const C = t.filter((V) => this.getLayer(V));
                v = C.length ? this.queryRenderedFeatures(p, { layers: C }) : [];
              } else v = this.queryRenderedFeatures(p, { target: t });
              return v;
            };
            if (u === "mouseenter" || u === "mouseover") {
              let p = !1;
              return { listener: n, targets: t, delegates: { mousemove: (C) => {
                const V = c(C.point);
                V.length ? p || (p = !0, n.call(this, new zs(u, this, C.originalEvent, { features: V }))) : p = !1;
              }, mouseout: () => {
                p = !1;
              } } };
            }
            if (u === "mouseleave" || u === "mouseout") {
              let p = !1;
              return { listener: n, targets: t, delegates: { mousemove: (V) => {
                c(V.point).length ? p = !0 : p && (p = !1, n.call(this, new zs(u, this, V.originalEvent)));
              }, mouseout: (V) => {
                p && (p = !1, n.call(this, new zs(u, this, V.originalEvent)));
              } } };
            }
            {
              const p = (v) => {
                const C = c(v.point);
                C.length && (v.features = C, n.call(this, v), delete v.features);
              };
              return { listener: n, targets: t, delegates: { [u]: p } };
            }
          }
          on(u, t, n) {
            if (typeof t == "function" || n === void 0) return super.on(u, t);
            if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t)) return this;
            const c = this._createDelegatedListener(u, t, n);
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[u] = this._delegatedListeners[u] || [], this._delegatedListeners[u].push(c);
            for (const p in c.delegates) this.on(p, c.delegates[p]);
            return this;
          }
          once(u, t, n) {
            if (typeof t == "function" || n === void 0) return super.once(u, t);
            if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t)) return this;
            const c = this._createDelegatedListener(u, t, n);
            for (const p in c.delegates) this.once(p, c.delegates[p]);
            return this;
          }
          off(u, t, n) {
            if (typeof t == "function" || n === void 0) return super.off(u, t);
            if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t)) return this;
            const c = this._delegatedListeners ? this._delegatedListeners[u] : void 0;
            return c && ((p) => {
              for (let v = 0; v < p.length; v++) {
                const C = p[v];
                if (C.listener === n && hn(C.targets, t)) {
                  for (const V in C.delegates) this.off(V, C.delegates[V]);
                  return p.splice(v, 1), this;
                }
              }
            })(c), this;
          }
          queryRenderedFeatures(u, t) {
            if (!this.style) return [];
            if (u === void 0 || u instanceof i.P || Array.isArray(u) || t !== void 0 || (t = u, u = void 0), u = u || [[0, 0], [this.transform.width, this.transform.height]], !t) {
              const v = this.style.queryRenderedFeatures(u, void 0, this.transform), C = this.style.queryRenderedFeatureset(u, void 0, this.transform);
              return v.concat(C);
            }
            let n = !0;
            if (t.target && (n = this._isTargetValid(t.target), n && !t.layers)) return this.style.queryRenderedFeatureset(u, t, this.transform);
            let c = !0;
            if (t.layers && Array.isArray(t.layers)) {
              for (const v of t.layers) if (!this._isValidId(v)) {
                c = !1;
                break;
              }
              if (c && !t.target) return this.style.queryRenderedFeatures(u, t, this.transform);
            }
            let p = [];
            return c && (p = p.concat(this.style.queryRenderedFeatures(u, t, this.transform))), n && (p = p.concat(this.style.queryRenderedFeatureset(u, t, this.transform))), p;
          }
          querySourceFeatures(u, t) {
            return !u || typeof u == "string" && !this._isValidId(u) ? [] : this.style.querySourceFeatures(u, t);
          }
          isPointOnSurface(u) {
            const { name: t } = this.transform.projection;
            return t !== "globe" && t !== "mercator" && i.w(`${t} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(i.P.convert(u));
          }
          addInteraction(u, t) {
            return this._interactions.add(u, t), this;
          }
          removeInteraction(u) {
            return this._interactions.remove(u), this;
          }
          setStyle(u, t) {
            return t = i.l({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, t), this.style && u && t.diff !== !1 && t.localFontFamily === this._localFontFamily && t.localIdeographFontFamily === this._localIdeographFontFamily && !t.config ? (this.style._diffStyle(u, (n, c) => {
              n ? (i.w(`Unable to perform style diff: ${String(n.message || n.error || n)}. Rebuilding the style from scratch.`), this._updateStyle(u, t)) : c && this._update(!0);
            }, () => {
              this._postStyleLoadEvent();
            }), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._localFontFamily = t.localFontFamily, this._updateStyle(u, t));
          }
          _getUIString(u) {
            const t = this._locale[u];
            if (t == null) throw new Error(`Missing UI string '${u}'`);
            return t;
          }
          _updateStyle(u, t) {
            if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), u) {
              const n = i.l({}, t);
              t && t.config && (n.initialConfig = t.config, delete n.config), this.style = new Hr(this, n).load(u), this.style.setEventedParent(this, { style: this.style });
            }
            return this._updateTerrain(), this;
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new Hr(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : (i.w("There is no style added to the map."), !1);
          }
          _isValidId(u) {
            return u == null ? (this.fire(new i.y(new Error("IDs can't be empty."))), !1) : !i.cr(u) || (this.fire(new i.y(new Error(`IDs can't contain special symbols: "${u}".`))), !1);
          }
          _isTargetValid(u) {
            return "featuresetId" in u ? this._isValidId("importId" in u ? u.importId : u.featuresetId) : "layerId" in u && this._isValidId(u.layerId);
          }
          _areTargetsValid(u) {
            if (Array.isArray(u)) {
              for (const t of u) if (!this._isValidId(t)) return !1;
              return !0;
            }
            return this._isTargetValid(u);
          }
          addSource(u, t) {
            return this._isValidId(u) ? (this._lazyInitEmptyStyle(), this.style.addSource(u, t), this._update(!0)) : this;
          }
          isSourceLoaded(u) {
            return !!this._isValidId(u) && !!this.style && this.style._isSourceCacheLoaded(u);
          }
          areTilesLoaded() {
            return this.style.areTilesLoaded();
          }
          addSourceType(u, t, n) {
            this._lazyInitEmptyStyle(), this.style.addSourceType(u, t, n);
          }
          removeSource(u) {
            return this._isValidId(u) ? (this.style.removeSource(u), this._updateTerrain(), this._update(!0)) : this;
          }
          getSource(u) {
            return this._isValidId(u) ? this.style.getOwnSource(u) : null;
          }
          addImage(u, t, { pixelRatio: n = 1, sdf: c = !1, stretchX: p, stretchY: v, content: C } = {}) {
            if (this._lazyInitEmptyStyle(), t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap) {
              const { width: V, height: K, data: se } = i.q.getImageData(t);
              this.style.addImage(u, { data: new i.r({ width: V, height: K }, se), pixelRatio: n, stretchX: p, stretchY: v, content: C, sdf: c, version: 0, usvg: !1 });
            } else if (t.width === void 0 || t.height === void 0) this.fire(new i.y(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            else {
              const { width: V, height: K } = t, se = t;
              this.style.addImage(u, { data: new i.r({ width: V, height: K }, new Uint8Array(se.data)), pixelRatio: n, stretchX: p, stretchY: v, content: C, sdf: c, usvg: !1, version: 0, userImage: se }), se.onAdd && se.onAdd(this, u);
            }
          }
          updateImage(u, t) {
            this._lazyInitEmptyStyle();
            const n = this.style.getImage(u);
            if (!n) return void this.fire(new i.y(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const c = t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap ? i.q.getImageData(t) : t, { width: p, height: v, data: C } = c;
            if (p === void 0 || v === void 0) return void this.fire(new i.y(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (p !== (n.usvg ? n.icon.usvg_tree.width : n.data.width) || v !== (n.usvg ? n.icon.usvg_tree.height : n.data.height)) return void this.fire(new i.y(new Error(`The width and height of the updated image (${p}, ${v})
                must be that same as the previous version of the image
                (${n.data.width}, ${n.data.height})`)));
            const V = !(t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap);
            let K = !1;
            n.usvg ? (n.data = new i.r({ width: p, height: v }, new Uint8Array(C)), n.usvg = !1, n.icon = void 0, K = !0) : n.data.replace(C, V), this.style.updateImage(u, n, K);
          }
          hasImage(u) {
            return u ? !!this.style && !!this.style.getImage(u) : (this.fire(new i.y(new Error("Missing required image id"))), !1);
          }
          removeImage(u) {
            this.style.removeImage(u);
          }
          loadImage(u, t) {
            i.o(this._requestManager.transformRequest(u, i.R.Image), (n, c) => {
              t(n, c instanceof HTMLImageElement ? i.q.getImageData(c) : c);
            });
          }
          listImages() {
            return this.style.listImages();
          }
          addModel(u, t) {
            this._lazyInitEmptyStyle(), this.style.addModel(u, t);
          }
          hasModel(u) {
            return u ? this.style.hasModel(u) : (this.fire(new i.y(new Error("Missing required model id"))), !1);
          }
          removeModel(u) {
            this.style.removeModel(u);
          }
          listModels() {
            return this.style.listModels();
          }
          addLayer(u, t) {
            return this._isValidId(u.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(u, t), this._update(!0)) : this;
          }
          getSlot(u) {
            const t = this.getLayer(u);
            return t && t.slot || null;
          }
          setSlot(u, t) {
            return this.style.setSlot(u, t), this.style.mergeLayers(), this._update(!0);
          }
          addImport(u, t) {
            return this.style.addImport(u, t), this;
          }
          updateImport(u, t) {
            return typeof t != "string" && t.id !== u ? (this.removeImport(u), this.addImport(t)) : (this.style.updateImport(u, t), this._update(!0));
          }
          removeImport(u) {
            return this.style.removeImport(u), this;
          }
          moveImport(u, t) {
            return this.style.moveImport(u, t), this._update(!0);
          }
          moveLayer(u, t) {
            return this._isValidId(u) ? (this.style.moveLayer(u, t), this._update(!0)) : this;
          }
          removeLayer(u) {
            return this._isValidId(u) ? (this.style.removeLayer(u), this._update(!0)) : this;
          }
          getLayer(u) {
            if (!this._isValidId(u)) return null;
            const t = this.style.getOwnLayer(u);
            return t ? t.type === "custom" ? t.implementation : t.serialize() : void 0;
          }
          getSlots() {
            return this.style.getSlots();
          }
          setLayerZoomRange(u, t, n) {
            return this._isValidId(u) ? (this.style.setLayerZoomRange(u, t, n), this._update(!0)) : this;
          }
          setFilter(u, t, n = {}) {
            return this._isValidId(u) ? (this.style.setFilter(u, t, n), this._update(!0)) : this;
          }
          getFilter(u) {
            return this._isValidId(u) ? this.style.getFilter(u) : null;
          }
          setPaintProperty(u, t, n, c = {}) {
            return this._isValidId(u) ? (this.style.setPaintProperty(u, t, n, c), this._update(!0)) : this;
          }
          getPaintProperty(u, t) {
            return this._isValidId(u) ? this.style.getPaintProperty(u, t) : null;
          }
          setLayoutProperty(u, t, n, c = {}) {
            return this._isValidId(u) ? (this.style.setLayoutProperty(u, t, n, c), this._update(!0)) : this;
          }
          getLayoutProperty(u, t) {
            return this._isValidId(u) ? this.style.getLayoutProperty(u, t) : null;
          }
          getSchema(u) {
            return this.style.getSchema(u);
          }
          setSchema(u, t) {
            return this.style.setSchema(u, t), this._update(!0);
          }
          getConfig(u) {
            return this.style.getConfig(u);
          }
          setConfig(u, t) {
            return this.style.setConfig(u, t), this._update(!0);
          }
          getConfigProperty(u, t) {
            return this.style.getConfigProperty(u, t);
          }
          setConfigProperty(u, t, n) {
            return this.style.setConfigProperty(u, t, n), this._update(!0);
          }
          getFeaturesetDescriptors(u) {
            return this.style.getFeaturesetDescriptors(u);
          }
          setLights(u) {
            if (this._lazyInitEmptyStyle(), u && u.length === 1 && u[0].type === "flat") {
              const t = u[0];
              t.properties ? this.style.setFlatLight(t.properties, t.id, {}) : this.style.setFlatLight({}, "flat");
            } else this.style.setLights(u), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
            return this._update(!0);
          }
          getLights() {
            const u = this.style.getLights() || [];
            return u.length === 0 && u.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), u;
          }
          setLight(u, t = {}) {
            return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: u }]);
          }
          getLight() {
            return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
          }
          setTerrain(u) {
            return this._lazyInitEmptyStyle(), !u && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(u), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
          }
          getTerrain() {
            return this.style ? this.style.getTerrain() : null;
          }
          setFog(u) {
            return this._lazyInitEmptyStyle(), this.style.setFog(u), this._update(!0);
          }
          getFog() {
            return this.style ? this.style.getFog() : null;
          }
          setSnow(u) {
            return this._lazyInitEmptyStyle(), this.style.setSnow(u), this._update(!0);
          }
          getSnow() {
            return this.style ? this.style.getSnow() : null;
          }
          setRain(u) {
            return this._lazyInitEmptyStyle(), this.style.setRain(u), this._update(!0);
          }
          getRain() {
            return this.style ? this.style.getRain() : null;
          }
          setColorTheme(u) {
            return this._lazyInitEmptyStyle(), this.style.setColorTheme(u), this._update(!0);
          }
          setImportColorTheme(u, t) {
            return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(u, t), this._update(!0);
          }
          setCamera(u) {
            return this.style.setCamera(u), this._triggerCameraUpdate(u);
          }
          _triggerCameraUpdate(u) {
            return this._update(this.transform.setOrthographicProjectionAtLowPitch(u["camera-projection"] === "orthographic"));
          }
          getCamera() {
            return this.style.camera;
          }
          _queryFogOpacity(u) {
            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(i.bO.convert(u), this.transform) : 0;
          }
          setFeatureState(u, t) {
            return u.source && !this._isValidId(u.source) ? this : (this.style.setFeatureState(u, t), this._update());
          }
          removeFeatureState(u, t) {
            return u.source && !this._isValidId(u.source) ? this : (this.style.removeFeatureState(u, t), this._update());
          }
          getFeatureState(u) {
            return u.source && !this._isValidId(u.source) ? null : this.style.getFeatureState(u);
          }
          _updateContainerDimensions() {
            if (!this._container) return;
            const u = this._container.getBoundingClientRect().width || 400, t = this._container.getBoundingClientRect().height || 300;
            let n, c, p, v = this._container;
            for (; v && (!c || !p); ) {
              const C = window.getComputedStyle(v).transform;
              C && C !== "none" && (n = C.match(/matrix.*\((.+)\)/)[1].split(", "), n[0] && n[0] !== "0" && n[0] !== "1" && (c = n[0]), n[3] && n[3] !== "0" && n[3] !== "1" && (p = n[3])), v = v.parentElement;
            }
            this._containerWidth = c ? Math.abs(u / c) : u, this._containerHeight = p ? Math.abs(t / p) : t;
          }
          _detectMissingCSS() {
            window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && i.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
          }
          _setupContainer() {
            const u = this._container;
            u.classList.add("mapboxgl-map"), (this._missingCSSCanary = w("div", "mapboxgl-canary", u)).style.visibility = "hidden", this._detectMissingCSS();
            const t = this._canvasContainer = w("div", "mapboxgl-canvas-container", u);
            this._canvas = w("canvas", "mapboxgl-canvas", t), this._interactive && (t.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
            const n = this._controlContainer = w("div", "mapboxgl-control-container", u), c = this._controlPositions = {};
            ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach((p) => {
              c[p] = w("div", `mapboxgl-ctrl-${p}`, n);
            }), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(u, t) {
            const n = i.q.devicePixelRatio || 1;
            this._canvas.width = n * Math.ceil(u), this._canvas.height = n * Math.ceil(t), this._canvas.style.width = `${u}px`, this._canvas.style.height = `${t}px`;
          }
          _addMarker(u) {
            this._markers.push(u);
          }
          _removeMarker(u) {
            const t = this._markers.indexOf(u);
            t !== -1 && this._markers.splice(t, 1);
          }
          _addPopup(u) {
            this._popups.push(u);
          }
          _removePopup(u) {
            const t = this._popups.indexOf(u);
            t !== -1 && this._popups.splice(t, 1);
          }
          _setupPainter() {
            const u = i.l({}, m.supported.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), t = this._canvas.getContext("webgl2", u);
            t ? (wi(t, !0), this.painter = new Ih(t, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp), this.on("data", (n) => {
              n.dataType === "source" && this.painter.setTileLoadedFlag(!0);
            }), i.m.testSupport(t)) : this.fire(new i.y(new Error("Failed to initialize WebGL")));
          }
          _contextLost(u) {
            u.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new i.z("webglcontextlost", { originalEvent: u }));
          }
          _contextRestored(u) {
            this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style.reloadModels(), this.style.clearSources(), this._update(), this.fire(new i.z("webglcontextrestored", { originalEvent: u }));
          }
          _onMapScroll(u) {
            if (u.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }
          idle() {
            return !this.isMoving() && this.loaded();
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          frameReady() {
            return this.loaded() && !this._placementDirty;
          }
          _update(u) {
            return this.style ? (this._styleDirty = this._styleDirty || u, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(u) {
            return this._update(), this._renderTaskQueue.add(u);
          }
          _cancelRenderFrame(u) {
            this._renderTaskQueue.remove(u);
          }
          _requestDomTask(u) {
            !this.loaded() || this.loaded() && !this.isMoving() ? u() : this._domRenderTaskQueue.add(u);
          }
          _render(u) {
            let t;
            this.fire(new i.z("renderstart")), ++this._frameId;
            const n = this.painter.context.extTimerQuery, c = i.q.now(), p = this.painter.context.gl;
            if (this.listens("gpu-timing-frame") && (t = p.createQuery(), p.beginQuery(n.TIME_ELAPSED_EXT, t)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(u), this._domRenderTaskQueue.run(u), this._removed) return;
            this._updateProjectionTransition();
            const v = this._isInitialLoad ? 0 : this._fadeDuration;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const se = this.transform.zoom, oe = this.transform.pitch, ve = i.q.now(), xe = new i.a8(se, { now: ve, fadeDuration: v, pitch: oe, transition: this.style.transition });
              this.style.update(xe);
            }
            this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
            let C = !1;
            this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), C = this._updateAverageElevation(c), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : C = this._updateAverageElevation(c);
            const V = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, v, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);
            if (this._scaleFactorChanged && (this._scaleFactorChanged = !1), V && (this._placementDirty = V.needsRerender), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: v, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new i.z("render")), this.loaded() && !this._loaded && (this._loaded = !0, R.mark(Z.load), this.fire(new i.z("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), t) {
              const se = i.q.now() - c;
              p.endQuery(n.TIME_ELAPSED_EXT), setTimeout(() => {
                const oe = p.getQueryParameter(t, p.QUERY_RESULT) / 1e6;
                p.deleteQuery(t), this.fire(new i.z("gpu-timing-frame", { cpuTime: se, gpuTime: oe }));
              }, 50);
            }
            if (this.listens("gpu-timing-layer")) {
              const se = this.painter.collectGpuTimers();
              setTimeout(() => {
                const oe = this.painter.queryGpuTimers(se);
                this.fire(new i.z("gpu-timing-layer", { layerTimes: oe }));
              }, 50);
            }
            if (this.listens("gpu-timing-deferred-render")) {
              const se = this.painter.collectDeferredRenderGpuQueries();
              setTimeout(() => {
                const oe = this.painter.queryGpuTimeDeferredRender(se);
                this.fire(new i.z("gpu-timing-deferred-render", { gpuTime: oe }));
              }, 50);
            }
            const K = this._sourcesDirty || this._styleDirty || this._placementDirty || C;
            if (K || this._repaint) this.triggerRepaint();
            else {
              const se = this.idle();
              if (se && (C = this._updateAverageElevation(c, !0)), C) this.triggerRepaint();
              else if (this._triggerFrame(!1), se && (this.fire(new i.z("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                const oe = this._calculateSpeedIndex();
                this.fire(new i.z("speedindexcompleted", { speedIndex: oe })), this.speedIndexTiming = !1;
              }
            }
            !this._loaded || this._fullyLoaded || K || (this._fullyLoaded = !0, R.mark(Z.fullLoad), this._performanceMetricsCollection && Ht(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
          }
          _forceMarkerAndPopupUpdate(u) {
            for (const t of this._markers) u && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();
            for (const t of this._popups) !u || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update();
          }
          _updateAverageElevation(u, t = !1) {
            const n = (p) => (this.transform.averageElevation = p, this._update(!1), !0);
            if (!this.painter.averageElevationNeedsEasing()) return this.transform.averageElevation !== 0 && n(0);
            const c = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
            if (c || (t || u - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(u)) {
              const p = this.transform.averageElevation;
              let v = this.transform.sampleAverageElevation();
              this.transform.elevation != null && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(v) ? v = 0 : this._averageElevationLastSampledAt = u;
              const C = Math.abs(p - v);
              if (C > 1) {
                if (this._isInitialLoad || c) return this._averageElevation.jumpTo(v), n(v);
                this._averageElevation.easeTo(v, u, 300);
              } else if (C > 1e-4) return this._averageElevation.jumpTo(v), n(v);
            }
            return !!this._averageElevation.isEasing(u) && n(this._averageElevation.getValue(u));
          }
          _authenticate() {
            rt(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (u) => {
              if (u && (u.message === ke || u.status === 401)) {
                const t = this.painter.context.gl;
                wi(t, !1), this._logoControl instanceof Ys && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new i.y(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
              }
            }), Ke(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
            });
          }
          _postStyleLoadEvent() {
            this.style.globalId && ct(this._requestManager._customAccessToken, { map: this, skuToken: this._requestManager._skuToken, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() });
          }
          _updateTerrain() {
            const u = this._isDragging();
            this.painter.updateTerrain(this.style, u);
          }
          _calculateSpeedIndex() {
            const u = this.painter.canvasCopy(), t = this.painter.getCanvasCopiesAndTimestamps();
            t.timeStamps.push(performance.now());
            const n = this.painter.context.gl, c = n.createFramebuffer();
            function p(v) {
              n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, v, 0);
              const C = new Uint8Array(n.drawingBufferWidth * n.drawingBufferHeight * 4);
              return n.readPixels(0, 0, n.drawingBufferWidth, n.drawingBufferHeight, n.RGBA, n.UNSIGNED_BYTE, C), C;
            }
            return n.bindFramebuffer(n.FRAMEBUFFER, c), this._canvasPixelComparison(p(u), t.canvasCopies.map(p), t.timeStamps);
          }
          _canvasPixelComparison(u, t, n) {
            let c = n[1] - n[0];
            const p = u.length / 4;
            for (let v = 0; v < t.length; v++) {
              const C = t[v];
              let V = 0;
              for (let K = 0; K < C.length; K += 4) C[K] === u[K] && C[K + 1] === u[K + 1] && C[K + 2] === u[K + 2] && C[K + 3] === u[K + 3] && (V += 1);
              c += (n[v + 2] - n[v + 1]) * (1 - V / p);
            }
            return c;
          }
          remove() {
            this._hash && this._hash.remove();
            for (const t of this._controls) t.onRemove(this);
            this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, !1), window.removeEventListener("orientationchange", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener("online", this._onWindowOnline, !1), window.removeEventListener("visibilitychange", this._onVisibilityChange, !1);
            const u = this.painter.context.gl.getExtension("WEBGL_lose_context");
            u && u.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), ri.delete(this.painter.context.gl), $t.remove(), pt.remove(), this._removed = !0, this.fire(new i.z("remove"));
          }
          triggerRepaint() {
            this._triggerFrame(!0);
          }
          _triggerFrame(u) {
            this._renderNextFrame = this._renderNextFrame || u, this.style && !this._frame && (this._frame = i.q.frame((t) => {
              const n = !!this._renderNextFrame;
              this._frame = null, this._renderNextFrame = null, n && this._render(t);
            }));
          }
          _preloadTiles(u) {
            const t = this.style ? this.style.getSourceCaches() : [];
            return i.bl(t, (n, c) => n._preloadTiles(u, c), () => {
              this.triggerRepaint();
            }), this;
          }
          _onWindowOnline() {
            this._update();
          }
          _onWindowResize(u) {
            this._trackResize && this.resize({ originalEvent: u })._update();
          }
          _onVisibilityChange() {
            document.visibilityState === "hidden" && this._visibilityHidden++;
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(u) {
            this._showTileBoundaries !== u && (this._showTileBoundaries = u, this._tp.refreshUI(), this._update());
          }
          get showParseStatus() {
            return !!this._showParseStatus;
          }
          set showParseStatus(u) {
            this._showParseStatus !== u && (this._showParseStatus = u, this._tp.refreshUI(), this._update());
          }
          get showTerrainWireframe() {
            return !!this._showTerrainWireframe;
          }
          set showTerrainWireframe(u) {
            this._showTerrainWireframe !== u && (this._showTerrainWireframe = u, this._tp.refreshUI(), this._update());
          }
          get showLayers2DWireframe() {
            return !!this._showLayers2DWireframe;
          }
          set showLayers2DWireframe(u) {
            this._showLayers2DWireframe !== u && (this._showLayers2DWireframe = u, this._tp.refreshUI(), this._update());
          }
          get showLayers3DWireframe() {
            return !!this._showLayers3DWireframe;
          }
          set showLayers3DWireframe(u) {
            this._showLayers3DWireframe !== u && (this._showLayers3DWireframe = u, this._tp.refreshUI(), this._update());
          }
          get speedIndexTiming() {
            return !!this._speedIndexTiming;
          }
          set speedIndexTiming(u) {
            this._speedIndexTiming !== u && (this._speedIndexTiming = u, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(u) {
            this._showPadding !== u && (this._showPadding = u, this._tp.refreshUI(), this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(u) {
            this._showCollisionBoxes !== u && (this._showCollisionBoxes = u, this._tp.refreshUI(), u ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(u) {
            this._showOverdrawInspector !== u && (this._showOverdrawInspector = u, this._tp.refreshUI(), this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(u) {
            this._repaint !== u && (this._repaint = u, this._tp.refreshUI(), this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(u) {
            this._vertices = u, this._update();
          }
          get showTileAABBs() {
            return !!this._showTileAABBs;
          }
          set showTileAABBs(u) {
            this._showTileAABBs !== u && (this._showTileAABBs = u, this._tp.refreshUI(), u && this._update());
          }
          _setCacheLimits(u, t) {
            i.dG(u, t);
          }
          get version() {
            return N;
          }
        }, NavigationControl: class {
          constructor(u = {}) {
            this.options = i.l({}, ih, u), this._container = w("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this.options.showZoom && (i.aP(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (t) => {
              this._map && this._map.zoomIn({}, { originalEvent: t });
            }), w("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (t) => {
              this._map && this._map.zoomOut({}, { originalEvent: t });
            }), w("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (i.aP(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (t) => {
              const n = this._map;
              n && (this.options.visualizePitch ? n.resetNorthPitch({}, { originalEvent: t }) : n.resetNorth({}, { originalEvent: t }));
            }), this._compassIcon = w("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          _updateZoomButtons() {
            const u = this._map;
            if (!u) return;
            const t = u.getZoom(), n = t === u.getMaxZoom(), c = t === u.getMinZoom();
            this._zoomInButton.disabled = n, this._zoomOutButton.disabled = c, this._zoomInButton.setAttribute("aria-disabled", n.toString()), this._zoomOutButton.setAttribute("aria-disabled", c.toString());
          }
          _rotateCompassArrow() {
            const u = this._map;
            if (!u) return;
            const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(u.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${u.transform.pitch}deg) rotateZ(${u.transform.angle * (180 / Math.PI)}deg)` : `rotate(${u.transform.angle * (180 / Math.PI)}deg)`;
            u._requestDomTask(() => {
              this._compassIcon && (this._compassIcon.style.transform = t);
            });
          }
          onAdd(u) {
            return this._map = u, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), u.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && u.on("pitch", this._rotateCompassArrow), u.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Cs(u, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            const u = this._map;
            u && (this._container.remove(), this.options.showZoom && u.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && u.off("pitch", this._rotateCompassArrow), u.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
          }
          _createButton(u, t) {
            const n = w("button", u, this._container);
            return n.type = "button", n.addEventListener("click", t), n;
          }
          _setButtonTitle(u, t) {
            if (!this._map) return;
            const n = this._map._getUIString(`NavigationControl.${t}`);
            u.setAttribute("aria-label", n), u.firstElementChild && u.firstElementChild.setAttribute("title", n);
          }
        }, GeolocateControl: class extends i.E {
          constructor(u = {}) {
            super();
            const t = navigator.geolocation;
            this.options = i.l({ geolocation: t }, Zn, u), i.aP(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = Xc(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
          }
          onAdd(u) {
            return this._map = u, this._container = w("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
          }
          _checkGeolocationSupport(u) {
            const t = (n = !!this.options.geolocation) => {
              this._supportsGeolocation = n, u(n);
            };
            this._supportsGeolocation !== void 0 ? u(this._supportsGeolocation) : navigator.permissions !== void 0 ? navigator.permissions.query({ name: "geolocation" }).then((n) => t(n.state !== "denied")).catch(() => t()) : t();
          }
          _isOutOfMapMaxBounds(u) {
            const t = this._map.getMaxBounds(), n = u.coords;
            return !!t && (n.longitude < t.getWest() || n.longitude > t.getEast() || n.latitude < t.getSouth() || n.latitude > t.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
            }
          }
          _onSuccess(u) {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(u)) return this._setErrorState(), this.fire(new i.z("outofmaxbounds", u)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = u, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(u), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(u), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new i.z("geolocate", u)), this._finish();
            }
          }
          _updateCamera(u) {
            const t = new i.bO(u.coords.longitude, u.coords.latitude), n = u.coords.accuracy, c = this._map.getBearing(), p = i.l({ bearing: c }, this.options.fitBoundsOptions);
            this._map.fitBounds(t.toBounds(n), p, { geolocateSource: !0 });
          }
          _updateMarker(u) {
            if (u) {
              const t = new i.bO(u.coords.longitude, u.coords.latitude);
              this._accuracyCircleMarker.setLngLat(t).addTo(this._map), this._userLocationDotMarker.setLngLat(t).addTo(this._map), this._accuracy = u.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }
          _updateCircleRadius() {
            const u = this._map.transform, t = i.bH(1, u._center.lat) * u.worldSize, n = Math.ceil(2 * this._accuracy * t);
            this._circleElement.style.width = `${n}px`, this._circleElement.style.height = `${n}px`;
          }
          _onZoom() {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }
          _updateMarkerRotation() {
            this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
          }
          _onError(u) {
            if (this._map) {
              if (this.options.trackUserLocation) if (u.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (u.code === 3 && this._noTimeout) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new i.z("error", u)), this._finish();
            }
          }
          _finish() {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }
          _setupUI(u) {
            if (this._map !== void 0) {
              if (this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this._geolocateButton = w("button", "mapboxgl-ctrl-geolocate", this._container), w("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", u === !1) {
                i.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
              } else {
                const t = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = w("div", "mapboxgl-user-location"), this._dotElement.appendChild(w("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(w("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Js({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = w("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Js({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (t) => {
                t.geolocateSource || this._watchState !== "ACTIVE_LOCK" || t.originalEvent && t.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new i.z("trackuserlocationend")));
              });
            }
          }
          _onDeviceOrientation(u) {
            this._userLocationDotMarker && (u.webkitCompassHeading ? this._heading = u.webkitCompassHeading : u.absolute === !0 && (this._heading = -1 * u.alpha), this._updateMarkerRotationThrottled());
          }
          trigger() {
            if (!this._setup) return i.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new i.z("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new i.z("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new i.z("trackuserlocationstart"));
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "BACKGROUND":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  break;
                case "BACKGROUND_ERROR":
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let u;
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (u = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = !0) : (u = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, u), this.options.showUserHeading && this._addDeviceOrientationListener();
              }
            } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
            return !0;
          }
          _addDeviceOrientationListener() {
            const u = () => {
              "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
            };
            typeof DeviceMotionEvent < "u" && typeof DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then((t) => {
              t === "granted" && u();
            }).catch(console.error) : u();
          }
          _clearWatch() {
            this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, AttributionControl: bc, ScaleControl: class {
          constructor(u = {}) {
            this.options = i.l({}, Qs, u), this._isNumberFormatSupported = function() {
              try {
                return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), !0;
              } catch {
                return !1;
              }
            }(), i.aP(["_update", "_setScale", "setUnit"], this);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          _update() {
            const u = this.options.maxWidth || 100, t = this._map, n = t._containerHeight / 2, c = t._containerWidth / 2 - u / 2, p = t.unproject([c, n]), v = t.unproject([c + u, n]), C = p.distanceTo(v);
            if (this.options.unit === "imperial") {
              const V = 3.2808 * C;
              V > 5280 ? this._setScale(u, V / 5280, "mile") : this._setScale(u, V, "foot");
            } else this.options.unit === "nautical" ? this._setScale(u, C / 1852, "nautical-mile") : C >= 1e3 ? this._setScale(u, C / 1e3, "kilometer") : this._setScale(u, C, "meter");
          }
          _setScale(u, t, n) {
            this._map._requestDomTask(() => {
              const c = function(v) {
                const C = Math.pow(10, `${Math.floor(v)}`.length - 1);
                let V = v / C;
                return V = V >= 10 ? 10 : V >= 5 ? 5 : V >= 3 ? 3 : V >= 2 ? 2 : V >= 1 ? 1 : function(K) {
                  const se = Math.pow(10, Math.ceil(-Math.log(K) / Math.LN10));
                  return Math.round(K * se) / se;
                }(V), C * V;
              }(t), p = c / t;
              this._container.innerHTML = this._isNumberFormatSupported && n !== "nautical-mile" ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: n }).format(c) : `${c}&nbsp;${Pr[n]}`, this._container.style.width = u * p + "px";
            });
          }
          onAdd(u) {
            return this._map = u, this._language = u.getLanguage(), this._container = w("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", u.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
          }
          onRemove() {
            this._container.remove(), this._map.off("move", this._update), this._map = void 0;
          }
          _setLanguage(u) {
            this._language = u, this._update();
          }
          setUnit(u) {
            this.options.unit = u, this._update();
          }
        }, FullscreenControl: class {
          constructor(u = {}) {
            this._fullscreen = !1, u && u.container && (u.container instanceof HTMLElement ? this._container = u.container : i.w("Full screen control 'container' must be a DOM element.")), i.aP(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
          }
          onAdd(u) {
            return this._map = u, this._container || (this._container = this._map.getContainer()), this._controlContainer = w("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", i.w("This device does not support fullscreen mode.")), this._controlContainer;
          }
          onRemove() {
            this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }
          _checkFullscreenSupport() {
            return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
          }
          _setupUI() {
            const u = this._fullscreenButton = w("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
            w("span", "mapboxgl-ctrl-icon", u).setAttribute("aria-hidden", "true"), u.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
          }
          _updateTitle() {
            const u = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", u), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", u);
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _changeIcon() {
            (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }
          _onClickFullscreen() {
            this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          }
        }, Popup: class extends i.E {
          constructor(u) {
            super(), this.options = i.l(Object.create(zu), u), i.aP(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(u && u.className ? u.className.trim().split(/\s+/) : []);
          }
          addTo(u) {
            return this._map && this.remove(), this._map = u, this.options.closeOnClick && u.on("preclick", this._onClose), this.options.closeOnMove && u.on("move", this._onClose), u.on("remove", this.remove), this._update(), u._addPopup(this), this._focusFirstElement(), this._trackPointer ? (u.on("mousemove", this._onMouseEvent), u.on("mouseup", this._onMouseEvent), u._canvasContainer.classList.add("mapboxgl-track-pointer")) : u.on("move", this._update), this.fire(new i.z("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          remove() {
            this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
            const u = this._map;
            return u && (u.off("move", this._update), u.off("move", this._onClose), u.off("preclick", this._onClose), u.off("click", this._onClose), u.off("remove", this.remove), u.off("mousemove", this._onMouseEvent), u.off("mouseup", this._onMouseEvent), u.off("drag", this._onMouseEvent), u._canvasContainer && u._canvasContainer.classList.remove("mapboxgl-track-pointer"), u._removePopup(this), this._map = void 0), this.fire(new i.z("close")), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(u) {
            this._lngLat = i.bO.convert(u), this._pos = null, this._trackPointer = !1, this._update();
            const t = this._map;
            return t && (t.on("move", this._update), t.off("mousemove", this._onMouseEvent), t._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
          }
          trackPointer() {
            this._trackPointer = !0, this._pos = null, this._update();
            const u = this._map;
            return u && (u.off("move", this._update), u.on("mousemove", this._onMouseEvent), u.on("drag", this._onMouseEvent), u._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(u) {
            return this.setDOMContent(document.createTextNode(u));
          }
          setHTML(u) {
            const t = document.createDocumentFragment(), n = document.createElement("body");
            let c;
            for (n.innerHTML = u; c = n.firstChild, c; ) t.appendChild(c);
            return this.setDOMContent(t);
          }
          getMaxWidth() {
            return this._container && this._container.style.maxWidth;
          }
          setMaxWidth(u) {
            return this.options.maxWidth = u, this._update(), this;
          }
          setDOMContent(u) {
            let t = this._content;
            if (t) for (; t.hasChildNodes(); ) t.firstChild && t.removeChild(t.firstChild);
            else t = this._content = w("div", "mapboxgl-popup-content", this._container || void 0);
            if (t.appendChild(u), this.options.closeButton) {
              const n = this._closeButton = w("button", "mapboxgl-popup-close-button", t);
              n.type = "button", n.setAttribute("aria-label", "Close popup"), n.innerHTML = '<span aria-hidden="true">&#215;</span>', n.addEventListener("click", this._onClose);
            }
            return this._update(), this._focusFirstElement(), this;
          }
          addClassName(u) {
            return this._classList.add(u), this._updateClassList(), this;
          }
          removeClassName(u) {
            return this._classList.delete(u), this._updateClassList(), this;
          }
          setOffset(u) {
            return this.options.offset = u, this._update(), this;
          }
          toggleClassName(u) {
            let t;
            return this._classList.delete(u) ? t = !1 : (this._classList.add(u), t = !0), this._updateClassList(), t;
          }
          _onMouseEvent(u) {
            this._update(u.point);
          }
          _getAnchor(u) {
            if (this.options.anchor) return this.options.anchor;
            const t = this._map, n = this._container, c = this._pos;
            if (!t || !n || !c) return "bottom";
            const p = n.offsetWidth, v = n.offsetHeight, C = c.x < p / 2, V = c.x > t.transform.width - p / 2;
            if (c.y + u < v) return C ? "top-left" : V ? "top-right" : "top";
            if (c.y > t.transform.height - v) {
              if (C) return "bottom-left";
              if (V) return "bottom-right";
            }
            return C ? "left" : V ? "right" : "bottom";
          }
          _updateClassList() {
            const u = this._container;
            if (!u) return;
            const t = [...this._classList];
            t.push("mapboxgl-popup"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push("mapboxgl-popup-track-pointer"), u.className = t.join(" ");
          }
          _update(u) {
            const t = this._map, n = this._content;
            if (!t || !this._lngLat && !this._trackPointer || !n) return;
            let c = this._container;
            if (c || (c = this._container = w("div", "mapboxgl-popup", t.getContainer()), this._tip = w("div", "mapboxgl-popup-tip", c), c.appendChild(n)), this.options.maxWidth && c.style.maxWidth !== this.options.maxWidth && (c.style.maxWidth = this.options.maxWidth), t.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Dh(this._lngLat, this._pos, t.transform)), !this._trackPointer || u) {
              const p = this._pos = this._trackPointer && u instanceof i.P ? u : t.project(this._lngLat), v = zh(this.options.offset), C = this._anchor = this._getAnchor(v.y), V = zh(this.options.offset, C), K = p.add(V).round();
              t._requestDomTask(() => {
                this._container && C && (this._container.style.transform = `${il[C]} translate(${K.x}px,${K.y}px)`);
              });
            }
            if (!this._marker && t._showingGlobe()) {
              const p = i.dH(t.transform, this._lngLat) ? 0 : 1;
              this._setOpacity(p);
            }
            this._updateClassList();
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const u = this._container.querySelector(la);
            u && u.focus();
          }
          _onClose() {
            this.remove();
          }
          _setOpacity(u) {
            this._container && (this._container.style.opacity = `${u}`), this._content && (this._content.style.pointerEvents = u ? "auto" : "none");
          }
        }, Marker: Js, Style: Hr, LngLat: i.bO, LngLatBounds: i.az, Point: i.P, MercatorCoordinate: i.aa, FreeCameraOptions: uu, Evented: i.E, config: i.e, prewarm: i.dM, clearPrewarmedResources: i.dN, get accessToken() {
          return i.e.ACCESS_TOKEN;
        }, set accessToken(u) {
          i.e.ACCESS_TOKEN = u;
        }, get baseApiUrl() {
          return i.e.API_URL;
        }, set baseApiUrl(u) {
          i.e.API_URL = u;
        }, get workerCount() {
          return i.dO.workerCount;
        }, set workerCount(u) {
          i.dO.workerCount = u;
        }, get maxParallelImageRequests() {
          return i.e.MAX_PARALLEL_IMAGE_REQUESTS;
        }, set maxParallelImageRequests(u) {
          i.e.MAX_PARALLEL_IMAGE_REQUESTS = u;
        }, clearStorage(u) {
          i.dP(u);
        }, get workerUrl() {
          return i.dQ.workerUrl;
        }, set workerUrl(u) {
          i.dQ.workerUrl = u;
        }, get workerClass() {
          return i.dQ.workerClass;
        }, set workerClass(u) {
          i.dQ.workerClass = u;
        }, get workerParams() {
          return i.dQ.workerParams;
        }, set workerParams(u) {
          i.dQ.workerParams = u;
        }, get dracoUrl() {
          return i.dR();
        }, set dracoUrl(u) {
          i.dS(u);
        }, get meshoptUrl() {
          return i.dT();
        }, set meshoptUrl(u) {
          i.dU(u);
        }, setNow: i.q.setNow, restoreNow: i.q.restoreNow };
      });
      var ie = de;
      return ie;
    });
  }(Xp)), Xp.exports;
}
var s2 = a2();
const ip = /* @__PURE__ */ dd(s2), o2 = ({ map: mt, setPreviewContent: Tt, setPreviewType: qe, cf: Q, setCustomFields: de }) => {
  const q = () => {
    window.devicePixelRatio = 2;
    const ie = 300, i = document.createElement("div");
    i.style.width = `${ie}px`, i.style.height = `${ie}px`, i.style.position = "absolute", i.style.visibility = "hidden", document.body.appendChild(i);
    const N = new ip.Map({
      container: i,
      style: mt.current.getStyle(),
      center: mt.current.getCenter(),
      zoom: mt.current.getZoom(),
      bearing: mt.current.getBearing(),
      pitch: mt.current.getPitch(),
      interactive: !1,
      preserveDrawingBuffer: !0,
      width: ie,
      height: ie
    });
    N.once("idle", () => {
      const Z = N.getCanvas(), R = document.createElement("canvas");
      R.width = ie, R.height = ie;
      const A = R.getContext("2d"), M = (Z.width - ie) / 2, x = (Z.height - ie) / 2;
      A.drawImage(Z, M, x, ie, ie, 0, 0, ie, ie);
      const m = R.toDataURL("image/jpeg", 1);
      Tt(m), qe("image"), de(Q), N.remove(), document.body.removeChild(i);
    });
  };
  return /* @__PURE__ */ Dr.jsx("div", { className: "map-snapshot", children: /* @__PURE__ */ Dr.jsx("div", { className: "confirm-button", onClick: q, children: Q.name }) });
}, Jp = {
  heart: /* @__PURE__ */ Dr.jsx("path", { d: "M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" }),
  pin: /* @__PURE__ */ Dr.jsx("path", { d: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" }),
  stone: /* @__PURE__ */ Dr.jsx("path", { d: "M12 2L2 8.5L12 15L22 8.5L12 2ZM12 17L2 10.5L12 22L22 10.5L12 17Z" })
}, V1 = ({ renderInMap: mt, onMarkerChange: Tt, selectedType: qe, metalType: Q }) => {
  var N;
  const q = tm().filter((Z) => {
    var R;
    return Z.field_type === "custom" && ((R = Z.slug) == null ? void 0 : R.includes("capture-"));
  }), ie = {
    heart: "#323232",
    pin: `var(--metal-border-${Q})`,
    stone: "#000000"
  };
  if (mt)
    return qe !== "none" ? /* @__PURE__ */ Dr.jsx("div", { className: "icon-marker", style: { color: ie[qe] }, children: /* @__PURE__ */ Dr.jsx("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "currentColor", children: Jp[qe] }) }) : null;
  const i = (N = q[0]) == null ? void 0 : N.options.marker;
  return /* @__PURE__ */ Dr.jsxs("div", { className: "marker-selector", children: [
    /* @__PURE__ */ Dr.jsx("label", { className: "marker-label", children: "Marker style:" }),
    /* @__PURE__ */ Dr.jsx("div", { className: "marker-swatches", children: i.map((Z) => /* @__PURE__ */ Dr.jsxs("label", { className: "marker-swatch", children: [
      /* @__PURE__ */ Dr.jsx(
        "input",
        {
          type: "radio",
          name: "marker-type",
          value: Z.value,
          checked: qe === Z.value,
          onChange: (R) => Tt(R.target.value)
        }
      ),
      /* @__PURE__ */ Dr.jsxs("span", { children: [
        Z.value !== "none" && /* @__PURE__ */ Dr.jsx(
          "svg",
          {
            width: "16",
            height: "16",
            viewBox: "0 0 24 24",
            fill: "currentColor",
            style: { color: ie[Z.value] },
            children: Jp[Z.value]
          }
        ),
        Z.label
      ] })
    ] }, Z.value)) })
  ] });
};
function rp(mt) {
  throw new Error('Could not dynamically require "' + mt + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var E_ = { exports: {} }, j1;
function Ky() {
  return j1 || (j1 = 1, function(mt, Tt) {
    if ((typeof qe > "u" || !qe) && typeof self < "u") var qe = self;
    (function(Q) {
      mt.exports = Q();
    })(function() {
      return (/* @__PURE__ */ function() {
        function Q(de, q, ie) {
          function i(R, A) {
            if (!q[R]) {
              if (!de[R]) {
                var M = typeof rp == "function" && rp;
                if (!A && M) return M(R, !0);
                if (N) return N(R, !0);
                var x = new Error("Cannot find module '" + R + "'");
                throw x.code = "MODULE_NOT_FOUND", x;
              }
              var m = q[R] = { exports: {} };
              de[R][0].call(m.exports, function(w) {
                var k = de[R][1][w];
                return i(k || w);
              }, m, m.exports, Q, de, q, ie);
            }
            return q[R].exports;
          }
          for (var N = typeof rp == "function" && rp, Z = 0; Z < ie.length; Z++) i(ie[Z]);
          return i;
        }
        return Q;
      }())({ 1: [function(Q, de, q) {
        function ie(i) {
          if (Array.isArray(i)) return i;
        }
        de.exports = ie;
      }, {}], 2: [function(Q, de, q) {
        function ie(i) {
          if (Array.isArray(i)) {
            for (var N = 0, Z = new Array(i.length); N < i.length; N++)
              Z[N] = i[N];
            return Z;
          }
        }
        de.exports = ie;
      }, {}], 3: [function(Q, de, q) {
        function ie(i) {
          if (i === void 0)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return i;
        }
        de.exports = ie;
      }, {}], 4: [function(Q, de, q) {
        function ie(i, N) {
          if (!(i instanceof N))
            throw new TypeError("Cannot call a class as a function");
        }
        de.exports = ie;
      }, {}], 5: [function(Q, de, q) {
        var ie = Q("./setPrototypeOf");
        function i() {
          if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
          if (typeof Proxy == "function") return !0;
          try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            })), !0;
          } catch {
            return !1;
          }
        }
        function N(Z, R, A) {
          return i() ? de.exports = N = Reflect.construct : de.exports = N = function(x, m, w) {
            var k = [null];
            k.push.apply(k, m);
            var E = Function.bind.apply(x, k), P = new E();
            return w && ie(P, w.prototype), P;
          }, N.apply(null, arguments);
        }
        de.exports = N;
      }, { "./setPrototypeOf": 18 }], 6: [function(Q, de, q) {
        function ie(N, Z) {
          for (var R = 0; R < Z.length; R++) {
            var A = Z[R];
            A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(N, A.key, A);
          }
        }
        function i(N, Z, R) {
          return Z && ie(N.prototype, Z), R && ie(N, R), N;
        }
        de.exports = i;
      }, {}], 7: [function(Q, de, q) {
        function ie(i, N, Z) {
          return N in i ? Object.defineProperty(i, N, {
            value: Z,
            enumerable: !0,
            configurable: !0,
            writable: !0
          }) : i[N] = Z, i;
        }
        de.exports = ie;
      }, {}], 8: [function(Q, de, q) {
        function ie() {
          return de.exports = ie = Object.assign || function(i) {
            for (var N = 1; N < arguments.length; N++) {
              var Z = arguments[N];
              for (var R in Z)
                Object.prototype.hasOwnProperty.call(Z, R) && (i[R] = Z[R]);
            }
            return i;
          }, ie.apply(this, arguments);
        }
        de.exports = ie;
      }, {}], 9: [function(Q, de, q) {
        function ie(i) {
          return de.exports = ie = Object.setPrototypeOf ? Object.getPrototypeOf : function(Z) {
            return Z.__proto__ || Object.getPrototypeOf(Z);
          }, ie(i);
        }
        de.exports = ie;
      }, {}], 10: [function(Q, de, q) {
        var ie = Q("./setPrototypeOf");
        function i(N, Z) {
          if (typeof Z != "function" && Z !== null)
            throw new TypeError("Super expression must either be null or a function");
          N.prototype = Object.create(Z && Z.prototype, {
            constructor: {
              value: N,
              writable: !0,
              configurable: !0
            }
          }), Z && ie(N, Z);
        }
        de.exports = i;
      }, { "./setPrototypeOf": 18 }], 11: [function(Q, de, q) {
        function ie(i) {
          return i && i.__esModule ? i : {
            default: i
          };
        }
        de.exports = ie;
      }, {}], 12: [function(Q, de, q) {
        var ie = Q("../helpers/typeof");
        function i() {
          if (typeof WeakMap != "function") return null;
          var Z = /* @__PURE__ */ new WeakMap();
          return i = function() {
            return Z;
          }, Z;
        }
        function N(Z) {
          if (Z && Z.__esModule)
            return Z;
          if (Z === null || ie(Z) !== "object" && typeof Z != "function")
            return {
              default: Z
            };
          var R = i();
          if (R && R.has(Z))
            return R.get(Z);
          var A = {}, M = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var x in Z)
            if (Object.prototype.hasOwnProperty.call(Z, x)) {
              var m = M ? Object.getOwnPropertyDescriptor(Z, x) : null;
              m && (m.get || m.set) ? Object.defineProperty(A, x, m) : A[x] = Z[x];
            }
          return A.default = Z, R && R.set(Z, A), A;
        }
        de.exports = N;
      }, { "../helpers/typeof": 21 }], 13: [function(Q, de, q) {
        function ie(i) {
          if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === "[object Arguments]") return Array.from(i);
        }
        de.exports = ie;
      }, {}], 14: [function(Q, de, q) {
        function ie(i, N) {
          if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === "[object Arguments]") {
            var Z = [], R = !0, A = !1, M = void 0;
            try {
              for (var x = i[Symbol.iterator](), m; !(R = (m = x.next()).done) && (Z.push(m.value), !(N && Z.length === N)); R = !0)
                ;
            } catch (w) {
              A = !0, M = w;
            } finally {
              try {
                !R && x.return != null && x.return();
              } finally {
                if (A) throw M;
              }
            }
            return Z;
          }
        }
        de.exports = ie;
      }, {}], 15: [function(Q, de, q) {
        function ie() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
        de.exports = ie;
      }, {}], 16: [function(Q, de, q) {
        function ie() {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }
        de.exports = ie;
      }, {}], 17: [function(Q, de, q) {
        var ie = Q("../helpers/typeof"), i = Q("./assertThisInitialized");
        function N(Z, R) {
          return R && (ie(R) === "object" || typeof R == "function") ? R : i(Z);
        }
        de.exports = N;
      }, { "../helpers/typeof": 21, "./assertThisInitialized": 3 }], 18: [function(Q, de, q) {
        function ie(i, N) {
          return de.exports = ie = Object.setPrototypeOf || function(R, A) {
            return R.__proto__ = A, R;
          }, ie(i, N);
        }
        de.exports = ie;
      }, {}], 19: [function(Q, de, q) {
        var ie = Q("./arrayWithHoles"), i = Q("./iterableToArrayLimit"), N = Q("./nonIterableRest");
        function Z(R, A) {
          return ie(R) || i(R, A) || N();
        }
        de.exports = Z;
      }, { "./arrayWithHoles": 1, "./iterableToArrayLimit": 14, "./nonIterableRest": 15 }], 20: [function(Q, de, q) {
        var ie = Q("./arrayWithoutHoles"), i = Q("./iterableToArray"), N = Q("./nonIterableSpread");
        function Z(R) {
          return ie(R) || i(R) || N();
        }
        de.exports = Z;
      }, { "./arrayWithoutHoles": 2, "./iterableToArray": 13, "./nonIterableSpread": 16 }], 21: [function(Q, de, q) {
        function ie(N) {
          return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ie = function(R) {
            return typeof R;
          } : ie = function(R) {
            return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
          }, ie(N);
        }
        function i(N) {
          return typeof Symbol == "function" && ie(Symbol.iterator) === "symbol" ? de.exports = i = function(R) {
            return ie(R);
          } : de.exports = i = function(R) {
            return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : ie(R);
          }, i(N);
        }
        de.exports = i;
      }, {}], 22: [function(Q, de, q) {
        de.exports = Q("regenerator-runtime");
      }, { "regenerator-runtime": 153 }], 23: [function(Q, de, q) {
        var ie = Q("./src/converter");
        function i(N, Z) {
          var R = new ie(N, Z);
          return function(A) {
            return R.convert(A);
          };
        }
        i.BIN = "01", i.OCT = "01234567", i.DEC = "0123456789", i.HEX = "0123456789abcdef", de.exports = i;
      }, { "./src/converter": 24 }], 24: [function(Q, de, q) {
        function ie(i, N) {
          if (!i || !N || !i.length || !N.length)
            throw new Error("Bad alphabet");
          this.srcAlphabet = i, this.dstAlphabet = N;
        }
        ie.prototype.convert = function(i) {
          var N, Z, R, A = {}, M = this.srcAlphabet.length, x = this.dstAlphabet.length, m = i.length, w = typeof i == "string" ? "" : [];
          if (!this.isValid(i))
            throw new Error('Number "' + i + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
          if (this.srcAlphabet === this.dstAlphabet)
            return i;
          for (N = 0; N < m; N++)
            A[N] = this.srcAlphabet.indexOf(i[N]);
          do {
            for (Z = 0, R = 0, N = 0; N < m; N++)
              Z = Z * M + A[N], Z >= x ? (A[R++] = parseInt(Z / x, 10), Z = Z % x) : R > 0 && (A[R++] = 0);
            m = R, w = this.dstAlphabet.slice(Z, Z + 1).concat(w);
          } while (R !== 0);
          return w;
        }, ie.prototype.isValid = function(i) {
          for (var N = 0; N < i.length; ++N)
            if (this.srcAlphabet.indexOf(i[N]) === -1)
              return !1;
          return !0;
        }, de.exports = ie;
      }, {}], 25: [function(Q, de, q) {
        (function(ie) {
          var i = Q("object-assign");
          /*!
           * The buffer module from node.js, for the browser.
           *
           * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
           * @license  MIT
           */
          function N(Ue, we) {
            if (Ue === we)
              return 0;
            for (var Ce = Ue.length, it = we.length, ut = 0, bt = Math.min(Ce, it); ut < bt; ++ut)
              if (Ue[ut] !== we[ut]) {
                Ce = Ue[ut], it = we[ut];
                break;
              }
            return Ce < it ? -1 : it < Ce ? 1 : 0;
          }
          function Z(Ue) {
            return ie.Buffer && typeof ie.Buffer.isBuffer == "function" ? ie.Buffer.isBuffer(Ue) : !!(Ue != null && Ue._isBuffer);
          }
          var R = Q("util/"), A = Object.prototype.hasOwnProperty, M = Array.prototype.slice, x = function() {
            return (function() {
            }).name === "foo";
          }();
          function m(Ue) {
            return Object.prototype.toString.call(Ue);
          }
          function w(Ue) {
            return Z(Ue) || typeof ie.ArrayBuffer != "function" ? !1 : typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(Ue) : Ue ? !!(Ue instanceof DataView || Ue.buffer && Ue.buffer instanceof ArrayBuffer) : !1;
          }
          var k = de.exports = W, E = /\s*function\s+([^\(\s]*)\s*/;
          function P(Ue) {
            if (R.isFunction(Ue)) {
              if (x)
                return Ue.name;
              var we = Ue.toString(), Ce = we.match(E);
              return Ce && Ce[1];
            }
          }
          k.AssertionError = function(we) {
            this.name = "AssertionError", this.actual = we.actual, this.expected = we.expected, this.operator = we.operator, we.message ? (this.message = we.message, this.generatedMessage = !1) : (this.message = j(this), this.generatedMessage = !0);
            var Ce = we.stackStartFunction || T;
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, Ce);
            else {
              var it = new Error();
              if (it.stack) {
                var ut = it.stack, bt = P(Ce), pt = ut.indexOf(`
` + bt);
                if (pt >= 0) {
                  var Ke = ut.indexOf(`
`, pt + 1);
                  ut = ut.substring(Ke + 1);
                }
                this.stack = ut;
              }
            }
          }, R.inherits(k.AssertionError, Error);
          function S(Ue, we) {
            return typeof Ue == "string" ? Ue.length < we ? Ue : Ue.slice(0, we) : Ue;
          }
          function U(Ue) {
            if (x || !R.isFunction(Ue))
              return R.inspect(Ue);
            var we = P(Ue), Ce = we ? ": " + we : "";
            return "[Function" + Ce + "]";
          }
          function j(Ue) {
            return S(U(Ue.actual), 128) + " " + Ue.operator + " " + S(U(Ue.expected), 128);
          }
          function T(Ue, we, Ce, it, ut) {
            throw new k.AssertionError({
              message: Ce,
              actual: Ue,
              expected: we,
              operator: it,
              stackStartFunction: ut
            });
          }
          k.fail = T;
          function W(Ue, we) {
            Ue || T(Ue, !0, we, "==", k.ok);
          }
          k.ok = W, k.equal = function(we, Ce, it) {
            we != Ce && T(we, Ce, it, "==", k.equal);
          }, k.notEqual = function(we, Ce, it) {
            we == Ce && T(we, Ce, it, "!=", k.notEqual);
          }, k.deepEqual = function(we, Ce, it) {
            J(we, Ce, !1) || T(we, Ce, it, "deepEqual", k.deepEqual);
          }, k.deepStrictEqual = function(we, Ce, it) {
            J(we, Ce, !0) || T(we, Ce, it, "deepStrictEqual", k.deepStrictEqual);
          };
          function J(Ue, we, Ce, it) {
            if (Ue === we)
              return !0;
            if (Z(Ue) && Z(we))
              return N(Ue, we) === 0;
            if (R.isDate(Ue) && R.isDate(we))
              return Ue.getTime() === we.getTime();
            if (R.isRegExp(Ue) && R.isRegExp(we))
              return Ue.source === we.source && Ue.global === we.global && Ue.multiline === we.multiline && Ue.lastIndex === we.lastIndex && Ue.ignoreCase === we.ignoreCase;
            if ((Ue === null || typeof Ue != "object") && (we === null || typeof we != "object"))
              return Ce ? Ue === we : Ue == we;
            if (w(Ue) && w(we) && m(Ue) === m(we) && !(Ue instanceof Float32Array || Ue instanceof Float64Array))
              return N(
                new Uint8Array(Ue.buffer),
                new Uint8Array(we.buffer)
              ) === 0;
            if (Z(Ue) !== Z(we))
              return !1;
            it = it || { actual: [], expected: [] };
            var ut = it.actual.indexOf(Ue);
            return ut !== -1 && ut === it.expected.indexOf(we) ? !0 : (it.actual.push(Ue), it.expected.push(we), te(Ue, we, Ce, it));
          }
          function ee(Ue) {
            return Object.prototype.toString.call(Ue) == "[object Arguments]";
          }
          function te(Ue, we, Ce, it) {
            if (Ue == null || we === null || we === void 0)
              return !1;
            if (R.isPrimitive(Ue) || R.isPrimitive(we))
              return Ue === we;
            if (Ce && Object.getPrototypeOf(Ue) !== Object.getPrototypeOf(we))
              return !1;
            var ut = ee(Ue), bt = ee(we);
            if (ut && !bt || !ut && bt)
              return !1;
            if (ut)
              return Ue = M.call(Ue), we = M.call(we), J(Ue, we, Ce);
            var pt = Oe(Ue), Ke = Oe(we), dt, ct;
            if (pt.length !== Ke.length)
              return !1;
            for (pt.sort(), Ke.sort(), ct = pt.length - 1; ct >= 0; ct--)
              if (pt[ct] !== Ke[ct])
                return !1;
            for (ct = pt.length - 1; ct >= 0; ct--)
              if (dt = pt[ct], !J(Ue[dt], we[dt], Ce, it))
                return !1;
            return !0;
          }
          k.notDeepEqual = function(we, Ce, it) {
            J(we, Ce, !1) && T(we, Ce, it, "notDeepEqual", k.notDeepEqual);
          }, k.notDeepStrictEqual = le;
          function le(Ue, we, Ce) {
            J(Ue, we, !0) && T(Ue, we, Ce, "notDeepStrictEqual", le);
          }
          k.strictEqual = function(we, Ce, it) {
            we !== Ce && T(we, Ce, it, "===", k.strictEqual);
          }, k.notStrictEqual = function(we, Ce, it) {
            we === Ce && T(we, Ce, it, "!==", k.notStrictEqual);
          };
          function me(Ue, we) {
            if (!Ue || !we)
              return !1;
            if (Object.prototype.toString.call(we) == "[object RegExp]")
              return we.test(Ue);
            try {
              if (Ue instanceof we)
                return !0;
            } catch {
            }
            return Error.isPrototypeOf(we) ? !1 : we.call({}, Ue) === !0;
          }
          function ke(Ue) {
            var we;
            try {
              Ue();
            } catch (Ce) {
              we = Ce;
            }
            return we;
          }
          function ge(Ue, we, Ce, it) {
            var ut;
            if (typeof we != "function")
              throw new TypeError('"block" argument must be a function');
            typeof Ce == "string" && (it = Ce, Ce = null), ut = ke(we), it = (Ce && Ce.name ? " (" + Ce.name + ")." : ".") + (it ? " " + it : "."), Ue && !ut && T(ut, Ce, "Missing expected exception" + it);
            var bt = typeof it == "string", pt = !Ue && R.isError(ut), Ke = !Ue && ut && !Ce;
            if ((pt && bt && me(ut, Ce) || Ke) && T(ut, Ce, "Got unwanted exception" + it), Ue && ut && Ce && !me(ut, Ce) || !Ue && ut)
              throw ut;
          }
          k.throws = function(Ue, we, Ce) {
            ge(!0, Ue, we, Ce);
          }, k.doesNotThrow = function(Ue, we, Ce) {
            ge(!1, Ue, we, Ce);
          }, k.ifError = function(Ue) {
            if (Ue) throw Ue;
          };
          function Ve(Ue, we) {
            Ue || T(Ue, !0, we, "==", Ve);
          }
          k.strict = i(Ve, k, {
            equal: k.strictEqual,
            deepEqual: k.deepStrictEqual,
            notEqual: k.notStrictEqual,
            notDeepEqual: k.notDeepStrictEqual
          }), k.strict.strict = k.strict;
          var Oe = Object.keys || function(Ue) {
            var we = [];
            for (var Ce in Ue)
              A.call(Ue, Ce) && we.push(Ce);
            return we;
          };
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {});
      }, { "object-assign": 84, "util/": 28 }], 26: [function(Q, de, q) {
        typeof Object.create == "function" ? de.exports = function(i, N) {
          i.super_ = N, i.prototype = Object.create(N.prototype, {
            constructor: {
              value: i,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          });
        } : de.exports = function(i, N) {
          i.super_ = N;
          var Z = function() {
          };
          Z.prototype = N.prototype, i.prototype = new Z(), i.prototype.constructor = i;
        };
      }, {}], 27: [function(Q, de, q) {
        de.exports = function(i) {
          return i && typeof i == "object" && typeof i.copy == "function" && typeof i.fill == "function" && typeof i.readUInt8 == "function";
        };
      }, {}], 28: [function(Q, de, q) {
        (function(ie, i) {
          var N = /%[sdj%]/g;
          q.format = function(Ke) {
            if (!te(Ke)) {
              for (var dt = [], ct = 0; ct < arguments.length; ct++)
                dt.push(A(arguments[ct]));
              return dt.join(" ");
            }
            for (var ct = 1, wt = arguments, Ht = wt.length, $t = String(Ke).replace(N, function(ri) {
              if (ri === "%%") return "%";
              if (ct >= Ht) return ri;
              switch (ri) {
                case "%s":
                  return String(wt[ct++]);
                case "%d":
                  return Number(wt[ct++]);
                case "%j":
                  try {
                    return JSON.stringify(wt[ct++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return ri;
              }
            }), rt = wt[ct]; ct < Ht; rt = wt[++ct])
              W(rt) || !ge(rt) ? $t += " " + rt : $t += " " + A(rt);
            return $t;
          }, q.deprecate = function(Ke, dt) {
            if (me(i.process))
              return function() {
                return q.deprecate(Ke, dt).apply(this, arguments);
              };
            if (ie.noDeprecation === !0)
              return Ke;
            var ct = !1;
            function wt() {
              if (!ct) {
                if (ie.throwDeprecation)
                  throw new Error(dt);
                ie.traceDeprecation ? console.trace(dt) : console.error(dt), ct = !0;
              }
              return Ke.apply(this, arguments);
            }
            return wt;
          };
          var Z = {}, R;
          q.debuglog = function(Ke) {
            if (me(R) && (R = ie.env.NODE_DEBUG || ""), Ke = Ke.toUpperCase(), !Z[Ke])
              if (new RegExp("\\b" + Ke + "\\b", "i").test(R)) {
                var dt = ie.pid;
                Z[Ke] = function() {
                  var ct = q.format.apply(q, arguments);
                  console.error("%s %d: %s", Ke, dt, ct);
                };
              } else
                Z[Ke] = function() {
                };
            return Z[Ke];
          };
          function A(Ke, dt) {
            var ct = {
              seen: [],
              stylize: x
            };
            return arguments.length >= 3 && (ct.depth = arguments[2]), arguments.length >= 4 && (ct.colors = arguments[3]), T(dt) ? ct.showHidden = dt : dt && q._extend(ct, dt), me(ct.showHidden) && (ct.showHidden = !1), me(ct.depth) && (ct.depth = 2), me(ct.colors) && (ct.colors = !1), me(ct.customInspect) && (ct.customInspect = !0), ct.colors && (ct.stylize = M), w(ct, Ke, ct.depth);
          }
          q.inspect = A, A.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, A.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red"
          };
          function M(Ke, dt) {
            var ct = A.styles[dt];
            return ct ? "\x1B[" + A.colors[ct][0] + "m" + Ke + "\x1B[" + A.colors[ct][1] + "m" : Ke;
          }
          function x(Ke, dt) {
            return Ke;
          }
          function m(Ke) {
            var dt = {};
            return Ke.forEach(function(ct, wt) {
              dt[ct] = !0;
            }), dt;
          }
          function w(Ke, dt, ct) {
            if (Ke.customInspect && dt && Ue(dt.inspect) && // Filter out the util module, it's inspect function is special
            dt.inspect !== q.inspect && // Also filter out any prototype objects using the circular check.
            !(dt.constructor && dt.constructor.prototype === dt)) {
              var wt = dt.inspect(ct, Ke);
              return te(wt) || (wt = w(Ke, wt, ct)), wt;
            }
            var Ht = k(Ke, dt);
            if (Ht)
              return Ht;
            var $t = Object.keys(dt), rt = m($t);
            if (Ke.showHidden && ($t = Object.getOwnPropertyNames(dt)), Oe(dt) && ($t.indexOf("message") >= 0 || $t.indexOf("description") >= 0))
              return E(dt);
            if ($t.length === 0) {
              if (Ue(dt)) {
                var ri = dt.name ? ": " + dt.name : "";
                return Ke.stylize("[Function" + ri + "]", "special");
              }
              if (ke(dt))
                return Ke.stylize(RegExp.prototype.toString.call(dt), "regexp");
              if (Ve(dt))
                return Ke.stylize(Date.prototype.toString.call(dt), "date");
              if (Oe(dt))
                return E(dt);
            }
            var wi = "", Qt = !1, At = ["{", "}"];
            if (j(dt) && (Qt = !0, At = ["[", "]"]), Ue(dt)) {
              var St = dt.name ? ": " + dt.name : "";
              wi = " [Function" + St + "]";
            }
            if (ke(dt) && (wi = " " + RegExp.prototype.toString.call(dt)), Ve(dt) && (wi = " " + Date.prototype.toUTCString.call(dt)), Oe(dt) && (wi = " " + E(dt)), $t.length === 0 && (!Qt || dt.length == 0))
              return At[0] + wi + At[1];
            if (ct < 0)
              return ke(dt) ? Ke.stylize(RegExp.prototype.toString.call(dt), "regexp") : Ke.stylize("[Object]", "special");
            Ke.seen.push(dt);
            var Lt;
            return Qt ? Lt = P(Ke, dt, ct, rt, $t) : Lt = $t.map(function(kt) {
              return S(Ke, dt, ct, rt, kt, Qt);
            }), Ke.seen.pop(), U(Lt, wi, At);
          }
          function k(Ke, dt) {
            if (me(dt))
              return Ke.stylize("undefined", "undefined");
            if (te(dt)) {
              var ct = "'" + JSON.stringify(dt).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return Ke.stylize(ct, "string");
            }
            if (ee(dt))
              return Ke.stylize("" + dt, "number");
            if (T(dt))
              return Ke.stylize("" + dt, "boolean");
            if (W(dt))
              return Ke.stylize("null", "null");
          }
          function E(Ke) {
            return "[" + Error.prototype.toString.call(Ke) + "]";
          }
          function P(Ke, dt, ct, wt, Ht) {
            for (var $t = [], rt = 0, ri = dt.length; rt < ri; ++rt)
              pt(dt, String(rt)) ? $t.push(S(
                Ke,
                dt,
                ct,
                wt,
                String(rt),
                !0
              )) : $t.push("");
            return Ht.forEach(function(wi) {
              wi.match(/^\d+$/) || $t.push(S(
                Ke,
                dt,
                ct,
                wt,
                wi,
                !0
              ));
            }), $t;
          }
          function S(Ke, dt, ct, wt, Ht, $t) {
            var rt, ri, wi;
            if (wi = Object.getOwnPropertyDescriptor(dt, Ht) || { value: dt[Ht] }, wi.get ? wi.set ? ri = Ke.stylize("[Getter/Setter]", "special") : ri = Ke.stylize("[Getter]", "special") : wi.set && (ri = Ke.stylize("[Setter]", "special")), pt(wt, Ht) || (rt = "[" + Ht + "]"), ri || (Ke.seen.indexOf(wi.value) < 0 ? (W(ct) ? ri = w(Ke, wi.value, null) : ri = w(Ke, wi.value, ct - 1), ri.indexOf(`
`) > -1 && ($t ? ri = ri.split(`
`).map(function(Qt) {
              return "  " + Qt;
            }).join(`
`).substr(2) : ri = `
` + ri.split(`
`).map(function(Qt) {
              return "   " + Qt;
            }).join(`
`))) : ri = Ke.stylize("[Circular]", "special")), me(rt)) {
              if ($t && Ht.match(/^\d+$/))
                return ri;
              rt = JSON.stringify("" + Ht), rt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (rt = rt.substr(1, rt.length - 2), rt = Ke.stylize(rt, "name")) : (rt = rt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), rt = Ke.stylize(rt, "string"));
            }
            return rt + ": " + ri;
          }
          function U(Ke, dt, ct) {
            var wt = Ke.reduce(function(Ht, $t) {
              return $t.indexOf(`
`) >= 0, Ht + $t.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return wt > 60 ? ct[0] + (dt === "" ? "" : dt + `
 `) + " " + Ke.join(`,
  `) + " " + ct[1] : ct[0] + dt + " " + Ke.join(", ") + " " + ct[1];
          }
          function j(Ke) {
            return Array.isArray(Ke);
          }
          q.isArray = j;
          function T(Ke) {
            return typeof Ke == "boolean";
          }
          q.isBoolean = T;
          function W(Ke) {
            return Ke === null;
          }
          q.isNull = W;
          function J(Ke) {
            return Ke == null;
          }
          q.isNullOrUndefined = J;
          function ee(Ke) {
            return typeof Ke == "number";
          }
          q.isNumber = ee;
          function te(Ke) {
            return typeof Ke == "string";
          }
          q.isString = te;
          function le(Ke) {
            return typeof Ke == "symbol";
          }
          q.isSymbol = le;
          function me(Ke) {
            return Ke === void 0;
          }
          q.isUndefined = me;
          function ke(Ke) {
            return ge(Ke) && Ce(Ke) === "[object RegExp]";
          }
          q.isRegExp = ke;
          function ge(Ke) {
            return typeof Ke == "object" && Ke !== null;
          }
          q.isObject = ge;
          function Ve(Ke) {
            return ge(Ke) && Ce(Ke) === "[object Date]";
          }
          q.isDate = Ve;
          function Oe(Ke) {
            return ge(Ke) && (Ce(Ke) === "[object Error]" || Ke instanceof Error);
          }
          q.isError = Oe;
          function Ue(Ke) {
            return typeof Ke == "function";
          }
          q.isFunction = Ue;
          function we(Ke) {
            return Ke === null || typeof Ke == "boolean" || typeof Ke == "number" || typeof Ke == "string" || typeof Ke == "symbol" || // ES6 symbol
            typeof Ke > "u";
          }
          q.isPrimitive = we, q.isBuffer = Q("./support/isBuffer");
          function Ce(Ke) {
            return Object.prototype.toString.call(Ke);
          }
          function it(Ke) {
            return Ke < 10 ? "0" + Ke.toString(10) : Ke.toString(10);
          }
          var ut = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function bt() {
            var Ke = /* @__PURE__ */ new Date(), dt = [
              it(Ke.getHours()),
              it(Ke.getMinutes()),
              it(Ke.getSeconds())
            ].join(":");
            return [Ke.getDate(), ut[Ke.getMonth()], dt].join(" ");
          }
          q.log = function() {
            console.log("%s - %s", bt(), q.format.apply(q, arguments));
          }, q.inherits = Q("inherits"), q._extend = function(Ke, dt) {
            if (!dt || !ge(dt)) return Ke;
            for (var ct = Object.keys(dt), wt = ct.length; wt--; )
              Ke[ct[wt]] = dt[ct[wt]];
            return Ke;
          };
          function pt(Ke, dt) {
            return Object.prototype.hasOwnProperty.call(Ke, dt);
          }
        }).call(this, Q("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {});
      }, { "./support/isBuffer": 27, _process: 133, inherits: 26 }], 29: [function(Q, de, q) {
        q.byteLength = x, q.toByteArray = w, q.fromByteArray = P;
        for (var ie = [], i = [], N = typeof Uint8Array < "u" ? Uint8Array : Array, Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", R = 0, A = Z.length; R < A; ++R)
          ie[R] = Z[R], i[Z.charCodeAt(R)] = R;
        i[45] = 62, i[95] = 63;
        function M(S) {
          var U = S.length;
          if (U % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var j = S.indexOf("=");
          j === -1 && (j = U);
          var T = j === U ? 0 : 4 - j % 4;
          return [j, T];
        }
        function x(S) {
          var U = M(S), j = U[0], T = U[1];
          return (j + T) * 3 / 4 - T;
        }
        function m(S, U, j) {
          return (U + j) * 3 / 4 - j;
        }
        function w(S) {
          var U, j = M(S), T = j[0], W = j[1], J = new N(m(S, T, W)), ee = 0, te = W > 0 ? T - 4 : T, le;
          for (le = 0; le < te; le += 4)
            U = i[S.charCodeAt(le)] << 18 | i[S.charCodeAt(le + 1)] << 12 | i[S.charCodeAt(le + 2)] << 6 | i[S.charCodeAt(le + 3)], J[ee++] = U >> 16 & 255, J[ee++] = U >> 8 & 255, J[ee++] = U & 255;
          return W === 2 && (U = i[S.charCodeAt(le)] << 2 | i[S.charCodeAt(le + 1)] >> 4, J[ee++] = U & 255), W === 1 && (U = i[S.charCodeAt(le)] << 10 | i[S.charCodeAt(le + 1)] << 4 | i[S.charCodeAt(le + 2)] >> 2, J[ee++] = U >> 8 & 255, J[ee++] = U & 255), J;
        }
        function k(S) {
          return ie[S >> 18 & 63] + ie[S >> 12 & 63] + ie[S >> 6 & 63] + ie[S & 63];
        }
        function E(S, U, j) {
          for (var T, W = [], J = U; J < j; J += 3)
            T = (S[J] << 16 & 16711680) + (S[J + 1] << 8 & 65280) + (S[J + 2] & 255), W.push(k(T));
          return W.join("");
        }
        function P(S) {
          for (var U, j = S.length, T = j % 3, W = [], J = 16383, ee = 0, te = j - T; ee < te; ee += J)
            W.push(E(
              S,
              ee,
              ee + J > te ? te : ee + J
            ));
          return T === 1 ? (U = S[j - 1], W.push(
            ie[U >> 2] + ie[U << 4 & 63] + "=="
          )) : T === 2 && (U = (S[j - 2] << 8) + S[j - 1], W.push(
            ie[U >> 10] + ie[U >> 4 & 63] + ie[U << 2 & 63] + "="
          )), W.join("");
        }
      }, {}], 30: [function(Q, de, q) {
        var ie = Q("./lib/encoder"), i = Q("./lib/decoder");
        de.exports = {
          encode: ie,
          decode: i
        };
      }, { "./lib/decoder": 31, "./lib/encoder": 32 }], 31: [function(Q, de, q) {
        (function(ie) {
          function i(N, Z) {
            if (this.pos = 0, this.buffer = N, this.is_with_alpha = !!Z, this.bottom_up = !0, this.flag = this.buffer.toString("utf-8", 0, this.pos += 2), this.flag != "BM") throw new Error("Invalid BMP File");
            this.parseHeader(), this.parseRGBA();
          }
          i.prototype.parseHeader = function() {
            if (this.fileSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.reserved = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.offset = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.headerSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.width = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.height = this.buffer.readInt32LE(this.pos), this.pos += 4, this.planes = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.bitPP = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.compress = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.rawSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.hr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.vr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.colors = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.importantColors = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
              var N = this.colors === 0 ? 1 << this.bitPP : this.colors;
              this.palette = new Array(N);
              for (var Z = 0; Z < N; Z++) {
                var R = this.buffer.readUInt8(this.pos++), A = this.buffer.readUInt8(this.pos++), M = this.buffer.readUInt8(this.pos++), x = this.buffer.readUInt8(this.pos++);
                this.palette[Z] = {
                  red: M,
                  green: A,
                  blue: R,
                  quad: x
                };
              }
            }
            this.height < 0 && (this.height *= -1, this.bottom_up = !1);
          }, i.prototype.parseRGBA = function() {
            var N = "bit" + this.bitPP, Z = this.width * this.height * 4;
            this.data = new ie(Z), this[N]();
          }, i.prototype.bit1 = function() {
            for (var N = Math.ceil(this.width / 8), Z = N % 4, R = this.height >= 0 ? this.height - 1 : -this.height, R = this.height - 1; R >= 0; R--) {
              for (var A = this.bottom_up ? R : this.height - 1 - R, M = 0; M < N; M++)
                for (var x = this.buffer.readUInt8(this.pos++), m = A * this.width * 4 + M * 8 * 4, w = 0; w < 8 && M * 8 + w < this.width; w++) {
                  var k = this.palette[x >> 7 - w & 1];
                  this.data[m + w * 4] = 0, this.data[m + w * 4 + 1] = k.blue, this.data[m + w * 4 + 2] = k.green, this.data[m + w * 4 + 3] = k.red;
                }
              Z != 0 && (this.pos += 4 - Z);
            }
          }, i.prototype.bit4 = function() {
            if (this.compress == 2) {
              let W = function(J) {
                var ee = this.palette[J];
                this.data[N] = 0, this.data[N + 1] = ee.blue, this.data[N + 2] = ee.green, this.data[N + 3] = ee.red, N += 4;
              };
              this.data.fill(255);
              for (var N = 0, Z = this.bottom_up ? this.height - 1 : 0, R = !1; N < this.data.length; ) {
                var A = this.buffer.readUInt8(this.pos++), M = this.buffer.readUInt8(this.pos++);
                if (A == 0)
                  if (M == 0) {
                    this.bottom_up ? Z-- : Z++, N = Z * this.width * 4, R = !1;
                    continue;
                  } else {
                    if (M == 1)
                      break;
                    if (M == 2) {
                      var x = this.buffer.readUInt8(this.pos++), m = this.buffer.readUInt8(this.pos++);
                      this.bottom_up ? Z -= m : Z += m, N += m * this.width * 4 + x * 4;
                    } else {
                      for (var w = this.buffer.readUInt8(this.pos++), k = 0; k < M; k++)
                        R ? W.call(this, w & 15) : W.call(this, (w & 240) >> 4), k & 1 && k + 1 < M && (w = this.buffer.readUInt8(this.pos++)), R = !R;
                      (M + 1 >> 1 & 1) == 1 && this.pos++;
                    }
                  }
                else
                  for (var k = 0; k < A; k++)
                    R ? W.call(this, M & 15) : W.call(this, (M & 240) >> 4), R = !R;
              }
            } else
              for (var E = Math.ceil(this.width / 2), P = E % 4, m = this.height - 1; m >= 0; m--) {
                for (var S = this.bottom_up ? m : this.height - 1 - m, x = 0; x < E; x++) {
                  var M = this.buffer.readUInt8(this.pos++), N = S * this.width * 4 + x * 2 * 4, U = M >> 4, j = M & 15, T = this.palette[U];
                  if (this.data[N] = 0, this.data[N + 1] = T.blue, this.data[N + 2] = T.green, this.data[N + 3] = T.red, x * 2 + 1 >= this.width) break;
                  T = this.palette[j], this.data[N + 4] = 0, this.data[N + 4 + 1] = T.blue, this.data[N + 4 + 2] = T.green, this.data[N + 4 + 3] = T.red;
                }
                P != 0 && (this.pos += 4 - P);
              }
          }, i.prototype.bit8 = function() {
            if (this.compress == 1) {
              let S = function(U) {
                var j = this.palette[U];
                this.data[N] = 0, this.data[N + 1] = j.blue, this.data[N + 2] = j.green, this.data[N + 3] = j.red, N += 4;
              };
              this.data.fill(255);
              for (var N = 0, Z = this.bottom_up ? this.height - 1 : 0; N < this.data.length; ) {
                var R = this.buffer.readUInt8(this.pos++), A = this.buffer.readUInt8(this.pos++);
                if (R == 0)
                  if (A == 0) {
                    this.bottom_up ? Z-- : Z++, N = Z * this.width * 4;
                    continue;
                  } else {
                    if (A == 1)
                      break;
                    if (A == 2) {
                      var M = this.buffer.readUInt8(this.pos++), x = this.buffer.readUInt8(this.pos++);
                      this.bottom_up ? Z -= x : Z += x, N += x * this.width * 4 + M * 4;
                    } else {
                      for (var m = 0; m < A; m++) {
                        var w = this.buffer.readUInt8(this.pos++);
                        S.call(this, w);
                      }
                      A & !0 && this.pos++;
                    }
                  }
                else
                  for (var m = 0; m < R; m++)
                    S.call(this, A);
              }
            } else
              for (var k = this.width % 4, x = this.height - 1; x >= 0; x--) {
                for (var E = this.bottom_up ? x : this.height - 1 - x, M = 0; M < this.width; M++) {
                  var A = this.buffer.readUInt8(this.pos++), N = E * this.width * 4 + M * 4;
                  if (A < this.palette.length) {
                    var P = this.palette[A];
                    this.data[N] = 0, this.data[N + 1] = P.blue, this.data[N + 2] = P.green, this.data[N + 3] = P.red;
                  } else
                    this.data[N] = 0, this.data[N + 1] = 255, this.data[N + 2] = 255, this.data[N + 3] = 255;
                }
                k != 0 && (this.pos += 4 - k);
              }
          }, i.prototype.bit15 = function() {
            for (var N = this.width % 3, Z = parseInt("11111", 2), R = Z, A = this.height - 1; A >= 0; A--) {
              for (var M = this.bottom_up ? A : this.height - 1 - A, x = 0; x < this.width; x++) {
                var m = this.buffer.readUInt16LE(this.pos);
                this.pos += 2;
                var w = (m & R) / R * 255 | 0, k = (m >> 5 & R) / R * 255 | 0, E = (m >> 10 & R) / R * 255 | 0, P = m >> 15 ? 255 : 0, S = M * this.width * 4 + x * 4;
                this.data[S] = P, this.data[S + 1] = w, this.data[S + 2] = k, this.data[S + 3] = E;
              }
              this.pos += N;
            }
          }, i.prototype.bit16 = function() {
            var N = this.width % 2 * 2;
            this.maskRed = 31744, this.maskGreen = 992, this.maskBlue = 31, this.mask0 = 0, this.compress == 3 && (this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4);
            for (var Z = [0, 0, 0], R = 0; R < 16; R++)
              this.maskRed >> R & 1 && Z[0]++, this.maskGreen >> R & 1 && Z[1]++, this.maskBlue >> R & 1 && Z[2]++;
            Z[1] += Z[0], Z[2] += Z[1], Z[0] = 8 - Z[0], Z[1] -= 8, Z[2] -= 8;
            for (var A = this.height - 1; A >= 0; A--) {
              for (var M = this.bottom_up ? A : this.height - 1 - A, x = 0; x < this.width; x++) {
                var m = this.buffer.readUInt16LE(this.pos);
                this.pos += 2;
                var w = (m & this.maskBlue) << Z[0], k = (m & this.maskGreen) >> Z[1], E = (m & this.maskRed) >> Z[2], P = M * this.width * 4 + x * 4;
                this.data[P] = 0, this.data[P + 1] = w, this.data[P + 2] = k, this.data[P + 3] = E;
              }
              this.pos += N;
            }
          }, i.prototype.bit24 = function() {
            for (var N = this.height - 1; N >= 0; N--) {
              for (var Z = this.bottom_up ? N : this.height - 1 - N, R = 0; R < this.width; R++) {
                var A = this.buffer.readUInt8(this.pos++), M = this.buffer.readUInt8(this.pos++), x = this.buffer.readUInt8(this.pos++), m = Z * this.width * 4 + R * 4;
                this.data[m] = 0, this.data[m + 1] = A, this.data[m + 2] = M, this.data[m + 3] = x;
              }
              this.pos += this.width % 4;
            }
          }, i.prototype.bit32 = function() {
            if (this.compress == 3) {
              this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4;
              for (var N = this.height - 1; N >= 0; N--)
                for (var Z = this.bottom_up ? N : this.height - 1 - N, R = 0; R < this.width; R++) {
                  var A = this.buffer.readUInt8(this.pos++), M = this.buffer.readUInt8(this.pos++), x = this.buffer.readUInt8(this.pos++), m = this.buffer.readUInt8(this.pos++), w = Z * this.width * 4 + R * 4;
                  this.data[w] = A, this.data[w + 1] = M, this.data[w + 2] = x, this.data[w + 3] = m;
                }
            } else
              for (var N = this.height - 1; N >= 0; N--)
                for (var Z = this.bottom_up ? N : this.height - 1 - N, R = 0; R < this.width; R++) {
                  var M = this.buffer.readUInt8(this.pos++), x = this.buffer.readUInt8(this.pos++), m = this.buffer.readUInt8(this.pos++), A = this.buffer.readUInt8(this.pos++), w = Z * this.width * 4 + R * 4;
                  this.data[w] = A, this.data[w + 1] = M, this.data[w + 2] = x, this.data[w + 3] = m;
                }
          }, i.prototype.getData = function() {
            return this.data;
          }, de.exports = function(N) {
            var Z = new i(N);
            return Z;
          };
        }).call(this, Q("buffer").Buffer);
      }, { buffer: 48 }], 32: [function(Q, de, q) {
        (function(ie) {
          function i(N) {
            this.buffer = N.data, this.width = N.width, this.height = N.height, this.extraBytes = this.width % 4, this.rgbSize = this.height * (3 * this.width + this.extraBytes), this.headerInfoSize = 40, this.data = [], this.flag = "BM", this.reserved = 0, this.offset = 54, this.fileSize = this.rgbSize + this.offset, this.planes = 1, this.bitPP = 24, this.compress = 0, this.hr = 0, this.vr = 0, this.colors = 0, this.importantColors = 0;
          }
          i.prototype.encode = function() {
            var N = new ie(this.offset + this.rgbSize);
            this.pos = 0, N.write(this.flag, this.pos, 2), this.pos += 2, N.writeUInt32LE(this.fileSize, this.pos), this.pos += 4, N.writeUInt32LE(this.reserved, this.pos), this.pos += 4, N.writeUInt32LE(this.offset, this.pos), this.pos += 4, N.writeUInt32LE(this.headerInfoSize, this.pos), this.pos += 4, N.writeUInt32LE(this.width, this.pos), this.pos += 4, N.writeInt32LE(-this.height, this.pos), this.pos += 4, N.writeUInt16LE(this.planes, this.pos), this.pos += 2, N.writeUInt16LE(this.bitPP, this.pos), this.pos += 2, N.writeUInt32LE(this.compress, this.pos), this.pos += 4, N.writeUInt32LE(this.rgbSize, this.pos), this.pos += 4, N.writeUInt32LE(this.hr, this.pos), this.pos += 4, N.writeUInt32LE(this.vr, this.pos), this.pos += 4, N.writeUInt32LE(this.colors, this.pos), this.pos += 4, N.writeUInt32LE(this.importantColors, this.pos), this.pos += 4;
            for (var Z = 0, R = 3 * this.width + this.extraBytes, A = 0; A < this.height; A++) {
              for (var M = 0; M < this.width; M++) {
                var x = this.pos + A * R + M * 3;
                Z++, N[x] = this.buffer[Z++], N[x + 1] = this.buffer[Z++], N[x + 2] = this.buffer[Z++];
              }
              if (this.extraBytes > 0) {
                var m = this.pos + A * R + this.width * 3;
                N.fill(0, m, m + this.extraBytes);
              }
            }
            return N;
          }, de.exports = function(N, Z) {
            var R = new i(N), A = R.encode();
            return {
              data: A,
              width: N.width,
              height: N.height
            };
          };
        }).call(this, Q("buffer").Buffer);
      }, { buffer: 48 }], 33: [function(Q, de, q) {
      }, {}], 34: [function(Q, de, q) {
        (function(ie, i) {
          var N = Q("assert"), Z = Q("pako/lib/zlib/zstream"), R = Q("pako/lib/zlib/deflate.js"), A = Q("pako/lib/zlib/inflate.js"), M = Q("pako/lib/zlib/constants");
          for (var x in M)
            q[x] = M[x];
          q.NONE = 0, q.DEFLATE = 1, q.INFLATE = 2, q.GZIP = 3, q.GUNZIP = 4, q.DEFLATERAW = 5, q.INFLATERAW = 6, q.UNZIP = 7;
          var m = 31, w = 139;
          function k(E) {
            if (typeof E != "number" || E < q.DEFLATE || E > q.UNZIP)
              throw new TypeError("Bad argument");
            this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = E, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
          }
          k.prototype.close = function() {
            if (this.write_in_progress) {
              this.pending_close = !0;
              return;
            }
            this.pending_close = !1, N(this.init_done, "close before init"), N(this.mode <= q.UNZIP), this.mode === q.DEFLATE || this.mode === q.GZIP || this.mode === q.DEFLATERAW ? R.deflateEnd(this.strm) : (this.mode === q.INFLATE || this.mode === q.GUNZIP || this.mode === q.INFLATERAW || this.mode === q.UNZIP) && A.inflateEnd(this.strm), this.mode = q.NONE, this.dictionary = null;
          }, k.prototype.write = function(E, P, S, U, j, T, W) {
            return this._write(!0, E, P, S, U, j, T, W);
          }, k.prototype.writeSync = function(E, P, S, U, j, T, W) {
            return this._write(!1, E, P, S, U, j, T, W);
          }, k.prototype._write = function(E, P, S, U, j, T, W, J) {
            if (N.equal(arguments.length, 8), N(this.init_done, "write before init"), N(this.mode !== q.NONE, "already finalized"), N.equal(!1, this.write_in_progress, "write already in progress"), N.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, N.equal(!1, P === void 0, "must provide flush value"), this.write_in_progress = !0, P !== q.Z_NO_FLUSH && P !== q.Z_PARTIAL_FLUSH && P !== q.Z_SYNC_FLUSH && P !== q.Z_FULL_FLUSH && P !== q.Z_FINISH && P !== q.Z_BLOCK)
              throw new Error("Invalid flush value");
            if (S == null && (S = i.alloc(0), j = 0, U = 0), this.strm.avail_in = j, this.strm.input = S, this.strm.next_in = U, this.strm.avail_out = J, this.strm.output = T, this.strm.next_out = W, this.flush = P, !E)
              return this._process(), this._checkError() ? this._afterSync() : void 0;
            var ee = this;
            return ie.nextTick(function() {
              ee._process(), ee._after();
            }), this;
          }, k.prototype._afterSync = function() {
            var E = this.strm.avail_out, P = this.strm.avail_in;
            return this.write_in_progress = !1, [P, E];
          }, k.prototype._process = function() {
            var E = null;
            switch (this.mode) {
              case q.DEFLATE:
              case q.GZIP:
              case q.DEFLATERAW:
                this.err = R.deflate(this.strm, this.flush);
                break;
              case q.UNZIP:
                switch (this.strm.avail_in > 0 && (E = this.strm.next_in), this.gzip_id_bytes_read) {
                  case 0:
                    if (E === null)
                      break;
                    if (this.strm.input[E] === m) {
                      if (this.gzip_id_bytes_read = 1, E++, this.strm.avail_in === 1)
                        break;
                    } else {
                      this.mode = q.INFLATE;
                      break;
                    }
                  // fallthrough
                  case 1:
                    if (E === null)
                      break;
                    this.strm.input[E] === w ? (this.gzip_id_bytes_read = 2, this.mode = q.GUNZIP) : this.mode = q.INFLATE;
                    break;
                  default:
                    throw new Error("invalid number of gzip magic number bytes read");
                }
              // fallthrough
              case q.INFLATE:
              case q.GUNZIP:
              case q.INFLATERAW:
                for (this.err = A.inflate(
                  this.strm,
                  this.flush
                  // If data was encoded with dictionary
                ), this.err === q.Z_NEED_DICT && this.dictionary && (this.err = A.inflateSetDictionary(this.strm, this.dictionary), this.err === q.Z_OK ? this.err = A.inflate(this.strm, this.flush) : this.err === q.Z_DATA_ERROR && (this.err = q.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === q.GUNZIP && this.err === q.Z_STREAM_END && this.strm.next_in[0] !== 0; )
                  this.reset(), this.err = A.inflate(this.strm, this.flush);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
          }, k.prototype._checkError = function() {
            switch (this.err) {
              case q.Z_OK:
              case q.Z_BUF_ERROR:
                if (this.strm.avail_out !== 0 && this.flush === q.Z_FINISH)
                  return this._error("unexpected end of file"), !1;
                break;
              case q.Z_STREAM_END:
                break;
              case q.Z_NEED_DICT:
                return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
              default:
                return this._error("Zlib error"), !1;
            }
            return !0;
          }, k.prototype._after = function() {
            if (this._checkError()) {
              var E = this.strm.avail_out, P = this.strm.avail_in;
              this.write_in_progress = !1, this.callback(P, E), this.pending_close && this.close();
            }
          }, k.prototype._error = function(E) {
            this.strm.msg && (E = this.strm.msg), this.onerror(
              E,
              this.err
              // no hope of rescue.
            ), this.write_in_progress = !1, this.pending_close && this.close();
          }, k.prototype.init = function(E, P, S, U, j) {
            N(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), N(E >= 8 && E <= 15, "invalid windowBits"), N(P >= -1 && P <= 9, "invalid compression level"), N(S >= 1 && S <= 9, "invalid memlevel"), N(U === q.Z_FILTERED || U === q.Z_HUFFMAN_ONLY || U === q.Z_RLE || U === q.Z_FIXED || U === q.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(P, E, S, U, j), this._setDictionary();
          }, k.prototype.params = function() {
            throw new Error("deflateParams Not supported");
          }, k.prototype.reset = function() {
            this._reset(), this._setDictionary();
          }, k.prototype._init = function(E, P, S, U, j) {
            switch (this.level = E, this.windowBits = P, this.memLevel = S, this.strategy = U, this.flush = q.Z_NO_FLUSH, this.err = q.Z_OK, (this.mode === q.GZIP || this.mode === q.GUNZIP) && (this.windowBits += 16), this.mode === q.UNZIP && (this.windowBits += 32), (this.mode === q.DEFLATERAW || this.mode === q.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new Z(), this.mode) {
              case q.DEFLATE:
              case q.GZIP:
              case q.DEFLATERAW:
                this.err = R.deflateInit2(this.strm, this.level, q.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                break;
              case q.INFLATE:
              case q.GUNZIP:
              case q.INFLATERAW:
              case q.UNZIP:
                this.err = A.inflateInit2(this.strm, this.windowBits);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
            this.err !== q.Z_OK && this._error("Init error"), this.dictionary = j, this.write_in_progress = !1, this.init_done = !0;
          }, k.prototype._setDictionary = function() {
            if (this.dictionary != null) {
              switch (this.err = q.Z_OK, this.mode) {
                case q.DEFLATE:
                case q.DEFLATERAW:
                  this.err = R.deflateSetDictionary(this.strm, this.dictionary);
                  break;
              }
              this.err !== q.Z_OK && this._error("Failed to set dictionary");
            }
          }, k.prototype._reset = function() {
            switch (this.err = q.Z_OK, this.mode) {
              case q.DEFLATE:
              case q.DEFLATERAW:
              case q.GZIP:
                this.err = R.deflateReset(this.strm);
                break;
              case q.INFLATE:
              case q.INFLATERAW:
              case q.GUNZIP:
                this.err = A.inflateReset(this.strm);
                break;
            }
            this.err !== q.Z_OK && this._error("Failed to reset stream");
          }, q.Zlib = k;
        }).call(this, Q("_process"), Q("buffer").Buffer);
      }, { _process: 133, assert: 25, buffer: 48, "pako/lib/zlib/constants": 38, "pako/lib/zlib/deflate.js": 40, "pako/lib/zlib/inflate.js": 42, "pako/lib/zlib/zstream": 46 }], 35: [function(Q, de, q) {
        (function(ie) {
          var i = Q("buffer").Buffer, N = Q("stream").Transform, Z = Q("./binding"), R = Q("util"), A = Q("assert").ok, M = Q("buffer").kMaxLength, x = "Cannot create final Buffer. It would be larger than 0x" + M.toString(16) + " bytes";
          Z.Z_MIN_WINDOWBITS = 8, Z.Z_MAX_WINDOWBITS = 15, Z.Z_DEFAULT_WINDOWBITS = 15, Z.Z_MIN_CHUNK = 64, Z.Z_MAX_CHUNK = 1 / 0, Z.Z_DEFAULT_CHUNK = 16 * 1024, Z.Z_MIN_MEMLEVEL = 1, Z.Z_MAX_MEMLEVEL = 9, Z.Z_DEFAULT_MEMLEVEL = 8, Z.Z_MIN_LEVEL = -1, Z.Z_MAX_LEVEL = 9, Z.Z_DEFAULT_LEVEL = Z.Z_DEFAULT_COMPRESSION;
          for (var m = Object.keys(Z), w = 0; w < m.length; w++) {
            var k = m[w];
            k.match(/^Z/) && Object.defineProperty(q, k, {
              enumerable: !0,
              value: Z[k],
              writable: !1
            });
          }
          for (var E = {
            Z_OK: Z.Z_OK,
            Z_STREAM_END: Z.Z_STREAM_END,
            Z_NEED_DICT: Z.Z_NEED_DICT,
            Z_ERRNO: Z.Z_ERRNO,
            Z_STREAM_ERROR: Z.Z_STREAM_ERROR,
            Z_DATA_ERROR: Z.Z_DATA_ERROR,
            Z_MEM_ERROR: Z.Z_MEM_ERROR,
            Z_BUF_ERROR: Z.Z_BUF_ERROR,
            Z_VERSION_ERROR: Z.Z_VERSION_ERROR
          }, P = Object.keys(E), S = 0; S < P.length; S++) {
            var U = P[S];
            E[E[U]] = U;
          }
          Object.defineProperty(q, "codes", {
            enumerable: !0,
            value: Object.freeze(E),
            writable: !1
          }), q.Deflate = W, q.Inflate = J, q.Gzip = ee, q.Gunzip = te, q.DeflateRaw = le, q.InflateRaw = me, q.Unzip = ke, q.createDeflate = function(we) {
            return new W(we);
          }, q.createInflate = function(we) {
            return new J(we);
          }, q.createDeflateRaw = function(we) {
            return new le(we);
          }, q.createInflateRaw = function(we) {
            return new me(we);
          }, q.createGzip = function(we) {
            return new ee(we);
          }, q.createGunzip = function(we) {
            return new te(we);
          }, q.createUnzip = function(we) {
            return new ke(we);
          }, q.deflate = function(we, Ce, it) {
            return typeof Ce == "function" && (it = Ce, Ce = {}), j(new W(Ce), we, it);
          }, q.deflateSync = function(we, Ce) {
            return T(new W(Ce), we);
          }, q.gzip = function(we, Ce, it) {
            return typeof Ce == "function" && (it = Ce, Ce = {}), j(new ee(Ce), we, it);
          }, q.gzipSync = function(we, Ce) {
            return T(new ee(Ce), we);
          }, q.deflateRaw = function(we, Ce, it) {
            return typeof Ce == "function" && (it = Ce, Ce = {}), j(new le(Ce), we, it);
          }, q.deflateRawSync = function(we, Ce) {
            return T(new le(Ce), we);
          }, q.unzip = function(we, Ce, it) {
            return typeof Ce == "function" && (it = Ce, Ce = {}), j(new ke(Ce), we, it);
          }, q.unzipSync = function(we, Ce) {
            return T(new ke(Ce), we);
          }, q.inflate = function(we, Ce, it) {
            return typeof Ce == "function" && (it = Ce, Ce = {}), j(new J(Ce), we, it);
          }, q.inflateSync = function(we, Ce) {
            return T(new J(Ce), we);
          }, q.gunzip = function(we, Ce, it) {
            return typeof Ce == "function" && (it = Ce, Ce = {}), j(new te(Ce), we, it);
          }, q.gunzipSync = function(we, Ce) {
            return T(new te(Ce), we);
          }, q.inflateRaw = function(we, Ce, it) {
            return typeof Ce == "function" && (it = Ce, Ce = {}), j(new me(Ce), we, it);
          }, q.inflateRawSync = function(we, Ce) {
            return T(new me(Ce), we);
          };
          function j(we, Ce, it) {
            var ut = [], bt = 0;
            we.on("error", Ke), we.on("end", dt), we.end(Ce), pt();
            function pt() {
              for (var ct; (ct = we.read()) !== null; )
                ut.push(ct), bt += ct.length;
              we.once("readable", pt);
            }
            function Ke(ct) {
              we.removeListener("end", dt), we.removeListener("readable", pt), it(ct);
            }
            function dt() {
              var ct, wt = null;
              bt >= M ? wt = new RangeError(x) : ct = i.concat(ut, bt), ut = [], we.close(), it(wt, ct);
            }
          }
          function T(we, Ce) {
            if (typeof Ce == "string" && (Ce = i.from(Ce)), !i.isBuffer(Ce)) throw new TypeError("Not a string or buffer");
            var it = we._finishFlushFlag;
            return we._processChunk(Ce, it);
          }
          function W(we) {
            if (!(this instanceof W)) return new W(we);
            Ve.call(this, we, Z.DEFLATE);
          }
          function J(we) {
            if (!(this instanceof J)) return new J(we);
            Ve.call(this, we, Z.INFLATE);
          }
          function ee(we) {
            if (!(this instanceof ee)) return new ee(we);
            Ve.call(this, we, Z.GZIP);
          }
          function te(we) {
            if (!(this instanceof te)) return new te(we);
            Ve.call(this, we, Z.GUNZIP);
          }
          function le(we) {
            if (!(this instanceof le)) return new le(we);
            Ve.call(this, we, Z.DEFLATERAW);
          }
          function me(we) {
            if (!(this instanceof me)) return new me(we);
            Ve.call(this, we, Z.INFLATERAW);
          }
          function ke(we) {
            if (!(this instanceof ke)) return new ke(we);
            Ve.call(this, we, Z.UNZIP);
          }
          function ge(we) {
            return we === Z.Z_NO_FLUSH || we === Z.Z_PARTIAL_FLUSH || we === Z.Z_SYNC_FLUSH || we === Z.Z_FULL_FLUSH || we === Z.Z_FINISH || we === Z.Z_BLOCK;
          }
          function Ve(we, Ce) {
            var it = this;
            if (this._opts = we = we || {}, this._chunkSize = we.chunkSize || q.Z_DEFAULT_CHUNK, N.call(this, we), we.flush && !ge(we.flush))
              throw new Error("Invalid flush flag: " + we.flush);
            if (we.finishFlush && !ge(we.finishFlush))
              throw new Error("Invalid flush flag: " + we.finishFlush);
            if (this._flushFlag = we.flush || Z.Z_NO_FLUSH, this._finishFlushFlag = typeof we.finishFlush < "u" ? we.finishFlush : Z.Z_FINISH, we.chunkSize && (we.chunkSize < q.Z_MIN_CHUNK || we.chunkSize > q.Z_MAX_CHUNK))
              throw new Error("Invalid chunk size: " + we.chunkSize);
            if (we.windowBits && (we.windowBits < q.Z_MIN_WINDOWBITS || we.windowBits > q.Z_MAX_WINDOWBITS))
              throw new Error("Invalid windowBits: " + we.windowBits);
            if (we.level && (we.level < q.Z_MIN_LEVEL || we.level > q.Z_MAX_LEVEL))
              throw new Error("Invalid compression level: " + we.level);
            if (we.memLevel && (we.memLevel < q.Z_MIN_MEMLEVEL || we.memLevel > q.Z_MAX_MEMLEVEL))
              throw new Error("Invalid memLevel: " + we.memLevel);
            if (we.strategy && we.strategy != q.Z_FILTERED && we.strategy != q.Z_HUFFMAN_ONLY && we.strategy != q.Z_RLE && we.strategy != q.Z_FIXED && we.strategy != q.Z_DEFAULT_STRATEGY)
              throw new Error("Invalid strategy: " + we.strategy);
            if (we.dictionary && !i.isBuffer(we.dictionary))
              throw new Error("Invalid dictionary: it should be a Buffer instance");
            this._handle = new Z.Zlib(Ce);
            var ut = this;
            this._hadError = !1, this._handle.onerror = function(Ke, dt) {
              Oe(ut), ut._hadError = !0;
              var ct = new Error(Ke);
              ct.errno = dt, ct.code = q.codes[dt], ut.emit("error", ct);
            };
            var bt = q.Z_DEFAULT_COMPRESSION;
            typeof we.level == "number" && (bt = we.level);
            var pt = q.Z_DEFAULT_STRATEGY;
            typeof we.strategy == "number" && (pt = we.strategy), this._handle.init(we.windowBits || q.Z_DEFAULT_WINDOWBITS, bt, we.memLevel || q.Z_DEFAULT_MEMLEVEL, pt, we.dictionary), this._buffer = i.allocUnsafe(this._chunkSize), this._offset = 0, this._level = bt, this._strategy = pt, this.once("end", this.close), Object.defineProperty(this, "_closed", {
              get: function() {
                return !it._handle;
              },
              configurable: !0,
              enumerable: !0
            });
          }
          R.inherits(Ve, N), Ve.prototype.params = function(we, Ce, it) {
            if (we < q.Z_MIN_LEVEL || we > q.Z_MAX_LEVEL)
              throw new RangeError("Invalid compression level: " + we);
            if (Ce != q.Z_FILTERED && Ce != q.Z_HUFFMAN_ONLY && Ce != q.Z_RLE && Ce != q.Z_FIXED && Ce != q.Z_DEFAULT_STRATEGY)
              throw new TypeError("Invalid strategy: " + Ce);
            if (this._level !== we || this._strategy !== Ce) {
              var ut = this;
              this.flush(Z.Z_SYNC_FLUSH, function() {
                A(ut._handle, "zlib binding closed"), ut._handle.params(we, Ce), ut._hadError || (ut._level = we, ut._strategy = Ce, it && it());
              });
            } else
              ie.nextTick(it);
          }, Ve.prototype.reset = function() {
            return A(this._handle, "zlib binding closed"), this._handle.reset();
          }, Ve.prototype._flush = function(we) {
            this._transform(i.alloc(0), "", we);
          }, Ve.prototype.flush = function(we, Ce) {
            var it = this, ut = this._writableState;
            (typeof we == "function" || we === void 0 && !Ce) && (Ce = we, we = Z.Z_FULL_FLUSH), ut.ended ? Ce && ie.nextTick(Ce) : ut.ending ? Ce && this.once("end", Ce) : ut.needDrain ? Ce && this.once("drain", function() {
              return it.flush(we, Ce);
            }) : (this._flushFlag = we, this.write(i.alloc(0), "", Ce));
          }, Ve.prototype.close = function(we) {
            Oe(this, we), ie.nextTick(Ue, this);
          };
          function Oe(we, Ce) {
            Ce && ie.nextTick(Ce), we._handle && (we._handle.close(), we._handle = null);
          }
          function Ue(we) {
            we.emit("close");
          }
          Ve.prototype._transform = function(we, Ce, it) {
            var ut, bt = this._writableState, pt = bt.ending || bt.ended, Ke = pt && (!we || bt.length === we.length);
            if (we !== null && !i.isBuffer(we)) return it(new Error("invalid input"));
            if (!this._handle) return it(new Error("zlib binding closed"));
            Ke ? ut = this._finishFlushFlag : (ut = this._flushFlag, we.length >= bt.length && (this._flushFlag = this._opts.flush || Z.Z_NO_FLUSH)), this._processChunk(we, ut, it);
          }, Ve.prototype._processChunk = function(we, Ce, it) {
            var ut = we && we.length, bt = this._chunkSize - this._offset, pt = 0, Ke = this, dt = typeof it == "function";
            if (!dt) {
              var ct = [], wt = 0, Ht;
              this.on("error", function(Qt) {
                Ht = Qt;
              }), A(this._handle, "zlib binding closed");
              do
                var $t = this._handle.writeSync(
                  Ce,
                  we,
                  // in
                  pt,
                  // in_off
                  ut,
                  // in_len
                  this._buffer,
                  // out
                  this._offset,
                  //out_off
                  bt
                );
              while (!this._hadError && wi($t[0], $t[1]));
              if (this._hadError)
                throw Ht;
              if (wt >= M)
                throw Oe(this), new RangeError(x);
              var rt = i.concat(ct, wt);
              return Oe(this), rt;
            }
            A(this._handle, "zlib binding closed");
            var ri = this._handle.write(
              Ce,
              we,
              // in
              pt,
              // in_off
              ut,
              // in_len
              this._buffer,
              // out
              this._offset,
              //out_off
              bt
            );
            ri.buffer = we, ri.callback = wi;
            function wi(Qt, At) {
              if (this && (this.buffer = null, this.callback = null), !Ke._hadError) {
                var St = bt - At;
                if (A(St >= 0, "have should not go down"), St > 0) {
                  var Lt = Ke._buffer.slice(Ke._offset, Ke._offset + St);
                  Ke._offset += St, dt ? Ke.push(Lt) : (ct.push(Lt), wt += Lt.length);
                }
                if ((At === 0 || Ke._offset >= Ke._chunkSize) && (bt = Ke._chunkSize, Ke._offset = 0, Ke._buffer = i.allocUnsafe(Ke._chunkSize)), At === 0) {
                  if (pt += ut - Qt, ut = Qt, !dt) return !0;
                  var kt = Ke._handle.write(Ce, we, pt, ut, Ke._buffer, Ke._offset, Ke._chunkSize);
                  kt.callback = wi, kt.buffer = we;
                  return;
                }
                if (!dt) return !1;
                it();
              }
            }
          }, R.inherits(W, Ve), R.inherits(J, Ve), R.inherits(ee, Ve), R.inherits(te, Ve), R.inherits(le, Ve), R.inherits(me, Ve), R.inherits(ke, Ve);
        }).call(this, Q("_process"));
      }, { "./binding": 34, _process: 133, assert: 25, buffer: 48, stream: 155, util: 186 }], 36: [function(Q, de, q) {
        var ie = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        function i(R, A) {
          return Object.prototype.hasOwnProperty.call(R, A);
        }
        q.assign = function(R) {
          for (var A = Array.prototype.slice.call(arguments, 1); A.length; ) {
            var M = A.shift();
            if (M) {
              if (typeof M != "object")
                throw new TypeError(M + "must be non-object");
              for (var x in M)
                i(M, x) && (R[x] = M[x]);
            }
          }
          return R;
        }, q.shrinkBuf = function(R, A) {
          return R.length === A ? R : R.subarray ? R.subarray(0, A) : (R.length = A, R);
        };
        var N = {
          arraySet: function(R, A, M, x, m) {
            if (A.subarray && R.subarray) {
              R.set(A.subarray(M, M + x), m);
              return;
            }
            for (var w = 0; w < x; w++)
              R[m + w] = A[M + w];
          },
          // Join array of chunks to single array.
          flattenChunks: function(R) {
            var A, M, x, m, w, k;
            for (x = 0, A = 0, M = R.length; A < M; A++)
              x += R[A].length;
            for (k = new Uint8Array(x), m = 0, A = 0, M = R.length; A < M; A++)
              w = R[A], k.set(w, m), m += w.length;
            return k;
          }
        }, Z = {
          arraySet: function(R, A, M, x, m) {
            for (var w = 0; w < x; w++)
              R[m + w] = A[M + w];
          },
          // Join array of chunks to single array.
          flattenChunks: function(R) {
            return [].concat.apply([], R);
          }
        };
        q.setTyped = function(R) {
          R ? (q.Buf8 = Uint8Array, q.Buf16 = Uint16Array, q.Buf32 = Int32Array, q.assign(q, N)) : (q.Buf8 = Array, q.Buf16 = Array, q.Buf32 = Array, q.assign(q, Z));
        }, q.setTyped(ie);
      }, {}], 37: [function(Q, de, q) {
        function ie(i, N, Z, R) {
          for (var A = i & 65535 | 0, M = i >>> 16 & 65535 | 0, x = 0; Z !== 0; ) {
            x = Z > 2e3 ? 2e3 : Z, Z -= x;
            do
              A = A + N[R++] | 0, M = M + A | 0;
            while (--x);
            A %= 65521, M %= 65521;
          }
          return A | M << 16 | 0;
        }
        de.exports = ie;
      }, {}], 38: [function(Q, de, q) {
        de.exports = {
          /* Allowed flush values; see deflate() and inflate() below for details */
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          /* Return codes for the compression/decompression functions. Negative values
          * are errors, positive values are used for special but normal events.
          */
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          //Z_MEM_ERROR:     -4,
          Z_BUF_ERROR: -5,
          //Z_VERSION_ERROR: -6,
          /* compression levels */
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          /* Possible values of the data_type field (though see inflate()) */
          Z_BINARY: 0,
          Z_TEXT: 1,
          //Z_ASCII:                1, // = Z_TEXT (deprecated)
          Z_UNKNOWN: 2,
          /* The deflate compression method */
          Z_DEFLATED: 8
          //Z_NULL:                 null // Use -1 or null inline, depending on var type
        };
      }, {}], 39: [function(Q, de, q) {
        function ie() {
          for (var Z, R = [], A = 0; A < 256; A++) {
            Z = A;
            for (var M = 0; M < 8; M++)
              Z = Z & 1 ? 3988292384 ^ Z >>> 1 : Z >>> 1;
            R[A] = Z;
          }
          return R;
        }
        var i = ie();
        function N(Z, R, A, M) {
          var x = i, m = M + A;
          Z ^= -1;
          for (var w = M; w < m; w++)
            Z = Z >>> 8 ^ x[(Z ^ R[w]) & 255];
          return Z ^ -1;
        }
        de.exports = N;
      }, {}], 40: [function(Q, de, q) {
        var ie = Q("../utils/common"), i = Q("./trees"), N = Q("./adler32"), Z = Q("./crc32"), R = Q("./messages"), A = 0, M = 1, x = 3, m = 4, w = 5, k = 0, E = 1, P = -2, S = -3, U = -5, j = -1, T = 1, W = 2, J = 3, ee = 4, te = 0, le = 2, me = 8, ke = 9, ge = 15, Ve = 8, Oe = 29, Ue = 256, we = Ue + 1 + Oe, Ce = 30, it = 19, ut = 2 * we + 1, bt = 15, pt = 3, Ke = 258, dt = Ke + pt + 1, ct = 32, wt = 42, Ht = 69, $t = 73, rt = 91, ri = 103, wi = 113, Qt = 666, At = 1, St = 2, Lt = 3, kt = 4, Ye = 3;
        function De(z, He) {
          return z.msg = R[He], He;
        }
        function Re(z) {
          return (z << 1) - (z > 4 ? 9 : 0);
        }
        function _t(z) {
          for (var He = z.length; --He >= 0; )
            z[He] = 0;
        }
        function et(z) {
          var He = z.state, nt = He.pending;
          nt > z.avail_out && (nt = z.avail_out), nt !== 0 && (ie.arraySet(z.output, He.pending_buf, He.pending_out, nt, z.next_out), z.next_out += nt, He.pending_out += nt, z.total_out += nt, z.avail_out -= nt, He.pending -= nt, He.pending === 0 && (He.pending_out = 0));
        }
        function Ie(z, He) {
          i._tr_flush_block(z, z.block_start >= 0 ? z.block_start : -1, z.strstart - z.block_start, He), z.block_start = z.strstart, et(z.strm);
        }
        function pe(z, He) {
          z.pending_buf[z.pending++] = He;
        }
        function xt(z, He) {
          z.pending_buf[z.pending++] = He >>> 8 & 255, z.pending_buf[z.pending++] = He & 255;
        }
        function l(z, He, nt, ae) {
          var $e = z.avail_in;
          return $e > ae && ($e = ae), $e === 0 ? 0 : (z.avail_in -= $e, ie.arraySet(He, z.input, z.next_in, $e, nt), z.state.wrap === 1 ? z.adler = N(z.adler, He, $e, nt) : z.state.wrap === 2 && (z.adler = Z(z.adler, He, $e, nt)), z.next_in += $e, z.total_in += $e, $e);
        }
        function _(z, He) {
          var nt = z.max_chain_length, ae = z.strstart, $e, Et, Nt = z.prev_length, Yt = z.nice_match, Ft = z.strstart > z.w_size - dt ? z.strstart - (z.w_size - dt) : 0, ai = z.window, Mt = z.w_mask, Ae = z.prev, Fe = z.strstart + Ke, tt = ai[ae + Nt - 1], Ct = ai[ae + Nt];
          z.prev_length >= z.good_match && (nt >>= 2), Yt > z.lookahead && (Yt = z.lookahead);
          do
            if ($e = He, !(ai[$e + Nt] !== Ct || ai[$e + Nt - 1] !== tt || ai[$e] !== ai[ae] || ai[++$e] !== ai[ae + 1])) {
              ae += 2, $e++;
              do
                ;
              while (ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ae < Fe);
              if (Et = Ke - (Fe - ae), ae = Fe - Ke, Et > Nt) {
                if (z.match_start = He, Nt = Et, Et >= Yt)
                  break;
                tt = ai[ae + Nt - 1], Ct = ai[ae + Nt];
              }
            }
          while ((He = Ae[He & Mt]) > Ft && --nt !== 0);
          return Nt <= z.lookahead ? Nt : z.lookahead;
        }
        function I(z) {
          var He = z.w_size, nt, ae, $e, Et, Nt;
          do {
            if (Et = z.window_size - z.lookahead - z.strstart, z.strstart >= He + (He - dt)) {
              ie.arraySet(z.window, z.window, He, He, 0), z.match_start -= He, z.strstart -= He, z.block_start -= He, ae = z.hash_size, nt = ae;
              do
                $e = z.head[--nt], z.head[nt] = $e >= He ? $e - He : 0;
              while (--ae);
              ae = He, nt = ae;
              do
                $e = z.prev[--nt], z.prev[nt] = $e >= He ? $e - He : 0;
              while (--ae);
              Et += He;
            }
            if (z.strm.avail_in === 0)
              break;
            if (ae = l(z.strm, z.window, z.strstart + z.lookahead, Et), z.lookahead += ae, z.lookahead + z.insert >= pt)
              for (Nt = z.strstart - z.insert, z.ins_h = z.window[Nt], z.ins_h = (z.ins_h << z.hash_shift ^ z.window[Nt + 1]) & z.hash_mask; z.insert && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[Nt + pt - 1]) & z.hash_mask, z.prev[Nt & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = Nt, Nt++, z.insert--, !(z.lookahead + z.insert < pt)); )
                ;
          } while (z.lookahead < dt && z.strm.avail_in !== 0);
        }
        function X(z, He) {
          var nt = 65535;
          for (nt > z.pending_buf_size - 5 && (nt = z.pending_buf_size - 5); ; ) {
            if (z.lookahead <= 1) {
              if (I(z), z.lookahead === 0 && He === A)
                return At;
              if (z.lookahead === 0)
                break;
            }
            z.strstart += z.lookahead, z.lookahead = 0;
            var ae = z.block_start + nt;
            if ((z.strstart === 0 || z.strstart >= ae) && (z.lookahead = z.strstart - ae, z.strstart = ae, Ie(z, !1), z.strm.avail_out === 0) || z.strstart - z.block_start >= z.w_size - dt && (Ie(z, !1), z.strm.avail_out === 0))
              return At;
          }
          return z.insert = 0, He === m ? (Ie(z, !0), z.strm.avail_out === 0 ? Lt : kt) : (z.strstart > z.block_start && (Ie(z, !1), z.strm.avail_out === 0), At);
        }
        function ne(z, He) {
          for (var nt, ae; ; ) {
            if (z.lookahead < dt) {
              if (I(z), z.lookahead < dt && He === A)
                return At;
              if (z.lookahead === 0)
                break;
            }
            if (nt = 0, z.lookahead >= pt && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + pt - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart), nt !== 0 && z.strstart - nt <= z.w_size - dt && (z.match_length = _(z, nt)), z.match_length >= pt)
              if (ae = i._tr_tally(z, z.strstart - z.match_start, z.match_length - pt), z.lookahead -= z.match_length, z.match_length <= z.max_lazy_match && z.lookahead >= pt) {
                z.match_length--;
                do
                  z.strstart++, z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + pt - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart;
                while (--z.match_length !== 0);
                z.strstart++;
              } else
                z.strstart += z.match_length, z.match_length = 0, z.ins_h = z.window[z.strstart], z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + 1]) & z.hash_mask;
            else
              ae = i._tr_tally(z, 0, z.window[z.strstart]), z.lookahead--, z.strstart++;
            if (ae && (Ie(z, !1), z.strm.avail_out === 0))
              return At;
          }
          return z.insert = z.strstart < pt - 1 ? z.strstart : pt - 1, He === m ? (Ie(z, !0), z.strm.avail_out === 0 ? Lt : kt) : z.last_lit && (Ie(z, !1), z.strm.avail_out === 0) ? At : St;
        }
        function ue(z, He) {
          for (var nt, ae, $e; ; ) {
            if (z.lookahead < dt) {
              if (I(z), z.lookahead < dt && He === A)
                return At;
              if (z.lookahead === 0)
                break;
            }
            if (nt = 0, z.lookahead >= pt && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + pt - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart), z.prev_length = z.match_length, z.prev_match = z.match_start, z.match_length = pt - 1, nt !== 0 && z.prev_length < z.max_lazy_match && z.strstart - nt <= z.w_size - dt && (z.match_length = _(z, nt), z.match_length <= 5 && (z.strategy === T || z.match_length === pt && z.strstart - z.match_start > 4096) && (z.match_length = pt - 1)), z.prev_length >= pt && z.match_length <= z.prev_length) {
              $e = z.strstart + z.lookahead - pt, ae = i._tr_tally(z, z.strstart - 1 - z.prev_match, z.prev_length - pt), z.lookahead -= z.prev_length - 1, z.prev_length -= 2;
              do
                ++z.strstart <= $e && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + pt - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart);
              while (--z.prev_length !== 0);
              if (z.match_available = 0, z.match_length = pt - 1, z.strstart++, ae && (Ie(z, !1), z.strm.avail_out === 0))
                return At;
            } else if (z.match_available) {
              if (ae = i._tr_tally(z, 0, z.window[z.strstart - 1]), ae && Ie(z, !1), z.strstart++, z.lookahead--, z.strm.avail_out === 0)
                return At;
            } else
              z.match_available = 1, z.strstart++, z.lookahead--;
          }
          return z.match_available && (ae = i._tr_tally(z, 0, z.window[z.strstart - 1]), z.match_available = 0), z.insert = z.strstart < pt - 1 ? z.strstart : pt - 1, He === m ? (Ie(z, !0), z.strm.avail_out === 0 ? Lt : kt) : z.last_lit && (Ie(z, !1), z.strm.avail_out === 0) ? At : St;
        }
        function Te(z, He) {
          for (var nt, ae, $e, Et, Nt = z.window; ; ) {
            if (z.lookahead <= Ke) {
              if (I(z), z.lookahead <= Ke && He === A)
                return At;
              if (z.lookahead === 0)
                break;
            }
            if (z.match_length = 0, z.lookahead >= pt && z.strstart > 0 && ($e = z.strstart - 1, ae = Nt[$e], ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e])) {
              Et = z.strstart + Ke;
              do
                ;
              while (ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && $e < Et);
              z.match_length = Ke - (Et - $e), z.match_length > z.lookahead && (z.match_length = z.lookahead);
            }
            if (z.match_length >= pt ? (nt = i._tr_tally(z, 1, z.match_length - pt), z.lookahead -= z.match_length, z.strstart += z.match_length, z.match_length = 0) : (nt = i._tr_tally(z, 0, z.window[z.strstart]), z.lookahead--, z.strstart++), nt && (Ie(z, !1), z.strm.avail_out === 0))
              return At;
          }
          return z.insert = 0, He === m ? (Ie(z, !0), z.strm.avail_out === 0 ? Lt : kt) : z.last_lit && (Ie(z, !1), z.strm.avail_out === 0) ? At : St;
        }
        function ye(z, He) {
          for (var nt; ; ) {
            if (z.lookahead === 0 && (I(z), z.lookahead === 0)) {
              if (He === A)
                return At;
              break;
            }
            if (z.match_length = 0, nt = i._tr_tally(z, 0, z.window[z.strstart]), z.lookahead--, z.strstart++, nt && (Ie(z, !1), z.strm.avail_out === 0))
              return At;
          }
          return z.insert = 0, He === m ? (Ie(z, !0), z.strm.avail_out === 0 ? Lt : kt) : z.last_lit && (Ie(z, !1), z.strm.avail_out === 0) ? At : St;
        }
        function Me(z, He, nt, ae, $e) {
          this.good_length = z, this.max_lazy = He, this.nice_length = nt, this.max_chain = ae, this.func = $e;
        }
        var Ge;
        Ge = [
          /*      good lazy nice chain */
          new Me(0, 0, 0, 0, X),
          /* 0 store only */
          new Me(4, 4, 8, 4, ne),
          /* 1 max speed, no lazy matches */
          new Me(4, 5, 16, 8, ne),
          /* 2 */
          new Me(4, 6, 32, 32, ne),
          /* 3 */
          new Me(4, 4, 16, 16, ue),
          /* 4 lazy matches */
          new Me(8, 16, 32, 32, ue),
          /* 5 */
          new Me(8, 16, 128, 128, ue),
          /* 6 */
          new Me(8, 32, 128, 256, ue),
          /* 7 */
          new Me(32, 128, 258, 1024, ue),
          /* 8 */
          new Me(32, 258, 258, 4096, ue)
          /* 9 max compression */
        ];
        function Qe(z) {
          z.window_size = 2 * z.w_size, _t(z.head), z.max_lazy_match = Ge[z.level].max_lazy, z.good_match = Ge[z.level].good_length, z.nice_match = Ge[z.level].nice_length, z.max_chain_length = Ge[z.level].max_chain, z.strstart = 0, z.block_start = 0, z.lookahead = 0, z.insert = 0, z.match_length = z.prev_length = pt - 1, z.match_available = 0, z.ins_h = 0;
        }
        function re() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = me, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new ie.Buf16(ut * 2), this.dyn_dtree = new ie.Buf16((2 * Ce + 1) * 2), this.bl_tree = new ie.Buf16((2 * it + 1) * 2), _t(this.dyn_ltree), _t(this.dyn_dtree), _t(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new ie.Buf16(bt + 1), this.heap = new ie.Buf16(2 * we + 1), _t(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new ie.Buf16(2 * we + 1), _t(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function Se(z) {
          var He;
          return !z || !z.state ? De(z, P) : (z.total_in = z.total_out = 0, z.data_type = le, He = z.state, He.pending = 0, He.pending_out = 0, He.wrap < 0 && (He.wrap = -He.wrap), He.status = He.wrap ? wt : wi, z.adler = He.wrap === 2 ? 0 : 1, He.last_flush = A, i._tr_init(He), k);
        }
        function Pe(z) {
          var He = Se(z);
          return He === k && Qe(z.state), He;
        }
        function at(z, He) {
          return !z || !z.state || z.state.wrap !== 2 ? P : (z.state.gzhead = He, k);
        }
        function Be(z, He, nt, ae, $e, Et) {
          if (!z)
            return P;
          var Nt = 1;
          if (He === j && (He = 6), ae < 0 ? (Nt = 0, ae = -ae) : ae > 15 && (Nt = 2, ae -= 16), $e < 1 || $e > ke || nt !== me || ae < 8 || ae > 15 || He < 0 || He > 9 || Et < 0 || Et > ee)
            return De(z, P);
          ae === 8 && (ae = 9);
          var Yt = new re();
          return z.state = Yt, Yt.strm = z, Yt.wrap = Nt, Yt.gzhead = null, Yt.w_bits = ae, Yt.w_size = 1 << Yt.w_bits, Yt.w_mask = Yt.w_size - 1, Yt.hash_bits = $e + 7, Yt.hash_size = 1 << Yt.hash_bits, Yt.hash_mask = Yt.hash_size - 1, Yt.hash_shift = ~~((Yt.hash_bits + pt - 1) / pt), Yt.window = new ie.Buf8(Yt.w_size * 2), Yt.head = new ie.Buf16(Yt.hash_size), Yt.prev = new ie.Buf16(Yt.w_size), Yt.lit_bufsize = 1 << $e + 6, Yt.pending_buf_size = Yt.lit_bufsize * 4, Yt.pending_buf = new ie.Buf8(Yt.pending_buf_size), Yt.d_buf = 1 * Yt.lit_bufsize, Yt.l_buf = 3 * Yt.lit_bufsize, Yt.level = He, Yt.strategy = Et, Yt.method = nt, Pe(z);
        }
        function Ze(z, He) {
          return Be(z, He, me, ge, Ve, te);
        }
        function fe(z, He) {
          var nt, ae, $e, Et;
          if (!z || !z.state || He > w || He < 0)
            return z ? De(z, P) : P;
          if (ae = z.state, !z.output || !z.input && z.avail_in !== 0 || ae.status === Qt && He !== m)
            return De(z, z.avail_out === 0 ? U : P);
          if (ae.strm = z, nt = ae.last_flush, ae.last_flush = He, ae.status === wt)
            if (ae.wrap === 2)
              z.adler = 0, pe(ae, 31), pe(ae, 139), pe(ae, 8), ae.gzhead ? (pe(
                ae,
                (ae.gzhead.text ? 1 : 0) + (ae.gzhead.hcrc ? 2 : 0) + (ae.gzhead.extra ? 4 : 0) + (ae.gzhead.name ? 8 : 0) + (ae.gzhead.comment ? 16 : 0)
              ), pe(ae, ae.gzhead.time & 255), pe(ae, ae.gzhead.time >> 8 & 255), pe(ae, ae.gzhead.time >> 16 & 255), pe(ae, ae.gzhead.time >> 24 & 255), pe(ae, ae.level === 9 ? 2 : ae.strategy >= W || ae.level < 2 ? 4 : 0), pe(ae, ae.gzhead.os & 255), ae.gzhead.extra && ae.gzhead.extra.length && (pe(ae, ae.gzhead.extra.length & 255), pe(ae, ae.gzhead.extra.length >> 8 & 255)), ae.gzhead.hcrc && (z.adler = Z(z.adler, ae.pending_buf, ae.pending, 0)), ae.gzindex = 0, ae.status = Ht) : (pe(ae, 0), pe(ae, 0), pe(ae, 0), pe(ae, 0), pe(ae, 0), pe(ae, ae.level === 9 ? 2 : ae.strategy >= W || ae.level < 2 ? 4 : 0), pe(ae, Ye), ae.status = wi);
            else {
              var Nt = me + (ae.w_bits - 8 << 4) << 8, Yt = -1;
              ae.strategy >= W || ae.level < 2 ? Yt = 0 : ae.level < 6 ? Yt = 1 : ae.level === 6 ? Yt = 2 : Yt = 3, Nt |= Yt << 6, ae.strstart !== 0 && (Nt |= ct), Nt += 31 - Nt % 31, ae.status = wi, xt(ae, Nt), ae.strstart !== 0 && (xt(ae, z.adler >>> 16), xt(ae, z.adler & 65535)), z.adler = 1;
            }
          if (ae.status === Ht)
            if (ae.gzhead.extra) {
              for ($e = ae.pending; ae.gzindex < (ae.gzhead.extra.length & 65535) && !(ae.pending === ae.pending_buf_size && (ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), et(z), $e = ae.pending, ae.pending === ae.pending_buf_size)); )
                pe(ae, ae.gzhead.extra[ae.gzindex] & 255), ae.gzindex++;
              ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), ae.gzindex === ae.gzhead.extra.length && (ae.gzindex = 0, ae.status = $t);
            } else
              ae.status = $t;
          if (ae.status === $t)
            if (ae.gzhead.name) {
              $e = ae.pending;
              do {
                if (ae.pending === ae.pending_buf_size && (ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), et(z), $e = ae.pending, ae.pending === ae.pending_buf_size)) {
                  Et = 1;
                  break;
                }
                ae.gzindex < ae.gzhead.name.length ? Et = ae.gzhead.name.charCodeAt(ae.gzindex++) & 255 : Et = 0, pe(ae, Et);
              } while (Et !== 0);
              ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), Et === 0 && (ae.gzindex = 0, ae.status = rt);
            } else
              ae.status = rt;
          if (ae.status === rt)
            if (ae.gzhead.comment) {
              $e = ae.pending;
              do {
                if (ae.pending === ae.pending_buf_size && (ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), et(z), $e = ae.pending, ae.pending === ae.pending_buf_size)) {
                  Et = 1;
                  break;
                }
                ae.gzindex < ae.gzhead.comment.length ? Et = ae.gzhead.comment.charCodeAt(ae.gzindex++) & 255 : Et = 0, pe(ae, Et);
              } while (Et !== 0);
              ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), Et === 0 && (ae.status = ri);
            } else
              ae.status = ri;
          if (ae.status === ri && (ae.gzhead.hcrc ? (ae.pending + 2 > ae.pending_buf_size && et(z), ae.pending + 2 <= ae.pending_buf_size && (pe(ae, z.adler & 255), pe(ae, z.adler >> 8 & 255), z.adler = 0, ae.status = wi)) : ae.status = wi), ae.pending !== 0) {
            if (et(z), z.avail_out === 0)
              return ae.last_flush = -1, k;
          } else if (z.avail_in === 0 && Re(He) <= Re(nt) && He !== m)
            return De(z, U);
          if (ae.status === Qt && z.avail_in !== 0)
            return De(z, U);
          if (z.avail_in !== 0 || ae.lookahead !== 0 || He !== A && ae.status !== Qt) {
            var Ft = ae.strategy === W ? ye(ae, He) : ae.strategy === J ? Te(ae, He) : Ge[ae.level].func(ae, He);
            if ((Ft === Lt || Ft === kt) && (ae.status = Qt), Ft === At || Ft === Lt)
              return z.avail_out === 0 && (ae.last_flush = -1), k;
            if (Ft === St && (He === M ? i._tr_align(ae) : He !== w && (i._tr_stored_block(ae, 0, 0, !1), He === x && (_t(ae.head), ae.lookahead === 0 && (ae.strstart = 0, ae.block_start = 0, ae.insert = 0))), et(z), z.avail_out === 0))
              return ae.last_flush = -1, k;
          }
          return He !== m ? k : ae.wrap <= 0 ? E : (ae.wrap === 2 ? (pe(ae, z.adler & 255), pe(ae, z.adler >> 8 & 255), pe(ae, z.adler >> 16 & 255), pe(ae, z.adler >> 24 & 255), pe(ae, z.total_in & 255), pe(ae, z.total_in >> 8 & 255), pe(ae, z.total_in >> 16 & 255), pe(ae, z.total_in >> 24 & 255)) : (xt(ae, z.adler >>> 16), xt(ae, z.adler & 65535)), et(z), ae.wrap > 0 && (ae.wrap = -ae.wrap), ae.pending !== 0 ? k : E);
        }
        function Je(z) {
          var He;
          return !z || !z.state ? P : (He = z.state.status, He !== wt && He !== Ht && He !== $t && He !== rt && He !== ri && He !== wi && He !== Qt ? De(z, P) : (z.state = null, He === wi ? De(z, S) : k));
        }
        function Xe(z, He) {
          var nt = He.length, ae, $e, Et, Nt, Yt, Ft, ai, Mt;
          if (!z || !z.state || (ae = z.state, Nt = ae.wrap, Nt === 2 || Nt === 1 && ae.status !== wt || ae.lookahead))
            return P;
          for (Nt === 1 && (z.adler = N(z.adler, He, nt, 0)), ae.wrap = 0, nt >= ae.w_size && (Nt === 0 && (_t(ae.head), ae.strstart = 0, ae.block_start = 0, ae.insert = 0), Mt = new ie.Buf8(ae.w_size), ie.arraySet(Mt, He, nt - ae.w_size, ae.w_size, 0), He = Mt, nt = ae.w_size), Yt = z.avail_in, Ft = z.next_in, ai = z.input, z.avail_in = nt, z.next_in = 0, z.input = He, I(ae); ae.lookahead >= pt; ) {
            $e = ae.strstart, Et = ae.lookahead - (pt - 1);
            do
              ae.ins_h = (ae.ins_h << ae.hash_shift ^ ae.window[$e + pt - 1]) & ae.hash_mask, ae.prev[$e & ae.w_mask] = ae.head[ae.ins_h], ae.head[ae.ins_h] = $e, $e++;
            while (--Et);
            ae.strstart = $e, ae.lookahead = pt - 1, I(ae);
          }
          return ae.strstart += ae.lookahead, ae.block_start = ae.strstart, ae.insert = ae.lookahead, ae.lookahead = 0, ae.match_length = ae.prev_length = pt - 1, ae.match_available = 0, z.next_in = Ft, z.input = ai, z.avail_in = Yt, ae.wrap = Nt, k;
        }
        q.deflateInit = Ze, q.deflateInit2 = Be, q.deflateReset = Pe, q.deflateResetKeep = Se, q.deflateSetHeader = at, q.deflate = fe, q.deflateEnd = Je, q.deflateSetDictionary = Xe, q.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 36, "./adler32": 37, "./crc32": 39, "./messages": 44, "./trees": 45 }], 41: [function(Q, de, q) {
        var ie = 30, i = 12;
        de.exports = function(Z, R) {
          var A, M, x, m, w, k, E, P, S, U, j, T, W, J, ee, te, le, me, ke, ge, Ve, Oe, Ue, we, Ce;
          A = Z.state, M = Z.next_in, we = Z.input, x = M + (Z.avail_in - 5), m = Z.next_out, Ce = Z.output, w = m - (R - Z.avail_out), k = m + (Z.avail_out - 257), E = A.dmax, P = A.wsize, S = A.whave, U = A.wnext, j = A.window, T = A.hold, W = A.bits, J = A.lencode, ee = A.distcode, te = (1 << A.lenbits) - 1, le = (1 << A.distbits) - 1;
          e:
            do {
              W < 15 && (T += we[M++] << W, W += 8, T += we[M++] << W, W += 8), me = J[T & te];
              t:
                for (; ; ) {
                  if (ke = me >>> 24, T >>>= ke, W -= ke, ke = me >>> 16 & 255, ke === 0)
                    Ce[m++] = me & 65535;
                  else if (ke & 16) {
                    ge = me & 65535, ke &= 15, ke && (W < ke && (T += we[M++] << W, W += 8), ge += T & (1 << ke) - 1, T >>>= ke, W -= ke), W < 15 && (T += we[M++] << W, W += 8, T += we[M++] << W, W += 8), me = ee[T & le];
                    i:
                      for (; ; ) {
                        if (ke = me >>> 24, T >>>= ke, W -= ke, ke = me >>> 16 & 255, ke & 16) {
                          if (Ve = me & 65535, ke &= 15, W < ke && (T += we[M++] << W, W += 8, W < ke && (T += we[M++] << W, W += 8)), Ve += T & (1 << ke) - 1, Ve > E) {
                            Z.msg = "invalid distance too far back", A.mode = ie;
                            break e;
                          }
                          if (T >>>= ke, W -= ke, ke = m - w, Ve > ke) {
                            if (ke = Ve - ke, ke > S && A.sane) {
                              Z.msg = "invalid distance too far back", A.mode = ie;
                              break e;
                            }
                            if (Oe = 0, Ue = j, U === 0) {
                              if (Oe += P - ke, ke < ge) {
                                ge -= ke;
                                do
                                  Ce[m++] = j[Oe++];
                                while (--ke);
                                Oe = m - Ve, Ue = Ce;
                              }
                            } else if (U < ke) {
                              if (Oe += P + U - ke, ke -= U, ke < ge) {
                                ge -= ke;
                                do
                                  Ce[m++] = j[Oe++];
                                while (--ke);
                                if (Oe = 0, U < ge) {
                                  ke = U, ge -= ke;
                                  do
                                    Ce[m++] = j[Oe++];
                                  while (--ke);
                                  Oe = m - Ve, Ue = Ce;
                                }
                              }
                            } else if (Oe += U - ke, ke < ge) {
                              ge -= ke;
                              do
                                Ce[m++] = j[Oe++];
                              while (--ke);
                              Oe = m - Ve, Ue = Ce;
                            }
                            for (; ge > 2; )
                              Ce[m++] = Ue[Oe++], Ce[m++] = Ue[Oe++], Ce[m++] = Ue[Oe++], ge -= 3;
                            ge && (Ce[m++] = Ue[Oe++], ge > 1 && (Ce[m++] = Ue[Oe++]));
                          } else {
                            Oe = m - Ve;
                            do
                              Ce[m++] = Ce[Oe++], Ce[m++] = Ce[Oe++], Ce[m++] = Ce[Oe++], ge -= 3;
                            while (ge > 2);
                            ge && (Ce[m++] = Ce[Oe++], ge > 1 && (Ce[m++] = Ce[Oe++]));
                          }
                        } else if (ke & 64) {
                          Z.msg = "invalid distance code", A.mode = ie;
                          break e;
                        } else {
                          me = ee[(me & 65535) + (T & (1 << ke) - 1)];
                          continue i;
                        }
                        break;
                      }
                  } else if (ke & 64)
                    if (ke & 32) {
                      A.mode = i;
                      break e;
                    } else {
                      Z.msg = "invalid literal/length code", A.mode = ie;
                      break e;
                    }
                  else {
                    me = J[(me & 65535) + (T & (1 << ke) - 1)];
                    continue t;
                  }
                  break;
                }
            } while (M < x && m < k);
          ge = W >> 3, M -= ge, W -= ge << 3, T &= (1 << W) - 1, Z.next_in = M, Z.next_out = m, Z.avail_in = M < x ? 5 + (x - M) : 5 - (M - x), Z.avail_out = m < k ? 257 + (k - m) : 257 - (m - k), A.hold = T, A.bits = W;
        };
      }, {}], 42: [function(Q, de, q) {
        var ie = Q("../utils/common"), i = Q("./adler32"), N = Q("./crc32"), Z = Q("./inffast"), R = Q("./inftrees"), A = 0, M = 1, x = 2, m = 4, w = 5, k = 6, E = 0, P = 1, S = 2, U = -2, j = -3, T = -4, W = -5, J = 8, ee = 1, te = 2, le = 3, me = 4, ke = 5, ge = 6, Ve = 7, Oe = 8, Ue = 9, we = 10, Ce = 11, it = 12, ut = 13, bt = 14, pt = 15, Ke = 16, dt = 17, ct = 18, wt = 19, Ht = 20, $t = 21, rt = 22, ri = 23, wi = 24, Qt = 25, At = 26, St = 27, Lt = 28, kt = 29, Ye = 30, De = 31, Re = 32, _t = 852, et = 592, Ie = 15, pe = Ie;
        function xt(Be) {
          return (Be >>> 24 & 255) + (Be >>> 8 & 65280) + ((Be & 65280) << 8) + ((Be & 255) << 24);
        }
        function l() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new ie.Buf16(320), this.work = new ie.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function _(Be) {
          var Ze;
          return !Be || !Be.state ? U : (Ze = Be.state, Be.total_in = Be.total_out = Ze.total = 0, Be.msg = "", Ze.wrap && (Be.adler = Ze.wrap & 1), Ze.mode = ee, Ze.last = 0, Ze.havedict = 0, Ze.dmax = 32768, Ze.head = null, Ze.hold = 0, Ze.bits = 0, Ze.lencode = Ze.lendyn = new ie.Buf32(_t), Ze.distcode = Ze.distdyn = new ie.Buf32(et), Ze.sane = 1, Ze.back = -1, E);
        }
        function I(Be) {
          var Ze;
          return !Be || !Be.state ? U : (Ze = Be.state, Ze.wsize = 0, Ze.whave = 0, Ze.wnext = 0, _(Be));
        }
        function X(Be, Ze) {
          var fe, Je;
          return !Be || !Be.state || (Je = Be.state, Ze < 0 ? (fe = 0, Ze = -Ze) : (fe = (Ze >> 4) + 1, Ze < 48 && (Ze &= 15)), Ze && (Ze < 8 || Ze > 15)) ? U : (Je.window !== null && Je.wbits !== Ze && (Je.window = null), Je.wrap = fe, Je.wbits = Ze, I(Be));
        }
        function ne(Be, Ze) {
          var fe, Je;
          return Be ? (Je = new l(), Be.state = Je, Je.window = null, fe = X(Be, Ze), fe !== E && (Be.state = null), fe) : U;
        }
        function ue(Be) {
          return ne(Be, pe);
        }
        var Te = !0, ye, Me;
        function Ge(Be) {
          if (Te) {
            var Ze;
            for (ye = new ie.Buf32(512), Me = new ie.Buf32(32), Ze = 0; Ze < 144; )
              Be.lens[Ze++] = 8;
            for (; Ze < 256; )
              Be.lens[Ze++] = 9;
            for (; Ze < 280; )
              Be.lens[Ze++] = 7;
            for (; Ze < 288; )
              Be.lens[Ze++] = 8;
            for (R(M, Be.lens, 0, 288, ye, 0, Be.work, { bits: 9 }), Ze = 0; Ze < 32; )
              Be.lens[Ze++] = 5;
            R(x, Be.lens, 0, 32, Me, 0, Be.work, { bits: 5 }), Te = !1;
          }
          Be.lencode = ye, Be.lenbits = 9, Be.distcode = Me, Be.distbits = 5;
        }
        function Qe(Be, Ze, fe, Je) {
          var Xe, z = Be.state;
          return z.window === null && (z.wsize = 1 << z.wbits, z.wnext = 0, z.whave = 0, z.window = new ie.Buf8(z.wsize)), Je >= z.wsize ? (ie.arraySet(z.window, Ze, fe - z.wsize, z.wsize, 0), z.wnext = 0, z.whave = z.wsize) : (Xe = z.wsize - z.wnext, Xe > Je && (Xe = Je), ie.arraySet(z.window, Ze, fe - Je, Xe, z.wnext), Je -= Xe, Je ? (ie.arraySet(z.window, Ze, fe - Je, Je, 0), z.wnext = Je, z.whave = z.wsize) : (z.wnext += Xe, z.wnext === z.wsize && (z.wnext = 0), z.whave < z.wsize && (z.whave += Xe))), 0;
        }
        function re(Be, Ze) {
          var fe, Je, Xe, z, He, nt, ae, $e, Et, Nt, Yt, Ft, ai, Mt, Ae = 0, Fe, tt, Ct, It, Ut, ti, Pt, Wt, ei = new ie.Buf8(4), oi, _i, Di = (
            /* permutation of code lengths */
            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
          );
          if (!Be || !Be.state || !Be.output || !Be.input && Be.avail_in !== 0)
            return U;
          fe = Be.state, fe.mode === it && (fe.mode = ut), He = Be.next_out, Xe = Be.output, ae = Be.avail_out, z = Be.next_in, Je = Be.input, nt = Be.avail_in, $e = fe.hold, Et = fe.bits, Nt = nt, Yt = ae, Wt = E;
          e:
            for (; ; )
              switch (fe.mode) {
                case ee:
                  if (fe.wrap === 0) {
                    fe.mode = ut;
                    break;
                  }
                  for (; Et < 16; ) {
                    if (nt === 0)
                      break e;
                    nt--, $e += Je[z++] << Et, Et += 8;
                  }
                  if (fe.wrap & 2 && $e === 35615) {
                    fe.check = 0, ei[0] = $e & 255, ei[1] = $e >>> 8 & 255, fe.check = N(fe.check, ei, 2, 0), $e = 0, Et = 0, fe.mode = te;
                    break;
                  }
                  if (fe.flags = 0, fe.head && (fe.head.done = !1), !(fe.wrap & 1) || /* check if zlib header allowed */
                  ((($e & 255) << 8) + ($e >> 8)) % 31) {
                    Be.msg = "incorrect header check", fe.mode = Ye;
                    break;
                  }
                  if (($e & 15) !== J) {
                    Be.msg = "unknown compression method", fe.mode = Ye;
                    break;
                  }
                  if ($e >>>= 4, Et -= 4, Pt = ($e & 15) + 8, fe.wbits === 0)
                    fe.wbits = Pt;
                  else if (Pt > fe.wbits) {
                    Be.msg = "invalid window size", fe.mode = Ye;
                    break;
                  }
                  fe.dmax = 1 << Pt, Be.adler = fe.check = 1, fe.mode = $e & 512 ? we : it, $e = 0, Et = 0;
                  break;
                case te:
                  for (; Et < 16; ) {
                    if (nt === 0)
                      break e;
                    nt--, $e += Je[z++] << Et, Et += 8;
                  }
                  if (fe.flags = $e, (fe.flags & 255) !== J) {
                    Be.msg = "unknown compression method", fe.mode = Ye;
                    break;
                  }
                  if (fe.flags & 57344) {
                    Be.msg = "unknown header flags set", fe.mode = Ye;
                    break;
                  }
                  fe.head && (fe.head.text = $e >> 8 & 1), fe.flags & 512 && (ei[0] = $e & 255, ei[1] = $e >>> 8 & 255, fe.check = N(fe.check, ei, 2, 0)), $e = 0, Et = 0, fe.mode = le;
                /* falls through */
                case le:
                  for (; Et < 32; ) {
                    if (nt === 0)
                      break e;
                    nt--, $e += Je[z++] << Et, Et += 8;
                  }
                  fe.head && (fe.head.time = $e), fe.flags & 512 && (ei[0] = $e & 255, ei[1] = $e >>> 8 & 255, ei[2] = $e >>> 16 & 255, ei[3] = $e >>> 24 & 255, fe.check = N(fe.check, ei, 4, 0)), $e = 0, Et = 0, fe.mode = me;
                /* falls through */
                case me:
                  for (; Et < 16; ) {
                    if (nt === 0)
                      break e;
                    nt--, $e += Je[z++] << Et, Et += 8;
                  }
                  fe.head && (fe.head.xflags = $e & 255, fe.head.os = $e >> 8), fe.flags & 512 && (ei[0] = $e & 255, ei[1] = $e >>> 8 & 255, fe.check = N(fe.check, ei, 2, 0)), $e = 0, Et = 0, fe.mode = ke;
                /* falls through */
                case ke:
                  if (fe.flags & 1024) {
                    for (; Et < 16; ) {
                      if (nt === 0)
                        break e;
                      nt--, $e += Je[z++] << Et, Et += 8;
                    }
                    fe.length = $e, fe.head && (fe.head.extra_len = $e), fe.flags & 512 && (ei[0] = $e & 255, ei[1] = $e >>> 8 & 255, fe.check = N(fe.check, ei, 2, 0)), $e = 0, Et = 0;
                  } else fe.head && (fe.head.extra = null);
                  fe.mode = ge;
                /* falls through */
                case ge:
                  if (fe.flags & 1024 && (Ft = fe.length, Ft > nt && (Ft = nt), Ft && (fe.head && (Pt = fe.head.extra_len - fe.length, fe.head.extra || (fe.head.extra = new Array(fe.head.extra_len)), ie.arraySet(
                    fe.head.extra,
                    Je,
                    z,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    Ft,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    Pt
                  )), fe.flags & 512 && (fe.check = N(fe.check, Je, Ft, z)), nt -= Ft, z += Ft, fe.length -= Ft), fe.length))
                    break e;
                  fe.length = 0, fe.mode = Ve;
                /* falls through */
                case Ve:
                  if (fe.flags & 2048) {
                    if (nt === 0)
                      break e;
                    Ft = 0;
                    do
                      Pt = Je[z + Ft++], fe.head && Pt && fe.length < 65536 && (fe.head.name += String.fromCharCode(Pt));
                    while (Pt && Ft < nt);
                    if (fe.flags & 512 && (fe.check = N(fe.check, Je, Ft, z)), nt -= Ft, z += Ft, Pt)
                      break e;
                  } else fe.head && (fe.head.name = null);
                  fe.length = 0, fe.mode = Oe;
                /* falls through */
                case Oe:
                  if (fe.flags & 4096) {
                    if (nt === 0)
                      break e;
                    Ft = 0;
                    do
                      Pt = Je[z + Ft++], fe.head && Pt && fe.length < 65536 && (fe.head.comment += String.fromCharCode(Pt));
                    while (Pt && Ft < nt);
                    if (fe.flags & 512 && (fe.check = N(fe.check, Je, Ft, z)), nt -= Ft, z += Ft, Pt)
                      break e;
                  } else fe.head && (fe.head.comment = null);
                  fe.mode = Ue;
                /* falls through */
                case Ue:
                  if (fe.flags & 512) {
                    for (; Et < 16; ) {
                      if (nt === 0)
                        break e;
                      nt--, $e += Je[z++] << Et, Et += 8;
                    }
                    if ($e !== (fe.check & 65535)) {
                      Be.msg = "header crc mismatch", fe.mode = Ye;
                      break;
                    }
                    $e = 0, Et = 0;
                  }
                  fe.head && (fe.head.hcrc = fe.flags >> 9 & 1, fe.head.done = !0), Be.adler = fe.check = 0, fe.mode = it;
                  break;
                case we:
                  for (; Et < 32; ) {
                    if (nt === 0)
                      break e;
                    nt--, $e += Je[z++] << Et, Et += 8;
                  }
                  Be.adler = fe.check = xt($e), $e = 0, Et = 0, fe.mode = Ce;
                /* falls through */
                case Ce:
                  if (fe.havedict === 0)
                    return Be.next_out = He, Be.avail_out = ae, Be.next_in = z, Be.avail_in = nt, fe.hold = $e, fe.bits = Et, S;
                  Be.adler = fe.check = 1, fe.mode = it;
                /* falls through */
                case it:
                  if (Ze === w || Ze === k)
                    break e;
                /* falls through */
                case ut:
                  if (fe.last) {
                    $e >>>= Et & 7, Et -= Et & 7, fe.mode = St;
                    break;
                  }
                  for (; Et < 3; ) {
                    if (nt === 0)
                      break e;
                    nt--, $e += Je[z++] << Et, Et += 8;
                  }
                  switch (fe.last = $e & 1, $e >>>= 1, Et -= 1, $e & 3) {
                    case 0:
                      fe.mode = bt;
                      break;
                    case 1:
                      if (Ge(fe), fe.mode = Ht, Ze === k) {
                        $e >>>= 2, Et -= 2;
                        break e;
                      }
                      break;
                    case 2:
                      fe.mode = dt;
                      break;
                    case 3:
                      Be.msg = "invalid block type", fe.mode = Ye;
                  }
                  $e >>>= 2, Et -= 2;
                  break;
                case bt:
                  for ($e >>>= Et & 7, Et -= Et & 7; Et < 32; ) {
                    if (nt === 0)
                      break e;
                    nt--, $e += Je[z++] << Et, Et += 8;
                  }
                  if (($e & 65535) !== ($e >>> 16 ^ 65535)) {
                    Be.msg = "invalid stored block lengths", fe.mode = Ye;
                    break;
                  }
                  if (fe.length = $e & 65535, $e = 0, Et = 0, fe.mode = pt, Ze === k)
                    break e;
                /* falls through */
                case pt:
                  fe.mode = Ke;
                /* falls through */
                case Ke:
                  if (Ft = fe.length, Ft) {
                    if (Ft > nt && (Ft = nt), Ft > ae && (Ft = ae), Ft === 0)
                      break e;
                    ie.arraySet(Xe, Je, z, Ft, He), nt -= Ft, z += Ft, ae -= Ft, He += Ft, fe.length -= Ft;
                    break;
                  }
                  fe.mode = it;
                  break;
                case dt:
                  for (; Et < 14; ) {
                    if (nt === 0)
                      break e;
                    nt--, $e += Je[z++] << Et, Et += 8;
                  }
                  if (fe.nlen = ($e & 31) + 257, $e >>>= 5, Et -= 5, fe.ndist = ($e & 31) + 1, $e >>>= 5, Et -= 5, fe.ncode = ($e & 15) + 4, $e >>>= 4, Et -= 4, fe.nlen > 286 || fe.ndist > 30) {
                    Be.msg = "too many length or distance symbols", fe.mode = Ye;
                    break;
                  }
                  fe.have = 0, fe.mode = ct;
                /* falls through */
                case ct:
                  for (; fe.have < fe.ncode; ) {
                    for (; Et < 3; ) {
                      if (nt === 0)
                        break e;
                      nt--, $e += Je[z++] << Et, Et += 8;
                    }
                    fe.lens[Di[fe.have++]] = $e & 7, $e >>>= 3, Et -= 3;
                  }
                  for (; fe.have < 19; )
                    fe.lens[Di[fe.have++]] = 0;
                  if (fe.lencode = fe.lendyn, fe.lenbits = 7, oi = { bits: fe.lenbits }, Wt = R(A, fe.lens, 0, 19, fe.lencode, 0, fe.work, oi), fe.lenbits = oi.bits, Wt) {
                    Be.msg = "invalid code lengths set", fe.mode = Ye;
                    break;
                  }
                  fe.have = 0, fe.mode = wt;
                /* falls through */
                case wt:
                  for (; fe.have < fe.nlen + fe.ndist; ) {
                    for (; Ae = fe.lencode[$e & (1 << fe.lenbits) - 1], Fe = Ae >>> 24, tt = Ae >>> 16 & 255, Ct = Ae & 65535, !(Fe <= Et); ) {
                      if (nt === 0)
                        break e;
                      nt--, $e += Je[z++] << Et, Et += 8;
                    }
                    if (Ct < 16)
                      $e >>>= Fe, Et -= Fe, fe.lens[fe.have++] = Ct;
                    else {
                      if (Ct === 16) {
                        for (_i = Fe + 2; Et < _i; ) {
                          if (nt === 0)
                            break e;
                          nt--, $e += Je[z++] << Et, Et += 8;
                        }
                        if ($e >>>= Fe, Et -= Fe, fe.have === 0) {
                          Be.msg = "invalid bit length repeat", fe.mode = Ye;
                          break;
                        }
                        Pt = fe.lens[fe.have - 1], Ft = 3 + ($e & 3), $e >>>= 2, Et -= 2;
                      } else if (Ct === 17) {
                        for (_i = Fe + 3; Et < _i; ) {
                          if (nt === 0)
                            break e;
                          nt--, $e += Je[z++] << Et, Et += 8;
                        }
                        $e >>>= Fe, Et -= Fe, Pt = 0, Ft = 3 + ($e & 7), $e >>>= 3, Et -= 3;
                      } else {
                        for (_i = Fe + 7; Et < _i; ) {
                          if (nt === 0)
                            break e;
                          nt--, $e += Je[z++] << Et, Et += 8;
                        }
                        $e >>>= Fe, Et -= Fe, Pt = 0, Ft = 11 + ($e & 127), $e >>>= 7, Et -= 7;
                      }
                      if (fe.have + Ft > fe.nlen + fe.ndist) {
                        Be.msg = "invalid bit length repeat", fe.mode = Ye;
                        break;
                      }
                      for (; Ft--; )
                        fe.lens[fe.have++] = Pt;
                    }
                  }
                  if (fe.mode === Ye)
                    break;
                  if (fe.lens[256] === 0) {
                    Be.msg = "invalid code -- missing end-of-block", fe.mode = Ye;
                    break;
                  }
                  if (fe.lenbits = 9, oi = { bits: fe.lenbits }, Wt = R(M, fe.lens, 0, fe.nlen, fe.lencode, 0, fe.work, oi), fe.lenbits = oi.bits, Wt) {
                    Be.msg = "invalid literal/lengths set", fe.mode = Ye;
                    break;
                  }
                  if (fe.distbits = 6, fe.distcode = fe.distdyn, oi = { bits: fe.distbits }, Wt = R(x, fe.lens, fe.nlen, fe.ndist, fe.distcode, 0, fe.work, oi), fe.distbits = oi.bits, Wt) {
                    Be.msg = "invalid distances set", fe.mode = Ye;
                    break;
                  }
                  if (fe.mode = Ht, Ze === k)
                    break e;
                /* falls through */
                case Ht:
                  fe.mode = $t;
                /* falls through */
                case $t:
                  if (nt >= 6 && ae >= 258) {
                    Be.next_out = He, Be.avail_out = ae, Be.next_in = z, Be.avail_in = nt, fe.hold = $e, fe.bits = Et, Z(Be, Yt), He = Be.next_out, Xe = Be.output, ae = Be.avail_out, z = Be.next_in, Je = Be.input, nt = Be.avail_in, $e = fe.hold, Et = fe.bits, fe.mode === it && (fe.back = -1);
                    break;
                  }
                  for (fe.back = 0; Ae = fe.lencode[$e & (1 << fe.lenbits) - 1], Fe = Ae >>> 24, tt = Ae >>> 16 & 255, Ct = Ae & 65535, !(Fe <= Et); ) {
                    if (nt === 0)
                      break e;
                    nt--, $e += Je[z++] << Et, Et += 8;
                  }
                  if (tt && !(tt & 240)) {
                    for (It = Fe, Ut = tt, ti = Ct; Ae = fe.lencode[ti + (($e & (1 << It + Ut) - 1) >> It)], Fe = Ae >>> 24, tt = Ae >>> 16 & 255, Ct = Ae & 65535, !(It + Fe <= Et); ) {
                      if (nt === 0)
                        break e;
                      nt--, $e += Je[z++] << Et, Et += 8;
                    }
                    $e >>>= It, Et -= It, fe.back += It;
                  }
                  if ($e >>>= Fe, Et -= Fe, fe.back += Fe, fe.length = Ct, tt === 0) {
                    fe.mode = At;
                    break;
                  }
                  if (tt & 32) {
                    fe.back = -1, fe.mode = it;
                    break;
                  }
                  if (tt & 64) {
                    Be.msg = "invalid literal/length code", fe.mode = Ye;
                    break;
                  }
                  fe.extra = tt & 15, fe.mode = rt;
                /* falls through */
                case rt:
                  if (fe.extra) {
                    for (_i = fe.extra; Et < _i; ) {
                      if (nt === 0)
                        break e;
                      nt--, $e += Je[z++] << Et, Et += 8;
                    }
                    fe.length += $e & (1 << fe.extra) - 1, $e >>>= fe.extra, Et -= fe.extra, fe.back += fe.extra;
                  }
                  fe.was = fe.length, fe.mode = ri;
                /* falls through */
                case ri:
                  for (; Ae = fe.distcode[$e & (1 << fe.distbits) - 1], Fe = Ae >>> 24, tt = Ae >>> 16 & 255, Ct = Ae & 65535, !(Fe <= Et); ) {
                    if (nt === 0)
                      break e;
                    nt--, $e += Je[z++] << Et, Et += 8;
                  }
                  if (!(tt & 240)) {
                    for (It = Fe, Ut = tt, ti = Ct; Ae = fe.distcode[ti + (($e & (1 << It + Ut) - 1) >> It)], Fe = Ae >>> 24, tt = Ae >>> 16 & 255, Ct = Ae & 65535, !(It + Fe <= Et); ) {
                      if (nt === 0)
                        break e;
                      nt--, $e += Je[z++] << Et, Et += 8;
                    }
                    $e >>>= It, Et -= It, fe.back += It;
                  }
                  if ($e >>>= Fe, Et -= Fe, fe.back += Fe, tt & 64) {
                    Be.msg = "invalid distance code", fe.mode = Ye;
                    break;
                  }
                  fe.offset = Ct, fe.extra = tt & 15, fe.mode = wi;
                /* falls through */
                case wi:
                  if (fe.extra) {
                    for (_i = fe.extra; Et < _i; ) {
                      if (nt === 0)
                        break e;
                      nt--, $e += Je[z++] << Et, Et += 8;
                    }
                    fe.offset += $e & (1 << fe.extra) - 1, $e >>>= fe.extra, Et -= fe.extra, fe.back += fe.extra;
                  }
                  if (fe.offset > fe.dmax) {
                    Be.msg = "invalid distance too far back", fe.mode = Ye;
                    break;
                  }
                  fe.mode = Qt;
                /* falls through */
                case Qt:
                  if (ae === 0)
                    break e;
                  if (Ft = Yt - ae, fe.offset > Ft) {
                    if (Ft = fe.offset - Ft, Ft > fe.whave && fe.sane) {
                      Be.msg = "invalid distance too far back", fe.mode = Ye;
                      break;
                    }
                    Ft > fe.wnext ? (Ft -= fe.wnext, ai = fe.wsize - Ft) : ai = fe.wnext - Ft, Ft > fe.length && (Ft = fe.length), Mt = fe.window;
                  } else
                    Mt = Xe, ai = He - fe.offset, Ft = fe.length;
                  Ft > ae && (Ft = ae), ae -= Ft, fe.length -= Ft;
                  do
                    Xe[He++] = Mt[ai++];
                  while (--Ft);
                  fe.length === 0 && (fe.mode = $t);
                  break;
                case At:
                  if (ae === 0)
                    break e;
                  Xe[He++] = fe.length, ae--, fe.mode = $t;
                  break;
                case St:
                  if (fe.wrap) {
                    for (; Et < 32; ) {
                      if (nt === 0)
                        break e;
                      nt--, $e |= Je[z++] << Et, Et += 8;
                    }
                    if (Yt -= ae, Be.total_out += Yt, fe.total += Yt, Yt && (Be.adler = fe.check = /*UPDATE(state.check, put - _out, _out);*/
                    fe.flags ? N(fe.check, Xe, Yt, He - Yt) : i(fe.check, Xe, Yt, He - Yt)), Yt = ae, (fe.flags ? $e : xt($e)) !== fe.check) {
                      Be.msg = "incorrect data check", fe.mode = Ye;
                      break;
                    }
                    $e = 0, Et = 0;
                  }
                  fe.mode = Lt;
                /* falls through */
                case Lt:
                  if (fe.wrap && fe.flags) {
                    for (; Et < 32; ) {
                      if (nt === 0)
                        break e;
                      nt--, $e += Je[z++] << Et, Et += 8;
                    }
                    if ($e !== (fe.total & 4294967295)) {
                      Be.msg = "incorrect length check", fe.mode = Ye;
                      break;
                    }
                    $e = 0, Et = 0;
                  }
                  fe.mode = kt;
                /* falls through */
                case kt:
                  Wt = P;
                  break e;
                case Ye:
                  Wt = j;
                  break e;
                case De:
                  return T;
                case Re:
                /* falls through */
                default:
                  return U;
              }
          return Be.next_out = He, Be.avail_out = ae, Be.next_in = z, Be.avail_in = nt, fe.hold = $e, fe.bits = Et, (fe.wsize || Yt !== Be.avail_out && fe.mode < Ye && (fe.mode < St || Ze !== m)) && Qe(Be, Be.output, Be.next_out, Yt - Be.avail_out), Nt -= Be.avail_in, Yt -= Be.avail_out, Be.total_in += Nt, Be.total_out += Yt, fe.total += Yt, fe.wrap && Yt && (Be.adler = fe.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          fe.flags ? N(fe.check, Xe, Yt, Be.next_out - Yt) : i(fe.check, Xe, Yt, Be.next_out - Yt)), Be.data_type = fe.bits + (fe.last ? 64 : 0) + (fe.mode === it ? 128 : 0) + (fe.mode === Ht || fe.mode === pt ? 256 : 0), (Nt === 0 && Yt === 0 || Ze === m) && Wt === E && (Wt = W), Wt;
        }
        function Se(Be) {
          if (!Be || !Be.state)
            return U;
          var Ze = Be.state;
          return Ze.window && (Ze.window = null), Be.state = null, E;
        }
        function Pe(Be, Ze) {
          var fe;
          return !Be || !Be.state || (fe = Be.state, !(fe.wrap & 2)) ? U : (fe.head = Ze, Ze.done = !1, E);
        }
        function at(Be, Ze) {
          var fe = Ze.length, Je, Xe, z;
          return !Be || !Be.state || (Je = Be.state, Je.wrap !== 0 && Je.mode !== Ce) ? U : Je.mode === Ce && (Xe = 1, Xe = i(Xe, Ze, fe, 0), Xe !== Je.check) ? j : (z = Qe(Be, Ze, fe, fe), z ? (Je.mode = De, T) : (Je.havedict = 1, E));
        }
        q.inflateReset = I, q.inflateReset2 = X, q.inflateResetKeep = _, q.inflateInit = ue, q.inflateInit2 = ne, q.inflate = re, q.inflateEnd = Se, q.inflateGetHeader = Pe, q.inflateSetDictionary = at, q.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 36, "./adler32": 37, "./crc32": 39, "./inffast": 41, "./inftrees": 43 }], 43: [function(Q, de, q) {
        var ie = Q("../utils/common"), i = 15, N = 852, Z = 592, R = 0, A = 1, M = 2, x = [
          /* Length codes 257..285 base */
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ], m = [
          /* Length codes 257..285 extra */
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ], w = [
          /* Distance codes 0..29 base */
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ], k = [
          /* Distance codes 0..29 extra */
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ];
        de.exports = function(P, S, U, j, T, W, J, ee) {
          var te = ee.bits, le = 0, me = 0, ke = 0, ge = 0, Ve = 0, Oe = 0, Ue = 0, we = 0, Ce = 0, it = 0, ut, bt, pt, Ke, dt, ct = null, wt = 0, Ht, $t = new ie.Buf16(i + 1), rt = new ie.Buf16(i + 1), ri = null, wi = 0, Qt, At, St;
          for (le = 0; le <= i; le++)
            $t[le] = 0;
          for (me = 0; me < j; me++)
            $t[S[U + me]]++;
          for (Ve = te, ge = i; ge >= 1 && $t[ge] === 0; ge--)
            ;
          if (Ve > ge && (Ve = ge), ge === 0)
            return T[W++] = 1 << 24 | 64 << 16 | 0, T[W++] = 1 << 24 | 64 << 16 | 0, ee.bits = 1, 0;
          for (ke = 1; ke < ge && $t[ke] === 0; ke++)
            ;
          for (Ve < ke && (Ve = ke), we = 1, le = 1; le <= i; le++)
            if (we <<= 1, we -= $t[le], we < 0)
              return -1;
          if (we > 0 && (P === R || ge !== 1))
            return -1;
          for (rt[1] = 0, le = 1; le < i; le++)
            rt[le + 1] = rt[le] + $t[le];
          for (me = 0; me < j; me++)
            S[U + me] !== 0 && (J[rt[S[U + me]]++] = me);
          if (P === R ? (ct = ri = J, Ht = 19) : P === A ? (ct = x, wt -= 257, ri = m, wi -= 257, Ht = 256) : (ct = w, ri = k, Ht = -1), it = 0, me = 0, le = ke, dt = W, Oe = Ve, Ue = 0, pt = -1, Ce = 1 << Ve, Ke = Ce - 1, P === A && Ce > N || P === M && Ce > Z)
            return 1;
          for (; ; ) {
            Qt = le - Ue, J[me] < Ht ? (At = 0, St = J[me]) : J[me] > Ht ? (At = ri[wi + J[me]], St = ct[wt + J[me]]) : (At = 96, St = 0), ut = 1 << le - Ue, bt = 1 << Oe, ke = bt;
            do
              bt -= ut, T[dt + (it >> Ue) + bt] = Qt << 24 | At << 16 | St | 0;
            while (bt !== 0);
            for (ut = 1 << le - 1; it & ut; )
              ut >>= 1;
            if (ut !== 0 ? (it &= ut - 1, it += ut) : it = 0, me++, --$t[le] === 0) {
              if (le === ge)
                break;
              le = S[U + J[me]];
            }
            if (le > Ve && (it & Ke) !== pt) {
              for (Ue === 0 && (Ue = Ve), dt += ke, Oe = le - Ue, we = 1 << Oe; Oe + Ue < ge && (we -= $t[Oe + Ue], !(we <= 0)); )
                Oe++, we <<= 1;
              if (Ce += 1 << Oe, P === A && Ce > N || P === M && Ce > Z)
                return 1;
              pt = it & Ke, T[pt] = Ve << 24 | Oe << 16 | dt - W | 0;
            }
          }
          return it !== 0 && (T[dt + it] = le - Ue << 24 | 64 << 16 | 0), ee.bits = Ve, 0;
        };
      }, { "../utils/common": 36 }], 44: [function(Q, de, q) {
        de.exports = {
          2: "need dictionary",
          /* Z_NEED_DICT       2  */
          1: "stream end",
          /* Z_STREAM_END      1  */
          0: "",
          /* Z_OK              0  */
          "-1": "file error",
          /* Z_ERRNO         (-1) */
          "-2": "stream error",
          /* Z_STREAM_ERROR  (-2) */
          "-3": "data error",
          /* Z_DATA_ERROR    (-3) */
          "-4": "insufficient memory",
          /* Z_MEM_ERROR     (-4) */
          "-5": "buffer error",
          /* Z_BUF_ERROR     (-5) */
          "-6": "incompatible version"
          /* Z_VERSION_ERROR (-6) */
        };
      }, {}], 45: [function(Q, de, q) {
        var ie = Q("../utils/common"), i = 4, N = 0, Z = 1, R = 2;
        function A(re) {
          for (var Se = re.length; --Se >= 0; )
            re[Se] = 0;
        }
        var M = 0, x = 1, m = 2, w = 3, k = 258, E = 29, P = 256, S = P + 1 + E, U = 30, j = 19, T = 2 * S + 1, W = 15, J = 16, ee = 7, te = 256, le = 16, me = 17, ke = 18, ge = (
          /* extra bits for each length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
        ), Ve = (
          /* extra bits for each distance code */
          [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
        ), Oe = (
          /* extra bits for each bit length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
        ), Ue = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], we = 512, Ce = new Array((S + 2) * 2);
        A(Ce);
        var it = new Array(U * 2);
        A(it);
        var ut = new Array(we);
        A(ut);
        var bt = new Array(k - w + 1);
        A(bt);
        var pt = new Array(E);
        A(pt);
        var Ke = new Array(U);
        A(Ke);
        function dt(re, Se, Pe, at, Be) {
          this.static_tree = re, this.extra_bits = Se, this.extra_base = Pe, this.elems = at, this.max_length = Be, this.has_stree = re && re.length;
        }
        var ct, wt, Ht;
        function $t(re, Se) {
          this.dyn_tree = re, this.max_code = 0, this.stat_desc = Se;
        }
        function rt(re) {
          return re < 256 ? ut[re] : ut[256 + (re >>> 7)];
        }
        function ri(re, Se) {
          re.pending_buf[re.pending++] = Se & 255, re.pending_buf[re.pending++] = Se >>> 8 & 255;
        }
        function wi(re, Se, Pe) {
          re.bi_valid > J - Pe ? (re.bi_buf |= Se << re.bi_valid & 65535, ri(re, re.bi_buf), re.bi_buf = Se >> J - re.bi_valid, re.bi_valid += Pe - J) : (re.bi_buf |= Se << re.bi_valid & 65535, re.bi_valid += Pe);
        }
        function Qt(re, Se, Pe) {
          wi(
            re,
            Pe[Se * 2],
            Pe[Se * 2 + 1]
            /*.Len*/
          );
        }
        function At(re, Se) {
          var Pe = 0;
          do
            Pe |= re & 1, re >>>= 1, Pe <<= 1;
          while (--Se > 0);
          return Pe >>> 1;
        }
        function St(re) {
          re.bi_valid === 16 ? (ri(re, re.bi_buf), re.bi_buf = 0, re.bi_valid = 0) : re.bi_valid >= 8 && (re.pending_buf[re.pending++] = re.bi_buf & 255, re.bi_buf >>= 8, re.bi_valid -= 8);
        }
        function Lt(re, Se) {
          var Pe = Se.dyn_tree, at = Se.max_code, Be = Se.stat_desc.static_tree, Ze = Se.stat_desc.has_stree, fe = Se.stat_desc.extra_bits, Je = Se.stat_desc.extra_base, Xe = Se.stat_desc.max_length, z, He, nt, ae, $e, Et, Nt = 0;
          for (ae = 0; ae <= W; ae++)
            re.bl_count[ae] = 0;
          for (Pe[re.heap[re.heap_max] * 2 + 1] = 0, z = re.heap_max + 1; z < T; z++)
            He = re.heap[z], ae = Pe[Pe[He * 2 + 1] * 2 + 1] + 1, ae > Xe && (ae = Xe, Nt++), Pe[He * 2 + 1] = ae, !(He > at) && (re.bl_count[ae]++, $e = 0, He >= Je && ($e = fe[He - Je]), Et = Pe[He * 2], re.opt_len += Et * (ae + $e), Ze && (re.static_len += Et * (Be[He * 2 + 1] + $e)));
          if (Nt !== 0) {
            do {
              for (ae = Xe - 1; re.bl_count[ae] === 0; )
                ae--;
              re.bl_count[ae]--, re.bl_count[ae + 1] += 2, re.bl_count[Xe]--, Nt -= 2;
            } while (Nt > 0);
            for (ae = Xe; ae !== 0; ae--)
              for (He = re.bl_count[ae]; He !== 0; )
                nt = re.heap[--z], !(nt > at) && (Pe[nt * 2 + 1] !== ae && (re.opt_len += (ae - Pe[nt * 2 + 1]) * Pe[nt * 2], Pe[nt * 2 + 1] = ae), He--);
          }
        }
        function kt(re, Se, Pe) {
          var at = new Array(W + 1), Be = 0, Ze, fe;
          for (Ze = 1; Ze <= W; Ze++)
            at[Ze] = Be = Be + Pe[Ze - 1] << 1;
          for (fe = 0; fe <= Se; fe++) {
            var Je = re[fe * 2 + 1];
            Je !== 0 && (re[fe * 2] = At(at[Je]++, Je));
          }
        }
        function Ye() {
          var re, Se, Pe, at, Be, Ze = new Array(W + 1);
          for (Pe = 0, at = 0; at < E - 1; at++)
            for (pt[at] = Pe, re = 0; re < 1 << ge[at]; re++)
              bt[Pe++] = at;
          for (bt[Pe - 1] = at, Be = 0, at = 0; at < 16; at++)
            for (Ke[at] = Be, re = 0; re < 1 << Ve[at]; re++)
              ut[Be++] = at;
          for (Be >>= 7; at < U; at++)
            for (Ke[at] = Be << 7, re = 0; re < 1 << Ve[at] - 7; re++)
              ut[256 + Be++] = at;
          for (Se = 0; Se <= W; Se++)
            Ze[Se] = 0;
          for (re = 0; re <= 143; )
            Ce[re * 2 + 1] = 8, re++, Ze[8]++;
          for (; re <= 255; )
            Ce[re * 2 + 1] = 9, re++, Ze[9]++;
          for (; re <= 279; )
            Ce[re * 2 + 1] = 7, re++, Ze[7]++;
          for (; re <= 287; )
            Ce[re * 2 + 1] = 8, re++, Ze[8]++;
          for (kt(Ce, S + 1, Ze), re = 0; re < U; re++)
            it[re * 2 + 1] = 5, it[re * 2] = At(re, 5);
          ct = new dt(Ce, ge, P + 1, S, W), wt = new dt(it, Ve, 0, U, W), Ht = new dt(new Array(0), Oe, 0, j, ee);
        }
        function De(re) {
          var Se;
          for (Se = 0; Se < S; Se++)
            re.dyn_ltree[Se * 2] = 0;
          for (Se = 0; Se < U; Se++)
            re.dyn_dtree[Se * 2] = 0;
          for (Se = 0; Se < j; Se++)
            re.bl_tree[Se * 2] = 0;
          re.dyn_ltree[te * 2] = 1, re.opt_len = re.static_len = 0, re.last_lit = re.matches = 0;
        }
        function Re(re) {
          re.bi_valid > 8 ? ri(re, re.bi_buf) : re.bi_valid > 0 && (re.pending_buf[re.pending++] = re.bi_buf), re.bi_buf = 0, re.bi_valid = 0;
        }
        function _t(re, Se, Pe, at) {
          Re(re), ri(re, Pe), ri(re, ~Pe), ie.arraySet(re.pending_buf, re.window, Se, Pe, re.pending), re.pending += Pe;
        }
        function et(re, Se, Pe, at) {
          var Be = Se * 2, Ze = Pe * 2;
          return re[Be] < re[Ze] || re[Be] === re[Ze] && at[Se] <= at[Pe];
        }
        function Ie(re, Se, Pe) {
          for (var at = re.heap[Pe], Be = Pe << 1; Be <= re.heap_len && (Be < re.heap_len && et(Se, re.heap[Be + 1], re.heap[Be], re.depth) && Be++, !et(Se, at, re.heap[Be], re.depth)); )
            re.heap[Pe] = re.heap[Be], Pe = Be, Be <<= 1;
          re.heap[Pe] = at;
        }
        function pe(re, Se, Pe) {
          var at, Be, Ze = 0, fe, Je;
          if (re.last_lit !== 0)
            do
              at = re.pending_buf[re.d_buf + Ze * 2] << 8 | re.pending_buf[re.d_buf + Ze * 2 + 1], Be = re.pending_buf[re.l_buf + Ze], Ze++, at === 0 ? Qt(re, Be, Se) : (fe = bt[Be], Qt(re, fe + P + 1, Se), Je = ge[fe], Je !== 0 && (Be -= pt[fe], wi(re, Be, Je)), at--, fe = rt(at), Qt(re, fe, Pe), Je = Ve[fe], Je !== 0 && (at -= Ke[fe], wi(re, at, Je)));
            while (Ze < re.last_lit);
          Qt(re, te, Se);
        }
        function xt(re, Se) {
          var Pe = Se.dyn_tree, at = Se.stat_desc.static_tree, Be = Se.stat_desc.has_stree, Ze = Se.stat_desc.elems, fe, Je, Xe = -1, z;
          for (re.heap_len = 0, re.heap_max = T, fe = 0; fe < Ze; fe++)
            Pe[fe * 2] !== 0 ? (re.heap[++re.heap_len] = Xe = fe, re.depth[fe] = 0) : Pe[fe * 2 + 1] = 0;
          for (; re.heap_len < 2; )
            z = re.heap[++re.heap_len] = Xe < 2 ? ++Xe : 0, Pe[z * 2] = 1, re.depth[z] = 0, re.opt_len--, Be && (re.static_len -= at[z * 2 + 1]);
          for (Se.max_code = Xe, fe = re.heap_len >> 1; fe >= 1; fe--)
            Ie(re, Pe, fe);
          z = Ze;
          do
            fe = re.heap[
              1
              /*SMALLEST*/
            ], re.heap[
              1
              /*SMALLEST*/
            ] = re.heap[re.heap_len--], Ie(
              re,
              Pe,
              1
              /*SMALLEST*/
            ), Je = re.heap[
              1
              /*SMALLEST*/
            ], re.heap[--re.heap_max] = fe, re.heap[--re.heap_max] = Je, Pe[z * 2] = Pe[fe * 2] + Pe[Je * 2], re.depth[z] = (re.depth[fe] >= re.depth[Je] ? re.depth[fe] : re.depth[Je]) + 1, Pe[fe * 2 + 1] = Pe[Je * 2 + 1] = z, re.heap[
              1
              /*SMALLEST*/
            ] = z++, Ie(
              re,
              Pe,
              1
              /*SMALLEST*/
            );
          while (re.heap_len >= 2);
          re.heap[--re.heap_max] = re.heap[
            1
            /*SMALLEST*/
          ], Lt(re, Se), kt(Pe, Xe, re.bl_count);
        }
        function l(re, Se, Pe) {
          var at, Be = -1, Ze, fe = Se[0 * 2 + 1], Je = 0, Xe = 7, z = 4;
          for (fe === 0 && (Xe = 138, z = 3), Se[(Pe + 1) * 2 + 1] = 65535, at = 0; at <= Pe; at++)
            Ze = fe, fe = Se[(at + 1) * 2 + 1], !(++Je < Xe && Ze === fe) && (Je < z ? re.bl_tree[Ze * 2] += Je : Ze !== 0 ? (Ze !== Be && re.bl_tree[Ze * 2]++, re.bl_tree[le * 2]++) : Je <= 10 ? re.bl_tree[me * 2]++ : re.bl_tree[ke * 2]++, Je = 0, Be = Ze, fe === 0 ? (Xe = 138, z = 3) : Ze === fe ? (Xe = 6, z = 3) : (Xe = 7, z = 4));
        }
        function _(re, Se, Pe) {
          var at, Be = -1, Ze, fe = Se[0 * 2 + 1], Je = 0, Xe = 7, z = 4;
          for (fe === 0 && (Xe = 138, z = 3), at = 0; at <= Pe; at++)
            if (Ze = fe, fe = Se[(at + 1) * 2 + 1], !(++Je < Xe && Ze === fe)) {
              if (Je < z)
                do
                  Qt(re, Ze, re.bl_tree);
                while (--Je !== 0);
              else Ze !== 0 ? (Ze !== Be && (Qt(re, Ze, re.bl_tree), Je--), Qt(re, le, re.bl_tree), wi(re, Je - 3, 2)) : Je <= 10 ? (Qt(re, me, re.bl_tree), wi(re, Je - 3, 3)) : (Qt(re, ke, re.bl_tree), wi(re, Je - 11, 7));
              Je = 0, Be = Ze, fe === 0 ? (Xe = 138, z = 3) : Ze === fe ? (Xe = 6, z = 3) : (Xe = 7, z = 4);
            }
        }
        function I(re) {
          var Se;
          for (l(re, re.dyn_ltree, re.l_desc.max_code), l(re, re.dyn_dtree, re.d_desc.max_code), xt(re, re.bl_desc), Se = j - 1; Se >= 3 && re.bl_tree[Ue[Se] * 2 + 1] === 0; Se--)
            ;
          return re.opt_len += 3 * (Se + 1) + 5 + 5 + 4, Se;
        }
        function X(re, Se, Pe, at) {
          var Be;
          for (wi(re, Se - 257, 5), wi(re, Pe - 1, 5), wi(re, at - 4, 4), Be = 0; Be < at; Be++)
            wi(re, re.bl_tree[Ue[Be] * 2 + 1], 3);
          _(re, re.dyn_ltree, Se - 1), _(re, re.dyn_dtree, Pe - 1);
        }
        function ne(re) {
          var Se = 4093624447, Pe;
          for (Pe = 0; Pe <= 31; Pe++, Se >>>= 1)
            if (Se & 1 && re.dyn_ltree[Pe * 2] !== 0)
              return N;
          if (re.dyn_ltree[9 * 2] !== 0 || re.dyn_ltree[10 * 2] !== 0 || re.dyn_ltree[13 * 2] !== 0)
            return Z;
          for (Pe = 32; Pe < P; Pe++)
            if (re.dyn_ltree[Pe * 2] !== 0)
              return Z;
          return N;
        }
        var ue = !1;
        function Te(re) {
          ue || (Ye(), ue = !0), re.l_desc = new $t(re.dyn_ltree, ct), re.d_desc = new $t(re.dyn_dtree, wt), re.bl_desc = new $t(re.bl_tree, Ht), re.bi_buf = 0, re.bi_valid = 0, De(re);
        }
        function ye(re, Se, Pe, at) {
          wi(re, (M << 1) + (at ? 1 : 0), 3), _t(re, Se, Pe);
        }
        function Me(re) {
          wi(re, x << 1, 3), Qt(re, te, Ce), St(re);
        }
        function Ge(re, Se, Pe, at) {
          var Be, Ze, fe = 0;
          re.level > 0 ? (re.strm.data_type === R && (re.strm.data_type = ne(re)), xt(re, re.l_desc), xt(re, re.d_desc), fe = I(re), Be = re.opt_len + 3 + 7 >>> 3, Ze = re.static_len + 3 + 7 >>> 3, Ze <= Be && (Be = Ze)) : Be = Ze = Pe + 5, Pe + 4 <= Be && Se !== -1 ? ye(re, Se, Pe, at) : re.strategy === i || Ze === Be ? (wi(re, (x << 1) + (at ? 1 : 0), 3), pe(re, Ce, it)) : (wi(re, (m << 1) + (at ? 1 : 0), 3), X(re, re.l_desc.max_code + 1, re.d_desc.max_code + 1, fe + 1), pe(re, re.dyn_ltree, re.dyn_dtree)), De(re), at && Re(re);
        }
        function Qe(re, Se, Pe) {
          return re.pending_buf[re.d_buf + re.last_lit * 2] = Se >>> 8 & 255, re.pending_buf[re.d_buf + re.last_lit * 2 + 1] = Se & 255, re.pending_buf[re.l_buf + re.last_lit] = Pe & 255, re.last_lit++, Se === 0 ? re.dyn_ltree[Pe * 2]++ : (re.matches++, Se--, re.dyn_ltree[(bt[Pe] + P + 1) * 2]++, re.dyn_dtree[rt(Se) * 2]++), re.last_lit === re.lit_bufsize - 1;
        }
        q._tr_init = Te, q._tr_stored_block = ye, q._tr_flush_block = Ge, q._tr_tally = Qe, q._tr_align = Me;
      }, { "../utils/common": 36 }], 46: [function(Q, de, q) {
        function ie() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        }
        de.exports = ie;
      }, {}], 47: [function(Q, de, q) {
        arguments[4][33][0].apply(q, arguments);
      }, { dup: 33 }], 48: [function(Q, de, q) {
        (function(x) {
          var i = Q("base64-js"), N = Q("ieee754"), Z = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
          q.Buffer = x, q.SlowBuffer = W, q.INSPECT_MAX_BYTES = 50;
          var R = 2147483647;
          q.kMaxLength = R, x.TYPED_ARRAY_SUPPORT = A(), !x.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          );
          function A() {
            try {
              var et = new Uint8Array(1), Ie = { foo: function() {
                return 42;
              } };
              return Object.setPrototypeOf(Ie, Uint8Array.prototype), Object.setPrototypeOf(et, Ie), et.foo() === 42;
            } catch {
              return !1;
            }
          }
          Object.defineProperty(x.prototype, "parent", {
            enumerable: !0,
            get: function() {
              if (x.isBuffer(this))
                return this.buffer;
            }
          }), Object.defineProperty(x.prototype, "offset", {
            enumerable: !0,
            get: function() {
              if (x.isBuffer(this))
                return this.byteOffset;
            }
          });
          function M(et) {
            if (et > R)
              throw new RangeError('The value "' + et + '" is invalid for option "size"');
            var Ie = new Uint8Array(et);
            return Object.setPrototypeOf(Ie, x.prototype), Ie;
          }
          function x(et, Ie, pe) {
            if (typeof et == "number") {
              if (typeof Ie == "string")
                throw new TypeError(
                  'The "string" argument must be of type string. Received type number'
                );
              return E(et);
            }
            return m(et, Ie, pe);
          }
          typeof Symbol < "u" && Symbol.species != null && x[Symbol.species] === x && Object.defineProperty(x, Symbol.species, {
            value: null,
            configurable: !0,
            enumerable: !1,
            writable: !1
          }), x.poolSize = 8192;
          function m(et, Ie, pe) {
            if (typeof et == "string")
              return P(et, Ie);
            if (ArrayBuffer.isView(et))
              return S(et);
            if (et == null)
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof et
              );
            if (De(et, ArrayBuffer) || et && De(et.buffer, ArrayBuffer))
              return U(et, Ie, pe);
            if (typeof et == "number")
              throw new TypeError(
                'The "value" argument must not be of type number. Received type number'
              );
            var xt = et.valueOf && et.valueOf();
            if (xt != null && xt !== et)
              return x.from(xt, Ie, pe);
            var l = j(et);
            if (l) return l;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof et[Symbol.toPrimitive] == "function")
              return x.from(
                et[Symbol.toPrimitive]("string"),
                Ie,
                pe
              );
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof et
            );
          }
          x.from = function(et, Ie, pe) {
            return m(et, Ie, pe);
          }, Object.setPrototypeOf(x.prototype, Uint8Array.prototype), Object.setPrototypeOf(x, Uint8Array);
          function w(et) {
            if (typeof et != "number")
              throw new TypeError('"size" argument must be of type number');
            if (et < 0)
              throw new RangeError('The value "' + et + '" is invalid for option "size"');
          }
          function k(et, Ie, pe) {
            return w(et), et <= 0 ? M(et) : Ie !== void 0 ? typeof pe == "string" ? M(et).fill(Ie, pe) : M(et).fill(Ie) : M(et);
          }
          x.alloc = function(et, Ie, pe) {
            return k(et, Ie, pe);
          };
          function E(et) {
            return w(et), M(et < 0 ? 0 : T(et) | 0);
          }
          x.allocUnsafe = function(et) {
            return E(et);
          }, x.allocUnsafeSlow = function(et) {
            return E(et);
          };
          function P(et, Ie) {
            if ((typeof Ie != "string" || Ie === "") && (Ie = "utf8"), !x.isEncoding(Ie))
              throw new TypeError("Unknown encoding: " + Ie);
            var pe = J(et, Ie) | 0, xt = M(pe), l = xt.write(et, Ie);
            return l !== pe && (xt = xt.slice(0, l)), xt;
          }
          function S(et) {
            for (var Ie = et.length < 0 ? 0 : T(et.length) | 0, pe = M(Ie), xt = 0; xt < Ie; xt += 1)
              pe[xt] = et[xt] & 255;
            return pe;
          }
          function U(et, Ie, pe) {
            if (Ie < 0 || et.byteLength < Ie)
              throw new RangeError('"offset" is outside of buffer bounds');
            if (et.byteLength < Ie + (pe || 0))
              throw new RangeError('"length" is outside of buffer bounds');
            var xt;
            return Ie === void 0 && pe === void 0 ? xt = new Uint8Array(et) : pe === void 0 ? xt = new Uint8Array(et, Ie) : xt = new Uint8Array(et, Ie, pe), Object.setPrototypeOf(xt, x.prototype), xt;
          }
          function j(et) {
            if (x.isBuffer(et)) {
              var Ie = T(et.length) | 0, pe = M(Ie);
              return pe.length === 0 || et.copy(pe, 0, 0, Ie), pe;
            }
            if (et.length !== void 0)
              return typeof et.length != "number" || Re(et.length) ? M(0) : S(et);
            if (et.type === "Buffer" && Array.isArray(et.data))
              return S(et.data);
          }
          function T(et) {
            if (et >= R)
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + R.toString(16) + " bytes");
            return et | 0;
          }
          function W(et) {
            return +et != et && (et = 0), x.alloc(+et);
          }
          x.isBuffer = function(Ie) {
            return Ie != null && Ie._isBuffer === !0 && Ie !== x.prototype;
          }, x.compare = function(Ie, pe) {
            if (De(Ie, Uint8Array) && (Ie = x.from(Ie, Ie.offset, Ie.byteLength)), De(pe, Uint8Array) && (pe = x.from(pe, pe.offset, pe.byteLength)), !x.isBuffer(Ie) || !x.isBuffer(pe))
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
              );
            if (Ie === pe) return 0;
            for (var xt = Ie.length, l = pe.length, _ = 0, I = Math.min(xt, l); _ < I; ++_)
              if (Ie[_] !== pe[_]) {
                xt = Ie[_], l = pe[_];
                break;
              }
            return xt < l ? -1 : l < xt ? 1 : 0;
          }, x.isEncoding = function(Ie) {
            switch (String(Ie).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, x.concat = function(Ie, pe) {
            if (!Array.isArray(Ie))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (Ie.length === 0)
              return x.alloc(0);
            var xt;
            if (pe === void 0)
              for (pe = 0, xt = 0; xt < Ie.length; ++xt)
                pe += Ie[xt].length;
            var l = x.allocUnsafe(pe), _ = 0;
            for (xt = 0; xt < Ie.length; ++xt) {
              var I = Ie[xt];
              if (De(I, Uint8Array) && (I = x.from(I)), !x.isBuffer(I))
                throw new TypeError('"list" argument must be an Array of Buffers');
              I.copy(l, _), _ += I.length;
            }
            return l;
          };
          function J(et, Ie) {
            if (x.isBuffer(et))
              return et.length;
            if (ArrayBuffer.isView(et) || De(et, ArrayBuffer))
              return et.byteLength;
            if (typeof et != "string")
              throw new TypeError(
                'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof et
              );
            var pe = et.length, xt = arguments.length > 2 && arguments[2] === !0;
            if (!xt && pe === 0) return 0;
            for (var l = !1; ; )
              switch (Ie) {
                case "ascii":
                case "latin1":
                case "binary":
                  return pe;
                case "utf8":
                case "utf-8":
                  return At(et).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return pe * 2;
                case "hex":
                  return pe >>> 1;
                case "base64":
                  return kt(et).length;
                default:
                  if (l)
                    return xt ? -1 : At(et).length;
                  Ie = ("" + Ie).toLowerCase(), l = !0;
              }
          }
          x.byteLength = J;
          function ee(et, Ie, pe) {
            var xt = !1;
            if ((Ie === void 0 || Ie < 0) && (Ie = 0), Ie > this.length || ((pe === void 0 || pe > this.length) && (pe = this.length), pe <= 0) || (pe >>>= 0, Ie >>>= 0, pe <= Ie))
              return "";
            for (et || (et = "utf8"); ; )
              switch (et) {
                case "hex":
                  return dt(this, Ie, pe);
                case "utf8":
                case "utf-8":
                  return it(this, Ie, pe);
                case "ascii":
                  return pt(this, Ie, pe);
                case "latin1":
                case "binary":
                  return Ke(this, Ie, pe);
                case "base64":
                  return Ce(this, Ie, pe);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ct(this, Ie, pe);
                default:
                  if (xt) throw new TypeError("Unknown encoding: " + et);
                  et = (et + "").toLowerCase(), xt = !0;
              }
          }
          x.prototype._isBuffer = !0;
          function te(et, Ie, pe) {
            var xt = et[Ie];
            et[Ie] = et[pe], et[pe] = xt;
          }
          x.prototype.swap16 = function() {
            var Ie = this.length;
            if (Ie % 2 !== 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var pe = 0; pe < Ie; pe += 2)
              te(this, pe, pe + 1);
            return this;
          }, x.prototype.swap32 = function() {
            var Ie = this.length;
            if (Ie % 4 !== 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var pe = 0; pe < Ie; pe += 4)
              te(this, pe, pe + 3), te(this, pe + 1, pe + 2);
            return this;
          }, x.prototype.swap64 = function() {
            var Ie = this.length;
            if (Ie % 8 !== 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var pe = 0; pe < Ie; pe += 8)
              te(this, pe, pe + 7), te(this, pe + 1, pe + 6), te(this, pe + 2, pe + 5), te(this, pe + 3, pe + 4);
            return this;
          }, x.prototype.toString = function() {
            var Ie = this.length;
            return Ie === 0 ? "" : arguments.length === 0 ? it(this, 0, Ie) : ee.apply(this, arguments);
          }, x.prototype.toLocaleString = x.prototype.toString, x.prototype.equals = function(Ie) {
            if (!x.isBuffer(Ie)) throw new TypeError("Argument must be a Buffer");
            return this === Ie ? !0 : x.compare(this, Ie) === 0;
          }, x.prototype.inspect = function() {
            var Ie = "", pe = q.INSPECT_MAX_BYTES;
            return Ie = this.toString("hex", 0, pe).replace(/(.{2})/g, "$1 ").trim(), this.length > pe && (Ie += " ... "), "<Buffer " + Ie + ">";
          }, Z && (x.prototype[Z] = x.prototype.inspect), x.prototype.compare = function(Ie, pe, xt, l, _) {
            if (De(Ie, Uint8Array) && (Ie = x.from(Ie, Ie.offset, Ie.byteLength)), !x.isBuffer(Ie))
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Ie
              );
            if (pe === void 0 && (pe = 0), xt === void 0 && (xt = Ie ? Ie.length : 0), l === void 0 && (l = 0), _ === void 0 && (_ = this.length), pe < 0 || xt > Ie.length || l < 0 || _ > this.length)
              throw new RangeError("out of range index");
            if (l >= _ && pe >= xt)
              return 0;
            if (l >= _)
              return -1;
            if (pe >= xt)
              return 1;
            if (pe >>>= 0, xt >>>= 0, l >>>= 0, _ >>>= 0, this === Ie) return 0;
            for (var I = _ - l, X = xt - pe, ne = Math.min(I, X), ue = this.slice(l, _), Te = Ie.slice(pe, xt), ye = 0; ye < ne; ++ye)
              if (ue[ye] !== Te[ye]) {
                I = ue[ye], X = Te[ye];
                break;
              }
            return I < X ? -1 : X < I ? 1 : 0;
          };
          function le(et, Ie, pe, xt, l) {
            if (et.length === 0) return -1;
            if (typeof pe == "string" ? (xt = pe, pe = 0) : pe > 2147483647 ? pe = 2147483647 : pe < -2147483648 && (pe = -2147483648), pe = +pe, Re(pe) && (pe = l ? 0 : et.length - 1), pe < 0 && (pe = et.length + pe), pe >= et.length) {
              if (l) return -1;
              pe = et.length - 1;
            } else if (pe < 0)
              if (l) pe = 0;
              else return -1;
            if (typeof Ie == "string" && (Ie = x.from(Ie, xt)), x.isBuffer(Ie))
              return Ie.length === 0 ? -1 : me(et, Ie, pe, xt, l);
            if (typeof Ie == "number")
              return Ie = Ie & 255, typeof Uint8Array.prototype.indexOf == "function" ? l ? Uint8Array.prototype.indexOf.call(et, Ie, pe) : Uint8Array.prototype.lastIndexOf.call(et, Ie, pe) : me(et, [Ie], pe, xt, l);
            throw new TypeError("val must be string, number or Buffer");
          }
          function me(et, Ie, pe, xt, l) {
            var _ = 1, I = et.length, X = Ie.length;
            if (xt !== void 0 && (xt = String(xt).toLowerCase(), xt === "ucs2" || xt === "ucs-2" || xt === "utf16le" || xt === "utf-16le")) {
              if (et.length < 2 || Ie.length < 2)
                return -1;
              _ = 2, I /= 2, X /= 2, pe /= 2;
            }
            function ne(Ge, Qe) {
              return _ === 1 ? Ge[Qe] : Ge.readUInt16BE(Qe * _);
            }
            var ue;
            if (l) {
              var Te = -1;
              for (ue = pe; ue < I; ue++)
                if (ne(et, ue) === ne(Ie, Te === -1 ? 0 : ue - Te)) {
                  if (Te === -1 && (Te = ue), ue - Te + 1 === X) return Te * _;
                } else
                  Te !== -1 && (ue -= ue - Te), Te = -1;
            } else
              for (pe + X > I && (pe = I - X), ue = pe; ue >= 0; ue--) {
                for (var ye = !0, Me = 0; Me < X; Me++)
                  if (ne(et, ue + Me) !== ne(Ie, Me)) {
                    ye = !1;
                    break;
                  }
                if (ye) return ue;
              }
            return -1;
          }
          x.prototype.includes = function(Ie, pe, xt) {
            return this.indexOf(Ie, pe, xt) !== -1;
          }, x.prototype.indexOf = function(Ie, pe, xt) {
            return le(this, Ie, pe, xt, !0);
          }, x.prototype.lastIndexOf = function(Ie, pe, xt) {
            return le(this, Ie, pe, xt, !1);
          };
          function ke(et, Ie, pe, xt) {
            pe = Number(pe) || 0;
            var l = et.length - pe;
            xt ? (xt = Number(xt), xt > l && (xt = l)) : xt = l;
            var _ = Ie.length;
            xt > _ / 2 && (xt = _ / 2);
            for (var I = 0; I < xt; ++I) {
              var X = parseInt(Ie.substr(I * 2, 2), 16);
              if (Re(X)) return I;
              et[pe + I] = X;
            }
            return I;
          }
          function ge(et, Ie, pe, xt) {
            return Ye(At(Ie, et.length - pe), et, pe, xt);
          }
          function Ve(et, Ie, pe, xt) {
            return Ye(St(Ie), et, pe, xt);
          }
          function Oe(et, Ie, pe, xt) {
            return Ve(et, Ie, pe, xt);
          }
          function Ue(et, Ie, pe, xt) {
            return Ye(kt(Ie), et, pe, xt);
          }
          function we(et, Ie, pe, xt) {
            return Ye(Lt(Ie, et.length - pe), et, pe, xt);
          }
          x.prototype.write = function(Ie, pe, xt, l) {
            if (pe === void 0)
              l = "utf8", xt = this.length, pe = 0;
            else if (xt === void 0 && typeof pe == "string")
              l = pe, xt = this.length, pe = 0;
            else if (isFinite(pe))
              pe = pe >>> 0, isFinite(xt) ? (xt = xt >>> 0, l === void 0 && (l = "utf8")) : (l = xt, xt = void 0);
            else
              throw new Error(
                "Buffer.write(string, encoding, offset[, length]) is no longer supported"
              );
            var _ = this.length - pe;
            if ((xt === void 0 || xt > _) && (xt = _), Ie.length > 0 && (xt < 0 || pe < 0) || pe > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            l || (l = "utf8");
            for (var I = !1; ; )
              switch (l) {
                case "hex":
                  return ke(this, Ie, pe, xt);
                case "utf8":
                case "utf-8":
                  return ge(this, Ie, pe, xt);
                case "ascii":
                  return Ve(this, Ie, pe, xt);
                case "latin1":
                case "binary":
                  return Oe(this, Ie, pe, xt);
                case "base64":
                  return Ue(this, Ie, pe, xt);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return we(this, Ie, pe, xt);
                default:
                  if (I) throw new TypeError("Unknown encoding: " + l);
                  l = ("" + l).toLowerCase(), I = !0;
              }
          }, x.prototype.toJSON = function() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function Ce(et, Ie, pe) {
            return Ie === 0 && pe === et.length ? i.fromByteArray(et) : i.fromByteArray(et.slice(Ie, pe));
          }
          function it(et, Ie, pe) {
            pe = Math.min(et.length, pe);
            for (var xt = [], l = Ie; l < pe; ) {
              var _ = et[l], I = null, X = _ > 239 ? 4 : _ > 223 ? 3 : _ > 191 ? 2 : 1;
              if (l + X <= pe) {
                var ne, ue, Te, ye;
                switch (X) {
                  case 1:
                    _ < 128 && (I = _);
                    break;
                  case 2:
                    ne = et[l + 1], (ne & 192) === 128 && (ye = (_ & 31) << 6 | ne & 63, ye > 127 && (I = ye));
                    break;
                  case 3:
                    ne = et[l + 1], ue = et[l + 2], (ne & 192) === 128 && (ue & 192) === 128 && (ye = (_ & 15) << 12 | (ne & 63) << 6 | ue & 63, ye > 2047 && (ye < 55296 || ye > 57343) && (I = ye));
                    break;
                  case 4:
                    ne = et[l + 1], ue = et[l + 2], Te = et[l + 3], (ne & 192) === 128 && (ue & 192) === 128 && (Te & 192) === 128 && (ye = (_ & 15) << 18 | (ne & 63) << 12 | (ue & 63) << 6 | Te & 63, ye > 65535 && ye < 1114112 && (I = ye));
                }
              }
              I === null ? (I = 65533, X = 1) : I > 65535 && (I -= 65536, xt.push(I >>> 10 & 1023 | 55296), I = 56320 | I & 1023), xt.push(I), l += X;
            }
            return bt(xt);
          }
          var ut = 4096;
          function bt(et) {
            var Ie = et.length;
            if (Ie <= ut)
              return String.fromCharCode.apply(String, et);
            for (var pe = "", xt = 0; xt < Ie; )
              pe += String.fromCharCode.apply(
                String,
                et.slice(xt, xt += ut)
              );
            return pe;
          }
          function pt(et, Ie, pe) {
            var xt = "";
            pe = Math.min(et.length, pe);
            for (var l = Ie; l < pe; ++l)
              xt += String.fromCharCode(et[l] & 127);
            return xt;
          }
          function Ke(et, Ie, pe) {
            var xt = "";
            pe = Math.min(et.length, pe);
            for (var l = Ie; l < pe; ++l)
              xt += String.fromCharCode(et[l]);
            return xt;
          }
          function dt(et, Ie, pe) {
            var xt = et.length;
            (!Ie || Ie < 0) && (Ie = 0), (!pe || pe < 0 || pe > xt) && (pe = xt);
            for (var l = "", _ = Ie; _ < pe; ++_)
              l += _t[et[_]];
            return l;
          }
          function ct(et, Ie, pe) {
            for (var xt = et.slice(Ie, pe), l = "", _ = 0; _ < xt.length; _ += 2)
              l += String.fromCharCode(xt[_] + xt[_ + 1] * 256);
            return l;
          }
          x.prototype.slice = function(Ie, pe) {
            var xt = this.length;
            Ie = ~~Ie, pe = pe === void 0 ? xt : ~~pe, Ie < 0 ? (Ie += xt, Ie < 0 && (Ie = 0)) : Ie > xt && (Ie = xt), pe < 0 ? (pe += xt, pe < 0 && (pe = 0)) : pe > xt && (pe = xt), pe < Ie && (pe = Ie);
            var l = this.subarray(Ie, pe);
            return Object.setPrototypeOf(l, x.prototype), l;
          };
          function wt(et, Ie, pe) {
            if (et % 1 !== 0 || et < 0) throw new RangeError("offset is not uint");
            if (et + Ie > pe) throw new RangeError("Trying to access beyond buffer length");
          }
          x.prototype.readUIntLE = function(Ie, pe, xt) {
            Ie = Ie >>> 0, pe = pe >>> 0, xt || wt(Ie, pe, this.length);
            for (var l = this[Ie], _ = 1, I = 0; ++I < pe && (_ *= 256); )
              l += this[Ie + I] * _;
            return l;
          }, x.prototype.readUIntBE = function(Ie, pe, xt) {
            Ie = Ie >>> 0, pe = pe >>> 0, xt || wt(Ie, pe, this.length);
            for (var l = this[Ie + --pe], _ = 1; pe > 0 && (_ *= 256); )
              l += this[Ie + --pe] * _;
            return l;
          }, x.prototype.readUInt8 = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 1, this.length), this[Ie];
          }, x.prototype.readUInt16LE = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 2, this.length), this[Ie] | this[Ie + 1] << 8;
          }, x.prototype.readUInt16BE = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 2, this.length), this[Ie] << 8 | this[Ie + 1];
          }, x.prototype.readUInt32LE = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 4, this.length), (this[Ie] | this[Ie + 1] << 8 | this[Ie + 2] << 16) + this[Ie + 3] * 16777216;
          }, x.prototype.readUInt32BE = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 4, this.length), this[Ie] * 16777216 + (this[Ie + 1] << 16 | this[Ie + 2] << 8 | this[Ie + 3]);
          }, x.prototype.readIntLE = function(Ie, pe, xt) {
            Ie = Ie >>> 0, pe = pe >>> 0, xt || wt(Ie, pe, this.length);
            for (var l = this[Ie], _ = 1, I = 0; ++I < pe && (_ *= 256); )
              l += this[Ie + I] * _;
            return _ *= 128, l >= _ && (l -= Math.pow(2, 8 * pe)), l;
          }, x.prototype.readIntBE = function(Ie, pe, xt) {
            Ie = Ie >>> 0, pe = pe >>> 0, xt || wt(Ie, pe, this.length);
            for (var l = pe, _ = 1, I = this[Ie + --l]; l > 0 && (_ *= 256); )
              I += this[Ie + --l] * _;
            return _ *= 128, I >= _ && (I -= Math.pow(2, 8 * pe)), I;
          }, x.prototype.readInt8 = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 1, this.length), this[Ie] & 128 ? (255 - this[Ie] + 1) * -1 : this[Ie];
          }, x.prototype.readInt16LE = function(Ie, pe) {
            Ie = Ie >>> 0, pe || wt(Ie, 2, this.length);
            var xt = this[Ie] | this[Ie + 1] << 8;
            return xt & 32768 ? xt | 4294901760 : xt;
          }, x.prototype.readInt16BE = function(Ie, pe) {
            Ie = Ie >>> 0, pe || wt(Ie, 2, this.length);
            var xt = this[Ie + 1] | this[Ie] << 8;
            return xt & 32768 ? xt | 4294901760 : xt;
          }, x.prototype.readInt32LE = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 4, this.length), this[Ie] | this[Ie + 1] << 8 | this[Ie + 2] << 16 | this[Ie + 3] << 24;
          }, x.prototype.readInt32BE = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 4, this.length), this[Ie] << 24 | this[Ie + 1] << 16 | this[Ie + 2] << 8 | this[Ie + 3];
          }, x.prototype.readFloatLE = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 4, this.length), N.read(this, Ie, !0, 23, 4);
          }, x.prototype.readFloatBE = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 4, this.length), N.read(this, Ie, !1, 23, 4);
          }, x.prototype.readDoubleLE = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 8, this.length), N.read(this, Ie, !0, 52, 8);
          }, x.prototype.readDoubleBE = function(Ie, pe) {
            return Ie = Ie >>> 0, pe || wt(Ie, 8, this.length), N.read(this, Ie, !1, 52, 8);
          };
          function Ht(et, Ie, pe, xt, l, _) {
            if (!x.isBuffer(et)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (Ie > l || Ie < _) throw new RangeError('"value" argument is out of bounds');
            if (pe + xt > et.length) throw new RangeError("Index out of range");
          }
          x.prototype.writeUIntLE = function(Ie, pe, xt, l) {
            if (Ie = +Ie, pe = pe >>> 0, xt = xt >>> 0, !l) {
              var _ = Math.pow(2, 8 * xt) - 1;
              Ht(this, Ie, pe, xt, _, 0);
            }
            var I = 1, X = 0;
            for (this[pe] = Ie & 255; ++X < xt && (I *= 256); )
              this[pe + X] = Ie / I & 255;
            return pe + xt;
          }, x.prototype.writeUIntBE = function(Ie, pe, xt, l) {
            if (Ie = +Ie, pe = pe >>> 0, xt = xt >>> 0, !l) {
              var _ = Math.pow(2, 8 * xt) - 1;
              Ht(this, Ie, pe, xt, _, 0);
            }
            var I = xt - 1, X = 1;
            for (this[pe + I] = Ie & 255; --I >= 0 && (X *= 256); )
              this[pe + I] = Ie / X & 255;
            return pe + xt;
          }, x.prototype.writeUInt8 = function(Ie, pe, xt) {
            return Ie = +Ie, pe = pe >>> 0, xt || Ht(this, Ie, pe, 1, 255, 0), this[pe] = Ie & 255, pe + 1;
          }, x.prototype.writeUInt16LE = function(Ie, pe, xt) {
            return Ie = +Ie, pe = pe >>> 0, xt || Ht(this, Ie, pe, 2, 65535, 0), this[pe] = Ie & 255, this[pe + 1] = Ie >>> 8, pe + 2;
          }, x.prototype.writeUInt16BE = function(Ie, pe, xt) {
            return Ie = +Ie, pe = pe >>> 0, xt || Ht(this, Ie, pe, 2, 65535, 0), this[pe] = Ie >>> 8, this[pe + 1] = Ie & 255, pe + 2;
          }, x.prototype.writeUInt32LE = function(Ie, pe, xt) {
            return Ie = +Ie, pe = pe >>> 0, xt || Ht(this, Ie, pe, 4, 4294967295, 0), this[pe + 3] = Ie >>> 24, this[pe + 2] = Ie >>> 16, this[pe + 1] = Ie >>> 8, this[pe] = Ie & 255, pe + 4;
          }, x.prototype.writeUInt32BE = function(Ie, pe, xt) {
            return Ie = +Ie, pe = pe >>> 0, xt || Ht(this, Ie, pe, 4, 4294967295, 0), this[pe] = Ie >>> 24, this[pe + 1] = Ie >>> 16, this[pe + 2] = Ie >>> 8, this[pe + 3] = Ie & 255, pe + 4;
          }, x.prototype.writeIntLE = function(Ie, pe, xt, l) {
            if (Ie = +Ie, pe = pe >>> 0, !l) {
              var _ = Math.pow(2, 8 * xt - 1);
              Ht(this, Ie, pe, xt, _ - 1, -_);
            }
            var I = 0, X = 1, ne = 0;
            for (this[pe] = Ie & 255; ++I < xt && (X *= 256); )
              Ie < 0 && ne === 0 && this[pe + I - 1] !== 0 && (ne = 1), this[pe + I] = (Ie / X >> 0) - ne & 255;
            return pe + xt;
          }, x.prototype.writeIntBE = function(Ie, pe, xt, l) {
            if (Ie = +Ie, pe = pe >>> 0, !l) {
              var _ = Math.pow(2, 8 * xt - 1);
              Ht(this, Ie, pe, xt, _ - 1, -_);
            }
            var I = xt - 1, X = 1, ne = 0;
            for (this[pe + I] = Ie & 255; --I >= 0 && (X *= 256); )
              Ie < 0 && ne === 0 && this[pe + I + 1] !== 0 && (ne = 1), this[pe + I] = (Ie / X >> 0) - ne & 255;
            return pe + xt;
          }, x.prototype.writeInt8 = function(Ie, pe, xt) {
            return Ie = +Ie, pe = pe >>> 0, xt || Ht(this, Ie, pe, 1, 127, -128), Ie < 0 && (Ie = 255 + Ie + 1), this[pe] = Ie & 255, pe + 1;
          }, x.prototype.writeInt16LE = function(Ie, pe, xt) {
            return Ie = +Ie, pe = pe >>> 0, xt || Ht(this, Ie, pe, 2, 32767, -32768), this[pe] = Ie & 255, this[pe + 1] = Ie >>> 8, pe + 2;
          }, x.prototype.writeInt16BE = function(Ie, pe, xt) {
            return Ie = +Ie, pe = pe >>> 0, xt || Ht(this, Ie, pe, 2, 32767, -32768), this[pe] = Ie >>> 8, this[pe + 1] = Ie & 255, pe + 2;
          }, x.prototype.writeInt32LE = function(Ie, pe, xt) {
            return Ie = +Ie, pe = pe >>> 0, xt || Ht(this, Ie, pe, 4, 2147483647, -2147483648), this[pe] = Ie & 255, this[pe + 1] = Ie >>> 8, this[pe + 2] = Ie >>> 16, this[pe + 3] = Ie >>> 24, pe + 4;
          }, x.prototype.writeInt32BE = function(Ie, pe, xt) {
            return Ie = +Ie, pe = pe >>> 0, xt || Ht(this, Ie, pe, 4, 2147483647, -2147483648), Ie < 0 && (Ie = 4294967295 + Ie + 1), this[pe] = Ie >>> 24, this[pe + 1] = Ie >>> 16, this[pe + 2] = Ie >>> 8, this[pe + 3] = Ie & 255, pe + 4;
          };
          function $t(et, Ie, pe, xt, l, _) {
            if (pe + xt > et.length) throw new RangeError("Index out of range");
            if (pe < 0) throw new RangeError("Index out of range");
          }
          function rt(et, Ie, pe, xt, l) {
            return Ie = +Ie, pe = pe >>> 0, l || $t(et, Ie, pe, 4), N.write(et, Ie, pe, xt, 23, 4), pe + 4;
          }
          x.prototype.writeFloatLE = function(Ie, pe, xt) {
            return rt(this, Ie, pe, !0, xt);
          }, x.prototype.writeFloatBE = function(Ie, pe, xt) {
            return rt(this, Ie, pe, !1, xt);
          };
          function ri(et, Ie, pe, xt, l) {
            return Ie = +Ie, pe = pe >>> 0, l || $t(et, Ie, pe, 8), N.write(et, Ie, pe, xt, 52, 8), pe + 8;
          }
          x.prototype.writeDoubleLE = function(Ie, pe, xt) {
            return ri(this, Ie, pe, !0, xt);
          }, x.prototype.writeDoubleBE = function(Ie, pe, xt) {
            return ri(this, Ie, pe, !1, xt);
          }, x.prototype.copy = function(Ie, pe, xt, l) {
            if (!x.isBuffer(Ie)) throw new TypeError("argument should be a Buffer");
            if (xt || (xt = 0), !l && l !== 0 && (l = this.length), pe >= Ie.length && (pe = Ie.length), pe || (pe = 0), l > 0 && l < xt && (l = xt), l === xt || Ie.length === 0 || this.length === 0) return 0;
            if (pe < 0)
              throw new RangeError("targetStart out of bounds");
            if (xt < 0 || xt >= this.length) throw new RangeError("Index out of range");
            if (l < 0) throw new RangeError("sourceEnd out of bounds");
            l > this.length && (l = this.length), Ie.length - pe < l - xt && (l = Ie.length - pe + xt);
            var _ = l - xt;
            if (this === Ie && typeof Uint8Array.prototype.copyWithin == "function")
              this.copyWithin(pe, xt, l);
            else if (this === Ie && xt < pe && pe < l)
              for (var I = _ - 1; I >= 0; --I)
                Ie[I + pe] = this[I + xt];
            else
              Uint8Array.prototype.set.call(
                Ie,
                this.subarray(xt, l),
                pe
              );
            return _;
          }, x.prototype.fill = function(Ie, pe, xt, l) {
            if (typeof Ie == "string") {
              if (typeof pe == "string" ? (l = pe, pe = 0, xt = this.length) : typeof xt == "string" && (l = xt, xt = this.length), l !== void 0 && typeof l != "string")
                throw new TypeError("encoding must be a string");
              if (typeof l == "string" && !x.isEncoding(l))
                throw new TypeError("Unknown encoding: " + l);
              if (Ie.length === 1) {
                var _ = Ie.charCodeAt(0);
                (l === "utf8" && _ < 128 || l === "latin1") && (Ie = _);
              }
            } else typeof Ie == "number" ? Ie = Ie & 255 : typeof Ie == "boolean" && (Ie = Number(Ie));
            if (pe < 0 || this.length < pe || this.length < xt)
              throw new RangeError("Out of range index");
            if (xt <= pe)
              return this;
            pe = pe >>> 0, xt = xt === void 0 ? this.length : xt >>> 0, Ie || (Ie = 0);
            var I;
            if (typeof Ie == "number")
              for (I = pe; I < xt; ++I)
                this[I] = Ie;
            else {
              var X = x.isBuffer(Ie) ? Ie : x.from(Ie, l), ne = X.length;
              if (ne === 0)
                throw new TypeError('The value "' + Ie + '" is invalid for argument "value"');
              for (I = 0; I < xt - pe; ++I)
                this[I + pe] = X[I % ne];
            }
            return this;
          };
          var wi = /[^+/0-9A-Za-z-_]/g;
          function Qt(et) {
            if (et = et.split("=")[0], et = et.trim().replace(wi, ""), et.length < 2) return "";
            for (; et.length % 4 !== 0; )
              et = et + "=";
            return et;
          }
          function At(et, Ie) {
            Ie = Ie || 1 / 0;
            for (var pe, xt = et.length, l = null, _ = [], I = 0; I < xt; ++I) {
              if (pe = et.charCodeAt(I), pe > 55295 && pe < 57344) {
                if (!l) {
                  if (pe > 56319) {
                    (Ie -= 3) > -1 && _.push(239, 191, 189);
                    continue;
                  } else if (I + 1 === xt) {
                    (Ie -= 3) > -1 && _.push(239, 191, 189);
                    continue;
                  }
                  l = pe;
                  continue;
                }
                if (pe < 56320) {
                  (Ie -= 3) > -1 && _.push(239, 191, 189), l = pe;
                  continue;
                }
                pe = (l - 55296 << 10 | pe - 56320) + 65536;
              } else l && (Ie -= 3) > -1 && _.push(239, 191, 189);
              if (l = null, pe < 128) {
                if ((Ie -= 1) < 0) break;
                _.push(pe);
              } else if (pe < 2048) {
                if ((Ie -= 2) < 0) break;
                _.push(
                  pe >> 6 | 192,
                  pe & 63 | 128
                );
              } else if (pe < 65536) {
                if ((Ie -= 3) < 0) break;
                _.push(
                  pe >> 12 | 224,
                  pe >> 6 & 63 | 128,
                  pe & 63 | 128
                );
              } else if (pe < 1114112) {
                if ((Ie -= 4) < 0) break;
                _.push(
                  pe >> 18 | 240,
                  pe >> 12 & 63 | 128,
                  pe >> 6 & 63 | 128,
                  pe & 63 | 128
                );
              } else
                throw new Error("Invalid code point");
            }
            return _;
          }
          function St(et) {
            for (var Ie = [], pe = 0; pe < et.length; ++pe)
              Ie.push(et.charCodeAt(pe) & 255);
            return Ie;
          }
          function Lt(et, Ie) {
            for (var pe, xt, l, _ = [], I = 0; I < et.length && !((Ie -= 2) < 0); ++I)
              pe = et.charCodeAt(I), xt = pe >> 8, l = pe % 256, _.push(l), _.push(xt);
            return _;
          }
          function kt(et) {
            return i.toByteArray(Qt(et));
          }
          function Ye(et, Ie, pe, xt) {
            for (var l = 0; l < xt && !(l + pe >= Ie.length || l >= et.length); ++l)
              Ie[l + pe] = et[l];
            return l;
          }
          function De(et, Ie) {
            return et instanceof Ie || et != null && et.constructor != null && et.constructor.name != null && et.constructor.name === Ie.name;
          }
          function Re(et) {
            return et !== et;
          }
          var _t = function() {
            for (var et = "0123456789abcdef", Ie = new Array(256), pe = 0; pe < 16; ++pe)
              for (var xt = pe * 16, l = 0; l < 16; ++l)
                Ie[xt + l] = et[pe] + et[l];
            return Ie;
          }();
        }).call(this, Q("buffer").Buffer);
      }, { "base64-js": 29, buffer: 48, ieee754: 73 }], 49: [function(Q, de, q) {
        var ie = Q("buffer").Buffer;
        de.exports = function(i, N) {
          if (ie.isBuffer(i) && ie.isBuffer(N)) {
            if (typeof i.equals == "function") return i.equals(N);
            if (i.length !== N.length) return !1;
            for (var Z = 0; Z < i.length; Z++)
              if (i[Z] !== N[Z]) return !1;
            return !0;
          }
        };
      }, { buffer: 48 }], 50: [function(Q, de, q) {
        de.exports = {
          100: "Continue",
          101: "Switching Protocols",
          102: "Processing",
          200: "OK",
          201: "Created",
          202: "Accepted",
          203: "Non-Authoritative Information",
          204: "No Content",
          205: "Reset Content",
          206: "Partial Content",
          207: "Multi-Status",
          208: "Already Reported",
          226: "IM Used",
          300: "Multiple Choices",
          301: "Moved Permanently",
          302: "Found",
          303: "See Other",
          304: "Not Modified",
          305: "Use Proxy",
          307: "Temporary Redirect",
          308: "Permanent Redirect",
          400: "Bad Request",
          401: "Unauthorized",
          402: "Payment Required",
          403: "Forbidden",
          404: "Not Found",
          405: "Method Not Allowed",
          406: "Not Acceptable",
          407: "Proxy Authentication Required",
          408: "Request Timeout",
          409: "Conflict",
          410: "Gone",
          411: "Length Required",
          412: "Precondition Failed",
          413: "Payload Too Large",
          414: "URI Too Long",
          415: "Unsupported Media Type",
          416: "Range Not Satisfiable",
          417: "Expectation Failed",
          418: "I'm a teapot",
          421: "Misdirected Request",
          422: "Unprocessable Entity",
          423: "Locked",
          424: "Failed Dependency",
          425: "Unordered Collection",
          426: "Upgrade Required",
          428: "Precondition Required",
          429: "Too Many Requests",
          431: "Request Header Fields Too Large",
          451: "Unavailable For Legal Reasons",
          500: "Internal Server Error",
          501: "Not Implemented",
          502: "Bad Gateway",
          503: "Service Unavailable",
          504: "Gateway Timeout",
          505: "HTTP Version Not Supported",
          506: "Variant Also Negotiates",
          507: "Insufficient Storage",
          508: "Loop Detected",
          509: "Bandwidth Limit Exceeded",
          510: "Not Extended",
          511: "Network Authentication Required"
        };
      }, {}], 51: [function(Q, de, q) {
        (function(ie) {
          function i(T) {
            return Array.isArray ? Array.isArray(T) : j(T) === "[object Array]";
          }
          q.isArray = i;
          function N(T) {
            return typeof T == "boolean";
          }
          q.isBoolean = N;
          function Z(T) {
            return T === null;
          }
          q.isNull = Z;
          function R(T) {
            return T == null;
          }
          q.isNullOrUndefined = R;
          function A(T) {
            return typeof T == "number";
          }
          q.isNumber = A;
          function M(T) {
            return typeof T == "string";
          }
          q.isString = M;
          function x(T) {
            return typeof T == "symbol";
          }
          q.isSymbol = x;
          function m(T) {
            return T === void 0;
          }
          q.isUndefined = m;
          function w(T) {
            return j(T) === "[object RegExp]";
          }
          q.isRegExp = w;
          function k(T) {
            return typeof T == "object" && T !== null;
          }
          q.isObject = k;
          function E(T) {
            return j(T) === "[object Date]";
          }
          q.isDate = E;
          function P(T) {
            return j(T) === "[object Error]" || T instanceof Error;
          }
          q.isError = P;
          function S(T) {
            return typeof T == "function";
          }
          q.isFunction = S;
          function U(T) {
            return T === null || typeof T == "boolean" || typeof T == "number" || typeof T == "string" || typeof T == "symbol" || // ES6 symbol
            typeof T > "u";
          }
          q.isPrimitive = U, q.isBuffer = ie.isBuffer;
          function j(T) {
            return Object.prototype.toString.call(T);
          }
        }).call(this, { isBuffer: Q("../../is-buffer/index.js") });
      }, { "../../is-buffer/index.js": 76 }], 52: [function(Q, de, q) {
        var ie = Object.create || le, i = Object.keys || me, N = Function.prototype.bind || ke;
        function Z() {
          (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) && (this._events = ie(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }
        de.exports = Z, Z.EventEmitter = Z, Z.prototype._events = void 0, Z.prototype._maxListeners = void 0;
        var R = 10, A;
        try {
          var M = {};
          Object.defineProperty && Object.defineProperty(M, "x", { value: 0 }), A = M.x === 0;
        } catch {
          A = !1;
        }
        A ? Object.defineProperty(Z, "defaultMaxListeners", {
          enumerable: !0,
          get: function() {
            return R;
          },
          set: function(ge) {
            if (typeof ge != "number" || ge < 0 || ge !== ge)
              throw new TypeError('"defaultMaxListeners" must be a positive number');
            R = ge;
          }
        }) : Z.defaultMaxListeners = R, Z.prototype.setMaxListeners = function(Ve) {
          if (typeof Ve != "number" || Ve < 0 || isNaN(Ve))
            throw new TypeError('"n" argument must be a positive number');
          return this._maxListeners = Ve, this;
        };
        function x(ge) {
          return ge._maxListeners === void 0 ? Z.defaultMaxListeners : ge._maxListeners;
        }
        Z.prototype.getMaxListeners = function() {
          return x(this);
        };
        function m(ge, Ve, Oe) {
          if (Ve)
            ge.call(Oe);
          else
            for (var Ue = ge.length, we = ee(ge, Ue), Ce = 0; Ce < Ue; ++Ce)
              we[Ce].call(Oe);
        }
        function w(ge, Ve, Oe, Ue) {
          if (Ve)
            ge.call(Oe, Ue);
          else
            for (var we = ge.length, Ce = ee(ge, we), it = 0; it < we; ++it)
              Ce[it].call(Oe, Ue);
        }
        function k(ge, Ve, Oe, Ue, we) {
          if (Ve)
            ge.call(Oe, Ue, we);
          else
            for (var Ce = ge.length, it = ee(ge, Ce), ut = 0; ut < Ce; ++ut)
              it[ut].call(Oe, Ue, we);
        }
        function E(ge, Ve, Oe, Ue, we, Ce) {
          if (Ve)
            ge.call(Oe, Ue, we, Ce);
          else
            for (var it = ge.length, ut = ee(ge, it), bt = 0; bt < it; ++bt)
              ut[bt].call(Oe, Ue, we, Ce);
        }
        function P(ge, Ve, Oe, Ue) {
          if (Ve)
            ge.apply(Oe, Ue);
          else
            for (var we = ge.length, Ce = ee(ge, we), it = 0; it < we; ++it)
              Ce[it].apply(Oe, Ue);
        }
        Z.prototype.emit = function(Ve) {
          var Oe, Ue, we, Ce, it, ut, bt = Ve === "error";
          if (ut = this._events, ut)
            bt = bt && ut.error == null;
          else if (!bt)
            return !1;
          if (bt) {
            if (arguments.length > 1 && (Oe = arguments[1]), Oe instanceof Error)
              throw Oe;
            var pt = new Error('Unhandled "error" event. (' + Oe + ")");
            throw pt.context = Oe, pt;
          }
          if (Ue = ut[Ve], !Ue)
            return !1;
          var Ke = typeof Ue == "function";
          switch (we = arguments.length, we) {
            // fast cases
            case 1:
              m(Ue, Ke, this);
              break;
            case 2:
              w(Ue, Ke, this, arguments[1]);
              break;
            case 3:
              k(Ue, Ke, this, arguments[1], arguments[2]);
              break;
            case 4:
              E(Ue, Ke, this, arguments[1], arguments[2], arguments[3]);
              break;
            // slower
            default:
              for (Ce = new Array(we - 1), it = 1; it < we; it++)
                Ce[it - 1] = arguments[it];
              P(Ue, Ke, this, Ce);
          }
          return !0;
        };
        function S(ge, Ve, Oe, Ue) {
          var we, Ce, it;
          if (typeof Oe != "function")
            throw new TypeError('"listener" argument must be a function');
          if (Ce = ge._events, Ce ? (Ce.newListener && (ge.emit(
            "newListener",
            Ve,
            Oe.listener ? Oe.listener : Oe
          ), Ce = ge._events), it = Ce[Ve]) : (Ce = ge._events = ie(null), ge._eventsCount = 0), !it)
            it = Ce[Ve] = Oe, ++ge._eventsCount;
          else if (typeof it == "function" ? it = Ce[Ve] = Ue ? [Oe, it] : [it, Oe] : Ue ? it.unshift(Oe) : it.push(Oe), !it.warned && (we = x(ge), we && we > 0 && it.length > we)) {
            it.warned = !0;
            var ut = new Error("Possible EventEmitter memory leak detected. " + it.length + ' "' + String(Ve) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
            ut.name = "MaxListenersExceededWarning", ut.emitter = ge, ut.type = Ve, ut.count = it.length, typeof console == "object" && console.warn && console.warn("%s: %s", ut.name, ut.message);
          }
          return ge;
        }
        Z.prototype.addListener = function(Ve, Oe) {
          return S(this, Ve, Oe, !1);
        }, Z.prototype.on = Z.prototype.addListener, Z.prototype.prependListener = function(Ve, Oe) {
          return S(this, Ve, Oe, !0);
        };
        function U() {
          if (!this.fired)
            switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length) {
              case 0:
                return this.listener.call(this.target);
              case 1:
                return this.listener.call(this.target, arguments[0]);
              case 2:
                return this.listener.call(this.target, arguments[0], arguments[1]);
              case 3:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1],
                  arguments[2]
                );
              default:
                for (var ge = new Array(arguments.length), Ve = 0; Ve < ge.length; ++Ve)
                  ge[Ve] = arguments[Ve];
                this.listener.apply(this.target, ge);
            }
        }
        function j(ge, Ve, Oe) {
          var Ue = { fired: !1, wrapFn: void 0, target: ge, type: Ve, listener: Oe }, we = N.call(U, Ue);
          return we.listener = Oe, Ue.wrapFn = we, we;
        }
        Z.prototype.once = function(Ve, Oe) {
          if (typeof Oe != "function")
            throw new TypeError('"listener" argument must be a function');
          return this.on(Ve, j(this, Ve, Oe)), this;
        }, Z.prototype.prependOnceListener = function(Ve, Oe) {
          if (typeof Oe != "function")
            throw new TypeError('"listener" argument must be a function');
          return this.prependListener(Ve, j(this, Ve, Oe)), this;
        }, Z.prototype.removeListener = function(Ve, Oe) {
          var Ue, we, Ce, it, ut;
          if (typeof Oe != "function")
            throw new TypeError('"listener" argument must be a function');
          if (we = this._events, !we)
            return this;
          if (Ue = we[Ve], !Ue)
            return this;
          if (Ue === Oe || Ue.listener === Oe)
            --this._eventsCount === 0 ? this._events = ie(null) : (delete we[Ve], we.removeListener && this.emit("removeListener", Ve, Ue.listener || Oe));
          else if (typeof Ue != "function") {
            for (Ce = -1, it = Ue.length - 1; it >= 0; it--)
              if (Ue[it] === Oe || Ue[it].listener === Oe) {
                ut = Ue[it].listener, Ce = it;
                break;
              }
            if (Ce < 0)
              return this;
            Ce === 0 ? Ue.shift() : J(Ue, Ce), Ue.length === 1 && (we[Ve] = Ue[0]), we.removeListener && this.emit("removeListener", Ve, ut || Oe);
          }
          return this;
        }, Z.prototype.removeAllListeners = function(Ve) {
          var Oe, Ue, we;
          if (Ue = this._events, !Ue)
            return this;
          if (!Ue.removeListener)
            return arguments.length === 0 ? (this._events = ie(null), this._eventsCount = 0) : Ue[Ve] && (--this._eventsCount === 0 ? this._events = ie(null) : delete Ue[Ve]), this;
          if (arguments.length === 0) {
            var Ce = i(Ue), it;
            for (we = 0; we < Ce.length; ++we)
              it = Ce[we], it !== "removeListener" && this.removeAllListeners(it);
            return this.removeAllListeners("removeListener"), this._events = ie(null), this._eventsCount = 0, this;
          }
          if (Oe = Ue[Ve], typeof Oe == "function")
            this.removeListener(Ve, Oe);
          else if (Oe)
            for (we = Oe.length - 1; we >= 0; we--)
              this.removeListener(Ve, Oe[we]);
          return this;
        };
        function T(ge, Ve, Oe) {
          var Ue = ge._events;
          if (!Ue)
            return [];
          var we = Ue[Ve];
          return we ? typeof we == "function" ? Oe ? [we.listener || we] : [we] : Oe ? te(we) : ee(we, we.length) : [];
        }
        Z.prototype.listeners = function(Ve) {
          return T(this, Ve, !0);
        }, Z.prototype.rawListeners = function(Ve) {
          return T(this, Ve, !1);
        }, Z.listenerCount = function(ge, Ve) {
          return typeof ge.listenerCount == "function" ? ge.listenerCount(Ve) : W.call(ge, Ve);
        }, Z.prototype.listenerCount = W;
        function W(ge) {
          var Ve = this._events;
          if (Ve) {
            var Oe = Ve[ge];
            if (typeof Oe == "function")
              return 1;
            if (Oe)
              return Oe.length;
          }
          return 0;
        }
        Z.prototype.eventNames = function() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };
        function J(ge, Ve) {
          for (var Oe = Ve, Ue = Oe + 1, we = ge.length; Ue < we; Oe += 1, Ue += 1)
            ge[Oe] = ge[Ue];
          ge.pop();
        }
        function ee(ge, Ve) {
          for (var Oe = new Array(Ve), Ue = 0; Ue < Ve; ++Ue)
            Oe[Ue] = ge[Ue];
          return Oe;
        }
        function te(ge) {
          for (var Ve = new Array(ge.length), Oe = 0; Oe < Ve.length; ++Oe)
            Ve[Oe] = ge[Oe].listener || ge[Oe];
          return Ve;
        }
        function le(ge) {
          var Ve = function() {
          };
          return Ve.prototype = ge, new Ve();
        }
        function me(ge) {
          for (var Ve in ge) Object.prototype.hasOwnProperty.call(ge, Ve);
          return Ve;
        }
        function ke(ge) {
          var Ve = this;
          return function() {
            return Ve.apply(ge, arguments);
          };
        }
      }, {}], 53: [function(Q, de, q) {
        var ie = Q("./lib/parser");
        function i() {
          return (0, eval)("this");
        }
        de.exports = {
          create: function(N, Z) {
            if (Z = Z || i(), N instanceof Z.ArrayBuffer) {
              var R = Q("./lib/dom-bufferstream");
              return new ie(new R(N, 0, N.byteLength, !0, Z));
            } else {
              var A = Q("./lib/bufferstream");
              return new ie(new A(N, 0, N.length, !0));
            }
          }
        };
      }, { "./lib/bufferstream": 54, "./lib/dom-bufferstream": 56, "./lib/parser": 60 }], 54: [function(Q, de, q) {
        function ie(i, N, Z, R) {
          this.buffer = i, this.offset = N || 0, Z = typeof Z == "number" ? Z : i.length, this.endPosition = this.offset + Z, this.setBigEndian(R);
        }
        ie.prototype = {
          setBigEndian: function(i) {
            this.bigEndian = !!i;
          },
          nextUInt8: function() {
            var i = this.buffer.readUInt8(this.offset);
            return this.offset += 1, i;
          },
          nextInt8: function() {
            var i = this.buffer.readInt8(this.offset);
            return this.offset += 1, i;
          },
          nextUInt16: function() {
            var i = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
            return this.offset += 2, i;
          },
          nextUInt32: function() {
            var i = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
            return this.offset += 4, i;
          },
          nextInt16: function() {
            var i = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
            return this.offset += 2, i;
          },
          nextInt32: function() {
            var i = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
            return this.offset += 4, i;
          },
          nextFloat: function() {
            var i = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
            return this.offset += 4, i;
          },
          nextDouble: function() {
            var i = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
            return this.offset += 8, i;
          },
          nextBuffer: function(i) {
            var N = this.buffer.slice(this.offset, this.offset + i);
            return this.offset += i, N;
          },
          remainingLength: function() {
            return this.endPosition - this.offset;
          },
          nextString: function(i) {
            var N = this.buffer.toString("utf8", this.offset, this.offset + i);
            return this.offset += i, N;
          },
          mark: function() {
            var i = this;
            return {
              openWithOffset: function(N) {
                return N = (N || 0) + this.offset, new ie(i.buffer, N, i.endPosition - N, i.bigEndian);
              },
              offset: this.offset
            };
          },
          offsetFrom: function(i) {
            return this.offset - i.offset;
          },
          skip: function(i) {
            this.offset += i;
          },
          branch: function(i, N) {
            return N = typeof N == "number" ? N : this.endPosition - (this.offset + i), new ie(this.buffer, this.offset + i, N, this.bigEndian);
          }
        }, de.exports = ie;
      }, {}], 55: [function(Q, de, q) {
        function ie(x) {
          return parseInt(x, 10);
        }
        var i = 3600, N = 60;
        function Z(x, m) {
          x = x.map(ie), m = m.map(ie);
          var w = x[0], k = x[1] - 1, E = x[2], P = m[0], S = m[1], U = m[2], j = Date.UTC(w, k, E, P, S, U, 0), T = j / 1e3;
          return T;
        }
        function R(x) {
          var m = x.substr(0, 10).split("-"), w = x.substr(11, 8).split(":"), k = x.substr(19, 6), E = k.split(":").map(ie), P = E[0] * i + E[1] * N, S = Z(m, w);
          if (S -= P, typeof S == "number" && !isNaN(S))
            return S;
        }
        function A(x) {
          var m = x.split(" "), w = m[0].split(":"), k = m[1].split(":"), E = Z(w, k);
          if (typeof E == "number" && !isNaN(E))
            return E;
        }
        function M(x) {
          var m = x.length === 19 && x.charAt(4) === ":", w = x.length === 25 && x.charAt(10) === "T";
          if (w)
            return R(x);
          if (m)
            return A(x);
        }
        de.exports = {
          parseDateWithSpecFormat: A,
          parseDateWithTimezoneFormat: R,
          parseExifDate: M
        };
      }, {}], 56: [function(Q, de, q) {
        function ie(i, N, Z, R, A, M) {
          this.global = A, N = N || 0, Z = Z || i.byteLength - N, this.arrayBuffer = i.slice(N, N + Z), this.view = new A.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength), this.setBigEndian(R), this.offset = 0, this.parentOffset = (M || 0) + N;
        }
        ie.prototype = {
          setBigEndian: function(i) {
            this.littleEndian = !i;
          },
          nextUInt8: function() {
            var i = this.view.getUint8(this.offset);
            return this.offset += 1, i;
          },
          nextInt8: function() {
            var i = this.view.getInt8(this.offset);
            return this.offset += 1, i;
          },
          nextUInt16: function() {
            var i = this.view.getUint16(this.offset, this.littleEndian);
            return this.offset += 2, i;
          },
          nextUInt32: function() {
            var i = this.view.getUint32(this.offset, this.littleEndian);
            return this.offset += 4, i;
          },
          nextInt16: function() {
            var i = this.view.getInt16(this.offset, this.littleEndian);
            return this.offset += 2, i;
          },
          nextInt32: function() {
            var i = this.view.getInt32(this.offset, this.littleEndian);
            return this.offset += 4, i;
          },
          nextFloat: function() {
            var i = this.view.getFloat32(this.offset, this.littleEndian);
            return this.offset += 4, i;
          },
          nextDouble: function() {
            var i = this.view.getFloat64(this.offset, this.littleEndian);
            return this.offset += 8, i;
          },
          nextBuffer: function(i) {
            var N = this.arrayBuffer.slice(this.offset, this.offset + i);
            return this.offset += i, N;
          },
          remainingLength: function() {
            return this.arrayBuffer.byteLength - this.offset;
          },
          nextString: function(i) {
            var N = this.arrayBuffer.slice(this.offset, this.offset + i);
            return N = String.fromCharCode.apply(null, new this.global.Uint8Array(N)), this.offset += i, N;
          },
          mark: function() {
            var i = this;
            return {
              openWithOffset: function(N) {
                return N = (N || 0) + this.offset, new ie(i.arrayBuffer, N, i.arrayBuffer.byteLength - N, !i.littleEndian, i.global, i.parentOffset);
              },
              offset: this.offset,
              getParentOffset: function() {
                return i.parentOffset;
              }
            };
          },
          offsetFrom: function(i) {
            return this.parentOffset + this.offset - (i.offset + i.getParentOffset());
          },
          skip: function(i) {
            this.offset += i;
          },
          branch: function(i, N) {
            return N = typeof N == "number" ? N : this.arrayBuffer.byteLength - (this.offset + i), new ie(this.arrayBuffer, this.offset + i, N, !this.littleEndian, this.global, this.parentOffset);
          }
        }, de.exports = ie;
      }, {}], 57: [function(Q, de, q) {
        de.exports = {
          exif: {
            1: "InteropIndex",
            2: "InteropVersion",
            11: "ProcessingSoftware",
            254: "SubfileType",
            255: "OldSubfileType",
            256: "ImageWidth",
            257: "ImageHeight",
            258: "BitsPerSample",
            259: "Compression",
            262: "PhotometricInterpretation",
            263: "Thresholding",
            264: "CellWidth",
            265: "CellLength",
            266: "FillOrder",
            269: "DocumentName",
            270: "ImageDescription",
            271: "Make",
            272: "Model",
            273: "StripOffsets",
            274: "Orientation",
            277: "SamplesPerPixel",
            278: "RowsPerStrip",
            279: "StripByteCounts",
            280: "MinSampleValue",
            281: "MaxSampleValue",
            282: "XResolution",
            283: "YResolution",
            284: "PlanarConfiguration",
            285: "PageName",
            286: "XPosition",
            287: "YPosition",
            288: "FreeOffsets",
            289: "FreeByteCounts",
            290: "GrayResponseUnit",
            291: "GrayResponseCurve",
            292: "T4Options",
            293: "T6Options",
            296: "ResolutionUnit",
            297: "PageNumber",
            300: "ColorResponseUnit",
            301: "TransferFunction",
            305: "Software",
            306: "ModifyDate",
            315: "Artist",
            316: "HostComputer",
            317: "Predictor",
            318: "WhitePoint",
            319: "PrimaryChromaticities",
            320: "ColorMap",
            321: "HalftoneHints",
            322: "TileWidth",
            323: "TileLength",
            324: "TileOffsets",
            325: "TileByteCounts",
            326: "BadFaxLines",
            327: "CleanFaxData",
            328: "ConsecutiveBadFaxLines",
            330: "SubIFD",
            332: "InkSet",
            333: "InkNames",
            334: "NumberofInks",
            336: "DotRange",
            337: "TargetPrinter",
            338: "ExtraSamples",
            339: "SampleFormat",
            340: "SMinSampleValue",
            341: "SMaxSampleValue",
            342: "TransferRange",
            343: "ClipPath",
            344: "XClipPathUnits",
            345: "YClipPathUnits",
            346: "Indexed",
            347: "JPEGTables",
            351: "OPIProxy",
            400: "GlobalParametersIFD",
            401: "ProfileType",
            402: "FaxProfile",
            403: "CodingMethods",
            404: "VersionYear",
            405: "ModeNumber",
            433: "Decode",
            434: "DefaultImageColor",
            435: "T82Options",
            437: "JPEGTables",
            512: "JPEGProc",
            513: "ThumbnailOffset",
            514: "ThumbnailLength",
            515: "JPEGRestartInterval",
            517: "JPEGLosslessPredictors",
            518: "JPEGPointTransforms",
            519: "JPEGQTables",
            520: "JPEGDCTables",
            521: "JPEGACTables",
            529: "YCbCrCoefficients",
            530: "YCbCrSubSampling",
            531: "YCbCrPositioning",
            532: "ReferenceBlackWhite",
            559: "StripRowCounts",
            700: "ApplicationNotes",
            999: "USPTOMiscellaneous",
            4096: "RelatedImageFileFormat",
            4097: "RelatedImageWidth",
            4098: "RelatedImageHeight",
            18246: "Rating",
            18247: "XP_DIP_XML",
            18248: "StitchInfo",
            18249: "RatingPercent",
            32781: "ImageID",
            32931: "WangTag1",
            32932: "WangAnnotation",
            32933: "WangTag3",
            32934: "WangTag4",
            32995: "Matteing",
            32996: "DataType",
            32997: "ImageDepth",
            32998: "TileDepth",
            33405: "Model2",
            33421: "CFARepeatPatternDim",
            33422: "CFAPattern2",
            33423: "BatteryLevel",
            33424: "KodakIFD",
            33432: "Copyright",
            33434: "ExposureTime",
            33437: "FNumber",
            33445: "MDFileTag",
            33446: "MDScalePixel",
            33447: "MDColorTable",
            33448: "MDLabName",
            33449: "MDSampleInfo",
            33450: "MDPrepDate",
            33451: "MDPrepTime",
            33452: "MDFileUnits",
            33550: "PixelScale",
            33589: "AdventScale",
            33590: "AdventRevision",
            33628: "UIC1Tag",
            33629: "UIC2Tag",
            33630: "UIC3Tag",
            33631: "UIC4Tag",
            33723: "IPTC-NAA",
            33918: "IntergraphPacketData",
            33919: "IntergraphFlagRegisters",
            33920: "IntergraphMatrix",
            33921: "INGRReserved",
            33922: "ModelTiePoint",
            34016: "Site",
            34017: "ColorSequence",
            34018: "IT8Header",
            34019: "RasterPadding",
            34020: "BitsPerRunLength",
            34021: "BitsPerExtendedRunLength",
            34022: "ColorTable",
            34023: "ImageColorIndicator",
            34024: "BackgroundColorIndicator",
            34025: "ImageColorValue",
            34026: "BackgroundColorValue",
            34027: "PixelIntensityRange",
            34028: "TransparencyIndicator",
            34029: "ColorCharacterization",
            34030: "HCUsage",
            34031: "TrapIndicator",
            34032: "CMYKEquivalent",
            34118: "SEMInfo",
            34152: "AFCP_IPTC",
            34232: "PixelMagicJBIGOptions",
            34264: "ModelTransform",
            34306: "WB_GRGBLevels",
            34310: "LeafData",
            34377: "PhotoshopSettings",
            34665: "ExifOffset",
            34675: "ICC_Profile",
            34687: "TIFF_FXExtensions",
            34688: "MultiProfiles",
            34689: "SharedData",
            34690: "T88Options",
            34732: "ImageLayer",
            34735: "GeoTiffDirectory",
            34736: "GeoTiffDoubleParams",
            34737: "GeoTiffAsciiParams",
            34850: "ExposureProgram",
            34852: "SpectralSensitivity",
            34853: "GPSInfo",
            34855: "ISO",
            34856: "Opto-ElectricConvFactor",
            34857: "Interlace",
            34858: "TimeZoneOffset",
            34859: "SelfTimerMode",
            34864: "SensitivityType",
            34865: "StandardOutputSensitivity",
            34866: "RecommendedExposureIndex",
            34867: "ISOSpeed",
            34868: "ISOSpeedLatitudeyyy",
            34869: "ISOSpeedLatitudezzz",
            34908: "FaxRecvParams",
            34909: "FaxSubAddress",
            34910: "FaxRecvTime",
            34954: "LeafSubIFD",
            36864: "ExifVersion",
            36867: "DateTimeOriginal",
            36868: "CreateDate",
            37121: "ComponentsConfiguration",
            37122: "CompressedBitsPerPixel",
            37377: "ShutterSpeedValue",
            37378: "ApertureValue",
            37379: "BrightnessValue",
            37380: "ExposureCompensation",
            37381: "MaxApertureValue",
            37382: "SubjectDistance",
            37383: "MeteringMode",
            37384: "LightSource",
            37385: "Flash",
            37386: "FocalLength",
            37387: "FlashEnergy",
            37388: "SpatialFrequencyResponse",
            37389: "Noise",
            37390: "FocalPlaneXResolution",
            37391: "FocalPlaneYResolution",
            37392: "FocalPlaneResolutionUnit",
            37393: "ImageNumber",
            37394: "SecurityClassification",
            37395: "ImageHistory",
            37396: "SubjectArea",
            37397: "ExposureIndex",
            37398: "TIFF-EPStandardID",
            37399: "SensingMethod",
            37434: "CIP3DataFile",
            37435: "CIP3Sheet",
            37436: "CIP3Side",
            37439: "StoNits",
            37500: "MakerNote",
            37510: "UserComment",
            37520: "SubSecTime",
            37521: "SubSecTimeOriginal",
            37522: "SubSecTimeDigitized",
            37679: "MSDocumentText",
            37680: "MSPropertySetStorage",
            37681: "MSDocumentTextPosition",
            37724: "ImageSourceData",
            40091: "XPTitle",
            40092: "XPComment",
            40093: "XPAuthor",
            40094: "XPKeywords",
            40095: "XPSubject",
            40960: "FlashpixVersion",
            40961: "ColorSpace",
            40962: "ExifImageWidth",
            40963: "ExifImageHeight",
            40964: "RelatedSoundFile",
            40965: "InteropOffset",
            41483: "FlashEnergy",
            41484: "SpatialFrequencyResponse",
            41485: "Noise",
            41486: "FocalPlaneXResolution",
            41487: "FocalPlaneYResolution",
            41488: "FocalPlaneResolutionUnit",
            41489: "ImageNumber",
            41490: "SecurityClassification",
            41491: "ImageHistory",
            41492: "SubjectLocation",
            41493: "ExposureIndex",
            41494: "TIFF-EPStandardID",
            41495: "SensingMethod",
            41728: "FileSource",
            41729: "SceneType",
            41730: "CFAPattern",
            41985: "CustomRendered",
            41986: "ExposureMode",
            41987: "WhiteBalance",
            41988: "DigitalZoomRatio",
            41989: "FocalLengthIn35mmFormat",
            41990: "SceneCaptureType",
            41991: "GainControl",
            41992: "Contrast",
            41993: "Saturation",
            41994: "Sharpness",
            41995: "DeviceSettingDescription",
            41996: "SubjectDistanceRange",
            42016: "ImageUniqueID",
            42032: "OwnerName",
            42033: "SerialNumber",
            42034: "LensInfo",
            42035: "LensMake",
            42036: "LensModel",
            42037: "LensSerialNumber",
            42112: "GDALMetadata",
            42113: "GDALNoData",
            42240: "Gamma",
            44992: "ExpandSoftware",
            44993: "ExpandLens",
            44994: "ExpandFilm",
            44995: "ExpandFilterLens",
            44996: "ExpandScanner",
            44997: "ExpandFlashLamp",
            48129: "PixelFormat",
            48130: "Transformation",
            48131: "Uncompressed",
            48132: "ImageType",
            48256: "ImageWidth",
            48257: "ImageHeight",
            48258: "WidthResolution",
            48259: "HeightResolution",
            48320: "ImageOffset",
            48321: "ImageByteCount",
            48322: "AlphaOffset",
            48323: "AlphaByteCount",
            48324: "ImageDataDiscard",
            48325: "AlphaDataDiscard",
            50215: "OceScanjobDesc",
            50216: "OceApplicationSelector",
            50217: "OceIDNumber",
            50218: "OceImageLogic",
            50255: "Annotations",
            50341: "PrintIM",
            50560: "USPTOOriginalContentType",
            50706: "DNGVersion",
            50707: "DNGBackwardVersion",
            50708: "UniqueCameraModel",
            50709: "LocalizedCameraModel",
            50710: "CFAPlaneColor",
            50711: "CFALayout",
            50712: "LinearizationTable",
            50713: "BlackLevelRepeatDim",
            50714: "BlackLevel",
            50715: "BlackLevelDeltaH",
            50716: "BlackLevelDeltaV",
            50717: "WhiteLevel",
            50718: "DefaultScale",
            50719: "DefaultCropOrigin",
            50720: "DefaultCropSize",
            50721: "ColorMatrix1",
            50722: "ColorMatrix2",
            50723: "CameraCalibration1",
            50724: "CameraCalibration2",
            50725: "ReductionMatrix1",
            50726: "ReductionMatrix2",
            50727: "AnalogBalance",
            50728: "AsShotNeutral",
            50729: "AsShotWhiteXY",
            50730: "BaselineExposure",
            50731: "BaselineNoise",
            50732: "BaselineSharpness",
            50733: "BayerGreenSplit",
            50734: "LinearResponseLimit",
            50735: "CameraSerialNumber",
            50736: "DNGLensInfo",
            50737: "ChromaBlurRadius",
            50738: "AntiAliasStrength",
            50739: "ShadowScale",
            50740: "DNGPrivateData",
            50741: "MakerNoteSafety",
            50752: "RawImageSegmentation",
            50778: "CalibrationIlluminant1",
            50779: "CalibrationIlluminant2",
            50780: "BestQualityScale",
            50781: "RawDataUniqueID",
            50784: "AliasLayerMetadata",
            50827: "OriginalRawFileName",
            50828: "OriginalRawFileData",
            50829: "ActiveArea",
            50830: "MaskedAreas",
            50831: "AsShotICCProfile",
            50832: "AsShotPreProfileMatrix",
            50833: "CurrentICCProfile",
            50834: "CurrentPreProfileMatrix",
            50879: "ColorimetricReference",
            50898: "PanasonicTitle",
            50899: "PanasonicTitle2",
            50931: "CameraCalibrationSig",
            50932: "ProfileCalibrationSig",
            50933: "ProfileIFD",
            50934: "AsShotProfileName",
            50935: "NoiseReductionApplied",
            50936: "ProfileName",
            50937: "ProfileHueSatMapDims",
            50938: "ProfileHueSatMapData1",
            50939: "ProfileHueSatMapData2",
            50940: "ProfileToneCurve",
            50941: "ProfileEmbedPolicy",
            50942: "ProfileCopyright",
            50964: "ForwardMatrix1",
            50965: "ForwardMatrix2",
            50966: "PreviewApplicationName",
            50967: "PreviewApplicationVersion",
            50968: "PreviewSettingsName",
            50969: "PreviewSettingsDigest",
            50970: "PreviewColorSpace",
            50971: "PreviewDateTime",
            50972: "RawImageDigest",
            50973: "OriginalRawFileDigest",
            50974: "SubTileBlockSize",
            50975: "RowInterleaveFactor",
            50981: "ProfileLookTableDims",
            50982: "ProfileLookTableData",
            51008: "OpcodeList1",
            51009: "OpcodeList2",
            51022: "OpcodeList3",
            51041: "NoiseProfile",
            51043: "TimeCodes",
            51044: "FrameRate",
            51058: "TStop",
            51081: "ReelName",
            51089: "OriginalDefaultFinalSize",
            51090: "OriginalBestQualitySize",
            51091: "OriginalDefaultCropSize",
            51105: "CameraLabel",
            51107: "ProfileHueSatMapEncoding",
            51108: "ProfileLookTableEncoding",
            51109: "BaselineExposureOffset",
            51110: "DefaultBlackRender",
            51111: "NewRawImageDigest",
            51112: "RawToPreviewGain",
            51125: "DefaultUserCrop",
            59932: "Padding",
            59933: "OffsetSchema",
            65e3: "OwnerName",
            65001: "SerialNumber",
            65002: "Lens",
            65024: "KDC_IFD",
            65100: "RawFile",
            65101: "Converter",
            65102: "WhiteBalance",
            65105: "Exposure",
            65106: "Shadows",
            65107: "Brightness",
            65108: "Contrast",
            65109: "Saturation",
            65110: "Sharpness",
            65111: "Smoothness",
            65112: "MoireFilter"
          },
          gps: {
            0: "GPSVersionID",
            1: "GPSLatitudeRef",
            2: "GPSLatitude",
            3: "GPSLongitudeRef",
            4: "GPSLongitude",
            5: "GPSAltitudeRef",
            6: "GPSAltitude",
            7: "GPSTimeStamp",
            8: "GPSSatellites",
            9: "GPSStatus",
            10: "GPSMeasureMode",
            11: "GPSDOP",
            12: "GPSSpeedRef",
            13: "GPSSpeed",
            14: "GPSTrackRef",
            15: "GPSTrack",
            16: "GPSImgDirectionRef",
            17: "GPSImgDirection",
            18: "GPSMapDatum",
            19: "GPSDestLatitudeRef",
            20: "GPSDestLatitude",
            21: "GPSDestLongitudeRef",
            22: "GPSDestLongitude",
            23: "GPSDestBearingRef",
            24: "GPSDestBearing",
            25: "GPSDestDistanceRef",
            26: "GPSDestDistance",
            27: "GPSProcessingMethod",
            28: "GPSAreaInformation",
            29: "GPSDateStamp",
            30: "GPSDifferential",
            31: "GPSHPositioningError"
          }
        };
      }, {}], 58: [function(Q, de, q) {
        function ie(A, M) {
          switch (A) {
            case 1:
              return M.nextUInt8();
            case 3:
              return M.nextUInt16();
            case 4:
              return M.nextUInt32();
            case 5:
              return [M.nextUInt32(), M.nextUInt32()];
            case 6:
              return M.nextInt8();
            case 8:
              return M.nextUInt16();
            case 9:
              return M.nextUInt32();
            case 10:
              return [M.nextInt32(), M.nextInt32()];
            case 11:
              return M.nextFloat();
            case 12:
              return M.nextDouble();
            default:
              throw new Error("Invalid format while decoding: " + A);
          }
        }
        function i(A) {
          switch (A) {
            case 1:
            case 2:
            case 6:
            case 7:
              return 1;
            case 3:
            case 8:
              return 2;
            case 4:
            case 9:
            case 11:
              return 4;
            case 5:
            case 10:
            case 12:
              return 8;
            default:
              return 0;
          }
        }
        function N(A, M) {
          var x = M.nextUInt16(), m = M.nextUInt16(), w = i(m), k = M.nextUInt32(), E = w * k, P, S;
          if (E > 4 && (M = A.openWithOffset(M.nextUInt32())), m === 2) {
            P = M.nextString(k);
            var U = P.indexOf("\0");
            U !== -1 && (P = P.substr(0, U));
          } else if (m === 7)
            P = M.nextBuffer(k);
          else if (m !== 0)
            for (P = [], S = 0; S < k; ++S)
              P.push(ie(m, M));
          return E < 4 && M.skip(4 - E), [x, P, m];
        }
        function Z(A, M, x) {
          var m = M.nextUInt16(), w, k;
          for (k = 0; k < m; ++k)
            w = N(A, M), x(w[0], w[1], w[2]);
        }
        function R(A) {
          var M = A.nextString(6);
          if (M !== "Exif\0\0")
            throw new Error("Invalid EXIF header");
          var x = A.mark(), m = A.nextUInt16();
          if (m === 18761)
            A.setBigEndian(!1);
          else if (m === 19789)
            A.setBigEndian(!0);
          else
            throw new Error("Invalid TIFF header");
          if (A.nextUInt16() !== 42)
            throw new Error("Invalid TIFF data");
          return x;
        }
        de.exports = {
          IFD0: 1,
          IFD1: 2,
          GPSIFD: 3,
          SubIFD: 4,
          InteropIFD: 5,
          parseTags: function(A, M) {
            var x;
            try {
              x = R(A);
            } catch {
              return !1;
            }
            var m, w, k, E = x.openWithOffset(A.nextUInt32()), P = this.IFD0;
            Z(x, E, function(ee, te, le) {
              switch (ee) {
                case 34853:
                  w = te[0];
                  break;
                case 34665:
                  m = te[0];
                  break;
                default:
                  M(P, ee, te, le);
                  break;
              }
            });
            var S = E.nextUInt32();
            if (S !== 0) {
              var U = x.openWithOffset(S);
              Z(x, U, M.bind(null, this.IFD1));
            }
            if (w) {
              var j = x.openWithOffset(w);
              Z(x, j, M.bind(null, this.GPSIFD));
            }
            if (m) {
              var T = x.openWithOffset(m), W = this.InteropIFD;
              Z(x, T, function(ee, te, le) {
                ee === 40965 ? k = te[0] : M(W, ee, te, le);
              });
            }
            if (k) {
              var J = x.openWithOffset(k);
              Z(x, J, M.bind(null, this.InteropIFD));
            }
            return !0;
          }
        };
      }, {}], 59: [function(Q, de, q) {
        de.exports = {
          parseSections: function(ie, i) {
            var N, Z;
            for (ie.setBigEndian(!0); ie.remainingLength() > 0 && Z !== 218; ) {
              if (ie.nextUInt8() !== 255)
                throw new Error("Invalid JPEG section offset");
              Z = ie.nextUInt8(), Z >= 208 && Z <= 217 || Z === 218 ? N = 0 : N = ie.nextUInt16() - 2, i(Z, ie.branch(0, N)), ie.skip(N);
            }
          },
          //stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator
          getSizeFromSOFSection: function(ie) {
            return ie.skip(1), {
              height: ie.nextUInt16(),
              width: ie.nextUInt16()
            };
          },
          getSectionName: function(ie) {
            var i, N;
            switch (ie) {
              case 216:
                i = "SOI";
                break;
              case 196:
                i = "DHT";
                break;
              case 219:
                i = "DQT";
                break;
              case 221:
                i = "DRI";
                break;
              case 218:
                i = "SOS";
                break;
              case 254:
                i = "COM";
                break;
              case 217:
                i = "EOI";
                break;
              default:
                ie >= 224 && ie <= 239 ? (i = "APP", N = ie - 224) : ie >= 192 && ie <= 207 && ie !== 196 && ie !== 200 && ie !== 204 ? (i = "SOF", N = ie - 192) : ie >= 208 && ie <= 215 && (i = "RST", N = ie - 208);
                break;
            }
            var Z = {
              name: i
            };
            return typeof N == "number" && (Z.index = N), Z;
          }
        };
      }, {}], 60: [function(Q, de, q) {
        var ie = Q("./jpeg"), i = Q("./exif"), N = Q("./simplify");
        function Z(A, M, x, m, w, k, E) {
          this.startMarker = A, this.tags = M, this.imageSize = x, this.thumbnailOffset = m, this.thumbnailLength = w, this.thumbnailType = k, this.app1Offset = E;
        }
        Z.prototype = {
          hasThumbnail: function(A) {
            return !this.thumbnailOffset || !this.thumbnailLength ? !1 : typeof A != "string" ? !0 : A.toLowerCase().trim() === "image/jpeg" ? this.thumbnailType === 6 : A.toLowerCase().trim() === "image/tiff" ? this.thumbnailType === 1 : !1;
          },
          getThumbnailOffset: function() {
            return this.app1Offset + 6 + this.thumbnailOffset;
          },
          getThumbnailLength: function() {
            return this.thumbnailLength;
          },
          getThumbnailBuffer: function() {
            return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
          },
          _getThumbnailStream: function() {
            return this.startMarker.openWithOffset(this.getThumbnailOffset());
          },
          getImageSize: function() {
            return this.imageSize;
          },
          getThumbnailSize: function() {
            var A = this._getThumbnailStream(), M;
            return ie.parseSections(A, function(x, m) {
              ie.getSectionName(x).name === "SOF" && (M = ie.getSizeFromSOFSection(m));
            }), M;
          }
        };
        function R(A) {
          this.stream = A, this.flags = {
            readBinaryTags: !1,
            resolveTagNames: !0,
            simplifyValues: !0,
            imageSize: !0,
            hidePointers: !0,
            returnTags: !0
          };
        }
        R.prototype = {
          enableBinaryFields: function(A) {
            return this.flags.readBinaryTags = !!A, this;
          },
          enablePointers: function(A) {
            return this.flags.hidePointers = !A, this;
          },
          enableTagNames: function(A) {
            return this.flags.resolveTagNames = !!A, this;
          },
          enableImageSize: function(A) {
            return this.flags.imageSize = !!A, this;
          },
          enableReturnTags: function(A) {
            return this.flags.returnTags = !!A, this;
          },
          enableSimpleValues: function(A) {
            return this.flags.simplifyValues = !!A, this;
          },
          parse: function() {
            var A = this.stream.mark(), M = A.openWithOffset(0), x = this.flags, m, w, k, E, P, S, U, j, T;
            return x.resolveTagNames && (U = Q("./exif-tags")), x.resolveTagNames ? (m = {}, j = function(W) {
              return m[W.name];
            }, T = function(W, J) {
              m[W.name] = J;
            }) : (m = [], j = function(W) {
              var J;
              for (J = 0; J < m.length; ++J)
                if (m[J].type === W.type && m[J].section === W.section)
                  return m.value;
            }, T = function(W, J) {
              var ee;
              for (ee = 0; ee < m.length; ++ee)
                if (m[ee].type === W.type && m[ee].section === W.section) {
                  m.value = J;
                  return;
                }
            }), ie.parseSections(M, function(W, J) {
              var ee, te = J.offsetFrom(A);
              W === 225 ? (ee = i.parseTags(J, function(le, me, ke, ge) {
                if (!(!x.readBinaryTags && ge === 7)) {
                  if (me === 513) {
                    if (k = ke[0], x.hidePointers)
                      return;
                  } else if (me === 514) {
                    if (E = ke[0], x.hidePointers)
                      return;
                  } else if (me === 259 && (P = ke[0], x.hidePointers))
                    return;
                  if (x.returnTags)
                    if (x.simplifyValues && (ke = N.simplifyValue(ke, ge)), x.resolveTagNames) {
                      var Ve = le === i.GPSIFD ? U.gps : U.exif, Oe = Ve[me];
                      Oe || (Oe = U.exif[me]), m.hasOwnProperty(Oe) || (m[Oe] = ke);
                    } else
                      m.push({
                        section: le,
                        type: me,
                        value: ke
                      });
                }
              }), ee && (S = te)) : x.imageSize && ie.getSectionName(W).name === "SOF" && (w = ie.getSizeFromSOFSection(J));
            }), x.simplifyValues && (N.castDegreeValues(j, T), N.castDateValues(j, T)), new Z(A, m, w, k, E, P, S);
          }
        }, de.exports = R;
      }, { "./exif": 58, "./exif-tags": 57, "./jpeg": 59, "./simplify": 61 }], 61: [function(Q, de, q) {
        var ie = Q("./exif"), i = Q("./date"), N = [
          {
            section: ie.GPSIFD,
            type: 2,
            name: "GPSLatitude",
            refType: 1,
            refName: "GPSLatitudeRef",
            posVal: "N"
          },
          {
            section: ie.GPSIFD,
            type: 4,
            name: "GPSLongitude",
            refType: 3,
            refName: "GPSLongitudeRef",
            posVal: "E"
          }
        ], Z = [
          {
            section: ie.SubIFD,
            type: 306,
            name: "ModifyDate"
          },
          {
            section: ie.SubIFD,
            type: 36867,
            name: "DateTimeOriginal"
          },
          {
            section: ie.SubIFD,
            type: 36868,
            name: "CreateDate"
          },
          {
            section: ie.SubIFD,
            type: 306,
            name: "ModifyDate"
          }
        ];
        de.exports = {
          castDegreeValues: function(R, A) {
            N.forEach(function(M) {
              var x = R(M);
              if (x) {
                var m = R({ section: M.section, type: M.refType, name: M.refName }), w = m === M.posVal ? 1 : -1, k = (x[0] + x[1] / 60 + x[2] / 3600) * w;
                A(M, k);
              }
            });
          },
          castDateValues: function(R, A) {
            Z.forEach(function(M) {
              var x = R(M);
              if (x) {
                var m = i.parseExifDate(x);
                typeof m < "u" && A(M, m);
              }
            });
          },
          simplifyValue: function(R, A) {
            return Array.isArray(R) && (R = R.map(function(M) {
              return A === 10 || A === 5 ? M[0] / M[1] : M;
            }), R.length === 1 && (R = R[0])), R;
          }
        };
      }, { "./date": 55, "./exif": 58 }], 62: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireDefault"), i = ie(Q("@babel/runtime/helpers/toConsumableArray")), N = function(x) {
          return (0, i.default)(x).map(function(m) {
            return m.charCodeAt(0);
          });
        }, Z = N("META-INF/mozilla.rsa"), R = N("[Content_Types].xml"), A = N("_rels/.rels");
        de.exports = function(M) {
          var x = M instanceof Uint8Array ? M : new Uint8Array(M);
          if (!(x && x.length > 1))
            return null;
          var m = function(le, me) {
            me = Object.assign({
              offset: 0
            }, me);
            for (var ke = 0; ke < le.length; ke++)
              if (me.mask) {
                if (le[ke] !== (me.mask[ke] & x[ke + me.offset]))
                  return !1;
              } else if (le[ke] !== x[ke + me.offset])
                return !1;
            return !0;
          }, w = function(le, me) {
            return m(N(le), me);
          };
          if (m([255, 216, 255]))
            return {
              ext: "jpg",
              mime: "image/jpeg"
            };
          if (m([137, 80, 78, 71, 13, 10, 26, 10]))
            return {
              ext: "png",
              mime: "image/png"
            };
          if (m([71, 73, 70]))
            return {
              ext: "gif",
              mime: "image/gif"
            };
          if (m([87, 69, 66, 80], {
            offset: 8
          }))
            return {
              ext: "webp",
              mime: "image/webp"
            };
          if (m([70, 76, 73, 70]))
            return {
              ext: "flif",
              mime: "image/flif"
            };
          if ((m([73, 73, 42, 0]) || m([77, 77, 0, 42])) && m([67, 82], {
            offset: 8
          }))
            return {
              ext: "cr2",
              mime: "image/x-canon-cr2"
            };
          if (m([73, 73, 42, 0]) || m([77, 77, 0, 42]))
            return {
              ext: "tif",
              mime: "image/tiff"
            };
          if (m([66, 77]))
            return {
              ext: "bmp",
              mime: "image/bmp"
            };
          if (m([73, 73, 188]))
            return {
              ext: "jxr",
              mime: "image/vnd.ms-photo"
            };
          if (m([56, 66, 80, 83]))
            return {
              ext: "psd",
              mime: "image/vnd.adobe.photoshop"
            };
          if (m([80, 75, 3, 4])) {
            if (m([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], {
              offset: 30
            }))
              return {
                ext: "epub",
                mime: "application/epub+zip"
              };
            if (m(Z, {
              offset: 30
            }))
              return {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
            if (w("mimetypeapplication/vnd.oasis.opendocument.text", {
              offset: 30
            }))
              return {
                ext: "odt",
                mime: "application/vnd.oasis.opendocument.text"
              };
            if (w("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", {
              offset: 30
            }))
              return {
                ext: "ods",
                mime: "application/vnd.oasis.opendocument.spreadsheet"
              };
            if (w("mimetypeapplication/vnd.oasis.opendocument.presentation", {
              offset: 30
            }))
              return {
                ext: "odp",
                mime: "application/vnd.oasis.opendocument.presentation"
              };
            var k = function(le) {
              var me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              return le.findIndex(function(ke, ge, Ve) {
                return ge >= me && Ve[ge] === 80 && Ve[ge + 1] === 75 && Ve[ge + 2] === 3 && Ve[ge + 3] === 4;
              });
            }, E = 0, P = !1, S = null;
            do {
              var U = E + 30;
              if (P || (P = m(R, {
                offset: U
              }) || m(A, {
                offset: U
              })), S || (w("word/", {
                offset: U
              }) ? S = {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
              } : w("ppt/", {
                offset: U
              }) ? S = {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
              } : w("xl/", {
                offset: U
              }) && (S = {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              })), P && S)
                return S;
              E = k(x, U);
            } while (E >= 0);
            if (S)
              return S;
          }
          if (m([80, 75]) && (x[2] === 3 || x[2] === 5 || x[2] === 7) && (x[3] === 4 || x[3] === 6 || x[3] === 8))
            return {
              ext: "zip",
              mime: "application/zip"
            };
          if (m([117, 115, 116, 97, 114], {
            offset: 257
          }))
            return {
              ext: "tar",
              mime: "application/x-tar"
            };
          if (m([82, 97, 114, 33, 26, 7]) && (x[6] === 0 || x[6] === 1))
            return {
              ext: "rar",
              mime: "application/x-rar-compressed"
            };
          if (m([31, 139, 8]))
            return {
              ext: "gz",
              mime: "application/gzip"
            };
          if (m([66, 90, 104]))
            return {
              ext: "bz2",
              mime: "application/x-bzip2"
            };
          if (m([55, 122, 188, 175, 39, 28]))
            return {
              ext: "7z",
              mime: "application/x-7z-compressed"
            };
          if (m([120, 1]))
            return {
              ext: "dmg",
              mime: "application/x-apple-diskimage"
            };
          if (m([51, 103, 112, 53]) || // 3gp5
          m([0, 0, 0]) && m([102, 116, 121, 112], {
            offset: 4
          }) && (m([109, 112, 52, 49], {
            offset: 8
          }) || // MP41
          m([109, 112, 52, 50], {
            offset: 8
          }) || // MP42
          m([105, 115, 111, 109], {
            offset: 8
          }) || // ISOM
          m([105, 115, 111, 50], {
            offset: 8
          }) || // ISO2
          m([109, 109, 112, 52], {
            offset: 8
          }) || // MMP4
          m([77, 52, 86], {
            offset: 8
          }) || // M4V
          m([100, 97, 115, 104], {
            offset: 8
          })))
            return {
              ext: "mp4",
              mime: "video/mp4"
            };
          if (m([77, 84, 104, 100]))
            return {
              ext: "mid",
              mime: "audio/midi"
            };
          if (m([26, 69, 223, 163])) {
            var j = x.subarray(4, 4100), T = j.findIndex(function(te, le, me) {
              return me[le] === 66 && me[le + 1] === 130;
            });
            if (T !== -1) {
              var W = T + 3, J = function(le) {
                return (0, i.default)(le).every(function(me, ke) {
                  return j[W + ke] === me.charCodeAt(0);
                });
              };
              if (J("matroska"))
                return {
                  ext: "mkv",
                  mime: "video/x-matroska"
                };
              if (J("webm"))
                return {
                  ext: "webm",
                  mime: "video/webm"
                };
            }
          }
          if (m([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || m([102, 114, 101, 101], {
            offset: 4
          }) || m([102, 116, 121, 112, 113, 116, 32, 32], {
            offset: 4
          }) || m([109, 100, 97, 116], {
            offset: 4
          }) || // MJPEG
          m([119, 105, 100, 101], {
            offset: 4
          }))
            return {
              ext: "mov",
              mime: "video/quicktime"
            };
          if (m([82, 73, 70, 70])) {
            if (m([65, 86, 73], {
              offset: 8
            }))
              return {
                ext: "avi",
                mime: "video/vnd.avi"
              };
            if (m([87, 65, 86, 69], {
              offset: 8
            }))
              return {
                ext: "wav",
                mime: "audio/vnd.wave"
              };
            if (m([81, 76, 67, 77], {
              offset: 8
            }))
              return {
                ext: "qcp",
                mime: "audio/qcelp"
              };
          }
          if (m([48, 38, 178, 117, 142, 102, 207, 17, 166, 217]))
            return {
              ext: "wmv",
              mime: "video/x-ms-wmv"
            };
          if (m([0, 0, 1, 186]) || m([0, 0, 1, 179]))
            return {
              ext: "mpg",
              mime: "video/mpeg"
            };
          if (m([102, 116, 121, 112, 51, 103], {
            offset: 4
          }))
            return {
              ext: "3gp",
              mime: "video/3gpp"
            };
          for (var ee = 0; ee < 2 && ee < x.length - 16; ee++) {
            if (m([73, 68, 51], {
              offset: ee
            }) || // ID3 header
            m([255, 226], {
              offset: ee,
              mask: [255, 226]
            }))
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            if (m([255, 228], {
              offset: ee,
              mask: [255, 228]
            }))
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            if (m([255, 248], {
              offset: ee,
              mask: [255, 252]
            }))
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            if (m([255, 240], {
              offset: ee,
              mask: [255, 252]
            }))
              return {
                ext: "mp4",
                mime: "audio/mpeg"
              };
          }
          if (m([102, 116, 121, 112, 77, 52, 65], {
            offset: 4
          }) || m([77, 52, 65, 32]))
            return {
              // MPEG-4 layer 3 (audio)
              ext: "m4a",
              mime: "audio/mp4"
              // RFC 4337
            };
          if (m([79, 112, 117, 115, 72, 101, 97, 100], {
            offset: 28
          }))
            return {
              ext: "opus",
              mime: "audio/opus"
            };
          if (m([79, 103, 103, 83]))
            return m([128, 116, 104, 101, 111, 114, 97], {
              offset: 28
            }) ? {
              ext: "ogv",
              mime: "video/ogg"
            } : m([1, 118, 105, 100, 101, 111, 0], {
              offset: 28
            }) ? {
              ext: "ogm",
              mime: "video/ogg"
            } : m([127, 70, 76, 65, 67], {
              offset: 28
            }) ? {
              ext: "oga",
              mime: "audio/ogg"
            } : m([83, 112, 101, 101, 120, 32, 32], {
              offset: 28
            }) ? {
              ext: "spx",
              mime: "audio/ogg"
            } : m([1, 118, 111, 114, 98, 105, 115], {
              offset: 28
            }) ? {
              ext: "ogg",
              mime: "audio/ogg"
            } : {
              ext: "ogx",
              mime: "application/ogg"
            };
          if (m([102, 76, 97, 67]))
            return {
              ext: "flac",
              mime: "audio/x-flac"
            };
          if (m([77, 65, 67, 32]))
            return {
              ext: "ape",
              mime: "audio/ape"
            };
          if (m([119, 118, 112, 107]))
            return {
              ext: "wv",
              mime: "audio/wavpack"
            };
          if (m([35, 33, 65, 77, 82, 10]))
            return {
              ext: "amr",
              mime: "audio/amr"
            };
          if (m([37, 80, 68, 70]))
            return {
              ext: "pdf",
              mime: "application/pdf"
            };
          if (m([77, 90]))
            return {
              ext: "exe",
              mime: "application/x-msdownload"
            };
          if ((x[0] === 67 || x[0] === 70) && m([87, 83], {
            offset: 1
          }))
            return {
              ext: "swf",
              mime: "application/x-shockwave-flash"
            };
          if (m([123, 92, 114, 116, 102]))
            return {
              ext: "rtf",
              mime: "application/rtf"
            };
          if (m([0, 97, 115, 109]))
            return {
              ext: "wasm",
              mime: "application/wasm"
            };
          if (m([119, 79, 70, 70]) && (m([0, 1, 0, 0], {
            offset: 4
          }) || m([79, 84, 84, 79], {
            offset: 4
          })))
            return {
              ext: "woff",
              mime: "font/woff"
            };
          if (m([119, 79, 70, 50]) && (m([0, 1, 0, 0], {
            offset: 4
          }) || m([79, 84, 84, 79], {
            offset: 4
          })))
            return {
              ext: "woff2",
              mime: "font/woff2"
            };
          if (m([76, 80], {
            offset: 34
          }) && (m([0, 0, 1], {
            offset: 8
          }) || m([1, 0, 2], {
            offset: 8
          }) || m([2, 0, 2], {
            offset: 8
          })))
            return {
              ext: "eot",
              mime: "application/vnd.ms-fontobject"
            };
          if (m([0, 1, 0, 0, 0]))
            return {
              ext: "ttf",
              mime: "font/ttf"
            };
          if (m([79, 84, 84, 79, 0]))
            return {
              ext: "otf",
              mime: "font/otf"
            };
          if (m([0, 0, 1, 0]))
            return {
              ext: "ico",
              mime: "image/x-icon"
            };
          if (m([0, 0, 2, 0]))
            return {
              ext: "cur",
              mime: "image/x-icon"
            };
          if (m([70, 76, 86, 1]))
            return {
              ext: "flv",
              mime: "video/x-flv"
            };
          if (m([37, 33]))
            return {
              ext: "ps",
              mime: "application/postscript"
            };
          if (m([253, 55, 122, 88, 90, 0]))
            return {
              ext: "xz",
              mime: "application/x-xz"
            };
          if (m([83, 81, 76, 105]))
            return {
              ext: "sqlite",
              mime: "application/x-sqlite3"
            };
          if (m([78, 69, 83, 26]))
            return {
              ext: "nes",
              mime: "application/x-nintendo-nes-rom"
            };
          if (m([67, 114, 50, 52]))
            return {
              ext: "crx",
              mime: "application/x-google-chrome-extension"
            };
          if (m([77, 83, 67, 70]) || m([73, 83, 99, 40]))
            return {
              ext: "cab",
              mime: "application/vnd.ms-cab-compressed"
            };
          if (m([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121]))
            return {
              ext: "deb",
              mime: "application/x-deb"
            };
          if (m([33, 60, 97, 114, 99, 104, 62]))
            return {
              ext: "ar",
              mime: "application/x-unix-archive"
            };
          if (m([237, 171, 238, 219]))
            return {
              ext: "rpm",
              mime: "application/x-rpm"
            };
          if (m([31, 160]) || m([31, 157]))
            return {
              ext: "Z",
              mime: "application/x-compress"
            };
          if (m([76, 90, 73, 80]))
            return {
              ext: "lz",
              mime: "application/x-lzip"
            };
          if (m([208, 207, 17, 224, 161, 177, 26, 225]))
            return {
              ext: "msi",
              mime: "application/x-msi"
            };
          if (m([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
            return {
              ext: "mxf",
              mime: "application/mxf"
            };
          if (m([71], {
            offset: 4
          }) && (m([71], {
            offset: 192
          }) || m([71], {
            offset: 196
          })))
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          if (m([66, 76, 69, 78, 68, 69, 82]))
            return {
              ext: "blend",
              mime: "application/x-blender"
            };
          if (m([66, 80, 71, 251]))
            return {
              ext: "bpg",
              mime: "image/bpg"
            };
          if (m([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
            if (m([106, 112, 50, 32], {
              offset: 20
            }))
              return {
                ext: "jp2",
                mime: "image/jp2"
              };
            if (m([106, 112, 120, 32], {
              offset: 20
            }))
              return {
                ext: "jpx",
                mime: "image/jpx"
              };
            if (m([106, 112, 109, 32], {
              offset: 20
            }))
              return {
                ext: "jpm",
                mime: "image/jpm"
              };
            if (m([109, 106, 112, 50], {
              offset: 20
            }))
              return {
                ext: "mj2",
                mime: "image/mj2"
              };
          }
          if (m([70, 79, 82, 77, 0]))
            return {
              ext: "aif",
              mime: "audio/aiff"
            };
          if (w("<?xml "))
            return {
              ext: "xml",
              mime: "application/xml"
            };
          if (m([66, 79, 79, 75, 77, 79, 66, 73], {
            offset: 60
          }))
            return {
              ext: "mobi",
              mime: "application/x-mobipocket-ebook"
            };
          if (m([102, 116, 121, 112], {
            offset: 4
          })) {
            if (m([109, 105, 102, 49], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heif"
              };
            if (m([109, 115, 102, 49], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heif-sequence"
              };
            if (m([104, 101, 105, 99], {
              offset: 8
            }) || m([104, 101, 105, 120], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heic"
              };
            if (m([104, 101, 118, 99], {
              offset: 8
            }) || m([104, 101, 118, 120], {
              offset: 8
            }))
              return {
                ext: "heic",
                mime: "image/heic-sequence"
              };
          }
          return m([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]) ? {
            ext: "ktx",
            mime: "image/ktx"
          } : null;
        };
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20 }], 63: [function(Q, de, q) {
        var ie = Q("is-callable"), i = Object.prototype.toString, N = Object.prototype.hasOwnProperty, Z = function(m, w, k) {
          for (var E = 0, P = m.length; E < P; E++)
            N.call(m, E) && (k == null ? w(m[E], E, m) : w.call(k, m[E], E, m));
        }, R = function(m, w, k) {
          for (var E = 0, P = m.length; E < P; E++)
            k == null ? w(m.charAt(E), E, m) : w.call(k, m.charAt(E), E, m);
        }, A = function(m, w, k) {
          for (var E in m)
            N.call(m, E) && (k == null ? w(m[E], E, m) : w.call(k, m[E], E, m));
        }, M = function(m, w, k) {
          if (!ie(w))
            throw new TypeError("iterator must be a function");
          var E;
          arguments.length >= 3 && (E = k), i.call(m) === "[object Array]" ? Z(m, w, E) : typeof m == "string" ? R(m, w, E) : A(m, w, E);
        };
        de.exports = M;
      }, { "is-callable": 77 }], 64: [function(Q, de, q) {
        function ie(R, A, M, w) {
          var m = 0, w = w === void 0 ? {} : w, k = w.loop === void 0 ? null : w.loop, E = w.palette === void 0 ? null : w.palette;
          if (A <= 0 || M <= 0 || A > 65535 || M > 65535)
            throw new Error("Width/Height invalid.");
          function P(te) {
            var le = te.length;
            if (le < 2 || le > 256 || le & le - 1)
              throw new Error(
                "Invalid code/color length, must be power of 2 and 2 .. 256."
              );
            return le;
          }
          R[m++] = 71, R[m++] = 73, R[m++] = 70, R[m++] = 56, R[m++] = 57, R[m++] = 97;
          var S = 0, U = 0;
          if (E !== null) {
            for (var j = P(E); j >>= 1; ) ++S;
            if (j = 1 << S, --S, w.background !== void 0) {
              if (U = w.background, U >= j)
                throw new Error("Background index out of range.");
              if (U === 0)
                throw new Error("Background index explicitly passed as 0.");
            }
          }
          if (R[m++] = A & 255, R[m++] = A >> 8 & 255, R[m++] = M & 255, R[m++] = M >> 8 & 255, R[m++] = (E !== null ? 128 : 0) | // Global Color Table Flag.
          S, R[m++] = U, R[m++] = 0, E !== null)
            for (var T = 0, W = E.length; T < W; ++T) {
              var J = E[T];
              R[m++] = J >> 16 & 255, R[m++] = J >> 8 & 255, R[m++] = J & 255;
            }
          if (k !== null) {
            if (k < 0 || k > 65535)
              throw new Error("Loop count invalid.");
            R[m++] = 33, R[m++] = 255, R[m++] = 11, R[m++] = 78, R[m++] = 69, R[m++] = 84, R[m++] = 83, R[m++] = 67, R[m++] = 65, R[m++] = 80, R[m++] = 69, R[m++] = 50, R[m++] = 46, R[m++] = 48, R[m++] = 3, R[m++] = 1, R[m++] = k & 255, R[m++] = k >> 8 & 255, R[m++] = 0;
          }
          var ee = !1;
          this.addFrame = function(te, le, me, ke, ge, Ve) {
            if (ee === !0 && (--m, ee = !1), Ve = Ve === void 0 ? {} : Ve, te < 0 || le < 0 || te > 65535 || le > 65535)
              throw new Error("x/y invalid.");
            if (me <= 0 || ke <= 0 || me > 65535 || ke > 65535)
              throw new Error("Width/Height invalid.");
            if (ge.length < me * ke)
              throw new Error("Not enough pixels for the frame size.");
            var Oe = !0, Ue = Ve.palette;
            if (Ue == null && (Oe = !1, Ue = E), Ue == null)
              throw new Error("Must supply either a local or global palette.");
            for (var we = P(Ue), Ce = 0; we >>= 1; ) ++Ce;
            we = 1 << Ce;
            var it = Ve.delay === void 0 ? 0 : Ve.delay, ut = Ve.disposal === void 0 ? 0 : Ve.disposal;
            if (ut < 0 || ut > 3)
              throw new Error("Disposal out of range.");
            var bt = !1, pt = 0;
            if (Ve.transparent !== void 0 && Ve.transparent !== null && (bt = !0, pt = Ve.transparent, pt < 0 || pt >= we))
              throw new Error("Transparent color index.");
            if ((ut !== 0 || bt || it !== 0) && (R[m++] = 33, R[m++] = 249, R[m++] = 4, R[m++] = ut << 2 | (bt === !0 ? 1 : 0), R[m++] = it & 255, R[m++] = it >> 8 & 255, R[m++] = pt, R[m++] = 0), R[m++] = 44, R[m++] = te & 255, R[m++] = te >> 8 & 255, R[m++] = le & 255, R[m++] = le >> 8 & 255, R[m++] = me & 255, R[m++] = me >> 8 & 255, R[m++] = ke & 255, R[m++] = ke >> 8 & 255, R[m++] = Oe === !0 ? 128 | Ce - 1 : 0, Oe === !0)
              for (var Ke = 0, dt = Ue.length; Ke < dt; ++Ke) {
                var ct = Ue[Ke];
                R[m++] = ct >> 16 & 255, R[m++] = ct >> 8 & 255, R[m++] = ct & 255;
              }
            return m = i(
              R,
              m,
              Ce < 2 ? 2 : Ce,
              ge
            ), m;
          }, this.end = function() {
            return ee === !1 && (R[m++] = 59, ee = !0), m;
          }, this.getOutputBuffer = function() {
            return R;
          }, this.setOutputBuffer = function(te) {
            R = te;
          }, this.getOutputBufferPosition = function() {
            return m;
          }, this.setOutputBufferPosition = function(te) {
            m = te;
          };
        }
        function i(R, A, M, x) {
          R[A++] = M;
          var m = A++, w = 1 << M, k = w - 1, E = w + 1, P = E + 1, S = M + 1, U = 0, j = 0;
          function T(Ve) {
            for (; U >= Ve; )
              R[A++] = j & 255, j >>= 8, U -= 8, A === m + 256 && (R[m] = 255, m = A++);
          }
          function W(Ve) {
            j |= Ve << U, U += S, T(8);
          }
          var J = x[0] & k, ee = {};
          W(w);
          for (var te = 1, le = x.length; te < le; ++te) {
            var me = x[te] & k, ke = J << 8 | me, ge = ee[ke];
            if (ge === void 0) {
              for (j |= J << U, U += S; U >= 8; )
                R[A++] = j & 255, j >>= 8, U -= 8, A === m + 256 && (R[m] = 255, m = A++);
              P === 4096 ? (W(w), P = E + 1, S = M + 1, ee = {}) : (P >= 1 << S && ++S, ee[ke] = P++), J = me;
            } else
              J = ge;
          }
          return W(J), W(E), T(1), m + 1 === A ? R[m] = 0 : (R[m] = A - m - 1, R[A++] = 0), A;
        }
        function N(R) {
          var A = 0;
          if (R[A++] !== 71 || R[A++] !== 73 || R[A++] !== 70 || R[A++] !== 56 || (R[A++] + 1 & 253) !== 56 || R[A++] !== 97)
            throw new Error("Invalid GIF 87a/89a header.");
          var M = R[A++] | R[A++] << 8, x = R[A++] | R[A++] << 8, m = R[A++], w = m >> 7, k = m & 7, E = 1 << k + 1;
          R[A++], R[A++];
          var P = null, S = null;
          w && (P = A, S = E, A += E * 3);
          var U = !0, j = [], T = 0, W = null, J = 0, ee = null;
          for (this.width = M, this.height = x; U && A < R.length; )
            switch (R[A++]) {
              case 33:
                switch (R[A++]) {
                  case 255:
                    if (R[A] !== 11 || // 21 FF already read, check block size.
                    // NETSCAPE2.0
                    R[A + 1] == 78 && R[A + 2] == 69 && R[A + 3] == 84 && R[A + 4] == 83 && R[A + 5] == 67 && R[A + 6] == 65 && R[A + 7] == 80 && R[A + 8] == 69 && R[A + 9] == 50 && R[A + 10] == 46 && R[A + 11] == 48 && // Sub-block
                    R[A + 12] == 3 && R[A + 13] == 1 && R[A + 16] == 0)
                      A += 14, ee = R[A++] | R[A++] << 8, A++;
                    else
                      for (A += 12; ; ) {
                        var te = R[A++];
                        if (!(te >= 0)) throw Error("Invalid block size");
                        if (te === 0) break;
                        A += te;
                      }
                    break;
                  case 249:
                    if (R[A++] !== 4 || R[A + 4] !== 0)
                      throw new Error("Invalid graphics extension block.");
                    var le = R[A++];
                    T = R[A++] | R[A++] << 8, W = R[A++], le & 1 || (W = null), J = le >> 2 & 7, A++;
                    break;
                  case 254:
                    for (; ; ) {
                      var te = R[A++];
                      if (!(te >= 0)) throw Error("Invalid block size");
                      if (te === 0) break;
                      A += te;
                    }
                    break;
                  default:
                    throw new Error(
                      "Unknown graphic control label: 0x" + R[A - 1].toString(16)
                    );
                }
                break;
              case 44:
                var me = R[A++] | R[A++] << 8, ke = R[A++] | R[A++] << 8, ge = R[A++] | R[A++] << 8, Ve = R[A++] | R[A++] << 8, Oe = R[A++], Ue = Oe >> 7, we = Oe >> 6 & 1, Ce = Oe & 7, it = 1 << Ce + 1, ut = P, bt = S, pt = !1;
                if (Ue) {
                  var pt = !0;
                  ut = A, bt = it, A += it * 3;
                }
                var Ke = A;
                for (A++; ; ) {
                  var te = R[A++];
                  if (!(te >= 0)) throw Error("Invalid block size");
                  if (te === 0) break;
                  A += te;
                }
                j.push({
                  x: me,
                  y: ke,
                  width: ge,
                  height: Ve,
                  has_local_palette: pt,
                  palette_offset: ut,
                  palette_size: bt,
                  data_offset: Ke,
                  data_length: A - Ke,
                  transparent_index: W,
                  interlaced: !!we,
                  delay: T,
                  disposal: J
                });
                break;
              case 59:
                U = !1;
                break;
              default:
                throw new Error("Unknown gif block: 0x" + R[A - 1].toString(16));
            }
          this.numFrames = function() {
            return j.length;
          }, this.loopCount = function() {
            return ee;
          }, this.frameInfo = function(dt) {
            if (dt < 0 || dt >= j.length)
              throw new Error("Frame index out of range.");
            return j[dt];
          }, this.decodeAndBlitFrameBGRA = function(dt, ct) {
            var wt = this.frameInfo(dt), Ht = wt.width * wt.height, $t = new Uint8Array(Ht);
            Z(
              R,
              wt.data_offset,
              $t,
              Ht
            );
            var rt = wt.palette_offset, ri = wt.transparent_index;
            ri === null && (ri = 256);
            var wi = wt.width, Qt = M - wi, At = wi, St = (wt.y * M + wt.x) * 4, Lt = ((wt.y + wt.height) * M + wt.x) * 4, kt = St, Ye = Qt * 4;
            wt.interlaced === !0 && (Ye += M * 4 * 7);
            for (var De = 8, Re = 0, _t = $t.length; Re < _t; ++Re) {
              var et = $t[Re];
              if (At === 0 && (kt += Ye, At = wi, kt >= Lt && (Ye = Qt * 4 + M * 4 * (De - 1), kt = St + (wi + Qt) * (De << 1), De >>= 1)), et === ri)
                kt += 4;
              else {
                var Ie = R[rt + et * 3], pe = R[rt + et * 3 + 1], xt = R[rt + et * 3 + 2];
                ct[kt++] = xt, ct[kt++] = pe, ct[kt++] = Ie, ct[kt++] = 255;
              }
              --At;
            }
          }, this.decodeAndBlitFrameRGBA = function(dt, ct) {
            var wt = this.frameInfo(dt), Ht = wt.width * wt.height, $t = new Uint8Array(Ht);
            Z(
              R,
              wt.data_offset,
              $t,
              Ht
            );
            var rt = wt.palette_offset, ri = wt.transparent_index;
            ri === null && (ri = 256);
            var wi = wt.width, Qt = M - wi, At = wi, St = (wt.y * M + wt.x) * 4, Lt = ((wt.y + wt.height) * M + wt.x) * 4, kt = St, Ye = Qt * 4;
            wt.interlaced === !0 && (Ye += M * 4 * 7);
            for (var De = 8, Re = 0, _t = $t.length; Re < _t; ++Re) {
              var et = $t[Re];
              if (At === 0 && (kt += Ye, At = wi, kt >= Lt && (Ye = Qt * 4 + M * 4 * (De - 1), kt = St + (wi + Qt) * (De << 1), De >>= 1)), et === ri)
                kt += 4;
              else {
                var Ie = R[rt + et * 3], pe = R[rt + et * 3 + 1], xt = R[rt + et * 3 + 2];
                ct[kt++] = Ie, ct[kt++] = pe, ct[kt++] = xt, ct[kt++] = 255;
              }
              --At;
            }
          };
        }
        function Z(R, A, M, x) {
          for (var m = R[A++], w = 1 << m, k = w + 1, E = k + 1, P = m + 1, S = (1 << P) - 1, U = 0, j = 0, T = 0, W = R[A++], J = new Int32Array(4096), ee = null; ; ) {
            for (; U < 16 && W !== 0; )
              j |= R[A++] << U, U += 8, W === 1 ? W = R[A++] : --W;
            if (U < P)
              break;
            var te = j & S;
            if (j >>= P, U -= P, te === w) {
              E = k + 1, P = m + 1, S = (1 << P) - 1, ee = null;
              continue;
            } else if (te === k)
              break;
            for (var le = te < E ? te : ee, me = 0, ke = le; ke > w; )
              ke = J[ke] >> 8, ++me;
            var ge = ke, Ve = T + me + (le !== te ? 1 : 0);
            if (Ve > x) {
              console.log("Warning, gif stream longer than expected.");
              return;
            }
            M[T++] = ge, T += me;
            var Oe = T;
            for (le !== te && (M[T++] = ge), ke = le; me--; )
              ke = J[ke], M[--Oe] = ke & 255, ke >>= 8;
            ee !== null && E < 4096 && (J[E++] = ee << 8 | ge, E >= S + 1 && P < 12 && (++P, S = S << 1 | 1)), ee = te;
          }
          return T !== x && console.log("Warning, gif stream shorter than expected."), M;
        }
        try {
          q.GifWriter = ie, q.GifReader = N;
        } catch {
        }
      }, {}], 65: [function(Q, de, q) {
        (function(ie) {
          class i {
            /**
             * BitmapImage is a class that hold an RGBA (red, green, blue, alpha) representation of an image. It's shape is borrowed from the Jimp package to make it easy to transfer GIF image frames into Jimp and Jimp images into GIF image frames. Each instance has a `bitmap` property having the following properties:
             * 
             * Property | Description
             * --- | ---
             * bitmap.width | width of image in pixels
             * bitmap.height | height of image in pixels
             * bitmap.data | a Buffer whose every four bytes represents a pixel, each sequential byte of a pixel corresponding to the red, green, blue, and alpha values of the pixel
             *
             * Its constructor supports the following signatures:
             *
             * * new BitmapImage(bitmap: { width: number, height: number, data: Buffer })
             * * new BitmapImage(bitmapImage: BitmapImage)
             * * new BitmapImage(width: number, height: number, buffer: Buffer)
             * * new BitmapImage(width: number, height: number, backgroundRGBA?: number)
             * 
             * When a `BitmapImage` is provided, the constructed `BitmapImage` is a deep clone of the provided one, so that each image's pixel data can subsequently be modified without affecting each other.
             *
             * `backgroundRGBA` is an optional parameter representing a pixel as a single number. In hex, the number is as follows: 0xRRGGBBAA, where RR is the red byte, GG the green byte, BB, the blue byte, and AA the alpha value. An AA of 0x00 is considered transparent, and all non-zero AA values are treated as opaque.
             */
            constructor(...Z) {
              if (Z.length === 0)
                throw new Error("constructor requires parameters");
              const R = Z[0];
              if (R !== null && typeof R == "object")
                if (R instanceof i) {
                  const A = R.bitmap;
                  this.bitmap = {
                    width: A.width,
                    height: A.height,
                    data: new ie(A.width * A.height * 4)
                  }, A.data.copy(this.bitmap.data);
                } else if (R.width && R.height && R.data)
                  this.bitmap = R;
                else
                  throw new Error("unrecognized constructor parameters");
              else if (typeof R == "number" && typeof Z[1] == "number") {
                const A = R, M = Z[1], x = Z[2];
                this.bitmap = { width: A, height: M }, ie.isBuffer(x) ? this.bitmap.data = x : (this.bitmap.data = new ie(A * M * 4), typeof x == "number" && this.fillRGBA(x));
              } else
                throw new Error("unrecognized constructor parameters");
            }
            /**
             * Copy a square portion of this image into another image. 
             * 
             * @param {BitmapImage} toImage Image into which to copy the square
             * @param {number} toX x-coord in toImage of upper-left corner of receiving square
             * @param {number} toY y-coord in toImage of upper-left corner of receiving square
             * @param {number} fromX x-coord in this image of upper-left corner of source square
             * @param {number} fromY y-coord in this image of upper-left corner of source square
             * @return {BitmapImage} The present image to allow for chaining.
             */
            blit(Z, R, A, M, x, m, w) {
              if (M + m > this.bitmap.width)
                throw new Error("copy exceeds width of source bitmap");
              if (R + m > Z.bitmap.width)
                throw new Error("copy exceeds width of target bitmap");
              if (x + w > this.bitmap.height)
                throw new Error("copy exceeds height of source bitmap");
              if (A + w > Z.bitmap.height)
                throw new Erro("copy exceeds height of target bitmap");
              const k = this.bitmap.data, E = Z.bitmap.data, P = this.bitmap.width * 4, S = Z.bitmap.width * 4, U = m * 4;
              let j = x * P + M * 4, T = A * S + R * 4;
              for (; --w >= 0; )
                k.copy(E, T, j, j + U), j += P, T += S;
              return this;
            }
            /**
             * Fills the image with a single color.
             * 
             * @param {number} rgba Color with which to fill image, expressed as a singlenumber in the form 0xRRGGBBAA, where AA is 0x00 for transparent and any other value for opaque.
             * @return {BitmapImage} The present image to allow for chaining.
             */
            fillRGBA(Z) {
              const R = this.bitmap.data, A = this.bitmap.height * 4;
              let M = 0;
              for (; M < A; )
                R.writeUInt32BE(Z, M), M += 4;
              for (; M < R.length; )
                R.copy(R, M, 0, A), M += A;
              return this;
            }
            /**
             * Gets the RGBA number of the pixel at the given coordinate in the form 0xRRGGBBAA, where AA is the alpha value, with alpha 0x00 encoding to transparency in GIFs.
             * 
             * @param {number} x x-coord of pixel
             * @param {number} y y-coord of pixel
             * @return {number} RGBA of pixel in 0xRRGGBBAA form
             */
            getRGBA(Z, R) {
              const A = (R * this.bitmap.width + Z) * 4;
              return this.bitmap.data.readUInt32BE(A);
            }
            /**
             * Gets a set of all RGBA colors found within the image.
             * 
             * @return {Set} Set of all RGBA colors that the image contains.
             */
            getRGBASet() {
              const Z = /* @__PURE__ */ new Set(), R = this.bitmap.data;
              for (let A = 0; A < R.length; A += 4)
                Z.add(R.readUInt32BE(A, !0));
              return Z;
            }
            /**
             * Converts the image to greyscale using inferred Adobe metrics.
             * 
             * @return {BitmapImage} The present image to allow for chaining.
             */
            greyscale() {
              const Z = this.bitmap.data;
              return this.scan(0, 0, this.bitmap.width, this.bitmap.height, (R, A, M) => {
                const x = Math.round(
                  0.299 * Z[M] + 0.587 * Z[M + 1] + 0.114 * Z[M + 2]
                );
                Z[M] = x, Z[M + 1] = x, Z[M + 2] = x;
              }), this;
            }
            /**
             * Reframes the image as if placing a frame around the original image and replacing the original image with the newly framed image. When the new frame is strictly within the boundaries of the original image, this method crops the image. When any of the new boundaries exceed those of the original image, the `fillRGBA` must be provided to indicate the color with which to fill the extra space added to the image.
             * 
             * @param {number} xOffset The x-coord offset of the upper-left pixel of the desired image relative to the present image.
             * @param {number} yOffset The y-coord offset of the upper-left pixel of the desired image relative to the present image.
             * @param {number} width The width of the new image after reframing
             * @param {number} height The height of the new image after reframing
             * @param {number} fillRGBA The color with which to fill space added to the image as a result of the reframing, in 0xRRGGBBAA format, where AA is 0x00 to indicate transparent and a non-zero value to indicate opaque. This parameter is only required when the reframing exceeds the original boundaries (i.e. does not simply perform a crop).
             * @return {BitmapImage} The present image to allow for chaining.
             */
            reframe(Z, R, A, M, x) {
              const m = Z < 0 ? 0 : Z, w = R < 0 ? 0 : R, k = A + m > this.bitmap.width ? this.bitmap.width - m : A, E = M + w > this.bitmap.height ? this.bitmap.height - w : M, P = Z < 0 ? -Z : 0, S = R < 0 ? -R : 0;
              let U;
              if (x === void 0) {
                if (m !== Z || w != R || k !== A || E !== M)
                  throw new GifError("fillRGBA required for this reframing");
                U = new i(A, M);
              } else
                U = new i(A, M, x);
              return this.blit(U, P, S, m, w, k, E), this.bitmap = U.bitmap, this;
            }
            /**
             * Scales the image size up by an integer factor. Each pixel of the original image becomes a square of the same color in the new image having a size of `factor` x `factor` pixels.
             * 
             * @param {number} factor The factor by which to scale up the image. Must be an integer >= 1.
             * @return {BitmapImage} The present image to allow for chaining.
             */
            scale(Z) {
              if (Z === 1)
                return;
              if (!Number.isInteger(Z) || Z < 1)
                throw new Error("the scale must be an integer >= 1");
              const R = this.bitmap.width, A = this.bitmap.height, M = R * Z * 4, x = this.bitmap.data, m = new ie(A * M * Z);
              let w = 0, k, E = 0;
              for (let P = 0; P < A; ++P) {
                k = E;
                for (let S = 0; S < R; ++S) {
                  const U = x.readUInt32BE(w, !0);
                  for (let j = 0; j < Z; ++j)
                    m.writeUInt32BE(U, E), E += 4;
                  w += 4;
                }
                for (let S = 1; S < Z; ++S)
                  m.copy(m, E, k, E), E += M, k += M;
              }
              return this.bitmap = {
                width: R * Z,
                height: A * Z,
                data: m
              }, this;
            }
            /**
             * Scans all coordinates of the image, handing each in turn to the provided handler function.
             *
             * @param {function} scanHandler A function(x: number, y: number, bi: number) to be called for each pixel of the image with that pixel's x-coord, y-coord, and index into the `data` buffer. The function accesses the pixel at this coordinate by accessing the `this.data` at index `bi`.
             * @see scanAllIndexes
             */
            scanAllCoords(Z) {
              const R = this.bitmap.width, A = this.bitmap.data.length;
              let M = 0, x = 0;
              for (let m = 0; m < A; m += 4)
                Z(M, x, m), ++M === R && (M = 0, ++x);
            }
            /**
             * Scans all pixels of the image, handing the index of each in turn to the provided handler function. Runs a bit faster than `scanAllCoords()`, should the handler not need pixel coordinates.
             *
             * @param {function} scanHandler A function(bi: number) to be called for each pixel of the image with that pixel's index into the `data` buffer. The pixels is found at index 'bi' within `this.data`.
             * @see scanAllCoords
             */
            scanAllIndexes(Z) {
              const R = this.bitmap.data.length;
              for (let A = 0; A < R; A += 4)
                Z(A);
            }
          }
          de.exports = i;
        }).call(this, Q("buffer").Buffer);
      }, { buffer: 48 }], 66: [function(Q, de, q) {
        class ie {
          // width - width of GIF in pixels
          // height - height of GIF in pixels
          // loops - 0 = unending; (n > 0) = iterate n times
          // usesTransparency - whether any frames have transparent pixels
          // colorScope - scope of color tables in GIF
          // frames - array of frames
          // buffer - GIF-formatted data
          /**
           * Gif is a class representing an encoded GIF. It is intended to be a read-only representation of a byte-encoded GIF. Only encoders and decoders should be creating instances of this class.
           * 
           * Property | Description
           * --- | ---
           * width | width of the GIF at its widest
           * height | height of the GIF at its highest
           * loops | the number of times the GIF should loop before stopping; 0 => loop indefinately
           * usesTransparency | boolean indicating whether at least one frame contains at least one transparent pixel
           * colorScope | the scope of the color tables as encoded within the GIF; either Gif.GlobalColorsOnly (== 1) or Gif.LocalColorsOnly (== 2).
           * frames | a array of GifFrame instances, one for each frame of the GIF
           * buffer | a Buffer holding the encoding's byte data
           * 
           * Its constructor should only ever be called by the GIF encoder or decoder.
           *
           * @param {Buffer} buffer A Buffer containing the encoded bytes
           * @param {GifFrame[]} frames Array of frames found in the encoding
           * @param {object} spec Properties of the encoding as listed above
           */
          constructor(Z, R, A) {
            this.width = A.width, this.height = A.height, this.loops = A.loops, this.usesTransparency = A.usesTransparency, this.colorScope = A.colorScope, this.frames = R, this.buffer = Z;
          }
        }
        ie.GlobalColorsPreferred = 0, ie.GlobalColorsOnly = 1, ie.LocalColorsOnly = 2;
        class i extends Error {
          /**
           * GifError is a class representing a GIF-related error
           * 
           * @param {string|Error} messageOrError
           */
          constructor(Z) {
            super(Z), Z instanceof Error && (this.stack = "Gif" + Z.stack);
          }
        }
        q.Gif = ie, q.GifError = i;
      }, {}], 67: [function(Q, de, q) {
        (function(ie, i) {
          const N = Q("omggif"), { Gif: Z, GifError: R } = Q("./gif");
          let A;
          ie.nextTick(() => {
            A = Q("./gifutil");
          });
          const { GifFrame: M } = Q("./gifframe"), x = 200, m = 100;
          class w {
            // _transparentRGBA - RGB given to transparent pixels (alpha=0) on decode; defaults to null indicating 0x000000, which is fastest
            /**
             * GifCodec is a class that both encodes and decodes GIFs. It implements both the `encode()` method expected of an encoder and the `decode()` method expected of a decoder, and it wraps the `omggif` GIF encoder/decoder package. GifCodec serves as this library's default encoder and decoder, but it's possible to wrap other GIF encoders and decoders for use by `gifwrap` as well. GifCodec will not encode GIFs with interlacing.
             * 
             * Instances of this class are stateless and can be shared across multiple encodings and decodings.
             * 
             * Its constructor takes one option argument:
             * 
             * @param {object} options Optionally takes an objection whose only possible property is `transparentRGB`. Images are internally represented in RGBA format, where A is the alpha value of a pixel. When `transparentRGB` is provided, this RGB value (excluding alpha) is assigned to transparent pixels, which are also given alpha value 0x00. (All opaque pixels are given alpha value 0xFF). The RGB color of transparent pixels shouldn't matter for most applications. Defaults to 0x000000.
             */
            constructor(te = {}) {
              this._transparentRGB = null, typeof te.transparentRGB == "number" && te.transparentRGB !== 0 && (this._transparentRGBA = te.transparentRGB * 256), this._testInitialBufferSize = 0;
            }
            /**
             * Decodes a GIF from a Buffer to yield an instance of Gif. Transparent pixels of the GIF are given alpha values of 0x00, and opaque pixels are given alpha values of 0xFF. The RGB values of transparent pixels default to 0x000000 but can be overridden by the constructor's `transparentRGB` option.
             * 
             * @param {Buffer} buffer Bytes of an encoded GIF to decode.
             * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
             * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
             */
            decodeGif(te) {
              try {
                let le;
                try {
                  le = new N.GifReader(te);
                } catch (Ve) {
                  throw new R(Ve);
                }
                const me = le.numFrames(), ke = [], ge = {
                  width: le.width,
                  height: le.height,
                  loops: le.loopCount()
                };
                ge.usesTransparency = !1;
                for (let Ve = 0; Ve < me; ++Ve) {
                  const Oe = this._decodeFrame(le, Ve, ge.usesTransparency);
                  ke.push(Oe.frame), Oe.usesTransparency && (ge.usesTransparency = !0);
                }
                return Promise.resolve(new Z(te, ke, ge));
              } catch (le) {
                return Promise.reject(le);
              }
            }
            /**
             * Encodes a GIF from provided frames. Each pixel having an alpha value of 0x00 renders as transparent within the encoding, while all pixels of non-zero alpha value render as opaque.
             * 
             * @param {GifFrame[]} frames Array of frames to encode
             * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely, and `colorScope` defaults to Gif.GlobalColorsPreferred.
             * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
             * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
             */
            encodeGif(te, le = {}) {
              try {
                if (te === null || te.length === 0)
                  throw new R("there are no frames");
                const me = A.getMaxDimensions(te);
                return le = Object.assign({}, le), le.width = me.maxWidth, le.height = me.maxHeight, le.loops = le.loops || 0, le.colorScope = le.colorScope || Z.GlobalColorsPreferred, Promise.resolve(this._encodeGif(te, le));
              } catch (me) {
                return Promise.reject(me);
              }
            }
            _decodeFrame(te, le, me) {
              let ke, ge;
              try {
                if (ke = te.frameInfo(le), ge = new i(te.width * te.height * 4), te.decodeAndBlitFrameRGBA(le, ge), ke.width !== te.width || ke.height !== te.height) {
                  if (ke.y && (ge = ge.slice(ke.y * te.width * 4)), te.width > ke.width)
                    for (let Ue = 0; Ue < ke.height; ++Ue)
                      ge.copy(
                        ge,
                        Ue * ke.width * 4,
                        (ke.x + Ue * te.width) * 4,
                        (ke.x + Ue * te.width) * 4 + ke.width * 4
                      );
                  ge = ge.slice(0, ke.width * ke.height * 4);
                }
              } catch (Ue) {
                throw new R(Ue);
              }
              let Ve = !1;
              if (this._transparentRGBA === null) {
                if (!me)
                  for (let Ue = 3; Ue < ge.length; Ue += 4)
                    ge[Ue] === 0 && (Ve = !0, Ue = ge.length);
              } else
                for (let Ue = 3; Ue < ge.length; Ue += 4)
                  ge[Ue] === 0 && (ge.writeUInt32BE(this._transparentRGBA, Ue - 3), Ve = !0);
              return { frame: new M(ke.width, ke.height, ge, {
                xOffset: ke.x,
                yOffset: ke.y,
                disposalMethod: ke.disposal,
                interlaced: ke.interlaced,
                delayCentisecs: ke.delay
              }), usesTransparency: Ve };
            }
            _encodeGif(te, le) {
              let me;
              if (le.colorScope === Z.LocalColorsOnly)
                me = A.getColorInfo(te, 0);
              else if (me = A.getColorInfo(te, 256), !me.colors) {
                if (le.colorScope === Z.GlobalColorsOnly)
                  throw new R(
                    "Too many color indexes for global color table"
                  );
                le.colorScope = Z.LocalColorsOnly;
              }
              le.usesTransparency = me.usesTransparency;
              const ke = me.palettes;
              return le.colorScope === Z.LocalColorsOnly ? S(te, le, 2e3, ke) : P(te, le, 2e3, me);
            }
            _getSizeEstimateGlobal(te, le) {
              if (this._testInitialBufferSize > 0)
                return this._testInitialBufferSize;
              let me = x + 3 * 256;
              const ke = W(te);
              return le.forEach((ge) => {
                me += j(ge, ke);
              }), me;
            }
            _getSizeEstimateLocal(te, le) {
              if (this._testInitialBufferSize > 0)
                return this._testInitialBufferSize;
              let me = x;
              for (let ke = 0; ke < le.length; ++ke) {
                const ge = te[ke], Ve = W(ge);
                me += j(le[ke], Ve);
              }
              return me;
            }
          }
          q.GifCodec = w;
          function k(ee, te) {
            const le = ee.indexOf(te);
            return le === -1 ? null : le;
          }
          function E(ee, te) {
            for (var le = 0, me = ee.length - 1, ke; le <= me; )
              if (ke = Math.floor((le + me) / 2), ee[ke] > te)
                me = ke - 1;
              else if (ee[ke] < te)
                le = ke + 1;
              else
                return ke;
            return null;
          }
          function P(ee, te, le, me) {
            const ke = {
              colors: me.colors.slice(),
              usesTransparency: me.usesTransparency
            };
            U(ke);
            const ge = {
              palette: ke.colors,
              loop: te.loops
            };
            let Ve = new i(le), Oe;
            try {
              Oe = new N.GifWriter(
                Ve,
                te.width,
                te.height,
                ge
              );
            } catch (Ue) {
              throw new R(Ue);
            }
            for (let Ue = 0; Ue < ee.length; ++Ue)
              Ve = J(Oe, Ue, ee[Ue], me, !1);
            return new Z(Ve.slice(0, Oe.end()), ee, te);
          }
          function S(ee, te, le, me) {
            const ke = {
              loop: te.loops
            };
            let ge = new i(le), Ve;
            try {
              Ve = new N.GifWriter(
                ge,
                te.width,
                te.height,
                ke
              );
            } catch (Oe) {
              throw new R(Oe);
            }
            for (let Oe = 0; Oe < ee.length; ++Oe)
              ge = J(Ve, Oe, ee[Oe], me[Oe], !0);
            return new Z(ge.slice(0, Ve.end()), ee, te);
          }
          function U(ee) {
            const te = ee.colors;
            ee.usesTransparency && te.push(0);
            const le = te.length;
            let me = 2;
            for (; le > me; )
              me <<= 1;
            te.length = me, te.fill(0, le);
          }
          function j(ee, te) {
            let le = ee.bitmap.width * ee.bitmap.height;
            return le = Math.ceil(le * te / 8), le += Math.ceil(le / 255), m + le + 3 * 256;
          }
          function T(ee, te, le) {
            const me = le.colors, ke = me.length <= 8 ? (
              // guess at the break-even
              k
            ) : E, ge = te.bitmap.data, Ve = new i(ge.length / 4);
            let Oe = me.length, Ue = 0, we = 0;
            for (; Ue < ge.length; ) {
              if (ge[Ue + 3] !== 0) {
                const Ce = ge.readUInt32BE(Ue, !0) >> 8 & 16777215;
                Ve[we] = ke(me, Ce);
              } else
                Ve[we] = Oe;
              Ue += 4, ++we;
            }
            if (le.usesTransparency) {
              if (Oe === 256)
                throw new R(`Frame ${ee} already has 256 colorsand so can't use transparency`);
            } else
              Oe = null;
            return { buffer: Ve, transparentIndex: Oe };
          }
          function W(ee) {
            let te = ee.indexCount, le = 0;
            for (--te; te; )
              ++le, te >>= 1;
            return le > 0 ? le : 1;
          }
          function J(ee, te, le, me, ke) {
            if (le.interlaced)
              throw new R("writing interlaced GIFs is not supported");
            const ge = T(te, le, me), Ve = {
              delay: le.delayCentisecs,
              disposal: le.disposalMethod,
              transparent: ge.transparentIndex
            };
            ke && (U(me), Ve.palette = me.colors);
            try {
              let Oe = ee.getOutputBuffer(), Ue = ee.getOutputBufferPosition(), we, Ce = !0;
              for (; Ce; )
                if (we = ee.addFrame(
                  le.xOffset,
                  le.yOffset,
                  le.bitmap.width,
                  le.bitmap.height,
                  ge.buffer,
                  Ve
                ), Ce = !1, we >= Oe.length - 1) {
                  const it = new i(Oe.length * 1.5);
                  Oe.copy(it), ee.setOutputBuffer(it), ee.setOutputBufferPosition(Ue), Oe = it, Ce = !0;
                }
              return Oe;
            } catch (Oe) {
              throw new R(Oe);
            }
          }
        }).call(this, Q("_process"), Q("buffer").Buffer);
      }, { "./gif": 66, "./gifframe": 68, "./gifutil": 69, _process: 133, buffer: 48, omggif: 64 }], 68: [function(Q, de, q) {
        const ie = Q("./bitmapimage");
        Q("./gif");
        class i extends ie {
          // xOffset - x offset of bitmap on GIF (defaults to 0)
          // yOffset - y offset of bitmap on GIF (defaults to 0)
          // disposalMethod - pixel disposal method when handling partial images
          // delayCentisecs - duration of frame in hundredths of a second
          // interlaced - whether the image is interlaced (defaults to false)
          /**
           * GifFrame is a class representing an image frame of a GIF. GIFs contain one or more instances of GifFrame.
           * 
           * Property | Description
           * --- | ---
           * xOffset | x-coord of position within GIF at which to render the image (defaults to 0)
           * yOffset | y-coord of position within GIF at which to render the image (defaults to 0)
           * disposalMethod | GIF disposal method; only relevant when the frames aren't all the same size (defaults to 2, disposing to background color)
           * delayCentisecs | duration of the frame in hundreths of a second
           * interlaced | boolean indicating whether the frame renders interlaced
           * 
           * Its constructor supports the following signatures:
           * 
           * * new GifFrame(bitmap: {width: number, height: number, data: Buffer}, options?)
           * * new GifFrame(bitmapImage: BitmapImage, options?)
           * * new GifFrame(width: number, height: number, buffer: Buffer, options?)
           * * new GifFrame(width: number, height: number, backgroundRGBA?: number, options?)
           * * new GifFrame(frame: GifFrame)
           * 
           * See the base class BitmapImage for a discussion of all parameters but `options` and `frame`. `options` is an optional argument providing initial values for the above-listed GifFrame properties. Each property within option is itself optional.
           * 
           * Provide a `frame` to the constructor to create a clone of the provided frame. The new frame includes a copy of the provided frame's pixel data so that each can subsequently be modified without affecting each other.
           */
          constructor(...Z) {
            if (super(...Z), Z[0] instanceof i) {
              const R = Z[0];
              this.xOffset = R.xOffset, this.yOffset = R.yOffset, this.disposalMethod = R.disposalMethod, this.delayCentisecs = R.delayCentisecs, this.interlaced = R.interlaced;
            } else {
              const R = Z[Z.length - 1];
              let A = {};
              typeof R == "object" && !(R instanceof ie) && (A = R), this.xOffset = A.xOffset || 0, this.yOffset = A.yOffset || 0, this.disposalMethod = A.disposalMethod !== void 0 ? A.disposalMethod : i.DisposeToBackgroundColor, this.delayCentisecs = A.delayCentisecs || 8, this.interlaced = A.interlaced || !1;
            }
          }
          /**
           * Get a summary of the colors found within the frame. The return value is an object of the following form:
           * 
           * Property | Description
           * --- | ---
           * colors | An array of all the opaque colors found within the frame. Each color is given as an RGB number of the form 0xRRGGBB. The array is sorted by increasing number. Will be an empty array when the image is completely transparent.
           * usesTransparency | boolean indicating whether there are any transparent pixels within the frame. A pixel is considered transparent if its alpha value is 0x00.
           * indexCount | The number of color indexes required to represent this palette of colors. It is equal to the number of opaque colors plus one if the image includes transparency.
           * 
           * @return {object} An object representing a color palette as described above.
           */
          getPalette() {
            const Z = /* @__PURE__ */ new Set(), R = this.bitmap.data;
            let A = 0, M = !1;
            for (; A < R.length; ) {
              if (R[A + 3] === 0)
                M = !0;
              else {
                const k = R.readUInt32BE(A, !0) >> 8 & 16777215;
                Z.add(k);
              }
              A += 4;
            }
            const x = new Array(Z.size), m = Z.values();
            for (A = 0; A < x.length; ++A)
              x[A] = m.next().value;
            x.sort((k, E) => k - E);
            let w = x.length;
            return M && ++w, { colors: x, usesTransparency: M, indexCount: w };
          }
        }
        i.DisposeToAnything = 0, i.DisposeNothing = 1, i.DisposeToBackgroundColor = 2, i.DisposeToPrevious = 3, q.GifFrame = i;
      }, { "./bitmapimage": 65, "./gif": 66 }], 69: [function(Q, de, q) {
        (function(ie) {
          const i = Q("fs"), N = Q("image-q"), Z = Q("./bitmapimage"), { GifFrame: R } = Q("./gifframe"), { GifError: A } = Q("./gif"), { GifCodec: M } = Q("./gifcodec"), x = [".jpg", ".jpeg", ".png", ".bmp"], m = new M();
          q.cloneFrames = function(P) {
            let S = [];
            return P.forEach((U) => {
              S.push(new R(U));
            }), S;
          }, q.getColorInfo = function(P, S) {
            let U = !1;
            const j = [];
            for (let te = 0; te < P.length; ++te) {
              let le = P[te].getPalette();
              if (le.usesTransparency && (U = !0), le.indexCount > 256)
                throw new A(`Frame ${te} uses more than 256 color indexes`);
              j.push(le);
            }
            if (S === 0)
              return { usesTransparency: U, palettes: j };
            const T = /* @__PURE__ */ new Set();
            j.forEach((te) => {
              te.colors.forEach((le) => {
                T.add(le);
              });
            });
            let W = T.size;
            if (U && ++W, S && W > S)
              return { usesTransparency: U, palettes: j };
            const J = new Array(T.size), ee = T.values();
            for (let te = 0; te < J.length; ++te)
              J[te] = ee.next().value;
            return J.sort((te, le) => te - le), { colors: J, indexCount: W, usesTransparency: U, palettes: j };
          }, q.copyAsJimp = function(P, S) {
            return q.shareAsJimp(P, new Z(S));
          }, q.getMaxDimensions = function(P) {
            let S = 0, U = 0;
            return P.forEach((j) => {
              const T = j.xOffset + j.bitmap.width;
              T > S && (S = T);
              const W = j.yOffset + j.bitmap.height;
              W > U && (U = W);
            }), { maxWidth: S, maxHeight: U };
          }, q.quantizeDekker = function(P, S, U) {
            S = S || 256, w(P, "NeuQuantFloat", S, 0, U);
          }, q.quantizeSorokin = function(P, S, U, j) {
            S = S || 256, U = U || "min-pop";
            let T;
            switch (U) {
              case "min-pop":
                T = 2;
                break;
              case "top-pop":
                T = 1;
                break;
              default:
                throw new Error(`Invalid quantizeSorokin histogram '${U}'`);
            }
            w(P, "RGBQuant", S, T, j);
          }, q.quantizeWu = function(P, S, U, j) {
            if (S = S || 256, U = U || 5, U < 1 || U > 8)
              throw new Error("Invalid quantization quality");
            w(P, "WuQuant", S, U, j);
          }, q.read = function(P, S) {
            return S = S || m, ie.isBuffer(P) ? S.decodeGif(P) : k(P).then((U) => S.decodeGif(U));
          }, q.shareAsJimp = function(P, S) {
            const U = new P(
              S.bitmap.width,
              S.bitmap.height,
              0
            );
            return U.bitmap.data = S.bitmap.data, U;
          }, q.write = function(P, S, U, j) {
            j = j || m;
            const T = P.match(/\.[a-zA-Z]+$/);
            if (T !== null && x.includes(T[0].toLowerCase()))
              throw new Error(`GIF '${P}' has an unexpected suffix`);
            return j.encodeGif(S, U).then((W) => E(P, W.buffer).then(() => W));
          };
          function w(P, S, U, j, T) {
            const W = Array.isArray(P) ? P : [P], J = [
              "FloydSteinberg",
              "FalseFloydSteinberg",
              "Stucki",
              "Atkinson",
              "Jarvis",
              "Burkes",
              "Sierra",
              "TwoSierra",
              "SierraLite"
            ];
            if (T) {
              if (J.indexOf(T.ditherAlgorithm) < 0)
                throw new Error(`Invalid ditherAlgorithm '${T.ditherAlgorithm}'`);
              T.serpentine === void 0 && (T.serpentine = !0), T.minimumColorDistanceToDither === void 0 && (T.minimumColorDistanceToDither = 0), T.calculateErrorLikeGIMP === void 0 && (T.calculateErrorLikeGIMP = !1);
            }
            const ee = new N.distance.Euclidean(), te = new N.palette[S](ee, U, j);
            let le;
            T ? le = new N.image.ErrorDiffusionArray(
              ee,
              N.image.ErrorDiffusionArrayKernel[T.ditherAlgorithm],
              T.serpentine,
              T.minimumColorDistanceToDither,
              T.calculateErrorLikeGIMP
            ) : le = new N.image.NearestColor(ee);
            const me = [];
            W.forEach((ge) => {
              const Ve = ge.bitmap.data, Oe = new ArrayBuffer(Ve.length), Ue = new Uint32Array(Oe);
              for (let Ce = 0, it = 0; Ce < Ve.length; Ce += 4, ++it)
                Ue[it] = Ve.readUInt32LE(Ce, !0);
              const we = N.utils.PointContainer.fromUint32Array(
                Ue,
                ge.bitmap.width,
                ge.bitmap.height
              );
              te.sample(we), me.push(we);
            });
            const ke = te.quantize();
            for (let ge = 0; ge < W.length; ++ge) {
              const Ve = W[ge].bitmap.data, Ue = le.quantize(me[ge], ke).toUint32Array();
              for (let we = 0, Ce = 0; we < Ve.length; we += 4, ++Ce)
                Ve.writeUInt32LE(Ue[Ce], we);
            }
          }
          function k(P) {
            return new Promise((S, U) => {
              i.readFile(P, (j, T) => j ? U(j) : S(T));
            });
          }
          function E(P, S) {
            return new Promise((U, j) => {
              i.writeFile(P, S, (T) => T ? j(T) : U());
            });
          }
        }).call(this, { isBuffer: Q("../../is-buffer/index.js") });
      }, { "../../is-buffer/index.js": 76, "./bitmapimage": 65, "./gif": 66, "./gifcodec": 67, "./gifframe": 68, fs: 47, "image-q": 74 }], 70: [function(Q, de, q) {
        const ie = Q("./bitmapimage"), { Gif: i, GifError: N } = Q("./gif"), { GifCodec: Z } = Q("./gifcodec"), { GifFrame: R } = Q("./gifframe"), A = Q("./gifutil");
        de.exports = {
          BitmapImage: ie,
          Gif: i,
          GifCodec: Z,
          GifFrame: R,
          GifUtil: A,
          GifError: N
        };
      }, { "./bitmapimage": 65, "./gif": 66, "./gifcodec": 67, "./gifframe": 68, "./gifutil": 69 }], 71: [function(Q, de, q) {
        (function(ie) {
          var i;
          typeof qe < "u" ? i = qe : typeof ie < "u" ? i = ie : typeof self < "u" ? i = self : i = {}, de.exports = i;
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {});
      }, {}], 72: [function(Q, de, q) {
        var ie = Q("http"), i = Q("url"), N = de.exports;
        for (var Z in ie)
          ie.hasOwnProperty(Z) && (N[Z] = ie[Z]);
        N.request = function(A, M) {
          return A = R(A), ie.request.call(this, A, M);
        }, N.get = function(A, M) {
          return A = R(A), ie.get.call(this, A, M);
        };
        function R(A) {
          if (typeof A == "string" && (A = i.parse(A)), A.protocol || (A.protocol = "https:"), A.protocol !== "https:")
            throw new Error('Protocol "' + A.protocol + '" not supported. Expected "https:"');
          return A;
        }
      }, { http: 156, url: 180 }], 73: [function(Q, de, q) {
        q.read = function(ie, i, N, Z, R) {
          var A, M, x = R * 8 - Z - 1, m = (1 << x) - 1, w = m >> 1, k = -7, E = N ? R - 1 : 0, P = N ? -1 : 1, S = ie[i + E];
          for (E += P, A = S & (1 << -k) - 1, S >>= -k, k += x; k > 0; A = A * 256 + ie[i + E], E += P, k -= 8)
            ;
          for (M = A & (1 << -k) - 1, A >>= -k, k += Z; k > 0; M = M * 256 + ie[i + E], E += P, k -= 8)
            ;
          if (A === 0)
            A = 1 - w;
          else {
            if (A === m)
              return M ? NaN : (S ? -1 : 1) * (1 / 0);
            M = M + Math.pow(2, Z), A = A - w;
          }
          return (S ? -1 : 1) * M * Math.pow(2, A - Z);
        }, q.write = function(ie, i, N, Z, R, A) {
          var M, x, m, w = A * 8 - R - 1, k = (1 << w) - 1, E = k >> 1, P = R === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, S = Z ? 0 : A - 1, U = Z ? 1 : -1, j = i < 0 || i === 0 && 1 / i < 0 ? 1 : 0;
          for (i = Math.abs(i), isNaN(i) || i === 1 / 0 ? (x = isNaN(i) ? 1 : 0, M = k) : (M = Math.floor(Math.log(i) / Math.LN2), i * (m = Math.pow(2, -M)) < 1 && (M--, m *= 2), M + E >= 1 ? i += P / m : i += P * Math.pow(2, 1 - E), i * m >= 2 && (M++, m /= 2), M + E >= k ? (x = 0, M = k) : M + E >= 1 ? (x = (i * m - 1) * Math.pow(2, R), M = M + E) : (x = i * Math.pow(2, E - 1) * Math.pow(2, R), M = 0)); R >= 8; ie[N + S] = x & 255, S += U, x /= 256, R -= 8)
            ;
          for (M = M << R | x, w += R; w > 0; ie[N + S] = M & 255, S += U, M /= 256, w -= 8)
            ;
          ie[N + S - U] |= j * 128;
        };
      }, {}], 74: [function(Q, de, q) {
        (function(i, N) {
          typeof q == "object" && typeof de == "object" ? de.exports = N() : typeof q == "object" ? q.iq = N() : i.iq = N();
        })(this, function() {
          return (
            /******/
            function(ie) {
              var i = {};
              function N(Z) {
                if (i[Z])
                  return i[Z].exports;
                var R = i[Z] = {
                  /******/
                  exports: {},
                  /******/
                  id: Z,
                  /******/
                  loaded: !1
                  /******/
                };
                return ie[Z].call(R.exports, R, R.exports, N), R.loaded = !0, R.exports;
              }
              return N.m = ie, N.c = i, N.p = "", N(0);
            }([
              /* 0 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var Z = N(1);
                i.constants = Z;
                var R = N(3);
                i.conversion = R;
                var A = N(12);
                i.distance = A;
                var M = N(20);
                i.palette = M;
                var x = N(30);
                i.image = x;
                var m = N(35);
                i.quality = m;
                var w = N(37);
                i.utils = w;
              },
              /* 1 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * constants.ts - part of Image Quantization Library
                 */
                var Z = N(2);
                i.bt709 = Z;
              },
              /* 2 */
              /***/
              function(ie, i) {
                var N;
                (function(A) {
                  A[A.RED = 0.2126] = "RED", A[A.GREEN = 0.7152] = "GREEN", A[A.BLUE = 0.0722] = "BLUE", A[A.WHITE = 1] = "WHITE";
                })(N || (N = {})), i.Y = N;
                var Z;
                (function(A) {
                  A[A.RED = 0.64] = "RED", A[A.GREEN = 0.3] = "GREEN", A[A.BLUE = 0.15] = "BLUE", A[A.WHITE = 0.3127] = "WHITE";
                })(Z || (Z = {})), i.x = Z;
                var R;
                (function(A) {
                  A[A.RED = 0.33] = "RED", A[A.GREEN = 0.6] = "GREEN", A[A.BLUE = 0.06] = "BLUE", A[A.WHITE = 0.329] = "WHITE";
                })(R || (R = {})), i.y = R;
              },
              /* 3 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var Z = N(4);
                i.rgb2xyz = Z.rgb2xyz;
                var R = N(5);
                i.rgb2hsl = R.rgb2hsl;
                var A = N(7);
                i.rgb2lab = A.rgb2lab;
                var M = N(9);
                i.lab2xyz = M.lab2xyz;
                var x = N(10);
                i.lab2rgb = x.lab2rgb;
                var m = N(8);
                i.xyz2lab = m.xyz2lab;
                var w = N(11);
                i.xyz2rgb = w.xyz2rgb;
              },
              /* 4 */
              /***/
              function(ie, i) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgb2xyz.ts - part of Image Quantization Library
                 */
                function N(R) {
                  return R > 0.04045 ? Math.pow((R + 0.055) / 1.055, 2.4) : R / 12.92;
                }
                function Z(R, A, M) {
                  return R = N(R / 255), A = N(A / 255), M = N(M / 255), {
                    x: R * 0.4124 + A * 0.3576 + M * 0.1805,
                    y: R * 0.2126 + A * 0.7152 + M * 0.0722,
                    z: R * 0.0193 + A * 0.1192 + M * 0.9505
                  };
                }
                i.rgb2xyz = Z;
              },
              /* 5 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgb2hsl.ts - part of Image Quantization Library
                 */
                var Z = N(6);
                function R(A, M, x) {
                  var m = Z.min3(A, M, x), w = Z.max3(A, M, x), k = w - m, E = (m + w) / 510, P = 0;
                  E > 0 && E < 1 && (P = k / (E < 0.5 ? w + m : 510 - w - m));
                  var S = 0;
                  return k > 0 && (w === A ? S = (M - x) / k : w === M ? S = 2 + (x - A) / k : S = 4 + (A - M) / k, S *= 60, S < 0 && (S += 360)), { h: S, s: P, l: E };
                }
                i.rgb2hsl = R;
              },
              /* 6 */
              /***/
              function(ie, i) {
                function N(w) {
                  return w * (Math.PI / 180);
                }
                i.degrees2radians = N;
                function Z(w, k, E) {
                  var P = w;
                  return P < k && (P = k), P < E && (P = E), P;
                }
                i.max3 = Z;
                function R(w, k, E) {
                  var P = w;
                  return P > k && (P = k), P > E && (P = E), P;
                }
                i.min3 = R;
                function A(w, k, E) {
                  return w > E && (w = E), w < k && (w = k), w | 0;
                }
                i.intInRange = A;
                function M(w) {
                  return w = Math.round(w), w > 255 ? w = 255 : w < 0 && (w = 0), w;
                }
                i.inRange0to255Rounded = M;
                function x(w) {
                  return w > 255 ? w = 255 : w < 0 && (w = 0), w;
                }
                i.inRange0to255 = x;
                function m(w, k) {
                  var E = typeof w[0], P;
                  if (E === "number" || E === "string") {
                    for (var S = /* @__PURE__ */ Object.create(null), U = 0, j = w.length; U < j; U++) {
                      var T = w[U];
                      S[T] || S[T] === 0 || (S[T] = U);
                    }
                    P = w.sort(function(J, ee) {
                      return k(J, ee) || S[J] - S[ee];
                    });
                  } else {
                    var W = w.slice(0);
                    P = w.sort(function(J, ee) {
                      return k(J, ee) || W.indexOf(J) - W.indexOf(ee);
                    });
                  }
                  return P;
                }
                i.stableSort = m;
              },
              /* 7 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgb2lab.ts - part of Image Quantization Library
                 */
                var Z = N(4), R = N(8);
                function A(M, x, m) {
                  var w = Z.rgb2xyz(M, x, m);
                  return R.xyz2lab(w.x, w.y, w.z);
                }
                i.rgb2lab = A;
              },
              /* 8 */
              /***/
              function(ie, i) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * xyz2lab.ts - part of Image Quantization Library
                 */
                var N = 0.95047, Z = 1, R = 1.08883;
                function A(x) {
                  return x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
                }
                function M(x, m, w) {
                  if (x = A(x / N), m = A(m / Z), w = A(w / R), 116 * m - 16 < 0)
                    throw new Error("xxx");
                  return {
                    L: Math.max(0, 116 * m - 16),
                    a: 500 * (x - m),
                    b: 200 * (m - w)
                  };
                }
                i.xyz2lab = M;
              },
              /* 9 */
              /***/
              function(ie, i) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * lab2xyz.ts - part of Image Quantization Library
                 */
                var N = 0.95047, Z = 1, R = 1.08883;
                function A(x) {
                  return x > 0.206893034 ? Math.pow(x, 3) : (x - 16 / 116) / 7.787;
                }
                function M(x, m, w) {
                  var k = (x + 16) / 116, E = m / 500 + k, P = k - w / 200;
                  return {
                    x: N * A(E),
                    y: Z * A(k),
                    z: R * A(P)
                  };
                }
                i.lab2xyz = M;
              },
              /* 10 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * lab2rgb.ts - part of Image Quantization Library
                 */
                var Z = N(9), R = N(11);
                function A(M, x, m) {
                  var w = Z.lab2xyz(M, x, m);
                  return R.xyz2rgb(w.x, w.y, w.z);
                }
                i.lab2rgb = A;
              },
              /* 11 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * xyz2rgb.ts - part of Image Quantization Library
                 */
                var Z = N(6);
                function R(M) {
                  return M > 31308e-7 ? 1.055 * Math.pow(M, 1 / 2.4) - 0.055 : 12.92 * M;
                }
                function A(M, x, m) {
                  var w = R(M * 3.2406 + x * -1.5372 + m * -0.4986), k = R(M * -0.9689 + x * 1.8758 + m * 0.0415), E = R(M * 0.0557 + x * -0.204 + m * 1.057);
                  return {
                    r: Z.inRange0to255Rounded(w * 255),
                    g: Z.inRange0to255Rounded(k * 255),
                    b: Z.inRange0to255Rounded(E * 255)
                  };
                }
                i.xyz2rgb = A;
              },
              /* 12 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var Z = N(13);
                i.AbstractDistanceCalculator = Z.AbstractDistanceCalculator;
                var R = N(14);
                i.CIE94Textiles = R.CIE94Textiles, i.CIE94GraphicArts = R.CIE94GraphicArts;
                var A = N(15);
                i.CIEDE2000 = A.CIEDE2000;
                var M = N(16);
                i.CMETRIC = M.CMETRIC;
                var x = N(17);
                i.AbstractEuclidean = x.AbstractEuclidean, i.Euclidean = x.Euclidean, i.EuclideanRgbQuantWOAlpha = x.EuclideanRgbQuantWOAlpha, i.EuclideanRgbQuantWithAlpha = x.EuclideanRgbQuantWithAlpha;
                var m = N(18);
                i.AbstractManhattan = m.AbstractManhattan, i.Manhattan = m.Manhattan, i.ManhattanSRGB = m.ManhattanSRGB, i.ManhattanNommyde = m.ManhattanNommyde;
                var w = N(19);
                i.PNGQUANT = w.PNGQUANT;
              },
              /* 13 */
              /***/
              function(ie, i) {
                var N = function() {
                  function Z() {
                    this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
                  }
                  return Z.prototype.setWhitePoint = function(R, A, M, x) {
                    this._whitePoint = {
                      r: R > 0 ? 255 / R : 0,
                      g: A > 0 ? 255 / A : 0,
                      b: M > 0 ? 255 / M : 0,
                      a: x > 0 ? 255 / x : 0
                    }, this._maxDistance = this.calculateRaw(R, A, M, x, 0, 0, 0, 0);
                  }, Z.prototype.calculateNormalized = function(R, A) {
                    return this.calculateRaw(R.r, R.g, R.b, R.a, A.r, A.g, A.b, A.a) / this._maxDistance;
                  }, Z.prototype._setDefaults = function() {
                  }, Z;
                }();
                i.AbstractDistanceCalculator = N;
              },
              /* 14 */
              /***/
              function(ie, i, N) {
                var Z = this && this.__extends || function(k, E) {
                  for (var P in E) E.hasOwnProperty(P) && (k[P] = E[P]);
                  function S() {
                    this.constructor = k;
                  }
                  k.prototype = E === null ? Object.create(E) : (S.prototype = E.prototype, new S());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * cie94.ts - part of Image Quantization Library
                 */
                var R = N(13), A = N(7), M = N(6), x = function(k) {
                  Z(E, k);
                  function E() {
                    k.apply(this, arguments);
                  }
                  return E.prototype.calculateRaw = function(P, S, U, j, T, W, J, ee) {
                    var te = A.rgb2lab(M.inRange0to255(P * this._whitePoint.r), M.inRange0to255(S * this._whitePoint.g), M.inRange0to255(U * this._whitePoint.b)), le = A.rgb2lab(M.inRange0to255(T * this._whitePoint.r), M.inRange0to255(W * this._whitePoint.g), M.inRange0to255(J * this._whitePoint.b)), me = te.L - le.L, ke = te.a - le.a, ge = te.b - le.b, Ve = Math.sqrt(te.a * te.a + te.b * te.b), Oe = Math.sqrt(le.a * le.a + le.b * le.b), Ue = Ve - Oe, we = ke * ke + ge * ge - Ue * Ue;
                    we = we < 0 ? 0 : Math.sqrt(we);
                    var Ce = (ee - j) * this._whitePoint.a * this._kA;
                    return Math.sqrt(Math.pow(me / this._Kl, 2) + Math.pow(Ue / (1 + this._K1 * Ve), 2) + Math.pow(we / (1 + this._K2 * Ve), 2) + Math.pow(Ce, 2));
                  }, E;
                }(R.AbstractDistanceCalculator);
                i.AbstractCIE94 = x;
                var m = function(k) {
                  Z(E, k);
                  function E() {
                    k.apply(this, arguments);
                  }
                  return E.prototype._setDefaults = function() {
                    this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 0.25 * 50 / 255;
                  }, E;
                }(x);
                i.CIE94Textiles = m;
                var w = function(k) {
                  Z(E, k);
                  function E() {
                    k.apply(this, arguments);
                  }
                  return E.prototype._setDefaults = function() {
                    this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 0.25 * 100 / 255;
                  }, E;
                }(x);
                i.CIE94GraphicArts = w;
              },
              /* 15 */
              /***/
              function(ie, i, N) {
                var Z = this && this.__extends || function(m, w) {
                  for (var k in w) w.hasOwnProperty(k) && (m[k] = w[k]);
                  function E() {
                    this.constructor = m;
                  }
                  m.prototype = w === null ? Object.create(w) : (E.prototype = w.prototype, new E());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * ciede2000.ts - part of Image Quantization Library
                 */
                var R = N(13), A = N(7), M = N(6), x = function(m) {
                  Z(w, m);
                  function w() {
                    m.apply(this, arguments);
                  }
                  return w.prototype.calculateRaw = function(k, E, P, S, U, j, T, W) {
                    var J = A.rgb2lab(M.inRange0to255(k * this._whitePoint.r), M.inRange0to255(E * this._whitePoint.g), M.inRange0to255(P * this._whitePoint.b)), ee = A.rgb2lab(M.inRange0to255(U * this._whitePoint.r), M.inRange0to255(j * this._whitePoint.g), M.inRange0to255(T * this._whitePoint.b)), te = (W - S) * this._whitePoint.a * w._kA, le = this.calculateRawInLab(J, ee);
                    return Math.sqrt(le + te * te);
                  }, w.prototype.calculateRawInLab = function(k, E) {
                    var P = k.L, S = k.a, U = k.b, j = E.L, T = E.a, W = E.b, J = Math.sqrt(S * S + U * U), ee = Math.sqrt(T * T + W * W), te = Math.pow((J + ee) / 2, 7), le = 0.5 * (1 - Math.sqrt(te / (te + w._pow25to7))), me = (1 + le) * S, ke = (1 + le) * T, ge = Math.sqrt(me * me + U * U), Ve = Math.sqrt(ke * ke + W * W), Oe = ge * Ve, Ue = w._calculatehp(U, me), we = w._calculatehp(W, ke), Ce = Math.abs(Ue - we), it = j - P, ut = Ve - ge, bt = w._calculate_dHp(Oe, Ce, we, Ue), pt = w._calculate_ahp(Oe, Ce, Ue, we), Ke = w._calculateT(pt), dt = (ge + Ve) / 2, ct = Math.pow((P + j) / 2 - 50, 2), wt = 1 + 0.015 * ct / Math.sqrt(20 + ct), Ht = 1 + 0.045 * dt, $t = 1 + 0.015 * Ke * dt, rt = w._calculateRT(pt, dt), ri = it / wt, wi = ut / Ht, Qt = bt / $t;
                    return Math.pow(ri, 2) + Math.pow(wi, 2) + Math.pow(Qt, 2) + rt * wi * Qt;
                  }, w._calculatehp = function(k, E) {
                    var P = Math.atan2(k, E);
                    return P >= 0 ? P : P + w._deg360InRad;
                  }, w._calculateRT = function(k, E) {
                    var P = Math.pow(E, 7), S = 2 * Math.sqrt(P / (P + w._pow25to7)), U = w._deg30InRad * Math.exp(-Math.pow((k - w._deg275InRad) / w._deg25InRad, 2));
                    return -Math.sin(2 * U) * S;
                  }, w._calculateT = function(k) {
                    return 1 - 0.17 * Math.cos(k - w._deg30InRad) + 0.24 * Math.cos(k * 2) + 0.32 * Math.cos(k * 3 + w._deg6InRad) - 0.2 * Math.cos(k * 4 - w._deg63InRad);
                  }, w._calculate_ahp = function(k, E, P, S) {
                    var U = P + S;
                    return k == 0 ? U : E <= w._deg180InRad ? U / 2 : U < w._deg360InRad ? (U + w._deg360InRad) / 2 : (U - w._deg360InRad) / 2;
                  }, w._calculate_dHp = function(k, E, P, S) {
                    var U;
                    return k == 0 ? U = 0 : E <= w._deg180InRad ? U = P - S : P <= S ? U = P - S + w._deg360InRad : U = P - S - w._deg360InRad, 2 * Math.sqrt(k) * Math.sin(U / 2);
                  }, w._kA = 0.25 * 100 / 255, w._pow25to7 = Math.pow(25, 7), w._deg360InRad = M.degrees2radians(360), w._deg180InRad = M.degrees2radians(180), w._deg30InRad = M.degrees2radians(30), w._deg6InRad = M.degrees2radians(6), w._deg63InRad = M.degrees2radians(63), w._deg275InRad = M.degrees2radians(275), w._deg25InRad = M.degrees2radians(25), w;
                }(R.AbstractDistanceCalculator);
                i.CIEDE2000 = x;
              },
              /* 16 */
              /***/
              function(ie, i, N) {
                var Z = this && this.__extends || function(M, x) {
                  for (var m in x) x.hasOwnProperty(m) && (M[m] = x[m]);
                  function w() {
                    this.constructor = M;
                  }
                  M.prototype = x === null ? Object.create(x) : (w.prototype = x.prototype, new w());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * cmetric.ts - part of Image Quantization Library
                 */
                var R = N(13), A = function(M) {
                  Z(x, M);
                  function x() {
                    M.apply(this, arguments);
                  }
                  return x.prototype.calculateRaw = function(m, w, k, E, P, S, U, j) {
                    var T = (m + P) / 2 * this._whitePoint.r, W = (m - P) * this._whitePoint.r, J = (w - S) * this._whitePoint.g, ee = (k - U) * this._whitePoint.b, te = ((512 + T) * W * W >> 8) + 4 * J * J + ((767 - T) * ee * ee >> 8), le = (j - E) * this._whitePoint.a;
                    return Math.sqrt(te + le * le);
                  }, x;
                }(R.AbstractDistanceCalculator);
                i.CMETRIC = A;
              },
              /* 17 */
              /***/
              function(ie, i, N) {
                var Z = this && this.__extends || function(k, E) {
                  for (var P in E) E.hasOwnProperty(P) && (k[P] = E[P]);
                  function S() {
                    this.constructor = k;
                  }
                  k.prototype = E === null ? Object.create(E) : (S.prototype = E.prototype, new S());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * euclidean.ts - part of Image Quantization Library
                 */
                var R = N(13), A = N(2), M = function(k) {
                  Z(E, k);
                  function E() {
                    k.apply(this, arguments);
                  }
                  return E.prototype.calculateRaw = function(P, S, U, j, T, W, J, ee) {
                    var te = T - P, le = W - S, me = J - U, ke = ee - j;
                    return Math.sqrt(this._kR * te * te + this._kG * le * le + this._kB * me * me + this._kA * ke * ke);
                  }, E;
                }(R.AbstractDistanceCalculator);
                i.AbstractEuclidean = M;
                var x = function(k) {
                  Z(E, k);
                  function E() {
                    k.apply(this, arguments);
                  }
                  return E.prototype._setDefaults = function() {
                    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
                  }, E;
                }(M);
                i.Euclidean = x;
                var m = function(k) {
                  Z(E, k);
                  function E() {
                    k.apply(this, arguments);
                  }
                  return E.prototype._setDefaults = function() {
                    this._kR = A.Y.RED, this._kG = A.Y.GREEN, this._kB = A.Y.BLUE, this._kA = 1;
                  }, E;
                }(M);
                i.EuclideanRgbQuantWithAlpha = m;
                var w = function(k) {
                  Z(E, k);
                  function E() {
                    k.apply(this, arguments);
                  }
                  return E.prototype._setDefaults = function() {
                    this._kR = A.Y.RED, this._kG = A.Y.GREEN, this._kB = A.Y.BLUE, this._kA = 0;
                  }, E;
                }(M);
                i.EuclideanRgbQuantWOAlpha = w;
              },
              /* 18 */
              /***/
              function(ie, i, N) {
                var Z = this && this.__extends || function(k, E) {
                  for (var P in E) E.hasOwnProperty(P) && (k[P] = E[P]);
                  function S() {
                    this.constructor = k;
                  }
                  k.prototype = E === null ? Object.create(E) : (S.prototype = E.prototype, new S());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * manhattanNeuQuant.ts - part of Image Quantization Library
                 */
                var R = N(13), A = N(2), M = function(k) {
                  Z(E, k);
                  function E() {
                    k.apply(this, arguments);
                  }
                  return E.prototype.calculateRaw = function(P, S, U, j, T, W, J, ee) {
                    var te = T - P, le = W - S, me = J - U, ke = ee - j;
                    return te < 0 && (te = 0 - te), le < 0 && (le = 0 - le), me < 0 && (me = 0 - me), ke < 0 && (ke = 0 - ke), this._kR * te + this._kG * le + this._kB * me + this._kA * ke;
                  }, E;
                }(R.AbstractDistanceCalculator);
                i.AbstractManhattan = M;
                var x = function(k) {
                  Z(E, k);
                  function E() {
                    k.apply(this, arguments);
                  }
                  return E.prototype._setDefaults = function() {
                    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
                  }, E;
                }(M);
                i.Manhattan = x;
                var m = function(k) {
                  Z(E, k);
                  function E() {
                    k.apply(this, arguments);
                  }
                  return E.prototype._setDefaults = function() {
                    this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
                  }, E;
                }(M);
                i.ManhattanNommyde = m;
                var w = function(k) {
                  Z(E, k);
                  function E() {
                    k.apply(this, arguments);
                  }
                  return E.prototype._setDefaults = function() {
                    this._kR = A.Y.RED, this._kG = A.Y.GREEN, this._kB = A.Y.BLUE, this._kA = 1;
                  }, E;
                }(M);
                i.ManhattanSRGB = w;
              },
              /* 19 */
              /***/
              function(ie, i, N) {
                var Z = this && this.__extends || function(M, x) {
                  for (var m in x) x.hasOwnProperty(m) && (M[m] = x[m]);
                  function w() {
                    this.constructor = M;
                  }
                  M.prototype = x === null ? Object.create(x) : (w.prototype = x.prototype, new w());
                };
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * pngQuant.ts - part of Image Quantization Library
                 */
                var R = N(13), A = function(M) {
                  Z(x, M);
                  function x() {
                    M.apply(this, arguments);
                  }
                  return x.prototype.calculateRaw = function(m, w, k, E, P, S, U, j) {
                    var T = (j - E) * this._whitePoint.a;
                    return this._colordifference_ch(m * this._whitePoint.r, P * this._whitePoint.r, T) + this._colordifference_ch(w * this._whitePoint.g, S * this._whitePoint.g, T) + this._colordifference_ch(k * this._whitePoint.b, U * this._whitePoint.b, T);
                  }, x.prototype._colordifference_ch = function(m, w, k) {
                    var E = m - w, P = E + k;
                    return E * E + P * P;
                  }, x;
                }(R.AbstractDistanceCalculator);
                i.PNGQUANT = A;
              },
              /* 20 */
              /***/
              function(ie, i, N) {
                var Z = N(21);
                i.NeuQuant = Z.NeuQuant;
                var R = N(25);
                i.NeuQuantFloat = R.NeuQuantFloat;
                var A = N(26);
                i.RGBQuant = A.RGBQuant;
                var M = N(27);
                i.ColorHistogram = M.ColorHistogram;
                var x = N(29);
                i.WuQuant = x.WuQuant, i.WuColorCube = x.WuColorCube;
              },
              /* 21 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * neuquant.ts - part of Image Quantization Library
                 */
                var Z = N(22), R = N(24), A = 3, M = function() {
                  function m(w) {
                    this.r = this.g = this.b = this.a = w;
                  }
                  return m.prototype.toPoint = function() {
                    return R.Point.createByRGBA(this.r >> A, this.g >> A, this.b >> A, this.a >> A);
                  }, m.prototype.subtract = function(w, k, E, P) {
                    this.r -= w | 0, this.g -= k | 0, this.b -= E | 0, this.a -= P | 0;
                  }, m;
                }(), x = function() {
                  function m(w, k) {
                    k === void 0 && (k = 256), this._distance = w, this._pointArray = [], this._sampleFactor = 1, this._networkSize = k, this._distance.setWhitePoint(255 << A, 255 << A, 255 << A, 255 << A);
                  }
                  return m.prototype.sample = function(w) {
                    this._pointArray = this._pointArray.concat(w.getPointArray());
                  }, m.prototype.quantize = function() {
                    return this._init(), this._learn(), this._buildPalette();
                  }, m.prototype._init = function() {
                    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
                    for (var w = 0; w < this._networkSize; w++)
                      this._network[w] = new M((w << A + 8) / this._networkSize | 0), this._freq[w] = m._initialBias / this._networkSize | 0, this._bias[w] = 0;
                  }, m.prototype._learn = function() {
                    var w = this._sampleFactor, k = this._pointArray.length;
                    k < m._minpicturebytes && (w = 1);
                    var E = 30 + (w - 1) / 3 | 0, P = k / w | 0, S = P / m._nCycles | 0, U = m._initAlpha, j = (this._networkSize >> 3) * m._radiusBias, T = j >> m._radiusBiasShift;
                    T <= 1 && (T = 0);
                    for (var W = 0; W < T; W++)
                      this._radPower[W] = U * ((T * T - W * W) * m._radBias / (T * T)) >>> 0;
                    var J;
                    k < m._minpicturebytes ? J = 1 : k % m._prime1 != 0 ? J = m._prime1 : k % m._prime2 != 0 ? J = m._prime2 : k % m._prime3 != 0 ? J = m._prime3 : J = m._prime4;
                    for (var W = 0, ee = 0; W < P; ) {
                      var te = this._pointArray[ee], le = te.b << A, me = te.g << A, ke = te.r << A, ge = te.a << A, Ve = this._contest(le, me, ke, ge);
                      if (this._alterSingle(U, Ve, le, me, ke, ge), T !== 0 && this._alterNeighbour(T, Ve, le, me, ke, ge), ee += J, ee >= k && (ee -= k), W++, S === 0 && (S = 1), W % S === 0) {
                        U -= U / E | 0, j -= j / m._radiusDecrease | 0, T = j >> m._radiusBiasShift, T <= 1 && (T = 0);
                        for (var Oe = 0; Oe < T; Oe++)
                          this._radPower[Oe] = U * ((T * T - Oe * Oe) * m._radBias / (T * T)) >>> 0;
                      }
                    }
                  }, m.prototype._buildPalette = function() {
                    var w = new Z.Palette();
                    return this._network.forEach(function(k) {
                      w.add(k.toPoint());
                    }), w.sort(), w;
                  }, m.prototype._alterNeighbour = function(w, k, E, P, S, U) {
                    var j = k - w;
                    j < -1 && (j = -1);
                    var T = k + w;
                    T > this._networkSize && (T = this._networkSize);
                    for (var W = k + 1, J = k - 1, ee = 1; W < T || J > j; ) {
                      var te = this._radPower[ee++] / m._alphaRadBias;
                      if (W < T) {
                        var le = this._network[W++];
                        le.subtract(te * (le.r - S), te * (le.g - P), te * (le.b - E), te * (le.a - U));
                      }
                      if (J > j) {
                        var le = this._network[J--];
                        le.subtract(te * (le.r - S), te * (le.g - P), te * (le.b - E), te * (le.a - U));
                      }
                    }
                  }, m.prototype._alterSingle = function(w, k, E, P, S, U) {
                    w /= m._initAlpha;
                    var j = this._network[k];
                    j.subtract(w * (j.r - S), w * (j.g - P), w * (j.b - E), w * (j.a - U));
                  }, m.prototype._contest = function(w, k, E, P) {
                    for (var S = 1020 << A, U = ~(1 << 31), j = U, T = -1, W = T, J = 0; J < this._networkSize; J++) {
                      var ee = this._network[J], te = this._distance.calculateNormalized(ee, { r: E, g: k, b: w, a: P }) * S | 0;
                      te < U && (U = te, T = J);
                      var le = te - (this._bias[J] >> m._initialBiasShift - A);
                      le < j && (j = le, W = J);
                      var me = this._freq[J] >> m._betaShift;
                      this._freq[J] -= me, this._bias[J] += me << m._gammaShift;
                    }
                    return this._freq[T] += m._beta, this._bias[T] -= m._betaGamma, W;
                  }, m._prime1 = 499, m._prime2 = 491, m._prime3 = 487, m._prime4 = 503, m._minpicturebytes = m._prime4, m._nCycles = 100, m._initialBiasShift = 16, m._initialBias = 1 << m._initialBiasShift, m._gammaShift = 10, m._betaShift = 10, m._beta = m._initialBias >> m._betaShift, m._betaGamma = m._initialBias << m._gammaShift - m._betaShift, m._radiusBiasShift = 6, m._radiusBias = 1 << m._radiusBiasShift, m._radiusDecrease = 30, m._alphaBiasShift = 10, m._initAlpha = 1 << m._alphaBiasShift, m._radBiasShift = 8, m._radBias = 1 << m._radBiasShift, m._alphaRadBiasShift = m._alphaBiasShift + m._radBiasShift, m._alphaRadBias = 1 << m._alphaRadBiasShift, m;
                }();
                i.NeuQuant = x;
              },
              /* 22 */
              /***/
              function(ie, i, N) {
                var Z = N(23), R = N(5), A = 10;
                function M(m, w) {
                  for (var k = 360, E = k / w, P = E / 2, S = 1, U = E - P; S < w; S++, U += E)
                    if (m >= U && m < U + E)
                      return S;
                  return 0;
                }
                i.hueGroup = M;
                var x = function() {
                  function m() {
                    this._pointArray = [], this._i32idx = {}, this._pointContainer = new Z.PointContainer(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
                  }
                  return m.prototype.add = function(w) {
                    this._pointArray.push(w), this._pointContainer.setWidth(this._pointArray.length);
                  }, m.prototype.has = function(w) {
                    for (var k = this._pointArray.length - 1; k >= 0; k--)
                      if (w.uint32 === this._pointArray[k].uint32)
                        return !0;
                    return !1;
                  }, m.prototype.getNearestColor = function(w, k) {
                    return this._pointArray[this.getNearestIndex(w, k) | 0];
                  }, m.prototype.getPointContainer = function() {
                    return this._pointContainer;
                  }, m.prototype._nearestPointFromCache = function(w) {
                    return typeof this._i32idx[w] == "number" ? this._i32idx[w] : -1;
                  }, m.prototype.getNearestIndex = function(w, k) {
                    var E = this._nearestPointFromCache("" + k.uint32);
                    if (E >= 0)
                      return E;
                    var P = Number.MAX_VALUE;
                    E = 0;
                    for (var S = 0, U = this._pointArray.length; S < U; S++) {
                      var j = this._pointArray[S], T = w.calculateRaw(k.r, k.g, k.b, k.a, j.r, j.g, j.b, j.a);
                      T < P && (P = T, E = S);
                    }
                    return this._i32idx[k.uint32] = E, E;
                  }, m.prototype.sort = function() {
                    this._i32idx = {}, this._pointArray.sort(function(w, k) {
                      var E = R.rgb2hsl(w.r, w.g, w.b), P = R.rgb2hsl(k.r, k.g, k.b), S = w.r === w.g && w.g === w.b ? 0 : 1 + M(E.h, A), U = k.r === k.g && k.g === k.b ? 0 : 1 + M(P.h, A), j = U - S;
                      if (j)
                        return -j;
                      var T = w.getLuminosity(!0), W = k.getLuminosity(!0);
                      if (W - T !== 0)
                        return W - T;
                      var J = (P.s * 100 | 0) - (E.s * 100 | 0);
                      return J ? -J : 0;
                    });
                  }, m;
                }();
                i.Palette = x;
              },
              /* 23 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * pointContainer.ts - part of Image Quantization Library
                 */
                var Z = N(24), R = function() {
                  function A() {
                    this._width = 0, this._height = 0, this._pointArray = [];
                  }
                  return A.prototype.getWidth = function() {
                    return this._width;
                  }, A.prototype.getHeight = function() {
                    return this._height;
                  }, A.prototype.setWidth = function(M) {
                    this._width = M;
                  }, A.prototype.setHeight = function(M) {
                    this._height = M;
                  }, A.prototype.getPointArray = function() {
                    return this._pointArray;
                  }, A.prototype.clone = function() {
                    var M = new A();
                    M._width = this._width, M._height = this._height;
                    for (var x = 0, m = this._pointArray.length; x < m; x++)
                      M._pointArray[x] = Z.Point.createByUint32(this._pointArray[x].uint32 | 0);
                    return M;
                  }, A.prototype.toUint32Array = function() {
                    for (var M = this._pointArray.length, x = new Uint32Array(M), m = 0; m < M; m++)
                      x[m] = this._pointArray[m].uint32;
                    return x;
                  }, A.prototype.toUint8Array = function() {
                    return new Uint8Array(this.toUint32Array().buffer);
                  }, A.fromHTMLImageElement = function(M) {
                    var x = M.naturalWidth, m = M.naturalHeight, w = document.createElement("canvas");
                    w.width = x, w.height = m;
                    var k = w.getContext("2d");
                    return k.drawImage(M, 0, 0, x, m, 0, 0, x, m), A.fromHTMLCanvasElement(w);
                  }, A.fromHTMLCanvasElement = function(M) {
                    var x = M.width, m = M.height, w = M.getContext("2d"), k = w.getImageData(0, 0, x, m);
                    return A.fromImageData(k);
                  }, A.fromNodeCanvas = function(M) {
                    return A.fromHTMLCanvasElement(M);
                  }, A.fromImageData = function(M) {
                    var x = M.width, m = M.height;
                    return A.fromCanvasPixelArray(M.data, x, m);
                  }, A.fromArray = function(M, x, m) {
                    var w = new Uint8Array(M);
                    return A.fromUint8Array(w, x, m);
                  }, A.fromCanvasPixelArray = function(M, x, m) {
                    return A.fromArray(M, x, m);
                  }, A.fromUint8Array = function(M, x, m) {
                    return A.fromUint32Array(new Uint32Array(M.buffer), x, m);
                  }, A.fromUint32Array = function(M, x, m) {
                    var w = new A();
                    w._width = x, w._height = m;
                    for (var k = 0, E = M.length; k < E; k++)
                      w._pointArray[k] = Z.Point.createByUint32(M[k] | 0);
                    return w;
                  }, A;
                }();
                i.PointContainer = R;
              },
              /* 24 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * point.ts - part of Image Quantization Library
                 */
                var Z = N(2), R = function() {
                  function A() {
                    this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
                  }
                  return A.createByQuadruplet = function(M) {
                    var x = new A();
                    return x.r = M[0] | 0, x.g = M[1] | 0, x.b = M[2] | 0, x.a = M[3] | 0, x._loadUINT32(), x._loadQuadruplet(), x;
                  }, A.createByRGBA = function(M, x, m, w) {
                    var k = new A();
                    return k.r = M | 0, k.g = x | 0, k.b = m | 0, k.a = w | 0, k._loadUINT32(), k._loadQuadruplet(), k;
                  }, A.createByUint32 = function(M) {
                    var x = new A();
                    return x.uint32 = M >>> 0, x._loadRGBA(), x._loadQuadruplet(), x;
                  }, A.prototype.from = function(M) {
                    this.r = M.r, this.g = M.g, this.b = M.b, this.a = M.a, this.uint32 = M.uint32, this.rgba[0] = M.r, this.rgba[1] = M.g, this.rgba[2] = M.b, this.rgba[3] = M.a;
                  }, A.prototype.getLuminosity = function(M) {
                    var x = this.r, m = this.g, w = this.b;
                    return M && (x = Math.min(255, 255 - this.a + this.a * x / 255), m = Math.min(255, 255 - this.a + this.a * m / 255), w = Math.min(255, 255 - this.a + this.a * w / 255)), x * Z.Y.RED + m * Z.Y.GREEN + w * Z.Y.BLUE;
                  }, A.prototype._loadUINT32 = function() {
                    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
                  }, A.prototype._loadRGBA = function() {
                    this.r = this.uint32 & 255, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
                  }, A.prototype._loadQuadruplet = function() {
                    this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
                  }, A;
                }();
                i.Point = R;
              },
              /* 25 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * neuquant.ts - part of Image Quantization Library
                 */
                var Z = N(22), R = N(24), A = 3, M = function() {
                  function m(w) {
                    this.r = this.g = this.b = this.a = w;
                  }
                  return m.prototype.toPoint = function() {
                    return R.Point.createByRGBA(this.r >> A, this.g >> A, this.b >> A, this.a >> A);
                  }, m.prototype.subtract = function(w, k, E, P) {
                    this.r -= w, this.g -= k, this.b -= E, this.a -= P;
                  }, m;
                }(), x = function() {
                  function m(w, k) {
                    k === void 0 && (k = 256), this._distance = w, this._pointArray = [], this._sampleFactor = 1, this._networkSize = k, this._distance.setWhitePoint(255 << A, 255 << A, 255 << A, 255 << A);
                  }
                  return m.prototype.sample = function(w) {
                    this._pointArray = this._pointArray.concat(w.getPointArray());
                  }, m.prototype.quantize = function() {
                    return this._init(), this._learn(), this._buildPalette();
                  }, m.prototype._init = function() {
                    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
                    for (var w = 0; w < this._networkSize; w++)
                      this._network[w] = new M((w << A + 8) / this._networkSize), this._freq[w] = m._initialBias / this._networkSize, this._bias[w] = 0;
                  }, m.prototype._learn = function() {
                    var w = this._sampleFactor, k = this._pointArray.length;
                    k < m._minpicturebytes && (w = 1);
                    var E = 30 + (w - 1) / 3, P = k / w, S = P / m._nCycles | 0, U = m._initAlpha, j = (this._networkSize >> 3) * m._radiusBias, T = j >> m._radiusBiasShift;
                    T <= 1 && (T = 0);
                    for (var W = 0; W < T; W++)
                      this._radPower[W] = U * ((T * T - W * W) * m._radBias / (T * T));
                    var J;
                    k < m._minpicturebytes ? J = 1 : k % m._prime1 != 0 ? J = m._prime1 : k % m._prime2 != 0 ? J = m._prime2 : k % m._prime3 != 0 ? J = m._prime3 : J = m._prime4;
                    for (var W = 0, ee = 0; W < P; ) {
                      var te = this._pointArray[ee], le = te.b << A, me = te.g << A, ke = te.r << A, ge = te.a << A, Ve = this._contest(le, me, ke, ge);
                      if (this._alterSingle(U, Ve, le, me, ke, ge), T != 0 && this._alterNeighbour(T, Ve, le, me, ke, ge), ee += J, ee >= k && (ee -= k), W++, S == 0 && (S = 1), W % S == 0) {
                        U -= U / E, j -= j / m._radiusDecrease, T = j >> m._radiusBiasShift, T <= 1 && (T = 0);
                        for (var Oe = 0; Oe < T; Oe++)
                          this._radPower[Oe] = U * ((T * T - Oe * Oe) * m._radBias / (T * T));
                      }
                    }
                  }, m.prototype._buildPalette = function() {
                    var w = new Z.Palette();
                    return this._network.forEach(function(k) {
                      w.add(k.toPoint());
                    }), w.sort(), w;
                  }, m.prototype._alterNeighbour = function(w, k, E, P, S, U) {
                    var j = k - w;
                    j < -1 && (j = -1);
                    var T = k + w;
                    T > this._networkSize && (T = this._networkSize);
                    for (var W = k + 1, J = k - 1, ee = 1; W < T || J > j; ) {
                      var te = this._radPower[ee++] / m._alphaRadBias;
                      if (W < T) {
                        var le = this._network[W++];
                        le.subtract(te * (le.r - S), te * (le.g - P), te * (le.b - E), te * (le.a - U));
                      }
                      if (J > j) {
                        var le = this._network[J--];
                        le.subtract(te * (le.r - S), te * (le.g - P), te * (le.b - E), te * (le.a - U));
                      }
                    }
                  }, m.prototype._alterSingle = function(w, k, E, P, S, U) {
                    w /= m._initAlpha;
                    var j = this._network[k];
                    j.subtract(w * (j.r - S), w * (j.g - P), w * (j.b - E), w * (j.a - U));
                  }, m.prototype._contest = function(w, k, E, P) {
                    for (var S = 1020 << A, U = ~(1 << 31), j = U, T = -1, W = T, J = 0; J < this._networkSize; J++) {
                      var ee = this._network[J], te = this._distance.calculateNormalized(ee, { r: E, g: k, b: w, a: P }) * S;
                      te < U && (U = te, T = J);
                      var le = te - (this._bias[J] >> m._initialBiasShift - A);
                      le < j && (j = le, W = J);
                      var me = this._freq[J] >> m._betaShift;
                      this._freq[J] -= me, this._bias[J] += me << m._gammaShift;
                    }
                    return this._freq[T] += m._beta, this._bias[T] -= m._betaGamma, W;
                  }, m._prime1 = 499, m._prime2 = 491, m._prime3 = 487, m._prime4 = 503, m._minpicturebytes = m._prime4, m._nCycles = 100, m._initialBiasShift = 16, m._initialBias = 1 << m._initialBiasShift, m._gammaShift = 10, m._betaShift = 10, m._beta = m._initialBias >> m._betaShift, m._betaGamma = m._initialBias << m._gammaShift - m._betaShift, m._radiusBiasShift = 6, m._radiusBias = 1 << m._radiusBiasShift, m._radiusDecrease = 30, m._alphaBiasShift = 10, m._initAlpha = 1 << m._alphaBiasShift, m._radBiasShift = 8, m._radBias = 1 << m._radBiasShift, m._alphaRadBiasShift = m._alphaBiasShift + m._radBiasShift, m._alphaRadBias = 1 << m._alphaRadBiasShift, m;
                }();
                i.NeuQuantFloat = x;
              },
              /* 26 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * rgbquant.ts - part of Image Quantization Library
                 */
                var Z = N(22), R = N(24), A = N(27), M = N(6), x = /* @__PURE__ */ function() {
                  function w(k, E, P) {
                    this.index = k, this.color = E, this.distance = P;
                  }
                  return w;
                }(), m = function() {
                  function w(k, E, P) {
                    E === void 0 && (E = 256), P === void 0 && (P = 2), this._distance = k, this._colors = E, this._histogram = new A.ColorHistogram(P, E), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
                  }
                  return w.prototype.sample = function(k) {
                    this._histogram.sample(k);
                  }, w.prototype.quantize = function() {
                    var k = this._histogram.getImportanceSortedColorsIDXI32();
                    if (k.length === 0)
                      throw new Error("No colors in image");
                    var E = this._buildPalette(k);
                    return E.sort(), E;
                  }, w.prototype._buildPalette = function(k) {
                    for (var E = new Z.Palette(), P = E.getPointContainer().getPointArray(), S = new Array(k.length), U = 0; U < k.length; U++)
                      P.push(R.Point.createByUint32(k[U])), S[U] = 1;
                    for (var j = P.length, T = [], W = j, J = this._initialDistance; W > this._colors; ) {
                      T.length = 0;
                      for (var U = 0; U < j; U++)
                        if (S[U] !== 0) {
                          for (var ee = P[U], te = U + 1; te < j; te++)
                            if (S[te] !== 0) {
                              var le = P[te], me = this._distance.calculateNormalized(ee, le);
                              me < J && (T.push(new x(te, le, me)), S[te] = 0, W--);
                            }
                        }
                      J += W > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
                    }
                    if (W < this._colors) {
                      M.stableSort(T, function(Ue, we) {
                        return we.distance - Ue.distance;
                      });
                      for (var ke = 0; W < this._colors && ke < T.length; ) {
                        var ge = T[ke];
                        S[ge.index] = 1, W++, ke++;
                      }
                    }
                    for (var Ve = P.length, Oe = Ve - 1; Oe >= 0; Oe--)
                      S[Oe] === 0 && (Oe !== Ve - 1 && (P[Oe] = P[Ve - 1]), --Ve);
                    return P.length = Ve, E;
                  }, w;
                }();
                i.RGBQuant = m;
              },
              /* 27 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve TypeScript port:
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * colorHistogram.ts - part of Image Quantization Library
                 */
                var Z = N(28), R = N(6), A = function() {
                  function M(x, m) {
                    this._method = x, this._minHueCols = m << 2, this._initColors = m << 2, this._hueStats = new Z.HueStatistics(M._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
                  }
                  return M.prototype.sample = function(x) {
                    switch (this._method) {
                      case 1:
                        this._colorStats1D(x);
                        break;
                      case 2:
                        this._colorStats2D(x);
                        break;
                    }
                  }, M.prototype.getImportanceSortedColorsIDXI32 = function() {
                    var x = this, m = R.stableSort(Object.keys(this._histogram), function(j, T) {
                      return x._histogram[T] - x._histogram[j];
                    });
                    if (m.length === 0)
                      return [];
                    var w;
                    switch (this._method) {
                      case 1:
                        var k = Math.min(m.length, this._initColors), E = m[k - 1], P = this._histogram[E];
                        w = m.slice(0, k);
                        for (var S = k, U = m.length; S < U && this._histogram[m[S]] == P; )
                          w.push(m[S++]);
                        this._hueStats.injectIntoArray(w);
                        break;
                      case 2:
                        w = m;
                        break;
                      default:
                        throw new Error("Incorrect method");
                    }
                    return w.map(function(j) {
                      return +j;
                    });
                  }, M.prototype._colorStats1D = function(x) {
                    for (var m = this._histogram, w = x.getPointArray(), k = w.length, E = 0; E < k; E++) {
                      var P = w[E].uint32;
                      this._hueStats.check(P), P in m ? m[P]++ : m[P] = 1;
                    }
                  }, M.prototype._colorStats2D = function(x) {
                    var m = this, w = x.getWidth(), k = x.getHeight(), E = x.getPointArray(), P = M._boxSize[0], S = M._boxSize[1], U = P * S, j = this._makeBoxes(w, k, P, S), T = this._histogram;
                    j.forEach(function(W) {
                      var J = Math.round(W.w * W.h / U) * M._boxPixels;
                      J < 2 && (J = 2);
                      var ee = {};
                      m._iterateBox(W, w, function(te) {
                        var le = E[te].uint32;
                        m._hueStats.check(le), le in T ? T[le]++ : le in ee ? ++ee[le] >= J && (T[le] = ee[le]) : ee[le] = 1;
                      });
                    }), this._hueStats.injectIntoDictionary(T);
                  }, M.prototype._iterateBox = function(x, m, w) {
                    var k = x, E = k.y * m + k.x, P = (k.y + k.h - 1) * m + (k.x + k.w - 1), S = m - k.w + 1, U = 0, j = E;
                    do
                      w.call(this, j), j += ++U % k.w == 0 ? S : 1;
                    while (j <= P);
                  }, M.prototype._makeBoxes = function(x, m, w, k) {
                    for (var E = x % w, P = m % k, S = x - E, U = m - P, j = [], T = 0; T < m; T += k)
                      for (var W = 0; W < x; W += w)
                        j.push({ x: W, y: T, w: W == S ? E : w, h: T == U ? P : k });
                    return j;
                  }, M._boxSize = [64, 64], M._boxPixels = 2, M._hueGroups = 10, M;
                }();
                i.ColorHistogram = A;
              },
              /* 28 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * hueStatistics.ts - part of Image Quantization Library
                 */
                var Z = N(5), R = N(22), A = /* @__PURE__ */ function() {
                  function x() {
                    this.num = 0, this.cols = [];
                  }
                  return x;
                }(), M = function() {
                  function x(m, w) {
                    this._numGroups = m, this._minCols = w, this._stats = [];
                    for (var k = 0; k <= m; k++)
                      this._stats[k] = new A();
                    this._groupsFull = 0;
                  }
                  return x.prototype.check = function(m) {
                    this._groupsFull == this._numGroups + 1 && (this.check = function() {
                    });
                    var w = m & 255, k = m >>> 8 & 255, E = m >>> 16 & 255, P = w == k && k == E ? 0 : 1 + R.hueGroup(Z.rgb2hsl(w, k, E).h, this._numGroups), S = this._stats[P], U = this._minCols;
                    S.num++, !(S.num > U) && (S.num == U && this._groupsFull++, S.num <= U && this._stats[P].cols.push(m));
                  }, x.prototype.injectIntoDictionary = function(m) {
                    for (var w = 0; w <= this._numGroups; w++)
                      this._stats[w].num <= this._minCols && this._stats[w].cols.forEach(function(k) {
                        m[k] ? m[k]++ : m[k] = 1;
                      });
                  }, x.prototype.injectIntoArray = function(m) {
                    for (var w = 0; w <= this._numGroups; w++)
                      this._stats[w].num <= this._minCols && this._stats[w].cols.forEach(function(k) {
                        m.indexOf(k) == -1 && m.push(k);
                      });
                  }, x;
                }();
                i.HueStatistics = M;
              },
              /* 29 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * wuQuant.ts - part of Image Quantization Library
                 */
                var Z = N(22), R = N(24);
                function A(P) {
                  for (var S = [], U = 0; U < P; U++)
                    S[U] = 0;
                  return S;
                }
                function M(P, S, U, j) {
                  for (var T = new Array(P), W = 0; W < P; W++) {
                    T[W] = new Array(S);
                    for (var J = 0; J < S; J++) {
                      T[W][J] = new Array(U);
                      for (var ee = 0; ee < U; ee++) {
                        T[W][J][ee] = new Array(j);
                        for (var te = 0; te < j; te++)
                          T[W][J][ee][te] = 0;
                      }
                    }
                  }
                  return T;
                }
                function x(P, S, U) {
                  for (var j = new Array(P), T = 0; T < P; T++) {
                    j[T] = new Array(S);
                    for (var W = 0; W < S; W++) {
                      j[T][W] = new Array(U);
                      for (var J = 0; J < U; J++)
                        j[T][W][J] = 0;
                    }
                  }
                  return j;
                }
                function m(P, S, U, j, T) {
                  for (var W = 0; W < S; W++) {
                    P[W] = [];
                    for (var J = 0; J < U; J++) {
                      P[W][J] = [];
                      for (var ee = 0; ee < j; ee++)
                        P[W][J][ee] = T;
                    }
                  }
                }
                function w(P, S, U) {
                  for (var j = 0; j < S; j++)
                    P[j] = U;
                }
                var k = /* @__PURE__ */ function() {
                  function P() {
                  }
                  return P;
                }();
                i.WuColorCube = k;
                var E = function() {
                  function P(S, U, j) {
                    U === void 0 && (U = 256), j === void 0 && (j = 5), this._distance = S, this._setQuality(j), this._initialize(U);
                  }
                  return P.prototype.sample = function(S) {
                    for (var U = S.getPointArray(), j = 0, T = U.length; j < T; j++)
                      this._addColor(U[j]);
                    this._pixels = this._pixels.concat(U);
                  }, P.prototype.quantize = function() {
                    this._preparePalette();
                    for (var S = new Z.Palette(), U = 0; U < this._colors; U++)
                      if (this._sums[U] > 0) {
                        var j = this._sums[U], T = this._reds[U] / j, W = this._greens[U] / j, J = this._blues[U] / j, ee = this._alphas[U] / j, te = R.Point.createByRGBA(T | 0, W | 0, J | 0, ee | 0);
                        S.add(te);
                      }
                    return S.sort(), S;
                  }, P.prototype._preparePalette = function() {
                    this._calculateMoments();
                    for (var S = 0, U = A(this._colors), j = 1; j < this._colors; ++j) {
                      this._cut(this._cubes[S], this._cubes[j]) ? (U[S] = this._cubes[S].volume > 1 ? this._calculateVariance(this._cubes[S]) : 0, U[j] = this._cubes[j].volume > 1 ? this._calculateVariance(this._cubes[j]) : 0) : (U[S] = 0, j--), S = 0;
                      for (var T = U[0], W = 1; W <= j; ++W)
                        U[W] > T && (T = U[W], S = W);
                      if (T <= 0) {
                        this._colors = j + 1;
                        break;
                      }
                    }
                    for (var J = [], ee = [], te = [], le = [], me = 0; me < this._colors; ++me) {
                      var ke = P._volume(this._cubes[me], this._weights);
                      ke > 0 ? (J[me] = P._volume(this._cubes[me], this._momentsRed) / ke | 0, ee[me] = P._volume(this._cubes[me], this._momentsGreen) / ke | 0, te[me] = P._volume(this._cubes[me], this._momentsBlue) / ke | 0, le[me] = P._volume(this._cubes[me], this._momentsAlpha) / ke | 0) : (J[me] = 0, ee[me] = 0, te[me] = 0, le[me] = 0);
                    }
                    this._reds = A(this._colors + 1), this._greens = A(this._colors + 1), this._blues = A(this._colors + 1), this._alphas = A(this._colors + 1), this._sums = A(this._colors + 1);
                    for (var W = 0, ge = this._pixels.length; W < ge; W++) {
                      for (var Ve = this._pixels[W], Oe = -1, Ue = Oe, we = Number.MAX_VALUE, Ce = 0; Ce < this._colors; Ce++) {
                        var it = J[Ce], ut = ee[Ce], bt = te[Ce], pt = le[Ce], Ke = this._distance.calculateRaw(it, ut, bt, pt, Ve.r, Ve.g, Ve.b, Ve.a);
                        Ke < we && (we = Ke, Ue = Ce);
                      }
                      this._reds[Ue] += Ve.r, this._greens[Ue] += Ve.g, this._blues[Ue] += Ve.b, this._alphas[Ue] += Ve.a, this._sums[Ue]++;
                    }
                  }, P.prototype._addColor = function(S) {
                    var U = 8 - this._significantBitsPerChannel, j = (S.r >> U) + 1, T = (S.g >> U) + 1, W = (S.b >> U) + 1, J = (S.a >> U) + 1;
                    this._weights[J][j][T][W]++, this._momentsRed[J][j][T][W] += S.r, this._momentsGreen[J][j][T][W] += S.g, this._momentsBlue[J][j][T][W] += S.b, this._momentsAlpha[J][j][T][W] += S.a, this._moments[J][j][T][W] += this._table[S.r] + this._table[S.g] + this._table[S.b] + this._table[S.a];
                  }, P.prototype._calculateMoments = function() {
                    for (var S = [], U = [], j = [], T = [], W = [], J = [], ee = x(this._sideSize, this._sideSize, this._sideSize), te = x(this._sideSize, this._sideSize, this._sideSize), le = x(this._sideSize, this._sideSize, this._sideSize), me = x(this._sideSize, this._sideSize, this._sideSize), ke = x(this._sideSize, this._sideSize, this._sideSize), ge = x(this._sideSize, this._sideSize, this._sideSize), Ve = 1; Ve <= this._alphaMaxSideIndex; ++Ve) {
                      m(ee, this._sideSize, this._sideSize, this._sideSize, 0), m(te, this._sideSize, this._sideSize, this._sideSize, 0), m(le, this._sideSize, this._sideSize, this._sideSize, 0), m(me, this._sideSize, this._sideSize, this._sideSize, 0), m(ke, this._sideSize, this._sideSize, this._sideSize, 0), m(ge, this._sideSize, this._sideSize, this._sideSize, 0);
                      for (var Oe = 1; Oe <= this._maxSideIndex; ++Oe) {
                        w(S, this._sideSize, 0), w(U, this._sideSize, 0), w(j, this._sideSize, 0), w(T, this._sideSize, 0), w(W, this._sideSize, 0), w(J, this._sideSize, 0);
                        for (var Ue = 1; Ue <= this._maxSideIndex; ++Ue)
                          for (var we = 0, Ce = 0, it = 0, ut = 0, bt = 0, pt = 0, Ke = 1; Ke <= this._maxSideIndex; ++Ke)
                            we += this._weights[Ve][Oe][Ue][Ke], Ce += this._momentsRed[Ve][Oe][Ue][Ke], it += this._momentsGreen[Ve][Oe][Ue][Ke], ut += this._momentsBlue[Ve][Oe][Ue][Ke], bt += this._momentsAlpha[Ve][Oe][Ue][Ke], pt += this._moments[Ve][Oe][Ue][Ke], S[Ke] += we, U[Ke] += Ce, j[Ke] += it, T[Ke] += ut, W[Ke] += bt, J[Ke] += pt, ee[Oe][Ue][Ke] = ee[Oe - 1][Ue][Ke] + S[Ke], te[Oe][Ue][Ke] = te[Oe - 1][Ue][Ke] + U[Ke], le[Oe][Ue][Ke] = le[Oe - 1][Ue][Ke] + j[Ke], me[Oe][Ue][Ke] = me[Oe - 1][Ue][Ke] + T[Ke], ke[Oe][Ue][Ke] = ke[Oe - 1][Ue][Ke] + W[Ke], ge[Oe][Ue][Ke] = ge[Oe - 1][Ue][Ke] + J[Ke], this._weights[Ve][Oe][Ue][Ke] = this._weights[Ve - 1][Oe][Ue][Ke] + ee[Oe][Ue][Ke], this._momentsRed[Ve][Oe][Ue][Ke] = this._momentsRed[Ve - 1][Oe][Ue][Ke] + te[Oe][Ue][Ke], this._momentsGreen[Ve][Oe][Ue][Ke] = this._momentsGreen[Ve - 1][Oe][Ue][Ke] + le[Oe][Ue][Ke], this._momentsBlue[Ve][Oe][Ue][Ke] = this._momentsBlue[Ve - 1][Oe][Ue][Ke] + me[Oe][Ue][Ke], this._momentsAlpha[Ve][Oe][Ue][Ke] = this._momentsAlpha[Ve - 1][Oe][Ue][Ke] + ke[Oe][Ue][Ke], this._moments[Ve][Oe][Ue][Ke] = this._moments[Ve - 1][Oe][Ue][Ke] + ge[Oe][Ue][Ke];
                      }
                    }
                  }, P._volumeFloat = function(S, U) {
                    return U[S.alphaMaximum][S.redMaximum][S.greenMaximum][S.blueMaximum] - U[S.alphaMaximum][S.redMaximum][S.greenMinimum][S.blueMaximum] - U[S.alphaMaximum][S.redMinimum][S.greenMaximum][S.blueMaximum] + U[S.alphaMaximum][S.redMinimum][S.greenMinimum][S.blueMaximum] - U[S.alphaMinimum][S.redMaximum][S.greenMaximum][S.blueMaximum] + U[S.alphaMinimum][S.redMaximum][S.greenMinimum][S.blueMaximum] + U[S.alphaMinimum][S.redMinimum][S.greenMaximum][S.blueMaximum] - U[S.alphaMinimum][S.redMinimum][S.greenMinimum][S.blueMaximum] - (U[S.alphaMaximum][S.redMaximum][S.greenMaximum][S.blueMinimum] - U[S.alphaMinimum][S.redMaximum][S.greenMaximum][S.blueMinimum] - U[S.alphaMaximum][S.redMaximum][S.greenMinimum][S.blueMinimum] + U[S.alphaMinimum][S.redMaximum][S.greenMinimum][S.blueMinimum] - U[S.alphaMaximum][S.redMinimum][S.greenMaximum][S.blueMinimum] + U[S.alphaMinimum][S.redMinimum][S.greenMaximum][S.blueMinimum] + U[S.alphaMaximum][S.redMinimum][S.greenMinimum][S.blueMinimum] - U[S.alphaMinimum][S.redMinimum][S.greenMinimum][S.blueMinimum]);
                  }, P._volume = function(S, U) {
                    return P._volumeFloat(S, U) | 0;
                  }, P._top = function(S, U, j, T) {
                    var W;
                    switch (U) {
                      case P.alpha:
                        W = T[j][S.redMaximum][S.greenMaximum][S.blueMaximum] - T[j][S.redMaximum][S.greenMinimum][S.blueMaximum] - T[j][S.redMinimum][S.greenMaximum][S.blueMaximum] + T[j][S.redMinimum][S.greenMinimum][S.blueMaximum] - (T[j][S.redMaximum][S.greenMaximum][S.blueMinimum] - T[j][S.redMaximum][S.greenMinimum][S.blueMinimum] - T[j][S.redMinimum][S.greenMaximum][S.blueMinimum] + T[j][S.redMinimum][S.greenMinimum][S.blueMinimum]);
                        break;
                      case P.red:
                        W = T[S.alphaMaximum][j][S.greenMaximum][S.blueMaximum] - T[S.alphaMaximum][j][S.greenMinimum][S.blueMaximum] - T[S.alphaMinimum][j][S.greenMaximum][S.blueMaximum] + T[S.alphaMinimum][j][S.greenMinimum][S.blueMaximum] - (T[S.alphaMaximum][j][S.greenMaximum][S.blueMinimum] - T[S.alphaMaximum][j][S.greenMinimum][S.blueMinimum] - T[S.alphaMinimum][j][S.greenMaximum][S.blueMinimum] + T[S.alphaMinimum][j][S.greenMinimum][S.blueMinimum]);
                        break;
                      case P.green:
                        W = T[S.alphaMaximum][S.redMaximum][j][S.blueMaximum] - T[S.alphaMaximum][S.redMinimum][j][S.blueMaximum] - T[S.alphaMinimum][S.redMaximum][j][S.blueMaximum] + T[S.alphaMinimum][S.redMinimum][j][S.blueMaximum] - (T[S.alphaMaximum][S.redMaximum][j][S.blueMinimum] - T[S.alphaMaximum][S.redMinimum][j][S.blueMinimum] - T[S.alphaMinimum][S.redMaximum][j][S.blueMinimum] + T[S.alphaMinimum][S.redMinimum][j][S.blueMinimum]);
                        break;
                      case P.blue:
                        W = T[S.alphaMaximum][S.redMaximum][S.greenMaximum][j] - T[S.alphaMaximum][S.redMaximum][S.greenMinimum][j] - T[S.alphaMaximum][S.redMinimum][S.greenMaximum][j] + T[S.alphaMaximum][S.redMinimum][S.greenMinimum][j] - (T[S.alphaMinimum][S.redMaximum][S.greenMaximum][j] - T[S.alphaMinimum][S.redMaximum][S.greenMinimum][j] - T[S.alphaMinimum][S.redMinimum][S.greenMaximum][j] + T[S.alphaMinimum][S.redMinimum][S.greenMinimum][j]);
                        break;
                      default:
                        throw new Error("impossible");
                    }
                    return W | 0;
                  }, P._bottom = function(S, U, j) {
                    switch (U) {
                      case P.alpha:
                        return -j[S.alphaMinimum][S.redMaximum][S.greenMaximum][S.blueMaximum] + j[S.alphaMinimum][S.redMaximum][S.greenMinimum][S.blueMaximum] + j[S.alphaMinimum][S.redMinimum][S.greenMaximum][S.blueMaximum] - j[S.alphaMinimum][S.redMinimum][S.greenMinimum][S.blueMaximum] - (-j[S.alphaMinimum][S.redMaximum][S.greenMaximum][S.blueMinimum] + j[S.alphaMinimum][S.redMaximum][S.greenMinimum][S.blueMinimum] + j[S.alphaMinimum][S.redMinimum][S.greenMaximum][S.blueMinimum] - j[S.alphaMinimum][S.redMinimum][S.greenMinimum][S.blueMinimum]);
                      case P.red:
                        return -j[S.alphaMaximum][S.redMinimum][S.greenMaximum][S.blueMaximum] + j[S.alphaMaximum][S.redMinimum][S.greenMinimum][S.blueMaximum] + j[S.alphaMinimum][S.redMinimum][S.greenMaximum][S.blueMaximum] - j[S.alphaMinimum][S.redMinimum][S.greenMinimum][S.blueMaximum] - (-j[S.alphaMaximum][S.redMinimum][S.greenMaximum][S.blueMinimum] + j[S.alphaMaximum][S.redMinimum][S.greenMinimum][S.blueMinimum] + j[S.alphaMinimum][S.redMinimum][S.greenMaximum][S.blueMinimum] - j[S.alphaMinimum][S.redMinimum][S.greenMinimum][S.blueMinimum]);
                      case P.green:
                        return -j[S.alphaMaximum][S.redMaximum][S.greenMinimum][S.blueMaximum] + j[S.alphaMaximum][S.redMinimum][S.greenMinimum][S.blueMaximum] + j[S.alphaMinimum][S.redMaximum][S.greenMinimum][S.blueMaximum] - j[S.alphaMinimum][S.redMinimum][S.greenMinimum][S.blueMaximum] - (-j[S.alphaMaximum][S.redMaximum][S.greenMinimum][S.blueMinimum] + j[S.alphaMaximum][S.redMinimum][S.greenMinimum][S.blueMinimum] + j[S.alphaMinimum][S.redMaximum][S.greenMinimum][S.blueMinimum] - j[S.alphaMinimum][S.redMinimum][S.greenMinimum][S.blueMinimum]);
                      case P.blue:
                        return -j[S.alphaMaximum][S.redMaximum][S.greenMaximum][S.blueMinimum] + j[S.alphaMaximum][S.redMaximum][S.greenMinimum][S.blueMinimum] + j[S.alphaMaximum][S.redMinimum][S.greenMaximum][S.blueMinimum] - j[S.alphaMaximum][S.redMinimum][S.greenMinimum][S.blueMinimum] - (-j[S.alphaMinimum][S.redMaximum][S.greenMaximum][S.blueMinimum] + j[S.alphaMinimum][S.redMaximum][S.greenMinimum][S.blueMinimum] + j[S.alphaMinimum][S.redMinimum][S.greenMaximum][S.blueMinimum] - j[S.alphaMinimum][S.redMinimum][S.greenMinimum][S.blueMinimum]);
                      default:
                        return 0;
                    }
                  }, P.prototype._calculateVariance = function(S) {
                    var U = P._volume(S, this._momentsRed), j = P._volume(S, this._momentsGreen), T = P._volume(S, this._momentsBlue), W = P._volume(S, this._momentsAlpha), J = P._volumeFloat(S, this._moments), ee = P._volume(S, this._weights), te = U * U + j * j + T * T + W * W;
                    return J - te / ee;
                  }, P.prototype._maximize = function(S, U, j, T, W, J, ee, te, le) {
                    for (var me = P._bottom(S, U, this._momentsRed) | 0, ke = P._bottom(S, U, this._momentsGreen) | 0, ge = P._bottom(S, U, this._momentsBlue) | 0, Ve = P._bottom(S, U, this._momentsAlpha) | 0, Oe = P._bottom(S, U, this._weights) | 0, Ue = 0, we = -1, Ce = j; Ce < T; ++Ce) {
                      var it = me + P._top(S, U, Ce, this._momentsRed), ut = ke + P._top(S, U, Ce, this._momentsGreen), bt = ge + P._top(S, U, Ce, this._momentsBlue), pt = Ve + P._top(S, U, Ce, this._momentsAlpha), Ke = Oe + P._top(S, U, Ce, this._weights);
                      if (Ke != 0) {
                        var dt = it * it + ut * ut + bt * bt + pt * pt, ct = dt / Ke;
                        it = W - it, ut = J - ut, bt = ee - bt, pt = te - pt, Ke = le - Ke, Ke != 0 && (dt = it * it + ut * ut + bt * bt + pt * pt, ct += dt / Ke, ct > Ue && (Ue = ct, we = Ce));
                      }
                    }
                    return { max: Ue, position: we };
                  }, P.prototype._cut = function(S, U) {
                    var j, T = P._volume(S, this._momentsRed), W = P._volume(S, this._momentsGreen), J = P._volume(S, this._momentsBlue), ee = P._volume(S, this._momentsAlpha), te = P._volume(S, this._weights), le = this._maximize(S, P.red, S.redMinimum + 1, S.redMaximum, T, W, J, ee, te), me = this._maximize(S, P.green, S.greenMinimum + 1, S.greenMaximum, T, W, J, ee, te), ke = this._maximize(S, P.blue, S.blueMinimum + 1, S.blueMaximum, T, W, J, ee, te), ge = this._maximize(S, P.alpha, S.alphaMinimum + 1, S.alphaMaximum, T, W, J, ee, te);
                    if (ge.max >= le.max && ge.max >= me.max && ge.max >= ke.max) {
                      if (j = P.alpha, ge.position < 0)
                        return !1;
                    } else
                      le.max >= ge.max && le.max >= me.max && le.max >= ke.max ? j = P.red : me.max >= ge.max && me.max >= le.max && me.max >= ke.max ? j = P.green : j = P.blue;
                    switch (U.redMaximum = S.redMaximum, U.greenMaximum = S.greenMaximum, U.blueMaximum = S.blueMaximum, U.alphaMaximum = S.alphaMaximum, j) {
                      case P.red:
                        U.redMinimum = S.redMaximum = le.position, U.greenMinimum = S.greenMinimum, U.blueMinimum = S.blueMinimum, U.alphaMinimum = S.alphaMinimum;
                        break;
                      case P.green:
                        U.greenMinimum = S.greenMaximum = me.position, U.redMinimum = S.redMinimum, U.blueMinimum = S.blueMinimum, U.alphaMinimum = S.alphaMinimum;
                        break;
                      case P.blue:
                        U.blueMinimum = S.blueMaximum = ke.position, U.redMinimum = S.redMinimum, U.greenMinimum = S.greenMinimum, U.alphaMinimum = S.alphaMinimum;
                        break;
                      case P.alpha:
                        U.alphaMinimum = S.alphaMaximum = ge.position, U.blueMinimum = S.blueMinimum, U.redMinimum = S.redMinimum, U.greenMinimum = S.greenMinimum;
                        break;
                    }
                    return S.volume = (S.redMaximum - S.redMinimum) * (S.greenMaximum - S.greenMinimum) * (S.blueMaximum - S.blueMinimum) * (S.alphaMaximum - S.alphaMinimum), U.volume = (U.redMaximum - U.redMinimum) * (U.greenMaximum - U.greenMinimum) * (U.blueMaximum - U.blueMinimum) * (U.alphaMaximum - U.alphaMinimum), !0;
                  }, P.prototype._initialize = function(S) {
                    this._colors = S, this._cubes = [];
                    for (var U = 0; U < S; U++)
                      this._cubes[U] = new k();
                    this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = M(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = M(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = M(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = M(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = M(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = M(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
                    for (var j = 0; j < 256; ++j)
                      this._table[j] = j * j;
                    this._pixels = [];
                  }, P.prototype._setQuality = function(S) {
                    S === void 0 && (S = 5), this._significantBitsPerChannel = S, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
                  }, P.alpha = 3, P.red = 2, P.green = 1, P.blue = 0, P;
                }();
                i.WuQuant = E;
              },
              /* 30 */
              /***/
              function(ie, i, N) {
                var Z = N(31);
                i.NearestColor = Z.NearestColor;
                var R = N(32);
                i.ErrorDiffusionArray = R.ErrorDiffusionArray, i.ErrorDiffusionArrayKernel = R.ErrorDiffusionArrayKernel;
                var A = N(33);
                i.ErrorDiffusionRiemersma = A.ErrorDiffusionRiemersma;
              },
              /* 31 */
              /***/
              function(ie, i) {
                var N = function() {
                  function Z(R) {
                    this._distance = R;
                  }
                  return Z.prototype.quantize = function(R, A) {
                    for (var M = R.getPointArray(), x = R.getWidth(), m = R.getHeight(), w = 0; w < m; w++)
                      for (var k = 0, E = w * x; k < x; k++, E++) {
                        var P = M[E];
                        P.from(A.getNearestColor(this._distance, P));
                      }
                    return R;
                  }, Z;
                }();
                i.NearestColor = N;
              },
              /* 32 */
              /***/
              function(ie, i, N) {
                var Z = N(24), R = N(6);
                (function(x) {
                  x[x.FloydSteinberg = 0] = "FloydSteinberg", x[x.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", x[x.Stucki = 2] = "Stucki", x[x.Atkinson = 3] = "Atkinson", x[x.Jarvis = 4] = "Jarvis", x[x.Burkes = 5] = "Burkes", x[x.Sierra = 6] = "Sierra", x[x.TwoSierra = 7] = "TwoSierra", x[x.SierraLite = 8] = "SierraLite";
                })(i.ErrorDiffusionArrayKernel || (i.ErrorDiffusionArrayKernel = {}));
                var A = i.ErrorDiffusionArrayKernel, M = function() {
                  function x(m, w, k, E, P) {
                    k === void 0 && (k = !0), E === void 0 && (E = 0), P === void 0 && (P = !1), this._setKernel(w), this._distance = m, this._minColorDistance = E, this._serpentine = k, this._calculateErrorLikeGIMP = P;
                  }
                  return x.prototype.quantize = function(m, w) {
                    for (var k = m.getPointArray(), E = new Z.Point(), P = m.getWidth(), S = m.getHeight(), U = [], j = 1, T = 1, W = 0; W < this._kernel.length; W++) {
                      var J = this._kernel[W][2] + 1;
                      T < J && (T = J);
                    }
                    for (var W = 0; W < T; W++)
                      this._fillErrorLine(U[W] = [], P);
                    for (var ee = 0; ee < S; ee++) {
                      this._serpentine && (j = j * -1);
                      var te = ee * P, le = j == 1 ? 0 : P - 1, me = j == 1 ? P : -1;
                      this._fillErrorLine(U[0], P), U.push(U.shift());
                      for (var ke = U[0], ge = le, Ve = te + le; ge !== me; ge += j, Ve += j) {
                        var Oe = k[Ve], Ue = ke[ge];
                        E.from(Oe);
                        var we = Z.Point.createByRGBA(R.inRange0to255Rounded(Oe.r + Ue[0]), R.inRange0to255Rounded(Oe.g + Ue[1]), R.inRange0to255Rounded(Oe.b + Ue[2]), R.inRange0to255Rounded(Oe.a + Ue[3])), Ce = w.getNearestColor(this._distance, we);
                        if (Oe.from(Ce), this._minColorDistance) {
                          var it = this._distance.calculateNormalized(Oe, Ce);
                          if (it < this._minColorDistance)
                            continue;
                        }
                        var ut = void 0, bt = void 0, pt = void 0, Ke = void 0;
                        this._calculateErrorLikeGIMP ? (ut = we.r - Ce.r, bt = we.g - Ce.g, pt = we.b - Ce.b, Ke = we.a - Ce.a) : (ut = E.r - Ce.r, bt = E.g - Ce.g, pt = E.b - Ce.b, Ke = E.a - Ce.a);
                        for (var dt = j == 1 ? 0 : this._kernel.length - 1, ct = j == 1 ? this._kernel.length : -1, W = dt; W !== ct; W += j) {
                          var wt = this._kernel[W][1] * j, Ht = this._kernel[W][2];
                          if (wt + ge >= 0 && wt + ge < P && Ht + ee >= 0 && Ht + ee < S) {
                            var $t = this._kernel[W][0], rt = U[Ht][wt + ge];
                            rt[0] = rt[0] + ut * $t, rt[1] = rt[1] + bt * $t, rt[2] = rt[2] + pt * $t, rt[3] = rt[3] + Ke * $t;
                          }
                        }
                      }
                    }
                    return m;
                  }, x.prototype._fillErrorLine = function(m, w) {
                    m.length > w && (m.length = w);
                    for (var k = m.length, E = 0; E < k; E++) {
                      var P = m[E];
                      P[0] = P[1] = P[2] = P[3] = 0;
                    }
                    for (var E = k; E < w; E++)
                      m[E] = [0, 0, 0, 0];
                  }, x.prototype._setKernel = function(m) {
                    switch (m) {
                      case A.FloydSteinberg:
                        this._kernel = [
                          [7 / 16, 1, 0],
                          [3 / 16, -1, 1],
                          [5 / 16, 0, 1],
                          [1 / 16, 1, 1]
                        ];
                        break;
                      case A.FalseFloydSteinberg:
                        this._kernel = [
                          [3 / 8, 1, 0],
                          [3 / 8, 0, 1],
                          [2 / 8, 1, 1]
                        ];
                        break;
                      case A.Stucki:
                        this._kernel = [
                          [8 / 42, 1, 0],
                          [4 / 42, 2, 0],
                          [2 / 42, -2, 1],
                          [4 / 42, -1, 1],
                          [8 / 42, 0, 1],
                          [4 / 42, 1, 1],
                          [2 / 42, 2, 1],
                          [1 / 42, -2, 2],
                          [2 / 42, -1, 2],
                          [4 / 42, 0, 2],
                          [2 / 42, 1, 2],
                          [1 / 42, 2, 2]
                        ];
                        break;
                      case A.Atkinson:
                        this._kernel = [
                          [1 / 8, 1, 0],
                          [1 / 8, 2, 0],
                          [1 / 8, -1, 1],
                          [1 / 8, 0, 1],
                          [1 / 8, 1, 1],
                          [1 / 8, 0, 2]
                        ];
                        break;
                      case A.Jarvis:
                        this._kernel = [
                          [7 / 48, 1, 0],
                          [5 / 48, 2, 0],
                          [3 / 48, -2, 1],
                          [5 / 48, -1, 1],
                          [7 / 48, 0, 1],
                          [5 / 48, 1, 1],
                          [3 / 48, 2, 1],
                          [1 / 48, -2, 2],
                          [3 / 48, -1, 2],
                          [5 / 48, 0, 2],
                          [3 / 48, 1, 2],
                          [1 / 48, 2, 2]
                        ];
                        break;
                      case A.Burkes:
                        this._kernel = [
                          [8 / 32, 1, 0],
                          [4 / 32, 2, 0],
                          [2 / 32, -2, 1],
                          [4 / 32, -1, 1],
                          [8 / 32, 0, 1],
                          [4 / 32, 1, 1],
                          [2 / 32, 2, 1]
                        ];
                        break;
                      case A.Sierra:
                        this._kernel = [
                          [5 / 32, 1, 0],
                          [3 / 32, 2, 0],
                          [2 / 32, -2, 1],
                          [4 / 32, -1, 1],
                          [5 / 32, 0, 1],
                          [4 / 32, 1, 1],
                          [2 / 32, 2, 1],
                          [2 / 32, -1, 2],
                          [3 / 32, 0, 2],
                          [2 / 32, 1, 2]
                        ];
                        break;
                      case A.TwoSierra:
                        this._kernel = [
                          [4 / 16, 1, 0],
                          [3 / 16, 2, 0],
                          [1 / 16, -2, 1],
                          [2 / 16, -1, 1],
                          [3 / 16, 0, 1],
                          [2 / 16, 1, 1],
                          [1 / 16, 2, 1]
                        ];
                        break;
                      case A.SierraLite:
                        this._kernel = [
                          [2 / 4, 1, 0],
                          [1 / 4, -1, 1],
                          [1 / 4, 0, 1]
                        ];
                        break;
                      default:
                        throw new Error("ErrorDiffusionArray: unknown kernel = " + m);
                    }
                  }, x;
                }();
                i.ErrorDiffusionArray = M;
              },
              /* 33 */
              /***/
              function(ie, i, N) {
                var Z = N(34), R = N(24), A = N(6), M = function() {
                  function x(m, w, k) {
                    w === void 0 && (w = 16), k === void 0 && (k = 1), this._distance = m, this._errorPropagation = k, this._errorQueueSize = w, this._max = this._errorQueueSize, this._createWeights();
                  }
                  return x.prototype.quantize = function(m, w) {
                    for (var k = this, E = new Z.HilbertCurveBase(), P = m.getPointArray(), S = m.getWidth(), U = m.getHeight(), j = [], T = 0, W = 0; W < this._errorQueueSize; W++)
                      j[W] = { r: 0, g: 0, b: 0, a: 0 };
                    return E.walk(S, U, function(J, ee) {
                      for (var te = P[J + ee * S], le = te.r, me = te.g, ke = te.b, ge = te.a, Ve = 0; Ve < k._errorQueueSize; Ve++) {
                        var Oe = k._weights[Ve], Ue = j[(Ve + T) % k._errorQueueSize];
                        le += Ue.r * Oe, me += Ue.g * Oe, ke += Ue.b * Oe, ge += Ue.a * Oe;
                      }
                      var we = R.Point.createByRGBA(A.inRange0to255Rounded(le), A.inRange0to255Rounded(me), A.inRange0to255Rounded(ke), A.inRange0to255Rounded(ge)), Ce = w.getNearestColor(k._distance, we);
                      T = (T + 1) % k._errorQueueSize;
                      var it = (T + k._errorQueueSize - 1) % k._errorQueueSize;
                      j[it].r = te.r - Ce.r, j[it].g = te.g - Ce.g, j[it].b = te.b - Ce.b, j[it].a = te.a - Ce.a, te.from(Ce);
                    }), m;
                  }, x.prototype._createWeights = function() {
                    this._weights = [];
                    for (var m = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1)), w = 0, k = 1; w < this._errorQueueSize; w++)
                      this._weights[w] = (k + 0.5 | 0) / this._max * this._errorPropagation, k *= m;
                  }, x;
                }();
                i.ErrorDiffusionRiemersma = M;
              },
              /* 34 */
              /***/
              function(ie, i) {
                var N;
                (function(R) {
                  R[R.NONE = 0] = "NONE", R[R.UP = 1] = "UP", R[R.LEFT = 2] = "LEFT", R[R.RIGHT = 3] = "RIGHT", R[R.DOWN = 4] = "DOWN";
                })(N || (N = {}));
                var Z = function() {
                  function R() {
                  }
                  return R.prototype.walk = function(A, M, x) {
                    this._x = 0, this._y = 0, this._d = 0, this._width = A, this._height = M, this._callback = x;
                    var m = Math.max(A, M);
                    this._level = Math.log(m) / Math.log(2) + 1 | 0, this._walkHilbert(N.UP), this._visit(N.NONE);
                  }, R.prototype._walkHilbert = function(A) {
                    if (!(this._level < 1)) {
                      switch (this._level--, A) {
                        case N.LEFT:
                          this._walkHilbert(N.UP), this._visit(N.RIGHT), this._walkHilbert(N.LEFT), this._visit(N.DOWN), this._walkHilbert(N.LEFT), this._visit(N.LEFT), this._walkHilbert(N.DOWN);
                          break;
                        case N.RIGHT:
                          this._walkHilbert(N.DOWN), this._visit(N.LEFT), this._walkHilbert(N.RIGHT), this._visit(N.UP), this._walkHilbert(N.RIGHT), this._visit(N.RIGHT), this._walkHilbert(N.UP);
                          break;
                        case N.UP:
                          this._walkHilbert(N.LEFT), this._visit(N.DOWN), this._walkHilbert(N.UP), this._visit(N.RIGHT), this._walkHilbert(N.UP), this._visit(N.UP), this._walkHilbert(N.RIGHT);
                          break;
                        case N.DOWN:
                          this._walkHilbert(N.RIGHT), this._visit(N.UP), this._walkHilbert(N.DOWN), this._visit(N.LEFT), this._walkHilbert(N.DOWN), this._visit(N.DOWN), this._walkHilbert(N.LEFT);
                          break;
                      }
                      this._level++;
                    }
                  }, R.prototype._visit = function(A) {
                    switch (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height && (this._callback(this._x, this._y, this._d), this._d++), A) {
                      case N.LEFT:
                        this._x--;
                        break;
                      case N.RIGHT:
                        this._x++;
                        break;
                      case N.UP:
                        this._y--;
                        break;
                      case N.DOWN:
                        this._y++;
                        break;
                    }
                  }, R;
                }();
                i.HilbertCurveBase = Z;
              },
              /* 35 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var Z = N(36);
                i.SSIM = Z.SSIM;
              },
              /* 36 */
              /***/
              function(ie, i, N) {
                var Z = N(2), R = 0.01, A = 0.03, M = function() {
                  function x() {
                  }
                  return x.prototype.compare = function(m, w) {
                    if (m.getHeight() !== w.getHeight() || m.getWidth() !== w.getWidth())
                      throw new Error("Images have different sizes!");
                    var k = 8, E = (1 << k) - 1, P = Math.pow(R * E, 2), S = Math.pow(A * E, 2), U = 0, j = 0;
                    return this._iterate(m, w, function(T, W, J, ee) {
                      for (var te = 0, le = 0, me = 0, ke = 0; ke < T.length; ke++)
                        le += Math.pow(T[ke] - J, 2), me += Math.pow(W[ke] - ee, 2), te += (T[ke] - J) * (W[ke] - ee);
                      var ge = T.length - 1;
                      le /= ge, me /= ge, te /= ge;
                      var Ve = (2 * J * ee + P) * (2 * te + S), Oe = (Math.pow(J, 2) + Math.pow(ee, 2) + P) * (le + me + S), Ue = Ve / Oe;
                      j += Ue, U++;
                    }), j / U;
                  }, x.prototype._iterate = function(m, w, k) {
                    for (var E = 8, P = m.getWidth(), S = m.getHeight(), U = 0; U < S; U += E)
                      for (var j = 0; j < P; j += E) {
                        var T = Math.min(E, P - j), W = Math.min(E, S - U), J = this._calculateLumaValuesForWindow(m, j, U, T, W), ee = this._calculateLumaValuesForWindow(w, j, U, T, W), te = this._calculateAverageLuma(J), le = this._calculateAverageLuma(ee);
                        k(J, ee, te, le);
                      }
                  }, x.prototype._calculateLumaValuesForWindow = function(m, w, k, E, P) {
                    for (var S = m.getPointArray(), U = [], j = 0, T = k; T < k + P; T++)
                      for (var W = T * m.getWidth(), J = w; J < w + E; J++) {
                        var ee = S[W + J];
                        U[j] = ee.r * Z.Y.RED + ee.g * Z.Y.GREEN + ee.b * Z.Y.BLUE, j++;
                      }
                    return U;
                  }, x.prototype._calculateAverageLuma = function(m) {
                    for (var w = 0, k = 0; k < m.length; k++)
                      w += m[k];
                    return w / m.length;
                  }, x;
                }();
                i.SSIM = M;
              },
              /* 37 */
              /***/
              function(ie, i, N) {
                /**
                 * @preserve
                 * Copyright 2015-2016 Igor Bezkrovnyi
                 * All rights reserved. (MIT Licensed)
                 *
                 * iq.ts - Image Quantization Library
                 */
                var Z = N(6);
                i.arithmetic = Z;
                var R = N(28);
                i.HueStatistics = R.HueStatistics;
                var A = N(22);
                i.Palette = A.Palette;
                var M = N(24);
                i.Point = M.Point;
                var x = N(23);
                i.PointContainer = x.PointContainer;
              }
              /******/
            ])
          );
        });
      }, {}], 75: [function(Q, de, q) {
        typeof Object.create == "function" ? de.exports = function(i, N) {
          N && (i.super_ = N, i.prototype = Object.create(N.prototype, {
            constructor: {
              value: i,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          }));
        } : de.exports = function(i, N) {
          if (N) {
            i.super_ = N;
            var Z = function() {
            };
            Z.prototype = N.prototype, i.prototype = new Z(), i.prototype.constructor = i;
          }
        };
      }, {}], 76: [function(Q, de, q) {
        /*!
         * Determine if an object is a Buffer
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */
        de.exports = function(N) {
          return N != null && (ie(N) || i(N) || !!N._isBuffer);
        };
        function ie(N) {
          return !!N.constructor && typeof N.constructor.isBuffer == "function" && N.constructor.isBuffer(N);
        }
        function i(N) {
          return typeof N.readFloatLE == "function" && typeof N.slice == "function" && ie(N.slice(0, 0));
        }
      }, {}], 77: [function(Q, de, q) {
        var ie = Function.prototype.toString, i = /^\s*class\b/, N = function(w) {
          try {
            var k = ie.call(w);
            return i.test(k);
          } catch {
            return !1;
          }
        }, Z = function(w) {
          try {
            return N(w) ? !1 : (ie.call(w), !0);
          } catch {
            return !1;
          }
        }, R = Object.prototype.toString, A = "[object Function]", M = "[object GeneratorFunction]", x = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
        de.exports = function(w) {
          if (!w || typeof w != "function" && typeof w != "object")
            return !1;
          if (typeof w == "function" && !w.prototype)
            return !0;
          if (x)
            return Z(w);
          if (N(w))
            return !1;
          var k = R.call(w);
          return k === A || k === M;
        };
      }, {}], 78: [function(Q, de, q) {
        de.exports = i;
        var ie = Object.prototype.toString;
        function i(N) {
          var Z = ie.call(N);
          return Z === "[object Function]" || typeof N == "function" && Z !== "[object RegExp]" || typeof qe < "u" && // IE8 and below
          (N === qe.setTimeout || N === qe.alert || N === qe.confirm || N === qe.prompt);
        }
      }, {}], 79: [function(Q, de, q) {
        var ie = {}.toString;
        de.exports = Array.isArray || function(i) {
          return ie.call(i) == "[object Array]";
        };
      }, {}], 80: [function(Q, de, q) {
        var ie = Q("./lib/encoder"), i = Q("./lib/decoder");
        de.exports = {
          encode: ie,
          decode: i
        };
      }, { "./lib/decoder": 81, "./lib/encoder": 82 }], 81: [function(Q, de, q) {
        (function(ie) {
          var i = function() {
            var R = new Int32Array([
              0,
              1,
              8,
              16,
              9,
              2,
              3,
              10,
              17,
              24,
              32,
              25,
              18,
              11,
              4,
              5,
              12,
              19,
              26,
              33,
              40,
              48,
              41,
              34,
              27,
              20,
              13,
              6,
              7,
              14,
              21,
              28,
              35,
              42,
              49,
              56,
              57,
              50,
              43,
              36,
              29,
              22,
              15,
              23,
              30,
              37,
              44,
              51,
              58,
              59,
              52,
              45,
              38,
              31,
              39,
              46,
              53,
              60,
              61,
              54,
              47,
              55,
              62,
              63
            ]), A = 4017, M = 799, x = 3406, m = 2276, w = 1567, k = 3784, E = 5793, P = 2896;
            function S() {
            }
            function U(le, me) {
              for (var ke = 0, ge = [], Ve, Oe, Ue = 16; Ue > 0 && !le[Ue - 1]; )
                Ue--;
              ge.push({ children: [], index: 0 });
              var we = ge[0], Ce;
              for (Ve = 0; Ve < Ue; Ve++) {
                for (Oe = 0; Oe < le[Ve]; Oe++) {
                  for (we = ge.pop(), we.children[we.index] = me[ke]; we.index > 0; ) {
                    if (ge.length === 0)
                      throw new Error("Could not recreate Huffman Table");
                    we = ge.pop();
                  }
                  for (we.index++, ge.push(we); ge.length <= Ve; )
                    ge.push(Ce = { children: [], index: 0 }), we.children[we.index] = Ce.children, we = Ce;
                  ke++;
                }
                Ve + 1 < Ue && (ge.push(Ce = { children: [], index: 0 }), we.children[we.index] = Ce.children, we = Ce);
              }
              return ge[0].children;
            }
            function j(le, me, ke, ge, Ve, Oe, Ue, we, Ce, it) {
              ke.precision, ke.samplesPerLine, ke.scanLines;
              var ut = ke.mcusPerLine, bt = ke.progressive;
              ke.maxH, ke.maxV;
              var pt = me, Ke = 0, dt = 0;
              function ct() {
                if (dt > 0)
                  return dt--, Ke >> dt & 1;
                if (Ke = le[me++], Ke == 255) {
                  var Te = le[me++];
                  if (Te)
                    throw new Error("unexpected marker: " + (Ke << 8 | Te).toString(16));
                }
                return dt = 7, Ke >>> 7;
              }
              function wt(Te) {
                for (var ye = Te, Me; (Me = ct()) !== null; ) {
                  if (ye = ye[Me], typeof ye == "number")
                    return ye;
                  if (typeof ye != "object")
                    throw new Error("invalid huffman sequence");
                }
                return null;
              }
              function Ht(Te) {
                for (var ye = 0; Te > 0; ) {
                  var Me = ct();
                  if (Me === null) return;
                  ye = ye << 1 | Me, Te--;
                }
                return ye;
              }
              function $t(Te) {
                var ye = Ht(Te);
                return ye >= 1 << Te - 1 ? ye : ye + (-1 << Te) + 1;
              }
              function rt(Te, ye) {
                var Me = wt(Te.huffmanTableDC), Ge = Me === 0 ? 0 : $t(Me);
                ye[0] = Te.pred += Ge;
                for (var Qe = 1; Qe < 64; ) {
                  var re = wt(Te.huffmanTableAC), Se = re & 15, Pe = re >> 4;
                  if (Se === 0) {
                    if (Pe < 15)
                      break;
                    Qe += 16;
                    continue;
                  }
                  Qe += Pe;
                  var at = R[Qe];
                  ye[at] = $t(Se), Qe++;
                }
              }
              function ri(Te, ye) {
                var Me = wt(Te.huffmanTableDC), Ge = Me === 0 ? 0 : $t(Me) << Ce;
                ye[0] = Te.pred += Ge;
              }
              function wi(Te, ye) {
                ye[0] |= ct() << Ce;
              }
              var Qt = 0;
              function At(Te, ye) {
                if (Qt > 0) {
                  Qt--;
                  return;
                }
                for (var Me = Oe, Ge = Ue; Me <= Ge; ) {
                  var Qe = wt(Te.huffmanTableAC), re = Qe & 15, Se = Qe >> 4;
                  if (re === 0) {
                    if (Se < 15) {
                      Qt = Ht(Se) + (1 << Se) - 1;
                      break;
                    }
                    Me += 16;
                    continue;
                  }
                  Me += Se;
                  var Pe = R[Me];
                  ye[Pe] = $t(re) * (1 << Ce), Me++;
                }
              }
              var St = 0, Lt;
              function kt(Te, ye) {
                for (var Me = Oe, Ge = Ue, Qe = 0; Me <= Ge; ) {
                  var re = R[Me], Se = ye[re] < 0 ? -1 : 1;
                  switch (St) {
                    case 0:
                      var Pe = wt(Te.huffmanTableAC), at = Pe & 15, Qe = Pe >> 4;
                      if (at === 0)
                        Qe < 15 ? (Qt = Ht(Qe) + (1 << Qe), St = 4) : (Qe = 16, St = 1);
                      else {
                        if (at !== 1)
                          throw new Error("invalid ACn encoding");
                        Lt = $t(at), St = Qe ? 2 : 3;
                      }
                      continue;
                    case 1:
                    // skipping r zero items
                    case 2:
                      ye[re] ? ye[re] += (ct() << Ce) * Se : (Qe--, Qe === 0 && (St = St == 2 ? 3 : 0));
                      break;
                    case 3:
                      ye[re] ? ye[re] += (ct() << Ce) * Se : (ye[re] = Lt << Ce, St = 0);
                      break;
                    case 4:
                      ye[re] && (ye[re] += (ct() << Ce) * Se);
                      break;
                  }
                  Me++;
                }
                St === 4 && (Qt--, Qt === 0 && (St = 0));
              }
              function Ye(Te, ye, Me, Ge, Qe) {
                var re = Me / ut | 0, Se = Me % ut, Pe = re * Te.v + Ge, at = Se * Te.h + Qe;
                Te.blocks[Pe] === void 0 && it.tolerantDecoding || ye(Te, Te.blocks[Pe][at]);
              }
              function De(Te, ye, Me) {
                var Ge = Me / Te.blocksPerLine | 0, Qe = Me % Te.blocksPerLine;
                Te.blocks[Ge] === void 0 && it.tolerantDecoding || ye(Te, Te.blocks[Ge][Qe]);
              }
              var Re = ge.length, _t, et, Ie, pe, xt, l;
              bt ? Oe === 0 ? l = we === 0 ? ri : wi : l = we === 0 ? At : kt : l = rt;
              var _ = 0, I, X;
              Re == 1 ? X = ge[0].blocksPerLine * ge[0].blocksPerColumn : X = ut * ke.mcusPerColumn, Ve || (Ve = X);
              for (var ne, ue; _ < X; ) {
                for (et = 0; et < Re; et++)
                  ge[et].pred = 0;
                if (Qt = 0, Re == 1)
                  for (_t = ge[0], xt = 0; xt < Ve; xt++)
                    De(_t, l, _), _++;
                else
                  for (xt = 0; xt < Ve; xt++) {
                    for (et = 0; et < Re; et++)
                      for (_t = ge[et], ne = _t.h, ue = _t.v, Ie = 0; Ie < ue; Ie++)
                        for (pe = 0; pe < ne; pe++)
                          Ye(_t, l, _, Ie, pe);
                    if (_++, _ === X) break;
                  }
                if (_ === X)
                  do {
                    if (le[me] === 255 && le[me + 1] !== 0)
                      break;
                    me += 1;
                  } while (me < le.length - 2);
                if (dt = 0, I = le[me] << 8 | le[me + 1], I < 65280)
                  throw new Error("marker was not found");
                if (I >= 65488 && I <= 65495)
                  me += 2;
                else
                  break;
              }
              return me - pt;
            }
            function T(le, me) {
              var ke = [], ge = me.blocksPerLine, Ve = me.blocksPerColumn, Oe = ge << 3, Ue = new Int32Array(64), we = new Uint8Array(64);
              function Ce(Ht, $t, rt) {
                var ri = me.quantizationTable, wi, Qt, At, St, Lt, kt, Ye, De, Re, _t = rt, et;
                for (et = 0; et < 64; et++)
                  _t[et] = Ht[et] * ri[et];
                for (et = 0; et < 8; ++et) {
                  var Ie = 8 * et;
                  if (_t[1 + Ie] == 0 && _t[2 + Ie] == 0 && _t[3 + Ie] == 0 && _t[4 + Ie] == 0 && _t[5 + Ie] == 0 && _t[6 + Ie] == 0 && _t[7 + Ie] == 0) {
                    Re = E * _t[0 + Ie] + 512 >> 10, _t[0 + Ie] = Re, _t[1 + Ie] = Re, _t[2 + Ie] = Re, _t[3 + Ie] = Re, _t[4 + Ie] = Re, _t[5 + Ie] = Re, _t[6 + Ie] = Re, _t[7 + Ie] = Re;
                    continue;
                  }
                  wi = E * _t[0 + Ie] + 128 >> 8, Qt = E * _t[4 + Ie] + 128 >> 8, At = _t[2 + Ie], St = _t[6 + Ie], Lt = P * (_t[1 + Ie] - _t[7 + Ie]) + 128 >> 8, De = P * (_t[1 + Ie] + _t[7 + Ie]) + 128 >> 8, kt = _t[3 + Ie] << 4, Ye = _t[5 + Ie] << 4, Re = wi - Qt + 1 >> 1, wi = wi + Qt + 1 >> 1, Qt = Re, Re = At * k + St * w + 128 >> 8, At = At * w - St * k + 128 >> 8, St = Re, Re = Lt - Ye + 1 >> 1, Lt = Lt + Ye + 1 >> 1, Ye = Re, Re = De + kt + 1 >> 1, kt = De - kt + 1 >> 1, De = Re, Re = wi - St + 1 >> 1, wi = wi + St + 1 >> 1, St = Re, Re = Qt - At + 1 >> 1, Qt = Qt + At + 1 >> 1, At = Re, Re = Lt * m + De * x + 2048 >> 12, Lt = Lt * x - De * m + 2048 >> 12, De = Re, Re = kt * M + Ye * A + 2048 >> 12, kt = kt * A - Ye * M + 2048 >> 12, Ye = Re, _t[0 + Ie] = wi + De, _t[7 + Ie] = wi - De, _t[1 + Ie] = Qt + Ye, _t[6 + Ie] = Qt - Ye, _t[2 + Ie] = At + kt, _t[5 + Ie] = At - kt, _t[3 + Ie] = St + Lt, _t[4 + Ie] = St - Lt;
                }
                for (et = 0; et < 8; ++et) {
                  var pe = et;
                  if (_t[8 + pe] == 0 && _t[16 + pe] == 0 && _t[24 + pe] == 0 && _t[32 + pe] == 0 && _t[40 + pe] == 0 && _t[48 + pe] == 0 && _t[56 + pe] == 0) {
                    Re = E * rt[et + 0] + 8192 >> 14, _t[0 + pe] = Re, _t[8 + pe] = Re, _t[16 + pe] = Re, _t[24 + pe] = Re, _t[32 + pe] = Re, _t[40 + pe] = Re, _t[48 + pe] = Re, _t[56 + pe] = Re;
                    continue;
                  }
                  wi = E * _t[0 + pe] + 2048 >> 12, Qt = E * _t[32 + pe] + 2048 >> 12, At = _t[16 + pe], St = _t[48 + pe], Lt = P * (_t[8 + pe] - _t[56 + pe]) + 2048 >> 12, De = P * (_t[8 + pe] + _t[56 + pe]) + 2048 >> 12, kt = _t[24 + pe], Ye = _t[40 + pe], Re = wi - Qt + 1 >> 1, wi = wi + Qt + 1 >> 1, Qt = Re, Re = At * k + St * w + 2048 >> 12, At = At * w - St * k + 2048 >> 12, St = Re, Re = Lt - Ye + 1 >> 1, Lt = Lt + Ye + 1 >> 1, Ye = Re, Re = De + kt + 1 >> 1, kt = De - kt + 1 >> 1, De = Re, Re = wi - St + 1 >> 1, wi = wi + St + 1 >> 1, St = Re, Re = Qt - At + 1 >> 1, Qt = Qt + At + 1 >> 1, At = Re, Re = Lt * m + De * x + 2048 >> 12, Lt = Lt * x - De * m + 2048 >> 12, De = Re, Re = kt * M + Ye * A + 2048 >> 12, kt = kt * A - Ye * M + 2048 >> 12, Ye = Re, _t[0 + pe] = wi + De, _t[56 + pe] = wi - De, _t[8 + pe] = Qt + Ye, _t[48 + pe] = Qt - Ye, _t[16 + pe] = At + kt, _t[40 + pe] = At - kt, _t[24 + pe] = St + Lt, _t[32 + pe] = St - Lt;
                }
                for (et = 0; et < 64; ++et) {
                  var xt = 128 + (_t[et] + 8 >> 4);
                  $t[et] = xt < 0 ? 0 : xt > 255 ? 255 : xt;
                }
              }
              te(Oe * Ve * 8);
              for (var it, ut, bt = 0; bt < Ve; bt++) {
                var pt = bt << 3;
                for (it = 0; it < 8; it++)
                  ke.push(new Uint8Array(Oe));
                for (var Ke = 0; Ke < ge; Ke++) {
                  Ce(me.blocks[bt][Ke], we, Ue);
                  var dt = 0, ct = Ke << 3;
                  for (ut = 0; ut < 8; ut++) {
                    var wt = ke[pt + ut];
                    for (it = 0; it < 8; it++)
                      wt[ct + it] = we[dt++];
                  }
                }
              }
              return ke;
            }
            function W(le) {
              return le < 0 ? 0 : le > 255 ? 255 : le;
            }
            S.prototype = {
              load: function(me) {
                var ke = new XMLHttpRequest();
                ke.open("GET", me, !0), ke.responseType = "arraybuffer", ke.onload = (function() {
                  var ge = new Uint8Array(ke.response || ke.mozResponseArrayBuffer);
                  this.parse(ge), this.onload && this.onload();
                }).bind(this), ke.send(null);
              },
              parse: function(me) {
                var ke = this.opts.maxResolutionInMP * 1e3 * 1e3, ge = 0;
                me.length;
                function Ve() {
                  var Qe = me[ge] << 8 | me[ge + 1];
                  return ge += 2, Qe;
                }
                function Oe() {
                  var Qe = Ve(), re = me.subarray(ge, ge + Qe - 2);
                  return ge += re.length, re;
                }
                function Ue(Qe) {
                  var re = 0, Se = 0, Pe, at;
                  for (at in Qe.components)
                    Qe.components.hasOwnProperty(at) && (Pe = Qe.components[at], re < Pe.h && (re = Pe.h), Se < Pe.v && (Se = Pe.v));
                  var Be = Math.ceil(Qe.samplesPerLine / 8 / re), Ze = Math.ceil(Qe.scanLines / 8 / Se);
                  for (at in Qe.components)
                    if (Qe.components.hasOwnProperty(at)) {
                      Pe = Qe.components[at];
                      var fe = Math.ceil(Math.ceil(Qe.samplesPerLine / 8) * Pe.h / re), Je = Math.ceil(Math.ceil(Qe.scanLines / 8) * Pe.v / Se), Xe = Be * Pe.h, z = Ze * Pe.v, He = z * Xe, nt = [];
                      te(He * 256);
                      for (var ae = 0; ae < z; ae++) {
                        for (var $e = [], Et = 0; Et < Xe; Et++)
                          $e.push(new Int32Array(64));
                        nt.push($e);
                      }
                      Pe.blocksPerLine = fe, Pe.blocksPerColumn = Je, Pe.blocks = nt;
                    }
                  Qe.maxH = re, Qe.maxV = Se, Qe.mcusPerLine = Be, Qe.mcusPerColumn = Ze;
                }
                var we = null, Ce = null, it, ut, bt = [], pt = [], Ke = [], dt = [], ct = Ve();
                if (ct != 65496)
                  throw new Error("SOI not found");
                for (ct = Ve(); ct != 65497; ) {
                  var wt, Ht;
                  switch (ct) {
                    case 65280:
                      break;
                    case 65504:
                    // APP0 (Application Specific)
                    case 65505:
                    // APP1
                    case 65506:
                    // APP2
                    case 65507:
                    // APP3
                    case 65508:
                    // APP4
                    case 65509:
                    // APP5
                    case 65510:
                    // APP6
                    case 65511:
                    // APP7
                    case 65512:
                    // APP8
                    case 65513:
                    // APP9
                    case 65514:
                    // APP10
                    case 65515:
                    // APP11
                    case 65516:
                    // APP12
                    case 65517:
                    // APP13
                    case 65518:
                    // APP14
                    case 65519:
                    // APP15
                    case 65534:
                      var $t = Oe();
                      ct === 65504 && $t[0] === 74 && $t[1] === 70 && $t[2] === 73 && $t[3] === 70 && $t[4] === 0 && (we = {
                        version: { major: $t[5], minor: $t[6] },
                        densityUnits: $t[7],
                        xDensity: $t[8] << 8 | $t[9],
                        yDensity: $t[10] << 8 | $t[11],
                        thumbWidth: $t[12],
                        thumbHeight: $t[13],
                        thumbData: $t.subarray(14, 14 + 3 * $t[12] * $t[13])
                      }), ct === 65505 && $t[0] === 69 && $t[1] === 120 && $t[2] === 105 && $t[3] === 102 && $t[4] === 0 && (this.exifBuffer = $t.subarray(5, $t.length)), ct === 65518 && $t[0] === 65 && $t[1] === 100 && $t[2] === 111 && $t[3] === 98 && $t[4] === 101 && $t[5] === 0 && (Ce = {
                        version: $t[6],
                        flags0: $t[7] << 8 | $t[8],
                        flags1: $t[9] << 8 | $t[10],
                        transformCode: $t[11]
                      });
                      break;
                    case 65499:
                      for (var rt = Ve(), ri = rt + ge - 2; ge < ri; ) {
                        var wi = me[ge++];
                        te(256);
                        var Qt = new Int32Array(64);
                        if (wi >> 4)
                          if (wi >> 4 === 1)
                            for (Ht = 0; Ht < 64; Ht++) {
                              var At = R[Ht];
                              Qt[At] = Ve();
                            }
                          else
                            throw new Error("DQT: invalid table spec");
                        else for (Ht = 0; Ht < 64; Ht++) {
                          var At = R[Ht];
                          Qt[At] = me[ge++];
                        }
                        bt[wi & 15] = Qt;
                      }
                      break;
                    case 65472:
                    // SOF0 (Start of Frame, Baseline DCT)
                    case 65473:
                    // SOF1 (Start of Frame, Extended DCT)
                    case 65474:
                      Ve(), it = {}, it.extended = ct === 65473, it.progressive = ct === 65474, it.precision = me[ge++], it.scanLines = Ve(), it.samplesPerLine = Ve(), it.components = {}, it.componentsOrder = [];
                      var St = it.scanLines * it.samplesPerLine;
                      if (St > ke) {
                        var Lt = Math.ceil((St - ke) / 1e6);
                        throw new Error(`maxResolutionInMP limit exceeded by ${Lt}MP`);
                      }
                      var kt = me[ge++], Ye;
                      for (wt = 0; wt < kt; wt++) {
                        Ye = me[ge];
                        var De = me[ge + 1] >> 4, Re = me[ge + 1] & 15, _t = me[ge + 2];
                        it.componentsOrder.push(Ye), it.components[Ye] = {
                          h: De,
                          v: Re,
                          quantizationIdx: _t
                        }, ge += 3;
                      }
                      Ue(it), pt.push(it);
                      break;
                    case 65476:
                      var et = Ve();
                      for (wt = 2; wt < et; ) {
                        var Ie = me[ge++], pe = new Uint8Array(16), xt = 0;
                        for (Ht = 0; Ht < 16; Ht++, ge++)
                          xt += pe[Ht] = me[ge];
                        te(16 + xt);
                        var l = new Uint8Array(xt);
                        for (Ht = 0; Ht < xt; Ht++, ge++)
                          l[Ht] = me[ge];
                        wt += 17 + xt, (Ie >> 4 ? Ke : dt)[Ie & 15] = U(pe, l);
                      }
                      break;
                    case 65501:
                      Ve(), ut = Ve();
                      break;
                    case 65498:
                      Ve();
                      var _ = me[ge++], I = [], X;
                      for (wt = 0; wt < _; wt++) {
                        X = it.components[me[ge++]];
                        var ne = me[ge++];
                        X.huffmanTableDC = dt[ne >> 4], X.huffmanTableAC = Ke[ne & 15], I.push(X);
                      }
                      var ue = me[ge++], Te = me[ge++], ye = me[ge++], Me = j(
                        me,
                        ge,
                        it,
                        I,
                        ut,
                        ue,
                        Te,
                        ye >> 4,
                        ye & 15,
                        this.opts
                      );
                      ge += Me;
                      break;
                    case 65535:
                      me[ge] !== 255 && ge--;
                      break;
                    default:
                      if (me[ge - 3] == 255 && me[ge - 2] >= 192 && me[ge - 2] <= 254) {
                        ge -= 3;
                        break;
                      }
                      throw new Error("unknown JPEG marker " + ct.toString(16));
                  }
                  ct = Ve();
                }
                if (pt.length != 1)
                  throw new Error("only single frame JPEGs supported");
                for (var wt = 0; wt < pt.length; wt++) {
                  var Ge = pt[wt].components;
                  for (var Ht in Ge)
                    Ge[Ht].quantizationTable = bt[Ge[Ht].quantizationIdx], delete Ge[Ht].quantizationIdx;
                }
                this.width = it.samplesPerLine, this.height = it.scanLines, this.jfif = we, this.adobe = Ce, this.components = [];
                for (var wt = 0; wt < it.componentsOrder.length; wt++) {
                  var X = it.components[it.componentsOrder[wt]];
                  this.components.push({
                    lines: T(it, X),
                    scaleX: X.h / it.maxH,
                    scaleY: X.v / it.maxV
                  });
                }
              },
              getData: function(me, ke) {
                var ge = this.width / me, Ve = this.height / ke, Oe, Ue, we, Ce, it, ut, bt, pt, Ke, dt, ct = 0, wt, Ht, $t, rt, ri, wi, Qt, At, St, Lt, kt, Ye = me * ke * this.components.length;
                te(Ye);
                var De = new Uint8Array(Ye);
                switch (this.components.length) {
                  case 1:
                    for (Oe = this.components[0], dt = 0; dt < ke; dt++)
                      for (it = Oe.lines[0 | dt * Oe.scaleY * Ve], Ke = 0; Ke < me; Ke++)
                        wt = it[0 | Ke * Oe.scaleX * ge], De[ct++] = wt;
                    break;
                  case 2:
                    for (Oe = this.components[0], Ue = this.components[1], dt = 0; dt < ke; dt++)
                      for (it = Oe.lines[0 | dt * Oe.scaleY * Ve], ut = Ue.lines[0 | dt * Ue.scaleY * Ve], Ke = 0; Ke < me; Ke++)
                        wt = it[0 | Ke * Oe.scaleX * ge], De[ct++] = wt, wt = ut[0 | Ke * Ue.scaleX * ge], De[ct++] = wt;
                    break;
                  case 3:
                    for (kt = !0, this.adobe && this.adobe.transformCode ? kt = !0 : typeof this.opts.colorTransform < "u" && (kt = !!this.opts.colorTransform), Oe = this.components[0], Ue = this.components[1], we = this.components[2], dt = 0; dt < ke; dt++)
                      for (it = Oe.lines[0 | dt * Oe.scaleY * Ve], ut = Ue.lines[0 | dt * Ue.scaleY * Ve], bt = we.lines[0 | dt * we.scaleY * Ve], Ke = 0; Ke < me; Ke++)
                        kt ? (wt = it[0 | Ke * Oe.scaleX * ge], Ht = ut[0 | Ke * Ue.scaleX * ge], $t = bt[0 | Ke * we.scaleX * ge], At = W(wt + 1.402 * ($t - 128)), St = W(wt - 0.3441363 * (Ht - 128) - 0.71413636 * ($t - 128)), Lt = W(wt + 1.772 * (Ht - 128))) : (At = it[0 | Ke * Oe.scaleX * ge], St = ut[0 | Ke * Ue.scaleX * ge], Lt = bt[0 | Ke * we.scaleX * ge]), De[ct++] = At, De[ct++] = St, De[ct++] = Lt;
                    break;
                  case 4:
                    if (!this.adobe)
                      throw new Error("Unsupported color mode (4 components)");
                    for (kt = !1, this.adobe && this.adobe.transformCode ? kt = !0 : typeof this.opts.colorTransform < "u" && (kt = !!this.opts.colorTransform), Oe = this.components[0], Ue = this.components[1], we = this.components[2], Ce = this.components[3], dt = 0; dt < ke; dt++)
                      for (it = Oe.lines[0 | dt * Oe.scaleY * Ve], ut = Ue.lines[0 | dt * Ue.scaleY * Ve], bt = we.lines[0 | dt * we.scaleY * Ve], pt = Ce.lines[0 | dt * Ce.scaleY * Ve], Ke = 0; Ke < me; Ke++)
                        kt ? (wt = it[0 | Ke * Oe.scaleX * ge], Ht = ut[0 | Ke * Ue.scaleX * ge], $t = bt[0 | Ke * we.scaleX * ge], rt = pt[0 | Ke * Ce.scaleX * ge], ri = 255 - W(wt + 1.402 * ($t - 128)), wi = 255 - W(wt - 0.3441363 * (Ht - 128) - 0.71413636 * ($t - 128)), Qt = 255 - W(wt + 1.772 * (Ht - 128))) : (ri = it[0 | Ke * Oe.scaleX * ge], wi = ut[0 | Ke * Ue.scaleX * ge], Qt = bt[0 | Ke * we.scaleX * ge], rt = pt[0 | Ke * Ce.scaleX * ge]), De[ct++] = 255 - ri, De[ct++] = 255 - wi, De[ct++] = 255 - Qt, De[ct++] = 255 - rt;
                    break;
                  default:
                    throw new Error("Unsupported color mode");
                }
                return De;
              },
              copyToImageData: function(me, ke) {
                var ge = me.width, Ve = me.height, Oe = me.data, Ue = this.getData(ge, Ve), we = 0, Ce = 0, it, ut, bt, pt, Ke, dt, ct, wt, Ht;
                switch (this.components.length) {
                  case 1:
                    for (ut = 0; ut < Ve; ut++)
                      for (it = 0; it < ge; it++)
                        bt = Ue[we++], Oe[Ce++] = bt, Oe[Ce++] = bt, Oe[Ce++] = bt, ke && (Oe[Ce++] = 255);
                    break;
                  case 3:
                    for (ut = 0; ut < Ve; ut++)
                      for (it = 0; it < ge; it++)
                        ct = Ue[we++], wt = Ue[we++], Ht = Ue[we++], Oe[Ce++] = ct, Oe[Ce++] = wt, Oe[Ce++] = Ht, ke && (Oe[Ce++] = 255);
                    break;
                  case 4:
                    for (ut = 0; ut < Ve; ut++)
                      for (it = 0; it < ge; it++)
                        Ke = Ue[we++], dt = Ue[we++], bt = Ue[we++], pt = Ue[we++], ct = 255 - W(Ke * (1 - pt / 255) + pt), wt = 255 - W(dt * (1 - pt / 255) + pt), Ht = 255 - W(bt * (1 - pt / 255) + pt), Oe[Ce++] = ct, Oe[Ce++] = wt, Oe[Ce++] = Ht, ke && (Oe[Ce++] = 255);
                    break;
                  default:
                    throw new Error("Unsupported color mode");
                }
              }
            };
            var J = 0, ee = 0;
            function te(le = 0) {
              var me = J + le;
              if (me > ee) {
                var ke = Math.ceil((me - ee) / 1024 / 1024);
                throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${ke}MB`);
              }
              J = me;
            }
            return S.resetMaxMemoryUsage = function(le) {
              J = 0, ee = le;
            }, S.getBytesAllocated = function() {
              return J;
            }, S.requestMemoryAllocation = te, S;
          }();
          typeof de < "u" ? de.exports = N : typeof qe < "u" && (qe["jpeg-js"] = qe["jpeg-js"] || {}, qe["jpeg-js"].decode = N);
          function N(Z, R = {}) {
            var A = {
              // "undefined" means "Choose whether to transform colors based on the images color model."
              colorTransform: void 0,
              useTArray: !1,
              formatAsRGBA: !0,
              tolerantDecoding: !0,
              maxResolutionInMP: 100,
              // Don't decode more than 100 megapixels
              maxMemoryUsageInMB: 512
              // Don't decode if memory footprint is more than 512MB
            }, M = { ...A, ...R }, x = new Uint8Array(Z), m = new i();
            m.opts = M, i.resetMaxMemoryUsage(M.maxMemoryUsageInMB * 1024 * 1024), m.parse(x);
            var w = M.formatAsRGBA ? 4 : 3, k = m.width * m.height * w;
            try {
              i.requestMemoryAllocation(k);
              var E = {
                width: m.width,
                height: m.height,
                exifBuffer: m.exifBuffer,
                data: M.useTArray ? new Uint8Array(k) : new ie(k)
              };
            } catch (P) {
              throw P instanceof RangeError ? new Error("Could not allocate enough memory for the image. Required: " + k) : P;
            }
            return m.copyToImageData(E, M.formatAsRGBA), E;
          }
        }).call(this, Q("buffer").Buffer);
      }, { buffer: 48 }], 82: [function(Q, de, q) {
        (function(ie) {
          function i(Z) {
            var R = Math.floor, A = new Array(64), M = new Array(64), x = new Array(64), m = new Array(64), w, k, E, P, S = new Array(65535), U = new Array(65535), j = new Array(64), T = new Array(64), W = [], J = 0, ee = 7, te = new Array(64), le = new Array(64), me = new Array(64), ke = new Array(256), ge = new Array(2048), Ve, Oe = [
              0,
              1,
              5,
              6,
              14,
              15,
              27,
              28,
              2,
              4,
              7,
              13,
              16,
              26,
              29,
              42,
              3,
              8,
              12,
              17,
              25,
              30,
              41,
              43,
              9,
              11,
              18,
              24,
              31,
              40,
              44,
              53,
              10,
              19,
              23,
              32,
              39,
              45,
              52,
              54,
              20,
              22,
              33,
              38,
              46,
              51,
              55,
              60,
              21,
              34,
              37,
              47,
              50,
              56,
              59,
              61,
              35,
              36,
              48,
              49,
              57,
              58,
              62,
              63
            ], Ue = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], we = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Ce = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], it = [
              1,
              2,
              3,
              0,
              4,
              17,
              5,
              18,
              33,
              49,
              65,
              6,
              19,
              81,
              97,
              7,
              34,
              113,
              20,
              50,
              129,
              145,
              161,
              8,
              35,
              66,
              177,
              193,
              21,
              82,
              209,
              240,
              36,
              51,
              98,
              114,
              130,
              9,
              10,
              22,
              23,
              24,
              25,
              26,
              37,
              38,
              39,
              40,
              41,
              42,
              52,
              53,
              54,
              55,
              56,
              57,
              58,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              90,
              99,
              100,
              101,
              102,
              103,
              104,
              105,
              106,
              115,
              116,
              117,
              118,
              119,
              120,
              121,
              122,
              131,
              132,
              133,
              134,
              135,
              136,
              137,
              138,
              146,
              147,
              148,
              149,
              150,
              151,
              152,
              153,
              154,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              178,
              179,
              180,
              181,
              182,
              183,
              184,
              185,
              186,
              194,
              195,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              210,
              211,
              212,
              213,
              214,
              215,
              216,
              217,
              218,
              225,
              226,
              227,
              228,
              229,
              230,
              231,
              232,
              233,
              234,
              241,
              242,
              243,
              244,
              245,
              246,
              247,
              248,
              249,
              250
            ], ut = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], bt = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], pt = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], Ke = [
              0,
              1,
              2,
              3,
              17,
              4,
              5,
              33,
              49,
              6,
              18,
              65,
              81,
              7,
              97,
              113,
              19,
              34,
              50,
              129,
              8,
              20,
              66,
              145,
              161,
              177,
              193,
              9,
              35,
              51,
              82,
              240,
              21,
              98,
              114,
              209,
              10,
              22,
              36,
              52,
              225,
              37,
              241,
              23,
              24,
              25,
              26,
              38,
              39,
              40,
              41,
              42,
              53,
              54,
              55,
              56,
              57,
              58,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              90,
              99,
              100,
              101,
              102,
              103,
              104,
              105,
              106,
              115,
              116,
              117,
              118,
              119,
              120,
              121,
              122,
              130,
              131,
              132,
              133,
              134,
              135,
              136,
              137,
              138,
              146,
              147,
              148,
              149,
              150,
              151,
              152,
              153,
              154,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              178,
              179,
              180,
              181,
              182,
              183,
              184,
              185,
              186,
              194,
              195,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              210,
              211,
              212,
              213,
              214,
              215,
              216,
              217,
              218,
              226,
              227,
              228,
              229,
              230,
              231,
              232,
              233,
              234,
              242,
              243,
              244,
              245,
              246,
              247,
              248,
              249,
              250
            ];
            function dt(pe) {
              for (var xt = [
                16,
                11,
                10,
                16,
                24,
                40,
                51,
                61,
                12,
                12,
                14,
                19,
                26,
                58,
                60,
                55,
                14,
                13,
                16,
                24,
                40,
                57,
                69,
                56,
                14,
                17,
                22,
                29,
                51,
                87,
                80,
                62,
                18,
                22,
                37,
                56,
                68,
                109,
                103,
                77,
                24,
                35,
                55,
                64,
                81,
                104,
                113,
                92,
                49,
                64,
                78,
                87,
                103,
                121,
                120,
                101,
                72,
                92,
                95,
                98,
                112,
                100,
                103,
                99
              ], l = 0; l < 64; l++) {
                var _ = R((xt[l] * pe + 50) / 100);
                _ < 1 ? _ = 1 : _ > 255 && (_ = 255), A[Oe[l]] = _;
              }
              for (var I = [
                17,
                18,
                24,
                47,
                99,
                99,
                99,
                99,
                18,
                21,
                26,
                66,
                99,
                99,
                99,
                99,
                24,
                26,
                56,
                99,
                99,
                99,
                99,
                99,
                47,
                66,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99
              ], X = 0; X < 64; X++) {
                var ne = R((I[X] * pe + 50) / 100);
                ne < 1 ? ne = 1 : ne > 255 && (ne = 255), M[Oe[X]] = ne;
              }
              for (var ue = [
                1,
                1.387039845,
                1.306562965,
                1.175875602,
                1,
                0.785694958,
                0.5411961,
                0.275899379
              ], Te = 0, ye = 0; ye < 8; ye++)
                for (var Me = 0; Me < 8; Me++)
                  x[Te] = 1 / (A[Oe[Te]] * ue[ye] * ue[Me] * 8), m[Te] = 1 / (M[Oe[Te]] * ue[ye] * ue[Me] * 8), Te++;
            }
            function ct(pe, xt) {
              for (var l = 0, _ = 0, I = new Array(), X = 1; X <= 16; X++) {
                for (var ne = 1; ne <= pe[X]; ne++)
                  I[xt[_]] = [], I[xt[_]][0] = l, I[xt[_]][1] = X, _++, l++;
                l *= 2;
              }
              return I;
            }
            function wt() {
              w = ct(Ue, we), k = ct(ut, bt), E = ct(Ce, it), P = ct(pt, Ke);
            }
            function Ht() {
              for (var pe = 1, xt = 2, l = 1; l <= 15; l++) {
                for (var _ = pe; _ < xt; _++)
                  U[32767 + _] = l, S[32767 + _] = [], S[32767 + _][1] = l, S[32767 + _][0] = _;
                for (var I = -(xt - 1); I <= -pe; I++)
                  U[32767 + I] = l, S[32767 + I] = [], S[32767 + I][1] = l, S[32767 + I][0] = xt - 1 + I;
                pe <<= 1, xt <<= 1;
              }
            }
            function $t() {
              for (var pe = 0; pe < 256; pe++)
                ge[pe] = 19595 * pe, ge[pe + 256 >> 0] = 38470 * pe, ge[pe + 512 >> 0] = 7471 * pe + 32768, ge[pe + 768 >> 0] = -11059 * pe, ge[pe + 1024 >> 0] = -21709 * pe, ge[pe + 1280 >> 0] = 32768 * pe + 8421375, ge[pe + 1536 >> 0] = -27439 * pe, ge[pe + 1792 >> 0] = -5329 * pe;
            }
            function rt(pe) {
              for (var xt = pe[0], l = pe[1] - 1; l >= 0; )
                xt & 1 << l && (J |= 1 << ee), l--, ee--, ee < 0 && (J == 255 ? (ri(255), ri(0)) : ri(J), ee = 7, J = 0);
            }
            function ri(pe) {
              W.push(pe);
            }
            function wi(pe) {
              ri(pe >> 8 & 255), ri(pe & 255);
            }
            function Qt(pe, xt) {
              var l, _, I, X, ne, ue, Te, ye, Me = 0, Ge, Qe = 8, re = 64;
              for (Ge = 0; Ge < Qe; ++Ge) {
                l = pe[Me], _ = pe[Me + 1], I = pe[Me + 2], X = pe[Me + 3], ne = pe[Me + 4], ue = pe[Me + 5], Te = pe[Me + 6], ye = pe[Me + 7];
                var Se = l + ye, Pe = l - ye, at = _ + Te, Be = _ - Te, Ze = I + ue, fe = I - ue, Je = X + ne, Xe = X - ne, z = Se + Je, He = Se - Je, nt = at + Ze, ae = at - Ze;
                pe[Me] = z + nt, pe[Me + 4] = z - nt;
                var $e = (ae + He) * 0.707106781;
                pe[Me + 2] = He + $e, pe[Me + 6] = He - $e, z = Xe + fe, nt = fe + Be, ae = Be + Pe;
                var Et = (z - ae) * 0.382683433, Nt = 0.5411961 * z + Et, Yt = 1.306562965 * ae + Et, Ft = nt * 0.707106781, ai = Pe + Ft, Mt = Pe - Ft;
                pe[Me + 5] = Mt + Nt, pe[Me + 3] = Mt - Nt, pe[Me + 1] = ai + Yt, pe[Me + 7] = ai - Yt, Me += 8;
              }
              for (Me = 0, Ge = 0; Ge < Qe; ++Ge) {
                l = pe[Me], _ = pe[Me + 8], I = pe[Me + 16], X = pe[Me + 24], ne = pe[Me + 32], ue = pe[Me + 40], Te = pe[Me + 48], ye = pe[Me + 56];
                var Ae = l + ye, Fe = l - ye, tt = _ + Te, Ct = _ - Te, It = I + ue, Ut = I - ue, ti = X + ne, Pt = X - ne, Wt = Ae + ti, ei = Ae - ti, oi = tt + It, _i = tt - It;
                pe[Me] = Wt + oi, pe[Me + 32] = Wt - oi;
                var Di = (_i + ei) * 0.707106781;
                pe[Me + 16] = ei + Di, pe[Me + 48] = ei - Di, Wt = Pt + Ut, oi = Ut + Ct, _i = Ct + Fe;
                var Bi = (Wt - _i) * 0.382683433, Hi = 0.5411961 * Wt + Bi, nr = 1.306562965 * _i + Bi, rr = oi * 0.707106781, dr = Fe + rr, Rr = Fe - rr;
                pe[Me + 40] = Rr + Hi, pe[Me + 24] = Rr - Hi, pe[Me + 8] = dr + nr, pe[Me + 56] = dr - nr, Me++;
              }
              var Br;
              for (Ge = 0; Ge < re; ++Ge)
                Br = pe[Ge] * xt[Ge], j[Ge] = Br > 0 ? Br + 0.5 | 0 : Br - 0.5 | 0;
              return j;
            }
            function At() {
              wi(65504), wi(16), ri(74), ri(70), ri(73), ri(70), ri(0), ri(1), ri(1), ri(0), wi(1), wi(1), ri(0), ri(0);
            }
            function St(pe) {
              if (pe) {
                wi(65505), pe[0] === 69 && pe[1] === 120 && pe[2] === 105 && pe[3] === 102 ? wi(pe.length + 2) : (wi(pe.length + 5 + 2), ri(69), ri(120), ri(105), ri(102), ri(0));
                for (var xt = 0; xt < pe.length; xt++)
                  ri(pe[xt]);
              }
            }
            function Lt(pe, xt) {
              wi(65472), wi(17), ri(8), wi(xt), wi(pe), ri(3), ri(1), ri(17), ri(0), ri(2), ri(17), ri(1), ri(3), ri(17), ri(1);
            }
            function kt() {
              wi(65499), wi(132), ri(0);
              for (var pe = 0; pe < 64; pe++)
                ri(A[pe]);
              ri(1);
              for (var xt = 0; xt < 64; xt++)
                ri(M[xt]);
            }
            function Ye() {
              wi(65476), wi(418), ri(0);
              for (var pe = 0; pe < 16; pe++)
                ri(Ue[pe + 1]);
              for (var xt = 0; xt <= 11; xt++)
                ri(we[xt]);
              ri(16);
              for (var l = 0; l < 16; l++)
                ri(Ce[l + 1]);
              for (var _ = 0; _ <= 161; _++)
                ri(it[_]);
              ri(1);
              for (var I = 0; I < 16; I++)
                ri(ut[I + 1]);
              for (var X = 0; X <= 11; X++)
                ri(bt[X]);
              ri(17);
              for (var ne = 0; ne < 16; ne++)
                ri(pt[ne + 1]);
              for (var ue = 0; ue <= 161; ue++)
                ri(Ke[ue]);
            }
            function De() {
              wi(65498), wi(12), ri(3), ri(1), ri(0), ri(2), ri(17), ri(3), ri(17), ri(0), ri(63), ri(0);
            }
            function Re(pe, xt, l, _, I) {
              for (var X = I[0], ne = I[240], ue, Te = 16, ye = 63, Me = 64, Ge = Qt(pe, xt), Qe = 0; Qe < Me; ++Qe)
                T[Oe[Qe]] = Ge[Qe];
              var re = T[0] - l;
              l = T[0], re == 0 ? rt(_[0]) : (ue = 32767 + re, rt(_[U[ue]]), rt(S[ue]));
              for (var Se = 63; Se > 0 && T[Se] == 0; Se--)
                ;
              if (Se == 0)
                return rt(X), l;
              for (var Pe = 1, at; Pe <= Se; ) {
                for (var Be = Pe; T[Pe] == 0 && Pe <= Se; ++Pe)
                  ;
                var Ze = Pe - Be;
                if (Ze >= Te) {
                  at = Ze >> 4;
                  for (var fe = 1; fe <= at; ++fe)
                    rt(ne);
                  Ze = Ze & 15;
                }
                ue = 32767 + T[Pe], rt(I[(Ze << 4) + U[ue]]), rt(S[ue]), Pe++;
              }
              return Se != ye && rt(X), l;
            }
            function _t() {
              for (var pe = String.fromCharCode, xt = 0; xt < 256; xt++)
                ke[xt] = pe(xt);
            }
            this.encode = function(pe, xt) {
              (/* @__PURE__ */ new Date()).getTime(), xt && et(xt), W = new Array(), J = 0, ee = 7, wi(65496), At(), St(pe.exifBuffer), kt(), Lt(pe.width, pe.height), Ye(), De();
              var l = 0, _ = 0, I = 0;
              J = 0, ee = 7, this.encode.displayName = "_encode_";
              for (var X = pe.data, ne = pe.width, ue = pe.height, Te = ne * 4, ye, Me = 0, Ge, Qe, re, Se, Pe, at, Be, Ze; Me < ue; ) {
                for (ye = 0; ye < Te; ) {
                  for (Se = Te * Me + ye, Pe = Se, at = -1, Be = 0, Ze = 0; Ze < 64; Ze++)
                    Be = Ze >> 3, at = (Ze & 7) * 4, Pe = Se + Be * Te + at, Me + Be >= ue && (Pe -= Te * (Me + 1 + Be - ue)), ye + at >= Te && (Pe -= ye + at - Te + 4), Ge = X[Pe++], Qe = X[Pe++], re = X[Pe++], te[Ze] = (ge[Ge] + ge[Qe + 256 >> 0] + ge[re + 512 >> 0] >> 16) - 128, le[Ze] = (ge[Ge + 768 >> 0] + ge[Qe + 1024 >> 0] + ge[re + 1280 >> 0] >> 16) - 128, me[Ze] = (ge[Ge + 1280 >> 0] + ge[Qe + 1536 >> 0] + ge[re + 1792 >> 0] >> 16) - 128;
                  l = Re(te, x, l, w, E), _ = Re(le, m, _, k, P), I = Re(me, m, I, k, P), ye += 32;
                }
                Me += 8;
              }
              if (ee >= 0) {
                var fe = [];
                fe[1] = ee + 1, fe[0] = (1 << ee + 1) - 1, rt(fe);
              }
              return wi(65497), typeof de > "u" ? new Uint8Array(W) : new ie(W);
            };
            function et(pe) {
              if (pe <= 0 && (pe = 1), pe > 100 && (pe = 100), Ve != pe) {
                var xt = 0;
                pe < 50 ? xt = Math.floor(5e3 / pe) : xt = Math.floor(200 - pe * 2), dt(xt), Ve = pe;
              }
            }
            function Ie() {
              var pe = (/* @__PURE__ */ new Date()).getTime();
              Z || (Z = 50), _t(), wt(), Ht(), $t(), et(Z), (/* @__PURE__ */ new Date()).getTime() - pe;
            }
            Ie();
          }
          typeof de < "u" ? de.exports = N : typeof qe < "u" && (qe["jpeg-js"] = qe["jpeg-js"] || {}, qe["jpeg-js"].encode = N);
          function N(Z, R) {
            typeof R > "u" && (R = 50);
            var A = new i(R), M = A.encode(Z, R);
            return {
              data: M,
              width: Z.width,
              height: Z.height
            };
          }
        }).call(this, Q("buffer").Buffer);
      }, { buffer: 48 }], 83: [function(Q, de, q) {
        (function(ie) {
          var i = Q("path"), N = Q("fs"), Z = parseInt("0777", 8);
          de.exports = R.mkdirp = R.mkdirP = R;
          function R(A, M, x, m) {
            typeof M == "function" ? (x = M, M = {}) : (!M || typeof M != "object") && (M = { mode: M });
            var w = M.mode, k = M.fs || N;
            w === void 0 && (w = Z & ~ie.umask()), m || (m = null);
            var E = x || function() {
            };
            A = i.resolve(A), k.mkdir(A, w, function(P) {
              if (!P)
                return m = m || A, E(null, m);
              switch (P.code) {
                case "ENOENT":
                  R(i.dirname(A), M, function(S, U) {
                    S ? E(S, U) : R(A, M, E, U);
                  });
                  break;
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                  k.stat(A, function(S, U) {
                    S || !U.isDirectory() ? E(P, m) : E(null, m);
                  });
                  break;
              }
            });
          }
          R.sync = function A(M, x, m) {
            (!x || typeof x != "object") && (x = { mode: x });
            var w = x.mode, k = x.fs || N;
            w === void 0 && (w = Z & ~ie.umask()), m || (m = null), M = i.resolve(M);
            try {
              k.mkdirSync(M, w), m = m || M;
            } catch (P) {
              switch (P.code) {
                case "ENOENT":
                  m = A(i.dirname(M), x, m), A(M, x, m);
                  break;
                // In the case of any other error, just see if there's a dir
                // there already.  If so, then hooray!  If not, then something
                // is borked.
                default:
                  var E;
                  try {
                    E = k.statSync(M);
                  } catch {
                    throw P;
                  }
                  if (!E.isDirectory()) throw P;
                  break;
              }
            }
            return m;
          };
        }).call(this, Q("_process"));
      }, { _process: 133, fs: 47, path: 107 }], 84: [function(Q, de, q) {
        var ie = Object.getOwnPropertySymbols, i = Object.prototype.hasOwnProperty, N = Object.prototype.propertyIsEnumerable;
        function Z(A) {
          if (A == null)
            throw new TypeError("Object.assign cannot be called with null or undefined");
          return Object(A);
        }
        function R() {
          try {
            if (!Object.assign)
              return !1;
            var A = new String("abc");
            if (A[5] = "de", Object.getOwnPropertyNames(A)[0] === "5")
              return !1;
            for (var M = {}, x = 0; x < 10; x++)
              M["_" + String.fromCharCode(x)] = x;
            var m = Object.getOwnPropertyNames(M).map(function(k) {
              return M[k];
            });
            if (m.join("") !== "0123456789")
              return !1;
            var w = {};
            return "abcdefghijklmnopqrst".split("").forEach(function(k) {
              w[k] = k;
            }), Object.keys(Object.assign({}, w)).join("") === "abcdefghijklmnopqrst";
          } catch {
            return !1;
          }
        }
        de.exports = R() ? Object.assign : function(A, M) {
          for (var x, m = Z(A), w, k = 1; k < arguments.length; k++) {
            x = Object(arguments[k]);
            for (var E in x)
              i.call(x, E) && (m[E] = x[E]);
            if (ie) {
              w = ie(x);
              for (var P = 0; P < w.length; P++)
                N.call(x, w[P]) && (m[w[P]] = x[w[P]]);
            }
          }
          return m;
        };
      }, {}], 85: [function(Q, de, q) {
        arguments[4][64][0].apply(q, arguments);
      }, { dup: 64 }], 86: [function(Q, de, q) {
        var ie = Q("./lib/utils/common").assign, i = Q("./lib/deflate"), N = Q("./lib/inflate"), Z = Q("./lib/zlib/constants"), R = {};
        ie(R, i, N, Z), de.exports = R;
      }, { "./lib/deflate": 87, "./lib/inflate": 88, "./lib/utils/common": 89, "./lib/zlib/constants": 92 }], 87: [function(Q, de, q) {
        var ie = Q("./zlib/deflate"), i = Q("./utils/common"), N = Q("./utils/strings"), Z = Q("./zlib/messages"), R = Q("./zlib/zstream"), A = Object.prototype.toString, M = 0, x = 4, m = 0, w = 1, k = 2, E = -1, P = 0, S = 8;
        function U(J) {
          if (!(this instanceof U)) return new U(J);
          this.options = i.assign({
            level: E,
            method: S,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: P,
            to: ""
          }, J || {});
          var ee = this.options;
          ee.raw && ee.windowBits > 0 ? ee.windowBits = -ee.windowBits : ee.gzip && ee.windowBits > 0 && ee.windowBits < 16 && (ee.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new R(), this.strm.avail_out = 0;
          var te = ie.deflateInit2(
            this.strm,
            ee.level,
            ee.method,
            ee.windowBits,
            ee.memLevel,
            ee.strategy
          );
          if (te !== m)
            throw new Error(Z[te]);
          if (ee.header && ie.deflateSetHeader(this.strm, ee.header), ee.dictionary) {
            var le;
            if (typeof ee.dictionary == "string" ? le = N.string2buf(ee.dictionary) : A.call(ee.dictionary) === "[object ArrayBuffer]" ? le = new Uint8Array(ee.dictionary) : le = ee.dictionary, te = ie.deflateSetDictionary(this.strm, le), te !== m)
              throw new Error(Z[te]);
            this._dict_set = !0;
          }
        }
        U.prototype.push = function(J, ee) {
          var te = this.strm, le = this.options.chunkSize, me, ke;
          if (this.ended)
            return !1;
          ke = ee === ~~ee ? ee : ee === !0 ? x : M, typeof J == "string" ? te.input = N.string2buf(J) : A.call(J) === "[object ArrayBuffer]" ? te.input = new Uint8Array(J) : te.input = J, te.next_in = 0, te.avail_in = te.input.length;
          do {
            if (te.avail_out === 0 && (te.output = new i.Buf8(le), te.next_out = 0, te.avail_out = le), me = ie.deflate(te, ke), me !== w && me !== m)
              return this.onEnd(me), this.ended = !0, !1;
            (te.avail_out === 0 || te.avail_in === 0 && (ke === x || ke === k)) && (this.options.to === "string" ? this.onData(N.buf2binstring(i.shrinkBuf(te.output, te.next_out))) : this.onData(i.shrinkBuf(te.output, te.next_out)));
          } while ((te.avail_in > 0 || te.avail_out === 0) && me !== w);
          return ke === x ? (me = ie.deflateEnd(this.strm), this.onEnd(me), this.ended = !0, me === m) : (ke === k && (this.onEnd(m), te.avail_out = 0), !0);
        }, U.prototype.onData = function(J) {
          this.chunks.push(J);
        }, U.prototype.onEnd = function(J) {
          J === m && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = J, this.msg = this.strm.msg;
        };
        function j(J, ee) {
          var te = new U(ee);
          if (te.push(J, !0), te.err)
            throw te.msg || Z[te.err];
          return te.result;
        }
        function T(J, ee) {
          return ee = ee || {}, ee.raw = !0, j(J, ee);
        }
        function W(J, ee) {
          return ee = ee || {}, ee.gzip = !0, j(J, ee);
        }
        q.Deflate = U, q.deflate = j, q.deflateRaw = T, q.gzip = W;
      }, { "./utils/common": 89, "./utils/strings": 90, "./zlib/deflate": 94, "./zlib/messages": 99, "./zlib/zstream": 101 }], 88: [function(Q, de, q) {
        var ie = Q("./zlib/inflate"), i = Q("./utils/common"), N = Q("./utils/strings"), Z = Q("./zlib/constants"), R = Q("./zlib/messages"), A = Q("./zlib/zstream"), M = Q("./zlib/gzheader"), x = Object.prototype.toString;
        function m(E) {
          if (!(this instanceof m)) return new m(E);
          this.options = i.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, E || {});
          var P = this.options;
          P.raw && P.windowBits >= 0 && P.windowBits < 16 && (P.windowBits = -P.windowBits, P.windowBits === 0 && (P.windowBits = -15)), P.windowBits >= 0 && P.windowBits < 16 && !(E && E.windowBits) && (P.windowBits += 32), P.windowBits > 15 && P.windowBits < 48 && (P.windowBits & 15 || (P.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new A(), this.strm.avail_out = 0;
          var S = ie.inflateInit2(
            this.strm,
            P.windowBits
          );
          if (S !== Z.Z_OK)
            throw new Error(R[S]);
          this.header = new M(), ie.inflateGetHeader(this.strm, this.header);
        }
        m.prototype.push = function(E, P) {
          var S = this.strm, U = this.options.chunkSize, j = this.options.dictionary, T, W, J, ee, te, le, me = !1;
          if (this.ended)
            return !1;
          W = P === ~~P ? P : P === !0 ? Z.Z_FINISH : Z.Z_NO_FLUSH, typeof E == "string" ? S.input = N.binstring2buf(E) : x.call(E) === "[object ArrayBuffer]" ? S.input = new Uint8Array(E) : S.input = E, S.next_in = 0, S.avail_in = S.input.length;
          do {
            if (S.avail_out === 0 && (S.output = new i.Buf8(U), S.next_out = 0, S.avail_out = U), T = ie.inflate(S, Z.Z_NO_FLUSH), T === Z.Z_NEED_DICT && j && (typeof j == "string" ? le = N.string2buf(j) : x.call(j) === "[object ArrayBuffer]" ? le = new Uint8Array(j) : le = j, T = ie.inflateSetDictionary(this.strm, le)), T === Z.Z_BUF_ERROR && me === !0 && (T = Z.Z_OK, me = !1), T !== Z.Z_STREAM_END && T !== Z.Z_OK)
              return this.onEnd(T), this.ended = !0, !1;
            S.next_out && (S.avail_out === 0 || T === Z.Z_STREAM_END || S.avail_in === 0 && (W === Z.Z_FINISH || W === Z.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (J = N.utf8border(S.output, S.next_out), ee = S.next_out - J, te = N.buf2string(S.output, J), S.next_out = ee, S.avail_out = U - ee, ee && i.arraySet(S.output, S.output, J, ee, 0), this.onData(te)) : this.onData(i.shrinkBuf(S.output, S.next_out))), S.avail_in === 0 && S.avail_out === 0 && (me = !0);
          } while ((S.avail_in > 0 || S.avail_out === 0) && T !== Z.Z_STREAM_END);
          return T === Z.Z_STREAM_END && (W = Z.Z_FINISH), W === Z.Z_FINISH ? (T = ie.inflateEnd(this.strm), this.onEnd(T), this.ended = !0, T === Z.Z_OK) : (W === Z.Z_SYNC_FLUSH && (this.onEnd(Z.Z_OK), S.avail_out = 0), !0);
        }, m.prototype.onData = function(E) {
          this.chunks.push(E);
        }, m.prototype.onEnd = function(E) {
          E === Z.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = E, this.msg = this.strm.msg;
        };
        function w(E, P) {
          var S = new m(P);
          if (S.push(E, !0), S.err)
            throw S.msg || R[S.err];
          return S.result;
        }
        function k(E, P) {
          return P = P || {}, P.raw = !0, w(E, P);
        }
        q.Inflate = m, q.inflate = w, q.inflateRaw = k, q.ungzip = w;
      }, { "./utils/common": 89, "./utils/strings": 90, "./zlib/constants": 92, "./zlib/gzheader": 95, "./zlib/inflate": 97, "./zlib/messages": 99, "./zlib/zstream": 101 }], 89: [function(Q, de, q) {
        arguments[4][36][0].apply(q, arguments);
      }, { dup: 36 }], 90: [function(Q, de, q) {
        var ie = Q("./common"), i = !0, N = !0;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch {
          i = !1;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          N = !1;
        }
        for (var Z = new ie.Buf8(256), R = 0; R < 256; R++)
          Z[R] = R >= 252 ? 6 : R >= 248 ? 5 : R >= 240 ? 4 : R >= 224 ? 3 : R >= 192 ? 2 : 1;
        Z[254] = Z[254] = 1, q.string2buf = function(M) {
          var x, m, w, k, E, P = M.length, S = 0;
          for (k = 0; k < P; k++)
            m = M.charCodeAt(k), (m & 64512) === 55296 && k + 1 < P && (w = M.charCodeAt(k + 1), (w & 64512) === 56320 && (m = 65536 + (m - 55296 << 10) + (w - 56320), k++)), S += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
          for (x = new ie.Buf8(S), E = 0, k = 0; E < S; k++)
            m = M.charCodeAt(k), (m & 64512) === 55296 && k + 1 < P && (w = M.charCodeAt(k + 1), (w & 64512) === 56320 && (m = 65536 + (m - 55296 << 10) + (w - 56320), k++)), m < 128 ? x[E++] = m : m < 2048 ? (x[E++] = 192 | m >>> 6, x[E++] = 128 | m & 63) : m < 65536 ? (x[E++] = 224 | m >>> 12, x[E++] = 128 | m >>> 6 & 63, x[E++] = 128 | m & 63) : (x[E++] = 240 | m >>> 18, x[E++] = 128 | m >>> 12 & 63, x[E++] = 128 | m >>> 6 & 63, x[E++] = 128 | m & 63);
          return x;
        };
        function A(M, x) {
          if (x < 65537 && (M.subarray && N || !M.subarray && i))
            return String.fromCharCode.apply(null, ie.shrinkBuf(M, x));
          for (var m = "", w = 0; w < x; w++)
            m += String.fromCharCode(M[w]);
          return m;
        }
        q.buf2binstring = function(M) {
          return A(M, M.length);
        }, q.binstring2buf = function(M) {
          for (var x = new ie.Buf8(M.length), m = 0, w = x.length; m < w; m++)
            x[m] = M.charCodeAt(m);
          return x;
        }, q.buf2string = function(M, x) {
          var m, w, k, E, P = x || M.length, S = new Array(P * 2);
          for (w = 0, m = 0; m < P; ) {
            if (k = M[m++], k < 128) {
              S[w++] = k;
              continue;
            }
            if (E = Z[k], E > 4) {
              S[w++] = 65533, m += E - 1;
              continue;
            }
            for (k &= E === 2 ? 31 : E === 3 ? 15 : 7; E > 1 && m < P; )
              k = k << 6 | M[m++] & 63, E--;
            if (E > 1) {
              S[w++] = 65533;
              continue;
            }
            k < 65536 ? S[w++] = k : (k -= 65536, S[w++] = 55296 | k >> 10 & 1023, S[w++] = 56320 | k & 1023);
          }
          return A(S, w);
        }, q.utf8border = function(M, x) {
          var m;
          for (x = x || M.length, x > M.length && (x = M.length), m = x - 1; m >= 0 && (M[m] & 192) === 128; )
            m--;
          return m < 0 || m === 0 ? x : m + Z[M[m]] > x ? m : x;
        };
      }, { "./common": 89 }], 91: [function(Q, de, q) {
        arguments[4][37][0].apply(q, arguments);
      }, { dup: 37 }], 92: [function(Q, de, q) {
        arguments[4][38][0].apply(q, arguments);
      }, { dup: 38 }], 93: [function(Q, de, q) {
        arguments[4][39][0].apply(q, arguments);
      }, { dup: 39 }], 94: [function(Q, de, q) {
        var ie = Q("../utils/common"), i = Q("./trees"), N = Q("./adler32"), Z = Q("./crc32"), R = Q("./messages"), A = 0, M = 1, x = 3, m = 4, w = 5, k = 0, E = 1, P = -2, S = -3, U = -5, j = -1, T = 1, W = 2, J = 3, ee = 4, te = 0, le = 2, me = 8, ke = 9, ge = 15, Ve = 8, Oe = 29, Ue = 256, we = Ue + 1 + Oe, Ce = 30, it = 19, ut = 2 * we + 1, bt = 15, pt = 3, Ke = 258, dt = Ke + pt + 1, ct = 32, wt = 42, Ht = 69, $t = 73, rt = 91, ri = 103, wi = 113, Qt = 666, At = 1, St = 2, Lt = 3, kt = 4, Ye = 3;
        function De(z, He) {
          return z.msg = R[He], He;
        }
        function Re(z) {
          return (z << 1) - (z > 4 ? 9 : 0);
        }
        function _t(z) {
          for (var He = z.length; --He >= 0; )
            z[He] = 0;
        }
        function et(z) {
          var He = z.state, nt = He.pending;
          nt > z.avail_out && (nt = z.avail_out), nt !== 0 && (ie.arraySet(z.output, He.pending_buf, He.pending_out, nt, z.next_out), z.next_out += nt, He.pending_out += nt, z.total_out += nt, z.avail_out -= nt, He.pending -= nt, He.pending === 0 && (He.pending_out = 0));
        }
        function Ie(z, He) {
          i._tr_flush_block(z, z.block_start >= 0 ? z.block_start : -1, z.strstart - z.block_start, He), z.block_start = z.strstart, et(z.strm);
        }
        function pe(z, He) {
          z.pending_buf[z.pending++] = He;
        }
        function xt(z, He) {
          z.pending_buf[z.pending++] = He >>> 8 & 255, z.pending_buf[z.pending++] = He & 255;
        }
        function l(z, He, nt, ae) {
          var $e = z.avail_in;
          return $e > ae && ($e = ae), $e === 0 ? 0 : (z.avail_in -= $e, ie.arraySet(He, z.input, z.next_in, $e, nt), z.state.wrap === 1 ? z.adler = N(z.adler, He, $e, nt) : z.state.wrap === 2 && (z.adler = Z(z.adler, He, $e, nt)), z.next_in += $e, z.total_in += $e, $e);
        }
        function _(z, He) {
          var nt = z.max_chain_length, ae = z.strstart, $e, Et, Nt = z.prev_length, Yt = z.nice_match, Ft = z.strstart > z.w_size - dt ? z.strstart - (z.w_size - dt) : 0, ai = z.window, Mt = z.w_mask, Ae = z.prev, Fe = z.strstart + Ke, tt = ai[ae + Nt - 1], Ct = ai[ae + Nt];
          z.prev_length >= z.good_match && (nt >>= 2), Yt > z.lookahead && (Yt = z.lookahead);
          do
            if ($e = He, !(ai[$e + Nt] !== Ct || ai[$e + Nt - 1] !== tt || ai[$e] !== ai[ae] || ai[++$e] !== ai[ae + 1])) {
              ae += 2, $e++;
              do
                ;
              while (ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ai[++ae] === ai[++$e] && ae < Fe);
              if (Et = Ke - (Fe - ae), ae = Fe - Ke, Et > Nt) {
                if (z.match_start = He, Nt = Et, Et >= Yt)
                  break;
                tt = ai[ae + Nt - 1], Ct = ai[ae + Nt];
              }
            }
          while ((He = Ae[He & Mt]) > Ft && --nt !== 0);
          return Nt <= z.lookahead ? Nt : z.lookahead;
        }
        function I(z) {
          var He = z.w_size, nt, ae, $e, Et, Nt;
          do {
            if (Et = z.window_size - z.lookahead - z.strstart, z.strstart >= He + (He - dt)) {
              ie.arraySet(z.window, z.window, He, He, 0), z.match_start -= He, z.strstart -= He, z.block_start -= He, ae = z.hash_size, nt = ae;
              do
                $e = z.head[--nt], z.head[nt] = $e >= He ? $e - He : 0;
              while (--ae);
              ae = He, nt = ae;
              do
                $e = z.prev[--nt], z.prev[nt] = $e >= He ? $e - He : 0;
              while (--ae);
              Et += He;
            }
            if (z.strm.avail_in === 0)
              break;
            if (ae = l(z.strm, z.window, z.strstart + z.lookahead, Et), z.lookahead += ae, z.lookahead + z.insert >= pt)
              for (Nt = z.strstart - z.insert, z.ins_h = z.window[Nt], z.ins_h = (z.ins_h << z.hash_shift ^ z.window[Nt + 1]) & z.hash_mask; z.insert && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[Nt + pt - 1]) & z.hash_mask, z.prev[Nt & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = Nt, Nt++, z.insert--, !(z.lookahead + z.insert < pt)); )
                ;
          } while (z.lookahead < dt && z.strm.avail_in !== 0);
        }
        function X(z, He) {
          var nt = 65535;
          for (nt > z.pending_buf_size - 5 && (nt = z.pending_buf_size - 5); ; ) {
            if (z.lookahead <= 1) {
              if (I(z), z.lookahead === 0 && He === A)
                return At;
              if (z.lookahead === 0)
                break;
            }
            z.strstart += z.lookahead, z.lookahead = 0;
            var ae = z.block_start + nt;
            if ((z.strstart === 0 || z.strstart >= ae) && (z.lookahead = z.strstart - ae, z.strstart = ae, Ie(z, !1), z.strm.avail_out === 0) || z.strstart - z.block_start >= z.w_size - dt && (Ie(z, !1), z.strm.avail_out === 0))
              return At;
          }
          return z.insert = 0, He === m ? (Ie(z, !0), z.strm.avail_out === 0 ? Lt : kt) : (z.strstart > z.block_start && (Ie(z, !1), z.strm.avail_out === 0), At);
        }
        function ne(z, He) {
          for (var nt, ae; ; ) {
            if (z.lookahead < dt) {
              if (I(z), z.lookahead < dt && He === A)
                return At;
              if (z.lookahead === 0)
                break;
            }
            if (nt = 0, z.lookahead >= pt && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + pt - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart), nt !== 0 && z.strstart - nt <= z.w_size - dt && (z.match_length = _(z, nt)), z.match_length >= pt)
              if (ae = i._tr_tally(z, z.strstart - z.match_start, z.match_length - pt), z.lookahead -= z.match_length, z.match_length <= z.max_lazy_match && z.lookahead >= pt) {
                z.match_length--;
                do
                  z.strstart++, z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + pt - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart;
                while (--z.match_length !== 0);
                z.strstart++;
              } else
                z.strstart += z.match_length, z.match_length = 0, z.ins_h = z.window[z.strstart], z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + 1]) & z.hash_mask;
            else
              ae = i._tr_tally(z, 0, z.window[z.strstart]), z.lookahead--, z.strstart++;
            if (ae && (Ie(z, !1), z.strm.avail_out === 0))
              return At;
          }
          return z.insert = z.strstart < pt - 1 ? z.strstart : pt - 1, He === m ? (Ie(z, !0), z.strm.avail_out === 0 ? Lt : kt) : z.last_lit && (Ie(z, !1), z.strm.avail_out === 0) ? At : St;
        }
        function ue(z, He) {
          for (var nt, ae, $e; ; ) {
            if (z.lookahead < dt) {
              if (I(z), z.lookahead < dt && He === A)
                return At;
              if (z.lookahead === 0)
                break;
            }
            if (nt = 0, z.lookahead >= pt && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + pt - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart), z.prev_length = z.match_length, z.prev_match = z.match_start, z.match_length = pt - 1, nt !== 0 && z.prev_length < z.max_lazy_match && z.strstart - nt <= z.w_size - dt && (z.match_length = _(z, nt), z.match_length <= 5 && (z.strategy === T || z.match_length === pt && z.strstart - z.match_start > 4096) && (z.match_length = pt - 1)), z.prev_length >= pt && z.match_length <= z.prev_length) {
              $e = z.strstart + z.lookahead - pt, ae = i._tr_tally(z, z.strstart - 1 - z.prev_match, z.prev_length - pt), z.lookahead -= z.prev_length - 1, z.prev_length -= 2;
              do
                ++z.strstart <= $e && (z.ins_h = (z.ins_h << z.hash_shift ^ z.window[z.strstart + pt - 1]) & z.hash_mask, nt = z.prev[z.strstart & z.w_mask] = z.head[z.ins_h], z.head[z.ins_h] = z.strstart);
              while (--z.prev_length !== 0);
              if (z.match_available = 0, z.match_length = pt - 1, z.strstart++, ae && (Ie(z, !1), z.strm.avail_out === 0))
                return At;
            } else if (z.match_available) {
              if (ae = i._tr_tally(z, 0, z.window[z.strstart - 1]), ae && Ie(z, !1), z.strstart++, z.lookahead--, z.strm.avail_out === 0)
                return At;
            } else
              z.match_available = 1, z.strstart++, z.lookahead--;
          }
          return z.match_available && (ae = i._tr_tally(z, 0, z.window[z.strstart - 1]), z.match_available = 0), z.insert = z.strstart < pt - 1 ? z.strstart : pt - 1, He === m ? (Ie(z, !0), z.strm.avail_out === 0 ? Lt : kt) : z.last_lit && (Ie(z, !1), z.strm.avail_out === 0) ? At : St;
        }
        function Te(z, He) {
          for (var nt, ae, $e, Et, Nt = z.window; ; ) {
            if (z.lookahead <= Ke) {
              if (I(z), z.lookahead <= Ke && He === A)
                return At;
              if (z.lookahead === 0)
                break;
            }
            if (z.match_length = 0, z.lookahead >= pt && z.strstart > 0 && ($e = z.strstart - 1, ae = Nt[$e], ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e])) {
              Et = z.strstart + Ke;
              do
                ;
              while (ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && ae === Nt[++$e] && $e < Et);
              z.match_length = Ke - (Et - $e), z.match_length > z.lookahead && (z.match_length = z.lookahead);
            }
            if (z.match_length >= pt ? (nt = i._tr_tally(z, 1, z.match_length - pt), z.lookahead -= z.match_length, z.strstart += z.match_length, z.match_length = 0) : (nt = i._tr_tally(z, 0, z.window[z.strstart]), z.lookahead--, z.strstart++), nt && (Ie(z, !1), z.strm.avail_out === 0))
              return At;
          }
          return z.insert = 0, He === m ? (Ie(z, !0), z.strm.avail_out === 0 ? Lt : kt) : z.last_lit && (Ie(z, !1), z.strm.avail_out === 0) ? At : St;
        }
        function ye(z, He) {
          for (var nt; ; ) {
            if (z.lookahead === 0 && (I(z), z.lookahead === 0)) {
              if (He === A)
                return At;
              break;
            }
            if (z.match_length = 0, nt = i._tr_tally(z, 0, z.window[z.strstart]), z.lookahead--, z.strstart++, nt && (Ie(z, !1), z.strm.avail_out === 0))
              return At;
          }
          return z.insert = 0, He === m ? (Ie(z, !0), z.strm.avail_out === 0 ? Lt : kt) : z.last_lit && (Ie(z, !1), z.strm.avail_out === 0) ? At : St;
        }
        function Me(z, He, nt, ae, $e) {
          this.good_length = z, this.max_lazy = He, this.nice_length = nt, this.max_chain = ae, this.func = $e;
        }
        var Ge;
        Ge = [
          /*      good lazy nice chain */
          new Me(0, 0, 0, 0, X),
          /* 0 store only */
          new Me(4, 4, 8, 4, ne),
          /* 1 max speed, no lazy matches */
          new Me(4, 5, 16, 8, ne),
          /* 2 */
          new Me(4, 6, 32, 32, ne),
          /* 3 */
          new Me(4, 4, 16, 16, ue),
          /* 4 lazy matches */
          new Me(8, 16, 32, 32, ue),
          /* 5 */
          new Me(8, 16, 128, 128, ue),
          /* 6 */
          new Me(8, 32, 128, 256, ue),
          /* 7 */
          new Me(32, 128, 258, 1024, ue),
          /* 8 */
          new Me(32, 258, 258, 4096, ue)
          /* 9 max compression */
        ];
        function Qe(z) {
          z.window_size = 2 * z.w_size, _t(z.head), z.max_lazy_match = Ge[z.level].max_lazy, z.good_match = Ge[z.level].good_length, z.nice_match = Ge[z.level].nice_length, z.max_chain_length = Ge[z.level].max_chain, z.strstart = 0, z.block_start = 0, z.lookahead = 0, z.insert = 0, z.match_length = z.prev_length = pt - 1, z.match_available = 0, z.ins_h = 0;
        }
        function re() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = me, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new ie.Buf16(ut * 2), this.dyn_dtree = new ie.Buf16((2 * Ce + 1) * 2), this.bl_tree = new ie.Buf16((2 * it + 1) * 2), _t(this.dyn_ltree), _t(this.dyn_dtree), _t(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new ie.Buf16(bt + 1), this.heap = new ie.Buf16(2 * we + 1), _t(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new ie.Buf16(2 * we + 1), _t(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function Se(z) {
          var He;
          return !z || !z.state ? De(z, P) : (z.total_in = z.total_out = 0, z.data_type = le, He = z.state, He.pending = 0, He.pending_out = 0, He.wrap < 0 && (He.wrap = -He.wrap), He.status = He.wrap ? wt : wi, z.adler = He.wrap === 2 ? 0 : 1, He.last_flush = A, i._tr_init(He), k);
        }
        function Pe(z) {
          var He = Se(z);
          return He === k && Qe(z.state), He;
        }
        function at(z, He) {
          return !z || !z.state || z.state.wrap !== 2 ? P : (z.state.gzhead = He, k);
        }
        function Be(z, He, nt, ae, $e, Et) {
          if (!z)
            return P;
          var Nt = 1;
          if (He === j && (He = 6), ae < 0 ? (Nt = 0, ae = -ae) : ae > 15 && (Nt = 2, ae -= 16), $e < 1 || $e > ke || nt !== me || ae < 8 || ae > 15 || He < 0 || He > 9 || Et < 0 || Et > ee)
            return De(z, P);
          ae === 8 && (ae = 9);
          var Yt = new re();
          return z.state = Yt, Yt.strm = z, Yt.wrap = Nt, Yt.gzhead = null, Yt.w_bits = ae, Yt.w_size = 1 << Yt.w_bits, Yt.w_mask = Yt.w_size - 1, Yt.hash_bits = $e + 7, Yt.hash_size = 1 << Yt.hash_bits, Yt.hash_mask = Yt.hash_size - 1, Yt.hash_shift = ~~((Yt.hash_bits + pt - 1) / pt), Yt.window = new ie.Buf8(Yt.w_size * 2), Yt.head = new ie.Buf16(Yt.hash_size), Yt.prev = new ie.Buf16(Yt.w_size), Yt.lit_bufsize = 1 << $e + 6, Yt.pending_buf_size = Yt.lit_bufsize * 4, Yt.pending_buf = new ie.Buf8(Yt.pending_buf_size), Yt.d_buf = 1 * Yt.lit_bufsize, Yt.l_buf = 3 * Yt.lit_bufsize, Yt.level = He, Yt.strategy = Et, Yt.method = nt, Pe(z);
        }
        function Ze(z, He) {
          return Be(z, He, me, ge, Ve, te);
        }
        function fe(z, He) {
          var nt, ae, $e, Et;
          if (!z || !z.state || He > w || He < 0)
            return z ? De(z, P) : P;
          if (ae = z.state, !z.output || !z.input && z.avail_in !== 0 || ae.status === Qt && He !== m)
            return De(z, z.avail_out === 0 ? U : P);
          if (ae.strm = z, nt = ae.last_flush, ae.last_flush = He, ae.status === wt)
            if (ae.wrap === 2)
              z.adler = 0, pe(ae, 31), pe(ae, 139), pe(ae, 8), ae.gzhead ? (pe(
                ae,
                (ae.gzhead.text ? 1 : 0) + (ae.gzhead.hcrc ? 2 : 0) + (ae.gzhead.extra ? 4 : 0) + (ae.gzhead.name ? 8 : 0) + (ae.gzhead.comment ? 16 : 0)
              ), pe(ae, ae.gzhead.time & 255), pe(ae, ae.gzhead.time >> 8 & 255), pe(ae, ae.gzhead.time >> 16 & 255), pe(ae, ae.gzhead.time >> 24 & 255), pe(ae, ae.level === 9 ? 2 : ae.strategy >= W || ae.level < 2 ? 4 : 0), pe(ae, ae.gzhead.os & 255), ae.gzhead.extra && ae.gzhead.extra.length && (pe(ae, ae.gzhead.extra.length & 255), pe(ae, ae.gzhead.extra.length >> 8 & 255)), ae.gzhead.hcrc && (z.adler = Z(z.adler, ae.pending_buf, ae.pending, 0)), ae.gzindex = 0, ae.status = Ht) : (pe(ae, 0), pe(ae, 0), pe(ae, 0), pe(ae, 0), pe(ae, 0), pe(ae, ae.level === 9 ? 2 : ae.strategy >= W || ae.level < 2 ? 4 : 0), pe(ae, Ye), ae.status = wi);
            else {
              var Nt = me + (ae.w_bits - 8 << 4) << 8, Yt = -1;
              ae.strategy >= W || ae.level < 2 ? Yt = 0 : ae.level < 6 ? Yt = 1 : ae.level === 6 ? Yt = 2 : Yt = 3, Nt |= Yt << 6, ae.strstart !== 0 && (Nt |= ct), Nt += 31 - Nt % 31, ae.status = wi, xt(ae, Nt), ae.strstart !== 0 && (xt(ae, z.adler >>> 16), xt(ae, z.adler & 65535)), z.adler = 1;
            }
          if (ae.status === Ht)
            if (ae.gzhead.extra) {
              for ($e = ae.pending; ae.gzindex < (ae.gzhead.extra.length & 65535) && !(ae.pending === ae.pending_buf_size && (ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), et(z), $e = ae.pending, ae.pending === ae.pending_buf_size)); )
                pe(ae, ae.gzhead.extra[ae.gzindex] & 255), ae.gzindex++;
              ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), ae.gzindex === ae.gzhead.extra.length && (ae.gzindex = 0, ae.status = $t);
            } else
              ae.status = $t;
          if (ae.status === $t)
            if (ae.gzhead.name) {
              $e = ae.pending;
              do {
                if (ae.pending === ae.pending_buf_size && (ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), et(z), $e = ae.pending, ae.pending === ae.pending_buf_size)) {
                  Et = 1;
                  break;
                }
                ae.gzindex < ae.gzhead.name.length ? Et = ae.gzhead.name.charCodeAt(ae.gzindex++) & 255 : Et = 0, pe(ae, Et);
              } while (Et !== 0);
              ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), Et === 0 && (ae.gzindex = 0, ae.status = rt);
            } else
              ae.status = rt;
          if (ae.status === rt)
            if (ae.gzhead.comment) {
              $e = ae.pending;
              do {
                if (ae.pending === ae.pending_buf_size && (ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), et(z), $e = ae.pending, ae.pending === ae.pending_buf_size)) {
                  Et = 1;
                  break;
                }
                ae.gzindex < ae.gzhead.comment.length ? Et = ae.gzhead.comment.charCodeAt(ae.gzindex++) & 255 : Et = 0, pe(ae, Et);
              } while (Et !== 0);
              ae.gzhead.hcrc && ae.pending > $e && (z.adler = Z(z.adler, ae.pending_buf, ae.pending - $e, $e)), Et === 0 && (ae.status = ri);
            } else
              ae.status = ri;
          if (ae.status === ri && (ae.gzhead.hcrc ? (ae.pending + 2 > ae.pending_buf_size && et(z), ae.pending + 2 <= ae.pending_buf_size && (pe(ae, z.adler & 255), pe(ae, z.adler >> 8 & 255), z.adler = 0, ae.status = wi)) : ae.status = wi), ae.pending !== 0) {
            if (et(z), z.avail_out === 0)
              return ae.last_flush = -1, k;
          } else if (z.avail_in === 0 && Re(He) <= Re(nt) && He !== m)
            return De(z, U);
          if (ae.status === Qt && z.avail_in !== 0)
            return De(z, U);
          if (z.avail_in !== 0 || ae.lookahead !== 0 || He !== A && ae.status !== Qt) {
            var Ft = ae.strategy === W ? ye(ae, He) : ae.strategy === J ? Te(ae, He) : Ge[ae.level].func(ae, He);
            if ((Ft === Lt || Ft === kt) && (ae.status = Qt), Ft === At || Ft === Lt)
              return z.avail_out === 0 && (ae.last_flush = -1), k;
            if (Ft === St && (He === M ? i._tr_align(ae) : He !== w && (i._tr_stored_block(ae, 0, 0, !1), He === x && (_t(ae.head), ae.lookahead === 0 && (ae.strstart = 0, ae.block_start = 0, ae.insert = 0))), et(z), z.avail_out === 0))
              return ae.last_flush = -1, k;
          }
          return He !== m ? k : ae.wrap <= 0 ? E : (ae.wrap === 2 ? (pe(ae, z.adler & 255), pe(ae, z.adler >> 8 & 255), pe(ae, z.adler >> 16 & 255), pe(ae, z.adler >> 24 & 255), pe(ae, z.total_in & 255), pe(ae, z.total_in >> 8 & 255), pe(ae, z.total_in >> 16 & 255), pe(ae, z.total_in >> 24 & 255)) : (xt(ae, z.adler >>> 16), xt(ae, z.adler & 65535)), et(z), ae.wrap > 0 && (ae.wrap = -ae.wrap), ae.pending !== 0 ? k : E);
        }
        function Je(z) {
          var He;
          return !z || !z.state ? P : (He = z.state.status, He !== wt && He !== Ht && He !== $t && He !== rt && He !== ri && He !== wi && He !== Qt ? De(z, P) : (z.state = null, He === wi ? De(z, S) : k));
        }
        function Xe(z, He) {
          var nt = He.length, ae, $e, Et, Nt, Yt, Ft, ai, Mt;
          if (!z || !z.state || (ae = z.state, Nt = ae.wrap, Nt === 2 || Nt === 1 && ae.status !== wt || ae.lookahead))
            return P;
          for (Nt === 1 && (z.adler = N(z.adler, He, nt, 0)), ae.wrap = 0, nt >= ae.w_size && (Nt === 0 && (_t(ae.head), ae.strstart = 0, ae.block_start = 0, ae.insert = 0), Mt = new ie.Buf8(ae.w_size), ie.arraySet(Mt, He, nt - ae.w_size, ae.w_size, 0), He = Mt, nt = ae.w_size), Yt = z.avail_in, Ft = z.next_in, ai = z.input, z.avail_in = nt, z.next_in = 0, z.input = He, I(ae); ae.lookahead >= pt; ) {
            $e = ae.strstart, Et = ae.lookahead - (pt - 1);
            do
              ae.ins_h = (ae.ins_h << ae.hash_shift ^ ae.window[$e + pt - 1]) & ae.hash_mask, ae.prev[$e & ae.w_mask] = ae.head[ae.ins_h], ae.head[ae.ins_h] = $e, $e++;
            while (--Et);
            ae.strstart = $e, ae.lookahead = pt - 1, I(ae);
          }
          return ae.strstart += ae.lookahead, ae.block_start = ae.strstart, ae.insert = ae.lookahead, ae.lookahead = 0, ae.match_length = ae.prev_length = pt - 1, ae.match_available = 0, z.next_in = Ft, z.input = ai, z.avail_in = Yt, ae.wrap = Nt, k;
        }
        q.deflateInit = Ze, q.deflateInit2 = Be, q.deflateReset = Pe, q.deflateResetKeep = Se, q.deflateSetHeader = at, q.deflate = fe, q.deflateEnd = Je, q.deflateSetDictionary = Xe, q.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 89, "./adler32": 91, "./crc32": 93, "./messages": 99, "./trees": 100 }], 95: [function(Q, de, q) {
        function ie() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
        }
        de.exports = ie;
      }, {}], 96: [function(Q, de, q) {
        arguments[4][41][0].apply(q, arguments);
      }, { dup: 41 }], 97: [function(Q, de, q) {
        arguments[4][42][0].apply(q, arguments);
      }, { "../utils/common": 89, "./adler32": 91, "./crc32": 93, "./inffast": 96, "./inftrees": 98, dup: 42 }], 98: [function(Q, de, q) {
        arguments[4][43][0].apply(q, arguments);
      }, { "../utils/common": 89, dup: 43 }], 99: [function(Q, de, q) {
        arguments[4][44][0].apply(q, arguments);
      }, { dup: 44 }], 100: [function(Q, de, q) {
        var ie = Q("../utils/common"), i = 4, N = 0, Z = 1, R = 2;
        function A(re) {
          for (var Se = re.length; --Se >= 0; )
            re[Se] = 0;
        }
        var M = 0, x = 1, m = 2, w = 3, k = 258, E = 29, P = 256, S = P + 1 + E, U = 30, j = 19, T = 2 * S + 1, W = 15, J = 16, ee = 7, te = 256, le = 16, me = 17, ke = 18, ge = (
          /* extra bits for each length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
        ), Ve = (
          /* extra bits for each distance code */
          [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
        ), Oe = (
          /* extra bits for each bit length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
        ), Ue = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], we = 512, Ce = new Array((S + 2) * 2);
        A(Ce);
        var it = new Array(U * 2);
        A(it);
        var ut = new Array(we);
        A(ut);
        var bt = new Array(k - w + 1);
        A(bt);
        var pt = new Array(E);
        A(pt);
        var Ke = new Array(U);
        A(Ke);
        function dt(re, Se, Pe, at, Be) {
          this.static_tree = re, this.extra_bits = Se, this.extra_base = Pe, this.elems = at, this.max_length = Be, this.has_stree = re && re.length;
        }
        var ct, wt, Ht;
        function $t(re, Se) {
          this.dyn_tree = re, this.max_code = 0, this.stat_desc = Se;
        }
        function rt(re) {
          return re < 256 ? ut[re] : ut[256 + (re >>> 7)];
        }
        function ri(re, Se) {
          re.pending_buf[re.pending++] = Se & 255, re.pending_buf[re.pending++] = Se >>> 8 & 255;
        }
        function wi(re, Se, Pe) {
          re.bi_valid > J - Pe ? (re.bi_buf |= Se << re.bi_valid & 65535, ri(re, re.bi_buf), re.bi_buf = Se >> J - re.bi_valid, re.bi_valid += Pe - J) : (re.bi_buf |= Se << re.bi_valid & 65535, re.bi_valid += Pe);
        }
        function Qt(re, Se, Pe) {
          wi(
            re,
            Pe[Se * 2],
            Pe[Se * 2 + 1]
            /*.Len*/
          );
        }
        function At(re, Se) {
          var Pe = 0;
          do
            Pe |= re & 1, re >>>= 1, Pe <<= 1;
          while (--Se > 0);
          return Pe >>> 1;
        }
        function St(re) {
          re.bi_valid === 16 ? (ri(re, re.bi_buf), re.bi_buf = 0, re.bi_valid = 0) : re.bi_valid >= 8 && (re.pending_buf[re.pending++] = re.bi_buf & 255, re.bi_buf >>= 8, re.bi_valid -= 8);
        }
        function Lt(re, Se) {
          var Pe = Se.dyn_tree, at = Se.max_code, Be = Se.stat_desc.static_tree, Ze = Se.stat_desc.has_stree, fe = Se.stat_desc.extra_bits, Je = Se.stat_desc.extra_base, Xe = Se.stat_desc.max_length, z, He, nt, ae, $e, Et, Nt = 0;
          for (ae = 0; ae <= W; ae++)
            re.bl_count[ae] = 0;
          for (Pe[re.heap[re.heap_max] * 2 + 1] = 0, z = re.heap_max + 1; z < T; z++)
            He = re.heap[z], ae = Pe[Pe[He * 2 + 1] * 2 + 1] + 1, ae > Xe && (ae = Xe, Nt++), Pe[He * 2 + 1] = ae, !(He > at) && (re.bl_count[ae]++, $e = 0, He >= Je && ($e = fe[He - Je]), Et = Pe[He * 2], re.opt_len += Et * (ae + $e), Ze && (re.static_len += Et * (Be[He * 2 + 1] + $e)));
          if (Nt !== 0) {
            do {
              for (ae = Xe - 1; re.bl_count[ae] === 0; )
                ae--;
              re.bl_count[ae]--, re.bl_count[ae + 1] += 2, re.bl_count[Xe]--, Nt -= 2;
            } while (Nt > 0);
            for (ae = Xe; ae !== 0; ae--)
              for (He = re.bl_count[ae]; He !== 0; )
                nt = re.heap[--z], !(nt > at) && (Pe[nt * 2 + 1] !== ae && (re.opt_len += (ae - Pe[nt * 2 + 1]) * Pe[nt * 2], Pe[nt * 2 + 1] = ae), He--);
          }
        }
        function kt(re, Se, Pe) {
          var at = new Array(W + 1), Be = 0, Ze, fe;
          for (Ze = 1; Ze <= W; Ze++)
            at[Ze] = Be = Be + Pe[Ze - 1] << 1;
          for (fe = 0; fe <= Se; fe++) {
            var Je = re[fe * 2 + 1];
            Je !== 0 && (re[fe * 2] = At(at[Je]++, Je));
          }
        }
        function Ye() {
          var re, Se, Pe, at, Be, Ze = new Array(W + 1);
          for (Pe = 0, at = 0; at < E - 1; at++)
            for (pt[at] = Pe, re = 0; re < 1 << ge[at]; re++)
              bt[Pe++] = at;
          for (bt[Pe - 1] = at, Be = 0, at = 0; at < 16; at++)
            for (Ke[at] = Be, re = 0; re < 1 << Ve[at]; re++)
              ut[Be++] = at;
          for (Be >>= 7; at < U; at++)
            for (Ke[at] = Be << 7, re = 0; re < 1 << Ve[at] - 7; re++)
              ut[256 + Be++] = at;
          for (Se = 0; Se <= W; Se++)
            Ze[Se] = 0;
          for (re = 0; re <= 143; )
            Ce[re * 2 + 1] = 8, re++, Ze[8]++;
          for (; re <= 255; )
            Ce[re * 2 + 1] = 9, re++, Ze[9]++;
          for (; re <= 279; )
            Ce[re * 2 + 1] = 7, re++, Ze[7]++;
          for (; re <= 287; )
            Ce[re * 2 + 1] = 8, re++, Ze[8]++;
          for (kt(Ce, S + 1, Ze), re = 0; re < U; re++)
            it[re * 2 + 1] = 5, it[re * 2] = At(re, 5);
          ct = new dt(Ce, ge, P + 1, S, W), wt = new dt(it, Ve, 0, U, W), Ht = new dt(new Array(0), Oe, 0, j, ee);
        }
        function De(re) {
          var Se;
          for (Se = 0; Se < S; Se++)
            re.dyn_ltree[Se * 2] = 0;
          for (Se = 0; Se < U; Se++)
            re.dyn_dtree[Se * 2] = 0;
          for (Se = 0; Se < j; Se++)
            re.bl_tree[Se * 2] = 0;
          re.dyn_ltree[te * 2] = 1, re.opt_len = re.static_len = 0, re.last_lit = re.matches = 0;
        }
        function Re(re) {
          re.bi_valid > 8 ? ri(re, re.bi_buf) : re.bi_valid > 0 && (re.pending_buf[re.pending++] = re.bi_buf), re.bi_buf = 0, re.bi_valid = 0;
        }
        function _t(re, Se, Pe, at) {
          Re(re), ri(re, Pe), ri(re, ~Pe), ie.arraySet(re.pending_buf, re.window, Se, Pe, re.pending), re.pending += Pe;
        }
        function et(re, Se, Pe, at) {
          var Be = Se * 2, Ze = Pe * 2;
          return re[Be] < re[Ze] || re[Be] === re[Ze] && at[Se] <= at[Pe];
        }
        function Ie(re, Se, Pe) {
          for (var at = re.heap[Pe], Be = Pe << 1; Be <= re.heap_len && (Be < re.heap_len && et(Se, re.heap[Be + 1], re.heap[Be], re.depth) && Be++, !et(Se, at, re.heap[Be], re.depth)); )
            re.heap[Pe] = re.heap[Be], Pe = Be, Be <<= 1;
          re.heap[Pe] = at;
        }
        function pe(re, Se, Pe) {
          var at, Be, Ze = 0, fe, Je;
          if (re.last_lit !== 0)
            do
              at = re.pending_buf[re.d_buf + Ze * 2] << 8 | re.pending_buf[re.d_buf + Ze * 2 + 1], Be = re.pending_buf[re.l_buf + Ze], Ze++, at === 0 ? Qt(re, Be, Se) : (fe = bt[Be], Qt(re, fe + P + 1, Se), Je = ge[fe], Je !== 0 && (Be -= pt[fe], wi(re, Be, Je)), at--, fe = rt(at), Qt(re, fe, Pe), Je = Ve[fe], Je !== 0 && (at -= Ke[fe], wi(re, at, Je)));
            while (Ze < re.last_lit);
          Qt(re, te, Se);
        }
        function xt(re, Se) {
          var Pe = Se.dyn_tree, at = Se.stat_desc.static_tree, Be = Se.stat_desc.has_stree, Ze = Se.stat_desc.elems, fe, Je, Xe = -1, z;
          for (re.heap_len = 0, re.heap_max = T, fe = 0; fe < Ze; fe++)
            Pe[fe * 2] !== 0 ? (re.heap[++re.heap_len] = Xe = fe, re.depth[fe] = 0) : Pe[fe * 2 + 1] = 0;
          for (; re.heap_len < 2; )
            z = re.heap[++re.heap_len] = Xe < 2 ? ++Xe : 0, Pe[z * 2] = 1, re.depth[z] = 0, re.opt_len--, Be && (re.static_len -= at[z * 2 + 1]);
          for (Se.max_code = Xe, fe = re.heap_len >> 1; fe >= 1; fe--)
            Ie(re, Pe, fe);
          z = Ze;
          do
            fe = re.heap[
              1
              /*SMALLEST*/
            ], re.heap[
              1
              /*SMALLEST*/
            ] = re.heap[re.heap_len--], Ie(
              re,
              Pe,
              1
              /*SMALLEST*/
            ), Je = re.heap[
              1
              /*SMALLEST*/
            ], re.heap[--re.heap_max] = fe, re.heap[--re.heap_max] = Je, Pe[z * 2] = Pe[fe * 2] + Pe[Je * 2], re.depth[z] = (re.depth[fe] >= re.depth[Je] ? re.depth[fe] : re.depth[Je]) + 1, Pe[fe * 2 + 1] = Pe[Je * 2 + 1] = z, re.heap[
              1
              /*SMALLEST*/
            ] = z++, Ie(
              re,
              Pe,
              1
              /*SMALLEST*/
            );
          while (re.heap_len >= 2);
          re.heap[--re.heap_max] = re.heap[
            1
            /*SMALLEST*/
          ], Lt(re, Se), kt(Pe, Xe, re.bl_count);
        }
        function l(re, Se, Pe) {
          var at, Be = -1, Ze, fe = Se[0 * 2 + 1], Je = 0, Xe = 7, z = 4;
          for (fe === 0 && (Xe = 138, z = 3), Se[(Pe + 1) * 2 + 1] = 65535, at = 0; at <= Pe; at++)
            Ze = fe, fe = Se[(at + 1) * 2 + 1], !(++Je < Xe && Ze === fe) && (Je < z ? re.bl_tree[Ze * 2] += Je : Ze !== 0 ? (Ze !== Be && re.bl_tree[Ze * 2]++, re.bl_tree[le * 2]++) : Je <= 10 ? re.bl_tree[me * 2]++ : re.bl_tree[ke * 2]++, Je = 0, Be = Ze, fe === 0 ? (Xe = 138, z = 3) : Ze === fe ? (Xe = 6, z = 3) : (Xe = 7, z = 4));
        }
        function _(re, Se, Pe) {
          var at, Be = -1, Ze, fe = Se[0 * 2 + 1], Je = 0, Xe = 7, z = 4;
          for (fe === 0 && (Xe = 138, z = 3), at = 0; at <= Pe; at++)
            if (Ze = fe, fe = Se[(at + 1) * 2 + 1], !(++Je < Xe && Ze === fe)) {
              if (Je < z)
                do
                  Qt(re, Ze, re.bl_tree);
                while (--Je !== 0);
              else Ze !== 0 ? (Ze !== Be && (Qt(re, Ze, re.bl_tree), Je--), Qt(re, le, re.bl_tree), wi(re, Je - 3, 2)) : Je <= 10 ? (Qt(re, me, re.bl_tree), wi(re, Je - 3, 3)) : (Qt(re, ke, re.bl_tree), wi(re, Je - 11, 7));
              Je = 0, Be = Ze, fe === 0 ? (Xe = 138, z = 3) : Ze === fe ? (Xe = 6, z = 3) : (Xe = 7, z = 4);
            }
        }
        function I(re) {
          var Se;
          for (l(re, re.dyn_ltree, re.l_desc.max_code), l(re, re.dyn_dtree, re.d_desc.max_code), xt(re, re.bl_desc), Se = j - 1; Se >= 3 && re.bl_tree[Ue[Se] * 2 + 1] === 0; Se--)
            ;
          return re.opt_len += 3 * (Se + 1) + 5 + 5 + 4, Se;
        }
        function X(re, Se, Pe, at) {
          var Be;
          for (wi(re, Se - 257, 5), wi(re, Pe - 1, 5), wi(re, at - 4, 4), Be = 0; Be < at; Be++)
            wi(re, re.bl_tree[Ue[Be] * 2 + 1], 3);
          _(re, re.dyn_ltree, Se - 1), _(re, re.dyn_dtree, Pe - 1);
        }
        function ne(re) {
          var Se = 4093624447, Pe;
          for (Pe = 0; Pe <= 31; Pe++, Se >>>= 1)
            if (Se & 1 && re.dyn_ltree[Pe * 2] !== 0)
              return N;
          if (re.dyn_ltree[9 * 2] !== 0 || re.dyn_ltree[10 * 2] !== 0 || re.dyn_ltree[13 * 2] !== 0)
            return Z;
          for (Pe = 32; Pe < P; Pe++)
            if (re.dyn_ltree[Pe * 2] !== 0)
              return Z;
          return N;
        }
        var ue = !1;
        function Te(re) {
          ue || (Ye(), ue = !0), re.l_desc = new $t(re.dyn_ltree, ct), re.d_desc = new $t(re.dyn_dtree, wt), re.bl_desc = new $t(re.bl_tree, Ht), re.bi_buf = 0, re.bi_valid = 0, De(re);
        }
        function ye(re, Se, Pe, at) {
          wi(re, (M << 1) + (at ? 1 : 0), 3), _t(re, Se, Pe);
        }
        function Me(re) {
          wi(re, x << 1, 3), Qt(re, te, Ce), St(re);
        }
        function Ge(re, Se, Pe, at) {
          var Be, Ze, fe = 0;
          re.level > 0 ? (re.strm.data_type === R && (re.strm.data_type = ne(re)), xt(re, re.l_desc), xt(re, re.d_desc), fe = I(re), Be = re.opt_len + 3 + 7 >>> 3, Ze = re.static_len + 3 + 7 >>> 3, Ze <= Be && (Be = Ze)) : Be = Ze = Pe + 5, Pe + 4 <= Be && Se !== -1 ? ye(re, Se, Pe, at) : re.strategy === i || Ze === Be ? (wi(re, (x << 1) + (at ? 1 : 0), 3), pe(re, Ce, it)) : (wi(re, (m << 1) + (at ? 1 : 0), 3), X(re, re.l_desc.max_code + 1, re.d_desc.max_code + 1, fe + 1), pe(re, re.dyn_ltree, re.dyn_dtree)), De(re), at && Re(re);
        }
        function Qe(re, Se, Pe) {
          return re.pending_buf[re.d_buf + re.last_lit * 2] = Se >>> 8 & 255, re.pending_buf[re.d_buf + re.last_lit * 2 + 1] = Se & 255, re.pending_buf[re.l_buf + re.last_lit] = Pe & 255, re.last_lit++, Se === 0 ? re.dyn_ltree[Pe * 2]++ : (re.matches++, Se--, re.dyn_ltree[(bt[Pe] + P + 1) * 2]++, re.dyn_dtree[rt(Se) * 2]++), re.last_lit === re.lit_bufsize - 1;
        }
        q._tr_init = Te, q._tr_stored_block = ye, q._tr_flush_block = Ge, q._tr_tally = Qe, q._tr_align = Me;
      }, { "../utils/common": 89 }], 101: [function(Q, de, q) {
        arguments[4][46][0].apply(q, arguments);
      }, { dup: 46 }], 102: [function(Q, de, q) {
        de.exports = function(R) {
          if (!R)
            throw new Error("no data provided");
          R = R.toString().trim();
          var A = {
            pages: [],
            chars: [],
            kernings: []
          }, M = R.split(/\r\n?|\n/g);
          if (M.length === 0)
            throw new Error("no data in BMFont file");
          for (var x = 0; x < M.length; x++) {
            var m = ie(M[x], x);
            if (m)
              if (m.key === "page") {
                if (typeof m.data.id != "number")
                  throw new Error("malformed file at line " + x + " -- needs page id=N");
                if (typeof m.data.file != "string")
                  throw new Error("malformed file at line " + x + ' -- needs page file="path"');
                A.pages[m.data.id] = m.data.file;
              } else m.key === "chars" || m.key === "kernings" || (m.key === "char" ? A.chars.push(m.data) : m.key === "kerning" ? A.kernings.push(m.data) : A[m.key] = m.data);
          }
          return A;
        };
        function ie(Z, R) {
          if (Z = Z.replace(/\t+/g, " ").trim(), !Z)
            return null;
          var A = Z.indexOf(" ");
          if (A === -1)
            throw new Error("no named row at line " + R);
          var M = Z.substring(0, A);
          Z = Z.substring(A + 1), Z = Z.replace(/letter=[\'\"]\S+[\'\"]/gi, ""), Z = Z.split("="), Z = Z.map(function(E) {
            return E.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
          });
          for (var x = [], m = 0; m < Z.length; m++) {
            var w = Z[m];
            m === 0 ? x.push({
              key: w[0],
              data: ""
            }) : m === Z.length - 1 ? x[x.length - 1].data = i(w[0]) : (x[x.length - 1].data = i(w[0]), x.push({
              key: w[1],
              data: ""
            }));
          }
          var k = {
            key: M,
            data: {}
          };
          return x.forEach(function(E) {
            k.data[E.key] = E.data;
          }), k;
        }
        function i(Z) {
          return !Z || Z.length === 0 ? "" : Z.indexOf('"') === 0 || Z.indexOf("'") === 0 ? Z.substring(1, Z.length - 1) : Z.indexOf(",") !== -1 ? N(Z) : parseInt(Z, 10);
        }
        function N(Z) {
          return Z.split(",").map(function(R) {
            return parseInt(R, 10);
          });
        }
      }, {}], 103: [function(Q, de, q) {
        var ie = [66, 77, 70];
        de.exports = function(k) {
          if (k.length < 6)
            throw new Error("invalid buffer length for BMFont");
          var E = ie.every(function(T, W) {
            return k.readUInt8(W) === T;
          });
          if (!E)
            throw new Error("BMFont missing BMF byte header");
          var P = 3, S = k.readUInt8(P++);
          if (S > 3)
            throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
          for (var U = { kernings: [], chars: [] }, j = 0; j < 5; j++)
            P += i(U, k, P);
          return U;
        };
        function i(w, k, E) {
          if (E > k.length - 1)
            return 0;
          var P = k.readUInt8(E++), S = k.readInt32LE(E);
          switch (E += 4, P) {
            case 1:
              w.info = N(k, E);
              break;
            case 2:
              w.common = Z(k, E);
              break;
            case 3:
              w.pages = R(k, E, S);
              break;
            case 4:
              w.chars = A(k, E, S);
              break;
            case 5:
              w.kernings = M(k, E, S);
              break;
          }
          return 5 + S;
        }
        function N(w, k) {
          var E = {};
          E.size = w.readInt16LE(k);
          var P = w.readUInt8(k + 2);
          return E.smooth = P >> 7 & 1, E.unicode = P >> 6 & 1, E.italic = P >> 5 & 1, E.bold = P >> 4 & 1, P >> 3 & 1 && (E.fixedHeight = 1), E.charset = w.readUInt8(k + 3) || "", E.stretchH = w.readUInt16LE(k + 4), E.aa = w.readUInt8(k + 6), E.padding = [
            w.readInt8(k + 7),
            w.readInt8(k + 8),
            w.readInt8(k + 9),
            w.readInt8(k + 10)
          ], E.spacing = [
            w.readInt8(k + 11),
            w.readInt8(k + 12)
          ], E.outline = w.readUInt8(k + 13), E.face = m(w, k + 14), E;
        }
        function Z(w, k) {
          var E = {};
          return E.lineHeight = w.readUInt16LE(k), E.base = w.readUInt16LE(k + 2), E.scaleW = w.readUInt16LE(k + 4), E.scaleH = w.readUInt16LE(k + 6), E.pages = w.readUInt16LE(k + 8), w.readUInt8(k + 10), E.packed = 0, E.alphaChnl = w.readUInt8(k + 11), E.redChnl = w.readUInt8(k + 12), E.greenChnl = w.readUInt8(k + 13), E.blueChnl = w.readUInt8(k + 14), E;
        }
        function R(w, k, E) {
          for (var P = [], S = x(w, k), U = S.length + 1, j = E / U, T = 0; T < j; T++)
            P[T] = w.slice(k, k + S.length).toString("utf8"), k += U;
          return P;
        }
        function A(w, k, E) {
          for (var P = [], S = E / 20, U = 0; U < S; U++) {
            var j = {}, T = U * 20;
            j.id = w.readUInt32LE(k + 0 + T), j.x = w.readUInt16LE(k + 4 + T), j.y = w.readUInt16LE(k + 6 + T), j.width = w.readUInt16LE(k + 8 + T), j.height = w.readUInt16LE(k + 10 + T), j.xoffset = w.readInt16LE(k + 12 + T), j.yoffset = w.readInt16LE(k + 14 + T), j.xadvance = w.readInt16LE(k + 16 + T), j.page = w.readUInt8(k + 18 + T), j.chnl = w.readUInt8(k + 19 + T), P[U] = j;
          }
          return P;
        }
        function M(w, k, E) {
          for (var P = [], S = E / 10, U = 0; U < S; U++) {
            var j = {}, T = U * 10;
            j.first = w.readUInt32LE(k + 0 + T), j.second = w.readUInt32LE(k + 4 + T), j.amount = w.readInt16LE(k + 8 + T), P[U] = j;
          }
          return P;
        }
        function x(w, k) {
          for (var E = k; E < w.length && w[E] !== 0; E++)
            ;
          return w.slice(k, E);
        }
        function m(w, k) {
          return x(w, k).toString("utf8");
        }
      }, {}], 104: [function(Q, de, q) {
        var ie = Q("./parse-attribs"), i = Q("xml-parse-from-string"), N = {
          scaleh: "scaleH",
          scalew: "scaleW",
          stretchh: "stretchH",
          lineheight: "lineHeight",
          alphachnl: "alphaChnl",
          redchnl: "redChnl",
          greenchnl: "greenChnl",
          bluechnl: "blueChnl"
        };
        de.exports = function(x) {
          x = x.toString();
          var m = i(x), w = {
            pages: [],
            chars: [],
            kernings: []
          };
          ["info", "common"].forEach(function(T) {
            var W = m.getElementsByTagName(T)[0];
            W && (w[T] = ie(Z(W)));
          });
          var k = m.getElementsByTagName("pages")[0];
          if (!k)
            throw new Error("malformed file -- no <pages> element");
          for (var E = k.getElementsByTagName("page"), P = 0; P < E.length; P++) {
            var S = E[P], U = parseInt(S.getAttribute("id"), 10), j = S.getAttribute("file");
            if (isNaN(U))
              throw new Error('malformed file -- page "id" attribute is NaN');
            if (!j)
              throw new Error('malformed file -- needs page "file" attribute');
            w.pages[parseInt(U, 10)] = j;
          }
          return ["chars", "kernings"].forEach(function(T) {
            var W = m.getElementsByTagName(T)[0];
            if (W)
              for (var J = T.substring(0, T.length - 1), ee = W.getElementsByTagName(J), te = 0; te < ee.length; te++) {
                var le = ee[te];
                w[T].push(ie(Z(le)));
              }
          }), w;
        };
        function Z(M) {
          var x = R(M);
          return x.reduce(function(m, w) {
            var k = A(w.nodeName);
            return m[k] = w.nodeValue, m;
          }, {});
        }
        function R(M) {
          for (var x = [], m = 0; m < M.attributes.length; m++)
            x.push(M.attributes[m]);
          return x;
        }
        function A(M) {
          return N[M.toLowerCase()] || M;
        }
      }, { "./parse-attribs": 105, "xml-parse-from-string": 188 }], 105: [function(Q, de, q) {
        var ie = "chasrset";
        de.exports = function(Z) {
          ie in Z && (Z.charset = Z[ie], delete Z[ie]);
          for (var R in Z)
            R === "face" || R === "charset" || (R === "padding" || R === "spacing" ? Z[R] = i(Z[R]) : Z[R] = parseInt(Z[R], 10));
          return Z;
        };
        function i(N) {
          return N.split(",").map(function(Z) {
            return parseInt(Z, 10);
          });
        }
      }, {}], 106: [function(Q, de, q) {
        var ie = Q("trim"), i = Q("for-each"), N = function(Z) {
          return Object.prototype.toString.call(Z) === "[object Array]";
        };
        de.exports = function(Z) {
          if (!Z)
            return {};
          var R = {};
          return i(
            ie(Z).split(`
`),
            function(A) {
              var M = A.indexOf(":"), x = ie(A.slice(0, M)).toLowerCase(), m = ie(A.slice(M + 1));
              typeof R[x] > "u" ? R[x] = m : N(R[x]) ? R[x].push(m) : R[x] = [R[x], m];
            }
          ), R;
        };
      }, { "for-each": 63, trim: 179 }], 107: [function(Q, de, q) {
        (function(ie) {
          function i(A, M) {
            for (var x = 0, m = A.length - 1; m >= 0; m--) {
              var w = A[m];
              w === "." ? A.splice(m, 1) : w === ".." ? (A.splice(m, 1), x++) : x && (A.splice(m, 1), x--);
            }
            if (M)
              for (; x--; x)
                A.unshift("..");
            return A;
          }
          q.resolve = function() {
            for (var A = "", M = !1, x = arguments.length - 1; x >= -1 && !M; x--) {
              var m = x >= 0 ? arguments[x] : ie.cwd();
              if (typeof m != "string")
                throw new TypeError("Arguments to path.resolve must be strings");
              if (!m)
                continue;
              A = m + "/" + A, M = m.charAt(0) === "/";
            }
            return A = i(Z(A.split("/"), function(w) {
              return !!w;
            }), !M).join("/"), (M ? "/" : "") + A || ".";
          }, q.normalize = function(A) {
            var M = q.isAbsolute(A), x = R(A, -1) === "/";
            return A = i(Z(A.split("/"), function(m) {
              return !!m;
            }), !M).join("/"), !A && !M && (A = "."), A && x && (A += "/"), (M ? "/" : "") + A;
          }, q.isAbsolute = function(A) {
            return A.charAt(0) === "/";
          }, q.join = function() {
            var A = Array.prototype.slice.call(arguments, 0);
            return q.normalize(Z(A, function(M, x) {
              if (typeof M != "string")
                throw new TypeError("Arguments to path.join must be strings");
              return M;
            }).join("/"));
          }, q.relative = function(A, M) {
            A = q.resolve(A).substr(1), M = q.resolve(M).substr(1);
            function x(U) {
              for (var j = 0; j < U.length && U[j] === ""; j++)
                ;
              for (var T = U.length - 1; T >= 0 && U[T] === ""; T--)
                ;
              return j > T ? [] : U.slice(j, T - j + 1);
            }
            for (var m = x(A.split("/")), w = x(M.split("/")), k = Math.min(m.length, w.length), E = k, P = 0; P < k; P++)
              if (m[P] !== w[P]) {
                E = P;
                break;
              }
            for (var S = [], P = E; P < m.length; P++)
              S.push("..");
            return S = S.concat(w.slice(E)), S.join("/");
          }, q.sep = "/", q.delimiter = ":", q.dirname = function(A) {
            if (typeof A != "string" && (A = A + ""), A.length === 0) return ".";
            for (var M = A.charCodeAt(0), x = M === 47, m = -1, w = !0, k = A.length - 1; k >= 1; --k)
              if (M = A.charCodeAt(k), M === 47) {
                if (!w) {
                  m = k;
                  break;
                }
              } else
                w = !1;
            return m === -1 ? x ? "/" : "." : x && m === 1 ? "/" : A.slice(0, m);
          };
          function N(A) {
            typeof A != "string" && (A = A + "");
            var M = 0, x = -1, m = !0, w;
            for (w = A.length - 1; w >= 0; --w)
              if (A.charCodeAt(w) === 47) {
                if (!m) {
                  M = w + 1;
                  break;
                }
              } else x === -1 && (m = !1, x = w + 1);
            return x === -1 ? "" : A.slice(M, x);
          }
          q.basename = function(A, M) {
            var x = N(A);
            return M && x.substr(-1 * M.length) === M && (x = x.substr(0, x.length - M.length)), x;
          }, q.extname = function(A) {
            typeof A != "string" && (A = A + "");
            for (var M = -1, x = 0, m = -1, w = !0, k = 0, E = A.length - 1; E >= 0; --E) {
              var P = A.charCodeAt(E);
              if (P === 47) {
                if (!w) {
                  x = E + 1;
                  break;
                }
                continue;
              }
              m === -1 && (w = !1, m = E + 1), P === 46 ? M === -1 ? M = E : k !== 1 && (k = 1) : M !== -1 && (k = -1);
            }
            return M === -1 || m === -1 || // We saw a non-dot character immediately before the dot
            k === 0 || // The (right-most) trimmed path component is exactly '..'
            k === 1 && M === m - 1 && M === x + 1 ? "" : A.slice(M, m);
          };
          function Z(A, M) {
            if (A.filter) return A.filter(M);
            for (var x = [], m = 0; m < A.length; m++)
              M(A[m], m, A) && x.push(A[m]);
            return x;
          }
          var R = "ab".substr(-1) === "b" ? function(A, M, x) {
            return A.substr(M, x);
          } : function(A, M, x) {
            return M < 0 && (M = A.length + M), A.substr(M, x);
          };
        }).call(this, Q("_process"));
      }, { _process: 133 }], 108: [function(Q, de, q) {
        (function(ie) {
          var i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(w) {
            return typeof w;
          } : function(w) {
            return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w;
          }, N = Q("http"), Z = Q("https"), R = Q("url"), A = Q("querystring"), M = Q("zlib"), x = Q("util"), m = function(k, E) {
            if (typeof k != "string" && !k.hasOwnProperty("url"))
              throw new Error("Missing url option from options for request method.");
            var P = (typeof k > "u" ? "undefined" : i(k)) === "object" ? R.parse(k.url) : R.parse(k), S = { hostname: P.hostname, port: P.port || (P.protocol.toLowerCase() === "http:" ? 80 : 443), path: P.path, method: "GET", headers: {}, auth: P.auth || null, parse: "none", stream: !1 };
            if ((typeof k > "u" ? "undefined" : i(k)) === "object" && (S = Object.assign(S, k)), S.port = Number(S.port), S.hasOwnProperty("timeout") && delete S.timeout, S.compressed === !0 && (S.headers["accept-encoding"] = "gzip, deflate"), k.hasOwnProperty("form")) {
              if (i(k.form) !== "object")
                throw new Error("phin 'form' option must be of type Object if present.");
              var U = A.stringify(k.form);
              S.headers["Content-Type"] = "application/x-www-form-urlencoded", S.headers["Content-Length"] = ie.byteLength(U), k.data = U;
            }
            var j = void 0, T = function(te) {
              var le = te;
              S.compressed === !0 && (te.headers["content-encoding"] === "gzip" ? le = te.pipe(M.createGunzip()) : te.headers["content-encoding"] === "deflate" && (le = te.pipe(M.createInflate()))), S.stream === !0 ? (te.stream = le, E(null, te)) : (te.body = new ie([]), le.on("data", function(me) {
                te.body = ie.concat([te.body, me]);
              }), le.on("end", function() {
                if (E) {
                  if (S.parse === "json")
                    try {
                      te.body = JSON.parse(te.body.toString());
                    } catch {
                      E("Invalid JSON received.", te);
                      return;
                    }
                  E(null, te);
                }
              }));
            };
            switch (P.protocol.toLowerCase()) {
              case "http:":
                j = N.request(S, T);
                break;
              case "https:":
                j = Z.request(S, T);
                break;
              default:
                E && E(new Error("Invalid / unknown URL protocol. Expected HTTP or HTTPS."), null);
                return;
            }
            if (typeof k.timeout == "number" && j.setTimeout(k.timeout, function() {
              j.abort(), E(new Error("Timeout has been reached."), null), E = null;
            }), j.on("error", function(ee) {
              E && E(ee, null);
            }), k.hasOwnProperty("data")) {
              var W = k.data;
              if (!(k.data instanceof ie) && i(k.data) === "object") {
                var J = S.headers["content-type"] || S.headers["Content-Type"];
                if (J === "application/x-www-form-urlencoded")
                  W = A.stringify(k.data);
                else
                  try {
                    W = JSON.stringify(k.data);
                  } catch {
                    E(new Error("Couldn't stringify object. (Likely due to a circular reference.)"), null);
                  }
              }
              j.write(W);
            }
            j.end();
          };
          m.promisified = function(w, k) {
            return new Promise(function(E, P) {
              m(w, function(S, U) {
                S ? P(S) : E(U);
              });
            });
          }, x.promisify && (m[x.promisify.custom] = m.promisified), de.exports = m;
        }).call(this, Q("buffer").Buffer);
      }, { buffer: 48, http: 156, https: 72, querystring: 137, url: 180, util: 186, zlib: 35 }], 109: [function(Q, de, q) {
        de.exports = ie;
        function ie(w, k, E, P, S, U) {
          U || (U = {});
          for (var j = U.threshold === void 0 ? 0.1 : U.threshold, T = 35215 * j * j, W = 0, J = 0; J < S; J++)
            for (var ee = 0; ee < P; ee++) {
              var te = (J * P + ee) * 4, le = N(w, k, te, te);
              if (le > T)
                !U.includeAA && (i(w, ee, J, P, S, k) || i(k, ee, J, P, S, w)) ? E && x(E, te, 255, 255, 0) : (E && x(E, te, 255, 0, 0), W++);
              else if (E) {
                var me = M(m(w, te), 0.1);
                x(E, te, me, me, me);
              }
            }
          return W;
        }
        function i(w, k, E, P, S, U) {
          for (var j = Math.max(k - 1, 0), T = Math.max(E - 1, 0), W = Math.min(k + 1, P - 1), J = Math.min(E + 1, S - 1), ee = (E * P + k) * 4, te = 0, le = 0, me = 0, ke = 0, ge = 0, Ve, Oe, Ue, we, Ce = j; Ce <= W; Ce++)
            for (var it = T; it <= J; it++)
              if (!(Ce === k && it === E)) {
                var ut = N(w, w, ee, (it * P + Ce) * 4, !0);
                if (ut === 0 ? te++ : ut < 0 ? me++ : ut > 0 && le++, te > 2) return !1;
                U && (ut < ke && (ke = ut, Ve = Ce, Oe = it), ut > ge && (ge = ut, Ue = Ce, we = it));
              }
          return U ? me === 0 || le === 0 ? !1 : !i(w, Ve, Oe, P, S) && !i(U, Ve, Oe, P, S) || !i(w, Ue, we, P, S) && !i(U, Ue, we, P, S) : !0;
        }
        function N(w, k, E, P, S) {
          var U = w[E + 3] / 255, j = k[P + 3] / 255, T = M(w[E + 0], U), W = M(w[E + 1], U), J = M(w[E + 2], U), ee = M(k[P + 0], j), te = M(k[P + 1], j), le = M(k[P + 2], j), me = Z(T, W, J) - Z(ee, te, le);
          if (S) return me;
          var ke = R(T, W, J) - R(ee, te, le), ge = A(T, W, J) - A(ee, te, le);
          return 0.5053 * me * me + 0.299 * ke * ke + 0.1957 * ge * ge;
        }
        function Z(w, k, E) {
          return w * 0.29889531 + k * 0.58662247 + E * 0.11448223;
        }
        function R(w, k, E) {
          return w * 0.59597799 - k * 0.2741761 - E * 0.32180189;
        }
        function A(w, k, E) {
          return w * 0.21147017 - k * 0.52261711 + E * 0.31114694;
        }
        function M(w, k) {
          return 255 + (w - 255) * k;
        }
        function x(w, k, E, P, S) {
          w[k + 0] = E, w[k + 1] = P, w[k + 2] = S, w[k + 3] = 255;
        }
        function m(w, k) {
          var E = w[k + 3] / 255, P = M(w[k + 0], E), S = M(w[k + 1], E), U = M(w[k + 2], E);
          return Z(P, S, U);
        }
      }, {}], 110: [function(Q, de, q) {
        (function(ie) {
          var i = Q("./interlace"), N = {
            1: {
              // L
              0: 0,
              1: 0,
              2: 0,
              3: 255
            },
            2: {
              // LA
              0: 0,
              1: 0,
              2: 0,
              3: 1
            },
            3: {
              // RGB
              0: 0,
              1: 1,
              2: 2,
              3: 255
            },
            4: {
              // RGBA
              0: 0,
              1: 1,
              2: 2,
              3: 3
            }
          };
          function Z(M, x) {
            var m = [], w = 0;
            function k() {
              if (w === M.length)
                throw new Error("Ran out of data");
              var E = M[w];
              w++;
              var P, S, U, j, T, W, J, ee;
              switch (x) {
                default:
                  throw new Error("unrecognised depth");
                case 16:
                  J = M[w], w++, m.push((E << 8) + J);
                  break;
                case 4:
                  J = E & 15, ee = E >> 4, m.push(ee, J);
                  break;
                case 2:
                  T = E & 3, W = E >> 2 & 3, J = E >> 4 & 3, ee = E >> 6 & 3, m.push(ee, J, W, T);
                  break;
                case 1:
                  P = E & 1, S = E >> 1 & 1, U = E >> 2 & 1, j = E >> 3 & 1, T = E >> 4 & 1, W = E >> 5 & 1, J = E >> 6 & 1, ee = E >> 7 & 1, m.push(ee, J, W, T, j, U, S, P);
                  break;
              }
            }
            return {
              get: function(E) {
                for (; m.length < E; )
                  k();
                var P = m.slice(0, E);
                return m = m.slice(E), P;
              },
              resetAfterLine: function() {
                m.length = 0;
              },
              end: function() {
                if (w !== M.length)
                  throw new Error("extra data found");
              }
            };
          }
          function R(M, x, m, w, k, E) {
            for (var P = M.width, S = M.height, U = M.index, j = 0; j < S; j++)
              for (var T = 0; T < P; T++) {
                for (var W = m(T, j, U), J = 0; J < 4; J++) {
                  var ee = N[w][J];
                  if (ee === 255)
                    x[W + J] = 255;
                  else {
                    var te = ee + E;
                    if (te === k.length)
                      throw new Error("Ran out of data");
                    x[W + J] = k[te];
                  }
                }
                E += w;
              }
            return E;
          }
          function A(M, x, m, w, k, E) {
            for (var P = M.width, S = M.height, U = M.index, j = 0; j < S; j++) {
              for (var T = 0; T < P; T++)
                for (var W = k.get(w), J = m(T, j, U), ee = 0; ee < 4; ee++) {
                  var te = N[w][ee];
                  x[J + ee] = te !== 255 ? W[te] : E;
                }
              k.resetAfterLine();
            }
          }
          q.dataToBitMap = function(M, x) {
            var m = x.width, w = x.height, k = x.depth, E = x.bpp, P = x.interlace;
            if (k !== 8)
              var S = Z(M, k);
            var U;
            k <= 8 ? U = new ie(m * w * 4) : U = new Uint16Array(m * w * 4);
            var j = Math.pow(2, k) - 1, T = 0, W, J;
            if (P)
              W = i.getImagePasses(m, w), J = i.getInterlaceIterator(m, w);
            else {
              var ee = 0;
              J = function() {
                var le = ee;
                return ee += 4, le;
              }, W = [{ width: m, height: w }];
            }
            for (var te = 0; te < W.length; te++)
              k === 8 ? T = R(W[te], U, J, E, M, T) : A(W[te], U, J, E, S, j);
            if (k === 8) {
              if (T !== M.length)
                throw new Error("extra data found");
            } else
              S.end();
            return U;
          };
        }).call(this, Q("buffer").Buffer);
      }, { "./interlace": 120, buffer: 48 }], 111: [function(Q, de, q) {
        (function(ie) {
          var i = Q("./constants");
          de.exports = function(N, Z, R, A) {
            var M = [i.COLORTYPE_COLOR_ALPHA, i.COLORTYPE_ALPHA].indexOf(A.colorType) !== -1;
            if (A.colorType === A.inputColorType) {
              var x = function() {
                var le = new ArrayBuffer(2);
                return new DataView(le).setInt16(
                  0,
                  256,
                  !0
                  /* littleEndian */
                ), new Int16Array(le)[0] !== 256;
              }();
              if (A.bitDepth === 8 || A.bitDepth === 16 && x)
                return N;
            }
            var m = A.bitDepth !== 16 ? N : new Uint16Array(N.buffer), w = 255, k = i.COLORTYPE_TO_BPP_MAP[A.inputColorType];
            k == 4 && !A.inputHasAlpha && (k = 3);
            var E = i.COLORTYPE_TO_BPP_MAP[A.colorType];
            A.bitDepth === 16 && (w = 65535, E *= 2);
            var P = new ie(Z * R * E), S = 0, U = 0, j = A.bgColor || {};
            j.red === void 0 && (j.red = w), j.green === void 0 && (j.green = w), j.blue === void 0 && (j.blue = w);
            function T(le, me) {
              var ke, ge, Ve, Oe = w;
              switch (A.inputColorType) {
                case i.COLORTYPE_COLOR_ALPHA:
                  Oe = le[me + 3], ke = le[me], ge = le[me + 1], Ve = le[me + 2];
                  break;
                case i.COLORTYPE_COLOR:
                  ke = le[me], ge = le[me + 1], Ve = le[me + 2];
                  break;
                case i.COLORTYPE_ALPHA:
                  Oe = le[me + 1], ke = le[me], ge = ke, Ve = ke;
                  break;
                case i.COLORTYPE_GRAYSCALE:
                  ke = le[me], ge = ke, Ve = ke;
                  break;
                default:
                  throw new Error("input color type:" + A.inputColorType + " is not supported at present");
              }
              return A.inputHasAlpha && (M || (Oe /= w, ke = Math.min(Math.max(Math.round((1 - Oe) * j.red + Oe * ke), 0), w), ge = Math.min(Math.max(Math.round((1 - Oe) * j.green + Oe * ge), 0), w), Ve = Math.min(Math.max(Math.round((1 - Oe) * j.blue + Oe * Ve), 0), w))), { red: ke, green: ge, blue: Ve, alpha: Oe };
            }
            for (var W = 0; W < R; W++)
              for (var J = 0; J < Z; J++) {
                var ee = T(m, S);
                switch (A.colorType) {
                  case i.COLORTYPE_COLOR_ALPHA:
                  case i.COLORTYPE_COLOR:
                    A.bitDepth === 8 ? (P[U] = ee.red, P[U + 1] = ee.green, P[U + 2] = ee.blue, M && (P[U + 3] = ee.alpha)) : (P.writeUInt16BE(ee.red, U), P.writeUInt16BE(ee.green, U + 2), P.writeUInt16BE(ee.blue, U + 4), M && P.writeUInt16BE(ee.alpha, U + 6));
                    break;
                  case i.COLORTYPE_ALPHA:
                  case i.COLORTYPE_GRAYSCALE:
                    var te = (ee.red + ee.green + ee.blue) / 3;
                    A.bitDepth === 8 ? (P[U] = te, M && (P[U + 1] = ee.alpha)) : (P.writeUInt16BE(te, U), M && P.writeUInt16BE(ee.alpha, U + 2));
                    break;
                }
                S += k, U += E;
              }
            return P;
          };
        }).call(this, Q("buffer").Buffer);
      }, { "./constants": 113, buffer: 48 }], 112: [function(Q, de, q) {
        (function(ie, i) {
          var N = Q("util"), Z = Q("stream"), R = de.exports = function() {
            Z.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = !1, this._encoding = "utf8", this.writable = !0;
          };
          N.inherits(R, Z), R.prototype.read = function(A, M) {
            this._reads.push({
              length: Math.abs(A),
              // if length < 0 then at most this length
              allowLess: A < 0,
              func: M
            }), ie.nextTick((function() {
              this._process(), this._paused && this._reads.length > 0 && (this._paused = !1, this.emit("drain"));
            }).bind(this));
          }, R.prototype.write = function(A, M) {
            if (!this.writable)
              return this.emit("error", new Error("Stream not writable")), !1;
            var x;
            return i.isBuffer(A) ? x = A : x = new i(A, M || this._encoding), this._buffers.push(x), this._buffered += x.length, this._process(), this._reads && this._reads.length === 0 && (this._paused = !0), this.writable && !this._paused;
          }, R.prototype.end = function(A, M) {
            A && this.write(A, M), this.writable = !1, this._buffers && (this._buffers.length === 0 ? this._end() : (this._buffers.push(null), this._process()));
          }, R.prototype.destroySoon = R.prototype.end, R.prototype._end = function() {
            this._reads.length > 0 && this.emit(
              "error",
              new Error("There are some read requests waiting on finished stream")
            ), this.destroy();
          }, R.prototype.destroy = function() {
            this._buffers && (this.writable = !1, this._reads = null, this._buffers = null, this.emit("close"));
          }, R.prototype._processReadAllowingLess = function(A) {
            this._reads.shift();
            var M = this._buffers[0];
            M.length > A.length ? (this._buffered -= A.length, this._buffers[0] = M.slice(A.length), A.func.call(this, M.slice(0, A.length))) : (this._buffered -= M.length, this._buffers.shift(), A.func.call(this, M));
          }, R.prototype._processRead = function(A) {
            this._reads.shift();
            for (var M = 0, x = 0, m = new i(A.length); M < A.length; ) {
              var w = this._buffers[x++], k = Math.min(w.length, A.length - M);
              w.copy(m, M, 0, k), M += k, k !== w.length && (this._buffers[--x] = w.slice(k));
            }
            x > 0 && this._buffers.splice(0, x), this._buffered -= A.length, A.func.call(this, m);
          }, R.prototype._process = function() {
            try {
              for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
                var A = this._reads[0];
                if (A.allowLess)
                  this._processReadAllowingLess(A);
                else if (this._buffered >= A.length)
                  this._processRead(A);
                else
                  break;
              }
              this._buffers && this._buffers.length > 0 && this._buffers[0] === null && this._end();
            } catch (M) {
              this.emit("error", M);
            }
          };
        }).call(this, Q("_process"), Q("buffer").Buffer);
      }, { _process: 133, buffer: 48, stream: 155, util: 186 }], 113: [function(Q, de, q) {
        de.exports = {
          PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
          TYPE_IHDR: 1229472850,
          TYPE_IEND: 1229278788,
          TYPE_IDAT: 1229209940,
          TYPE_PLTE: 1347179589,
          TYPE_tRNS: 1951551059,
          // eslint-disable-line camelcase
          TYPE_gAMA: 1732332865,
          // eslint-disable-line camelcase
          // color-type bits
          COLORTYPE_GRAYSCALE: 0,
          COLORTYPE_PALETTE: 1,
          COLORTYPE_COLOR: 2,
          COLORTYPE_ALPHA: 4,
          // e.g. grayscale and alpha
          // color-type combinations
          COLORTYPE_PALETTE_COLOR: 3,
          COLORTYPE_COLOR_ALPHA: 6,
          COLORTYPE_TO_BPP_MAP: {
            0: 1,
            2: 3,
            3: 1,
            4: 2,
            6: 4
          },
          GAMMA_DIVISION: 1e5
        };
      }, {}], 114: [function(Q, de, q) {
        var ie = [];
        (function() {
          for (var N = 0; N < 256; N++) {
            for (var Z = N, R = 0; R < 8; R++)
              Z & 1 ? Z = 3988292384 ^ Z >>> 1 : Z = Z >>> 1;
            ie[N] = Z;
          }
        })();
        var i = de.exports = function() {
          this._crc = -1;
        };
        i.prototype.write = function(N) {
          for (var Z = 0; Z < N.length; Z++)
            this._crc = ie[(this._crc ^ N[Z]) & 255] ^ this._crc >>> 8;
          return !0;
        }, i.prototype.crc32 = function() {
          return this._crc ^ -1;
        }, i.crc32 = function(N) {
          for (var Z = -1, R = 0; R < N.length; R++)
            Z = ie[(Z ^ N[R]) & 255] ^ Z >>> 8;
          return Z ^ -1;
        };
      }, {}], 115: [function(Q, de, q) {
        (function(ie) {
          var i = Q("./paeth-predictor");
          function N(U, j, T, W, J) {
            for (var ee = 0; ee < T; ee++)
              W[J + ee] = U[j + ee];
          }
          function Z(U, j, T) {
            for (var W = 0, J = j + T, ee = j; ee < J; ee++)
              W += Math.abs(U[ee]);
            return W;
          }
          function R(U, j, T, W, J, ee) {
            for (var te = 0; te < T; te++) {
              var le = te >= ee ? U[j + te - ee] : 0, me = U[j + te] - le;
              W[J + te] = me;
            }
          }
          function A(U, j, T, W) {
            for (var J = 0, ee = 0; ee < T; ee++) {
              var te = ee >= W ? U[j + ee - W] : 0, le = U[j + ee] - te;
              J += Math.abs(le);
            }
            return J;
          }
          function M(U, j, T, W, J) {
            for (var ee = 0; ee < T; ee++) {
              var te = j > 0 ? U[j + ee - T] : 0, le = U[j + ee] - te;
              W[J + ee] = le;
            }
          }
          function x(U, j, T) {
            for (var W = 0, J = j + T, ee = j; ee < J; ee++) {
              var te = j > 0 ? U[ee - T] : 0, le = U[ee] - te;
              W += Math.abs(le);
            }
            return W;
          }
          function m(U, j, T, W, J, ee) {
            for (var te = 0; te < T; te++) {
              var le = te >= ee ? U[j + te - ee] : 0, me = j > 0 ? U[j + te - T] : 0, ke = U[j + te] - (le + me >> 1);
              W[J + te] = ke;
            }
          }
          function w(U, j, T, W) {
            for (var J = 0, ee = 0; ee < T; ee++) {
              var te = ee >= W ? U[j + ee - W] : 0, le = j > 0 ? U[j + ee - T] : 0, me = U[j + ee] - (te + le >> 1);
              J += Math.abs(me);
            }
            return J;
          }
          function k(U, j, T, W, J, ee) {
            for (var te = 0; te < T; te++) {
              var le = te >= ee ? U[j + te - ee] : 0, me = j > 0 ? U[j + te - T] : 0, ke = j > 0 && te >= ee ? U[j + te - (T + ee)] : 0, ge = U[j + te] - i(le, me, ke);
              W[J + te] = ge;
            }
          }
          function E(U, j, T, W) {
            for (var J = 0, ee = 0; ee < T; ee++) {
              var te = ee >= W ? U[j + ee - W] : 0, le = j > 0 ? U[j + ee - T] : 0, me = j > 0 && ee >= W ? U[j + ee - (T + W)] : 0, ke = U[j + ee] - i(te, le, me);
              J += Math.abs(ke);
            }
            return J;
          }
          var P = {
            0: N,
            1: R,
            2: M,
            3: m,
            4: k
          }, S = {
            0: Z,
            1: A,
            2: x,
            3: w,
            4: E
          };
          de.exports = function(U, j, T, W, J) {
            var ee;
            if (!("filterType" in W) || W.filterType === -1)
              ee = [0, 1, 2, 3, 4];
            else if (typeof W.filterType == "number")
              ee = [W.filterType];
            else
              throw new Error("unrecognised filter types");
            W.bitDepth === 16 && (J *= 2);
            for (var te = j * J, le = 0, me = 0, ke = new ie((te + 1) * T), ge = ee[0], Ve = 0; Ve < T; Ve++) {
              if (ee.length > 1)
                for (var Oe = 1 / 0, Ue = 0; Ue < ee.length; Ue++) {
                  var we = S[ee[Ue]](U, me, te, J);
                  we < Oe && (ge = ee[Ue], Oe = we);
                }
              ke[le] = ge, le++, P[ge](U, me, te, ke, le, J), le += te, me += te;
            }
            return ke;
          };
        }).call(this, Q("buffer").Buffer);
      }, { "./paeth-predictor": 124, buffer: 48 }], 116: [function(Q, de, q) {
        (function(ie) {
          var i = Q("util"), N = Q("./chunkstream"), Z = Q("./filter-parse"), R = de.exports = function(A) {
            N.call(this);
            var M = [], x = this;
            this._filter = new Z(A, {
              read: this.read.bind(this),
              write: function(m) {
                M.push(m);
              },
              complete: function() {
                x.emit("complete", ie.concat(M));
              }
            }), this._filter.start();
          };
          i.inherits(R, N);
        }).call(this, Q("buffer").Buffer);
      }, { "./chunkstream": 112, "./filter-parse": 118, buffer: 48, util: 186 }], 117: [function(Q, de, q) {
        (function(ie) {
          var i = Q("./sync-reader"), N = Q("./filter-parse");
          q.process = function(Z, R) {
            var A = [], M = new i(Z), x = new N(R, {
              read: M.read.bind(M),
              write: function(m) {
                A.push(m);
              },
              complete: function() {
              }
            });
            return x.start(), M.process(), ie.concat(A);
          };
        }).call(this, Q("buffer").Buffer);
      }, { "./filter-parse": 118, "./sync-reader": 131, buffer: 48 }], 118: [function(Q, de, q) {
        (function(ie) {
          var i = Q("./interlace"), N = Q("./paeth-predictor");
          function Z(A, M, x) {
            var m = A * M;
            return x !== 8 && (m = Math.ceil(m / (8 / x))), m;
          }
          var R = de.exports = function(A, M) {
            var x = A.width, m = A.height, w = A.interlace, k = A.bpp, E = A.depth;
            if (this.read = M.read, this.write = M.write, this.complete = M.complete, this._imageIndex = 0, this._images = [], w)
              for (var P = i.getImagePasses(x, m), S = 0; S < P.length; S++)
                this._images.push({
                  byteWidth: Z(P[S].width, k, E),
                  height: P[S].height,
                  lineIndex: 0
                });
            else
              this._images.push({
                byteWidth: Z(x, k, E),
                height: m,
                lineIndex: 0
              });
            E === 8 ? this._xComparison = k : E === 16 ? this._xComparison = k * 2 : this._xComparison = 1;
          };
          R.prototype.start = function() {
            this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
          }, R.prototype._unFilterType1 = function(A, M, x) {
            for (var m = this._xComparison, w = m - 1, k = 0; k < x; k++) {
              var E = A[1 + k], P = k > w ? M[k - m] : 0;
              M[k] = E + P;
            }
          }, R.prototype._unFilterType2 = function(A, M, x) {
            for (var m = this._lastLine, w = 0; w < x; w++) {
              var k = A[1 + w], E = m ? m[w] : 0;
              M[w] = k + E;
            }
          }, R.prototype._unFilterType3 = function(A, M, x) {
            for (var m = this._xComparison, w = m - 1, k = this._lastLine, E = 0; E < x; E++) {
              var P = A[1 + E], S = k ? k[E] : 0, U = E > w ? M[E - m] : 0, j = Math.floor((U + S) / 2);
              M[E] = P + j;
            }
          }, R.prototype._unFilterType4 = function(A, M, x) {
            for (var m = this._xComparison, w = m - 1, k = this._lastLine, E = 0; E < x; E++) {
              var P = A[1 + E], S = k ? k[E] : 0, U = E > w ? M[E - m] : 0, j = E > w && k ? k[E - m] : 0, T = N(U, S, j);
              M[E] = P + T;
            }
          }, R.prototype._reverseFilterLine = function(A) {
            var M = A[0], x, m = this._images[this._imageIndex], w = m.byteWidth;
            if (M === 0)
              x = A.slice(1, w + 1);
            else
              switch (x = new ie(w), M) {
                case 1:
                  this._unFilterType1(A, x, w);
                  break;
                case 2:
                  this._unFilterType2(A, x, w);
                  break;
                case 3:
                  this._unFilterType3(A, x, w);
                  break;
                case 4:
                  this._unFilterType4(A, x, w);
                  break;
                default:
                  throw new Error("Unrecognised filter type - " + M);
              }
            this.write(x), m.lineIndex++, m.lineIndex >= m.height ? (this._lastLine = null, this._imageIndex++, m = this._images[this._imageIndex]) : this._lastLine = x, m ? this.read(m.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
          };
        }).call(this, Q("buffer").Buffer);
      }, { "./interlace": 120, "./paeth-predictor": 124, buffer: 48 }], 119: [function(Q, de, q) {
        (function(ie) {
          function i(R, A, M, x, m) {
            for (var w = 0, k = 0; k < x; k++)
              for (var E = 0; E < M; E++) {
                var P = m[R[w]];
                if (!P)
                  throw new Error("index " + R[w] + " not in palette");
                for (var S = 0; S < 4; S++)
                  A[w + S] = P[S];
                w += 4;
              }
          }
          function N(R, A, M, x, m) {
            for (var w = 0, k = 0; k < x; k++)
              for (var E = 0; E < M; E++) {
                var P = !1;
                if (m.length === 1 ? m[0] === R[w] && (P = !0) : m[0] === R[w] && m[1] === R[w + 1] && m[2] === R[w + 2] && (P = !0), P)
                  for (var S = 0; S < 4; S++)
                    A[w + S] = 0;
                w += 4;
              }
          }
          function Z(R, A, M, x, m) {
            for (var w = 255, k = Math.pow(2, m) - 1, E = 0, P = 0; P < x; P++)
              for (var S = 0; S < M; S++) {
                for (var U = 0; U < 4; U++)
                  A[E + U] = Math.floor(R[E + U] * w / k + 0.5);
                E += 4;
              }
          }
          de.exports = function(R, A) {
            var M = A.depth, x = A.width, m = A.height, w = A.colorType, k = A.transColor, E = A.palette, P = R;
            return w === 3 ? i(R, P, x, m, E) : (k && N(R, P, x, m, k), M !== 8 && (M === 16 && (P = new ie(x * m * 4)), Z(R, P, x, m, M))), P;
          };
        }).call(this, Q("buffer").Buffer);
      }, { buffer: 48 }], 120: [function(Q, de, q) {
        var ie = [
          {
            // pass 1 - 1px
            x: [0],
            y: [0]
          },
          {
            // pass 2 - 1px
            x: [4],
            y: [0]
          },
          {
            // pass 3 - 2px
            x: [0, 4],
            y: [4]
          },
          {
            // pass 4 - 4px
            x: [2, 6],
            y: [0, 4]
          },
          {
            // pass 5 - 8px
            x: [0, 2, 4, 6],
            y: [2, 6]
          },
          {
            // pass 6 - 16px
            x: [1, 3, 5, 7],
            y: [0, 2, 4, 6]
          },
          {
            // pass 7 - 32px
            x: [0, 1, 2, 3, 4, 5, 6, 7],
            y: [1, 3, 5, 7]
          }
        ];
        q.getImagePasses = function(i, N) {
          for (var Z = [], R = i % 8, A = N % 8, M = (i - R) / 8, x = (N - A) / 8, m = 0; m < ie.length; m++) {
            for (var w = ie[m], k = M * w.x.length, E = x * w.y.length, P = 0; P < w.x.length && w.x[P] < R; P++)
              k++;
            for (P = 0; P < w.y.length && w.y[P] < A; P++)
              E++;
            k > 0 && E > 0 && Z.push({ width: k, height: E, index: m });
          }
          return Z;
        }, q.getInterlaceIterator = function(i) {
          return function(N, Z, R) {
            var A = N % ie[R].x.length, M = (N - A) / ie[R].x.length * 8 + ie[R].x[A], x = Z % ie[R].y.length, m = (Z - x) / ie[R].y.length * 8 + ie[R].y[x];
            return M * 4 + m * i * 4;
          };
        };
      }, {}], 121: [function(Q, de, q) {
        (function(ie) {
          var i = Q("util"), N = Q("stream"), Z = Q("./constants"), R = Q("./packer"), A = de.exports = function(M) {
            N.call(this);
            var x = M || {};
            this._packer = new R(x), this._deflate = this._packer.createDeflate(), this.readable = !0;
          };
          i.inherits(A, N), A.prototype.pack = function(M, x, m, w) {
            this.emit("data", new ie(Z.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(x, m)), w && this.emit("data", this._packer.packGAMA(w));
            var k = this._packer.filterData(M, x, m);
            this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", (function(E) {
              this.emit("data", this._packer.packIDAT(E));
            }).bind(this)), this._deflate.on("end", (function() {
              this.emit("data", this._packer.packIEND()), this.emit("end");
            }).bind(this)), this._deflate.end(k);
          };
        }).call(this, Q("buffer").Buffer);
      }, { "./constants": 113, "./packer": 123, buffer: 48, stream: 155, util: 186 }], 122: [function(Q, de, q) {
        (function(ie) {
          var i = !0, N = Q("zlib");
          N.deflateSync || (i = !1);
          var Z = Q("./constants"), R = Q("./packer");
          de.exports = function(A, M) {
            if (!i)
              throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            var x = M || {}, m = new R(x), w = [];
            w.push(new ie(Z.PNG_SIGNATURE)), w.push(m.packIHDR(A.width, A.height)), A.gamma && w.push(m.packGAMA(A.gamma));
            var k = m.filterData(A.data, A.width, A.height), E = N.deflateSync(k, m.getDeflateOptions());
            if (k = null, !E || !E.length)
              throw new Error("bad png - invalid compressed data response");
            return w.push(m.packIDAT(E)), w.push(m.packIEND()), ie.concat(w);
          };
        }).call(this, Q("buffer").Buffer);
      }, { "./constants": 113, "./packer": 123, buffer: 48, zlib: 35 }], 123: [function(Q, de, q) {
        (function(ie) {
          var i = Q("./constants"), N = Q("./crc"), Z = Q("./bitpacker"), R = Q("./filter-pack"), A = Q("zlib"), M = de.exports = function(x) {
            if (this._options = x, x.deflateChunkSize = x.deflateChunkSize || 32 * 1024, x.deflateLevel = x.deflateLevel != null ? x.deflateLevel : 9, x.deflateStrategy = x.deflateStrategy != null ? x.deflateStrategy : 3, x.inputHasAlpha = x.inputHasAlpha != null ? x.inputHasAlpha : !0, x.deflateFactory = x.deflateFactory || A.createDeflate, x.bitDepth = x.bitDepth || 8, x.colorType = typeof x.colorType == "number" ? x.colorType : i.COLORTYPE_COLOR_ALPHA, x.inputColorType = typeof x.inputColorType == "number" ? x.inputColorType : i.COLORTYPE_COLOR_ALPHA, [
              i.COLORTYPE_GRAYSCALE,
              i.COLORTYPE_COLOR,
              i.COLORTYPE_COLOR_ALPHA,
              i.COLORTYPE_ALPHA
            ].indexOf(x.colorType) === -1)
              throw new Error("option color type:" + x.colorType + " is not supported at present");
            if ([
              i.COLORTYPE_GRAYSCALE,
              i.COLORTYPE_COLOR,
              i.COLORTYPE_COLOR_ALPHA,
              i.COLORTYPE_ALPHA
            ].indexOf(x.inputColorType) === -1)
              throw new Error("option input color type:" + x.inputColorType + " is not supported at present");
            if (x.bitDepth !== 8 && x.bitDepth !== 16)
              throw new Error("option bit depth:" + x.bitDepth + " is not supported at present");
          };
          M.prototype.getDeflateOptions = function() {
            return {
              chunkSize: this._options.deflateChunkSize,
              level: this._options.deflateLevel,
              strategy: this._options.deflateStrategy
            };
          }, M.prototype.createDeflate = function() {
            return this._options.deflateFactory(this.getDeflateOptions());
          }, M.prototype.filterData = function(x, m, w) {
            var k = Z(x, m, w, this._options), E = i.COLORTYPE_TO_BPP_MAP[this._options.colorType], P = R(k, m, w, this._options, E);
            return P;
          }, M.prototype._packChunk = function(x, m) {
            var w = m ? m.length : 0, k = new ie(w + 12);
            return k.writeUInt32BE(w, 0), k.writeUInt32BE(x, 4), m && m.copy(k, 8), k.writeInt32BE(N.crc32(k.slice(4, k.length - 4)), k.length - 4), k;
          }, M.prototype.packGAMA = function(x) {
            var m = new ie(4);
            return m.writeUInt32BE(Math.floor(x * i.GAMMA_DIVISION), 0), this._packChunk(i.TYPE_gAMA, m);
          }, M.prototype.packIHDR = function(x, m) {
            var w = new ie(13);
            return w.writeUInt32BE(x, 0), w.writeUInt32BE(m, 4), w[8] = this._options.bitDepth, w[9] = this._options.colorType, w[10] = 0, w[11] = 0, w[12] = 0, this._packChunk(i.TYPE_IHDR, w);
          }, M.prototype.packIDAT = function(x) {
            return this._packChunk(i.TYPE_IDAT, x);
          }, M.prototype.packIEND = function() {
            return this._packChunk(i.TYPE_IEND, null);
          };
        }).call(this, Q("buffer").Buffer);
      }, { "./bitpacker": 111, "./constants": 113, "./crc": 114, "./filter-pack": 115, buffer: 48, zlib: 35 }], 124: [function(Q, de, q) {
        de.exports = function(i, N, Z) {
          var R = i + N - Z, A = Math.abs(R - i), M = Math.abs(R - N), x = Math.abs(R - Z);
          return A <= M && A <= x ? i : M <= x ? N : Z;
        };
      }, {}], 125: [function(Q, de, q) {
        var ie = Q("util"), i = Q("zlib"), N = Q("./chunkstream"), Z = Q("./filter-parse-async"), R = Q("./parser"), A = Q("./bitmapper"), M = Q("./format-normaliser"), x = de.exports = function(m) {
          N.call(this), this._parser = new R(m, {
            read: this.read.bind(this),
            error: this._handleError.bind(this),
            metadata: this._handleMetaData.bind(this),
            gamma: this.emit.bind(this, "gamma"),
            palette: this._handlePalette.bind(this),
            transColor: this._handleTransColor.bind(this),
            finished: this._finished.bind(this),
            inflateData: this._inflateData.bind(this)
          }), this._options = m, this.writable = !0, this._parser.start();
        };
        ie.inherits(x, N), x.prototype._handleError = function(m) {
          this.emit("error", m), this.writable = !1, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
          })), this.errord = !0;
        }, x.prototype._inflateData = function(m) {
          if (!this._inflate)
            if (this._bitmapInfo.interlace)
              this._inflate = i.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
            else {
              var w = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1, k = w * this._bitmapInfo.height, E = Math.max(k, i.Z_MIN_CHUNK);
              this._inflate = i.createInflate({ chunkSize: E });
              var P = k, S = this.emit.bind(this, "error");
              this._inflate.on("error", function(j) {
                P && S(j);
              }), this._filter.on("complete", this._complete.bind(this));
              var U = this._filter.write.bind(this._filter);
              this._inflate.on("data", function(j) {
                P && (j.length > P && (j = j.slice(0, P)), P -= j.length, U(j));
              }), this._inflate.on("end", this._filter.end.bind(this._filter));
            }
          this._inflate.write(m);
        }, x.prototype._handleMetaData = function(m) {
          this.emit("metadata", m), this._bitmapInfo = Object.create(m), this._filter = new Z(this._bitmapInfo);
        }, x.prototype._handleTransColor = function(m) {
          this._bitmapInfo.transColor = m;
        }, x.prototype._handlePalette = function(m) {
          this._bitmapInfo.palette = m;
        }, x.prototype._finished = function() {
          this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"), this.destroySoon());
        }, x.prototype._complete = function(m) {
          if (!this.errord) {
            try {
              var w = A.dataToBitMap(m, this._bitmapInfo), k = M(w, this._bitmapInfo);
              w = null;
            } catch (E) {
              this._handleError(E);
              return;
            }
            this.emit("parsed", k);
          }
        };
      }, { "./bitmapper": 110, "./chunkstream": 112, "./filter-parse-async": 116, "./format-normaliser": 119, "./parser": 127, util: 186, zlib: 35 }], 126: [function(Q, de, q) {
        (function(ie) {
          var i = !0, N = Q("zlib"), Z = Q("./sync-inflate");
          N.deflateSync || (i = !1);
          var R = Q("./sync-reader"), A = Q("./filter-parse-sync"), M = Q("./parser"), x = Q("./bitmapper"), m = Q("./format-normaliser");
          de.exports = function(w, k) {
            if (!i)
              throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            var E;
            function P(it) {
              E = it;
            }
            var S;
            function U(it) {
              S = it;
            }
            function j(it) {
              S.transColor = it;
            }
            function T(it) {
              S.palette = it;
            }
            var W;
            function J(it) {
              W = it;
            }
            var ee = [];
            function te(it) {
              ee.push(it);
            }
            var le = new R(w), me = new M(k, {
              read: le.read.bind(le),
              error: P,
              metadata: U,
              gamma: J,
              palette: T,
              transColor: j,
              inflateData: te
            });
            if (me.start(), le.process(), E)
              throw E;
            var ke = ie.concat(ee);
            ee.length = 0;
            var ge;
            if (S.interlace)
              ge = N.inflateSync(ke);
            else {
              var Ve = (S.width * S.bpp * S.depth + 7 >> 3) + 1, Oe = Ve * S.height;
              ge = Z(ke, { chunkSize: Oe, maxLength: Oe });
            }
            if (ke = null, !ge || !ge.length)
              throw new Error("bad png - invalid inflate data response");
            var Ue = A.process(ge, S);
            ke = null;
            var we = x.dataToBitMap(Ue, S);
            Ue = null;
            var Ce = m(we, S);
            return S.data = Ce, S.gamma = W || 0, S;
          };
        }).call(this, Q("buffer").Buffer);
      }, { "./bitmapper": 110, "./filter-parse-sync": 117, "./format-normaliser": 119, "./parser": 127, "./sync-inflate": 130, "./sync-reader": 131, buffer: 48, zlib: 35 }], 127: [function(Q, de, q) {
        (function(ie) {
          var i = Q("./constants"), N = Q("./crc"), Z = de.exports = function(R, A) {
            this._options = R, R.checkCRC = R.checkCRC !== !1, this._hasIHDR = !1, this._hasIEND = !1, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[i.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[i.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[i.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[i.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[i.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[i.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = A.read, this.error = A.error, this.metadata = A.metadata, this.gamma = A.gamma, this.transColor = A.transColor, this.palette = A.palette, this.parsed = A.parsed, this.inflateData = A.inflateData, this.finished = A.finished;
          };
          Z.prototype.start = function() {
            this.read(
              i.PNG_SIGNATURE.length,
              this._parseSignature.bind(this)
            );
          }, Z.prototype._parseSignature = function(R) {
            for (var A = i.PNG_SIGNATURE, M = 0; M < A.length; M++)
              if (R[M] !== A[M]) {
                this.error(new Error("Invalid file signature"));
                return;
              }
            this.read(8, this._parseChunkBegin.bind(this));
          }, Z.prototype._parseChunkBegin = function(R) {
            for (var A = R.readUInt32BE(0), M = R.readUInt32BE(4), x = "", m = 4; m < 8; m++)
              x += String.fromCharCode(R[m]);
            var w = !!(R[4] & 32);
            if (!this._hasIHDR && M !== i.TYPE_IHDR) {
              this.error(new Error("Expected IHDR on beggining"));
              return;
            }
            if (this._crc = new N(), this._crc.write(new ie(x)), this._chunks[M])
              return this._chunks[M](A);
            if (!w) {
              this.error(new Error("Unsupported critical chunk type " + x));
              return;
            }
            this.read(A + 4, this._skipChunk.bind(this));
          }, Z.prototype._skipChunk = function() {
            this.read(8, this._parseChunkBegin.bind(this));
          }, Z.prototype._handleChunkEnd = function() {
            this.read(4, this._parseChunkEnd.bind(this));
          }, Z.prototype._parseChunkEnd = function(R) {
            var A = R.readInt32BE(0), M = this._crc.crc32();
            if (this._options.checkCRC && M !== A) {
              this.error(new Error("Crc error - " + A + " - " + M));
              return;
            }
            this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
          }, Z.prototype._handleIHDR = function(R) {
            this.read(R, this._parseIHDR.bind(this));
          }, Z.prototype._parseIHDR = function(R) {
            this._crc.write(R);
            var A = R.readUInt32BE(0), M = R.readUInt32BE(4), x = R[8], m = R[9], w = R[10], k = R[11], E = R[12];
            if (x !== 8 && x !== 4 && x !== 2 && x !== 1 && x !== 16) {
              this.error(new Error("Unsupported bit depth " + x));
              return;
            }
            if (!(m in i.COLORTYPE_TO_BPP_MAP)) {
              this.error(new Error("Unsupported color type"));
              return;
            }
            if (w !== 0) {
              this.error(new Error("Unsupported compression method"));
              return;
            }
            if (k !== 0) {
              this.error(new Error("Unsupported filter method"));
              return;
            }
            if (E !== 0 && E !== 1) {
              this.error(new Error("Unsupported interlace method"));
              return;
            }
            this._colorType = m;
            var P = i.COLORTYPE_TO_BPP_MAP[this._colorType];
            this._hasIHDR = !0, this.metadata({
              width: A,
              height: M,
              depth: x,
              interlace: !!E,
              palette: !!(m & i.COLORTYPE_PALETTE),
              color: !!(m & i.COLORTYPE_COLOR),
              alpha: !!(m & i.COLORTYPE_ALPHA),
              bpp: P,
              colorType: m
            }), this._handleChunkEnd();
          }, Z.prototype._handlePLTE = function(R) {
            this.read(R, this._parsePLTE.bind(this));
          }, Z.prototype._parsePLTE = function(R) {
            this._crc.write(R);
            for (var A = Math.floor(R.length / 3), M = 0; M < A; M++)
              this._palette.push([
                R[M * 3],
                R[M * 3 + 1],
                R[M * 3 + 2],
                255
              ]);
            this.palette(this._palette), this._handleChunkEnd();
          }, Z.prototype._handleTRNS = function(R) {
            this.read(R, this._parseTRNS.bind(this));
          }, Z.prototype._parseTRNS = function(R) {
            if (this._crc.write(R), this._colorType === i.COLORTYPE_PALETTE_COLOR) {
              if (this._palette.length === 0) {
                this.error(new Error("Transparency chunk must be after palette"));
                return;
              }
              if (R.length > this._palette.length) {
                this.error(new Error("More transparent colors than palette size"));
                return;
              }
              for (var A = 0; A < R.length; A++)
                this._palette[A][3] = R[A];
              this.palette(this._palette);
            }
            this._colorType === i.COLORTYPE_GRAYSCALE && this.transColor([R.readUInt16BE(0)]), this._colorType === i.COLORTYPE_COLOR && this.transColor([R.readUInt16BE(0), R.readUInt16BE(2), R.readUInt16BE(4)]), this._handleChunkEnd();
          }, Z.prototype._handleGAMA = function(R) {
            this.read(R, this._parseGAMA.bind(this));
          }, Z.prototype._parseGAMA = function(R) {
            this._crc.write(R), this.gamma(R.readUInt32BE(0) / i.GAMMA_DIVISION), this._handleChunkEnd();
          }, Z.prototype._handleIDAT = function(R) {
            this.read(-R, this._parseIDAT.bind(this, R));
          }, Z.prototype._parseIDAT = function(R, A) {
            if (this._crc.write(A), this._colorType === i.COLORTYPE_PALETTE_COLOR && this._palette.length === 0)
              throw new Error("Expected palette not found");
            this.inflateData(A);
            var M = R - A.length;
            M > 0 ? this._handleIDAT(M) : this._handleChunkEnd();
          }, Z.prototype._handleIEND = function(R) {
            this.read(R, this._parseIEND.bind(this));
          }, Z.prototype._parseIEND = function(R) {
            this._crc.write(R), this._hasIEND = !0, this._handleChunkEnd(), this.finished && this.finished();
          };
        }).call(this, Q("buffer").Buffer);
      }, { "./constants": 113, "./crc": 114, buffer: 48 }], 128: [function(Q, de, q) {
        var ie = Q("./parser-sync"), i = Q("./packer-sync");
        q.read = function(N, Z) {
          return ie(N, Z || {});
        }, q.write = function(N, Z) {
          return i(N, Z);
        };
      }, { "./packer-sync": 122, "./parser-sync": 126 }], 129: [function(Q, de, q) {
        (function(ie, i) {
          var N = Q("util"), Z = Q("stream"), R = Q("./parser-async"), A = Q("./packer-async"), M = Q("./png-sync"), x = q.PNG = function(m) {
            Z.call(this), m = m || {}, this.width = m.width | 0, this.height = m.height | 0, this.data = this.width > 0 && this.height > 0 ? new i(4 * this.width * this.height) : null, m.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = !0, this._parser = new R(m), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", (function(w) {
              this.data = w, this.emit("parsed", w);
            }).bind(this)), this._packer = new A(m), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
          };
          N.inherits(x, Z), x.sync = M, x.prototype.pack = function() {
            return !this.data || !this.data.length ? (this.emit("error", "No data provided"), this) : (ie.nextTick((function() {
              this._packer.pack(this.data, this.width, this.height, this.gamma);
            }).bind(this)), this);
          }, x.prototype.parse = function(m, w) {
            if (w) {
              var k, E;
              k = (function(P) {
                this.removeListener("error", E), this.data = P, w(null, this);
              }).bind(this), E = (function(P) {
                this.removeListener("parsed", k), w(P, null);
              }).bind(this), this.once("parsed", k), this.once("error", E);
            }
            return this.end(m), this;
          }, x.prototype.write = function(m) {
            return this._parser.write(m), !0;
          }, x.prototype.end = function(m) {
            this._parser.end(m);
          }, x.prototype._metadata = function(m) {
            this.width = m.width, this.height = m.height, this.emit("metadata", m);
          }, x.prototype._gamma = function(m) {
            this.gamma = m;
          }, x.prototype._handleClose = function() {
            !this._parser.writable && !this._packer.readable && this.emit("close");
          }, x.bitblt = function(m, w, k, E, P, S, U, j) {
            if (k |= 0, E |= 0, P |= 0, S |= 0, U |= 0, j |= 0, k > m.width || E > m.height || k + P > m.width || E + S > m.height)
              throw new Error("bitblt reading outside image");
            if (U > w.width || j > w.height || U + P > w.width || j + S > w.height)
              throw new Error("bitblt writing outside image");
            for (var T = 0; T < S; T++)
              m.data.copy(
                w.data,
                (j + T) * w.width + U << 2,
                (E + T) * m.width + k << 2,
                (E + T) * m.width + k + P << 2
              );
          }, x.prototype.bitblt = function(m, w, k, E, P, S, U) {
            return x.bitblt(this, m, w, k, E, P, S, U), this;
          }, x.adjustGamma = function(m) {
            if (m.gamma) {
              for (var w = 0; w < m.height; w++)
                for (var k = 0; k < m.width; k++)
                  for (var E = m.width * w + k << 2, P = 0; P < 3; P++) {
                    var S = m.data[E + P] / 255;
                    S = Math.pow(S, 1 / 2.2 / m.gamma), m.data[E + P] = Math.round(S * 255);
                  }
              m.gamma = 0;
            }
          }, x.prototype.adjustGamma = function() {
            x.adjustGamma(this);
          };
        }).call(this, Q("_process"), Q("buffer").Buffer);
      }, { "./packer-async": 121, "./parser-async": 125, "./png-sync": 128, _process: 133, buffer: 48, stream: 155, util: 186 }], 130: [function(Q, de, q) {
        (function(ie, i) {
          var N = Q("assert").ok, Z = Q("zlib"), R = Q("util"), A = Q("buffer").kMaxLength;
          function M(E) {
            if (!(this instanceof M))
              return new M(E);
            E && E.chunkSize < Z.Z_MIN_CHUNK && (E.chunkSize = Z.Z_MIN_CHUNK), Z.Inflate.call(this, E), this._offset = this._offset === void 0 ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, E && E.maxLength != null && (this._maxLength = E.maxLength);
          }
          function x(E) {
            return new M(E);
          }
          function m(E, P) {
            E._handle && (E._handle.close(), E._handle = null);
          }
          M.prototype._processChunk = function(E, P, S) {
            if (typeof S == "function")
              return Z.Inflate._processChunk.call(this, E, P, S);
            var U = this, j = E && E.length, T = this._chunkSize - this._offset, W = this._maxLength, J = 0, ee = [], te = 0, le;
            this.on("error", function(Ve) {
              le = Ve;
            });
            function me(Ve, Oe) {
              if (!U._hadError) {
                var Ue = T - Oe;
                if (N(Ue >= 0, "have should not go down"), Ue > 0) {
                  var we = U._buffer.slice(U._offset, U._offset + Ue);
                  if (U._offset += Ue, we.length > W && (we = we.slice(0, W)), ee.push(we), te += we.length, W -= we.length, W === 0)
                    return !1;
                }
                return (Oe === 0 || U._offset >= U._chunkSize) && (T = U._chunkSize, U._offset = 0, U._buffer = i.allocUnsafe(U._chunkSize)), Oe === 0 ? (J += j - Ve, j = Ve, !0) : !1;
              }
            }
            N(this._handle, "zlib binding closed");
            do {
              var ke = this._handle.writeSync(
                P,
                E,
                // in
                J,
                // in_off
                j,
                // in_len
                this._buffer,
                // out
                this._offset,
                //out_off
                T
              );
              ke = ke || this._writeState;
            } while (!this._hadError && me(ke[0], ke[1]));
            if (this._hadError)
              throw le;
            if (te >= A)
              throw m(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + A.toString(16) + " bytes");
            var ge = i.concat(ee, te);
            return m(this), ge;
          }, R.inherits(M, Z.Inflate);
          function w(E, P) {
            if (typeof P == "string" && (P = i.from(P)), !(P instanceof i))
              throw new TypeError("Not a string or buffer");
            var S = E._finishFlushFlag;
            return S == null && (S = Z.Z_FINISH), E._processChunk(P, S);
          }
          function k(E, P) {
            return w(new M(P), E);
          }
          de.exports = q = k, q.Inflate = M, q.createInflate = x, q.inflateSync = k;
        }).call(this, Q("_process"), Q("buffer").Buffer);
      }, { _process: 133, assert: 25, buffer: 48, util: 186, zlib: 35 }], 131: [function(Q, de, q) {
        var ie = de.exports = function(i) {
          this._buffer = i, this._reads = [];
        };
        ie.prototype.read = function(i, N) {
          this._reads.push({
            length: Math.abs(i),
            // if length < 0 then at most this length
            allowLess: i < 0,
            func: N
          });
        }, ie.prototype.process = function() {
          for (; this._reads.length > 0 && this._buffer.length; ) {
            var i = this._reads[0];
            if (this._buffer.length && (this._buffer.length >= i.length || i.allowLess)) {
              this._reads.shift();
              var N = this._buffer;
              this._buffer = N.slice(i.length), i.func.call(this, N.slice(0, i.length));
            } else
              break;
          }
          if (this._reads.length > 0)
            return new Error("There are some read requests waitng on finished stream");
          if (this._buffer.length > 0)
            return new Error("unrecognised content at end of stream");
        };
      }, {}], 132: [function(Q, de, q) {
        (function(ie) {
          typeof ie > "u" || !ie.version || ie.version.indexOf("v0.") === 0 || ie.version.indexOf("v1.") === 0 && ie.version.indexOf("v1.8.") !== 0 ? de.exports = { nextTick: i } : de.exports = ie;
          function i(N, Z, R, A) {
            if (typeof N != "function")
              throw new TypeError('"callback" argument must be a function');
            var M = arguments.length, x, m;
            switch (M) {
              case 0:
              case 1:
                return ie.nextTick(N);
              case 2:
                return ie.nextTick(function() {
                  N.call(null, Z);
                });
              case 3:
                return ie.nextTick(function() {
                  N.call(null, Z, R);
                });
              case 4:
                return ie.nextTick(function() {
                  N.call(null, Z, R, A);
                });
              default:
                for (x = new Array(M - 1), m = 0; m < x.length; )
                  x[m++] = arguments[m];
                return ie.nextTick(function() {
                  N.apply(null, x);
                });
            }
          }
        }).call(this, Q("_process"));
      }, { _process: 133 }], 133: [function(Q, de, q) {
        var ie = de.exports = {}, i, N;
        function Z() {
          throw new Error("setTimeout has not been defined");
        }
        function R() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            typeof setTimeout == "function" ? i = setTimeout : i = Z;
          } catch {
            i = Z;
          }
          try {
            typeof clearTimeout == "function" ? N = clearTimeout : N = R;
          } catch {
            N = R;
          }
        })();
        function A(j) {
          if (i === setTimeout)
            return setTimeout(j, 0);
          if ((i === Z || !i) && setTimeout)
            return i = setTimeout, setTimeout(j, 0);
          try {
            return i(j, 0);
          } catch {
            try {
              return i.call(null, j, 0);
            } catch {
              return i.call(this, j, 0);
            }
          }
        }
        function M(j) {
          if (N === clearTimeout)
            return clearTimeout(j);
          if ((N === R || !N) && clearTimeout)
            return N = clearTimeout, clearTimeout(j);
          try {
            return N(j);
          } catch {
            try {
              return N.call(null, j);
            } catch {
              return N.call(this, j);
            }
          }
        }
        var x = [], m = !1, w, k = -1;
        function E() {
          !m || !w || (m = !1, w.length ? x = w.concat(x) : k = -1, x.length && P());
        }
        function P() {
          if (!m) {
            var j = A(E);
            m = !0;
            for (var T = x.length; T; ) {
              for (w = x, x = []; ++k < T; )
                w && w[k].run();
              k = -1, T = x.length;
            }
            w = null, m = !1, M(j);
          }
        }
        ie.nextTick = function(j) {
          var T = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var W = 1; W < arguments.length; W++)
              T[W - 1] = arguments[W];
          x.push(new S(j, T)), x.length === 1 && !m && A(P);
        };
        function S(j, T) {
          this.fun = j, this.array = T;
        }
        S.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, ie.title = "browser", ie.browser = !0, ie.env = {}, ie.argv = [], ie.version = "", ie.versions = {};
        function U() {
        }
        ie.on = U, ie.addListener = U, ie.once = U, ie.off = U, ie.removeListener = U, ie.removeAllListeners = U, ie.emit = U, ie.prependListener = U, ie.prependOnceListener = U, ie.listeners = function(j) {
          return [];
        }, ie.binding = function(j) {
          throw new Error("process.binding is not supported");
        }, ie.cwd = function() {
          return "/";
        }, ie.chdir = function(j) {
          throw new Error("process.chdir is not supported");
        }, ie.umask = function() {
          return 0;
        };
      }, {}], 134: [function(Q, de, q) {
        (function(ie) {
          (function(i) {
            var N = typeof q == "object" && q && !q.nodeType && q, Z = typeof de == "object" && de && !de.nodeType && de, R = typeof ie == "object" && ie;
            (R.global === R || R.window === R || R.self === R) && (i = R);
            var A, M = 2147483647, x = 36, m = 1, w = 26, k = 38, E = 700, P = 72, S = 128, U = "-", j = /^xn--/, T = /[^\x20-\x7E]/, W = /[\x2E\u3002\uFF0E\uFF61]/g, J = {
              overflow: "Overflow: input needs wider integers to process",
              "not-basic": "Illegal input >= 0x80 (not a basic code point)",
              "invalid-input": "Invalid input"
            }, ee = x - m, te = Math.floor, le = String.fromCharCode, me;
            function ke(dt) {
              throw new RangeError(J[dt]);
            }
            function ge(dt, ct) {
              for (var wt = dt.length, Ht = []; wt--; )
                Ht[wt] = ct(dt[wt]);
              return Ht;
            }
            function Ve(dt, ct) {
              var wt = dt.split("@"), Ht = "";
              wt.length > 1 && (Ht = wt[0] + "@", dt = wt[1]), dt = dt.replace(W, ".");
              var $t = dt.split("."), rt = ge($t, ct).join(".");
              return Ht + rt;
            }
            function Oe(dt) {
              for (var ct = [], wt = 0, Ht = dt.length, $t, rt; wt < Ht; )
                $t = dt.charCodeAt(wt++), $t >= 55296 && $t <= 56319 && wt < Ht ? (rt = dt.charCodeAt(wt++), (rt & 64512) == 56320 ? ct.push((($t & 1023) << 10) + (rt & 1023) + 65536) : (ct.push($t), wt--)) : ct.push($t);
              return ct;
            }
            function Ue(dt) {
              return ge(dt, function(ct) {
                var wt = "";
                return ct > 65535 && (ct -= 65536, wt += le(ct >>> 10 & 1023 | 55296), ct = 56320 | ct & 1023), wt += le(ct), wt;
              }).join("");
            }
            function we(dt) {
              return dt - 48 < 10 ? dt - 22 : dt - 65 < 26 ? dt - 65 : dt - 97 < 26 ? dt - 97 : x;
            }
            function Ce(dt, ct) {
              return dt + 22 + 75 * (dt < 26) - ((ct != 0) << 5);
            }
            function it(dt, ct, wt) {
              var Ht = 0;
              for (dt = wt ? te(dt / E) : dt >> 1, dt += te(dt / ct); dt > ee * w >> 1; Ht += x)
                dt = te(dt / ee);
              return te(Ht + (ee + 1) * dt / (dt + k));
            }
            function ut(dt) {
              var ct = [], wt = dt.length, Ht, $t = 0, rt = S, ri = P, wi, Qt, At, St, Lt, kt, Ye, De, Re;
              for (wi = dt.lastIndexOf(U), wi < 0 && (wi = 0), Qt = 0; Qt < wi; ++Qt)
                dt.charCodeAt(Qt) >= 128 && ke("not-basic"), ct.push(dt.charCodeAt(Qt));
              for (At = wi > 0 ? wi + 1 : 0; At < wt; ) {
                for (St = $t, Lt = 1, kt = x; At >= wt && ke("invalid-input"), Ye = we(dt.charCodeAt(At++)), (Ye >= x || Ye > te((M - $t) / Lt)) && ke("overflow"), $t += Ye * Lt, De = kt <= ri ? m : kt >= ri + w ? w : kt - ri, !(Ye < De); kt += x)
                  Re = x - De, Lt > te(M / Re) && ke("overflow"), Lt *= Re;
                Ht = ct.length + 1, ri = it($t - St, Ht, St == 0), te($t / Ht) > M - rt && ke("overflow"), rt += te($t / Ht), $t %= Ht, ct.splice($t++, 0, rt);
              }
              return Ue(ct);
            }
            function bt(dt) {
              var ct, wt, Ht, $t, rt, ri, wi, Qt, At, St, Lt, kt = [], Ye, De, Re, _t;
              for (dt = Oe(dt), Ye = dt.length, ct = S, wt = 0, rt = P, ri = 0; ri < Ye; ++ri)
                Lt = dt[ri], Lt < 128 && kt.push(le(Lt));
              for (Ht = $t = kt.length, $t && kt.push(U); Ht < Ye; ) {
                for (wi = M, ri = 0; ri < Ye; ++ri)
                  Lt = dt[ri], Lt >= ct && Lt < wi && (wi = Lt);
                for (De = Ht + 1, wi - ct > te((M - wt) / De) && ke("overflow"), wt += (wi - ct) * De, ct = wi, ri = 0; ri < Ye; ++ri)
                  if (Lt = dt[ri], Lt < ct && ++wt > M && ke("overflow"), Lt == ct) {
                    for (Qt = wt, At = x; St = At <= rt ? m : At >= rt + w ? w : At - rt, !(Qt < St); At += x)
                      _t = Qt - St, Re = x - St, kt.push(
                        le(Ce(St + _t % Re, 0))
                      ), Qt = te(_t / Re);
                    kt.push(le(Ce(Qt, 0))), rt = it(wt, De, Ht == $t), wt = 0, ++Ht;
                  }
                ++wt, ++ct;
              }
              return kt.join("");
            }
            function pt(dt) {
              return Ve(dt, function(ct) {
                return j.test(ct) ? ut(ct.slice(4).toLowerCase()) : ct;
              });
            }
            function Ke(dt) {
              return Ve(dt, function(ct) {
                return T.test(ct) ? "xn--" + bt(ct) : ct;
              });
            }
            if (A = {
              /**
               * A string representing the current Punycode.js version number.
               * @memberOf punycode
               * @type String
               */
              version: "1.4.1",
              /**
               * An object of methods to convert from JavaScript's internal character
               * representation (UCS-2) to Unicode code points, and back.
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode
               * @type Object
               */
              ucs2: {
                decode: Oe,
                encode: Ue
              },
              decode: ut,
              encode: bt,
              toASCII: Ke,
              toUnicode: pt
            }, N && Z)
              if (de.exports == N)
                Z.exports = A;
              else
                for (me in A)
                  A.hasOwnProperty(me) && (N[me] = A[me]);
            else
              i.punycode = A;
          })(this);
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {});
      }, {}], 135: [function(Q, de, q) {
        function ie(N, Z) {
          return Object.prototype.hasOwnProperty.call(N, Z);
        }
        de.exports = function(N, Z, R, A) {
          Z = Z || "&", R = R || "=";
          var M = {};
          if (typeof N != "string" || N.length === 0)
            return M;
          var x = /\+/g;
          N = N.split(Z);
          var m = 1e3;
          A && typeof A.maxKeys == "number" && (m = A.maxKeys);
          var w = N.length;
          m > 0 && w > m && (w = m);
          for (var k = 0; k < w; ++k) {
            var E = N[k].replace(x, "%20"), P = E.indexOf(R), S, U, j, T;
            P >= 0 ? (S = E.substr(0, P), U = E.substr(P + 1)) : (S = E, U = ""), j = decodeURIComponent(S), T = decodeURIComponent(U), ie(M, j) ? i(M[j]) ? M[j].push(T) : M[j] = [M[j], T] : M[j] = T;
          }
          return M;
        };
        var i = Array.isArray || function(N) {
          return Object.prototype.toString.call(N) === "[object Array]";
        };
      }, {}], 136: [function(Q, de, q) {
        var ie = function(R) {
          switch (typeof R) {
            case "string":
              return R;
            case "boolean":
              return R ? "true" : "false";
            case "number":
              return isFinite(R) ? R : "";
            default:
              return "";
          }
        };
        de.exports = function(R, A, M, x) {
          return A = A || "&", M = M || "=", R === null && (R = void 0), typeof R == "object" ? N(Z(R), function(m) {
            var w = encodeURIComponent(ie(m)) + M;
            return i(R[m]) ? N(R[m], function(k) {
              return w + encodeURIComponent(ie(k));
            }).join(A) : w + encodeURIComponent(ie(R[m]));
          }).join(A) : x ? encodeURIComponent(ie(x)) + M + encodeURIComponent(ie(R)) : "";
        };
        var i = Array.isArray || function(R) {
          return Object.prototype.toString.call(R) === "[object Array]";
        };
        function N(R, A) {
          if (R.map) return R.map(A);
          for (var M = [], x = 0; x < R.length; x++)
            M.push(A(R[x], x));
          return M;
        }
        var Z = Object.keys || function(R) {
          var A = [];
          for (var M in R)
            Object.prototype.hasOwnProperty.call(R, M) && A.push(M);
          return A;
        };
      }, {}], 137: [function(Q, de, q) {
        q.decode = q.parse = Q("./decode"), q.encode = q.stringify = Q("./encode");
      }, { "./decode": 135, "./encode": 136 }], 138: [function(Q, de, q) {
        de.exports = Q("./lib/_stream_duplex.js");
      }, { "./lib/_stream_duplex.js": 139 }], 139: [function(Q, de, q) {
        var ie = Q("process-nextick-args"), i = Object.keys || function(E) {
          var P = [];
          for (var S in E)
            P.push(S);
          return P;
        };
        de.exports = m;
        var N = Q("core-util-is");
        N.inherits = Q("inherits");
        var Z = Q("./_stream_readable"), R = Q("./_stream_writable");
        N.inherits(m, Z);
        for (var A = i(R.prototype), M = 0; M < A.length; M++) {
          var x = A[M];
          m.prototype[x] || (m.prototype[x] = R.prototype[x]);
        }
        function m(E) {
          if (!(this instanceof m)) return new m(E);
          Z.call(this, E), R.call(this, E), E && E.readable === !1 && (this.readable = !1), E && E.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, E && E.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", w);
        }
        Object.defineProperty(m.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: !1,
          get: function() {
            return this._writableState.highWaterMark;
          }
        });
        function w() {
          this.allowHalfOpen || this._writableState.ended || ie.nextTick(k, this);
        }
        function k(E) {
          E.end();
        }
        Object.defineProperty(m.prototype, "destroyed", {
          get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
          },
          set: function(E) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = E, this._writableState.destroyed = E);
          }
        }), m.prototype._destroy = function(E, P) {
          this.push(null), this.end(), ie.nextTick(P, E);
        };
      }, { "./_stream_readable": 141, "./_stream_writable": 143, "core-util-is": 51, inherits: 75, "process-nextick-args": 132 }], 140: [function(Q, de, q) {
        de.exports = N;
        var ie = Q("./_stream_transform"), i = Q("core-util-is");
        i.inherits = Q("inherits"), i.inherits(N, ie);
        function N(Z) {
          if (!(this instanceof N)) return new N(Z);
          ie.call(this, Z);
        }
        N.prototype._transform = function(Z, R, A) {
          A(null, Z);
        };
      }, { "./_stream_transform": 142, "core-util-is": 51, inherits: 75 }], 141: [function(Q, de, q) {
        (function(ie, i) {
          var N = Q("process-nextick-args");
          de.exports = te;
          var Z = Q("isarray"), R;
          te.ReadableState = ee, Q("events").EventEmitter;
          var A = function(St, Lt) {
            return St.listeners(Lt).length;
          }, M = Q("./internal/streams/stream"), x = Q("safe-buffer").Buffer, m = i.Uint8Array || function() {
          };
          function w(St) {
            return x.from(St);
          }
          function k(St) {
            return x.isBuffer(St) || St instanceof m;
          }
          var E = Q("core-util-is");
          E.inherits = Q("inherits");
          var P = Q("util"), S = void 0;
          P && P.debuglog ? S = P.debuglog("stream") : S = function() {
          };
          var U = Q("./internal/streams/BufferList"), j = Q("./internal/streams/destroy"), T;
          E.inherits(te, M);
          var W = ["error", "close", "destroy", "pause", "resume"];
          function J(St, Lt, kt) {
            if (typeof St.prependListener == "function") return St.prependListener(Lt, kt);
            !St._events || !St._events[Lt] ? St.on(Lt, kt) : Z(St._events[Lt]) ? St._events[Lt].unshift(kt) : St._events[Lt] = [kt, St._events[Lt]];
          }
          function ee(St, Lt) {
            R = R || Q("./_stream_duplex"), St = St || {};
            var kt = Lt instanceof R;
            this.objectMode = !!St.objectMode, kt && (this.objectMode = this.objectMode || !!St.readableObjectMode);
            var Ye = St.highWaterMark, De = St.readableHighWaterMark, Re = this.objectMode ? 16 : 16 * 1024;
            Ye || Ye === 0 ? this.highWaterMark = Ye : kt && (De || De === 0) ? this.highWaterMark = De : this.highWaterMark = Re, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new U(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = St.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, St.encoding && (T || (T = Q("string_decoder/").StringDecoder), this.decoder = new T(St.encoding), this.encoding = St.encoding);
          }
          function te(St) {
            if (R = R || Q("./_stream_duplex"), !(this instanceof te)) return new te(St);
            this._readableState = new ee(St, this), this.readable = !0, St && (typeof St.read == "function" && (this._read = St.read), typeof St.destroy == "function" && (this._destroy = St.destroy)), M.call(this);
          }
          Object.defineProperty(te.prototype, "destroyed", {
            get: function() {
              return this._readableState === void 0 ? !1 : this._readableState.destroyed;
            },
            set: function(St) {
              this._readableState && (this._readableState.destroyed = St);
            }
          }), te.prototype.destroy = j.destroy, te.prototype._undestroy = j.undestroy, te.prototype._destroy = function(St, Lt) {
            this.push(null), Lt(St);
          }, te.prototype.push = function(St, Lt) {
            var kt = this._readableState, Ye;
            return kt.objectMode ? Ye = !0 : typeof St == "string" && (Lt = Lt || kt.defaultEncoding, Lt !== kt.encoding && (St = x.from(St, Lt), Lt = ""), Ye = !0), le(this, St, Lt, !1, Ye);
          }, te.prototype.unshift = function(St) {
            return le(this, St, null, !0, !1);
          };
          function le(St, Lt, kt, Ye, De) {
            var Re = St._readableState;
            if (Lt === null)
              Re.reading = !1, we(St, Re);
            else {
              var _t;
              De || (_t = ke(Re, Lt)), _t ? St.emit("error", _t) : Re.objectMode || Lt && Lt.length > 0 ? (typeof Lt != "string" && !Re.objectMode && Object.getPrototypeOf(Lt) !== x.prototype && (Lt = w(Lt)), Ye ? Re.endEmitted ? St.emit("error", new Error("stream.unshift() after end event")) : me(St, Re, Lt, !0) : Re.ended ? St.emit("error", new Error("stream.push() after EOF")) : (Re.reading = !1, Re.decoder && !kt ? (Lt = Re.decoder.write(Lt), Re.objectMode || Lt.length !== 0 ? me(St, Re, Lt, !1) : ut(St, Re)) : me(St, Re, Lt, !1))) : Ye || (Re.reading = !1);
            }
            return ge(Re);
          }
          function me(St, Lt, kt, Ye) {
            Lt.flowing && Lt.length === 0 && !Lt.sync ? (St.emit("data", kt), St.read(0)) : (Lt.length += Lt.objectMode ? 1 : kt.length, Ye ? Lt.buffer.unshift(kt) : Lt.buffer.push(kt), Lt.needReadable && Ce(St)), ut(St, Lt);
          }
          function ke(St, Lt) {
            var kt;
            return !k(Lt) && typeof Lt != "string" && Lt !== void 0 && !St.objectMode && (kt = new TypeError("Invalid non-string/buffer chunk")), kt;
          }
          function ge(St) {
            return !St.ended && (St.needReadable || St.length < St.highWaterMark || St.length === 0);
          }
          te.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, te.prototype.setEncoding = function(St) {
            return T || (T = Q("string_decoder/").StringDecoder), this._readableState.decoder = new T(St), this._readableState.encoding = St, this;
          };
          var Ve = 8388608;
          function Oe(St) {
            return St >= Ve ? St = Ve : (St--, St |= St >>> 1, St |= St >>> 2, St |= St >>> 4, St |= St >>> 8, St |= St >>> 16, St++), St;
          }
          function Ue(St, Lt) {
            return St <= 0 || Lt.length === 0 && Lt.ended ? 0 : Lt.objectMode ? 1 : St !== St ? Lt.flowing && Lt.length ? Lt.buffer.head.data.length : Lt.length : (St > Lt.highWaterMark && (Lt.highWaterMark = Oe(St)), St <= Lt.length ? St : Lt.ended ? Lt.length : (Lt.needReadable = !0, 0));
          }
          te.prototype.read = function(St) {
            S("read", St), St = parseInt(St, 10);
            var Lt = this._readableState, kt = St;
            if (St !== 0 && (Lt.emittedReadable = !1), St === 0 && Lt.needReadable && (Lt.length >= Lt.highWaterMark || Lt.ended))
              return S("read: emitReadable", Lt.length, Lt.ended), Lt.length === 0 && Lt.ended ? wi(this) : Ce(this), null;
            if (St = Ue(St, Lt), St === 0 && Lt.ended)
              return Lt.length === 0 && wi(this), null;
            var Ye = Lt.needReadable;
            S("need readable", Ye), (Lt.length === 0 || Lt.length - St < Lt.highWaterMark) && (Ye = !0, S("length less than watermark", Ye)), Lt.ended || Lt.reading ? (Ye = !1, S("reading or ended", Ye)) : Ye && (S("do read"), Lt.reading = !0, Lt.sync = !0, Lt.length === 0 && (Lt.needReadable = !0), this._read(Lt.highWaterMark), Lt.sync = !1, Lt.reading || (St = Ue(kt, Lt)));
            var De;
            return St > 0 ? De = Ht(St, Lt) : De = null, De === null ? (Lt.needReadable = !0, St = 0) : Lt.length -= St, Lt.length === 0 && (Lt.ended || (Lt.needReadable = !0), kt !== St && Lt.ended && wi(this)), De !== null && this.emit("data", De), De;
          };
          function we(St, Lt) {
            if (!Lt.ended) {
              if (Lt.decoder) {
                var kt = Lt.decoder.end();
                kt && kt.length && (Lt.buffer.push(kt), Lt.length += Lt.objectMode ? 1 : kt.length);
              }
              Lt.ended = !0, Ce(St);
            }
          }
          function Ce(St) {
            var Lt = St._readableState;
            Lt.needReadable = !1, Lt.emittedReadable || (S("emitReadable", Lt.flowing), Lt.emittedReadable = !0, Lt.sync ? N.nextTick(it, St) : it(St));
          }
          function it(St) {
            S("emit readable"), St.emit("readable"), wt(St);
          }
          function ut(St, Lt) {
            Lt.readingMore || (Lt.readingMore = !0, N.nextTick(bt, St, Lt));
          }
          function bt(St, Lt) {
            for (var kt = Lt.length; !Lt.reading && !Lt.flowing && !Lt.ended && Lt.length < Lt.highWaterMark && (S("maybeReadMore read 0"), St.read(0), kt !== Lt.length); )
              kt = Lt.length;
            Lt.readingMore = !1;
          }
          te.prototype._read = function(St) {
            this.emit("error", new Error("_read() is not implemented"));
          }, te.prototype.pipe = function(St, Lt) {
            var kt = this, Ye = this._readableState;
            switch (Ye.pipesCount) {
              case 0:
                Ye.pipes = St;
                break;
              case 1:
                Ye.pipes = [Ye.pipes, St];
                break;
              default:
                Ye.pipes.push(St);
                break;
            }
            Ye.pipesCount += 1, S("pipe count=%d opts=%j", Ye.pipesCount, Lt);
            var De = (!Lt || Lt.end !== !1) && St !== ie.stdout && St !== ie.stderr, Re = De ? et : ue;
            Ye.endEmitted ? N.nextTick(Re) : kt.once("end", Re), St.on("unpipe", _t);
            function _t(Te, ye) {
              S("onunpipe"), Te === kt && ye && ye.hasUnpiped === !1 && (ye.hasUnpiped = !0, xt());
            }
            function et() {
              S("onend"), St.end();
            }
            var Ie = pt(kt);
            St.on("drain", Ie);
            var pe = !1;
            function xt() {
              S("cleanup"), St.removeListener("close", X), St.removeListener("finish", ne), St.removeListener("drain", Ie), St.removeListener("error", I), St.removeListener("unpipe", _t), kt.removeListener("end", et), kt.removeListener("end", ue), kt.removeListener("data", _), pe = !0, Ye.awaitDrain && (!St._writableState || St._writableState.needDrain) && Ie();
            }
            var l = !1;
            kt.on("data", _);
            function _(Te) {
              S("ondata"), l = !1;
              var ye = St.write(Te);
              ye === !1 && !l && ((Ye.pipesCount === 1 && Ye.pipes === St || Ye.pipesCount > 1 && At(Ye.pipes, St) !== -1) && !pe && (S("false write response, pause", kt._readableState.awaitDrain), kt._readableState.awaitDrain++, l = !0), kt.pause());
            }
            function I(Te) {
              S("onerror", Te), ue(), St.removeListener("error", I), A(St, "error") === 0 && St.emit("error", Te);
            }
            J(St, "error", I);
            function X() {
              St.removeListener("finish", ne), ue();
            }
            St.once("close", X);
            function ne() {
              S("onfinish"), St.removeListener("close", X), ue();
            }
            St.once("finish", ne);
            function ue() {
              S("unpipe"), kt.unpipe(St);
            }
            return St.emit("pipe", kt), Ye.flowing || (S("pipe resume"), kt.resume()), St;
          };
          function pt(St) {
            return function() {
              var Lt = St._readableState;
              S("pipeOnDrain", Lt.awaitDrain), Lt.awaitDrain && Lt.awaitDrain--, Lt.awaitDrain === 0 && A(St, "data") && (Lt.flowing = !0, wt(St));
            };
          }
          te.prototype.unpipe = function(St) {
            var Lt = this._readableState, kt = { hasUnpiped: !1 };
            if (Lt.pipesCount === 0) return this;
            if (Lt.pipesCount === 1)
              return St && St !== Lt.pipes ? this : (St || (St = Lt.pipes), Lt.pipes = null, Lt.pipesCount = 0, Lt.flowing = !1, St && St.emit("unpipe", this, kt), this);
            if (!St) {
              var Ye = Lt.pipes, De = Lt.pipesCount;
              Lt.pipes = null, Lt.pipesCount = 0, Lt.flowing = !1;
              for (var Re = 0; Re < De; Re++)
                Ye[Re].emit("unpipe", this, kt);
              return this;
            }
            var _t = At(Lt.pipes, St);
            return _t === -1 ? this : (Lt.pipes.splice(_t, 1), Lt.pipesCount -= 1, Lt.pipesCount === 1 && (Lt.pipes = Lt.pipes[0]), St.emit("unpipe", this, kt), this);
          }, te.prototype.on = function(St, Lt) {
            var kt = M.prototype.on.call(this, St, Lt);
            if (St === "data")
              this._readableState.flowing !== !1 && this.resume();
            else if (St === "readable") {
              var Ye = this._readableState;
              !Ye.endEmitted && !Ye.readableListening && (Ye.readableListening = Ye.needReadable = !0, Ye.emittedReadable = !1, Ye.reading ? Ye.length && Ce(this) : N.nextTick(Ke, this));
            }
            return kt;
          }, te.prototype.addListener = te.prototype.on;
          function Ke(St) {
            S("readable nexttick read 0"), St.read(0);
          }
          te.prototype.resume = function() {
            var St = this._readableState;
            return St.flowing || (S("resume"), St.flowing = !0, dt(this, St)), this;
          };
          function dt(St, Lt) {
            Lt.resumeScheduled || (Lt.resumeScheduled = !0, N.nextTick(ct, St, Lt));
          }
          function ct(St, Lt) {
            Lt.reading || (S("resume read 0"), St.read(0)), Lt.resumeScheduled = !1, Lt.awaitDrain = 0, St.emit("resume"), wt(St), Lt.flowing && !Lt.reading && St.read(0);
          }
          te.prototype.pause = function() {
            return S("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (S("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
          };
          function wt(St) {
            var Lt = St._readableState;
            for (S("flow", Lt.flowing); Lt.flowing && St.read() !== null; )
              ;
          }
          te.prototype.wrap = function(St) {
            var Lt = this, kt = this._readableState, Ye = !1;
            St.on("end", function() {
              if (S("wrapped end"), kt.decoder && !kt.ended) {
                var _t = kt.decoder.end();
                _t && _t.length && Lt.push(_t);
              }
              Lt.push(null);
            }), St.on("data", function(_t) {
              if (S("wrapped data"), kt.decoder && (_t = kt.decoder.write(_t)), !(kt.objectMode && _t == null) && !(!kt.objectMode && (!_t || !_t.length))) {
                var et = Lt.push(_t);
                et || (Ye = !0, St.pause());
              }
            });
            for (var De in St)
              this[De] === void 0 && typeof St[De] == "function" && (this[De] = /* @__PURE__ */ function(_t) {
                return function() {
                  return St[_t].apply(St, arguments);
                };
              }(De));
            for (var Re = 0; Re < W.length; Re++)
              St.on(W[Re], this.emit.bind(this, W[Re]));
            return this._read = function(_t) {
              S("wrapped _read", _t), Ye && (Ye = !1, St.resume());
            }, this;
          }, Object.defineProperty(te.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.highWaterMark;
            }
          }), te._fromList = Ht;
          function Ht(St, Lt) {
            if (Lt.length === 0) return null;
            var kt;
            return Lt.objectMode ? kt = Lt.buffer.shift() : !St || St >= Lt.length ? (Lt.decoder ? kt = Lt.buffer.join("") : Lt.buffer.length === 1 ? kt = Lt.buffer.head.data : kt = Lt.buffer.concat(Lt.length), Lt.buffer.clear()) : kt = $t(St, Lt.buffer, Lt.decoder), kt;
          }
          function $t(St, Lt, kt) {
            var Ye;
            return St < Lt.head.data.length ? (Ye = Lt.head.data.slice(0, St), Lt.head.data = Lt.head.data.slice(St)) : St === Lt.head.data.length ? Ye = Lt.shift() : Ye = kt ? rt(St, Lt) : ri(St, Lt), Ye;
          }
          function rt(St, Lt) {
            var kt = Lt.head, Ye = 1, De = kt.data;
            for (St -= De.length; kt = kt.next; ) {
              var Re = kt.data, _t = St > Re.length ? Re.length : St;
              if (_t === Re.length ? De += Re : De += Re.slice(0, St), St -= _t, St === 0) {
                _t === Re.length ? (++Ye, kt.next ? Lt.head = kt.next : Lt.head = Lt.tail = null) : (Lt.head = kt, kt.data = Re.slice(_t));
                break;
              }
              ++Ye;
            }
            return Lt.length -= Ye, De;
          }
          function ri(St, Lt) {
            var kt = x.allocUnsafe(St), Ye = Lt.head, De = 1;
            for (Ye.data.copy(kt), St -= Ye.data.length; Ye = Ye.next; ) {
              var Re = Ye.data, _t = St > Re.length ? Re.length : St;
              if (Re.copy(kt, kt.length - St, 0, _t), St -= _t, St === 0) {
                _t === Re.length ? (++De, Ye.next ? Lt.head = Ye.next : Lt.head = Lt.tail = null) : (Lt.head = Ye, Ye.data = Re.slice(_t));
                break;
              }
              ++De;
            }
            return Lt.length -= De, kt;
          }
          function wi(St) {
            var Lt = St._readableState;
            if (Lt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
            Lt.endEmitted || (Lt.ended = !0, N.nextTick(Qt, Lt, St));
          }
          function Qt(St, Lt) {
            !St.endEmitted && St.length === 0 && (St.endEmitted = !0, Lt.readable = !1, Lt.emit("end"));
          }
          function At(St, Lt) {
            for (var kt = 0, Ye = St.length; kt < Ye; kt++)
              if (St[kt] === Lt) return kt;
            return -1;
          }
        }).call(this, Q("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {});
      }, { "./_stream_duplex": 139, "./internal/streams/BufferList": 144, "./internal/streams/destroy": 145, "./internal/streams/stream": 146, _process: 133, "core-util-is": 51, events: 52, inherits: 75, isarray: 79, "process-nextick-args": 132, "safe-buffer": 147, "string_decoder/": 148, util: 33 }], 142: [function(Q, de, q) {
        de.exports = Z;
        var ie = Q("./_stream_duplex"), i = Q("core-util-is");
        i.inherits = Q("inherits"), i.inherits(Z, ie);
        function N(M, x) {
          var m = this._transformState;
          m.transforming = !1;
          var w = m.writecb;
          if (!w)
            return this.emit("error", new Error("write callback called multiple times"));
          m.writechunk = null, m.writecb = null, x != null && this.push(x), w(M);
          var k = this._readableState;
          k.reading = !1, (k.needReadable || k.length < k.highWaterMark) && this._read(k.highWaterMark);
        }
        function Z(M) {
          if (!(this instanceof Z)) return new Z(M);
          ie.call(this, M), this._transformState = {
            afterTransform: N.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }, this._readableState.needReadable = !0, this._readableState.sync = !1, M && (typeof M.transform == "function" && (this._transform = M.transform), typeof M.flush == "function" && (this._flush = M.flush)), this.on("prefinish", R);
        }
        function R() {
          var M = this;
          typeof this._flush == "function" ? this._flush(function(x, m) {
            A(M, x, m);
          }) : A(this, null, null);
        }
        Z.prototype.push = function(M, x) {
          return this._transformState.needTransform = !1, ie.prototype.push.call(this, M, x);
        }, Z.prototype._transform = function(M, x, m) {
          throw new Error("_transform() is not implemented");
        }, Z.prototype._write = function(M, x, m) {
          var w = this._transformState;
          if (w.writecb = m, w.writechunk = M, w.writeencoding = x, !w.transforming) {
            var k = this._readableState;
            (w.needTransform || k.needReadable || k.length < k.highWaterMark) && this._read(k.highWaterMark);
          }
        }, Z.prototype._read = function(M) {
          var x = this._transformState;
          x.writechunk !== null && x.writecb && !x.transforming ? (x.transforming = !0, this._transform(x.writechunk, x.writeencoding, x.afterTransform)) : x.needTransform = !0;
        }, Z.prototype._destroy = function(M, x) {
          var m = this;
          ie.prototype._destroy.call(this, M, function(w) {
            x(w), m.emit("close");
          });
        };
        function A(M, x, m) {
          if (x) return M.emit("error", x);
          if (m != null && M.push(m), M._writableState.length) throw new Error("Calling transform done when ws.length != 0");
          if (M._transformState.transforming) throw new Error("Calling transform done when still transforming");
          return M.push(null);
        }
      }, { "./_stream_duplex": 139, "core-util-is": 51, inherits: 75 }], 143: [function(Q, de, q) {
        (function(ie, i, N) {
          var Z = Q("process-nextick-args");
          de.exports = J;
          function R(ct) {
            var wt = this;
            this.next = null, this.entry = null, this.finish = function() {
              dt(wt, ct);
            };
          }
          var A = !ie.browser && ["v0.10", "v0.9."].indexOf(ie.version.slice(0, 5)) > -1 ? N : Z.nextTick, M;
          J.WritableState = T;
          var x = Q("core-util-is");
          x.inherits = Q("inherits");
          var m = {
            deprecate: Q("util-deprecate")
          }, w = Q("./internal/streams/stream"), k = Q("safe-buffer").Buffer, E = i.Uint8Array || function() {
          };
          function P(ct) {
            return k.from(ct);
          }
          function S(ct) {
            return k.isBuffer(ct) || ct instanceof E;
          }
          var U = Q("./internal/streams/destroy");
          x.inherits(J, w);
          function j() {
          }
          function T(ct, wt) {
            M = M || Q("./_stream_duplex"), ct = ct || {};
            var Ht = wt instanceof M;
            this.objectMode = !!ct.objectMode, Ht && (this.objectMode = this.objectMode || !!ct.writableObjectMode);
            var $t = ct.highWaterMark, rt = ct.writableHighWaterMark, ri = this.objectMode ? 16 : 16 * 1024;
            $t || $t === 0 ? this.highWaterMark = $t : Ht && (rt || rt === 0) ? this.highWaterMark = rt : this.highWaterMark = ri, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var wi = ct.decodeStrings === !1;
            this.decodeStrings = !wi, this.defaultEncoding = ct.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Qt) {
              Oe(wt, Qt);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new R(this);
          }
          T.prototype.getBuffer = function() {
            for (var wt = this.bufferedRequest, Ht = []; wt; )
              Ht.push(wt), wt = wt.next;
            return Ht;
          }, function() {
            try {
              Object.defineProperty(T.prototype, "buffer", {
                get: m.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch {
            }
          }();
          var W;
          typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (W = Function.prototype[Symbol.hasInstance], Object.defineProperty(J, Symbol.hasInstance, {
            value: function(ct) {
              return W.call(this, ct) ? !0 : this !== J ? !1 : ct && ct._writableState instanceof T;
            }
          })) : W = function(ct) {
            return ct instanceof this;
          };
          function J(ct) {
            if (M = M || Q("./_stream_duplex"), !W.call(J, this) && !(this instanceof M))
              return new J(ct);
            this._writableState = new T(ct, this), this.writable = !0, ct && (typeof ct.write == "function" && (this._write = ct.write), typeof ct.writev == "function" && (this._writev = ct.writev), typeof ct.destroy == "function" && (this._destroy = ct.destroy), typeof ct.final == "function" && (this._final = ct.final)), w.call(this);
          }
          J.prototype.pipe = function() {
            this.emit("error", new Error("Cannot pipe, not readable"));
          };
          function ee(ct, wt) {
            var Ht = new Error("write after end");
            ct.emit("error", Ht), Z.nextTick(wt, Ht);
          }
          function te(ct, wt, Ht, $t) {
            var rt = !0, ri = !1;
            return Ht === null ? ri = new TypeError("May not write null values to stream") : typeof Ht != "string" && Ht !== void 0 && !wt.objectMode && (ri = new TypeError("Invalid non-string/buffer chunk")), ri && (ct.emit("error", ri), Z.nextTick($t, ri), rt = !1), rt;
          }
          J.prototype.write = function(ct, wt, Ht) {
            var $t = this._writableState, rt = !1, ri = !$t.objectMode && S(ct);
            return ri && !k.isBuffer(ct) && (ct = P(ct)), typeof wt == "function" && (Ht = wt, wt = null), ri ? wt = "buffer" : wt || (wt = $t.defaultEncoding), typeof Ht != "function" && (Ht = j), $t.ended ? ee(this, Ht) : (ri || te(this, $t, ct, Ht)) && ($t.pendingcb++, rt = me(this, $t, ri, ct, wt, Ht)), rt;
          }, J.prototype.cork = function() {
            var ct = this._writableState;
            ct.corked++;
          }, J.prototype.uncork = function() {
            var ct = this._writableState;
            ct.corked && (ct.corked--, !ct.writing && !ct.corked && !ct.finished && !ct.bufferProcessing && ct.bufferedRequest && Ce(this, ct));
          }, J.prototype.setDefaultEncoding = function(wt) {
            if (typeof wt == "string" && (wt = wt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((wt + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + wt);
            return this._writableState.defaultEncoding = wt, this;
          };
          function le(ct, wt, Ht) {
            return !ct.objectMode && ct.decodeStrings !== !1 && typeof wt == "string" && (wt = k.from(wt, Ht)), wt;
          }
          Object.defineProperty(J.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.highWaterMark;
            }
          });
          function me(ct, wt, Ht, $t, rt, ri) {
            if (!Ht) {
              var wi = le(wt, $t, rt);
              $t !== wi && (Ht = !0, rt = "buffer", $t = wi);
            }
            var Qt = wt.objectMode ? 1 : $t.length;
            wt.length += Qt;
            var At = wt.length < wt.highWaterMark;
            if (At || (wt.needDrain = !0), wt.writing || wt.corked) {
              var St = wt.lastBufferedRequest;
              wt.lastBufferedRequest = {
                chunk: $t,
                encoding: rt,
                isBuf: Ht,
                callback: ri,
                next: null
              }, St ? St.next = wt.lastBufferedRequest : wt.bufferedRequest = wt.lastBufferedRequest, wt.bufferedRequestCount += 1;
            } else
              ke(ct, wt, !1, Qt, $t, rt, ri);
            return At;
          }
          function ke(ct, wt, Ht, $t, rt, ri, wi) {
            wt.writelen = $t, wt.writecb = wi, wt.writing = !0, wt.sync = !0, Ht ? ct._writev(rt, wt.onwrite) : ct._write(rt, ri, wt.onwrite), wt.sync = !1;
          }
          function ge(ct, wt, Ht, $t, rt) {
            --wt.pendingcb, Ht ? (Z.nextTick(rt, $t), Z.nextTick(pt, ct, wt), ct._writableState.errorEmitted = !0, ct.emit("error", $t)) : (rt($t), ct._writableState.errorEmitted = !0, ct.emit("error", $t), pt(ct, wt));
          }
          function Ve(ct) {
            ct.writing = !1, ct.writecb = null, ct.length -= ct.writelen, ct.writelen = 0;
          }
          function Oe(ct, wt) {
            var Ht = ct._writableState, $t = Ht.sync, rt = Ht.writecb;
            if (Ve(Ht), wt) ge(ct, Ht, $t, wt, rt);
            else {
              var ri = it(Ht);
              !ri && !Ht.corked && !Ht.bufferProcessing && Ht.bufferedRequest && Ce(ct, Ht), $t ? A(Ue, ct, Ht, ri, rt) : Ue(ct, Ht, ri, rt);
            }
          }
          function Ue(ct, wt, Ht, $t) {
            Ht || we(ct, wt), wt.pendingcb--, $t(), pt(ct, wt);
          }
          function we(ct, wt) {
            wt.length === 0 && wt.needDrain && (wt.needDrain = !1, ct.emit("drain"));
          }
          function Ce(ct, wt) {
            wt.bufferProcessing = !0;
            var Ht = wt.bufferedRequest;
            if (ct._writev && Ht && Ht.next) {
              var $t = wt.bufferedRequestCount, rt = new Array($t), ri = wt.corkedRequestsFree;
              ri.entry = Ht;
              for (var wi = 0, Qt = !0; Ht; )
                rt[wi] = Ht, Ht.isBuf || (Qt = !1), Ht = Ht.next, wi += 1;
              rt.allBuffers = Qt, ke(ct, wt, !0, wt.length, rt, "", ri.finish), wt.pendingcb++, wt.lastBufferedRequest = null, ri.next ? (wt.corkedRequestsFree = ri.next, ri.next = null) : wt.corkedRequestsFree = new R(wt), wt.bufferedRequestCount = 0;
            } else {
              for (; Ht; ) {
                var At = Ht.chunk, St = Ht.encoding, Lt = Ht.callback, kt = wt.objectMode ? 1 : At.length;
                if (ke(ct, wt, !1, kt, At, St, Lt), Ht = Ht.next, wt.bufferedRequestCount--, wt.writing)
                  break;
              }
              Ht === null && (wt.lastBufferedRequest = null);
            }
            wt.bufferedRequest = Ht, wt.bufferProcessing = !1;
          }
          J.prototype._write = function(ct, wt, Ht) {
            Ht(new Error("_write() is not implemented"));
          }, J.prototype._writev = null, J.prototype.end = function(ct, wt, Ht) {
            var $t = this._writableState;
            typeof ct == "function" ? (Ht = ct, ct = null, wt = null) : typeof wt == "function" && (Ht = wt, wt = null), ct != null && this.write(ct, wt), $t.corked && ($t.corked = 1, this.uncork()), !$t.ending && !$t.finished && Ke(this, $t, Ht);
          };
          function it(ct) {
            return ct.ending && ct.length === 0 && ct.bufferedRequest === null && !ct.finished && !ct.writing;
          }
          function ut(ct, wt) {
            ct._final(function(Ht) {
              wt.pendingcb--, Ht && ct.emit("error", Ht), wt.prefinished = !0, ct.emit("prefinish"), pt(ct, wt);
            });
          }
          function bt(ct, wt) {
            !wt.prefinished && !wt.finalCalled && (typeof ct._final == "function" ? (wt.pendingcb++, wt.finalCalled = !0, Z.nextTick(ut, ct, wt)) : (wt.prefinished = !0, ct.emit("prefinish")));
          }
          function pt(ct, wt) {
            var Ht = it(wt);
            return Ht && (bt(ct, wt), wt.pendingcb === 0 && (wt.finished = !0, ct.emit("finish"))), Ht;
          }
          function Ke(ct, wt, Ht) {
            wt.ending = !0, pt(ct, wt), Ht && (wt.finished ? Z.nextTick(Ht) : ct.once("finish", Ht)), wt.ended = !0, ct.writable = !1;
          }
          function dt(ct, wt, Ht) {
            var $t = ct.entry;
            for (ct.entry = null; $t; ) {
              var rt = $t.callback;
              wt.pendingcb--, rt(Ht), $t = $t.next;
            }
            wt.corkedRequestsFree ? wt.corkedRequestsFree.next = ct : wt.corkedRequestsFree = ct;
          }
          Object.defineProperty(J.prototype, "destroyed", {
            get: function() {
              return this._writableState === void 0 ? !1 : this._writableState.destroyed;
            },
            set: function(ct) {
              this._writableState && (this._writableState.destroyed = ct);
            }
          }), J.prototype.destroy = U.destroy, J.prototype._undestroy = U.undestroy, J.prototype._destroy = function(ct, wt) {
            this.end(), wt(ct);
          };
        }).call(this, Q("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {}, Q("timers").setImmediate);
      }, { "./_stream_duplex": 139, "./internal/streams/destroy": 145, "./internal/streams/stream": 146, _process: 133, "core-util-is": 51, inherits: 75, "process-nextick-args": 132, "safe-buffer": 147, timers: 176, "util-deprecate": 183 }], 144: [function(Q, de, q) {
        function ie(R, A) {
          if (!(R instanceof A))
            throw new TypeError("Cannot call a class as a function");
        }
        var i = Q("safe-buffer").Buffer, N = Q("util");
        function Z(R, A, M) {
          R.copy(A, M);
        }
        de.exports = function() {
          function R() {
            ie(this, R), this.head = null, this.tail = null, this.length = 0;
          }
          return R.prototype.push = function(M) {
            var x = { data: M, next: null };
            this.length > 0 ? this.tail.next = x : this.head = x, this.tail = x, ++this.length;
          }, R.prototype.unshift = function(M) {
            var x = { data: M, next: this.head };
            this.length === 0 && (this.tail = x), this.head = x, ++this.length;
          }, R.prototype.shift = function() {
            if (this.length !== 0) {
              var M = this.head.data;
              return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, M;
            }
          }, R.prototype.clear = function() {
            this.head = this.tail = null, this.length = 0;
          }, R.prototype.join = function(M) {
            if (this.length === 0) return "";
            for (var x = this.head, m = "" + x.data; x = x.next; )
              m += M + x.data;
            return m;
          }, R.prototype.concat = function(M) {
            if (this.length === 0) return i.alloc(0);
            if (this.length === 1) return this.head.data;
            for (var x = i.allocUnsafe(M >>> 0), m = this.head, w = 0; m; )
              Z(m.data, x, w), w += m.data.length, m = m.next;
            return x;
          }, R;
        }(), N && N.inspect && N.inspect.custom && (de.exports.prototype[N.inspect.custom] = function() {
          var R = N.inspect({ length: this.length });
          return this.constructor.name + " " + R;
        });
      }, { "safe-buffer": 147, util: 33 }], 145: [function(Q, de, q) {
        var ie = Q("process-nextick-args");
        function i(R, A) {
          var M = this, x = this._readableState && this._readableState.destroyed, m = this._writableState && this._writableState.destroyed;
          return x || m ? (A ? A(R) : R && (!this._writableState || !this._writableState.errorEmitted) && ie.nextTick(Z, this, R), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(R || null, function(w) {
            !A && w ? (ie.nextTick(Z, M, w), M._writableState && (M._writableState.errorEmitted = !0)) : A && A(w);
          }), this);
        }
        function N() {
          this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
        }
        function Z(R, A) {
          R.emit("error", A);
        }
        de.exports = {
          destroy: i,
          undestroy: N
        };
      }, { "process-nextick-args": 132 }], 146: [function(Q, de, q) {
        de.exports = Q("events").EventEmitter;
      }, { events: 52 }], 147: [function(Q, de, q) {
        var ie = Q("buffer"), i = ie.Buffer;
        function N(R, A) {
          for (var M in R)
            A[M] = R[M];
        }
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? de.exports = ie : (N(ie, q), q.Buffer = Z);
        function Z(R, A, M) {
          return i(R, A, M);
        }
        N(i, Z), Z.from = function(R, A, M) {
          if (typeof R == "number")
            throw new TypeError("Argument must not be a number");
          return i(R, A, M);
        }, Z.alloc = function(R, A, M) {
          if (typeof R != "number")
            throw new TypeError("Argument must be a number");
          var x = i(R);
          return A !== void 0 ? typeof M == "string" ? x.fill(A, M) : x.fill(A) : x.fill(0), x;
        }, Z.allocUnsafe = function(R) {
          if (typeof R != "number")
            throw new TypeError("Argument must be a number");
          return i(R);
        }, Z.allocUnsafeSlow = function(R) {
          if (typeof R != "number")
            throw new TypeError("Argument must be a number");
          return ie.SlowBuffer(R);
        };
      }, { buffer: 48 }], 148: [function(Q, de, q) {
        var ie = Q("safe-buffer").Buffer, i = ie.isEncoding || function(W) {
          switch (W = "" + W, W && W.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return !0;
            default:
              return !1;
          }
        };
        function N(W) {
          if (!W) return "utf8";
          for (var J; ; )
            switch (W) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return W;
              default:
                if (J) return;
                W = ("" + W).toLowerCase(), J = !0;
            }
        }
        function Z(W) {
          var J = N(W);
          if (typeof J != "string" && (ie.isEncoding === i || !i(W))) throw new Error("Unknown encoding: " + W);
          return J || W;
        }
        q.StringDecoder = R;
        function R(W) {
          this.encoding = Z(W);
          var J;
          switch (this.encoding) {
            case "utf16le":
              this.text = E, this.end = P, J = 4;
              break;
            case "utf8":
              this.fillLast = m, J = 4;
              break;
            case "base64":
              this.text = S, this.end = U, J = 3;
              break;
            default:
              this.write = j, this.end = T;
              return;
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = ie.allocUnsafe(J);
        }
        R.prototype.write = function(W) {
          if (W.length === 0) return "";
          var J, ee;
          if (this.lastNeed) {
            if (J = this.fillLast(W), J === void 0) return "";
            ee = this.lastNeed, this.lastNeed = 0;
          } else
            ee = 0;
          return ee < W.length ? J ? J + this.text(W, ee) : this.text(W, ee) : J || "";
        }, R.prototype.end = k, R.prototype.text = w, R.prototype.fillLast = function(W) {
          if (this.lastNeed <= W.length)
            return W.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          W.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, W.length), this.lastNeed -= W.length;
        };
        function A(W) {
          return W <= 127 ? 0 : W >> 5 === 6 ? 2 : W >> 4 === 14 ? 3 : W >> 3 === 30 ? 4 : W >> 6 === 2 ? -1 : -2;
        }
        function M(W, J, ee) {
          var te = J.length - 1;
          if (te < ee) return 0;
          var le = A(J[te]);
          return le >= 0 ? (le > 0 && (W.lastNeed = le - 1), le) : --te < ee || le === -2 ? 0 : (le = A(J[te]), le >= 0 ? (le > 0 && (W.lastNeed = le - 2), le) : --te < ee || le === -2 ? 0 : (le = A(J[te]), le >= 0 ? (le > 0 && (le === 2 ? le = 0 : W.lastNeed = le - 3), le) : 0));
        }
        function x(W, J, ee) {
          if ((J[0] & 192) !== 128)
            return W.lastNeed = 0, "";
          if (W.lastNeed > 1 && J.length > 1) {
            if ((J[1] & 192) !== 128)
              return W.lastNeed = 1, "";
            if (W.lastNeed > 2 && J.length > 2 && (J[2] & 192) !== 128)
              return W.lastNeed = 2, "";
          }
        }
        function m(W) {
          var J = this.lastTotal - this.lastNeed, ee = x(this, W);
          if (ee !== void 0) return ee;
          if (this.lastNeed <= W.length)
            return W.copy(this.lastChar, J, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          W.copy(this.lastChar, J, 0, W.length), this.lastNeed -= W.length;
        }
        function w(W, J) {
          var ee = M(this, W, J);
          if (!this.lastNeed) return W.toString("utf8", J);
          this.lastTotal = ee;
          var te = W.length - (ee - this.lastNeed);
          return W.copy(this.lastChar, 0, te), W.toString("utf8", J, te);
        }
        function k(W) {
          var J = W && W.length ? this.write(W) : "";
          return this.lastNeed ? J + "" : J;
        }
        function E(W, J) {
          if ((W.length - J) % 2 === 0) {
            var ee = W.toString("utf16le", J);
            if (ee) {
              var te = ee.charCodeAt(ee.length - 1);
              if (te >= 55296 && te <= 56319)
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = W[W.length - 2], this.lastChar[1] = W[W.length - 1], ee.slice(0, -1);
            }
            return ee;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = W[W.length - 1], W.toString("utf16le", J, W.length - 1);
        }
        function P(W) {
          var J = W && W.length ? this.write(W) : "";
          if (this.lastNeed) {
            var ee = this.lastTotal - this.lastNeed;
            return J + this.lastChar.toString("utf16le", 0, ee);
          }
          return J;
        }
        function S(W, J) {
          var ee = (W.length - J) % 3;
          return ee === 0 ? W.toString("base64", J) : (this.lastNeed = 3 - ee, this.lastTotal = 3, ee === 1 ? this.lastChar[0] = W[W.length - 1] : (this.lastChar[0] = W[W.length - 2], this.lastChar[1] = W[W.length - 1]), W.toString("base64", J, W.length - ee));
        }
        function U(W) {
          var J = W && W.length ? this.write(W) : "";
          return this.lastNeed ? J + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : J;
        }
        function j(W) {
          return W.toString(this.encoding);
        }
        function T(W) {
          return W && W.length ? this.write(W) : "";
        }
      }, { "safe-buffer": 147 }], 149: [function(Q, de, q) {
        de.exports = Q("./readable").PassThrough;
      }, { "./readable": 150 }], 150: [function(Q, de, q) {
        q = de.exports = Q("./lib/_stream_readable.js"), q.Stream = q, q.Readable = q, q.Writable = Q("./lib/_stream_writable.js"), q.Duplex = Q("./lib/_stream_duplex.js"), q.Transform = Q("./lib/_stream_transform.js"), q.PassThrough = Q("./lib/_stream_passthrough.js");
      }, { "./lib/_stream_duplex.js": 139, "./lib/_stream_passthrough.js": 140, "./lib/_stream_readable.js": 141, "./lib/_stream_transform.js": 142, "./lib/_stream_writable.js": 143 }], 151: [function(Q, de, q) {
        de.exports = Q("./readable").Transform;
      }, { "./readable": 150 }], 152: [function(Q, de, q) {
        de.exports = Q("./lib/_stream_writable.js");
      }, { "./lib/_stream_writable.js": 143 }], 153: [function(Q, de, q) {
        var ie = function(i) {
          var N = Object.prototype, Z = N.hasOwnProperty, R, A = typeof Symbol == "function" ? Symbol : {}, M = A.iterator || "@@iterator", x = A.asyncIterator || "@@asyncIterator", m = A.toStringTag || "@@toStringTag";
          function w(bt, pt, Ke, dt) {
            var ct = pt && pt.prototype instanceof T ? pt : T, wt = Object.create(ct.prototype), Ht = new Ce(dt || []);
            return wt._invoke = Ve(bt, Ke, Ht), wt;
          }
          i.wrap = w;
          function k(bt, pt, Ke) {
            try {
              return { type: "normal", arg: bt.call(pt, Ke) };
            } catch (dt) {
              return { type: "throw", arg: dt };
            }
          }
          var E = "suspendedStart", P = "suspendedYield", S = "executing", U = "completed", j = {};
          function T() {
          }
          function W() {
          }
          function J() {
          }
          var ee = {};
          ee[M] = function() {
            return this;
          };
          var te = Object.getPrototypeOf, le = te && te(te(it([])));
          le && le !== N && Z.call(le, M) && (ee = le);
          var me = J.prototype = T.prototype = Object.create(ee);
          W.prototype = me.constructor = J, J.constructor = W, J[m] = W.displayName = "GeneratorFunction";
          function ke(bt) {
            ["next", "throw", "return"].forEach(function(pt) {
              bt[pt] = function(Ke) {
                return this._invoke(pt, Ke);
              };
            });
          }
          i.isGeneratorFunction = function(bt) {
            var pt = typeof bt == "function" && bt.constructor;
            return pt ? pt === W || // For the native GeneratorFunction constructor, the best we can
            // do is to check its .name property.
            (pt.displayName || pt.name) === "GeneratorFunction" : !1;
          }, i.mark = function(bt) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(bt, J) : (bt.__proto__ = J, m in bt || (bt[m] = "GeneratorFunction")), bt.prototype = Object.create(me), bt;
          }, i.awrap = function(bt) {
            return { __await: bt };
          };
          function ge(bt) {
            function pt(ct, wt, Ht, $t) {
              var rt = k(bt[ct], bt, wt);
              if (rt.type === "throw")
                $t(rt.arg);
              else {
                var ri = rt.arg, wi = ri.value;
                return wi && typeof wi == "object" && Z.call(wi, "__await") ? Promise.resolve(wi.__await).then(function(Qt) {
                  pt("next", Qt, Ht, $t);
                }, function(Qt) {
                  pt("throw", Qt, Ht, $t);
                }) : Promise.resolve(wi).then(function(Qt) {
                  ri.value = Qt, Ht(ri);
                }, function(Qt) {
                  return pt("throw", Qt, Ht, $t);
                });
              }
            }
            var Ke;
            function dt(ct, wt) {
              function Ht() {
                return new Promise(function($t, rt) {
                  pt(ct, wt, $t, rt);
                });
              }
              return Ke = // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              Ke ? Ke.then(
                Ht,
                // Avoid propagating failures to Promises returned by later
                // invocations of the iterator.
                Ht
              ) : Ht();
            }
            this._invoke = dt;
          }
          ke(ge.prototype), ge.prototype[x] = function() {
            return this;
          }, i.AsyncIterator = ge, i.async = function(bt, pt, Ke, dt) {
            var ct = new ge(
              w(bt, pt, Ke, dt)
            );
            return i.isGeneratorFunction(pt) ? ct : ct.next().then(function(wt) {
              return wt.done ? wt.value : ct.next();
            });
          };
          function Ve(bt, pt, Ke) {
            var dt = E;
            return function(wt, Ht) {
              if (dt === S)
                throw new Error("Generator is already running");
              if (dt === U) {
                if (wt === "throw")
                  throw Ht;
                return ut();
              }
              for (Ke.method = wt, Ke.arg = Ht; ; ) {
                var $t = Ke.delegate;
                if ($t) {
                  var rt = Oe($t, Ke);
                  if (rt) {
                    if (rt === j) continue;
                    return rt;
                  }
                }
                if (Ke.method === "next")
                  Ke.sent = Ke._sent = Ke.arg;
                else if (Ke.method === "throw") {
                  if (dt === E)
                    throw dt = U, Ke.arg;
                  Ke.dispatchException(Ke.arg);
                } else Ke.method === "return" && Ke.abrupt("return", Ke.arg);
                dt = S;
                var ri = k(bt, pt, Ke);
                if (ri.type === "normal") {
                  if (dt = Ke.done ? U : P, ri.arg === j)
                    continue;
                  return {
                    value: ri.arg,
                    done: Ke.done
                  };
                } else ri.type === "throw" && (dt = U, Ke.method = "throw", Ke.arg = ri.arg);
              }
            };
          }
          function Oe(bt, pt) {
            var Ke = bt.iterator[pt.method];
            if (Ke === R) {
              if (pt.delegate = null, pt.method === "throw") {
                if (bt.iterator.return && (pt.method = "return", pt.arg = R, Oe(bt, pt), pt.method === "throw"))
                  return j;
                pt.method = "throw", pt.arg = new TypeError(
                  "The iterator does not provide a 'throw' method"
                );
              }
              return j;
            }
            var dt = k(Ke, bt.iterator, pt.arg);
            if (dt.type === "throw")
              return pt.method = "throw", pt.arg = dt.arg, pt.delegate = null, j;
            var ct = dt.arg;
            if (!ct)
              return pt.method = "throw", pt.arg = new TypeError("iterator result is not an object"), pt.delegate = null, j;
            if (ct.done)
              pt[bt.resultName] = ct.value, pt.next = bt.nextLoc, pt.method !== "return" && (pt.method = "next", pt.arg = R);
            else
              return ct;
            return pt.delegate = null, j;
          }
          ke(me), me[m] = "Generator", me[M] = function() {
            return this;
          }, me.toString = function() {
            return "[object Generator]";
          };
          function Ue(bt) {
            var pt = { tryLoc: bt[0] };
            1 in bt && (pt.catchLoc = bt[1]), 2 in bt && (pt.finallyLoc = bt[2], pt.afterLoc = bt[3]), this.tryEntries.push(pt);
          }
          function we(bt) {
            var pt = bt.completion || {};
            pt.type = "normal", delete pt.arg, bt.completion = pt;
          }
          function Ce(bt) {
            this.tryEntries = [{ tryLoc: "root" }], bt.forEach(Ue, this), this.reset(!0);
          }
          i.keys = function(bt) {
            var pt = [];
            for (var Ke in bt)
              pt.push(Ke);
            return pt.reverse(), function dt() {
              for (; pt.length; ) {
                var ct = pt.pop();
                if (ct in bt)
                  return dt.value = ct, dt.done = !1, dt;
              }
              return dt.done = !0, dt;
            };
          };
          function it(bt) {
            if (bt) {
              var pt = bt[M];
              if (pt)
                return pt.call(bt);
              if (typeof bt.next == "function")
                return bt;
              if (!isNaN(bt.length)) {
                var Ke = -1, dt = function ct() {
                  for (; ++Ke < bt.length; )
                    if (Z.call(bt, Ke))
                      return ct.value = bt[Ke], ct.done = !1, ct;
                  return ct.value = R, ct.done = !0, ct;
                };
                return dt.next = dt;
              }
            }
            return { next: ut };
          }
          i.values = it;
          function ut() {
            return { value: R, done: !0 };
          }
          return Ce.prototype = {
            constructor: Ce,
            reset: function(bt) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = R, this.done = !1, this.delegate = null, this.method = "next", this.arg = R, this.tryEntries.forEach(we), !bt)
                for (var pt in this)
                  pt.charAt(0) === "t" && Z.call(this, pt) && !isNaN(+pt.slice(1)) && (this[pt] = R);
            },
            stop: function() {
              this.done = !0;
              var bt = this.tryEntries[0], pt = bt.completion;
              if (pt.type === "throw")
                throw pt.arg;
              return this.rval;
            },
            dispatchException: function(bt) {
              if (this.done)
                throw bt;
              var pt = this;
              function Ke(rt, ri) {
                return wt.type = "throw", wt.arg = bt, pt.next = rt, ri && (pt.method = "next", pt.arg = R), !!ri;
              }
              for (var dt = this.tryEntries.length - 1; dt >= 0; --dt) {
                var ct = this.tryEntries[dt], wt = ct.completion;
                if (ct.tryLoc === "root")
                  return Ke("end");
                if (ct.tryLoc <= this.prev) {
                  var Ht = Z.call(ct, "catchLoc"), $t = Z.call(ct, "finallyLoc");
                  if (Ht && $t) {
                    if (this.prev < ct.catchLoc)
                      return Ke(ct.catchLoc, !0);
                    if (this.prev < ct.finallyLoc)
                      return Ke(ct.finallyLoc);
                  } else if (Ht) {
                    if (this.prev < ct.catchLoc)
                      return Ke(ct.catchLoc, !0);
                  } else if ($t) {
                    if (this.prev < ct.finallyLoc)
                      return Ke(ct.finallyLoc);
                  } else
                    throw new Error("try statement without catch or finally");
                }
              }
            },
            abrupt: function(bt, pt) {
              for (var Ke = this.tryEntries.length - 1; Ke >= 0; --Ke) {
                var dt = this.tryEntries[Ke];
                if (dt.tryLoc <= this.prev && Z.call(dt, "finallyLoc") && this.prev < dt.finallyLoc) {
                  var ct = dt;
                  break;
                }
              }
              ct && (bt === "break" || bt === "continue") && ct.tryLoc <= pt && pt <= ct.finallyLoc && (ct = null);
              var wt = ct ? ct.completion : {};
              return wt.type = bt, wt.arg = pt, ct ? (this.method = "next", this.next = ct.finallyLoc, j) : this.complete(wt);
            },
            complete: function(bt, pt) {
              if (bt.type === "throw")
                throw bt.arg;
              return bt.type === "break" || bt.type === "continue" ? this.next = bt.arg : bt.type === "return" ? (this.rval = this.arg = bt.arg, this.method = "return", this.next = "end") : bt.type === "normal" && pt && (this.next = pt), j;
            },
            finish: function(bt) {
              for (var pt = this.tryEntries.length - 1; pt >= 0; --pt) {
                var Ke = this.tryEntries[pt];
                if (Ke.finallyLoc === bt)
                  return this.complete(Ke.completion, Ke.afterLoc), we(Ke), j;
              }
            },
            catch: function(bt) {
              for (var pt = this.tryEntries.length - 1; pt >= 0; --pt) {
                var Ke = this.tryEntries[pt];
                if (Ke.tryLoc === bt) {
                  var dt = Ke.completion;
                  if (dt.type === "throw") {
                    var ct = dt.arg;
                    we(Ke);
                  }
                  return ct;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function(bt, pt, Ke) {
              return this.delegate = {
                iterator: it(bt),
                resultName: pt,
                nextLoc: Ke
              }, this.method === "next" && (this.arg = R), j;
            }
          }, i;
        }(
          // If this script is executing as a CommonJS module, use module.exports
          // as the regeneratorRuntime namespace. Otherwise create a new empty
          // object. Either way, the resulting object will be used to initialize
          // the regeneratorRuntime variable at the top of this file.
          typeof de == "object" ? de.exports : {}
        );
        try {
          regeneratorRuntime = ie;
        } catch {
          Function("r", "regeneratorRuntime = r")(ie);
        }
      }, {}], 154: [function(Q, de, q) {
        var ie = Q("buffer"), i = ie.Buffer;
        function N(R, A) {
          for (var M in R)
            A[M] = R[M];
        }
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? de.exports = ie : (N(ie, q), q.Buffer = Z);
        function Z(R, A, M) {
          return i(R, A, M);
        }
        Z.prototype = Object.create(i.prototype), N(i, Z), Z.from = function(R, A, M) {
          if (typeof R == "number")
            throw new TypeError("Argument must not be a number");
          return i(R, A, M);
        }, Z.alloc = function(R, A, M) {
          if (typeof R != "number")
            throw new TypeError("Argument must be a number");
          var x = i(R);
          return A !== void 0 ? typeof M == "string" ? x.fill(A, M) : x.fill(A) : x.fill(0), x;
        }, Z.allocUnsafe = function(R) {
          if (typeof R != "number")
            throw new TypeError("Argument must be a number");
          return i(R);
        }, Z.allocUnsafeSlow = function(R) {
          if (typeof R != "number")
            throw new TypeError("Argument must be a number");
          return ie.SlowBuffer(R);
        };
      }, { buffer: 48 }], 155: [function(Q, de, q) {
        de.exports = N;
        var ie = Q("events").EventEmitter, i = Q("inherits");
        i(N, ie), N.Readable = Q("readable-stream/readable.js"), N.Writable = Q("readable-stream/writable.js"), N.Duplex = Q("readable-stream/duplex.js"), N.Transform = Q("readable-stream/transform.js"), N.PassThrough = Q("readable-stream/passthrough.js"), N.Stream = N;
        function N() {
          ie.call(this);
        }
        N.prototype.pipe = function(Z, R) {
          var A = this;
          function M(S) {
            Z.writable && Z.write(S) === !1 && A.pause && A.pause();
          }
          A.on("data", M);
          function x() {
            A.readable && A.resume && A.resume();
          }
          Z.on("drain", x), !Z._isStdio && (!R || R.end !== !1) && (A.on("end", w), A.on("close", k));
          var m = !1;
          function w() {
            m || (m = !0, Z.end());
          }
          function k() {
            m || (m = !0, typeof Z.destroy == "function" && Z.destroy());
          }
          function E(S) {
            if (P(), ie.listenerCount(this, "error") === 0)
              throw S;
          }
          A.on("error", E), Z.on("error", E);
          function P() {
            A.removeListener("data", M), Z.removeListener("drain", x), A.removeListener("end", w), A.removeListener("close", k), A.removeListener("error", E), Z.removeListener("error", E), A.removeListener("end", P), A.removeListener("close", P), Z.removeListener("close", P);
          }
          return A.on("end", P), A.on("close", P), Z.on("close", P), Z.emit("pipe", A), Z;
        };
      }, { events: 52, inherits: 75, "readable-stream/duplex.js": 138, "readable-stream/passthrough.js": 149, "readable-stream/readable.js": 150, "readable-stream/transform.js": 151, "readable-stream/writable.js": 152 }], 156: [function(Q, de, q) {
        (function(ie) {
          var i = Q("./lib/request"), N = Q("./lib/response"), Z = Q("xtend"), R = Q("builtin-status-codes"), A = Q("url"), M = q;
          M.request = function(x, m) {
            typeof x == "string" ? x = A.parse(x) : x = Z(x);
            var w = ie.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", k = x.protocol || w, E = x.hostname || x.host, P = x.port, S = x.path || "/";
            E && E.indexOf(":") !== -1 && (E = "[" + E + "]"), x.url = (E ? k + "//" + E : "") + (P ? ":" + P : "") + S, x.method = (x.method || "GET").toUpperCase(), x.headers = x.headers || {};
            var U = new i(x);
            return m && U.on("response", m), U;
          }, M.get = function(m, w) {
            var k = M.request(m, w);
            return k.end(), k;
          }, M.ClientRequest = i, M.IncomingMessage = N.IncomingMessage, M.Agent = function() {
          }, M.Agent.defaultMaxSockets = 4, M.globalAgent = new M.Agent(), M.STATUS_CODES = R, M.METHODS = [
            "CHECKOUT",
            "CONNECT",
            "COPY",
            "DELETE",
            "GET",
            "HEAD",
            "LOCK",
            "M-SEARCH",
            "MERGE",
            "MKACTIVITY",
            "MKCOL",
            "MOVE",
            "NOTIFY",
            "OPTIONS",
            "PATCH",
            "POST",
            "PROPFIND",
            "PROPPATCH",
            "PURGE",
            "PUT",
            "REPORT",
            "SEARCH",
            "SUBSCRIBE",
            "TRACE",
            "UNLOCK",
            "UNSUBSCRIBE"
          ];
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {});
      }, { "./lib/request": 158, "./lib/response": 159, "builtin-status-codes": 50, url: 180, xtend: 189 }], 157: [function(Q, de, q) {
        (function(ie) {
          q.fetch = R(ie.fetch) && R(ie.ReadableStream), q.writableStream = R(ie.WritableStream), q.abortController = R(ie.AbortController);
          var i;
          function N() {
            if (i !== void 0) return i;
            if (ie.XMLHttpRequest) {
              i = new ie.XMLHttpRequest();
              try {
                i.open("GET", ie.XDomainRequest ? "/" : "https://example.com");
              } catch {
                i = null;
              }
            } else
              i = null;
            return i;
          }
          function Z(A) {
            var M = N();
            if (!M) return !1;
            try {
              return M.responseType = A, M.responseType === A;
            } catch {
            }
            return !1;
          }
          q.arraybuffer = q.fetch || Z("arraybuffer"), q.msstream = !q.fetch && Z("ms-stream"), q.mozchunkedarraybuffer = !q.fetch && Z("moz-chunked-arraybuffer"), q.overrideMimeType = q.fetch || (N() ? R(N().overrideMimeType) : !1);
          function R(A) {
            return typeof A == "function";
          }
          i = null;
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {});
      }, {}], 158: [function(Q, de, q) {
        (function(ie, i, N) {
          var Z = Q("./capability"), R = Q("inherits"), A = Q("./response"), M = Q("readable-stream"), x = A.IncomingMessage, m = A.readyStates;
          function w(S, U) {
            return Z.fetch && U ? "fetch" : Z.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : Z.msstream ? "ms-stream" : Z.arraybuffer && S ? "arraybuffer" : "text";
          }
          var k = de.exports = function(S) {
            var U = this;
            M.Writable.call(U), U._opts = S, U._body = [], U._headers = {}, S.auth && U.setHeader("Authorization", "Basic " + N.from(S.auth).toString("base64")), Object.keys(S.headers).forEach(function(W) {
              U.setHeader(W, S.headers[W]);
            });
            var j, T = !0;
            if (S.mode === "disable-fetch" || "requestTimeout" in S && !Z.abortController)
              T = !1, j = !0;
            else if (S.mode === "prefer-streaming")
              j = !1;
            else if (S.mode === "allow-wrong-content-type")
              j = !Z.overrideMimeType;
            else if (!S.mode || S.mode === "default" || S.mode === "prefer-fast")
              j = !0;
            else
              throw new Error("Invalid value for opts.mode");
            U._mode = w(j, T), U._fetchTimer = null, U.on("finish", function() {
              U._onFinish();
            });
          };
          R(k, M.Writable), k.prototype.setHeader = function(S, U) {
            var j = this, T = S.toLowerCase();
            P.indexOf(T) === -1 && (j._headers[T] = {
              name: S,
              value: U
            });
          }, k.prototype.getHeader = function(S) {
            var U = this._headers[S.toLowerCase()];
            return U ? U.value : null;
          }, k.prototype.removeHeader = function(S) {
            var U = this;
            delete U._headers[S.toLowerCase()];
          }, k.prototype._onFinish = function() {
            var S = this;
            if (!S._destroyed) {
              var U = S._opts, j = S._headers, T = null;
              U.method !== "GET" && U.method !== "HEAD" && (T = new Blob(S._body, {
                type: (j["content-type"] || {}).value || ""
              }));
              var W = [];
              if (Object.keys(j).forEach(function(le) {
                var me = j[le].name, ke = j[le].value;
                Array.isArray(ke) ? ke.forEach(function(ge) {
                  W.push([me, ge]);
                }) : W.push([me, ke]);
              }), S._mode === "fetch") {
                var J = null;
                if (Z.abortController) {
                  var ee = new AbortController();
                  J = ee.signal, S._fetchAbortController = ee, "requestTimeout" in U && U.requestTimeout !== 0 && (S._fetchTimer = i.setTimeout(function() {
                    S.emit("requestTimeout"), S._fetchAbortController && S._fetchAbortController.abort();
                  }, U.requestTimeout));
                }
                i.fetch(S._opts.url, {
                  method: S._opts.method,
                  headers: W,
                  body: T || void 0,
                  mode: "cors",
                  credentials: U.withCredentials ? "include" : "same-origin",
                  signal: J
                }).then(function(le) {
                  S._fetchResponse = le, S._connect();
                }, function(le) {
                  i.clearTimeout(S._fetchTimer), S._destroyed || S.emit("error", le);
                });
              } else {
                var te = S._xhr = new i.XMLHttpRequest();
                try {
                  te.open(S._opts.method, S._opts.url, !0);
                } catch (le) {
                  ie.nextTick(function() {
                    S.emit("error", le);
                  });
                  return;
                }
                "responseType" in te && (te.responseType = S._mode), "withCredentials" in te && (te.withCredentials = !!U.withCredentials), S._mode === "text" && "overrideMimeType" in te && te.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in U && (te.timeout = U.requestTimeout, te.ontimeout = function() {
                  S.emit("requestTimeout");
                }), W.forEach(function(le) {
                  te.setRequestHeader(le[0], le[1]);
                }), S._response = null, te.onreadystatechange = function() {
                  switch (te.readyState) {
                    case m.LOADING:
                    case m.DONE:
                      S._onXHRProgress();
                      break;
                  }
                }, S._mode === "moz-chunked-arraybuffer" && (te.onprogress = function() {
                  S._onXHRProgress();
                }), te.onerror = function() {
                  S._destroyed || S.emit("error", new Error("XHR error"));
                };
                try {
                  te.send(T);
                } catch (le) {
                  ie.nextTick(function() {
                    S.emit("error", le);
                  });
                  return;
                }
              }
            }
          };
          function E(S) {
            try {
              var U = S.status;
              return U !== null && U !== 0;
            } catch {
              return !1;
            }
          }
          k.prototype._onXHRProgress = function() {
            var S = this;
            !E(S._xhr) || S._destroyed || (S._response || S._connect(), S._response._onXHRProgress());
          }, k.prototype._connect = function() {
            var S = this;
            S._destroyed || (S._response = new x(S._xhr, S._fetchResponse, S._mode, S._fetchTimer), S._response.on("error", function(U) {
              S.emit("error", U);
            }), S.emit("response", S._response));
          }, k.prototype._write = function(S, U, j) {
            var T = this;
            T._body.push(S), j();
          }, k.prototype.abort = k.prototype.destroy = function() {
            var S = this;
            S._destroyed = !0, i.clearTimeout(S._fetchTimer), S._response && (S._response._destroyed = !0), S._xhr ? S._xhr.abort() : S._fetchAbortController && S._fetchAbortController.abort();
          }, k.prototype.end = function(S, U, j) {
            var T = this;
            typeof S == "function" && (j = S, S = void 0), M.Writable.prototype.end.call(T, S, U, j);
          }, k.prototype.flushHeaders = function() {
          }, k.prototype.setTimeout = function() {
          }, k.prototype.setNoDelay = function() {
          }, k.prototype.setSocketKeepAlive = function() {
          };
          var P = [
            "accept-charset",
            "accept-encoding",
            "access-control-request-headers",
            "access-control-request-method",
            "connection",
            "content-length",
            "cookie",
            "cookie2",
            "date",
            "dnt",
            "expect",
            "host",
            "keep-alive",
            "origin",
            "referer",
            "te",
            "trailer",
            "transfer-encoding",
            "upgrade",
            "via"
          ];
        }).call(this, Q("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {}, Q("buffer").Buffer);
      }, { "./capability": 157, "./response": 159, _process: 133, buffer: 48, inherits: 75, "readable-stream": 174 }], 159: [function(Q, de, q) {
        (function(ie, i, N) {
          var Z = Q("./capability"), R = Q("inherits"), A = Q("readable-stream"), M = q.readyStates = {
            UNSENT: 0,
            OPENED: 1,
            HEADERS_RECEIVED: 2,
            LOADING: 3,
            DONE: 4
          }, x = q.IncomingMessage = function(m, w, k, E) {
            var P = this;
            if (A.Readable.call(P), P._mode = k, P.headers = {}, P.rawHeaders = [], P.trailers = {}, P.rawTrailers = [], P.on("end", function() {
              ie.nextTick(function() {
                P.emit("close");
              });
            }), k === "fetch") {
              let J = function() {
                U.read().then(function(ee) {
                  if (!P._destroyed) {
                    if (ee.done) {
                      i.clearTimeout(E), P.push(null);
                      return;
                    }
                    P.push(N.from(ee.value)), J();
                  }
                }).catch(function(ee) {
                  i.clearTimeout(E), P._destroyed || P.emit("error", ee);
                });
              };
              if (P._fetchResponse = w, P.url = w.url, P.statusCode = w.status, P.statusMessage = w.statusText, w.headers.forEach(function(ee, te) {
                P.headers[te.toLowerCase()] = ee, P.rawHeaders.push(te, ee);
              }), Z.writableStream) {
                var S = new WritableStream({
                  write: function(ee) {
                    return new Promise(function(te, le) {
                      P._destroyed ? le() : P.push(N.from(ee)) ? te() : P._resumeFetch = te;
                    });
                  },
                  close: function() {
                    i.clearTimeout(E), P._destroyed || P.push(null);
                  },
                  abort: function(ee) {
                    P._destroyed || P.emit("error", ee);
                  }
                });
                try {
                  w.body.pipeTo(S).catch(function(ee) {
                    i.clearTimeout(E), P._destroyed || P.emit("error", ee);
                  });
                  return;
                } catch {
                }
              }
              var U = w.body.getReader();
              J();
            } else {
              P._xhr = m, P._pos = 0, P.url = m.responseURL, P.statusCode = m.status, P.statusMessage = m.statusText;
              var j = m.getAllResponseHeaders().split(/\r?\n/);
              if (j.forEach(function(J) {
                var ee = J.match(/^([^:]+):\s*(.*)/);
                if (ee) {
                  var te = ee[1].toLowerCase();
                  te === "set-cookie" ? (P.headers[te] === void 0 && (P.headers[te] = []), P.headers[te].push(ee[2])) : P.headers[te] !== void 0 ? P.headers[te] += ", " + ee[2] : P.headers[te] = ee[2], P.rawHeaders.push(ee[1], ee[2]);
                }
              }), P._charset = "x-user-defined", !Z.overrideMimeType) {
                var T = P.rawHeaders["mime-type"];
                if (T) {
                  var W = T.match(/;\s*charset=([^;])(;|$)/);
                  W && (P._charset = W[1].toLowerCase());
                }
                P._charset || (P._charset = "utf-8");
              }
            }
          };
          R(x, A.Readable), x.prototype._read = function() {
            var m = this, w = m._resumeFetch;
            w && (m._resumeFetch = null, w());
          }, x.prototype._onXHRProgress = function() {
            var m = this, w = m._xhr, k = null;
            switch (m._mode) {
              case "text":
                if (k = w.responseText, k.length > m._pos) {
                  var E = k.substr(m._pos);
                  if (m._charset === "x-user-defined") {
                    for (var P = N.alloc(E.length), S = 0; S < E.length; S++)
                      P[S] = E.charCodeAt(S) & 255;
                    m.push(P);
                  } else
                    m.push(E, m._charset);
                  m._pos = k.length;
                }
                break;
              case "arraybuffer":
                if (w.readyState !== M.DONE || !w.response)
                  break;
                k = w.response, m.push(N.from(new Uint8Array(k)));
                break;
              case "moz-chunked-arraybuffer":
                if (k = w.response, w.readyState !== M.LOADING || !k)
                  break;
                m.push(N.from(new Uint8Array(k)));
                break;
              case "ms-stream":
                if (k = w.response, w.readyState !== M.LOADING)
                  break;
                var U = new i.MSStreamReader();
                U.onprogress = function() {
                  U.result.byteLength > m._pos && (m.push(N.from(new Uint8Array(U.result.slice(m._pos)))), m._pos = U.result.byteLength);
                }, U.onload = function() {
                  m.push(null);
                }, U.readAsArrayBuffer(k);
                break;
            }
            m._xhr.readyState === M.DONE && m._mode !== "ms-stream" && m.push(null);
          };
        }).call(this, Q("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {}, Q("buffer").Buffer);
      }, { "./capability": 157, _process: 133, buffer: 48, inherits: 75, "readable-stream": 174 }], 160: [function(Q, de, q) {
        function ie(x, m) {
          x.prototype = Object.create(m.prototype), x.prototype.constructor = x, x.__proto__ = m;
        }
        var i = {};
        function N(x, m, w) {
          w || (w = Error);
          function k(P, S, U) {
            return typeof m == "string" ? m : m(P, S, U);
          }
          var E = /* @__PURE__ */ function(P) {
            ie(S, P);
            function S(U, j, T) {
              return P.call(this, k(U, j, T)) || this;
            }
            return S;
          }(w);
          E.prototype.name = w.name, E.prototype.code = x, i[x] = E;
        }
        function Z(x, m) {
          if (Array.isArray(x)) {
            var w = x.length;
            return x = x.map(function(k) {
              return String(k);
            }), w > 2 ? "one of ".concat(m, " ").concat(x.slice(0, w - 1).join(", "), ", or ") + x[w - 1] : w === 2 ? "one of ".concat(m, " ").concat(x[0], " or ").concat(x[1]) : "of ".concat(m, " ").concat(x[0]);
          } else
            return "of ".concat(m, " ").concat(String(x));
        }
        function R(x, m, w) {
          return x.substr(0, m.length) === m;
        }
        function A(x, m, w) {
          return (w === void 0 || w > x.length) && (w = x.length), x.substring(w - m.length, w) === m;
        }
        function M(x, m, w) {
          return typeof w != "number" && (w = 0), w + m.length > x.length ? !1 : x.indexOf(m, w) !== -1;
        }
        N("ERR_INVALID_OPT_VALUE", function(x, m) {
          return 'The value "' + m + '" is invalid for option "' + x + '"';
        }, TypeError), N("ERR_INVALID_ARG_TYPE", function(x, m, w) {
          var k;
          typeof m == "string" && R(m, "not ") ? (k = "must not be", m = m.replace(/^not /, "")) : k = "must be";
          var E;
          if (A(x, " argument"))
            E = "The ".concat(x, " ").concat(k, " ").concat(Z(m, "type"));
          else {
            var P = M(x, ".") ? "property" : "argument";
            E = 'The "'.concat(x, '" ').concat(P, " ").concat(k, " ").concat(Z(m, "type"));
          }
          return E += ". Received type ".concat(typeof w), E;
        }, TypeError), N("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), N("ERR_METHOD_NOT_IMPLEMENTED", function(x) {
          return "The " + x + " method is not implemented";
        }), N("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), N("ERR_STREAM_DESTROYED", function(x) {
          return "Cannot call " + x + " after a stream was destroyed";
        }), N("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), N("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), N("ERR_STREAM_WRITE_AFTER_END", "write after end"), N("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), N("ERR_UNKNOWN_ENCODING", function(x) {
          return "Unknown encoding: " + x;
        }, TypeError), N("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), de.exports.codes = i;
      }, {}], 161: [function(Q, de, q) {
        (function(ie) {
          var i = /* @__PURE__ */ new Set();
          function N(R) {
            if (!i.has(R)) {
              var A = R + " is an experimental feature. This feature could change at any time";
              i.add(R), ie.emitWarning(A, "ExperimentalWarning");
            }
          }
          function Z() {
          }
          de.exports.emitExperimentalWarning = ie.emitWarning ? N : Z;
        }).call(this, Q("_process"));
      }, { _process: 133 }], 162: [function(Q, de, q) {
        (function(ie) {
          var i = Object.keys || function(k) {
            var E = [];
            for (var P in k)
              E.push(P);
            return E;
          };
          de.exports = x;
          var N = Q("./_stream_readable"), Z = Q("./_stream_writable");
          Q("inherits")(x, N);
          for (var R = i(Z.prototype), A = 0; A < R.length; A++) {
            var M = R[A];
            x.prototype[M] || (x.prototype[M] = Z.prototype[M]);
          }
          function x(k) {
            if (!(this instanceof x)) return new x(k);
            N.call(this, k), Z.call(this, k), this.allowHalfOpen = !0, k && (k.readable === !1 && (this.readable = !1), k.writable === !1 && (this.writable = !1), k.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", m)));
          }
          Object.defineProperty(x.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.highWaterMark;
            }
          }), Object.defineProperty(x.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState && this._writableState.getBuffer();
            }
          }), Object.defineProperty(x.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.length;
            }
          });
          function m() {
            this._writableState.ended || ie.nextTick(w, this);
          }
          function w(k) {
            k.end();
          }
          Object.defineProperty(x.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function(E) {
              this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = E, this._writableState.destroyed = E);
            }
          });
        }).call(this, Q("_process"));
      }, { "./_stream_readable": 164, "./_stream_writable": 166, _process: 133, inherits: 75 }], 163: [function(Q, de, q) {
        de.exports = i;
        var ie = Q("./_stream_transform");
        Q("inherits")(i, ie);
        function i(N) {
          if (!(this instanceof i)) return new i(N);
          ie.call(this, N);
        }
        i.prototype._transform = function(N, Z, R) {
          R(null, N);
        };
      }, { "./_stream_transform": 165, inherits: 75 }], 164: [function(Q, de, q) {
        (function(ie, i) {
          de.exports = Ue;
          var N;
          Ue.ReadableState = Oe, Q("events").EventEmitter;
          var Z = function(Re, _t) {
            return Re.listeners(_t).length;
          }, R = Q("./internal/streams/stream"), A = Q("buffer").Buffer, M = i.Uint8Array || function() {
          };
          function x(De) {
            return A.from(De);
          }
          function m(De) {
            return A.isBuffer(De) || De instanceof M;
          }
          var w = Q("util"), k;
          w && w.debuglog ? k = w.debuglog("stream") : k = function() {
          };
          var E = Q("./internal/streams/buffer_list"), P = Q("./internal/streams/destroy"), S = Q("./internal/streams/state"), U = S.getHighWaterMark, j = Q("../errors").codes, T = j.ERR_INVALID_ARG_TYPE, W = j.ERR_STREAM_PUSH_AFTER_EOF, J = j.ERR_METHOD_NOT_IMPLEMENTED, ee = j.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, te = Q("../experimentalWarning"), le = te.emitExperimentalWarning, me, ke;
          Q("inherits")(Ue, R);
          var ge = ["error", "close", "destroy", "pause", "resume"];
          function Ve(De, Re, _t) {
            if (typeof De.prependListener == "function") return De.prependListener(Re, _t);
            !De._events || !De._events[Re] ? De.on(Re, _t) : Array.isArray(De._events[Re]) ? De._events[Re].unshift(_t) : De._events[Re] = [_t, De._events[Re]];
          }
          function Oe(De, Re, _t) {
            N = N || Q("./_stream_duplex"), De = De || {}, typeof _t != "boolean" && (_t = Re instanceof N), this.objectMode = !!De.objectMode, _t && (this.objectMode = this.objectMode || !!De.readableObjectMode), this.highWaterMark = U(this, De, "readableHighWaterMark", _t), this.buffer = new E(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = De.emitClose !== !1, this.destroyed = !1, this.defaultEncoding = De.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, De.encoding && (me || (me = Q("string_decoder/").StringDecoder), this.decoder = new me(De.encoding), this.encoding = De.encoding);
          }
          function Ue(De) {
            if (N = N || Q("./_stream_duplex"), !(this instanceof Ue)) return new Ue(De);
            var Re = this instanceof N;
            this._readableState = new Oe(De, this, Re), this.readable = !0, De && (typeof De.read == "function" && (this._read = De.read), typeof De.destroy == "function" && (this._destroy = De.destroy)), R.call(this);
          }
          Object.defineProperty(Ue.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState === void 0 ? !1 : this._readableState.destroyed;
            },
            set: function(Re) {
              this._readableState && (this._readableState.destroyed = Re);
            }
          }), Ue.prototype.destroy = P.destroy, Ue.prototype._undestroy = P.undestroy, Ue.prototype._destroy = function(De, Re) {
            Re(De);
          }, Ue.prototype.push = function(De, Re) {
            var _t = this._readableState, et;
            return _t.objectMode ? et = !0 : typeof De == "string" && (Re = Re || _t.defaultEncoding, Re !== _t.encoding && (De = A.from(De, Re), Re = ""), et = !0), we(this, De, Re, !1, et);
          }, Ue.prototype.unshift = function(De) {
            return we(this, De, null, !0, !1);
          };
          function we(De, Re, _t, et, Ie) {
            k("readableAddChunk", Re);
            var pe = De._readableState;
            if (Re === null)
              pe.reading = !1, Ke(De, pe);
            else {
              var xt;
              if (Ie || (xt = it(pe, Re)), xt)
                De.emit("error", xt);
              else if (pe.objectMode || Re && Re.length > 0)
                if (typeof Re != "string" && !pe.objectMode && Object.getPrototypeOf(Re) !== A.prototype && (Re = x(Re)), et)
                  pe.endEmitted ? De.emit("error", new ee()) : Ce(De, pe, Re, !0);
                else if (pe.ended)
                  De.emit("error", new W());
                else {
                  if (pe.destroyed)
                    return !1;
                  pe.reading = !1, pe.decoder && !_t ? (Re = pe.decoder.write(Re), pe.objectMode || Re.length !== 0 ? Ce(De, pe, Re, !1) : wt(De, pe)) : Ce(De, pe, Re, !1);
                }
              else et || (pe.reading = !1, wt(De, pe));
            }
            return !pe.ended && (pe.length < pe.highWaterMark || pe.length === 0);
          }
          function Ce(De, Re, _t, et) {
            Re.flowing && Re.length === 0 && !Re.sync ? (Re.awaitDrain = 0, De.emit("data", _t)) : (Re.length += Re.objectMode ? 1 : _t.length, et ? Re.buffer.unshift(_t) : Re.buffer.push(_t), Re.needReadable && dt(De)), wt(De, Re);
          }
          function it(De, Re) {
            var _t;
            return !m(Re) && typeof Re != "string" && Re !== void 0 && !De.objectMode && (_t = new T("chunk", ["string", "Buffer", "Uint8Array"], Re)), _t;
          }
          Ue.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, Ue.prototype.setEncoding = function(De) {
            return me || (me = Q("string_decoder/").StringDecoder), this._readableState.decoder = new me(De), this._readableState.encoding = this._readableState.decoder.encoding, this;
          };
          var ut = 8388608;
          function bt(De) {
            return De >= ut ? De = ut : (De--, De |= De >>> 1, De |= De >>> 2, De |= De >>> 4, De |= De >>> 8, De |= De >>> 16, De++), De;
          }
          function pt(De, Re) {
            return De <= 0 || Re.length === 0 && Re.ended ? 0 : Re.objectMode ? 1 : De !== De ? Re.flowing && Re.length ? Re.buffer.head.data.length : Re.length : (De > Re.highWaterMark && (Re.highWaterMark = bt(De)), De <= Re.length ? De : Re.ended ? Re.length : (Re.needReadable = !0, 0));
          }
          Ue.prototype.read = function(De) {
            k("read", De), De = parseInt(De, 10);
            var Re = this._readableState, _t = De;
            if (De !== 0 && (Re.emittedReadable = !1), De === 0 && Re.needReadable && ((Re.highWaterMark !== 0 ? Re.length >= Re.highWaterMark : Re.length > 0) || Re.ended))
              return k("read: emitReadable", Re.length, Re.ended), Re.length === 0 && Re.ended ? Lt(this) : dt(this), null;
            if (De = pt(De, Re), De === 0 && Re.ended)
              return Re.length === 0 && Lt(this), null;
            var et = Re.needReadable;
            k("need readable", et), (Re.length === 0 || Re.length - De < Re.highWaterMark) && (et = !0, k("length less than watermark", et)), Re.ended || Re.reading ? (et = !1, k("reading or ended", et)) : et && (k("do read"), Re.reading = !0, Re.sync = !0, Re.length === 0 && (Re.needReadable = !0), this._read(Re.highWaterMark), Re.sync = !1, Re.reading || (De = pt(_t, Re)));
            var Ie;
            return De > 0 ? Ie = St(De, Re) : Ie = null, Ie === null ? (Re.needReadable = !0, De = 0) : (Re.length -= De, Re.awaitDrain = 0), Re.length === 0 && (Re.ended || (Re.needReadable = !0), _t !== De && Re.ended && Lt(this)), Ie !== null && this.emit("data", Ie), Ie;
          };
          function Ke(De, Re) {
            if (!Re.ended) {
              if (Re.decoder) {
                var _t = Re.decoder.end();
                _t && _t.length && (Re.buffer.push(_t), Re.length += Re.objectMode ? 1 : _t.length);
              }
              Re.ended = !0, Re.sync ? dt(De) : (Re.needReadable = !1, Re.emittedReadable || (Re.emittedReadable = !0, ct(De)));
            }
          }
          function dt(De) {
            var Re = De._readableState;
            Re.needReadable = !1, Re.emittedReadable || (k("emitReadable", Re.flowing), Re.emittedReadable = !0, ie.nextTick(ct, De));
          }
          function ct(De) {
            var Re = De._readableState;
            k("emitReadable_", Re.destroyed, Re.length, Re.ended), !Re.destroyed && (Re.length || Re.ended) && De.emit("readable"), Re.needReadable = !Re.flowing && !Re.ended && Re.length <= Re.highWaterMark, At(De);
          }
          function wt(De, Re) {
            Re.readingMore || (Re.readingMore = !0, ie.nextTick(Ht, De, Re));
          }
          function Ht(De, Re) {
            for (; !Re.reading && !Re.ended && (Re.length < Re.highWaterMark || Re.flowing && Re.length === 0); ) {
              var _t = Re.length;
              if (k("maybeReadMore read 0"), De.read(0), _t === Re.length)
                break;
            }
            Re.readingMore = !1;
          }
          Ue.prototype._read = function(De) {
            this.emit("error", new J("_read()"));
          }, Ue.prototype.pipe = function(De, Re) {
            var _t = this, et = this._readableState;
            switch (et.pipesCount) {
              case 0:
                et.pipes = De;
                break;
              case 1:
                et.pipes = [et.pipes, De];
                break;
              default:
                et.pipes.push(De);
                break;
            }
            et.pipesCount += 1, k("pipe count=%d opts=%j", et.pipesCount, Re);
            var Ie = (!Re || Re.end !== !1) && De !== ie.stdout && De !== ie.stderr, pe = Ie ? l : Me;
            et.endEmitted ? ie.nextTick(pe) : _t.once("end", pe), De.on("unpipe", xt);
            function xt(Ge, Qe) {
              k("onunpipe"), Ge === _t && Qe && Qe.hasUnpiped === !1 && (Qe.hasUnpiped = !0, X());
            }
            function l() {
              k("onend"), De.end();
            }
            var _ = $t(_t);
            De.on("drain", _);
            var I = !1;
            function X() {
              k("cleanup"), De.removeListener("close", Te), De.removeListener("finish", ye), De.removeListener("drain", _), De.removeListener("error", ue), De.removeListener("unpipe", xt), _t.removeListener("end", l), _t.removeListener("end", Me), _t.removeListener("data", ne), I = !0, et.awaitDrain && (!De._writableState || De._writableState.needDrain) && _();
            }
            _t.on("data", ne);
            function ne(Ge) {
              k("ondata");
              var Qe = De.write(Ge);
              k("dest.write", Qe), Qe === !1 && ((et.pipesCount === 1 && et.pipes === De || et.pipesCount > 1 && Ye(et.pipes, De) !== -1) && !I && (k("false write response, pause", et.awaitDrain), et.awaitDrain++), _t.pause());
            }
            function ue(Ge) {
              k("onerror", Ge), Me(), De.removeListener("error", ue), Z(De, "error") === 0 && De.emit("error", Ge);
            }
            Ve(De, "error", ue);
            function Te() {
              De.removeListener("finish", ye), Me();
            }
            De.once("close", Te);
            function ye() {
              k("onfinish"), De.removeListener("close", Te), Me();
            }
            De.once("finish", ye);
            function Me() {
              k("unpipe"), _t.unpipe(De);
            }
            return De.emit("pipe", _t), et.flowing || (k("pipe resume"), _t.resume()), De;
          };
          function $t(De) {
            return function() {
              var _t = De._readableState;
              k("pipeOnDrain", _t.awaitDrain), _t.awaitDrain && _t.awaitDrain--, _t.awaitDrain === 0 && Z(De, "data") && (_t.flowing = !0, At(De));
            };
          }
          Ue.prototype.unpipe = function(De) {
            var Re = this._readableState, _t = {
              hasUnpiped: !1
            };
            if (Re.pipesCount === 0) return this;
            if (Re.pipesCount === 1)
              return De && De !== Re.pipes ? this : (De || (De = Re.pipes), Re.pipes = null, Re.pipesCount = 0, Re.flowing = !1, De && De.emit("unpipe", this, _t), this);
            if (!De) {
              var et = Re.pipes, Ie = Re.pipesCount;
              Re.pipes = null, Re.pipesCount = 0, Re.flowing = !1;
              for (var pe = 0; pe < Ie; pe++)
                et[pe].emit("unpipe", this, {
                  hasUnpiped: !1
                });
              return this;
            }
            var xt = Ye(Re.pipes, De);
            return xt === -1 ? this : (Re.pipes.splice(xt, 1), Re.pipesCount -= 1, Re.pipesCount === 1 && (Re.pipes = Re.pipes[0]), De.emit("unpipe", this, _t), this);
          }, Ue.prototype.on = function(De, Re) {
            var _t = R.prototype.on.call(this, De, Re), et = this._readableState;
            return De === "data" ? (et.readableListening = this.listenerCount("readable") > 0, et.flowing !== !1 && this.resume()) : De === "readable" && !et.endEmitted && !et.readableListening && (et.readableListening = et.needReadable = !0, et.flowing = !1, et.emittedReadable = !1, k("on readable", et.length, et.reading), et.length ? dt(this) : et.reading || ie.nextTick(ri, this)), _t;
          }, Ue.prototype.addListener = Ue.prototype.on, Ue.prototype.removeListener = function(De, Re) {
            var _t = R.prototype.removeListener.call(this, De, Re);
            return De === "readable" && ie.nextTick(rt, this), _t;
          }, Ue.prototype.removeAllListeners = function(De) {
            var Re = R.prototype.removeAllListeners.apply(this, arguments);
            return (De === "readable" || De === void 0) && ie.nextTick(rt, this), Re;
          };
          function rt(De) {
            var Re = De._readableState;
            Re.readableListening = De.listenerCount("readable") > 0, Re.resumeScheduled && !Re.paused ? Re.flowing = !0 : De.listenerCount("data") > 0 && De.resume();
          }
          function ri(De) {
            k("readable nexttick read 0"), De.read(0);
          }
          Ue.prototype.resume = function() {
            var De = this._readableState;
            return De.flowing || (k("resume"), De.flowing = !De.readableListening, wi(this, De)), De.paused = !1, this;
          };
          function wi(De, Re) {
            Re.resumeScheduled || (Re.resumeScheduled = !0, ie.nextTick(Qt, De, Re));
          }
          function Qt(De, Re) {
            k("resume", Re.reading), Re.reading || De.read(0), Re.resumeScheduled = !1, De.emit("resume"), At(De), Re.flowing && !Re.reading && De.read(0);
          }
          Ue.prototype.pause = function() {
            return k("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (k("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
          };
          function At(De) {
            var Re = De._readableState;
            for (k("flow", Re.flowing); Re.flowing && De.read() !== null; )
              ;
          }
          Ue.prototype.wrap = function(De) {
            var Re = this, _t = this._readableState, et = !1;
            De.on("end", function() {
              if (k("wrapped end"), _t.decoder && !_t.ended) {
                var xt = _t.decoder.end();
                xt && xt.length && Re.push(xt);
              }
              Re.push(null);
            }), De.on("data", function(xt) {
              if (k("wrapped data"), _t.decoder && (xt = _t.decoder.write(xt)), !(_t.objectMode && xt == null) && !(!_t.objectMode && (!xt || !xt.length))) {
                var l = Re.push(xt);
                l || (et = !0, De.pause());
              }
            });
            for (var Ie in De)
              this[Ie] === void 0 && typeof De[Ie] == "function" && (this[Ie] = /* @__PURE__ */ function(l) {
                return function() {
                  return De[l].apply(De, arguments);
                };
              }(Ie));
            for (var pe = 0; pe < ge.length; pe++)
              De.on(ge[pe], this.emit.bind(this, ge[pe]));
            return this._read = function(xt) {
              k("wrapped _read", xt), et && (et = !1, De.resume());
            }, this;
          }, typeof Symbol == "function" && (Ue.prototype[Symbol.asyncIterator] = function() {
            return le("Readable[Symbol.asyncIterator]"), ke === void 0 && (ke = Q("./internal/streams/async_iterator")), ke(this);
          }), Object.defineProperty(Ue.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.highWaterMark;
            }
          }), Object.defineProperty(Ue.prototype, "readableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState && this._readableState.buffer;
            }
          }), Object.defineProperty(Ue.prototype, "readableFlowing", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.flowing;
            },
            set: function(Re) {
              this._readableState && (this._readableState.flowing = Re);
            }
          }), Ue._fromList = St, Object.defineProperty(Ue.prototype, "readableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._readableState.length;
            }
          });
          function St(De, Re) {
            if (Re.length === 0) return null;
            var _t;
            return Re.objectMode ? _t = Re.buffer.shift() : !De || De >= Re.length ? (Re.decoder ? _t = Re.buffer.join("") : Re.buffer.length === 1 ? _t = Re.buffer.first() : _t = Re.buffer.concat(Re.length), Re.buffer.clear()) : _t = Re.buffer.consume(De, Re.decoder), _t;
          }
          function Lt(De) {
            var Re = De._readableState;
            k("endReadable", Re.endEmitted), Re.endEmitted || (Re.ended = !0, ie.nextTick(kt, Re, De));
          }
          function kt(De, Re) {
            k("endReadableNT", De.endEmitted, De.length), !De.endEmitted && De.length === 0 && (De.endEmitted = !0, Re.readable = !1, Re.emit("end"));
          }
          function Ye(De, Re) {
            for (var _t = 0, et = De.length; _t < et; _t++)
              if (De[_t] === Re) return _t;
            return -1;
          }
        }).call(this, Q("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {});
      }, { "../errors": 160, "../experimentalWarning": 161, "./_stream_duplex": 162, "./internal/streams/async_iterator": 167, "./internal/streams/buffer_list": 168, "./internal/streams/destroy": 169, "./internal/streams/state": 172, "./internal/streams/stream": 173, _process: 133, buffer: 48, events: 52, inherits: 75, "string_decoder/": 175, util: 33 }], 165: [function(Q, de, q) {
        de.exports = x;
        var ie = Q("../errors").codes, i = ie.ERR_METHOD_NOT_IMPLEMENTED, N = ie.ERR_MULTIPLE_CALLBACK, Z = ie.ERR_TRANSFORM_ALREADY_TRANSFORMING, R = ie.ERR_TRANSFORM_WITH_LENGTH_0, A = Q("./_stream_duplex");
        Q("inherits")(x, A);
        function M(k, E) {
          var P = this._transformState;
          P.transforming = !1;
          var S = P.writecb;
          if (S === null)
            return this.emit("error", new N());
          P.writechunk = null, P.writecb = null, E != null && this.push(E), S(k);
          var U = this._readableState;
          U.reading = !1, (U.needReadable || U.length < U.highWaterMark) && this._read(U.highWaterMark);
        }
        function x(k) {
          if (!(this instanceof x)) return new x(k);
          A.call(this, k), this._transformState = {
            afterTransform: M.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }, this._readableState.needReadable = !0, this._readableState.sync = !1, k && (typeof k.transform == "function" && (this._transform = k.transform), typeof k.flush == "function" && (this._flush = k.flush)), this.on("prefinish", m);
        }
        function m() {
          var k = this;
          typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(E, P) {
            w(k, E, P);
          }) : w(this, null, null);
        }
        x.prototype.push = function(k, E) {
          return this._transformState.needTransform = !1, A.prototype.push.call(this, k, E);
        }, x.prototype._transform = function(k, E, P) {
          P(new i("_transform()"));
        }, x.prototype._write = function(k, E, P) {
          var S = this._transformState;
          if (S.writecb = P, S.writechunk = k, S.writeencoding = E, !S.transforming) {
            var U = this._readableState;
            (S.needTransform || U.needReadable || U.length < U.highWaterMark) && this._read(U.highWaterMark);
          }
        }, x.prototype._read = function(k) {
          var E = this._transformState;
          E.writechunk !== null && !E.transforming ? (E.transforming = !0, this._transform(E.writechunk, E.writeencoding, E.afterTransform)) : E.needTransform = !0;
        }, x.prototype._destroy = function(k, E) {
          A.prototype._destroy.call(this, k, function(P) {
            E(P);
          });
        };
        function w(k, E, P) {
          if (E) return k.emit("error", E);
          if (P != null && k.push(P), k._writableState.length) throw new R();
          if (k._transformState.transforming) throw new Z();
          return k.push(null);
        }
      }, { "../errors": 160, "./_stream_duplex": 162, inherits: 75 }], 166: [function(Q, de, q) {
        (function(ie, i) {
          de.exports = Ve;
          function N(Qt) {
            var At = this;
            this.next = null, this.entry = null, this.finish = function() {
              wi(At, Qt);
            };
          }
          var Z;
          Ve.WritableState = ke;
          var R = {
            deprecate: Q("util-deprecate")
          }, A = Q("./internal/streams/stream"), M = Q("buffer").Buffer, x = i.Uint8Array || function() {
          };
          function m(Qt) {
            return M.from(Qt);
          }
          function w(Qt) {
            return M.isBuffer(Qt) || Qt instanceof x;
          }
          var k = Q("./internal/streams/destroy"), E = Q("./internal/streams/state"), P = E.getHighWaterMark, S = Q("../errors").codes, U = S.ERR_INVALID_ARG_TYPE, j = S.ERR_METHOD_NOT_IMPLEMENTED, T = S.ERR_MULTIPLE_CALLBACK, W = S.ERR_STREAM_CANNOT_PIPE, J = S.ERR_STREAM_DESTROYED, ee = S.ERR_STREAM_NULL_VALUES, te = S.ERR_STREAM_WRITE_AFTER_END, le = S.ERR_UNKNOWN_ENCODING;
          Q("inherits")(Ve, A);
          function me() {
          }
          function ke(Qt, At, St) {
            Z = Z || Q("./_stream_duplex"), Qt = Qt || {}, typeof St != "boolean" && (St = At instanceof Z), this.objectMode = !!Qt.objectMode, St && (this.objectMode = this.objectMode || !!Qt.writableObjectMode), this.highWaterMark = P(this, Qt, "writableHighWaterMark", St), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var Lt = Qt.decodeStrings === !1;
            this.decodeStrings = !Lt, this.defaultEncoding = Qt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(kt) {
              pt(At, kt);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Qt.emitClose !== !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new N(this);
          }
          ke.prototype.getBuffer = function() {
            for (var At = this.bufferedRequest, St = []; At; )
              St.push(At), At = At.next;
            return St;
          }, function() {
            try {
              Object.defineProperty(ke.prototype, "buffer", {
                get: R.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch {
            }
          }();
          var ge;
          typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ge = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ve, Symbol.hasInstance, {
            value: function(At) {
              return ge.call(this, At) ? !0 : this !== Ve ? !1 : At && At._writableState instanceof ke;
            }
          })) : ge = function(At) {
            return At instanceof this;
          };
          function Ve(Qt) {
            Z = Z || Q("./_stream_duplex");
            var At = this instanceof Z;
            if (!At && !ge.call(Ve, this)) return new Ve(Qt);
            this._writableState = new ke(Qt, this, At), this.writable = !0, Qt && (typeof Qt.write == "function" && (this._write = Qt.write), typeof Qt.writev == "function" && (this._writev = Qt.writev), typeof Qt.destroy == "function" && (this._destroy = Qt.destroy), typeof Qt.final == "function" && (this._final = Qt.final)), A.call(this);
          }
          Ve.prototype.pipe = function() {
            this.emit("error", new W());
          };
          function Oe(Qt, At) {
            var St = new te();
            Qt.emit("error", St), ie.nextTick(At, St);
          }
          function Ue(Qt, At, St, Lt) {
            var kt;
            return St === null ? kt = new ee() : typeof St != "string" && !At.objectMode && (kt = new U("chunk", ["string", "Buffer"], St)), kt ? (Qt.emit("error", kt), ie.nextTick(Lt, kt), !1) : !0;
          }
          Ve.prototype.write = function(Qt, At, St) {
            var Lt = this._writableState, kt = !1, Ye = !Lt.objectMode && w(Qt);
            return Ye && !M.isBuffer(Qt) && (Qt = m(Qt)), typeof At == "function" && (St = At, At = null), Ye ? At = "buffer" : At || (At = Lt.defaultEncoding), typeof St != "function" && (St = me), Lt.ending ? Oe(this, St) : (Ye || Ue(this, Lt, Qt, St)) && (Lt.pendingcb++, kt = Ce(this, Lt, Ye, Qt, At, St)), kt;
          }, Ve.prototype.cork = function() {
            this._writableState.corked++;
          }, Ve.prototype.uncork = function() {
            var Qt = this._writableState;
            Qt.corked && (Qt.corked--, !Qt.writing && !Qt.corked && !Qt.bufferProcessing && Qt.bufferedRequest && ct(this, Qt));
          }, Ve.prototype.setDefaultEncoding = function(At) {
            if (typeof At == "string" && (At = At.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((At + "").toLowerCase()) > -1)) throw new le(At);
            return this._writableState.defaultEncoding = At, this;
          }, Object.defineProperty(Ve.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          function we(Qt, At, St) {
            return !Qt.objectMode && Qt.decodeStrings !== !1 && typeof At == "string" && (At = M.from(At, St)), At;
          }
          Object.defineProperty(Ve.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.highWaterMark;
            }
          });
          function Ce(Qt, At, St, Lt, kt, Ye) {
            if (!St) {
              var De = we(At, Lt, kt);
              Lt !== De && (St = !0, kt = "buffer", Lt = De);
            }
            var Re = At.objectMode ? 1 : Lt.length;
            At.length += Re;
            var _t = At.length < At.highWaterMark;
            if (_t || (At.needDrain = !0), At.writing || At.corked) {
              var et = At.lastBufferedRequest;
              At.lastBufferedRequest = {
                chunk: Lt,
                encoding: kt,
                isBuf: St,
                callback: Ye,
                next: null
              }, et ? et.next = At.lastBufferedRequest : At.bufferedRequest = At.lastBufferedRequest, At.bufferedRequestCount += 1;
            } else
              it(Qt, At, !1, Re, Lt, kt, Ye);
            return _t;
          }
          function it(Qt, At, St, Lt, kt, Ye, De) {
            At.writelen = Lt, At.writecb = De, At.writing = !0, At.sync = !0, At.destroyed ? At.onwrite(new J("write")) : St ? Qt._writev(kt, At.onwrite) : Qt._write(kt, Ye, At.onwrite), At.sync = !1;
          }
          function ut(Qt, At, St, Lt, kt) {
            --At.pendingcb, St ? (ie.nextTick(kt, Lt), ie.nextTick(rt, Qt, At), Qt._writableState.errorEmitted = !0, Qt.emit("error", Lt)) : (kt(Lt), Qt._writableState.errorEmitted = !0, Qt.emit("error", Lt), rt(Qt, At));
          }
          function bt(Qt) {
            Qt.writing = !1, Qt.writecb = null, Qt.length -= Qt.writelen, Qt.writelen = 0;
          }
          function pt(Qt, At) {
            var St = Qt._writableState, Lt = St.sync, kt = St.writecb;
            if (typeof kt != "function") throw new T();
            if (bt(St), At) ut(Qt, St, Lt, At, kt);
            else {
              var Ye = wt(St) || Qt.destroyed;
              !Ye && !St.corked && !St.bufferProcessing && St.bufferedRequest && ct(Qt, St), Lt ? ie.nextTick(Ke, Qt, St, Ye, kt) : Ke(Qt, St, Ye, kt);
            }
          }
          function Ke(Qt, At, St, Lt) {
            St || dt(Qt, At), At.pendingcb--, Lt(), rt(Qt, At);
          }
          function dt(Qt, At) {
            At.length === 0 && At.needDrain && (At.needDrain = !1, Qt.emit("drain"));
          }
          function ct(Qt, At) {
            At.bufferProcessing = !0;
            var St = At.bufferedRequest;
            if (Qt._writev && St && St.next) {
              var Lt = At.bufferedRequestCount, kt = new Array(Lt), Ye = At.corkedRequestsFree;
              Ye.entry = St;
              for (var De = 0, Re = !0; St; )
                kt[De] = St, St.isBuf || (Re = !1), St = St.next, De += 1;
              kt.allBuffers = Re, it(Qt, At, !0, At.length, kt, "", Ye.finish), At.pendingcb++, At.lastBufferedRequest = null, Ye.next ? (At.corkedRequestsFree = Ye.next, Ye.next = null) : At.corkedRequestsFree = new N(At), At.bufferedRequestCount = 0;
            } else {
              for (; St; ) {
                var _t = St.chunk, et = St.encoding, Ie = St.callback, pe = At.objectMode ? 1 : _t.length;
                if (it(Qt, At, !1, pe, _t, et, Ie), St = St.next, At.bufferedRequestCount--, At.writing)
                  break;
              }
              St === null && (At.lastBufferedRequest = null);
            }
            At.bufferedRequest = St, At.bufferProcessing = !1;
          }
          Ve.prototype._write = function(Qt, At, St) {
            St(new j("_write()"));
          }, Ve.prototype._writev = null, Ve.prototype.end = function(Qt, At, St) {
            var Lt = this._writableState;
            return typeof Qt == "function" ? (St = Qt, Qt = null, At = null) : typeof At == "function" && (St = At, At = null), Qt != null && this.write(Qt, At), Lt.corked && (Lt.corked = 1, this.uncork()), Lt.ending || ri(this, Lt, St), this;
          }, Object.defineProperty(Ve.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState.length;
            }
          });
          function wt(Qt) {
            return Qt.ending && Qt.length === 0 && Qt.bufferedRequest === null && !Qt.finished && !Qt.writing;
          }
          function Ht(Qt, At) {
            Qt._final(function(St) {
              At.pendingcb--, St && Qt.emit("error", St), At.prefinished = !0, Qt.emit("prefinish"), rt(Qt, At);
            });
          }
          function $t(Qt, At) {
            !At.prefinished && !At.finalCalled && (typeof Qt._final == "function" && !At.destroyed ? (At.pendingcb++, At.finalCalled = !0, ie.nextTick(Ht, Qt, At)) : (At.prefinished = !0, Qt.emit("prefinish")));
          }
          function rt(Qt, At) {
            var St = wt(At);
            return St && ($t(Qt, At), At.pendingcb === 0 && (At.finished = !0, Qt.emit("finish"))), St;
          }
          function ri(Qt, At, St) {
            At.ending = !0, rt(Qt, At), St && (At.finished ? ie.nextTick(St) : Qt.once("finish", St)), At.ended = !0, Qt.writable = !1;
          }
          function wi(Qt, At, St) {
            var Lt = Qt.entry;
            for (Qt.entry = null; Lt; ) {
              var kt = Lt.callback;
              At.pendingcb--, kt(St), Lt = Lt.next;
            }
            At.corkedRequestsFree.next = Qt;
          }
          Object.defineProperty(Ve.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: !1,
            get: function() {
              return this._writableState === void 0 ? !1 : this._writableState.destroyed;
            },
            set: function(At) {
              this._writableState && (this._writableState.destroyed = At);
            }
          }), Ve.prototype.destroy = k.destroy, Ve.prototype._undestroy = k.undestroy, Ve.prototype._destroy = function(Qt, At) {
            At(Qt);
          };
        }).call(this, Q("_process"), typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {});
      }, { "../errors": 160, "./_stream_duplex": 162, "./internal/streams/destroy": 169, "./internal/streams/state": 172, "./internal/streams/stream": 173, _process: 133, buffer: 48, inherits: 75, "util-deprecate": 183 }], 167: [function(Q, de, q) {
        (function(ie) {
          var i;
          function N(J, ee, te) {
            return ee in J ? Object.defineProperty(J, ee, { value: te, enumerable: !0, configurable: !0, writable: !0 }) : J[ee] = te, J;
          }
          var Z = Q("./end-of-stream"), R = Symbol("lastResolve"), A = Symbol("lastReject"), M = Symbol("error"), x = Symbol("ended"), m = Symbol("lastPromise"), w = Symbol("handlePromise"), k = Symbol("stream");
          function E(J, ee) {
            return {
              value: J,
              done: ee
            };
          }
          function P(J) {
            var ee = J[R];
            if (ee !== null) {
              var te = J[k].read();
              te !== null && (J[m] = null, J[R] = null, J[A] = null, ee(E(te, !1)));
            }
          }
          function S(J) {
            ie.nextTick(P, J);
          }
          function U(J, ee) {
            return function(te, le) {
              J.then(function() {
                if (ee[x]) {
                  te(E(void 0, !0));
                  return;
                }
                ee[w](te, le);
              }, le);
            };
          }
          var j = Object.getPrototypeOf(function() {
          }), T = Object.setPrototypeOf((i = {
            get stream() {
              return this[k];
            },
            next: function() {
              var ee = this, te = this[M];
              if (te !== null)
                return Promise.reject(te);
              if (this[x])
                return Promise.resolve(E(void 0, !0));
              if (this[k].destroyed)
                return new Promise(function(ge, Ve) {
                  ie.nextTick(function() {
                    ee[M] ? Ve(ee[M]) : ge(E(void 0, !0));
                  });
                });
              var le = this[m], me;
              if (le)
                me = new Promise(U(le, this));
              else {
                var ke = this[k].read();
                if (ke !== null)
                  return Promise.resolve(E(ke, !1));
                me = new Promise(this[w]);
              }
              return this[m] = me, me;
            }
          }, N(i, Symbol.asyncIterator, function() {
            return this;
          }), N(i, "return", function() {
            var ee = this;
            return new Promise(function(te, le) {
              ee[k].destroy(null, function(me) {
                if (me) {
                  le(me);
                  return;
                }
                te(E(void 0, !0));
              });
            });
          }), i), j), W = function(ee) {
            var te, le = Object.create(T, (te = {}, N(te, k, {
              value: ee,
              writable: !0
            }), N(te, R, {
              value: null,
              writable: !0
            }), N(te, A, {
              value: null,
              writable: !0
            }), N(te, M, {
              value: null,
              writable: !0
            }), N(te, x, {
              value: ee._readableState.endEmitted,
              writable: !0
            }), N(te, w, {
              value: function(ke, ge) {
                var Ve = le[k].read();
                Ve ? (le[m] = null, le[R] = null, le[A] = null, ke(E(Ve, !1))) : (le[R] = ke, le[A] = ge);
              },
              writable: !0
            }), te));
            return le[m] = null, Z(ee, function(me) {
              if (me && me.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var ke = le[A];
                ke !== null && (le[m] = null, le[R] = null, le[A] = null, ke(me)), le[M] = me;
                return;
              }
              var ge = le[R];
              ge !== null && (le[m] = null, le[R] = null, le[A] = null, ge(E(void 0, !0))), le[x] = !0;
            }), ee.on("readable", S.bind(null, le)), le;
          };
          de.exports = W;
        }).call(this, Q("_process"));
      }, { "./end-of-stream": 170, _process: 133 }], 168: [function(Q, de, q) {
        function ie(m) {
          for (var w = 1; w < arguments.length; w++) {
            var k = arguments[w] != null ? arguments[w] : {}, E = Object.keys(k);
            typeof Object.getOwnPropertySymbols == "function" && (E = E.concat(Object.getOwnPropertySymbols(k).filter(function(P) {
              return Object.getOwnPropertyDescriptor(k, P).enumerable;
            }))), E.forEach(function(P) {
              i(m, P, k[P]);
            });
          }
          return m;
        }
        function i(m, w, k) {
          return w in m ? Object.defineProperty(m, w, { value: k, enumerable: !0, configurable: !0, writable: !0 }) : m[w] = k, m;
        }
        var N = Q("buffer"), Z = N.Buffer, R = Q("util"), A = R.inspect, M = A && A.custom || "inspect";
        function x(m, w, k) {
          Z.prototype.copy.call(m, w, k);
        }
        de.exports = /* @__PURE__ */ function() {
          function m() {
            this.head = null, this.tail = null, this.length = 0;
          }
          var w = m.prototype;
          return w.push = function(E) {
            var P = {
              data: E,
              next: null
            };
            this.length > 0 ? this.tail.next = P : this.head = P, this.tail = P, ++this.length;
          }, w.unshift = function(E) {
            var P = {
              data: E,
              next: this.head
            };
            this.length === 0 && (this.tail = P), this.head = P, ++this.length;
          }, w.shift = function() {
            if (this.length !== 0) {
              var E = this.head.data;
              return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, E;
            }
          }, w.clear = function() {
            this.head = this.tail = null, this.length = 0;
          }, w.join = function(E) {
            if (this.length === 0) return "";
            for (var P = this.head, S = "" + P.data; P = P.next; )
              S += E + P.data;
            return S;
          }, w.concat = function(E) {
            if (this.length === 0) return Z.alloc(0);
            for (var P = Z.allocUnsafe(E >>> 0), S = this.head, U = 0; S; )
              x(S.data, P, U), U += S.data.length, S = S.next;
            return P;
          }, w.consume = function(E, P) {
            var S;
            return E < this.head.data.length ? (S = this.head.data.slice(0, E), this.head.data = this.head.data.slice(E)) : E === this.head.data.length ? S = this.shift() : S = P ? this._getString(E) : this._getBuffer(E), S;
          }, w.first = function() {
            return this.head.data;
          }, w._getString = function(E) {
            var P = this.head, S = 1, U = P.data;
            for (E -= U.length; P = P.next; ) {
              var j = P.data, T = E > j.length ? j.length : E;
              if (T === j.length ? U += j : U += j.slice(0, E), E -= T, E === 0) {
                T === j.length ? (++S, P.next ? this.head = P.next : this.head = this.tail = null) : (this.head = P, P.data = j.slice(T));
                break;
              }
              ++S;
            }
            return this.length -= S, U;
          }, w._getBuffer = function(E) {
            var P = Z.allocUnsafe(E), S = this.head, U = 1;
            for (S.data.copy(P), E -= S.data.length; S = S.next; ) {
              var j = S.data, T = E > j.length ? j.length : E;
              if (j.copy(P, P.length - E, 0, T), E -= T, E === 0) {
                T === j.length ? (++U, S.next ? this.head = S.next : this.head = this.tail = null) : (this.head = S, S.data = j.slice(T));
                break;
              }
              ++U;
            }
            return this.length -= U, P;
          }, w[M] = function(k, E) {
            return A(this, ie({}, E, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: !1
            }));
          }, m;
        }();
      }, { buffer: 48, util: 33 }], 169: [function(Q, de, q) {
        (function(ie) {
          function i(M, x) {
            var m = this, w = this._readableState && this._readableState.destroyed, k = this._writableState && this._writableState.destroyed;
            return w || k ? (x ? x(M) : M && (!this._writableState || !this._writableState.errorEmitted) && ie.nextTick(A, this, M), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(M || null, function(E) {
              !x && E ? (ie.nextTick(N, m, E), m._writableState && (m._writableState.errorEmitted = !0)) : x ? (ie.nextTick(Z, m), x(E)) : ie.nextTick(Z, m);
            }), this);
          }
          function N(M, x) {
            A(M, x), Z(M);
          }
          function Z(M) {
            M._writableState && !M._writableState.emitClose || M._readableState && !M._readableState.emitClose || M.emit("close");
          }
          function R() {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
          }
          function A(M, x) {
            M.emit("error", x);
          }
          de.exports = {
            destroy: i,
            undestroy: R
          };
        }).call(this, Q("_process"));
      }, { _process: 133 }], 170: [function(Q, de, q) {
        var ie = Q("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function i(A) {
          var M = !1;
          return function() {
            if (!M) {
              M = !0;
              for (var x = arguments.length, m = new Array(x), w = 0; w < x; w++)
                m[w] = arguments[w];
              A.apply(this, m);
            }
          };
        }
        function N() {
        }
        function Z(A) {
          return A.setHeader && typeof A.abort == "function";
        }
        function R(A, M, x) {
          if (typeof M == "function") return R(A, null, M);
          M || (M = {}), x = i(x || N);
          var m = M.readable || M.readable !== !1 && A.readable, w = M.writable || M.writable !== !1 && A.writable, k = function() {
            A.writable || P();
          }, E = A._writableState && A._writableState.finished, P = function() {
            w = !1, E = !0, m || x.call(A);
          }, S = A._readableState && A._readableState.endEmitted, U = function() {
            m = !1, S = !0, w || x.call(A);
          }, j = function(ee) {
            x.call(A, ee);
          }, T = function() {
            var ee;
            if (m && !S)
              return (!A._readableState || !A._readableState.ended) && (ee = new ie()), x.call(A, ee);
            if (w && !E)
              return (!A._writableState || !A._writableState.ended) && (ee = new ie()), x.call(A, ee);
          }, W = function() {
            A.req.on("finish", P);
          };
          return Z(A) ? (A.on("complete", P), A.on("abort", T), A.req ? W() : A.on("request", W)) : w && !A._writableState && (A.on("end", k), A.on("close", k)), A.on("end", U), A.on("finish", P), M.error !== !1 && A.on("error", j), A.on("close", T), function() {
            A.removeListener("complete", P), A.removeListener("abort", T), A.removeListener("request", W), A.req && A.req.removeListener("finish", P), A.removeListener("end", k), A.removeListener("close", k), A.removeListener("finish", P), A.removeListener("end", U), A.removeListener("error", j), A.removeListener("close", T);
          };
        }
        de.exports = R;
      }, { "../../../errors": 160 }], 171: [function(Q, de, q) {
        var ie;
        function i(P) {
          var S = !1;
          return function() {
            S || (S = !0, P.apply(void 0, arguments));
          };
        }
        var N = Q("../../../errors").codes, Z = N.ERR_MISSING_ARGS, R = N.ERR_STREAM_DESTROYED;
        function A(P) {
          if (P) throw P;
        }
        function M(P) {
          return P.setHeader && typeof P.abort == "function";
        }
        function x(P, S, U, j) {
          j = i(j);
          var T = !1;
          P.on("close", function() {
            T = !0;
          }), ie === void 0 && (ie = Q("./end-of-stream")), ie(P, {
            readable: S,
            writable: U
          }, function(J) {
            if (J) return j(J);
            T = !0, j();
          });
          var W = !1;
          return function(J) {
            if (!T && !W) {
              if (W = !0, M(P)) return P.abort();
              if (typeof P.destroy == "function") return P.destroy();
              j(J || new R("pipe"));
            }
          };
        }
        function m(P) {
          P();
        }
        function w(P, S) {
          return P.pipe(S);
        }
        function k(P) {
          return !P.length || typeof P[P.length - 1] != "function" ? A : P.pop();
        }
        function E() {
          for (var P = arguments.length, S = new Array(P), U = 0; U < P; U++)
            S[U] = arguments[U];
          var j = k(S);
          if (Array.isArray(S[0]) && (S = S[0]), S.length < 2)
            throw new Z("streams");
          var T, W = S.map(function(J, ee) {
            var te = ee < S.length - 1, le = ee > 0;
            return x(J, te, le, function(me) {
              T || (T = me), me && W.forEach(m), !te && (W.forEach(m), j(T));
            });
          });
          return S.reduce(w);
        }
        de.exports = E;
      }, { "../../../errors": 160, "./end-of-stream": 170 }], 172: [function(Q, de, q) {
        var ie = Q("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        function i(Z, R, A) {
          return Z.highWaterMark != null ? Z.highWaterMark : R ? Z[A] : null;
        }
        function N(Z, R, A, M) {
          var x = i(R, M, A);
          if (x != null) {
            if (!(isFinite(x) && Math.floor(x) === x) || x < 0) {
              var m = M ? A : "highWaterMark";
              throw new ie(m, x);
            }
            return Math.floor(x);
          }
          return Z.objectMode ? 16 : 16 * 1024;
        }
        de.exports = {
          getHighWaterMark: N
        };
      }, { "../../../errors": 160 }], 173: [function(Q, de, q) {
        arguments[4][146][0].apply(q, arguments);
      }, { dup: 146, events: 52 }], 174: [function(Q, de, q) {
        q = de.exports = Q("./lib/_stream_readable.js"), q.Stream = q, q.Readable = q, q.Writable = Q("./lib/_stream_writable.js"), q.Duplex = Q("./lib/_stream_duplex.js"), q.Transform = Q("./lib/_stream_transform.js"), q.PassThrough = Q("./lib/_stream_passthrough.js"), q.finished = Q("./lib/internal/streams/end-of-stream.js"), q.pipeline = Q("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 162, "./lib/_stream_passthrough.js": 163, "./lib/_stream_readable.js": 164, "./lib/_stream_transform.js": 165, "./lib/_stream_writable.js": 166, "./lib/internal/streams/end-of-stream.js": 170, "./lib/internal/streams/pipeline.js": 171 }], 175: [function(Q, de, q) {
        arguments[4][148][0].apply(q, arguments);
      }, { dup: 148, "safe-buffer": 154 }], 176: [function(Q, de, q) {
        (function(ie, i) {
          var N = Q("process/browser.js").nextTick, Z = Function.prototype.apply, R = Array.prototype.slice, A = {}, M = 0;
          q.setTimeout = function() {
            return new x(Z.call(setTimeout, qe, arguments), clearTimeout);
          }, q.setInterval = function() {
            return new x(Z.call(setInterval, qe, arguments), clearInterval);
          }, q.clearTimeout = q.clearInterval = function(m) {
            m.close();
          };
          function x(m, w) {
            this._id = m, this._clearFn = w;
          }
          x.prototype.unref = x.prototype.ref = function() {
          }, x.prototype.close = function() {
            this._clearFn.call(qe, this._id);
          }, q.enroll = function(m, w) {
            clearTimeout(m._idleTimeoutId), m._idleTimeout = w;
          }, q.unenroll = function(m) {
            clearTimeout(m._idleTimeoutId), m._idleTimeout = -1;
          }, q._unrefActive = q.active = function(m) {
            clearTimeout(m._idleTimeoutId);
            var w = m._idleTimeout;
            w >= 0 && (m._idleTimeoutId = setTimeout(function() {
              m._onTimeout && m._onTimeout();
            }, w));
          }, q.setImmediate = typeof ie == "function" ? ie : function(m) {
            var w = M++, k = arguments.length < 2 ? !1 : R.call(arguments, 1);
            return A[w] = !0, N(function() {
              A[w] && (k ? m.apply(null, k) : m.call(null), q.clearImmediate(w));
            }), w;
          }, q.clearImmediate = typeof i == "function" ? i : function(m) {
            delete A[m];
          };
        }).call(this, Q("timers").setImmediate, Q("timers").clearImmediate);
      }, { "process/browser.js": 133, timers: 176 }], 177: [function(Q, de, q) {
        (function(ie) {
          Object.defineProperty(q, "__esModule", {
            value: !0
          });
          var i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(we) {
            return typeof we;
          } : function(we) {
            return we && typeof Symbol == "function" && we.constructor === Symbol && we !== Symbol.prototype ? "symbol" : typeof we;
          };
          q.clone = M, q.addLast = w, q.addFirst = k, q.removeLast = E, q.removeFirst = P, q.insert = S, q.removeAt = U, q.replaceAt = j, q.getIn = T, q.set = W, q.setIn = ee, q.update = te, q.updateIn = le, q.merge = me, q.mergeDeep = ke, q.mergeIn = ge, q.omit = Ve, q.addDefaults = Oe;
          /*!
           * Timm
           *
           * Immutability helpers with fast reads and acceptable writes.
           *
           * @copyright Guillermo Grau Panea 2016
           * @license MIT
           */
          var N = "INVALID_ARGS";
          function Z(we) {
            throw new Error(we);
          }
          function R(we) {
            var Ce = Object.keys(we);
            return Object.getOwnPropertySymbols ? Ce.concat(Object.getOwnPropertySymbols(we)) : Ce;
          }
          var A = {}.hasOwnProperty;
          function M(we) {
            if (Array.isArray(we)) return we.slice();
            for (var Ce = R(we), it = {}, ut = 0; ut < Ce.length; ut++) {
              var bt = Ce[ut];
              it[bt] = we[bt];
            }
            return it;
          }
          function x(we, Ce, it) {
            var ut = it;
            ut == null && Z(ie.env.NODE_ENV !== "production" ? "At least one object should be provided to merge()" : N);
            for (var bt = !1, pt = arguments.length, Ke = Array(pt > 3 ? pt - 3 : 0), dt = 3; dt < pt; dt++)
              Ke[dt - 3] = arguments[dt];
            for (var ct = 0; ct < Ke.length; ct++) {
              var wt = Ke[ct];
              if (wt != null) {
                var Ht = R(wt);
                if (Ht.length)
                  for (var $t = 0; $t <= Ht.length; $t++) {
                    var rt = Ht[$t];
                    if (!(we && ut[rt] !== void 0)) {
                      var ri = wt[rt];
                      Ce && m(ut[rt]) && m(ri) && (ri = x(we, Ce, ut[rt], ri)), !(ri === void 0 || ri === ut[rt]) && (bt || (bt = !0, ut = M(ut)), ut[rt] = ri);
                    }
                  }
              }
            }
            return ut;
          }
          function m(we) {
            var Ce = typeof we > "u" ? "undefined" : i(we);
            return we != null && Ce === "object";
          }
          function w(we, Ce) {
            return Array.isArray(Ce) ? we.concat(Ce) : we.concat([Ce]);
          }
          function k(we, Ce) {
            return Array.isArray(Ce) ? Ce.concat(we) : [Ce].concat(we);
          }
          function E(we) {
            return we.length ? we.slice(0, we.length - 1) : we;
          }
          function P(we) {
            return we.length ? we.slice(1) : we;
          }
          function S(we, Ce, it) {
            return we.slice(0, Ce).concat(Array.isArray(it) ? it : [it]).concat(we.slice(Ce));
          }
          function U(we, Ce) {
            return Ce >= we.length || Ce < 0 ? we : we.slice(0, Ce).concat(we.slice(Ce + 1));
          }
          function j(we, Ce, it) {
            if (we[Ce] === it) return we;
            for (var ut = we.length, bt = Array(ut), pt = 0; pt < ut; pt++)
              bt[pt] = we[pt];
            return bt[Ce] = it, bt;
          }
          function T(we, Ce) {
            if (!Array.isArray(Ce) && Z(ie.env.NODE_ENV !== "production" ? "A path array should be provided when calling getIn()" : N), we != null) {
              for (var it = we, ut = 0; ut < Ce.length; ut++) {
                var bt = Ce[ut];
                if (it = it != null ? it[bt] : void 0, it === void 0) return it;
              }
              return it;
            }
          }
          function W(we, Ce, it) {
            var ut = typeof Ce == "number" ? [] : {}, bt = we ?? ut;
            if (bt[Ce] === it) return bt;
            var pt = M(bt);
            return pt[Ce] = it, pt;
          }
          function J(we, Ce, it, ut) {
            var bt = void 0, pt = Ce[ut];
            if (ut === Ce.length - 1)
              bt = it;
            else {
              var Ke = m(we) && m(we[pt]) ? we[pt] : typeof Ce[ut + 1] == "number" ? [] : {};
              bt = J(Ke, Ce, it, ut + 1);
            }
            return W(we, pt, bt);
          }
          function ee(we, Ce, it) {
            return Ce.length ? J(we, Ce, it, 0) : it;
          }
          function te(we, Ce, it) {
            var ut = we == null ? void 0 : we[Ce], bt = it(ut);
            return W(we, Ce, bt);
          }
          function le(we, Ce, it) {
            var ut = T(we, Ce), bt = it(ut);
            return ee(we, Ce, bt);
          }
          function me(we, Ce, it, ut, bt, pt) {
            for (var Ke = arguments.length, dt = Array(Ke > 6 ? Ke - 6 : 0), ct = 6; ct < Ke; ct++)
              dt[ct - 6] = arguments[ct];
            return dt.length ? x.call.apply(x, [null, !1, !1, we, Ce, it, ut, bt, pt].concat(dt)) : x(!1, !1, we, Ce, it, ut, bt, pt);
          }
          function ke(we, Ce, it, ut, bt, pt) {
            for (var Ke = arguments.length, dt = Array(Ke > 6 ? Ke - 6 : 0), ct = 6; ct < Ke; ct++)
              dt[ct - 6] = arguments[ct];
            return dt.length ? x.call.apply(x, [null, !1, !0, we, Ce, it, ut, bt, pt].concat(dt)) : x(!1, !0, we, Ce, it, ut, bt, pt);
          }
          function ge(we, Ce, it, ut, bt, pt, Ke) {
            var dt = T(we, Ce);
            dt == null && (dt = {});
            for (var ct = void 0, wt = arguments.length, Ht = Array(wt > 7 ? wt - 7 : 0), $t = 7; $t < wt; $t++)
              Ht[$t - 7] = arguments[$t];
            return Ht.length ? ct = x.call.apply(x, [null, !1, !1, dt, it, ut, bt, pt, Ke].concat(Ht)) : ct = x(!1, !1, dt, it, ut, bt, pt, Ke), ee(we, Ce, ct);
          }
          function Ve(we, Ce) {
            for (var it = Array.isArray(Ce) ? Ce : [Ce], ut = !1, bt = 0; bt < it.length; bt++)
              if (A.call(we, it[bt])) {
                ut = !0;
                break;
              }
            if (!ut) return we;
            for (var pt = {}, Ke = R(we), dt = 0; dt < Ke.length; dt++) {
              var ct = Ke[dt];
              it.indexOf(ct) >= 0 || (pt[ct] = we[ct]);
            }
            return pt;
          }
          function Oe(we, Ce, it, ut, bt, pt) {
            for (var Ke = arguments.length, dt = Array(Ke > 6 ? Ke - 6 : 0), ct = 6; ct < Ke; ct++)
              dt[ct - 6] = arguments[ct];
            return dt.length ? x.call.apply(x, [null, !0, !1, we, Ce, it, ut, bt, pt].concat(dt)) : x(!0, !1, we, Ce, it, ut, bt, pt);
          }
          var Ue = {
            clone: M,
            addLast: w,
            addFirst: k,
            removeLast: E,
            removeFirst: P,
            insert: S,
            removeAt: U,
            replaceAt: j,
            getIn: T,
            // eslint-disable-next-line object-shorthand
            set: W,
            // so that flow doesn't complain
            setIn: ee,
            update: te,
            updateIn: le,
            merge: me,
            mergeDeep: ke,
            mergeIn: ge,
            omit: Ve,
            addDefaults: Oe
          };
          q.default = Ue;
        }).call(this, Q("_process"));
      }, { _process: 133 }], 178: [function(Q, de, q) {
        (function(ie) {
          var i = /^\s+/, N = /\s+$/, Z = 0, R = ie.round, A = ie.min, M = ie.max, x = ie.random;
          function m(Ye, De) {
            if (Ye = Ye || "", De = De || {}, Ye instanceof m)
              return Ye;
            if (!(this instanceof m))
              return new m(Ye, De);
            var Re = w(Ye);
            this._originalInput = Ye, this._r = Re.r, this._g = Re.g, this._b = Re.b, this._a = Re.a, this._roundA = R(100 * this._a) / 100, this._format = De.format || Re.format, this._gradientType = De.gradientType, this._r < 1 && (this._r = R(this._r)), this._g < 1 && (this._g = R(this._g)), this._b < 1 && (this._b = R(this._b)), this._ok = Re.ok, this._tc_id = Z++;
          }
          m.prototype = {
            isDark: function() {
              return this.getBrightness() < 128;
            },
            isLight: function() {
              return !this.isDark();
            },
            isValid: function() {
              return this._ok;
            },
            getOriginalInput: function() {
              return this._originalInput;
            },
            getFormat: function() {
              return this._format;
            },
            getAlpha: function() {
              return this._a;
            },
            getBrightness: function() {
              var Ye = this.toRgb();
              return (Ye.r * 299 + Ye.g * 587 + Ye.b * 114) / 1e3;
            },
            getLuminance: function() {
              var Ye = this.toRgb(), De, Re, _t, et, Ie, pe;
              return De = Ye.r / 255, Re = Ye.g / 255, _t = Ye.b / 255, De <= 0.03928 ? et = De / 12.92 : et = ie.pow((De + 0.055) / 1.055, 2.4), Re <= 0.03928 ? Ie = Re / 12.92 : Ie = ie.pow((Re + 0.055) / 1.055, 2.4), _t <= 0.03928 ? pe = _t / 12.92 : pe = ie.pow((_t + 0.055) / 1.055, 2.4), 0.2126 * et + 0.7152 * Ie + 0.0722 * pe;
            },
            setAlpha: function(Ye) {
              return this._a = Ke(Ye), this._roundA = R(100 * this._a) / 100, this;
            },
            toHsv: function() {
              var Ye = S(this._r, this._g, this._b);
              return { h: Ye.h * 360, s: Ye.s, v: Ye.v, a: this._a };
            },
            toHsvString: function() {
              var Ye = S(this._r, this._g, this._b), De = R(Ye.h * 360), Re = R(Ye.s * 100), _t = R(Ye.v * 100);
              return this._a == 1 ? "hsv(" + De + ", " + Re + "%, " + _t + "%)" : "hsva(" + De + ", " + Re + "%, " + _t + "%, " + this._roundA + ")";
            },
            toHsl: function() {
              var Ye = E(this._r, this._g, this._b);
              return { h: Ye.h * 360, s: Ye.s, l: Ye.l, a: this._a };
            },
            toHslString: function() {
              var Ye = E(this._r, this._g, this._b), De = R(Ye.h * 360), Re = R(Ye.s * 100), _t = R(Ye.l * 100);
              return this._a == 1 ? "hsl(" + De + ", " + Re + "%, " + _t + "%)" : "hsla(" + De + ", " + Re + "%, " + _t + "%, " + this._roundA + ")";
            },
            toHex: function(Ye) {
              return j(this._r, this._g, this._b, Ye);
            },
            toHexString: function(Ye) {
              return "#" + this.toHex(Ye);
            },
            toHex8: function(Ye) {
              return T(this._r, this._g, this._b, this._a, Ye);
            },
            toHex8String: function(Ye) {
              return "#" + this.toHex8(Ye);
            },
            toRgb: function() {
              return { r: R(this._r), g: R(this._g), b: R(this._b), a: this._a };
            },
            toRgbString: function() {
              return this._a == 1 ? "rgb(" + R(this._r) + ", " + R(this._g) + ", " + R(this._b) + ")" : "rgba(" + R(this._r) + ", " + R(this._g) + ", " + R(this._b) + ", " + this._roundA + ")";
            },
            toPercentageRgb: function() {
              return { r: R(dt(this._r, 255) * 100) + "%", g: R(dt(this._g, 255) * 100) + "%", b: R(dt(this._b, 255) * 100) + "%", a: this._a };
            },
            toPercentageRgbString: function() {
              return this._a == 1 ? "rgb(" + R(dt(this._r, 255) * 100) + "%, " + R(dt(this._g, 255) * 100) + "%, " + R(dt(this._b, 255) * 100) + "%)" : "rgba(" + R(dt(this._r, 255) * 100) + "%, " + R(dt(this._g, 255) * 100) + "%, " + R(dt(this._b, 255) * 100) + "%, " + this._roundA + ")";
            },
            toName: function() {
              return this._a === 0 ? "transparent" : this._a < 1 ? !1 : bt[j(this._r, this._g, this._b, !0)] || !1;
            },
            toFilter: function(Ye) {
              var De = "#" + W(this._r, this._g, this._b, this._a), Re = De, _t = this._gradientType ? "GradientType = 1, " : "";
              if (Ye) {
                var et = m(Ye);
                Re = "#" + W(et._r, et._g, et._b, et._a);
              }
              return "progid:DXImageTransform.Microsoft.gradient(" + _t + "startColorstr=" + De + ",endColorstr=" + Re + ")";
            },
            toString: function(Ye) {
              var De = !!Ye;
              Ye = Ye || this._format;
              var Re = !1, _t = this._a < 1 && this._a >= 0, et = !De && _t && (Ye === "hex" || Ye === "hex6" || Ye === "hex3" || Ye === "hex4" || Ye === "hex8" || Ye === "name");
              return et ? Ye === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (Ye === "rgb" && (Re = this.toRgbString()), Ye === "prgb" && (Re = this.toPercentageRgbString()), (Ye === "hex" || Ye === "hex6") && (Re = this.toHexString()), Ye === "hex3" && (Re = this.toHexString(!0)), Ye === "hex4" && (Re = this.toHex8String(!0)), Ye === "hex8" && (Re = this.toHex8String()), Ye === "name" && (Re = this.toName()), Ye === "hsl" && (Re = this.toHslString()), Ye === "hsv" && (Re = this.toHsvString()), Re || this.toHexString());
            },
            clone: function() {
              return m(this.toString());
            },
            _applyModification: function(Ye, De) {
              var Re = Ye.apply(null, [this].concat([].slice.call(De)));
              return this._r = Re._r, this._g = Re._g, this._b = Re._b, this.setAlpha(Re._a), this;
            },
            lighten: function() {
              return this._applyModification(le, arguments);
            },
            brighten: function() {
              return this._applyModification(me, arguments);
            },
            darken: function() {
              return this._applyModification(ke, arguments);
            },
            desaturate: function() {
              return this._applyModification(J, arguments);
            },
            saturate: function() {
              return this._applyModification(ee, arguments);
            },
            greyscale: function() {
              return this._applyModification(te, arguments);
            },
            spin: function() {
              return this._applyModification(ge, arguments);
            },
            _applyCombination: function(Ye, De) {
              return Ye.apply(null, [this].concat([].slice.call(De)));
            },
            analogous: function() {
              return this._applyCombination(Ce, arguments);
            },
            complement: function() {
              return this._applyCombination(Ve, arguments);
            },
            monochromatic: function() {
              return this._applyCombination(it, arguments);
            },
            splitcomplement: function() {
              return this._applyCombination(we, arguments);
            },
            triad: function() {
              return this._applyCombination(Oe, arguments);
            },
            tetrad: function() {
              return this._applyCombination(Ue, arguments);
            }
          }, m.fromRatio = function(Ye, De) {
            if (typeof Ye == "object") {
              var Re = {};
              for (var _t in Ye)
                Ye.hasOwnProperty(_t) && (_t === "a" ? Re[_t] = Ye[_t] : Re[_t] = ri(Ye[_t]));
              Ye = Re;
            }
            return m(Ye, De);
          };
          function w(Ye) {
            var De = { r: 0, g: 0, b: 0 }, Re = 1, _t = null, et = null, Ie = null, pe = !1, xt = !1;
            return typeof Ye == "string" && (Ye = Lt(Ye)), typeof Ye == "object" && (St(Ye.r) && St(Ye.g) && St(Ye.b) ? (De = k(Ye.r, Ye.g, Ye.b), pe = !0, xt = String(Ye.r).substr(-1) === "%" ? "prgb" : "rgb") : St(Ye.h) && St(Ye.s) && St(Ye.v) ? (_t = ri(Ye.s), et = ri(Ye.v), De = U(Ye.h, _t, et), pe = !0, xt = "hsv") : St(Ye.h) && St(Ye.s) && St(Ye.l) && (_t = ri(Ye.s), Ie = ri(Ye.l), De = P(Ye.h, _t, Ie), pe = !0, xt = "hsl"), Ye.hasOwnProperty("a") && (Re = Ye.a)), Re = Ke(Re), {
              ok: pe,
              format: Ye.format || xt,
              r: A(255, M(De.r, 0)),
              g: A(255, M(De.g, 0)),
              b: A(255, M(De.b, 0)),
              a: Re
            };
          }
          function k(Ye, De, Re) {
            return {
              r: dt(Ye, 255) * 255,
              g: dt(De, 255) * 255,
              b: dt(Re, 255) * 255
            };
          }
          function E(Ye, De, Re) {
            Ye = dt(Ye, 255), De = dt(De, 255), Re = dt(Re, 255);
            var _t = M(Ye, De, Re), et = A(Ye, De, Re), Ie, pe, xt = (_t + et) / 2;
            if (_t == et)
              Ie = pe = 0;
            else {
              var l = _t - et;
              switch (pe = xt > 0.5 ? l / (2 - _t - et) : l / (_t + et), _t) {
                case Ye:
                  Ie = (De - Re) / l + (De < Re ? 6 : 0);
                  break;
                case De:
                  Ie = (Re - Ye) / l + 2;
                  break;
                case Re:
                  Ie = (Ye - De) / l + 4;
                  break;
              }
              Ie /= 6;
            }
            return { h: Ie, s: pe, l: xt };
          }
          function P(Ye, De, Re) {
            var _t, et, Ie;
            Ye = dt(Ye, 360), De = dt(De, 100), Re = dt(Re, 100);
            function pe(_, I, X) {
              return X < 0 && (X += 1), X > 1 && (X -= 1), X < 1 / 6 ? _ + (I - _) * 6 * X : X < 1 / 2 ? I : X < 2 / 3 ? _ + (I - _) * (2 / 3 - X) * 6 : _;
            }
            if (De === 0)
              _t = et = Ie = Re;
            else {
              var xt = Re < 0.5 ? Re * (1 + De) : Re + De - Re * De, l = 2 * Re - xt;
              _t = pe(l, xt, Ye + 1 / 3), et = pe(l, xt, Ye), Ie = pe(l, xt, Ye - 1 / 3);
            }
            return { r: _t * 255, g: et * 255, b: Ie * 255 };
          }
          function S(Ye, De, Re) {
            Ye = dt(Ye, 255), De = dt(De, 255), Re = dt(Re, 255);
            var _t = M(Ye, De, Re), et = A(Ye, De, Re), Ie, pe, xt = _t, l = _t - et;
            if (pe = _t === 0 ? 0 : l / _t, _t == et)
              Ie = 0;
            else {
              switch (_t) {
                case Ye:
                  Ie = (De - Re) / l + (De < Re ? 6 : 0);
                  break;
                case De:
                  Ie = (Re - Ye) / l + 2;
                  break;
                case Re:
                  Ie = (Ye - De) / l + 4;
                  break;
              }
              Ie /= 6;
            }
            return { h: Ie, s: pe, v: xt };
          }
          function U(Ye, De, Re) {
            Ye = dt(Ye, 360) * 6, De = dt(De, 100), Re = dt(Re, 100);
            var _t = ie.floor(Ye), et = Ye - _t, Ie = Re * (1 - De), pe = Re * (1 - et * De), xt = Re * (1 - (1 - et) * De), l = _t % 6, _ = [Re, pe, Ie, Ie, xt, Re][l], I = [xt, Re, Re, pe, Ie, Ie][l], X = [Ie, Ie, xt, Re, Re, pe][l];
            return { r: _ * 255, g: I * 255, b: X * 255 };
          }
          function j(Ye, De, Re, _t) {
            var et = [
              rt(R(Ye).toString(16)),
              rt(R(De).toString(16)),
              rt(R(Re).toString(16))
            ];
            return _t && et[0].charAt(0) == et[0].charAt(1) && et[1].charAt(0) == et[1].charAt(1) && et[2].charAt(0) == et[2].charAt(1) ? et[0].charAt(0) + et[1].charAt(0) + et[2].charAt(0) : et.join("");
          }
          function T(Ye, De, Re, _t, et) {
            var Ie = [
              rt(R(Ye).toString(16)),
              rt(R(De).toString(16)),
              rt(R(Re).toString(16)),
              rt(wi(_t))
            ];
            return et && Ie[0].charAt(0) == Ie[0].charAt(1) && Ie[1].charAt(0) == Ie[1].charAt(1) && Ie[2].charAt(0) == Ie[2].charAt(1) && Ie[3].charAt(0) == Ie[3].charAt(1) ? Ie[0].charAt(0) + Ie[1].charAt(0) + Ie[2].charAt(0) + Ie[3].charAt(0) : Ie.join("");
          }
          function W(Ye, De, Re, _t) {
            var et = [
              rt(wi(_t)),
              rt(R(Ye).toString(16)),
              rt(R(De).toString(16)),
              rt(R(Re).toString(16))
            ];
            return et.join("");
          }
          m.equals = function(Ye, De) {
            return !Ye || !De ? !1 : m(Ye).toRgbString() == m(De).toRgbString();
          }, m.random = function() {
            return m.fromRatio({
              r: x(),
              g: x(),
              b: x()
            });
          };
          function J(Ye, De) {
            De = De === 0 ? 0 : De || 10;
            var Re = m(Ye).toHsl();
            return Re.s -= De / 100, Re.s = ct(Re.s), m(Re);
          }
          function ee(Ye, De) {
            De = De === 0 ? 0 : De || 10;
            var Re = m(Ye).toHsl();
            return Re.s += De / 100, Re.s = ct(Re.s), m(Re);
          }
          function te(Ye) {
            return m(Ye).desaturate(100);
          }
          function le(Ye, De) {
            De = De === 0 ? 0 : De || 10;
            var Re = m(Ye).toHsl();
            return Re.l += De / 100, Re.l = ct(Re.l), m(Re);
          }
          function me(Ye, De) {
            De = De === 0 ? 0 : De || 10;
            var Re = m(Ye).toRgb();
            return Re.r = M(0, A(255, Re.r - R(255 * -(De / 100)))), Re.g = M(0, A(255, Re.g - R(255 * -(De / 100)))), Re.b = M(0, A(255, Re.b - R(255 * -(De / 100)))), m(Re);
          }
          function ke(Ye, De) {
            De = De === 0 ? 0 : De || 10;
            var Re = m(Ye).toHsl();
            return Re.l -= De / 100, Re.l = ct(Re.l), m(Re);
          }
          function ge(Ye, De) {
            var Re = m(Ye).toHsl(), _t = (Re.h + De) % 360;
            return Re.h = _t < 0 ? 360 + _t : _t, m(Re);
          }
          function Ve(Ye) {
            var De = m(Ye).toHsl();
            return De.h = (De.h + 180) % 360, m(De);
          }
          function Oe(Ye) {
            var De = m(Ye).toHsl(), Re = De.h;
            return [
              m(Ye),
              m({ h: (Re + 120) % 360, s: De.s, l: De.l }),
              m({ h: (Re + 240) % 360, s: De.s, l: De.l })
            ];
          }
          function Ue(Ye) {
            var De = m(Ye).toHsl(), Re = De.h;
            return [
              m(Ye),
              m({ h: (Re + 90) % 360, s: De.s, l: De.l }),
              m({ h: (Re + 180) % 360, s: De.s, l: De.l }),
              m({ h: (Re + 270) % 360, s: De.s, l: De.l })
            ];
          }
          function we(Ye) {
            var De = m(Ye).toHsl(), Re = De.h;
            return [
              m(Ye),
              m({ h: (Re + 72) % 360, s: De.s, l: De.l }),
              m({ h: (Re + 216) % 360, s: De.s, l: De.l })
            ];
          }
          function Ce(Ye, De, Re) {
            De = De || 6, Re = Re || 30;
            var _t = m(Ye).toHsl(), et = 360 / Re, Ie = [m(Ye)];
            for (_t.h = (_t.h - (et * De >> 1) + 720) % 360; --De; )
              _t.h = (_t.h + et) % 360, Ie.push(m(_t));
            return Ie;
          }
          function it(Ye, De) {
            De = De || 6;
            for (var Re = m(Ye).toHsv(), _t = Re.h, et = Re.s, Ie = Re.v, pe = [], xt = 1 / De; De--; )
              pe.push(m({ h: _t, s: et, v: Ie })), Ie = (Ie + xt) % 1;
            return pe;
          }
          m.mix = function(Ye, De, Re) {
            Re = Re === 0 ? 0 : Re || 50;
            var _t = m(Ye).toRgb(), et = m(De).toRgb(), Ie = Re / 100, pe = {
              r: (et.r - _t.r) * Ie + _t.r,
              g: (et.g - _t.g) * Ie + _t.g,
              b: (et.b - _t.b) * Ie + _t.b,
              a: (et.a - _t.a) * Ie + _t.a
            };
            return m(pe);
          }, m.readability = function(Ye, De) {
            var Re = m(Ye), _t = m(De);
            return (ie.max(Re.getLuminance(), _t.getLuminance()) + 0.05) / (ie.min(Re.getLuminance(), _t.getLuminance()) + 0.05);
          }, m.isReadable = function(Ye, De, Re) {
            var _t = m.readability(Ye, De), et, Ie;
            switch (Ie = !1, et = kt(Re), et.level + et.size) {
              case "AAsmall":
              case "AAAlarge":
                Ie = _t >= 4.5;
                break;
              case "AAlarge":
                Ie = _t >= 3;
                break;
              case "AAAsmall":
                Ie = _t >= 7;
                break;
            }
            return Ie;
          }, m.mostReadable = function(Ye, De, Re) {
            var _t = null, et = 0, Ie, pe, xt, l;
            Re = Re || {}, pe = Re.includeFallbackColors, xt = Re.level, l = Re.size;
            for (var _ = 0; _ < De.length; _++)
              Ie = m.readability(Ye, De[_]), Ie > et && (et = Ie, _t = m(De[_]));
            return m.isReadable(Ye, _t, { level: xt, size: l }) || !pe ? _t : (Re.includeFallbackColors = !1, m.mostReadable(Ye, ["#fff", "#000"], Re));
          };
          var ut = m.names = {
            aliceblue: "f0f8ff",
            antiquewhite: "faebd7",
            aqua: "0ff",
            aquamarine: "7fffd4",
            azure: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "000",
            blanchedalmond: "ffebcd",
            blue: "00f",
            blueviolet: "8a2be2",
            brown: "a52a2a",
            burlywood: "deb887",
            burntsienna: "ea7e5d",
            cadetblue: "5f9ea0",
            chartreuse: "7fff00",
            chocolate: "d2691e",
            coral: "ff7f50",
            cornflowerblue: "6495ed",
            cornsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "0ff",
            darkblue: "00008b",
            darkcyan: "008b8b",
            darkgoldenrod: "b8860b",
            darkgray: "a9a9a9",
            darkgreen: "006400",
            darkgrey: "a9a9a9",
            darkkhaki: "bdb76b",
            darkmagenta: "8b008b",
            darkolivegreen: "556b2f",
            darkorange: "ff8c00",
            darkorchid: "9932cc",
            darkred: "8b0000",
            darksalmon: "e9967a",
            darkseagreen: "8fbc8f",
            darkslateblue: "483d8b",
            darkslategray: "2f4f4f",
            darkslategrey: "2f4f4f",
            darkturquoise: "00ced1",
            darkviolet: "9400d3",
            deeppink: "ff1493",
            deepskyblue: "00bfff",
            dimgray: "696969",
            dimgrey: "696969",
            dodgerblue: "1e90ff",
            firebrick: "b22222",
            floralwhite: "fffaf0",
            forestgreen: "228b22",
            fuchsia: "f0f",
            gainsboro: "dcdcdc",
            ghostwhite: "f8f8ff",
            gold: "ffd700",
            goldenrod: "daa520",
            gray: "808080",
            green: "008000",
            greenyellow: "adff2f",
            grey: "808080",
            honeydew: "f0fff0",
            hotpink: "ff69b4",
            indianred: "cd5c5c",
            indigo: "4b0082",
            ivory: "fffff0",
            khaki: "f0e68c",
            lavender: "e6e6fa",
            lavenderblush: "fff0f5",
            lawngreen: "7cfc00",
            lemonchiffon: "fffacd",
            lightblue: "add8e6",
            lightcoral: "f08080",
            lightcyan: "e0ffff",
            lightgoldenrodyellow: "fafad2",
            lightgray: "d3d3d3",
            lightgreen: "90ee90",
            lightgrey: "d3d3d3",
            lightpink: "ffb6c1",
            lightsalmon: "ffa07a",
            lightseagreen: "20b2aa",
            lightskyblue: "87cefa",
            lightslategray: "789",
            lightslategrey: "789",
            lightsteelblue: "b0c4de",
            lightyellow: "ffffe0",
            lime: "0f0",
            limegreen: "32cd32",
            linen: "faf0e6",
            magenta: "f0f",
            maroon: "800000",
            mediumaquamarine: "66cdaa",
            mediumblue: "0000cd",
            mediumorchid: "ba55d3",
            mediumpurple: "9370db",
            mediumseagreen: "3cb371",
            mediumslateblue: "7b68ee",
            mediumspringgreen: "00fa9a",
            mediumturquoise: "48d1cc",
            mediumvioletred: "c71585",
            midnightblue: "191970",
            mintcream: "f5fffa",
            mistyrose: "ffe4e1",
            moccasin: "ffe4b5",
            navajowhite: "ffdead",
            navy: "000080",
            oldlace: "fdf5e6",
            olive: "808000",
            olivedrab: "6b8e23",
            orange: "ffa500",
            orangered: "ff4500",
            orchid: "da70d6",
            palegoldenrod: "eee8aa",
            palegreen: "98fb98",
            paleturquoise: "afeeee",
            palevioletred: "db7093",
            papayawhip: "ffefd5",
            peachpuff: "ffdab9",
            peru: "cd853f",
            pink: "ffc0cb",
            plum: "dda0dd",
            powderblue: "b0e0e6",
            purple: "800080",
            rebeccapurple: "663399",
            red: "f00",
            rosybrown: "bc8f8f",
            royalblue: "4169e1",
            saddlebrown: "8b4513",
            salmon: "fa8072",
            sandybrown: "f4a460",
            seagreen: "2e8b57",
            seashell: "fff5ee",
            sienna: "a0522d",
            silver: "c0c0c0",
            skyblue: "87ceeb",
            slateblue: "6a5acd",
            slategray: "708090",
            slategrey: "708090",
            snow: "fffafa",
            springgreen: "00ff7f",
            steelblue: "4682b4",
            tan: "d2b48c",
            teal: "008080",
            thistle: "d8bfd8",
            tomato: "ff6347",
            turquoise: "40e0d0",
            violet: "ee82ee",
            wheat: "f5deb3",
            white: "fff",
            whitesmoke: "f5f5f5",
            yellow: "ff0",
            yellowgreen: "9acd32"
          }, bt = m.hexNames = pt(ut);
          function pt(Ye) {
            var De = {};
            for (var Re in Ye)
              Ye.hasOwnProperty(Re) && (De[Ye[Re]] = Re);
            return De;
          }
          function Ke(Ye) {
            return Ye = parseFloat(Ye), (isNaN(Ye) || Ye < 0 || Ye > 1) && (Ye = 1), Ye;
          }
          function dt(Ye, De) {
            Ht(Ye) && (Ye = "100%");
            var Re = $t(Ye);
            return Ye = A(De, M(0, parseFloat(Ye))), Re && (Ye = parseInt(Ye * De, 10) / 100), ie.abs(Ye - De) < 1e-6 ? 1 : Ye % De / parseFloat(De);
          }
          function ct(Ye) {
            return A(1, M(0, Ye));
          }
          function wt(Ye) {
            return parseInt(Ye, 16);
          }
          function Ht(Ye) {
            return typeof Ye == "string" && Ye.indexOf(".") != -1 && parseFloat(Ye) === 1;
          }
          function $t(Ye) {
            return typeof Ye == "string" && Ye.indexOf("%") != -1;
          }
          function rt(Ye) {
            return Ye.length == 1 ? "0" + Ye : "" + Ye;
          }
          function ri(Ye) {
            return Ye <= 1 && (Ye = Ye * 100 + "%"), Ye;
          }
          function wi(Ye) {
            return ie.round(parseFloat(Ye) * 255).toString(16);
          }
          function Qt(Ye) {
            return wt(Ye) / 255;
          }
          var At = function() {
            var Ye = "[-\\+]?\\d+%?", De = "[-\\+]?\\d*\\.\\d+%?", Re = "(?:" + De + ")|(?:" + Ye + ")", _t = "[\\s|\\(]+(" + Re + ")[,|\\s]+(" + Re + ")[,|\\s]+(" + Re + ")\\s*\\)?", et = "[\\s|\\(]+(" + Re + ")[,|\\s]+(" + Re + ")[,|\\s]+(" + Re + ")[,|\\s]+(" + Re + ")\\s*\\)?";
            return {
              CSS_UNIT: new RegExp(Re),
              rgb: new RegExp("rgb" + _t),
              rgba: new RegExp("rgba" + et),
              hsl: new RegExp("hsl" + _t),
              hsla: new RegExp("hsla" + et),
              hsv: new RegExp("hsv" + _t),
              hsva: new RegExp("hsva" + et),
              hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
              hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
            };
          }();
          function St(Ye) {
            return !!At.CSS_UNIT.exec(Ye);
          }
          function Lt(Ye) {
            Ye = Ye.replace(i, "").replace(N, "").toLowerCase();
            var De = !1;
            if (ut[Ye])
              Ye = ut[Ye], De = !0;
            else if (Ye == "transparent")
              return { r: 0, g: 0, b: 0, a: 0, format: "name" };
            var Re;
            return (Re = At.rgb.exec(Ye)) ? { r: Re[1], g: Re[2], b: Re[3] } : (Re = At.rgba.exec(Ye)) ? { r: Re[1], g: Re[2], b: Re[3], a: Re[4] } : (Re = At.hsl.exec(Ye)) ? { h: Re[1], s: Re[2], l: Re[3] } : (Re = At.hsla.exec(Ye)) ? { h: Re[1], s: Re[2], l: Re[3], a: Re[4] } : (Re = At.hsv.exec(Ye)) ? { h: Re[1], s: Re[2], v: Re[3] } : (Re = At.hsva.exec(Ye)) ? { h: Re[1], s: Re[2], v: Re[3], a: Re[4] } : (Re = At.hex8.exec(Ye)) ? {
              r: wt(Re[1]),
              g: wt(Re[2]),
              b: wt(Re[3]),
              a: Qt(Re[4]),
              format: De ? "name" : "hex8"
            } : (Re = At.hex6.exec(Ye)) ? {
              r: wt(Re[1]),
              g: wt(Re[2]),
              b: wt(Re[3]),
              format: De ? "name" : "hex"
            } : (Re = At.hex4.exec(Ye)) ? {
              r: wt(Re[1] + "" + Re[1]),
              g: wt(Re[2] + "" + Re[2]),
              b: wt(Re[3] + "" + Re[3]),
              a: Qt(Re[4] + "" + Re[4]),
              format: De ? "name" : "hex8"
            } : (Re = At.hex3.exec(Ye)) ? {
              r: wt(Re[1] + "" + Re[1]),
              g: wt(Re[2] + "" + Re[2]),
              b: wt(Re[3] + "" + Re[3]),
              format: De ? "name" : "hex"
            } : !1;
          }
          function kt(Ye) {
            var De, Re;
            return Ye = Ye || { level: "AA", size: "small" }, De = (Ye.level || "AA").toUpperCase(), Re = (Ye.size || "small").toLowerCase(), De !== "AA" && De !== "AAA" && (De = "AA"), Re !== "small" && Re !== "large" && (Re = "small"), { level: De, size: Re };
          }
          typeof de < "u" && de.exports ? de.exports = m : qe.tinycolor = m;
        })(Math);
      }, {}], 179: [function(Q, de, q) {
        q = de.exports = ie;
        function ie(i) {
          return i.replace(/^\s*|\s*$/g, "");
        }
        q.left = function(i) {
          return i.replace(/^\s*/, "");
        }, q.right = function(i) {
          return i.replace(/\s*$/, "");
        };
      }, {}], 180: [function(Q, de, q) {
        var ie = Q("punycode"), i = Q("./util");
        q.parse = J, q.resolve = te, q.resolveObject = le, q.format = ee, q.Url = N;
        function N() {
          this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
        }
        var Z = /^([a-z0-9.+-]+:)/i, R = /:[0-9]*$/, A = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, M = ["<", ">", '"', "`", " ", "\r", `
`, "	"], x = ["{", "}", "|", "\\", "^", "`"].concat(M), m = ["'"].concat(x), w = ["%", "/", "?", ";", "#"].concat(m), k = ["/", "?", "#"], E = 255, P = /^[+a-z0-9A-Z_-]{0,63}$/, S = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, U = {
          javascript: !0,
          "javascript:": !0
        }, j = {
          javascript: !0,
          "javascript:": !0
        }, T = {
          http: !0,
          https: !0,
          ftp: !0,
          gopher: !0,
          file: !0,
          "http:": !0,
          "https:": !0,
          "ftp:": !0,
          "gopher:": !0,
          "file:": !0
        }, W = Q("querystring");
        function J(me, ke, ge) {
          if (me && i.isObject(me) && me instanceof N) return me;
          var Ve = new N();
          return Ve.parse(me, ke, ge), Ve;
        }
        N.prototype.parse = function(me, ke, ge) {
          if (!i.isString(me))
            throw new TypeError("Parameter 'url' must be a string, not " + typeof me);
          var Ve = me.indexOf("?"), Oe = Ve !== -1 && Ve < me.indexOf("#") ? "?" : "#", Ue = me.split(Oe), we = /\\/g;
          Ue[0] = Ue[0].replace(we, "/"), me = Ue.join(Oe);
          var Ce = me;
          if (Ce = Ce.trim(), !ge && me.split("#").length === 1) {
            var it = A.exec(Ce);
            if (it)
              return this.path = Ce, this.href = Ce, this.pathname = it[1], it[2] ? (this.search = it[2], ke ? this.query = W.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : ke && (this.search = "", this.query = {}), this;
          }
          var ut = Z.exec(Ce);
          if (ut) {
            ut = ut[0];
            var bt = ut.toLowerCase();
            this.protocol = bt, Ce = Ce.substr(ut.length);
          }
          if (ge || ut || Ce.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var pt = Ce.substr(0, 2) === "//";
            pt && !(ut && j[ut]) && (Ce = Ce.substr(2), this.slashes = !0);
          }
          if (!j[ut] && (pt || ut && !T[ut])) {
            for (var Ke = -1, dt = 0; dt < k.length; dt++) {
              var ct = Ce.indexOf(k[dt]);
              ct !== -1 && (Ke === -1 || ct < Ke) && (Ke = ct);
            }
            var wt, Ht;
            Ke === -1 ? Ht = Ce.lastIndexOf("@") : Ht = Ce.lastIndexOf("@", Ke), Ht !== -1 && (wt = Ce.slice(0, Ht), Ce = Ce.slice(Ht + 1), this.auth = decodeURIComponent(wt)), Ke = -1;
            for (var dt = 0; dt < w.length; dt++) {
              var ct = Ce.indexOf(w[dt]);
              ct !== -1 && (Ke === -1 || ct < Ke) && (Ke = ct);
            }
            Ke === -1 && (Ke = Ce.length), this.host = Ce.slice(0, Ke), Ce = Ce.slice(Ke), this.parseHost(), this.hostname = this.hostname || "";
            var $t = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!$t)
              for (var rt = this.hostname.split(/\./), dt = 0, ri = rt.length; dt < ri; dt++) {
                var wi = rt[dt];
                if (wi && !wi.match(P)) {
                  for (var Qt = "", At = 0, St = wi.length; At < St; At++)
                    wi.charCodeAt(At) > 127 ? Qt += "x" : Qt += wi[At];
                  if (!Qt.match(P)) {
                    var Lt = rt.slice(0, dt), kt = rt.slice(dt + 1), Ye = wi.match(S);
                    Ye && (Lt.push(Ye[1]), kt.unshift(Ye[2])), kt.length && (Ce = "/" + kt.join(".") + Ce), this.hostname = Lt.join(".");
                    break;
                  }
                }
              }
            this.hostname.length > E ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), $t || (this.hostname = ie.toASCII(this.hostname));
            var De = this.port ? ":" + this.port : "", Re = this.hostname || "";
            this.host = Re + De, this.href += this.host, $t && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), Ce[0] !== "/" && (Ce = "/" + Ce));
          }
          if (!U[bt])
            for (var dt = 0, ri = m.length; dt < ri; dt++) {
              var _t = m[dt];
              if (Ce.indexOf(_t) !== -1) {
                var et = encodeURIComponent(_t);
                et === _t && (et = escape(_t)), Ce = Ce.split(_t).join(et);
              }
            }
          var Ie = Ce.indexOf("#");
          Ie !== -1 && (this.hash = Ce.substr(Ie), Ce = Ce.slice(0, Ie));
          var pe = Ce.indexOf("?");
          if (pe !== -1 ? (this.search = Ce.substr(pe), this.query = Ce.substr(pe + 1), ke && (this.query = W.parse(this.query)), Ce = Ce.slice(0, pe)) : ke && (this.search = "", this.query = {}), Ce && (this.pathname = Ce), T[bt] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            var De = this.pathname || "", xt = this.search || "";
            this.path = De + xt;
          }
          return this.href = this.format(), this;
        };
        function ee(me) {
          return i.isString(me) && (me = J(me)), me instanceof N ? me.format() : N.prototype.format.call(me);
        }
        N.prototype.format = function() {
          var me = this.auth || "";
          me && (me = encodeURIComponent(me), me = me.replace(/%3A/i, ":"), me += "@");
          var ke = this.protocol || "", ge = this.pathname || "", Ve = this.hash || "", Oe = !1, Ue = "";
          this.host ? Oe = me + this.host : this.hostname && (Oe = me + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (Oe += ":" + this.port)), this.query && i.isObject(this.query) && Object.keys(this.query).length && (Ue = W.stringify(this.query));
          var we = this.search || Ue && "?" + Ue || "";
          return ke && ke.substr(-1) !== ":" && (ke += ":"), this.slashes || (!ke || T[ke]) && Oe !== !1 ? (Oe = "//" + (Oe || ""), ge && ge.charAt(0) !== "/" && (ge = "/" + ge)) : Oe || (Oe = ""), Ve && Ve.charAt(0) !== "#" && (Ve = "#" + Ve), we && we.charAt(0) !== "?" && (we = "?" + we), ge = ge.replace(/[?#]/g, function(Ce) {
            return encodeURIComponent(Ce);
          }), we = we.replace("#", "%23"), ke + Oe + ge + we + Ve;
        };
        function te(me, ke) {
          return J(me, !1, !0).resolve(ke);
        }
        N.prototype.resolve = function(me) {
          return this.resolveObject(J(me, !1, !0)).format();
        };
        function le(me, ke) {
          return me ? J(me, !1, !0).resolveObject(ke) : ke;
        }
        N.prototype.resolveObject = function(me) {
          if (i.isString(me)) {
            var ke = new N();
            ke.parse(me, !1, !0), me = ke;
          }
          for (var ge = new N(), Ve = Object.keys(this), Oe = 0; Oe < Ve.length; Oe++) {
            var Ue = Ve[Oe];
            ge[Ue] = this[Ue];
          }
          if (ge.hash = me.hash, me.href === "")
            return ge.href = ge.format(), ge;
          if (me.slashes && !me.protocol) {
            for (var we = Object.keys(me), Ce = 0; Ce < we.length; Ce++) {
              var it = we[Ce];
              it !== "protocol" && (ge[it] = me[it]);
            }
            return T[ge.protocol] && ge.hostname && !ge.pathname && (ge.path = ge.pathname = "/"), ge.href = ge.format(), ge;
          }
          if (me.protocol && me.protocol !== ge.protocol) {
            if (!T[me.protocol]) {
              for (var ut = Object.keys(me), bt = 0; bt < ut.length; bt++) {
                var pt = ut[bt];
                ge[pt] = me[pt];
              }
              return ge.href = ge.format(), ge;
            }
            if (ge.protocol = me.protocol, !me.host && !j[me.protocol]) {
              for (var ri = (me.pathname || "").split("/"); ri.length && !(me.host = ri.shift()); ) ;
              me.host || (me.host = ""), me.hostname || (me.hostname = ""), ri[0] !== "" && ri.unshift(""), ri.length < 2 && ri.unshift(""), ge.pathname = ri.join("/");
            } else
              ge.pathname = me.pathname;
            if (ge.search = me.search, ge.query = me.query, ge.host = me.host || "", ge.auth = me.auth, ge.hostname = me.hostname || me.host, ge.port = me.port, ge.pathname || ge.search) {
              var Ke = ge.pathname || "", dt = ge.search || "";
              ge.path = Ke + dt;
            }
            return ge.slashes = ge.slashes || me.slashes, ge.href = ge.format(), ge;
          }
          var ct = ge.pathname && ge.pathname.charAt(0) === "/", wt = me.host || me.pathname && me.pathname.charAt(0) === "/", Ht = wt || ct || ge.host && me.pathname, $t = Ht, rt = ge.pathname && ge.pathname.split("/") || [], ri = me.pathname && me.pathname.split("/") || [], wi = ge.protocol && !T[ge.protocol];
          if (wi && (ge.hostname = "", ge.port = null, ge.host && (rt[0] === "" ? rt[0] = ge.host : rt.unshift(ge.host)), ge.host = "", me.protocol && (me.hostname = null, me.port = null, me.host && (ri[0] === "" ? ri[0] = me.host : ri.unshift(me.host)), me.host = null), Ht = Ht && (ri[0] === "" || rt[0] === "")), wt)
            ge.host = me.host || me.host === "" ? me.host : ge.host, ge.hostname = me.hostname || me.hostname === "" ? me.hostname : ge.hostname, ge.search = me.search, ge.query = me.query, rt = ri;
          else if (ri.length)
            rt || (rt = []), rt.pop(), rt = rt.concat(ri), ge.search = me.search, ge.query = me.query;
          else if (!i.isNullOrUndefined(me.search)) {
            if (wi) {
              ge.hostname = ge.host = rt.shift();
              var Qt = ge.host && ge.host.indexOf("@") > 0 ? ge.host.split("@") : !1;
              Qt && (ge.auth = Qt.shift(), ge.host = ge.hostname = Qt.shift());
            }
            return ge.search = me.search, ge.query = me.query, (!i.isNull(ge.pathname) || !i.isNull(ge.search)) && (ge.path = (ge.pathname ? ge.pathname : "") + (ge.search ? ge.search : "")), ge.href = ge.format(), ge;
          }
          if (!rt.length)
            return ge.pathname = null, ge.search ? ge.path = "/" + ge.search : ge.path = null, ge.href = ge.format(), ge;
          for (var At = rt.slice(-1)[0], St = (ge.host || me.host || rt.length > 1) && (At === "." || At === "..") || At === "", Lt = 0, kt = rt.length; kt >= 0; kt--)
            At = rt[kt], At === "." ? rt.splice(kt, 1) : At === ".." ? (rt.splice(kt, 1), Lt++) : Lt && (rt.splice(kt, 1), Lt--);
          if (!Ht && !$t)
            for (; Lt--; Lt)
              rt.unshift("..");
          Ht && rt[0] !== "" && (!rt[0] || rt[0].charAt(0) !== "/") && rt.unshift(""), St && rt.join("/").substr(-1) !== "/" && rt.push("");
          var Ye = rt[0] === "" || rt[0] && rt[0].charAt(0) === "/";
          if (wi) {
            ge.hostname = ge.host = Ye ? "" : rt.length ? rt.shift() : "";
            var Qt = ge.host && ge.host.indexOf("@") > 0 ? ge.host.split("@") : !1;
            Qt && (ge.auth = Qt.shift(), ge.host = ge.hostname = Qt.shift());
          }
          return Ht = Ht || ge.host && rt.length, Ht && !Ye && rt.unshift(""), rt.length ? ge.pathname = rt.join("/") : (ge.pathname = null, ge.path = null), (!i.isNull(ge.pathname) || !i.isNull(ge.search)) && (ge.path = (ge.pathname ? ge.pathname : "") + (ge.search ? ge.search : "")), ge.auth = me.auth || ge.auth, ge.slashes = ge.slashes || me.slashes, ge.href = ge.format(), ge;
        }, N.prototype.parseHost = function() {
          var me = this.host, ke = R.exec(me);
          ke && (ke = ke[0], ke !== ":" && (this.port = ke.substr(1)), me = me.substr(0, me.length - ke.length)), me && (this.hostname = me);
        };
      }, { "./util": 181, punycode: 134, querystring: 137 }], 181: [function(Q, de, q) {
        de.exports = {
          isString: function(ie) {
            return typeof ie == "string";
          },
          isObject: function(ie) {
            return typeof ie == "object" && ie !== null;
          },
          isNull: function(ie) {
            return ie === null;
          },
          isNullOrUndefined: function(ie) {
            return ie == null;
          }
        };
      }, {}], 182: [function(Q, de, q) {
        (function(ie) {
          (function() {
            var i = {};
            typeof de == "object" ? de.exports = i : self.UTIF = i;
            var N;
            typeof Q == "function" ? N = Q("pako") : N = self.pako;
            function Z() {
              (typeof ie > "u" || ie.env.NODE_ENV == "development") && console.log.apply(console, arguments);
            }
            (function(R, A) {
              (function() {
                var M = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(w) {
                  return typeof w;
                } : function(w) {
                  return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w;
                }, x = function() {
                  function w(k) {
                    this.message = "JPEG error: " + k;
                  }
                  return w.prototype = Error(), w.prototype.name = "JpegError", w.constructor = w;
                }(), m = function() {
                  function w(k, E) {
                    this.message = k, this.g = E;
                  }
                  return w.prototype = Error(), w.prototype.name = "DNLMarkerError", w.constructor = w;
                }();
                (function() {
                  function w() {
                    this.M = null, this.B = -1;
                  }
                  function k(j, T) {
                    for (var W = 0, J = [], ee, te, le = 16; 0 < le && !j[le - 1]; ) le--;
                    J.push({ children: [], index: 0 });
                    var me = J[0], ke;
                    for (ee = 0; ee < le; ee++) {
                      for (te = 0; te < j[ee]; te++) {
                        for (me = J.pop(), me.children[me.index] = T[W]; 0 < me.index; ) me = J.pop();
                        for (me.index++, J.push(me); J.length <= ee; ) J.push(ke = { children: [], index: 0 }), me.children[me.index] = ke.children, me = ke;
                        W++;
                      }
                      ee + 1 < le && (J.push(ke = { children: [], index: 0 }), me.children[me.index] = ke.children, me = ke);
                    }
                    return J[0].children;
                  }
                  function E(j, T, W, J, ee, te, le, me, ke) {
                    function ge() {
                      if (0 < wt) return wt--, ct >> wt & 1;
                      if (ct = j[T++], ct === 255) {
                        var Ie = j[T++];
                        if (Ie) {
                          if (Ie === 220 && pt) {
                            T += 2;
                            var pe = j[T++] << 8 | j[T++];
                            if (0 < pe && pe !== W.g) throw new m("Found DNL marker (0xFFDC) while parsing scan data", pe);
                          }
                          throw new x("unexpected marker " + (ct << 8 | Ie).toString(16));
                        }
                      }
                      return wt = 7, ct >>> 7;
                    }
                    function Ve(Ie) {
                      for (; ; ) {
                        if (Ie = Ie[ge()], typeof Ie == "number") return Ie;
                        if ((typeof Ie > "u" ? "undefined" : M(Ie)) !== "object") throw new x("invalid huffman sequence");
                      }
                    }
                    function Oe(Ie) {
                      for (var pe = 0; 0 < Ie; ) pe = pe << 1 | ge(), Ie--;
                      return pe;
                    }
                    function Ue(Ie) {
                      if (Ie === 1) return ge() === 1 ? 1 : -1;
                      var pe = Oe(Ie);
                      return pe >= 1 << Ie - 1 ? pe : pe + (-1 << Ie) + 1;
                    }
                    function we(Ie, pe) {
                      var xt = Ve(Ie.D);
                      for (xt = xt === 0 ? 0 : Ue(xt), Ie.a[pe] = Ie.m += xt, xt = 1; 64 > xt; ) {
                        var l = Ve(Ie.o), _ = l & 15;
                        if (l >>= 4, _ === 0) {
                          if (15 > l) break;
                          xt += 16;
                        } else xt += l, Ie.a[pe + U[xt]] = Ue(_), xt++;
                      }
                    }
                    function Ce(Ie, pe) {
                      var xt = Ve(Ie.D);
                      xt = xt === 0 ? 0 : Ue(xt) << ke, Ie.a[pe] = Ie.m += xt;
                    }
                    function it(Ie, pe) {
                      Ie.a[pe] |= ge() << ke;
                    }
                    function ut(Ie, pe) {
                      if (0 < Ht) Ht--;
                      else for (var xt = te; xt <= le; ) {
                        var l = Ve(Ie.o), _ = l & 15;
                        if (l >>= 4, _ === 0) {
                          if (15 > l) {
                            Ht = Oe(l) + (1 << l) - 1;
                            break;
                          }
                          xt += 16;
                        } else xt += l, Ie.a[pe + U[xt]] = Ue(_) * (1 << ke), xt++;
                      }
                    }
                    function bt(Ie, pe) {
                      for (var xt = te, l = 0, _; xt <= le; ) {
                        _ = pe + U[xt];
                        var I = 0 > Ie.a[_] ? -1 : 1;
                        switch ($t) {
                          case 0:
                            if (l = Ve(Ie.o), _ = l & 15, l >>= 4, _ === 0) 15 > l ? (Ht = Oe(l) + (1 << l), $t = 4) : (l = 16, $t = 1);
                            else {
                              if (_ !== 1) throw new x("invalid ACn encoding");
                              rt = Ue(_), $t = l ? 2 : 3;
                            }
                            continue;
                          case 1:
                          case 2:
                            Ie.a[_] ? Ie.a[_] += I * (ge() << ke) : (l--, l === 0 && ($t = $t === 2 ? 3 : 0));
                            break;
                          case 3:
                            Ie.a[_] ? Ie.a[_] += I * (ge() << ke) : (Ie.a[_] = rt << ke, $t = 0);
                            break;
                          case 4:
                            Ie.a[_] && (Ie.a[_] += I * (ge() << ke));
                        }
                        xt++;
                      }
                      $t === 4 && (Ht--, Ht === 0 && ($t = 0));
                    }
                    for (var pt = 9 < arguments.length && arguments[9] !== void 0 ? arguments[9] : !1, Ke = W.P, dt = T, ct = 0, wt = 0, Ht = 0, $t = 0, rt, ri = J.length, wi, Qt, At, St, Lt = W.S ? te === 0 ? me === 0 ? Ce : it : me === 0 ? ut : bt : we, kt = 0, Ye = ri === 1 ? J[0].c * J[0].l : Ke * W.O, De, Re; kt < Ye; ) {
                      var _t = ee ? Math.min(Ye - kt, ee) : Ye;
                      for (wi = 0; wi < ri; wi++) J[wi].m = 0;
                      if (Ht = 0, ri === 1) {
                        var et = J[0];
                        for (St = 0; St < _t; St++) Lt(et, 64 * ((et.c + 1) * (kt / et.c | 0) + kt % et.c)), kt++;
                      } else for (St = 0; St < _t; St++) {
                        for (wi = 0; wi < ri; wi++) for (et = J[wi], De = et.h, Re = et.j, Qt = 0; Qt < Re; Qt++) for (At = 0; At < De; At++) Lt(et, 64 * ((et.c + 1) * ((kt / Ke | 0) * et.j + Qt) + (kt % Ke * et.h + At)));
                        kt++;
                      }
                      if (wt = 0, (et = S(j, T)) && et.f && ((0, _util.warn)("decodeScan - unexpected MCU data, current marker is: " + et.f), T = et.offset), et = et && et.F, !et || 65280 >= et) throw new x("marker was not found");
                      if (65488 <= et && 65495 >= et) T += 2;
                      else break;
                    }
                    return (et = S(j, T)) && et.f && ((0, _util.warn)("decodeScan - unexpected Scan data, current marker is: " + et.f), T = et.offset), T - dt;
                  }
                  function P(j, T) {
                    for (var W = T.c, J = T.l, ee = new Int16Array(64), te = 0; te < J; te++) for (var le = 0; le < W; le++) {
                      var me = 64 * ((T.c + 1) * te + le), ke = ee, ge = T.G, Ve = T.a;
                      if (!ge) throw new x("missing required Quantization Table.");
                      for (var Oe = 0; 64 > Oe; Oe += 8) {
                        var Ue = Ve[me + Oe], we = Ve[me + Oe + 1], Ce = Ve[me + Oe + 2], it = Ve[me + Oe + 3], ut = Ve[me + Oe + 4], bt = Ve[me + Oe + 5], pt = Ve[me + Oe + 6], Ke = Ve[me + Oe + 7];
                        if (Ue *= ge[Oe], !(we | Ce | it | ut | bt | pt | Ke)) Ue = 5793 * Ue + 512 >> 10, ke[Oe] = Ue, ke[Oe + 1] = Ue, ke[Oe + 2] = Ue, ke[Oe + 3] = Ue, ke[Oe + 4] = Ue, ke[Oe + 5] = Ue, ke[Oe + 6] = Ue, ke[Oe + 7] = Ue;
                        else {
                          we *= ge[Oe + 1], Ce *= ge[Oe + 2], it *= ge[Oe + 3], ut *= ge[Oe + 4], bt *= ge[Oe + 5], pt *= ge[Oe + 6], Ke *= ge[Oe + 7];
                          var dt = 5793 * Ue + 128 >> 8, ct = 5793 * ut + 128 >> 8, wt = Ce, Ht = pt;
                          ut = 2896 * (we - Ke) + 128 >> 8, Ke = 2896 * (we + Ke) + 128 >> 8, it <<= 4, bt <<= 4, dt = dt + ct + 1 >> 1, ct = dt - ct, Ue = 3784 * wt + 1567 * Ht + 128 >> 8, wt = 1567 * wt - 3784 * Ht + 128 >> 8, Ht = Ue, ut = ut + bt + 1 >> 1, bt = ut - bt, Ke = Ke + it + 1 >> 1, it = Ke - it, dt = dt + Ht + 1 >> 1, Ht = dt - Ht, ct = ct + wt + 1 >> 1, wt = ct - wt, Ue = 2276 * ut + 3406 * Ke + 2048 >> 12, ut = 3406 * ut - 2276 * Ke + 2048 >> 12, Ke = Ue, Ue = 799 * it + 4017 * bt + 2048 >> 12, it = 4017 * it - 799 * bt + 2048 >> 12, bt = Ue, ke[Oe] = dt + Ke, ke[Oe + 7] = dt - Ke, ke[Oe + 1] = ct + bt, ke[Oe + 6] = ct - bt, ke[Oe + 2] = wt + it, ke[Oe + 5] = wt - it, ke[Oe + 3] = Ht + ut, ke[Oe + 4] = Ht - ut;
                        }
                      }
                      for (ge = 0; 8 > ge; ++ge) Ue = ke[ge], we = ke[ge + 8], Ce = ke[ge + 16], it = ke[ge + 24], ut = ke[ge + 32], bt = ke[ge + 40], pt = ke[ge + 48], Ke = ke[ge + 56], we | Ce | it | ut | bt | pt | Ke ? (dt = 5793 * Ue + 2048 >> 12, ct = 5793 * ut + 2048 >> 12, wt = Ce, Ht = pt, ut = 2896 * (we - Ke) + 2048 >> 12, Ke = 2896 * (we + Ke) + 2048 >> 12, dt = (dt + ct + 1 >> 1) + 4112, ct = dt - ct, Ue = 3784 * wt + 1567 * Ht + 2048 >> 12, wt = 1567 * wt - 3784 * Ht + 2048 >> 12, Ht = Ue, ut = ut + bt + 1 >> 1, bt = ut - bt, Ke = Ke + it + 1 >> 1, it = Ke - it, dt = dt + Ht + 1 >> 1, Ht = dt - Ht, ct = ct + wt + 1 >> 1, wt = ct - wt, Ue = 2276 * ut + 3406 * Ke + 2048 >> 12, ut = 3406 * ut - 2276 * Ke + 2048 >> 12, Ke = Ue, Ue = 799 * it + 4017 * bt + 2048 >> 12, it = 4017 * it - 799 * bt + 2048 >> 12, bt = Ue, Ue = dt + Ke, Ke = dt - Ke, we = ct + bt, pt = ct - bt, Ce = wt + it, bt = wt - it, it = Ht + ut, ut = Ht - ut, Ue = 16 > Ue ? 0 : 4080 <= Ue ? 255 : Ue >> 4, we = 16 > we ? 0 : 4080 <= we ? 255 : we >> 4, Ce = 16 > Ce ? 0 : 4080 <= Ce ? 255 : Ce >> 4, it = 16 > it ? 0 : 4080 <= it ? 255 : it >> 4, ut = 16 > ut ? 0 : 4080 <= ut ? 255 : ut >> 4, bt = 16 > bt ? 0 : 4080 <= bt ? 255 : bt >> 4, pt = 16 > pt ? 0 : 4080 <= pt ? 255 : pt >> 4, Ke = 16 > Ke ? 0 : 4080 <= Ke ? 255 : Ke >> 4, Ve[me + ge] = Ue, Ve[me + ge + 8] = we, Ve[me + ge + 16] = Ce, Ve[me + ge + 24] = it, Ve[me + ge + 32] = ut, Ve[me + ge + 40] = bt, Ve[me + ge + 48] = pt, Ve[me + ge + 56] = Ke) : (Ue = 5793 * Ue + 8192 >> 14, Ue = -2040 > Ue ? 0 : 2024 <= Ue ? 255 : Ue + 2056 >> 4, Ve[me + ge] = Ue, Ve[me + ge + 8] = Ue, Ve[me + ge + 16] = Ue, Ve[me + ge + 24] = Ue, Ve[me + ge + 32] = Ue, Ve[me + ge + 40] = Ue, Ve[me + ge + 48] = Ue, Ve[me + ge + 56] = Ue);
                    }
                    return T.a;
                  }
                  function S(j, T) {
                    var W = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : T, J = j.length - 1;
                    if (W = W < T ? W : T, T >= J) return null;
                    var ee = j[T] << 8 | j[T + 1];
                    if (65472 <= ee && 65534 >= ee) return { f: null, F: ee, offset: T };
                    for (var te = j[W] << 8 | j[W + 1]; !(65472 <= te && 65534 >= te); ) {
                      if (++W >= J) return null;
                      te = j[W] << 8 | j[W + 1];
                    }
                    return { f: ee.toString(16), F: te, offset: W };
                  }
                  var U = new Uint8Array([
                    0,
                    1,
                    8,
                    16,
                    9,
                    2,
                    3,
                    10,
                    17,
                    24,
                    32,
                    25,
                    18,
                    11,
                    4,
                    5,
                    12,
                    19,
                    26,
                    33,
                    40,
                    48,
                    41,
                    34,
                    27,
                    20,
                    13,
                    6,
                    7,
                    14,
                    21,
                    28,
                    35,
                    42,
                    49,
                    56,
                    57,
                    50,
                    43,
                    36,
                    29,
                    22,
                    15,
                    23,
                    30,
                    37,
                    44,
                    51,
                    58,
                    59,
                    52,
                    45,
                    38,
                    31,
                    39,
                    46,
                    53,
                    60,
                    61,
                    54,
                    47,
                    55,
                    62,
                    63
                  ]);
                  w.prototype = { parse: function(j) {
                    function T() {
                      var wt = j[le] << 8 | j[le + 1];
                      return le += 2, wt;
                    }
                    function W() {
                      var wt = T();
                      wt = le + wt - 2;
                      var Ht = S(j, wt, le);
                      return Ht && Ht.f && ((0, _util.warn)("readDataBlock - incorrect length, current marker is: " + Ht.f), wt = Ht.offset), wt = j.subarray(le, wt), le += wt.length, wt;
                    }
                    function J(wt) {
                      for (var Ht = Math.ceil(wt.v / 8 / wt.s), $t = Math.ceil(wt.g / 8 / wt.u), rt = 0; rt < wt.b.length; rt++) {
                        dt = wt.b[rt];
                        var ri = Math.ceil(Math.ceil(wt.v / 8) * dt.h / wt.s), wi = Math.ceil(Math.ceil(wt.g / 8) * dt.j / wt.u);
                        dt.a = new Int16Array(64 * $t * dt.j * (Ht * dt.h + 1)), dt.c = ri, dt.l = wi;
                      }
                      wt.P = Ht, wt.O = $t;
                    }
                    var ee = (1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}).N, te = ee === void 0 ? null : ee, le = 0, me = null, ke = 0;
                    ee = [];
                    var ge = [], Ve = [], Oe = T();
                    if (Oe !== 65496) throw new x("SOI not found");
                    for (Oe = T(); Oe !== 65497; ) {
                      switch (Oe) {
                        case 65504:
                        case 65505:
                        case 65506:
                        case 65507:
                        case 65508:
                        case 65509:
                        case 65510:
                        case 65511:
                        case 65512:
                        case 65513:
                        case 65514:
                        case 65515:
                        case 65516:
                        case 65517:
                        case 65518:
                        case 65519:
                        case 65534:
                          var Ue = W();
                          Oe === 65518 && Ue[0] === 65 && Ue[1] === 100 && Ue[2] === 111 && Ue[3] === 98 && Ue[4] === 101 && (me = { version: Ue[5] << 8 | Ue[6], Y: Ue[7] << 8 | Ue[8], Z: Ue[9] << 8 | Ue[10], W: Ue[11] });
                          break;
                        case 65499:
                          Oe = T() + le - 2;
                          for (var we; le < Oe; ) {
                            var Ce = j[le++], it = new Uint16Array(64);
                            if (Ce >> 4) if (Ce >> 4 === 1) for (Ue = 0; 64 > Ue; Ue++) we = U[Ue], it[we] = T();
                            else throw new x("DQT - invalid table spec");
                            else for (Ue = 0; 64 > Ue; Ue++) we = U[Ue], it[we] = j[le++];
                            ee[Ce & 15] = it;
                          }
                          break;
                        case 65472:
                        case 65473:
                        case 65474:
                          if (ut) throw new x("Only single frame JPEGs supported");
                          T();
                          var ut = {};
                          for (ut.X = Oe === 65473, ut.S = Oe === 65474, ut.precision = j[le++], Oe = T(), ut.g = te || Oe, ut.v = T(), ut.b = [], ut.C = {}, Ue = j[le++], Oe = it = Ce = 0; Oe < Ue; Oe++) {
                            we = j[le];
                            var bt = j[le + 1] >> 4, pt = j[le + 1] & 15;
                            Ce < bt && (Ce = bt), it < pt && (it = pt), bt = ut.b.push({ h: bt, j: pt, T: j[le + 2], G: null }), ut.C[we] = bt - 1, le += 3;
                          }
                          ut.s = Ce, ut.u = it, J(ut);
                          break;
                        case 65476:
                          for (we = T(), Oe = 2; Oe < we; ) {
                            for (Ce = j[le++], it = new Uint8Array(16), Ue = bt = 0; 16 > Ue; Ue++, le++) bt += it[Ue] = j[le];
                            for (pt = new Uint8Array(bt), Ue = 0; Ue < bt; Ue++, le++) pt[Ue] = j[le];
                            Oe += 17 + bt, (Ce >> 4 ? ge : Ve)[Ce & 15] = k(it, pt);
                          }
                          break;
                        case 65501:
                          T();
                          var Ke = T();
                          break;
                        case 65498:
                          for (Ue = ++ke === 1 && !te, T(), Ce = j[le++], we = [], Oe = 0; Oe < Ce; Oe++) {
                            it = ut.C[j[le++]];
                            var dt = ut.b[it];
                            it = j[le++], dt.D = Ve[it >> 4], dt.o = ge[it & 15], we.push(dt);
                          }
                          Oe = j[le++], Ce = j[le++], it = j[le++];
                          try {
                            var ct = E(j, le, ut, we, Ke, Oe, Ce, it >> 4, it & 15, Ue);
                            le += ct;
                          } catch (wt) {
                            if (wt instanceof m) return (0, _util.warn)('Attempting to re-parse JPEG image using "scanLines" parameter found in DNL marker (0xFFDC) segment.'), this.parse(j, { N: wt.g });
                            throw wt;
                          }
                          break;
                        case 65500:
                          le += 4;
                          break;
                        case 65535:
                          j[le] !== 255 && le--;
                          break;
                        default:
                          if (j[le - 3] === 255 && 192 <= j[le - 2] && 254 >= j[le - 2]) le -= 3;
                          else if ((Ue = S(j, le - 2)) && Ue.f) (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + Ue.f), le = Ue.offset;
                          else throw new x("unknown marker " + Oe.toString(16));
                      }
                      Oe = T();
                    }
                    for (this.width = ut.v, this.height = ut.g, this.A = me, this.b = [], Oe = 0; Oe < ut.b.length; Oe++)
                      dt = ut.b[Oe], (Ke = ee[dt.T]) && (dt.G = Ke), this.b.push({ R: P(ut, dt), U: dt.h / ut.s, V: dt.j / ut.u, c: dt.c, l: dt.l });
                    this.i = this.b.length;
                  }, L: function(j, T) {
                    var W = this.width / j, J = this.height / T, ee, te, le = this.b.length, me = j * T * le, ke = new Uint8ClampedArray(me), ge = new Uint32Array(j);
                    for (te = 0; te < le; te++) {
                      var Ve = this.b[te], Oe = Ve.U * W, Ue = Ve.V * J, we = te, Ce = Ve.R, it = Ve.c + 1 << 3;
                      for (ee = 0; ee < j; ee++) Ve = 0 | ee * Oe, ge[ee] = (Ve & 4294967288) << 3 | Ve & 7;
                      for (Oe = 0; Oe < T; Oe++) for (Ve = 0 | Oe * Ue, Ve = it * (Ve & 4294967288) | (Ve & 7) << 3, ee = 0; ee < j; ee++) ke[we] = Ce[Ve + ge[ee]], we += le;
                    }
                    if (J = this.M) for (te = 0; te < me; ) for (W = Ve = 0; Ve < le; Ve++, te++, W += 2) ke[te] = (ke[te] * J[W] >> 8) + J[W + 1];
                    return ke;
                  }, w: function() {
                    return this.A ? !!this.A.W : this.i === 3 ? this.B !== 0 : this.B === 1;
                  }, I: function(j) {
                    for (var T, W, J, ee = 0, te = j.length; ee < te; ee += 3) T = j[ee], W = j[ee + 1], J = j[ee + 2], j[ee] = T - 179.456 + 1.402 * J, j[ee + 1] = T + 135.459 - 0.344 * W - 0.714 * J, j[ee + 2] = T - 226.816 + 1.772 * W;
                    return j;
                  }, K: function(j) {
                    for (var T, W, J, ee, te = 0, le = 0, me = j.length; le < me; le += 4) T = j[le], W = j[le + 1], J = j[le + 2], ee = j[le + 3], j[te++] = -122.67195406894 + W * (-660635669420364e-19 * W + 437130475926232e-18 * J - 54080610064599e-18 * T + 48449797120281e-17 * ee - 0.154362151871126) + J * (-957964378445773e-18 * J + 817076911346625e-18 * T - 0.00477271405408747 * ee + 1.53380253221734) + T * (961250184130688e-18 * T - 0.00266257332283933 * ee + 0.48357088451265) + ee * (-336197177618394e-18 * ee + 0.484791561490776), j[te++] = 107.268039397724 + W * (219927104525741e-19 * W - 640992018297945e-18 * J + 659397001245577e-18 * T + 426105652938837e-18 * ee - 0.176491792462875) + J * (-778269941513683e-18 * J + 0.00130872261408275 * T + 770482631801132e-18 * ee - 0.151051492775562) + T * (0.00126935368114843 * T - 0.00265090189010898 * ee + 0.25802910206845) + ee * (-318913117588328e-18 * ee - 0.213742400323665), j[te++] = -20.810012546947 + W * (-570115196973677e-18 * W - 263409051004589e-19 * J + 0.0020741088115012 * T - 0.00288260236853442 * ee + 0.814272968359295) + J * (-153496057440975e-19 * J - 132689043961446e-18 * T + 560833691242812e-18 * ee - 0.195152027534049) + T * (0.00174418132927582 * T - 0.00255243321439347 * ee + 0.116935020465145) + ee * (-343531996510555e-18 * ee + 0.24165260232407);
                    return j.subarray(
                      0,
                      te
                    );
                  }, J: function(j) {
                    for (var T, W, J, ee = 0, te = j.length; ee < te; ee += 4) T = j[ee], W = j[ee + 1], J = j[ee + 2], j[ee] = 434.456 - T - 1.402 * J, j[ee + 1] = 119.541 - T + 0.344 * W + 0.714 * J, j[ee + 2] = 481.816 - T - 1.772 * W;
                    return j;
                  }, H: function(j) {
                    for (var T, W, J, ee, te = 0, le = 1 / 255, me = 0, ke = j.length; me < ke; me += 4) T = j[me] * le, W = j[me + 1] * le, J = j[me + 2] * le, ee = j[me + 3] * le, j[te++] = 255 + T * (-4.387332384609988 * T + 54.48615194189176 * W + 18.82290502165302 * J + 212.25662451639585 * ee - 285.2331026137004) + W * (1.7149763477362134 * W - 5.6096736904047315 * J - 17.873870861415444 * ee - 5.497006427196366) + J * (-2.5217340131683033 * J - 21.248923337353073 * ee + 17.5119270841813) - ee * (21.86122147463605 * ee + 189.48180835922747), j[te++] = 255 + T * (8.841041422036149 * T + 60.118027045597366 * W + 6.871425592049007 * J + 31.159100130055922 * ee - 79.2970844816548) + W * (-15.310361306967817 * W + 17.575251261109482 * J + 131.35250912493976 * ee - 190.9453302588951) + J * (4.444339102852739 * J + 9.8632861493405 * ee - 24.86741582555878) - ee * (20.737325471181034 * ee + 187.80453709719578), j[te++] = 255 + T * (0.8842522430003296 * T + 8.078677503112928 * W + 30.89978309703729 * J - 0.23883238689178934 * ee - 14.183576799673286) + W * (10.49593273432072 * W + 63.02378494754052 * J + 50.606957656360734 * ee - 112.23884253719248) + J * (0.03296041114873217 * J + 115.60384449646641 * ee - 193.58209356861505) - ee * (22.33816807309886 * ee + 180.12613974708367);
                    return j.subarray(0, te);
                  }, getData: function(j, T, W) {
                    if (4 < this.i) throw new x("Unsupported color mode");
                    if (j = this.L(j, T), this.i === 1 && W) {
                      W = j.length, T = new Uint8ClampedArray(3 * W);
                      for (var J = 0, ee = 0; ee < W; ee++) {
                        var te = j[ee];
                        T[J++] = te, T[J++] = te, T[J++] = te;
                      }
                      return T;
                    }
                    if (this.i === 3 && this.w()) return this.I(j);
                    if (this.i === 4) {
                      if (this.w()) return W ? this.K(j) : this.J(j);
                      if (W) return this.H(j);
                    }
                    return j;
                  } }, R.JpegDecoder = w;
                })();
              })(), R.encodeImage = function(M, x, m, w) {
                var k = {
                  t256: [x],
                  t257: [m],
                  t258: [8, 8, 8, 8],
                  t259: [1],
                  t262: [2],
                  t273: [1e3],
                  // strips offset
                  t277: [4],
                  t278: [m],
                  /* rows per strip */
                  t279: [x * m * 4],
                  // strip byte counts
                  t282: [1],
                  t283: [1],
                  t284: [1],
                  t286: [0],
                  t287: [0],
                  t296: [1],
                  t305: ["Photopea (UTIF.js)"],
                  t338: [1]
                };
                if (w) for (var E in w) k[E] = w[E];
                for (var P = new Uint8Array(R.encode([k])), S = new Uint8Array(M), U = new Uint8Array(1e3 + x * m * 4), E = 0; E < P.length; E++) U[E] = P[E];
                for (var E = 0; E < S.length; E++) U[1e3 + E] = S[E];
                return U.buffer;
              }, R.encode = function(M) {
                var x = new Uint8Array(2e4), m = 4, w = R._binBE;
                x[0] = 77, x[1] = 77, x[3] = 42;
                var k = 8;
                w.writeUint(x, m, k), m += 4;
                for (var E = 0; E < M.length; E++) {
                  var P = R._writeIFD(w, x, k, M[E]);
                  k = P[1], E < M.length - 1 && w.writeUint(x, P[0], k);
                }
                return x.slice(0, k).buffer;
              }, R.decode = function(M) {
                R.decode._decodeG3.allow2D = null;
                var x = new Uint8Array(M), m = 0, w = R._binBE.readASCII(x, m, 2);
                m += 2;
                var k = w == "II" ? R._binLE : R._binBE;
                k.readUshort(x, m), m += 2;
                var E = k.readUint(x, m);
                m += 4;
                for (var P = []; ; ) {
                  var S = R._readIFD(k, x, E, P);
                  if (E = k.readUint(x, S), E == 0) break;
                }
                return P;
              }, R.decodeImages = function(M, x) {
                for (var m = new Uint8Array(M), w = R._binBE.readASCII(m, 0, 2), k = 0; k < x.length; k++) {
                  var E = x[k];
                  if (E.t256 != null) {
                    E.isLE = w == "II", E.width = E.t256[0], E.height = E.t257[0];
                    var P = E.t259 ? E.t259[0] : 1, S = E.t266 ? E.t266[0] : 1;
                    E.t284 && E.t284[0] == 2 && Z("PlanarConfiguration 2 should not be used!");
                    var U = (E.t258 ? Math.min(32, E.t258[0]) : 1) * (E.t277 ? E.t277[0] : 1), j = Math.ceil(E.width * U / 8) * 8, T = E.t273;
                    T == null && (T = E.t324);
                    var W = E.t279;
                    P == 1 && T.length == 1 && (W = [E.height * (j >>> 3)]), W == null && (W = E.t325);
                    var J = new Uint8Array(E.height * (j >>> 3)), ee = 0;
                    if (E.t322 != null) {
                      for (var te = E.t322[0], le = E.t323[0], me = Math.floor((E.width + te - 1) / te), ke = Math.floor((E.height + le - 1) / le), ge = new Uint8Array(Math.ceil(te * le * U / 8) | 0), Ve = 0; Ve < ke; Ve++)
                        for (var Oe = 0; Oe < me; Oe++) {
                          for (var Ue = Ve * me + Oe, we = 0; we < ge.length; we++) ge[we] = 0;
                          R.decode._decompress(E, m, T[Ue], W[Ue], P, ge, 0, S), P == 6 ? J = ge : R._copyTile(ge, Math.ceil(te * U / 8) | 0, le, J, Math.ceil(E.width * U / 8) | 0, E.height, Math.ceil(Oe * te * U / 8) | 0, Ve * le);
                        }
                      ee = J.length * 8;
                    } else {
                      var Ce = E.t278 ? E.t278[0] : E.height;
                      Ce = Math.min(Ce, E.height);
                      for (var Ue = 0; Ue < T.length; Ue++)
                        R.decode._decompress(E, m, T[Ue], W[Ue], P, J, Math.ceil(ee / 8) | 0, S), ee += j * Ce;
                      ee = Math.min(ee, J.length * 8);
                    }
                    E.data = new Uint8Array(J.buffer, 0, Math.ceil(ee / 8) | 0);
                  }
                }
              }, R.decode._decompress = function(M, x, m, w, k, E, P, S) {
                if (k == 1) for (var U = 0; U < w; U++) E[P + U] = x[m + U];
                else if (k == 3) R.decode._decodeG3(x, m, w, E, P, M.width, S);
                else if (k == 4) R.decode._decodeG4(x, m, w, E, P, M.width, S);
                else if (k == 5) R.decode._decodeLZW(x, m, E, P);
                else if (k == 6) R.decode._decodeOldJPEG(M, x, m, w, E, P);
                else if (k == 7) R.decode._decodeNewJPEG(M, x, m, w, E, P);
                else if (k == 8)
                  for (var j = new Uint8Array(x.buffer, m, w), T = A.inflate(j), W = 0; W < T.length; W++) E[P + W] = T[W];
                else k == 32773 ? R.decode._decodePackBits(x, m, w, E, P) : k == 32809 ? R.decode._decodeThunder(x, m, w, E, P) : Z("Unknown compression", k);
                if (M.t317 && M.t317[0] == 2)
                  for (var J = M.t277 ? M.t277[0] : 1, ee = M.t278 ? M.t278[0] : M.height, te = M.width * J, le = 0; le < ee; le++) {
                    var me = P + le * te;
                    if (J == 3) for (var U = 3; U < te; U += 3)
                      E[me + U] = E[me + U] + E[me + U - 3] & 255, E[me + U + 1] = E[me + U + 1] + E[me + U - 2] & 255, E[me + U + 2] = E[me + U + 2] + E[me + U - 1] & 255;
                    else for (var U = J; U < te; U++) E[me + U] = E[me + U] + E[me + U - J] & 255;
                  }
              }, R.decode._decodeNikon = function(M, x, S, w, k) {
                var E, P, S;
                Z(M.slice(x, x + 100)), E = M[x], x++, P = M[x], x++, Z(E.toString(16), P.toString(16), S);
              }, R.decode._decodeNewJPEG = function(M, x, m, w, k, E) {
                var P = M.t347, S = P ? P.length : 0, U = new Uint8Array(S + w);
                if (P) {
                  for (var j = 216, T = 217, W = 0, J = 0; J < S - 1 && !(P[J] == 255 && P[J + 1] == T); J++)
                    U[W++] = P[J];
                  var ee = x[m], te = x[m + 1];
                  (ee != 255 || te != j) && (U[W++] = ee, U[W++] = te);
                  for (var J = 2; J < w; J++) U[W++] = x[m + J];
                } else for (var J = 0; J < w; J++) U[J] = x[m + J];
                if (M.t262 == 32803) {
                  var le = M.t258[0], me = new LosslessJpegDecoder(), ke = me.decode(U), ge = ke.length;
                  if (le == 16) for (var J = 0; J < ge; J++)
                    k[E++] = ke[J] & 255, k[E++] = ke[J] >>> 8;
                  else if (le == 12) for (var J = 0; J < ge; J += 2)
                    k[E++] = ke[J] >>> 4, k[E++] = (ke[J] << 4 | ke[J + 1] >>> 8) & 255, k[E++] = ke[J + 1] & 255;
                  else throw new Error("unsupported bit depth " + le);
                } else {
                  var Ve = new R.JpegDecoder();
                  Ve.parse(U);
                  for (var Oe = Ve.getData(Ve.width, Ve.height), J = 0; J < Oe.length; J++) k[E + J] = Oe[J];
                }
                M.t262[0] == 6 && (M.t262[0] = 2);
              }, R.decode._decodeOldJPEGInit = function(M, x, m, w) {
                var k = 216, E = 219, P = 196, S = 221, U = 192, j = 218, T = 0, W = 0, J, ee, te = !1, le, me, ke, ge = M.t513, Ve = ge ? ge[0] : 0, Oe = M.t514, Ue = Oe ? Oe[0] : 0, we = M.t324 || M.t273 || ge, Ce = M.t530, it = 0, ut = 0, bt = M.t277 ? M.t277[0] : 1, pt = M.t515;
                if (we && (W = we[0], te = we.length > 1), !te) {
                  if (x[m] == 255 && x[m + 1] == k) return { jpegOffset: m };
                  if (ge != null && (x[m + Ve] == 255 && x[m + Ve + 1] == k ? T = m + Ve : Z("JPEGInterchangeFormat does not point to SOI"), Oe == null ? Z("JPEGInterchangeFormatLength field is missing") : (Ve >= W || Ve + Ue <= W) && Z("JPEGInterchangeFormatLength field value is invalid"), T != null))
                    return { jpegOffset: T };
                }
                if (Ce != null && (it = Ce[0], ut = Ce[1]), ge != null && Oe != null)
                  if (Ue >= 2 && Ve + Ue <= W) {
                    for (x[m + Ve + Ue - 2] == 255 && x[m + Ve + Ue - 1] == k ? J = new Uint8Array(Ue - 2) : J = new Uint8Array(Ue), le = 0; le < J.length; le++) J[le] = x[m + Ve + le];
                    Z("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
                  } else Z("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
                if (J == null) {
                  var Ke = 0, dt = [];
                  dt[Ke++] = 255, dt[Ke++] = k;
                  var ct = M.t519;
                  if (ct == null) throw new Error("JPEGQTables tag is missing");
                  for (le = 0; le < ct.length; le++)
                    for (dt[Ke++] = 255, dt[Ke++] = E, dt[Ke++] = 0, dt[Ke++] = 67, dt[Ke++] = le, me = 0; me < 64; me++) dt[Ke++] = x[m + ct[le] + me];
                  for (ke = 0; ke < 2; ke++) {
                    var wt = M[ke == 0 ? "t520" : "t521"];
                    if (wt == null) throw new Error((ke == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
                    for (le = 0; le < wt.length; le++) {
                      dt[Ke++] = 255, dt[Ke++] = P;
                      var Ht = 19;
                      for (me = 0; me < 16; me++) Ht += x[m + wt[le] + me];
                      for (dt[Ke++] = Ht >>> 8, dt[Ke++] = Ht & 255, dt[Ke++] = le | ke << 4, me = 0; me < 16; me++) dt[Ke++] = x[m + wt[le] + me];
                      for (me = 0; me < Ht; me++) dt[Ke++] = x[m + wt[le] + 16 + me];
                    }
                  }
                  if (dt[Ke++] = 255, dt[Ke++] = U, dt[Ke++] = 0, dt[Ke++] = 8 + 3 * bt, dt[Ke++] = 8, dt[Ke++] = M.height >>> 8 & 255, dt[Ke++] = M.height & 255, dt[Ke++] = M.width >>> 8 & 255, dt[Ke++] = M.width & 255, dt[Ke++] = bt, bt == 1)
                    dt[Ke++] = 1, dt[Ke++] = 17, dt[Ke++] = 0;
                  else for (le = 0; le < 3; le++)
                    dt[Ke++] = le + 1, dt[Ke++] = le != 0 ? 17 : (it & 15) << 4 | ut & 15, dt[Ke++] = le;
                  pt != null && pt[0] != 0 && (dt[Ke++] = 255, dt[Ke++] = S, dt[Ke++] = 0, dt[Ke++] = 4, dt[Ke++] = pt[0] >>> 8 & 255, dt[Ke++] = pt[0] & 255), J = new Uint8Array(dt);
                }
                var $t = -1;
                for (le = 0; le < J.length - 1; ) {
                  if (J[le] == 255 && J[le + 1] == U) {
                    $t = le;
                    break;
                  }
                  le++;
                }
                if ($t == -1) {
                  var rt = new Uint8Array(J.length + 10 + 3 * bt);
                  rt.set(J);
                  var ri = J.length;
                  if ($t = J.length, J = rt, J[ri++] = 255, J[ri++] = U, J[ri++] = 0, J[ri++] = 8 + 3 * bt, J[ri++] = 8, J[ri++] = M.height >>> 8 & 255, J[ri++] = M.height & 255, J[ri++] = M.width >>> 8 & 255, J[ri++] = M.width & 255, J[ri++] = bt, bt == 1)
                    J[ri++] = 1, J[ri++] = 17, J[ri++] = 0;
                  else for (le = 0; le < 3; le++)
                    J[ri++] = le + 1, J[ri++] = le != 0 ? 17 : (it & 15) << 4 | ut & 15, J[ri++] = le;
                }
                if (x[W] == 255 && x[W + 1] == j) {
                  var wi = x[W + 2] << 8 | x[W + 3];
                  for (ee = new Uint8Array(wi + 2), ee[0] = x[W], ee[1] = x[W + 1], ee[2] = x[W + 2], ee[3] = x[W + 3], le = 0; le < wi - 2; le++) ee[le + 4] = x[W + le + 4];
                } else {
                  ee = new Uint8Array(8 + 2 * bt);
                  var Qt = 0;
                  if (ee[Qt++] = 255, ee[Qt++] = j, ee[Qt++] = 0, ee[Qt++] = 6 + 2 * bt, ee[Qt++] = bt, bt == 1)
                    ee[Qt++] = 1, ee[Qt++] = 0;
                  else for (le = 0; le < 3; le++)
                    ee[Qt++] = le + 1, ee[Qt++] = le << 4 | le;
                  ee[Qt++] = 0, ee[Qt++] = 63, ee[Qt++] = 0;
                }
                return { jpegOffset: m, tables: J, sosMarker: ee, sofPosition: $t };
              }, R.decode._decodeOldJPEG = function(M, x, m, w, k, E) {
                var P, S, U, j, T = R.decode._decodeOldJPEGInit(M, x, m, w);
                if (T.jpegOffset != null)
                  for (S = m + w - T.jpegOffset, j = new Uint8Array(S), P = 0; P < S; P++) j[P] = x[T.jpegOffset + P];
                else {
                  for (U = T.tables.length, j = new Uint8Array(U + T.sosMarker.length + w + 2), j.set(T.tables), j[T.sofPosition + 5] = M.height >>> 8 & 255, j[T.sofPosition + 6] = M.height & 255, j[T.sofPosition + 7] = M.width >>> 8 & 255, j[T.sofPosition + 8] = M.width & 255, (x[m] != 255 || x[m + 1] != SOS) && (j.set(T.sosMarker, bufoff), bufoff += sosMarker.length), P = 0; P < w; P++) j[bufoff++] = x[m + P];
                  j[bufoff++] = 255, j[bufoff++] = EOI;
                }
                var W = new R.JpegDecoder();
                W.parse(j);
                for (var J = W.getData(W.width, W.height), P = 0; P < J.length; P++) k[E + P] = J[P];
                M.t262[0] == 6 && (M.t262[0] = 2);
              }, R.decode._decodePackBits = function(M, x, m, w, k) {
                for (var E = new Int8Array(M.buffer), P = new Int8Array(w.buffer), S = x + m; x < S; ) {
                  var U = E[x];
                  if (x++, U >= 0 && U < 128) for (var j = 0; j < U + 1; j++)
                    P[k] = E[x], k++, x++;
                  if (U >= -127 && U < 0) {
                    for (var j = 0; j < -U + 1; j++)
                      P[k] = E[x], k++;
                    x++;
                  }
                }
              }, R.decode._decodeThunder = function(M, x, m, w, k) {
                for (var E = [0, 1, 0, -1], P = [0, 1, 2, 3, 0, -3, -2, -1], S = x + m, U = k * 2, j = 0; x < S; ) {
                  var T = M[x], W = T >>> 6, J = T & 63;
                  if (x++, W == 3 && (j = J & 15, w[U >>> 1] |= j << 4 * (1 - U & 1), U++), W == 0) for (var ee = 0; ee < J; ee++)
                    w[U >>> 1] |= j << 4 * (1 - U & 1), U++;
                  if (W == 2) for (var ee = 0; ee < 2; ee++) {
                    var te = J >>> 3 * (1 - ee) & 7;
                    te != 4 && (j += P[te], w[U >>> 1] |= j << 4 * (1 - U & 1), U++);
                  }
                  if (W == 1) for (var ee = 0; ee < 3; ee++) {
                    var te = J >>> 2 * (2 - ee) & 3;
                    te != 2 && (j += E[te], w[U >>> 1] |= j << 4 * (1 - U & 1), U++);
                  }
                }
              }, R.decode._dmap = { 1: 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 }, R.decode._lens = function() {
                var M = function(U, j, T, W) {
                  for (var J = 0; J < j.length; J++) U[j[J]] = T + J * W;
                }, x = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", m = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", w = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", k = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", E = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
                x = x.split(","), m = m.split(","), w = w.split(","), k = k.split(","), E = E.split(",");
                var P = {}, S = {};
                return M(P, x, 0, 1), M(P, w, 64, 64), M(P, E, 1792, 64), M(S, m, 0, 1), M(S, k, 64, 64), M(S, E, 1792, 64), [P, S];
              }(), R.decode._decodeG4 = function(M, x, m, w, k, E, P) {
                for (var S = R.decode, U = x << 3, j = 0, T = "", W = [], J = [], ee = 0; ee < E; ee++) J.push(0);
                J = S._makeDiff(J);
                for (var te = 0, le = 0, me = 0, ke = 0, ge = 0, Ve = 0, Oe = "", Ue = 0, we = Math.ceil(E / 8) * 8; U >>> 3 < x + m; ) {
                  me = S._findDiff(J, te + (te == 0 ? 0 : 1), 1 - ge), ke = S._findDiff(J, me, ge);
                  var Ce = 0;
                  if (P == 1 && (Ce = M[U >>> 3] >>> 7 - (U & 7) & 1), P == 2 && (Ce = M[U >>> 3] >>> (U & 7) & 1), U++, T += Ce, Oe == "H") {
                    if (S._lens[ge][T] != null) {
                      var it = S._lens[ge][T];
                      T = "", j += it, it < 64 && (S._addNtimes(W, j, ge), te += j, ge = 1 - ge, j = 0, Ue--, Ue == 0 && (Oe = ""));
                    }
                  } else
                    T == "0001" && (T = "", S._addNtimes(W, ke - te, ge), te = ke), T == "001" && (T = "", Oe = "H", Ue = 2), S._dmap[T] != null && (le = me + S._dmap[T], S._addNtimes(W, le - te, ge), te = le, T = "", ge = 1 - ge);
                  W.length == E && Oe == "" && (S._writeBits(W, w, k * 8 + Ve * we), ge = 0, Ve++, te = 0, J = S._makeDiff(W), W = []);
                }
              }, R.decode._findDiff = function(M, x, m) {
                for (var w = 0; w < M.length; w += 2) if (M[w] >= x && M[w + 1] == m) return M[w];
              }, R.decode._makeDiff = function(M) {
                var x = [];
                M[0] == 1 && x.push(0, 1);
                for (var m = 1; m < M.length; m++) M[m - 1] != M[m] && x.push(m, M[m]);
                return x.push(M.length, 0, M.length, 1), x;
              }, R.decode._decodeG3 = function(M, x, m, w, k, E, P) {
                for (var S = R.decode, U = x << 3, j = 0, T = "", W = [], J = [], ee = 0; ee < E; ee++) W.push(0);
                for (var te = 0, le = 0, me = 0, ke = 0, ge = 0, Ve = -1, Oe = "", Ue = 0, we = !1, Ce = Math.ceil(E / 8) * 8; U >>> 3 < x + m; ) {
                  me = S._findDiff(J, te + (te == 0 ? 0 : 1), 1 - ge), ke = S._findDiff(J, me, ge);
                  var it = 0;
                  if (P == 1 && (it = M[U >>> 3] >>> 7 - (U & 7) & 1), P == 2 && (it = M[U >>> 3] >>> (U & 7) & 1), U++, T += it, we) {
                    if (S._lens[ge][T] != null) {
                      var ut = S._lens[ge][T];
                      T = "", j += ut, ut < 64 && (S._addNtimes(W, j, ge), ge = 1 - ge, j = 0);
                    }
                  } else if (Oe == "H") {
                    if (S._lens[ge][T] != null) {
                      var ut = S._lens[ge][T];
                      T = "", j += ut, ut < 64 && (S._addNtimes(W, j, ge), te += j, ge = 1 - ge, j = 0, Ue--, Ue == 0 && (Oe = ""));
                    }
                  } else
                    T == "0001" && (T = "", S._addNtimes(W, ke - te, ge), te = ke), T == "001" && (T = "", Oe = "H", Ue = 2), S._dmap[T] != null && (le = me + S._dmap[T], S._addNtimes(W, le - te, ge), te = le, T = "", ge = 1 - ge);
                  T.endsWith("000000000001") && (Ve >= 0 && S._writeBits(W, w, k * 8 + Ve * Ce), P == 1 && (we = (M[U >>> 3] >>> 7 - (U & 7) & 1) == 1), P == 2 && (we = (M[U >>> 3] >>> (U & 7) & 1) == 1), U++, S._decodeG3.allow2D == null && (S._decodeG3.allow2D = we), S._decodeG3.allow2D || (we = !0, U--), T = "", ge = 0, Ve++, te = 0, J = S._makeDiff(W), W = []);
                }
                W.length == E && S._writeBits(W, w, k * 8 + Ve * Ce);
              }, R.decode._addNtimes = function(M, x, m) {
                for (var w = 0; w < x; w++) M.push(m);
              }, R.decode._writeBits = function(M, x, m) {
                for (var w = 0; w < M.length; w++) x[m + w >>> 3] |= M[w] << 7 - (m + w & 7);
              }, R.decode._decodeLZW = function(M, x, m, w) {
                if (R.decode._lzwTab == null) {
                  for (var k = new Uint32Array(65535), E = new Uint16Array(65535), T = new Uint8Array(2e6), P = 0; P < 256; P++)
                    T[P << 2] = P, k[P] = P << 2, E[P] = 1;
                  R.decode._lzwTab = [k, E, T];
                }
                for (var S = R.decode._copyData, U = R.decode._lzwTab[0], j = R.decode._lzwTab[1], T = R.decode._lzwTab[2], W = 258, J = 1032, ee = 9, te = x << 3, le = 256, me = 257, ke = 0, ge = 0, Ve = 0; ke = M[te >>> 3] << 16 | M[te + 8 >>> 3] << 8 | M[te + 16 >>> 3], ge = ke >> 24 - (te & 7) - ee & (1 << ee) - 1, te += ee, ge != me; ) {
                  if (ge == le) {
                    if (ee = 9, W = 258, J = 1032, ke = M[te >>> 3] << 16 | M[te + 8 >>> 3] << 8 | M[te + 16 >>> 3], ge = ke >> 24 - (te & 7) - ee & (1 << ee) - 1, te += ee, ge == me) break;
                    m[w] = ge, w++;
                  } else if (ge < W) {
                    var Oe = U[ge], Ue = j[ge];
                    if (S(T, Oe, m, w, Ue), w += Ue, Ve >= W)
                      U[W] = J, T[U[W]] = Oe[0], j[W] = 1, J = J + 1 + 3 & -4, W++;
                    else {
                      U[W] = J;
                      var we = U[Ve], Ce = j[Ve];
                      S(T, we, T, J, Ce), T[J + Ce] = T[Oe], Ce++, j[W] = Ce, W++, J = J + Ce + 3 & -4;
                    }
                    W + 1 == 1 << ee && ee++;
                  } else {
                    if (Ve >= W)
                      U[W] = J, j[W] = 0, W++;
                    else {
                      U[W] = J;
                      var we = U[Ve], Ce = j[Ve];
                      S(T, we, T, J, Ce), T[J + Ce] = T[J], Ce++, j[W] = Ce, W++, S(T, J, m, w, Ce), w += Ce, J = J + Ce + 3 & -4;
                    }
                    W + 1 == 1 << ee && ee++;
                  }
                  Ve = ge;
                }
              }, R.decode._copyData = function(M, x, m, w, k) {
                for (var E = 0; E < k; E += 4)
                  m[w + E] = M[x + E], m[w + E + 1] = M[x + E + 1], m[w + E + 2] = M[x + E + 2], m[w + E + 3] = M[x + E + 3];
              }, R.tags = {
                254: "NewSubfileType",
                255: "SubfileType",
                256: "ImageWidth",
                257: "ImageLength",
                258: "BitsPerSample",
                259: "Compression",
                262: "PhotometricInterpretation",
                266: "FillOrder",
                269: "DocumentName",
                270: "ImageDescription",
                271: "Make",
                272: "Model",
                273: "StripOffset",
                274: "Orientation",
                277: "SamplesPerPixel",
                278: "RowsPerStrip",
                279: "StripByteCounts",
                280: "MinSampleValue",
                281: "MaxSampleValue",
                282: "XResolution",
                283: "YResolution",
                284: "PlanarConfiguration",
                285: "PageName",
                286: "XPosition",
                287: "YPosition",
                292: "T4Options",
                296: "ResolutionUnit",
                297: "PageNumber",
                305: "Software",
                306: "DateTime",
                315: "Artist",
                316: "HostComputer",
                317: "Predictor",
                318: "WhitePoint",
                319: "PrimaryChromaticities",
                320: "ColorMap",
                321: "HalftoneHints",
                322: "TileWidth",
                323: "TileLength",
                324: "TileOffset",
                325: "TileByteCounts",
                330: "SubIFDs",
                336: "DotRange",
                338: "ExtraSample",
                339: "SampleFormat",
                347: "JPEGTables",
                512: "JPEGProc",
                513: "JPEGInterchangeFormat",
                514: "JPEGInterchangeFormatLength",
                519: "JPEGQTables",
                520: "JPEGDCTables",
                521: "JPEGACTables",
                529: "YCbCrCoefficients",
                530: "YCbCrSubSampling",
                531: "YCbCrPositioning",
                532: "ReferenceBlackWhite",
                700: "XMP",
                33421: "CFARepeatPatternDim",
                33422: "CFAPattern",
                33432: "Copyright",
                33434: "ExposureTime",
                33437: "FNumber",
                33723: "IPTC/NAA",
                34377: "Photoshop",
                34665: "ExifIFD",
                34675: "ICC Profile",
                34850: "ExposureProgram",
                34853: "GPSInfo",
                34855: "ISOSpeedRatings",
                34858: "TimeZoneOffset",
                34859: "SelfTimeMode",
                36867: "DateTimeOriginal",
                36868: "DateTimeDigitized",
                37377: "ShutterSpeedValue",
                37378: "ApertureValue",
                37380: "ExposureBiasValue",
                37383: "MeteringMode",
                37385: "Flash",
                37386: "FocalLength",
                37390: "FocalPlaneXResolution",
                37391: "FocalPlaneYResolution",
                37392: "FocalPlaneResolutionUnit",
                37393: "ImageNumber",
                37398: "TIFF/EPStandardID",
                37399: "SensingMethod",
                37500: "MakerNote",
                37510: "UserComment",
                37724: "ImageSourceData",
                40092: "XPComment",
                40094: "XPKeywords",
                40961: "ColorSpace",
                40962: "PixelXDimension",
                40963: "PixelXDimension",
                41486: "FocalPlaneXResolution",
                41487: "FocalPlaneYResolution",
                41488: "FocalPlaneResolutionUnit",
                41985: "CustomRendered",
                41986: "ExposureMode",
                41987: "WhiteBalance",
                41990: "SceneCaptureType",
                50706: "DNGVersion",
                50707: "DNGBackwardVersion",
                50708: "UniqueCameraModel",
                50709: "LocalizedCameraModel",
                50710: "CFAPlaneColor",
                50711: "CFALayout",
                50712: "LinearizationTable",
                50713: "BlackLevelRepeatDim",
                50714: "BlackLevel",
                50716: "BlackLevelDeltaV",
                50717: "WhiteLevel",
                50718: "DefaultScale",
                50719: "DefaultCropOrigin",
                50720: "DefaultCropSize",
                50733: "BayerGreenSplit",
                50738: "AntiAliasStrength",
                50721: "ColorMatrix1",
                50722: "ColorMatrix2",
                50723: "CameraCalibration1",
                50724: "CameraCalibration2",
                50727: "AnalogBalance",
                50728: "AsShotNeutral",
                50730: "BaselineExposure",
                50731: "BaselineNoise",
                50732: "BaselineSharpness",
                50734: "LinearResponseLimit",
                50735: "CameraSerialNumber",
                50736: "LensInfo",
                50739: "ShadowScale",
                50740: "DNGPrivateData",
                50741: "MakerNoteSafety",
                50778: "CalibrationIlluminant1",
                50779: "CalibrationIlluminant2",
                50780: "BestQualityScale",
                50781: "RawDataUniqueID",
                50827: "OriginalRawFileName",
                50829: "ActiveArea",
                50830: "MaskedAreas",
                50931: "CameraCalibrationSignature",
                50932: "ProfileCalibrationSignature",
                50935: "NoiseReductionApplied",
                50936: "ProfileName",
                50937: "ProfileHueSatMapDims",
                50938: "ProfileHueSatMapData1",
                50939: "ProfileHueSatMapData2",
                50940: "ProfileToneCurve",
                50941: "ProfileEmbedPolicy",
                50942: "ProfileCopyright",
                50964: "ForwardMatrix1",
                50965: "ForwardMatrix2",
                50966: "PreviewApplicationName",
                50967: "PreviewApplicationVersion",
                50969: "PreviewSettingsDigest",
                50970: "PreviewColorSpace",
                50971: "PreviewDateTime",
                50972: "RawImageDigest",
                51008: "OpcodeList1",
                51009: "OpcodeList2",
                51022: "OpcodeList3",
                51041: "NoiseProfile",
                51089: "OriginalDefaultFinalSize",
                51090: "OriginalBestQualityFinalSize",
                51091: "OriginalDefaultCropSize",
                51125: "DefaultUserCrop"
              }, R.ttypes = { 256: 3, 257: 3, 258: 3, 259: 3, 262: 3, 273: 4, 274: 3, 277: 3, 278: 4, 279: 4, 282: 5, 283: 5, 284: 3, 286: 5, 287: 5, 296: 3, 305: 2, 306: 2, 338: 3, 513: 4, 514: 4, 34665: 4 }, R._readIFD = function(M, x, m, w) {
                var k = M.readUshort(x, m);
                m += 2;
                var E = {};
                w.push(E);
                for (var P = 0; P < k; P++) {
                  var S = M.readUshort(x, m);
                  m += 2;
                  var U = M.readUshort(x, m);
                  m += 2;
                  var j = M.readUint(x, m);
                  m += 4;
                  var T = M.readUint(x, m);
                  m += 4;
                  var W = [];
                  if (E["t" + S] = W, U == 1 || U == 7)
                    for (var J = 0; J < j; J++) W.push(x[(j < 5 ? m - 4 : T) + J]);
                  if (U == 2 && W.push(M.readASCII(x, j < 5 ? m - 4 : T, j - 1)), U == 3)
                    for (var J = 0; J < j; J++) W.push(M.readUshort(x, (j < 3 ? m - 4 : T) + 2 * J));
                  if (U == 4)
                    for (var J = 0; J < j; J++) W.push(M.readUint(x, (j < 2 ? m - 4 : T) + 4 * J));
                  if (U == 5)
                    for (var J = 0; J < j; J++) W.push(M.readUint(x, T + J * 8) / M.readUint(x, T + J * 8 + 4));
                  if (U == 8)
                    for (var J = 0; J < j; J++) W.push(M.readShort(x, (j < 3 ? m - 4 : T) + 2 * J));
                  if (U == 9)
                    for (var J = 0; J < j; J++) W.push(M.readInt(x, (j < 2 ? m - 4 : T) + 4 * J));
                  if (U == 10)
                    for (var J = 0; J < j; J++) W.push(M.readInt(x, T + J * 8) / M.readInt(x, T + J * 8 + 4));
                  if (U == 11)
                    for (var J = 0; J < j; J++) W.push(M.readFloat(x, T + J * 4));
                  if (U == 12)
                    for (var J = 0; J < j; J++) W.push(M.readDouble(x, T + J * 8));
                  if (j != 0 && W.length == 0 && Z("unknown TIFF tag type: ", U, "num:", j), S == 330) for (var J = 0; J < j; J++) R._readIFD(M, x, W[J], w);
                }
                return m;
              }, R._writeIFD = function(M, x, m, w) {
                var k = Object.keys(w);
                M.writeUshort(x, m, k.length), m += 2;
                for (var E = m + k.length * 12 + 4, P = 0; P < k.length; P++) {
                  var S = k[P], U = parseInt(S.slice(1)), j = R.ttypes[U];
                  if (j == null) throw new Error("unknown type of tag: " + U);
                  var T = w[S];
                  j == 2 && (T = T[0] + "\0");
                  var W = T.length;
                  M.writeUshort(x, m, U), m += 2, M.writeUshort(x, m, j), m += 2, M.writeUint(x, m, W), m += 4;
                  var J = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][j] * W, ee = m;
                  if (J > 4 && (M.writeUint(x, m, E), ee = E), j == 2 && M.writeASCII(x, ee, T), j == 3)
                    for (var te = 0; te < W; te++) M.writeUshort(x, ee + 2 * te, T[te]);
                  if (j == 4)
                    for (var te = 0; te < W; te++) M.writeUint(x, ee + 4 * te, T[te]);
                  if (j == 5)
                    for (var te = 0; te < W; te++)
                      M.writeUint(x, ee + 8 * te, Math.round(T[te] * 1e4)), M.writeUint(x, ee + 8 * te + 4, 1e4);
                  if (j == 12)
                    for (var te = 0; te < W; te++) M.writeDouble(x, ee + 8 * te, T[te]);
                  J > 4 && (J += J & 1, E += J), m += 4;
                }
                return [m, E];
              }, R.toRGBA8 = function(M) {
                var x = M.width, m = M.height, w = x * m, k = w * 4, E = M.data, P = new Uint8Array(w * 4), S = M.t262[0], U = M.t258 ? Math.min(32, M.t258[0]) : 1, j = M.isLE ? 1 : 0;
                if (S == 0)
                  for (var T = Math.ceil(U * x / 8), W = 0; W < m; W++) {
                    var J = W * T, ee = W * x;
                    if (U == 1) for (var te = 0; te < x; te++) {
                      var le = ee + te << 2, me = E[J + (te >> 3)] >> 7 - (te & 7) & 1;
                      P[le] = P[le + 1] = P[le + 2] = (1 - me) * 255, P[le + 3] = 255;
                    }
                    if (U == 4) for (var te = 0; te < x; te++) {
                      var le = ee + te << 2, me = E[J + (te >> 1)] >> 4 - 4 * (te & 1) & 15;
                      P[le] = P[le + 1] = P[le + 2] = (15 - me) * 17, P[le + 3] = 255;
                    }
                    if (U == 8) for (var te = 0; te < x; te++) {
                      var le = ee + te << 2, me = E[J + te];
                      P[le] = P[le + 1] = P[le + 2] = 255 - me, P[le + 3] = 255;
                    }
                  }
                else if (S == 1)
                  for (var T = Math.ceil(U * x / 8), W = 0; W < m; W++) {
                    var J = W * T, ee = W * x;
                    if (U == 1) for (var te = 0; te < x; te++) {
                      var le = ee + te << 2, me = E[J + (te >> 3)] >> 7 - (te & 7) & 1;
                      P[le] = P[le + 1] = P[le + 2] = me * 255, P[le + 3] = 255;
                    }
                    if (U == 2) for (var te = 0; te < x; te++) {
                      var le = ee + te << 2, me = E[J + (te >> 2)] >> 6 - 2 * (te & 3) & 3;
                      P[le] = P[le + 1] = P[le + 2] = me * 85, P[le + 3] = 255;
                    }
                    if (U == 8) for (var te = 0; te < x; te++) {
                      var le = ee + te << 2, me = E[J + te];
                      P[le] = P[le + 1] = P[le + 2] = me, P[le + 3] = 255;
                    }
                    if (U == 16) for (var te = 0; te < x; te++) {
                      var le = ee + te << 2, me = E[J + (2 * te + j)];
                      P[le] = P[le + 1] = P[le + 2] = Math.min(255, me), P[le + 3] = 255;
                    }
                  }
                else if (S == 2)
                  if (U == 8)
                    if (M.t338)
                      if (M.t338[0] > 0) for (var te = 0; te < k; te++) P[te] = E[te];
                      else for (var te = 0; te < k; te += 4)
                        P[te] = E[te], P[te + 1] = E[te + 1], P[te + 2] = E[te + 2], P[te + 3] = 255;
                    else {
                      var ke = M.t258 ? M.t258.length : 3;
                      if (ke == 4) for (var te = 0; te < k; te++) P[te] = E[te];
                      if (ke == 3) for (var te = 0; te < w; te++) {
                        var le = te << 2, ge = te * 3;
                        P[le] = E[ge], P[le + 1] = E[ge + 1], P[le + 2] = E[ge + 2], P[le + 3] = 255;
                      }
                    }
                  else
                    for (var te = 0; te < w; te++) {
                      var le = te << 2, ge = te * 6;
                      P[le] = E[ge], P[le + 1] = E[ge + 2], P[le + 2] = E[ge + 4], P[le + 3] = 255;
                    }
                else if (S == 3)
                  for (var Ve = M.t320, te = 0; te < w; te++) {
                    var le = te << 2, Oe = E[te];
                    P[le] = Ve[Oe] >> 8, P[le + 1] = Ve[256 + Oe] >> 8, P[le + 2] = Ve[512 + Oe] >> 8, P[le + 3] = 255;
                  }
                else if (S == 5)
                  for (var ke = M.t258 ? M.t258.length : 4, Ue = ke > 4 ? 1 : 0, te = 0; te < w; te++) {
                    var le = te << 2, we = te * ke, Ce = 255 - E[we], it = 255 - E[we + 1], ut = 255 - E[we + 2], bt = (255 - E[we + 3]) * (1 / 255);
                    P[le] = ~~(Ce * bt + 0.5), P[le + 1] = ~~(it * bt + 0.5), P[le + 2] = ~~(ut * bt + 0.5), P[le + 3] = 255 * (1 - Ue) + E[we + 4] * Ue;
                  }
                else Z("Unknown Photometric interpretation: " + S);
                return P;
              }, R.replaceIMG = function() {
                for (var M = document.getElementsByTagName("img"), x = 0; x < M.length; x++) {
                  var m = M[x], w = m.getAttribute("src");
                  if (w != null) {
                    var k = w.split(".").pop().toLowerCase();
                    if (!(k != "tif" && k != "tiff")) {
                      var E = new XMLHttpRequest();
                      R._xhrs.push(E), R._imgs.push(m), E.open("GET", w), E.responseType = "arraybuffer", E.onload = R._imgLoaded, E.send();
                    }
                  }
                }
              }, R._xhrs = [], R._imgs = [], R._imgLoaded = function(M) {
                var x = M.target.response, m = R.decode(x), w = m[0];
                R.decodeImages(x, m);
                var k = R.toRGBA8(w), E = w.width, P = w.height, S = R._xhrs.indexOf(M.target), U = R._imgs[S];
                R._xhrs.splice(S, 1), R._imgs.splice(S, 1);
                var j = document.createElement("canvas");
                j.width = E, j.height = P;
                for (var T = j.getContext("2d"), W = T.createImageData(E, P), J = 0; J < k.length; J++) W.data[J] = k[J];
                T.putImageData(W, 0, 0);
                for (var ee = ["style", "class", "id"], J = 0; J < ee.length; J++) j.setAttribute(ee[J], U.getAttribute(ee[J]));
                U.parentNode.replaceChild(j, U);
              }, R._binBE = {
                nextZero: function(M, x) {
                  for (; M[x] != 0; ) x++;
                  return x;
                },
                readUshort: function(M, x) {
                  return M[x] << 8 | M[x + 1];
                },
                readShort: function(M, x) {
                  var m = R._binBE.ui8;
                  return m[0] = M[x + 1], m[1] = M[x + 0], R._binBE.i16[0];
                },
                readInt: function(M, x) {
                  var m = R._binBE.ui8;
                  return m[0] = M[x + 3], m[1] = M[x + 2], m[2] = M[x + 1], m[3] = M[x + 0], R._binBE.i32[0];
                },
                readUint: function(M, x) {
                  var m = R._binBE.ui8;
                  return m[0] = M[x + 3], m[1] = M[x + 2], m[2] = M[x + 1], m[3] = M[x + 0], R._binBE.ui32[0];
                },
                readASCII: function(M, x, m) {
                  for (var w = "", k = 0; k < m; k++) w += String.fromCharCode(M[x + k]);
                  return w;
                },
                readFloat: function(M, x) {
                  for (var m = R._binBE.ui8, w = 0; w < 4; w++) m[w] = M[x + 3 - w];
                  return R._binBE.fl32[0];
                },
                readDouble: function(M, x) {
                  for (var m = R._binBE.ui8, w = 0; w < 8; w++) m[w] = M[x + 7 - w];
                  return R._binBE.fl64[0];
                },
                writeUshort: function(M, x, m) {
                  M[x] = m >> 8 & 255, M[x + 1] = m & 255;
                },
                writeUint: function(M, x, m) {
                  M[x] = m >> 24 & 255, M[x + 1] = m >> 16 & 255, M[x + 2] = m >> 8 & 255, M[x + 3] = m >> 0 & 255;
                },
                writeASCII: function(M, x, m) {
                  for (var w = 0; w < m.length; w++) M[x + w] = m.charCodeAt(w);
                },
                writeDouble: function(M, x, m) {
                  R._binBE.fl64[0] = m;
                  for (var w = 0; w < 8; w++) M[x + w] = R._binBE.ui8[7 - w];
                }
              }, R._binBE.ui8 = new Uint8Array(8), R._binBE.i16 = new Int16Array(R._binBE.ui8.buffer), R._binBE.i32 = new Int32Array(R._binBE.ui8.buffer), R._binBE.ui32 = new Uint32Array(R._binBE.ui8.buffer), R._binBE.fl32 = new Float32Array(R._binBE.ui8.buffer), R._binBE.fl64 = new Float64Array(R._binBE.ui8.buffer), R._binLE = {
                nextZero: R._binBE.nextZero,
                readUshort: function(M, x) {
                  return M[x + 1] << 8 | M[x];
                },
                readShort: function(M, x) {
                  var m = R._binBE.ui8;
                  return m[0] = M[x + 0], m[1] = M[x + 1], R._binBE.i16[0];
                },
                readInt: function(M, x) {
                  var m = R._binBE.ui8;
                  return m[0] = M[x + 0], m[1] = M[x + 1], m[2] = M[x + 2], m[3] = M[x + 3], R._binBE.i32[0];
                },
                readUint: function(M, x) {
                  var m = R._binBE.ui8;
                  return m[0] = M[x + 0], m[1] = M[x + 1], m[2] = M[x + 2], m[3] = M[x + 3], R._binBE.ui32[0];
                },
                readASCII: R._binBE.readASCII,
                readFloat: function(M, x) {
                  for (var m = R._binBE.ui8, w = 0; w < 4; w++) m[w] = M[x + w];
                  return R._binBE.fl32[0];
                },
                readDouble: function(M, x) {
                  for (var m = R._binBE.ui8, w = 0; w < 8; w++) m[w] = M[x + w];
                  return R._binBE.fl64[0];
                }
              }, R._copyTile = function(M, x, m, w, k, E, P, S) {
                for (var U = Math.min(x, k - P), j = Math.min(m, E - S), T = 0; T < j; T++)
                  for (var W = (S + T) * k + P, J = T * x, ee = 0; ee < U; ee++) w[W + ee] = M[J + ee];
              };
            })(i, N);
          })();
        }).call(this, Q("_process"));
      }, { _process: 133, pako: 86 }], 183: [function(Q, de, q) {
        (function(ie) {
          de.exports = i;
          function i(Z, R) {
            if (N("noDeprecation"))
              return Z;
            var A = !1;
            function M() {
              if (!A) {
                if (N("throwDeprecation"))
                  throw new Error(R);
                N("traceDeprecation") ? console.trace(R) : console.warn(R), A = !0;
              }
              return Z.apply(this, arguments);
            }
            return M;
          }
          function N(Z) {
            try {
              if (!ie.localStorage) return !1;
            } catch {
              return !1;
            }
            var R = ie.localStorage[Z];
            return R == null ? !1 : String(R).toLowerCase() === "true";
          }
        }).call(this, typeof Qn < "u" ? Qn : typeof self < "u" ? self : typeof qe < "u" ? qe : {});
      }, {}], 184: [function(Q, de, q) {
        arguments[4][26][0].apply(q, arguments);
      }, { dup: 26 }], 185: [function(Q, de, q) {
        arguments[4][27][0].apply(q, arguments);
      }, { dup: 27 }], 186: [function(Q, de, q) {
        arguments[4][28][0].apply(q, arguments);
      }, { "./support/isBuffer": 185, _process: 133, dup: 28, inherits: 184 }], 187: [function(Q, de, q) {
        var ie = Q("global/window"), i = Q("is-function"), N = Q("parse-headers"), Z = Q("xtend");
        de.exports = x, de.exports.default = x, x.XMLHttpRequest = ie.XMLHttpRequest || k, x.XDomainRequest = "withCredentials" in new x.XMLHttpRequest() ? x.XMLHttpRequest : ie.XDomainRequest, R(["get", "put", "post", "patch", "head", "delete"], function(E) {
          x[E === "delete" ? "del" : E] = function(P, S, U) {
            return S = M(P, S, U), S.method = E.toUpperCase(), m(S);
          };
        });
        function R(E, P) {
          for (var S = 0; S < E.length; S++)
            P(E[S]);
        }
        function A(E) {
          for (var P in E)
            if (E.hasOwnProperty(P)) return !1;
          return !0;
        }
        function M(E, P, S) {
          var U = E;
          return i(P) ? (S = P, typeof E == "string" && (U = { uri: E })) : U = Z(P, { uri: E }), U.callback = S, U;
        }
        function x(E, P, S) {
          return P = M(E, P, S), m(P);
        }
        function m(E) {
          if (typeof E.callback > "u")
            throw new Error("callback argument missing");
          var P = !1, S = function(it, ut, bt) {
            P || (P = !0, E.callback(it, ut, bt));
          };
          function U() {
            J.readyState === 4 && setTimeout(W, 0);
          }
          function j() {
            var Ce = void 0;
            if (J.response ? Ce = J.response : Ce = J.responseText || w(J), Oe)
              try {
                Ce = JSON.parse(Ce);
              } catch {
              }
            return Ce;
          }
          function T(Ce) {
            return clearTimeout(Ue), Ce instanceof Error || (Ce = new Error("" + (Ce || "Unknown XMLHttpRequest Error"))), Ce.statusCode = 0, S(Ce, we);
          }
          function W() {
            if (!te) {
              var Ce;
              clearTimeout(Ue), E.useXDR && J.status === void 0 ? Ce = 200 : Ce = J.status === 1223 ? 204 : J.status;
              var it = we, ut = null;
              return Ce !== 0 ? (it = {
                body: j(),
                statusCode: Ce,
                method: me,
                headers: {},
                url: le,
                rawRequest: J
              }, J.getAllResponseHeaders && (it.headers = N(J.getAllResponseHeaders()))) : ut = new Error("Internal XMLHttpRequest Error"), S(ut, it, it.body);
            }
          }
          var J = E.xhr || null;
          J || (E.cors || E.useXDR ? J = new x.XDomainRequest() : J = new x.XMLHttpRequest());
          var ee, te, le = J.url = E.uri || E.url, me = J.method = E.method || "GET", ke = E.body || E.data, ge = J.headers = E.headers || {}, Ve = !!E.sync, Oe = !1, Ue, we = {
            body: void 0,
            headers: {},
            statusCode: 0,
            method: me,
            url: le,
            rawRequest: J
          };
          if ("json" in E && E.json !== !1 && (Oe = !0, ge.accept || ge.Accept || (ge.Accept = "application/json"), me !== "GET" && me !== "HEAD" && (ge["content-type"] || ge["Content-Type"] || (ge["Content-Type"] = "application/json"), ke = JSON.stringify(E.json === !0 ? ke : E.json))), J.onreadystatechange = U, J.onload = W, J.onerror = T, J.onprogress = function() {
          }, J.onabort = function() {
            te = !0;
          }, J.ontimeout = T, J.open(me, le, !Ve, E.username, E.password), Ve || (J.withCredentials = !!E.withCredentials), !Ve && E.timeout > 0 && (Ue = setTimeout(function() {
            if (!te) {
              te = !0, J.abort("timeout");
              var Ce = new Error("XMLHttpRequest timeout");
              Ce.code = "ETIMEDOUT", T(Ce);
            }
          }, E.timeout)), J.setRequestHeader)
            for (ee in ge)
              ge.hasOwnProperty(ee) && J.setRequestHeader(ee, ge[ee]);
          else if (E.headers && !A(E.headers))
            throw new Error("Headers cannot be set on an XDomainRequest object");
          return "responseType" in E && (J.responseType = E.responseType), "beforeSend" in E && typeof E.beforeSend == "function" && E.beforeSend(J), J.send(ke || null), J;
        }
        function w(E) {
          try {
            if (E.responseType === "document")
              return E.responseXML;
            var P = E.responseXML && E.responseXML.documentElement.nodeName === "parsererror";
            if (E.responseType === "" && !P)
              return E.responseXML;
          } catch {
          }
          return null;
        }
        function k() {
        }
      }, { "global/window": 71, "is-function": 78, "parse-headers": 106, xtend: 189 }], 188: [function(Q, de, q) {
        de.exports = function() {
          return typeof self.DOMParser < "u" ? function(i) {
            var N = new self.DOMParser();
            return N.parseFromString(i, "application/xml");
          } : typeof self.ActiveXObject < "u" && new self.ActiveXObject("Microsoft.XMLDOM") ? function(i) {
            var N = new self.ActiveXObject("Microsoft.XMLDOM");
            return N.async = "false", N.loadXML(i), N;
          } : function(i) {
            var N = document.createElement("div");
            return N.innerHTML = i, N;
          };
        }();
      }, {}], 189: [function(Q, de, q) {
        de.exports = i;
        var ie = Object.prototype.hasOwnProperty;
        function i() {
          for (var N = {}, Z = 0; Z < arguments.length; Z++) {
            var R = arguments[Z];
            for (var A in R)
              ie.call(R, A) && (N[A] = R[A]);
          }
          return N;
        }
      }, {}], 190: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.srcOver = ie, q.dstOver = i, q.multiply = N, q.add = Z, q.screen = R, q.overlay = A, q.darken = M, q.lighten = x, q.hardLight = m, q.difference = w, q.exclusion = k;
        function ie(E, P) {
          var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          E.a *= S;
          var U = P.a + E.a - P.a * E.a, j = (E.r * E.a + P.r * P.a * (1 - E.a)) / U, T = (E.g * E.a + P.g * P.a * (1 - E.a)) / U, W = (E.b * E.a + P.b * P.a * (1 - E.a)) / U;
          return {
            r: j,
            g: T,
            b: W,
            a: U
          };
        }
        function i(E, P) {
          var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          E.a *= S;
          var U = P.a + E.a - P.a * E.a, j = (P.r * P.a + E.r * E.a * (1 - P.a)) / U, T = (P.g * P.a + E.g * E.a * (1 - P.a)) / U, W = (P.b * P.a + E.b * E.a * (1 - P.a)) / U;
          return {
            r: j,
            g: T,
            b: W,
            a: U
          };
        }
        function N(E, P) {
          var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          E.a *= S;
          var U = P.a + E.a - P.a * E.a, j = E.r * E.a, T = E.g * E.a, W = E.b * E.a, J = P.r * P.a, ee = P.g * P.a, te = P.b * P.a, le = (j * J + j * (1 - P.a) + J * (1 - E.a)) / U, me = (T * ee + T * (1 - P.a) + ee * (1 - E.a)) / U, ke = (W * te + W * (1 - P.a) + te * (1 - E.a)) / U;
          return {
            r: le,
            g: me,
            b: ke,
            a: U
          };
        }
        function Z(E, P) {
          var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          E.a *= S;
          var U = P.a + E.a - P.a * E.a, j = E.r * E.a, T = E.g * E.a, W = E.b * E.a, J = P.r * P.a, ee = P.g * P.a, te = P.b * P.a, le = (j + J) / U, me = (T + ee) / U, ke = (W + te) / U;
          return {
            r: le,
            g: me,
            b: ke,
            a: U
          };
        }
        function R(E, P) {
          var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          E.a *= S;
          var U = P.a + E.a - P.a * E.a, j = E.r * E.a, T = E.g * E.a, W = E.b * E.a, J = P.r * P.a, ee = P.g * P.a, te = P.b * P.a, le = (j * P.a + J * E.a - j * J + j * (1 - P.a) + J * (1 - E.a)) / U, me = (T * P.a + ee * E.a - T * ee + T * (1 - P.a) + ee * (1 - E.a)) / U, ke = (W * P.a + te * E.a - W * te + W * (1 - P.a) + te * (1 - E.a)) / U;
          return {
            r: le,
            g: me,
            b: ke,
            a: U
          };
        }
        function A(E, P) {
          var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          E.a *= S;
          var U = P.a + E.a - P.a * E.a, j = E.r * E.a, T = E.g * E.a, W = E.b * E.a, J = P.r * P.a, ee = P.g * P.a, te = P.b * P.a, le = (2 * J <= P.a ? 2 * j * J + j * (1 - P.a) + J * (1 - E.a) : j * (1 + P.a) + J * (1 + E.a) - 2 * J * j - P.a * E.a) / U, me = (2 * ee <= P.a ? 2 * T * ee + T * (1 - P.a) + ee * (1 - E.a) : T * (1 + P.a) + ee * (1 + E.a) - 2 * ee * T - P.a * E.a) / U, ke = (2 * te <= P.a ? 2 * W * te + W * (1 - P.a) + te * (1 - E.a) : W * (1 + P.a) + te * (1 + E.a) - 2 * te * W - P.a * E.a) / U;
          return {
            r: le,
            g: me,
            b: ke,
            a: U
          };
        }
        function M(E, P) {
          var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          E.a *= S;
          var U = P.a + E.a - P.a * E.a, j = E.r * E.a, T = E.g * E.a, W = E.b * E.a, J = P.r * P.a, ee = P.g * P.a, te = P.b * P.a, le = (Math.min(j * P.a, J * E.a) + j * (1 - P.a) + J * (1 - E.a)) / U, me = (Math.min(T * P.a, ee * E.a) + T * (1 - P.a) + ee * (1 - E.a)) / U, ke = (Math.min(W * P.a, te * E.a) + W * (1 - P.a) + te * (1 - E.a)) / U;
          return {
            r: le,
            g: me,
            b: ke,
            a: U
          };
        }
        function x(E, P) {
          var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          E.a *= S;
          var U = P.a + E.a - P.a * E.a, j = E.r * E.a, T = E.g * E.a, W = E.b * E.a, J = P.r * P.a, ee = P.g * P.a, te = P.b * P.a, le = (Math.max(j * P.a, J * E.a) + j * (1 - P.a) + J * (1 - E.a)) / U, me = (Math.max(T * P.a, ee * E.a) + T * (1 - P.a) + ee * (1 - E.a)) / U, ke = (Math.max(W * P.a, te * E.a) + W * (1 - P.a) + te * (1 - E.a)) / U;
          return {
            r: le,
            g: me,
            b: ke,
            a: U
          };
        }
        function m(E, P) {
          var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          E.a *= S;
          var U = P.a + E.a - P.a * E.a, j = E.r * E.a, T = E.g * E.a, W = E.b * E.a, J = P.r * P.a, ee = P.g * P.a, te = P.b * P.a, le = (2 * j <= E.a ? 2 * j * J + j * (1 - P.a) + J * (1 - E.a) : j * (1 + P.a) + J * (1 + E.a) - 2 * J * j - P.a * E.a) / U, me = (2 * T <= E.a ? 2 * T * ee + T * (1 - P.a) + ee * (1 - E.a) : T * (1 + P.a) + ee * (1 + E.a) - 2 * ee * T - P.a * E.a) / U, ke = (2 * W <= E.a ? 2 * W * te + W * (1 - P.a) + te * (1 - E.a) : W * (1 + P.a) + te * (1 + E.a) - 2 * te * W - P.a * E.a) / U;
          return {
            r: le,
            g: me,
            b: ke,
            a: U
          };
        }
        function w(E, P) {
          var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          E.a *= S;
          var U = P.a + E.a - P.a * E.a, j = E.r * E.a, T = E.g * E.a, W = E.b * E.a, J = P.r * P.a, ee = P.g * P.a, te = P.b * P.a, le = (j + J - 2 * Math.min(j * P.a, J * E.a)) / U, me = (T + ee - 2 * Math.min(T * P.a, ee * E.a)) / U, ke = (W + te - 2 * Math.min(W * P.a, te * E.a)) / U;
          return {
            r: le,
            g: me,
            b: ke,
            a: U
          };
        }
        function k(E, P) {
          var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          E.a *= S;
          var U = P.a + E.a - P.a * E.a, j = E.r * E.a, T = E.g * E.a, W = E.b * E.a, J = P.r * P.a, ee = P.g * P.a, te = P.b * P.a, le = (j * P.a + J * E.a - 2 * j * J + j * (1 - P.a) + J * (1 - E.a)) / U, me = (T * P.a + ee * E.a - 2 * T * ee + T * (1 - P.a) + ee * (1 - E.a)) / U, ke = (W * P.a + te * E.a - 2 * W * te + W * (1 - P.a) + te * (1 - E.a)) / U;
          return {
            r: le,
            g: me,
            b: ke,
            a: U
          };
        }
      }, {}], 191: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireWildcard");
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = R;
        var i = Q("@jimp/utils"), N = ie(Q("../constants")), Z = ie(Q("./composite-modes"));
        function R(A, M, x) {
          var m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, w = arguments.length > 4 ? arguments[4] : void 0;
          if (typeof m == "function" && (w = m, m = {}), !(A instanceof this.constructor))
            return i.throwError.call(this, "The source must be a Jimp image", w);
          if (typeof M != "number" || typeof x != "number")
            return i.throwError.call(this, "x and y must be numbers", w);
          var k = m, E = k.mode, P = k.opacitySource, S = k.opacityDest;
          E || (E = N.BLEND_SOURCE_OVER), (typeof P != "number" || P < 0 || P > 1) && (P = 1), (typeof S != "number" || S < 0 || S > 1) && (S = 1);
          var U = Z[E];
          M = Math.round(M), x = Math.round(x);
          var j = this;
          return S !== 1 && j.opacity(S), A.scanQuiet(0, 0, A.bitmap.width, A.bitmap.height, function(T, W, J) {
            var ee = j.getPixelIndex(M + T, x + W, N.EDGE_CROP), te = U({
              r: this.bitmap.data[J + 0] / 255,
              g: this.bitmap.data[J + 1] / 255,
              b: this.bitmap.data[J + 2] / 255,
              a: this.bitmap.data[J + 3] / 255
            }, {
              r: j.bitmap.data[ee + 0] / 255,
              g: j.bitmap.data[ee + 1] / 255,
              b: j.bitmap.data[ee + 2] / 255,
              a: j.bitmap.data[ee + 3] / 255
            }, P);
            j.bitmap.data[ee + 0] = this.constructor.limit255(te.r * 255), j.bitmap.data[ee + 1] = this.constructor.limit255(te.g * 255), j.bitmap.data[ee + 2] = this.constructor.limit255(te.b * 255), j.bitmap.data[ee + 3] = this.constructor.limit255(te.a * 255);
          }), (0, i.isNodePattern)(w) && w.call(this, null, this), this;
        }
        de.exports = q.default;
      }, { "../constants": 192, "./composite-modes": 190, "@babel/runtime/helpers/interopRequireWildcard": 12, "@jimp/utils": 235 }], 192: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.EDGE_CROP = q.EDGE_WRAP = q.EDGE_EXTEND = q.BLEND_EXCLUSION = q.BLEND_DIFFERENCE = q.BLEND_HARDLIGHT = q.BLEND_LIGHTEN = q.BLEND_DARKEN = q.BLEND_OVERLAY = q.BLEND_SCREEN = q.BLEND_ADD = q.BLEND_MULTIPLY = q.BLEND_DESTINATION_OVER = q.BLEND_SOURCE_OVER = q.VERTICAL_ALIGN_BOTTOM = q.VERTICAL_ALIGN_MIDDLE = q.VERTICAL_ALIGN_TOP = q.HORIZONTAL_ALIGN_RIGHT = q.HORIZONTAL_ALIGN_CENTER = q.HORIZONTAL_ALIGN_LEFT = q.AUTO = void 0;
        var ie = -1;
        q.AUTO = ie;
        var i = 1;
        q.HORIZONTAL_ALIGN_LEFT = i;
        var N = 2;
        q.HORIZONTAL_ALIGN_CENTER = N;
        var Z = 4;
        q.HORIZONTAL_ALIGN_RIGHT = Z;
        var R = 8;
        q.VERTICAL_ALIGN_TOP = R;
        var A = 16;
        q.VERTICAL_ALIGN_MIDDLE = A;
        var M = 32;
        q.VERTICAL_ALIGN_BOTTOM = M;
        var x = "srcOver";
        q.BLEND_SOURCE_OVER = x;
        var m = "dstOver";
        q.BLEND_DESTINATION_OVER = m;
        var w = "multiply";
        q.BLEND_MULTIPLY = w;
        var k = "add";
        q.BLEND_ADD = k;
        var E = "screen";
        q.BLEND_SCREEN = E;
        var P = "overlay";
        q.BLEND_OVERLAY = P;
        var S = "darken";
        q.BLEND_DARKEN = S;
        var U = "lighten";
        q.BLEND_LIGHTEN = U;
        var j = "hardLight";
        q.BLEND_HARDLIGHT = j;
        var T = "difference";
        q.BLEND_DIFFERENCE = T;
        var W = "exclusion";
        q.BLEND_EXCLUSION = W;
        var J = 1;
        q.EDGE_EXTEND = J;
        var ee = 2;
        q.EDGE_WRAP = ee;
        var te = 3;
        q.EDGE_CROP = te;
      }, {}], 193: [function(Q, de, q) {
        (function(ie) {
          var i = Q("@babel/runtime/helpers/interopRequireWildcard"), N = Q("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(q, "__esModule", {
            value: !0
          }), q.addConstants = ri, q.addJimpMethods = wi, q.jimpEvMethod = Qt, q.jimpEvChange = At, Object.defineProperty(q, "addType", {
            enumerable: !0,
            get: function() {
              return Ve.addType;
            }
          }), q.default = void 0;
          for (var Z = N(Q("@babel/runtime/helpers/construct")), R = N(Q("@babel/runtime/helpers/slicedToArray")), A = N(Q("@babel/runtime/helpers/classCallCheck")), M = N(Q("@babel/runtime/helpers/createClass")), x = N(Q("@babel/runtime/helpers/possibleConstructorReturn")), m = N(Q("@babel/runtime/helpers/getPrototypeOf")), w = N(Q("@babel/runtime/helpers/assertThisInitialized")), k = N(Q("@babel/runtime/helpers/inherits")), E = N(Q("@babel/runtime/helpers/defineProperty")), P = N(Q("@babel/runtime/helpers/typeof")), S = N(Q("fs")), U = N(Q("path")), j = N(Q("events")), T = Q("@jimp/utils"), W = N(Q("any-base")), J = N(Q("mkdirp")), ee = N(Q("pixelmatch")), te = N(Q("tinycolor2")), le = N(Q("./modules/phash")), me = N(Q("./request")), ke = N(Q("./composite")), ge = N(Q("./utils/promisify")), Ve = i(Q("./utils/mime")), Oe = Q("./utils/image-bitmap"), Ue = i(Q("./constants")), we = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", Ce = [NaN, NaN], it = 2; it < 65; it++) {
            var ut = (0, W.default)(W.default.BIN, we.slice(0, it))(new Array(65).join("1"));
            Ce.push(ut.length);
          }
          function bt() {
          }
          function pt(kt) {
            return Object.prototype.toString.call(kt).toLowerCase().indexOf("arraybuffer") > -1;
          }
          function Ke(kt) {
            for (var Ye = ie.alloc(kt.byteLength), De = new Uint8Array(kt), Re = 0; Re < Ye.length; ++Re)
              Ye[Re] = De[Re];
            return Ye;
          }
          function dt(kt, Ye) {
            (0, me.default)(kt, function(De, Re, _t) {
              if (De)
                return Ye(De);
              if ("headers" in Re && "location" in Re.headers)
                return kt.url = Re.headers.location, dt(kt, Ye);
              if ((0, P.default)(_t) === "object" && ie.isBuffer(_t))
                return Ye(null, _t);
              var et = "Could not load Buffer from <" + kt.url + "> (HTTP: " + Re.statusCode + ")";
              return new Error(et);
            });
          }
          function ct(kt, Ye) {
            S.default && typeof S.default.readFile == "function" && !kt.match(/^(http|ftp)s?:\/\/./) ? S.default.readFile(kt, Ye) : dt({
              url: kt
            }, Ye);
          }
          function wt(kt) {
            return kt && (0, P.default)(kt) === "object" && typeof kt.width == "number" && typeof kt.height == "number" && (ie.isBuffer(kt.data) || kt.data instanceof Uint8Array || typeof Uint8ClampedArray == "function" && kt.data instanceof Uint8ClampedArray) && (kt.data.length === kt.width * kt.height * 4 || kt.data.length === kt.width * kt.height * 3);
          }
          function Ht(kt) {
            if (kt.length % 3 !== 0)
              throw new Error("Buffer length is incorrect");
            for (var Ye = ie.allocUnsafe(kt.length / 3 * 4), De = 0, Re = 0; Re < kt.length; Re++)
              Ye[De] = kt[Re], (Re + 1) % 3 === 0 && (Ye[++De] = 255), De++;
            return Ye;
          }
          var $t = {
            data: null,
            width: null,
            height: null
          }, rt = /* @__PURE__ */ function(kt) {
            (0, k.default)(Ye, kt);
            function Ye() {
              for (var De, Re = arguments.length, _t = new Array(Re), et = 0; et < Re; et++)
                _t[et] = arguments[et];
              (0, A.default)(this, Ye), De = (0, x.default)(this, (0, m.default)(Ye).call(this)), (0, E.default)((0, w.default)(De), "bitmap", $t), (0, E.default)((0, w.default)(De), "_background", 0), (0, E.default)((0, w.default)(De), "_originalMime", Ye.MIME_PNG), (0, E.default)((0, w.default)(De), "_exif", null), (0, E.default)((0, w.default)(De), "_rgba", !0), (0, E.default)((0, w.default)(De), "writeAsync", function(Qe) {
                return (0, ge.default)(De.write, (0, w.default)(De), Qe);
              }), (0, E.default)((0, w.default)(De), "getBase64Async", function(Qe) {
                return (0, ge.default)(De.getBase64, (0, w.default)(De), Qe);
              }), (0, E.default)((0, w.default)(De), "getBuffer", Oe.getBuffer), (0, E.default)((0, w.default)(De), "getBufferAsync", Oe.getBufferAsync), (0, E.default)((0, w.default)(De), "getPixelColour", De.getPixelColor), (0, E.default)((0, w.default)(De), "setPixelColour", De.setPixelColor);
              var Ie = (0, w.default)(De), pe = bt;
              pt(_t[0]) && (_t[0] = Ke(_t[0]));
              function xt() {
                for (var Qe = arguments.length, re = new Array(Qe), Se = 0; Se < Qe; Se++)
                  re[Se] = arguments[Se];
                var Pe = re[0], at = Pe || {};
                at.methodName = "constructor", setTimeout(function() {
                  var Be;
                  Pe && pe === bt ? Ie.emitError("constructor", Pe) : Pe || Ie.emitMulti("constructor", "initialized"), (Be = pe).call.apply(Be, [Ie].concat(re));
                }, 1);
              }
              if (typeof _t[0] == "number" && typeof _t[1] == "number" || parseInt(_t[0], 10) && parseInt(_t[1], 10)) {
                var l = parseInt(_t[0], 10), _ = parseInt(_t[1], 10);
                if (pe = _t[2], typeof _t[2] == "number" && (De._background = _t[2], pe = _t[3]), typeof _t[2] == "string" && (De._background = Ye.cssColorToHex(_t[2]), pe = _t[3]), typeof pe > "u" && (pe = bt), typeof pe != "function")
                  return (0, x.default)(De, T.throwError.call((0, w.default)(De), "cb must be a function", xt));
                De.bitmap = {
                  data: ie.alloc(l * _ * 4),
                  width: l,
                  height: _
                };
                for (var I = 0; I < De.bitmap.data.length; I += 4)
                  De.bitmap.data.writeUInt32BE(De._background, I);
                xt(null, (0, w.default)(De));
              } else if ((0, P.default)(_t[0]) === "object" && _t[0].url) {
                if (pe = _t[1] || bt, typeof pe != "function")
                  return (0, x.default)(De, T.throwError.call((0, w.default)(De), "cb must be a function", xt));
                dt(_t[0], function(Qe, re) {
                  if (Qe)
                    return T.throwError.call((0, w.default)(De), Qe, xt);
                  De.parseBitmap(re, _t[0].url, xt);
                });
              } else if (_t[0] instanceof Ye) {
                var X = _t[0];
                if (pe = _t[1], typeof pe > "u" && (pe = bt), typeof pe != "function")
                  return (0, x.default)(De, T.throwError.call((0, w.default)(De), "cb must be a function", xt));
                De.bitmap = {
                  data: ie.from(X.bitmap.data),
                  width: X.bitmap.width,
                  height: X.bitmap.height
                }, De._quality = X._quality, De._deflateLevel = X._deflateLevel, De._deflateStrategy = X._deflateStrategy, De._filterType = X._filterType, De._rgba = X._rgba, De._background = X._background, De._originalMime = X._originalMime, xt(null, (0, w.default)(De));
              } else if (wt(_t[0])) {
                var ne = _t[0];
                pe = _t[1] || bt;
                var ue = ne.width * ne.height * 4 === ne.data.length, Te = ue ? ie.from(ne.data) : Ht(ne.data);
                De.bitmap = {
                  data: Te,
                  width: ne.width,
                  height: ne.height
                }, xt(null, (0, w.default)(De));
              } else if (typeof _t[0] == "string") {
                var ye = _t[0];
                if (pe = _t[1], typeof pe > "u" && (pe = bt), typeof pe != "function")
                  return (0, x.default)(De, T.throwError.call((0, w.default)(De), "cb must be a function", xt));
                ct(ye, function(Qe, re) {
                  if (Qe)
                    return T.throwError.call((0, w.default)(De), Qe, xt);
                  De.parseBitmap(re, ye, xt);
                });
              } else if ((0, P.default)(_t[0]) === "object" && ie.isBuffer(_t[0])) {
                var Me = _t[0];
                if (pe = _t[1], typeof pe != "function")
                  return (0, x.default)(De, T.throwError.call((0, w.default)(De), "cb must be a function", xt));
                De.parseBitmap(Me, null, xt);
              } else {
                pe = _t[_t.length - 1], typeof pe != "function" && (pe = _t[_t.length - 2], typeof pe != "function" && (pe = bt));
                var Ge = Ye.__extraConstructors.find(function(Qe) {
                  return Qe.test.apply(Qe, _t);
                });
                if (Ge)
                  new Promise(function(Qe, re) {
                    var Se;
                    return (Se = Ge.run).call.apply(Se, [(0, w.default)(De), Qe, re].concat(_t));
                  }).then(function() {
                    return xt(null, (0, w.default)(De));
                  }).catch(xt);
                else
                  return (0, x.default)(De, T.throwError.call((0, w.default)(De), "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", xt));
              }
              return De;
            }
            return (0, M.default)(Ye, [{
              key: "parseBitmap",
              value: function(Re, _t, et) {
                Oe.parseBitmap.call(this, Re, null, et);
              }
              /**
               * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)
               * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "rgba",
              value: function(Re, _t) {
                return typeof Re != "boolean" ? T.throwError.call(this, "bool must be a boolean, true for RGBA or false for RGB", _t) : (this._rgba = Re, (0, T.isNodePattern)(_t) && _t.call(this, null, this), this);
              }
              /**
               * Emit for multiple listeners
               * @param {string} methodName name of the method to emit an error for
               * @param {string} eventName name of the eventName to emit an error for
               * @param {object} data to emit
               */
            }, {
              key: "emitMulti",
              value: function(Re, _t) {
                var et = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                et = Object.assign(et, {
                  methodName: Re,
                  eventName: _t
                }), this.emit("any", et), Re && this.emit(Re, et), this.emit(_t, et);
              }
            }, {
              key: "emitError",
              value: function(Re, _t) {
                this.emitMulti(Re, "error", _t);
              }
              /**
               * Get the current height of the image
               * @return {number} height of the image
               */
            }, {
              key: "getHeight",
              value: function() {
                return this.bitmap.height;
              }
              /**
               * Get the current width of the image
               * @return {number} width of the image
               */
            }, {
              key: "getWidth",
              value: function() {
                return this.bitmap.width;
              }
              /**
               * Nicely format Jimp object when sent to the console e.g. console.log(image)
               * @returns {string} pretty printed
               */
            }, {
              key: "inspect",
              value: function() {
                return "<Jimp " + (this.bitmap === $t ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
              }
              /**
               * Nicely format Jimp object when converted to a string
               * @returns {string} pretty printed
               */
            }, {
              key: "toString",
              value: function() {
                return "[object Jimp]";
              }
              /**
               * Returns the original MIME of the image (default: "image/png")
               * @returns {string} the MIME
               */
            }, {
              key: "getMIME",
              value: function() {
                var Re = this._originalMime || Ye.MIME_PNG;
                return Re;
              }
              /**
               * Returns the appropriate file extension for the original MIME of the image (default: "png")
               * @returns {string} the file extension
               */
            }, {
              key: "getExtension",
              value: function() {
                var Re = this.getMIME();
                return Ve.getExtension(Re);
              }
              /**
               * Writes the image to a file
               * @param {string} path a path to the destination file
               * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "write",
              value: function(Re, _t) {
                var et = this;
                if (!S.default || !S.default.createWriteStream)
                  throw new Error("Cant access the filesystem. You can use the getBase64 method.");
                if (typeof Re != "string")
                  return T.throwError.call(this, "path must be a string", _t);
                if (typeof _t > "u" && (_t = bt), typeof _t != "function")
                  return T.throwError.call(this, "cb must be a function", _t);
                var Ie = Ve.getType(Re) || this.getMIME(), pe = U.default.parse(Re);
                return pe.dir && J.default.sync(pe.dir), this.getBuffer(Ie, function(xt, l) {
                  if (xt)
                    return T.throwError.call(et, xt, _t);
                  var _ = S.default.createWriteStream(Re);
                  _.on("open", function() {
                    _.write(l), _.end();
                  }).on("error", function(I) {
                    return T.throwError.call(et, I, _t);
                  }), _.on("finish", function() {
                    _t.call(et, null, et);
                  });
                }), this;
              }
            }, {
              key: "getBase64",
              /**
               * Converts the image to a base 64 string
               * @param {string} mime the mime type of the image data to be created
               * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
               * @returns {Jimp} this for chaining of methods
               */
              value: function(Re, _t) {
                return Re === Ye.AUTO && (Re = this.getMIME()), typeof Re != "string" ? T.throwError.call(this, "mime must be a string", _t) : typeof _t != "function" ? T.throwError.call(this, "cb must be a function", _t) : (this.getBuffer(Re, function(et, Ie) {
                  if (et)
                    return T.throwError.call(this, et, _t);
                  var pe = "data:" + Re + ";base64," + Ie.toString("base64");
                  _t.call(this, null, pe);
                }), this);
              }
            }, {
              key: "hash",
              /**
               * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.
               * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {string} a string representing the hash
               */
              value: function(Re, _t) {
                if (Re = Re || 64, typeof Re == "function" && (_t = Re, Re = 64), typeof Re != "number")
                  return T.throwError.call(this, "base must be a number", _t);
                if (Re < 2 || Re > 64)
                  return T.throwError.call(this, "base must be a number between 2 and 64", _t);
                var et = this.pHash();
                for (et = (0, W.default)(W.default.BIN, we.slice(0, Re))(et); et.length < Ce[Re]; )
                  et = "0" + et;
                return (0, T.isNodePattern)(_t) && _t.call(this, null, et), et;
              }
              /**
               * Calculates the perceptual hash
               * @returns {number} the perceptual hash
               */
            }, {
              key: "pHash",
              value: function() {
                var Re = new le.default();
                return Re.getHash(this);
              }
              /**
               * Calculates the hamming distance of the current image and a hash based on their perceptual hash
               * @param {hash} compareHash hash to compare to
               * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
               */
            }, {
              key: "distanceFromHash",
              value: function(Re) {
                var _t = new le.default(), et = _t.getHash(this);
                return _t.distance(et, Re);
              }
              /**
               * Converts the image to a buffer
               * @param {string} mime the mime type of the image buffer to be created
               * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "getPixelIndex",
              /**
               * Returns the offset of a pixel in the bitmap buffer
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
               * @param {number} cb (optional) a callback for when complete
               * @returns {number} the index of the pixel or -1 if not found
               */
              value: function(Re, _t, et, Ie) {
                var pe, xt;
                if (typeof et == "function" && typeof Ie > "u" && (Ie = et, et = null), et || (et = Ye.EDGE_EXTEND), typeof Re != "number" || typeof _t != "number")
                  return T.throwError.call(this, "x and y must be numbers", Ie);
                Re = Math.round(Re), _t = Math.round(_t), pe = Re, xt = _t, et === Ye.EDGE_EXTEND && (Re < 0 && (pe = 0), Re >= this.bitmap.width && (pe = this.bitmap.width - 1), _t < 0 && (xt = 0), _t >= this.bitmap.height && (xt = this.bitmap.height - 1)), et === Ye.EDGE_WRAP && (Re < 0 && (pe = this.bitmap.width + Re), Re >= this.bitmap.width && (pe = Re % this.bitmap.width), _t < 0 && (pe = this.bitmap.height + _t), _t >= this.bitmap.height && (xt = _t % this.bitmap.height));
                var l = this.bitmap.width * xt + pe << 2;
                return (pe < 0 || pe >= this.bitmap.width) && (l = -1), (xt < 0 || xt >= this.bitmap.height) && (l = -1), (0, T.isNodePattern)(Ie) && Ie.call(this, null, l), l;
              }
              /**
               * Returns the hex colour value of a pixel
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {number} the color of the pixel
               */
            }, {
              key: "getPixelColor",
              value: function(Re, _t, et) {
                if (typeof Re != "number" || typeof _t != "number") return T.throwError.call(this, "x and y must be numbers", et);
                Re = Math.round(Re), _t = Math.round(_t);
                var Ie = this.getPixelIndex(Re, _t), pe = this.bitmap.data.readUInt32BE(Ie);
                return (0, T.isNodePattern)(et) && et.call(this, null, pe), pe;
              }
            }, {
              key: "setPixelColor",
              /**
               * Returns the hex colour value of a pixel
               * @param {number} hex color to set
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {number} the index of the pixel or -1 if not found
               */
              value: function(Re, _t, et, Ie) {
                if (typeof Re != "number" || typeof _t != "number" || typeof et != "number") return T.throwError.call(this, "hex, x and y must be numbers", Ie);
                _t = Math.round(_t), et = Math.round(et);
                var pe = this.getPixelIndex(_t, et);
                return this.bitmap.data.writeUInt32BE(Re, pe), (0, T.isNodePattern)(Ie) && Ie.call(this, null, this), this;
              }
            }, {
              key: "hasAlpha",
              /**
               * Determine if the image contains opaque pixels.
               * @return {boolean} hasAlpha whether the image contains opaque pixels
               */
              value: function() {
                for (var Re = 0; Re < this.bitmap.height; Re++)
                  for (var _t = 0; _t < this.bitmap.width; _t++) {
                    var et = this.bitmap.width * Re + _t << 2, Ie = this.bitmap.data[et + 3];
                    if (Ie !== 255)
                      return !0;
                  }
                return !1;
              }
              /**
               * Iterate scan through a region of the bitmap
               * @param {number} x the x coordinate to begin the scan at
               * @param {number} y the y coordinate to begin the scan at
               * @param w the width of the scan region
               * @param h the height of the scan region
               * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}
               */
            }, {
              key: "scanIterator",
              value: function(Re, _t, et, Ie) {
                return typeof Re != "number" || typeof _t != "number" ? T.throwError.call(this, "x and y must be numbers") : typeof et != "number" || typeof Ie != "number" ? T.throwError.call(this, "w and h must be numbers") : (0, T.scanIterator)(this, Re, _t, et, Ie);
              }
            }]), Ye;
          }(j.default);
          function ri(kt) {
            var Ye = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rt;
            Object.entries(kt).forEach(function(De) {
              var Re = (0, R.default)(De, 2), _t = Re[0], et = Re[1];
              Ye[_t] = et;
            });
          }
          function wi(kt) {
            var Ye = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rt;
            Object.entries(kt).forEach(function(De) {
              var Re = (0, R.default)(De, 2), _t = Re[0], et = Re[1];
              Ye.prototype[_t] = et;
            });
          }
          ri(Ue), wi({
            composite: ke.default
          }), rt.__extraConstructors = [], rt.appendConstructorOption = function(kt, Ye, De) {
            rt.__extraConstructors.push({
              name: kt,
              test: Ye,
              run: De
            });
          }, rt.read = function() {
            for (var kt = arguments.length, Ye = new Array(kt), De = 0; De < kt; De++)
              Ye[De] = arguments[De];
            return new Promise(function(Re, _t) {
              (0, Z.default)(rt, Ye.concat([function(et, Ie) {
                et ? _t(et) : Re(Ie);
              }]));
            });
          }, rt.create = rt.read, rt.rgbaToInt = function(kt, Ye, De, Re, _t) {
            if (typeof kt != "number" || typeof Ye != "number" || typeof De != "number" || typeof Re != "number")
              return T.throwError.call(this, "r, g, b and a must be numbers", _t);
            if (kt < 0 || kt > 255)
              return T.throwError.call(this, "r must be between 0 and 255", _t);
            if ((Ye < 0 || Ye > 255) && T.throwError.call(this, "g must be between 0 and 255", _t), De < 0 || De > 255)
              return T.throwError.call(this, "b must be between 0 and 255", _t);
            if (Re < 0 || Re > 255)
              return T.throwError.call(this, "a must be between 0 and 255", _t);
            kt = Math.round(kt), De = Math.round(De), Ye = Math.round(Ye), Re = Math.round(Re);
            var et = kt * Math.pow(256, 3) + Ye * Math.pow(256, 2) + De * Math.pow(256, 1) + Re * Math.pow(256, 0);
            return (0, T.isNodePattern)(_t) && _t.call(this, null, et), et;
          }, rt.intToRGBA = function(kt, Ye) {
            if (typeof kt != "number")
              return T.throwError.call(this, "i must be a number", Ye);
            var De = {};
            return De.r = Math.floor(kt / Math.pow(256, 3)), De.g = Math.floor((kt - De.r * Math.pow(256, 3)) / Math.pow(256, 2)), De.b = Math.floor((kt - De.r * Math.pow(256, 3) - De.g * Math.pow(256, 2)) / Math.pow(256, 1)), De.a = Math.floor((kt - De.r * Math.pow(256, 3) - De.g * Math.pow(256, 2) - De.b * Math.pow(256, 1)) / Math.pow(256, 0)), (0, T.isNodePattern)(Ye) && Ye.call(this, null, De), De;
          }, rt.cssColorToHex = function(kt) {
            return kt = kt || 0, typeof kt == "number" ? Number(kt) : parseInt((0, te.default)(kt).toHex8(), 16);
          }, rt.limit255 = function(kt) {
            return kt = Math.max(kt, 0), kt = Math.min(kt, 255), kt;
          }, rt.diff = function(kt, Ye) {
            var De = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.1;
            if (!(kt instanceof rt) || !(Ye instanceof rt)) return T.throwError.call(this, "img1 and img2 must be an Jimp images");
            var Re = kt.bitmap, _t = Ye.bitmap;
            if ((Re.width !== _t.width || Re.height !== _t.height) && (Re.width * Re.height > _t.width * _t.height ? kt = kt.cloneQuiet().resize(_t.width, _t.height) : Ye = Ye.cloneQuiet().resize(Re.width, Re.height)), typeof De != "number" || De < 0 || De > 1)
              return T.throwError.call(this, "threshold must be a number between 0 and 1");
            var et = new rt(Re.width, Re.height, 4294967295), Ie = (0, ee.default)(Re.data, _t.data, et.bitmap.data, et.bitmap.width, et.bitmap.height, {
              threshold: De
            });
            return {
              percent: Ie / (et.bitmap.width * et.bitmap.height),
              image: et
            };
          }, rt.distance = function(kt, Ye) {
            var De = new le.default(), Re = De.getHash(kt), _t = De.getHash(Ye);
            return De.distance(Re, _t);
          }, rt.compareHashes = function(kt, Ye) {
            var De = new le.default();
            return De.distance(kt, Ye);
          }, rt.colorDiff = function(kt, Ye) {
            var De = function(Ie) {
              return Math.pow(Ie, 2);
            }, Re = Math.max, _t = 255 * 255 * 3;
            return kt.a !== 0 && !kt.a && (kt.a = 255), Ye.a !== 0 && !Ye.a && (Ye.a = 255), (Re(De(kt.r - Ye.r), De(kt.r - Ye.r - kt.a + Ye.a)) + Re(De(kt.g - Ye.g), De(kt.g - Ye.g - kt.a + Ye.a)) + Re(De(kt.b - Ye.b), De(kt.b - Ye.b - kt.a + Ye.a))) / _t;
          };
          function Qt(kt, Ye, De) {
            var Re = "before-" + Ye, _t = Ye.replace(/e$/, "") + "ed";
            rt.prototype[kt] = function() {
              for (var et, Ie = arguments.length, pe = new Array(Ie), xt = 0; xt < Ie; xt++)
                pe[xt] = arguments[xt];
              var l = pe[De.length - 1], _ = this;
              typeof l == "function" ? (et = function() {
                for (var ne = arguments.length, ue = new Array(ne), Te = 0; Te < ne; Te++)
                  ue[Te] = arguments[Te];
                var ye = ue[0], Me = ue[1];
                ye ? _.emitError(kt, ye) : _.emitMulti(kt, _t, (0, E.default)({}, kt, Me)), l.apply(this, ue);
              }, pe[pe.length - 1] = et) : et = !1, this.emitMulti(kt, Re);
              var I;
              try {
                I = De.apply(this, pe), et || this.emitMulti(kt, _t, (0, E.default)({}, kt, I));
              } catch (X) {
                X.methodName = kt, this.emitError(kt, X);
              }
              return I;
            }, rt.prototype[kt + "Quiet"] = De;
          }
          Qt("clone", "clone", function(kt) {
            var Ye = new rt(this);
            return (0, T.isNodePattern)(kt) && kt.call(Ye, null, Ye), Ye;
          });
          function At(kt, Ye) {
            Qt(kt, "change", Ye);
          }
          At("background", function(kt, Ye) {
            return typeof kt != "number" ? T.throwError.call(this, "hex must be a hexadecimal rgba value", Ye) : (this._background = kt, (0, T.isNodePattern)(Ye) && Ye.call(this, null, this), this);
          }), At("scan", function(kt, Ye, De, Re, _t, et) {
            if (typeof kt != "number" || typeof Ye != "number")
              return T.throwError.call(this, "x and y must be numbers", et);
            if (typeof De != "number" || typeof Re != "number")
              return T.throwError.call(this, "w and h must be numbers", et);
            if (typeof _t != "function")
              return T.throwError.call(this, "f must be a function", et);
            var Ie = (0, T.scan)(this, kt, Ye, De, Re, _t);
            return (0, T.isNodePattern)(et) && et.call(this, null, Ie), Ie;
          });
          {
            var St;
            typeof qe < "u" && (typeof qe > "u" ? "undefined" : (0, P.default)(qe)) === "object" && (St = qe), typeof self < "u" && (typeof self > "u" ? "undefined" : (0, P.default)(self)) === "object" && (St = self), St.Jimp = rt, St.Buffer = ie;
          }
          var Lt = rt;
          q.default = Lt;
        }).call(this, Q("buffer").Buffer);
      }, { "./composite": 191, "./constants": 192, "./modules/phash": 194, "./request": 195, "./utils/image-bitmap": 196, "./utils/mime": 197, "./utils/promisify": 198, "@babel/runtime/helpers/assertThisInitialized": 3, "@babel/runtime/helpers/classCallCheck": 4, "@babel/runtime/helpers/construct": 5, "@babel/runtime/helpers/createClass": 6, "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/getPrototypeOf": 9, "@babel/runtime/helpers/inherits": 10, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/possibleConstructorReturn": 17, "@babel/runtime/helpers/slicedToArray": 19, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, "any-base": 23, buffer: 48, events: 52, fs: 47, mkdirp: 83, path: 107, pixelmatch: 109, tinycolor2: 178 }], 194: [function(Q, de, q) {
        function ie(A, M) {
          this.size = this.size || A, this.smallerSize = this.smallerSize || M, Z(this.size);
        }
        ie.prototype.size = 32, ie.prototype.smallerSize = 8, ie.prototype.distance = function(A, M) {
          for (var x = 0, m = 0; m < A.length; m++)
            A[m] !== M[m] && x++;
          return x / A.length;
        }, ie.prototype.getHash = function(A) {
          A = A.clone().resize(this.size, this.size), A.grayscale();
          for (var M = [], x = 0; x < A.bitmap.width; x++) {
            M[x] = [];
            for (var m = 0; m < A.bitmap.height; m++)
              M[x][m] = i(A.getPixelColor(x, m)).b;
          }
          for (var w = R(M, this.size), k = 0, E = 0; E < this.smallerSize; E++)
            for (var P = 0; P < this.smallerSize; P++)
              k += w[E][P];
          for (var S = k / (this.smallerSize * this.smallerSize), U = "", j = 0; j < this.smallerSize; j++)
            for (var T = 0; T < this.smallerSize; T++)
              U += w[j][T] > S ? "1" : "0";
          return U;
        };
        function i(A) {
          var M = {};
          return M.r = Math.floor(A / Math.pow(256, 3)), M.g = Math.floor((A - M.r * Math.pow(256, 3)) / Math.pow(256, 2)), M.b = Math.floor((A - M.r * Math.pow(256, 3) - M.g * Math.pow(256, 2)) / Math.pow(256, 1)), M.a = Math.floor((A - M.r * Math.pow(256, 3) - M.g * Math.pow(256, 2) - M.b * Math.pow(256, 1)) / Math.pow(256, 0)), M;
        }
        var N = [];
        function Z(A) {
          for (var M = 1; M < A; M++)
            N[M] = 1;
          N[0] = 1 / Math.sqrt(2);
        }
        function R(A, M) {
          for (var x = M, m = [], w = 0; w < x; w++) {
            m[w] = [];
            for (var k = 0; k < x; k++) {
              for (var E = 0, P = 0; P < x; P++)
                for (var S = 0; S < x; S++)
                  E += Math.cos((2 * P + 1) / (2 * x) * w * Math.PI) * Math.cos((2 * S + 1) / (2 * x) * k * Math.PI) * A[P][S];
              E *= N[w] * N[k] / 4, m[w][k] = E;
            }
          }
          return m;
        }
        de.exports = ie;
      }, {}], 195: [function(Q, de, q) {
        (function(ie, i) {
          var N = Q("@babel/runtime/helpers/interopRequireDefault");
          N(Q("@babel/runtime/helpers/defineProperty")), N(Q("@babel/runtime/helpers/extends")), ie.browser, de.exports = function(Z, R) {
            var A = new XMLHttpRequest();
            A.open("GET", Z.url, !0), A.responseType = "arraybuffer", A.addEventListener("load", function() {
              if (A.status < 400)
                try {
                  var M = i.from(this.response);
                  R(null, A, M);
                } catch (x) {
                  return R(new Error("Response is not a buffer for url " + Z.url + ". Error: " + x.message));
                }
              else
                R(new Error("HTTP Status " + A.status + " for url " + Z.url));
            }), A.addEventListener("error", function(M) {
              R(M);
            }), A.send();
          };
        }).call(this, Q("_process"), Q("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/extends": 8, "@babel/runtime/helpers/interopRequireDefault": 11, _process: 133, buffer: 48, phin: 108 }], 196: [function(Q, de, q) {
        (function(ie) {
          var i = Q("@babel/runtime/helpers/interopRequireWildcard"), N = Q("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(q, "__esModule", {
            value: !0
          }), q.parseBitmap = j, q.getBuffer = W, q.getBufferAsync = J;
          var Z = N(Q("@babel/runtime/helpers/slicedToArray")), R = N(Q("file-type")), A = N(Q("exif-parser")), M = Q("@jimp/utils"), x = i(Q("../constants")), m = i(Q("./mime")), w = N(Q("./promisify"));
          function k(ee, te) {
            var le = (0, R.default)(ee);
            return le ? le.mime : te ? m.getType(te) : null;
          }
          function E(ee) {
            return ee._exif && ee._exif.tags && ee._exif.tags.Orientation || 1;
          }
          function P(ee) {
            var te = ee.getWidth(), le = ee.getHeight();
            switch (E(ee)) {
              case 1:
                return null;
              case 2:
                return function(me, ke) {
                  return [te - me - 1, ke];
                };
              case 3:
                return function(me, ke) {
                  return [te - me - 1, le - ke - 1];
                };
              case 4:
                return function(me, ke) {
                  return [me, le - ke - 1];
                };
              case 5:
                return function(me, ke) {
                  return [ke, me];
                };
              case 6:
                return function(me, ke) {
                  return [ke, le - me - 1];
                };
              case 7:
                return function(me, ke) {
                  return [te - ke - 1, le - me - 1];
                };
              case 8:
                return function(me, ke) {
                  return [te - ke - 1, me];
                };
              default:
                return null;
            }
          }
          function S(ee, te, le, me) {
            for (var ke = ee.bitmap.data, ge = ee.bitmap.width, Ve = ie.alloc(ke.length), Oe = 0; Oe < te; Oe++)
              for (var Ue = 0; Ue < le; Ue++) {
                var we = me(Oe, Ue), Ce = (0, Z.default)(we, 2), it = Ce[0], ut = Ce[1], bt = te * Ue + Oe << 2, pt = ge * ut + it << 2, Ke = ke.readUInt32BE(pt);
                Ve.writeUInt32BE(Ke, bt);
              }
            ee.bitmap.data = Ve, ee.bitmap.width = te, ee.bitmap.height = le;
          }
          function U(ee) {
            if (!(E(ee) < 2)) {
              var te = P(ee), le = E(ee) > 4, me = le ? ee.bitmap.height : ee.bitmap.width, ke = le ? ee.bitmap.width : ee.bitmap.height;
              S(ee, me, ke, te);
            }
          }
          function j(ee, te, le) {
            var me = k(ee, te);
            if (typeof me != "string")
              return le(new Error("Could not find MIME for Buffer <" + te + ">"));
            this._originalMime = me.toLowerCase();
            try {
              var ke = this.getMIME();
              if (this.constructor.decoders[ke])
                this.bitmap = this.constructor.decoders[ke](ee);
              else
                return M.throwError.call(this, "Unsupported MIME type: " + ke, le);
            } catch (ge) {
              return le.call(this, ge, this);
            }
            try {
              this._exif = A.default.create(ee).parse(), U(this);
            } catch {
            }
            return le.call(this, null, this), this;
          }
          function T(ee, te) {
            return new ee(te.bitmap.width, te.bitmap.height, te._background).composite(te, 0, 0).bitmap;
          }
          function W(ee, te) {
            if (ee === x.AUTO && (ee = this.getMIME()), typeof ee != "string")
              return M.throwError.call(this, "mime must be a string", te);
            if (typeof te != "function")
              return M.throwError.call(this, "cb must be a function", te);
            if (ee = ee.toLowerCase(), this._rgba && this.constructor.hasAlpha[ee] ? this.bitmap.data = ie.from(this.bitmap.data) : this.bitmap.data = T(this.constructor, this).data, this.constructor.encoders[ee]) {
              var le = this.constructor.encoders[ee](this);
              te.call(this, null, le);
            } else
              te.call(this, "Unsupported MIME type: " + ee);
            return this;
          }
          function J(ee) {
            return (0, w.default)(W, this, ee);
          }
        }).call(this, Q("buffer").Buffer);
      }, { "../constants": 192, "./mime": 197, "./promisify": 198, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/slicedToArray": 19, "@jimp/utils": 235, buffer: 48, "exif-parser": 53, "file-type": 62 }], 197: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.getExtension = q.getType = q.addType = void 0;
        var ie = {}, i = function(M) {
          return Object.entries(ie).find(function(x) {
            return x[1].includes(M);
          }) || [];
        }, N = function(M, x) {
          ie[M] = x;
        };
        q.addType = N;
        var Z = function(M) {
          var x = M.split("/").slice(-1), m = x[x.length - 1].split(".").pop(), w = i(m);
          return w[0];
        };
        q.getType = Z;
        var R = function(M) {
          return (ie[M.toLowerCase()] || [])[0];
        };
        q.getExtension = R;
      }, {}], 198: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = function(Z, R) {
          for (var A = arguments.length, M = new Array(A > 2 ? A - 2 : 0), x = 2; x < A; x++)
            M[x - 2] = arguments[x];
          return new Promise(function(m, w) {
            M.push(function(k, E) {
              k && w(k), m(E);
            }), Z.bind(R).apply(void 0, M);
          });
        }, i = ie;
        q.default = i, de.exports = q.default;
      }, {}], 199: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireWildcard"), i = Q("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = m;
        var N = i(Q("@babel/runtime/helpers/toConsumableArray")), Z = i(Q("@babel/runtime/helpers/defineProperty")), R = i(Q("@babel/runtime/helpers/slicedToArray")), A = ie(Q("@jimp/core"));
        function M(w, k) {
          var E = Object.keys(w);
          if (Object.getOwnPropertySymbols) {
            var P = Object.getOwnPropertySymbols(w);
            k && (P = P.filter(function(S) {
              return Object.getOwnPropertyDescriptor(w, S).enumerable;
            })), E.push.apply(E, P);
          }
          return E;
        }
        function x(w) {
          for (var k = 1; k < arguments.length; k++) {
            var E = arguments[k] != null ? arguments[k] : {};
            k % 2 ? M(E, !0).forEach(function(P) {
              (0, Z.default)(w, P, E[P]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(E)) : M(E).forEach(function(P) {
              Object.defineProperty(w, P, Object.getOwnPropertyDescriptor(E, P));
            });
          }
          return w;
        }
        function m(w) {
          var k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A.default, E = {
            hasAlpha: {},
            encoders: {},
            decoders: {},
            class: {},
            constants: {}
          };
          function P(j) {
            Object.entries(j).forEach(function(T) {
              var W = (0, R.default)(T, 2), J = W[0], ee = W[1];
              E[J] = x({}, E[J], {}, ee);
            });
          }
          function S(j) {
            var T = j();
            Array.isArray(T.mime) ? A.addType.apply(void 0, (0, N.default)(T.mime)) : Object.entries(T.mime).forEach(function(W) {
              return A.addType.apply(void 0, (0, N.default)(W));
            }), delete T.mime, P(T);
          }
          function U(j) {
            var T = j(A.jimpEvChange) || {};
            !T.class && !T.constants ? P({
              class: T
            }) : P(T);
          }
          return w.types && (w.types.forEach(S), k.decoders = x({}, k.decoders, {}, E.decoders), k.encoders = x({}, k.encoders, {}, E.encoders), k.hasAlpha = x({}, k.hasAlpha, {}, E.hasAlpha)), w.plugins && w.plugins.forEach(U), (0, A.addJimpMethods)(E.class, k), (0, A.addConstants)(E.constants, k), A.default;
        }
        de.exports = q.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/slicedToArray": 19, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/core": 193 }], 200: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var i = ie(Q("@jimp/custom")), N = ie(Q("@jimp/types")), Z = ie(Q("@jimp/plugins")), R = (0, i.default)({
          types: [N.default],
          plugins: [Z.default]
        });
        q.default = R, de.exports = q.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/custom": 199, "@jimp/plugins": 228, "@jimp/types": 234 }], 201: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var i = ie(Q("@babel/runtime/helpers/typeof")), N = Q("@jimp/utils"), Z = function() {
          return {
            /**
             * Blits a source image on to this image
             * @param {Jimp} src the source Jimp instance
             * @param {number} x the x position to blit the image
             * @param {number} y the y position to blit the image
             * @param {number} srcx (optional) the x position from which to crop the source image
             * @param {number} srcy (optional) the y position from which to crop the source image
             * @param {number} srcw (optional) the width to which to crop the source image
             * @param {number} srch (optional) the height to which to crop the source image
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            blit: function(M, x, m, w, k, E, P, S) {
              if (!(M instanceof this.constructor))
                return N.throwError.call(this, "The source must be a Jimp image", S);
              if (typeof x != "number" || typeof m != "number")
                return N.throwError.call(this, "x and y must be numbers", S);
              if (typeof w == "function")
                S = w, w = 0, k = 0, E = M.bitmap.width, P = M.bitmap.height;
              else if ((0, i.default)(w) === (0, i.default)(k) && (0, i.default)(k) === (0, i.default)(E) && (0, i.default)(E) === (0, i.default)(P))
                w = w || 0, k = k || 0, E = E || M.bitmap.width, P = P || M.bitmap.height;
              else
                return N.throwError.call(this, "srcx, srcy, srcw, srch must be numbers", S);
              x = Math.round(x), m = Math.round(m), w = Math.round(w), k = Math.round(k), E = Math.round(E), P = Math.round(P);
              var U = this.bitmap.width, j = this.bitmap.height, T = this;
              return M.scanQuiet(w, k, E, P, function(W, J, ee) {
                var te = x + W - w, le = m + J - k;
                if (te >= 0 && le >= 0 && U - te > 0 && j - le > 0) {
                  var me = T.getPixelIndex(te, le), ke = {
                    r: this.bitmap.data[ee],
                    g: this.bitmap.data[ee + 1],
                    b: this.bitmap.data[ee + 2],
                    a: this.bitmap.data[ee + 3]
                  }, ge = {
                    r: T.bitmap.data[me],
                    g: T.bitmap.data[me + 1],
                    b: T.bitmap.data[me + 2],
                    a: T.bitmap.data[me + 3]
                  };
                  T.bitmap.data[me] = (ke.a * (ke.r - ge.r) - ge.r + 255 >> 8) + ge.r, T.bitmap.data[me + 1] = (ke.a * (ke.g - ge.g) - ge.g + 255 >> 8) + ge.g, T.bitmap.data[me + 2] = (ke.a * (ke.b - ge.b) - ge.b + 255 >> 8) + ge.b, T.bitmap.data[me + 3] = this.constructor.limit255(ge.a + ke.a);
                }
              }), (0, N.isNodePattern)(S) && S.call(this, null, this), this;
            }
          };
        };
        q.default = Z, de.exports = q.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235 }], 202: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.shgTable = q.mulTable = void 0;
        var ie = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
        q.mulTable = ie;
        var i = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
        q.shgTable = i;
      }, {}], 203: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils"), i = Q("./blur-tables"), N = function() {
          return {
            /**
             * A fast blur algorithm that produces similar effect to a Gaussian blur - but MUCH quicker
             * @param {number} r the pixel radius of the blur
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            blur: function(A, M) {
              if (typeof A != "number") return ie.throwError.call(this, "r must be a number", M);
              if (A < 1) return ie.throwError.call(this, "r must be greater than 0", M);
              for (var x, m, w, k, E, P, S, U, j, T, W, J, ee, te, le = this.bitmap.width - 1, me = this.bitmap.height - 1, ke = A + 1, ge = i.mulTable[A], Ve = i.shgTable[A], Oe = [], Ue = [], we = [], Ce = [], it = [], ut = [], bt = 2; bt-- > 0; ) {
                for (J = 0, ee = 0, P = 0; P < this.bitmap.height; P++) {
                  for (x = this.bitmap.data[ee] * ke, m = this.bitmap.data[ee + 1] * ke, w = this.bitmap.data[ee + 2] * ke, k = this.bitmap.data[ee + 3] * ke, S = 1; S <= A; S++)
                    U = ee + ((S > le ? le : S) << 2), x += this.bitmap.data[U++], m += this.bitmap.data[U++], w += this.bitmap.data[U++], k += this.bitmap.data[U];
                  for (E = 0; E < this.bitmap.width; E++)
                    Oe[J] = x, Ue[J] = m, we[J] = w, Ce[J] = k, P === 0 && (it[E] = ((U = E + ke) < le ? U : le) << 2, ut[E] = (U = E - A) > 0 ? U << 2 : 0), j = ee + it[E], T = ee + ut[E], x += this.bitmap.data[j++] - this.bitmap.data[T++], m += this.bitmap.data[j++] - this.bitmap.data[T++], w += this.bitmap.data[j++] - this.bitmap.data[T++], k += this.bitmap.data[j] - this.bitmap.data[T], J++;
                  ee += this.bitmap.width << 2;
                }
                for (E = 0; E < this.bitmap.width; E++) {
                  for (W = E, x = Oe[W] * ke, m = Ue[W] * ke, w = we[W] * ke, k = Ce[W] * ke, S = 1; S <= A; S++)
                    W += S > me ? 0 : this.bitmap.width, x += Oe[W], m += Ue[W], w += we[W], k += Ce[W];
                  for (J = E << 2, P = 0; P < this.bitmap.height; P++)
                    te = k * ge >>> Ve, this.bitmap.data[J + 3] = te, te > 255 && (this.bitmap.data[J + 3] = 255), te > 0 ? (te = 255 / te, this.bitmap.data[J] = (x * ge >>> Ve) * te, this.bitmap.data[J + 1] = (m * ge >>> Ve) * te, this.bitmap.data[J + 2] = (w * ge >>> Ve) * te) : (this.bitmap.data[J + 2] = 0, this.bitmap.data[J + 1] = 0, this.bitmap.data[J] = 0), E === 0 && (it[P] = ((U = P + ke) < me ? U : me) * this.bitmap.width, ut[P] = (U = P - A) > 0 ? U * this.bitmap.width : 0), j = E + it[P], T = E + ut[P], x += Oe[j] - Oe[T], m += Ue[j] - Ue[T], w += we[j] - we[T], k += Ce[j] - Ce[T], J += this.bitmap.width << 2;
                }
              }
              return (0, ie.isNodePattern)(M) && M.call(this, null, this), this;
            }
          };
        };
        q.default = N, de.exports = q.default;
      }, { "./blur-tables": 202, "@jimp/utils": 235 }], 204: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils"), i = function() {
          return {
            circle: function() {
              var R = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, A = arguments.length > 1 ? arguments[1] : void 0;
              typeof R == "function" && (A = R, R = {});
              var M = R.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2, x = {
                x: typeof R.x == "number" ? R.x : this.bitmap.width / 2,
                y: typeof R.y == "number" ? R.y : this.bitmap.height / 2
              };
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(m, w, k) {
                var E = Math.sqrt(Math.pow(m - x.x, 2) + Math.pow(w - x.y, 2));
                M - E <= 0 ? this.bitmap.data[k + 3] = 0 : M - E < 1 && (this.bitmap.data[k + 3] = 255 * (M - E));
              }), (0, ie.isNodePattern)(A) && A.call(this, null, this), this;
            }
          };
        };
        q.default = i, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 205: [function(Q, de, q) {
        (function(ie) {
          var i = Q("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(q, "__esModule", {
            value: !0
          }), q.default = void 0;
          var N = i(Q("@babel/runtime/helpers/toConsumableArray")), Z = i(Q("tinycolor2")), R = Q("@jimp/utils");
          function A(E, P, S, U) {
            for (var j = [0, 0, 0], T = (P.length - 1) / 2, W = 0; W < P.length; W += 1)
              for (var J = 0; J < P[W].length; J += 1) {
                var ee = E.getPixelIndex(S + W - T, U + J - T);
                j[0] += E.bitmap.data[ee] * P[W][J], j[1] += E.bitmap.data[ee + 1] * P[W][J], j[2] += E.bitmap.data[ee + 2] * P[W][J];
              }
            return j;
          }
          var M = function(P) {
            return typeof P < "u" && P !== null;
          };
          function x(E) {
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(P, S, U) {
              var j = parseInt(0.2126 * this.bitmap.data[U] + 0.7152 * this.bitmap.data[U + 1] + 0.0722 * this.bitmap.data[U + 2], 10);
              this.bitmap.data[U] = j, this.bitmap.data[U + 1] = j, this.bitmap.data[U + 2] = j;
            }), (0, R.isNodePattern)(E) && E.call(this, null, this), this;
          }
          function m(E, P) {
            var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50;
            return {
              r: (P.r - E.r) * (S / 100) + E.r,
              g: (P.g - E.g) * (S / 100) + E.g,
              b: (P.b - E.b) * (S / 100) + E.b
            };
          }
          function w(E, P) {
            var S = this;
            return !E || !Array.isArray(E) ? R.throwError.call(this, "actions must be an array", P) : (E = E.map(function(U) {
              return (U.apply === "xor" || U.apply === "mix") && (U.params[0] = (0, Z.default)(U.params[0]).toRgb()), U;
            }), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(U, j, T) {
              var W = {
                r: S.bitmap.data[T],
                g: S.bitmap.data[T + 1],
                b: S.bitmap.data[T + 2]
              }, J = function(te, le) {
                return S.constructor.limit255(W[te] + le);
              };
              E.forEach(function(ee) {
                if (ee.apply === "mix")
                  W = m(W, ee.params[0], ee.params[1]);
                else if (ee.apply === "tint")
                  W = m(W, {
                    r: 255,
                    g: 255,
                    b: 255
                  }, ee.params[0]);
                else if (ee.apply === "shade")
                  W = m(W, {
                    r: 0,
                    g: 0,
                    b: 0
                  }, ee.params[0]);
                else if (ee.apply === "xor")
                  W = {
                    r: W.r ^ ee.params[0].r,
                    g: W.g ^ ee.params[0].g,
                    b: W.b ^ ee.params[0].b
                  };
                else if (ee.apply === "red")
                  W.r = J("r", ee.params[0]);
                else if (ee.apply === "green")
                  W.g = J("g", ee.params[0]);
                else if (ee.apply === "blue")
                  W.b = J("b", ee.params[0]);
                else {
                  var te;
                  if (ee.apply === "hue" && (ee.apply = "spin"), W = (0, Z.default)(W), !W[ee.apply])
                    return R.throwError.call(S, "action " + ee.apply + " not supported", P);
                  W = (te = W)[ee.apply].apply(te, (0, N.default)(ee.params)).toRgb();
                }
              }), S.bitmap.data[T] = W.r, S.bitmap.data[T + 1] = W.g, S.bitmap.data[T + 2] = W.b;
            }), (0, R.isNodePattern)(P) && P.call(this, null, this), this);
          }
          var k = function() {
            return {
              /**
               * Adjusts the brightness of the image
               * @param {number} val the amount to adjust the brightness, a number between -1 and +1
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              brightness: function(S, U) {
                return typeof S != "number" ? R.throwError.call(this, "val must be numbers", U) : S < -1 || S > 1 ? R.throwError.call(this, "val must be a number between -1 and +1", U) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(j, T, W) {
                  S < 0 ? (this.bitmap.data[W] = this.bitmap.data[W] * (1 + S), this.bitmap.data[W + 1] = this.bitmap.data[W + 1] * (1 + S), this.bitmap.data[W + 2] = this.bitmap.data[W + 2] * (1 + S)) : (this.bitmap.data[W] = this.bitmap.data[W] + (255 - this.bitmap.data[W]) * S, this.bitmap.data[W + 1] = this.bitmap.data[W + 1] + (255 - this.bitmap.data[W + 1]) * S, this.bitmap.data[W + 2] = this.bitmap.data[W + 2] + (255 - this.bitmap.data[W + 2]) * S);
                }), (0, R.isNodePattern)(U) && U.call(this, null, this), this);
              },
              /**
               * Adjusts the contrast of the image
               * @param {number} val the amount to adjust the contrast, a number between -1 and +1
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              contrast: function(S, U) {
                if (typeof S != "number")
                  return R.throwError.call(this, "val must be numbers", U);
                if (S < -1 || S > 1)
                  return R.throwError.call(this, "val must be a number between -1 and +1", U);
                var j = (S + 1) / (1 - S);
                function T(W) {
                  return W = Math.floor(j * (W - 127) + 127), W < 0 ? 0 : W > 255 ? 255 : W;
                }
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(W, J, ee) {
                  this.bitmap.data[ee] = T(this.bitmap.data[ee]), this.bitmap.data[ee + 1] = T(this.bitmap.data[ee + 1]), this.bitmap.data[ee + 2] = T(this.bitmap.data[ee + 2]);
                }), (0, R.isNodePattern)(U) && U.call(this, null, this), this;
              },
              /**
               * Apply a posterize effect
               * @param {number} n the amount to adjust the contrast, minimum threshold is two
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              posterize: function(S, U) {
                return typeof S != "number" ? R.throwError.call(this, "n must be numbers", U) : (S < 2 && (S = 2), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(j, T, W) {
                  this.bitmap.data[W] = Math.floor(this.bitmap.data[W] / 255 * (S - 1)) / (S - 1) * 255, this.bitmap.data[W + 1] = Math.floor(this.bitmap.data[W + 1] / 255 * (S - 1)) / (S - 1) * 255, this.bitmap.data[W + 2] = Math.floor(this.bitmap.data[W + 2] / 255 * (S - 1)) / (S - 1) * 255;
                }), (0, R.isNodePattern)(U) && U.call(this, null, this), this);
              },
              /**
               * Removes colour from the image using ITU Rec 709 luminance values
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              greyscale: x,
              // Alias of greyscale for our American friends
              grayscale: x,
              /**
               * Multiplies the opacity of each pixel by a factor between 0 and 1
               * @param {number} f A number, the factor by which to multiply the opacity of each pixel
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              opacity: function(S, U) {
                return typeof S != "number" ? R.throwError.call(this, "f must be a number", U) : S < 0 || S > 1 ? R.throwError.call(this, "f must be a number from 0 to 1", U) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(j, T, W) {
                  var J = this.bitmap.data[W + 3] * S;
                  this.bitmap.data[W + 3] = J;
                }), (0, R.isNodePattern)(U) && U.call(this, null, this), this);
              },
              /**
               * Applies a sepia tone to the image
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              sepia: function(S) {
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(U, j, T) {
                  var W = this.bitmap.data[T], J = this.bitmap.data[T + 1], ee = this.bitmap.data[T + 2];
                  W = W * 0.393 + J * 0.769 + ee * 0.189, J = W * 0.349 + J * 0.686 + ee * 0.168, ee = W * 0.272 + J * 0.534 + ee * 0.131, this.bitmap.data[T] = W < 255 ? W : 255, this.bitmap.data[T + 1] = J < 255 ? J : 255, this.bitmap.data[T + 2] = ee < 255 ? ee : 255;
                }), (0, R.isNodePattern)(S) && S.call(this, null, this), this;
              },
              /**
               * Fades each pixel by a factor between 0 and 1
               * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              fade: function(S, U) {
                return typeof S != "number" ? R.throwError.call(this, "f must be a number", U) : S < 0 || S > 1 ? R.throwError.call(this, "f must be a number from 0 to 1", U) : (this.opacity(1 - S), (0, R.isNodePattern)(U) && U.call(this, null, this), this);
              },
              /**
               * Adds each element of the image to its local neighbors, weighted by the kernel
               * @param {array} kernel a matrix to weight the neighbors sum
               * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              convolution: function(S, U, j) {
                typeof U == "function" && typeof j > "u" && (j = U, U = null), U || (U = this.constructor.EDGE_EXTEND);
                var T = ie.from(this.bitmap.data), W = S.length, J = S[0].length, ee = Math.floor(W / 2), te = Math.floor(J / 2), le = -ee, me = -te, ke, ge, Ve, Oe, Ue, we, Ce, it, ut, bt;
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(pt, Ke, dt) {
                  Oe = 0, Ve = 0, ge = 0;
                  for (var ct = le; ct <= ee; ct++)
                    for (var wt = me; wt <= te; wt++)
                      it = pt + wt, ut = Ke + ct, ke = S[ct + ee][wt + te], bt = this.getPixelIndex(it, ut, U), bt === -1 ? (Ce = 0, we = 0, Ue = 0) : (Ue = this.bitmap.data[bt + 0], we = this.bitmap.data[bt + 1], Ce = this.bitmap.data[bt + 2]), ge += ke * Ue, Ve += ke * we, Oe += ke * Ce;
                  ge < 0 && (ge = 0), Ve < 0 && (Ve = 0), Oe < 0 && (Oe = 0), ge > 255 && (ge = 255), Ve > 255 && (Ve = 255), Oe > 255 && (Oe = 255), T[dt + 0] = ge, T[dt + 1] = Ve, T[dt + 2] = Oe;
                }), this.bitmap.data = T, (0, R.isNodePattern)(j) && j.call(this, null, this), this;
              },
              /**
               * Set the alpha channel on every pixel to fully opaque
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              opaque: function(S) {
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(U, j, T) {
                  this.bitmap.data[T + 3] = 255;
                }), (0, R.isNodePattern)(S) && S.call(this, null, this), this;
              },
              /**
               * Pixelates the image or a region
               * @param {number} size the size of the pixels
               * @param {number} x (optional) the x position of the region to pixelate
               * @param {number} y (optional) the y position of the region to pixelate
               * @param {number} w (optional) the width of the region to pixelate
               * @param {number} h (optional) the height of the region to pixelate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              pixelate: function(S, U, j, T, W, J) {
                if (typeof U == "function")
                  J = U, W = null, T = null, j = null, U = null;
                else {
                  if (typeof S != "number")
                    return R.throwError.call(this, "size must be a number", J);
                  if (M(U) && typeof U != "number")
                    return R.throwError.call(this, "x must be a number", J);
                  if (M(j) && typeof j != "number")
                    return R.throwError.call(this, "y must be a number", J);
                  if (M(T) && typeof T != "number")
                    return R.throwError.call(this, "w must be a number", J);
                  if (M(W) && typeof W != "number")
                    return R.throwError.call(this, "h must be a number", J);
                }
                var ee = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];
                U = U || 0, j = j || 0, T = M(T) ? T : this.bitmap.width - U, W = M(W) ? W : this.bitmap.height - j;
                var te = this.cloneQuiet();
                return this.scanQuiet(U, j, T, W, function(le, me, ke) {
                  le = S * Math.floor(le / S), me = S * Math.floor(me / S);
                  var ge = A(te, ee, le, me);
                  this.bitmap.data[ke] = ge[0], this.bitmap.data[ke + 1] = ge[1], this.bitmap.data[ke + 2] = ge[2];
                }), (0, R.isNodePattern)(J) && J.call(this, null, this), this;
              },
              /**
               * Applies a convolution kernel to the image or a region
               * @param {array} kernel the convolution kernel
               * @param {number} x (optional) the x position of the region to apply convolution to
               * @param {number} y (optional) the y position of the region to apply convolution to
               * @param {number} w (optional) the width of the region to apply convolution to
               * @param {number} h (optional) the height of the region to apply convolution to
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              convolute: function(S, U, j, T, W, J) {
                if (!Array.isArray(S)) return R.throwError.call(this, "the kernel must be an array", J);
                if (typeof U == "function")
                  J = U, U = null, j = null, T = null, W = null;
                else {
                  if (M(U) && typeof U != "number")
                    return R.throwError.call(this, "x must be a number", J);
                  if (M(j) && typeof j != "number")
                    return R.throwError.call(this, "y must be a number", J);
                  if (M(T) && typeof T != "number")
                    return R.throwError.call(this, "w must be a number", J);
                  if (M(W) && typeof W != "number")
                    return R.throwError.call(this, "h must be a number", J);
                }
                var ee = (S.length - 1) / 2;
                U = M(U) ? U : ee, j = M(j) ? j : ee, T = M(T) ? T : this.bitmap.width - U, W = M(W) ? W : this.bitmap.height - j;
                var te = this.cloneQuiet();
                return this.scanQuiet(U, j, T, W, function(le, me, ke) {
                  var ge = A(te, S, le, me);
                  this.bitmap.data[ke] = this.constructor.limit255(ge[0]), this.bitmap.data[ke + 1] = this.constructor.limit255(ge[1]), this.bitmap.data[ke + 2] = this.constructor.limit255(ge[2]);
                }), (0, R.isNodePattern)(J) && J.call(this, null, this), this;
              },
              /**
               * Apply multiple color modification rules
               * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              color: w,
              colour: w
            };
          };
          q.default = k, de.exports = q.default;
        }).call(this, Q("buffer").Buffer);
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/utils": 235, buffer: 48, tinycolor2: 178 }], 206: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils"), i = function() {
          return {
            contain: function(R, A, M, x, m) {
              if (typeof R != "number" || typeof A != "number")
                return ie.throwError.call(this, "w and h must be numbers", m);
              typeof M == "string" && (typeof x == "function" && typeof m > "u" && (m = x), x = M, M = null), typeof M == "function" && (typeof m > "u" && (m = M), x = null, M = null), typeof x == "function" && typeof m > "u" && (m = x, x = null), M = M || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
              var w = M & 7, k = M >> 3;
              if (!(w !== 0 && !(w & w - 1) || k !== 0 && !(k & k - 1)))
                return ie.throwError.call(this, "only use one flag per alignment direction", m);
              var E = w >> 1, P = k >> 1, S = R / A > this.bitmap.width / this.bitmap.height ? A / this.bitmap.height : R / this.bitmap.width, U = this.cloneQuiet().scale(S, x);
              return this.resize(R, A, x), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(j, T, W) {
                this.bitmap.data.writeUInt32BE(this._background, W);
              }), this.blit(U, (this.bitmap.width - U.bitmap.width) / 2 * E, (this.bitmap.height - U.bitmap.height) / 2 * P), (0, ie.isNodePattern)(m) && m.call(this, null, this), this;
            }
          };
        };
        q.default = i, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 207: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils"), i = function() {
          return {
            cover: function(R, A, M, x, m) {
              if (typeof R != "number" || typeof A != "number")
                return ie.throwError.call(this, "w and h must be numbers", m);
              M && typeof M == "function" && typeof m > "u" ? (m = M, M = null, x = null) : typeof x == "function" && typeof m > "u" && (m = x, x = null), M = M || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
              var w = M & 7, k = M >> 3;
              if (!(w !== 0 && !(w & w - 1) || k !== 0 && !(k & k - 1))) return ie.throwError.call(this, "only use one flag per alignment direction", m);
              var E = w >> 1, P = k >> 1, S = R / A > this.bitmap.width / this.bitmap.height ? R / this.bitmap.width : A / this.bitmap.height;
              return this.scale(S, x), this.crop((this.bitmap.width - R) / 2 * E, (this.bitmap.height - A) / 2 * P, R, A), (0, ie.isNodePattern)(m) && m.call(this, null, this), this;
            }
          };
        };
        q.default = i, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 208: [function(Q, de, q) {
        (function(ie) {
          var i = Q("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(q, "__esModule", {
            value: !0
          }), q.default = R;
          var N = i(Q("@babel/runtime/helpers/typeof")), Z = Q("@jimp/utils");
          function R(A) {
            return A("crop", function(M, x, m, w, k) {
              if (typeof M != "number" || typeof x != "number") return Z.throwError.call(this, "x and y must be numbers", k);
              if (typeof m != "number" || typeof w != "number") return Z.throwError.call(this, "w and h must be numbers", k);
              if (M = Math.round(M), x = Math.round(x), m = Math.round(m), w = Math.round(w), M === 0 && m === this.bitmap.width) {
                var E = m * x + M << 2, P = E + w * m << 2;
                this.bitmap.data = this.bitmap.data.slice(E, P);
              } else {
                var S = ie.allocUnsafe(m * w * 4), U = 0;
                this.scanQuiet(M, x, m, w, function(j, T, W) {
                  var J = this.bitmap.data.readUInt32BE(W, !0);
                  S.writeUInt32BE(J, U, !0), U += 4;
                }), this.bitmap.data = S;
              }
              return this.bitmap.width = m, this.bitmap.height = w, (0, Z.isNodePattern)(k) && k.call(this, null, this), this;
            }), {
              class: {
                /**
                 * Autocrop same color borders from this image
                 * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)
                 * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)
                 * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)
                 * @returns {Jimp} this for chaining of methods
                 */
                autocrop: function() {
                  for (var x = this.bitmap.width, m = this.bitmap.height, w = 1, k, E = 0, P = 2e-4, S = !0, U = !1, j = arguments.length, T = new Array(j), W = 0; W < j; W++)
                    T[W] = arguments[W];
                  for (var J = 0, ee = T.length; J < ee; J++)
                    if (typeof T[J] == "number" && (P = T[J]), typeof T[J] == "boolean" && (S = T[J]), typeof T[J] == "function" && (k = T[J]), (0, N.default)(T[J]) === "object") {
                      var te = T[J];
                      typeof te.tolerance < "u" && (P = te.tolerance), typeof te.cropOnlyFrames < "u" && (S = te.cropOnlyFrames), typeof te.cropSymmetric < "u" && (U = te.cropSymmetric), typeof te.leaveBorder < "u" && (E = te.leaveBorder);
                    }
                  var le = this.getPixelColor(0, 0), me = this.constructor.intToRGBA(le), ke = 0, ge = 0, Ve = 0, Oe = 0;
                  le = this.getPixelColor(0, 0);
                  e: for (var Ue = 0; Ue < m - w; Ue++) {
                    for (var we = 0; we < x; we++) {
                      var Ce = this.getPixelColor(we, Ue), it = this.constructor.intToRGBA(Ce);
                      if (this.constructor.colorDiff(me, it) > P)
                        break e;
                    }
                    ke++;
                  }
                  le = this.getPixelColor(x, 0);
                  e: for (var ut = 0; ut < x - w; ut++) {
                    for (var bt = 0 + ke; bt < m; bt++) {
                      var pt = this.getPixelColor(ut, bt), Ke = this.constructor.intToRGBA(pt);
                      if (this.constructor.colorDiff(me, Ke) > P)
                        break e;
                    }
                    ge++;
                  }
                  le = this.getPixelColor(0, m);
                  e: for (var dt = m - 1; dt >= ke + w; dt--) {
                    for (var ct = x - ge - 1; ct >= 0; ct--) {
                      var wt = this.getPixelColor(ct, dt), Ht = this.constructor.intToRGBA(wt);
                      if (this.constructor.colorDiff(me, Ht) > P)
                        break e;
                    }
                    Ve++;
                  }
                  le = this.getPixelColor(x, m);
                  e: for (var $t = x - 1; $t >= 0 + ge + w; $t--) {
                    for (var rt = m - 1; rt >= 0 + ke; rt--) {
                      var ri = this.getPixelColor($t, rt), wi = this.constructor.intToRGBA(ri);
                      if (this.constructor.colorDiff(me, wi) > P)
                        break e;
                    }
                    Oe++;
                  }
                  var Qt = !1;
                  if (Oe -= E, ge -= E, ke -= E, Ve -= E, U) {
                    var At = Math.min(ge, Oe), St = Math.min(ke, Ve);
                    Oe = At, ge = At, ke = St, Ve = St;
                  }
                  Oe = Oe >= 0 ? Oe : 0, ge = ge >= 0 ? ge : 0, ke = ke >= 0 ? ke : 0, Ve = Ve >= 0 ? Ve : 0;
                  var Lt = x - (Oe + ge), kt = m - (Ve + ke);
                  return S ? Qt = ge !== 0 && ke !== 0 && Oe !== 0 && Ve !== 0 : Qt = ge !== 0 || ke !== 0 || Oe !== 0 || Ve !== 0, Qt && this.crop(ge, ke, Lt, kt), (0, Z.isNodePattern)(k) && k.call(this, null, this), this;
                }
              }
            };
          }
          de.exports = q.default;
        }).call(this, Q("buffer").Buffer);
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, buffer: 48 }], 209: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var i = ie(Q("@babel/runtime/helpers/typeof")), N = Q("@jimp/utils"), Z = function() {
          return {
            displace: function(M, x, m) {
              if ((0, i.default)(M) !== "object" || M.constructor !== this.constructor)
                return N.throwError.call(this, "The source must be a Jimp image", m);
              if (typeof x != "number")
                return N.throwError.call(this, "factor must be a number", m);
              var w = this.cloneQuiet();
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(k, E, P) {
                var S = M.bitmap.data[P] / 256 * x;
                S = Math.round(S);
                var U = this.getPixelIndex(k + S, E);
                this.bitmap.data[U] = w.bitmap.data[P], this.bitmap.data[U + 1] = w.bitmap.data[P + 1], this.bitmap.data[U + 2] = w.bitmap.data[P + 2];
              }), (0, N.isNodePattern)(m) && m.call(this, null, this), this;
            }
          };
        };
        q.default = Z, de.exports = q.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235 }], 210: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils");
        function i(Z) {
          var R = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
          return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(A, M, x) {
            var m = ((M & 3) << 2) + A % 4, w = R[m];
            this.bitmap.data[x] = Math.min(this.bitmap.data[x] + w, 255), this.bitmap.data[x + 1] = Math.min(this.bitmap.data[x + 1] + w, 255), this.bitmap.data[x + 2] = Math.min(this.bitmap.data[x + 2] + w, 255);
          }), (0, ie.isNodePattern)(Z) && Z.call(this, null, this), this;
        }
        var N = function() {
          return {
            dither565: i,
            dither16: i
          };
        };
        q.default = N, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 211: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils"), i = function() {
          return {
            fisheye: function() {
              var R = this, A = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
                r: 2.5
              }, M = arguments.length > 1 ? arguments[1] : void 0;
              typeof A == "function" && (M = A, A = {
                r: 2.5
              });
              var x = this.cloneQuiet(), m = x.bitmap, w = m.width, k = m.height;
              return x.scanQuiet(0, 0, w, k, function(E, P) {
                var S = E / w, U = P / k, j = Math.sqrt(Math.pow(S - 0.5, 2) + Math.pow(U - 0.5, 2)), T = 2 * Math.pow(j, A.r), W = (S - 0.5) / j, J = (U - 0.5) / j, ee = Math.round((T * W + 0.5) * w), te = Math.round((T * J + 0.5) * k), le = x.getPixelColor(ee, te);
                R.setPixelColor(le, E, P);
              }), this.setPixelColor(x.getPixelColor(w / 2, k / 2), w / 2, k / 2), (0, ie.isNodePattern)(M) && M.call(this, null, this), this;
            }
          };
        };
        q.default = i, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 212: [function(Q, de, q) {
        (function(ie) {
          Object.defineProperty(q, "__esModule", {
            value: !0
          }), q.default = void 0;
          var i = Q("@jimp/utils");
          function N(R, A, M) {
            if (typeof R != "boolean" || typeof A != "boolean") return i.throwError.call(this, "horizontal and vertical must be Booleans", M);
            var x = ie.alloc(this.bitmap.data.length);
            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(m, w, k) {
              var E = R ? this.bitmap.width - 1 - m : m, P = A ? this.bitmap.height - 1 - w : w, S = this.bitmap.width * P + E << 2, U = this.bitmap.data.readUInt32BE(k);
              x.writeUInt32BE(U, S);
            }), this.bitmap.data = ie.from(x), (0, i.isNodePattern)(M) && M.call(this, null, this), this;
          }
          var Z = function() {
            return {
              flip: N,
              mirror: N
            };
          };
          q.default = Z, de.exports = q.default;
        }).call(this, Q("buffer").Buffer);
      }, { "@jimp/utils": 235, buffer: 48 }], 213: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils"), i = function() {
          return {
            gaussian: function(R, A) {
              if (typeof R != "number")
                return ie.throwError.call(this, "r must be a number", A);
              if (R < 1)
                return ie.throwError.call(this, "r must be greater than 0", A);
              for (var M = Math.ceil(R * 2.57), x = M * 2 + 1, m = R * R * 2, w = m * Math.PI, k = [], E = 0; E < x; E++) {
                k[E] = [];
                for (var P = 0; P < x; P++) {
                  var S = Math.pow(P - M, 2) + Math.pow(E - M, 2);
                  k[E][P] = Math.exp(-S / m) / w;
                }
              }
              for (var U = 0; U < this.bitmap.height; U++)
                for (var j = 0; j < this.bitmap.width; j++)
                  for (var T = 0, W = 0, J = 0, ee = 0, te = 0, le = 0; le < x; le++) {
                    for (var me = 0; me < x; me++) {
                      var ke = Math.min(this.bitmap.width - 1, Math.max(0, me + j - M)), ge = Math.min(this.bitmap.height - 1, Math.max(0, le + U - M)), Ve = k[le][me], Oe = ge * this.bitmap.width + ke << 2;
                      T += this.bitmap.data[Oe] * Ve, W += this.bitmap.data[Oe + 1] * Ve, J += this.bitmap.data[Oe + 2] * Ve, ee += this.bitmap.data[Oe + 3] * Ve, te += Ve;
                    }
                    var Ue = U * this.bitmap.width + j << 2;
                    this.bitmap.data[Ue] = Math.round(T / te), this.bitmap.data[Ue + 1] = Math.round(W / te), this.bitmap.data[Ue + 2] = Math.round(J / te), this.bitmap.data[Ue + 3] = Math.round(ee / te);
                  }
              return (0, ie.isNodePattern)(A) && A.call(this, null, this), this;
            }
          };
        };
        q.default = i, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 214: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils"), i = function() {
          return {
            invert: function(R) {
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(A, M, x) {
                this.bitmap.data[x] = 255 - this.bitmap.data[x], this.bitmap.data[x + 1] = 255 - this.bitmap.data[x + 1], this.bitmap.data[x + 2] = 255 - this.bitmap.data[x + 2];
              }), (0, ie.isNodePattern)(R) && R.call(this, null, this), this;
            }
          };
        };
        q.default = i, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 215: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils"), i = function() {
          return {
            mask: function(R) {
              var A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, M = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, x = arguments.length > 3 ? arguments[3] : void 0;
              if (!(R instanceof this.constructor))
                return ie.throwError.call(this, "The source must be a Jimp image", x);
              if (typeof A != "number" || typeof M != "number")
                return ie.throwError.call(this, "x and y must be numbers", x);
              A = Math.round(A), M = Math.round(M);
              var m = this.bitmap.width, w = this.bitmap.height, k = this;
              return R.scanQuiet(0, 0, R.bitmap.width, R.bitmap.height, function(E, P, S) {
                var U = A + E, j = M + P;
                if (U >= 0 && j >= 0 && U < m && j < w) {
                  var T = k.getPixelIndex(U, j), W = this.bitmap.data, J = (W[S + 0] + W[S + 1] + W[S + 2]) / 3;
                  k.bitmap.data[T + 3] *= J / 255;
                }
              }), (0, ie.isNodePattern)(x) && x.call(this, null, this), this;
            }
          };
        };
        q.default = i, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 216: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils");
        function i() {
          var A = {
            r: new Array(256).fill(0),
            g: new Array(256).fill(0),
            b: new Array(256).fill(0)
          };
          return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(M, x, m) {
            A.r[this.bitmap.data[m + 0]]++, A.g[this.bitmap.data[m + 1]]++, A.b[this.bitmap.data[m + 2]]++;
          }), A;
        }
        var N = function(M, x, m) {
          return (M - x) * 255 / (m - x);
        }, Z = function(M) {
          return [M.findIndex(function(x) {
            return x > 0;
          }), 255 - M.slice().reverse().findIndex(function(x) {
            return x > 0;
          })];
        }, R = function() {
          return {
            normalize: function(x) {
              var m = i.call(this), w = {
                r: Z(m.r),
                g: Z(m.g),
                b: Z(m.b)
              };
              return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(k, E, P) {
                var S = this.bitmap.data[P + 0], U = this.bitmap.data[P + 1], j = this.bitmap.data[P + 2];
                this.bitmap.data[P + 0] = N(S, w.r[0], w.r[1]), this.bitmap.data[P + 1] = N(U, w.g[0], w.g[1]), this.bitmap.data[P + 2] = N(j, w.b[0], w.b[1]);
              }), (0, ie.isNodePattern)(x) && x.call(this, null, this), this;
            }
          };
        };
        q.default = R, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 217: [function(Q, de, q) {
        (function(ie) {
          var i = Q("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(q, "__esModule", {
            value: !0
          }), q.default = void 0;
          var N = i(Q("@babel/runtime/helpers/typeof")), Z = i(Q("@babel/runtime/helpers/toConsumableArray")), R = i(Q("path")), A = i(Q("load-bmfont")), M = Q("@jimp/utils"), x = Q("./measure-text");
          function m(j, T, W, J, ee) {
            return ee === j.HORIZONTAL_ALIGN_LEFT ? 0 : ee === j.HORIZONTAL_ALIGN_CENTER ? (J - (0, x.measureText)(T, W)) / 2 : J - (0, x.measureText)(T, W);
          }
          function w(j, T, W, J, ee) {
            if (ee.width > 0 && ee.height > 0) {
              var te = T.pages[ee.page];
              j.blit(te, W + ee.xoffset, J + ee.yoffset, ee.x, ee.y, ee.width, ee.height);
            }
            return j;
          }
          function k(j, T, W, J, ee) {
            for (var te = 0; te < J.length; te++) {
              var le = void 0;
              j.chars[J[te]] ? le = J[te] : /\s/.test(J[te]) ? le = "" : le = "?";
              var me = j.chars[le] || {}, ke = j.kernings[le];
              w(this, j, T, W, me || {});
              var ge = ke && ke[J[te + 1]] ? ke[J[te + 1]] : 0;
              T += ge + (me.xadvance || ee);
            }
          }
          function E(j, T, W) {
            var J = T.split(" "), ee = [], te = [], le = 0;
            return J.forEach(function(me) {
              var ke = [].concat((0, Z.default)(te), [me]).join(" "), ge = (0, x.measureText)(j, ke);
              ge <= W ? (ge > le && (le = ge), te.push(me)) : (ee.push(te), te = [me]);
            }), ee.push(te), {
              lines: ee,
              longestLine: le
            };
          }
          function P(j, T, W) {
            var J = W.map(function(ee) {
              return j.read(T + "/" + ee);
            });
            return Promise.all(J);
          }
          var S = "browser/lib/", U = function() {
            return {
              constants: {
                measureText: x.measureText,
                measureTextHeight: x.measureTextHeight,
                FONT_SANS_8_BLACK: R.default.join(S, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"),
                FONT_SANS_10_BLACK: R.default.join(S, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"),
                FONT_SANS_12_BLACK: R.default.join(S, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"),
                FONT_SANS_14_BLACK: R.default.join(S, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"),
                FONT_SANS_16_BLACK: R.default.join(S, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"),
                FONT_SANS_32_BLACK: R.default.join(S, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"),
                FONT_SANS_64_BLACK: R.default.join(S, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"),
                FONT_SANS_128_BLACK: R.default.join(S, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"),
                FONT_SANS_8_WHITE: R.default.join(S, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"),
                FONT_SANS_16_WHITE: R.default.join(S, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"),
                FONT_SANS_32_WHITE: R.default.join(S, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"),
                FONT_SANS_64_WHITE: R.default.join(S, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"),
                FONT_SANS_128_WHITE: R.default.join(S, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"),
                /**
                 * Loads a bitmap font from a file
                 * @param {string} file the file path of a .fnt file
                 * @param {function(Error, Jimp)} cb (optional) a function to call when the font is loaded
                 * @returns {Promise} a promise
                 */
                loadFont: function(W, J) {
                  var ee = this;
                  return typeof W != "string" ? M.throwError.call(this, "file must be a string", J) : new Promise(function(te, le) {
                    J = J || function(me, ke) {
                      me ? le(me) : te(ke);
                    }, (0, A.default)(W, function(me, ke) {
                      var ge = {}, Ve = {};
                      if (me)
                        return M.throwError.call(ee, me, J);
                      for (var Oe = 0; Oe < ke.chars.length; Oe++)
                        ge[String.fromCharCode(ke.chars[Oe].id)] = ke.chars[Oe];
                      for (var Ue = 0; Ue < ke.kernings.length; Ue++) {
                        var we = String.fromCharCode(ke.kernings[Ue].first);
                        Ve[we] = Ve[we] || {}, Ve[we][String.fromCharCode(ke.kernings[Ue].second)] = ke.kernings[Ue].amount;
                      }
                      P(ee, R.default.dirname(W), ke.pages).then(function(Ce) {
                        J(null, {
                          chars: ge,
                          kernings: Ve,
                          pages: Ce,
                          common: ke.common,
                          info: ke.info
                        });
                      });
                    });
                  });
                }
              },
              class: {
                /**
                 * Draws a text on a image on a given boundary
                 * @param {Jimp} font a bitmap font loaded from `Jimp.loadFont` command
                 * @param {number} x the x position to start drawing the text
                 * @param {number} y the y position to start drawing the text
                 * @param {any} text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)
                 * @param {number} maxWidth (optional) the boundary width to draw in
                 * @param {number} maxHeight (optional) the boundary height to draw in
                 * @param {function(Error, Jimp)} cb (optional) a function to call when the text is written
                 * @returns {Jimp} this for chaining of methods
                 */
                print: function(W, J, ee, te, le, me, ke) {
                  var ge = this;
                  if (typeof le == "function" && typeof ke > "u" && (ke = le, le = 1 / 0), typeof le > "u" && (le = 1 / 0), typeof me == "function" && typeof ke > "u" && (ke = me, me = 1 / 0), typeof me > "u" && (me = 1 / 0), (0, N.default)(W) !== "object")
                    return M.throwError.call(this, "font must be a Jimp loadFont", ke);
                  if (typeof J != "number" || typeof ee != "number" || typeof le != "number")
                    return M.throwError.call(this, "x, y and maxWidth must be numbers", ke);
                  if (typeof le != "number")
                    return M.throwError.call(this, "maxWidth must be a number", ke);
                  if (typeof me != "number")
                    return M.throwError.call(this, "maxHeight must be a number", ke);
                  var Ve, Oe;
                  if ((0, N.default)(te) === "object" && te.text !== null && te.text !== void 0) {
                    Ve = te.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT, Oe = te.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;
                    var Ue = te;
                    te = Ue.text;
                  } else
                    Ve = this.constructor.HORIZONTAL_ALIGN_LEFT, Oe = this.constructor.VERTICAL_ALIGN_TOP, te = te.toString();
                  me !== 1 / 0 && Oe === this.constructor.VERTICAL_ALIGN_BOTTOM ? ee += me - (0, x.measureTextHeight)(W, te, le) : me !== 1 / 0 && Oe === this.constructor.VERTICAL_ALIGN_MIDDLE && (ee += me / 2 - (0, x.measureTextHeight)(W, te, le) / 2);
                  var we = Object.entries(W.chars)[0][1].xadvance, Ce = E(W, te, le), it = Ce.lines, ut = Ce.longestLine;
                  return it.forEach(function(bt) {
                    var pt = bt.join(" "), Ke = m(ge.constructor, W, pt, le, Ve);
                    k.call(ge, W, J + Ke, ee, pt, we), ee += W.common.lineHeight;
                  }), (0, M.isNodePattern)(ke) && ke.call(this, null, this, {
                    x: J + ut,
                    y: ee
                  }), this;
                }
              }
            };
          };
          q.default = U, de.exports = q.default;
        }).call(this, "/../../node_modules/@jimp/plugin-print/dist");
      }, { "./measure-text": 218, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, "load-bmfont": 219, path: 107 }], 218: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.measureText = ie, q.measureTextHeight = i;
        function ie(N, Z) {
          for (var R = 0, A = 0; A < Z.length; A++)
            if (N.chars[Z[A]]) {
              var M = N.kernings[Z[A]] && N.kernings[Z[A]][Z[A + 1]] ? N.kernings[Z[A]][Z[A + 1]] : 0;
              R += (N.chars[Z[A]].xadvance || 0) + M;
            }
          return R;
        }
        function i(N, Z, R) {
          for (var A = Z.split(" "), M = "", x = N.common.lineHeight, m = 0; m < A.length; m++) {
            var w = M + A[m] + " ", k = ie(N, w);
            k > R && m > 0 ? (x += N.common.lineHeight, M = A[m] + " ") : M = w;
          }
          return x;
        }
      }, {}], 219: [function(Q, de, q) {
        (function(ie) {
          var i = Q("xhr"), N = function() {
          }, Z = Q("parse-bmfont-ascii"), R = Q("parse-bmfont-xml"), A = Q("parse-bmfont-binary"), M = Q("./lib/is-binary"), x = Q("xtend"), m = function() {
            return self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
          }();
          de.exports = function(E, P) {
            P = typeof P == "function" ? P : N, typeof E == "string" ? E = { uri: E } : E || (E = {});
            var S = E.binary;
            S && (E = k(E)), i(E, function(U, j, T) {
              if (U)
                return P(U);
              if (!/^2/.test(j.statusCode))
                return P(new Error("http status code: " + j.statusCode));
              if (!T)
                return P(new Error("no body result"));
              var W = !1;
              if (w(T)) {
                var J = new Uint8Array(T);
                T = new ie(J, "binary");
              }
              M(T) && (W = !0, typeof T == "string" && (T = new ie(T, "binary"))), W || (ie.isBuffer(T) && (T = T.toString(E.encoding)), T = T.trim());
              var ee;
              try {
                var te = j.headers["content-type"];
                W ? ee = A(T) : /json/.test(te) || T.charAt(0) === "{" ? ee = JSON.parse(T) : /xml/.test(te) || T.charAt(0) === "<" ? ee = R(T) : ee = Z(T);
              } catch (le) {
                P(new Error("error parsing font " + le.message)), P = N;
              }
              P(null, ee);
            });
          };
          function w(E) {
            var P = Object.prototype.toString;
            return P.call(E) === "[object ArrayBuffer]";
          }
          function k(E) {
            if (m)
              return x(E, { responseType: "arraybuffer" });
            if (typeof self.XMLHttpRequest > "u")
              throw new Error("your browser does not support XHR loading");
            var P = new self.XMLHttpRequest();
            return P.overrideMimeType("text/plain; charset=x-user-defined"), x({
              xhr: P
            }, E);
          }
        }).call(this, Q("buffer").Buffer);
      }, { "./lib/is-binary": 220, buffer: 48, "parse-bmfont-ascii": 102, "parse-bmfont-binary": 103, "parse-bmfont-xml": 104, xhr: 187, xtend: 189 }], 220: [function(Q, de, q) {
        (function(ie) {
          var i = Q("buffer-equal"), N = new ie([66, 77, 70, 3]);
          de.exports = function(Z) {
            return typeof Z == "string" ? Z.substring(0, 3) === "BMF" : Z.length > 4 && i(Z.slice(0, 4), N);
          };
        }).call(this, Q("buffer").Buffer);
      }, { buffer: 48, "buffer-equal": 49 }], 221: [function(Q, de, q) {
        (function(ie) {
          var i = Q("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(q, "__esModule", {
            value: !0
          }), q.default = void 0;
          var N = Q("@jimp/utils"), Z = i(Q("./modules/resize")), R = i(Q("./modules/resize2")), A = function() {
            return {
              constants: {
                RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor",
                RESIZE_BILINEAR: "bilinearInterpolation",
                RESIZE_BICUBIC: "bicubicInterpolation",
                RESIZE_HERMITE: "hermiteInterpolation",
                RESIZE_BEZIER: "bezierInterpolation"
              },
              class: {
                /**
                 * Resizes the image to a set width and height using a 2-pass bilinear algorithm
                 * @param {number} w the width to resize the image to (or Jimp.AUTO)
                 * @param {number} h the height to resize the image to (or Jimp.AUTO)
                 * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
                 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
                 * @returns {Jimp} this for chaining of methods
                 */
                resize: function(m, w, k, E) {
                  if (typeof m != "number" || typeof w != "number")
                    return N.throwError.call(this, "w and h must be numbers", E);
                  if (typeof k == "function" && typeof E > "u" && (E = k, k = null), m === this.constructor.AUTO && w === this.constructor.AUTO)
                    return N.throwError.call(this, "w and h cannot both be set to auto", E);
                  if (m === this.constructor.AUTO && (m = this.bitmap.width * (w / this.bitmap.height)), w === this.constructor.AUTO && (w = this.bitmap.height * (m / this.bitmap.width)), m < 0 || w < 0)
                    return N.throwError.call(this, "w and h must be positive numbers", E);
                  if (m = Math.round(m), w = Math.round(w), typeof R.default[k] == "function") {
                    var P = {
                      data: ie.alloc(m * w * 4),
                      width: m,
                      height: w
                    };
                    R.default[k](this.bitmap, P), this.bitmap = P;
                  } else {
                    var S = this, U = new Z.default(this.bitmap.width, this.bitmap.height, m, w, !0, !0, function(j) {
                      S.bitmap.data = ie.from(j), S.bitmap.width = m, S.bitmap.height = w;
                    });
                    U.resize(this.bitmap.data);
                  }
                  return (0, N.isNodePattern)(E) && E.call(this, null, this), this;
                }
              }
            };
          };
          q.default = A, de.exports = q.default;
        }).call(this, Q("buffer").Buffer);
      }, { "./modules/resize": 222, "./modules/resize2": 223, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, buffer: 48 }], 222: [function(Q, de, q) {
        function ie(i, N, Z, R, A, M, x) {
          this.widthOriginal = Math.abs(Math.floor(i) || 0), this.heightOriginal = Math.abs(Math.floor(N) || 0), this.targetWidth = Math.abs(Math.floor(Z) || 0), this.targetHeight = Math.abs(Math.floor(R) || 0), this.colorChannels = A ? 4 : 3, this.interpolationPass = !!M, this.resizeCallback = typeof x == "function" ? x : function() {
          }, this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels, this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels, this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels, this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal, this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight, this.initialize();
        }
        ie.prototype.initialize = function() {
          if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0)
            this.configurePasses();
          else
            throw new Error("Invalid settings specified for the resizer.");
        }, ie.prototype.configurePasses = function() {
          this.widthOriginal === this.targetWidth ? this.resizeWidth = this.bypassResizer : (this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth, this.ratioWeightWidthPass < 1 && this.interpolationPass ? (this.initializeFirstPassBuffers(!0), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB) : (this.initializeFirstPassBuffers(!1), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB)), this.heightOriginal === this.targetHeight ? this.resizeHeight = this.bypassResizer : (this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight, this.ratioWeightHeightPass < 1 && this.interpolationPass ? (this.initializeSecondPassBuffers(!0), this.resizeHeight = this.resizeHeightInterpolated) : (this.initializeSecondPassBuffers(!1), this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB));
        }, ie.prototype._resizeWidthInterpolatedRGBChannels = function(i, N) {
          var Z = N ? 4 : 3, R = this.ratioWeightWidthPass, A = this.widthBuffer, M = 0, x = 0, m = 0, w = 0, k = 0, E;
          for (E = 0; M < 1 / 3; E += Z, M += R)
            for (x = E, m = 0; x < this.widthPassResultSize; m += this.originalWidthMultipliedByChannels, x += this.targetWidthMultipliedByChannels)
              A[x] = i[m], A[x + 1] = i[m + 1], A[x + 2] = i[m + 2], N && (A[x + 3] = i[m + 3]);
          M -= 1 / 3;
          var P;
          for (P = this.widthOriginal - 1; M < P; E += Z, M += R)
            for (k = M % 1, w = 1 - k, x = E, m = Math.floor(M) * Z; x < this.widthPassResultSize; m += this.originalWidthMultipliedByChannels, x += this.targetWidthMultipliedByChannels)
              A[x + 0] = i[m + 0] * w + i[m + Z + 0] * k, A[x + 1] = i[m + 1] * w + i[m + Z + 1] * k, A[x + 2] = i[m + 2] * w + i[m + Z + 2] * k, N && (A[x + 3] = i[m + 3] * w + i[m + Z + 3] * k);
          for (P = this.originalWidthMultipliedByChannels - Z; E < this.targetWidthMultipliedByChannels; E += Z)
            for (x = E, m = P; x < this.widthPassResultSize; m += this.originalWidthMultipliedByChannels, x += this.targetWidthMultipliedByChannels)
              A[x] = i[m], A[x + 1] = i[m + 1], A[x + 2] = i[m + 2], N && (A[x + 3] = i[m + 3]);
          return A;
        }, ie.prototype._resizeWidthRGBChannels = function(i, N) {
          var Z = N ? 4 : 3, R = this.ratioWeightWidthPass, A = 1 / R, M = this.originalWidthMultipliedByChannels - Z + 1, x = this.targetWidthMultipliedByChannels - Z + 1, m = this.outputWidthWorkBench, w = this.widthBuffer, k = this.outputWidthWorkBenchOpaquePixelsCount, E = 0, P = 0, S = 0, U = 0, j = 0, T = 0, W = 0, J = 1, ee = 0, te = 0, le = 0, me = 0;
          do {
            for (j = 0; j < this.originalHeightMultipliedByChannels; )
              m[j++] = 0, m[j++] = 0, m[j++] = 0, N && (m[j++] = 0, k[j / Z - 1] = 0);
            E = R;
            do {
              for (P = 1 + S - U, J = Math.min(E, P), j = 0, T = S; j < this.originalHeightMultipliedByChannels; T += M)
                ee = i[T], te = i[++T], le = i[++T], me = N ? i[++T] : 255, m[j++] += (me ? ee : 0) * J, m[j++] += (me ? te : 0) * J, m[j++] += (me ? le : 0) * J, N && (m[j++] += me * J, k[j / Z - 1] += me ? J : 0);
              if (E >= P)
                S += Z, U = S, E -= P;
              else {
                U += E;
                break;
              }
            } while (E > 0 && S < this.originalWidthMultipliedByChannels);
            for (j = 0, T = W; j < this.originalHeightMultipliedByChannels; T += x)
              E = N ? k[j / Z] : 1, J = N ? E ? 1 / E : 0 : A, w[T] = m[j++] * J, w[++T] = m[j++] * J, w[++T] = m[j++] * J, N && (w[++T] = m[j++] * A);
            W += Z;
          } while (W < this.targetWidthMultipliedByChannels);
          return w;
        }, ie.prototype._resizeHeightRGBChannels = function(i, N) {
          var Z = this.ratioWeightHeightPass, R = 1 / Z, A = this.outputHeightWorkBench, M = this.heightBuffer, x = this.outputHeightWorkBenchOpaquePixelsCount, m = 0, w = 0, k = 0, E = 0, P = 0, S = 0, U = 0, j = 1, T = 0, W = 0, J = 0, ee = 0;
          do {
            for (P = 0; P < this.targetWidthMultipliedByChannels; )
              A[P++] = 0, A[P++] = 0, A[P++] = 0, N && (A[P++] = 0, x[P / 4 - 1] = 0);
            m = Z;
            do {
              for (w = 1 + k - E, j = Math.min(m, w), U = k, P = 0; P < this.targetWidthMultipliedByChannels; )
                T = i[U++], W = i[U++], J = i[U++], ee = N ? i[U++] : 255, A[P++] += (ee ? T : 0) * j, A[P++] += (ee ? W : 0) * j, A[P++] += (ee ? J : 0) * j, N && (A[P++] += ee * j, x[P / 4 - 1] += ee ? j : 0);
              if (m >= w)
                k = U, E = k, m -= w;
              else {
                E += m;
                break;
              }
            } while (m > 0 && k < this.widthPassResultSize);
            for (P = 0; P < this.targetWidthMultipliedByChannels; )
              m = N ? x[P / 4] : 1, j = N ? m ? 1 / m : 0 : R, M[S++] = Math.round(A[P++] * j), M[S++] = Math.round(A[P++] * j), M[S++] = Math.round(A[P++] * j), N && (M[S++] = Math.round(A[P++] * R));
          } while (S < this.finalResultSize);
          return M;
        }, ie.prototype.resizeWidthInterpolatedRGB = function(i) {
          return this._resizeWidthInterpolatedRGBChannels(i, !1);
        }, ie.prototype.resizeWidthInterpolatedRGBA = function(i) {
          return this._resizeWidthInterpolatedRGBChannels(i, !0);
        }, ie.prototype.resizeWidthRGB = function(i) {
          return this._resizeWidthRGBChannels(i, !1);
        }, ie.prototype.resizeWidthRGBA = function(i) {
          return this._resizeWidthRGBChannels(i, !0);
        }, ie.prototype.resizeHeightInterpolated = function(i) {
          for (var N = this.ratioWeightHeightPass, Z = this.heightBuffer, R = 0, A = 0, M = 0, x = 0, m = 0, w = 0, k = 0, E; R < 1 / 3; R += N)
            for (M = 0; M < this.targetWidthMultipliedByChannels; )
              Z[A++] = Math.round(i[M++]);
          for (R -= 1 / 3, E = this.heightOriginal - 1; R < E; R += N)
            for (k = R % 1, w = 1 - k, x = Math.floor(R) * this.targetWidthMultipliedByChannels, m = x + this.targetWidthMultipliedByChannels, M = 0; M < this.targetWidthMultipliedByChannels; ++M)
              Z[A++] = Math.round(i[x++] * w + i[m++] * k);
          for (; A < this.finalResultSize; )
            for (M = 0, x = E * this.targetWidthMultipliedByChannels; M < this.targetWidthMultipliedByChannels; ++M)
              Z[A++] = Math.round(i[x++]);
          return Z;
        }, ie.prototype.resizeHeightRGB = function(i) {
          return this._resizeHeightRGBChannels(i, !1);
        }, ie.prototype.resizeHeightRGBA = function(i) {
          return this._resizeHeightRGBChannels(i, !0);
        }, ie.prototype.resize = function(i) {
          this.resizeCallback(this.resizeHeight(this.resizeWidth(i)));
        }, ie.prototype.bypassResizer = function(i) {
          return i;
        }, ie.prototype.initializeFirstPassBuffers = function(i) {
          this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize), i || (this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels), this.colorChannels > 3 && (this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal)));
        }, ie.prototype.initializeSecondPassBuffers = function(i) {
          this.heightBuffer = this.generateUint8Buffer(this.finalResultSize), i || (this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels), this.colorChannels > 3 && (this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth)));
        }, ie.prototype.generateFloatBuffer = function(i) {
          try {
            return new Float32Array(i);
          } catch {
            return [];
          }
        }, ie.prototype.generateFloat64Buffer = function(i) {
          try {
            return new Float64Array(i);
          } catch {
            return [];
          }
        }, ie.prototype.generateUint8Buffer = function(i) {
          try {
            return new Uint8Array(i);
          } catch {
            return [];
          }
        }, de.exports = ie;
      }, {}], 223: [function(Q, de, q) {
        (function(ie) {
          de.exports = {
            nearestNeighbor: function(N, Z) {
              for (var R = N.width, A = N.height, M = Z.width, x = Z.height, m = N.data, w = Z.data, k = 0; k < x; k++)
                for (var E = 0; E < M; E++) {
                  var P = (k * M + E) * 4, S = Math.floor(k * A / x), U = Math.floor(E * R / M), j = (S * R + U) * 4;
                  w[P++] = m[j++], w[P++] = m[j++], w[P++] = m[j++], w[P++] = m[j++];
                }
            },
            bilinearInterpolation: function(N, Z) {
              for (var R = N.width, A = N.height, M = Z.width, x = Z.height, m = N.data, w = Z.data, k = function(me, ke, ge, Ve, Oe) {
                return ke === Ve ? ge : Math.round((me - ke) * Oe + (Ve - me) * ge);
              }, E = function(me, ke, ge, Ve, Oe, Ue, we, Ce) {
                var it = (we * R + Ve) * 4 + ke, ut = (we * R + Oe) * 4 + ke, bt = k(ge, Ve, m[it], Oe, m[ut]);
                if (Ce === we)
                  w[me + ke] = bt;
                else {
                  it = (Ce * R + Ve) * 4 + ke, ut = (Ce * R + Oe) * 4 + ke;
                  var pt = k(ge, Ve, m[it], Oe, m[ut]);
                  w[me + ke] = k(Ue, we, bt, Ce, pt);
                }
              }, P = 0; P < x; P++)
                for (var S = 0; S < M; S++) {
                  var U = (P * M + S) * 4, j = S * R / M, T = Math.floor(j), W = Math.min(Math.ceil(j), R - 1), J = P * A / x, ee = Math.floor(J), te = Math.min(Math.ceil(J), A - 1);
                  E(U, 0, j, T, W, J, ee, te), E(U, 1, j, T, W, J, ee, te), E(U, 2, j, T, W, J, ee, te), E(U, 3, j, T, W, J, ee, te);
                }
            },
            _interpolate2D: function(N, Z, R, A) {
              for (var M = N.data, x = Z.data, m = N.width, w = N.height, k = Z.width, E = Z.height, P = Math.max(1, Math.floor(m / k)), S = k * P, U = Math.max(1, Math.floor(w / E)), j = E * U, T = ie.alloc(S * w * 4), W = 0; W < w; W++)
                for (var J = 0; J < S; J++)
                  for (var ee = J * (m - 1) / S, te = Math.floor(ee), le = ee - te, me = (W * m + te) * 4, ke = (W * S + J) * 4, ge = 0; ge < 4; ge++) {
                    var Ve = me + ge, Oe = te > 0 ? M[Ve - 4] : 2 * M[Ve] - M[Ve + 4], Ue = M[Ve], we = M[Ve + 4], Ce = te < m - 2 ? M[Ve + 8] : 2 * M[Ve + 4] - M[Ve];
                    T[ke + ge] = A(Oe, Ue, we, Ce, le);
                  }
              for (var it = ie.alloc(S * j * 4), ut = 0; ut < j; ut++)
                for (var bt = 0; bt < S; bt++)
                  for (var pt = ut * (w - 1) / j, Ke = Math.floor(pt), dt = pt - Ke, ct = (Ke * S + bt) * 4, wt = (ut * S + bt) * 4, Ht = 0; Ht < 4; Ht++) {
                    var $t = ct + Ht, rt = Ke > 0 ? T[$t - S * 4] : 2 * T[$t] - T[$t + S * 4], ri = T[$t], wi = T[$t + S * 4], Qt = Ke < w - 2 ? T[$t + S * 8] : 2 * T[$t + S * 4] - T[$t];
                    it[wt + Ht] = A(rt, ri, wi, Qt, dt);
                  }
              var At = P * U;
              if (At > 1)
                for (var St = 0; St < E; St++)
                  for (var Lt = 0; Lt < k; Lt++) {
                    for (var kt = 0, Ye = 0, De = 0, Re = 0, _t = 0, et = 0; et < U; et++)
                      for (var Ie = St * U + et, pe = 0; pe < P; pe++) {
                        var xt = Lt * P + pe, l = (Ie * S + xt) * 4, _ = it[l + 3];
                        _ && (kt += it[l], Ye += it[l + 1], De += it[l + 2], _t++), Re += _;
                      }
                    var I = (St * k + Lt) * 4;
                    x[I] = _t ? Math.round(kt / _t) : 0, x[I + 1] = _t ? Math.round(Ye / _t) : 0, x[I + 2] = _t ? Math.round(De / _t) : 0, x[I + 3] = Math.round(Re / At);
                  }
              else
                Z.data = it;
            },
            bicubicInterpolation: function(N, Z, R) {
              var A = function(x, m, w, k, E) {
                var P = k - w - x + m, S = x - m - P, U = w - x, j = m;
                return Math.max(0, Math.min(255, P * (E * E * E) + S * (E * E) + U * E + j));
              };
              return this._interpolate2D(N, Z, R, A);
            },
            hermiteInterpolation: function(N, Z, R) {
              var A = function(x, m, w, k, E) {
                var P = m, S = 0.5 * (w - x), U = x - 2.5 * m + 2 * w - 0.5 * k, j = 0.5 * (k - x) + 1.5 * (m - w);
                return Math.max(0, Math.min(255, Math.round(((j * E + U) * E + S) * E + P)));
              };
              return this._interpolate2D(N, Z, R, A);
            },
            bezierInterpolation: function(N, Z, R) {
              var A = function(x, m, w, k, E) {
                var P = m + (w - x) / 4, S = w - (k - m) / 4, U = 1 - E, j = m * U * U * U, T = 3 * P * U * U * E, W = 3 * S * U * E * E, J = w * E * E * E;
                return Math.max(0, Math.min(255, Math.round(j + T + W + J)));
              };
              return this._interpolate2D(N, Z, R, A);
            }
          };
        }).call(this, Q("buffer").Buffer);
      }, { buffer: 48 }], 224: [function(Q, de, q) {
        (function(ie) {
          Object.defineProperty(q, "__esModule", {
            value: !0
          }), q.default = void 0;
          var i = Q("@jimp/utils");
          function N(R, A) {
            R %= 360;
            var M = R * Math.PI / 180, x = Math.cos(M), m = Math.sin(M), w = this.bitmap.width, k = this.bitmap.height;
            if (A === !0 || typeof A == "string") {
              w = Math.ceil(Math.abs(this.bitmap.width * x) + Math.abs(this.bitmap.height * m)) + 1, k = Math.ceil(Math.abs(this.bitmap.width * m) + Math.abs(this.bitmap.height * x)) + 1, w % 2 !== 0 && w++, k % 2 !== 0 && k++;
              var E = this.cloneQuiet();
              this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(we, Ce, it) {
                this.bitmap.data.writeUInt32BE(this._background, it);
              });
              var P = Math.max(w, k, this.bitmap.width, this.bitmap.height);
              this.resize(P, P, A), this.blit(E, this.bitmap.width / 2 - E.bitmap.width / 2, this.bitmap.height / 2 - E.bitmap.height / 2);
            }
            var S = this.bitmap.width, U = this.bitmap.height, j = ie.alloc(this.bitmap.data.length);
            function T(we, Ce) {
              return function(it, ut) {
                return {
                  x: it + we,
                  y: ut + Ce
                };
              };
            }
            for (var W = T(-(S / 2), -(U / 2)), J = T(S / 2 + 0.5, U / 2 + 0.5), ee = 1; ee <= U; ee++)
              for (var te = 1; te <= S; te++) {
                var le = W(te, ee), me = J(x * le.x - m * le.y, x * le.y + m * le.x), ke = S * (ee - 1) + te - 1 << 2;
                if (me.x >= 0 && me.x < S && me.y >= 0 && me.y < U) {
                  var ge = (S * (me.y | 0) + me.x | 0) << 2, Ve = this.bitmap.data.readUInt32BE(ge);
                  j.writeUInt32BE(Ve, ke);
                } else
                  j.writeUInt32BE(this._background, ke);
              }
            if (this.bitmap.data = j, A === !0 || typeof A == "string") {
              var Oe = S / 2 - w / 2, Ue = U / 2 - k / 2;
              this.crop(Oe, Ue, w, k);
            }
          }
          var Z = function() {
            return {
              /**
               * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.
               * @param {number} deg the number of degrees to rotate the image by
               * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              rotate: function(M, x, m) {
                return (typeof x > "u" || x === null) && (x = !0), typeof x == "function" && typeof m > "u" && (m = x, x = !0), typeof M != "number" ? i.throwError.call(this, "deg must be a number", m) : typeof x != "boolean" && typeof x != "string" ? i.throwError.call(this, "mode must be a boolean or a string", m) : (N.call(this, M, x, m), (0, i.isNodePattern)(m) && m.call(this, null, this), this);
              }
            };
          };
          q.default = Z, de.exports = q.default;
        }).call(this, Q("buffer").Buffer);
      }, { "@jimp/utils": 235, buffer: 48 }], 225: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils"), i = function() {
          return {
            /**
             * Uniformly scales the image by a factor.
             * @param {number} f the factor to scale the image by
             * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            scale: function(R, A, M) {
              if (typeof R != "number")
                return ie.throwError.call(this, "f must be a number", M);
              if (R < 0)
                return ie.throwError.call(this, "f must be a positive number", M);
              typeof A == "function" && typeof M > "u" && (M = A, A = null);
              var x = this.bitmap.width * R, m = this.bitmap.height * R;
              return this.resize(x, m, A), (0, ie.isNodePattern)(M) && M.call(this, null, this), this;
            },
            /**
             * Scale the image to the largest size that fits inside the rectangle that has the given width and height.
             * @param {number} w the width to resize the image to
             * @param {number} h the height to resize the image to
             * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            scaleToFit: function(R, A, M, x) {
              if (typeof R != "number" || typeof A != "number")
                return ie.throwError.call(this, "w and h must be numbers", x);
              typeof M == "function" && typeof x > "u" && (x = M, M = null);
              var m = R / A > this.bitmap.width / this.bitmap.height ? A / this.bitmap.height : R / this.bitmap.width;
              return this.scale(m, M), (0, ie.isNodePattern)(x) && x.call(this, null, this), this;
            }
          };
        };
        q.default = i, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 226: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils"), i = function() {
          return {
            shadow: function() {
              var R = this, A = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, M = arguments.length > 1 ? arguments[1] : void 0;
              typeof A == "function" && (M = A, A = {});
              var x = A, m = x.opacity, w = m === void 0 ? 0.7 : m, k = x.size, E = k === void 0 ? 1.1 : k, P = x.x, S = P === void 0 ? -25 : P, U = x.y, j = U === void 0 ? 25 : U, T = x.blur, W = T === void 0 ? 5 : T, J = this.clone(), ee = this.clone();
              return ee.scan(0, 0, ee.bitmap.width, ee.bitmap.height, function(te, le, me) {
                ee.bitmap.data[me] = 0, ee.bitmap.data[me + 1] = 0, ee.bitmap.data[me + 2] = 0, ee.bitmap.data[me + 3] = ee.constructor.limit255(ee.bitmap.data[me + 3] * w), R.bitmap.data[me] = 0, R.bitmap.data[me + 1] = 0, R.bitmap.data[me + 2] = 0, R.bitmap.data[me + 3] = 0;
              }), ee.resize(ee.bitmap.width * E, ee.bitmap.height * E).blur(W), this.composite(ee, S, j), this.composite(J, 0, 0), (0, ie.isNodePattern)(M) && M.call(this, null, this), this;
            }
          };
        };
        q.default = i, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 227: [function(Q, de, q) {
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var ie = Q("@jimp/utils"), i = function() {
          return {
            threshold: function(R, A) {
              var M = this, x = R.max, m = R.replace, w = m === void 0 ? 255 : m, k = R.autoGreyscale, E = k === void 0 ? !0 : k;
              return typeof x != "number" ? ie.throwError.call(this, "max must be a number", A) : typeof w != "number" ? ie.throwError.call(this, "replace must be a number", A) : typeof E != "boolean" ? ie.throwError.call(this, "autoGreyscale must be a boolean", A) : (x = this.constructor.limit255(x), w = this.constructor.limit255(w), E && this.greyscale(), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(P, S, U) {
                var j = M.bitmap.data[U] < x ? M.bitmap.data[U] : w;
                M.bitmap.data[U] = j, M.bitmap.data[U + 1] = j, M.bitmap.data[U + 2] = j;
              }), (0, ie.isNodePattern)(A) && A.call(this, null, this), this);
            }
          };
        };
        q.default = i, de.exports = q.default;
      }, { "@jimp/utils": 235 }], 228: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var i = ie(Q("@babel/runtime/helpers/toConsumableArray")), N = Q("timm"), Z = ie(Q("@jimp/plugin-blit")), R = ie(Q("@jimp/plugin-blur")), A = ie(Q("@jimp/plugin-circle")), M = ie(Q("@jimp/plugin-color")), x = ie(Q("@jimp/plugin-contain")), m = ie(Q("@jimp/plugin-cover")), w = ie(Q("@jimp/plugin-crop")), k = ie(Q("@jimp/plugin-displace")), E = ie(Q("@jimp/plugin-dither")), P = ie(Q("@jimp/plugin-fisheye")), S = ie(Q("@jimp/plugin-flip")), U = ie(Q("@jimp/plugin-gaussian")), j = ie(Q("@jimp/plugin-invert")), T = ie(Q("@jimp/plugin-mask")), W = ie(Q("@jimp/plugin-normalize")), J = ie(Q("@jimp/plugin-print")), ee = ie(Q("@jimp/plugin-resize")), te = ie(Q("@jimp/plugin-rotate")), le = ie(Q("@jimp/plugin-scale")), me = ie(Q("@jimp/plugin-shadow")), ke = ie(Q("@jimp/plugin-threshold")), ge = [Z.default, R.default, A.default, M.default, x.default, m.default, w.default, k.default, E.default, P.default, S.default, U.default, j.default, T.default, W.default, J.default, ee.default, te.default, le.default, me.default, ke.default], Ve = function(Ue) {
          var we = ge.map(function(Ce) {
            var it = Ce(Ue) || {};
            return !it.class && !it.constants && (it = {
              class: it
            }), it;
          });
          return N.mergeDeep.apply(void 0, (0, i.default)(we));
        };
        q.default = Ve, de.exports = q.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/plugin-blit": 201, "@jimp/plugin-blur": 203, "@jimp/plugin-circle": 204, "@jimp/plugin-color": 205, "@jimp/plugin-contain": 206, "@jimp/plugin-cover": 207, "@jimp/plugin-crop": 208, "@jimp/plugin-displace": 209, "@jimp/plugin-dither": 210, "@jimp/plugin-fisheye": 211, "@jimp/plugin-flip": 212, "@jimp/plugin-gaussian": 213, "@jimp/plugin-invert": 214, "@jimp/plugin-mask": 215, "@jimp/plugin-normalize": 216, "@jimp/plugin-print": 217, "@jimp/plugin-resize": 221, "@jimp/plugin-rotate": 224, "@jimp/plugin-scale": 225, "@jimp/plugin-shadow": 226, "@jimp/plugin-threshold": 227, timm: 177 }], 229: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var i = ie(Q("@babel/runtime/helpers/defineProperty")), N = ie(Q("bmp-js")), Z = Q("@jimp/utils"), R = "image/bmp", A = "image/x-ms-bmp";
        function M(E) {
          return (0, Z.scan)(E, 0, 0, E.bitmap.width, E.bitmap.height, function(P, S, U) {
            var j = this.bitmap.data[U + 0], T = this.bitmap.data[U + 1], W = this.bitmap.data[U + 2], J = this.bitmap.data[U + 3];
            this.bitmap.data[U + 0] = J, this.bitmap.data[U + 1] = W, this.bitmap.data[U + 2] = T, this.bitmap.data[U + 3] = j;
          }).bitmap;
        }
        function x(E) {
          return (0, Z.scan)({
            bitmap: E
          }, 0, 0, E.width, E.height, function(P, S, U) {
            var j = this.bitmap.data[U + 0], T = this.bitmap.data[U + 1], W = this.bitmap.data[U + 2], J = this.bitmap.data[U + 3];
            this.bitmap.data[U + 0] = J, this.bitmap.data[U + 1] = W, this.bitmap.data[U + 2] = T, this.bitmap.data[U + 3] = E.is_with_alpha ? j : 255;
          }).bitmap;
        }
        var m = function(P) {
          return x(N.default.decode(P));
        }, w = function(P) {
          return N.default.encode(M(P)).data;
        }, k = function() {
          var P, S;
          return {
            mime: (0, i.default)({}, R, ["bmp"]),
            constants: {
              MIME_BMP: R,
              MIME_X_MS_BMP: A
            },
            decoders: (P = {}, (0, i.default)(P, R, m), (0, i.default)(P, A, m), P),
            encoders: (S = {}, (0, i.default)(S, R, w), (0, i.default)(S, A, w), S)
          };
        };
        q.default = k, de.exports = q.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, "bmp-js": 30 }], 230: [function(Q, de, q) {
        (function(ie) {
          var i = Q("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(q, "__esModule", {
            value: !0
          }), q.default = void 0;
          var N = i(Q("@babel/runtime/helpers/defineProperty")), Z = i(Q("omggif")), R = Q("gifwrap"), A = "image/gif", M = function() {
            return {
              mime: (0, N.default)({}, A, ["gif"]),
              constants: {
                MIME_GIF: A
              },
              decoders: (0, N.default)({}, A, function(m) {
                var w = new Z.default.GifReader(m), k = ie.alloc(w.width * w.height * 4);
                return w.decodeAndBlitFrameRGBA(0, k), {
                  data: k,
                  width: w.width,
                  height: w.height
                };
              }),
              encoders: (0, N.default)({}, A, function(m) {
                var w = new R.BitmapImage(m.bitmap);
                R.GifUtil.quantizeDekker(w, 256);
                var k = new R.GifFrame(w), E = new R.GifCodec();
                return E.encodeGif([k], {}).then(function(P) {
                  return P.buffer;
                });
              })
            };
          };
          q.default = M, de.exports = q.default;
        }).call(this, Q("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, buffer: 48, gifwrap: 70, omggif: 85 }], 231: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var i = ie(Q("@babel/runtime/helpers/defineProperty")), N = ie(Q("jpeg-js")), Z = Q("@jimp/utils"), R = "image/jpeg", A = function() {
          return {
            mime: (0, i.default)({}, R, ["jpeg", "jpg", "jpe"]),
            constants: {
              MIME_JPEG: R
            },
            decoders: (0, i.default)({}, R, N.default.decode),
            encoders: (0, i.default)({}, R, function(x) {
              return N.default.encode(x.bitmap, x._quality).data;
            }),
            class: {
              // The quality to be used when saving JPEG images
              _quality: 100,
              /**
               * Sets the quality of the image when saving as JPEG format (default is 100)
               * @param {number} n The quality to use 0-100
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              quality: function(m, w) {
                return typeof m != "number" ? Z.throwError.call(this, "n must be a number", w) : m < 0 || m > 100 ? Z.throwError.call(this, "n must be a number 0 - 100", w) : (this._quality = Math.round(m), (0, Z.isNodePattern)(w) && w.call(this, null, this), this);
              }
            }
          };
        };
        q.default = A, de.exports = q.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, "jpeg-js": 80 }], 232: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var i = ie(Q("@babel/runtime/helpers/defineProperty")), N = Q("pngjs"), Z = Q("@jimp/utils"), R = "image/png", A = -1, M = 0, x = 1, m = 2, w = 3, k = 4, E = function() {
          return {
            mime: (0, i.default)({}, R, ["png"]),
            constants: {
              MIME_PNG: R,
              PNG_FILTER_AUTO: A,
              PNG_FILTER_NONE: M,
              PNG_FILTER_SUB: x,
              PNG_FILTER_UP: m,
              PNG_FILTER_AVERAGE: w,
              PNG_FILTER_PATH: k
            },
            hasAlpha: (0, i.default)({}, R, !0),
            decoders: (0, i.default)({}, R, N.PNG.sync.read),
            encoders: (0, i.default)({}, R, function(S) {
              var U = new N.PNG({
                width: S.bitmap.width,
                height: S.bitmap.height
              });
              return U.data = S.bitmap.data, N.PNG.sync.write(U, {
                width: S.bitmap.width,
                height: S.bitmap.height,
                deflateLevel: S._deflateLevel,
                deflateStrategy: S._deflateStrategy,
                filterType: S._filterType,
                colorType: typeof S._colorType == "number" ? S._colorType : S._rgba ? 6 : 2,
                inputHasAlpha: S._rgba
              });
            }),
            class: {
              _deflateLevel: 9,
              _deflateStrategy: 3,
              _filterType: A,
              _colorType: null,
              /**
               * Sets the deflate level used when saving as PNG format (default is 9)
               * @param {number} l Deflate level to use 0-9. 0 is no compression. 9 (default) is maximum compression.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              deflateLevel: function(U, j) {
                return typeof U != "number" ? Z.throwError.call(this, "l must be a number", j) : U < 0 || U > 9 ? Z.throwError.call(this, "l must be a number 0 - 9", j) : (this._deflateLevel = Math.round(U), (0, Z.isNodePattern)(j) && j.call(this, null, this), this);
              },
              /**
               * Sets the deflate strategy used when saving as PNG format (default is 3)
               * @param {number} s Deflate strategy to use 0-3.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              deflateStrategy: function(U, j) {
                return typeof U != "number" ? Z.throwError.call(this, "s must be a number", j) : U < 0 || U > 3 ? Z.throwError.call(this, "s must be a number 0 - 3", j) : (this._deflateStrategy = Math.round(U), (0, Z.isNodePattern)(j) && j.call(this, null, this), this);
              },
              /**
               * Sets the filter type used when saving as PNG format (default is automatic filters)
               * @param {number} f The quality to use -1-4.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              filterType: function(U, j) {
                return typeof U != "number" ? Z.throwError.call(this, "n must be a number", j) : U < -1 || U > 4 ? Z.throwError.call(this, "n must be -1 (auto) or a number 0 - 4", j) : (this._filterType = Math.round(U), (0, Z.isNodePattern)(j) && j.call(this, null, this), this);
              },
              /**
               * Sets the color type used when saving as PNG format
               * @param {number} s color type to use 0, 2, 4, 6.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              colorType: function(U, j) {
                return typeof U != "number" ? Z.throwError.call(this, "s must be a number", j) : U !== 0 && U !== 2 && U !== 4 && U !== 6 ? Z.throwError.call(this, "s must be a number 0, 2, 4, 6.", j) : (this._colorType = Math.round(U), (0, Z.isNodePattern)(j) && j.call(this, null, this), this);
              }
            }
          };
        };
        q.default = E, de.exports = q.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, pngjs: 129 }], 233: [function(Q, de, q) {
        (function(ie) {
          var i = Q("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(q, "__esModule", {
            value: !0
          }), q.default = void 0;
          var N = i(Q("@babel/runtime/helpers/defineProperty")), Z = i(Q("utif")), R = "image/tiff", A = function() {
            return {
              mime: (0, N.default)({}, R, ["tiff", "tif"]),
              constants: {
                MIME_TIFF: R
              },
              decoders: (0, N.default)({}, R, function(x) {
                var m = Z.default.decode(x), w = m[0];
                Z.default.decodeImages(x, m);
                var k = Z.default.toRGBA8(w);
                return {
                  data: ie.from(k),
                  width: w.t256[0],
                  height: w.t257[0]
                };
              }),
              encoders: (0, N.default)({}, R, function(x) {
                var m = Z.default.encodeImage(x.bitmap.data, x.bitmap.width, x.bitmap.height);
                return ie.from(m);
              })
            };
          };
          q.default = A, de.exports = q.default;
        }).call(this, Q("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, buffer: 48, utif: 182 }], 234: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.default = void 0;
        var i = Q("timm"), N = ie(Q("@jimp/jpeg")), Z = ie(Q("@jimp/png")), R = ie(Q("@jimp/bmp")), A = ie(Q("@jimp/tiff")), M = ie(Q("@jimp/gif")), x = function() {
          return (0, i.mergeDeep)((0, N.default)(), (0, Z.default)(), (0, R.default)(), (0, A.default)(), (0, M.default)());
        };
        q.default = x, de.exports = q.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/bmp": 229, "@jimp/gif": 230, "@jimp/jpeg": 231, "@jimp/png": 232, "@jimp/tiff": 233, timm: 177 }], 235: [function(Q, de, q) {
        var ie = Q("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(q, "__esModule", {
          value: !0
        }), q.isNodePattern = Z, q.throwError = R, q.scan = A, q.scanIterator = M;
        var i = ie(Q("@babel/runtime/regenerator")), N = /* @__PURE__ */ i.default.mark(M);
        function Z(x) {
          if (typeof x > "u")
            return !1;
          if (typeof x != "function")
            throw new TypeError("Callback must be a function");
          return !0;
        }
        function R(x, m) {
          if (typeof x == "string" && (x = new Error(x)), typeof m == "function")
            return m.call(this, x);
          throw x;
        }
        function A(x, m, w, k, E, P) {
          m = Math.round(m), w = Math.round(w), k = Math.round(k), E = Math.round(E);
          for (var S = w; S < w + E; S++)
            for (var U = m; U < m + k; U++) {
              var j = x.bitmap.width * S + U << 2;
              P.call(x, U, S, j);
            }
          return x;
        }
        function M(x, m, w, k, E) {
          var P, S, U;
          return i.default.wrap(function(T) {
            for (; ; )
              switch (T.prev = T.next) {
                case 0:
                  m = Math.round(m), w = Math.round(w), k = Math.round(k), E = Math.round(E), P = w;
                case 5:
                  if (!(P < w + E)) {
                    T.next = 17;
                    break;
                  }
                  S = m;
                case 7:
                  if (!(S < m + k)) {
                    T.next = 14;
                    break;
                  }
                  return U = x.bitmap.width * P + S << 2, T.next = 11, {
                    x: S,
                    y: P,
                    idx: U,
                    image: x
                  };
                case 11:
                  S++, T.next = 7;
                  break;
                case 14:
                  P++, T.next = 5;
                  break;
                case 17:
                case "end":
                  return T.stop();
              }
          }, N);
        }
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/regenerator": 22 }] }, {}, [200])(200);
    });
  }(E_)), E_.exports;
}
var T_, G1;
function im() {
  if (G1) return T_;
  G1 = 1;
  function mt(Tt, qe) {
    this.x = Tt || 0, this.y = qe || 0;
  }
  return mt.prototype = {
    copy: function() {
      return new mt(this.x, this.y);
    }
  }, T_ = mt, T_;
}
var C_, H1;
function rm() {
  if (H1) return C_;
  H1 = 1;
  var mt = im(), Tt = {};
  function qe(P) {
    return Tt[P] || (Tt[P] = new RegExp(" " + P + '="((?:\\\\(?=")"|[^"])+)"', "i")), Tt[P];
  }
  function Q(P, S, U) {
    var j = " " + S + '="' + U + '"';
    return P.indexOf(" " + S + '="') === -1 ? P = P.replace(/<[a-z]+/i, function(T) {
      return T + j;
    }) : P = P.replace(qe(S), j), P;
  }
  function de(P) {
    return P.toFixed(3).replace(".000", "");
  }
  function q(P, S) {
    return P >= S ? P % S : P >= 0 ? P : S - 1 - (-1 - P) % S;
  }
  function ie(P, S) {
    return P.x * S.y - P.y * S.x;
  }
  function i(P, S, U) {
    return P <= U ? P <= S && S < U : P <= S || S < U;
  }
  function N(P) {
    return P > 0 ? 1 : P < 0 ? -1 : 0;
  }
  function Z(P, S) {
    var U = new Array(3), j, T, W;
    for (U[0] = S.x, U[1] = S.y, U[2] = 1, W = 0, j = 0; j < 3; j++)
      for (T = 0; T < 3; T++)
        W += U[j] * P.at(j, T) * U[T];
    return W;
  }
  function R(P, S, U) {
    var j = new mt();
    return j.x = S.x + P * (U.x - S.x), j.y = S.y + P * (U.y - S.y), j;
  }
  function A(P, S) {
    var U = new mt();
    return U.y = N(S.x - P.x), U.x = -N(S.y - P.y), U;
  }
  function M(P, S) {
    var U = A(P, S);
    return U.y * (S.x - P.x) - U.x * (S.y - P.y);
  }
  function x(P, S, U) {
    var j, T, W, J;
    return j = S.x - P.x, T = S.y - P.y, W = U.x - P.x, J = U.y - P.y, j * J - W * T;
  }
  function m(P, S, U, j) {
    var T, W, J, ee;
    return T = S.x - P.x, W = S.y - P.y, J = j.x - U.x, ee = j.y - U.y, T * ee - J * W;
  }
  function w(P, S, U) {
    var j, T, W, J;
    return j = S.x - P.x, T = S.y - P.y, W = U.x - P.x, J = U.y - P.y, j * W + T * J;
  }
  function k(P, S, U, j) {
    var T, W, J, ee;
    return T = S.x - P.x, W = S.y - P.y, J = j.x - U.x, ee = j.y - U.y, T * J + W * ee;
  }
  function E(P, S) {
    return Math.sqrt((P.x - S.x) * (P.x - S.x) + (P.y - S.y) * (P.y - S.y));
  }
  return C_ = {
    luminance: function(P, S, U) {
      return Math.round(0.2126 * P + 0.7153 * S + 0.0721 * U);
    },
    between: function(P, S, U) {
      return P >= S && P <= U;
    },
    clamp: function(P, S, U) {
      return Math.min(U, Math.max(S, P));
    },
    isNumber: function(P) {
      return typeof P == "number";
    },
    setHtmlAttr: Q,
    /**
     * Generates path instructions for given curve
     *
     * @param {Curve} curve
     * @param {Number} [scale]
     * @returns {string}
     */
    renderCurve: function(P, S) {
      S = S || { x: 1, y: 1 };
      var U = P.c[(P.n - 1) * 3 + 2], j = [
        "M " + de(U.x * S.x) + " " + de(U.y * S.y)
      ];
      return P.tag.forEach(function(T, W) {
        var J = W * 3, ee = P.c[J], te = P.c[J + 1], le = P.c[J + 2];
        T === "CURVE" ? j.push(
          "C " + de(ee.x * S.x) + " " + de(ee.y * S.y) + ", " + de(te.x * S.x) + " " + de(te.y * S.y) + ", " + de(le.x * S.x) + " " + de(le.y * S.y)
        ) : T === "CORNER" && j.push(
          "L " + de(te.x * S.x) + " " + de(te.y * S.y) + " " + de(le.x * S.x) + " " + de(le.y * S.y)
        );
      }), j.join(" ");
    },
    bezier: function(S, U, j, T, W) {
      var J = 1 - S, ee = new mt();
      return ee.x = J * J * J * U.x + 3 * (J * J * S) * j.x + 3 * (S * S * J) * T.x + S * S * S * W.x, ee.y = J * J * J * U.y + 3 * (J * J * S) * j.y + 3 * (S * S * J) * T.y + S * S * S * W.y, ee;
    },
    tangent: function(S, U, j, T, W, J) {
      var ee, te, le, me, ke, ge, Ve, Oe, Ue, we;
      return ee = m(S, U, W, J), te = m(U, j, W, J), le = m(j, T, W, J), me = ee - 2 * te + le, ke = -2 * ee + 2 * te, ge = ee, Ve = ke * ke - 4 * me * ge, me === 0 || Ve < 0 ? -1 : (Oe = Math.sqrt(Ve), Ue = (-ke + Oe) / (2 * me), we = (-ke - Oe) / (2 * me), Ue >= 0 && Ue <= 1 ? Ue : we >= 0 && we <= 1 ? we : -1);
    },
    mod: q,
    xprod: ie,
    cyclic: i,
    sign: N,
    quadform: Z,
    interval: R,
    dorth_infty: A,
    ddenom: M,
    dpara: x,
    cprod: m,
    iprod: w,
    iprod1: k,
    ddist: E
  }, C_;
}
var A_, q1;
function W1() {
  if (q1) return A_;
  q1 = 1;
  var mt = rm(), Tt = null;
  try {
    Tt = Ky();
  } catch {
  }
  var qe = Jy(), Q = 256, de = Q - 1;
  function q(N, Z) {
    return Q * N + Z;
  }
  function ie(N, Z) {
    if (N = typeof N == "number" ? mt.clamp(Math.round(N), 0, de) : 0, Z = typeof Z == "number" ? mt.clamp(Math.round(Z), 0, de) : de, N > Z)
      throw new Error('Invalid range "' + N + "..." + Z + '"');
    return [N, Z];
  }
  function i(N, Z) {
    if (this.data = null, this.pixels = 0, this._sortedIndexes = null, this._cachedStats = {}, this._lookupTableH = null, typeof N == "number")
      this._createArray(N);
    else if (N instanceof qe)
      this._collectValuesBitmap(N);
    else if (Tt && N instanceof Tt)
      this._collectValuesJimp(N, Z);
    else
      throw new Error("Unsupported image source");
  }
  return i.MODE_LUMINANCE = "luminance", i.MODE_R = "r", i.MODE_G = "g", i.MODE_B = "b", i.prototype = {
    /**
     * Initializes data array for an image of given pixel size
     * @param imageSize
     * @returns {Uint8Array|Uint16Array|Uint32Array}
     * @private
     */
    _createArray: function(N) {
      var Z = N <= Math.pow(2, 8) ? Uint8Array : N <= Math.pow(2, 16) ? Uint16Array : Uint32Array;
      return this.pixels = N, this.data = new Z(Q);
    },
    /**
     * Aggregates color data from {@link Jimp} instance
     * @param {Jimp} source
     * @param mode
     * @private
     */
    _collectValuesJimp: function(N, Z) {
      var R = N.bitmap.data, A = this._createArray(N.bitmap.width * N.bitmap.height);
      N.scan(0, 0, N.bitmap.width, N.bitmap.height, function(M, x, m) {
        var w = Z === i.MODE_R ? R[m] : Z === i.MODE_G ? R[m + 1] : Z === i.MODE_B ? R[m + 2] : mt.luminance(R[m], R[m + 1], R[m + 2]);
        A[w]++;
      });
    },
    /**
     * Aggregates color data from {@link Bitmap} instance
     * @param {Bitmap} source
     * @private
     */
    _collectValuesBitmap: function(N) {
      for (var Z = this._createArray(N.size), R = N.data.length, A, M = 0; M < R; M++)
        A = N.data[M], Z[A]++;
    },
    /**
     * Returns array of color indexes in ascending order
     * @param refresh
     * @returns {*}
     * @private
     */
    _getSortedIndexes: function(N) {
      if (!N && this._sortedIndexes)
        return this._sortedIndexes;
      var Z = this.data, R = new Array(Q), A = 0;
      for (A; A < Q; A++)
        R[A] = A;
      return R.sort(function(M, x) {
        return Z[M] > Z[x] ? 1 : Z[M] < Z[x] ? -1 : 0;
      }), this._sortedIndexes = R, R;
    },
    /**
     * Builds lookup table H from lookup tables P and S.
     * see {@link http://www.iis.sinica.edu.tw/page/jise/2001/200109_01.pdf|this paper} for more details
     *
     * @returns {Float64Array}
     * @private
     */
    _thresholdingBuildLookupTable: function() {
      var N = new Float64Array(Q * Q), Z = new Float64Array(Q * Q), R = new Float64Array(Q * Q), A = this.pixels, M, x, m, w;
      for (M = 1; M < Q; ++M)
        m = q(M, M), w = this.data[M] / A, N[m] = w, Z[m] = M * w;
      for (M = 1; M < Q - 1; ++M)
        w = this.data[M + 1] / A, m = q(1, M), N[m + 1] = N[m] + w, Z[m + 1] = Z[m] + (M + 1) * w;
      for (M = 2; M < Q; M++)
        for (x = M + 1; x < Q; x++)
          N[q(M, x)] = N[q(1, x)] - N[q(1, M - 1)], Z[q(M, x)] = Z[q(1, x)] - Z[q(1, M - 1)];
      for (M = 1; M < Q; ++M)
        for (x = M + 1; x < Q; x++)
          m = q(M, x), R[m] = N[m] !== 0 ? Z[m] * Z[m] / N[m] : 0;
      return this._lookupTableH = R;
    },
    /**
     * Implements Algorithm For Multilevel Thresholding
     * Receives desired number of color stops, returns array of said size. Could be limited to a range levelMin..levelMax
     *
     * Regardless of levelMin and levelMax values it still relies on between class variances for the entire histogram
     *
     * @param amount - how many thresholds should be calculated
     * @param [levelMin=0] - histogram segment start
     * @param [levelMax=255] - histogram segment end
     * @returns {number[]}
    */
    multilevelThresholding: function(N, Z, R) {
      if (Z = ie(Z, R), R = Z[1], Z = Z[0], N = Math.min(R - Z - 2, ~~N), N < 1)
        return [];
      this._lookupTableH || this._thresholdingBuildLookupTable();
      var A = this._lookupTableH, M = null, x = 0;
      N > 4 && console.log("[Warning]: Threshold computation for more than 5 levels may take a long time");
      function m(w, k, E, P) {
        w = (w || 0) + 1, k = k || 0, E = E || new Array(N), P = P || 0;
        for (var S = P + 1, U, j = w; j < R - N + P; j++)
          U = k + A[q(w, j)], E[S - 1] = j, S + 1 < N + 1 ? m(j, U, E, S) : (U += A[q(j + 1, R)], x < U && (x = U, M = E.slice()));
      }
      return m(Z || 0), M || [];
    },
    /**
     * Automatically finds threshold value using Algorithm For Multilevel Thresholding
     *
     * @param {number} [levelMin]
     * @param {number} [levelMax]
     * @returns {null|number}
     */
    autoThreshold: function(N, Z) {
      var R = this.multilevelThresholding(1, N, Z);
      return R.length ? R[0] : null;
    },
    /**
     * Returns dominant color in given range. Returns -1 if not a single color from the range present on the image
     *
     * @param [levelMin=0]
     * @param [levelMax=255]
     * @param [tolerance=1]
     * @returns {number}
     */
    getDominantColor: function(N, Z, R) {
      N = ie(N, Z), Z = N[1], N = N[0], R = R || 1;
      var A = this.data, M = -1, x = -1, m, w, k;
      if (N === Z)
        return A[N] ? N : -1;
      for (m = N; m <= Z; m++) {
        for (k = 0, w = ~~(R / -2); w < R; w++)
          k += mt.between(m + w, 0, de) ? A[m + w] : 0;
        var E = k > x, P = x === k && (M < 0 || A[m] > A[M]);
        (E || P) && (M = m, x = k);
      }
      return x <= 0 ? -1 : M;
    },
    /**
     * Returns stats for histogram or its segment.
     *
     * Returned object contains median, mean and standard deviation for pixel values;
     * peak, mean and median number of pixels per level and few other values
     *
     * If no pixels colors from specified range present on the image - most values will be NaN
     *
     * @param {Number} [levelMin=0] - histogram segment start
     * @param {Number} [levelMax=255] - histogram segment end
     * @param {Boolean} [refresh=false] - if cached result can be returned
     * @returns {{levels: {mean: (number|*), median: *, stdDev: number, unique: number}, pixelsPerLevel: {mean: (number|*), median: (number|*), peak: number}, pixels: number}}
     */
    getStats: function(N, Z, R) {
      if (N = ie(N, Z), Z = N[1], N = N[0], !R && this._cachedStats[N + "-" + Z])
        return this._cachedStats[N + "-" + Z];
      var A = this.data, M = this._getSortedIndexes(), x = 0, m = null, w, k, E, P, S = 0, U = 0, j = 0, T, W, J, ee = 0, te = 0;
      for (T = N; T <= Z; T++)
        x += A[T], j += A[T] * T, ee += A[T] === 0 ? 0 : 1, te < A[T] && (te = A[T]);
      for (w = j / x, E = x / (Z - N), P = x / ee, k = Math.floor(x / 2), T = 0; T < Q; T++)
        J = M[T], W = A[J], !(J < N || J > Z) && (U += W, S += Math.pow(J - w, 2) * W, m === null && U >= k && (m = J));
      return this._cachedStats[N + "-" + Z] = {
        // various pixel counts for levels (0..255)
        levels: {
          mean: w,
          median: m,
          stdDev: Math.sqrt(S / x),
          unique: ee
        },
        // what's visually represented as bars
        pixelsPerLevel: {
          mean: E,
          median: P,
          peak: te
        },
        pixels: x
      };
    }
  }, A_ = i, A_;
}
var M_, Z1;
function Jy() {
  if (Z1) return M_;
  Z1 = 1;
  var mt = im(), Tt = rm();
  function qe(Q, de) {
    this._histogram = null, this.width = Q, this.height = de, this.size = Q * de, this.arrayBuffer = new ArrayBuffer(this.size), this.data = new Uint8Array(this.arrayBuffer);
  }
  return M_ = qe, W1(), qe.prototype = {
    /**
     * Returns pixel value
     *
     * @param {Number|Point} x - index, point or x
     * @param {Number} [y]
     */
    getValueAt: function(Q, de) {
      var q = typeof Q == "number" && typeof de != "number" ? Q : this.pointToIndex(Q, de);
      return this.data[q];
    },
    /**
     * Converts {@link Point} to index value
     *
     * @param {Number} index
     * @returns {Point}
     */
    indexToPoint: function(Q) {
      var de = new mt();
      return Tt.between(Q, 0, this.size) ? (de.y = Math.floor(Q / this.width), de.x = Q - de.y * this.width) : (de.x = -1, de.y = -1), de;
    },
    /**
     * Calculates index for point or coordinate pair
     *
     * @param {Number|Point} pointOrX
     * @param {Number} [y]
     * @returns {Number}
     */
    pointToIndex: function(Q, de) {
      var q = Q, ie = de;
      return Q instanceof mt && (q = Q.x, ie = Q.y), !Tt.between(q, 0, this.width) || !Tt.between(ie, 0, this.height) ? -1 : this.width * ie + q;
    },
    /**
     * Makes a copy of current bitmap
     *
     * @param {Function} [iterator] optional callback, used for processing pixel value. Accepted arguments: value, index
     * @returns {Bitmap}
     */
    copy: function(Q) {
      var de = new qe(this.width, this.height), q = typeof Q == "function", ie;
      for (ie = 0; ie < this.size; ie++)
        de.data[ie] = q ? Q(this.data[ie], ie) : this.data[ie];
      return de;
    },
    histogram: function() {
      var Q = W1();
      return this._histogram ? this._histogram : (this._histogram = new Q(this), this._histogram);
    }
  }, M_;
}
var I_, $1;
function l2() {
  if ($1) return I_;
  $1 = 1;
  function mt(Tt) {
    this.n = Tt, this.tag = new Array(Tt), this.c = new Array(Tt * 3), this.alphaCurve = 0, this.vertex = new Array(Tt), this.alpha = new Array(Tt), this.alpha0 = new Array(Tt), this.beta = new Array(Tt);
  }
  return I_ = mt, I_;
}
var P_, X1;
function u2() {
  if (X1) return P_;
  X1 = 1;
  function mt() {
    this.area = 0, this.len = 0, this.curve = {}, this.pt = [], this.minX = 1e5, this.minY = 1e5, this.maxX = -1, this.maxY = -1;
  }
  return P_ = mt, P_;
}
var R_, Y1;
function c2() {
  if (Y1) return R_;
  Y1 = 1;
  function mt() {
    this.data = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  return mt.prototype.at = function(Tt, qe) {
    return this.data[Tt * 3 + qe];
  }, R_ = mt, R_;
}
var k_, K1;
function h2() {
  if (K1) return k_;
  K1 = 1;
  function mt(Tt, qe, Q, de, q) {
    this.x = Tt, this.y = qe, this.xy = Q, this.x2 = de, this.y2 = q;
  }
  return k_ = mt, k_;
}
var L_, J1;
function f2() {
  if (J1) return L_;
  J1 = 1;
  var mt = im();
  function Tt() {
    this.pen = 0, this.c = [new mt(), new mt()], this.t = 0, this.s = 0, this.alpha = 0;
  }
  return L_ = Tt, L_;
}
var O_, Q1;
function Qy() {
  if (Q1) return O_;
  Q1 = 1;
  var mt = Ky(), Tt = Jy(), qe = l2(), Q = im(), de = u2(), q = c2(), ie = h2(), i = f2(), N = rm();
  function Z(A) {
    this._luminanceData = null, this._pathlist = [], this._imageLoadingIdentifier = null, this._imageLoaded = !1, this._processed = !1, this._params = {
      turnPolicy: Z.TURNPOLICY_MINORITY,
      turdSize: 2,
      alphaMax: 1,
      optCurve: !0,
      optTolerance: 0.2,
      threshold: Z.THRESHOLD_AUTO,
      blackOnWhite: !0,
      color: Z.COLOR_AUTO,
      background: Z.COLOR_TRANSPARENT,
      width: null,
      height: null
    }, A && this.setParameters(A);
  }
  Z.COLOR_AUTO = "auto", Z.COLOR_TRANSPARENT = "transparent", Z.THRESHOLD_AUTO = -1, Z.TURNPOLICY_BLACK = "black", Z.TURNPOLICY_WHITE = "white", Z.TURNPOLICY_LEFT = "left", Z.TURNPOLICY_RIGHT = "right", Z.TURNPOLICY_MINORITY = "minority", Z.TURNPOLICY_MAJORITY = "majority";
  var R = [
    Z.TURNPOLICY_BLACK,
    Z.TURNPOLICY_WHITE,
    Z.TURNPOLICY_LEFT,
    Z.TURNPOLICY_RIGHT,
    Z.TURNPOLICY_MINORITY,
    Z.TURNPOLICY_MAJORITY
  ];
  return Z.prototype = {
    /**
     * Creating a new {@link Path} for every group of black pixels.
     * @private
     */
    _bmToPathlist: function() {
      var A = this, M = this._params.threshold, x = this._params.blackOnWhite, m, w = new Q(0, 0), k;
      M === Z.THRESHOLD_AUTO && (M = this._luminanceData.histogram().autoThreshold() || 128), m = this._luminanceData.copy(function(j) {
        var T = x ? j > M : j < M;
        return T ? 0 : 1;
      });
      function E(j) {
        for (var T = m.pointToIndex(j); T < m.size && m.data[T] !== 1; )
          T++;
        return T < m.size && m.indexToPoint(T);
      }
      function P(j, T) {
        var W, J, ee;
        for (W = 2; W < 5; W++) {
          for (ee = 0, J = -W + 1; J <= W - 1; J++)
            ee += m.getValueAt(j + J, T + W - 1) ? 1 : -1, ee += m.getValueAt(j + W - 1, T + J - 1) ? 1 : -1, ee += m.getValueAt(j + J - 1, T - W) ? 1 : -1, ee += m.getValueAt(j - W, T + J) ? 1 : -1;
          if (ee > 0)
            return 1;
          if (ee < 0)
            return 0;
        }
        return 0;
      }
      function S(j) {
        var T = new de(), W = j.x, J = j.y, ee = 0, te = 1, le;
        for (T.sign = m.getValueAt(j.x, j.y) ? "+" : "-"; T.pt.push(new Q(W, J)), W > T.maxX && (T.maxX = W), W < T.minX && (T.minX = W), J > T.maxY && (T.maxY = J), J < T.minY && (T.minY = J), T.len++, W += ee, J += te, T.area -= W * te, !(W === j.x && J === j.y); ) {
          var me = m.getValueAt(W + (ee + te - 1) / 2, J + (te - ee - 1) / 2), ke = m.getValueAt(W + (ee - te - 1) / 2, J + (te + ee - 1) / 2);
          ke && !me ? A._params.turnPolicy === "right" || A._params.turnPolicy === "black" && T.sign === "+" || A._params.turnPolicy === "white" && T.sign === "-" || A._params.turnPolicy === "majority" && P(W, J) || A._params.turnPolicy === "minority" && !P(W, J) ? (le = ee, ee = -te, te = le) : (le = ee, ee = te, te = -le) : ke ? (le = ee, ee = -te, te = le) : me || (le = ee, ee = te, te = -le);
        }
        return T;
      }
      function U(j) {
        var T = j.pt[0].y, W = j.len, J, ee, te, le, me, ke, ge;
        for (me = 1; me < W; me++)
          if (J = j.pt[me].x, ee = j.pt[me].y, ee !== T) {
            for (le = T < ee ? T : ee, te = j.maxX, ke = J; ke < te; ke++)
              ge = m.pointToIndex(ke, le), m.data[ge] = m.data[ge] ? 0 : 1;
            T = ee;
          }
      }
      for (this._pathlist = []; w = E(w); )
        k = S(w), U(k), k.area > A._params.turdSize && this._pathlist.push(k);
    },
    /**
     * Processes path list created by _bmToPathlist method creating and optimizing {@link Curve}'s
     * @private
     */
    _processPath: function() {
      var A = this;
      function M(j) {
        var T, W, J;
        j.x0 = j.pt[0].x, j.y0 = j.pt[0].y, j.sums = [];
        var ee = j.sums;
        for (ee.push(new ie(0, 0, 0, 0, 0)), T = 0; T < j.len; T++)
          W = j.pt[T].x - j.x0, J = j.pt[T].y - j.y0, ee.push(new ie(
            ee[T].x + W,
            ee[T].y + J,
            ee[T].xy + W * J,
            ee[T].x2 + W * W,
            ee[T].y2 + J * J
          ));
      }
      function x(j) {
        var T = j.len, W = j.pt, J, ee = new Array(T), te = new Array(T), le = new Array(4);
        j.lon = new Array(T);
        var me = [new Q(), new Q()], ke = new Q(), ge = new Q(), Ve = new Q(), Oe, Ue, we, Ce, it, ut, bt, pt, Ke = 0;
        for (Ue = T - 1; Ue >= 0; Ue--)
          W[Ue].x != W[Ke].x && W[Ue].y != W[Ke].y && (Ke = Ue + 1), te[Ue] = Ke;
        for (Ue = T - 1; Ue >= 0; Ue--) {
          for (le[0] = le[1] = le[2] = le[3] = 0, J = (3 + 3 * (W[N.mod(Ue + 1, T)].x - W[Ue].x) + (W[N.mod(Ue + 1, T)].y - W[Ue].y)) / 2, le[J]++, me[0].x = 0, me[0].y = 0, me[1].x = 0, me[1].y = 0, Ke = te[Ue], Ce = Ue; ; ) {
            if (Oe = 0, J = (3 + 3 * N.sign(W[Ke].x - W[Ce].x) + N.sign(W[Ke].y - W[Ce].y)) / 2, le[J]++, le[0] && le[1] && le[2] && le[3]) {
              ee[Ue] = Ce, Oe = 1;
              break;
            }
            if (ke.x = W[Ke].x - W[Ue].x, ke.y = W[Ke].y - W[Ue].y, N.xprod(me[0], ke) < 0 || N.xprod(me[1], ke) > 0 || (Math.abs(ke.x) <= 1 && Math.abs(ke.y) <= 1 || (ge.x = ke.x + (ke.y >= 0 && (ke.y > 0 || ke.x < 0) ? 1 : -1), ge.y = ke.y + (ke.x <= 0 && (ke.x < 0 || ke.y < 0) ? 1 : -1), N.xprod(me[0], ge) >= 0 && (me[0].x = ge.x, me[0].y = ge.y), ge.x = ke.x + (ke.y <= 0 && (ke.y < 0 || ke.x < 0) ? 1 : -1), ge.y = ke.y + (ke.x >= 0 && (ke.x > 0 || ke.y < 0) ? 1 : -1), N.xprod(me[1], ge) <= 0 && (me[1].x = ge.x, me[1].y = ge.y)), Ce = Ke, Ke = te[Ce], !N.cyclic(Ke, Ue, Ce)))
              break;
          }
          Oe === 0 && (Ve.x = N.sign(W[Ke].x - W[Ce].x), Ve.y = N.sign(W[Ke].y - W[Ce].y), ke.x = W[Ce].x - W[Ue].x, ke.y = W[Ce].y - W[Ue].y, it = N.xprod(me[0], ke), ut = N.xprod(me[0], Ve), bt = N.xprod(me[1], ke), pt = N.xprod(me[1], Ve), we = 1e7, ut < 0 && (we = Math.floor(it / -ut)), pt > 0 && (we = Math.min(we, Math.floor(-bt / pt))), ee[Ue] = N.mod(Ce + we, T));
        }
        for (we = ee[T - 1], j.lon[T - 1] = we, Ue = T - 2; Ue >= 0; Ue--)
          N.cyclic(Ue + 1, ee[Ue], we) && (we = ee[Ue]), j.lon[Ue] = we;
        for (Ue = T - 1; N.cyclic(N.mod(Ue + 1, T), we, j.lon[Ue]); Ue--)
          j.lon[Ue] = we;
      }
      function m(j) {
        function T(ut, bt, pt) {
          var Ke = ut.len, dt = ut.pt, ct = ut.sums, wt, Ht, $t, rt, ri, wi, Qt, At, St, Lt, kt, Ye, De, Re, _t = 0;
          return pt >= Ke && (pt -= Ke, _t = 1), _t === 0 ? (wt = ct[pt + 1].x - ct[bt].x, Ht = ct[pt + 1].y - ct[bt].y, rt = ct[pt + 1].x2 - ct[bt].x2, $t = ct[pt + 1].xy - ct[bt].xy, ri = ct[pt + 1].y2 - ct[bt].y2, wi = pt + 1 - bt) : (wt = ct[pt + 1].x - ct[bt].x + ct[Ke].x, Ht = ct[pt + 1].y - ct[bt].y + ct[Ke].y, rt = ct[pt + 1].x2 - ct[bt].x2 + ct[Ke].x2, $t = ct[pt + 1].xy - ct[bt].xy + ct[Ke].xy, ri = ct[pt + 1].y2 - ct[bt].y2 + ct[Ke].y2, wi = pt + 1 - bt + Ke), kt = (dt[bt].x + dt[pt].x) / 2 - dt[0].x, Ye = (dt[bt].y + dt[pt].y) / 2 - dt[0].y, Re = dt[pt].x - dt[bt].x, De = -(dt[pt].y - dt[bt].y), Qt = (rt - 2 * wt * kt) / wi + kt * kt, At = ($t - wt * Ye - Ht * kt) / wi + kt * Ye, St = (ri - 2 * Ht * Ye) / wi + Ye * Ye, Lt = De * De * Qt + 2 * De * Re * At + Re * Re * St, Math.sqrt(Lt);
        }
        var W, J, ee, te, le = j.len, me = new Array(le + 1), ke = new Array(le + 1), ge = new Array(le), Ve = new Array(le + 1), Oe = new Array(le + 1), Ue = new Array(le + 1), we, Ce, it;
        for (W = 0; W < le; W++)
          it = N.mod(j.lon[N.mod(W - 1, le)] - 1, le), it == W && (it = N.mod(W + 1, le)), it < W ? ge[W] = le : ge[W] = it;
        for (J = 1, W = 0; W < le; W++)
          for (; J <= ge[W]; )
            Ve[J] = W, J++;
        for (W = 0, J = 0; W < le; J++)
          Oe[J] = W, W = ge[W];
        for (Oe[J] = le, ee = J, W = le, J = ee; J > 0; J--)
          Ue[J] = W, W = Ve[W];
        for (Ue[0] = 0, me[0] = 0, J = 1; J <= ee; J++)
          for (W = Ue[J]; W <= Oe[J]; W++) {
            for (Ce = -1, te = Oe[J - 1]; te >= Ve[W]; te--)
              we = T(j, te, W) + me[te], (Ce < 0 || we < Ce) && (ke[W] = te, Ce = we);
            me[W] = Ce;
          }
        for (j.m = ee, j.po = new Array(ee), W = le, J = ee - 1; W > 0; J--)
          W = ke[W], j.po[J] = W;
      }
      function w(j) {
        function T(Qt, At, St, Lt, kt) {
          for (var Ye = Qt.len, De = Qt.sums, Re, _t, et, Ie, pe, xt, l, _, I, X, ne, ue = 0; St >= Ye; )
            St -= Ye, ue += 1;
          for (; At >= Ye; )
            At -= Ye, ue -= 1;
          for (; St < 0; )
            St += Ye, ue -= 1;
          for (; At < 0; )
            At += Ye, ue += 1;
          Re = De[St + 1].x - De[At].x + ue * De[Ye].x, _t = De[St + 1].y - De[At].y + ue * De[Ye].y, et = De[St + 1].x2 - De[At].x2 + ue * De[Ye].x2, Ie = De[St + 1].xy - De[At].xy + ue * De[Ye].xy, pe = De[St + 1].y2 - De[At].y2 + ue * De[Ye].y2, xt = St + 1 - At + ue * Ye, Lt.x = Re / xt, Lt.y = _t / xt, l = (et - Re * Re / xt) / xt, _ = (Ie - Re * _t / xt) / xt, I = (pe - _t * _t / xt) / xt, X = (l + I + Math.sqrt((l - I) * (l - I) + 4 * _ * _)) / 2, l -= X, I -= X, Math.abs(l) >= Math.abs(I) ? (ne = Math.sqrt(l * l + _ * _), ne !== 0 && (kt.x = -_ / ne, kt.y = l / ne)) : (ne = Math.sqrt(I * I + _ * _), ne !== 0 && (kt.x = -I / ne, kt.y = _ / ne)), ne === 0 && (kt.x = kt.y = 0);
        }
        var W = j.m, J = j.po, ee = j.len, te = j.pt, le = j.x0, me = j.y0, ke = new Array(W), ge = new Array(W), Ve = new Array(W), Oe = new Array(3), Ue, we, Ce, it, ut, bt = new Q();
        for (j.curve = new qe(W), we = 0; we < W; we++)
          Ce = J[N.mod(we + 1, W)], Ce = N.mod(Ce - J[we], ee) + J[we], ke[we] = new Q(), ge[we] = new Q(), T(j, J[we], Ce, ke[we], ge[we]);
        for (we = 0; we < W; we++)
          if (Ve[we] = new q(), Ue = ge[we].x * ge[we].x + ge[we].y * ge[we].y, Ue === 0)
            for (Ce = 0; Ce < 3; Ce++)
              for (it = 0; it < 3; it++)
                Ve[we].data[Ce * 3 + it] = 0;
          else
            for (Oe[0] = ge[we].y, Oe[1] = -ge[we].x, Oe[2] = -Oe[1] * ke[we].y - Oe[0] * ke[we].x, ut = 0; ut < 3; ut++)
              for (it = 0; it < 3; it++)
                Ve[we].data[ut * 3 + it] = Oe[ut] * Oe[it] / Ue;
        var pt, Ke, dt, ct, wt, Ht, $t, rt, ri, wi;
        for (we = 0; we < W; we++) {
          for (pt = new q(), Ke = new Q(), bt.x = te[J[we]].x - le, bt.y = te[J[we]].y - me, Ce = N.mod(we - 1, W), ut = 0; ut < 3; ut++)
            for (it = 0; it < 3; it++)
              pt.data[ut * 3 + it] = Ve[Ce].at(ut, it) + Ve[we].at(ut, it);
          for (; ; ) {
            if (wt = pt.at(0, 0) * pt.at(1, 1) - pt.at(0, 1) * pt.at(1, 0), wt !== 0) {
              Ke.x = (-pt.at(0, 2) * pt.at(1, 1) + pt.at(1, 2) * pt.at(0, 1)) / wt, Ke.y = (pt.at(0, 2) * pt.at(1, 0) - pt.at(1, 2) * pt.at(0, 0)) / wt;
              break;
            }
            for (pt.at(0, 0) > pt.at(1, 1) ? (Oe[0] = -pt.at(0, 1), Oe[1] = pt.at(0, 0)) : pt.at(1, 1) ? (Oe[0] = -pt.at(1, 1), Oe[1] = pt.at(1, 0)) : (Oe[0] = 1, Oe[1] = 0), Ue = Oe[0] * Oe[0] + Oe[1] * Oe[1], Oe[2] = -Oe[1] * bt.y - Oe[0] * bt.x, ut = 0; ut < 3; ut++)
              for (it = 0; it < 3; it++)
                pt.data[ut * 3 + it] += Oe[ut] * Oe[it] / Ue;
          }
          if (dt = Math.abs(Ke.x - bt.x), ct = Math.abs(Ke.y - bt.y), dt <= 0.5 && ct <= 0.5) {
            j.curve.vertex[we] = new Q(Ke.x + le, Ke.y + me);
            continue;
          }
          if (Ht = N.quadform(pt, bt), rt = bt.x, ri = bt.y, pt.at(0, 0) !== 0)
            for (wi = 0; wi < 2; wi++)
              Ke.y = bt.y - 0.5 + wi, Ke.x = -(pt.at(0, 1) * Ke.y + pt.at(0, 2)) / pt.at(0, 0), dt = Math.abs(Ke.x - bt.x), $t = N.quadform(pt, Ke), dt <= 0.5 && $t < Ht && (Ht = $t, rt = Ke.x, ri = Ke.y);
          if (pt.at(1, 1) !== 0)
            for (wi = 0; wi < 2; wi++)
              Ke.x = bt.x - 0.5 + wi, Ke.y = -(pt.at(1, 0) * Ke.x + pt.at(1, 2)) / pt.at(1, 1), ct = Math.abs(Ke.y - bt.y), $t = N.quadform(pt, Ke), ct <= 0.5 && $t < Ht && (Ht = $t, rt = Ke.x, ri = Ke.y);
          for (ut = 0; ut < 2; ut++)
            for (it = 0; it < 2; it++)
              Ke.x = bt.x - 0.5 + ut, Ke.y = bt.y - 0.5 + it, $t = N.quadform(pt, Ke), $t < Ht && (Ht = $t, rt = Ke.x, ri = Ke.y);
          j.curve.vertex[we] = new Q(rt + le, ri + me);
        }
      }
      function k(j) {
        var T = j.curve, W = T.n, J = T.vertex, ee, te, le;
        for (ee = 0, te = W - 1; ee < te; ee++, te--)
          le = J[ee], J[ee] = J[te], J[te] = le;
      }
      function E(j) {
        var T = j.curve.n, W = j.curve, J, ee, te, le, me, ke, ge, Ve, Oe;
        for (J = 0; J < T; J++)
          ee = N.mod(J + 1, T), te = N.mod(J + 2, T), Oe = N.interval(1 / 2, W.vertex[te], W.vertex[ee]), me = N.ddenom(W.vertex[J], W.vertex[te]), me !== 0 ? (le = N.dpara(W.vertex[J], W.vertex[ee], W.vertex[te]) / me, le = Math.abs(le), ke = le > 1 ? 1 - 1 / le : 0, ke = ke / 0.75) : ke = 4 / 3, W.alpha0[ee] = ke, ke >= A._params.alphaMax ? (W.tag[ee] = "CORNER", W.c[3 * ee + 1] = W.vertex[ee], W.c[3 * ee + 2] = Oe) : (ke < 0.55 ? ke = 0.55 : ke > 1 && (ke = 1), ge = N.interval(0.5 + 0.5 * ke, W.vertex[J], W.vertex[ee]), Ve = N.interval(0.5 + 0.5 * ke, W.vertex[te], W.vertex[ee]), W.tag[ee] = "CURVE", W.c[3 * ee + 0] = ge, W.c[3 * ee + 1] = Ve, W.c[3 * ee + 2] = Oe), W.alpha[ee] = ke, W.beta[ee] = 0.5;
        W.alphaCurve = 1;
      }
      function P(j) {
        function T(Ht, $t, rt, ri, wi, Qt, At) {
          var St = Ht.curve.n, Lt = Ht.curve, kt = Lt.vertex, Ye, De, Re, _t, et, Ie, pe, xt, l, _, I, X, ne, ue, Te, ye, Me, Ge, Qe, re, Se, Pe, at;
          if ($t == rt || (Ye = $t, et = N.mod($t + 1, St), De = N.mod(Ye + 1, St), _t = Qt[De], _t === 0))
            return 1;
          for (xt = N.ddist(kt[$t], kt[et]), Ye = De; Ye != rt; Ye = De)
            if (De = N.mod(Ye + 1, St), Re = N.mod(Ye + 2, St), Qt[De] != _t || N.sign(N.cprod(kt[$t], kt[et], kt[De], kt[Re])) != _t || N.iprod1(kt[$t], kt[et], kt[De], kt[Re]) < xt * N.ddist(kt[De], kt[Re]) * -0.999847695156)
              return 1;
          if (I = Lt.c[N.mod($t, St) * 3 + 2].copy(), X = kt[N.mod($t + 1, St)].copy(), ne = kt[N.mod(rt, St)].copy(), ue = Lt.c[N.mod(rt, St) * 3 + 2].copy(), Ie = At[rt] - At[$t], Ie -= N.dpara(kt[0], Lt.c[$t * 3 + 2], Lt.c[rt * 3 + 2]) / 2, $t >= rt && (Ie += At[St]), Ge = N.dpara(I, X, ne), Qe = N.dpara(I, X, ue), re = N.dpara(I, ne, ue), Se = Ge + re - Qe, Qe == Ge || (at = re / (re - Se), Pe = Qe / (Qe - Ge), ye = Qe * at / 2, ye === 0))
            return 1;
          for (Me = Ie / ye, pe = 2 - Math.sqrt(4 - Me / 0.3), ri.c[0] = N.interval(at * pe, I, X), ri.c[1] = N.interval(Pe * pe, ue, ne), ri.alpha = pe, ri.t = at, ri.s = Pe, X = ri.c[0].copy(), ne = ri.c[1].copy(), ri.pen = 0, Ye = N.mod($t + 1, St); Ye != rt; Ye = De) {
            if (De = N.mod(Ye + 1, St), at = N.tangent(I, X, ne, ue, kt[Ye], kt[De]), at < -0.5 || (Te = N.bezier(at, I, X, ne, ue), xt = N.ddist(kt[Ye], kt[De]), xt === 0) || (l = N.dpara(kt[Ye], kt[De], Te) / xt, Math.abs(l) > wi) || N.iprod(kt[Ye], kt[De], Te) < 0 || N.iprod(kt[De], kt[Ye], Te) < 0)
              return 1;
            ri.pen += l * l;
          }
          for (Ye = $t; Ye != rt; Ye = De) {
            if (De = N.mod(Ye + 1, St), at = N.tangent(I, X, ne, ue, Lt.c[Ye * 3 + 2], Lt.c[De * 3 + 2]), at < -0.5 || (Te = N.bezier(at, I, X, ne, ue), xt = N.ddist(Lt.c[Ye * 3 + 2], Lt.c[De * 3 + 2]), xt === 0) || (l = N.dpara(Lt.c[Ye * 3 + 2], Lt.c[De * 3 + 2], Te) / xt, _ = N.dpara(Lt.c[Ye * 3 + 2], Lt.c[De * 3 + 2], kt[De]) / xt, _ *= 0.75 * Lt.alpha[De], _ < 0 && (l = -l, _ = -_), l < _ - wi))
              return 1;
            l < _ && (ri.pen += (l - _) * (l - _));
          }
          return 0;
        }
        var W = j.curve, J = W.n, ee = W.vertex, te = new Array(J + 1), le = new Array(J + 1), me = new Array(J + 1), ke = new Array(J + 1), ge, Ve, Oe, Ue, we = new i(), Ce, it, ut, bt, pt, Ke, dt, ct = new Array(J), wt = new Array(J + 1);
        for (Ve = 0; Ve < J; Ve++)
          W.tag[Ve] == "CURVE" ? ct[Ve] = N.sign(N.dpara(ee[N.mod(Ve - 1, J)], ee[Ve], ee[N.mod(Ve + 1, J)])) : ct[Ve] = 0;
        for (ut = 0, wt[0] = 0, Ce = W.vertex[0], Ve = 0; Ve < J; Ve++)
          it = N.mod(Ve + 1, J), W.tag[it] == "CURVE" && (bt = W.alpha[it], ut += 0.3 * bt * (4 - bt) * N.dpara(W.c[Ve * 3 + 2], ee[it], W.c[it * 3 + 2]) / 2, ut += N.dpara(Ce, W.c[Ve * 3 + 2], W.c[it * 3 + 2]) / 2), wt[Ve + 1] = ut;
        for (te[0] = -1, le[0] = 0, me[0] = 0, Oe = 1; Oe <= J; Oe++)
          for (te[Oe] = Oe - 1, le[Oe] = le[Oe - 1], me[Oe] = me[Oe - 1] + 1, Ve = Oe - 2; Ve >= 0 && (Ue = T(
            j,
            Ve,
            N.mod(Oe, J),
            we,
            A._params.optTolerance,
            ct,
            wt
          ), !Ue); Ve--)
            (me[Oe] > me[Ve] + 1 || me[Oe] == me[Ve] + 1 && le[Oe] > le[Ve] + we.pen) && (te[Oe] = Ve, le[Oe] = le[Ve] + we.pen, me[Oe] = me[Ve] + 1, ke[Oe] = we, we = new i());
        for (ge = me[J], pt = new qe(ge), Ke = new Array(ge), dt = new Array(ge), Oe = J, Ve = ge - 1; Ve >= 0; Ve--)
          te[Oe] == Oe - 1 ? (pt.tag[Ve] = W.tag[N.mod(Oe, J)], pt.c[Ve * 3 + 0] = W.c[N.mod(Oe, J) * 3 + 0], pt.c[Ve * 3 + 1] = W.c[N.mod(Oe, J) * 3 + 1], pt.c[Ve * 3 + 2] = W.c[N.mod(Oe, J) * 3 + 2], pt.vertex[Ve] = W.vertex[N.mod(Oe, J)], pt.alpha[Ve] = W.alpha[N.mod(Oe, J)], pt.alpha0[Ve] = W.alpha0[N.mod(Oe, J)], pt.beta[Ve] = W.beta[N.mod(Oe, J)], Ke[Ve] = dt[Ve] = 1) : (pt.tag[Ve] = "CURVE", pt.c[Ve * 3 + 0] = ke[Oe].c[0], pt.c[Ve * 3 + 1] = ke[Oe].c[1], pt.c[Ve * 3 + 2] = W.c[N.mod(Oe, J) * 3 + 2], pt.vertex[Ve] = N.interval(
            ke[Oe].s,
            W.c[N.mod(Oe, J) * 3 + 2],
            ee[N.mod(Oe, J)]
          ), pt.alpha[Ve] = ke[Oe].alpha, pt.alpha0[Ve] = ke[Oe].alpha, Ke[Ve] = ke[Oe].s, dt[Ve] = ke[Oe].t), Oe = te[Oe];
        for (Ve = 0; Ve < ge; Ve++)
          it = N.mod(Ve + 1, ge), pt.beta[Ve] = Ke[Ve] / (Ke[Ve] + dt[it]);
        pt.alphaCurve = 1, j.curve = pt;
      }
      for (var S = 0; S < this._pathlist.length; S++) {
        var U = this._pathlist[S];
        M(U), x(U), m(U), w(U), U.sign === "-" && k(U), E(U), A._params.optCurve && P(U);
      }
    },
    /**
     * Validates some of parameters
     * @param params
     * @private
     */
    _validateParameters: function(A) {
      if (A && A.turnPolicy && R.indexOf(A.turnPolicy) === -1) {
        var M = "'" + R.join("', '") + "'";
        throw new Error("Bad turnPolicy value. Allowed values are: " + M);
      }
      if (A && A.threshold != null && A.threshold !== Z.THRESHOLD_AUTO && (typeof A.threshold != "number" || !N.between(A.threshold, 0, 255)))
        throw new Error("Bad threshold value. Expected to be an integer in range 0..255");
      if (A && A.optCurve != null && typeof A.optCurve != "boolean")
        throw new Error("'optCurve' must be Boolean");
    },
    _processLoadedImage: function(A) {
      var M = new Tt(A.bitmap.width, A.bitmap.height), x = A.bitmap.data;
      A.scan(0, 0, A.bitmap.width, A.bitmap.height, function(m, w, k) {
        var E = x[k + 3] / 255, P = 255 + (x[k + 0] - 255) * E, S = 255 + (x[k + 1] - 255) * E, U = 255 + (x[k + 2] - 255) * E;
        M.data[k / 4] = N.luminance(P, S, U);
      }), this._luminanceData = M, this._imageLoaded = !0;
    },
    /**
     * Reads given image. Uses {@link Jimp} under the hood, so target can be whatever Jimp can take
     *
     * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or BMP
     * @param {Function} callback
     */
    loadImage: function(A, M) {
      var x = this, m = {};
      this._imageLoadingIdentifier = m, this._imageLoaded = !1, A instanceof mt ? (this._imageLoadingIdentifier = null, this._imageLoaded = !0, x._processLoadedImage(A), M.call(x, null)) : mt.read(A, function(w, k) {
        var E = x._imageLoadingIdentifier !== m;
        if (E) {
          var P = w || new Error("Another image was loaded instead");
          return M.call(x, P);
        }
        x._imageLoadingIdentifier = null, x._processLoadedImage(k), M.call(x, null);
      });
    },
    /**
     * Sets algorithm parameters
     * @param {Potrace~Options} newParams
     */
    setParameters: function(A) {
      var M, x;
      this._validateParameters(A);
      for (M in this._params)
        this._params.hasOwnProperty(M) && A.hasOwnProperty(M) && (x = this._params[M], this._params[M] = A[M], x !== this._params[M] && ["color", "background"].indexOf(M) === -1 && (this._processed = !1));
    },
    /**
     * Generates just <path> tag without rest of the SVG file
     *
     * @param {String} [fillColor] - overrides color from parameters
     * @returns {String}
     */
    getPathTag: function(A, M) {
      if (A = arguments.length === 0 ? this._params.color : A, A === Z.COLOR_AUTO && (A = this._params.blackOnWhite ? "black" : "white"), !this._imageLoaded)
        throw new Error("Image should be loaded first");
      this._processed || (this._bmToPathlist(), this._processPath(), this._processed = !0);
      var x = '<path d="';
      return x += this._pathlist.map(function(m) {
        return N.renderCurve(m.curve, M);
      }).join(" "), x += '" stroke="none" fill="' + A + '" fill-rule="evenodd"/>', x;
    },
    /**
     * Returns <symbol> tag. Always has viewBox specified and comes with no fill color,
     * so it could be changed with <use> tag
     *
     * @param id
     * @returns {string}
     */
    getSymbol: function(A) {
      return '<symbol viewBox="0 0 ' + this._luminanceData.width + " " + this._luminanceData.height + '" id="' + A + '">' + this.getPathTag("") + "</symbol>";
    },
    /**
     * Generates SVG image
     * @returns {String}
     */
    getSVG: function() {
      var A = this._params.width || this._luminanceData.width, M = this._params.height || this._luminanceData.height, x = {
        x: this._params.width ? this._params.width / this._luminanceData.width : 1,
        y: this._params.height ? this._params.height / this._luminanceData.height : 1
      };
      return '<svg xmlns="http://www.w3.org/2000/svg" width="' + A + '" height="' + M + '" viewBox="0 0 ' + A + " " + M + `" version="1.1">
` + (this._params.background !== Z.COLOR_TRANSPARENT ? '	<rect x="0" y="0" width="100%" height="100%" fill="' + this._params.background + `" />
` : "") + "	" + this.getPathTag(this._params.color, x) + `
</svg>`;
    }
  }, O_ = Z, O_;
}
var D_, ey;
function d2() {
  if (ey) return D_;
  ey = 1;
  var mt = Qy(), Tt = rm();
  function qe(de) {
    this._potrace = new mt(), this._calculatedThreshold = null, this._params = {
      threshold: mt.THRESHOLD_AUTO,
      blackOnWhite: !0,
      steps: qe.STEPS_AUTO,
      background: mt.COLOR_TRANSPARENT,
      fillStrategy: qe.FILL_DOMINANT,
      rangeDistribution: qe.RANGES_AUTO
    }, de && this.setParameters(de);
  }
  for (var Q in mt)
    Object.prototype.hasOwnProperty.call(mt, Q) && Q === Q.toUpperCase() && (qe[Q] = mt[Q]);
  return qe.STEPS_AUTO = -1, qe.FILL_SPREAD = "spread", qe.FILL_DOMINANT = "dominant", qe.FILL_MEDIAN = "median", qe.FILL_MEAN = "mean", qe.RANGES_AUTO = "auto", qe.RANGES_EQUAL = "equal", qe.prototype = {
    /**
     * Fine tuning to color ranges.
     *
     * If last range (featuring most saturated color) is larger than 10% of color space (25 units)
     * then we want to add another color stop, that hopefully will include darkest pixels, improving presence of
     * shadows and line art
     *
     * @param ranges
     * @private
     */
    _addExtraColorStop: function(de) {
      var q = this._params.blackOnWhite, ie = de[de.length - 1], i = q ? 0 : ie.value, N = q ? ie.value : 255;
      if (N - i > 25 && ie.colorIntensity !== 1) {
        var Z = this._getImageHistogram(), R = Z.getStats(i, N).levels, A = R.mean + R.stdDev <= 25 ? R.mean + R.stdDev : R.mean - R.stdDev <= 25 ? R.mean - R.stdDev : 25, M = q ? Z.getStats(0, A) : Z.getStats(A, 255), x = M.levels.mean;
        de.push({
          value: Math.abs((q ? 0 : 255) - A),
          colorIntensity: isNaN(x) ? 0 : (q ? 255 - x : x) / 255
        });
      }
      return de;
    },
    /**
     * Calculates color intensity for each element of numeric array
     * 
     * @param {number[]} colorStops
     * @returns {{ levels: number, colorIntensity: number }[]}
     * @private
     */
    _calcColorIntensity: function(de) {
      var q = this._params.blackOnWhite, ie = this._params.fillStrategy, i = ie !== qe.FILL_SPREAD ? this._getImageHistogram() : null, N = Math.abs(this._paramThreshold() - (q ? 0 : 255));
      return de.map(function(Z, R) {
        var A = R + 1 === de.length ? q ? -1 : 256 : de[R + 1], M = Math.round(q ? A + 1 : Z), x = Math.round(q ? Z : A - 1), m = R / (de.length - 1), w = x - M, k = i.getStats(M, x), E = -1;
        if (k.pixels === 0)
          return {
            value: Z,
            colorIntensity: 0
          };
        switch (ie) {
          case qe.FILL_SPREAD:
            E = (q ? M : x) + (q ? 1 : -1) * w * Math.max(0.5, N / 255) * m;
            break;
          case qe.FILL_DOMINANT:
            E = i.getDominantColor(M, x, Tt.clamp(w, 1, 5));
            break;
          case qe.FILL_MEAN:
            E = k.levels.mean;
            break;
          case qe.FILL_MEDIAN:
            E = k.levels.median;
            break;
        }
        return R !== 0 && (E = q ? Tt.clamp(E, M, x - Math.round(w * 0.1)) : Tt.clamp(E, M + Math.round(w * 0.1), x)), {
          value: Z,
          colorIntensity: E === -1 ? 0 : (q ? 255 - E : E) / 255
        };
      });
    },
    /**
     * @returns {Histogram}
     * @private
     */
    _getImageHistogram: function() {
      return this._potrace._luminanceData.histogram();
    },
    /**
     * Processes threshold, steps and rangeDistribution parameters and returns normalized array of color stops
     * @returns {*}
     * @private
     */
    _getRanges: function() {
      var de = this._paramSteps();
      if (!Array.isArray(de))
        return this._params.rangeDistribution === qe.RANGES_AUTO ? this._getRangesAuto() : this._getRangesEquallyDistributed();
      var q = [], ie = this._paramThreshold(), i = this._params.blackOnWhite;
      return de.forEach(function(N) {
        q.indexOf(N) === -1 && Tt.between(N, 0, 255) && q.push(N);
      }), q.length || q.push(ie), q = q.sort(function(N, Z) {
        return N < Z === i ? 1 : -1;
      }), i && q[0] < ie ? q.unshift(ie) : !i && q[q.length - 1] < ie && q.push(ie), this._calcColorIntensity(q);
    },
    /**
     * Calculates given (or lower) number of thresholds using automatic thresholding algorithm
     * @returns {*}
     * @private
     */
    _getRangesAuto: function() {
      var de = this._getImageHistogram(), q = this._paramSteps(!0), ie;
      if (this._params.threshold === mt.THRESHOLD_AUTO)
        ie = de.multilevelThresholding(q);
      else {
        var i = this._paramThreshold();
        ie = this._params.blackOnWhite ? de.multilevelThresholding(q - 1, 0, i) : de.multilevelThresholding(q - 1, i, 255), this._params.blackOnWhite ? ie.push(i) : ie.unshift(i);
      }
      return this._params.blackOnWhite && (ie = ie.reverse()), this._calcColorIntensity(ie);
    },
    /**
     * Calculates color stops and color representing each segment, returning them
     * from least to most intense color (black or white, depending on blackOnWhite parameter)
     *
     * @private
     */
    _getRangesEquallyDistributed: function() {
      for (var de = this._params.blackOnWhite, q = de ? this._paramThreshold() : 255 - this._paramThreshold(), ie = this._paramSteps(), i = q / ie, N = [], Z = ie - 1, R; Z >= 0; )
        R = Math.min(q, (Z + 1) * i), R = de ? R : 255 - R, Z--, N.push(R);
      return this._calcColorIntensity(N);
    },
    /**
     * Returns valid steps value
     * @param {Boolean} [count=false]
     * @returns {number|number[]}
     * @private
     */
    _paramSteps: function(de) {
      var q = this._params.steps;
      if (Array.isArray(q))
        return de ? q.length : q;
      if (q === qe.STEPS_AUTO && this._params.threshold === mt.THRESHOLD_AUTO)
        return 4;
      var ie = this._params.blackOnWhite, i = ie ? this._paramThreshold() : 255 - this._paramThreshold();
      return q === qe.STEPS_AUTO ? i > 200 ? 4 : 3 : Math.min(i, Math.max(2, q));
    },
    /**
     * Returns valid threshold value
     * @returns {number}
     * @private
     */
    _paramThreshold: function() {
      if (this._calculatedThreshold !== null)
        return this._calculatedThreshold;
      if (this._params.threshold !== mt.THRESHOLD_AUTO)
        return this._calculatedThreshold = this._params.threshold, this._calculatedThreshold;
      var de = this._getImageHistogram().multilevelThresholding(2);
      return this._calculatedThreshold = this._params.blackOnWhite ? de[1] : de[0], this._calculatedThreshold = this._calculatedThreshold || 128, this._calculatedThreshold;
    },
    /**
     * Running potrace on the image multiple times with different thresholds and returns an array
     * of path tags
     *
     * @param {Boolean} [noFillColor]
     * @returns {string[]}
     * @private
     */
    _pathTags: function(de) {
      var q = this._getRanges(), ie = this._potrace, i = this._params.blackOnWhite;
      q.length >= 10 && (q = this._addExtraColorStop(q)), ie.setParameters({ blackOnWhite: i });
      var N = 0;
      return q.map(function(Z) {
        var R = Z.colorIntensity;
        if (R === 0)
          return "";
        var A = !N || R === 1 ? R : (N - R) / (N - 1);
        A = Tt.clamp(parseFloat(A.toFixed(3)), 0, 1), N = N + (1 - N) * A, ie.setParameters({ threshold: Z.value });
        var M = de ? ie.getPathTag("") : ie.getPathTag();
        M = Tt.setHtmlAttr(M, "fill-opacity", A.toFixed(3));
        var x = A === 0 || M.indexOf(' d=""') !== -1;
        return x ? "" : M;
      });
    },
    /**
     * Loads image.
     *
     * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or BMP
     * @param {Function} callback
     */
    loadImage: function(de, q) {
      var ie = this;
      this._potrace.loadImage(de, function(i) {
        ie._calculatedThreshold = null, q.call(ie, i);
      });
    },
    /**
     * Sets parameters. Accepts same object as {Potrace}
     *
     * @param {Posterizer~Options} params
     */
    setParameters: function(de) {
      if (de) {
        if (this._potrace.setParameters(de), de.steps && !Array.isArray(de.steps) && (!Tt.isNumber(de.steps) || !Tt.between(de.steps, 1, 255)))
          throw new Error("Bad 'steps' value");
        for (var q in this._params)
          this._params.hasOwnProperty(q) && de.hasOwnProperty(q) && (this._params[q] = de[q]);
        this._calculatedThreshold = null;
      }
    },
    /**
     * Returns image as <symbol> tag. Always has viewBox specified
     *
     * @param {string} id
     */
    getSymbol: function(de) {
      var q = this._potrace._luminanceData.width, ie = this._potrace._luminanceData.height, i = this._pathTags(!0);
      return '<symbol viewBox="0 0 ' + q + " " + ie + '" id="' + de + '">' + i.join("") + "</symbol>";
    },
    /**
     * Generates SVG image
     * @returns {String}
     */
    getSVG: function() {
      var de = this._potrace._luminanceData.width, q = this._potrace._luminanceData.height, ie = this._pathTags(!1), i = '<svg xmlns="http://www.w3.org/2000/svg" width="' + de + '" height="' + q + '" viewBox="0 0 ' + de + " " + q + `" version="1.1">
	` + (this._params.background !== mt.COLOR_TRANSPARENT ? '<rect x="0" y="0" width="100%" height="100%" fill="' + this._params.background + `" />
	` : "") + ie.join(`
	`) + `
</svg>`;
      return i.replace(/\n(?:\t*\n)+(\t*)/g, `
$1`);
    }
  }, D_ = qe, D_;
}
var z_, ty;
function p2() {
  if (ty) return z_;
  ty = 1;
  var mt = Qy(), Tt = d2();
  function qe(de, q, ie) {
    arguments.length === 2 && (ie = q, q = {});
    var i = new mt(q);
    i.loadImage(de, function(N) {
      if (N)
        return ie(N);
      ie(null, i.getSVG(), i);
    });
  }
  function Q(de, q, ie) {
    arguments.length === 2 && (ie = q, q = {});
    var i = new Tt(q);
    i.loadImage(de, function(N) {
      if (N)
        return ie(N);
      ie(null, i.getSVG(), i);
    });
  }
  return z_ = {
    trace: qe,
    posterize: Q,
    Potrace: mt,
    Posterizer: Tt
  }, z_;
}
var m2 = p2();
const iy = /* @__PURE__ */ dd(m2);
var Yp = { exports: {} };
const _2 = {}, g2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _2
}, Symbol.toStringTag, { value: "Module" })), ry = /* @__PURE__ */ Xy(g2);
var np = { exports: {} }, v2 = np.exports, ny;
function y2() {
  return ny || (ny = 1, function(mt, Tt) {
    (function(qe, Q) {
      Q(Tt);
    })(v2, function(qe) {
      var Q = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], de = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], q = "-----------------------------------------------------------------------------------------------------------------------------------------------------", ie = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", i = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      }, N = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", Z = {
        5: N,
        "5module": N + " export import",
        6: N + " const class extends export import super"
      }, R = /^in(stanceof)?$/, A = new RegExp("[" + ie + "]"), M = new RegExp("[" + ie + q + "]");
      function x(D, be) {
        for (var ht = 65536, Ot = 0; Ot < be.length; Ot += 2) {
          if (ht += be[Ot], ht > D)
            return !1;
          if (ht += be[Ot + 1], ht >= D)
            return !0;
        }
        return !1;
      }
      function m(D, be) {
        return D < 65 ? D === 36 : D < 91 ? !0 : D < 97 ? D === 95 : D < 123 ? !0 : D <= 65535 ? D >= 170 && A.test(String.fromCharCode(D)) : be === !1 ? !1 : x(D, de);
      }
      function w(D, be) {
        return D < 48 ? D === 36 : D < 58 ? !0 : D < 65 ? !1 : D < 91 ? !0 : D < 97 ? D === 95 : D < 123 ? !0 : D <= 65535 ? D >= 170 && M.test(String.fromCharCode(D)) : be === !1 ? !1 : x(D, de) || x(D, Q);
      }
      var k = function(be, ht) {
        ht === void 0 && (ht = {}), this.label = be, this.keyword = ht.keyword, this.beforeExpr = !!ht.beforeExpr, this.startsExpr = !!ht.startsExpr, this.isLoop = !!ht.isLoop, this.isAssign = !!ht.isAssign, this.prefix = !!ht.prefix, this.postfix = !!ht.postfix, this.binop = ht.binop || null, this.updateContext = null;
      };
      function E(D, be) {
        return new k(D, { beforeExpr: !0, binop: be });
      }
      var P = { beforeExpr: !0 }, S = { startsExpr: !0 }, U = {};
      function j(D, be) {
        return be === void 0 && (be = {}), be.keyword = D, U[D] = new k(D, be);
      }
      var T = {
        num: new k("num", S),
        regexp: new k("regexp", S),
        string: new k("string", S),
        name: new k("name", S),
        privateId: new k("privateId", S),
        eof: new k("eof"),
        // Punctuation token types.
        bracketL: new k("[", { beforeExpr: !0, startsExpr: !0 }),
        bracketR: new k("]"),
        braceL: new k("{", { beforeExpr: !0, startsExpr: !0 }),
        braceR: new k("}"),
        parenL: new k("(", { beforeExpr: !0, startsExpr: !0 }),
        parenR: new k(")"),
        comma: new k(",", P),
        semi: new k(";", P),
        colon: new k(":", P),
        dot: new k("."),
        question: new k("?", P),
        questionDot: new k("?."),
        arrow: new k("=>", P),
        template: new k("template"),
        invalidTemplate: new k("invalidTemplate"),
        ellipsis: new k("...", P),
        backQuote: new k("`", S),
        dollarBraceL: new k("${", { beforeExpr: !0, startsExpr: !0 }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new k("=", { beforeExpr: !0, isAssign: !0 }),
        assign: new k("_=", { beforeExpr: !0, isAssign: !0 }),
        incDec: new k("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
        prefix: new k("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        logicalOR: E("||", 1),
        logicalAND: E("&&", 2),
        bitwiseOR: E("|", 3),
        bitwiseXOR: E("^", 4),
        bitwiseAND: E("&", 5),
        equality: E("==/!=/===/!==", 6),
        relational: E("</>/<=/>=", 7),
        bitShift: E("<</>>/>>>", 8),
        plusMin: new k("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
        modulo: E("%", 10),
        star: E("*", 10),
        slash: E("/", 10),
        starstar: new k("**", { beforeExpr: !0 }),
        coalesce: E("??", 1),
        // Keyword token types.
        _break: j("break"),
        _case: j("case", P),
        _catch: j("catch"),
        _continue: j("continue"),
        _debugger: j("debugger"),
        _default: j("default", P),
        _do: j("do", { isLoop: !0, beforeExpr: !0 }),
        _else: j("else", P),
        _finally: j("finally"),
        _for: j("for", { isLoop: !0 }),
        _function: j("function", S),
        _if: j("if"),
        _return: j("return", P),
        _switch: j("switch"),
        _throw: j("throw", P),
        _try: j("try"),
        _var: j("var"),
        _const: j("const"),
        _while: j("while", { isLoop: !0 }),
        _with: j("with"),
        _new: j("new", { beforeExpr: !0, startsExpr: !0 }),
        _this: j("this", S),
        _super: j("super", S),
        _class: j("class", S),
        _extends: j("extends", P),
        _export: j("export"),
        _import: j("import", S),
        _null: j("null", S),
        _true: j("true", S),
        _false: j("false", S),
        _in: j("in", { beforeExpr: !0, binop: 7 }),
        _instanceof: j("instanceof", { beforeExpr: !0, binop: 7 }),
        _typeof: j("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _void: j("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _delete: j("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
      }, W = /\r\n?|\n|\u2028|\u2029/, J = new RegExp(W.source, "g");
      function ee(D) {
        return D === 10 || D === 13 || D === 8232 || D === 8233;
      }
      function te(D, be, ht) {
        ht === void 0 && (ht = D.length);
        for (var Ot = be; Ot < ht; Ot++) {
          var hi = D.charCodeAt(Ot);
          if (ee(hi))
            return Ot < ht - 1 && hi === 13 && D.charCodeAt(Ot + 1) === 10 ? Ot + 2 : Ot + 1;
        }
        return -1;
      }
      var le = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, me = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ke = Object.prototype, ge = ke.hasOwnProperty, Ve = ke.toString, Oe = Object.hasOwn || function(D, be) {
        return ge.call(D, be);
      }, Ue = Array.isArray || function(D) {
        return Ve.call(D) === "[object Array]";
      }, we = /* @__PURE__ */ Object.create(null);
      function Ce(D) {
        return we[D] || (we[D] = new RegExp("^(?:" + D.replace(/ /g, "|") + ")$"));
      }
      function it(D) {
        return D <= 65535 ? String.fromCharCode(D) : (D -= 65536, String.fromCharCode((D >> 10) + 55296, (D & 1023) + 56320));
      }
      var ut = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, bt = function(be, ht) {
        this.line = be, this.column = ht;
      };
      bt.prototype.offset = function(be) {
        return new bt(this.line, this.column + be);
      };
      var pt = function(be, ht, Ot) {
        this.start = ht, this.end = Ot, be.sourceFile !== null && (this.source = be.sourceFile);
      };
      function Ke(D, be) {
        for (var ht = 1, Ot = 0; ; ) {
          var hi = te(D, Ot, be);
          if (hi < 0)
            return new bt(ht, be - Ot);
          ++ht, Ot = hi;
        }
      }
      var dt = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: !1,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: !1,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: !1,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: !0,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: !1,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callbackthat will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callbackthat will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: !1,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: !1
      }, ct = !1;
      function wt(D) {
        var be = {};
        for (var ht in dt)
          be[ht] = D && Oe(D, ht) ? D[ht] : dt[ht];
        if (be.ecmaVersion === "latest" ? be.ecmaVersion = 1e8 : be.ecmaVersion == null ? (!ct && typeof console == "object" && console.warn && (ct = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), be.ecmaVersion = 11) : be.ecmaVersion >= 2015 && (be.ecmaVersion -= 2009), be.allowReserved == null && (be.allowReserved = be.ecmaVersion < 5), (!D || D.allowHashBang == null) && (be.allowHashBang = be.ecmaVersion >= 14), Ue(be.onToken)) {
          var Ot = be.onToken;
          be.onToken = function(hi) {
            return Ot.push(hi);
          };
        }
        return Ue(be.onComment) && (be.onComment = Ht(be, be.onComment)), be;
      }
      function Ht(D, be) {
        return function(ht, Ot, hi, di, ki, er) {
          var _r = {
            type: ht ? "Block" : "Line",
            value: Ot,
            start: hi,
            end: di
          };
          D.locations && (_r.loc = new pt(this, ki, er)), D.ranges && (_r.range = [hi, di]), be.push(_r);
        };
      }
      var $t = 1, rt = 2, ri = 4, wi = 8, Qt = 16, At = 32, St = 64, Lt = 128, kt = 256, Ye = $t | rt | kt;
      function De(D, be) {
        return rt | (D ? ri : 0) | (be ? wi : 0);
      }
      var Re = 0, _t = 1, et = 2, Ie = 3, pe = 4, xt = 5, l = function(be, ht, Ot) {
        this.options = be = wt(be), this.sourceFile = be.sourceFile, this.keywords = Ce(Z[be.ecmaVersion >= 6 ? 6 : be.sourceType === "module" ? "5module" : 5]);
        var hi = "";
        be.allowReserved !== !0 && (hi = i[be.ecmaVersion >= 6 ? 6 : be.ecmaVersion === 5 ? 5 : 3], be.sourceType === "module" && (hi += " await")), this.reservedWords = Ce(hi);
        var di = (hi ? hi + " " : "") + i.strict;
        this.reservedWordsStrict = Ce(di), this.reservedWordsStrictBind = Ce(di + " " + i.strictBind), this.input = String(ht), this.containsEsc = !1, Ot ? (this.pos = Ot, this.lineStart = this.input.lastIndexOf(`
`, Ot - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(W).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = T.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = be.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && be.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope($t), this.regexpState = null, this.privateNameStack = [];
      }, _ = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
      l.prototype.parse = function() {
        var be = this.options.program || this.startNode();
        return this.nextToken(), this.parseTopLevel(be);
      }, _.inFunction.get = function() {
        return (this.currentVarScope().flags & rt) > 0;
      }, _.inGenerator.get = function() {
        return (this.currentVarScope().flags & wi) > 0 && !this.currentVarScope().inClassFieldInit;
      }, _.inAsync.get = function() {
        return (this.currentVarScope().flags & ri) > 0 && !this.currentVarScope().inClassFieldInit;
      }, _.canAwait.get = function() {
        for (var D = this.scopeStack.length - 1; D >= 0; D--) {
          var be = this.scopeStack[D];
          if (be.inClassFieldInit || be.flags & kt)
            return !1;
          if (be.flags & rt)
            return (be.flags & ri) > 0;
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      }, _.allowSuper.get = function() {
        var D = this.currentThisScope(), be = D.flags, ht = D.inClassFieldInit;
        return (be & St) > 0 || ht || this.options.allowSuperOutsideMethod;
      }, _.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & Lt) > 0;
      }, _.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }, _.allowNewDotTarget.get = function() {
        var D = this.currentThisScope(), be = D.flags, ht = D.inClassFieldInit;
        return (be & (rt | kt)) > 0 || ht;
      }, _.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & kt) > 0;
      }, l.extend = function() {
        for (var be = [], ht = arguments.length; ht--; ) be[ht] = arguments[ht];
        for (var Ot = this, hi = 0; hi < be.length; hi++)
          Ot = be[hi](Ot);
        return Ot;
      }, l.parse = function(be, ht) {
        return new this(ht, be).parse();
      }, l.parseExpressionAt = function(be, ht, Ot) {
        var hi = new this(Ot, be, ht);
        return hi.nextToken(), hi.parseExpression();
      }, l.tokenizer = function(be, ht) {
        return new this(ht, be);
      }, Object.defineProperties(l.prototype, _);
      var I = l.prototype, X = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
      I.strictDirective = function(D) {
        if (this.options.ecmaVersion < 5)
          return !1;
        for (; ; ) {
          me.lastIndex = D, D += me.exec(this.input)[0].length;
          var be = X.exec(this.input.slice(D));
          if (!be)
            return !1;
          if ((be[1] || be[2]) === "use strict") {
            me.lastIndex = D + be[0].length;
            var ht = me.exec(this.input), Ot = ht.index + ht[0].length, hi = this.input.charAt(Ot);
            return hi === ";" || hi === "}" || W.test(ht[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(hi) || hi === "!" && this.input.charAt(Ot + 1) === "=");
          }
          D += be[0].length, me.lastIndex = D, D += me.exec(this.input)[0].length, this.input[D] === ";" && D++;
        }
      }, I.eat = function(D) {
        return this.type === D ? (this.next(), !0) : !1;
      }, I.isContextual = function(D) {
        return this.type === T.name && this.value === D && !this.containsEsc;
      }, I.eatContextual = function(D) {
        return this.isContextual(D) ? (this.next(), !0) : !1;
      }, I.expectContextual = function(D) {
        this.eatContextual(D) || this.unexpected();
      }, I.canInsertSemicolon = function() {
        return this.type === T.eof || this.type === T.braceR || W.test(this.input.slice(this.lastTokEnd, this.start));
      }, I.insertSemicolon = function() {
        if (this.canInsertSemicolon())
          return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
      }, I.semicolon = function() {
        !this.eat(T.semi) && !this.insertSemicolon() && this.unexpected();
      }, I.afterTrailingComma = function(D, be) {
        if (this.type === D)
          return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), be || this.next(), !0;
      }, I.expect = function(D) {
        this.eat(D) || this.unexpected();
      }, I.unexpected = function(D) {
        this.raise(D ?? this.start, "Unexpected token");
      };
      var ne = function() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      I.checkPatternErrors = function(D, be) {
        if (D) {
          D.trailingComma > -1 && this.raiseRecoverable(D.trailingComma, "Comma is not permitted after the rest element");
          var ht = be ? D.parenthesizedAssign : D.parenthesizedBind;
          ht > -1 && this.raiseRecoverable(ht, be ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      }, I.checkExpressionErrors = function(D, be) {
        if (!D)
          return !1;
        var ht = D.shorthandAssign, Ot = D.doubleProto;
        if (!be)
          return ht >= 0 || Ot >= 0;
        ht >= 0 && this.raise(ht, "Shorthand property assignments are valid only in destructuring patterns"), Ot >= 0 && this.raiseRecoverable(Ot, "Redefinition of __proto__ property");
      }, I.checkYieldAwaitInDefaultParams = function() {
        this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
      }, I.isSimpleAssignTarget = function(D) {
        return D.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(D.expression) : D.type === "Identifier" || D.type === "MemberExpression";
      };
      var ue = l.prototype;
      ue.parseTopLevel = function(D) {
        var be = /* @__PURE__ */ Object.create(null);
        for (D.body || (D.body = []); this.type !== T.eof; ) {
          var ht = this.parseStatement(null, !0, be);
          D.body.push(ht);
        }
        if (this.inModule)
          for (var Ot = 0, hi = Object.keys(this.undefinedExports); Ot < hi.length; Ot += 1) {
            var di = hi[Ot];
            this.raiseRecoverable(this.undefinedExports[di].start, "Export '" + di + "' is not defined");
          }
        return this.adaptDirectivePrologue(D.body), this.next(), D.sourceType = this.options.sourceType, this.finishNode(D, "Program");
      };
      var Te = { kind: "loop" }, ye = { kind: "switch" };
      ue.isLet = function(D) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
          return !1;
        me.lastIndex = this.pos;
        var be = me.exec(this.input), ht = this.pos + be[0].length, Ot = this.input.charCodeAt(ht);
        if (Ot === 91 || Ot === 92)
          return !0;
        if (D)
          return !1;
        if (Ot === 123 || Ot > 55295 && Ot < 56320)
          return !0;
        if (m(Ot, !0)) {
          for (var hi = ht + 1; w(Ot = this.input.charCodeAt(hi), !0); )
            ++hi;
          if (Ot === 92 || Ot > 55295 && Ot < 56320)
            return !0;
          var di = this.input.slice(ht, hi);
          if (!R.test(di))
            return !0;
        }
        return !1;
      }, ue.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
          return !1;
        me.lastIndex = this.pos;
        var D = me.exec(this.input), be = this.pos + D[0].length, ht;
        return !W.test(this.input.slice(this.pos, be)) && this.input.slice(be, be + 8) === "function" && (be + 8 === this.input.length || !(w(ht = this.input.charCodeAt(be + 8)) || ht > 55295 && ht < 56320));
      }, ue.parseStatement = function(D, be, ht) {
        var Ot = this.type, hi = this.startNode(), di;
        switch (this.isLet(D) && (Ot = T._var, di = "let"), Ot) {
          case T._break:
          case T._continue:
            return this.parseBreakContinueStatement(hi, Ot.keyword);
          case T._debugger:
            return this.parseDebuggerStatement(hi);
          case T._do:
            return this.parseDoStatement(hi);
          case T._for:
            return this.parseForStatement(hi);
          case T._function:
            return D && (this.strict || D !== "if" && D !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(hi, !1, !D);
          case T._class:
            return D && this.unexpected(), this.parseClass(hi, !0);
          case T._if:
            return this.parseIfStatement(hi);
          case T._return:
            return this.parseReturnStatement(hi);
          case T._switch:
            return this.parseSwitchStatement(hi);
          case T._throw:
            return this.parseThrowStatement(hi);
          case T._try:
            return this.parseTryStatement(hi);
          case T._const:
          case T._var:
            return di = di || this.value, D && di !== "var" && this.unexpected(), this.parseVarStatement(hi, di);
          case T._while:
            return this.parseWhileStatement(hi);
          case T._with:
            return this.parseWithStatement(hi);
          case T.braceL:
            return this.parseBlock(!0, hi);
          case T.semi:
            return this.parseEmptyStatement(hi);
          case T._export:
          case T._import:
            if (this.options.ecmaVersion > 10 && Ot === T._import) {
              me.lastIndex = this.pos;
              var ki = me.exec(this.input), er = this.pos + ki[0].length, _r = this.input.charCodeAt(er);
              if (_r === 40 || _r === 46)
                return this.parseExpressionStatement(hi, this.parseExpression());
            }
            return this.options.allowImportExportEverywhere || (be || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), Ot === T._import ? this.parseImport(hi) : this.parseExport(hi, ht);
          // If the statement does not start with a statement keyword or a
          // brace, it's an ExpressionStatement or LabeledStatement. We
          // simply start parsing an expression, and afterwards, if the
          // next token is a colon and the expression was a simple
          // Identifier node, we switch to interpreting it as a label.
          default:
            if (this.isAsyncFunction())
              return D && this.unexpected(), this.next(), this.parseFunctionStatement(hi, !0, !D);
            var en = this.value, br = this.parseExpression();
            return Ot === T.name && br.type === "Identifier" && this.eat(T.colon) ? this.parseLabeledStatement(hi, en, br, D) : this.parseExpressionStatement(hi, br);
        }
      }, ue.parseBreakContinueStatement = function(D, be) {
        var ht = be === "break";
        this.next(), this.eat(T.semi) || this.insertSemicolon() ? D.label = null : this.type !== T.name ? this.unexpected() : (D.label = this.parseIdent(), this.semicolon());
        for (var Ot = 0; Ot < this.labels.length; ++Ot) {
          var hi = this.labels[Ot];
          if ((D.label == null || hi.name === D.label.name) && (hi.kind != null && (ht || hi.kind === "loop") || D.label && ht))
            break;
        }
        return Ot === this.labels.length && this.raise(D.start, "Unsyntactic " + be), this.finishNode(D, ht ? "BreakStatement" : "ContinueStatement");
      }, ue.parseDebuggerStatement = function(D) {
        return this.next(), this.semicolon(), this.finishNode(D, "DebuggerStatement");
      }, ue.parseDoStatement = function(D) {
        return this.next(), this.labels.push(Te), D.body = this.parseStatement("do"), this.labels.pop(), this.expect(T._while), D.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(T.semi) : this.semicolon(), this.finishNode(D, "DoWhileStatement");
      }, ue.parseForStatement = function(D) {
        this.next();
        var be = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        if (this.labels.push(Te), this.enterScope(0), this.expect(T.parenL), this.type === T.semi)
          return be > -1 && this.unexpected(be), this.parseFor(D, null);
        var ht = this.isLet();
        if (this.type === T._var || this.type === T._const || ht) {
          var Ot = this.startNode(), hi = ht ? "let" : this.value;
          return this.next(), this.parseVar(Ot, !0, hi), this.finishNode(Ot, "VariableDeclaration"), (this.type === T._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && Ot.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === T._in ? be > -1 && this.unexpected(be) : D.await = be > -1), this.parseForIn(D, Ot)) : (be > -1 && this.unexpected(be), this.parseFor(D, Ot));
        }
        var di = this.isContextual("let"), ki = !1, er = this.containsEsc, _r = new ne(), en = this.start, br = be > -1 ? this.parseExprSubscripts(_r, "await") : this.parseExpression(!0, _r);
        return this.type === T._in || (ki = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (be > -1 ? (this.type === T._in && this.unexpected(be), D.await = !0) : ki && this.options.ecmaVersion >= 8 && (br.start === en && !er && br.type === "Identifier" && br.name === "async" ? this.unexpected() : this.options.ecmaVersion >= 9 && (D.await = !1)), di && ki && this.raise(br.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(br, !1, _r), this.checkLValPattern(br), this.parseForIn(D, br)) : (this.checkExpressionErrors(_r, !0), be > -1 && this.unexpected(be), this.parseFor(D, br));
      }, ue.parseFunctionStatement = function(D, be, ht) {
        return this.next(), this.parseFunction(D, Ge | (ht ? 0 : Qe), !1, be);
      }, ue.parseIfStatement = function(D) {
        return this.next(), D.test = this.parseParenExpression(), D.consequent = this.parseStatement("if"), D.alternate = this.eat(T._else) ? this.parseStatement("if") : null, this.finishNode(D, "IfStatement");
      }, ue.parseReturnStatement = function(D) {
        return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(T.semi) || this.insertSemicolon() ? D.argument = null : (D.argument = this.parseExpression(), this.semicolon()), this.finishNode(D, "ReturnStatement");
      }, ue.parseSwitchStatement = function(D) {
        this.next(), D.discriminant = this.parseParenExpression(), D.cases = [], this.expect(T.braceL), this.labels.push(ye), this.enterScope(0);
        for (var be, ht = !1; this.type !== T.braceR; )
          if (this.type === T._case || this.type === T._default) {
            var Ot = this.type === T._case;
            be && this.finishNode(be, "SwitchCase"), D.cases.push(be = this.startNode()), be.consequent = [], this.next(), Ot ? be.test = this.parseExpression() : (ht && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), ht = !0, be.test = null), this.expect(T.colon);
          } else
            be || this.unexpected(), be.consequent.push(this.parseStatement(null));
        return this.exitScope(), be && this.finishNode(be, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(D, "SwitchStatement");
      }, ue.parseThrowStatement = function(D) {
        return this.next(), W.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), D.argument = this.parseExpression(), this.semicolon(), this.finishNode(D, "ThrowStatement");
      };
      var Me = [];
      ue.parseCatchClauseParam = function() {
        var D = this.parseBindingAtom(), be = D.type === "Identifier";
        return this.enterScope(be ? At : 0), this.checkLValPattern(D, be ? pe : et), this.expect(T.parenR), D;
      }, ue.parseTryStatement = function(D) {
        if (this.next(), D.block = this.parseBlock(), D.handler = null, this.type === T._catch) {
          var be = this.startNode();
          this.next(), this.eat(T.parenL) ? be.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), be.param = null, this.enterScope(0)), be.body = this.parseBlock(!1), this.exitScope(), D.handler = this.finishNode(be, "CatchClause");
        }
        return D.finalizer = this.eat(T._finally) ? this.parseBlock() : null, !D.handler && !D.finalizer && this.raise(D.start, "Missing catch or finally clause"), this.finishNode(D, "TryStatement");
      }, ue.parseVarStatement = function(D, be, ht) {
        return this.next(), this.parseVar(D, !1, be, ht), this.semicolon(), this.finishNode(D, "VariableDeclaration");
      }, ue.parseWhileStatement = function(D) {
        return this.next(), D.test = this.parseParenExpression(), this.labels.push(Te), D.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(D, "WhileStatement");
      }, ue.parseWithStatement = function(D) {
        return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), D.object = this.parseParenExpression(), D.body = this.parseStatement("with"), this.finishNode(D, "WithStatement");
      }, ue.parseEmptyStatement = function(D) {
        return this.next(), this.finishNode(D, "EmptyStatement");
      }, ue.parseLabeledStatement = function(D, be, ht, Ot) {
        for (var hi = 0, di = this.labels; hi < di.length; hi += 1) {
          var ki = di[hi];
          ki.name === be && this.raise(ht.start, "Label '" + be + "' is already declared");
        }
        for (var er = this.type.isLoop ? "loop" : this.type === T._switch ? "switch" : null, _r = this.labels.length - 1; _r >= 0; _r--) {
          var en = this.labels[_r];
          if (en.statementStart === D.start)
            en.statementStart = this.start, en.kind = er;
          else
            break;
        }
        return this.labels.push({ name: be, kind: er, statementStart: this.start }), D.body = this.parseStatement(Ot ? Ot.indexOf("label") === -1 ? Ot + "label" : Ot : "label"), this.labels.pop(), D.label = ht, this.finishNode(D, "LabeledStatement");
      }, ue.parseExpressionStatement = function(D, be) {
        return D.expression = be, this.semicolon(), this.finishNode(D, "ExpressionStatement");
      }, ue.parseBlock = function(D, be, ht) {
        for (D === void 0 && (D = !0), be === void 0 && (be = this.startNode()), be.body = [], this.expect(T.braceL), D && this.enterScope(0); this.type !== T.braceR; ) {
          var Ot = this.parseStatement(null);
          be.body.push(Ot);
        }
        return ht && (this.strict = !1), this.next(), D && this.exitScope(), this.finishNode(be, "BlockStatement");
      }, ue.parseFor = function(D, be) {
        return D.init = be, this.expect(T.semi), D.test = this.type === T.semi ? null : this.parseExpression(), this.expect(T.semi), D.update = this.type === T.parenR ? null : this.parseExpression(), this.expect(T.parenR), D.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(D, "ForStatement");
      }, ue.parseForIn = function(D, be) {
        var ht = this.type === T._in;
        return this.next(), be.type === "VariableDeclaration" && be.declarations[0].init != null && (!ht || this.options.ecmaVersion < 8 || this.strict || be.kind !== "var" || be.declarations[0].id.type !== "Identifier") && this.raise(
          be.start,
          (ht ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
        ), D.left = be, D.right = ht ? this.parseExpression() : this.parseMaybeAssign(), this.expect(T.parenR), D.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(D, ht ? "ForInStatement" : "ForOfStatement");
      }, ue.parseVar = function(D, be, ht, Ot) {
        for (D.declarations = [], D.kind = ht; ; ) {
          var hi = this.startNode();
          if (this.parseVarId(hi, ht), this.eat(T.eq) ? hi.init = this.parseMaybeAssign(be) : !Ot && ht === "const" && !(this.type === T._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !Ot && hi.id.type !== "Identifier" && !(be && (this.type === T._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : hi.init = null, D.declarations.push(this.finishNode(hi, "VariableDeclarator")), !this.eat(T.comma))
            break;
        }
        return D;
      }, ue.parseVarId = function(D, be) {
        D.id = this.parseBindingAtom(), this.checkLValPattern(D.id, be === "var" ? _t : et, !1);
      };
      var Ge = 1, Qe = 2, re = 4;
      ue.parseFunction = function(D, be, ht, Ot, hi) {
        this.initFunction(D), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !Ot) && (this.type === T.star && be & Qe && this.unexpected(), D.generator = this.eat(T.star)), this.options.ecmaVersion >= 8 && (D.async = !!Ot), be & Ge && (D.id = be & re && this.type !== T.name ? null : this.parseIdent(), D.id && !(be & Qe) && this.checkLValSimple(D.id, this.strict || D.generator || D.async ? this.treatFunctionsAsVar ? _t : et : Ie));
        var di = this.yieldPos, ki = this.awaitPos, er = this.awaitIdentPos;
        return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(De(D.async, D.generator)), be & Ge || (D.id = this.type === T.name ? this.parseIdent() : null), this.parseFunctionParams(D), this.parseFunctionBody(D, ht, !1, hi), this.yieldPos = di, this.awaitPos = ki, this.awaitIdentPos = er, this.finishNode(D, be & Ge ? "FunctionDeclaration" : "FunctionExpression");
      }, ue.parseFunctionParams = function(D) {
        this.expect(T.parenL), D.params = this.parseBindingList(T.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
      }, ue.parseClass = function(D, be) {
        this.next();
        var ht = this.strict;
        this.strict = !0, this.parseClassId(D, be), this.parseClassSuper(D);
        var Ot = this.enterClassBody(), hi = this.startNode(), di = !1;
        for (hi.body = [], this.expect(T.braceL); this.type !== T.braceR; ) {
          var ki = this.parseClassElement(D.superClass !== null);
          ki && (hi.body.push(ki), ki.type === "MethodDefinition" && ki.kind === "constructor" ? (di && this.raiseRecoverable(ki.start, "Duplicate constructor in the same class"), di = !0) : ki.key && ki.key.type === "PrivateIdentifier" && Se(Ot, ki) && this.raiseRecoverable(ki.key.start, "Identifier '#" + ki.key.name + "' has already been declared"));
        }
        return this.strict = ht, this.next(), D.body = this.finishNode(hi, "ClassBody"), this.exitClassBody(), this.finishNode(D, be ? "ClassDeclaration" : "ClassExpression");
      }, ue.parseClassElement = function(D) {
        if (this.eat(T.semi))
          return null;
        var be = this.options.ecmaVersion, ht = this.startNode(), Ot = "", hi = !1, di = !1, ki = "method", er = !1;
        if (this.eatContextual("static")) {
          if (be >= 13 && this.eat(T.braceL))
            return this.parseClassStaticBlock(ht), ht;
          this.isClassElementNameStart() || this.type === T.star ? er = !0 : Ot = "static";
        }
        if (ht.static = er, !Ot && be >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === T.star) && !this.canInsertSemicolon() ? di = !0 : Ot = "async"), !Ot && (be >= 9 || !di) && this.eat(T.star) && (hi = !0), !Ot && !di && !hi) {
          var _r = this.value;
          (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? ki = _r : Ot = _r);
        }
        if (Ot ? (ht.computed = !1, ht.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), ht.key.name = Ot, this.finishNode(ht.key, "Identifier")) : this.parseClassElementName(ht), be < 13 || this.type === T.parenL || ki !== "method" || hi || di) {
          var en = !ht.static && Pe(ht, "constructor"), br = en && D;
          en && ki !== "method" && this.raise(ht.key.start, "Constructor can't have get/set modifier"), ht.kind = en ? "constructor" : ki, this.parseClassMethod(ht, hi, di, br);
        } else
          this.parseClassField(ht);
        return ht;
      }, ue.isClassElementNameStart = function() {
        return this.type === T.name || this.type === T.privateId || this.type === T.num || this.type === T.string || this.type === T.bracketL || this.type.keyword;
      }, ue.parseClassElementName = function(D) {
        this.type === T.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), D.computed = !1, D.key = this.parsePrivateIdent()) : this.parsePropertyName(D);
      }, ue.parseClassMethod = function(D, be, ht, Ot) {
        var hi = D.key;
        D.kind === "constructor" ? (be && this.raise(hi.start, "Constructor can't be a generator"), ht && this.raise(hi.start, "Constructor can't be an async method")) : D.static && Pe(D, "prototype") && this.raise(hi.start, "Classes may not have a static property named prototype");
        var di = D.value = this.parseMethod(be, ht, Ot);
        return D.kind === "get" && di.params.length !== 0 && this.raiseRecoverable(di.start, "getter should have no params"), D.kind === "set" && di.params.length !== 1 && this.raiseRecoverable(di.start, "setter should have exactly one param"), D.kind === "set" && di.params[0].type === "RestElement" && this.raiseRecoverable(di.params[0].start, "Setter cannot use rest params"), this.finishNode(D, "MethodDefinition");
      }, ue.parseClassField = function(D) {
        if (Pe(D, "constructor") ? this.raise(D.key.start, "Classes can't have a field named 'constructor'") : D.static && Pe(D, "prototype") && this.raise(D.key.start, "Classes can't have a static field named 'prototype'"), this.eat(T.eq)) {
          var be = this.currentThisScope(), ht = be.inClassFieldInit;
          be.inClassFieldInit = !0, D.value = this.parseMaybeAssign(), be.inClassFieldInit = ht;
        } else
          D.value = null;
        return this.semicolon(), this.finishNode(D, "PropertyDefinition");
      }, ue.parseClassStaticBlock = function(D) {
        D.body = [];
        var be = this.labels;
        for (this.labels = [], this.enterScope(kt | St); this.type !== T.braceR; ) {
          var ht = this.parseStatement(null);
          D.body.push(ht);
        }
        return this.next(), this.exitScope(), this.labels = be, this.finishNode(D, "StaticBlock");
      }, ue.parseClassId = function(D, be) {
        this.type === T.name ? (D.id = this.parseIdent(), be && this.checkLValSimple(D.id, et, !1)) : (be === !0 && this.unexpected(), D.id = null);
      }, ue.parseClassSuper = function(D) {
        D.superClass = this.eat(T._extends) ? this.parseExprSubscripts(null, !1) : null;
      }, ue.enterClassBody = function() {
        var D = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        return this.privateNameStack.push(D), D.declared;
      }, ue.exitClassBody = function() {
        var D = this.privateNameStack.pop(), be = D.declared, ht = D.used;
        if (this.options.checkPrivateFields)
          for (var Ot = this.privateNameStack.length, hi = Ot === 0 ? null : this.privateNameStack[Ot - 1], di = 0; di < ht.length; ++di) {
            var ki = ht[di];
            Oe(be, ki.name) || (hi ? hi.used.push(ki) : this.raiseRecoverable(ki.start, "Private field '#" + ki.name + "' must be declared in an enclosing class"));
          }
      };
      function Se(D, be) {
        var ht = be.key.name, Ot = D[ht], hi = "true";
        return be.type === "MethodDefinition" && (be.kind === "get" || be.kind === "set") && (hi = (be.static ? "s" : "i") + be.kind), Ot === "iget" && hi === "iset" || Ot === "iset" && hi === "iget" || Ot === "sget" && hi === "sset" || Ot === "sset" && hi === "sget" ? (D[ht] = "true", !1) : Ot ? !0 : (D[ht] = hi, !1);
      }
      function Pe(D, be) {
        var ht = D.computed, Ot = D.key;
        return !ht && (Ot.type === "Identifier" && Ot.name === be || Ot.type === "Literal" && Ot.value === be);
      }
      ue.parseExportAllDeclaration = function(D, be) {
        return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (D.exported = this.parseModuleExportName(), this.checkExport(be, D.exported, this.lastTokStart)) : D.exported = null), this.expectContextual("from"), this.type !== T.string && this.unexpected(), D.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (D.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(D, "ExportAllDeclaration");
      }, ue.parseExport = function(D, be) {
        if (this.next(), this.eat(T.star))
          return this.parseExportAllDeclaration(D, be);
        if (this.eat(T._default))
          return this.checkExport(be, "default", this.lastTokStart), D.declaration = this.parseExportDefaultDeclaration(), this.finishNode(D, "ExportDefaultDeclaration");
        if (this.shouldParseExportStatement())
          D.declaration = this.parseExportDeclaration(D), D.declaration.type === "VariableDeclaration" ? this.checkVariableExport(be, D.declaration.declarations) : this.checkExport(be, D.declaration.id, D.declaration.id.start), D.specifiers = [], D.source = null;
        else {
          if (D.declaration = null, D.specifiers = this.parseExportSpecifiers(be), this.eatContextual("from"))
            this.type !== T.string && this.unexpected(), D.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (D.attributes = this.parseWithClause());
          else {
            for (var ht = 0, Ot = D.specifiers; ht < Ot.length; ht += 1) {
              var hi = Ot[ht];
              this.checkUnreserved(hi.local), this.checkLocalExport(hi.local), hi.local.type === "Literal" && this.raise(hi.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
            D.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(D, "ExportNamedDeclaration");
      }, ue.parseExportDeclaration = function(D) {
        return this.parseStatement(null);
      }, ue.parseExportDefaultDeclaration = function() {
        var D;
        if (this.type === T._function || (D = this.isAsyncFunction())) {
          var be = this.startNode();
          return this.next(), D && this.next(), this.parseFunction(be, Ge | re, !1, D);
        } else if (this.type === T._class) {
          var ht = this.startNode();
          return this.parseClass(ht, "nullableID");
        } else {
          var Ot = this.parseMaybeAssign();
          return this.semicolon(), Ot;
        }
      }, ue.checkExport = function(D, be, ht) {
        D && (typeof be != "string" && (be = be.type === "Identifier" ? be.name : be.value), Oe(D, be) && this.raiseRecoverable(ht, "Duplicate export '" + be + "'"), D[be] = !0);
      }, ue.checkPatternExport = function(D, be) {
        var ht = be.type;
        if (ht === "Identifier")
          this.checkExport(D, be, be.start);
        else if (ht === "ObjectPattern")
          for (var Ot = 0, hi = be.properties; Ot < hi.length; Ot += 1) {
            var di = hi[Ot];
            this.checkPatternExport(D, di);
          }
        else if (ht === "ArrayPattern")
          for (var ki = 0, er = be.elements; ki < er.length; ki += 1) {
            var _r = er[ki];
            _r && this.checkPatternExport(D, _r);
          }
        else ht === "Property" ? this.checkPatternExport(D, be.value) : ht === "AssignmentPattern" ? this.checkPatternExport(D, be.left) : ht === "RestElement" && this.checkPatternExport(D, be.argument);
      }, ue.checkVariableExport = function(D, be) {
        if (D)
          for (var ht = 0, Ot = be; ht < Ot.length; ht += 1) {
            var hi = Ot[ht];
            this.checkPatternExport(D, hi.id);
          }
      }, ue.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      }, ue.parseExportSpecifier = function(D) {
        var be = this.startNode();
        return be.local = this.parseModuleExportName(), be.exported = this.eatContextual("as") ? this.parseModuleExportName() : be.local, this.checkExport(
          D,
          be.exported,
          be.exported.start
        ), this.finishNode(be, "ExportSpecifier");
      }, ue.parseExportSpecifiers = function(D) {
        var be = [], ht = !0;
        for (this.expect(T.braceL); !this.eat(T.braceR); ) {
          if (ht)
            ht = !1;
          else if (this.expect(T.comma), this.afterTrailingComma(T.braceR))
            break;
          be.push(this.parseExportSpecifier(D));
        }
        return be;
      }, ue.parseImport = function(D) {
        return this.next(), this.type === T.string ? (D.specifiers = Me, D.source = this.parseExprAtom()) : (D.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), D.source = this.type === T.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (D.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(D, "ImportDeclaration");
      }, ue.parseImportSpecifier = function() {
        var D = this.startNode();
        return D.imported = this.parseModuleExportName(), this.eatContextual("as") ? D.local = this.parseIdent() : (this.checkUnreserved(D.imported), D.local = D.imported), this.checkLValSimple(D.local, et), this.finishNode(D, "ImportSpecifier");
      }, ue.parseImportDefaultSpecifier = function() {
        var D = this.startNode();
        return D.local = this.parseIdent(), this.checkLValSimple(D.local, et), this.finishNode(D, "ImportDefaultSpecifier");
      }, ue.parseImportNamespaceSpecifier = function() {
        var D = this.startNode();
        return this.next(), this.expectContextual("as"), D.local = this.parseIdent(), this.checkLValSimple(D.local, et), this.finishNode(D, "ImportNamespaceSpecifier");
      }, ue.parseImportSpecifiers = function() {
        var D = [], be = !0;
        if (this.type === T.name && (D.push(this.parseImportDefaultSpecifier()), !this.eat(T.comma)))
          return D;
        if (this.type === T.star)
          return D.push(this.parseImportNamespaceSpecifier()), D;
        for (this.expect(T.braceL); !this.eat(T.braceR); ) {
          if (be)
            be = !1;
          else if (this.expect(T.comma), this.afterTrailingComma(T.braceR))
            break;
          D.push(this.parseImportSpecifier());
        }
        return D;
      }, ue.parseWithClause = function() {
        var D = [];
        if (!this.eat(T._with))
          return D;
        this.expect(T.braceL);
        for (var be = {}, ht = !0; !this.eat(T.braceR); ) {
          if (ht)
            ht = !1;
          else if (this.expect(T.comma), this.afterTrailingComma(T.braceR))
            break;
          var Ot = this.parseImportAttribute(), hi = Ot.key.type === "Identifier" ? Ot.key.name : Ot.key.value;
          Oe(be, hi) && this.raiseRecoverable(Ot.key.start, "Duplicate attribute key '" + hi + "'"), be[hi] = !0, D.push(Ot);
        }
        return D;
      }, ue.parseImportAttribute = function() {
        var D = this.startNode();
        return D.key = this.type === T.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(T.colon), this.type !== T.string && this.unexpected(), D.value = this.parseExprAtom(), this.finishNode(D, "ImportAttribute");
      }, ue.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === T.string) {
          var D = this.parseLiteral(this.value);
          return ut.test(D.value) && this.raise(D.start, "An export name cannot include a lone surrogate."), D;
        }
        return this.parseIdent(!0);
      }, ue.adaptDirectivePrologue = function(D) {
        for (var be = 0; be < D.length && this.isDirectiveCandidate(D[be]); ++be)
          D[be].directive = D[be].expression.raw.slice(1, -1);
      }, ue.isDirectiveCandidate = function(D) {
        return this.options.ecmaVersion >= 5 && D.type === "ExpressionStatement" && D.expression.type === "Literal" && typeof D.expression.value == "string" && // Reject parenthesized strings.
        (this.input[D.start] === '"' || this.input[D.start] === "'");
      };
      var at = l.prototype;
      at.toAssignable = function(D, be, ht) {
        if (this.options.ecmaVersion >= 6 && D)
          switch (D.type) {
            case "Identifier":
              this.inAsync && D.name === "await" && this.raise(D.start, "Cannot use 'await' as identifier inside an async function");
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              D.type = "ObjectPattern", ht && this.checkPatternErrors(ht, !0);
              for (var Ot = 0, hi = D.properties; Ot < hi.length; Ot += 1) {
                var di = hi[Ot];
                this.toAssignable(di, be), di.type === "RestElement" && (di.argument.type === "ArrayPattern" || di.argument.type === "ObjectPattern") && this.raise(di.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              D.kind !== "init" && this.raise(D.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(D.value, be);
              break;
            case "ArrayExpression":
              D.type = "ArrayPattern", ht && this.checkPatternErrors(ht, !0), this.toAssignableList(D.elements, be);
              break;
            case "SpreadElement":
              D.type = "RestElement", this.toAssignable(D.argument, be), D.argument.type === "AssignmentPattern" && this.raise(D.argument.start, "Rest elements cannot have a default value");
              break;
            case "AssignmentExpression":
              D.operator !== "=" && this.raise(D.left.end, "Only '=' operator can be used for specifying default value."), D.type = "AssignmentPattern", delete D.operator, this.toAssignable(D.left, be);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(D.expression, be, ht);
              break;
            case "ChainExpression":
              this.raiseRecoverable(D.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!be)
                break;
            default:
              this.raise(D.start, "Assigning to rvalue");
          }
        else ht && this.checkPatternErrors(ht, !0);
        return D;
      }, at.toAssignableList = function(D, be) {
        for (var ht = D.length, Ot = 0; Ot < ht; Ot++) {
          var hi = D[Ot];
          hi && this.toAssignable(hi, be);
        }
        if (ht) {
          var di = D[ht - 1];
          this.options.ecmaVersion === 6 && be && di && di.type === "RestElement" && di.argument.type !== "Identifier" && this.unexpected(di.argument.start);
        }
        return D;
      }, at.parseSpread = function(D) {
        var be = this.startNode();
        return this.next(), be.argument = this.parseMaybeAssign(!1, D), this.finishNode(be, "SpreadElement");
      }, at.parseRestBinding = function() {
        var D = this.startNode();
        return this.next(), this.options.ecmaVersion === 6 && this.type !== T.name && this.unexpected(), D.argument = this.parseBindingAtom(), this.finishNode(D, "RestElement");
      }, at.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6)
          switch (this.type) {
            case T.bracketL:
              var D = this.startNode();
              return this.next(), D.elements = this.parseBindingList(T.bracketR, !0, !0), this.finishNode(D, "ArrayPattern");
            case T.braceL:
              return this.parseObj(!0);
          }
        return this.parseIdent();
      }, at.parseBindingList = function(D, be, ht, Ot) {
        for (var hi = [], di = !0; !this.eat(D); )
          if (di ? di = !1 : this.expect(T.comma), be && this.type === T.comma)
            hi.push(null);
          else {
            if (ht && this.afterTrailingComma(D))
              break;
            if (this.type === T.ellipsis) {
              var ki = this.parseRestBinding();
              this.parseBindingListItem(ki), hi.push(ki), this.type === T.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(D);
              break;
            } else
              hi.push(this.parseAssignableListItem(Ot));
          }
        return hi;
      }, at.parseAssignableListItem = function(D) {
        var be = this.parseMaybeDefault(this.start, this.startLoc);
        return this.parseBindingListItem(be), be;
      }, at.parseBindingListItem = function(D) {
        return D;
      }, at.parseMaybeDefault = function(D, be, ht) {
        if (ht = ht || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(T.eq))
          return ht;
        var Ot = this.startNodeAt(D, be);
        return Ot.left = ht, Ot.right = this.parseMaybeAssign(), this.finishNode(Ot, "AssignmentPattern");
      }, at.checkLValSimple = function(D, be, ht) {
        be === void 0 && (be = Re);
        var Ot = be !== Re;
        switch (D.type) {
          case "Identifier":
            this.strict && this.reservedWordsStrictBind.test(D.name) && this.raiseRecoverable(D.start, (Ot ? "Binding " : "Assigning to ") + D.name + " in strict mode"), Ot && (be === et && D.name === "let" && this.raiseRecoverable(D.start, "let is disallowed as a lexically bound name"), ht && (Oe(ht, D.name) && this.raiseRecoverable(D.start, "Argument name clash"), ht[D.name] = !0), be !== xt && this.declareName(D.name, be, D.start));
            break;
          case "ChainExpression":
            this.raiseRecoverable(D.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            Ot && this.raiseRecoverable(D.start, "Binding member expression");
            break;
          case "ParenthesizedExpression":
            return Ot && this.raiseRecoverable(D.start, "Binding parenthesized expression"), this.checkLValSimple(D.expression, be, ht);
          default:
            this.raise(D.start, (Ot ? "Binding" : "Assigning to") + " rvalue");
        }
      }, at.checkLValPattern = function(D, be, ht) {
        switch (be === void 0 && (be = Re), D.type) {
          case "ObjectPattern":
            for (var Ot = 0, hi = D.properties; Ot < hi.length; Ot += 1) {
              var di = hi[Ot];
              this.checkLValInnerPattern(di, be, ht);
            }
            break;
          case "ArrayPattern":
            for (var ki = 0, er = D.elements; ki < er.length; ki += 1) {
              var _r = er[ki];
              _r && this.checkLValInnerPattern(_r, be, ht);
            }
            break;
          default:
            this.checkLValSimple(D, be, ht);
        }
      }, at.checkLValInnerPattern = function(D, be, ht) {
        switch (be === void 0 && (be = Re), D.type) {
          case "Property":
            this.checkLValInnerPattern(D.value, be, ht);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(D.left, be, ht);
            break;
          case "RestElement":
            this.checkLValPattern(D.argument, be, ht);
            break;
          default:
            this.checkLValPattern(D, be, ht);
        }
      };
      var Be = function(be, ht, Ot, hi, di) {
        this.token = be, this.isExpr = !!ht, this.preserveSpace = !!Ot, this.override = hi, this.generator = !!di;
      }, Ze = {
        b_stat: new Be("{", !1),
        b_expr: new Be("{", !0),
        b_tmpl: new Be("${", !1),
        p_stat: new Be("(", !1),
        p_expr: new Be("(", !0),
        q_tmpl: new Be("`", !0, !0, function(D) {
          return D.tryReadTemplateToken();
        }),
        f_stat: new Be("function", !1),
        f_expr: new Be("function", !0),
        f_expr_gen: new Be("function", !0, !1, null, !0),
        f_gen: new Be("function", !1, !1, null, !0)
      }, fe = l.prototype;
      fe.initialContext = function() {
        return [Ze.b_stat];
      }, fe.curContext = function() {
        return this.context[this.context.length - 1];
      }, fe.braceIsBlock = function(D) {
        var be = this.curContext();
        return be === Ze.f_expr || be === Ze.f_stat ? !0 : D === T.colon && (be === Ze.b_stat || be === Ze.b_expr) ? !be.isExpr : D === T._return || D === T.name && this.exprAllowed ? W.test(this.input.slice(this.lastTokEnd, this.start)) : D === T._else || D === T.semi || D === T.eof || D === T.parenR || D === T.arrow ? !0 : D === T.braceL ? be === Ze.b_stat : D === T._var || D === T._const || D === T.name ? !1 : !this.exprAllowed;
      }, fe.inGeneratorContext = function() {
        for (var D = this.context.length - 1; D >= 1; D--) {
          var be = this.context[D];
          if (be.token === "function")
            return be.generator;
        }
        return !1;
      }, fe.updateContext = function(D) {
        var be, ht = this.type;
        ht.keyword && D === T.dot ? this.exprAllowed = !1 : (be = ht.updateContext) ? be.call(this, D) : this.exprAllowed = ht.beforeExpr;
      }, fe.overrideContext = function(D) {
        this.curContext() !== D && (this.context[this.context.length - 1] = D);
      }, T.parenR.updateContext = T.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = !0;
          return;
        }
        var D = this.context.pop();
        D === Ze.b_stat && this.curContext().token === "function" && (D = this.context.pop()), this.exprAllowed = !D.isExpr;
      }, T.braceL.updateContext = function(D) {
        this.context.push(this.braceIsBlock(D) ? Ze.b_stat : Ze.b_expr), this.exprAllowed = !0;
      }, T.dollarBraceL.updateContext = function() {
        this.context.push(Ze.b_tmpl), this.exprAllowed = !0;
      }, T.parenL.updateContext = function(D) {
        var be = D === T._if || D === T._for || D === T._with || D === T._while;
        this.context.push(be ? Ze.p_stat : Ze.p_expr), this.exprAllowed = !0;
      }, T.incDec.updateContext = function() {
      }, T._function.updateContext = T._class.updateContext = function(D) {
        D.beforeExpr && D !== T._else && !(D === T.semi && this.curContext() !== Ze.p_stat) && !(D === T._return && W.test(this.input.slice(this.lastTokEnd, this.start))) && !((D === T.colon || D === T.braceL) && this.curContext() === Ze.b_stat) ? this.context.push(Ze.f_expr) : this.context.push(Ze.f_stat), this.exprAllowed = !1;
      }, T.colon.updateContext = function() {
        this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
      }, T.backQuote.updateContext = function() {
        this.curContext() === Ze.q_tmpl ? this.context.pop() : this.context.push(Ze.q_tmpl), this.exprAllowed = !1;
      }, T.star.updateContext = function(D) {
        if (D === T._function) {
          var be = this.context.length - 1;
          this.context[be] === Ze.f_expr ? this.context[be] = Ze.f_expr_gen : this.context[be] = Ze.f_gen;
        }
        this.exprAllowed = !0;
      }, T.name.updateContext = function(D) {
        var be = !1;
        this.options.ecmaVersion >= 6 && D !== T.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (be = !0), this.exprAllowed = be;
      };
      var Je = l.prototype;
      Je.checkPropClash = function(D, be, ht) {
        if (!(this.options.ecmaVersion >= 9 && D.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (D.computed || D.method || D.shorthand))) {
          var Ot = D.key, hi;
          switch (Ot.type) {
            case "Identifier":
              hi = Ot.name;
              break;
            case "Literal":
              hi = String(Ot.value);
              break;
            default:
              return;
          }
          var di = D.kind;
          if (this.options.ecmaVersion >= 6) {
            hi === "__proto__" && di === "init" && (be.proto && (ht ? ht.doubleProto < 0 && (ht.doubleProto = Ot.start) : this.raiseRecoverable(Ot.start, "Redefinition of __proto__ property")), be.proto = !0);
            return;
          }
          hi = "$" + hi;
          var ki = be[hi];
          if (ki) {
            var er;
            di === "init" ? er = this.strict && ki.init || ki.get || ki.set : er = ki.init || ki[di], er && this.raiseRecoverable(Ot.start, "Redefinition of property");
          } else
            ki = be[hi] = {
              init: !1,
              get: !1,
              set: !1
            };
          ki[di] = !0;
        }
      }, Je.parseExpression = function(D, be) {
        var ht = this.start, Ot = this.startLoc, hi = this.parseMaybeAssign(D, be);
        if (this.type === T.comma) {
          var di = this.startNodeAt(ht, Ot);
          for (di.expressions = [hi]; this.eat(T.comma); )
            di.expressions.push(this.parseMaybeAssign(D, be));
          return this.finishNode(di, "SequenceExpression");
        }
        return hi;
      }, Je.parseMaybeAssign = function(D, be, ht) {
        if (this.isContextual("yield")) {
          if (this.inGenerator)
            return this.parseYield(D);
          this.exprAllowed = !1;
        }
        var Ot = !1, hi = -1, di = -1, ki = -1;
        be ? (hi = be.parenthesizedAssign, di = be.trailingComma, ki = be.doubleProto, be.parenthesizedAssign = be.trailingComma = -1) : (be = new ne(), Ot = !0);
        var er = this.start, _r = this.startLoc;
        (this.type === T.parenL || this.type === T.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = D === "await");
        var en = this.parseMaybeConditional(D, be);
        if (ht && (en = ht.call(this, en, er, _r)), this.type.isAssign) {
          var br = this.startNodeAt(er, _r);
          return br.operator = this.value, this.type === T.eq && (en = this.toAssignable(en, !1, be)), Ot || (be.parenthesizedAssign = be.trailingComma = be.doubleProto = -1), be.shorthandAssign >= en.start && (be.shorthandAssign = -1), this.type === T.eq ? this.checkLValPattern(en) : this.checkLValSimple(en), br.left = en, this.next(), br.right = this.parseMaybeAssign(D), ki > -1 && (be.doubleProto = ki), this.finishNode(br, "AssignmentExpression");
        } else
          Ot && this.checkExpressionErrors(be, !0);
        return hi > -1 && (be.parenthesizedAssign = hi), di > -1 && (be.trailingComma = di), en;
      }, Je.parseMaybeConditional = function(D, be) {
        var ht = this.start, Ot = this.startLoc, hi = this.parseExprOps(D, be);
        if (this.checkExpressionErrors(be))
          return hi;
        if (this.eat(T.question)) {
          var di = this.startNodeAt(ht, Ot);
          return di.test = hi, di.consequent = this.parseMaybeAssign(), this.expect(T.colon), di.alternate = this.parseMaybeAssign(D), this.finishNode(di, "ConditionalExpression");
        }
        return hi;
      }, Je.parseExprOps = function(D, be) {
        var ht = this.start, Ot = this.startLoc, hi = this.parseMaybeUnary(be, !1, !1, D);
        return this.checkExpressionErrors(be) || hi.start === ht && hi.type === "ArrowFunctionExpression" ? hi : this.parseExprOp(hi, ht, Ot, -1, D);
      }, Je.parseExprOp = function(D, be, ht, Ot, hi) {
        var di = this.type.binop;
        if (di != null && (!hi || this.type !== T._in) && di > Ot) {
          var ki = this.type === T.logicalOR || this.type === T.logicalAND, er = this.type === T.coalesce;
          er && (di = T.logicalAND.binop);
          var _r = this.value;
          this.next();
          var en = this.start, br = this.startLoc, Gn = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, hi), en, br, di, hi), Ia = this.buildBinary(be, ht, D, Gn, _r, ki || er);
          return (ki && this.type === T.coalesce || er && (this.type === T.logicalOR || this.type === T.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(Ia, be, ht, Ot, hi);
        }
        return D;
      }, Je.buildBinary = function(D, be, ht, Ot, hi, di) {
        Ot.type === "PrivateIdentifier" && this.raise(Ot.start, "Private identifier can only be left side of binary expression");
        var ki = this.startNodeAt(D, be);
        return ki.left = ht, ki.operator = hi, ki.right = Ot, this.finishNode(ki, di ? "LogicalExpression" : "BinaryExpression");
      }, Je.parseMaybeUnary = function(D, be, ht, Ot) {
        var hi = this.start, di = this.startLoc, ki;
        if (this.isContextual("await") && this.canAwait)
          ki = this.parseAwait(Ot), be = !0;
        else if (this.type.prefix) {
          var er = this.startNode(), _r = this.type === T.incDec;
          er.operator = this.value, er.prefix = !0, this.next(), er.argument = this.parseMaybeUnary(null, !0, _r, Ot), this.checkExpressionErrors(D, !0), _r ? this.checkLValSimple(er.argument) : this.strict && er.operator === "delete" && Xe(er.argument) ? this.raiseRecoverable(er.start, "Deleting local variable in strict mode") : er.operator === "delete" && z(er.argument) ? this.raiseRecoverable(er.start, "Private fields can not be deleted") : be = !0, ki = this.finishNode(er, _r ? "UpdateExpression" : "UnaryExpression");
        } else if (!be && this.type === T.privateId)
          (Ot || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), ki = this.parsePrivateIdent(), this.type !== T._in && this.unexpected();
        else {
          if (ki = this.parseExprSubscripts(D, Ot), this.checkExpressionErrors(D))
            return ki;
          for (; this.type.postfix && !this.canInsertSemicolon(); ) {
            var en = this.startNodeAt(hi, di);
            en.operator = this.value, en.prefix = !1, en.argument = ki, this.checkLValSimple(ki), this.next(), ki = this.finishNode(en, "UpdateExpression");
          }
        }
        if (!ht && this.eat(T.starstar))
          if (be)
            this.unexpected(this.lastTokStart);
          else
            return this.buildBinary(hi, di, ki, this.parseMaybeUnary(null, !1, !1, Ot), "**", !1);
        else
          return ki;
      };
      function Xe(D) {
        return D.type === "Identifier" || D.type === "ParenthesizedExpression" && Xe(D.expression);
      }
      function z(D) {
        return D.type === "MemberExpression" && D.property.type === "PrivateIdentifier" || D.type === "ChainExpression" && z(D.expression) || D.type === "ParenthesizedExpression" && z(D.expression);
      }
      Je.parseExprSubscripts = function(D, be) {
        var ht = this.start, Ot = this.startLoc, hi = this.parseExprAtom(D, be);
        if (hi.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
          return hi;
        var di = this.parseSubscripts(hi, ht, Ot, !1, be);
        return D && di.type === "MemberExpression" && (D.parenthesizedAssign >= di.start && (D.parenthesizedAssign = -1), D.parenthesizedBind >= di.start && (D.parenthesizedBind = -1), D.trailingComma >= di.start && (D.trailingComma = -1)), di;
      }, Je.parseSubscripts = function(D, be, ht, Ot, hi) {
        for (var di = this.options.ecmaVersion >= 8 && D.type === "Identifier" && D.name === "async" && this.lastTokEnd === D.end && !this.canInsertSemicolon() && D.end - D.start === 5 && this.potentialArrowAt === D.start, ki = !1; ; ) {
          var er = this.parseSubscript(D, be, ht, Ot, di, ki, hi);
          if (er.optional && (ki = !0), er === D || er.type === "ArrowFunctionExpression") {
            if (ki) {
              var _r = this.startNodeAt(be, ht);
              _r.expression = er, er = this.finishNode(_r, "ChainExpression");
            }
            return er;
          }
          D = er;
        }
      }, Je.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(T.arrow);
      }, Je.parseSubscriptAsyncArrow = function(D, be, ht, Ot) {
        return this.parseArrowExpression(this.startNodeAt(D, be), ht, !0, Ot);
      }, Je.parseSubscript = function(D, be, ht, Ot, hi, di, ki) {
        var er = this.options.ecmaVersion >= 11, _r = er && this.eat(T.questionDot);
        Ot && _r && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        var en = this.eat(T.bracketL);
        if (en || _r && this.type !== T.parenL && this.type !== T.backQuote || this.eat(T.dot)) {
          var br = this.startNodeAt(be, ht);
          br.object = D, en ? (br.property = this.parseExpression(), this.expect(T.bracketR)) : this.type === T.privateId && D.type !== "Super" ? br.property = this.parsePrivateIdent() : br.property = this.parseIdent(this.options.allowReserved !== "never"), br.computed = !!en, er && (br.optional = _r), D = this.finishNode(br, "MemberExpression");
        } else if (!Ot && this.eat(T.parenL)) {
          var Gn = new ne(), Ia = this.yieldPos, ls = this.awaitPos, Hn = this.awaitIdentPos;
          this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
          var Dn = this.parseExprList(T.parenR, this.options.ecmaVersion >= 8, !1, Gn);
          if (hi && !_r && this.shouldParseAsyncArrow())
            return this.checkPatternErrors(Gn, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = Ia, this.awaitPos = ls, this.awaitIdentPos = Hn, this.parseSubscriptAsyncArrow(be, ht, Dn, ki);
          this.checkExpressionErrors(Gn, !0), this.yieldPos = Ia || this.yieldPos, this.awaitPos = ls || this.awaitPos, this.awaitIdentPos = Hn || this.awaitIdentPos;
          var xs = this.startNodeAt(be, ht);
          xs.callee = D, xs.arguments = Dn, er && (xs.optional = _r), D = this.finishNode(xs, "CallExpression");
        } else if (this.type === T.backQuote) {
          (_r || di) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          var va = this.startNodeAt(be, ht);
          va.tag = D, va.quasi = this.parseTemplate({ isTagged: !0 }), D = this.finishNode(va, "TaggedTemplateExpression");
        }
        return D;
      }, Je.parseExprAtom = function(D, be, ht) {
        this.type === T.slash && this.readRegexp();
        var Ot, hi = this.potentialArrowAt === this.start;
        switch (this.type) {
          case T._super:
            return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), Ot = this.startNode(), this.next(), this.type === T.parenL && !this.allowDirectSuper && this.raise(Ot.start, "super() call outside constructor of a subclass"), this.type !== T.dot && this.type !== T.bracketL && this.type !== T.parenL && this.unexpected(), this.finishNode(Ot, "Super");
          case T._this:
            return Ot = this.startNode(), this.next(), this.finishNode(Ot, "ThisExpression");
          case T.name:
            var di = this.start, ki = this.startLoc, er = this.containsEsc, _r = this.parseIdent(!1);
            if (this.options.ecmaVersion >= 8 && !er && _r.name === "async" && !this.canInsertSemicolon() && this.eat(T._function))
              return this.overrideContext(Ze.f_expr), this.parseFunction(this.startNodeAt(di, ki), 0, !1, !0, be);
            if (hi && !this.canInsertSemicolon()) {
              if (this.eat(T.arrow))
                return this.parseArrowExpression(this.startNodeAt(di, ki), [_r], !1, be);
              if (this.options.ecmaVersion >= 8 && _r.name === "async" && this.type === T.name && !er && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
                return _r = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(T.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(di, ki), [_r], !0, be);
            }
            return _r;
          case T.regexp:
            var en = this.value;
            return Ot = this.parseLiteral(en.value), Ot.regex = { pattern: en.pattern, flags: en.flags }, Ot;
          case T.num:
          case T.string:
            return this.parseLiteral(this.value);
          case T._null:
          case T._true:
          case T._false:
            return Ot = this.startNode(), Ot.value = this.type === T._null ? null : this.type === T._true, Ot.raw = this.type.keyword, this.next(), this.finishNode(Ot, "Literal");
          case T.parenL:
            var br = this.start, Gn = this.parseParenAndDistinguishExpression(hi, be);
            return D && (D.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(Gn) && (D.parenthesizedAssign = br), D.parenthesizedBind < 0 && (D.parenthesizedBind = br)), Gn;
          case T.bracketL:
            return Ot = this.startNode(), this.next(), Ot.elements = this.parseExprList(T.bracketR, !0, !0, D), this.finishNode(Ot, "ArrayExpression");
          case T.braceL:
            return this.overrideContext(Ze.b_expr), this.parseObj(!1, D);
          case T._function:
            return Ot = this.startNode(), this.next(), this.parseFunction(Ot, 0);
          case T._class:
            return this.parseClass(this.startNode(), !1);
          case T._new:
            return this.parseNew();
          case T.backQuote:
            return this.parseTemplate();
          case T._import:
            return this.options.ecmaVersion >= 11 ? this.parseExprImport(ht) : this.unexpected();
          default:
            return this.parseExprAtomDefault();
        }
      }, Je.parseExprAtomDefault = function() {
        this.unexpected();
      }, Je.parseExprImport = function(D) {
        var be = this.startNode();
        if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === T.parenL && !D)
          return this.parseDynamicImport(be);
        if (this.type === T.dot) {
          var ht = this.startNodeAt(be.start, be.loc && be.loc.start);
          return ht.name = "import", be.meta = this.finishNode(ht, "Identifier"), this.parseImportMeta(be);
        } else
          this.unexpected();
      }, Je.parseDynamicImport = function(D) {
        if (this.next(), D.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16)
          this.eat(T.parenR) ? D.options = null : (this.expect(T.comma), this.afterTrailingComma(T.parenR) ? D.options = null : (D.options = this.parseMaybeAssign(), this.eat(T.parenR) || (this.expect(T.comma), this.afterTrailingComma(T.parenR) || this.unexpected())));
        else if (!this.eat(T.parenR)) {
          var be = this.start;
          this.eat(T.comma) && this.eat(T.parenR) ? this.raiseRecoverable(be, "Trailing comma is not allowed in import()") : this.unexpected(be);
        }
        return this.finishNode(D, "ImportExpression");
      }, Je.parseImportMeta = function(D) {
        this.next();
        var be = this.containsEsc;
        return D.property = this.parseIdent(!0), D.property.name !== "meta" && this.raiseRecoverable(D.property.start, "The only valid meta property for import is 'import.meta'"), be && this.raiseRecoverable(D.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(D.start, "Cannot use 'import.meta' outside a module"), this.finishNode(D, "MetaProperty");
      }, Je.parseLiteral = function(D) {
        var be = this.startNode();
        return be.value = D, be.raw = this.input.slice(this.start, this.end), be.raw.charCodeAt(be.raw.length - 1) === 110 && (be.bigint = be.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(be, "Literal");
      }, Je.parseParenExpression = function() {
        this.expect(T.parenL);
        var D = this.parseExpression();
        return this.expect(T.parenR), D;
      }, Je.shouldParseArrow = function(D) {
        return !this.canInsertSemicolon();
      }, Je.parseParenAndDistinguishExpression = function(D, be) {
        var ht = this.start, Ot = this.startLoc, hi, di = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var ki = this.start, er = this.startLoc, _r = [], en = !0, br = !1, Gn = new ne(), Ia = this.yieldPos, ls = this.awaitPos, Hn;
          for (this.yieldPos = 0, this.awaitPos = 0; this.type !== T.parenR; )
            if (en ? en = !1 : this.expect(T.comma), di && this.afterTrailingComma(T.parenR, !0)) {
              br = !0;
              break;
            } else if (this.type === T.ellipsis) {
              Hn = this.start, _r.push(this.parseParenItem(this.parseRestBinding())), this.type === T.comma && this.raiseRecoverable(
                this.start,
                "Comma is not permitted after the rest element"
              );
              break;
            } else
              _r.push(this.parseMaybeAssign(!1, Gn, this.parseParenItem));
          var Dn = this.lastTokEnd, xs = this.lastTokEndLoc;
          if (this.expect(T.parenR), D && this.shouldParseArrow(_r) && this.eat(T.arrow))
            return this.checkPatternErrors(Gn, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = Ia, this.awaitPos = ls, this.parseParenArrowList(ht, Ot, _r, be);
          (!_r.length || br) && this.unexpected(this.lastTokStart), Hn && this.unexpected(Hn), this.checkExpressionErrors(Gn, !0), this.yieldPos = Ia || this.yieldPos, this.awaitPos = ls || this.awaitPos, _r.length > 1 ? (hi = this.startNodeAt(ki, er), hi.expressions = _r, this.finishNodeAt(hi, "SequenceExpression", Dn, xs)) : hi = _r[0];
        } else
          hi = this.parseParenExpression();
        if (this.options.preserveParens) {
          var va = this.startNodeAt(ht, Ot);
          return va.expression = hi, this.finishNode(va, "ParenthesizedExpression");
        } else
          return hi;
      }, Je.parseParenItem = function(D) {
        return D;
      }, Je.parseParenArrowList = function(D, be, ht, Ot) {
        return this.parseArrowExpression(this.startNodeAt(D, be), ht, !1, Ot);
      };
      var He = [];
      Je.parseNew = function() {
        this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        var D = this.startNode();
        if (this.next(), this.options.ecmaVersion >= 6 && this.type === T.dot) {
          var be = this.startNodeAt(D.start, D.loc && D.loc.start);
          be.name = "new", D.meta = this.finishNode(be, "Identifier"), this.next();
          var ht = this.containsEsc;
          return D.property = this.parseIdent(!0), D.property.name !== "target" && this.raiseRecoverable(D.property.start, "The only valid meta property for new is 'new.target'"), ht && this.raiseRecoverable(D.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(D.start, "'new.target' can only be used in functions and class static block"), this.finishNode(D, "MetaProperty");
        }
        var Ot = this.start, hi = this.startLoc;
        return D.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), Ot, hi, !0, !1), this.eat(T.parenL) ? D.arguments = this.parseExprList(T.parenR, this.options.ecmaVersion >= 8, !1) : D.arguments = He, this.finishNode(D, "NewExpression");
      }, Je.parseTemplateElement = function(D) {
        var be = D.isTagged, ht = this.startNode();
        return this.type === T.invalidTemplate ? (be || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), ht.value = {
          raw: this.value.replace(/\r\n?/g, `
`),
          cooked: null
        }) : ht.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
          cooked: this.value
        }, this.next(), ht.tail = this.type === T.backQuote, this.finishNode(ht, "TemplateElement");
      }, Je.parseTemplate = function(D) {
        D === void 0 && (D = {});
        var be = D.isTagged;
        be === void 0 && (be = !1);
        var ht = this.startNode();
        this.next(), ht.expressions = [];
        var Ot = this.parseTemplateElement({ isTagged: be });
        for (ht.quasis = [Ot]; !Ot.tail; )
          this.type === T.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(T.dollarBraceL), ht.expressions.push(this.parseExpression()), this.expect(T.braceR), ht.quasis.push(Ot = this.parseTemplateElement({ isTagged: be }));
        return this.next(), this.finishNode(ht, "TemplateLiteral");
      }, Je.isAsyncProp = function(D) {
        return !D.computed && D.key.type === "Identifier" && D.key.name === "async" && (this.type === T.name || this.type === T.num || this.type === T.string || this.type === T.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === T.star) && !W.test(this.input.slice(this.lastTokEnd, this.start));
      }, Je.parseObj = function(D, be) {
        var ht = this.startNode(), Ot = !0, hi = {};
        for (ht.properties = [], this.next(); !this.eat(T.braceR); ) {
          if (Ot)
            Ot = !1;
          else if (this.expect(T.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(T.braceR))
            break;
          var di = this.parseProperty(D, be);
          D || this.checkPropClash(di, hi, be), ht.properties.push(di);
        }
        return this.finishNode(ht, D ? "ObjectPattern" : "ObjectExpression");
      }, Je.parseProperty = function(D, be) {
        var ht = this.startNode(), Ot, hi, di, ki;
        if (this.options.ecmaVersion >= 9 && this.eat(T.ellipsis))
          return D ? (ht.argument = this.parseIdent(!1), this.type === T.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(ht, "RestElement")) : (ht.argument = this.parseMaybeAssign(!1, be), this.type === T.comma && be && be.trailingComma < 0 && (be.trailingComma = this.start), this.finishNode(ht, "SpreadElement"));
        this.options.ecmaVersion >= 6 && (ht.method = !1, ht.shorthand = !1, (D || be) && (di = this.start, ki = this.startLoc), D || (Ot = this.eat(T.star)));
        var er = this.containsEsc;
        return this.parsePropertyName(ht), !D && !er && this.options.ecmaVersion >= 8 && !Ot && this.isAsyncProp(ht) ? (hi = !0, Ot = this.options.ecmaVersion >= 9 && this.eat(T.star), this.parsePropertyName(ht)) : hi = !1, this.parsePropertyValue(ht, D, Ot, hi, di, ki, be, er), this.finishNode(ht, "Property");
      }, Je.parseGetterSetter = function(D) {
        D.kind = D.key.name, this.parsePropertyName(D), D.value = this.parseMethod(!1);
        var be = D.kind === "get" ? 0 : 1;
        if (D.value.params.length !== be) {
          var ht = D.value.start;
          D.kind === "get" ? this.raiseRecoverable(ht, "getter should have no params") : this.raiseRecoverable(ht, "setter should have exactly one param");
        } else
          D.kind === "set" && D.value.params[0].type === "RestElement" && this.raiseRecoverable(D.value.params[0].start, "Setter cannot use rest params");
      }, Je.parsePropertyValue = function(D, be, ht, Ot, hi, di, ki, er) {
        (ht || Ot) && this.type === T.colon && this.unexpected(), this.eat(T.colon) ? (D.value = be ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, ki), D.kind = "init") : this.options.ecmaVersion >= 6 && this.type === T.parenL ? (be && this.unexpected(), D.kind = "init", D.method = !0, D.value = this.parseMethod(ht, Ot)) : !be && !er && this.options.ecmaVersion >= 5 && !D.computed && D.key.type === "Identifier" && (D.key.name === "get" || D.key.name === "set") && this.type !== T.comma && this.type !== T.braceR && this.type !== T.eq ? ((ht || Ot) && this.unexpected(), this.parseGetterSetter(D)) : this.options.ecmaVersion >= 6 && !D.computed && D.key.type === "Identifier" ? ((ht || Ot) && this.unexpected(), this.checkUnreserved(D.key), D.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = hi), D.kind = "init", be ? D.value = this.parseMaybeDefault(hi, di, this.copyNode(D.key)) : this.type === T.eq && ki ? (ki.shorthandAssign < 0 && (ki.shorthandAssign = this.start), D.value = this.parseMaybeDefault(hi, di, this.copyNode(D.key))) : D.value = this.copyNode(D.key), D.shorthand = !0) : this.unexpected();
      }, Je.parsePropertyName = function(D) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(T.bracketL))
            return D.computed = !0, D.key = this.parseMaybeAssign(), this.expect(T.bracketR), D.key;
          D.computed = !1;
        }
        return D.key = this.type === T.num || this.type === T.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      }, Je.initFunction = function(D) {
        D.id = null, this.options.ecmaVersion >= 6 && (D.generator = D.expression = !1), this.options.ecmaVersion >= 8 && (D.async = !1);
      }, Je.parseMethod = function(D, be, ht) {
        var Ot = this.startNode(), hi = this.yieldPos, di = this.awaitPos, ki = this.awaitIdentPos;
        return this.initFunction(Ot), this.options.ecmaVersion >= 6 && (Ot.generator = D), this.options.ecmaVersion >= 8 && (Ot.async = !!be), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(De(be, Ot.generator) | St | (ht ? Lt : 0)), this.expect(T.parenL), Ot.params = this.parseBindingList(T.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(Ot, !1, !0, !1), this.yieldPos = hi, this.awaitPos = di, this.awaitIdentPos = ki, this.finishNode(Ot, "FunctionExpression");
      }, Je.parseArrowExpression = function(D, be, ht, Ot) {
        var hi = this.yieldPos, di = this.awaitPos, ki = this.awaitIdentPos;
        return this.enterScope(De(ht, !1) | Qt), this.initFunction(D), this.options.ecmaVersion >= 8 && (D.async = !!ht), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, D.params = this.toAssignableList(be, !0), this.parseFunctionBody(D, !0, !1, Ot), this.yieldPos = hi, this.awaitPos = di, this.awaitIdentPos = ki, this.finishNode(D, "ArrowFunctionExpression");
      }, Je.parseFunctionBody = function(D, be, ht, Ot) {
        var hi = be && this.type !== T.braceL, di = this.strict, ki = !1;
        if (hi)
          D.body = this.parseMaybeAssign(Ot), D.expression = !0, this.checkParams(D, !1);
        else {
          var er = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(D.params);
          (!di || er) && (ki = this.strictDirective(this.end), ki && er && this.raiseRecoverable(D.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
          var _r = this.labels;
          this.labels = [], ki && (this.strict = !0), this.checkParams(D, !di && !ki && !be && !ht && this.isSimpleParamList(D.params)), this.strict && D.id && this.checkLValSimple(D.id, xt), D.body = this.parseBlock(!1, void 0, ki && !di), D.expression = !1, this.adaptDirectivePrologue(D.body.body), this.labels = _r;
        }
        this.exitScope();
      }, Je.isSimpleParamList = function(D) {
        for (var be = 0, ht = D; be < ht.length; be += 1) {
          var Ot = ht[be];
          if (Ot.type !== "Identifier")
            return !1;
        }
        return !0;
      }, Je.checkParams = function(D, be) {
        for (var ht = /* @__PURE__ */ Object.create(null), Ot = 0, hi = D.params; Ot < hi.length; Ot += 1) {
          var di = hi[Ot];
          this.checkLValInnerPattern(di, _t, be ? null : ht);
        }
      }, Je.parseExprList = function(D, be, ht, Ot) {
        for (var hi = [], di = !0; !this.eat(D); ) {
          if (di)
            di = !1;
          else if (this.expect(T.comma), be && this.afterTrailingComma(D))
            break;
          var ki = void 0;
          ht && this.type === T.comma ? ki = null : this.type === T.ellipsis ? (ki = this.parseSpread(Ot), Ot && this.type === T.comma && Ot.trailingComma < 0 && (Ot.trailingComma = this.start)) : ki = this.parseMaybeAssign(!1, Ot), hi.push(ki);
        }
        return hi;
      }, Je.checkUnreserved = function(D) {
        var be = D.start, ht = D.end, Ot = D.name;
        if (this.inGenerator && Ot === "yield" && this.raiseRecoverable(be, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && Ot === "await" && this.raiseRecoverable(be, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && Ot === "arguments" && this.raiseRecoverable(be, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (Ot === "arguments" || Ot === "await") && this.raise(be, "Cannot use " + Ot + " in class static initialization block"), this.keywords.test(Ot) && this.raise(be, "Unexpected keyword '" + Ot + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(be, ht).indexOf("\\") !== -1)) {
          var hi = this.strict ? this.reservedWordsStrict : this.reservedWords;
          hi.test(Ot) && (!this.inAsync && Ot === "await" && this.raiseRecoverable(be, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(be, "The keyword '" + Ot + "' is reserved"));
        }
      }, Je.parseIdent = function(D) {
        var be = this.parseIdentNode();
        return this.next(!!D), this.finishNode(be, "Identifier"), D || (this.checkUnreserved(be), be.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = be.start)), be;
      }, Je.parseIdentNode = function() {
        var D = this.startNode();
        return this.type === T.name ? D.name = this.value : this.type.keyword ? (D.name = this.type.keyword, (D.name === "class" || D.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = T.name) : this.unexpected(), D;
      }, Je.parsePrivateIdent = function() {
        var D = this.startNode();
        return this.type === T.privateId ? D.name = this.value : this.unexpected(), this.next(), this.finishNode(D, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(D.start, "Private field '#" + D.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(D)), D;
      }, Je.parseYield = function(D) {
        this.yieldPos || (this.yieldPos = this.start);
        var be = this.startNode();
        return this.next(), this.type === T.semi || this.canInsertSemicolon() || this.type !== T.star && !this.type.startsExpr ? (be.delegate = !1, be.argument = null) : (be.delegate = this.eat(T.star), be.argument = this.parseMaybeAssign(D)), this.finishNode(be, "YieldExpression");
      }, Je.parseAwait = function(D) {
        this.awaitPos || (this.awaitPos = this.start);
        var be = this.startNode();
        return this.next(), be.argument = this.parseMaybeUnary(null, !0, !1, D), this.finishNode(be, "AwaitExpression");
      };
      var nt = l.prototype;
      nt.raise = function(D, be) {
        var ht = Ke(this.input, D);
        be += " (" + ht.line + ":" + ht.column + ")";
        var Ot = new SyntaxError(be);
        throw Ot.pos = D, Ot.loc = ht, Ot.raisedAt = this.pos, Ot;
      }, nt.raiseRecoverable = nt.raise, nt.curPosition = function() {
        if (this.options.locations)
          return new bt(this.curLine, this.pos - this.lineStart);
      };
      var ae = l.prototype, $e = function(be) {
        this.flags = be, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
      };
      ae.enterScope = function(D) {
        this.scopeStack.push(new $e(D));
      }, ae.exitScope = function() {
        this.scopeStack.pop();
      }, ae.treatFunctionsAsVarInScope = function(D) {
        return D.flags & rt || !this.inModule && D.flags & $t;
      }, ae.declareName = function(D, be, ht) {
        var Ot = !1;
        if (be === et) {
          var hi = this.currentScope();
          Ot = hi.lexical.indexOf(D) > -1 || hi.functions.indexOf(D) > -1 || hi.var.indexOf(D) > -1, hi.lexical.push(D), this.inModule && hi.flags & $t && delete this.undefinedExports[D];
        } else if (be === pe) {
          var di = this.currentScope();
          di.lexical.push(D);
        } else if (be === Ie) {
          var ki = this.currentScope();
          this.treatFunctionsAsVar ? Ot = ki.lexical.indexOf(D) > -1 : Ot = ki.lexical.indexOf(D) > -1 || ki.var.indexOf(D) > -1, ki.functions.push(D);
        } else
          for (var er = this.scopeStack.length - 1; er >= 0; --er) {
            var _r = this.scopeStack[er];
            if (_r.lexical.indexOf(D) > -1 && !(_r.flags & At && _r.lexical[0] === D) || !this.treatFunctionsAsVarInScope(_r) && _r.functions.indexOf(D) > -1) {
              Ot = !0;
              break;
            }
            if (_r.var.push(D), this.inModule && _r.flags & $t && delete this.undefinedExports[D], _r.flags & Ye)
              break;
          }
        Ot && this.raiseRecoverable(ht, "Identifier '" + D + "' has already been declared");
      }, ae.checkLocalExport = function(D) {
        this.scopeStack[0].lexical.indexOf(D.name) === -1 && this.scopeStack[0].var.indexOf(D.name) === -1 && (this.undefinedExports[D.name] = D);
      }, ae.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      }, ae.currentVarScope = function() {
        for (var D = this.scopeStack.length - 1; ; D--) {
          var be = this.scopeStack[D];
          if (be.flags & Ye)
            return be;
        }
      }, ae.currentThisScope = function() {
        for (var D = this.scopeStack.length - 1; ; D--) {
          var be = this.scopeStack[D];
          if (be.flags & Ye && !(be.flags & Qt))
            return be;
        }
      };
      var Et = function(be, ht, Ot) {
        this.type = "", this.start = ht, this.end = 0, be.options.locations && (this.loc = new pt(be, Ot)), be.options.directSourceFile && (this.sourceFile = be.options.directSourceFile), be.options.ranges && (this.range = [ht, 0]);
      }, Nt = l.prototype;
      Nt.startNode = function() {
        return new Et(this, this.start, this.startLoc);
      }, Nt.startNodeAt = function(D, be) {
        return new Et(this, D, be);
      };
      function Yt(D, be, ht, Ot) {
        return D.type = be, D.end = ht, this.options.locations && (D.loc.end = Ot), this.options.ranges && (D.range[1] = ht), D;
      }
      Nt.finishNode = function(D, be) {
        return Yt.call(this, D, be, this.lastTokEnd, this.lastTokEndLoc);
      }, Nt.finishNodeAt = function(D, be, ht, Ot) {
        return Yt.call(this, D, be, ht, Ot);
      }, Nt.copyNode = function(D) {
        var be = new Et(this, D.start, this.startLoc);
        for (var ht in D)
          be[ht] = D[ht];
        return be;
      };
      var Ft = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz", ai = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Mt = ai + " Extended_Pictographic", Ae = Mt, Fe = Ae + " EBase EComp EMod EPres ExtPict", tt = Fe, Ct = tt, It = {
        9: ai,
        10: Mt,
        11: Ae,
        12: Fe,
        13: tt,
        14: Ct
      }, Ut = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", ti = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: Ut
      }, Pt = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Wt = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", ei = Wt + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", oi = ei + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", _i = oi + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", Di = _i + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", Bi = Di + " " + Ft, Hi = {
        9: Wt,
        10: ei,
        11: oi,
        12: _i,
        13: Di,
        14: Bi
      }, nr = {};
      function rr(D) {
        var be = nr[D] = {
          binary: Ce(It[D] + " " + Pt),
          binaryOfStrings: Ce(ti[D]),
          nonBinary: {
            General_Category: Ce(Pt),
            Script: Ce(Hi[D])
          }
        };
        be.nonBinary.Script_Extensions = be.nonBinary.Script, be.nonBinary.gc = be.nonBinary.General_Category, be.nonBinary.sc = be.nonBinary.Script, be.nonBinary.scx = be.nonBinary.Script_Extensions;
      }
      for (var dr = 0, Rr = [9, 10, 11, 12, 13, 14]; dr < Rr.length; dr += 1) {
        var Br = Rr[dr];
        rr(Br);
      }
      var Ki = l.prototype, Ir = function(be, ht) {
        this.parent = be, this.base = ht || this;
      };
      Ir.prototype.separatedFrom = function(be) {
        for (var ht = this; ht; ht = ht.parent)
          for (var Ot = be; Ot; Ot = Ot.parent)
            if (ht.base === Ot.base && ht !== Ot)
              return !0;
        return !1;
      }, Ir.prototype.sibling = function() {
        return new Ir(this.parent, this.base);
      };
      var Mr = function(be) {
        this.parser = be, this.validFlags = "gim" + (be.options.ecmaVersion >= 6 ? "uy" : "") + (be.options.ecmaVersion >= 9 ? "s" : "") + (be.options.ecmaVersion >= 13 ? "d" : "") + (be.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = nr[be.options.ecmaVersion >= 14 ? 14 : be.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
      };
      Mr.prototype.reset = function(be, ht, Ot) {
        var hi = Ot.indexOf("v") !== -1, di = Ot.indexOf("u") !== -1;
        this.start = be | 0, this.source = ht + "", this.flags = Ot, hi && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = di && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = di && this.parser.options.ecmaVersion >= 9);
      }, Mr.prototype.raise = function(be) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + be);
      }, Mr.prototype.at = function(be, ht) {
        ht === void 0 && (ht = !1);
        var Ot = this.source, hi = Ot.length;
        if (be >= hi)
          return -1;
        var di = Ot.charCodeAt(be);
        if (!(ht || this.switchU) || di <= 55295 || di >= 57344 || be + 1 >= hi)
          return di;
        var ki = Ot.charCodeAt(be + 1);
        return ki >= 56320 && ki <= 57343 ? (di << 10) + ki - 56613888 : di;
      }, Mr.prototype.nextIndex = function(be, ht) {
        ht === void 0 && (ht = !1);
        var Ot = this.source, hi = Ot.length;
        if (be >= hi)
          return hi;
        var di = Ot.charCodeAt(be), ki;
        return !(ht || this.switchU) || di <= 55295 || di >= 57344 || be + 1 >= hi || (ki = Ot.charCodeAt(be + 1)) < 56320 || ki > 57343 ? be + 1 : be + 2;
      }, Mr.prototype.current = function(be) {
        return be === void 0 && (be = !1), this.at(this.pos, be);
      }, Mr.prototype.lookahead = function(be) {
        return be === void 0 && (be = !1), this.at(this.nextIndex(this.pos, be), be);
      }, Mr.prototype.advance = function(be) {
        be === void 0 && (be = !1), this.pos = this.nextIndex(this.pos, be);
      }, Mr.prototype.eat = function(be, ht) {
        return ht === void 0 && (ht = !1), this.current(ht) === be ? (this.advance(ht), !0) : !1;
      }, Mr.prototype.eatChars = function(be, ht) {
        ht === void 0 && (ht = !1);
        for (var Ot = this.pos, hi = 0, di = be; hi < di.length; hi += 1) {
          var ki = di[hi], er = this.at(Ot, ht);
          if (er === -1 || er !== ki)
            return !1;
          Ot = this.nextIndex(Ot, ht);
        }
        return this.pos = Ot, !0;
      }, Ki.validateRegExpFlags = function(D) {
        for (var be = D.validFlags, ht = D.flags, Ot = !1, hi = !1, di = 0; di < ht.length; di++) {
          var ki = ht.charAt(di);
          be.indexOf(ki) === -1 && this.raise(D.start, "Invalid regular expression flag"), ht.indexOf(ki, di + 1) > -1 && this.raise(D.start, "Duplicate regular expression flag"), ki === "u" && (Ot = !0), ki === "v" && (hi = !0);
        }
        this.options.ecmaVersion >= 15 && Ot && hi && this.raise(D.start, "Invalid regular expression flag");
      };
      function wn(D) {
        for (var be in D)
          return !0;
        return !1;
      }
      Ki.validateRegExpPattern = function(D) {
        this.regexp_pattern(D), !D.switchN && this.options.ecmaVersion >= 9 && wn(D.groupNames) && (D.switchN = !0, this.regexp_pattern(D));
      }, Ki.regexp_pattern = function(D) {
        D.pos = 0, D.lastIntValue = 0, D.lastStringValue = "", D.lastAssertionIsQuantifiable = !1, D.numCapturingParens = 0, D.maxBackReference = 0, D.groupNames = /* @__PURE__ */ Object.create(null), D.backReferenceNames.length = 0, D.branchID = null, this.regexp_disjunction(D), D.pos !== D.source.length && (D.eat(
          41
          /* ) */
        ) && D.raise("Unmatched ')'"), (D.eat(
          93
          /* ] */
        ) || D.eat(
          125
          /* } */
        )) && D.raise("Lone quantifier brackets")), D.maxBackReference > D.numCapturingParens && D.raise("Invalid escape");
        for (var be = 0, ht = D.backReferenceNames; be < ht.length; be += 1) {
          var Ot = ht[be];
          D.groupNames[Ot] || D.raise("Invalid named capture referenced");
        }
      }, Ki.regexp_disjunction = function(D) {
        var be = this.options.ecmaVersion >= 16;
        for (be && (D.branchID = new Ir(D.branchID, null)), this.regexp_alternative(D); D.eat(
          124
          /* | */
        ); )
          be && (D.branchID = D.branchID.sibling()), this.regexp_alternative(D);
        be && (D.branchID = D.branchID.parent), this.regexp_eatQuantifier(D, !0) && D.raise("Nothing to repeat"), D.eat(
          123
          /* { */
        ) && D.raise("Lone quantifier brackets");
      }, Ki.regexp_alternative = function(D) {
        for (; D.pos < D.source.length && this.regexp_eatTerm(D); )
          ;
      }, Ki.regexp_eatTerm = function(D) {
        return this.regexp_eatAssertion(D) ? (D.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(D) && D.switchU && D.raise("Invalid quantifier"), !0) : (D.switchU ? this.regexp_eatAtom(D) : this.regexp_eatExtendedAtom(D)) ? (this.regexp_eatQuantifier(D), !0) : !1;
      }, Ki.regexp_eatAssertion = function(D) {
        var be = D.pos;
        if (D.lastAssertionIsQuantifiable = !1, D.eat(
          94
          /* ^ */
        ) || D.eat(
          36
          /* $ */
        ))
          return !0;
        if (D.eat(
          92
          /* \ */
        )) {
          if (D.eat(
            66
            /* B */
          ) || D.eat(
            98
            /* b */
          ))
            return !0;
          D.pos = be;
        }
        if (D.eat(
          40
          /* ( */
        ) && D.eat(
          63
          /* ? */
        )) {
          var ht = !1;
          if (this.options.ecmaVersion >= 9 && (ht = D.eat(
            60
            /* < */
          )), D.eat(
            61
            /* = */
          ) || D.eat(
            33
            /* ! */
          ))
            return this.regexp_disjunction(D), D.eat(
              41
              /* ) */
            ) || D.raise("Unterminated group"), D.lastAssertionIsQuantifiable = !ht, !0;
        }
        return D.pos = be, !1;
      }, Ki.regexp_eatQuantifier = function(D, be) {
        return be === void 0 && (be = !1), this.regexp_eatQuantifierPrefix(D, be) ? (D.eat(
          63
          /* ? */
        ), !0) : !1;
      }, Ki.regexp_eatQuantifierPrefix = function(D, be) {
        return D.eat(
          42
          /* * */
        ) || D.eat(
          43
          /* + */
        ) || D.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(D, be);
      }, Ki.regexp_eatBracedQuantifier = function(D, be) {
        var ht = D.pos;
        if (D.eat(
          123
          /* { */
        )) {
          var Ot = 0, hi = -1;
          if (this.regexp_eatDecimalDigits(D) && (Ot = D.lastIntValue, D.eat(
            44
            /* , */
          ) && this.regexp_eatDecimalDigits(D) && (hi = D.lastIntValue), D.eat(
            125
            /* } */
          )))
            return hi !== -1 && hi < Ot && !be && D.raise("numbers out of order in {} quantifier"), !0;
          D.switchU && !be && D.raise("Incomplete quantifier"), D.pos = ht;
        }
        return !1;
      }, Ki.regexp_eatAtom = function(D) {
        return this.regexp_eatPatternCharacters(D) || D.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(D) || this.regexp_eatCharacterClass(D) || this.regexp_eatUncapturingGroup(D) || this.regexp_eatCapturingGroup(D);
      }, Ki.regexp_eatReverseSolidusAtomEscape = function(D) {
        var be = D.pos;
        if (D.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(D))
            return !0;
          D.pos = be;
        }
        return !1;
      }, Ki.regexp_eatUncapturingGroup = function(D) {
        var be = D.pos;
        if (D.eat(
          40
          /* ( */
        )) {
          if (D.eat(
            63
            /* ? */
          )) {
            if (this.options.ecmaVersion >= 16) {
              var ht = this.regexp_eatModifiers(D), Ot = D.eat(
                45
                /* - */
              );
              if (ht || Ot) {
                for (var hi = 0; hi < ht.length; hi++) {
                  var di = ht.charAt(hi);
                  ht.indexOf(di, hi + 1) > -1 && D.raise("Duplicate regular expression modifiers");
                }
                if (Ot) {
                  var ki = this.regexp_eatModifiers(D);
                  !ht && !ki && D.current() === 58 && D.raise("Invalid regular expression modifiers");
                  for (var er = 0; er < ki.length; er++) {
                    var _r = ki.charAt(er);
                    (ki.indexOf(_r, er + 1) > -1 || ht.indexOf(_r) > -1) && D.raise("Duplicate regular expression modifiers");
                  }
                }
              }
            }
            if (D.eat(
              58
              /* : */
            )) {
              if (this.regexp_disjunction(D), D.eat(
                41
                /* ) */
              ))
                return !0;
              D.raise("Unterminated group");
            }
          }
          D.pos = be;
        }
        return !1;
      }, Ki.regexp_eatCapturingGroup = function(D) {
        if (D.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(D) : D.current() === 63 && D.raise("Invalid group"), this.regexp_disjunction(D), D.eat(
            41
            /* ) */
          ))
            return D.numCapturingParens += 1, !0;
          D.raise("Unterminated group");
        }
        return !1;
      }, Ki.regexp_eatModifiers = function(D) {
        for (var be = "", ht = 0; (ht = D.current()) !== -1 && xn(ht); )
          be += it(ht), D.advance();
        return be;
      };
      function xn(D) {
        return D === 105 || D === 109 || D === 115;
      }
      Ki.regexp_eatExtendedAtom = function(D) {
        return D.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(D) || this.regexp_eatCharacterClass(D) || this.regexp_eatUncapturingGroup(D) || this.regexp_eatCapturingGroup(D) || this.regexp_eatInvalidBracedQuantifier(D) || this.regexp_eatExtendedPatternCharacter(D);
      }, Ki.regexp_eatInvalidBracedQuantifier = function(D) {
        return this.regexp_eatBracedQuantifier(D, !0) && D.raise("Nothing to repeat"), !1;
      }, Ki.regexp_eatSyntaxCharacter = function(D) {
        var be = D.current();
        return En(be) ? (D.lastIntValue = be, D.advance(), !0) : !1;
      };
      function En(D) {
        return D === 36 || D >= 40 && D <= 43 || D === 46 || D === 63 || D >= 91 && D <= 94 || D >= 123 && D <= 125;
      }
      Ki.regexp_eatPatternCharacters = function(D) {
        for (var be = D.pos, ht = 0; (ht = D.current()) !== -1 && !En(ht); )
          D.advance();
        return D.pos !== be;
      }, Ki.regexp_eatExtendedPatternCharacter = function(D) {
        var be = D.current();
        return be !== -1 && be !== 36 && !(be >= 40 && be <= 43) && be !== 46 && be !== 63 && be !== 91 && be !== 94 && be !== 124 ? (D.advance(), !0) : !1;
      }, Ki.regexp_groupSpecifier = function(D) {
        if (D.eat(
          63
          /* ? */
        )) {
          this.regexp_eatGroupName(D) || D.raise("Invalid group");
          var be = this.options.ecmaVersion >= 16, ht = D.groupNames[D.lastStringValue];
          if (ht)
            if (be)
              for (var Ot = 0, hi = ht; Ot < hi.length; Ot += 1) {
                var di = hi[Ot];
                di.separatedFrom(D.branchID) || D.raise("Duplicate capture group name");
              }
            else
              D.raise("Duplicate capture group name");
          be ? (ht || (D.groupNames[D.lastStringValue] = [])).push(D.branchID) : D.groupNames[D.lastStringValue] = !0;
        }
      }, Ki.regexp_eatGroupName = function(D) {
        if (D.lastStringValue = "", D.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(D) && D.eat(
            62
            /* > */
          ))
            return !0;
          D.raise("Invalid capture group name");
        }
        return !1;
      }, Ki.regexp_eatRegExpIdentifierName = function(D) {
        if (D.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(D)) {
          for (D.lastStringValue += it(D.lastIntValue); this.regexp_eatRegExpIdentifierPart(D); )
            D.lastStringValue += it(D.lastIntValue);
          return !0;
        }
        return !1;
      }, Ki.regexp_eatRegExpIdentifierStart = function(D) {
        var be = D.pos, ht = this.options.ecmaVersion >= 11, Ot = D.current(ht);
        return D.advance(ht), Ot === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(D, ht) && (Ot = D.lastIntValue), Vn(Ot) ? (D.lastIntValue = Ot, !0) : (D.pos = be, !1);
      };
      function Vn(D) {
        return m(D, !0) || D === 36 || D === 95;
      }
      Ki.regexp_eatRegExpIdentifierPart = function(D) {
        var be = D.pos, ht = this.options.ecmaVersion >= 11, Ot = D.current(ht);
        return D.advance(ht), Ot === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(D, ht) && (Ot = D.lastIntValue), Yn(Ot) ? (D.lastIntValue = Ot, !0) : (D.pos = be, !1);
      };
      function Yn(D) {
        return w(D, !0) || D === 36 || D === 95 || D === 8204 || D === 8205;
      }
      Ki.regexp_eatAtomEscape = function(D) {
        return this.regexp_eatBackReference(D) || this.regexp_eatCharacterClassEscape(D) || this.regexp_eatCharacterEscape(D) || D.switchN && this.regexp_eatKGroupName(D) ? !0 : (D.switchU && (D.current() === 99 && D.raise("Invalid unicode escape"), D.raise("Invalid escape")), !1);
      }, Ki.regexp_eatBackReference = function(D) {
        var be = D.pos;
        if (this.regexp_eatDecimalEscape(D)) {
          var ht = D.lastIntValue;
          if (D.switchU)
            return ht > D.maxBackReference && (D.maxBackReference = ht), !0;
          if (ht <= D.numCapturingParens)
            return !0;
          D.pos = be;
        }
        return !1;
      }, Ki.regexp_eatKGroupName = function(D) {
        if (D.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(D))
            return D.backReferenceNames.push(D.lastStringValue), !0;
          D.raise("Invalid named reference");
        }
        return !1;
      }, Ki.regexp_eatCharacterEscape = function(D) {
        return this.regexp_eatControlEscape(D) || this.regexp_eatCControlLetter(D) || this.regexp_eatZero(D) || this.regexp_eatHexEscapeSequence(D) || this.regexp_eatRegExpUnicodeEscapeSequence(D, !1) || !D.switchU && this.regexp_eatLegacyOctalEscapeSequence(D) || this.regexp_eatIdentityEscape(D);
      }, Ki.regexp_eatCControlLetter = function(D) {
        var be = D.pos;
        if (D.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(D))
            return !0;
          D.pos = be;
        }
        return !1;
      }, Ki.regexp_eatZero = function(D) {
        return D.current() === 48 && !La(D.lookahead()) ? (D.lastIntValue = 0, D.advance(), !0) : !1;
      }, Ki.regexp_eatControlEscape = function(D) {
        var be = D.current();
        return be === 116 ? (D.lastIntValue = 9, D.advance(), !0) : be === 110 ? (D.lastIntValue = 10, D.advance(), !0) : be === 118 ? (D.lastIntValue = 11, D.advance(), !0) : be === 102 ? (D.lastIntValue = 12, D.advance(), !0) : be === 114 ? (D.lastIntValue = 13, D.advance(), !0) : !1;
      }, Ki.regexp_eatControlLetter = function(D) {
        var be = D.current();
        return ka(be) ? (D.lastIntValue = be % 32, D.advance(), !0) : !1;
      };
      function ka(D) {
        return D >= 65 && D <= 90 || D >= 97 && D <= 122;
      }
      Ki.regexp_eatRegExpUnicodeEscapeSequence = function(D, be) {
        be === void 0 && (be = !1);
        var ht = D.pos, Ot = be || D.switchU;
        if (D.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(D, 4)) {
            var hi = D.lastIntValue;
            if (Ot && hi >= 55296 && hi <= 56319) {
              var di = D.pos;
              if (D.eat(
                92
                /* \ */
              ) && D.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(D, 4)) {
                var ki = D.lastIntValue;
                if (ki >= 56320 && ki <= 57343)
                  return D.lastIntValue = (hi - 55296) * 1024 + (ki - 56320) + 65536, !0;
              }
              D.pos = di, D.lastIntValue = hi;
            }
            return !0;
          }
          if (Ot && D.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(D) && D.eat(
            125
            /* } */
          ) && ea(D.lastIntValue))
            return !0;
          Ot && D.raise("Invalid unicode escape"), D.pos = ht;
        }
        return !1;
      };
      function ea(D) {
        return D >= 0 && D <= 1114111;
      }
      Ki.regexp_eatIdentityEscape = function(D) {
        if (D.switchU)
          return this.regexp_eatSyntaxCharacter(D) ? !0 : D.eat(
            47
            /* / */
          ) ? (D.lastIntValue = 47, !0) : !1;
        var be = D.current();
        return be !== 99 && (!D.switchN || be !== 107) ? (D.lastIntValue = be, D.advance(), !0) : !1;
      }, Ki.regexp_eatDecimalEscape = function(D) {
        D.lastIntValue = 0;
        var be = D.current();
        if (be >= 49 && be <= 57) {
          do
            D.lastIntValue = 10 * D.lastIntValue + (be - 48), D.advance();
          while ((be = D.current()) >= 48 && be <= 57);
          return !0;
        }
        return !1;
      };
      var ga = 0, Ta = 1, ha = 2;
      Ki.regexp_eatCharacterClassEscape = function(D) {
        var be = D.current();
        if (Bo(be))
          return D.lastIntValue = -1, D.advance(), Ta;
        var ht = !1;
        if (D.switchU && this.options.ecmaVersion >= 9 && ((ht = be === 80) || be === 112)) {
          D.lastIntValue = -1, D.advance();
          var Ot;
          if (D.eat(
            123
            /* { */
          ) && (Ot = this.regexp_eatUnicodePropertyValueExpression(D)) && D.eat(
            125
            /* } */
          ))
            return ht && Ot === ha && D.raise("Invalid property name"), Ot;
          D.raise("Invalid property name");
        }
        return ga;
      };
      function Bo(D) {
        return D === 100 || D === 68 || D === 115 || D === 83 || D === 119 || D === 87;
      }
      Ki.regexp_eatUnicodePropertyValueExpression = function(D) {
        var be = D.pos;
        if (this.regexp_eatUnicodePropertyName(D) && D.eat(
          61
          /* = */
        )) {
          var ht = D.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(D)) {
            var Ot = D.lastStringValue;
            return this.regexp_validateUnicodePropertyNameAndValue(D, ht, Ot), Ta;
          }
        }
        if (D.pos = be, this.regexp_eatLoneUnicodePropertyNameOrValue(D)) {
          var hi = D.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(D, hi);
        }
        return ga;
      }, Ki.regexp_validateUnicodePropertyNameAndValue = function(D, be, ht) {
        Oe(D.unicodeProperties.nonBinary, be) || D.raise("Invalid property name"), D.unicodeProperties.nonBinary[be].test(ht) || D.raise("Invalid property value");
      }, Ki.regexp_validateUnicodePropertyNameOrValue = function(D, be) {
        if (D.unicodeProperties.binary.test(be))
          return Ta;
        if (D.switchV && D.unicodeProperties.binaryOfStrings.test(be))
          return ha;
        D.raise("Invalid property name");
      }, Ki.regexp_eatUnicodePropertyName = function(D) {
        var be = 0;
        for (D.lastStringValue = ""; Ao(be = D.current()); )
          D.lastStringValue += it(be), D.advance();
        return D.lastStringValue !== "";
      };
      function Ao(D) {
        return ka(D) || D === 95;
      }
      Ki.regexp_eatUnicodePropertyValue = function(D) {
        var be = 0;
        for (D.lastStringValue = ""; za(be = D.current()); )
          D.lastStringValue += it(be), D.advance();
        return D.lastStringValue !== "";
      };
      function za(D) {
        return Ao(D) || La(D);
      }
      Ki.regexp_eatLoneUnicodePropertyNameOrValue = function(D) {
        return this.regexp_eatUnicodePropertyValue(D);
      }, Ki.regexp_eatCharacterClass = function(D) {
        if (D.eat(
          91
          /* [ */
        )) {
          var be = D.eat(
            94
            /* ^ */
          ), ht = this.regexp_classContents(D);
          return D.eat(
            93
            /* ] */
          ) || D.raise("Unterminated character class"), be && ht === ha && D.raise("Negated character class may contain strings"), !0;
        }
        return !1;
      }, Ki.regexp_classContents = function(D) {
        return D.current() === 93 ? Ta : D.switchV ? this.regexp_classSetExpression(D) : (this.regexp_nonEmptyClassRanges(D), Ta);
      }, Ki.regexp_nonEmptyClassRanges = function(D) {
        for (; this.regexp_eatClassAtom(D); ) {
          var be = D.lastIntValue;
          if (D.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(D)) {
            var ht = D.lastIntValue;
            D.switchU && (be === -1 || ht === -1) && D.raise("Invalid character class"), be !== -1 && ht !== -1 && be > ht && D.raise("Range out of order in character class");
          }
        }
      }, Ki.regexp_eatClassAtom = function(D) {
        var be = D.pos;
        if (D.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(D))
            return !0;
          if (D.switchU) {
            var ht = D.current();
            (ht === 99 || mo(ht)) && D.raise("Invalid class escape"), D.raise("Invalid escape");
          }
          D.pos = be;
        }
        var Ot = D.current();
        return Ot !== 93 ? (D.lastIntValue = Ot, D.advance(), !0) : !1;
      }, Ki.regexp_eatClassEscape = function(D) {
        var be = D.pos;
        if (D.eat(
          98
          /* b */
        ))
          return D.lastIntValue = 8, !0;
        if (D.switchU && D.eat(
          45
          /* - */
        ))
          return D.lastIntValue = 45, !0;
        if (!D.switchU && D.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(D))
            return !0;
          D.pos = be;
        }
        return this.regexp_eatCharacterClassEscape(D) || this.regexp_eatCharacterEscape(D);
      }, Ki.regexp_classSetExpression = function(D) {
        var be = Ta, ht;
        if (!this.regexp_eatClassSetRange(D)) if (ht = this.regexp_eatClassSetOperand(D)) {
          ht === ha && (be = ha);
          for (var Ot = D.pos; D.eatChars(
            [38, 38]
            /* && */
          ); ) {
            if (D.current() !== 38 && (ht = this.regexp_eatClassSetOperand(D))) {
              ht !== ha && (be = Ta);
              continue;
            }
            D.raise("Invalid character in character class");
          }
          if (Ot !== D.pos)
            return be;
          for (; D.eatChars(
            [45, 45]
            /* -- */
          ); )
            this.regexp_eatClassSetOperand(D) || D.raise("Invalid character in character class");
          if (Ot !== D.pos)
            return be;
        } else
          D.raise("Invalid character in character class");
        for (; ; )
          if (!this.regexp_eatClassSetRange(D)) {
            if (ht = this.regexp_eatClassSetOperand(D), !ht)
              return be;
            ht === ha && (be = ha);
          }
      }, Ki.regexp_eatClassSetRange = function(D) {
        var be = D.pos;
        if (this.regexp_eatClassSetCharacter(D)) {
          var ht = D.lastIntValue;
          if (D.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(D)) {
            var Ot = D.lastIntValue;
            return ht !== -1 && Ot !== -1 && ht > Ot && D.raise("Range out of order in character class"), !0;
          }
          D.pos = be;
        }
        return !1;
      }, Ki.regexp_eatClassSetOperand = function(D) {
        return this.regexp_eatClassSetCharacter(D) ? Ta : this.regexp_eatClassStringDisjunction(D) || this.regexp_eatNestedClass(D);
      }, Ki.regexp_eatNestedClass = function(D) {
        var be = D.pos;
        if (D.eat(
          91
          /* [ */
        )) {
          var ht = D.eat(
            94
            /* ^ */
          ), Ot = this.regexp_classContents(D);
          if (D.eat(
            93
            /* ] */
          ))
            return ht && Ot === ha && D.raise("Negated character class may contain strings"), Ot;
          D.pos = be;
        }
        if (D.eat(
          92
          /* \ */
        )) {
          var hi = this.regexp_eatCharacterClassEscape(D);
          if (hi)
            return hi;
          D.pos = be;
        }
        return null;
      }, Ki.regexp_eatClassStringDisjunction = function(D) {
        var be = D.pos;
        if (D.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (D.eat(
            123
            /* { */
          )) {
            var ht = this.regexp_classStringDisjunctionContents(D);
            if (D.eat(
              125
              /* } */
            ))
              return ht;
          } else
            D.raise("Invalid escape");
          D.pos = be;
        }
        return null;
      }, Ki.regexp_classStringDisjunctionContents = function(D) {
        for (var be = this.regexp_classString(D); D.eat(
          124
          /* | */
        ); )
          this.regexp_classString(D) === ha && (be = ha);
        return be;
      }, Ki.regexp_classString = function(D) {
        for (var be = 0; this.regexp_eatClassSetCharacter(D); )
          be++;
        return be === 1 ? Ta : ha;
      }, Ki.regexp_eatClassSetCharacter = function(D) {
        var be = D.pos;
        if (D.eat(
          92
          /* \ */
        ))
          return this.regexp_eatCharacterEscape(D) || this.regexp_eatClassSetReservedPunctuator(D) ? !0 : D.eat(
            98
            /* b */
          ) ? (D.lastIntValue = 8, !0) : (D.pos = be, !1);
        var ht = D.current();
        return ht < 0 || ht === D.lookahead() && ss(ht) || os(ht) ? !1 : (D.advance(), D.lastIntValue = ht, !0);
      };
      function ss(D) {
        return D === 33 || D >= 35 && D <= 38 || D >= 42 && D <= 44 || D === 46 || D >= 58 && D <= 64 || D === 94 || D === 96 || D === 126;
      }
      function os(D) {
        return D === 40 || D === 41 || D === 45 || D === 47 || D >= 91 && D <= 93 || D >= 123 && D <= 125;
      }
      Ki.regexp_eatClassSetReservedPunctuator = function(D) {
        var be = D.current();
        return Ms(be) ? (D.lastIntValue = be, D.advance(), !0) : !1;
      };
      function Ms(D) {
        return D === 33 || D === 35 || D === 37 || D === 38 || D === 44 || D === 45 || D >= 58 && D <= 62 || D === 64 || D === 96 || D === 126;
      }
      Ki.regexp_eatClassControlLetter = function(D) {
        var be = D.current();
        return La(be) || be === 95 ? (D.lastIntValue = be % 32, D.advance(), !0) : !1;
      }, Ki.regexp_eatHexEscapeSequence = function(D) {
        var be = D.pos;
        if (D.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(D, 2))
            return !0;
          D.switchU && D.raise("Invalid escape"), D.pos = be;
        }
        return !1;
      }, Ki.regexp_eatDecimalDigits = function(D) {
        var be = D.pos, ht = 0;
        for (D.lastIntValue = 0; La(ht = D.current()); )
          D.lastIntValue = 10 * D.lastIntValue + (ht - 48), D.advance();
        return D.pos !== be;
      };
      function La(D) {
        return D >= 48 && D <= 57;
      }
      Ki.regexp_eatHexDigits = function(D) {
        var be = D.pos, ht = 0;
        for (D.lastIntValue = 0; mn(ht = D.current()); )
          D.lastIntValue = 16 * D.lastIntValue + eo(ht), D.advance();
        return D.pos !== be;
      };
      function mn(D) {
        return D >= 48 && D <= 57 || D >= 65 && D <= 70 || D >= 97 && D <= 102;
      }
      function eo(D) {
        return D >= 65 && D <= 70 ? 10 + (D - 65) : D >= 97 && D <= 102 ? 10 + (D - 97) : D - 48;
      }
      Ki.regexp_eatLegacyOctalEscapeSequence = function(D) {
        if (this.regexp_eatOctalDigit(D)) {
          var be = D.lastIntValue;
          if (this.regexp_eatOctalDigit(D)) {
            var ht = D.lastIntValue;
            be <= 3 && this.regexp_eatOctalDigit(D) ? D.lastIntValue = be * 64 + ht * 8 + D.lastIntValue : D.lastIntValue = be * 8 + ht;
          } else
            D.lastIntValue = be;
          return !0;
        }
        return !1;
      }, Ki.regexp_eatOctalDigit = function(D) {
        var be = D.current();
        return mo(be) ? (D.lastIntValue = be - 48, D.advance(), !0) : (D.lastIntValue = 0, !1);
      };
      function mo(D) {
        return D >= 48 && D <= 55;
      }
      Ki.regexp_eatFixedHexDigits = function(D, be) {
        var ht = D.pos;
        D.lastIntValue = 0;
        for (var Ot = 0; Ot < be; ++Ot) {
          var hi = D.current();
          if (!mn(hi))
            return D.pos = ht, !1;
          D.lastIntValue = 16 * D.lastIntValue + eo(hi), D.advance();
        }
        return !0;
      };
      var Ba = function(be) {
        this.type = be.type, this.value = be.value, this.start = be.start, this.end = be.end, be.options.locations && (this.loc = new pt(be, be.startLoc, be.endLoc)), be.options.ranges && (this.range = [be.start, be.end]);
      }, tn = l.prototype;
      tn.next = function(D) {
        !D && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Ba(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
      }, tn.getToken = function() {
        return this.next(), new Ba(this);
      }, typeof Symbol < "u" && (tn[Symbol.iterator] = function() {
        var D = this;
        return {
          next: function() {
            var be = D.getToken();
            return {
              done: be.type === T.eof,
              value: be
            };
          }
        };
      }), tn.nextToken = function() {
        var D = this.curContext();
        if ((!D || !D.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
          return this.finishToken(T.eof);
        if (D.override)
          return D.override(this);
        this.readToken(this.fullCharCodeAtPos());
      }, tn.readToken = function(D) {
        return m(D, this.options.ecmaVersion >= 6) || D === 92 ? this.readWord() : this.getTokenFromCode(D);
      }, tn.fullCharCodeAtPos = function() {
        var D = this.input.charCodeAt(this.pos);
        if (D <= 55295 || D >= 56320)
          return D;
        var be = this.input.charCodeAt(this.pos + 1);
        return be <= 56319 || be >= 57344 ? D : (D << 10) + be - 56613888;
      }, tn.skipBlockComment = function() {
        var D = this.options.onComment && this.curPosition(), be = this.pos, ht = this.input.indexOf("*/", this.pos += 2);
        if (ht === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = ht + 2, this.options.locations)
          for (var Ot = void 0, hi = be; (Ot = te(this.input, hi, this.pos)) > -1; )
            ++this.curLine, hi = this.lineStart = Ot;
        this.options.onComment && this.options.onComment(
          !0,
          this.input.slice(be + 2, ht),
          be,
          this.pos,
          D,
          this.curPosition()
        );
      }, tn.skipLineComment = function(D) {
        for (var be = this.pos, ht = this.options.onComment && this.curPosition(), Ot = this.input.charCodeAt(this.pos += D); this.pos < this.input.length && !ee(Ot); )
          Ot = this.input.charCodeAt(++this.pos);
        this.options.onComment && this.options.onComment(
          !1,
          this.input.slice(be + D, this.pos),
          be,
          this.pos,
          ht,
          this.curPosition()
        );
      }, tn.skipSpace = function() {
        e: for (; this.pos < this.input.length; ) {
          var D = this.input.charCodeAt(this.pos);
          switch (D) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break e;
              }
              break;
            default:
              if (D > 8 && D < 14 || D >= 5760 && le.test(String.fromCharCode(D)))
                ++this.pos;
              else
                break e;
          }
        }
      }, tn.finishToken = function(D, be) {
        this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
        var ht = this.type;
        this.type = D, this.value = be, this.updateContext(ht);
      }, tn.readToken_dot = function() {
        var D = this.input.charCodeAt(this.pos + 1);
        if (D >= 48 && D <= 57)
          return this.readNumber(!0);
        var be = this.input.charCodeAt(this.pos + 2);
        return this.options.ecmaVersion >= 6 && D === 46 && be === 46 ? (this.pos += 3, this.finishToken(T.ellipsis)) : (++this.pos, this.finishToken(T.dot));
      }, tn.readToken_slash = function() {
        var D = this.input.charCodeAt(this.pos + 1);
        return this.exprAllowed ? (++this.pos, this.readRegexp()) : D === 61 ? this.finishOp(T.assign, 2) : this.finishOp(T.slash, 1);
      }, tn.readToken_mult_modulo_exp = function(D) {
        var be = this.input.charCodeAt(this.pos + 1), ht = 1, Ot = D === 42 ? T.star : T.modulo;
        return this.options.ecmaVersion >= 7 && D === 42 && be === 42 && (++ht, Ot = T.starstar, be = this.input.charCodeAt(this.pos + 2)), be === 61 ? this.finishOp(T.assign, ht + 1) : this.finishOp(Ot, ht);
      }, tn.readToken_pipe_amp = function(D) {
        var be = this.input.charCodeAt(this.pos + 1);
        if (be === D) {
          if (this.options.ecmaVersion >= 12) {
            var ht = this.input.charCodeAt(this.pos + 2);
            if (ht === 61)
              return this.finishOp(T.assign, 3);
          }
          return this.finishOp(D === 124 ? T.logicalOR : T.logicalAND, 2);
        }
        return be === 61 ? this.finishOp(T.assign, 2) : this.finishOp(D === 124 ? T.bitwiseOR : T.bitwiseAND, 1);
      }, tn.readToken_caret = function() {
        var D = this.input.charCodeAt(this.pos + 1);
        return D === 61 ? this.finishOp(T.assign, 2) : this.finishOp(T.bitwiseXOR, 1);
      }, tn.readToken_plus_min = function(D) {
        var be = this.input.charCodeAt(this.pos + 1);
        return be === D ? be === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || W.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(T.incDec, 2) : be === 61 ? this.finishOp(T.assign, 2) : this.finishOp(T.plusMin, 1);
      }, tn.readToken_lt_gt = function(D) {
        var be = this.input.charCodeAt(this.pos + 1), ht = 1;
        return be === D ? (ht = D === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + ht) === 61 ? this.finishOp(T.assign, ht + 1) : this.finishOp(T.bitShift, ht)) : be === 33 && D === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (be === 61 && (ht = 2), this.finishOp(T.relational, ht));
      }, tn.readToken_eq_excl = function(D) {
        var be = this.input.charCodeAt(this.pos + 1);
        return be === 61 ? this.finishOp(T.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : D === 61 && be === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(T.arrow)) : this.finishOp(D === 61 ? T.eq : T.prefix, 1);
      }, tn.readToken_question = function() {
        var D = this.options.ecmaVersion;
        if (D >= 11) {
          var be = this.input.charCodeAt(this.pos + 1);
          if (be === 46) {
            var ht = this.input.charCodeAt(this.pos + 2);
            if (ht < 48 || ht > 57)
              return this.finishOp(T.questionDot, 2);
          }
          if (be === 63) {
            if (D >= 12) {
              var Ot = this.input.charCodeAt(this.pos + 2);
              if (Ot === 61)
                return this.finishOp(T.assign, 3);
            }
            return this.finishOp(T.coalesce, 2);
          }
        }
        return this.finishOp(T.question, 1);
      }, tn.readToken_numberSign = function() {
        var D = this.options.ecmaVersion, be = 35;
        if (D >= 13 && (++this.pos, be = this.fullCharCodeAtPos(), m(be, !0) || be === 92))
          return this.finishToken(T.privateId, this.readWord1());
        this.raise(this.pos, "Unexpected character '" + it(be) + "'");
      }, tn.getTokenFromCode = function(D) {
        switch (D) {
          // The interpretation of a dot depends on whether it is followed
          // by a digit or another two dots.
          case 46:
            return this.readToken_dot();
          // Punctuation tokens.
          case 40:
            return ++this.pos, this.finishToken(T.parenL);
          case 41:
            return ++this.pos, this.finishToken(T.parenR);
          case 59:
            return ++this.pos, this.finishToken(T.semi);
          case 44:
            return ++this.pos, this.finishToken(T.comma);
          case 91:
            return ++this.pos, this.finishToken(T.bracketL);
          case 93:
            return ++this.pos, this.finishToken(T.bracketR);
          case 123:
            return ++this.pos, this.finishToken(T.braceL);
          case 125:
            return ++this.pos, this.finishToken(T.braceR);
          case 58:
            return ++this.pos, this.finishToken(T.colon);
          case 96:
            if (this.options.ecmaVersion < 6)
              break;
            return ++this.pos, this.finishToken(T.backQuote);
          case 48:
            var be = this.input.charCodeAt(this.pos + 1);
            if (be === 120 || be === 88)
              return this.readRadixNumber(16);
            if (this.options.ecmaVersion >= 6) {
              if (be === 111 || be === 79)
                return this.readRadixNumber(8);
              if (be === 98 || be === 66)
                return this.readRadixNumber(2);
            }
          // Anything else beginning with a digit is an integer, octal
          // number, or float.
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(!1);
          // Quotes produce strings.
          case 34:
          case 39:
            return this.readString(D);
          // Operators are parsed inline in tiny state machines. '=' (61) is
          // often referred to. `finishOp` simply skips the amount of
          // characters it is given as second argument, and returns a token
          // of the type given by its first argument.
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(D);
          case 124:
          case 38:
            return this.readToken_pipe_amp(D);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(D);
          case 60:
          case 62:
            return this.readToken_lt_gt(D);
          case 61:
          case 33:
            return this.readToken_eq_excl(D);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(T.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + it(D) + "'");
      }, tn.finishOp = function(D, be) {
        var ht = this.input.slice(this.pos, this.pos + be);
        return this.pos += be, this.finishToken(D, ht);
      }, tn.readRegexp = function() {
        for (var D, be, ht = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(ht, "Unterminated regular expression");
          var Ot = this.input.charAt(this.pos);
          if (W.test(Ot) && this.raise(ht, "Unterminated regular expression"), D)
            D = !1;
          else {
            if (Ot === "[")
              be = !0;
            else if (Ot === "]" && be)
              be = !1;
            else if (Ot === "/" && !be)
              break;
            D = Ot === "\\";
          }
          ++this.pos;
        }
        var hi = this.input.slice(ht, this.pos);
        ++this.pos;
        var di = this.pos, ki = this.readWord1();
        this.containsEsc && this.unexpected(di);
        var er = this.regexpState || (this.regexpState = new Mr(this));
        er.reset(ht, hi, ki), this.validateRegExpFlags(er), this.validateRegExpPattern(er);
        var _r = null;
        try {
          _r = new RegExp(hi, ki);
        } catch {
        }
        return this.finishToken(T.regexp, { pattern: hi, flags: ki, value: _r });
      }, tn.readInt = function(D, be, ht) {
        for (var Ot = this.options.ecmaVersion >= 12 && be === void 0, hi = ht && this.input.charCodeAt(this.pos) === 48, di = this.pos, ki = 0, er = 0, _r = 0, en = be ?? 1 / 0; _r < en; ++_r, ++this.pos) {
          var br = this.input.charCodeAt(this.pos), Gn = void 0;
          if (Ot && br === 95) {
            hi && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), er === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), _r === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), er = br;
            continue;
          }
          if (br >= 97 ? Gn = br - 97 + 10 : br >= 65 ? Gn = br - 65 + 10 : br >= 48 && br <= 57 ? Gn = br - 48 : Gn = 1 / 0, Gn >= D)
            break;
          er = br, ki = ki * D + Gn;
        }
        return Ot && er === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === di || be != null && this.pos - di !== be ? null : ki;
      };
      function ys(D, be) {
        return be ? parseInt(D, 8) : parseFloat(D.replace(/_/g, ""));
      }
      function Qa(D) {
        return typeof BigInt != "function" ? null : BigInt(D.replace(/_/g, ""));
      }
      tn.readRadixNumber = function(D) {
        var be = this.pos;
        this.pos += 2;
        var ht = this.readInt(D);
        return ht == null && this.raise(this.start + 2, "Expected number in radix " + D), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (ht = Qa(this.input.slice(be, this.pos)), ++this.pos) : m(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(T.num, ht);
      }, tn.readNumber = function(D) {
        var be = this.pos;
        !D && this.readInt(10, void 0, !0) === null && this.raise(be, "Invalid number");
        var ht = this.pos - be >= 2 && this.input.charCodeAt(be) === 48;
        ht && this.strict && this.raise(be, "Invalid number");
        var Ot = this.input.charCodeAt(this.pos);
        if (!ht && !D && this.options.ecmaVersion >= 11 && Ot === 110) {
          var hi = Qa(this.input.slice(be, this.pos));
          return ++this.pos, m(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(T.num, hi);
        }
        ht && /[89]/.test(this.input.slice(be, this.pos)) && (ht = !1), Ot === 46 && !ht && (++this.pos, this.readInt(10), Ot = this.input.charCodeAt(this.pos)), (Ot === 69 || Ot === 101) && !ht && (Ot = this.input.charCodeAt(++this.pos), (Ot === 43 || Ot === 45) && ++this.pos, this.readInt(10) === null && this.raise(be, "Invalid number")), m(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
        var di = ys(this.input.slice(be, this.pos), ht);
        return this.finishToken(T.num, di);
      }, tn.readCodePoint = function() {
        var D = this.input.charCodeAt(this.pos), be;
        if (D === 123) {
          this.options.ecmaVersion < 6 && this.unexpected();
          var ht = ++this.pos;
          be = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, be > 1114111 && this.invalidStringToken(ht, "Code point out of bounds");
        } else
          be = this.readHexChar(4);
        return be;
      }, tn.readString = function(D) {
        for (var be = "", ht = ++this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
          var Ot = this.input.charCodeAt(this.pos);
          if (Ot === D)
            break;
          Ot === 92 ? (be += this.input.slice(ht, this.pos), be += this.readEscapedChar(!1), ht = this.pos) : Ot === 8232 || Ot === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (ee(Ot) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
        }
        return be += this.input.slice(ht, this.pos++), this.finishToken(T.string, be);
      };
      var fa = {};
      tn.tryReadTemplateToken = function() {
        this.inTemplateElement = !0;
        try {
          this.readTmplToken();
        } catch (D) {
          if (D === fa)
            this.readInvalidTemplateToken();
          else
            throw D;
        }
        this.inTemplateElement = !1;
      }, tn.invalidStringToken = function(D, be) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9)
          throw fa;
        this.raise(D, be);
      }, tn.readTmplToken = function() {
        for (var D = "", be = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
          var ht = this.input.charCodeAt(this.pos);
          if (ht === 96 || ht === 36 && this.input.charCodeAt(this.pos + 1) === 123)
            return this.pos === this.start && (this.type === T.template || this.type === T.invalidTemplate) ? ht === 36 ? (this.pos += 2, this.finishToken(T.dollarBraceL)) : (++this.pos, this.finishToken(T.backQuote)) : (D += this.input.slice(be, this.pos), this.finishToken(T.template, D));
          if (ht === 92)
            D += this.input.slice(be, this.pos), D += this.readEscapedChar(!0), be = this.pos;
          else if (ee(ht)) {
            switch (D += this.input.slice(be, this.pos), ++this.pos, ht) {
              case 13:
                this.input.charCodeAt(this.pos) === 10 && ++this.pos;
              case 10:
                D += `
`;
                break;
              default:
                D += String.fromCharCode(ht);
                break;
            }
            this.options.locations && (++this.curLine, this.lineStart = this.pos), be = this.pos;
          } else
            ++this.pos;
        }
      }, tn.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++)
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{")
                break;
            // fall through
            case "`":
              return this.finishToken(T.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              this.input[this.pos + 1] === `
` && ++this.pos;
            // fall through
            case `
`:
            case "\u2028":
            case "\u2029":
              ++this.curLine, this.lineStart = this.pos + 1;
              break;
          }
        this.raise(this.start, "Unterminated template");
      }, tn.readEscapedChar = function(D) {
        var be = this.input.charCodeAt(++this.pos);
        switch (++this.pos, be) {
          case 110:
            return `
`;
          // 'n' -> '\n'
          case 114:
            return "\r";
          // 'r' -> '\r'
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          // 'x'
          case 117:
            return it(this.readCodePoint());
          // 'u'
          case 116:
            return "	";
          // 't' -> '\t'
          case 98:
            return "\b";
          // 'b' -> '\b'
          case 118:
            return "\v";
          // 'v' -> '\u000b'
          case 102:
            return "\f";
          // 'f' -> '\f'
          case 13:
            this.input.charCodeAt(this.pos) === 10 && ++this.pos;
          // '\r\n'
          case 10:
            return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
          case 56:
          case 57:
            if (this.strict && this.invalidStringToken(
              this.pos - 1,
              "Invalid escape sequence"
            ), D) {
              var ht = this.pos - 1;
              this.invalidStringToken(
                ht,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (be >= 48 && be <= 55) {
              var Ot = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], hi = parseInt(Ot, 8);
              return hi > 255 && (Ot = Ot.slice(0, -1), hi = parseInt(Ot, 8)), this.pos += Ot.length - 1, be = this.input.charCodeAt(this.pos), (Ot !== "0" || be === 56 || be === 57) && (this.strict || D) && this.invalidStringToken(
                this.pos - 1 - Ot.length,
                D ? "Octal literal in template string" : "Octal literal in strict mode"
              ), String.fromCharCode(hi);
            }
            return ee(be) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(be);
        }
      }, tn.readHexChar = function(D) {
        var be = this.pos, ht = this.readInt(16, D);
        return ht === null && this.invalidStringToken(be, "Bad character escape sequence"), ht;
      }, tn.readWord1 = function() {
        this.containsEsc = !1;
        for (var D = "", be = !0, ht = this.pos, Ot = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
          var hi = this.fullCharCodeAtPos();
          if (w(hi, Ot))
            this.pos += hi <= 65535 ? 1 : 2;
          else if (hi === 92) {
            this.containsEsc = !0, D += this.input.slice(ht, this.pos);
            var di = this.pos;
            this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
            var ki = this.readCodePoint();
            (be ? m : w)(ki, Ot) || this.invalidStringToken(di, "Invalid Unicode escape"), D += it(ki), ht = this.pos;
          } else
            break;
          be = !1;
        }
        return D + this.input.slice(ht, this.pos);
      }, tn.readWord = function() {
        var D = this.readWord1(), be = T.name;
        return this.keywords.test(D) && (be = U[D]), this.finishToken(be, D);
      };
      var Wr = "8.14.0";
      l.acorn = {
        Parser: l,
        version: Wr,
        defaultOptions: dt,
        Position: bt,
        SourceLocation: pt,
        getLineInfo: Ke,
        Node: Et,
        TokenType: k,
        tokTypes: T,
        keywordTypes: U,
        TokContext: Be,
        tokContexts: Ze,
        isIdentifierChar: w,
        isIdentifierStart: m,
        Token: Ba,
        isNewLine: ee,
        lineBreak: W,
        lineBreakG: J,
        nonASCIIwhitespace: le
      };
      function es(D, be) {
        return l.parse(D, be);
      }
      function Tr(D, be, ht) {
        return l.parseExpressionAt(D, be, ht);
      }
      function Is(D, be) {
        return l.tokenizer(D, be);
      }
      qe.Node = Et, qe.Parser = l, qe.Position = bt, qe.SourceLocation = pt, qe.TokContext = Be, qe.Token = Ba, qe.TokenType = k, qe.defaultOptions = dt, qe.getLineInfo = Ke, qe.isIdentifierChar = w, qe.isIdentifierStart = m, qe.isNewLine = ee, qe.keywordTypes = U, qe.lineBreak = W, qe.lineBreakG = J, qe.nonASCIIwhitespace = le, qe.parse = es, qe.parseExpressionAt = Tr, qe.tokContexts = Ze, qe.tokTypes = T, qe.tokenizer = Is, qe.version = Wr;
    });
  }(np, np.exports)), np.exports;
}
/*!
 * Paper.js v0.12.18 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2020, Jrg Lehni & Jonathan Puckey
 * http://juerglehni.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Wed Jul 17 14:57:24 2024 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2020 Jrg Lehni
 * http://juerglehni.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */
var x2 = Yp.exports, ay;
function b2() {
  return ay || (ay = 1, function(mt) {
    (function(Tt, qe) {
      Tt = Tt || ry;
      var Q = Tt.window, de = Tt.document, q = new function() {
        var l = /^(statics|enumerable|beans|preserve)$/, _ = [], I = _.slice, X = Object.create, ne = Object.getOwnPropertyDescriptor, ue = Object.defineProperty, Te = _.forEach || function(Se, Pe) {
          for (var at = 0, Be = this.length; at < Be; at++)
            Se.call(Pe, this[at], at, this);
        }, ye = function(Se, Pe) {
          for (var at in this)
            this.hasOwnProperty(at) && Se.call(Pe, this[at], at, this);
        }, Me = Object.assign || function(Se) {
          for (var Pe = 1, at = arguments.length; Pe < at; Pe++) {
            var Be = arguments[Pe];
            for (var Ze in Be)
              Be.hasOwnProperty(Ze) && (Se[Ze] = Be[Ze]);
          }
          return Se;
        }, Ge = function(Se, Pe, at) {
          if (Se) {
            var Be = ne(Se, "length");
            (Be && typeof Be.value == "number" ? Te : ye).call(Se, Pe, at = at || Se);
          }
          return at;
        };
        function Qe(Se, Pe, at, Be, Ze) {
          var fe = {};
          function Je(ae, $e) {
            $e = $e || ($e = ne(Pe, ae)) && ($e.get ? $e : $e.value), typeof $e == "string" && $e[0] === "#" && ($e = Se[$e.substring(1)] || $e);
            var Et = typeof $e == "function", Nt = $e, Yt = Ze || Et && !$e.base ? $e && $e.get ? ae in Se : Se[ae] : null, Ft;
            (!Ze || !Yt) && (Et && Yt && ($e.base = Yt), Et && Be !== !1 && (Ft = ae.match(/^([gs]et|is)(([A-Z])(.*))$/)) && (fe[Ft[3].toLowerCase() + Ft[4]] = Ft[2]), (!Nt || Et || !Nt.get || typeof Nt.get != "function" || !re.isPlainObject(Nt)) && (Nt = { value: Nt, writable: !0 }), (ne(Se, ae) || { configurable: !0 }).configurable && (Nt.configurable = !0, Nt.enumerable = at ?? !Ft), ue(Se, ae, Nt));
          }
          if (Pe) {
            for (var Xe in Pe)
              Pe.hasOwnProperty(Xe) && !l.test(Xe) && Je(Xe);
            for (var Xe in fe) {
              var z = fe[Xe], He = Se["set" + z], nt = Se["get" + z] || He && Se["is" + z];
              nt && (Be === !0 || nt.length === 0) && Je(Xe, { get: nt, set: He });
            }
          }
          return Se;
        }
        function re() {
          for (var Se = 0, Pe = arguments.length; Se < Pe; Se++) {
            var at = arguments[Se];
            at && Me(this, at);
          }
          return this;
        }
        return Qe(re, {
          inject: function(Se) {
            if (Se) {
              var Pe = Se.statics === !0 ? Se : Se.statics, at = Se.beans, Be = Se.preserve;
              Pe !== Se && Qe(this.prototype, Se, Se.enumerable, at, Be), Qe(this, Pe, null, at, Be);
            }
            for (var Ze = 1, fe = arguments.length; Ze < fe; Ze++)
              this.inject(arguments[Ze]);
            return this;
          },
          extend: function() {
            for (var Se = this, Pe, at, Be = 0, Ze, fe = arguments.length; Be < fe && !(Pe && at); Be++)
              Ze = arguments[Be], Pe = Pe || Ze.initialize, at = at || Ze.prototype;
            return Pe = Pe || function() {
              Se.apply(this, arguments);
            }, at = Pe.prototype = at || X(this.prototype), ue(
              at,
              "constructor",
              { value: Pe, writable: !0, configurable: !0 }
            ), Qe(Pe, this), arguments.length && this.inject.apply(Pe, arguments), Pe.base = Se, Pe;
          }
        }).inject({
          enumerable: !1,
          initialize: re,
          set: re,
          inject: function() {
            for (var Se = 0, Pe = arguments.length; Se < Pe; Se++) {
              var at = arguments[Se];
              at && Qe(this, at, at.enumerable, at.beans, at.preserve);
            }
            return this;
          },
          extend: function() {
            var Se = X(this);
            return Se.inject.apply(Se, arguments);
          },
          each: function(Se, Pe) {
            return Ge(this, Se, Pe);
          },
          clone: function() {
            return new this.constructor(this);
          },
          statics: {
            set: Me,
            each: Ge,
            create: X,
            define: ue,
            describe: ne,
            clone: function(Se) {
              return Me(new Se.constructor(), Se);
            },
            isPlainObject: function(Se) {
              var Pe = Se != null && Se.constructor;
              return Pe && (Pe === Object || Pe === re || Pe.name === "Object");
            },
            pick: function(Se, Pe) {
              return Se !== qe ? Se : Pe;
            },
            slice: function(Se, Pe, at) {
              return I.call(Se, Pe, at);
            }
          }
        });
      }();
      mt.exports = q, q.inject({
        enumerable: !1,
        toString: function() {
          return this._id != null ? (this._class || "Object") + (this._name ? " '" + this._name + "'" : " @" + this._id) : "{ " + q.each(this, function(l, _) {
            if (!/^_/.test(_)) {
              var I = typeof l;
              this.push(_ + ": " + (I === "number" ? R.instance.number(l) : I === "string" ? "'" + l + "'" : l));
            }
          }, []).join(", ") + " }";
        },
        getClassName: function() {
          return this._class || "";
        },
        importJSON: function(l) {
          return q.importJSON(l, this);
        },
        exportJSON: function(l) {
          return q.exportJSON(this, l);
        },
        toJSON: function() {
          return q.serialize(this);
        },
        set: function(l, _) {
          return l && q.filter(this, l, _, this._prioritize), this;
        }
      }, {
        beans: !1,
        statics: {
          exports: {},
          extend: function l() {
            var _ = l.base.apply(this, arguments), I = _.prototype._class;
            return I && !q.exports[I] && (q.exports[I] = _), _;
          },
          equals: function(l, _) {
            if (l === _)
              return !0;
            if (l && l.equals)
              return l.equals(_);
            if (_ && _.equals)
              return _.equals(l);
            if (l && _ && typeof l == "object" && typeof _ == "object") {
              if (Array.isArray(l) && Array.isArray(_)) {
                var I = l.length;
                if (I !== _.length)
                  return !1;
                for (; I--; )
                  if (!q.equals(l[I], _[I]))
                    return !1;
              } else {
                var X = Object.keys(l), I = X.length;
                if (I !== Object.keys(_).length)
                  return !1;
                for (; I--; ) {
                  var ne = X[I];
                  if (!(_.hasOwnProperty(ne) && q.equals(l[ne], _[ne])))
                    return !1;
                }
              }
              return !0;
            }
            return !1;
          },
          read: function(l, _, I, X) {
            if (this === q) {
              var ne = this.peek(l, _);
              return l.__index++, ne;
            }
            var ue = this.prototype, Te = ue._readIndex, ye = _ || Te && l.__index || 0, Me = l.length, Ge = l[ye];
            if (X = X || Me - ye, Ge instanceof this || I && I.readNull && Ge == null && X <= 1)
              return Te && (l.__index = ye + 1), Ge && I && I.clone ? Ge.clone() : Ge;
            if (Ge = q.create(ue), Te && (Ge.__read = !0), Ge = Ge.initialize.apply(Ge, ye > 0 || ye + X < Me ? q.slice(l, ye, ye + X) : l) || Ge, Te) {
              l.__index = ye + Ge.__read;
              var Qe = Ge.__filtered;
              Qe && (l.__filtered = Qe, Ge.__filtered = qe), Ge.__read = qe;
            }
            return Ge;
          },
          peek: function(l, _) {
            return l[l.__index = _ || l.__index || 0];
          },
          remain: function(l) {
            return l.length - (l.__index || 0);
          },
          readList: function(l, _, I, X) {
            for (var ne = [], ue, Te = _ || 0, ye = X ? Te + X : l.length, Me = Te; Me < ye; Me++)
              ne.push(Array.isArray(ue = l[Me]) ? this.read(ue, 0, I) : this.read(l, Me, I, 1));
            return ne;
          },
          readNamed: function(l, _, I, X, ne) {
            var ue = this.getNamed(l, _), Te = ue !== qe;
            if (Te) {
              var ye = l.__filtered;
              if (!ye) {
                var Me = this.getSource(l);
                ye = l.__filtered = q.create(Me), ye.__unfiltered = Me;
              }
              ye[_] = qe;
            }
            return this.read(Te ? [ue] : l, I, X, ne);
          },
          readSupported: function(l, _) {
            var I = this.getSource(l), X = this, ne = !1;
            return I && Object.keys(I).forEach(function(ue) {
              if (ue in _) {
                var Te = X.readNamed(l, ue);
                Te !== qe && (_[ue] = Te), ne = !0;
              }
            }), ne;
          },
          getSource: function(l) {
            var _ = l.__source;
            if (_ === qe) {
              var I = l.length === 1 && l[0];
              _ = l.__source = I && q.isPlainObject(I) ? I : null;
            }
            return _;
          },
          getNamed: function(l, _) {
            var I = this.getSource(l);
            if (I)
              return _ ? I[_] : l.__filtered || I;
          },
          hasNamed: function(l, _) {
            return !!this.getNamed(l, _);
          },
          filter: function(l, _, I, X) {
            var ne;
            function ue(Qe) {
              if (!(I && Qe in I) && !(ne && Qe in ne)) {
                var re = _[Qe];
                re !== qe && (l[Qe] = re);
              }
            }
            if (X) {
              for (var Te = {}, ye = 0, Me, Ge = X.length; ye < Ge; ye++)
                (Me = X[ye]) in _ && (ue(Me), Te[Me] = !0);
              ne = Te;
            }
            return Object.keys(_.__unfiltered || _).forEach(ue), l;
          },
          isPlainValue: function(l, _) {
            return q.isPlainObject(l) || Array.isArray(l) || _ && typeof l == "string";
          },
          serialize: function(l, _, I, X) {
            _ = _ || {};
            var ne = !X, ue;
            if (ne && (_.formatter = new R(_.precision), X = {
              length: 0,
              definitions: {},
              references: {},
              add: function(re, Se) {
                var Pe = "#" + re._id, at = this.references[Pe];
                if (!at) {
                  this.length++;
                  var Be = Se.call(re), Ze = re._class;
                  Ze && Be[0] !== Ze && Be.unshift(Ze), this.definitions[Pe] = Be, at = this.references[Pe] = [Pe];
                }
                return at;
              }
            }), l && l._serialize) {
              ue = l._serialize(_, X);
              var Te = l._class;
              Te && !l._compactSerialize && (ne || !I) && ue[0] !== Te && ue.unshift(Te);
            } else if (Array.isArray(l)) {
              ue = [];
              for (var ye = 0, Me = l.length; ye < Me; ye++)
                ue[ye] = q.serialize(l[ye], _, I, X);
            } else if (q.isPlainObject(l)) {
              ue = {};
              for (var Ge = Object.keys(l), ye = 0, Me = Ge.length; ye < Me; ye++) {
                var Qe = Ge[ye];
                ue[Qe] = q.serialize(
                  l[Qe],
                  _,
                  I,
                  X
                );
              }
            } else typeof l == "number" ? ue = _.formatter.number(l, _.precision) : ue = l;
            return ne && X.length > 0 ? [["dictionary", X.definitions], ue] : ue;
          },
          deserialize: function(l, _, I, X, ne) {
            var ue = l, Te = !I, ye = Te && l && l.length && l[0][0] === "dictionary";
            if (I = I || {}, Array.isArray(l)) {
              var Me = l[0], Ge = Me === "dictionary";
              if (l.length == 1 && /^#/.test(Me))
                return I.dictionary[Me];
              Me = q.exports[Me], ue = [];
              for (var Qe = Me ? 1 : 0, re = l.length; Qe < re; Qe++)
                ue.push(q.deserialize(
                  l[Qe],
                  _,
                  I,
                  Ge,
                  ye
                ));
              if (Me) {
                var Se = ue;
                _ ? ue = _(Me, Se, Te || ne) : ue = new Me(Se);
              }
            } else if (q.isPlainObject(l)) {
              ue = {}, X && (I.dictionary = ue);
              for (var Pe in l)
                ue[Pe] = q.deserialize(l[Pe], _, I);
            }
            return ye ? ue[1] : ue;
          },
          exportJSON: function(l, _) {
            var I = q.serialize(l, _);
            return _ && _.asString == !1 ? I : JSON.stringify(I);
          },
          importJSON: function(l, _) {
            return q.deserialize(
              typeof l == "string" ? JSON.parse(l) : l,
              function(I, X, ne) {
                var ue = ne && _ && _.constructor === I, Te = ue ? _ : q.create(I.prototype);
                if (X.length === 1 && Te instanceof T && (ue || !(Te instanceof J))) {
                  var ye = X[0];
                  q.isPlainObject(ye) && (ye.insert = !1, ue && (X = X.concat([T.INSERT])));
                }
                return (ue ? Te.set : I).apply(Te, X), ue && (_ = null), Te;
              }
            );
          },
          push: function(l, _) {
            var I = _.length;
            if (I < 4096)
              l.push.apply(l, _);
            else {
              var X = l.length;
              l.length += I;
              for (var ne = 0; ne < I; ne++)
                l[X + ne] = _[ne];
            }
            return l;
          },
          splice: function(l, _, I, X) {
            var ne = _ && _.length, ue = I === qe;
            I = ue ? l.length : I, I > l.length && (I = l.length);
            for (var Te = 0; Te < ne; Te++)
              _[Te]._index = I + Te;
            if (ue)
              return q.push(l, _), [];
            var ye = [I, X];
            _ && q.push(ye, _);
            for (var Me = l.splice.apply(l, ye), Te = 0, Ge = Me.length; Te < Ge; Te++)
              Me[Te]._index = qe;
            for (var Te = I + ne, Ge = l.length; Te < Ge; Te++)
              l[Te]._index = Te;
            return Me;
          },
          capitalize: function(l) {
            return l.replace(/\b[a-z]/g, function(_) {
              return _.toUpperCase();
            });
          },
          camelize: function(l) {
            return l.replace(/-(.)/g, function(_, I) {
              return I.toUpperCase();
            });
          },
          hyphenate: function(l) {
            return l.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
          }
        }
      });
      var ie = {
        on: function(l, _) {
          if (typeof l != "string")
            q.each(l, function(ue, Te) {
              this.on(Te, ue);
            }, this);
          else {
            var I = this._eventTypes, X = I && I[l], ne = this._callbacks = this._callbacks || {};
            ne = ne[l] = ne[l] || [], ne.indexOf(_) === -1 && (ne.push(_), X && X.install && ne.length === 1 && X.install.call(this, l));
          }
          return this;
        },
        off: function(l, _) {
          if (typeof l != "string") {
            q.each(l, function(Te, ye) {
              this.off(ye, Te);
            }, this);
            return;
          }
          var I = this._eventTypes, X = I && I[l], ne = this._callbacks && this._callbacks[l], ue;
          return ne && (!_ || (ue = ne.indexOf(_)) !== -1 && ne.length === 1 ? (X && X.uninstall && X.uninstall.call(this, l), delete this._callbacks[l]) : ue !== -1 && ne.splice(ue, 1)), this;
        },
        once: function(l, _) {
          return this.on(l, function I() {
            _.apply(this, arguments), this.off(l, I);
          });
        },
        emit: function(l, _) {
          var I = this._callbacks && this._callbacks[l];
          if (!I)
            return !1;
          var X = q.slice(arguments, 1), ne = _ && _.target && !_.currentTarget;
          I = I.slice(), ne && (_.currentTarget = this);
          for (var ue = 0, Te = I.length; ue < Te; ue++)
            if (I[ue].apply(this, X) == !1) {
              _ && _.stop && _.stop();
              break;
            }
          return ne && delete _.currentTarget, !0;
        },
        responds: function(l) {
          return !!(this._callbacks && this._callbacks[l]);
        },
        attach: "#on",
        detach: "#off",
        fire: "#emit",
        _installEvents: function(l) {
          var _ = this._eventTypes, I = this._callbacks, X = l ? "install" : "uninstall";
          if (_) {
            for (var ne in I)
              if (I[ne].length > 0) {
                var ue = _[ne], Te = ue && ue[X];
                Te && Te.call(this, ne);
              }
          }
        },
        statics: {
          inject: function l(_) {
            var I = _._events;
            if (I) {
              var X = {};
              q.each(I, function(ne, ue) {
                var Te = typeof ne == "string", ye = Te ? ne : ue, Me = q.capitalize(ye), Ge = ye.substring(2).toLowerCase();
                X[Ge] = Te ? {} : ne, ye = "_" + ye, _["get" + Me] = function() {
                  return this[ye];
                }, _["set" + Me] = function(Qe) {
                  var re = this[ye];
                  re && this.off(Ge, re), Qe && this.on(Ge, Qe), this[ye] = Qe;
                };
              }), _._eventTypes = X;
            }
            return l.base.apply(this, arguments);
          }
        }
      }, i = q.extend({
        _class: "PaperScope",
        initialize: function l() {
          xt = this, this.settings = new q({
            applyMatrix: !0,
            insertItems: !0,
            handleSize: 4,
            hitTolerance: 0
          }), this.project = null, this.projects = [], this.tools = [], this._id = l._id++, l._scopes[this._id] = this;
          var _ = l.prototype;
          if (!this.support) {
            var I = _t.getContext(1, 1) || {};
            _.support = {
              nativeDash: "setLineDash" in I || "mozDash" in I,
              nativeBlendModes: et.nativeModes
            }, _t.release(I);
          }
          if (!this.agent) {
            var X = Tt.navigator.userAgent.toLowerCase(), ne = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(X) || [])[0], ue = ne === "darwin" ? "mac" : ne, Te = _.agent = _.browser = { platform: ue };
            ue && (Te[ue] = !0), X.replace(
              /(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g,
              function(ye, Me, Ge, Qe, re) {
                if (!Te.chrome) {
                  var Se = Me === "opera" ? Qe : /^(node|trident)$/.test(Me) ? re : Ge;
                  Te.version = Se, Te.versionNumber = parseFloat(Se), Me = { trident: "msie", jsdom: "node" }[Me] || Me, Te.name = Me, Te[Me] = !0;
                }
              }
            ), Te.chrome && delete Te.webkit, Te.atom && delete Te.chrome;
          }
        },
        version: "0.12.18",
        getView: function() {
          var l = this.project;
          return l && l._view;
        },
        getPaper: function() {
          return this;
        },
        execute: function(l, _) {
          var I = xt.PaperScript.execute(l, this, _);
          return ri.updateFocus(), I;
        },
        install: function(l) {
          var _ = this;
          q.each(["project", "view", "tool"], function(X) {
            q.define(l, X, {
              configurable: !0,
              get: function() {
                return _[X];
              }
            });
          });
          for (var I in this)
            !/^_/.test(I) && this[I] && (l[I] = this[I]);
        },
        setup: function(l) {
          return xt = this, this.project = new j(l), this;
        },
        createCanvas: function(l, _) {
          return _t.getCanvas(l, _);
        },
        activate: function() {
          xt = this;
        },
        clear: function() {
          for (var l = this.projects, _ = this.tools, I = l.length - 1; I >= 0; I--)
            l[I].remove();
          for (var I = _.length - 1; I >= 0; I--)
            _[I].remove();
        },
        remove: function() {
          this.clear(), delete i._scopes[this._id];
        },
        statics: new function() {
          function l(_) {
            return _ += "Attribute", function(I, X) {
              return I[_](X) || I[_]("data-paper-" + X);
            };
          }
          return {
            _scopes: {},
            _id: 0,
            get: function(_) {
              return this._scopes[_] || null;
            },
            getAttribute: l("get"),
            hasAttribute: l("has")
          };
        }()
      }), N = q.extend(ie, {
        initialize: function(l) {
          this._scope = xt, this._index = this._scope[this._list].push(this) - 1, (l || !this._scope[this._reference]) && this.activate();
        },
        activate: function() {
          if (!this._scope)
            return !1;
          var l = this._scope[this._reference];
          return l && l !== this && l.emit("deactivate"), this._scope[this._reference] = this, this.emit("activate", l), !0;
        },
        isActive: function() {
          return this._scope[this._reference] === this;
        },
        remove: function() {
          return this._index == null ? !1 : (q.splice(this._scope[this._list], null, this._index, 1), this._scope[this._reference] == this && (this._scope[this._reference] = null), this._scope = null, !0);
        },
        getView: function() {
          return this._scope.getView();
        }
      }), Z = {
        findItemBoundsCollisions: function(l, _, I) {
          function X(Te) {
            for (var ye = new Array(Te.length), Me = 0; Me < Te.length; Me++) {
              var Ge = Te[Me].getBounds();
              ye[Me] = [Ge.left, Ge.top, Ge.right, Ge.bottom];
            }
            return ye;
          }
          var ne = X(l), ue = !_ || _ === l ? ne : X(_);
          return this.findBoundsCollisions(ne, ue, I || 0);
        },
        findCurveBoundsCollisions: function(l, _, I, X) {
          function ne(Se) {
            for (var Pe = Math.min, at = Math.max, Be = new Array(Se.length), Ze = 0; Ze < Se.length; Ze++) {
              var fe = Se[Ze];
              Be[Ze] = [
                Pe(fe[0], fe[2], fe[4], fe[6]),
                Pe(fe[1], fe[3], fe[5], fe[7]),
                at(fe[0], fe[2], fe[4], fe[6]),
                at(fe[1], fe[3], fe[5], fe[7])
              ];
            }
            return Be;
          }
          var ue = ne(l), Te = !_ || _ === l ? ue : ne(_);
          if (X) {
            for (var ye = this.findBoundsCollisions(
              ue,
              Te,
              I || 0,
              !1,
              !0
            ), Me = this.findBoundsCollisions(
              ue,
              Te,
              I || 0,
              !0,
              !0
            ), Ge = [], Qe = 0, re = ye.length; Qe < re; Qe++)
              Ge[Qe] = { hor: ye[Qe], ver: Me[Qe] };
            return Ge;
          }
          return this.findBoundsCollisions(ue, Te, I || 0);
        },
        findBoundsCollisions: function(l, _, I, X, ne) {
          var ue = !_ || l === _, Te = ue ? l : l.concat(_), ye = l.length, Me = Te.length;
          function Ge(It, Ut, ti) {
            for (var Pt = 0, Wt = It.length; Pt < Wt; ) {
              var ei = Wt + Pt >>> 1;
              Te[It[ei]][Ut] < ti ? Pt = ei + 1 : Wt = ei;
            }
            return Pt - 1;
          }
          for (var Qe = X ? 1 : 0, re = Qe + 2, Se = X ? 0 : 1, Pe = Se + 2, at = new Array(Me), Be = 0; Be < Me; Be++)
            at[Be] = Be;
          at.sort(function(It, Ut) {
            return Te[It][Qe] - Te[Ut][Qe];
          });
          for (var Ze = [], fe = new Array(ye), Be = 0; Be < Me; Be++) {
            var Je = at[Be], Xe = Te[Je], z = ue ? Je : Je - ye, He = Je < ye, nt = ue || !He, ae = He ? [] : null;
            if (Ze.length) {
              var $e = Ge(
                Ze,
                re,
                Xe[Qe] - I
              ) + 1;
              if (Ze.splice(0, $e), ue && ne) {
                ae = ae.concat(Ze);
                for (var Et = 0; Et < Ze.length; Et++) {
                  var Nt = Ze[Et];
                  fe[Nt].push(z);
                }
              } else
                for (var Yt = Xe[Pe], Ft = Xe[Se], Et = 0; Et < Ze.length; Et++) {
                  var Nt = Ze[Et], ai = Te[Nt], Mt = Nt < ye, Ae = ue || Nt >= ye;
                  (ne || (He && Ae || nt && Mt) && Yt >= ai[Se] - I && Ft <= ai[Pe] + I) && (He && Ae && ae.push(
                    ue ? Nt : Nt - ye
                  ), nt && Mt && fe[Nt].push(z));
                }
            }
            if (He && (l === _ && ae.push(Je), fe[Je] = ae), Ze.length) {
              var Fe = Xe[re], tt = Ge(Ze, re, Fe);
              Ze.splice(tt + 1, 0, Je);
            } else
              Ze.push(Je);
          }
          for (var Be = 0; Be < fe.length; Be++) {
            var Ct = fe[Be];
            Ct && Ct.sort(function(Ut, ti) {
              return Ut - ti;
            });
          }
          return fe;
        }
      }, R = q.extend({
        initialize: function(l) {
          this.precision = q.pick(l, 5), this.multiplier = Math.pow(10, this.precision);
        },
        number: function(l) {
          return this.precision < 16 ? Math.round(l * this.multiplier) / this.multiplier : l;
        },
        pair: function(l, _, I) {
          return this.number(l) + (I || ",") + this.number(_);
        },
        point: function(l, _) {
          return this.number(l.x) + (_ || ",") + this.number(l.y);
        },
        size: function(l, _) {
          return this.number(l.width) + (_ || ",") + this.number(l.height);
        },
        rectangle: function(l, _) {
          return this.point(l, _) + (_ || ",") + this.size(l, _);
        }
      });
      R.instance = new R();
      var A = new function() {
        var l = [
          [0.5773502691896257],
          [0, 0.7745966692414834],
          [0.33998104358485626, 0.8611363115940526],
          [0, 0.5384693101056831, 0.906179845938664],
          [0.2386191860831969, 0.6612093864662645, 0.932469514203152],
          [0, 0.4058451513773972, 0.7415311855993945, 0.9491079123427585],
          [0.1834346424956498, 0.525532409916329, 0.7966664774136267, 0.9602898564975363],
          [0, 0.3242534234038089, 0.6133714327005904, 0.8360311073266358, 0.9681602395076261],
          [0.14887433898163122, 0.4333953941292472, 0.6794095682990244, 0.8650633666889845, 0.9739065285171717],
          [0, 0.26954315595234496, 0.5190961292068118, 0.7301520055740494, 0.8870625997680953, 0.978228658146057],
          [0.1252334085114689, 0.3678314989981802, 0.5873179542866175, 0.7699026741943047, 0.9041172563704749, 0.9815606342467192],
          [0, 0.2304583159551348, 0.44849275103644687, 0.6423493394403402, 0.8015780907333099, 0.9175983992229779, 0.9841830547185881],
          [0.10805494870734367, 0.31911236892788974, 0.5152486363581541, 0.6872929048116855, 0.827201315069765, 0.9284348836635735, 0.9862838086968123],
          [0, 0.20119409399743451, 0.3941513470775634, 0.5709721726085388, 0.7244177313601701, 0.8482065834104272, 0.937273392400706, 0.9879925180204854],
          [0.09501250983763744, 0.2816035507792589, 0.45801677765722737, 0.6178762444026438, 0.755404408355003, 0.8656312023878318, 0.9445750230732326, 0.9894009349916499]
        ], _ = [
          [1],
          [0.8888888888888888, 0.5555555555555556],
          [0.6521451548625461, 0.34785484513745385],
          [0.5688888888888889, 0.47862867049936647, 0.23692688505618908],
          [0.46791393457269104, 0.3607615730481386, 0.17132449237917036],
          [0.4179591836734694, 0.3818300505051189, 0.27970539148927664, 0.1294849661688697],
          [0.362683783378362, 0.31370664587788727, 0.22238103445337448, 0.10122853629037626],
          [0.3302393550012598, 0.31234707704000286, 0.26061069640293544, 0.1806481606948574, 0.08127438836157441],
          [0.29552422471475287, 0.26926671930999635, 0.21908636251598204, 0.1494513491505806, 0.06667134430868814],
          [0.2729250867779006, 0.26280454451024665, 0.23319376459199048, 0.18629021092773426, 0.1255803694649046, 0.05566856711617366],
          [0.24914704581340277, 0.2334925365383548, 0.20316742672306592, 0.16007832854334622, 0.10693932599531843, 0.04717533638651183],
          [0.2325515532308739, 0.22628318026289723, 0.2078160475368885, 0.17814598076194574, 0.13887351021978725, 0.09212149983772845, 0.04048400476531588],
          [0.2152638534631578, 0.2051984637212956, 0.18553839747793782, 0.15720316715819355, 0.12151857068790319, 0.08015808715976021, 0.03511946033175186],
          [0.2025782419255613, 0.19843148532711158, 0.1861610000155622, 0.16626920581699392, 0.13957067792615432, 0.10715922046717194, 0.07036604748810812, 0.03075324199611727],
          [0.1894506104550685, 0.18260341504492358, 0.16915651939500254, 0.14959598881657674, 0.12462897125553388, 0.09515851168249279, 0.062253523938647894, 0.027152459411754096]
        ], I = Math.abs, X = Math.sqrt, ne = Math.pow, ue = Math.log2 || function(re) {
          return Math.log(re) * Math.LOG2E;
        }, Te = 1e-12, ye = 112e-18;
        function Me(re, Se, Pe) {
          return re < Se ? Se : re > Pe ? Pe : re;
        }
        function Ge(re, Se, Pe) {
          function at($e) {
            var Et = $e * 134217729, Nt = $e - Et, Yt = Nt + Et, Ft = $e - Yt;
            return [Yt, Ft];
          }
          var Be = Se * Se - re * Pe, Ze = Se * Se + re * Pe;
          if (I(Be) * 3 < Ze) {
            var fe = at(re), Je = at(Se), Xe = at(Pe), z = Se * Se, He = Je[0] * Je[0] - z + 2 * Je[0] * Je[1] + Je[1] * Je[1], nt = re * Pe, ae = fe[0] * Xe[0] - nt + fe[0] * Xe[1] + fe[1] * Xe[0] + fe[1] * Xe[1];
            Be = z - nt + (He - ae);
          }
          return Be;
        }
        function Qe() {
          var re = Math.max.apply(Math, arguments);
          return re && (re < 1e-8 || re > 1e8) ? ne(2, -Math.round(ue(re))) : 0;
        }
        return {
          EPSILON: Te,
          MACHINE_EPSILON: ye,
          CURVETIME_EPSILON: 1e-8,
          GEOMETRIC_EPSILON: 1e-7,
          TRIGONOMETRIC_EPSILON: 1e-8,
          ANGULAR_EPSILON: 1e-5,
          KAPPA: 4 * (X(2) - 1) / 3,
          isZero: function(re) {
            return re >= -Te && re <= Te;
          },
          isMachineZero: function(re) {
            return re >= -ye && re <= ye;
          },
          clamp: Me,
          integrate: function(re, Se, Pe, at) {
            for (var Be = l[at - 2], Ze = _[at - 2], fe = (Pe - Se) * 0.5, Je = fe + Se, Xe = 0, z = at + 1 >> 1, He = at & 1 ? Ze[Xe++] * re(Je) : 0; Xe < z; ) {
              var nt = fe * Be[Xe];
              He += Ze[Xe++] * (re(Je + nt) + re(Je - nt));
            }
            return fe * He;
          },
          findRoot: function(re, Se, Pe, at, Be, Ze, fe) {
            for (var Je = 0; Je < Ze; Je++) {
              var Xe = re(Pe), z = Xe / Se(Pe), He = Pe - z;
              if (I(z) < fe) {
                Pe = He;
                break;
              }
              Xe > 0 ? (Be = Pe, Pe = He <= at ? (at + Be) * 0.5 : He) : (at = Pe, Pe = He >= Be ? (at + Be) * 0.5 : He);
            }
            return Me(Pe, at, Be);
          },
          solveQuadratic: function(re, Se, Pe, at, Be, Ze) {
            var fe, Je = 1 / 0;
            if (I(re) < Te) {
              if (I(Se) < Te)
                return I(Pe) < Te ? -1 : 0;
              fe = -Pe / Se;
            } else {
              Se *= -0.5;
              var Xe = Ge(re, Se, Pe);
              if (Xe && I(Xe) < ye) {
                var z = Qe(I(re), I(Se), I(Pe));
                z && (re *= z, Se *= z, Pe *= z, Xe = Ge(re, Se, Pe));
              }
              if (Xe >= -ye) {
                var He = Xe < 0 ? 0 : X(Xe), nt = Se + (Se < 0 ? -He : He);
                nt === 0 ? (fe = Pe / re, Je = -fe) : (fe = nt / re, Je = Pe / nt);
              }
            }
            var ae = 0, $e = Be == null, Et = Be - Te, Nt = Ze + Te;
            return isFinite(fe) && ($e || fe > Et && fe < Nt) && (at[ae++] = $e ? fe : Me(fe, Be, Ze)), Je !== fe && isFinite(Je) && ($e || Je > Et && Je < Nt) && (at[ae++] = $e ? Je : Me(Je, Be, Ze)), ae;
          },
          solveCubic: function(re, Se, Pe, at, Be, Ze, fe) {
            var Je = Qe(I(re), I(Se), I(Pe), I(at)), Xe, z, He, nt, ae;
            Je && (re *= Je, Se *= Je, Pe *= Je, at *= Je);
            function $e(tt) {
              Xe = tt;
              var Ct = re * Xe;
              z = Ct + Se, He = z * Xe + Pe, nt = (Ct + z) * Xe + He, ae = He * Xe + at;
            }
            if (I(re) < Te)
              re = Se, z = Pe, He = at, Xe = 1 / 0;
            else if (I(at) < Te)
              z = Se, He = Pe, Xe = 0;
            else {
              $e(-(Se / re) / 3);
              var Et = ae / re, Nt = ne(I(Et), 1 / 3), Yt = Et < 0 ? -1 : 1, Ft = -nt / re, ai = Ft > 0 ? 1.324717957244746 * Math.max(Nt, X(Ft)) : Nt, Mt = Xe - Yt * ai;
              if (Mt !== Xe) {
                do
                  $e(Mt), Mt = nt === 0 ? Xe : Xe - ae / nt / (1 + ye);
                while (Yt * Mt > Yt * Xe);
                I(re) * Xe * Xe > I(at / Xe) && (He = -at / Xe, z = (He - Pe) / Xe);
              }
            }
            var Ae = A.solveQuadratic(re, z, He, Be, Ze, fe), Fe = Ze == null;
            return isFinite(Xe) && (Ae === 0 || Ae > 0 && Xe !== Be[0] && Xe !== Be[1]) && (Fe || Xe > Ze - Te && Xe < fe + Te) && (Be[Ae++] = Fe ? Xe : Me(Xe, Ze, fe)), Ae;
          }
        };
      }(), M = {
        _id: 1,
        _pools: {},
        get: function(l) {
          if (l) {
            var _ = this._pools[l];
            return _ || (_ = this._pools[l] = { _id: 1 }), _._id++;
          } else
            return this._id++;
        }
      }, x = q.extend({
        _class: "Point",
        _readIndex: !0,
        initialize: function(_, I) {
          var X = typeof _, ne = this.__read, ue = 0;
          if (X === "number") {
            var Te = typeof I == "number";
            this._set(_, Te ? I : _), ne && (ue = Te ? 2 : 1);
          } else if (X === "undefined" || _ === null)
            this._set(0, 0), ne && (ue = _ === null ? 1 : 0);
          else {
            var ye = X === "string" ? _.split(/[\s,]+/) || [] : _;
            ue = 1, Array.isArray(ye) ? this._set(+ye[0], +(ye.length > 1 ? ye[1] : ye[0])) : "x" in ye ? this._set(ye.x || 0, ye.y || 0) : "width" in ye ? this._set(ye.width || 0, ye.height || 0) : "angle" in ye ? (this._set(ye.length || 0, 0), this.setAngle(ye.angle || 0)) : (this._set(0, 0), ue = 0);
          }
          return ne && (this.__read = ue), this;
        },
        set: "#initialize",
        _set: function(l, _) {
          return this.x = l, this.y = _, this;
        },
        equals: function(l) {
          return this === l || l && (this.x === l.x && this.y === l.y || Array.isArray(l) && this.x === l[0] && this.y === l[1]) || !1;
        },
        clone: function() {
          return new x(this.x, this.y);
        },
        toString: function() {
          var l = R.instance;
          return "{ x: " + l.number(this.x) + ", y: " + l.number(this.y) + " }";
        },
        _serialize: function(l) {
          var _ = l.formatter;
          return [_.number(this.x), _.number(this.y)];
        },
        getLength: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        setLength: function(l) {
          if (this.isZero()) {
            var _ = this._angle || 0;
            this._set(
              Math.cos(_) * l,
              Math.sin(_) * l
            );
          } else {
            var I = l / this.getLength();
            A.isZero(I) && this.getAngle(), this._set(
              this.x * I,
              this.y * I
            );
          }
        },
        getAngle: function() {
          return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
        },
        setAngle: function(l) {
          this.setAngleInRadians.call(this, l * Math.PI / 180);
        },
        getAngleInDegrees: "#getAngle",
        setAngleInDegrees: "#setAngle",
        getAngleInRadians: function() {
          if (arguments.length) {
            var l = x.read(arguments), _ = this.getLength() * l.getLength();
            if (A.isZero(_))
              return NaN;
            var I = this.dot(l) / _;
            return Math.acos(I < -1 ? -1 : I > 1 ? 1 : I);
          } else
            return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);
        },
        setAngleInRadians: function(l) {
          if (this._angle = l, !this.isZero()) {
            var _ = this.getLength();
            this._set(
              Math.cos(l) * _,
              Math.sin(l) * _
            );
          }
        },
        getQuadrant: function() {
          return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
        }
      }, {
        beans: !1,
        getDirectedAngle: function() {
          var l = x.read(arguments);
          return Math.atan2(this.cross(l), this.dot(l)) * 180 / Math.PI;
        },
        getDistance: function() {
          var l = arguments, _ = x.read(l), I = _.x - this.x, X = _.y - this.y, ne = I * I + X * X, ue = q.read(l);
          return ue ? ne : Math.sqrt(ne);
        },
        normalize: function(l) {
          l === qe && (l = 1);
          var _ = this.getLength(), I = _ !== 0 ? l / _ : 0, X = new x(this.x * I, this.y * I);
          return I >= 0 && (X._angle = this._angle), X;
        },
        rotate: function(l, _) {
          if (l === 0)
            return this.clone();
          l = l * Math.PI / 180;
          var I = _ ? this.subtract(_) : this, X = Math.sin(l), ne = Math.cos(l);
          return I = new x(
            I.x * ne - I.y * X,
            I.x * X + I.y * ne
          ), _ ? I.add(_) : I;
        },
        transform: function(l) {
          return l ? l._transformPoint(this) : this;
        },
        add: function() {
          var l = x.read(arguments);
          return new x(this.x + l.x, this.y + l.y);
        },
        subtract: function() {
          var l = x.read(arguments);
          return new x(this.x - l.x, this.y - l.y);
        },
        multiply: function() {
          var l = x.read(arguments);
          return new x(this.x * l.x, this.y * l.y);
        },
        divide: function() {
          var l = x.read(arguments);
          return new x(this.x / l.x, this.y / l.y);
        },
        modulo: function() {
          var l = x.read(arguments);
          return new x(this.x % l.x, this.y % l.y);
        },
        negate: function() {
          return new x(-this.x, -this.y);
        },
        isInside: function() {
          return E.read(arguments).contains(this);
        },
        isClose: function() {
          var l = arguments, _ = x.read(l), I = q.read(l);
          return this.getDistance(_) <= I;
        },
        isCollinear: function() {
          var l = x.read(arguments);
          return x.isCollinear(this.x, this.y, l.x, l.y);
        },
        isColinear: "#isCollinear",
        isOrthogonal: function() {
          var l = x.read(arguments);
          return x.isOrthogonal(this.x, this.y, l.x, l.y);
        },
        isZero: function() {
          var l = A.isZero;
          return l(this.x) && l(this.y);
        },
        isNaN: function() {
          return isNaN(this.x) || isNaN(this.y);
        },
        isInQuadrant: function(l) {
          return this.x * (l > 1 && l < 4 ? -1 : 1) >= 0 && this.y * (l > 2 ? -1 : 1) >= 0;
        },
        dot: function() {
          var l = x.read(arguments);
          return this.x * l.x + this.y * l.y;
        },
        cross: function() {
          var l = x.read(arguments);
          return this.x * l.y - this.y * l.x;
        },
        project: function() {
          var l = x.read(arguments), _ = l.isZero() ? 0 : this.dot(l) / l.dot(l);
          return new x(
            l.x * _,
            l.y * _
          );
        },
        statics: {
          min: function() {
            var l = arguments, _ = x.read(l), I = x.read(l);
            return new x(
              Math.min(_.x, I.x),
              Math.min(_.y, I.y)
            );
          },
          max: function() {
            var l = arguments, _ = x.read(l), I = x.read(l);
            return new x(
              Math.max(_.x, I.x),
              Math.max(_.y, I.y)
            );
          },
          random: function() {
            return new x(Math.random(), Math.random());
          },
          isCollinear: function(l, _, I, X) {
            return Math.abs(l * X - _ * I) <= Math.sqrt((l * l + _ * _) * (I * I + X * X)) * 1e-8;
          },
          isOrthogonal: function(l, _, I, X) {
            return Math.abs(l * I + _ * X) <= Math.sqrt((l * l + _ * _) * (I * I + X * X)) * 1e-8;
          }
        }
      }, q.each(["round", "ceil", "floor", "abs"], function(l) {
        var _ = Math[l];
        this[l] = function() {
          return new x(_(this.x), _(this.y));
        };
      }, {})), m = x.extend({
        initialize: function(_, I, X, ne) {
          this._x = _, this._y = I, this._owner = X, this._setter = ne;
        },
        _set: function(l, _, I) {
          return this._x = l, this._y = _, I || this._owner[this._setter](this), this;
        },
        getX: function() {
          return this._x;
        },
        setX: function(l) {
          this._x = l, this._owner[this._setter](this);
        },
        getY: function() {
          return this._y;
        },
        setY: function(l) {
          this._y = l, this._owner[this._setter](this);
        },
        isSelected: function() {
          return !!(this._owner._selection & this._getSelection());
        },
        setSelected: function(l) {
          this._owner._changeSelection(this._getSelection(), l);
        },
        _getSelection: function() {
          return this._setter === "setPosition" ? 4 : 0;
        }
      }), w = q.extend({
        _class: "Size",
        _readIndex: !0,
        initialize: function(_, I) {
          var X = typeof _, ne = this.__read, ue = 0;
          if (X === "number") {
            var Te = typeof I == "number";
            this._set(_, Te ? I : _), ne && (ue = Te ? 2 : 1);
          } else if (X === "undefined" || _ === null)
            this._set(0, 0), ne && (ue = _ === null ? 1 : 0);
          else {
            var ye = X === "string" ? _.split(/[\s,]+/) || [] : _;
            ue = 1, Array.isArray(ye) ? this._set(+ye[0], +(ye.length > 1 ? ye[1] : ye[0])) : "width" in ye ? this._set(ye.width || 0, ye.height || 0) : "x" in ye ? this._set(ye.x || 0, ye.y || 0) : (this._set(0, 0), ue = 0);
          }
          return ne && (this.__read = ue), this;
        },
        set: "#initialize",
        _set: function(l, _) {
          return this.width = l, this.height = _, this;
        },
        equals: function(l) {
          return l === this || l && (this.width === l.width && this.height === l.height || Array.isArray(l) && this.width === l[0] && this.height === l[1]) || !1;
        },
        clone: function() {
          return new w(this.width, this.height);
        },
        toString: function() {
          var l = R.instance;
          return "{ width: " + l.number(this.width) + ", height: " + l.number(this.height) + " }";
        },
        _serialize: function(l) {
          var _ = l.formatter;
          return [
            _.number(this.width),
            _.number(this.height)
          ];
        },
        add: function() {
          var l = w.read(arguments);
          return new w(this.width + l.width, this.height + l.height);
        },
        subtract: function() {
          var l = w.read(arguments);
          return new w(this.width - l.width, this.height - l.height);
        },
        multiply: function() {
          var l = w.read(arguments);
          return new w(this.width * l.width, this.height * l.height);
        },
        divide: function() {
          var l = w.read(arguments);
          return new w(this.width / l.width, this.height / l.height);
        },
        modulo: function() {
          var l = w.read(arguments);
          return new w(this.width % l.width, this.height % l.height);
        },
        negate: function() {
          return new w(-this.width, -this.height);
        },
        isZero: function() {
          var l = A.isZero;
          return l(this.width) && l(this.height);
        },
        isNaN: function() {
          return isNaN(this.width) || isNaN(this.height);
        },
        statics: {
          min: function(l, _) {
            return new w(
              Math.min(l.width, _.width),
              Math.min(l.height, _.height)
            );
          },
          max: function(l, _) {
            return new w(
              Math.max(l.width, _.width),
              Math.max(l.height, _.height)
            );
          },
          random: function() {
            return new w(Math.random(), Math.random());
          }
        }
      }, q.each(["round", "ceil", "floor", "abs"], function(l) {
        var _ = Math[l];
        this[l] = function() {
          return new w(_(this.width), _(this.height));
        };
      }, {})), k = w.extend({
        initialize: function(_, I, X, ne) {
          this._width = _, this._height = I, this._owner = X, this._setter = ne;
        },
        _set: function(l, _, I) {
          return this._width = l, this._height = _, I || this._owner[this._setter](this), this;
        },
        getWidth: function() {
          return this._width;
        },
        setWidth: function(l) {
          this._width = l, this._owner[this._setter](this);
        },
        getHeight: function() {
          return this._height;
        },
        setHeight: function(l) {
          this._height = l, this._owner[this._setter](this);
        }
      }), E = q.extend({
        _class: "Rectangle",
        _readIndex: !0,
        beans: !0,
        initialize: function(_, I, X, ne) {
          var ue = arguments, Te = typeof _, ye;
          if (Te === "number" ? (this._set(_, I, X, ne), ye = 4) : Te === "undefined" || _ === null ? (this._set(0, 0, 0, 0), ye = _ === null ? 1 : 0) : ue.length === 1 && (Array.isArray(_) ? (this._set.apply(this, _), ye = 1) : _.x !== qe || _.width !== qe ? (this._set(
            _.x || 0,
            _.y || 0,
            _.width || 0,
            _.height || 0
          ), ye = 1) : _.from === qe && _.to === qe && (this._set(0, 0, 0, 0), q.readSupported(ue, this) && (ye = 1))), ye === qe) {
            var Me = x.readNamed(ue, "from"), Ge = q.peek(ue), Qe = Me.x, re = Me.y, Se, Pe;
            if (Ge && Ge.x !== qe || q.hasNamed(ue, "to")) {
              var at = x.readNamed(ue, "to");
              Se = at.x - Qe, Pe = at.y - re, Se < 0 && (Qe = at.x, Se = -Se), Pe < 0 && (re = at.y, Pe = -Pe);
            } else {
              var Be = w.read(ue);
              Se = Be.width, Pe = Be.height;
            }
            this._set(Qe, re, Se, Pe), ye = ue.__index;
          }
          var Ze = ue.__filtered;
          return Ze && (this.__filtered = Ze), this.__read && (this.__read = ye), this;
        },
        set: "#initialize",
        _set: function(l, _, I, X) {
          return this.x = l, this.y = _, this.width = I, this.height = X, this;
        },
        clone: function() {
          return new E(this.x, this.y, this.width, this.height);
        },
        equals: function(l) {
          var _ = q.isPlainValue(l) ? E.read(arguments) : l;
          return _ === this || _ && this.x === _.x && this.y === _.y && this.width === _.width && this.height === _.height || !1;
        },
        toString: function() {
          var l = R.instance;
          return "{ x: " + l.number(this.x) + ", y: " + l.number(this.y) + ", width: " + l.number(this.width) + ", height: " + l.number(this.height) + " }";
        },
        _serialize: function(l) {
          var _ = l.formatter;
          return [
            _.number(this.x),
            _.number(this.y),
            _.number(this.width),
            _.number(this.height)
          ];
        },
        getPoint: function(l) {
          var _ = l ? x : m;
          return new _(this.x, this.y, this, "setPoint");
        },
        setPoint: function() {
          var l = x.read(arguments);
          this.x = l.x, this.y = l.y;
        },
        getSize: function(l) {
          var _ = l ? w : k;
          return new _(this.width, this.height, this, "setSize");
        },
        _fw: 1,
        _fh: 1,
        setSize: function() {
          var l = w.read(arguments), _ = this._sx, I = this._sy, X = l.width, ne = l.height;
          _ && (this.x += (this.width - X) * _), I && (this.y += (this.height - ne) * I), this.width = X, this.height = ne, this._fw = this._fh = 1;
        },
        getLeft: function() {
          return this.x;
        },
        setLeft: function(l) {
          if (!this._fw) {
            var _ = l - this.x;
            this.width -= this._sx === 0.5 ? _ * 2 : _;
          }
          this.x = l, this._sx = this._fw = 0;
        },
        getTop: function() {
          return this.y;
        },
        setTop: function(l) {
          if (!this._fh) {
            var _ = l - this.y;
            this.height -= this._sy === 0.5 ? _ * 2 : _;
          }
          this.y = l, this._sy = this._fh = 0;
        },
        getRight: function() {
          return this.x + this.width;
        },
        setRight: function(l) {
          if (!this._fw) {
            var _ = l - this.x;
            this.width = this._sx === 0.5 ? _ * 2 : _;
          }
          this.x = l - this.width, this._sx = 1, this._fw = 0;
        },
        getBottom: function() {
          return this.y + this.height;
        },
        setBottom: function(l) {
          if (!this._fh) {
            var _ = l - this.y;
            this.height = this._sy === 0.5 ? _ * 2 : _;
          }
          this.y = l - this.height, this._sy = 1, this._fh = 0;
        },
        getCenterX: function() {
          return this.x + this.width / 2;
        },
        setCenterX: function(l) {
          this._fw || this._sx === 0.5 ? this.x = l - this.width / 2 : (this._sx && (this.x += (l - this.x) * 2 * this._sx), this.width = (l - this.x) * 2), this._sx = 0.5, this._fw = 0;
        },
        getCenterY: function() {
          return this.y + this.height / 2;
        },
        setCenterY: function(l) {
          this._fh || this._sy === 0.5 ? this.y = l - this.height / 2 : (this._sy && (this.y += (l - this.y) * 2 * this._sy), this.height = (l - this.y) * 2), this._sy = 0.5, this._fh = 0;
        },
        getCenter: function(l) {
          var _ = l ? x : m;
          return new _(this.getCenterX(), this.getCenterY(), this, "setCenter");
        },
        setCenter: function() {
          var l = x.read(arguments);
          return this.setCenterX(l.x), this.setCenterY(l.y), this;
        },
        getArea: function() {
          return this.width * this.height;
        },
        isEmpty: function() {
          return this.width === 0 || this.height === 0;
        },
        contains: function(l) {
          return l && l.width !== qe || (Array.isArray(l) ? l : arguments).length === 4 ? this._containsRectangle(E.read(arguments)) : this._containsPoint(x.read(arguments));
        },
        _containsPoint: function(l) {
          var _ = l.x, I = l.y;
          return _ >= this.x && I >= this.y && _ <= this.x + this.width && I <= this.y + this.height;
        },
        _containsRectangle: function(l) {
          var _ = l.x, I = l.y;
          return _ >= this.x && I >= this.y && _ + l.width <= this.x + this.width && I + l.height <= this.y + this.height;
        },
        intersects: function() {
          var l = E.read(arguments), _ = q.read(arguments) || 0;
          return l.x + l.width > this.x - _ && l.y + l.height > this.y - _ && l.x < this.x + this.width + _ && l.y < this.y + this.height + _;
        },
        intersect: function() {
          var l = E.read(arguments), _ = Math.max(this.x, l.x), I = Math.max(this.y, l.y), X = Math.min(this.x + this.width, l.x + l.width), ne = Math.min(this.y + this.height, l.y + l.height);
          return new E(_, I, X - _, ne - I);
        },
        unite: function() {
          var l = E.read(arguments), _ = Math.min(this.x, l.x), I = Math.min(this.y, l.y), X = Math.max(this.x + this.width, l.x + l.width), ne = Math.max(this.y + this.height, l.y + l.height);
          return new E(_, I, X - _, ne - I);
        },
        include: function() {
          var l = x.read(arguments), _ = Math.min(this.x, l.x), I = Math.min(this.y, l.y), X = Math.max(this.x + this.width, l.x), ne = Math.max(this.y + this.height, l.y);
          return new E(_, I, X - _, ne - I);
        },
        expand: function() {
          var l = w.read(arguments), _ = l.width, I = l.height;
          return new E(
            this.x - _ / 2,
            this.y - I / 2,
            this.width + _,
            this.height + I
          );
        },
        scale: function(l, _) {
          return this.expand(
            this.width * l - this.width,
            this.height * (_ === qe ? l : _) - this.height
          );
        }
      }, q.each(
        [
          ["Top", "Left"],
          ["Top", "Right"],
          ["Bottom", "Left"],
          ["Bottom", "Right"],
          ["Left", "Center"],
          ["Top", "Center"],
          ["Right", "Center"],
          ["Bottom", "Center"]
        ],
        function(l, _) {
          var I = l.join(""), X = /^[RL]/.test(I);
          _ >= 4 && (l[1] += X ? "Y" : "X");
          var ne = l[X ? 0 : 1], ue = l[X ? 1 : 0], Te = "get" + ne, ye = "get" + ue, Me = "set" + ne, Ge = "set" + ue, Qe = "get" + I, re = "set" + I;
          this[Qe] = function(Se) {
            var Pe = Se ? x : m;
            return new Pe(this[Te](), this[ye](), this, re);
          }, this[re] = function() {
            var Se = x.read(arguments);
            this[Me](Se.x), this[Ge](Se.y);
          };
        },
        {
          beans: !0
        }
      )), P = E.extend(
        {
          initialize: function(_, I, X, ne, ue, Te) {
            this._set(_, I, X, ne, !0), this._owner = ue, this._setter = Te;
          },
          _set: function(l, _, I, X, ne) {
            return this._x = l, this._y = _, this._width = I, this._height = X, ne || this._owner[this._setter](this), this;
          }
        },
        new function() {
          var l = E.prototype;
          return q.each(
            ["x", "y", "width", "height"],
            function(_) {
              var I = q.capitalize(_), X = "_" + _;
              this["get" + I] = function() {
                return this[X];
              }, this["set" + I] = function(ne) {
                this[X] = ne, this._dontNotify || this._owner[this._setter](this);
              };
            },
            q.each(
              [
                "Point",
                "Size",
                "Center",
                "Left",
                "Top",
                "Right",
                "Bottom",
                "CenterX",
                "CenterY",
                "TopLeft",
                "TopRight",
                "BottomLeft",
                "BottomRight",
                "LeftCenter",
                "TopCenter",
                "RightCenter",
                "BottomCenter"
              ],
              function(_) {
                var I = "set" + _;
                this[I] = function() {
                  this._dontNotify = !0, l[I].apply(this, arguments), this._dontNotify = !1, this._owner[this._setter](this);
                };
              },
              {
                isSelected: function() {
                  return !!(this._owner._selection & 2);
                },
                setSelected: function(_) {
                  var I = this._owner;
                  I._changeSelection && I._changeSelection(2, _);
                }
              }
            )
          );
        }()
      ), S = q.extend({
        _class: "Matrix",
        initialize: function l(_, I) {
          var X = arguments, ne = X.length, ue = !0;
          if (ne >= 6 ? this._set.apply(this, X) : ne === 1 || ne === 2 ? _ instanceof l ? this._set(
            _._a,
            _._b,
            _._c,
            _._d,
            _._tx,
            _._ty,
            I
          ) : Array.isArray(_) ? this._set.apply(
            this,
            I ? _.concat([I]) : _
          ) : ue = !1 : ne ? ue = !1 : this.reset(), !ue)
            throw new Error("Unsupported matrix parameters");
          return this;
        },
        set: "#initialize",
        _set: function(l, _, I, X, ne, ue, Te) {
          return this._a = l, this._b = _, this._c = I, this._d = X, this._tx = ne, this._ty = ue, Te || this._changed(), this;
        },
        _serialize: function(l, _) {
          return q.serialize(this.getValues(), l, !0, _);
        },
        _changed: function() {
          var l = this._owner;
          l && (l._applyMatrix ? l.transform(null, !0) : l._changed(25));
        },
        clone: function() {
          return new S(
            this._a,
            this._b,
            this._c,
            this._d,
            this._tx,
            this._ty
          );
        },
        equals: function(l) {
          return l === this || l && this._a === l._a && this._b === l._b && this._c === l._c && this._d === l._d && this._tx === l._tx && this._ty === l._ty;
        },
        toString: function() {
          var l = R.instance;
          return "[[" + [
            l.number(this._a),
            l.number(this._c),
            l.number(this._tx)
          ].join(", ") + "], [" + [
            l.number(this._b),
            l.number(this._d),
            l.number(this._ty)
          ].join(", ") + "]]";
        },
        reset: function(l) {
          return this._a = this._d = 1, this._b = this._c = this._tx = this._ty = 0, l || this._changed(), this;
        },
        apply: function(l, _) {
          var I = this._owner;
          return I ? (I.transform(null, q.pick(l, !0), _), this.isIdentity()) : !1;
        },
        translate: function() {
          var l = x.read(arguments), _ = l.x, I = l.y;
          return this._tx += _ * this._a + I * this._c, this._ty += _ * this._b + I * this._d, this._changed(), this;
        },
        scale: function() {
          var l = arguments, _ = x.read(l), I = x.read(l, 0, { readNull: !0 });
          return I && this.translate(I), this._a *= _.x, this._b *= _.x, this._c *= _.y, this._d *= _.y, I && this.translate(I.negate()), this._changed(), this;
        },
        rotate: function(l) {
          l *= Math.PI / 180;
          var _ = x.read(arguments, 1), I = _.x, X = _.y, ne = Math.cos(l), ue = Math.sin(l), Te = I - I * ne + X * ue, ye = X - I * ue - X * ne, Me = this._a, Ge = this._b, Qe = this._c, re = this._d;
          return this._a = ne * Me + ue * Qe, this._b = ne * Ge + ue * re, this._c = -ue * Me + ne * Qe, this._d = -ue * Ge + ne * re, this._tx += Te * Me + ye * Qe, this._ty += Te * Ge + ye * re, this._changed(), this;
        },
        shear: function() {
          var l = arguments, _ = x.read(l), I = x.read(l, 0, { readNull: !0 });
          I && this.translate(I);
          var X = this._a, ne = this._b;
          return this._a += _.y * this._c, this._b += _.y * this._d, this._c += _.x * X, this._d += _.x * ne, I && this.translate(I.negate()), this._changed(), this;
        },
        skew: function() {
          var l = arguments, _ = x.read(l), I = x.read(l, 0, { readNull: !0 }), X = Math.PI / 180, ne = new x(
            Math.tan(_.x * X),
            Math.tan(_.y * X)
          );
          return this.shear(ne, I);
        },
        append: function(l, _) {
          if (l) {
            var I = this._a, X = this._b, ne = this._c, ue = this._d, Te = l._a, ye = l._c, Me = l._b, Ge = l._d, Qe = l._tx, re = l._ty;
            this._a = Te * I + Me * ne, this._c = ye * I + Ge * ne, this._b = Te * X + Me * ue, this._d = ye * X + Ge * ue, this._tx += Qe * I + re * ne, this._ty += Qe * X + re * ue, _ || this._changed();
          }
          return this;
        },
        prepend: function(l, _) {
          if (l) {
            var I = this._a, X = this._b, ne = this._c, ue = this._d, Te = this._tx, ye = this._ty, Me = l._a, Ge = l._c, Qe = l._b, re = l._d, Se = l._tx, Pe = l._ty;
            this._a = Me * I + Ge * X, this._c = Me * ne + Ge * ue, this._b = Qe * I + re * X, this._d = Qe * ne + re * ue, this._tx = Me * Te + Ge * ye + Se, this._ty = Qe * Te + re * ye + Pe, _ || this._changed();
          }
          return this;
        },
        appended: function(l) {
          return this.clone().append(l);
        },
        prepended: function(l) {
          return this.clone().prepend(l);
        },
        invert: function() {
          var l = this._a, _ = this._b, I = this._c, X = this._d, ne = this._tx, ue = this._ty, Te = l * X - _ * I, ye = null;
          return Te && !isNaN(Te) && isFinite(ne) && isFinite(ue) && (this._a = X / Te, this._b = -_ / Te, this._c = -I / Te, this._d = l / Te, this._tx = (I * ue - X * ne) / Te, this._ty = (_ * ne - l * ue) / Te, ye = this), ye;
        },
        inverted: function() {
          return this.clone().invert();
        },
        concatenate: "#append",
        preConcatenate: "#prepend",
        chain: "#appended",
        _shiftless: function() {
          return new S(this._a, this._b, this._c, this._d, 0, 0);
        },
        _orNullIfIdentity: function() {
          return this.isIdentity() ? null : this;
        },
        isIdentity: function() {
          return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1 && this._tx === 0 && this._ty === 0;
        },
        isInvertible: function() {
          var l = this._a * this._d - this._c * this._b;
          return l && !isNaN(l) && isFinite(this._tx) && isFinite(this._ty);
        },
        isSingular: function() {
          return !this.isInvertible();
        },
        transform: function(l, _, I) {
          return arguments.length < 3 ? this._transformPoint(x.read(arguments)) : this._transformCoordinates(l, _, I);
        },
        _transformPoint: function(l, _, I) {
          var X = l.x, ne = l.y;
          return _ || (_ = new x()), _._set(
            X * this._a + ne * this._c + this._tx,
            X * this._b + ne * this._d + this._ty,
            I
          );
        },
        _transformCoordinates: function(l, _, I) {
          for (var X = 0, ne = 2 * I; X < ne; X += 2) {
            var ue = l[X], Te = l[X + 1];
            _[X] = ue * this._a + Te * this._c + this._tx, _[X + 1] = ue * this._b + Te * this._d + this._ty;
          }
          return _;
        },
        _transformCorners: function(l) {
          var _ = l.x, I = l.y, X = _ + l.width, ne = I + l.height, ue = [_, I, X, I, X, ne, _, ne];
          return this._transformCoordinates(ue, ue, 4);
        },
        _transformBounds: function(l, _, I) {
          for (var X = this._transformCorners(l), ne = X.slice(0, 2), ue = ne.slice(), Te = 2; Te < 8; Te++) {
            var ye = X[Te], Me = Te & 1;
            ye < ne[Me] ? ne[Me] = ye : ye > ue[Me] && (ue[Me] = ye);
          }
          return _ || (_ = new E()), _._set(
            ne[0],
            ne[1],
            ue[0] - ne[0],
            ue[1] - ne[1],
            I
          );
        },
        inverseTransform: function() {
          return this._inverseTransform(x.read(arguments));
        },
        _inverseTransform: function(l, _, I) {
          var X = this._a, ne = this._b, ue = this._c, Te = this._d, ye = this._tx, Me = this._ty, Ge = X * Te - ne * ue, Qe = null;
          if (Ge && !isNaN(Ge) && isFinite(ye) && isFinite(Me)) {
            var re = l.x - this._tx, Se = l.y - this._ty;
            _ || (_ = new x()), Qe = _._set(
              (re * Te - Se * ue) / Ge,
              (Se * X - re * ne) / Ge,
              I
            );
          }
          return Qe;
        },
        decompose: function() {
          var l = this._a, _ = this._b, I = this._c, X = this._d, ne = l * X - _ * I, ue = Math.sqrt, Te = Math.atan2, ye = 180 / Math.PI, Me, Ge, Qe;
          if (l !== 0 || _ !== 0) {
            var re = ue(l * l + _ * _);
            Me = Math.acos(l / re) * (_ > 0 ? 1 : -1), Ge = [re, ne / re], Qe = [Te(l * I + _ * X, re * re), 0];
          } else if (I !== 0 || X !== 0) {
            var Se = ue(I * I + X * X);
            Me = Math.asin(I / Se) * (X > 0 ? 1 : -1), Ge = [ne / Se, Se], Qe = [0, Te(l * I + _ * X, Se * Se)];
          } else
            Me = 0, Qe = Ge = [0, 0];
          return {
            translation: this.getTranslation(),
            rotation: Me * ye,
            scaling: new x(Ge),
            skewing: new x(Qe[0] * ye, Qe[1] * ye)
          };
        },
        getValues: function() {
          return [this._a, this._b, this._c, this._d, this._tx, this._ty];
        },
        getTranslation: function() {
          return new x(this._tx, this._ty);
        },
        getScaling: function() {
          return this.decompose().scaling;
        },
        getRotation: function() {
          return this.decompose().rotation;
        },
        applyToContext: function(l) {
          this.isIdentity() || l.transform(
            this._a,
            this._b,
            this._c,
            this._d,
            this._tx,
            this._ty
          );
        }
      }, q.each(["a", "b", "c", "d", "tx", "ty"], function(l) {
        var _ = q.capitalize(l), I = "_" + l;
        this["get" + _] = function() {
          return this[I];
        }, this["set" + _] = function(X) {
          this[I] = X, this._changed();
        };
      }, {})), U = q.extend({
        _class: "Line",
        initialize: function(_, I, X, ne, ue) {
          var Te = !1;
          arguments.length >= 4 ? (this._px = _, this._py = I, this._vx = X, this._vy = ne, Te = ue) : (this._px = _.x, this._py = _.y, this._vx = I.x, this._vy = I.y, Te = X), Te || (this._vx -= this._px, this._vy -= this._py);
        },
        getPoint: function() {
          return new x(this._px, this._py);
        },
        getVector: function() {
          return new x(this._vx, this._vy);
        },
        getLength: function() {
          return this.getVector().getLength();
        },
        intersect: function(l, _) {
          return U.intersect(
            this._px,
            this._py,
            this._vx,
            this._vy,
            l._px,
            l._py,
            l._vx,
            l._vy,
            !0,
            _
          );
        },
        getSide: function(l, _) {
          return U.getSide(
            this._px,
            this._py,
            this._vx,
            this._vy,
            l.x,
            l.y,
            !0,
            _
          );
        },
        getDistance: function(l) {
          return Math.abs(this.getSignedDistance(l));
        },
        getSignedDistance: function(l) {
          return U.getSignedDistance(
            this._px,
            this._py,
            this._vx,
            this._vy,
            l.x,
            l.y,
            !0
          );
        },
        isCollinear: function(l) {
          return x.isCollinear(this._vx, this._vy, l._vx, l._vy);
        },
        isOrthogonal: function(l) {
          return x.isOrthogonal(this._vx, this._vy, l._vx, l._vy);
        },
        statics: {
          intersect: function(l, _, I, X, ne, ue, Te, ye, Me, Ge) {
            Me || (I -= l, X -= _, Te -= ne, ye -= ue);
            var Qe = I * ye - X * Te;
            if (!A.isMachineZero(Qe)) {
              var re = l - ne, Se = _ - ue, Pe = (Te * Se - ye * re) / Qe, at = (I * Se - X * re) / Qe, Be = 1e-12, Ze = -Be, fe = 1 + Be;
              if (Ge || Ze < Pe && Pe < fe && Ze < at && at < fe)
                return Ge || (Pe = Pe <= 0 ? 0 : Pe >= 1 ? 1 : Pe), new x(
                  l + Pe * I,
                  _ + Pe * X
                );
            }
          },
          getSide: function(l, _, I, X, ne, ue, Te, ye) {
            Te || (I -= l, X -= _);
            var Me = ne - l, Ge = ue - _, Qe = Me * X - Ge * I;
            return !ye && A.isMachineZero(Qe) && (Qe = (Me * I + Me * I) / (I * I + X * X), Qe >= 0 && Qe <= 1 && (Qe = 0)), Qe < 0 ? -1 : Qe > 0 ? 1 : 0;
          },
          getSignedDistance: function(l, _, I, X, ne, ue, Te) {
            return Te || (I -= l, X -= _), I === 0 ? X > 0 ? ne - l : l - ne : X === 0 ? I < 0 ? ue - _ : _ - ue : ((ne - l) * X - (ue - _) * I) / (X > I ? X * Math.sqrt(1 + I * I / (X * X)) : I * Math.sqrt(1 + X * X / (I * I)));
          },
          getDistance: function(l, _, I, X, ne, ue, Te) {
            return Math.abs(
              U.getSignedDistance(l, _, I, X, ne, ue, Te)
            );
          }
        }
      }), j = N.extend({
        _class: "Project",
        _list: "projects",
        _reference: "project",
        _compactSerialize: !0,
        initialize: function(_) {
          N.call(this, !0), this._children = [], this._namedChildren = {}, this._activeLayer = null, this._currentStyle = new Ht(null, null, this), this._view = ri.create(
            this,
            _ || _t.getCanvas(1, 1)
          ), this._selectionItems = {}, this._selectionCount = 0, this._updateVersion = 0;
        },
        _serialize: function(l, _) {
          return q.serialize(this._children, l, !0, _);
        },
        _changed: function(l, _) {
          if (l & 1) {
            var I = this._view;
            I && (I._needsUpdate = !0, !I._requested && I._autoUpdate && I.requestUpdate());
          }
          var X = this._changes;
          if (X && _) {
            var ne = this._changesById, ue = _._id, Te = ne[ue];
            Te ? Te.flags |= l : X.push(ne[ue] = { item: _, flags: l });
          }
        },
        clear: function() {
          for (var l = this._children, _ = l.length - 1; _ >= 0; _--)
            l[_].remove();
        },
        isEmpty: function() {
          return !this._children.length;
        },
        remove: function l() {
          return l.base.call(this) ? (this._view && this._view.remove(), !0) : !1;
        },
        getView: function() {
          return this._view;
        },
        getCurrentStyle: function() {
          return this._currentStyle;
        },
        setCurrentStyle: function(l) {
          this._currentStyle.set(l);
        },
        getIndex: function() {
          return this._index;
        },
        getOptions: function() {
          return this._scope.settings;
        },
        getLayers: function() {
          return this._children;
        },
        getActiveLayer: function() {
          return this._activeLayer || new J({ project: this, insert: !0 });
        },
        getSymbolDefinitions: function() {
          var l = [], _ = {};
          return this.getItems({
            class: le,
            match: function(I) {
              var X = I._definition, ne = X._id;
              return _[ne] || (_[ne] = !0, l.push(X)), !1;
            }
          }), l;
        },
        getSymbols: "getSymbolDefinitions",
        getSelectedItems: function() {
          var l = this._selectionItems, _ = [];
          for (var I in l) {
            var X = l[I], ne = X._selection;
            ne & 1 && X.isInserted() ? _.push(X) : ne || this._updateSelection(X);
          }
          return _;
        },
        _updateSelection: function(l) {
          var _ = l._id, I = this._selectionItems;
          l._selection ? I[_] !== l && (this._selectionCount++, I[_] = l) : I[_] === l && (this._selectionCount--, delete I[_]);
        },
        selectAll: function() {
          for (var l = this._children, _ = 0, I = l.length; _ < I; _++)
            l[_].setFullySelected(!0);
        },
        deselectAll: function() {
          var l = this._selectionItems;
          for (var _ in l)
            l[_].setFullySelected(!1);
        },
        addLayer: function(l) {
          return this.insertLayer(qe, l);
        },
        insertLayer: function(l, _) {
          if (_ instanceof J) {
            _._remove(!1, !0), q.splice(this._children, [_], l, 0), _._setProject(this, !0);
            var I = _._name;
            I && _.setName(I), this._changes && _._changed(5), this._activeLayer || (this._activeLayer = _);
          } else
            _ = null;
          return _;
        },
        _insertItem: function(l, _, I) {
          return _ = this.insertLayer(l, _) || (this._activeLayer || this._insertItem(
            qe,
            new J(T.NO_INSERT),
            !0
          )).insertChild(l, _), I && _.activate && _.activate(), _;
        },
        getItems: function(l) {
          return T._getItems(this, l);
        },
        getItem: function(l) {
          return T._getItems(this, l, null, null, !0)[0] || null;
        },
        importJSON: function(l) {
          this.activate();
          var _ = this._activeLayer;
          return q.importJSON(l, _ && _.isEmpty() && _);
        },
        removeOn: function(l) {
          var _ = this._removeSets;
          if (_) {
            l === "mouseup" && (_.mousedrag = null);
            var I = _[l];
            if (I) {
              for (var X in I) {
                var ne = I[X];
                for (var ue in _) {
                  var Te = _[ue];
                  Te && Te != I && delete Te[ne._id];
                }
                ne.remove();
              }
              _[l] = null;
            }
          }
        },
        draw: function(l, _, I) {
          this._updateVersion++, l.save(), _.applyToContext(l);
          for (var X = this._children, ne = new q({
            offset: new x(0, 0),
            pixelRatio: I,
            viewMatrix: _.isIdentity() ? null : _,
            matrices: [new S()],
            updateMatrix: !0
          }), ue = 0, Te = X.length; ue < Te; ue++)
            X[ue].draw(l, ne);
          if (l.restore(), this._selectionCount > 0) {
            l.save(), l.strokeWidth = 1;
            var ye = this._selectionItems, Me = this._scope.settings.handleSize, Ge = this._updateVersion;
            for (var Qe in ye)
              ye[Qe]._drawSelection(l, _, Me, ye, Ge);
            l.restore();
          }
        }
      }), T = q.extend(
        ie,
        {
          statics: {
            extend: function l(_) {
              return _._serializeFields && (_._serializeFields = q.set(
                {},
                this.prototype._serializeFields,
                _._serializeFields
              )), l.base.apply(this, arguments);
            },
            INSERT: { insert: !0 },
            NO_INSERT: { insert: !1 }
          },
          _class: "Item",
          _name: null,
          _applyMatrix: !0,
          _canApplyMatrix: !0,
          _canScaleStroke: !1,
          _pivot: null,
          _visible: !0,
          _blendMode: "normal",
          _opacity: 1,
          _locked: !1,
          _guide: !1,
          _clipMask: !1,
          _selection: 0,
          _selectBounds: !0,
          _selectChildren: !1,
          _serializeFields: {
            name: null,
            applyMatrix: null,
            matrix: new S(),
            pivot: null,
            visible: !0,
            blendMode: "normal",
            opacity: 1,
            locked: !1,
            guide: !1,
            clipMask: !1,
            selected: !1,
            data: {}
          },
          _prioritize: ["applyMatrix"]
        },
        new function() {
          var l = [
            "onMouseDown",
            "onMouseUp",
            "onMouseDrag",
            "onClick",
            "onDoubleClick",
            "onMouseMove",
            "onMouseEnter",
            "onMouseLeave"
          ];
          return q.each(
            l,
            function(_) {
              this._events[_] = {
                install: function(I) {
                  this.getView()._countItemEvent(I, 1);
                },
                uninstall: function(I) {
                  this.getView()._countItemEvent(I, -1);
                }
              };
            },
            {
              _events: {
                onFrame: {
                  install: function() {
                    this.getView()._animateItem(this, !0);
                  },
                  uninstall: function() {
                    this.getView()._animateItem(this, !1);
                  }
                },
                onLoad: {},
                onError: {}
              },
              statics: {
                _itemHandlers: l
              }
            }
          );
        }(),
        {
          initialize: function() {
          },
          _initialize: function(l, _) {
            var I = l && q.isPlainObject(l), X = I && l.internal === !0, ne = this._matrix = new S(), ue = I && l.project || xt.project, Te = xt.settings;
            return this._id = X ? null : M.get(), this._parent = this._index = null, this._applyMatrix = this._canApplyMatrix && Te.applyMatrix, _ && ne.translate(_), ne._owner = this, this._style = new Ht(ue._currentStyle, this, ue), X || I && l.insert == !1 || !Te.insertItems && !(I && l.insert == !0) ? this._setProject(ue) : (I && l.parent || ue)._insertItem(qe, this, !0), I && l !== T.NO_INSERT && l !== T.INSERT && this.set(l, {
              internal: !0,
              insert: !0,
              project: !0,
              parent: !0
            }), I;
          },
          _serialize: function(l, _) {
            var I = {}, X = this;
            function ne(ue) {
              for (var Te in ue) {
                var ye = X[Te];
                q.equals(ye, Te === "leading" ? ue.fontSize * 1.2 : ue[Te]) || (I[Te] = q.serialize(
                  ye,
                  l,
                  Te !== "data",
                  _
                ));
              }
            }
            return ne(this._serializeFields), this instanceof W || ne(this._style._defaults), [this._class, I];
          },
          _changed: function(l) {
            var _ = this._symbol, I = this._parent || _, X = this._project;
            l & 8 && (this._bounds = this._position = this._decomposed = qe), l & 16 && (this._globalMatrix = qe), I && l & 72 && T._clearBoundsCache(I), l & 2 && T._clearBoundsCache(this), X && X._changed(l, this), _ && _._changed(l);
          },
          getId: function() {
            return this._id;
          },
          getName: function() {
            return this._name;
          },
          setName: function(l) {
            if (this._name && this._removeNamed(), l === +l + "")
              throw new Error(
                "Names consisting only of numbers are not supported."
              );
            var _ = this._getOwner();
            if (l && _) {
              var I = _._children, X = _._namedChildren;
              (X[l] = X[l] || []).push(this), l in I || (I[l] = this);
            }
            this._name = l || qe, this._changed(256);
          },
          getStyle: function() {
            return this._style;
          },
          setStyle: function(l) {
            this.getStyle().set(l);
          }
        },
        q.each(
          ["locked", "visible", "blendMode", "opacity", "guide"],
          function(l) {
            var _ = q.capitalize(l), I = "_" + l, X = {
              locked: 256,
              visible: 265
            };
            this["get" + _] = function() {
              return this[I];
            }, this["set" + _] = function(ne) {
              ne != this[I] && (this[I] = ne, this._changed(X[l] || 257));
            };
          },
          {}
        ),
        {
          beans: !0,
          getSelection: function() {
            return this._selection;
          },
          setSelection: function(l) {
            if (l !== this._selection) {
              this._selection = l;
              var _ = this._project;
              _ && (_._updateSelection(this), this._changed(257));
            }
          },
          _changeSelection: function(l, _) {
            var I = this._selection;
            this.setSelection(_ ? I | l : I & ~l);
          },
          isSelected: function() {
            if (this._selectChildren) {
              for (var l = this._children, _ = 0, I = l.length; _ < I; _++)
                if (l[_].isSelected())
                  return !0;
            }
            return !!(this._selection & 1);
          },
          setSelected: function(l) {
            if (this._selectChildren)
              for (var _ = this._children, I = 0, X = _.length; I < X; I++)
                _[I].setSelected(l);
            this._changeSelection(1, l);
          },
          isFullySelected: function() {
            var l = this._children, _ = !!(this._selection & 1);
            if (l && _) {
              for (var I = 0, X = l.length; I < X; I++)
                if (!l[I].isFullySelected())
                  return !1;
              return !0;
            }
            return _;
          },
          setFullySelected: function(l) {
            var _ = this._children;
            if (_)
              for (var I = 0, X = _.length; I < X; I++)
                _[I].setFullySelected(l);
            this._changeSelection(1, l);
          },
          isClipMask: function() {
            return this._clipMask;
          },
          setClipMask: function(l) {
            this._clipMask != (l = !!l) && (this._clipMask = l, l && (this.setFillColor(null), this.setStrokeColor(null)), this._changed(257), this._parent && this._parent._changed(2048));
          },
          getData: function() {
            return this._data || (this._data = {}), this._data;
          },
          setData: function(l) {
            this._data = l;
          },
          getPosition: function(l) {
            var _ = l ? x : m, I = this._position || (this._position = this._getPositionFromBounds());
            return new _(I.x, I.y, this, "setPosition");
          },
          setPosition: function() {
            this.translate(x.read(arguments).subtract(this.getPosition(!0)));
          },
          _getPositionFromBounds: function(l) {
            return this._pivot ? this._matrix._transformPoint(this._pivot) : (l || this.getBounds()).getCenter(!0);
          },
          getPivot: function() {
            var l = this._pivot;
            return l ? new m(l.x, l.y, this, "setPivot") : null;
          },
          setPivot: function() {
            this._pivot = x.read(arguments, 0, { clone: !0, readNull: !0 }), this._position = qe;
          }
        },
        q.each(
          {
            getStrokeBounds: { stroke: !0 },
            getHandleBounds: { handle: !0 },
            getInternalBounds: { internal: !0 }
          },
          function(l, _) {
            this[_] = function(I) {
              return this.getBounds(I, l);
            };
          },
          {
            beans: !0,
            getBounds: function(l, _) {
              var I = _ || l instanceof S, X = q.set(
                {},
                I ? _ : l,
                this._boundsOptions
              );
              (!X.stroke || this.getStrokeScaling()) && (X.cacheItem = this);
              var ne = this._getCachedBounds(I && l, X).rect;
              return arguments.length ? ne : new P(
                ne.x,
                ne.y,
                ne.width,
                ne.height,
                this,
                "setBounds"
              );
            },
            setBounds: function() {
              var l = E.read(arguments), _ = this.getBounds(), I = this._matrix, X = new S(), ne = l.getCenter();
              X.translate(ne), (l.width != _.width || l.height != _.height) && (I.isInvertible() || (I.set(I._backup || new S().translate(I.getTranslation())), _ = this.getBounds()), X.scale(
                _.width !== 0 ? l.width / _.width : 0,
                _.height !== 0 ? l.height / _.height : 0
              )), ne = _.getCenter(), X.translate(-ne.x, -ne.y), this.transform(X);
            },
            _getBounds: function(l, _) {
              var I = this._children;
              return !I || !I.length ? new E() : (T._updateBoundsCache(this, _.cacheItem), T._getBounds(I, l, _));
            },
            _getBoundsCacheKey: function(l, _) {
              return [
                l.stroke ? 1 : 0,
                l.handle ? 1 : 0,
                _ ? 1 : 0
              ].join("");
            },
            _getCachedBounds: function(l, _, I) {
              l = l && l._orNullIfIdentity();
              var X = _.internal && !I, ne = _.cacheItem, ue = X ? null : this._matrix._orNullIfIdentity(), Te = ne && (!l || l.equals(ue)) && this._getBoundsCacheKey(_, X), ye = this._bounds;
              if (T._updateBoundsCache(this._parent || this._symbol, ne), Te && ye && Te in ye) {
                var Me = ye[Te];
                return {
                  rect: Me.rect.clone(),
                  nonscaling: Me.nonscaling
                };
              }
              var Ge = this._getBounds(l || ue, _), Qe = Ge.rect || Ge, re = this._style, Se = Ge.nonscaling || re.hasStroke() && !re.getStrokeScaling();
              if (Te) {
                ye || (this._bounds = ye = {});
                var Me = ye[Te] = {
                  rect: Qe.clone(),
                  nonscaling: Se,
                  internal: X
                };
              }
              return {
                rect: Qe,
                nonscaling: Se
              };
            },
            _getStrokeMatrix: function(l, _) {
              var I = this.getStrokeScaling() ? null : _ && _.internal ? this : this._parent || this._symbol && this._symbol._item, X = I ? I.getViewMatrix().invert() : l;
              return X && X._shiftless();
            },
            statics: {
              _updateBoundsCache: function(l, _) {
                if (l && _) {
                  var I = _._id, X = l._boundsCache = l._boundsCache || {
                    ids: {},
                    list: []
                  };
                  X.ids[I] || (X.list.push(_), X.ids[I] = _);
                }
              },
              _clearBoundsCache: function(l) {
                var _ = l._boundsCache;
                if (_) {
                  l._bounds = l._position = l._boundsCache = qe;
                  for (var I = 0, X = _.list, ne = X.length; I < ne; I++) {
                    var ue = X[I];
                    ue !== l && (ue._bounds = ue._position = qe, ue._boundsCache && T._clearBoundsCache(ue));
                  }
                }
              },
              _getBounds: function(l, _, I) {
                var X = 1 / 0, ne = -X, ue = X, Te = ne, ye = !1;
                I = I || {};
                for (var Me = 0, Ge = l.length; Me < Ge; Me++) {
                  var Qe = l[Me];
                  if (Qe._visible && !Qe.isEmpty(!0)) {
                    var re = Qe._getCachedBounds(
                      _ && _.appended(Qe._matrix),
                      I,
                      !0
                    ), Se = re.rect;
                    X = Math.min(Se.x, X), ue = Math.min(Se.y, ue), ne = Math.max(Se.x + Se.width, ne), Te = Math.max(Se.y + Se.height, Te), re.nonscaling && (ye = !0);
                  }
                }
                return {
                  rect: isFinite(X) ? new E(X, ue, ne - X, Te - ue) : new E(),
                  nonscaling: ye
                };
              }
            }
          }
        ),
        {
          beans: !0,
          _decompose: function() {
            return this._applyMatrix ? null : this._decomposed || (this._decomposed = this._matrix.decompose());
          },
          getRotation: function() {
            var l = this._decompose();
            return l ? l.rotation : 0;
          },
          setRotation: function(l) {
            var _ = this.getRotation();
            if (_ != null && l != null) {
              var I = this._decomposed;
              this.rotate(l - _), I && (I.rotation = l, this._decomposed = I);
            }
          },
          getScaling: function() {
            var l = this._decompose(), _ = l && l.scaling;
            return new m(_ ? _.x : 1, _ ? _.y : 1, this, "setScaling");
          },
          setScaling: function() {
            var l = this.getScaling(), _ = x.read(arguments, 0, { clone: !0, readNull: !0 });
            if (l && _ && !l.equals(_)) {
              var I = this.getRotation(), X = this._decomposed, ne = new S(), ue = A.isZero;
              if (ue(l.x) || ue(l.y))
                ne.translate(X.translation), I && ne.rotate(I), ne.scale(_.x, _.y), this._matrix.set(ne);
              else {
                var Te = this.getPosition(!0);
                ne.translate(Te), I && ne.rotate(I), ne.scale(_.x / l.x, _.y / l.y), I && ne.rotate(-I), ne.translate(Te.negate()), this.transform(ne);
              }
              X && (X.scaling = _, this._decomposed = X);
            }
          },
          getMatrix: function() {
            return this._matrix;
          },
          setMatrix: function() {
            var l = this._matrix;
            l.set.apply(l, arguments);
          },
          getGlobalMatrix: function(l) {
            var _ = this._globalMatrix;
            if (_)
              for (var I = this._parent, X = []; I; ) {
                if (!I._globalMatrix) {
                  _ = null;
                  for (var ne = 0, ue = X.length; ne < ue; ne++)
                    X[ne]._globalMatrix = null;
                  break;
                }
                X.push(I), I = I._parent;
              }
            if (!_) {
              _ = this._globalMatrix = this._matrix.clone();
              var I = this._parent;
              I && _.prepend(I.getGlobalMatrix(!0));
            }
            return l ? _ : _.clone();
          },
          getViewMatrix: function() {
            return this.getGlobalMatrix().prepend(this.getView()._matrix);
          },
          getApplyMatrix: function() {
            return this._applyMatrix;
          },
          setApplyMatrix: function(l) {
            (this._applyMatrix = this._canApplyMatrix && !!l) && this.transform(null, !0);
          },
          getTransformContent: "#getApplyMatrix",
          setTransformContent: "#setApplyMatrix"
        },
        {
          getProject: function() {
            return this._project;
          },
          _setProject: function(l, _) {
            if (this._project !== l) {
              this._project && this._installEvents(!1), this._project = l;
              for (var I = this._children, X = 0, ne = I && I.length; X < ne; X++)
                I[X]._setProject(l);
              _ = !0;
            }
            _ && this._installEvents(!0);
          },
          getView: function() {
            return this._project._view;
          },
          _installEvents: function l(_) {
            l.base.call(this, _);
            for (var I = this._children, X = 0, ne = I && I.length; X < ne; X++)
              I[X]._installEvents(_);
          },
          getLayer: function() {
            for (var l = this; l = l._parent; )
              if (l instanceof J)
                return l;
            return null;
          },
          getParent: function() {
            return this._parent;
          },
          setParent: function(l) {
            return l.addChild(this);
          },
          _getOwner: "#getParent",
          getChildren: function() {
            return this._children;
          },
          setChildren: function(l) {
            this.removeChildren(), this.addChildren(l);
          },
          getFirstChild: function() {
            return this._children && this._children[0] || null;
          },
          getLastChild: function() {
            return this._children && this._children[this._children.length - 1] || null;
          },
          getNextSibling: function() {
            var l = this._getOwner();
            return l && l._children[this._index + 1] || null;
          },
          getPreviousSibling: function() {
            var l = this._getOwner();
            return l && l._children[this._index - 1] || null;
          },
          getIndex: function() {
            return this._index;
          },
          setIndex: function(l) {
            var _ = this._parent, I = _ && _._children;
            I && _.insertChildren(
              l in I ? l : qe,
              [this]
            );
          },
          equals: function(l) {
            return l === this || l && this._class === l._class && this._style.equals(l._style) && this._matrix.equals(l._matrix) && this._locked === l._locked && this._visible === l._visible && this._blendMode === l._blendMode && this._opacity === l._opacity && this._clipMask === l._clipMask && this._guide === l._guide && this._equals(l) || !1;
          },
          _equals: function(l) {
            return q.equals(this._children, l._children);
          },
          clone: function(l) {
            var _ = new this.constructor(T.NO_INSERT), I = this._children, X = q.pick(
              l ? l.insert : qe,
              l === qe || l === !0
            ), ne = q.pick(l ? l.deep : qe, !0);
            I && _.copyAttributes(this), (!I || ne) && _.copyContent(this), I || _.copyAttributes(this), X && _.insertAbove(this);
            var ue = this._name, Te = this._parent;
            if (ue && Te) {
              for (var I = Te._children, ye = ue, Me = 1; I[ue]; )
                ue = ye + " " + Me++;
              ue !== ye && _.setName(ue);
            }
            return _;
          },
          copyContent: function(l) {
            for (var _ = l._children, I = 0, X = _ && _.length; I < X; I++)
              this.addChild(_[I].clone(!1), !0);
          },
          copyAttributes: function(l, _) {
            this.setStyle(l._style);
            for (var I = [
              "_locked",
              "_visible",
              "_blendMode",
              "_opacity",
              "_clipMask",
              "_guide"
            ], X = 0, ne = I.length; X < ne; X++) {
              var ue = I[X];
              l.hasOwnProperty(ue) && (this[ue] = l[ue]);
            }
            _ || this._matrix.set(l._matrix, !0), this.setApplyMatrix(l._applyMatrix), this.setPivot(l._pivot), this.setSelection(l._selection);
            var Te = l._data, ye = l._name;
            this._data = Te ? q.clone(Te) : null, ye && this.setName(ye);
          },
          rasterize: function(l, _) {
            var I, X, ne;
            q.isPlainObject(l) ? (I = l.resolution, X = l.insert, ne = l.raster) : (I = l, X = _), ne || (ne = new te(T.NO_INSERT));
            var ue = this.getStrokeBounds(), Te = (I || this.getView().getResolution()) / 72, ye = ue.getTopLeft().floor(), Me = ue.getBottomRight().ceil(), Ge = new w(Me.subtract(ye)), Qe = Ge.multiply(Te);
            if (ne.setSize(Qe, !0), !Qe.isZero()) {
              var re = ne.getContext(!0), Se = new S().scale(Te).translate(ye.negate());
              re.save(), Se.applyToContext(re), this.draw(re, new q({ matrices: [Se] })), re.restore();
            }
            return ne._matrix.set(
              new S().translate(ye.add(Ge.divide(2))).scale(1 / Te)
            ), (X === qe || X) && ne.insertAbove(this), ne;
          },
          contains: function() {
            var l = this._matrix;
            return l.isInvertible() && !!this._contains(l._inverseTransform(x.read(arguments)));
          },
          _contains: function(l) {
            var _ = this._children;
            if (_) {
              for (var I = _.length - 1; I >= 0; I--)
                if (_[I].contains(l))
                  return !0;
              return !1;
            }
            return l.isInside(this.getInternalBounds());
          },
          isInside: function() {
            return E.read(arguments).contains(this.getBounds());
          },
          _asPathItem: function() {
            return new Ce.Rectangle({
              rectangle: this.getInternalBounds(),
              matrix: this._matrix,
              insert: !1
            });
          },
          intersects: function(l, _) {
            return l instanceof T ? this._asPathItem().getIntersections(
              l._asPathItem(),
              null,
              _,
              !0
            ).length > 0 : !1;
          }
        },
        new function() {
          function l() {
            var X = arguments;
            return this._hitTest(
              x.read(X),
              ke.getOptions(X)
            );
          }
          function _() {
            var X = arguments, ne = x.read(X), ue = ke.getOptions(X), Te = [];
            return this._hitTest(ne, new q({ all: Te }, ue)), Te;
          }
          function I(X, ne, ue, Te) {
            var ye = this._children;
            if (ye)
              for (var Me = ye.length - 1; Me >= 0; Me--) {
                var Ge = ye[Me], Qe = Ge !== Te && Ge._hitTest(
                  X,
                  ne,
                  ue
                );
                if (Qe && !ne.all)
                  return Qe;
              }
            return null;
          }
          return j.inject({
            hitTest: l,
            hitTestAll: _,
            _hitTest: I
          }), {
            hitTest: l,
            hitTestAll: _,
            _hitTestChildren: I
          };
        }(),
        {
          _hitTest: function(l, _, I) {
            if (this._locked || !this._visible || this._guide && !_.guides || this.isEmpty())
              return null;
            var X = this._matrix, ne = I ? I.appended(X) : this.getGlobalMatrix().prepend(this.getView()._matrix), ue = Math.max(_.tolerance, 1e-12), Te = _._tolerancePadding = new w(
              Ce._getStrokePadding(
                ue,
                X._shiftless().invert()
              )
            );
            if (l = X._inverseTransform(l), !l || !this._children && !this.getBounds({ internal: !0, stroke: !0, handle: !0 }).expand(Te.multiply(2))._containsPoint(l))
              return null;
            var ye = !(_.guides && !this._guide || _.selected && !this.isSelected() || _.type && _.type !== q.hyphenate(this._class) || _.class && !(this instanceof _.class)), Me = _.match, Ge = this, Qe, re;
            function Se(Xe) {
              return Xe && Me && !Me(Xe) && (Xe = null), Xe && _.all && _.all.push(Xe), Xe;
            }
            function Pe(Xe, z) {
              var He = z ? Qe["get" + z]() : Ge.getPosition();
              if (l.subtract(He).divide(Te).length <= 1)
                return new ke(Xe, Ge, {
                  name: z ? q.hyphenate(z) : Xe,
                  point: He
                });
            }
            var at = _.position, Be = _.center, Ze = _.bounds;
            if (ye && this._parent && (at || Be || Ze)) {
              if ((Be || Ze) && (Qe = this.getInternalBounds()), re = at && Pe("position") || Be && Pe("center", "Center"), !re && Ze)
                for (var fe = [
                  "TopLeft",
                  "TopRight",
                  "BottomLeft",
                  "BottomRight",
                  "LeftCenter",
                  "TopCenter",
                  "RightCenter",
                  "BottomCenter"
                ], Je = 0; Je < 8 && !re; Je++)
                  re = Pe("bounds", fe[Je]);
              re = Se(re);
            }
            return re || (re = this._hitTestChildren(l, _, ne) || ye && Se(this._hitTestSelf(
              l,
              _,
              ne,
              this.getStrokeScaling() ? null : ne._shiftless().invert()
            )) || null), re && re.point && (re.point = X.transform(re.point)), re;
          },
          _hitTestSelf: function(l, _) {
            if (_.fill && this.hasFill() && this._contains(l))
              return new ke("fill", this);
          },
          matches: function(l, _) {
            function I(Te, ye) {
              for (var Me in Te)
                if (Te.hasOwnProperty(Me)) {
                  var Ge = Te[Me], Qe = ye[Me];
                  if (q.isPlainObject(Ge) && q.isPlainObject(Qe)) {
                    if (!I(Ge, Qe))
                      return !1;
                  } else if (!q.equals(Ge, Qe))
                    return !1;
                }
              return !0;
            }
            var X = typeof l;
            if (X === "object") {
              for (var ne in l)
                if (l.hasOwnProperty(ne) && !this.matches(ne, l[ne]))
                  return !1;
              return !0;
            } else {
              if (X === "function")
                return l(this);
              if (l === "match")
                return _(this);
              var ue = /^(empty|editable)$/.test(l) ? this["is" + q.capitalize(l)]() : l === "type" ? q.hyphenate(this._class) : this[l];
              if (l === "class") {
                if (typeof _ == "function")
                  return this instanceof _;
                ue = this._class;
              }
              if (typeof _ == "function")
                return !!_(ue);
              if (_) {
                if (_.test)
                  return _.test(ue);
                if (q.isPlainObject(_))
                  return I(_, ue);
              }
              return q.equals(ue, _);
            }
          },
          getItems: function(l) {
            return T._getItems(this, l, this._matrix);
          },
          getItem: function(l) {
            return T._getItems(this, l, this._matrix, null, !0)[0] || null;
          },
          statics: {
            _getItems: function l(_, I, X, ne, ue) {
              if (!ne) {
                var Te = typeof I == "object" && I, ye = Te && Te.overlapping, Me = Te && Te.inside, Ge = ye || Me, Se = Ge && E.read([Ge]);
                ne = {
                  items: [],
                  recursive: Te && Te.recursive !== !1,
                  inside: !!Me,
                  overlapping: !!ye,
                  rect: Se,
                  path: ye && new Ce.Rectangle({
                    rectangle: Se,
                    insert: !1
                  })
                }, Te && (I = q.filter({}, I, {
                  recursive: !0,
                  inside: !0,
                  overlapping: !0
                }));
              }
              var Qe = _._children, re = ne.items, Se = ne.rect;
              X = Se && (X || new S());
              for (var Pe = 0, at = Qe && Qe.length; Pe < at; Pe++) {
                var Be = Qe[Pe], Ze = X && X.appended(Be._matrix), fe = !0;
                if (Se) {
                  var Ge = Be.getBounds(Ze);
                  if (!Se.intersects(Ge))
                    continue;
                  Se.contains(Ge) || ne.overlapping && (Ge.contains(Se) || ne.path.intersects(Be, Ze)) || (fe = !1);
                }
                if (fe && Be.matches(I) && (re.push(Be), ue) || (ne.recursive !== !1 && l(Be, I, Ze, ne, ue), ue && re.length > 0))
                  break;
              }
              return re;
            }
          }
        },
        {
          importJSON: function(l) {
            var _ = q.importJSON(l, this);
            return _ !== this ? this.addChild(_) : _;
          },
          addChild: function(l) {
            return this.insertChild(qe, l);
          },
          insertChild: function(l, _) {
            var I = _ ? this.insertChildren(l, [_]) : null;
            return I && I[0];
          },
          addChildren: function(l) {
            return this.insertChildren(this._children.length, l);
          },
          insertChildren: function(l, _) {
            var I = this._children;
            if (I && _ && _.length > 0) {
              _ = q.slice(_);
              for (var X = {}, ne = _.length - 1; ne >= 0; ne--) {
                var ue = _[ne], Te = ue && ue._id;
                !ue || X[Te] ? _.splice(ne, 1) : (ue._remove(!1, !0), X[Te] = !0);
              }
              q.splice(I, _, l, 0);
              for (var ye = this._project, Me = ye._changes, ne = 0, Ge = _.length; ne < Ge; ne++) {
                var ue = _[ne], Qe = ue._name;
                ue._parent = this, ue._setProject(ye, !0), Qe && ue.setName(Qe), Me && ue._changed(5);
              }
              this._changed(11);
            } else
              _ = null;
            return _;
          },
          _insertItem: "#insertChild",
          _insertAt: function(l, _) {
            var I = l && l._getOwner(), X = l !== this && I ? this : null;
            return X && (X._remove(!1, !0), I._insertItem(l._index + _, X)), X;
          },
          insertAbove: function(l) {
            return this._insertAt(l, 1);
          },
          insertBelow: function(l) {
            return this._insertAt(l, 0);
          },
          sendToBack: function() {
            var l = this._getOwner();
            return l ? l._insertItem(0, this) : null;
          },
          bringToFront: function() {
            var l = this._getOwner();
            return l ? l._insertItem(qe, this) : null;
          },
          appendTop: "#addChild",
          appendBottom: function(l) {
            return this.insertChild(0, l);
          },
          moveAbove: "#insertAbove",
          moveBelow: "#insertBelow",
          addTo: function(l) {
            return l._insertItem(qe, this);
          },
          copyTo: function(l) {
            return this.clone(!1).addTo(l);
          },
          reduce: function(l) {
            var _ = this._children;
            if (_ && _.length === 1) {
              var I = _[0].reduce(l);
              return this._parent ? (I.insertAbove(this), this.remove()) : I.remove(), I;
            }
            return this;
          },
          _removeNamed: function() {
            var l = this._getOwner();
            if (l) {
              var _ = l._children, I = l._namedChildren, X = this._name, ne = I[X], ue = ne ? ne.indexOf(this) : -1;
              ue !== -1 && (_[X] == this && delete _[X], ne.splice(ue, 1), ne.length ? _[X] = ne[0] : delete I[X]);
            }
          },
          _remove: function(l, _) {
            var I = this._getOwner(), X = this._project, ne = this._index;
            return this._style && this._style._dispose(), I ? (this._name && this._removeNamed(), ne != null && (X._activeLayer === this && (X._activeLayer = this.getNextSibling() || this.getPreviousSibling()), q.splice(I._children, null, ne, 1)), this._installEvents(!1), l && X._changes && this._changed(5), _ && I._changed(11, this), this._parent = null, !0) : !1;
          },
          remove: function() {
            return this._remove(!0, !0);
          },
          replaceWith: function(l) {
            var _ = l && l.insertBelow(this);
            return _ && this.remove(), _;
          },
          removeChildren: function(l, _) {
            if (!this._children)
              return null;
            l = l || 0, _ = q.pick(_, this._children.length);
            for (var I = q.splice(this._children, null, l, _ - l), X = I.length - 1; X >= 0; X--)
              I[X]._remove(!0, !1);
            return I.length > 0 && this._changed(11), I;
          },
          clear: "#removeChildren",
          reverseChildren: function() {
            if (this._children) {
              this._children.reverse();
              for (var l = 0, _ = this._children.length; l < _; l++)
                this._children[l]._index = l;
              this._changed(11);
            }
          },
          isEmpty: function(l) {
            var _ = this._children, I = _ ? _.length : 0;
            if (l) {
              for (var X = 0; X < I; X++)
                if (!_[X].isEmpty(l))
                  return !1;
              return !0;
            }
            return !I;
          },
          isEditable: function() {
            for (var l = this; l; ) {
              if (!l._visible || l._locked)
                return !1;
              l = l._parent;
            }
            return !0;
          },
          hasFill: function() {
            return this.getStyle().hasFill();
          },
          hasStroke: function() {
            return this.getStyle().hasStroke();
          },
          hasShadow: function() {
            return this.getStyle().hasShadow();
          },
          _getOrder: function(l) {
            function _(Te) {
              var ye = [];
              do
                ye.unshift(Te);
              while (Te = Te._parent);
              return ye;
            }
            for (var I = _(this), X = _(l), ne = 0, ue = Math.min(I.length, X.length); ne < ue; ne++)
              if (I[ne] != X[ne])
                return I[ne]._index < X[ne]._index ? 1 : -1;
            return 0;
          },
          hasChildren: function() {
            return this._children && this._children.length > 0;
          },
          isInserted: function() {
            return this._parent ? this._parent.isInserted() : !1;
          },
          isAbove: function(l) {
            return this._getOrder(l) === -1;
          },
          isBelow: function(l) {
            return this._getOrder(l) === 1;
          },
          isParent: function(l) {
            return this._parent === l;
          },
          isChild: function(l) {
            return l && l._parent === this;
          },
          isDescendant: function(l) {
            for (var _ = this; _ = _._parent; )
              if (_ === l)
                return !0;
            return !1;
          },
          isAncestor: function(l) {
            return l ? l.isDescendant(this) : !1;
          },
          isSibling: function(l) {
            return this._parent === l._parent;
          },
          isGroupedWith: function(l) {
            for (var _ = this._parent; _; ) {
              if (_._parent && /^(Group|Layer|CompoundPath)$/.test(_._class) && l.isDescendant(_))
                return !0;
              _ = _._parent;
            }
            return !1;
          }
        },
        q.each(["rotate", "scale", "shear", "skew"], function(l) {
          var _ = l === "rotate";
          this[l] = function() {
            var I = arguments, X = (_ ? q : x).read(I), ne = x.read(I, 0, { readNull: !0 });
            return this.transform(new S()[l](
              X,
              ne || this.getPosition(!0)
            ));
          };
        }, {
          translate: function() {
            var l = new S();
            return this.transform(l.translate.apply(l, arguments));
          },
          transform: function(l, _, I) {
            var X = this._matrix, ne = l && !l.isIdentity(), ue = I && this._canApplyMatrix || this._applyMatrix && (ne || !X.isIdentity() || _ && this._children);
            if (!ne && !ue)
              return this;
            if (ne) {
              !l.isInvertible() && X.isInvertible() && (X._backup = X.getValues()), X.prepend(l, !0);
              var Te = this._style, ye = Te.getFillColor(!0), Me = Te.getStrokeColor(!0);
              ye && ye.transform(l), Me && Me.transform(l);
            }
            if (ue && (ue = this._transformContent(
              X,
              _,
              I
            ))) {
              var Ge = this._pivot;
              Ge && X._transformPoint(Ge, Ge, !0), X.reset(!0), I && this._canApplyMatrix && (this._applyMatrix = !0);
            }
            var Qe = this._bounds, re = this._position;
            (ne || ue) && this._changed(25);
            var Se = ne && Qe && l.decompose();
            if (Se && Se.skewing.isZero() && Se.rotation % 90 === 0) {
              for (var Pe in Qe) {
                var at = Qe[Pe];
                if (at.nonscaling)
                  delete Qe[Pe];
                else if (ue || !at.internal) {
                  var Be = at.rect;
                  l._transformBounds(Be, Be);
                }
              }
              this._bounds = Qe;
              var Ze = Qe[this._getBoundsCacheKey(
                this._boundsOptions || {}
              )];
              Ze && (this._position = this._getPositionFromBounds(Ze.rect));
            } else ne && re && this._pivot && (this._position = l._transformPoint(re, re));
            return this;
          },
          _transformContent: function(l, _, I) {
            var X = this._children;
            if (X) {
              for (var ne = 0, ue = X.length; ne < ue; ne++)
                X[ne].transform(l, _, I);
              return !0;
            }
          },
          globalToLocal: function() {
            return this.getGlobalMatrix(!0)._inverseTransform(
              x.read(arguments)
            );
          },
          localToGlobal: function() {
            return this.getGlobalMatrix(!0)._transformPoint(
              x.read(arguments)
            );
          },
          parentToLocal: function() {
            return this._matrix._inverseTransform(x.read(arguments));
          },
          localToParent: function() {
            return this._matrix._transformPoint(x.read(arguments));
          },
          fitBounds: function(l, _) {
            l = E.read(arguments);
            var I = this.getBounds(), X = I.height / I.width, ne = l.height / l.width, ue = (_ ? X > ne : X < ne) ? l.width / I.width : l.height / I.height, Te = new E(
              new x(),
              new w(I.width * ue, I.height * ue)
            );
            Te.setCenter(l.getCenter()), this.setBounds(Te);
          }
        }),
        {
          _setStyles: function(l, _, I) {
            var X = this._style, ne = this._matrix;
            if (X.hasFill() && (l.fillStyle = X.getFillColor().toCanvasStyle(l, ne)), X.hasStroke()) {
              l.strokeStyle = X.getStrokeColor().toCanvasStyle(l, ne), l.lineWidth = X.getStrokeWidth();
              var ue = X.getStrokeJoin(), Te = X.getStrokeCap(), ye = X.getMiterLimit();
              if (ue && (l.lineJoin = ue), Te && (l.lineCap = Te), ye && (l.miterLimit = ye), xt.support.nativeDash) {
                var Me = X.getDashArray(), Ge = X.getDashOffset();
                Me && Me.length && ("setLineDash" in l ? (l.setLineDash(Me), l.lineDashOffset = Ge) : (l.mozDash = Me, l.mozDashOffset = Ge));
              }
            }
            if (X.hasShadow()) {
              var Qe = _.pixelRatio || 1, re = I._shiftless().prepend(
                new S().scale(Qe, Qe)
              ), Se = re.transform(new x(X.getShadowBlur(), 0)), Pe = re.transform(this.getShadowOffset());
              l.shadowColor = X.getShadowColor().toCanvasStyle(l), l.shadowBlur = Se.getLength(), l.shadowOffsetX = Pe.x, l.shadowOffsetY = Pe.y;
            }
          },
          draw: function(l, _, I) {
            if (this._updateVersion = this._project._updateVersion, !(!this._visible || this._opacity === 0)) {
              var X = _.matrices, ne = _.viewMatrix, ue = this._matrix, Te = X[X.length - 1].appended(ue);
              if (Te.isInvertible()) {
                ne = ne ? ne.appended(Te) : Te, X.push(Te), _.updateMatrix && (this._globalMatrix = Te);
                var ye = this._blendMode, Me = A.clamp(this._opacity, 0, 1), Ge = ye === "normal", Qe = et.nativeModes[ye], re = Ge && Me === 1 || _.dontStart || _.clip || (Qe || Ge && Me < 1) && this._canComposite(), Se = _.pixelRatio || 1, Pe, at, Be;
                if (!re) {
                  var Ze = this.getStrokeBounds(ne);
                  if (!Ze.width || !Ze.height) {
                    X.pop();
                    return;
                  }
                  Be = _.offset, at = _.offset = Ze.getTopLeft().floor(), Pe = l, l = _t.getContext(Ze.getSize().ceil().add(1).multiply(Se)), Se !== 1 && l.scale(Se, Se);
                }
                l.save();
                var fe = I ? I.appended(ue) : this._canScaleStroke && !this.getStrokeScaling(!0) && ne, Je = !re && _.clipItem, Xe = !fe || Je;
                if (re ? (l.globalAlpha = Me, Qe && (l.globalCompositeOperation = ye)) : Xe && l.translate(-at.x, -at.y), Xe && (re ? ue : ne).applyToContext(l), Je && _.clipItem.draw(l, _.extend({ clip: !0 })), fe) {
                  l.setTransform(Se, 0, 0, Se, 0, 0);
                  var z = _.offset;
                  z && l.translate(-z.x, -z.y);
                }
                this._draw(l, _, ne, fe), l.restore(), X.pop(), _.clip && !_.dontFinish && l.clip(this.getFillRule()), re || (et.process(
                  ye,
                  l,
                  Pe,
                  Me,
                  at.subtract(Be).multiply(Se)
                ), _t.release(l), _.offset = Be);
              }
            }
          },
          _isUpdated: function(l) {
            var _ = this._parent;
            if (_ instanceof it)
              return _._isUpdated(l);
            var I = this._updateVersion === l;
            return !I && _ && _._visible && _._isUpdated(l) && (this._updateVersion = l, I = !0), I;
          },
          _drawSelection: function(l, _, I, X, ne) {
            var ue = this._selection, Te = ue & 1, ye = ue & 2 || Te && this._selectBounds, Me = ue & 4;
            if (this._drawSelected || (Te = !1), (Te || ye || Me) && this._isUpdated(ne)) {
              var Ge, Qe = this.getSelectedColor(!0) || (Ge = this.getLayer()) && Ge.getSelectedColor(!0), re = _.appended(this.getGlobalMatrix(!0)), Se = I / 2;
              if (l.strokeStyle = l.fillStyle = Qe ? Qe.toCanvasStyle(l) : "#009dec", Te && this._drawSelected(l, re, X), Me) {
                var Pe = this.getPosition(!0), at = this._parent, Be = at ? at.localToGlobal(Pe) : Pe, Ze = Be.x, fe = Be.y;
                l.beginPath(), l.arc(Ze, fe, Se, 0, Math.PI * 2, !0), l.stroke();
                for (var Je = [[0, -1], [1, 0], [0, 1], [-1, 0]], Xe = Se, z = I + 1, He = 0; He < 4; He++) {
                  var nt = Je[He], ae = nt[0], $e = nt[1];
                  l.moveTo(Ze + ae * Xe, fe + $e * Xe), l.lineTo(Ze + ae * z, fe + $e * z), l.stroke();
                }
              }
              if (ye) {
                var Et = re._transformCorners(this.getInternalBounds());
                l.beginPath();
                for (var He = 0; He < 8; He++)
                  l[He ? "lineTo" : "moveTo"](Et[He], Et[++He]);
                l.closePath(), l.stroke();
                for (var He = 0; He < 8; He++)
                  l.fillRect(
                    Et[He] - Se,
                    Et[++He] - Se,
                    I,
                    I
                  );
              }
            }
          },
          _canComposite: function() {
            return !1;
          }
        },
        q.each(["down", "drag", "up", "move"], function(l) {
          this["removeOn" + q.capitalize(l)] = function() {
            var _ = {};
            return _[l] = !0, this.removeOn(_);
          };
        }, {
          removeOn: function(l) {
            for (var _ in l)
              if (l[_]) {
                var I = "mouse" + _, X = this._project, ne = X._removeSets = X._removeSets || {};
                ne[I] = ne[I] || {}, ne[I][this._id] = this;
              }
            return this;
          }
        }),
        {
          tween: function(l, _, I) {
            I || (I = _, _ = l, l = null, I || (I = _, _ = null));
            var X = I && I.easing, ne = I && I.start, ue = I != null && (typeof I == "number" ? I : I.duration), Te = new De(this, l, _, ue, X, ne);
            function ye(Me) {
              Te._handleFrame(Me.time * 1e3), Te.running || this.off("frame", ye);
            }
            return ue && this.on("frame", ye), Te;
          },
          tweenTo: function(l, _) {
            return this.tween(null, l, _);
          },
          tweenFrom: function(l, _) {
            return this.tween(l, null, _);
          }
        }
      ), W = T.extend({
        _class: "Group",
        _selectBounds: !1,
        _selectChildren: !0,
        _serializeFields: {
          children: []
        },
        initialize: function(_) {
          this._children = [], this._namedChildren = {}, this._initialize(_) || this.addChildren(Array.isArray(_) ? _ : arguments);
        },
        _changed: function l(_) {
          l.base.call(this, _), _ & 2050 && (this._clipItem = qe);
        },
        _getClipItem: function() {
          var l = this._clipItem;
          if (l === qe) {
            l = null;
            for (var _ = this._children, I = 0, X = _.length; I < X; I++)
              if (_[I]._clipMask) {
                l = _[I];
                break;
              }
            this._clipItem = l;
          }
          return l;
        },
        isClipped: function() {
          return !!this._getClipItem();
        },
        setClipped: function(l) {
          var _ = this.getFirstChild();
          _ && _.setClipMask(l);
        },
        _getBounds: function l(_, I) {
          var X = this._getClipItem();
          return X ? X._getCachedBounds(
            X._matrix.prepended(_),
            q.set({}, I, { stroke: !1 })
          ) : l.base.call(this, _, I);
        },
        _hitTestChildren: function l(_, I, X) {
          var ne = this._getClipItem();
          return (!ne || ne.contains(_)) && l.base.call(
            this,
            _,
            I,
            X,
            ne
          );
        },
        _draw: function(l, _) {
          var I = _.clip, X = !I && this._getClipItem();
          _ = _.extend({ clipItem: X, clip: !1 }), I ? (l.beginPath(), _.dontStart = _.dontFinish = !0) : X && X.draw(l, _.extend({ clip: !0 }));
          for (var ne = this._children, ue = 0, Te = ne.length; ue < Te; ue++) {
            var ye = ne[ue];
            ye !== X && ye.draw(l, _);
          }
        }
      }), J = W.extend({
        _class: "Layer",
        initialize: function() {
          W.apply(this, arguments);
        },
        _getOwner: function() {
          return this._parent || this._index != null && this._project;
        },
        isInserted: function l() {
          return this._parent ? l.base.call(this) : this._index != null;
        },
        activate: function() {
          this._project._activeLayer = this;
        },
        _hitTestSelf: function() {
        }
      }), ee = T.extend(
        {
          _class: "Shape",
          _applyMatrix: !1,
          _canApplyMatrix: !1,
          _canScaleStroke: !0,
          _serializeFields: {
            type: null,
            size: null,
            radius: null
          },
          initialize: function(_, I) {
            this._initialize(_, I);
          },
          _equals: function(l) {
            return this._type === l._type && this._size.equals(l._size) && q.equals(this._radius, l._radius);
          },
          copyContent: function(l) {
            this.setType(l._type), this.setSize(l._size), this.setRadius(l._radius);
          },
          getType: function() {
            return this._type;
          },
          setType: function(l) {
            this._type = l;
          },
          getShape: "#getType",
          setShape: "#setType",
          getSize: function() {
            var l = this._size;
            return new k(l.width, l.height, this, "setSize");
          },
          setSize: function() {
            var l = w.read(arguments);
            if (!this._size)
              this._size = l.clone();
            else if (!this._size.equals(l)) {
              var _ = this._type, I = l.width, X = l.height;
              _ === "rectangle" ? this._radius.set(w.min(this._radius, l.divide(2).abs())) : _ === "circle" ? (I = X = (I + X) / 2, this._radius = I / 2) : _ === "ellipse" && this._radius._set(I / 2, X / 2), this._size._set(I, X), this._changed(9);
            }
          },
          getRadius: function() {
            var l = this._radius;
            return this._type === "circle" ? l : new k(l.width, l.height, this, "setRadius");
          },
          setRadius: function(l) {
            var _ = this._type;
            if (_ === "circle") {
              if (l === this._radius)
                return;
              var I = l * 2;
              this._radius = l, this._size._set(I, I);
            } else if (l = w.read(arguments), !this._radius)
              this._radius = l.clone();
            else {
              if (this._radius.equals(l))
                return;
              if (this._radius.set(l), _ === "rectangle") {
                var I = w.max(this._size, l.multiply(2));
                this._size.set(I);
              } else _ === "ellipse" && this._size._set(l.width * 2, l.height * 2);
            }
            this._changed(9);
          },
          isEmpty: function() {
            return !1;
          },
          toPath: function(l) {
            var _ = new Ce[q.capitalize(this._type)]({
              center: new x(),
              size: this._size,
              radius: this._radius,
              insert: !1
            });
            return _.copyAttributes(this), xt.settings.applyMatrix && _.setApplyMatrix(!0), (l === qe || l) && _.insertAbove(this), _;
          },
          toShape: "#clone",
          _asPathItem: function() {
            return this.toPath(!1);
          },
          _draw: function(l, _, I, X) {
            var ne = this._style, ue = ne.hasFill(), Te = ne.hasStroke(), ye = _.dontFinish || _.clip, Me = !X;
            if (ue || Te || ye) {
              var Ge = this._type, Qe = this._radius, re = Ge === "circle";
              if (_.dontStart || l.beginPath(), Me && re)
                l.arc(0, 0, Qe, 0, Math.PI * 2, !0);
              else {
                var Se = re ? Qe : Qe.width, Pe = re ? Qe : Qe.height, at = this._size, Be = at.width, Ze = at.height;
                if (Me && Ge === "rectangle" && Se === 0 && Pe === 0)
                  l.rect(-Be / 2, -Ze / 2, Be, Ze);
                else {
                  var fe = Be / 2, Je = Ze / 2, Xe = 1 - 0.5522847498307936, z = Se * Xe, He = Pe * Xe, nt = [
                    -fe,
                    -Je + Pe,
                    -fe,
                    -Je + He,
                    -fe + z,
                    -Je,
                    -fe + Se,
                    -Je,
                    fe - Se,
                    -Je,
                    fe - z,
                    -Je,
                    fe,
                    -Je + He,
                    fe,
                    -Je + Pe,
                    fe,
                    Je - Pe,
                    fe,
                    Je - He,
                    fe - z,
                    Je,
                    fe - Se,
                    Je,
                    -fe + Se,
                    Je,
                    -fe + z,
                    Je,
                    -fe,
                    Je - He,
                    -fe,
                    Je - Pe
                  ];
                  X && X.transform(nt, nt, 32), l.moveTo(nt[0], nt[1]), l.bezierCurveTo(nt[2], nt[3], nt[4], nt[5], nt[6], nt[7]), fe !== Se && l.lineTo(nt[8], nt[9]), l.bezierCurveTo(nt[10], nt[11], nt[12], nt[13], nt[14], nt[15]), Je !== Pe && l.lineTo(nt[16], nt[17]), l.bezierCurveTo(nt[18], nt[19], nt[20], nt[21], nt[22], nt[23]), fe !== Se && l.lineTo(nt[24], nt[25]), l.bezierCurveTo(nt[26], nt[27], nt[28], nt[29], nt[30], nt[31]);
                }
              }
              l.closePath();
            }
            !ye && (ue || Te) && (this._setStyles(l, _, I), ue && (l.fill(ne.getFillRule()), l.shadowColor = "rgba(0,0,0,0)"), Te && l.stroke());
          },
          _canComposite: function() {
            return !(this.hasFill() && this.hasStroke());
          },
          _getBounds: function(l, _) {
            var I = new E(this._size).setCenter(0, 0), X = this._style, ne = _.stroke && X.hasStroke() && X.getStrokeWidth();
            return l && (I = l._transformBounds(I)), ne ? I.expand(Ce._getStrokePadding(
              ne,
              this._getStrokeMatrix(l, _)
            )) : I;
          }
        },
        new function() {
          function l(I, X, ne) {
            var ue = I._radius;
            if (!ue.isZero())
              for (var Te = I._size.divide(2), ye = 1; ye <= 4; ye++) {
                var Me = new x(ye > 1 && ye < 4 ? -1 : 1, ye > 2 ? -1 : 1), Ge = Me.multiply(Te), Qe = Ge.subtract(Me.multiply(ue)), re = new E(
                  ne ? Ge.add(Me.multiply(ne)) : Ge,
                  Qe
                );
                if (re.contains(X))
                  return { point: Qe, quadrant: ye };
              }
          }
          function _(I, X, ne, ue) {
            var Te = I.divide(X);
            return (!ue || Te.isInQuadrant(ue)) && Te.subtract(Te.normalize()).multiply(X).divide(ne).length <= 1;
          }
          return {
            _contains: function I(X) {
              if (this._type === "rectangle") {
                var ne = l(this, X);
                return ne ? X.subtract(ne.point).divide(this._radius).getLength() <= 1 : I.base.call(this, X);
              } else
                return X.divide(this.size).getLength() <= 0.5;
            },
            _hitTestSelf: function I(X, ne, ue, Te) {
              var ye = !1, Me = this._style, Ge = ne.stroke && Me.hasStroke(), Qe = ne.fill && Me.hasFill();
              if (Ge || Qe) {
                var re = this._type, Se = this._radius, Pe = Ge ? Me.getStrokeWidth() / 2 : 0, at = ne._tolerancePadding.add(
                  Ce._getStrokePadding(
                    Pe,
                    !Me.getStrokeScaling() && Te
                  )
                );
                if (re === "rectangle") {
                  var Be = at.multiply(2), Ze = l(this, X, Be);
                  if (Ze)
                    ye = _(
                      X.subtract(Ze.point),
                      Se,
                      at,
                      Ze.quadrant
                    );
                  else {
                    var fe = new E(this._size).setCenter(0, 0), Je = fe.expand(Be), Xe = fe.expand(Be.negate());
                    ye = Je._containsPoint(X) && !Xe._containsPoint(X);
                  }
                } else
                  ye = _(X, Se, at);
              }
              return ye ? new ke(Ge ? "stroke" : "fill", this) : I.base.apply(this, arguments);
            }
          };
        }(),
        {
          statics: new function() {
            function l(_, I, X, ne, ue) {
              var Te = q.create(ee.prototype);
              return Te._type = _, Te._size = X, Te._radius = ne, Te._initialize(q.getNamed(ue), I), Te;
            }
            return {
              Circle: function() {
                var _ = arguments, I = x.readNamed(_, "center"), X = q.readNamed(_, "radius");
                return l(
                  "circle",
                  I,
                  new w(X * 2),
                  X,
                  _
                );
              },
              Rectangle: function() {
                var _ = arguments, I = E.readNamed(_, "rectangle"), X = w.min(
                  w.readNamed(_, "radius"),
                  I.getSize(!0).divide(2)
                );
                return l(
                  "rectangle",
                  I.getCenter(!0),
                  I.getSize(!0),
                  X,
                  _
                );
              },
              Ellipse: function() {
                var _ = arguments, I = ee._readEllipse(_), X = I.radius;
                return l(
                  "ellipse",
                  I.center,
                  X.multiply(2),
                  X,
                  _
                );
              },
              _readEllipse: function(_) {
                var I, X;
                if (q.hasNamed(_, "radius"))
                  I = x.readNamed(_, "center"), X = w.readNamed(_, "radius");
                else {
                  var ne = E.readNamed(_, "rectangle");
                  I = ne.getCenter(!0), X = ne.getSize(!0).divide(2);
                }
                return { center: I, radius: X };
              }
            };
          }()
        }
      ), te = T.extend({
        _class: "Raster",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _boundsOptions: { stroke: !1, handle: !1 },
        _serializeFields: {
          crossOrigin: null,
          source: null
        },
        _prioritize: ["crossOrigin"],
        _smoothing: "low",
        beans: !0,
        initialize: function(_, I) {
          if (!this._initialize(
            _,
            I !== qe && x.read(arguments)
          )) {
            var X, ne = typeof _, ue = ne === "string" ? de.getElementById(_) : ne === "object" ? _ : null;
            if (ue && ue !== T.NO_INSERT) {
              if (ue.getContext || ue.naturalHeight != null)
                X = ue;
              else if (ue) {
                var Te = w.read(arguments);
                Te.isZero() || (X = _t.getCanvas(Te));
              }
            }
            X ? this.setImage(X) : this.setSource(_);
          }
          this._size || (this._size = new w(), this._loaded = !1);
        },
        _equals: function(l) {
          return this.getSource() === l.getSource();
        },
        copyContent: function(l) {
          var _ = l._image, I = l._canvas;
          if (_)
            this._setImage(_);
          else if (I) {
            var X = _t.getCanvas(l._size);
            X.getContext("2d").drawImage(I, 0, 0), this._setImage(X);
          }
          this._crossOrigin = l._crossOrigin;
        },
        getSize: function() {
          var l = this._size;
          return new k(
            l ? l.width : 0,
            l ? l.height : 0,
            this,
            "setSize"
          );
        },
        setSize: function(l, _) {
          var I = w.read(arguments);
          if (I.equals(this._size))
            _ && this.clear();
          else if (I.width > 0 && I.height > 0) {
            var X = !_ && this.getElement();
            this._setImage(_t.getCanvas(I)), X && this.getContext(!0).drawImage(
              X,
              0,
              0,
              I.width,
              I.height
            );
          } else
            this._canvas && _t.release(this._canvas), this._size = I.clone();
        },
        getWidth: function() {
          return this._size ? this._size.width : 0;
        },
        setWidth: function(l) {
          this.setSize(l, this.getHeight());
        },
        getHeight: function() {
          return this._size ? this._size.height : 0;
        },
        setHeight: function(l) {
          this.setSize(this.getWidth(), l);
        },
        getLoaded: function() {
          return this._loaded;
        },
        isEmpty: function() {
          var l = this._size;
          return !l || l.width === 0 && l.height === 0;
        },
        getResolution: function() {
          var l = this._matrix, _ = new x(0, 0).transform(l), I = new x(1, 0).transform(l).subtract(_), X = new x(0, 1).transform(l).subtract(_);
          return new w(
            72 / I.getLength(),
            72 / X.getLength()
          );
        },
        getPpi: "#getResolution",
        getImage: function() {
          return this._image;
        },
        setImage: function(l) {
          var _ = this;
          function I(X) {
            var ne = _.getView(), ue = X && X.type || "load";
            ne && _.responds(ue) && (xt = ne._scope, _.emit(ue, new Qt(X)));
          }
          this._setImage(l), this._loaded ? setTimeout(I, 0) : l && rt.add(l, {
            load: function(X) {
              _._setImage(l), I(X);
            },
            error: I
          });
        },
        _setImage: function(l) {
          this._canvas && _t.release(this._canvas), l && l.getContext ? (this._image = null, this._canvas = l, this._loaded = !0) : (this._image = l, this._canvas = null, this._loaded = !!(l && l.src && l.complete)), this._size = new w(
            l ? l.naturalWidth || l.width : 0,
            l ? l.naturalHeight || l.height : 0
          ), this._context = null, this._changed(1033);
        },
        getCanvas: function() {
          if (!this._canvas) {
            var l = _t.getContext(this._size);
            try {
              this._image && l.drawImage(this._image, 0, 0), this._canvas = l.canvas;
            } catch {
              _t.release(l);
            }
          }
          return this._canvas;
        },
        setCanvas: "#setImage",
        getContext: function(l) {
          return this._context || (this._context = this.getCanvas().getContext("2d")), l && (this._image = null, this._changed(1025)), this._context;
        },
        setContext: function(l) {
          this._context = l;
        },
        getSource: function() {
          var l = this._image;
          return l && l.src || this.toDataURL();
        },
        setSource: function(l) {
          var _ = new Tt.Image(), I = this._crossOrigin;
          I && (_.crossOrigin = I), l && (_.src = l), this.setImage(_);
        },
        getCrossOrigin: function() {
          var l = this._image;
          return l && l.crossOrigin || this._crossOrigin || "";
        },
        setCrossOrigin: function(l) {
          this._crossOrigin = l;
          var _ = this._image;
          _ && (_.crossOrigin = l);
        },
        getSmoothing: function() {
          return this._smoothing;
        },
        setSmoothing: function(l) {
          this._smoothing = typeof l == "string" ? l : l ? "low" : "off", this._changed(257);
        },
        getElement: function() {
          return this._canvas || this._loaded && this._image;
        }
      }, {
        beans: !1,
        getSubCanvas: function() {
          var l = E.read(arguments), _ = _t.getContext(l.getSize());
          return _.drawImage(
            this.getCanvas(),
            l.x,
            l.y,
            l.width,
            l.height,
            0,
            0,
            l.width,
            l.height
          ), _.canvas;
        },
        getSubRaster: function() {
          var l = E.read(arguments), _ = new te(T.NO_INSERT);
          return _._setImage(this.getSubCanvas(l)), _.translate(l.getCenter().subtract(this.getSize().divide(2))), _._matrix.prepend(this._matrix), _.insertAbove(this), _;
        },
        toDataURL: function() {
          var l = this._image, _ = l && l.src;
          if (/^data:/.test(_))
            return _;
          var I = this.getCanvas();
          return I ? I.toDataURL.apply(I, arguments) : null;
        },
        drawImage: function(l) {
          var _ = x.read(arguments, 1);
          this.getContext(!0).drawImage(l, _.x, _.y);
        },
        getAverageColor: function(l) {
          var _, I;
          if (l ? l instanceof we ? (I = l, _ = l.getBounds()) : typeof l == "object" && ("width" in l ? _ = new E(l) : "x" in l && (_ = new E(l.x - 0.5, l.y - 0.5, 1, 1))) : _ = this.getBounds(), !_)
            return null;
          var X = 32, ne = Math.min(_.width, X), ue = Math.min(_.height, X), Te = te._sampleContext;
          Te ? Te.clearRect(0, 0, X + 1, X + 1) : Te = te._sampleContext = _t.getContext(
            new w(X)
          ), Te.save();
          var ye = new S().scale(ne / _.width, ue / _.height).translate(-_.x, -_.y);
          ye.applyToContext(Te), I && I.draw(Te, new q({ clip: !0, matrices: [ye] })), this._matrix.applyToContext(Te);
          var Me = this.getElement(), Ge = this._size;
          Me && Te.drawImage(Me, -Ge.width / 2, -Ge.height / 2), Te.restore();
          for (var Qe = Te.getImageData(
            0.5,
            0.5,
            Math.ceil(ne),
            Math.ceil(ue)
          ).data, re = [0, 0, 0], Se = 0, Pe = 0, at = Qe.length; Pe < at; Pe += 4) {
            var Be = Qe[Pe + 3];
            Se += Be, Be /= 255, re[0] += Qe[Pe] * Be, re[1] += Qe[Pe + 1] * Be, re[2] += Qe[Pe + 2] * Be;
          }
          for (var Pe = 0; Pe < 3; Pe++)
            re[Pe] /= Se;
          return Se ? dt.read(re) : null;
        },
        getPixel: function() {
          var l = x.read(arguments), _ = this.getContext().getImageData(l.x, l.y, 1, 1).data;
          return new dt(
            "rgb",
            [_[0] / 255, _[1] / 255, _[2] / 255],
            _[3] / 255
          );
        },
        setPixel: function() {
          var l = arguments, _ = x.read(l), I = dt.read(l), X = I._convert("rgb"), ne = I._alpha, ue = this.getContext(!0), Te = ue.createImageData(1, 1), ye = Te.data;
          ye[0] = X[0] * 255, ye[1] = X[1] * 255, ye[2] = X[2] * 255, ye[3] = ne != null ? ne * 255 : 255, ue.putImageData(Te, _.x, _.y);
        },
        clear: function() {
          var l = this._size;
          this.getContext(!0).clearRect(0, 0, l.width + 1, l.height + 1);
        },
        createImageData: function() {
          var l = w.read(arguments);
          return this.getContext().createImageData(l.width, l.height);
        },
        getImageData: function() {
          var l = E.read(arguments);
          return l.isEmpty() && (l = new E(this._size)), this.getContext().getImageData(
            l.x,
            l.y,
            l.width,
            l.height
          );
        },
        putImageData: function(l) {
          var _ = x.read(arguments, 1);
          this.getContext(!0).putImageData(l, _.x, _.y);
        },
        setImageData: function(l) {
          this.setSize(l), this.getContext(!0).putImageData(l, 0, 0);
        },
        _getBounds: function(l, _) {
          var I = new E(this._size).setCenter(0, 0);
          return l ? l._transformBounds(I) : I;
        },
        _hitTestSelf: function(l) {
          if (this._contains(l)) {
            var _ = this;
            return new ke("pixel", _, {
              offset: l.add(_._size.divide(2)).round(),
              color: {
                get: function() {
                  return _.getPixel(this.offset);
                }
              }
            });
          }
        },
        _draw: function(l, _, I) {
          var X = this.getElement();
          if (X && X.width > 0 && X.height > 0) {
            l.globalAlpha = A.clamp(this._opacity, 0, 1), this._setStyles(l, _, I);
            var ne = this._smoothing, ue = ne === "off";
            $t.setPrefixed(
              l,
              ue ? "imageSmoothingEnabled" : "imageSmoothingQuality",
              ue ? !1 : ne
            ), l.drawImage(
              X,
              -this._size.width / 2,
              -this._size.height / 2
            );
          }
        },
        _canComposite: function() {
          return !0;
        }
      }), le = T.extend({
        _class: "SymbolItem",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _boundsOptions: { stroke: !0 },
        _serializeFields: {
          symbol: null
        },
        initialize: function(_, I) {
          this._initialize(
            _,
            I !== qe && x.read(arguments, 1)
          ) || this.setDefinition(_ instanceof me ? _ : new me(_));
        },
        _equals: function(l) {
          return this._definition === l._definition;
        },
        copyContent: function(l) {
          this.setDefinition(l._definition);
        },
        getDefinition: function() {
          return this._definition;
        },
        setDefinition: function(l) {
          this._definition = l, this._changed(9);
        },
        getSymbol: "#getDefinition",
        setSymbol: "#setDefinition",
        isEmpty: function() {
          return this._definition._item.isEmpty();
        },
        _getBounds: function(l, _) {
          var I = this._definition._item;
          return I._getCachedBounds(I._matrix.prepended(l), _);
        },
        _hitTestSelf: function(l, _, I) {
          var X = _.extend({ all: !1 }), ne = this._definition._item._hitTest(l, X, I);
          return ne && (ne.item = this), ne;
        },
        _draw: function(l, _) {
          this._definition._item.draw(l, _);
        }
      }), me = q.extend({
        _class: "SymbolDefinition",
        initialize: function(_, I) {
          this._id = M.get(), this.project = xt.project, _ && this.setItem(_, I);
        },
        _serialize: function(l, _) {
          return _.add(this, function() {
            return q.serialize(
              [this._class, this._item],
              l,
              !1,
              _
            );
          });
        },
        _changed: function(l) {
          l & 8 && T._clearBoundsCache(this), l & 1 && this.project._changed(l);
        },
        getItem: function() {
          return this._item;
        },
        setItem: function(l, _) {
          l._symbol && (l = l.clone()), this._item && (this._item._symbol = null), this._item = l, l.remove(), l.setSelected(!1), _ || l.setPosition(new x()), l._symbol = this, this._changed(9);
        },
        getDefinition: "#getItem",
        setDefinition: "#setItem",
        place: function(l) {
          return new le(this, l);
        },
        clone: function() {
          return new me(this._item.clone(!1));
        },
        equals: function(l) {
          return l === this || l && this._item.equals(l._item) || !1;
        }
      }), ke = q.extend({
        _class: "HitResult",
        initialize: function(_, I, X) {
          this.type = _, this.item = I, X && this.inject(X);
        },
        statics: {
          getOptions: function(l) {
            var _ = l && q.read(l);
            return new q({
              type: null,
              tolerance: xt.settings.hitTolerance,
              fill: !_,
              stroke: !_,
              segments: !_,
              handles: !1,
              ends: !1,
              position: !1,
              center: !1,
              bounds: !1,
              guides: !1,
              selected: !1
            }, _);
          }
        }
      }), ge = q.extend({
        _class: "Segment",
        beans: !0,
        _selection: 0,
        initialize: function(_, I, X, ne, ue, Te) {
          var ye = arguments.length, Me, Ge, Qe, re;
          ye > 0 && (_ == null || typeof _ == "object" ? ye === 1 && _ && "point" in _ ? (Me = _.point, Ge = _.handleIn, Qe = _.handleOut, re = _.selection) : (Me = _, Ge = I, Qe = X, re = ne) : (Me = [_, I], Ge = X !== qe ? [X, ne] : null, Qe = ue !== qe ? [ue, Te] : null)), new Ve(Me, this, "_point"), new Ve(Ge, this, "_handleIn"), new Ve(Qe, this, "_handleOut"), re && this.setSelection(re);
        },
        _serialize: function(l, _) {
          var I = this._point, X = this._selection, ne = X || this.hasHandles() ? [I, this._handleIn, this._handleOut] : I;
          return X && ne.push(X), q.serialize(ne, l, !0, _);
        },
        _changed: function(l) {
          var _ = this._path;
          if (_) {
            var I = _._curves, X = this._index, ne;
            I && ((!l || l === this._point || l === this._handleIn) && (ne = X > 0 ? I[X - 1] : _._closed ? I[I.length - 1] : null) && ne._changed(), (!l || l === this._point || l === this._handleOut) && (ne = I[X]) && ne._changed()), _._changed(41);
          }
        },
        getPoint: function() {
          return this._point;
        },
        setPoint: function() {
          this._point.set(x.read(arguments));
        },
        getHandleIn: function() {
          return this._handleIn;
        },
        setHandleIn: function() {
          this._handleIn.set(x.read(arguments));
        },
        getHandleOut: function() {
          return this._handleOut;
        },
        setHandleOut: function() {
          this._handleOut.set(x.read(arguments));
        },
        hasHandles: function() {
          return !this._handleIn.isZero() || !this._handleOut.isZero();
        },
        isSmooth: function() {
          var l = this._handleIn, _ = this._handleOut;
          return !l.isZero() && !_.isZero() && l.isCollinear(_);
        },
        clearHandles: function() {
          this._handleIn._set(0, 0), this._handleOut._set(0, 0);
        },
        getSelection: function() {
          return this._selection;
        },
        setSelection: function(l) {
          var _ = this._selection, I = this._path;
          this._selection = l = l || 0, I && l !== _ && (I._updateSelection(this, _, l), I._changed(257));
        },
        _changeSelection: function(l, _) {
          var I = this._selection;
          this.setSelection(_ ? I | l : I & ~l);
        },
        isSelected: function() {
          return !!(this._selection & 7);
        },
        setSelected: function(l) {
          this._changeSelection(7, l);
        },
        getIndex: function() {
          return this._index !== qe ? this._index : null;
        },
        getPath: function() {
          return this._path || null;
        },
        getCurve: function() {
          var l = this._path, _ = this._index;
          return l ? (_ > 0 && !l._closed && _ === l._segments.length - 1 && _--, l.getCurves()[_] || null) : null;
        },
        getLocation: function() {
          var l = this.getCurve();
          return l ? new Ue(l, this === l._segment1 ? 0 : 1) : null;
        },
        getNext: function() {
          var l = this._path && this._path._segments;
          return l && (l[this._index + 1] || this._path._closed && l[0]) || null;
        },
        smooth: function(l, _, I) {
          var X = l || {}, ne = X.type, ue = X.factor, Te = this.getPrevious(), ye = this.getNext(), Me = (Te || this)._point, Ge = this._point, Qe = (ye || this)._point, re = Me.getDistance(Ge), Se = Ge.getDistance(Qe);
          if (!ne || ne === "catmull-rom") {
            var Pe = ue === qe ? 0.5 : ue, at = Math.pow(re, Pe), Be = at * at, Ze = Math.pow(Se, Pe), fe = Ze * Ze;
            if (!_ && Te) {
              var Je = 2 * fe + 3 * Ze * at + Be, Xe = 3 * Ze * (Ze + at);
              this.setHandleIn(Xe !== 0 ? new x(
                (fe * Me._x + Je * Ge._x - Be * Qe._x) / Xe - Ge._x,
                (fe * Me._y + Je * Ge._y - Be * Qe._y) / Xe - Ge._y
              ) : new x());
            }
            if (!I && ye) {
              var Je = 2 * Be + 3 * at * Ze + fe, Xe = 3 * at * (at + Ze);
              this.setHandleOut(Xe !== 0 ? new x(
                (Be * Qe._x + Je * Ge._x - fe * Me._x) / Xe - Ge._x,
                (Be * Qe._y + Je * Ge._y - fe * Me._y) / Xe - Ge._y
              ) : new x());
            }
          } else if (ne === "geometric") {
            if (Te && ye) {
              var z = Me.subtract(Qe), He = ue === qe ? 0.4 : ue, nt = He * re / (re + Se);
              _ || this.setHandleIn(z.multiply(nt)), I || this.setHandleOut(z.multiply(nt - He));
            }
          } else
            throw new Error("Smoothing method '" + ne + "' not supported.");
        },
        getPrevious: function() {
          var l = this._path && this._path._segments;
          return l && (l[this._index - 1] || this._path._closed && l[l.length - 1]) || null;
        },
        isFirst: function() {
          return !this._index;
        },
        isLast: function() {
          var l = this._path;
          return l && this._index === l._segments.length - 1 || !1;
        },
        reverse: function() {
          var l = this._handleIn, _ = this._handleOut, I = l.clone();
          l.set(_), _.set(I);
        },
        reversed: function() {
          return new ge(this._point, this._handleOut, this._handleIn);
        },
        remove: function() {
          return this._path ? !!this._path.removeSegment(this._index) : !1;
        },
        clone: function() {
          return new ge(this._point, this._handleIn, this._handleOut);
        },
        equals: function(l) {
          return l === this || l && this._class === l._class && this._point.equals(l._point) && this._handleIn.equals(l._handleIn) && this._handleOut.equals(l._handleOut) || !1;
        },
        toString: function() {
          var l = ["point: " + this._point];
          return this._handleIn.isZero() || l.push("handleIn: " + this._handleIn), this._handleOut.isZero() || l.push("handleOut: " + this._handleOut), "{ " + l.join(", ") + " }";
        },
        transform: function(l) {
          this._transformCoordinates(l, new Array(6), !0), this._changed();
        },
        interpolate: function(l, _, I) {
          var X = 1 - I, ne = I, ue = l._point, Te = _._point, ye = l._handleIn, Me = _._handleIn, Ge = _._handleOut, Qe = l._handleOut;
          this._point._set(
            X * ue._x + ne * Te._x,
            X * ue._y + ne * Te._y,
            !0
          ), this._handleIn._set(
            X * ye._x + ne * Me._x,
            X * ye._y + ne * Me._y,
            !0
          ), this._handleOut._set(
            X * Qe._x + ne * Ge._x,
            X * Qe._y + ne * Ge._y,
            !0
          ), this._changed();
        },
        _transformCoordinates: function(l, _, I) {
          var X = this._point, ne = !I || !this._handleIn.isZero() ? this._handleIn : null, ue = !I || !this._handleOut.isZero() ? this._handleOut : null, Te = X._x, ye = X._y, Me = 2;
          return _[0] = Te, _[1] = ye, ne && (_[Me++] = ne._x + Te, _[Me++] = ne._y + ye), ue && (_[Me++] = ue._x + Te, _[Me++] = ue._y + ye), l && (l._transformCoordinates(_, _, Me / 2), Te = _[0], ye = _[1], I ? (X._x = Te, X._y = ye, Me = 2, ne && (ne._x = _[Me++] - Te, ne._y = _[Me++] - ye), ue && (ue._x = _[Me++] - Te, ue._y = _[Me++] - ye)) : (ne || (_[Me++] = Te, _[Me++] = ye), ue || (_[Me++] = Te, _[Me++] = ye))), _;
        }
      }), Ve = x.extend({
        initialize: function(_, I, X) {
          var ne, ue, Te;
          if (!_)
            ne = ue = 0;
          else if ((ne = _[0]) !== qe)
            ue = _[1];
          else {
            var ye = _;
            (ne = ye.x) === qe && (ye = x.read(arguments), ne = ye.x), ue = ye.y, Te = ye.selected;
          }
          this._x = ne, this._y = ue, this._owner = I, I[X] = this, Te && this.setSelected(!0);
        },
        _set: function(l, _) {
          return this._x = l, this._y = _, this._owner._changed(this), this;
        },
        getX: function() {
          return this._x;
        },
        setX: function(l) {
          this._x = l, this._owner._changed(this);
        },
        getY: function() {
          return this._y;
        },
        setY: function(l) {
          this._y = l, this._owner._changed(this);
        },
        isZero: function() {
          var l = A.isZero;
          return l(this._x) && l(this._y);
        },
        isSelected: function() {
          return !!(this._owner._selection & this._getSelection());
        },
        setSelected: function(l) {
          this._owner._changeSelection(this._getSelection(), l);
        },
        _getSelection: function() {
          var l = this._owner;
          return this === l._point ? 1 : this === l._handleIn ? 2 : this === l._handleOut ? 4 : 0;
        }
      }), Oe = q.extend(
        {
          _class: "Curve",
          beans: !0,
          initialize: function(_, I, X, ne, ue, Te, ye, Me) {
            var Ge = arguments.length, Qe, re, Se, Pe, at, Be;
            Ge === 3 ? (this._path = _, Qe = I, re = X) : Ge ? Ge === 1 ? "segment1" in _ ? (Qe = new ge(_.segment1), re = new ge(_.segment2)) : "point1" in _ ? (Se = _.point1, at = _.handle1, Be = _.handle2, Pe = _.point2) : Array.isArray(_) && (Se = [_[0], _[1]], Pe = [_[6], _[7]], at = [_[2] - _[0], _[3] - _[1]], Be = [_[4] - _[6], _[5] - _[7]]) : Ge === 2 ? (Qe = new ge(_), re = new ge(I)) : Ge === 4 ? (Se = _, at = I, Be = X, Pe = ne) : Ge === 8 && (Se = [_, I], Pe = [ye, Me], at = [X - _, ne - I], Be = [ue - ye, Te - Me]) : (Qe = new ge(), re = new ge()), this._segment1 = Qe || new ge(Se, null, at), this._segment2 = re || new ge(Pe, Be, null);
          },
          _serialize: function(l, _) {
            return q.serialize(
              this.hasHandles() ? [
                this.getPoint1(),
                this.getHandle1(),
                this.getHandle2(),
                this.getPoint2()
              ] : [this.getPoint1(), this.getPoint2()],
              l,
              !0,
              _
            );
          },
          _changed: function() {
            this._length = this._bounds = qe;
          },
          clone: function() {
            return new Oe(this._segment1, this._segment2);
          },
          toString: function() {
            var l = ["point1: " + this._segment1._point];
            return this._segment1._handleOut.isZero() || l.push("handle1: " + this._segment1._handleOut), this._segment2._handleIn.isZero() || l.push("handle2: " + this._segment2._handleIn), l.push("point2: " + this._segment2._point), "{ " + l.join(", ") + " }";
          },
          classify: function() {
            return Oe.classify(this.getValues());
          },
          remove: function() {
            var l = !1;
            if (this._path) {
              var _ = this._segment2, I = _._handleOut;
              l = _.remove(), l && this._segment1._handleOut.set(I);
            }
            return l;
          },
          getPoint1: function() {
            return this._segment1._point;
          },
          setPoint1: function() {
            this._segment1._point.set(x.read(arguments));
          },
          getPoint2: function() {
            return this._segment2._point;
          },
          setPoint2: function() {
            this._segment2._point.set(x.read(arguments));
          },
          getHandle1: function() {
            return this._segment1._handleOut;
          },
          setHandle1: function() {
            this._segment1._handleOut.set(x.read(arguments));
          },
          getHandle2: function() {
            return this._segment2._handleIn;
          },
          setHandle2: function() {
            this._segment2._handleIn.set(x.read(arguments));
          },
          getSegment1: function() {
            return this._segment1;
          },
          getSegment2: function() {
            return this._segment2;
          },
          getPath: function() {
            return this._path;
          },
          getIndex: function() {
            return this._segment1._index;
          },
          getNext: function() {
            var l = this._path && this._path._curves;
            return l && (l[this._segment1._index + 1] || this._path._closed && l[0]) || null;
          },
          getPrevious: function() {
            var l = this._path && this._path._curves;
            return l && (l[this._segment1._index - 1] || this._path._closed && l[l.length - 1]) || null;
          },
          isFirst: function() {
            return !this._segment1._index;
          },
          isLast: function() {
            var l = this._path;
            return l && this._segment1._index === l._curves.length - 1 || !1;
          },
          isSelected: function() {
            return this.getPoint1().isSelected() && this.getHandle1().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();
          },
          setSelected: function(l) {
            this.getPoint1().setSelected(l), this.getHandle1().setSelected(l), this.getHandle2().setSelected(l), this.getPoint2().setSelected(l);
          },
          getValues: function(l) {
            return Oe.getValues(this._segment1, this._segment2, l);
          },
          getPoints: function() {
            for (var l = this.getValues(), _ = [], I = 0; I < 8; I += 2)
              _.push(new x(l[I], l[I + 1]));
            return _;
          }
        },
        {
          getLength: function() {
            return this._length == null && (this._length = Oe.getLength(this.getValues(), 0, 1)), this._length;
          },
          getArea: function() {
            return Oe.getArea(this.getValues());
          },
          getLine: function() {
            return new U(this._segment1._point, this._segment2._point);
          },
          getPart: function(l, _) {
            return new Oe(Oe.getPart(this.getValues(), l, _));
          },
          getPartLength: function(l, _) {
            return Oe.getLength(this.getValues(), l, _);
          },
          divideAt: function(l) {
            return this.divideAtTime(l && l.curve === this ? l.time : this.getTimeAt(l));
          },
          divideAtTime: function(l, _) {
            var I = 1e-8, X = 1 - I, ne = null;
            if (l >= I && l <= X) {
              var ue = Oe.subdivide(this.getValues(), l), Te = ue[0], ye = ue[1], Me = _ || this.hasHandles(), Ge = this._segment1, Qe = this._segment2, re = this._path;
              Me && (Ge._handleOut._set(Te[2] - Te[0], Te[3] - Te[1]), Qe._handleIn._set(ye[4] - ye[6], ye[5] - ye[7]));
              var Se = Te[6], Pe = Te[7], at = new ge(
                new x(Se, Pe),
                Me && new x(Te[4] - Se, Te[5] - Pe),
                Me && new x(ye[2] - Se, ye[3] - Pe)
              );
              re ? (re.insert(Ge._index + 1, at), ne = this.getNext()) : (this._segment2 = at, this._changed(), ne = new Oe(at, Qe));
            }
            return ne;
          },
          splitAt: function(l) {
            var _ = this._path;
            return _ ? _.splitAt(l) : null;
          },
          splitAtTime: function(l) {
            return this.splitAt(this.getLocationAtTime(l));
          },
          divide: function(l, _) {
            return this.divideAtTime(l === qe ? 0.5 : _ ? l : this.getTimeAt(l));
          },
          split: function(l, _) {
            return this.splitAtTime(l === qe ? 0.5 : _ ? l : this.getTimeAt(l));
          },
          reversed: function() {
            return new Oe(this._segment2.reversed(), this._segment1.reversed());
          },
          clearHandles: function() {
            this._segment1._handleOut._set(0, 0), this._segment2._handleIn._set(0, 0);
          },
          statics: {
            getValues: function(l, _, I, X) {
              var ne = l._point, ue = l._handleOut, Te = _._handleIn, ye = _._point, Me = ne.x, Ge = ne.y, Qe = ye.x, re = ye.y, Se = X ? [Me, Ge, Me, Ge, Qe, re, Qe, re] : [
                Me,
                Ge,
                Me + ue._x,
                Ge + ue._y,
                Qe + Te._x,
                re + Te._y,
                Qe,
                re
              ];
              return I && I._transformCoordinates(Se, Se, 4), Se;
            },
            subdivide: function(l, _) {
              var I = l[0], X = l[1], ne = l[2], ue = l[3], Te = l[4], ye = l[5], Me = l[6], Ge = l[7];
              _ === qe && (_ = 0.5);
              var Qe = 1 - _, re = Qe * I + _ * ne, Se = Qe * X + _ * ue, Pe = Qe * ne + _ * Te, at = Qe * ue + _ * ye, Be = Qe * Te + _ * Me, Ze = Qe * ye + _ * Ge, fe = Qe * re + _ * Pe, Je = Qe * Se + _ * at, Xe = Qe * Pe + _ * Be, z = Qe * at + _ * Ze, He = Qe * fe + _ * Xe, nt = Qe * Je + _ * z;
              return [
                [I, X, re, Se, fe, Je, He, nt],
                [He, nt, Xe, z, Be, Ze, Me, Ge]
              ];
            },
            getMonoCurves: function(l, _) {
              var I = [], X = _ ? 0 : 1, ne = l[X + 0], ue = l[X + 2], Te = l[X + 4], ye = l[X + 6];
              if (ne >= ue == ue >= Te && ue >= Te == Te >= ye || Oe.isStraight(l))
                I.push(l);
              else {
                var Me = 3 * (ue - Te) - ne + ye, Ge = 2 * (ne + Te) - 4 * ue, Qe = ue - ne, re = 1e-8, Se = 1 - re, Pe = [], at = A.solveQuadratic(Me, Ge, Qe, Pe, re, Se);
                if (!at)
                  I.push(l);
                else {
                  Pe.sort();
                  var Be = Pe[0], Ze = Oe.subdivide(l, Be);
                  I.push(Ze[0]), at > 1 && (Be = (Pe[1] - Be) / (1 - Be), Ze = Oe.subdivide(Ze[1], Be), I.push(Ze[0])), I.push(Ze[1]);
                }
              }
              return I;
            },
            solveCubic: function(l, _, I, X, ne, ue) {
              var Te = l[_], ye = l[_ + 2], Me = l[_ + 4], Ge = l[_ + 6], Qe = 0;
              if (!(Te < I && Ge < I && ye < I && Me < I || Te > I && Ge > I && ye > I && Me > I)) {
                var re = 3 * (ye - Te), Se = 3 * (Me - ye) - re, Pe = Ge - Te - re - Se;
                Qe = A.solveCubic(Pe, Se, re, Te - I, X, ne, ue);
              }
              return Qe;
            },
            getTimeOf: function(l, _) {
              var I = new x(l[0], l[1]), X = new x(l[6], l[7]), ne = 1e-12, ue = 1e-7, Te = _.isClose(I, ne) ? 0 : _.isClose(X, ne) ? 1 : null;
              if (Te === null)
                for (var ye = [_.x, _.y], Me = [], Ge = 0; Ge < 2; Ge++)
                  for (var Qe = Oe.solveCubic(l, Ge, ye[Ge], Me, 0, 1), re = 0; re < Qe; re++) {
                    var Se = Me[re];
                    if (_.isClose(Oe.getPoint(l, Se), ue))
                      return Se;
                  }
              return _.isClose(I, ue) ? 0 : _.isClose(X, ue) ? 1 : null;
            },
            getNearestTime: function(l, _) {
              if (Oe.isStraight(l)) {
                var I = l[0], X = l[1], ne = l[6], ue = l[7], Te = ne - I, ye = ue - X, Me = Te * Te + ye * ye;
                if (Me === 0)
                  return 0;
                var Ge = ((_.x - I) * Te + (_.y - X) * ye) / Me;
                return Ge < 1e-12 ? 0 : Ge > 0.999999999999 ? 1 : Oe.getTimeOf(
                  l,
                  new x(I + Ge * Te, X + Ge * ye)
                );
              }
              var Qe = 100, re = 1 / 0, Se = 0;
              function Pe(Ze) {
                if (Ze >= 0 && Ze <= 1) {
                  var fe = _.getDistance(Oe.getPoint(l, Ze), !0);
                  if (fe < re)
                    return re = fe, Se = Ze, !0;
                }
              }
              for (var at = 0; at <= Qe; at++)
                Pe(at / Qe);
              for (var Be = 1 / (Qe * 2); Be > 1e-8; )
                !Pe(Se - Be) && !Pe(Se + Be) && (Be /= 2);
              return Se;
            },
            getPart: function(l, _, I) {
              var X = _ > I;
              if (X) {
                var ne = _;
                _ = I, I = ne;
              }
              return _ > 0 && (l = Oe.subdivide(l, _)[1]), I < 1 && (l = Oe.subdivide(l, (I - _) / (1 - _))[0]), X ? [l[6], l[7], l[4], l[5], l[2], l[3], l[0], l[1]] : l;
            },
            isFlatEnough: function(l, _) {
              var I = l[0], X = l[1], ne = l[2], ue = l[3], Te = l[4], ye = l[5], Me = l[6], Ge = l[7], Qe = 3 * ne - 2 * I - Me, re = 3 * ue - 2 * X - Ge, Se = 3 * Te - 2 * Me - I, Pe = 3 * ye - 2 * Ge - X;
              return Math.max(Qe * Qe, Se * Se) + Math.max(re * re, Pe * Pe) <= 16 * _ * _;
            },
            getArea: function(l) {
              var _ = l[0], I = l[1], X = l[2], ne = l[3], ue = l[4], Te = l[5], ye = l[6], Me = l[7];
              return 3 * ((Me - I) * (X + ue) - (ye - _) * (ne + Te) + ne * (_ - ue) - X * (I - Te) + Me * (ue + _ / 3) - ye * (Te + I / 3)) / 20;
            },
            getBounds: function(l) {
              for (var _ = l.slice(0, 2), I = _.slice(), X = [0, 0], ne = 0; ne < 2; ne++)
                Oe._addBounds(
                  l[ne],
                  l[ne + 2],
                  l[ne + 4],
                  l[ne + 6],
                  ne,
                  0,
                  _,
                  I,
                  X
                );
              return new E(_[0], _[1], I[0] - _[0], I[1] - _[1]);
            },
            _addBounds: function(l, _, I, X, ne, ue, Te, ye, Me) {
              function Ge(He, nt) {
                var ae = He - nt, $e = He + nt;
                ae < Te[ne] && (Te[ne] = ae), $e > ye[ne] && (ye[ne] = $e);
              }
              ue /= 2;
              var Qe = Te[ne] + ue, re = ye[ne] - ue;
              if (l < Qe || _ < Qe || I < Qe || X < Qe || l > re || _ > re || I > re || X > re)
                if (_ < l != _ < X && I < l != I < X)
                  Ge(l, 0), Ge(X, 0);
                else {
                  var Se = 3 * (_ - I) - l + X, Pe = 2 * (l + I) - 4 * _, at = _ - l, Be = A.solveQuadratic(Se, Pe, at, Me), Ze = 1e-8, fe = 1 - Ze;
                  Ge(X, 0);
                  for (var Je = 0; Je < Be; Je++) {
                    var Xe = Me[Je], z = 1 - Xe;
                    Ze <= Xe && Xe <= fe && Ge(
                      z * z * z * l + 3 * z * z * Xe * _ + 3 * z * Xe * Xe * I + Xe * Xe * Xe * X,
                      ue
                    );
                  }
                }
            }
          }
        },
        q.each(
          ["getBounds", "getStrokeBounds", "getHandleBounds"],
          function(l) {
            this[l] = function() {
              this._bounds || (this._bounds = {});
              var _ = this._bounds[l];
              return _ || (_ = this._bounds[l] = Ce[l](
                [this._segment1, this._segment2],
                !1,
                this._path
              )), _.clone();
            };
          },
          {}
        ),
        q.each({
          isStraight: function(l, _, I, X) {
            if (_.isZero() && I.isZero())
              return !0;
            var ne = X.subtract(l);
            if (ne.isZero())
              return !1;
            if (ne.isCollinear(_) && ne.isCollinear(I)) {
              var ue = new U(l, X), Te = 1e-7;
              if (ue.getDistance(l.add(_)) < Te && ue.getDistance(X.add(I)) < Te) {
                var ye = ne.dot(ne), Me = ne.dot(_) / ye, Ge = ne.dot(I) / ye;
                return Me >= 0 && Me <= 1 && Ge <= 0 && Ge >= -1;
              }
            }
            return !1;
          },
          isLinear: function(l, _, I, X) {
            var ne = X.subtract(l).divide(3);
            return _.equals(ne) && I.negate().equals(ne);
          }
        }, function(l, _) {
          this[_] = function(I) {
            var X = this._segment1, ne = this._segment2;
            return l(
              X._point,
              X._handleOut,
              ne._handleIn,
              ne._point,
              I
            );
          }, this.statics[_] = function(I, X) {
            var ne = I[0], ue = I[1], Te = I[6], ye = I[7];
            return l(
              new x(ne, ue),
              new x(I[2] - ne, I[3] - ue),
              new x(I[4] - Te, I[5] - ye),
              new x(Te, ye),
              X
            );
          };
        }, {
          statics: {},
          hasHandles: function() {
            return !this._segment1._handleOut.isZero() || !this._segment2._handleIn.isZero();
          },
          hasLength: function(l) {
            return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles()) && this.getLength() > (l || 0);
          },
          isCollinear: function(l) {
            return l && this.isStraight() && l.isStraight() && this.getLine().isCollinear(l.getLine());
          },
          isHorizontal: function() {
            return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y) < 1e-8;
          },
          isVertical: function() {
            return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x) < 1e-8;
          }
        }),
        {
          beans: !1,
          getLocationAt: function(l, _) {
            return this.getLocationAtTime(
              _ ? l : this.getTimeAt(l)
            );
          },
          getLocationAtTime: function(l) {
            return l != null && l >= 0 && l <= 1 ? new Ue(this, l) : null;
          },
          getTimeAt: function(l, _) {
            return Oe.getTimeAt(this.getValues(), l, _);
          },
          getParameterAt: "#getTimeAt",
          getTimesWithTangent: function() {
            var l = x.read(arguments);
            return l.isZero() ? [] : Oe.getTimesWithTangent(this.getValues(), l);
          },
          getOffsetAtTime: function(l) {
            return this.getPartLength(0, l);
          },
          getLocationOf: function() {
            return this.getLocationAtTime(this.getTimeOf(x.read(arguments)));
          },
          getOffsetOf: function() {
            var l = this.getLocationOf.apply(this, arguments);
            return l ? l.getOffset() : null;
          },
          getTimeOf: function() {
            return Oe.getTimeOf(this.getValues(), x.read(arguments));
          },
          getParameterOf: "#getTimeOf",
          getNearestLocation: function() {
            var l = x.read(arguments), _ = this.getValues(), I = Oe.getNearestTime(_, l), X = Oe.getPoint(_, I);
            return new Ue(this, I, X, null, l.getDistance(X));
          },
          getNearestPoint: function() {
            var l = this.getNearestLocation.apply(this, arguments);
            return l && l.getPoint();
          }
        },
        new function() {
          var l = [
            "getPoint",
            "getTangent",
            "getNormal",
            "getWeightedTangent",
            "getWeightedNormal",
            "getCurvature"
          ];
          return q.each(
            l,
            function(_) {
              this[_ + "At"] = function(I, X) {
                var ne = this.getValues();
                return Oe[_](ne, X ? I : Oe.getTimeAt(ne, I));
              }, this[_ + "AtTime"] = function(I) {
                return Oe[_](this.getValues(), I);
              };
            },
            {
              statics: {
                _evaluateMethods: l
              }
            }
          );
        }(),
        new function() {
          function l(X) {
            var ne = X[0], ue = X[1], Te = X[2], ye = X[3], Me = X[4], Ge = X[5], Qe = X[6], re = X[7], Se = 9 * (Te - Me) + 3 * (Qe - ne), Pe = 6 * (ne + Me) - 12 * Te, at = 3 * (Te - ne), Be = 9 * (ye - Ge) + 3 * (re - ue), Ze = 6 * (ue + Ge) - 12 * ye, fe = 3 * (ye - ue);
            return function(Je) {
              var Xe = (Se * Je + Pe) * Je + at, z = (Be * Je + Ze) * Je + fe;
              return Math.sqrt(Xe * Xe + z * z);
            };
          }
          function _(X, ne) {
            return Math.max(2, Math.min(16, Math.ceil(Math.abs(ne - X) * 32)));
          }
          function I(X, ne, ue, Te) {
            if (ne == null || ne < 0 || ne > 1)
              return null;
            var ye = X[0], Me = X[1], Ge = X[2], Qe = X[3], re = X[4], Se = X[5], Pe = X[6], at = X[7], Be = A.isZero;
            Be(Ge - ye) && Be(Qe - Me) && (Ge = ye, Qe = Me), Be(re - Pe) && Be(Se - at) && (re = Pe, Se = at);
            var Ze = 3 * (Ge - ye), fe = 3 * (re - Ge) - Ze, Je = Pe - ye - Ze - fe, Xe = 3 * (Qe - Me), z = 3 * (Se - Qe) - Xe, He = at - Me - Xe - z, nt, ae;
            if (ue === 0)
              nt = ne === 0 ? ye : ne === 1 ? Pe : ((Je * ne + fe) * ne + Ze) * ne + ye, ae = ne === 0 ? Me : ne === 1 ? at : ((He * ne + z) * ne + Xe) * ne + Me;
            else {
              var $e = 1e-8, Et = 1 - $e;
              if (ne < $e ? (nt = Ze, ae = Xe) : ne > Et ? (nt = 3 * (Pe - re), ae = 3 * (at - Se)) : (nt = (3 * Je * ne + 2 * fe) * ne + Ze, ae = (3 * He * ne + 2 * z) * ne + Xe), Te) {
                nt === 0 && ae === 0 && (ne < $e || ne > Et) && (nt = re - Ge, ae = Se - Qe);
                var Nt = Math.sqrt(nt * nt + ae * ae);
                Nt && (nt /= Nt, ae /= Nt);
              }
              if (ue === 3) {
                var re = 6 * Je * ne + 2 * fe, Se = 6 * He * ne + 2 * z, Yt = Math.pow(nt * nt + ae * ae, 3 / 2);
                nt = Yt !== 0 ? (nt * Se - ae * re) / Yt : 0, ae = 0;
              }
            }
            return ue === 2 ? new x(ae, -nt) : new x(nt, ae);
          }
          return { statics: {
            classify: function(X) {
              var ne = X[0], ue = X[1], Te = X[2], ye = X[3], Me = X[4], Ge = X[5], Qe = X[6], re = X[7], Se = ne * (re - Ge) + ue * (Me - Qe) + Qe * Ge - re * Me, Pe = Te * (ue - re) + ye * (Qe - ne) + ne * re - ue * Qe, at = Me * (ye - ue) + Ge * (ne - Te) + Te * ue - ye * ne, Be = 3 * at, Ze = Be - Pe, fe = Ze - Pe + Se, Je = Math.sqrt(fe * fe + Ze * Ze + Be * Be), Xe = Je !== 0 ? 1 / Je : 0, z = A.isZero, He = "serpentine";
              fe *= Xe, Ze *= Xe, Be *= Xe;
              function nt(Nt, Yt, Ft) {
                var ai = Yt !== qe, Mt = ai && Yt > 0 && Yt < 1, Ae = ai && Ft > 0 && Ft < 1;
                return ai && (!(Mt || Ae) || Nt === "loop" && !(Mt && Ae)) && (Nt = "arch", Mt = Ae = !1), {
                  type: Nt,
                  roots: Mt || Ae ? Mt && Ae ? Yt < Ft ? [Yt, Ft] : [Ft, Yt] : [Mt ? Yt : Ft] : null
                };
              }
              if (z(fe))
                return z(Ze) ? nt(z(Be) ? "line" : "quadratic") : nt(He, Be / (3 * Ze));
              var ae = 3 * Ze * Ze - 4 * fe * Be;
              if (z(ae))
                return nt("cusp", Ze / (2 * fe));
              var $e = ae > 0 ? Math.sqrt(ae / 3) : Math.sqrt(-ae), Et = 2 * fe;
              return nt(
                ae > 0 ? He : "loop",
                (Ze + $e) / Et,
                (Ze - $e) / Et
              );
            },
            getLength: function(X, ne, ue, Te) {
              if (ne === qe && (ne = 0), ue === qe && (ue = 1), Oe.isStraight(X)) {
                var ye = X;
                ue < 1 && (ye = Oe.subdivide(ye, ue)[0], ne /= ue), ne > 0 && (ye = Oe.subdivide(ye, ne)[1]);
                var Me = ye[6] - ye[0], Ge = ye[7] - ye[1];
                return Math.sqrt(Me * Me + Ge * Ge);
              }
              return A.integrate(
                Te || l(X),
                ne,
                ue,
                _(ne, ue)
              );
            },
            getTimeAt: function(X, ne, ue) {
              if (ue === qe && (ue = ne < 0 ? 1 : 0), ne === 0)
                return ue;
              var Te = Math.abs, ye = 1e-12, Me = ne > 0, Ge = Me ? ue : 0, Qe = Me ? 1 : ue, re = l(X), Se = Oe.getLength(X, Ge, Qe, re), Pe = Te(ne) - Se;
              if (Te(Pe) < ye)
                return Me ? Qe : Ge;
              if (Pe > ye)
                return null;
              var at = ne / Se, Be = 0;
              function Ze(fe) {
                return Be += A.integrate(
                  re,
                  ue,
                  fe,
                  _(ue, fe)
                ), ue = fe, Be - ne;
              }
              return A.findRoot(
                Ze,
                re,
                ue + at,
                Ge,
                Qe,
                32,
                1e-12
              );
            },
            getPoint: function(X, ne) {
              return I(X, ne, 0, !1);
            },
            getTangent: function(X, ne) {
              return I(X, ne, 1, !0);
            },
            getWeightedTangent: function(X, ne) {
              return I(X, ne, 1, !1);
            },
            getNormal: function(X, ne) {
              return I(X, ne, 2, !0);
            },
            getWeightedNormal: function(X, ne) {
              return I(X, ne, 2, !1);
            },
            getCurvature: function(X, ne) {
              return I(X, ne, 3, !1).x;
            },
            getPeaks: function(X) {
              var ne = X[0], ue = X[1], Te = X[2], ye = X[3], Me = X[4], Ge = X[5], Qe = X[6], re = X[7], Se = -ne + 3 * Te - 3 * Me + Qe, Pe = 3 * ne - 6 * Te + 3 * Me, at = -3 * ne + 3 * Te, Be = -ue + 3 * ye - 3 * Ge + re, Ze = 3 * ue - 6 * ye + 3 * Ge, fe = -3 * ue + 3 * ye, Je = 1e-8, Xe = 1 - Je, z = [];
              return A.solveCubic(
                9 * (Se * Se + Be * Be),
                9 * (Se * Pe + Ze * Be),
                2 * (Pe * Pe + Ze * Ze) + 3 * (at * Se + fe * Be),
                at * Pe + Ze * fe,
                z,
                Je,
                Xe
              ), z.sort();
            }
          } };
        }(),
        new function() {
          function l(Pe, at, Be, Ze, fe, Je, Xe) {
            var z = !Xe && Be.getPrevious() === fe, He = !Xe && Be !== fe && Be.getNext() === fe, nt = 1e-8, ae = 1 - nt;
            if (Ze !== null && Ze >= (z ? nt : 0) && Ze <= (He ? ae : 1) && Je !== null && Je >= (He ? nt : 0) && Je <= (z ? ae : 1)) {
              var $e = new Ue(Be, Ze, null, Xe), Et = new Ue(fe, Je, null, Xe);
              $e._intersection = Et, Et._intersection = $e, (!at || at($e)) && Ue.insert(Pe, $e, !0);
            }
          }
          function _(Pe, at, Be, Ze, fe, Je, Xe, z, He, nt, ae, $e, Et) {
            if (++He >= 4096 || ++z >= 40)
              return He;
            var Nt = 1e-9, Yt = at[0], Ft = at[1], ai = at[6], Mt = at[7], Ae = U.getSignedDistance, Fe = Ae(Yt, Ft, ai, Mt, at[2], at[3]), tt = Ae(Yt, Ft, ai, Mt, at[4], at[5]), Ct = Fe * tt > 0 ? 3 / 4 : 4 / 9, It = Ct * Math.min(0, Fe, tt), Ut = Ct * Math.max(0, Fe, tt), ti = Ae(Yt, Ft, ai, Mt, Pe[0], Pe[1]), Pt = Ae(Yt, Ft, ai, Mt, Pe[2], Pe[3]), Wt = Ae(Yt, Ft, ai, Mt, Pe[4], Pe[5]), ei = Ae(Yt, Ft, ai, Mt, Pe[6], Pe[7]), oi = I(ti, Pt, Wt, ei), _i = oi[0], Di = oi[1], Bi, Hi;
            if (Fe === 0 && tt === 0 && ti === 0 && Pt === 0 && Wt === 0 && ei === 0 || (Bi = X(_i, Di, It, Ut)) == null || (Hi = X(
              _i.reverse(),
              Di.reverse(),
              It,
              Ut
            )) == null)
              return He;
            var nr = nt + (ae - nt) * Bi, rr = nt + (ae - nt) * Hi;
            if (Math.max(Et - $e, rr - nr) < Nt) {
              var dr = (nr + rr) / 2, Rr = ($e + Et) / 2;
              l(
                fe,
                Je,
                Xe ? Ze : Be,
                Xe ? Rr : dr,
                Xe ? Be : Ze,
                Xe ? dr : Rr
              );
            } else {
              Pe = Oe.getPart(Pe, Bi, Hi);
              var Br = Et - $e;
              if (Hi - Bi > 0.8)
                if (rr - nr > Br) {
                  var Ki = Oe.subdivide(Pe, 0.5), dr = (nr + rr) / 2;
                  He = _(
                    at,
                    Ki[0],
                    Ze,
                    Be,
                    fe,
                    Je,
                    !Xe,
                    z,
                    He,
                    $e,
                    Et,
                    nr,
                    dr
                  ), He = _(
                    at,
                    Ki[1],
                    Ze,
                    Be,
                    fe,
                    Je,
                    !Xe,
                    z,
                    He,
                    $e,
                    Et,
                    dr,
                    rr
                  );
                } else {
                  var Ki = Oe.subdivide(at, 0.5), Rr = ($e + Et) / 2;
                  He = _(
                    Ki[0],
                    Pe,
                    Ze,
                    Be,
                    fe,
                    Je,
                    !Xe,
                    z,
                    He,
                    $e,
                    Rr,
                    nr,
                    rr
                  ), He = _(
                    Ki[1],
                    Pe,
                    Ze,
                    Be,
                    fe,
                    Je,
                    !Xe,
                    z,
                    He,
                    Rr,
                    Et,
                    nr,
                    rr
                  );
                }
              else
                Br === 0 || Br >= Nt ? He = _(
                  at,
                  Pe,
                  Ze,
                  Be,
                  fe,
                  Je,
                  !Xe,
                  z,
                  He,
                  $e,
                  Et,
                  nr,
                  rr
                ) : He = _(
                  Pe,
                  at,
                  Be,
                  Ze,
                  fe,
                  Je,
                  Xe,
                  z,
                  He,
                  nr,
                  rr,
                  $e,
                  Et
                );
            }
            return He;
          }
          function I(Pe, at, Be, Ze) {
            var fe = [0, Pe], Je = [1 / 3, at], Xe = [2 / 3, Be], z = [1, Ze], He = at - (2 * Pe + Ze) / 3, nt = Be - (Pe + 2 * Ze) / 3, ae;
            if (He * nt < 0)
              ae = [[fe, Je, z], [fe, Xe, z]];
            else {
              var $e = He / nt;
              ae = [
                $e >= 2 ? [fe, Je, z] : $e <= 0.5 ? [fe, Xe, z] : [fe, Je, Xe, z],
                [fe, z]
              ];
            }
            return (He || nt) < 0 ? ae.reverse() : ae;
          }
          function X(Pe, at, Be, Ze) {
            return Pe[0][1] < Be ? ne(Pe, !0, Be) : at[0][1] > Ze ? ne(at, !1, Ze) : Pe[0][0];
          }
          function ne(Pe, at, Be) {
            for (var Ze = Pe[0][0], fe = Pe[0][1], Je = 1, Xe = Pe.length; Je < Xe; Je++) {
              var z = Pe[Je][0], He = Pe[Je][1];
              if (at ? He >= Be : He <= Be)
                return He === Be ? z : Ze + (Be - fe) * (z - Ze) / (He - fe);
              Ze = z, fe = He;
            }
            return null;
          }
          function ue(Pe, at, Be, Ze, fe) {
            var Je = A.isZero;
            if (Je(Ze) && Je(fe)) {
              var Xe = Oe.getTimeOf(Pe, new x(at, Be));
              return Xe === null ? [] : [Xe];
            }
            for (var z = Math.atan2(-fe, Ze), He = Math.sin(z), nt = Math.cos(z), ae = [], $e = [], Et = 0; Et < 8; Et += 2) {
              var Nt = Pe[Et] - at, Yt = Pe[Et + 1] - Be;
              ae.push(
                Nt * nt - Yt * He,
                Nt * He + Yt * nt
              );
            }
            return Oe.solveCubic(ae, 1, 0, $e, 0, 1), $e;
          }
          function Te(Pe, at, Be, Ze, fe, Je, Xe) {
            for (var z = at[0], He = at[1], nt = at[6], ae = at[7], $e = ue(Pe, z, He, nt - z, ae - He), Et = 0, Nt = $e.length; Et < Nt; Et++) {
              var Yt = $e[Et], Ft = Oe.getPoint(Pe, Yt), ai = Oe.getTimeOf(at, Ft);
              ai !== null && l(
                fe,
                Je,
                Xe ? Ze : Be,
                Xe ? ai : Yt,
                Xe ? Be : Ze,
                Xe ? Yt : ai
              );
            }
          }
          function ye(Pe, at, Be, Ze, fe, Je) {
            var Xe = U.intersect(
              Pe[0],
              Pe[1],
              Pe[6],
              Pe[7],
              at[0],
              at[1],
              at[6],
              at[7]
            );
            Xe && l(
              fe,
              Je,
              Be,
              Oe.getTimeOf(Pe, Xe),
              Ze,
              Oe.getTimeOf(at, Xe)
            );
          }
          function Me(Pe, at, Be, Ze, fe, Je) {
            var Xe = 1e-12, z = Math.min, He = Math.max;
            if (He(Pe[0], Pe[2], Pe[4], Pe[6]) + Xe > z(at[0], at[2], at[4], at[6]) && z(Pe[0], Pe[2], Pe[4], Pe[6]) - Xe < He(at[0], at[2], at[4], at[6]) && He(Pe[1], Pe[3], Pe[5], Pe[7]) + Xe > z(at[1], at[3], at[5], at[7]) && z(Pe[1], Pe[3], Pe[5], Pe[7]) - Xe < He(at[1], at[3], at[5], at[7])) {
              var nt = re(Pe, at);
              if (nt)
                for (var ae = 0; ae < 2; ae++) {
                  var $e = nt[ae];
                  l(
                    fe,
                    Je,
                    Be,
                    $e[0],
                    Ze,
                    $e[1],
                    !0
                  );
                }
              else {
                var Et = Oe.isStraight(Pe), Nt = Oe.isStraight(at), Yt = Et && Nt, Ft = Et && !Nt, ai = fe.length;
                if ((Yt ? ye : Et || Nt ? Te : _)(
                  Ft ? at : Pe,
                  Ft ? Pe : at,
                  Ft ? Ze : Be,
                  Ft ? Be : Ze,
                  fe,
                  Je,
                  Ft,
                  0,
                  0,
                  0,
                  1,
                  0,
                  1
                ), !Yt || fe.length === ai)
                  for (var ae = 0; ae < 4; ae++) {
                    var Mt = ae >> 1, Ae = ae & 1, Fe = Mt * 6, tt = Ae * 6, Ct = new x(Pe[Fe], Pe[Fe + 1]), It = new x(at[tt], at[tt + 1]);
                    Ct.isClose(It, Xe) && l(
                      fe,
                      Je,
                      Be,
                      Mt,
                      Ze,
                      Ae
                    );
                  }
              }
            }
            return fe;
          }
          function Ge(Pe, at, Be, Ze) {
            var fe = Oe.classify(Pe);
            if (fe.type === "loop") {
              var Je = fe.roots;
              l(
                Be,
                Ze,
                at,
                Je[0],
                at,
                Je[1]
              );
            }
            return Be;
          }
          function Qe(Pe, at, Be, Ze, fe, Je) {
            var Xe = 1e-7, z = !at;
            z && (at = Pe);
            for (var He = Pe.length, nt = at.length, ae = new Array(He), $e = z ? ae : new Array(nt), Et = [], Nt = 0; Nt < He; Nt++)
              ae[Nt] = Pe[Nt].getValues(Ze);
            if (!z)
              for (var Nt = 0; Nt < nt; Nt++)
                $e[Nt] = at[Nt].getValues(fe);
            for (var Yt = Z.findCurveBoundsCollisions(
              ae,
              $e,
              Xe
            ), Ft = 0; Ft < He; Ft++) {
              var ai = Pe[Ft], Mt = ae[Ft];
              z && Ge(Mt, ai, Et, Be);
              var Ae = Yt[Ft];
              if (Ae)
                for (var Fe = 0; Fe < Ae.length; Fe++) {
                  if (Je && Et.length)
                    return Et;
                  var tt = Ae[Fe];
                  if (!z || tt > Ft) {
                    var Ct = at[tt], It = $e[tt];
                    Me(
                      Mt,
                      It,
                      ai,
                      Ct,
                      Et,
                      Be
                    );
                  }
                }
            }
            return Et;
          }
          function re(Pe, at) {
            function Be(ei) {
              var oi = ei[6] - ei[0], _i = ei[7] - ei[1];
              return oi * oi + _i * _i;
            }
            var Ze = Math.abs, fe = U.getDistance, Je = 1e-8, Xe = 1e-7, z = Oe.isStraight(Pe), He = Oe.isStraight(at), nt = z && He, ae = Be(Pe) < Be(at), $e = ae ? at : Pe, Et = ae ? Pe : at, Nt = $e[0], Yt = $e[1], Ft = $e[6] - Nt, ai = $e[7] - Yt;
            if (fe(Nt, Yt, Ft, ai, Et[0], Et[1], !0) < Xe && fe(Nt, Yt, Ft, ai, Et[6], Et[7], !0) < Xe)
              !nt && fe(Nt, Yt, Ft, ai, $e[2], $e[3], !0) < Xe && fe(Nt, Yt, Ft, ai, $e[4], $e[5], !0) < Xe && fe(Nt, Yt, Ft, ai, Et[2], Et[3], !0) < Xe && fe(Nt, Yt, Ft, ai, Et[4], Et[5], !0) < Xe && (z = He = nt = !0);
            else if (nt)
              return null;
            if (z ^ He)
              return null;
            for (var Mt = [Pe, at], Ae = [], Fe = 0; Fe < 4 && Ae.length < 2; Fe++) {
              var tt = Fe & 1, Ct = tt ^ 1, It = Fe >> 1, Ut = Oe.getTimeOf(Mt[tt], new x(
                Mt[Ct][It ? 6 : 0],
                Mt[Ct][It ? 7 : 1]
              ));
              if (Ut != null) {
                var ti = tt ? [It, Ut] : [Ut, It];
                (!Ae.length || Ze(ti[0] - Ae[0][0]) > Je && Ze(ti[1] - Ae[0][1]) > Je) && Ae.push(ti);
              }
              if (Fe > 2 && !Ae.length)
                break;
            }
            if (Ae.length !== 2)
              Ae = null;
            else if (!nt) {
              var Pt = Oe.getPart(Pe, Ae[0][0], Ae[1][0]), Wt = Oe.getPart(at, Ae[0][1], Ae[1][1]);
              (Ze(Wt[2] - Pt[2]) > Xe || Ze(Wt[3] - Pt[3]) > Xe || Ze(Wt[4] - Pt[4]) > Xe || Ze(Wt[5] - Pt[5]) > Xe) && (Ae = null);
            }
            return Ae;
          }
          function Se(Pe, at) {
            var Be = Pe[0], Ze = Pe[1], fe = Pe[2], Je = Pe[3], Xe = Pe[4], z = Pe[5], He = Pe[6], nt = Pe[7], ae = at.normalize(), $e = ae.x, Et = ae.y, Nt = 3 * He - 9 * Xe + 9 * fe - 3 * Be, Yt = 3 * nt - 9 * z + 9 * Je - 3 * Ze, Ft = 6 * Xe - 12 * fe + 6 * Be, ai = 6 * z - 12 * Je + 6 * Ze, Mt = 3 * fe - 3 * Be, Ae = 3 * Je - 3 * Ze, Fe = 2 * Nt * Et - 2 * Yt * $e, tt = [];
            if (Math.abs(Fe) < A.CURVETIME_EPSILON) {
              var Ct = Nt * Ae - Yt * Mt, Fe = Nt * ai - Yt * Ft;
              if (Fe != 0) {
                var It = -Ct / Fe;
                It >= 0 && It <= 1 && tt.push(It);
              }
            } else {
              var Ut = (Ft * Ft - 4 * Nt * Mt) * Et * Et + (-2 * Ft * ai + 4 * Yt * Mt + 4 * Nt * Ae) * $e * Et + (ai * ai - 4 * Yt * Ae) * $e * $e, ti = Ft * Et - ai * $e;
              if (Ut >= 0 && Fe != 0) {
                var Pt = Math.sqrt(Ut), Wt = -(ti + Pt) / Fe, ei = (-ti + Pt) / Fe;
                Wt >= 0 && Wt <= 1 && tt.push(Wt), ei >= 0 && ei <= 1 && tt.push(ei);
              }
            }
            return tt;
          }
          return {
            getIntersections: function(Pe) {
              var at = this.getValues(), Be = Pe && Pe !== this && Pe.getValues();
              return Be ? Me(at, Be, this, Pe, []) : Ge(at, this, []);
            },
            statics: {
              getOverlaps: re,
              getIntersections: Qe,
              getCurveLineIntersections: ue,
              getTimesWithTangent: Se
            }
          };
        }()
      ), Ue = q.extend(
        {
          _class: "CurveLocation",
          initialize: function(_, I, X, ne, ue) {
            if (I >= 0.99999999) {
              var Te = _.getNext();
              Te && (I = 0, _ = Te);
            }
            this._setCurve(_), this._time = I, this._point = X || _.getPointAtTime(I), this._overlap = ne, this._distance = ue, this._intersection = this._next = this._previous = null;
          },
          _setPath: function(l) {
            this._path = l, this._version = l ? l._version : 0;
          },
          _setCurve: function(l) {
            this._setPath(l._path), this._curve = l, this._segment = null, this._segment1 = l._segment1, this._segment2 = l._segment2;
          },
          _setSegment: function(l) {
            var _ = l.getCurve();
            _ ? this._setCurve(_) : (this._setPath(l._path), this._segment1 = l, this._segment2 = null), this._segment = l, this._time = l === this._segment1 ? 0 : 1, this._point = l._point.clone();
          },
          getSegment: function() {
            var l = this._segment;
            if (!l) {
              var _ = this.getCurve(), I = this.getTime();
              I === 0 ? l = _._segment1 : I === 1 ? l = _._segment2 : I != null && (l = _.getPartLength(0, I) < _.getPartLength(I, 1) ? _._segment1 : _._segment2), this._segment = l;
            }
            return l;
          },
          getCurve: function() {
            var l = this._path, _ = this;
            l && l._version !== this._version && (this._time = this._offset = this._curveOffset = this._curve = null);
            function I(X) {
              var ne = X && X.getCurve();
              if (ne && (_._time = ne.getTimeOf(_._point)) != null)
                return _._setCurve(ne), ne;
            }
            return this._curve || I(this._segment) || I(this._segment1) || I(this._segment2.getPrevious());
          },
          getPath: function() {
            var l = this.getCurve();
            return l && l._path;
          },
          getIndex: function() {
            var l = this.getCurve();
            return l && l.getIndex();
          },
          getTime: function() {
            var l = this.getCurve(), _ = this._time;
            return l && _ == null ? this._time = l.getTimeOf(this._point) : _;
          },
          getParameter: "#getTime",
          getPoint: function() {
            return this._point;
          },
          getOffset: function() {
            var l = this._offset;
            if (l == null) {
              l = 0;
              var _ = this.getPath(), I = this.getIndex();
              if (_ && I != null)
                for (var X = _.getCurves(), ne = 0; ne < I; ne++)
                  l += X[ne].getLength();
              this._offset = l += this.getCurveOffset();
            }
            return l;
          },
          getCurveOffset: function() {
            var l = this._curveOffset;
            if (l == null) {
              var _ = this.getCurve(), I = this.getTime();
              this._curveOffset = l = I != null && _ && _.getPartLength(0, I);
            }
            return l;
          },
          getIntersection: function() {
            return this._intersection;
          },
          getDistance: function() {
            return this._distance;
          },
          divide: function() {
            var l = this.getCurve(), _ = l && l.divideAtTime(this.getTime());
            return _ && this._setSegment(_._segment1), _;
          },
          split: function() {
            var l = this.getCurve(), _ = l._path, I = l && l.splitAtTime(this.getTime());
            return I && this._setSegment(_.getLastSegment()), I;
          },
          equals: function(l, _) {
            var I = this === l;
            if (!I && l instanceof Ue) {
              var X = this.getCurve(), ne = l.getCurve(), ue = X._path, Te = ne._path;
              if (ue === Te) {
                var ye = Math.abs, Me = 1e-7, Ge = ye(this.getOffset() - l.getOffset()), Qe = !_ && this._intersection, re = !_ && l._intersection;
                I = (Ge < Me || ue && ye(ue.getLength() - Ge) < Me) && (!Qe && !re || Qe && re && Qe.equals(re, !0));
              }
            }
            return I;
          },
          toString: function() {
            var l = [], _ = this.getPoint(), I = R.instance;
            _ && l.push("point: " + _);
            var X = this.getIndex();
            X != null && l.push("index: " + X);
            var ne = this.getTime();
            return ne != null && l.push("time: " + I.number(ne)), this._distance != null && l.push("distance: " + I.number(this._distance)), "{ " + l.join(", ") + " }";
          },
          isTouching: function() {
            var l = this._intersection;
            if (l && this.getTangent().isCollinear(l.getTangent())) {
              var _ = this.getCurve(), I = l.getCurve();
              return !(_.isStraight() && I.isStraight() && _.getLine().intersect(I.getLine()));
            }
            return !1;
          },
          isCrossing: function() {
            var l = this._intersection;
            if (!l)
              return !1;
            var _ = this.getTime(), I = l.getTime(), X = 1e-8, ne = 1 - X, ue = _ >= X && _ <= ne, Te = I >= X && I <= ne;
            if (ue && Te)
              return !this.isTouching();
            var ye = this.getCurve(), Me = ye && _ < X ? ye.getPrevious() : ye, Ge = l.getCurve(), Qe = Ge && I < X ? Ge.getPrevious() : Ge;
            if (_ > ne && (ye = ye.getNext()), I > ne && (Ge = Ge.getNext()), !Me || !ye || !Qe || !Ge)
              return !1;
            var re = [];
            function Se($e, Et) {
              var Nt = $e.getValues(), Yt = Oe.classify(Nt).roots || Oe.getPeaks(Nt), Ft = Yt.length, ai = Oe.getLength(
                Nt,
                Et && Ft ? Yt[Ft - 1] : 0,
                !Et && Ft ? Yt[0] : 1
              );
              re.push(Ft ? ai : ai / 32);
            }
            function Pe($e, Et, Nt) {
              return Et < Nt ? $e > Et && $e < Nt : $e > Et || $e < Nt;
            }
            ue || (Se(Me, !0), Se(ye, !1)), Te || (Se(Qe, !0), Se(Ge, !1));
            var at = this.getPoint(), Be = Math.min.apply(Math, re), Ze = ue ? ye.getTangentAtTime(_) : ye.getPointAt(Be).subtract(at), fe = ue ? Ze.negate() : Me.getPointAt(-Be).subtract(at), Je = Te ? Ge.getTangentAtTime(I) : Ge.getPointAt(Be).subtract(at), Xe = Te ? Je.negate() : Qe.getPointAt(-Be).subtract(at), z = fe.getAngle(), He = Ze.getAngle(), nt = Xe.getAngle(), ae = Je.getAngle();
            return !!(ue ? Pe(z, nt, ae) ^ Pe(He, nt, ae) && Pe(z, ae, nt) ^ Pe(He, ae, nt) : Pe(nt, z, He) ^ Pe(ae, z, He) && Pe(nt, He, z) ^ Pe(ae, He, z));
          },
          hasOverlap: function() {
            return !!this._overlap;
          }
        },
        q.each(Oe._evaluateMethods, function(l) {
          var _ = l + "At";
          this[l] = function() {
            var I = this.getCurve(), X = this.getTime();
            return X != null && I && I[_](X, !0);
          };
        }, {
          preserve: !0
        }),
        new function() {
          function l(_, I, X) {
            var ne = _.length, ue = 0, Te = ne - 1;
            function ye(at, Be) {
              for (var Ze = at + Be; Ze >= -1 && Ze <= ne; Ze += Be) {
                var fe = _[(Ze % ne + ne) % ne];
                if (!I.getPoint().isClose(
                  fe.getPoint(),
                  1e-7
                ))
                  break;
                if (I.equals(fe))
                  return fe;
              }
              return null;
            }
            for (; ue <= Te; ) {
              var Me = ue + Te >>> 1, Ge = _[Me], Qe;
              if (X && (Qe = I.equals(Ge) ? Ge : ye(Me, -1) || ye(Me, 1)))
                return I._overlap && (Qe._overlap = Qe._intersection._overlap = !0), Qe;
              var re = I.getPath(), Se = Ge.getPath(), Pe = re !== Se ? re._id - Se._id : I.getIndex() + I.getTime() - (Ge.getIndex() + Ge.getTime());
              Pe < 0 ? Te = Me - 1 : ue = Me + 1;
            }
            return _.splice(ue, 0, I), I;
          }
          return { statics: {
            insert: l,
            expand: function(_) {
              for (var I = _.slice(), X = _.length - 1; X >= 0; X--)
                l(I, _[X]._intersection, !1);
              return I;
            }
          } };
        }()
      ), we = T.extend({
        _class: "PathItem",
        _selectBounds: !1,
        _canScaleStroke: !0,
        beans: !0,
        initialize: function() {
        },
        statics: {
          create: function(l) {
            var _, I, X;
            if (q.isPlainObject(l) ? (I = l.segments, _ = l.pathData) : Array.isArray(l) ? I = l : typeof l == "string" && (_ = l), I) {
              var ne = I[0];
              X = ne && Array.isArray(ne[0]);
            } else _ && (X = (_.match(/m/gi) || []).length > 1 || /z\s*\S+/i.test(_));
            var ue = X ? it : Ce;
            return new ue(l);
          }
        },
        _asPathItem: function() {
          return this;
        },
        isClockwise: function() {
          return this.getArea() >= 0;
        },
        setClockwise: function(l) {
          this.isClockwise() != (l = !!l) && this.reverse();
        },
        setPathData: function(l) {
          var _ = l && l.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig), I, X = !1, ne, ue, Te = new x(), ye = new x();
          function Me(Xe, z) {
            var He = +I[Xe];
            return X && (He += Te[z]), He;
          }
          function Ge(Xe) {
            return new x(
              Me(Xe, "x"),
              Me(Xe + 1, "y")
            );
          }
          this.clear();
          for (var Qe = 0, re = _ && _.length; Qe < re; Qe++) {
            var Se = _[Qe], Pe = Se[0], at = Pe.toLowerCase();
            I = Se.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
            var Be = I && I.length;
            switch (X = Pe === at, ne === "z" && !/[mz]/.test(at) && this.moveTo(Te), at) {
              case "m":
              case "l":
                for (var Ze = at === "m", fe = 0; fe < Be; fe += 2)
                  this[Ze ? "moveTo" : "lineTo"](Te = Ge(fe)), Ze && (ye = Te, Ze = !1);
                ue = Te;
                break;
              case "h":
              case "v":
                var Je = at === "h" ? "x" : "y";
                Te = Te.clone();
                for (var fe = 0; fe < Be; fe++)
                  Te[Je] = Me(fe, Je), this.lineTo(Te);
                ue = Te;
                break;
              case "c":
                for (var fe = 0; fe < Be; fe += 6)
                  this.cubicCurveTo(
                    Ge(fe),
                    ue = Ge(fe + 2),
                    Te = Ge(fe + 4)
                  );
                break;
              case "s":
                for (var fe = 0; fe < Be; fe += 4)
                  this.cubicCurveTo(
                    /[cs]/.test(ne) ? Te.multiply(2).subtract(ue) : Te,
                    ue = Ge(fe),
                    Te = Ge(fe + 2)
                  ), ne = at;
                break;
              case "q":
                for (var fe = 0; fe < Be; fe += 4)
                  this.quadraticCurveTo(
                    ue = Ge(fe),
                    Te = Ge(fe + 2)
                  );
                break;
              case "t":
                for (var fe = 0; fe < Be; fe += 2)
                  this.quadraticCurveTo(
                    ue = /[qt]/.test(ne) ? Te.multiply(2).subtract(ue) : Te,
                    Te = Ge(fe)
                  ), ne = at;
                break;
              case "a":
                for (var fe = 0; fe < Be; fe += 7)
                  this.arcTo(
                    Te = Ge(fe + 5),
                    new w(+I[fe], +I[fe + 1]),
                    +I[fe + 2],
                    +I[fe + 4],
                    +I[fe + 3]
                  );
                break;
              case "z":
                this.closePath(1e-12), Te = ye;
                break;
            }
            ne = at;
          }
        },
        _canComposite: function() {
          return !(this.hasFill() && this.hasStroke());
        },
        _contains: function(l) {
          var _ = l.isInside(
            this.getBounds({ internal: !0, handle: !0 })
          ) ? this._getWinding(l) : {};
          return _.onPath || !!(this.getFillRule() === "evenodd" ? _.windingL & 1 || _.windingR & 1 : _.winding);
        },
        getIntersections: function(l, _, I, X) {
          var ne = this === l || !l, ue = this._matrix._orNullIfIdentity(), Te = ne ? ue : (I || l._matrix)._orNullIfIdentity();
          return ne || this.getBounds(ue).intersects(
            l.getBounds(Te),
            1e-12
          ) ? Oe.getIntersections(
            this.getCurves(),
            !ne && l.getCurves(),
            _,
            ue,
            Te,
            X
          ) : [];
        },
        getCrossings: function(l) {
          return this.getIntersections(l, function(_) {
            return _.isCrossing();
          });
        },
        getNearestLocation: function() {
          for (var l = x.read(arguments), _ = this.getCurves(), I = 1 / 0, X = null, ne = 0, ue = _.length; ne < ue; ne++) {
            var Te = _[ne].getNearestLocation(l);
            Te._distance < I && (I = Te._distance, X = Te);
          }
          return X;
        },
        getNearestPoint: function() {
          var l = this.getNearestLocation.apply(this, arguments);
          return l && l.getPoint();
        },
        interpolate: function(l, _, I) {
          var X = !this._children, ne = X ? "_segments" : "_children", ue = l[ne], Te = _[ne], ye = this[ne];
          if (!ue || !Te || ue.length !== Te.length)
            throw new Error("Invalid operands in interpolate() call: " + l + ", " + _);
          var Me = ye.length, Ge = Te.length;
          if (Me < Ge)
            for (var Qe = X ? ge : Ce, re = Me; re < Ge; re++)
              this.add(new Qe());
          else Me > Ge && this[X ? "removeSegments" : "removeChildren"](Ge, Me);
          for (var re = 0; re < Ge; re++)
            ye[re].interpolate(ue[re], Te[re], I);
          X && (this.setClosed(l._closed), this._changed(9));
        },
        compare: function(l) {
          var _ = !1;
          if (l) {
            var I = this._children || [this], X = l._children ? l._children.slice() : [l], ne = I.length, ue = X.length, Te = [], ye = 0;
            _ = !0;
            for (var Me = Z.findItemBoundsCollisions(I, X, A.GEOMETRIC_EPSILON), Ge = ne - 1; Ge >= 0 && _; Ge--) {
              var Qe = I[Ge];
              _ = !1;
              var re = Me[Ge];
              if (re)
                for (var Se = re.length - 1; Se >= 0 && !_; Se--)
                  Qe.compare(X[re[Se]]) && (Te[re[Se]] || (Te[re[Se]] = !0, ye++), _ = !0);
            }
            _ = _ && ye === ue;
          }
          return _;
        }
      }), Ce = we.extend(
        {
          _class: "Path",
          _serializeFields: {
            segments: [],
            closed: !1
          },
          initialize: function(_) {
            this._closed = !1, this._segments = [], this._version = 0;
            var I = arguments, X = Array.isArray(_) ? typeof _[0] == "object" ? _ : I : _ && _.size === qe && (_.x !== qe || _.point !== qe) ? I : null;
            X && X.length > 0 ? this.setSegments(X) : (this._curves = qe, this._segmentSelection = 0, !X && typeof _ == "string" && (this.setPathData(_), _ = null)), this._initialize(!X && _);
          },
          _equals: function(l) {
            return this._closed === l._closed && q.equals(this._segments, l._segments);
          },
          copyContent: function(l) {
            this.setSegments(l._segments), this._closed = l._closed;
          },
          _changed: function l(_) {
            if (l.base.call(this, _), _ & 8) {
              if (this._length = this._area = qe, _ & 32)
                this._version++;
              else if (this._curves)
                for (var I = 0, X = this._curves.length; I < X; I++)
                  this._curves[I]._changed();
            } else _ & 64 && (this._bounds = qe);
          },
          getStyle: function() {
            var l = this._parent;
            return (l instanceof it ? l : this)._style;
          },
          getSegments: function() {
            return this._segments;
          },
          setSegments: function(l) {
            var _ = this.isFullySelected(), I = l && l.length;
            if (this._segments.length = 0, this._segmentSelection = 0, this._curves = qe, I) {
              var X = l[I - 1];
              typeof X == "boolean" && (this.setClosed(X), I--), this._add(ge.readList(l, 0, {}, I));
            }
            _ && this.setFullySelected(!0);
          },
          getFirstSegment: function() {
            return this._segments[0];
          },
          getLastSegment: function() {
            return this._segments[this._segments.length - 1];
          },
          getCurves: function() {
            var l = this._curves, _ = this._segments;
            if (!l) {
              var I = this._countCurves();
              l = this._curves = new Array(I);
              for (var X = 0; X < I; X++)
                l[X] = new Oe(
                  this,
                  _[X],
                  _[X + 1] || _[0]
                );
            }
            return l;
          },
          getFirstCurve: function() {
            return this.getCurves()[0];
          },
          getLastCurve: function() {
            var l = this.getCurves();
            return l[l.length - 1];
          },
          isClosed: function() {
            return this._closed;
          },
          setClosed: function(l) {
            if (this._closed != (l = !!l)) {
              if (this._closed = l, this._curves) {
                var _ = this._curves.length = this._countCurves();
                l && (this._curves[_ - 1] = new Oe(
                  this,
                  this._segments[_ - 1],
                  this._segments[0]
                ));
              }
              this._changed(41);
            }
          }
        },
        {
          beans: !0,
          getPathData: function(l, _) {
            var I = this._segments, X = I.length, ne = new R(_), ue = new Array(6), Te = !0, ye, Me, Ge, Qe, re, Se, Pe, at, Be = [];
            function Ze(Je, Xe) {
              if (Je._transformCoordinates(l, ue), ye = ue[0], Me = ue[1], Te)
                Be.push("M" + ne.pair(ye, Me)), Te = !1;
              else if (re = ue[2], Se = ue[3], re === ye && Se === Me && Pe === Ge && at === Qe) {
                if (!Xe) {
                  var z = ye - Ge, He = Me - Qe;
                  Be.push(
                    z === 0 ? "v" + ne.number(He) : He === 0 ? "h" + ne.number(z) : "l" + ne.pair(z, He)
                  );
                }
              } else
                Be.push("c" + ne.pair(Pe - Ge, at - Qe) + " " + ne.pair(re - Ge, Se - Qe) + " " + ne.pair(ye - Ge, Me - Qe));
              Ge = ye, Qe = Me, Pe = ue[4], at = ue[5];
            }
            if (!X)
              return "";
            for (var fe = 0; fe < X; fe++)
              Ze(I[fe]);
            return this._closed && X > 0 && (Ze(I[0], !0), Be.push("z")), Be.join("");
          },
          isEmpty: function() {
            return !this._segments.length;
          },
          _transformContent: function(l) {
            for (var _ = this._segments, I = new Array(6), X = 0, ne = _.length; X < ne; X++)
              _[X]._transformCoordinates(l, I, !0);
            return !0;
          },
          _add: function(l, Te) {
            for (var I = this._segments, X = this._curves, ne = l.length, ue = Te == null, Te = ue ? I.length : Te, ye = 0; ye < ne; ye++) {
              var Me = l[ye];
              Me._path && (Me = l[ye] = Me.clone()), Me._path = this, Me._index = Te + ye, Me._selection && this._updateSelection(Me, 0, Me._selection);
            }
            if (ue)
              q.push(I, l);
            else {
              I.splice.apply(I, [Te, 0].concat(l));
              for (var ye = Te + ne, Ge = I.length; ye < Ge; ye++)
                I[ye]._index = ye;
            }
            if (X) {
              var Qe = this._countCurves(), re = Te > 0 && Te + ne - 1 === Qe ? Te - 1 : Te, Se = re, Pe = Math.min(re + ne, Qe);
              l._curves && (X.splice.apply(X, [re, 0].concat(l._curves)), Se += l._curves.length);
              for (var ye = Se; ye < Pe; ye++)
                X.splice(ye, 0, new Oe(this, null, null));
              this._adjustCurves(re, Pe);
            }
            return this._changed(41), l;
          },
          _adjustCurves: function(l, _) {
            for (var I = this._segments, X = this._curves, ne, ue = l; ue < _; ue++)
              ne = X[ue], ne._path = this, ne._segment1 = I[ue], ne._segment2 = I[ue + 1] || I[0], ne._changed();
            (ne = X[this._closed && !l ? I.length - 1 : l - 1]) && (ne._segment2 = I[l] || I[0], ne._changed()), (ne = X[_]) && (ne._segment1 = I[_], ne._changed());
          },
          _countCurves: function() {
            var l = this._segments.length;
            return !this._closed && l > 0 ? l - 1 : l;
          },
          add: function(l) {
            var _ = arguments;
            return _.length > 1 && typeof l != "number" ? this._add(ge.readList(_)) : this._add([ge.read(_)])[0];
          },
          insert: function(l, _) {
            var I = arguments;
            return I.length > 2 && typeof _ != "number" ? this._add(ge.readList(I, 1), l) : this._add([ge.read(I, 1)], l)[0];
          },
          addSegment: function() {
            return this._add([ge.read(arguments)])[0];
          },
          insertSegment: function(l) {
            return this._add([ge.read(arguments, 1)], l)[0];
          },
          addSegments: function(l) {
            return this._add(ge.readList(l));
          },
          insertSegments: function(l, _) {
            return this._add(ge.readList(_), l);
          },
          removeSegment: function(l) {
            return this.removeSegments(l, l + 1)[0] || null;
          },
          removeSegments: function(l, _, I) {
            l = l || 0, _ = q.pick(_, this._segments.length);
            var X = this._segments, ne = this._curves, ue = X.length, Te = X.splice(l, _ - l), ye = Te.length;
            if (!ye)
              return Te;
            for (var Me = 0; Me < ye; Me++) {
              var Ge = Te[Me];
              Ge._selection && this._updateSelection(Ge, Ge._selection, 0), Ge._index = Ge._path = null;
            }
            for (var Me = l, Qe = X.length; Me < Qe; Me++)
              X[Me]._index = Me;
            if (ne) {
              for (var re = l > 0 && _ === ue + (this._closed ? 1 : 0) ? l - 1 : l, ne = ne.splice(re, ye), Me = ne.length - 1; Me >= 0; Me--)
                ne[Me]._path = null;
              I && (Te._curves = ne.slice(1)), this._adjustCurves(re, re);
            }
            return this._changed(41), Te;
          },
          clear: "#removeSegments",
          hasHandles: function() {
            for (var l = this._segments, _ = 0, I = l.length; _ < I; _++)
              if (l[_].hasHandles())
                return !0;
            return !1;
          },
          clearHandles: function() {
            for (var l = this._segments, _ = 0, I = l.length; _ < I; _++)
              l[_].clearHandles();
          },
          getLength: function() {
            if (this._length == null) {
              for (var l = this.getCurves(), _ = 0, I = 0, X = l.length; I < X; I++)
                _ += l[I].getLength();
              this._length = _;
            }
            return this._length;
          },
          getArea: function() {
            var l = this._area;
            if (l == null) {
              var _ = this._segments, I = this._closed;
              l = 0;
              for (var X = 0, ne = _.length; X < ne; X++) {
                var ue = X + 1 === ne;
                l += Oe.getArea(Oe.getValues(
                  _[X],
                  _[ue ? 0 : X + 1],
                  null,
                  ue && !I
                ));
              }
              this._area = l;
            }
            return l;
          },
          isFullySelected: function() {
            var l = this._segments.length;
            return this.isSelected() && l > 0 && this._segmentSelection === l * 7;
          },
          setFullySelected: function(l) {
            l && this._selectSegments(!0), this.setSelected(l);
          },
          setSelection: function l(_) {
            _ & 1 || this._selectSegments(!1), l.base.call(this, _);
          },
          _selectSegments: function(l) {
            var _ = this._segments, I = _.length, X = l ? 7 : 0;
            this._segmentSelection = X * I;
            for (var ne = 0; ne < I; ne++)
              _[ne]._selection = X;
          },
          _updateSelection: function(l, _, I) {
            l._selection = I;
            var X = this._segmentSelection += I - _;
            X > 0 && this.setSelected(!0);
          },
          divideAt: function(l) {
            var _ = this.getLocationAt(l), I;
            return _ && (I = _.getCurve().divideAt(_.getCurveOffset())) ? I._segment1 : null;
          },
          splitAt: function(l) {
            var _ = this.getLocationAt(l), I = _ && _.index, X = _ && _.time, ne = 1e-8, ue = 1 - ne;
            X > ue && (I++, X = 0);
            var Te = this.getCurves();
            if (I >= 0 && I < Te.length) {
              X >= ne && Te[I++].divideAtTime(X);
              var ye = this.removeSegments(I, this._segments.length, !0), Me;
              return this._closed ? (this.setClosed(!1), Me = this) : (Me = new Ce(T.NO_INSERT), Me.insertAbove(this), Me.copyAttributes(this)), Me._add(ye, 0), this.addSegment(ye[0]), Me;
            }
            return null;
          },
          split: function(l, _) {
            var I, X = _ === qe ? l : (I = this.getCurves()[l]) && I.getLocationAtTime(_);
            return X != null ? this.splitAt(X) : null;
          },
          join: function(l, _) {
            var I = _ || 0;
            if (l && l !== this) {
              var X = l._segments, ne = this.getLastSegment(), ue = l.getLastSegment();
              if (!ue)
                return this;
              ne && ne._point.isClose(ue._point, I) && l.reverse();
              var Te = l.getFirstSegment();
              if (ne && ne._point.isClose(Te._point, I))
                ne.setHandleOut(Te._handleOut), this._add(X.slice(1));
              else {
                var ye = this.getFirstSegment();
                ye && ye._point.isClose(Te._point, I) && l.reverse(), ue = l.getLastSegment(), ye && ye._point.isClose(ue._point, I) ? (ye.setHandleIn(ue._handleIn), this._add(X.slice(0, X.length - 1), 0)) : this._add(X.slice());
              }
              l._closed && this._add([X[0]]), l.remove();
            }
            var Me = this.getFirstSegment(), Ge = this.getLastSegment();
            return Me !== Ge && Me._point.isClose(Ge._point, I) && (Me.setHandleIn(Ge._handleIn), Ge.remove(), this.setClosed(!0)), this;
          },
          reduce: function(l) {
            for (var _ = this.getCurves(), I = l && l.simplify, X = I ? 1e-7 : 0, ne = _.length - 1; ne >= 0; ne--) {
              var ue = _[ne];
              !ue.hasHandles() && (!ue.hasLength(X) || I && ue.isCollinear(ue.getNext())) && ue.remove();
            }
            return this;
          },
          reverse: function() {
            this._segments.reverse();
            for (var l = 0, _ = this._segments.length; l < _; l++) {
              var I = this._segments[l], X = I._handleIn;
              I._handleIn = I._handleOut, I._handleOut = X, I._index = l;
            }
            this._curves = null, this._changed(9);
          },
          flatten: function(l) {
            for (var _ = new ut(this, l || 0.25, 256, !0), I = _.parts, X = I.length, ne = [], ue = 0; ue < X; ue++)
              ne.push(new ge(I[ue].curve.slice(0, 2)));
            !this._closed && X > 0 && ne.push(new ge(I[X - 1].curve.slice(6))), this.setSegments(ne);
          },
          simplify: function(l) {
            var _ = new bt(this).fit(l || 2.5);
            return _ && this.setSegments(_), !!_;
          },
          smooth: function(l) {
            var _ = this, I = l || {}, X = I.type || "asymmetric", ne = this._segments, ue = ne.length, Te = this._closed;
            function ye(_i, Di) {
              var Bi = _i && _i.index;
              if (Bi != null) {
                var Hi = _i.path;
                if (Hi && Hi !== _)
                  throw new Error(_i._class + " " + Bi + " of " + Hi + " is not part of " + _);
                Di && _i instanceof Oe && Bi++;
              } else
                Bi = typeof _i == "number" ? _i : Di;
              return Math.min(Bi < 0 && Te ? Bi % ue : Bi < 0 ? Bi + ue : Bi, ue - 1);
            }
            var Me = Te && I.from === qe && I.to === qe, Ge = ye(I.from, 0), Qe = ye(I.to, ue - 1);
            if (Ge > Qe)
              if (Te)
                Ge -= ue;
              else {
                var re = Ge;
                Ge = Qe, Qe = re;
              }
            if (/^(?:asymmetric|continuous)$/.test(X)) {
              var Se = X === "asymmetric", Pe = Math.min, at = Qe - Ge + 1, Be = at - 1, Ze = Me ? Pe(at, 4) : 1, fe = Ze, Je = Ze, Xe = [];
              if (Te || (fe = Pe(1, Ge), Je = Pe(1, ue - Qe - 1)), Be += fe + Je, Be <= 1)
                return;
              for (var z = 0, He = Ge - fe; z <= Be; z++, He++)
                Xe[z] = ne[(He < 0 ? He + ue : He) % ue]._point;
              for (var nt = Xe[0]._x + 2 * Xe[1]._x, ae = Xe[0]._y + 2 * Xe[1]._y, $e = 2, Et = Be - 1, Nt = [nt], Yt = [ae], Ft = [$e], ai = [], Mt = [], z = 1; z < Be; z++) {
                var Ae = z < Et, Fe = Ae || Se ? 1 : 2, tt = Ae ? 4 : Se ? 2 : 7, Ct = Ae ? 4 : Se ? 3 : 8, It = Ae ? 2 : Se ? 0 : 1, Ut = Fe / $e;
                $e = Ft[z] = tt - Ut, nt = Nt[z] = Ct * Xe[z]._x + It * Xe[z + 1]._x - Ut * nt, ae = Yt[z] = Ct * Xe[z]._y + It * Xe[z + 1]._y - Ut * ae;
              }
              ai[Et] = Nt[Et] / Ft[Et], Mt[Et] = Yt[Et] / Ft[Et];
              for (var z = Be - 2; z >= 0; z--)
                ai[z] = (Nt[z] - ai[z + 1]) / Ft[z], Mt[z] = (Yt[z] - Mt[z + 1]) / Ft[z];
              ai[Be] = (3 * Xe[Be]._x - ai[Et]) / 2, Mt[Be] = (3 * Xe[Be]._y - Mt[Et]) / 2;
              for (var z = fe, ti = Be - Je, He = Ge; z <= ti; z++, He++) {
                var Pt = ne[He < 0 ? He + ue : He], Wt = Pt._point, ei = ai[z] - Wt._x, oi = Mt[z] - Wt._y;
                (Me || z < ti) && Pt.setHandleOut(ei, oi), (Me || z > fe) && Pt.setHandleIn(-ei, -oi);
              }
            } else
              for (var z = Ge; z <= Qe; z++)
                ne[z < 0 ? z + ue : z].smooth(
                  I,
                  !Me && z === Ge,
                  !Me && z === Qe
                );
          },
          toShape: function(l) {
            if (!this._closed)
              return null;
            var _ = this._segments, I, X, ne, ue;
            function Te(Se, Pe) {
              var at = _[Se], Be = at.getNext(), Ze = _[Pe], fe = Ze.getNext();
              return at._handleOut.isZero() && Be._handleIn.isZero() && Ze._handleOut.isZero() && fe._handleIn.isZero() && Be._point.subtract(at._point).isCollinear(
                fe._point.subtract(Ze._point)
              );
            }
            function ye(Se) {
              var Pe = _[Se], at = Pe.getPrevious(), Be = Pe.getNext();
              return at._handleOut.isZero() && Pe._handleIn.isZero() && Pe._handleOut.isZero() && Be._handleIn.isZero() && Pe._point.subtract(at._point).isOrthogonal(
                Be._point.subtract(Pe._point)
              );
            }
            function Me(Se) {
              var Pe = _[Se], at = Pe.getNext(), Be = Pe._handleOut, Ze = at._handleIn, fe = 0.5522847498307936;
              if (Be.isOrthogonal(Ze)) {
                var Je = Pe._point, Xe = at._point, z = new U(Je, Be, !0).intersect(
                  new U(Xe, Ze, !0),
                  !0
                );
                return z && A.isZero(Be.getLength() / z.subtract(Je).getLength() - fe) && A.isZero(Ze.getLength() / z.subtract(Xe).getLength() - fe);
              }
              return !1;
            }
            function Ge(Se, Pe) {
              return _[Se]._point.getDistance(_[Pe]._point);
            }
            if (!this.hasHandles() && _.length === 4 && Te(0, 2) && Te(1, 3) && ye(1) ? (I = ee.Rectangle, X = new w(Ge(0, 3), Ge(0, 1)), ue = _[1]._point.add(_[2]._point).divide(2)) : _.length === 8 && Me(0) && Me(2) && Me(4) && Me(6) && Te(1, 5) && Te(3, 7) ? (I = ee.Rectangle, X = new w(Ge(1, 6), Ge(0, 3)), ne = X.subtract(new w(
              Ge(0, 7),
              Ge(1, 2)
            )).divide(2), ue = _[3]._point.add(_[4]._point).divide(2)) : _.length === 4 && Me(0) && Me(1) && Me(2) && Me(3) && (A.isZero(Ge(0, 2) - Ge(1, 3)) ? (I = ee.Circle, ne = Ge(0, 2) / 2) : (I = ee.Ellipse, ne = new w(Ge(2, 0) / 2, Ge(3, 1) / 2)), ue = _[1]._point), I) {
              var Qe = this.getPosition(!0), re = new I({
                center: Qe,
                size: X,
                radius: ne,
                insert: !1
              });
              return re.copyAttributes(this, !0), re._matrix.prepend(this._matrix), re.rotate(ue.subtract(Qe).getAngle() + 90), (l === qe || l) && re.insertAbove(this), re;
            }
            return null;
          },
          toPath: "#clone",
          compare: function l(_) {
            if (!_ || _ instanceof it)
              return l.base.call(this, _);
            var I = this.getCurves(), X = _.getCurves(), ne = I.length, ue = X.length;
            if (!ne || !ue)
              return ne == ue;
            for (var Te = I[0].getValues(), ye = [], Me = 0, Ge, Qe = 0, re, Se = 0; Se < ue; Se++) {
              var Ze = X[Se].getValues();
              ye.push(Ze);
              var Pe = Oe.getOverlaps(Te, Ze);
              if (Pe) {
                Ge = !Se && Pe[0][0] > 0 ? ue - 1 : Se, re = Pe[0][1];
                break;
              }
            }
            for (var at = Math.abs, Be = 1e-8, Ze = ye[Ge], fe; Te && Ze; ) {
              var Pe = Oe.getOverlaps(Te, Ze);
              if (Pe) {
                var Je = Pe[0][0];
                if (at(Je - Qe) < Be) {
                  Qe = Pe[1][0], Qe === 1 && (Te = ++Me < ne ? I[Me].getValues() : null, Qe = 0);
                  var Xe = Pe[0][1];
                  if (at(Xe - re) < Be) {
                    if (fe || (fe = [Ge, Xe]), re = Pe[1][1], re === 1 && (++Ge >= ue && (Ge = 0), Ze = ye[Ge] || X[Ge].getValues(), re = 0), !Te)
                      return fe[0] === Ge && fe[1] === re;
                    continue;
                  }
                }
              }
              break;
            }
            return !1;
          },
          _hitTestSelf: function(l, _, I, X) {
            var ne = this, ue = this.getStyle(), Te = this._segments, ye = Te.length, Me = this._closed, Ge = _._tolerancePadding, Qe = Ge, re, Se, Pe, at, Be, Ze, fe = _.stroke && ue.hasStroke(), Je = _.fill && ue.hasFill(), Xe = _.curves, z = fe ? ue.getStrokeWidth() / 2 : Je && _.tolerance > 0 || Xe ? 0 : null;
            z !== null && (z > 0 ? (re = ue.getStrokeJoin(), Se = ue.getStrokeCap(), Pe = ue.getMiterLimit(), Qe = Qe.add(
              Ce._getStrokePadding(z, X)
            )) : re = Se = "round");
            function He(ai, Mt) {
              return l.subtract(ai).divide(Mt).length <= 1;
            }
            function nt(ai, Mt, Ae) {
              if (!_.selected || Mt.isSelected()) {
                var Fe = ai._point;
                if (Mt !== Fe && (Mt = Mt.add(Fe)), He(Mt, Qe))
                  return new ke(Ae, ne, {
                    segment: ai,
                    point: Mt
                  });
              }
            }
            function ae(ai, Mt) {
              return (Mt || _.segments) && nt(ai, ai._point, "segment") || !Mt && _.handles && (nt(ai, ai._handleIn, "handle-in") || nt(ai, ai._handleOut, "handle-out"));
            }
            function $e(ai) {
              at.add(ai);
            }
            function Et(ai) {
              var Mt = Me || ai._index > 0 && ai._index < ye - 1;
              if ((Mt ? re : Se) === "round")
                return He(ai._point, Qe);
              if (at = new Ce({ internal: !0, closed: !0 }), Mt ? ai.isSmooth() || Ce._addBevelJoin(
                ai,
                re,
                z,
                Pe,
                null,
                X,
                $e,
                !0
              ) : Se === "square" && Ce._addSquareCap(
                ai,
                Se,
                z,
                null,
                X,
                $e,
                !0
              ), !at.isEmpty()) {
                var Ae;
                return at.contains(l) || (Ae = at.getNearestLocation(l)) && He(Ae.getPoint(), Ge);
              }
            }
            if (_.ends && !_.segments && !Me) {
              if (Ze = ae(Te[0], !0) || ae(Te[ye - 1], !0))
                return Ze;
            } else if (_.segments || _.handles) {
              for (var Nt = 0; Nt < ye; Nt++)
                if (Ze = ae(Te[Nt]))
                  return Ze;
            }
            if (z !== null) {
              if (Be = this.getNearestLocation(l), Be) {
                var Yt = Be.getTime();
                Yt === 0 || Yt === 1 && ye > 1 ? Et(Be.getSegment()) || (Be = null) : He(Be.getPoint(), Qe) || (Be = null);
              }
              if (!Be && re === "miter" && ye > 1)
                for (var Nt = 0; Nt < ye; Nt++) {
                  var Ft = Te[Nt];
                  if (l.getDistance(Ft._point) <= Pe * z && Et(Ft)) {
                    Be = Ft.getLocation();
                    break;
                  }
                }
            }
            return !Be && Je && this._contains(l) || Be && !fe && !Xe ? new ke("fill", this) : Be ? new ke(fe ? "stroke" : "curve", this, {
              location: Be,
              point: Be.getPoint()
            }) : null;
          }
        },
        q.each(
          Oe._evaluateMethods,
          function(l) {
            this[l + "At"] = function(_) {
              var I = this.getLocationAt(_);
              return I && I[l]();
            };
          },
          {
            beans: !1,
            getLocationOf: function() {
              for (var l = x.read(arguments), _ = this.getCurves(), I = 0, X = _.length; I < X; I++) {
                var ne = _[I].getLocationOf(l);
                if (ne)
                  return ne;
              }
              return null;
            },
            getOffsetOf: function() {
              var l = this.getLocationOf.apply(this, arguments);
              return l ? l.getOffset() : null;
            },
            getLocationAt: function(l) {
              if (typeof l == "number") {
                for (var _ = this.getCurves(), I = 0, X = 0, ne = _.length; X < ne; X++) {
                  var ue = I, Te = _[X];
                  if (I += Te.getLength(), I > l)
                    return Te.getLocationAt(l - ue);
                }
                if (_.length > 0 && l <= this.getLength())
                  return new Ue(_[_.length - 1], 1);
              } else if (l && l.getPath && l.getPath() === this)
                return l;
              return null;
            },
            getOffsetsWithTangent: function() {
              var l = x.read(arguments);
              if (l.isZero())
                return [];
              for (var _ = [], I = 0, X = this.getCurves(), ne = 0, ue = X.length; ne < ue; ne++) {
                for (var Te = X[ne], ye = Te.getTimesWithTangent(l), Me = 0, Ge = ye.length; Me < Ge; Me++) {
                  var Qe = I + Te.getOffsetAtTime(ye[Me]);
                  _.indexOf(Qe) < 0 && _.push(Qe);
                }
                I += Te.length;
              }
              return _;
            }
          }
        ),
        new function() {
          function l(I, X, ne, ue) {
            if (ue <= 0) return;
            var Te = ue / 2, ye = ue - 2, Me = Te - 1, Ge = new Array(6), Qe, re;
            function Se(Je) {
              var Xe = Ge[Je], z = Ge[Je + 1];
              (Qe != Xe || re != z) && (I.beginPath(), I.moveTo(Qe, re), I.lineTo(Xe, z), I.stroke(), I.beginPath(), I.arc(Xe, z, Te, 0, Math.PI * 2, !0), I.fill());
            }
            for (var Pe = 0, at = X.length; Pe < at; Pe++) {
              var Be = X[Pe], Ze = Be._selection;
              if (Be._transformCoordinates(ne, Ge), Qe = Ge[0], re = Ge[1], Ze & 2 && Se(2), Ze & 4 && Se(4), I.fillRect(Qe - Te, re - Te, ue, ue), ye > 0 && !(Ze & 1)) {
                var fe = I.fillStyle;
                I.fillStyle = "#ffffff", I.fillRect(Qe - Me, re - Me, ye, ye), I.fillStyle = fe;
              }
            }
          }
          function _(I, X, ne) {
            var ue = X._segments, Te = ue.length, ye = new Array(6), Me = !0, Ge, Qe, re, Se, Pe, at, Be, Ze;
            function fe(Xe) {
              if (ne)
                Xe._transformCoordinates(ne, ye), Ge = ye[0], Qe = ye[1];
              else {
                var z = Xe._point;
                Ge = z._x, Qe = z._y;
              }
              if (Me)
                I.moveTo(Ge, Qe), Me = !1;
              else {
                if (ne)
                  Pe = ye[2], at = ye[3];
                else {
                  var He = Xe._handleIn;
                  Pe = Ge + He._x, at = Qe + He._y;
                }
                Pe === Ge && at === Qe && Be === re && Ze === Se ? I.lineTo(Ge, Qe) : I.bezierCurveTo(Be, Ze, Pe, at, Ge, Qe);
              }
              if (re = Ge, Se = Qe, ne)
                Be = ye[4], Ze = ye[5];
              else {
                var He = Xe._handleOut;
                Be = re + He._x, Ze = Se + He._y;
              }
            }
            for (var Je = 0; Je < Te; Je++)
              fe(ue[Je]);
            X._closed && Te > 0 && fe(ue[0]);
          }
          return {
            _draw: function(I, X, ne, ue) {
              var Te = X.dontStart, ye = X.dontFinish || X.clip, Me = this.getStyle(), Ge = Me.hasFill(), Qe = Me.hasStroke(), re = Me.getDashArray(), Se = !xt.support.nativeDash && Qe && re && re.length;
              Te || I.beginPath(), (Ge || Qe && !Se || ye) && (_(I, this, ue), this._closed && I.closePath());
              function Pe(Xe) {
                return re[(Xe % Se + Se) % Se];
              }
              if (!ye && (Ge || Qe) && (this._setStyles(I, X, ne), Ge && (I.fill(Me.getFillRule()), I.shadowColor = "rgba(0,0,0,0)"), Qe)) {
                if (Se) {
                  Te || I.beginPath();
                  for (var at = new ut(
                    this,
                    0.25,
                    32,
                    !1,
                    ue
                  ), Be = at.length, Ze = -Me.getDashOffset(), fe, Je = 0; Ze > 0; )
                    Ze -= Pe(Je--) + Pe(Je--);
                  for (; Ze < Be; )
                    fe = Ze + Pe(Je++), (Ze > 0 || fe > 0) && at.drawPart(
                      I,
                      Math.max(Ze, 0),
                      Math.max(fe, 0)
                    ), Ze = fe + Pe(Je++);
                }
                I.stroke();
              }
            },
            _drawSelected: function(I, X) {
              I.beginPath(), _(I, this, X), I.stroke(), l(I, this._segments, X, xt.settings.handleSize);
            }
          };
        }(),
        new function() {
          function l(_) {
            var I = _._segments;
            if (!I.length)
              throw new Error("Use a moveTo() command first");
            return I[I.length - 1];
          }
          return {
            moveTo: function() {
              var _ = this._segments;
              _.length === 1 && this.removeSegment(0), _.length || this._add([new ge(x.read(arguments))]);
            },
            moveBy: function() {
              throw new Error("moveBy() is unsupported on Path items.");
            },
            lineTo: function() {
              this._add([new ge(x.read(arguments))]);
            },
            cubicCurveTo: function() {
              var _ = arguments, I = x.read(_), X = x.read(_), ne = x.read(_), ue = l(this);
              ue.setHandleOut(I.subtract(ue._point)), this._add([new ge(ne, X.subtract(ne))]);
            },
            quadraticCurveTo: function() {
              var _ = arguments, I = x.read(_), X = x.read(_), ne = l(this)._point;
              this.cubicCurveTo(
                I.add(ne.subtract(I).multiply(1 / 3)),
                I.add(X.subtract(I).multiply(1 / 3)),
                X
              );
            },
            curveTo: function() {
              var _ = arguments, I = x.read(_), X = x.read(_), ne = q.pick(q.read(_), 0.5), ue = 1 - ne, Te = l(this)._point, ye = I.subtract(Te.multiply(ue * ue)).subtract(X.multiply(ne * ne)).divide(2 * ne * ue);
              if (ye.isNaN())
                throw new Error(
                  "Cannot put a curve through points with parameter = " + ne
                );
              this.quadraticCurveTo(ye, X);
            },
            arcTo: function() {
              var _ = arguments, I = Math.abs, X = Math.sqrt, ne = l(this), ue = ne._point, Te = x.read(_), ye, Me = q.peek(_), Ge = q.pick(Me, !0), Qe, re, Se, Pe;
              if (typeof Ge == "boolean")
                var at = ue.add(Te).divide(2), ye = at.add(at.subtract(ue).rotate(
                  Ge ? -90 : 90
                ));
              else if (q.remain(_) <= 2)
                ye = Te, Te = x.read(_);
              else if (!ue.equals(Te)) {
                var Be = w.read(_), Ze = A.isZero;
                if (Ze(Be.width) || Ze(Be.height))
                  return this.lineTo(Te);
                var fe = q.read(_), Ge = !!q.read(_), Je = !!q.read(_), at = ue.add(Te).divide(2), Xe = ue.subtract(at).rotate(-fe), z = Xe.x, He = Xe.y, nt = I(Be.width), ae = I(Be.height), $e = nt * nt, Et = ae * ae, Nt = z * z, Yt = He * He, Ft = X(Nt / $e + Yt / Et);
                if (Ft > 1 && (nt *= Ft, ae *= Ft, $e = nt * nt, Et = ae * ae), Ft = ($e * Et - $e * Yt - Et * Nt) / ($e * Yt + Et * Nt), I(Ft) < 1e-12 && (Ft = 0), Ft < 0)
                  throw new Error(
                    "Cannot create an arc with the given arguments"
                  );
                Qe = new x(nt * He / ae, -ae * z / nt).multiply((Je === Ge ? -1 : 1) * X(Ft)).rotate(fe).add(at), Pe = new S().translate(Qe).rotate(fe).scale(nt, ae), Se = Pe._inverseTransform(ue), re = Se.getDirectedAngle(Pe._inverseTransform(Te)), !Ge && re > 0 ? re -= 360 : Ge && re < 0 && (re += 360);
              }
              if (ye) {
                var ai = new U(
                  ue.add(ye).divide(2),
                  ye.subtract(ue).rotate(90),
                  !0
                ), Mt = new U(
                  ye.add(Te).divide(2),
                  Te.subtract(ye).rotate(90),
                  !0
                ), Ae = new U(ue, Te), Fe = Ae.getSide(ye);
                if (Qe = ai.intersect(Mt, !0), !Qe) {
                  if (!Fe)
                    return this.lineTo(Te);
                  throw new Error(
                    "Cannot create an arc with the given arguments"
                  );
                }
                Se = ue.subtract(Qe), re = Se.getDirectedAngle(Te.subtract(Qe));
                var tt = Ae.getSide(Qe, !0);
                tt === 0 ? re = Fe * I(re) : Fe === tt && (re += re < 0 ? 360 : -360);
              }
              if (re) {
                for (var Ct = 1e-5, It = I(re), Ut = It >= 360 ? 4 : Math.ceil((It - Ct) / 90), ti = re / Ut, Pt = ti * Math.PI / 360, Wt = 4 / 3 * Math.sin(Pt) / (1 + Math.cos(Pt)), ei = [], oi = 0; oi <= Ut; oi++) {
                  var Xe = Te, _i = null;
                  if (oi < Ut && (_i = Se.rotate(90).multiply(Wt), Pe ? (Xe = Pe._transformPoint(Se), _i = Pe._transformPoint(Se.add(_i)).subtract(Xe)) : Xe = Qe.add(Se)), !oi)
                    ne.setHandleOut(_i);
                  else {
                    var Di = Se.rotate(-90).multiply(Wt);
                    Pe && (Di = Pe._transformPoint(Se.add(Di)).subtract(Xe)), ei.push(new ge(Xe, Di, _i));
                  }
                  Se = Se.rotate(ti);
                }
                this._add(ei);
              }
            },
            lineBy: function() {
              var _ = x.read(arguments), I = l(this)._point;
              this.lineTo(I.add(_));
            },
            curveBy: function() {
              var _ = arguments, I = x.read(_), X = x.read(_), ne = q.read(_), ue = l(this)._point;
              this.curveTo(ue.add(I), ue.add(X), ne);
            },
            cubicCurveBy: function() {
              var _ = arguments, I = x.read(_), X = x.read(_), ne = x.read(_), ue = l(this)._point;
              this.cubicCurveTo(
                ue.add(I),
                ue.add(X),
                ue.add(ne)
              );
            },
            quadraticCurveBy: function() {
              var _ = arguments, I = x.read(_), X = x.read(_), ne = l(this)._point;
              this.quadraticCurveTo(ne.add(I), ne.add(X));
            },
            arcBy: function() {
              var _ = arguments, I = l(this)._point, X = I.add(x.read(_)), ne = q.pick(q.peek(_), !0);
              typeof ne == "boolean" ? this.arcTo(X, ne) : this.arcTo(X, I.add(x.read(_)));
            },
            closePath: function(_) {
              this.setClosed(!0), this.join(this, _);
            }
          };
        }(),
        {
          _getBounds: function(l, _) {
            var I = _.handle ? "getHandleBounds" : _.stroke ? "getStrokeBounds" : "getBounds";
            return Ce[I](this._segments, this._closed, this, l, _);
          },
          statics: {
            getBounds: function(l, _, I, X, ne, ue) {
              var Te = l[0];
              if (!Te)
                return new E();
              var ye = new Array(6), Me = Te._transformCoordinates(X, new Array(6)), Ge = Me.slice(0, 2), Qe = Ge.slice(), re = new Array(2);
              function Se(Be) {
                Be._transformCoordinates(X, ye);
                for (var Ze = 0; Ze < 2; Ze++)
                  Oe._addBounds(
                    Me[Ze],
                    Me[Ze + 4],
                    ye[Ze + 2],
                    ye[Ze],
                    Ze,
                    ue ? ue[Ze] : 0,
                    Ge,
                    Qe,
                    re
                  );
                var fe = Me;
                Me = ye, ye = fe;
              }
              for (var Pe = 1, at = l.length; Pe < at; Pe++)
                Se(l[Pe]);
              return _ && Se(Te), new E(Ge[0], Ge[1], Qe[0] - Ge[0], Qe[1] - Ge[1]);
            },
            getStrokeBounds: function(l, _, I, X, ne) {
              var ue = I.getStyle(), Te = ue.hasStroke(), ye = ue.getStrokeWidth(), Me = Te && I._getStrokeMatrix(X, ne), Ge = Te && Ce._getStrokePadding(
                ye,
                Me
              ), Qe = Ce.getBounds(
                l,
                _,
                I,
                X,
                ne,
                Ge
              );
              if (!Te)
                return Qe;
              var re = ye / 2, Se = ue.getStrokeJoin(), Pe = ue.getStrokeCap(), at = ue.getMiterLimit(), Be = new E(new w(Ge));
              function Ze(nt) {
                Qe = Qe.include(nt);
              }
              function fe(nt) {
                Qe = Qe.unite(
                  Be.setCenter(nt._point.transform(X))
                );
              }
              function Je(nt, ae) {
                ae === "round" || nt.isSmooth() ? fe(nt) : Ce._addBevelJoin(
                  nt,
                  ae,
                  re,
                  at,
                  X,
                  Me,
                  Ze
                );
              }
              function Xe(nt, ae) {
                ae === "round" ? fe(nt) : Ce._addSquareCap(
                  nt,
                  ae,
                  re,
                  X,
                  Me,
                  Ze
                );
              }
              var z = l.length - (_ ? 0 : 1);
              if (z > 0) {
                for (var He = 1; He < z; He++)
                  Je(l[He], Se);
                _ ? Je(l[0], Se) : (Xe(l[0], Pe), Xe(l[l.length - 1], Pe));
              }
              return Qe;
            },
            _getStrokePadding: function(l, _) {
              if (!_)
                return [l, l];
              var I = new x(l, 0).transform(_), X = new x(0, l).transform(_), ne = I.getAngleInRadians(), ue = I.getLength(), Te = X.getLength(), ye = Math.sin(ne), Me = Math.cos(ne), Ge = Math.tan(ne), Qe = Math.atan2(Te * Ge, ue), re = Math.atan2(Te, Ge * ue);
              return [
                Math.abs(ue * Math.cos(Qe) * Me + Te * Math.sin(Qe) * ye),
                Math.abs(Te * Math.sin(re) * Me + ue * Math.cos(re) * ye)
              ];
            },
            _addBevelJoin: function(l, _, I, X, ne, ue, Te, ye) {
              var Me = l.getCurve(), Ge = Me.getPrevious(), Qe = Me.getPoint1().transform(ne), re = Ge.getNormalAtTime(1).multiply(I).transform(ue), Se = Me.getNormalAtTime(0).multiply(I).transform(ue), Pe = re.getDirectedAngle(Se);
              if ((Pe < 0 || Pe >= 180) && (re = re.negate(), Se = Se.negate()), ye && Te(Qe), Te(Qe.add(re)), _ === "miter") {
                var at = new U(
                  Qe.add(re),
                  new x(-re.y, re.x),
                  !0
                ).intersect(new U(
                  Qe.add(Se),
                  new x(-Se.y, Se.x),
                  !0
                ), !0);
                at && Qe.getDistance(at) <= X * I && Te(at);
              }
              Te(Qe.add(Se));
            },
            _addSquareCap: function(l, _, I, X, ne, ue, Te) {
              var ye = l._point.transform(X), Me = l.getLocation(), Ge = Me.getNormal().multiply(Me.getTime() === 0 ? I : -I).transform(ne);
              _ === "square" && (Te && (ue(ye.subtract(Ge)), ue(ye.add(Ge))), ye = ye.add(Ge.rotate(-90))), ue(ye.add(Ge)), ue(ye.subtract(Ge));
            },
            getHandleBounds: function(l, _, I, X, ne) {
              var ue = I.getStyle(), Te = ne.stroke && ue.hasStroke(), ye, Me;
              if (Te) {
                var Ge = I._getStrokeMatrix(X, ne), Qe = ue.getStrokeWidth() / 2, re = Qe;
                ue.getStrokeJoin() === "miter" && (re = Qe * ue.getMiterLimit()), ue.getStrokeCap() === "square" && (re = Math.max(re, Qe * Math.SQRT2)), ye = Ce._getStrokePadding(Qe, Ge), Me = Ce._getStrokePadding(re, Ge);
              }
              for (var Se = new Array(6), Pe = 1 / 0, at = -Pe, Be = Pe, Ze = at, fe = 0, Je = l.length; fe < Je; fe++) {
                var Xe = l[fe];
                Xe._transformCoordinates(X, Se);
                for (var z = 0; z < 6; z += 2) {
                  var He = z ? ye : Me, nt = He ? He[0] : 0, ae = He ? He[1] : 0, $e = Se[z], Et = Se[z + 1], Nt = $e - nt, Yt = $e + nt, Ft = Et - ae, ai = Et + ae;
                  Nt < Pe && (Pe = Nt), Yt > at && (at = Yt), Ft < Be && (Be = Ft), ai > Ze && (Ze = ai);
                }
              }
              return new E(Pe, Be, at - Pe, Ze - Be);
            }
          }
        }
      );
      Ce.inject({ statics: new function() {
        var l = 0.5522847498307936, _ = [
          new ge([-1, 0], [0, l], [0, -l]),
          new ge([0, -1], [-l, 0], [l, 0]),
          new ge([1, 0], [0, -l], [0, l]),
          new ge([0, 1], [l, 0], [-l, 0])
        ];
        function I(ne, ue, Te) {
          var ye = q.getNamed(Te), Me = new Ce(ye && (ye.insert == !0 ? T.INSERT : ye.insert == !1 ? T.NO_INSERT : null));
          return Me._add(ne), Me._closed = ue, Me.set(ye, T.INSERT);
        }
        function X(ne, ue, Te) {
          for (var ye = new Array(4), Me = 0; Me < 4; Me++) {
            var Ge = _[Me];
            ye[Me] = new ge(
              Ge._point.multiply(ue).add(ne),
              Ge._handleIn.multiply(ue),
              Ge._handleOut.multiply(ue)
            );
          }
          return I(ye, !0, Te);
        }
        return {
          Line: function() {
            var ne = arguments;
            return I([
              new ge(x.readNamed(ne, "from")),
              new ge(x.readNamed(ne, "to"))
            ], !1, ne);
          },
          Circle: function() {
            var ne = arguments, ue = x.readNamed(ne, "center"), Te = q.readNamed(ne, "radius");
            return X(ue, new w(Te), ne);
          },
          Rectangle: function() {
            var ne = arguments, ue = E.readNamed(ne, "rectangle"), Te = w.readNamed(
              ne,
              "radius",
              0,
              { readNull: !0 }
            ), ye = ue.getBottomLeft(!0), Me = ue.getTopLeft(!0), Ge = ue.getTopRight(!0), Qe = ue.getBottomRight(!0), re;
            if (!Te || Te.isZero())
              re = [
                new ge(ye),
                new ge(Me),
                new ge(Ge),
                new ge(Qe)
              ];
            else {
              Te = w.min(Te, ue.getSize(!0).divide(2));
              var Se = Te.width, Pe = Te.height, at = Se * l, Be = Pe * l;
              re = [
                new ge(ye.add(Se, 0), null, [-at, 0]),
                new ge(ye.subtract(0, Pe), [0, Be]),
                new ge(Me.add(0, Pe), null, [0, -Be]),
                new ge(Me.add(Se, 0), [-at, 0], null),
                new ge(Ge.subtract(Se, 0), null, [at, 0]),
                new ge(Ge.add(0, Pe), [0, -Be], null),
                new ge(Qe.subtract(0, Pe), null, [0, Be]),
                new ge(Qe.subtract(Se, 0), [at, 0])
              ];
            }
            return I(re, !0, ne);
          },
          RoundRectangle: "#Rectangle",
          Ellipse: function() {
            var ne = arguments, ue = ee._readEllipse(ne);
            return X(ue.center, ue.radius, ne);
          },
          Oval: "#Ellipse",
          Arc: function() {
            var ne = arguments, ue = x.readNamed(ne, "from"), Te = x.readNamed(ne, "through"), ye = x.readNamed(ne, "to"), Me = q.getNamed(ne), Ge = new Ce(Me && Me.insert == !1 && T.NO_INSERT);
            return Ge.moveTo(ue), Ge.arcTo(Te, ye), Ge.set(Me);
          },
          RegularPolygon: function() {
            for (var ne = arguments, ue = x.readNamed(ne, "center"), Te = q.readNamed(ne, "sides"), ye = q.readNamed(ne, "radius"), Me = 360 / Te, Ge = Te % 3 === 0, Qe = new x(0, Ge ? -ye : ye), re = Ge ? -1 : 0.5, Se = new Array(Te), Pe = 0; Pe < Te; Pe++)
              Se[Pe] = new ge(ue.add(
                Qe.rotate((Pe + re) * Me)
              ));
            return I(Se, !0, ne);
          },
          Star: function() {
            for (var ne = arguments, ue = x.readNamed(ne, "center"), Te = q.readNamed(ne, "points") * 2, ye = q.readNamed(ne, "radius1"), Me = q.readNamed(ne, "radius2"), Ge = 360 / Te, Qe = new x(0, -1), re = new Array(Te), Se = 0; Se < Te; Se++)
              re[Se] = new ge(ue.add(Qe.rotate(Ge * Se).multiply(Se % 2 ? Me : ye)));
            return I(re, !0, ne);
          }
        };
      }() });
      var it = we.extend(
        {
          _class: "CompoundPath",
          _serializeFields: {
            children: []
          },
          beans: !0,
          initialize: function(_) {
            this._children = [], this._namedChildren = {}, this._initialize(_) || (typeof _ == "string" ? this.setPathData(_) : this.addChildren(Array.isArray(_) ? _ : arguments));
          },
          insertChildren: function l(_, I) {
            var X = I, ne = X[0];
            ne && typeof ne[0] == "number" && (X = [X]);
            for (var ue = I.length - 1; ue >= 0; ue--) {
              var Te = X[ue];
              X === I && !(Te instanceof Ce) && (X = q.slice(X)), Array.isArray(Te) ? X[ue] = new Ce({ segments: Te, insert: !1 }) : Te instanceof it && (X.splice.apply(X, [ue, 1].concat(Te.removeChildren())), Te.remove());
            }
            return l.base.call(this, _, X);
          },
          reduce: function l(_) {
            for (var I = this._children, X = I.length - 1; X >= 0; X--) {
              var ne = I[X].reduce(_);
              ne.isEmpty() && ne.remove();
            }
            if (!I.length) {
              var ne = new Ce(T.NO_INSERT);
              return ne.copyAttributes(this), ne.insertAbove(this), this.remove(), ne;
            }
            return l.base.call(this);
          },
          isClosed: function() {
            for (var l = this._children, _ = 0, I = l.length; _ < I; _++)
              if (!l[_]._closed)
                return !1;
            return !0;
          },
          setClosed: function(l) {
            for (var _ = this._children, I = 0, X = _.length; I < X; I++)
              _[I].setClosed(l);
          },
          getFirstSegment: function() {
            var l = this.getFirstChild();
            return l && l.getFirstSegment();
          },
          getLastSegment: function() {
            var l = this.getLastChild();
            return l && l.getLastSegment();
          },
          getCurves: function() {
            for (var l = this._children, _ = [], I = 0, X = l.length; I < X; I++)
              q.push(_, l[I].getCurves());
            return _;
          },
          getFirstCurve: function() {
            var l = this.getFirstChild();
            return l && l.getFirstCurve();
          },
          getLastCurve: function() {
            var l = this.getLastChild();
            return l && l.getLastCurve();
          },
          getArea: function() {
            for (var l = this._children, _ = 0, I = 0, X = l.length; I < X; I++)
              _ += l[I].getArea();
            return _;
          },
          getLength: function() {
            for (var l = this._children, _ = 0, I = 0, X = l.length; I < X; I++)
              _ += l[I].getLength();
            return _;
          },
          getPathData: function(l, _) {
            for (var I = this._children, X = [], ne = 0, ue = I.length; ne < ue; ne++) {
              var Te = I[ne], ye = Te._matrix;
              X.push(Te.getPathData(l && !ye.isIdentity() ? l.appended(ye) : l, _));
            }
            return X.join("");
          },
          _hitTestChildren: function l(_, I, X) {
            return l.base.call(
              this,
              _,
              I.class === Ce || I.type === "path" ? I : q.set({}, I, { fill: !1 }),
              X
            );
          },
          _draw: function(l, _, I, X) {
            var ne = this._children;
            if (ne.length) {
              _ = _.extend({ dontStart: !0, dontFinish: !0 }), l.beginPath();
              for (var ue = 0, Te = ne.length; ue < Te; ue++)
                ne[ue].draw(l, _, X);
              if (!_.clip) {
                this._setStyles(l, _, I);
                var ye = this._style;
                ye.hasFill() && (l.fill(ye.getFillRule()), l.shadowColor = "rgba(0,0,0,0)"), ye.hasStroke() && l.stroke();
              }
            }
          },
          _drawSelected: function(l, _, I) {
            for (var X = this._children, ne = 0, ue = X.length; ne < ue; ne++) {
              var Te = X[ne], ye = Te._matrix;
              I[Te._id] || Te._drawSelected(l, ye.isIdentity() ? _ : _.appended(ye));
            }
          }
        },
        new function() {
          function l(_, I) {
            var X = _._children;
            if (I && !X.length)
              throw new Error("Use a moveTo() command first");
            return X[X.length - 1];
          }
          return q.each(
            [
              "lineTo",
              "cubicCurveTo",
              "quadraticCurveTo",
              "curveTo",
              "arcTo",
              "lineBy",
              "cubicCurveBy",
              "quadraticCurveBy",
              "curveBy",
              "arcBy"
            ],
            function(_) {
              this[_] = function() {
                var I = l(this, !0);
                I[_].apply(I, arguments);
              };
            },
            {
              moveTo: function() {
                var _ = l(this), I = _ && _.isEmpty() ? _ : new Ce(T.NO_INSERT);
                I !== _ && this.addChild(I), I.moveTo.apply(I, arguments);
              },
              moveBy: function() {
                var _ = l(this, !0), I = _ && _.getLastSegment(), X = x.read(arguments);
                this.moveTo(I ? X.add(I._point) : X);
              },
              closePath: function(_) {
                l(this, !0).closePath(_);
              }
            }
          );
        }(),
        q.each(["reverse", "flatten", "simplify", "smooth"], function(l) {
          this[l] = function(_) {
            for (var I = this._children, X, ne = 0, ue = I.length; ne < ue; ne++)
              X = I[ne][l](_) || X;
            return X;
          };
        }, {})
      );
      we.inject(new function() {
        var l = Math.min, _ = Math.max, I = Math.abs, X = {
          unite: { 1: !0, 2: !0 },
          intersect: { 2: !0 },
          subtract: { 1: !0 },
          exclude: { 1: !0, "-1": !0 }
        };
        function ne(fe) {
          return fe._children || [fe];
        }
        function ue(fe, Je) {
          var Xe = fe.clone(!1).reduce({ simplify: !0 }).transform(null, !0, !0);
          if (Je) {
            for (var z = ne(Xe), He = 0, nt = z.length; He < nt; He++) {
              var fe = z[He];
              !fe._closed && !fe.isEmpty() && (fe.closePath(1e-12), fe.getFirstSegment().setHandleIn(0, 0), fe.getLastSegment().setHandleOut(0, 0));
            }
            Xe = Xe.resolveCrossings().reorient(Xe.getFillRule() === "nonzero", !0);
          }
          return Xe;
        }
        function Te(fe, Je, Xe, z, He) {
          var nt = new it(T.NO_INSERT);
          return nt.addChildren(fe, !0), nt = nt.reduce({ simplify: Je }), He && He.insert == !1 || nt.insertAbove(z && Xe.isSibling(z) && Xe.getIndex() < z.getIndex() ? z : Xe), nt.copyAttributes(Xe, !0), nt;
        }
        function ye(fe) {
          return fe.hasOverlap() || fe.isCrossing();
        }
        function Me(fe, Je, Xe, z) {
          if (z && (z.trace == !1 || z.stroke) && /^(subtract|intersect)$/.test(Xe))
            return Ge(fe, Je, Xe);
          var He = ue(fe, !0), nt = Je && fe !== Je && ue(Je, !0), ae = X[Xe];
          ae[Xe] = !0, nt && (ae.subtract || ae.exclude) ^ (nt.isClockwise() ^ He.isClockwise()) && nt.reverse();
          var $e = Pe(Ue.expand(
            He.getIntersections(nt, ye)
          )), Et = ne(He), Nt = nt && ne(nt), Yt = [], Ft = [], ai;
          function Mt(_i) {
            for (var Di = 0, Bi = _i.length; Di < Bi; Di++) {
              var Hi = _i[Di];
              q.push(Yt, Hi._segments), q.push(Ft, Hi.getCurves()), Hi._overlapsOnly = !0;
            }
          }
          function Ae(_i) {
            for (var Di = [], Bi = 0, Hi = _i && _i.length; Bi < Hi; Bi++)
              Di.push(Ft[_i[Bi]]);
            return Di;
          }
          if ($e.length) {
            Mt(Et), Nt && Mt(Nt);
            for (var Fe = new Array(Ft.length), tt = 0, Ct = Ft.length; tt < Ct; tt++)
              Fe[tt] = Ft[tt].getValues();
            for (var It = Z.findCurveBoundsCollisions(
              Fe,
              Fe,
              0,
              !0
            ), Ut = {}, tt = 0; tt < Ft.length; tt++) {
              var ti = Ft[tt], Pt = ti._path._id, Wt = Ut[Pt] = Ut[Pt] || {};
              Wt[ti.getIndex()] = {
                hor: Ae(It[tt].hor),
                ver: Ae(It[tt].ver)
              };
            }
            for (var tt = 0, Ct = $e.length; tt < Ct; tt++)
              Be(
                $e[tt]._segment,
                He,
                nt,
                Ut,
                ae
              );
            for (var tt = 0, Ct = Yt.length; tt < Ct; tt++) {
              var ei = Yt[tt], oi = ei._intersection;
              ei._winding || Be(
                ei,
                He,
                nt,
                Ut,
                ae
              ), oi && oi._overlap || (ei._path._overlapsOnly = !1);
            }
            ai = Ze(Yt, ae);
          } else
            ai = Se(
              Nt ? Et.concat(Nt) : Et.slice(),
              function(_i) {
                return !!ae[_i];
              }
            );
          return Te(ai, !0, fe, Je, z);
        }
        function Ge(fe, Je, Xe) {
          var z = ue(fe), He = ue(Je), nt = z.getIntersections(He, ye), ae = Xe === "subtract", $e = Xe === "divide", Et = {}, Nt = [];
          function Yt(Mt) {
            if (!Et[Mt._id] && ($e || He.contains(Mt.getPointAt(Mt.getLength() / 2)) ^ ae))
              return Nt.unshift(Mt), Et[Mt._id] = !0;
          }
          for (var Ft = nt.length - 1; Ft >= 0; Ft--) {
            var ai = nt[Ft].split();
            ai && (Yt(ai) && ai.getFirstSegment().setHandleIn(0, 0), z.getLastSegment().setHandleOut(0, 0));
          }
          return Yt(z), Te(Nt, !1, fe, Je);
        }
        function Qe(fe, Je) {
          for (var Xe = fe; Xe; ) {
            if (Xe === Je)
              return;
            Xe = Xe._previous;
          }
          for (; fe._next && fe._next !== Je; )
            fe = fe._next;
          if (!fe._next) {
            for (; Je._previous; )
              Je = Je._previous;
            fe._next = Je, Je._previous = fe;
          }
        }
        function re(fe) {
          for (var Je = fe.length - 1; Je >= 0; Je--)
            fe[Je].clearHandles();
        }
        function Se(fe, Je, Xe) {
          var z = fe && fe.length;
          if (z) {
            var He = q.each(fe, function(It, Ut) {
              this[It._id] = {
                container: null,
                winding: It.isClockwise() ? 1 : -1,
                index: Ut
              };
            }, {}), nt = fe.slice().sort(function(It, Ut) {
              return I(Ut.getArea()) - I(It.getArea());
            }), ae = nt[0], $e = Z.findItemBoundsCollisions(
              nt,
              null,
              A.GEOMETRIC_EPSILON
            );
            Xe == null && (Xe = ae.isClockwise());
            for (var Et = 0; Et < z; Et++) {
              var Nt = nt[Et], Yt = He[Nt._id], Ft = 0, ai = $e[Et];
              if (ai) {
                for (var Mt = null, Ae = ai.length - 1; Ae >= 0; Ae--)
                  if (ai[Ae] < Et) {
                    Mt = Mt || Nt.getInteriorPoint();
                    var Fe = nt[ai[Ae]];
                    if (Fe.contains(Mt)) {
                      var tt = He[Fe._id];
                      Ft = tt.winding, Yt.winding += Ft, Yt.container = tt.exclude ? tt.container : Fe;
                      break;
                    }
                  }
              }
              if (Je(Yt.winding) === Je(Ft))
                Yt.exclude = !0, fe[Yt.index] = null;
              else {
                var Ct = Yt.container;
                Nt.setClockwise(
                  Ct ? !Ct.isClockwise() : Xe
                );
              }
            }
          }
          return fe;
        }
        function Pe(fe, Je, Xe) {
          var z = Je && [], He = 1e-8, nt = 1 - He, ae = !1, $e = Xe || [], Et = Xe && {}, Nt, Yt, Ft;
          function ai(Di) {
            return Di._path._id + "." + Di._segment1._index;
          }
          for (var Mt = (Xe && Xe.length) - 1; Mt >= 0; Mt--) {
            var Ae = Xe[Mt];
            Ae._path && (Et[ai(Ae)] = !0);
          }
          for (var Mt = fe.length - 1; Mt >= 0; Mt--) {
            var Fe = fe[Mt], tt = Fe._time, Ct = tt, It = Je && !Je(Fe), Ae = Fe._curve, Ut;
            if (Ae && (Ae !== Yt ? (ae = !Ae.hasHandles() || Et && Et[ai(Ae)], Nt = [], Ft = null, Yt = Ae) : Ft >= He && (tt /= Ft)), It) {
              Nt && Nt.push(Fe);
              continue;
            } else Je && z.unshift(Fe);
            if (Ft = Ct, tt < He)
              Ut = Ae._segment1;
            else if (tt > nt)
              Ut = Ae._segment2;
            else {
              var ti = Ae.divideAtTime(tt, !0);
              ae && $e.push(Ae, ti), Ut = ti._segment1;
              for (var Pt = Nt.length - 1; Pt >= 0; Pt--) {
                var Wt = Nt[Pt];
                Wt._time = (Wt._time - tt) / (1 - tt);
              }
            }
            Fe._setSegment(Ut);
            var ei = Ut._intersection, oi = Fe._intersection;
            if (ei) {
              Qe(ei, oi);
              for (var _i = ei; _i; )
                Qe(_i._intersection, ei), _i = _i._next;
            } else
              Ut._intersection = oi;
          }
          return Xe || re($e), z || fe;
        }
        function at(fe, Je, Xe, z, He) {
          var nt = Array.isArray(Je) ? Je : Je[Xe ? "hor" : "ver"], ae = Xe ? 1 : 0, $e = ae ^ 1, Et = [fe.x, fe.y], Nt = Et[ae], Yt = Et[$e], Ft = 1e-9, ai = 1e-6, Mt = Nt - Ft, Ae = Nt + Ft, Fe = 0, tt = 0, Ct = 0, It = 0, Ut = !1, ti = !1, Pt = 1, Wt = [], ei, oi;
          function _i(Ir) {
            var Mr = Ir[$e + 0], wn = Ir[$e + 6];
            if (!(Yt < l(Mr, wn) || Yt > _(Mr, wn))) {
              var xn = Ir[ae + 0], En = Ir[ae + 2], Vn = Ir[ae + 4], Yn = Ir[ae + 6];
              if (Mr === wn) {
                (xn < Ae && Yn > Mt || Yn < Ae && xn > Mt) && (Ut = !0);
                return;
              }
              var ka = Yt === Mr ? 0 : Yt === wn || Mt > _(xn, En, Vn, Yn) || Ae < l(xn, En, Vn, Yn) ? 1 : Oe.solveCubic(Ir, $e, Yt, Wt, 0, 1) > 0 ? Wt[0] : 1, ea = ka === 0 ? xn : ka === 1 ? Yn : Oe.getPoint(Ir, ka)[Xe ? "y" : "x"], ga = Mr > wn ? 1 : -1, Ta = ei[$e] > ei[$e + 6] ? 1 : -1, ha = ei[ae + 6];
              return Yt !== Mr ? (ea < Mt ? Ct += ga : ea > Ae ? It += ga : Ut = !0, ea > Nt - ai && ea < Nt + ai && (Pt /= 2)) : (ga !== Ta ? xn < Mt ? Ct += ga : xn > Ae && (It += ga) : xn != ha && (ha < Ae && ea > Ae ? (It += ga, Ut = !0) : ha > Mt && ea < Mt && (Ct += ga, Ut = !0)), Pt /= 4), ei = Ir, !He && ea > Mt && ea < Ae && Oe.getTangent(Ir, ka)[Xe ? "x" : "y"] === 0 && at(fe, Je, !Xe, z, !0);
            }
          }
          function Di(Ir) {
            var Mr = Ir[$e + 0], wn = Ir[$e + 2], xn = Ir[$e + 4], En = Ir[$e + 6];
            if (Yt <= _(Mr, wn, xn, En) && Yt >= l(Mr, wn, xn, En)) {
              for (var Vn = Ir[ae + 0], Yn = Ir[ae + 2], ka = Ir[ae + 4], ea = Ir[ae + 6], ga = Mt > _(Vn, Yn, ka, ea) || Ae < l(Vn, Yn, ka, ea) ? [Ir] : Oe.getMonoCurves(Ir, Xe), Ta, ha = 0, Bo = ga.length; ha < Bo; ha++)
                if (Ta = _i(ga[ha]))
                  return Ta;
            }
          }
          for (var Bi = 0, Hi = nt.length; Bi < Hi; Bi++) {
            var nr = nt[Bi], rr = nr._path, dr = nr.getValues(), Rr;
            if ((!Bi || nt[Bi - 1]._path !== rr) && (ei = null, rr._closed || (oi = Oe.getValues(
              rr.getLastCurve().getSegment2(),
              nr.getSegment1(),
              null,
              !z
            ), oi[$e] !== oi[$e + 6] && (ei = oi)), !ei)) {
              ei = dr;
              for (var Br = rr.getLastCurve(); Br && Br !== nr; ) {
                var Ki = Br.getValues();
                if (Ki[$e] !== Ki[$e + 6]) {
                  ei = Ki;
                  break;
                }
                Br = Br.getPrevious();
              }
            }
            if (Rr = Di(dr))
              return Rr;
            if (Bi + 1 === Hi || nt[Bi + 1]._path !== rr) {
              if (oi && (Rr = Di(oi)))
                return Rr;
              Ut && !Ct && !It && (Ct = It = rr.isClockwise(z) ^ Xe ? 1 : -1), Fe += Ct, tt += It, Ct = It = 0, Ut && (ti = !0, Ut = !1), oi = null;
            }
          }
          return Fe = I(Fe), tt = I(tt), {
            winding: _(Fe, tt),
            windingL: Fe,
            windingR: tt,
            quality: Pt,
            onPath: ti
          };
        }
        function Be(fe, Je, Xe, z, He) {
          var nt = [], ae = fe, $e = 0, Ft;
          do {
            var Et = fe.getCurve();
            if (Et) {
              var Nt = Et.getLength();
              nt.push({ segment: fe, curve: Et, length: Nt }), $e += Nt;
            }
            fe = fe.getNext();
          } while (fe && !fe._intersection && fe !== ae);
          for (var Yt = [0.5, 0.25, 0.75], Ft = { winding: 0, quality: -1 }, ai = 1e-3, Mt = 1 - ai, Ae = 0; Ae < Yt.length && Ft.quality < 0.5; Ae++)
            for (var Nt = $e * Yt[Ae], Fe = 0, tt = nt.length; Fe < tt; Fe++) {
              var Ct = nt[Fe], It = Ct.length;
              if (Nt <= It) {
                var Et = Ct.curve, Ut = Et._path, ti = Ut._parent, Pt = ti instanceof it ? ti : Ut, Wt = A.clamp(Et.getTimeAt(Nt), ai, Mt), ei = Et.getPointAtTime(Wt), oi = I(Et.getTangentAtTime(Wt).y) < Math.SQRT1_2, _i = null;
                if (He.subtract && Xe) {
                  var Di = Pt === Je ? Xe : Je, Bi = Di._getWinding(ei, oi, !0);
                  if (Pt === Je && Bi.winding || Pt === Xe && !Bi.winding) {
                    if (Bi.quality < 1)
                      continue;
                    _i = { winding: 0, quality: 1 };
                  }
                }
                _i = _i || at(
                  ei,
                  z[Ut._id][Et.getIndex()],
                  oi,
                  !0
                ), _i.quality > Ft.quality && (Ft = _i);
                break;
              }
              Nt -= It;
            }
          for (var Fe = nt.length - 1; Fe >= 0; Fe--)
            nt[Fe].segment._winding = Ft;
        }
        function Ze(fe, Je) {
          var Xe = [], z;
          function He(Hi) {
            var nr;
            return !!(Hi && !Hi._visited && (!Je || Je[(nr = Hi._winding || {}).winding] && !(Je.unite && nr.winding === 2 && nr.windingL && nr.windingR)));
          }
          function nt(Hi) {
            if (Hi) {
              for (var nr = 0, rr = z.length; nr < rr; nr++)
                if (Hi === z[nr])
                  return !0;
            }
            return !1;
          }
          function ae(Hi) {
            for (var nr = Hi._segments, rr = 0, dr = nr.length; rr < dr; rr++)
              nr[rr]._visited = !0;
          }
          function $e(Hi, nr) {
            var rr = Hi._intersection, dr = rr, Rr = [];
            nr && (z = [Hi]);
            function Br(Ki, Ir) {
              for (; Ki && Ki !== Ir; ) {
                var Mr = Ki._segment, wn = Mr && Mr._path;
                if (wn) {
                  var xn = Mr.getNext() || wn.getFirstSegment(), En = xn._intersection;
                  Mr !== Hi && (nt(Mr) || nt(xn) || xn && He(Mr) && (He(xn) || En && He(En._segment))) && Rr.push(Mr), nr && z.push(Mr);
                }
                Ki = Ki._next;
              }
            }
            if (rr) {
              for (Br(rr); rr && rr._previous; )
                rr = rr._previous;
              Br(rr, dr);
            }
            return Rr;
          }
          fe.sort(function(Hi, nr) {
            var rr = Hi._intersection, dr = nr._intersection, Rr = !!(rr && rr._overlap), Br = !!(dr && dr._overlap), Ki = Hi._path, Ir = nr._path;
            return Rr ^ Br ? Rr ? 1 : -1 : !rr ^ !dr ? rr ? 1 : -1 : Ki !== Ir ? Ki._id - Ir._id : Hi._index - nr._index;
          });
          for (var Et = 0, Nt = fe.length; Et < Nt; Et++) {
            var Yt = fe[Et], Ft = He(Yt), ai = null, Mt = !1, Ae = !0, Fe = [], tt, Ct, It;
            if (Ft && Yt._path._overlapsOnly) {
              var Ut = Yt._path, ti = Yt._intersection._segment._path;
              Ut.compare(ti) && (Ut.getArea() && Xe.push(Ut.clone(!1)), ae(Ut), ae(ti), Ft = !1);
            }
            for (; Ft; ) {
              var Pt = !ai, Wt = $e(Yt, Pt), ei = Wt.shift(), Mt = !Pt && (nt(Yt) || nt(ei)), oi = !Mt && ei;
              if (Pt && (ai = new Ce(T.NO_INSERT), tt = null), Mt) {
                (Yt.isFirst() || Yt.isLast()) && (Ae = Yt._path._closed), Yt._visited = !0;
                break;
              }
              if (oi && tt && (Fe.push(tt), tt = null), tt || (oi && Wt.push(Yt), tt = {
                start: ai._segments.length,
                crossings: Wt,
                visited: Ct = [],
                handleIn: It
              }), oi && (Yt = ei), !He(Yt)) {
                ai.removeSegments(tt.start);
                for (var _i = 0, Di = Ct.length; _i < Di; _i++)
                  Ct[_i]._visited = !1;
                Ct.length = 0;
                do
                  Yt = tt && tt.crossings.shift(), (!Yt || !Yt._path) && (Yt = null, tt = Fe.pop(), tt && (Ct = tt.visited, It = tt.handleIn));
                while (tt && !He(Yt));
                if (!Yt)
                  break;
              }
              var Bi = Yt.getNext();
              ai.add(new ge(
                Yt._point,
                It,
                Bi && Yt._handleOut
              )), Yt._visited = !0, Ct.push(Yt), Yt = Bi || Yt._path.getFirstSegment(), It = Bi && Bi._handleIn;
            }
            Mt && (Ae && (ai.getFirstSegment().setHandleIn(It), ai.setClosed(Ae)), ai.getArea() !== 0 && Xe.push(ai));
          }
          return Xe;
        }
        return {
          _getWinding: function(fe, Je, Xe) {
            return at(fe, this.getCurves(), Je, Xe);
          },
          unite: function(fe, Je) {
            return Me(this, fe, "unite", Je);
          },
          intersect: function(fe, Je) {
            return Me(this, fe, "intersect", Je);
          },
          subtract: function(fe, Je) {
            return Me(this, fe, "subtract", Je);
          },
          exclude: function(fe, Je) {
            return Me(this, fe, "exclude", Je);
          },
          divide: function(fe, Je) {
            return Je && (Je.trace == !1 || Je.stroke) ? Ge(this, fe, "divide") : Te([
              this.subtract(fe, Je),
              this.intersect(fe, Je)
            ], !0, this, fe, Je);
          },
          resolveCrossings: function() {
            var fe = this._children, Je = fe || [this];
            function Xe(tt, Ct) {
              var It = tt && tt._intersection;
              return It && It._overlap && It._path === Ct;
            }
            var z = !1, He = !1, nt = this.getIntersections(null, function(tt) {
              return tt.hasOverlap() && (z = !0) || tt.isCrossing() && (He = !0);
            }), ae = z && He && [];
            if (nt = Ue.expand(nt), z)
              for (var $e = Pe(nt, function(tt) {
                return tt.hasOverlap();
              }, ae), Et = $e.length - 1; Et >= 0; Et--) {
                var Nt = $e[Et], Yt = Nt._path, Ft = Nt._segment, ai = Ft.getPrevious(), Mt = Ft.getNext();
                Xe(ai, Yt) && Xe(Mt, Yt) && (Ft.remove(), ai._handleOut._set(0, 0), Mt._handleIn._set(0, 0), ai !== Ft && !ai.getCurve().hasLength() && (Mt._handleIn.set(ai._handleIn), ai.remove()));
              }
            He && (Pe(nt, z && function(tt) {
              var Ct = tt.getCurve(), It = tt.getSegment(), Ut = tt._intersection, ti = Ut._curve, Pt = Ut._segment;
              if (Ct && ti && Ct._path && ti._path)
                return !0;
              It && (It._intersection = null), Pt && (Pt._intersection = null);
            }, ae), ae && re(ae), Je = Ze(q.each(Je, function(tt) {
              q.push(this, tt._segments);
            }, [])));
            var Ae = Je.length, Fe;
            return Ae > 1 && fe ? (Je !== fe && this.setChildren(Je), Fe = this) : Ae === 1 && !fe && (Je[0] !== this && this.setSegments(Je[0].removeSegments()), Fe = this), Fe || (Fe = new it(T.NO_INSERT), Fe.addChildren(Je), Fe = Fe.reduce(), Fe.copyAttributes(this), this.replaceWith(Fe)), Fe;
          },
          reorient: function(fe, Je) {
            var Xe = this._children;
            return Xe && Xe.length ? this.setChildren(Se(
              this.removeChildren(),
              function(z) {
                return !!(fe ? z : z & 1);
              },
              Je
            )) : Je !== qe && this.setClockwise(Je), this;
          },
          getInteriorPoint: function() {
            var fe = this.getBounds(), Je = fe.getCenter(!0);
            if (!this.contains(Je)) {
              for (var Xe = this.getCurves(), z = Je.y, He = [], nt = [], ae = 0, $e = Xe.length; ae < $e; ae++) {
                var Et = Xe[ae].getValues(), Nt = Et[1], Yt = Et[3], Ft = Et[5], ai = Et[7];
                if (z >= l(Nt, Yt, Ft, ai) && z <= _(Nt, Yt, Ft, ai))
                  for (var Mt = Oe.getMonoCurves(Et), Ae = 0, Fe = Mt.length; Ae < Fe; Ae++) {
                    var tt = Mt[Ae], Ct = tt[1], It = tt[7];
                    if (Ct !== It && (z >= Ct && z <= It || z >= It && z <= Ct)) {
                      var Ut = z === Ct ? tt[0] : z === It ? tt[6] : Oe.solveCubic(tt, 1, z, nt, 0, 1) === 1 ? Oe.getPoint(tt, nt[0]).x : (tt[0] + tt[6]) / 2;
                      He.push(Ut);
                    }
                  }
              }
              He.length > 1 && (He.sort(function(ti, Pt) {
                return ti - Pt;
              }), Je.x = (He[0] + He[1]) / 2);
            }
            return Je;
          }
        };
      }());
      var ut = q.extend(
        {
          _class: "PathFlattener",
          initialize: function(l, _, I, X, ne) {
            var ue = [], Te = [], ye = 0, Me = 1 / (I || 32), Ge = l._segments, Qe = Ge[0], re;
            function Se(Ze, fe) {
              var Je = Oe.getValues(Ze, fe, ne);
              ue.push(Je), Pe(Je, Ze._index, 0, 1);
            }
            function Pe(Ze, fe, Je, Xe) {
              if (Xe - Je > Me && !(X && Oe.isStraight(Ze)) && !Oe.isFlatEnough(Ze, _ || 0.25)) {
                var z = Oe.subdivide(Ze, 0.5), He = (Je + Xe) / 2;
                Pe(z[0], fe, Je, He), Pe(z[1], fe, He, Xe);
              } else {
                var nt = Ze[6] - Ze[0], ae = Ze[7] - Ze[1], $e = Math.sqrt(nt * nt + ae * ae);
                $e > 0 && (ye += $e, Te.push({
                  offset: ye,
                  curve: Ze,
                  index: fe,
                  time: Xe
                }));
              }
            }
            for (var at = 1, Be = Ge.length; at < Be; at++)
              re = Ge[at], Se(Qe, re), Qe = re;
            l._closed && Se(re || Qe, Ge[0]), this.curves = ue, this.parts = Te, this.length = ye, this.index = 0;
          },
          _get: function(l) {
            for (var _ = this.parts, I = _.length, X, ne = this.index; X = ne, !(!ne || _[--ne].offset < l); )
              ;
            for (; X < I; X++) {
              var ue = _[X];
              if (ue.offset >= l) {
                this.index = X;
                var Te = _[X - 1], ye = Te && Te.index === ue.index ? Te.time : 0, Me = Te ? Te.offset : 0;
                return {
                  index: ue.index,
                  time: ye + (ue.time - ye) * (l - Me) / (ue.offset - Me)
                };
              }
            }
            return {
              index: _[I - 1].index,
              time: 1
            };
          },
          drawPart: function(l, _, I) {
            for (var X = this._get(_), ne = this._get(I), ue = X.index, Te = ne.index; ue <= Te; ue++) {
              var ye = Oe.getPart(
                this.curves[ue],
                ue === X.index ? X.time : 0,
                ue === ne.index ? ne.time : 1
              );
              ue === X.index && l.moveTo(ye[0], ye[1]), l.bezierCurveTo.apply(l, ye.slice(2));
            }
          }
        },
        q.each(
          Oe._evaluateMethods,
          function(l) {
            this[l + "At"] = function(_) {
              var I = this._get(_);
              return Oe[l](this.curves[I.index], I.time);
            };
          },
          {}
        )
      ), bt = q.extend({
        initialize: function(l) {
          for (var _ = this.points = [], I = l._segments, X = l._closed, ne = 0, ue, Te = I.length; ne < Te; ne++) {
            var ye = I[ne].point;
            (!ue || !ue.equals(ye)) && _.push(ue = ye.clone());
          }
          X && (_.unshift(_[_.length - 1]), _.push(_[1])), this.closed = X;
        },
        fit: function(l) {
          var _ = this.points, I = _.length, X = null;
          return I > 0 && (X = [new ge(_[0])], I > 1 && (this.fitCubic(
            X,
            l,
            0,
            I - 1,
            _[1].subtract(_[0]),
            _[I - 2].subtract(_[I - 1])
          ), this.closed && (X.shift(), X.pop()))), X;
        },
        fitCubic: function(l, _, I, X, ne, ue) {
          var Te = this.points;
          if (X - I === 1) {
            var ye = Te[I], Me = Te[X], Ge = ye.getDistance(Me) / 3;
            this.addCurve(l, [
              ye,
              ye.add(ne.normalize(Ge)),
              Me.add(ue.normalize(Ge)),
              Me
            ]);
            return;
          }
          for (var Qe = this.chordLengthParameterize(I, X), re = Math.max(_, _ * _), Se, Pe = !0, at = 0; at <= 4; at++) {
            var Be = this.generateBezier(I, X, Qe, ne, ue), Ze = this.findMaxError(I, X, Be, Qe);
            if (Ze.error < _ && Pe) {
              this.addCurve(l, Be);
              return;
            }
            if (Se = Ze.index, Ze.error >= re)
              break;
            Pe = this.reparameterize(I, X, Qe, Be), re = Ze.error;
          }
          var fe = Te[Se - 1].subtract(Te[Se + 1]);
          this.fitCubic(l, _, I, Se, ne, fe), this.fitCubic(l, _, Se, X, fe.negate(), ue);
        },
        addCurve: function(l, _) {
          var I = l[l.length - 1];
          I.setHandleOut(_[1].subtract(_[0])), l.push(new ge(_[3], _[2].subtract(_[3])));
        },
        generateBezier: function(l, _, I, X, ne) {
          for (var ue = 1e-12, Te = Math.abs, ye = this.points, Me = ye[l], Ge = ye[_], Qe = [[0, 0], [0, 0]], re = [0, 0], Se = 0, Pe = _ - l + 1; Se < Pe; Se++) {
            var at = I[Se], Be = 1 - at, Ze = 3 * at * Be, fe = Be * Be * Be, Je = Ze * Be, Xe = Ze * at, z = at * at * at, He = X.normalize(Je), nt = ne.normalize(Xe), ae = ye[l + Se].subtract(Me.multiply(fe + Je)).subtract(Ge.multiply(Xe + z));
            Qe[0][0] += He.dot(He), Qe[0][1] += He.dot(nt), Qe[1][0] = Qe[0][1], Qe[1][1] += nt.dot(nt), re[0] += He.dot(ae), re[1] += nt.dot(ae);
          }
          var $e = Qe[0][0] * Qe[1][1] - Qe[1][0] * Qe[0][1], Et, Nt;
          if (Te($e) > ue) {
            var Yt = Qe[0][0] * re[1] - Qe[1][0] * re[0], Ft = re[0] * Qe[1][1] - re[1] * Qe[0][1];
            Et = Ft / $e, Nt = Yt / $e;
          } else {
            var ai = Qe[0][0] + Qe[0][1], Mt = Qe[1][0] + Qe[1][1];
            Et = Nt = Te(ai) > ue ? re[0] / ai : Te(Mt) > ue ? re[1] / Mt : 0;
          }
          var Ae = Ge.getDistance(Me), Fe = ue * Ae, tt, Ct;
          if (Et < Fe || Nt < Fe)
            Et = Nt = Ae / 3;
          else {
            var It = Ge.subtract(Me);
            tt = X.normalize(Et), Ct = ne.normalize(Nt), tt.dot(It) - Ct.dot(It) > Ae * Ae && (Et = Nt = Ae / 3, tt = Ct = null);
          }
          return [
            Me,
            Me.add(tt || X.normalize(Et)),
            Ge.add(Ct || ne.normalize(Nt)),
            Ge
          ];
        },
        reparameterize: function(l, _, I, X) {
          for (var ne = l; ne <= _; ne++)
            I[ne - l] = this.findRoot(X, this.points[ne], I[ne - l]);
          for (var ne = 1, ue = I.length; ne < ue; ne++)
            if (I[ne] <= I[ne - 1])
              return !1;
          return !0;
        },
        findRoot: function(l, _, I) {
          for (var X = [], ne = [], ue = 0; ue <= 2; ue++)
            X[ue] = l[ue + 1].subtract(l[ue]).multiply(3);
          for (var ue = 0; ue <= 1; ue++)
            ne[ue] = X[ue + 1].subtract(X[ue]).multiply(2);
          var Te = this.evaluate(3, l, I), ye = this.evaluate(2, X, I), Me = this.evaluate(1, ne, I), Ge = Te.subtract(_), Qe = ye.dot(ye) + Ge.dot(Me);
          return A.isMachineZero(Qe) ? I : I - Ge.dot(ye) / Qe;
        },
        evaluate: function(l, _, I) {
          for (var X = _.slice(), ne = 1; ne <= l; ne++)
            for (var ue = 0; ue <= l - ne; ue++)
              X[ue] = X[ue].multiply(1 - I).add(X[ue + 1].multiply(I));
          return X[0];
        },
        chordLengthParameterize: function(l, _) {
          for (var I = [0], X = l + 1; X <= _; X++)
            I[X - l] = I[X - l - 1] + this.points[X].getDistance(this.points[X - 1]);
          for (var X = 1, ne = _ - l; X <= ne; X++)
            I[X] /= I[ne];
          return I;
        },
        findMaxError: function(l, _, I, X) {
          for (var ne = Math.floor((_ - l + 1) / 2), ue = 0, Te = l + 1; Te < _; Te++) {
            var ye = this.evaluate(3, I, X[Te - l]), Me = ye.subtract(this.points[Te]), Ge = Me.x * Me.x + Me.y * Me.y;
            Ge >= ue && (ue = Ge, ne = Te);
          }
          return {
            error: ue,
            index: ne
          };
        }
      }), pt = T.extend({
        _class: "TextItem",
        _applyMatrix: !1,
        _canApplyMatrix: !1,
        _serializeFields: {
          content: null
        },
        _boundsOptions: { stroke: !1, handle: !1 },
        initialize: function(_) {
          this._content = "", this._lines = [];
          var I = _ && q.isPlainObject(_) && _.x === qe && _.y === qe;
          this._initialize(I && _, !I && x.read(arguments));
        },
        _equals: function(l) {
          return this._content === l._content;
        },
        copyContent: function(l) {
          this.setContent(l._content);
        },
        getContent: function() {
          return this._content;
        },
        setContent: function(l) {
          this._content = "" + l, this._lines = this._content.split(/\r\n|\n|\r/mg), this._changed(521);
        },
        isEmpty: function() {
          return !this._content;
        },
        getCharacterStyle: "#getStyle",
        setCharacterStyle: "#setStyle",
        getParagraphStyle: "#getStyle",
        setParagraphStyle: "#setStyle"
      }), Ke = pt.extend({
        _class: "PointText",
        initialize: function() {
          pt.apply(this, arguments);
        },
        getPoint: function() {
          var l = this._matrix.getTranslation();
          return new m(l.x, l.y, this, "setPoint");
        },
        setPoint: function() {
          var l = x.read(arguments);
          this.translate(l.subtract(this._matrix.getTranslation()));
        },
        _draw: function(l, _, I) {
          if (this._content) {
            this._setStyles(l, _, I);
            var X = this._lines, ne = this._style, ue = ne.hasFill(), Te = ne.hasStroke(), ye = ne.getLeading(), Me = l.shadowColor;
            l.font = ne.getFontStyle(), l.textAlign = ne.getJustification();
            for (var Ge = 0, Qe = X.length; Ge < Qe; Ge++) {
              l.shadowColor = Me;
              var re = X[Ge];
              ue && (l.fillText(re, 0, 0), l.shadowColor = "rgba(0,0,0,0)"), Te && l.strokeText(re, 0, 0), l.translate(0, ye);
            }
          }
        },
        _getBounds: function(l, _) {
          var I = this._style, X = this._lines, ne = X.length, ue = I.getJustification(), Te = I.getLeading(), ye = this.getView().getTextWidth(I.getFontStyle(), X), Me = 0;
          ue !== "left" && (Me -= ye / (ue === "center" ? 2 : 1));
          var Ge = new E(
            Me,
            ne ? -0.75 * Te : 0,
            ye,
            ne * Te
          );
          return l ? l._transformBounds(Ge, Ge) : Ge;
        }
      }), dt = q.extend(
        new function() {
          var l = {
            gray: ["gray"],
            rgb: ["red", "green", "blue"],
            hsb: ["hue", "saturation", "brightness"],
            hsl: ["hue", "saturation", "lightness"],
            gradient: ["gradient", "origin", "destination", "highlight"]
          }, _ = {}, I = {
            transparent: [0, 0, 0, 0]
          }, X;
          function ne(ye) {
            var Me = ye.match(
              /^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i
            ) || ye.match(
              /^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i
            ), Ge = "rgb", Qe;
            if (Me) {
              var re = Me[4] ? 4 : 3;
              Qe = new Array(re);
              for (var Se = 0; Se < re; Se++) {
                var Pe = Me[Se + 1];
                Qe[Se] = parseInt(Pe.length == 1 ? Pe + Pe : Pe, 16) / 255;
              }
            } else if (Me = ye.match(/^(rgb|hsl)a?\((.*)\)$/)) {
              Ge = Me[1], Qe = Me[2].trim().split(/[,\s]+/g);
              for (var at = Ge === "hsl", Se = 0, Be = Math.min(Qe.length, 4); Se < Be; Se++) {
                var Ze = Qe[Se], Pe = parseFloat(Ze);
                if (at)
                  if (Se === 0) {
                    var fe = Ze.match(/([a-z]*)$/)[1];
                    Pe *= {
                      turn: 360,
                      rad: 180 / Math.PI,
                      grad: 0.9
                    }[fe] || 1;
                  } else Se < 3 && (Pe /= 100);
                else Se < 3 && (Pe /= /%$/.test(Ze) ? 100 : 255);
                Qe[Se] = Pe;
              }
            } else {
              var Je = I[ye];
              if (!Je)
                if (Q) {
                  X || (X = _t.getContext(1, 1, {
                    willReadFrequently: !0
                  }), X.globalCompositeOperation = "copy"), X.fillStyle = "rgba(0,0,0,0)", X.fillStyle = ye, X.fillRect(0, 0, 1, 1);
                  var Xe = X.getImageData(0, 0, 1, 1).data;
                  Je = I[ye] = [
                    Xe[0] / 255,
                    Xe[1] / 255,
                    Xe[2] / 255
                  ];
                } else
                  Je = [0, 0, 0];
              Qe = Je.slice();
            }
            return [Ge, Qe];
          }
          var ue = [
            [0, 3, 1],
            [2, 0, 1],
            [1, 0, 3],
            [1, 2, 0],
            [3, 1, 0],
            [0, 1, 2]
          ], Te = {
            "rgb-hsb": function(ye, Me, Ge) {
              var Qe = Math.max(ye, Me, Ge), re = Math.min(ye, Me, Ge), Se = Qe - re, Pe = Se === 0 ? 0 : (Qe == ye ? (Me - Ge) / Se + (Me < Ge ? 6 : 0) : Qe == Me ? (Ge - ye) / Se + 2 : (ye - Me) / Se + 4) * 60;
              return [Pe, Qe === 0 ? 0 : Se / Qe, Qe];
            },
            "hsb-rgb": function(ye, Me, Ge) {
              ye = (ye / 60 % 6 + 6) % 6;
              var re = Math.floor(ye), Qe = ye - re, re = ue[re], Se = [
                Ge,
                Ge * (1 - Me),
                Ge * (1 - Me * Qe),
                Ge * (1 - Me * (1 - Qe))
              ];
              return [Se[re[0]], Se[re[1]], Se[re[2]]];
            },
            "rgb-hsl": function(ye, Me, Ge) {
              var Qe = Math.max(ye, Me, Ge), re = Math.min(ye, Me, Ge), Se = Qe - re, Pe = Se === 0, at = Pe ? 0 : (Qe == ye ? (Me - Ge) / Se + (Me < Ge ? 6 : 0) : Qe == Me ? (Ge - ye) / Se + 2 : (ye - Me) / Se + 4) * 60, Be = (Qe + re) / 2, Ze = Pe ? 0 : Be < 0.5 ? Se / (Qe + re) : Se / (2 - Qe - re);
              return [at, Ze, Be];
            },
            "hsl-rgb": function(ye, Me, Ge) {
              if (ye = (ye / 360 % 1 + 1) % 1, Me === 0)
                return [Ge, Ge, Ge];
              for (var Qe = [ye + 1 / 3, ye, ye - 1 / 3], re = Ge < 0.5 ? Ge * (1 + Me) : Ge + Me - Ge * Me, Se = 2 * Ge - re, Pe = [], at = 0; at < 3; at++) {
                var Be = Qe[at];
                Be < 0 && (Be += 1), Be > 1 && (Be -= 1), Pe[at] = 6 * Be < 1 ? Se + (re - Se) * 6 * Be : 2 * Be < 1 ? re : 3 * Be < 2 ? Se + (re - Se) * (2 / 3 - Be) * 6 : Se;
              }
              return Pe;
            },
            "rgb-gray": function(ye, Me, Ge) {
              return [ye * 0.2989 + Me * 0.587 + Ge * 0.114];
            },
            "gray-rgb": function(ye) {
              return [ye, ye, ye];
            },
            "gray-hsb": function(ye) {
              return [0, 0, ye];
            },
            "gray-hsl": function(ye) {
              return [0, 0, ye];
            },
            "gradient-rgb": function() {
              return [];
            },
            "rgb-gradient": function() {
              return [];
            }
          };
          return q.each(l, function(ye, Me) {
            _[Me] = [], q.each(ye, function(Ge, Qe) {
              var re = q.capitalize(Ge), Se = /^(hue|saturation)$/.test(Ge), Pe = _[Me][Qe] = Me === "gradient" ? Ge === "gradient" ? function(at) {
                var Be = this._components[0];
                return at = ct.read(
                  Array.isArray(at) ? at : arguments,
                  0,
                  { readNull: !0 }
                ), Be !== at && (Be && Be._removeOwner(this), at && at._addOwner(this)), at;
              } : function() {
                return x.read(arguments, 0, {
                  readNull: Ge === "highlight",
                  clone: !0
                });
              } : function(at) {
                return at == null || isNaN(at) ? 0 : +at;
              };
              this["get" + re] = function() {
                return this._type === Me || Se && /^hs[bl]$/.test(this._type) ? this._components[Qe] : this._convert(Me)[Qe];
              }, this["set" + re] = function(at) {
                this._type !== Me && !(Se && /^hs[bl]$/.test(this._type)) && (this._components = this._convert(Me), this._properties = l[Me], this._type = Me), this._components[Qe] = Pe.call(this, at), this._changed();
              };
            }, this);
          }, {
            _class: "Color",
            _readIndex: !0,
            initialize: function ye(Me) {
              var Ge = arguments, Qe = this.__read, re = 0, Se, Pe, at, Be;
              Array.isArray(Me) && (Ge = Me, Me = Ge[0]);
              var Ze = Me != null && typeof Me;
              if (Ze === "string" && Me in l && (Se = Me, Me = Ge[1], Array.isArray(Me) ? (Pe = Me, at = Ge[2]) : (Qe && (re = 1), Ge = q.slice(Ge, 1), Ze = typeof Me)), !Pe) {
                if (Be = Ze === "number" ? Ge : Ze === "object" && Me.length != null ? Me : null, Be) {
                  Se || (Se = Be.length >= 3 ? "rgb" : "gray");
                  var fe = l[Se].length;
                  at = Be[fe], Qe && (re += Be === arguments ? fe + (at != null ? 1 : 0) : 1), Be.length > fe && (Be = q.slice(Be, 0, fe));
                } else if (Ze === "string") {
                  var Je = ne(Me);
                  Se = Je[0], Pe = Je[1], Pe.length === 4 && (at = Pe[3], Pe.length--);
                } else if (Ze === "object")
                  if (Me.constructor === ye) {
                    if (Se = Me._type, Pe = Me._components.slice(), at = Me._alpha, Se === "gradient")
                      for (var Xe = 1, z = Pe.length; Xe < z; Xe++) {
                        var He = Pe[Xe];
                        He && (Pe[Xe] = He.clone());
                      }
                  } else if (Me.constructor === ct)
                    Se = "gradient", Be = Ge;
                  else {
                    Se = "hue" in Me ? "lightness" in Me ? "hsl" : "hsb" : "gradient" in Me || "stops" in Me || "radial" in Me ? "gradient" : "gray" in Me ? "gray" : "rgb";
                    var nt = l[Se], ae = _[Se];
                    this._components = Pe = [];
                    for (var Xe = 0, z = nt.length; Xe < z; Xe++) {
                      var $e = Me[nt[Xe]];
                      $e == null && !Xe && Se === "gradient" && "stops" in Me && ($e = {
                        stops: Me.stops,
                        radial: Me.radial
                      }), $e = ae[Xe].call(this, $e), $e != null && (Pe[Xe] = $e);
                    }
                    at = Me.alpha;
                  }
                Qe && Se && (re = 1);
              }
              if (this._type = Se || "rgb", !Pe) {
                this._components = Pe = [];
                for (var ae = _[this._type], Xe = 0, z = ae.length; Xe < z; Xe++) {
                  var $e = ae[Xe].call(this, Be && Be[Xe]);
                  $e != null && (Pe[Xe] = $e);
                }
              }
              return this._components = Pe, this._properties = l[this._type], this._alpha = at, Qe && (this.__read = re), this;
            },
            set: "#initialize",
            _serialize: function(ye, Me) {
              var Ge = this.getComponents();
              return q.serialize(
                /^(gray|rgb)$/.test(this._type) ? Ge : [this._type].concat(Ge),
                ye,
                !0,
                Me
              );
            },
            _changed: function() {
              this._canvasStyle = null, this._owner && (this._setter ? this._owner[this._setter](this) : this._owner._changed(129));
            },
            _convert: function(ye) {
              var Me;
              return this._type === ye ? this._components.slice() : (Me = Te[this._type + "-" + ye]) ? Me.apply(this, this._components) : Te["rgb-" + ye].apply(
                this,
                Te[this._type + "-rgb"].apply(
                  this,
                  this._components
                )
              );
            },
            convert: function(ye) {
              return new dt(ye, this._convert(ye), this._alpha);
            },
            getType: function() {
              return this._type;
            },
            setType: function(ye) {
              this._components = this._convert(ye), this._properties = l[ye], this._type = ye;
            },
            getComponents: function() {
              var ye = this._components.slice();
              return this._alpha != null && ye.push(this._alpha), ye;
            },
            getAlpha: function() {
              return this._alpha != null ? this._alpha : 1;
            },
            setAlpha: function(ye) {
              this._alpha = ye == null ? null : Math.min(Math.max(ye, 0), 1), this._changed();
            },
            hasAlpha: function() {
              return this._alpha != null;
            },
            equals: function(ye) {
              var Me = q.isPlainValue(ye, !0) ? dt.read(arguments) : ye;
              return Me === this || Me && this._class === Me._class && this._type === Me._type && this.getAlpha() === Me.getAlpha() && q.equals(this._components, Me._components) || !1;
            },
            toString: function() {
              for (var ye = this._properties, Me = [], Ge = this._type === "gradient", Qe = R.instance, re = 0, Se = ye.length; re < Se; re++) {
                var Pe = this._components[re];
                Pe != null && Me.push(ye[re] + ": " + (Ge ? Pe : Qe.number(Pe)));
              }
              return this._alpha != null && Me.push("alpha: " + Qe.number(this._alpha)), "{ " + Me.join(", ") + " }";
            },
            toCSS: function(ye) {
              var Me = this._convert("rgb"), Ge = ye || this._alpha == null ? 1 : this._alpha;
              function Qe(re) {
                return Math.round((re < 0 ? 0 : re > 1 ? 1 : re) * 255);
              }
              return Me = [
                Qe(Me[0]),
                Qe(Me[1]),
                Qe(Me[2])
              ], Ge < 1 && Me.push(Ge < 0 ? 0 : Ge), ye ? "#" + ((1 << 24) + (Me[0] << 16) + (Me[1] << 8) + Me[2]).toString(16).slice(1) : (Me.length == 4 ? "rgba(" : "rgb(") + Me.join(",") + ")";
            },
            toCanvasStyle: function(ye, Me) {
              if (this._canvasStyle)
                return this._canvasStyle;
              if (this._type !== "gradient")
                return this._canvasStyle = this.toCSS();
              var Ge = this._components, Qe = Ge[0], re = Qe._stops, Se = Ge[1], Pe = Ge[2], at = Ge[3], Be = Me && Me.inverted(), Ze;
              if (Be && (Se = Be._transformPoint(Se), Pe = Be._transformPoint(Pe), at && (at = Be._transformPoint(at))), Qe._radial) {
                var fe = Pe.getDistance(Se);
                if (at) {
                  var Je = at.subtract(Se);
                  Je.getLength() > fe && (at = Se.add(Je.normalize(fe - 0.1)));
                }
                var Xe = at || Se;
                Ze = ye.createRadialGradient(
                  Xe.x,
                  Xe.y,
                  0,
                  Se.x,
                  Se.y,
                  fe
                );
              } else
                Ze = ye.createLinearGradient(
                  Se.x,
                  Se.y,
                  Pe.x,
                  Pe.y
                );
              for (var z = 0, He = re.length; z < He; z++) {
                var nt = re[z], ae = nt._offset;
                Ze.addColorStop(
                  ae ?? z / (He - 1),
                  nt._color.toCanvasStyle()
                );
              }
              return this._canvasStyle = Ze;
            },
            transform: function(ye) {
              if (this._type === "gradient") {
                for (var Me = this._components, Ge = 1, Qe = Me.length; Ge < Qe; Ge++) {
                  var re = Me[Ge];
                  ye._transformPoint(re, re, !0);
                }
                this._changed();
              }
            },
            statics: {
              _types: l,
              random: function() {
                var ye = Math.random;
                return new dt(ye(), ye(), ye());
              },
              _setOwner: function(ye, Me, Ge) {
                return ye && (ye._owner && Me && ye._owner !== Me && (ye = ye.clone()), !ye._owner ^ !Me && (ye._owner = Me || null, ye._setter = Ge || null)), ye;
              }
            }
          });
        }(),
        new function() {
          var l = {
            add: function(_, I) {
              return _ + I;
            },
            subtract: function(_, I) {
              return _ - I;
            },
            multiply: function(_, I) {
              return _ * I;
            },
            divide: function(_, I) {
              return _ / I;
            }
          };
          return q.each(l, function(_, I) {
            this[I] = function(X) {
              X = dt.read(arguments);
              for (var ne = this._type, ue = this._components, Te = X._convert(ne), ye = 0, Me = ue.length; ye < Me; ye++)
                Te[ye] = _(ue[ye], Te[ye]);
              return new dt(
                ne,
                Te,
                this._alpha != null ? _(this._alpha, X.getAlpha()) : null
              );
            };
          }, {});
        }()
      ), ct = q.extend({
        _class: "Gradient",
        initialize: function(_, I) {
          this._id = M.get(), _ && q.isPlainObject(_) && (this.set(_), _ = I = null), this._stops == null && this.setStops(_ || ["white", "black"]), this._radial == null && this.setRadial(typeof I == "string" && I === "radial" || I || !1);
        },
        _serialize: function(l, _) {
          return _.add(this, function() {
            return q.serialize(
              [this._stops, this._radial],
              l,
              !0,
              _
            );
          });
        },
        _changed: function() {
          for (var l = 0, _ = this._owners && this._owners.length; l < _; l++)
            this._owners[l]._changed();
        },
        _addOwner: function(l) {
          this._owners || (this._owners = []), this._owners.push(l);
        },
        _removeOwner: function(l) {
          var _ = this._owners ? this._owners.indexOf(l) : -1;
          _ != -1 && (this._owners.splice(_, 1), this._owners.length || (this._owners = qe));
        },
        clone: function() {
          for (var l = [], _ = 0, I = this._stops.length; _ < I; _++)
            l[_] = this._stops[_].clone();
          return new ct(l, this._radial);
        },
        getStops: function() {
          return this._stops;
        },
        setStops: function(l) {
          if (l.length < 2)
            throw new Error(
              "Gradient stop list needs to contain at least two stops."
            );
          var _ = this._stops;
          if (_)
            for (var I = 0, X = _.length; I < X; I++)
              _[I]._owner = qe;
          _ = this._stops = wt.readList(l, 0, { clone: !0 });
          for (var I = 0, X = _.length; I < X; I++)
            _[I]._owner = this;
          this._changed();
        },
        getRadial: function() {
          return this._radial;
        },
        setRadial: function(l) {
          this._radial = l, this._changed();
        },
        equals: function(l) {
          if (l === this)
            return !0;
          if (l && this._class === l._class) {
            var _ = this._stops, I = l._stops, X = _.length;
            if (X === I.length) {
              for (var ne = 0; ne < X; ne++)
                if (!_[ne].equals(I[ne]))
                  return !1;
              return !0;
            }
          }
          return !1;
        }
      }), wt = q.extend({
        _class: "GradientStop",
        initialize: function(_, I) {
          var X = _, ne = I;
          typeof _ == "object" && I === qe && (Array.isArray(_) && typeof _[0] != "number" ? (X = _[0], ne = _[1]) : ("color" in _ || "offset" in _ || "rampPoint" in _) && (X = _.color, ne = _.offset || _.rampPoint || 0)), this.setColor(X), this.setOffset(ne);
        },
        clone: function() {
          return new wt(this._color.clone(), this._offset);
        },
        _serialize: function(l, _) {
          var I = this._color, X = this._offset;
          return q.serialize(
            X == null ? [I] : [I, X],
            l,
            !0,
            _
          );
        },
        _changed: function() {
          this._owner && this._owner._changed(129);
        },
        getOffset: function() {
          return this._offset;
        },
        setOffset: function(l) {
          this._offset = l, this._changed();
        },
        getRampPoint: "#getOffset",
        setRampPoint: "#setOffset",
        getColor: function() {
          return this._color;
        },
        setColor: function() {
          dt._setOwner(this._color, null), this._color = dt._setOwner(
            dt.read(arguments, 0),
            this,
            "setColor"
          ), this._changed();
        },
        equals: function(l) {
          return l === this || l && this._class === l._class && this._color.equals(l._color) && this._offset == l._offset || !1;
        }
      }), Ht = q.extend(new function() {
        var l = {
          fillColor: null,
          fillRule: "nonzero",
          strokeColor: null,
          strokeWidth: 1,
          strokeCap: "butt",
          strokeJoin: "miter",
          strokeScaling: !0,
          miterLimit: 10,
          dashOffset: 0,
          dashArray: [],
          shadowColor: null,
          shadowBlur: 0,
          shadowOffset: new x(),
          selectedColor: null
        }, _ = q.set({}, l, {
          fontFamily: "sans-serif",
          fontWeight: "normal",
          fontSize: 12,
          leading: null,
          justification: "left"
        }), I = q.set({}, _, {
          fillColor: new dt()
        }), X = {
          strokeWidth: 193,
          strokeCap: 193,
          strokeJoin: 193,
          strokeScaling: 201,
          miterLimit: 193,
          fontFamily: 9,
          fontWeight: 9,
          fontSize: 9,
          font: 9,
          leading: 9,
          justification: 9
        }, ne = {
          beans: !0
        }, ue = {
          _class: "Style",
          beans: !0,
          initialize: function(ye, Me, Ge) {
            this._values = {}, this._owner = Me, this._project = Me && Me._project || Ge || xt.project, this._defaults = !Me || Me instanceof W ? _ : Me instanceof pt ? I : l, ye && this.set(ye);
          }
        };
        return q.each(_, function(Te, ye) {
          var Me = /Color$/.test(ye), Ge = ye === "shadowOffset", Qe = q.capitalize(ye), re = X[ye], Se = "set" + Qe, Pe = "get" + Qe;
          ue[Se] = function(at) {
            var Be = this._owner, Ze = Be && Be._children, fe = Ze && Ze.length > 0 && !(Be instanceof it);
            if (fe)
              for (var Je = 0, Xe = Ze.length; Je < Xe; Je++)
                Ze[Je]._style[Se](at);
            if ((ye === "selectedColor" || !fe) && ye in this._defaults) {
              var z = this._values[ye];
              z !== at && (Me && (z && (dt._setOwner(z, null), z._canvasStyle = null), at && at.constructor === dt && (at = dt._setOwner(
                at,
                Be,
                fe && Se
              ))), this._values[ye] = at, Be && Be._changed(re || 129));
            }
          }, ue[Pe] = function(at) {
            var Be = this._owner, Ze = Be && Be._children, fe = Ze && Ze.length > 0 && !(Be instanceof it), Je;
            if (fe && !at)
              for (var Xe = 0, z = Ze.length; Xe < z; Xe++) {
                var He = Ze[Xe]._style[Pe]();
                if (!Xe)
                  Je = He;
                else if (!q.equals(Je, He))
                  return qe;
              }
            else if (ye in this._defaults) {
              var Je = this._values[ye];
              if (Je === qe)
                Je = this._defaults[ye], Je && Je.clone && (Je = Je.clone());
              else {
                var nt = Me ? dt : Ge ? x : null;
                nt && !(Je && Je.constructor === nt) && (this._values[ye] = Je = nt.read(
                  [Je],
                  0,
                  { readNull: !0, clone: !0 }
                ));
              }
            }
            return Je && Me && (Je = dt._setOwner(Je, Be, fe && Se)), Je;
          }, ne[Pe] = function(at) {
            return this._style[Pe](at);
          }, ne[Se] = function(at) {
            this._style[Se](at);
          };
        }), q.each({
          Font: "FontFamily",
          WindingRule: "FillRule"
        }, function(Te, ye) {
          var Me = "get" + ye, Ge = "set" + ye;
          ue[Me] = ne[Me] = "#get" + Te, ue[Ge] = ne[Ge] = "#set" + Te;
        }), T.inject(ne), ue;
      }(), {
        set: function(l) {
          var _ = l instanceof Ht, I = _ ? l._values : l;
          if (I) {
            for (var X in I)
              if (X in this._defaults) {
                var ne = I[X];
                this[X] = ne && _ && ne.clone ? ne.clone() : ne;
              }
          }
        },
        equals: function(l) {
          function _(I, X, ne) {
            var ue = I._values, Te = X._values, ye = X._defaults;
            for (var Me in ue) {
              var Ge = ue[Me], Qe = Te[Me];
              if (!(ne && Me in Te) && !q.equals(
                Ge,
                Qe === qe ? ye[Me] : Qe
              ))
                return !1;
            }
            return !0;
          }
          return l === this || l && this._class === l._class && _(this, l) && _(l, this, !0) || !1;
        },
        _dispose: function() {
          var l;
          l = this.getFillColor(), l && (l._canvasStyle = null), l = this.getStrokeColor(), l && (l._canvasStyle = null), l = this.getShadowColor(), l && (l._canvasStyle = null);
        },
        hasFill: function() {
          var l = this.getFillColor();
          return !!l && l.alpha > 0;
        },
        hasStroke: function() {
          var l = this.getStrokeColor();
          return !!l && l.alpha > 0 && this.getStrokeWidth() > 0;
        },
        hasShadow: function() {
          var l = this.getShadowColor();
          return !!l && l.alpha > 0 && (this.getShadowBlur() > 0 || !this.getShadowOffset().isZero());
        },
        getView: function() {
          return this._project._view;
        },
        getFontStyle: function() {
          var l = this.getFontSize();
          return this.getFontWeight() + " " + l + (/[a-z]/i.test(l + "") ? " " : "px ") + this.getFontFamily();
        },
        getFont: "#getFontFamily",
        setFont: "#setFontFamily",
        getLeading: function l() {
          var _ = l.base.call(this), I = this.getFontSize();
          return /pt|em|%|px/.test(I) && (I = this.getView().getPixelSize(I)), _ ?? I * 1.2;
        }
      }), $t = new function() {
        function l(_, I, X, ne) {
          for (var ue = ["", "webkit", "moz", "Moz", "ms", "o"], Te = I[0].toUpperCase() + I.substring(1), ye = 0; ye < 6; ye++) {
            var Me = ue[ye], Ge = Me ? Me + Te : I;
            if (Ge in _) {
              if (X)
                _[Ge] = ne;
              else
                return _[Ge];
              break;
            }
          }
        }
        return {
          getStyles: function(_) {
            var I = _ && _.nodeType !== 9 ? _.ownerDocument : _, X = I && I.defaultView;
            return X && X.getComputedStyle(_, "");
          },
          getBounds: function(_, I) {
            var X = _.ownerDocument, ne = X.body, ue = X.documentElement, Te;
            try {
              Te = _.getBoundingClientRect();
            } catch {
              Te = { left: 0, top: 0, width: 0, height: 0 };
            }
            var ye = Te.left - (ue.clientLeft || ne.clientLeft || 0), Me = Te.top - (ue.clientTop || ne.clientTop || 0);
            if (!I) {
              var Ge = X.defaultView;
              ye += Ge.pageXOffset || ue.scrollLeft || ne.scrollLeft, Me += Ge.pageYOffset || ue.scrollTop || ne.scrollTop;
            }
            return new E(ye, Me, Te.width, Te.height);
          },
          getViewportBounds: function(_) {
            var I = _.ownerDocument, X = I.defaultView, ne = I.documentElement;
            return new E(
              0,
              0,
              X.innerWidth || ne.clientWidth,
              X.innerHeight || ne.clientHeight
            );
          },
          getOffset: function(_, I) {
            return $t.getBounds(_, I).getPoint();
          },
          getSize: function(_) {
            return $t.getBounds(_, !0).getSize();
          },
          isInvisible: function(_) {
            return $t.getSize(_).equals(new w(0, 0));
          },
          isInView: function(_) {
            return !$t.isInvisible(_) && $t.getViewportBounds(_).intersects(
              $t.getBounds(_, !0)
            );
          },
          isInserted: function(_) {
            return de.body.contains(_);
          },
          getPrefixed: function(_, I) {
            return _ && l(_, I);
          },
          setPrefixed: function(_, I, X) {
            if (typeof I == "object")
              for (var ne in I)
                l(_, ne, !0, I[ne]);
            else
              l(_, I, !0, X);
          }
        };
      }(), rt = {
        add: function(l, _) {
          if (l)
            for (var I in _)
              for (var X = _[I], ne = I.split(/[\s,]+/g), ue = 0, Te = ne.length; ue < Te; ue++) {
                var ye = ne[ue], Me = l === de && (ye === "touchstart" || ye === "touchmove") ? { passive: !1 } : !1;
                l.addEventListener(ye, X, Me);
              }
        },
        remove: function(l, _) {
          if (l)
            for (var I in _)
              for (var X = _[I], ne = I.split(/[\s,]+/g), ue = 0, Te = ne.length; ue < Te; ue++)
                l.removeEventListener(ne[ue], X, !1);
        },
        getPoint: function(l) {
          var _ = l.targetTouches ? l.targetTouches.length ? l.targetTouches[0] : l.changedTouches[0] : l;
          return new x(
            _.pageX || _.clientX + de.documentElement.scrollLeft,
            _.pageY || _.clientY + de.documentElement.scrollTop
          );
        },
        getTarget: function(l) {
          return l.target || l.srcElement;
        },
        getRelatedTarget: function(l) {
          return l.relatedTarget || l.toElement;
        },
        getOffset: function(l, _) {
          return rt.getPoint(l).subtract($t.getOffset(
            _ || rt.getTarget(l)
          ));
        }
      };
      rt.requestAnimationFrame = new function() {
        var l = $t.getPrefixed(Q, "requestAnimationFrame"), _ = !1, I = [], X;
        function ne() {
          var ue = I;
          I = [];
          for (var Te = 0, ye = ue.length; Te < ye; Te++)
            ue[Te]();
          _ = l && I.length, _ && l(ne);
        }
        return function(ue) {
          I.push(ue), l ? _ || (l(ne), _ = !0) : X || (X = setInterval(ne, 1e3 / 60));
        };
      }();
      var ri = q.extend(
        ie,
        {
          _class: "View",
          initialize: function l(_, I) {
            function X(re) {
              return I[re] || parseInt(I.getAttribute(re), 10);
            }
            function ne() {
              var re = $t.getSize(I);
              return re.isNaN() || re.isZero() ? new w(X("width"), X("height")) : re;
            }
            var ue;
            if (Q && I) {
              this._id = I.getAttribute("id"), this._id == null && I.setAttribute("id", this._id = "paper-view-" + l._id++), rt.add(I, this._viewEvents);
              var Te = "none";
              if ($t.setPrefixed(I.style, {
                userDrag: Te,
                userSelect: Te,
                touchCallout: Te,
                contentZooming: Te,
                tapHighlightColor: "rgba(0,0,0,0)"
              }), i.hasAttribute(I, "resize")) {
                var ye = this;
                rt.add(Q, this._windowEvents = {
                  resize: function() {
                    ye.setViewSize(ne());
                  }
                });
              }
              if (ue = ne(), i.hasAttribute(I, "stats") && typeof Stats < "u") {
                this._stats = new Stats();
                var Me = this._stats.domElement, Ge = Me.style, Qe = $t.getOffset(I);
                Ge.position = "absolute", Ge.left = Qe.x + "px", Ge.top = Qe.y + "px", de.body.appendChild(Me);
              }
            } else
              ue = new w(I), I = null;
            this._project = _, this._scope = _._scope, this._element = I, this._pixelRatio || (this._pixelRatio = Q && Q.devicePixelRatio || 1), this._setElementSize(ue.width, ue.height), this._viewSize = ue, l._views.push(this), l._viewsById[this._id] = this, (this._matrix = new S())._owner = this, l._focused || (l._focused = this), this._frameItems = {}, this._frameItemCount = 0, this._itemEvents = { native: {}, virtual: {} }, this._autoUpdate = !xt.agent.node, this._needsUpdate = !1;
          },
          remove: function() {
            if (!this._project)
              return !1;
            ri._focused === this && (ri._focused = null), ri._views.splice(ri._views.indexOf(this), 1), delete ri._viewsById[this._id];
            var l = this._project;
            return l._view === this && (l._view = null), rt.remove(this._element, this._viewEvents), rt.remove(Q, this._windowEvents), this._element = this._project = null, this.off("frame"), this._animate = !1, this._frameItems = {}, !0;
          },
          _events: q.each(
            T._itemHandlers.concat(["onResize", "onKeyDown", "onKeyUp"]),
            function(l) {
              this[l] = {};
            },
            {
              onFrame: {
                install: function() {
                  this.play();
                },
                uninstall: function() {
                  this.pause();
                }
              }
            }
          ),
          _animate: !1,
          _time: 0,
          _count: 0,
          getAutoUpdate: function() {
            return this._autoUpdate;
          },
          setAutoUpdate: function(l) {
            this._autoUpdate = l, l && this.requestUpdate();
          },
          update: function() {
          },
          draw: function() {
            this.update();
          },
          requestUpdate: function() {
            if (!this._requested) {
              var l = this;
              rt.requestAnimationFrame(function() {
                if (l._requested = !1, l._animate) {
                  l.requestUpdate();
                  var _ = l._element;
                  (!$t.getPrefixed(de, "hidden") || i.getAttribute(_, "keepalive") === "true") && $t.isInView(_) && l._handleFrame();
                }
                l._autoUpdate && l.update();
              }), this._requested = !0;
            }
          },
          play: function() {
            this._animate = !0, this.requestUpdate();
          },
          pause: function() {
            this._animate = !1;
          },
          _handleFrame: function() {
            xt = this._scope;
            var l = Date.now() / 1e3, _ = this._last ? l - this._last : 0;
            this._last = l, this.emit("frame", new q({
              delta: _,
              time: this._time += _,
              count: this._count++
            })), this._stats && this._stats.update();
          },
          _animateItem: function(l, _) {
            var I = this._frameItems;
            _ ? (I[l._id] = {
              item: l,
              time: 0,
              count: 0
            }, ++this._frameItemCount === 1 && this.on("frame", this._handleFrameItems)) : (delete I[l._id], --this._frameItemCount === 0 && this.off("frame", this._handleFrameItems));
          },
          _handleFrameItems: function(l) {
            for (var _ in this._frameItems) {
              var I = this._frameItems[_];
              I.item.emit("frame", new q(l, {
                time: I.time += l.delta,
                count: I.count++
              }));
            }
          },
          _changed: function() {
            this._project._changed(4097), this._bounds = this._decomposed = qe;
          },
          getElement: function() {
            return this._element;
          },
          getPixelRatio: function() {
            return this._pixelRatio;
          },
          getResolution: function() {
            return this._pixelRatio * 72;
          },
          getViewSize: function() {
            var l = this._viewSize;
            return new k(l.width, l.height, this, "setViewSize");
          },
          setViewSize: function() {
            var l = w.read(arguments), _ = l.subtract(this._viewSize);
            _.isZero() || (this._setElementSize(l.width, l.height), this._viewSize.set(l), this._changed(), this.emit("resize", { size: l, delta: _ }), this._autoUpdate && this.update());
          },
          _setElementSize: function(l, _) {
            var I = this._element;
            I && (I.width !== l && (I.width = l), I.height !== _ && (I.height = _));
          },
          getBounds: function() {
            return this._bounds || (this._bounds = this._matrix.inverted()._transformBounds(
              new E(new x(), this._viewSize)
            )), this._bounds;
          },
          getSize: function() {
            return this.getBounds().getSize();
          },
          isVisible: function() {
            return $t.isInView(this._element);
          },
          isInserted: function() {
            return $t.isInserted(this._element);
          },
          getPixelSize: function(l) {
            var _ = this._element, I;
            if (_) {
              var X = _.parentNode, ne = de.createElement("div");
              ne.style.fontSize = l, X.appendChild(ne), I = parseFloat($t.getStyles(ne).fontSize), X.removeChild(ne);
            } else
              I = parseFloat(I);
            return I;
          },
          getTextWidth: function(l, _) {
            return 0;
          }
        },
        q.each(["rotate", "scale", "shear", "skew"], function(l) {
          var _ = l === "rotate";
          this[l] = function() {
            var I = arguments, X = (_ ? q : x).read(I), ne = x.read(I, 0, { readNull: !0 });
            return this.transform(new S()[l](
              X,
              ne || this.getCenter(!0)
            ));
          };
        }, {
          _decompose: function() {
            return this._decomposed || (this._decomposed = this._matrix.decompose());
          },
          translate: function() {
            var l = new S();
            return this.transform(l.translate.apply(l, arguments));
          },
          getCenter: function() {
            return this.getBounds().getCenter();
          },
          setCenter: function() {
            var l = x.read(arguments);
            this.translate(this.getCenter().subtract(l));
          },
          getZoom: function() {
            var l = this._decompose().scaling;
            return (l.x + l.y) / 2;
          },
          setZoom: function(l) {
            this.transform(new S().scale(
              l / this.getZoom(),
              this.getCenter()
            ));
          },
          getRotation: function() {
            return this._decompose().rotation;
          },
          setRotation: function(l) {
            var _ = this.getRotation();
            _ != null && l != null && this.rotate(l - _);
          },
          getScaling: function() {
            var l = this._decompose().scaling;
            return new m(l.x, l.y, this, "setScaling");
          },
          setScaling: function() {
            var l = this.getScaling(), _ = x.read(arguments, 0, { clone: !0, readNull: !0 });
            l && _ && this.scale(_.x / l.x, _.y / l.y);
          },
          getMatrix: function() {
            return this._matrix;
          },
          setMatrix: function() {
            var l = this._matrix;
            l.set.apply(l, arguments);
          },
          transform: function(l) {
            this._matrix.append(l);
          },
          scrollBy: function() {
            this.translate(x.read(arguments).negate());
          }
        }),
        {
          projectToView: function() {
            return this._matrix._transformPoint(x.read(arguments));
          },
          viewToProject: function() {
            return this._matrix._inverseTransform(x.read(arguments));
          },
          getEventPoint: function(l) {
            return this.viewToProject(rt.getOffset(l, this._element));
          }
        },
        {
          statics: {
            _views: [],
            _viewsById: {},
            _id: 0,
            create: function(l, _) {
              de && typeof _ == "string" && (_ = de.getElementById(_));
              var I = Q ? wi : ri;
              return new I(l, _);
            }
          }
        },
        new function() {
          if (!Q)
            return;
          var l, _, I = !1, X = !1;
          function ne(Ft) {
            var ai = rt.getTarget(Ft);
            return ai.getAttribute && ri._viewsById[ai.getAttribute("id")];
          }
          function ue() {
            var Ft = ri._focused;
            if (!Ft || !Ft.isVisible()) {
              for (var ai = 0, Mt = ri._views.length; ai < Mt; ai++)
                if ((Ft = ri._views[ai]).isVisible()) {
                  ri._focused = _ = Ft;
                  break;
                }
            }
          }
          function Te(Ft, ai, Mt) {
            Ft._handleMouseEvent("mousemove", ai, Mt);
          }
          var ye = Q.navigator, Me, Ge, Qe;
          ye.pointerEnabled || ye.msPointerEnabled ? (Me = "pointerdown MSPointerDown", Ge = "pointermove MSPointerMove", Qe = "pointerup pointercancel MSPointerUp MSPointerCancel") : (Me = "touchstart", Ge = "touchmove", Qe = "touchend touchcancel", "ontouchstart" in Q && ye.userAgent.match(
            /mobile|tablet|ip(ad|hone|od)|android|silk/i
          ) || (Me += " mousedown", Ge += " mousemove", Qe += " mouseup"));
          var re = {}, Se = {
            mouseout: function(Ft) {
              var ai = ri._focused, Mt = rt.getRelatedTarget(Ft);
              if (ai && (!Mt || Mt.nodeName === "HTML")) {
                var Ae = rt.getOffset(Ft, ai._element), Fe = Ae.x, tt = Math.abs, Ct = tt(Fe), It = 1 << 25, Ut = Ct - It;
                Ae.x = tt(Ut) < Ct ? Ut * (Fe < 0 ? -1 : 1) : Fe, Te(ai, Ft, ai.viewToProject(Ae));
              }
            },
            scroll: ue
          };
          re[Me] = function(Ft) {
            var ai = ri._focused = ne(Ft);
            I || (I = !0, ai._handleMouseEvent("mousedown", Ft));
          }, Se[Ge] = function(Ft) {
            var ai = ri._focused;
            if (!X) {
              var Mt = ne(Ft);
              Mt ? ai !== Mt && (ai && Te(ai, Ft), l || (l = ai), ai = ri._focused = _ = Mt) : _ && _ === ai && (l && !l.isInserted() && (l = null), ai = ri._focused = l, l = null, ue());
            }
            ai && Te(ai, Ft);
          }, Se[Me] = function() {
            X = !0;
          }, Se[Qe] = function(Ft) {
            var ai = ri._focused;
            ai && I && ai._handleMouseEvent("mouseup", Ft), X = I = !1;
          }, rt.add(de, Se), rt.add(Q, {
            load: ue
          });
          var Pe = !1, at = !1, Be = {
            doubleclick: "click",
            mousedrag: "mousemove"
          }, Ze = !1, fe, Je, Xe, z, He, nt, ae, $e;
          function Et(Ft, ai, Mt, Ae, Fe, tt, Ct) {
            var It = !1, Ut;
            function ti(Pt, Wt) {
              if (Pt.responds(Wt)) {
                if (Ut || (Ut = new Lt(
                  Wt,
                  Ae,
                  Fe,
                  ai || Pt,
                  tt ? Fe.subtract(tt) : null
                )), Pt.emit(Wt, Ut) && (Pe = !0, Ut.prevented && (at = !0), Ut.stopped))
                  return It = !0;
              } else {
                var ei = Be[Wt];
                if (ei)
                  return ti(Pt, ei);
              }
            }
            for (; Ft && Ft !== Ct && !ti(Ft, Mt); )
              Ft = Ft._parent;
            return It;
          }
          function Nt(Ft, ai, Mt, Ae, Fe, tt) {
            return Ft._project.removeOn(Mt), at = Pe = !1, He && Et(
              He,
              null,
              Mt,
              Ae,
              Fe,
              tt
            ) || ai && ai !== He && !ai.isDescendant(He) && Et(ai, null, Mt === "mousedrag" ? "mousemove" : Mt, Ae, Fe, tt, He) || Et(
              Ft,
              He || ai || Ft,
              Mt,
              Ae,
              Fe,
              tt
            );
          }
          var Yt = {
            mousedown: {
              mousedown: 1,
              mousedrag: 1,
              click: 1,
              doubleclick: 1
            },
            mouseup: {
              mouseup: 1,
              mousedrag: 1,
              click: 1,
              doubleclick: 1
            },
            mousemove: {
              mousedrag: 1,
              mousemove: 1,
              mouseenter: 1,
              mouseleave: 1
            }
          };
          return {
            _viewEvents: re,
            _handleMouseEvent: function(Ft, ai, Mt) {
              var Ae = this._itemEvents, Fe = Ae.native[Ft], tt = Ft === "mousemove", Ct = this._scope.tool, It = this;
              function Ut(Di) {
                return Ae.virtual[Di] || It.responds(Di) || Ct && Ct.responds(Di);
              }
              tt && I && Ut("mousedrag") && (Ft = "mousedrag"), Mt || (Mt = this.getEventPoint(ai));
              var ti = this.getBounds().contains(Mt), Pt = Fe && ti && It._project.hitTest(Mt, {
                tolerance: 0,
                fill: !0,
                stroke: !0
              }), Wt = Pt && Pt.item || null, ei = !1, oi = {};
              if (oi[Ft.substr(5)] = !0, Fe && Wt !== z && (z && Et(z, null, "mouseleave", ai, Mt), Wt && Et(Wt, null, "mouseenter", ai, Mt), z = Wt), Ze ^ ti && (Et(
                this,
                null,
                ti ? "mouseenter" : "mouseleave",
                ai,
                Mt
              ), ei = !0), (ti || oi.drag) && !Mt.equals(Je) && (Nt(
                this,
                Wt,
                tt ? Ft : "mousemove",
                ai,
                Mt,
                Je
              ), ei = !0), Ze = ti, oi.down && ti || oi.up && fe) {
                if (Nt(this, Wt, Ft, ai, Mt, fe), oi.down) {
                  if ($e = Wt === nt && Date.now() - ae < 300, Xe = nt = Wt, !at && Wt) {
                    for (var _i = Wt; _i && !_i.responds("mousedrag"); )
                      _i = _i._parent;
                    _i && (He = Wt);
                  }
                  fe = Mt;
                } else oi.up && (!at && Wt === Xe && (ae = Date.now(), Nt(this, Wt, $e ? "doubleclick" : "click", ai, Mt, fe), $e = !1), Xe = He = null);
                Ze = !1, ei = !0;
              }
              Je = Mt, ei && Ct && (Pe = Ct._handleMouseEvent(Ft, ai, Mt, oi) || Pe), ai.cancelable !== !1 && (Pe && !oi.move || oi.down && Ut("mouseup")) && ai.preventDefault();
            },
            _handleKeyEvent: function(Ft, ai, Mt, Ae) {
              var Fe = this._scope, tt = Fe.tool, Ct;
              function It(Ut) {
                Ut.responds(Ft) && (xt = Fe, Ut.emit(Ft, Ct = Ct || new At(Ft, ai, Mt, Ae)));
              }
              this.isVisible() && (It(this), tt && tt.responds(Ft) && It(tt));
            },
            _countItemEvent: function(Ft, ai) {
              var Mt = this._itemEvents, Ae = Mt.native, Fe = Mt.virtual;
              for (var tt in Yt)
                Ae[tt] = (Ae[tt] || 0) + (Yt[tt][Ft] || 0) * ai;
              Fe[Ft] = (Fe[Ft] || 0) + ai;
            },
            statics: {
              updateFocus: ue,
              _resetState: function() {
                I = X = Pe = Ze = !1, l = _ = fe = Je = Xe = z = He = nt = ae = $e = null;
              }
            }
          };
        }()
      ), wi = ri.extend({
        _class: "CanvasView",
        initialize: function(_, I) {
          if (!(I instanceof Q.HTMLCanvasElement)) {
            var X = w.read(arguments, 1);
            if (X.isZero())
              throw new Error(
                "Cannot create CanvasView with the provided argument: " + q.slice(arguments, 1)
              );
            I = _t.getCanvas(X);
          }
          var ne = this._context = I.getContext("2d");
          if (ne.save(), this._pixelRatio = 1, !/^off|false$/.test(i.getAttribute(I, "hidpi"))) {
            var ue = Q.devicePixelRatio || 1, Te = $t.getPrefixed(
              ne,
              "backingStorePixelRatio"
            ) || 1;
            this._pixelRatio = ue / Te;
          }
          ri.call(this, _, I), this._needsUpdate = !0;
        },
        remove: function l() {
          return this._context.restore(), l.base.call(this);
        },
        _setElementSize: function l(_, I) {
          var X = this._pixelRatio;
          if (l.base.call(this, _ * X, I * X), X !== 1) {
            var ne = this._element, ue = this._context;
            if (!i.hasAttribute(ne, "resize")) {
              var Te = ne.style;
              Te.width = _ + "px", Te.height = I + "px";
            }
            ue.restore(), ue.save(), ue.scale(X, X);
          }
        },
        getContext: function() {
          return this._context;
        },
        getPixelSize: function l(_) {
          var I = xt.agent, X;
          if (I && I.firefox)
            X = l.base.call(this, _);
          else {
            var ne = this._context, ue = ne.font;
            ne.font = _ + " serif", X = parseFloat(ne.font), ne.font = ue;
          }
          return X;
        },
        getTextWidth: function(l, _) {
          var I = this._context, X = I.font, ne = 0;
          I.font = l;
          for (var ue = 0, Te = _.length; ue < Te; ue++)
            ne = Math.max(ne, I.measureText(_[ue]).width);
          return I.font = X, ne;
        },
        update: function() {
          if (!this._needsUpdate)
            return !1;
          var l = this._project, _ = this._context, I = this._viewSize;
          return _.clearRect(0, 0, I.width + 1, I.height + 1), l && l.draw(_, this._matrix, this._pixelRatio), this._needsUpdate = !1, !0;
        }
      }), Qt = q.extend({
        _class: "Event",
        initialize: function(_) {
          this.event = _, this.type = _ && _.type;
        },
        prevented: !1,
        stopped: !1,
        preventDefault: function() {
          this.prevented = !0, this.event.preventDefault();
        },
        stopPropagation: function() {
          this.stopped = !0, this.event.stopPropagation();
        },
        stop: function() {
          this.stopPropagation(), this.preventDefault();
        },
        getTimeStamp: function() {
          return this.event.timeStamp;
        },
        getModifiers: function() {
          return St.modifiers;
        }
      }), At = Qt.extend({
        _class: "KeyEvent",
        initialize: function(_, I, X, ne) {
          this.type = _, this.event = I, this.key = X, this.character = ne;
        },
        toString: function() {
          return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }";
        }
      }), St = new function() {
        var l = {
          "	": "tab",
          " ": "space",
          "\b": "backspace",
          "": "delete",
          Spacebar: "space",
          Del: "delete",
          Win: "meta",
          Esc: "escape"
        }, _ = {
          tab: "	",
          space: " ",
          enter: "\r"
        }, I = {}, X = {}, ne, ue, Te = new q({
          shift: !1,
          control: !1,
          alt: !1,
          meta: !1,
          capsLock: !1,
          space: !1
        }).inject({
          option: {
            get: function() {
              return this.alt;
            }
          },
          command: {
            get: function() {
              var Ge = xt && xt.agent;
              return Ge && Ge.mac ? this.meta : this.control;
            }
          }
        });
        function ye(Ge) {
          var Qe = Ge.key || Ge.keyIdentifier;
          return Qe = /^U\+/.test(Qe) ? String.fromCharCode(parseInt(Qe.substr(2), 16)) : /^Arrow[A-Z]/.test(Qe) ? Qe.substr(5) : Qe === "Unidentified" || Qe === qe ? String.fromCharCode(Ge.keyCode) : Qe, l[Qe] || (Qe.length > 1 ? q.hyphenate(Qe) : Qe.toLowerCase());
        }
        function Me(Ge, Qe, re, Se) {
          var Pe = ri._focused, at;
          if (I[Qe] = Ge, Ge ? X[Qe] = re : delete X[Qe], Qe.length > 1 && (at = q.camelize(Qe)) in Te) {
            Te[at] = Ge;
            var Be = xt && xt.agent;
            if (at === "meta" && Be && Be.mac)
              if (Ge)
                ne = {};
              else {
                for (var Ze in ne)
                  Ze in X && Me(!1, Ze, ne[Ze], Se);
                ne = null;
              }
          } else Ge && ne && (ne[Qe] = re);
          Pe && Pe._handleKeyEvent(
            Ge ? "keydown" : "keyup",
            Se,
            Qe,
            re
          );
        }
        return rt.add(de, {
          keydown: function(Ge) {
            var Qe = ye(Ge), re = xt && xt.agent;
            Qe.length > 1 || re && re.chrome && (Ge.altKey || re.mac && Ge.metaKey || !re.mac && Ge.ctrlKey) ? Me(
              !0,
              Qe,
              _[Qe] || (Qe.length > 1 ? "" : Qe),
              Ge
            ) : ue = Qe;
          },
          keypress: function(Ge) {
            if (ue) {
              var Qe = ye(Ge), re = Ge.charCode, Se = re >= 32 ? String.fromCharCode(re) : Qe.length > 1 ? "" : Qe;
              Qe !== ue && (Qe = Se.toLowerCase()), Me(!0, Qe, Se, Ge), ue = null;
            }
          },
          keyup: function(Ge) {
            var Qe = ye(Ge);
            Qe in X && Me(!1, Qe, X[Qe], Ge);
          }
        }), rt.add(Q, {
          blur: function(Ge) {
            for (var Qe in X)
              Me(!1, Qe, X[Qe], Ge);
          }
        }), {
          modifiers: Te,
          isDown: function(Ge) {
            return !!I[Ge];
          }
        };
      }(), Lt = Qt.extend({
        _class: "MouseEvent",
        initialize: function(_, I, X, ne, ue) {
          this.type = _, this.event = I, this.point = X, this.target = ne, this.delta = ue;
        },
        toString: function() {
          return "{ type: '" + this.type + "', point: " + this.point + ", target: " + this.target + (this.delta ? ", delta: " + this.delta : "") + ", modifiers: " + this.getModifiers() + " }";
        }
      }), kt = Qt.extend({
        _class: "ToolEvent",
        _item: null,
        initialize: function(_, I, X) {
          this.tool = _, this.type = I, this.event = X;
        },
        _choosePoint: function(l, _) {
          return l || (_ ? _.clone() : null);
        },
        getPoint: function() {
          return this._choosePoint(this._point, this.tool._point);
        },
        setPoint: function(l) {
          this._point = l;
        },
        getLastPoint: function() {
          return this._choosePoint(this._lastPoint, this.tool._lastPoint);
        },
        setLastPoint: function(l) {
          this._lastPoint = l;
        },
        getDownPoint: function() {
          return this._choosePoint(this._downPoint, this.tool._downPoint);
        },
        setDownPoint: function(l) {
          this._downPoint = l;
        },
        getMiddlePoint: function() {
          return !this._middlePoint && this.tool._lastPoint ? this.tool._point.add(this.tool._lastPoint).divide(2) : this._middlePoint;
        },
        setMiddlePoint: function(l) {
          this._middlePoint = l;
        },
        getDelta: function() {
          return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;
        },
        setDelta: function(l) {
          this._delta = l;
        },
        getCount: function() {
          return this.tool[/^mouse(down|up)$/.test(this.type) ? "_downCount" : "_moveCount"];
        },
        setCount: function(l) {
          this.tool[/^mouse(down|up)$/.test(this.type) ? "downCount" : "count"] = l;
        },
        getItem: function() {
          if (!this._item) {
            var l = this.tool._scope.project.hitTest(this.getPoint());
            if (l) {
              for (var _ = l.item, I = _._parent; /^(Group|CompoundPath)$/.test(I._class); )
                _ = I, I = I._parent;
              this._item = _;
            }
          }
          return this._item;
        },
        setItem: function(l) {
          this._item = l;
        },
        toString: function() {
          return "{ type: " + this.type + ", point: " + this.getPoint() + ", count: " + this.getCount() + ", modifiers: " + this.getModifiers() + " }";
        }
      }), Ye = N.extend({
        _class: "Tool",
        _list: "tools",
        _reference: "tool",
        _events: [
          "onMouseDown",
          "onMouseUp",
          "onMouseDrag",
          "onMouseMove",
          "onActivate",
          "onDeactivate",
          "onEditOptions",
          "onKeyDown",
          "onKeyUp"
        ],
        initialize: function(_) {
          N.call(this), this._moveCount = -1, this._downCount = -1, this.set(_);
        },
        getMinDistance: function() {
          return this._minDistance;
        },
        setMinDistance: function(l) {
          this._minDistance = l, l != null && this._maxDistance != null && l > this._maxDistance && (this._maxDistance = l);
        },
        getMaxDistance: function() {
          return this._maxDistance;
        },
        setMaxDistance: function(l) {
          this._maxDistance = l, this._minDistance != null && l != null && l < this._minDistance && (this._minDistance = l);
        },
        getFixedDistance: function() {
          return this._minDistance == this._maxDistance ? this._minDistance : null;
        },
        setFixedDistance: function(l) {
          this._minDistance = this._maxDistance = l;
        },
        _handleMouseEvent: function(l, _, I, X) {
          xt = this._scope, X.drag && !this.responds(l) && (l = "mousemove");
          var ne = X.move || X.drag, ue = this.responds(l), Te = !1, ye = this;
          function Me(Qe, re) {
            var Se = I, Pe = ne ? ye._point : ye._downPoint || Se;
            if (ne) {
              if (ye._moveCount >= 0 && Se.equals(Pe))
                return !1;
              if (Pe && (Qe != null || re != null)) {
                var at = Se.subtract(Pe), Be = at.getLength();
                if (Be < (Qe || 0))
                  return !1;
                re && (Se = Pe.add(at.normalize(
                  Math.min(Be, re)
                )));
              }
              ye._moveCount++;
            }
            return ye._point = Se, ye._lastPoint = Pe || Se, X.down && (ye._moveCount = -1, ye._downPoint = Se, ye._downCount++), !0;
          }
          function Ge() {
            ue && (Te = ye.emit(l, new kt(ye, l, _)) || Te);
          }
          if (X.down)
            Me(), Ge();
          else if (X.up)
            Me(null, this._maxDistance), Ge();
          else if (ue)
            for (; Me(this._minDistance, this._maxDistance); )
              Ge();
          return Te;
        }
      }), De = q.extend(ie, {
        _class: "Tween",
        statics: {
          easings: new q({
            linear: function(l) {
              return l;
            },
            easeInQuad: function(l) {
              return l * l;
            },
            easeOutQuad: function(l) {
              return l * (2 - l);
            },
            easeInOutQuad: function(l) {
              return l < 0.5 ? 2 * l * l : -1 + 2 * (2 - l) * l;
            },
            easeInCubic: function(l) {
              return l * l * l;
            },
            easeOutCubic: function(l) {
              return --l * l * l + 1;
            },
            easeInOutCubic: function(l) {
              return l < 0.5 ? 4 * l * l * l : (l - 1) * (2 * l - 2) * (2 * l - 2) + 1;
            },
            easeInQuart: function(l) {
              return l * l * l * l;
            },
            easeOutQuart: function(l) {
              return 1 - --l * l * l * l;
            },
            easeInOutQuart: function(l) {
              return l < 0.5 ? 8 * l * l * l * l : 1 - 8 * --l * l * l * l;
            },
            easeInQuint: function(l) {
              return l * l * l * l * l;
            },
            easeOutQuint: function(l) {
              return 1 + --l * l * l * l * l;
            },
            easeInOutQuint: function(l) {
              return l < 0.5 ? 16 * l * l * l * l * l : 1 + 16 * --l * l * l * l * l;
            }
          })
        },
        initialize: function l(_, I, X, ne, ue, Te) {
          this.object = _;
          var ye = typeof ue, Me = ye === "function";
          this.type = Me ? ye : ye === "string" ? ue : "linear", this.easing = Me ? ue : l.easings[this.type], this.duration = ne, this.running = !1, this._then = null, this._startTime = null;
          var Ge = I || X;
          this._keys = Ge ? Object.keys(Ge) : [], this._parsedKeys = this._parseKeys(this._keys), this._from = Ge && this._getState(I), this._to = Ge && this._getState(X), Te !== !1 && this.start();
        },
        then: function(l) {
          return this._then = l, this;
        },
        start: function() {
          return this._startTime = null, this.running = !0, this;
        },
        stop: function() {
          return this.running = !1, this;
        },
        update: function(l) {
          if (this.running) {
            l >= 1 && (l = 1, this.running = !1);
            for (var _ = this.easing(l), I = this._keys, X = function(Qe) {
              return typeof Qe == "function" ? Qe(_, l) : Qe;
            }, ne = 0, ue = I && I.length; ne < ue; ne++) {
              var Te = I[ne], ye = X(this._from[Te]), Me = X(this._to[Te]), Ge = ye && Me && ye.__add && Me.__add ? Me.__subtract(ye).__multiply(_).__add(ye) : (Me - ye) * _ + ye;
              this._setProperty(this._parsedKeys[Te], Ge);
            }
            this.responds("update") && this.emit("update", new q({
              progress: l,
              factor: _
            })), !this.running && this._then && this._then(this.object);
          }
          return this;
        },
        _events: {
          onUpdate: {}
        },
        _handleFrame: function(l) {
          var _ = this._startTime, I = _ ? (l - _) / this.duration : 0;
          _ || (this._startTime = l), this.update(I);
        },
        _getState: function(l) {
          for (var _ = this._keys, I = {}, X = 0, ne = _.length; X < ne; X++) {
            var ue = _[X], Te = this._parsedKeys[ue], ye = this._getProperty(Te), Me;
            if (l) {
              var Ge = this._resolveValue(ye, l[ue]);
              this._setProperty(Te, Ge), Me = this._getProperty(Te), Me = Me && Me.clone ? Me.clone() : Me, this._setProperty(Te, ye);
            } else
              Me = ye && ye.clone ? ye.clone() : ye;
            I[ue] = Me;
          }
          return I;
        },
        _resolveValue: function(l, _) {
          if (_) {
            if (Array.isArray(_) && _.length === 2) {
              var I = _[0];
              return I && I.match && I.match(/^[+\-\*\/]=/) ? this._calculate(l, I[0], _[1]) : _;
            } else if (typeof _ == "string") {
              var X = _.match(/^[+\-*/]=(.*)/);
              if (X) {
                var ne = JSON.parse(X[1].replace(
                  /(['"])?([a-zA-Z0-9_]+)(['"])?:/g,
                  '"$2": '
                ));
                return this._calculate(l, _[0], ne);
              }
            }
          }
          return _;
        },
        _calculate: function(l, _, I) {
          return xt.PaperScript.calculateBinary(l, _, I);
        },
        _parseKeys: function(l) {
          for (var _ = {}, I = 0, X = l.length; I < X; I++) {
            var ne = l[I], ue = ne.replace(/\.([^.]*)/g, "/$1").replace(/\[['"]?([^'"\]]*)['"]?\]/g, "/$1");
            _[ne] = ue.split("/");
          }
          return _;
        },
        _getProperty: function(l, _) {
          for (var I = this.object, X = 0, ne = l.length - (_ || 0); X < ne && I; X++)
            I = I[l[X]];
          return I;
        },
        _setProperty: function(l, _) {
          var I = this._getProperty(l, 1);
          I && (I[l[l.length - 1]] = _);
        }
      }), Re = {
        request: function(l) {
          var _ = new Tt.XMLHttpRequest();
          return _.open(
            (l.method || "get").toUpperCase(),
            l.url,
            q.pick(l.async, !0)
          ), l.mimeType && _.overrideMimeType(l.mimeType), _.onload = function() {
            var I = _.status;
            I === 0 || I === 200 ? l.onLoad && l.onLoad.call(_, _.responseText) : _.onerror();
          }, _.onerror = function() {
            var I = _.status, X = 'Could not load "' + l.url + '" (Status: ' + I + ")";
            if (l.onError)
              l.onError(X, I);
            else
              throw new Error(X);
          }, _.send(null);
        }
      }, _t = q.exports.CanvasProvider = {
        canvases: [],
        getCanvas: function(l, _, I) {
          if (!Q)
            return null;
          var X, ne = !0;
          typeof l == "object" && (_ = l.height, l = l.width), this.canvases.length ? X = this.canvases.pop() : (X = de.createElement("canvas"), ne = !1);
          var ue = X.getContext("2d", I || {});
          if (!ue)
            throw new Error("Canvas " + X + " is unable to provide a 2D context.");
          return X.width === l && X.height === _ ? ne && ue.clearRect(0, 0, l + 1, _ + 1) : (X.width = l, X.height = _), ue.save(), X;
        },
        getContext: function(l, _, I) {
          var X = this.getCanvas(l, _, I);
          return X ? X.getContext("2d", I || {}) : null;
        },
        release: function(l) {
          var _ = l && l.canvas ? l.canvas : l;
          _ && _.getContext && (_.getContext("2d").restore(), this.canvases.push(_));
        }
      }, et = new function() {
        var l = Math.min, _ = Math.max, I = Math.abs, X, ne, ue, Te, ye, Me, Ge, Qe, re, Se, Pe;
        function at(He, nt, ae) {
          return 0.2989 * He + 0.587 * nt + 0.114 * ae;
        }
        function Be(He, nt, ae, Nt) {
          var Et = Nt - at(He, nt, ae);
          re = He + Et, Se = nt + Et, Pe = ae + Et;
          var Nt = at(re, Se, Pe), Yt = l(re, Se, Pe), Ft = _(re, Se, Pe);
          if (Yt < 0) {
            var ai = Nt - Yt;
            re = Nt + (re - Nt) * Nt / ai, Se = Nt + (Se - Nt) * Nt / ai, Pe = Nt + (Pe - Nt) * Nt / ai;
          }
          if (Ft > 255) {
            var Mt = 255 - Nt, Ae = Ft - Nt;
            re = Nt + (re - Nt) * Mt / Ae, Se = Nt + (Se - Nt) * Mt / Ae, Pe = Nt + (Pe - Nt) * Mt / Ae;
          }
        }
        function Ze(He, nt, ae) {
          return _(He, nt, ae) - l(He, nt, ae);
        }
        function fe(He, nt, ae, $e) {
          var Et = [He, nt, ae], Nt = _(He, nt, ae), Yt = l(He, nt, ae), Ft;
          Yt = Yt === He ? 0 : Yt === nt ? 1 : 2, Nt = Nt === He ? 0 : Nt === nt ? 1 : 2, Ft = l(Yt, Nt) === 0 ? _(Yt, Nt) === 1 ? 2 : 1 : 0, Et[Nt] > Et[Yt] ? (Et[Ft] = (Et[Ft] - Et[Yt]) * $e / (Et[Nt] - Et[Yt]), Et[Nt] = $e) : Et[Ft] = Et[Nt] = 0, Et[Yt] = 0, re = Et[0], Se = Et[1], Pe = Et[2];
        }
        var Je = {
          multiply: function() {
            re = ye * X / 255, Se = Me * ne / 255, Pe = Ge * ue / 255;
          },
          screen: function() {
            re = ye + X - ye * X / 255, Se = Me + ne - Me * ne / 255, Pe = Ge + ue - Ge * ue / 255;
          },
          overlay: function() {
            re = ye < 128 ? 2 * ye * X / 255 : 255 - 2 * (255 - ye) * (255 - X) / 255, Se = Me < 128 ? 2 * Me * ne / 255 : 255 - 2 * (255 - Me) * (255 - ne) / 255, Pe = Ge < 128 ? 2 * Ge * ue / 255 : 255 - 2 * (255 - Ge) * (255 - ue) / 255;
          },
          "soft-light": function() {
            var He = X * ye / 255;
            re = He + ye * (255 - (255 - ye) * (255 - X) / 255 - He) / 255, He = ne * Me / 255, Se = He + Me * (255 - (255 - Me) * (255 - ne) / 255 - He) / 255, He = ue * Ge / 255, Pe = He + Ge * (255 - (255 - Ge) * (255 - ue) / 255 - He) / 255;
          },
          "hard-light": function() {
            re = X < 128 ? 2 * X * ye / 255 : 255 - 2 * (255 - X) * (255 - ye) / 255, Se = ne < 128 ? 2 * ne * Me / 255 : 255 - 2 * (255 - ne) * (255 - Me) / 255, Pe = ue < 128 ? 2 * ue * Ge / 255 : 255 - 2 * (255 - ue) * (255 - Ge) / 255;
          },
          "color-dodge": function() {
            re = ye === 0 ? 0 : X === 255 ? 255 : l(255, 255 * ye / (255 - X)), Se = Me === 0 ? 0 : ne === 255 ? 255 : l(255, 255 * Me / (255 - ne)), Pe = Ge === 0 ? 0 : ue === 255 ? 255 : l(255, 255 * Ge / (255 - ue));
          },
          "color-burn": function() {
            re = ye === 255 ? 255 : X === 0 ? 0 : _(0, 255 - (255 - ye) * 255 / X), Se = Me === 255 ? 255 : ne === 0 ? 0 : _(0, 255 - (255 - Me) * 255 / ne), Pe = Ge === 255 ? 255 : ue === 0 ? 0 : _(0, 255 - (255 - Ge) * 255 / ue);
          },
          darken: function() {
            re = ye < X ? ye : X, Se = Me < ne ? Me : ne, Pe = Ge < ue ? Ge : ue;
          },
          lighten: function() {
            re = ye > X ? ye : X, Se = Me > ne ? Me : ne, Pe = Ge > ue ? Ge : ue;
          },
          difference: function() {
            re = ye - X, re < 0 && (re = -re), Se = Me - ne, Se < 0 && (Se = -Se), Pe = Ge - ue, Pe < 0 && (Pe = -Pe);
          },
          exclusion: function() {
            re = ye + X * (255 - ye - ye) / 255, Se = Me + ne * (255 - Me - Me) / 255, Pe = Ge + ue * (255 - Ge - Ge) / 255;
          },
          hue: function() {
            fe(X, ne, ue, Ze(ye, Me, Ge)), Be(re, Se, Pe, at(ye, Me, Ge));
          },
          saturation: function() {
            fe(ye, Me, Ge, Ze(X, ne, ue)), Be(re, Se, Pe, at(ye, Me, Ge));
          },
          luminosity: function() {
            Be(ye, Me, Ge, at(X, ne, ue));
          },
          color: function() {
            Be(X, ne, ue, at(ye, Me, Ge));
          },
          add: function() {
            re = l(ye + X, 255), Se = l(Me + ne, 255), Pe = l(Ge + ue, 255);
          },
          subtract: function() {
            re = _(ye - X, 0), Se = _(Me - ne, 0), Pe = _(Ge - ue, 0);
          },
          average: function() {
            re = (ye + X) / 2, Se = (Me + ne) / 2, Pe = (Ge + ue) / 2;
          },
          negation: function() {
            re = 255 - I(255 - X - ye), Se = 255 - I(255 - ne - Me), Pe = 255 - I(255 - ue - Ge);
          }
        }, Xe = this.nativeModes = q.each([
          "source-over",
          "source-in",
          "source-out",
          "source-atop",
          "destination-over",
          "destination-in",
          "destination-out",
          "destination-atop",
          "lighter",
          "darker",
          "copy",
          "xor"
        ], function(He) {
          this[He] = !0;
        }, {}), z = _t.getContext(1, 1, { willReadFrequently: !0 });
        z && (q.each(Je, function(He, nt) {
          var ae = nt === "darken", $e = !1;
          z.save();
          try {
            z.fillStyle = ae ? "#300" : "#a00", z.fillRect(0, 0, 1, 1), z.globalCompositeOperation = nt, z.globalCompositeOperation === nt && (z.fillStyle = ae ? "#a00" : "#300", z.fillRect(0, 0, 1, 1), $e = z.getImageData(0, 0, 1, 1).data[0] !== ae ? 170 : 51);
          } catch {
          }
          z.restore(), Xe[nt] = $e;
        }), _t.release(z)), this.process = function(He, nt, ae, $e, Et) {
          var Nt = nt.canvas, Yt = He === "normal";
          if (Yt || Xe[He])
            ae.save(), ae.setTransform(1, 0, 0, 1, 0, 0), ae.globalAlpha = $e, Yt || (ae.globalCompositeOperation = He), ae.drawImage(Nt, Et.x, Et.y), ae.restore();
          else {
            var Ft = Je[He];
            if (!Ft)
              return;
            for (var ai = ae.getImageData(
              Et.x,
              Et.y,
              Nt.width,
              Nt.height
            ), Mt = ai.data, Ae = nt.getImageData(
              0,
              0,
              Nt.width,
              Nt.height
            ).data, Fe = 0, tt = Mt.length; Fe < tt; Fe += 4) {
              X = Ae[Fe], ye = Mt[Fe], ne = Ae[Fe + 1], Me = Mt[Fe + 1], ue = Ae[Fe + 2], Ge = Mt[Fe + 2], Te = Ae[Fe + 3], Qe = Mt[Fe + 3], Ft();
              var Ct = Te * $e / 255, It = 1 - Ct;
              Mt[Fe] = Ct * re + It * ye, Mt[Fe + 1] = Ct * Se + It * Me, Mt[Fe + 2] = Ct * Pe + It * Ge, Mt[Fe + 3] = Te * $e + It * Qe;
            }
            ae.putImageData(ai, Et.x, Et.y);
          }
        };
      }(), Ie = new function() {
        var l = "http://www.w3.org/2000/svg", _ = "http://www.w3.org/2000/xmlns", I = "http://www.w3.org/1999/xlink", X = {
          href: I,
          xlink: _,
          xmlns: _ + "/",
          "xmlns:xlink": _ + "/"
        };
        function ne(ye, Me, Ge) {
          return Te(de.createElementNS(l, ye), Me, Ge);
        }
        function ue(ye, Me) {
          var Ge = X[Me], Qe = Ge ? ye.getAttributeNS(Ge, Me) : ye.getAttribute(Me);
          return Qe === "null" ? null : Qe;
        }
        function Te(ye, Me, Ge) {
          for (var Qe in Me) {
            var re = Me[Qe], Se = X[Qe];
            typeof re == "number" && Ge && (re = Ge.number(re)), Se ? ye.setAttributeNS(Se, Qe, re) : ye.setAttribute(Qe, re);
          }
          return ye;
        }
        return {
          svg: l,
          xmlns: _,
          xlink: I,
          create: ne,
          get: ue,
          set: Te
        };
      }(), pe = q.each({
        fillColor: ["fill", "color"],
        fillRule: ["fill-rule", "string"],
        strokeColor: ["stroke", "color"],
        strokeWidth: ["stroke-width", "number"],
        strokeCap: ["stroke-linecap", "string"],
        strokeJoin: ["stroke-linejoin", "string"],
        strokeScaling: ["vector-effect", "lookup", {
          true: "none",
          false: "non-scaling-stroke"
        }, function(l, _) {
          return !_ && (l instanceof we || l instanceof ee || l instanceof pt);
        }],
        miterLimit: ["stroke-miterlimit", "number"],
        dashArray: ["stroke-dasharray", "array"],
        dashOffset: ["stroke-dashoffset", "number"],
        fontFamily: ["font-family", "string"],
        fontWeight: ["font-weight", "string"],
        fontSize: ["font-size", "number"],
        justification: ["text-anchor", "lookup", {
          left: "start",
          center: "middle",
          right: "end"
        }],
        opacity: ["opacity", "number"],
        blendMode: ["mix-blend-mode", "style"]
      }, function(l, _) {
        var I = q.capitalize(_), X = l[2];
        this[_] = {
          type: l[1],
          property: _,
          attribute: l[0],
          toSVG: X,
          fromSVG: X && q.each(X, function(ne, ue) {
            this[ne] = ue;
          }, {}),
          exportFilter: l[3],
          get: "get" + I,
          set: "set" + I
        };
      }, {});
      new function() {
        var l;
        function _(Je, Xe, z) {
          var He = new q(), nt = Je.getTranslation();
          if (Xe) {
            var ae;
            Je.isInvertible() ? (Je = Je._shiftless(), ae = Je._inverseTransform(nt), nt = null) : ae = new x(), He[z ? "cx" : "x"] = ae.x, He[z ? "cy" : "y"] = ae.y;
          }
          if (!Je.isIdentity()) {
            var $e = Je.decompose();
            if ($e) {
              var Et = [], Nt = $e.rotation, Yt = $e.scaling, Ft = $e.skewing;
              nt && !nt.isZero() && Et.push("translate(" + l.point(nt) + ")"), Nt && Et.push("rotate(" + l.number(Nt) + ")"), (!A.isZero(Yt.x - 1) || !A.isZero(Yt.y - 1)) && Et.push("scale(" + l.point(Yt) + ")"), Ft.x && Et.push("skewX(" + l.number(Ft.x) + ")"), Ft.y && Et.push("skewY(" + l.number(Ft.y) + ")"), He.transform = Et.join(" ");
            } else
              He.transform = "matrix(" + Je.getValues().join(",") + ")";
          }
          return He;
        }
        function I(Je, Xe) {
          for (var z = _(Je._matrix), He = Je._children, nt = Ie.create("g", z, l), ae = 0, $e = He.length; ae < $e; ae++) {
            var Et = He[ae], Nt = Ze(Et, Xe);
            if (Nt)
              if (Et.isClipMask()) {
                var Yt = Ie.create("clipPath");
                Yt.appendChild(Nt), at(Et, Yt, "clip"), Ie.set(nt, {
                  "clip-path": "url(#" + Yt.id + ")"
                });
              } else
                nt.appendChild(Nt);
          }
          return nt;
        }
        function X(Je, Xe) {
          var z = _(Je._matrix, !0), He = Je.getSize(), nt = Je.getImage();
          return z.x -= He.width / 2, z.y -= He.height / 2, z.width = He.width, z.height = He.height, z.href = Xe.embedImages == !1 && nt && nt.src || Je.toDataURL(), Ie.create("image", z, l);
        }
        function ne(Je, Xe) {
          var z = Xe.matchShapes;
          if (z) {
            var He = Je.toShape(!1);
            if (He)
              return ue(He);
          }
          var nt = Je._segments, ae = nt.length, $e, Et = _(Je._matrix);
          if (z && ae >= 2 && !Je.hasHandles())
            if (ae > 2) {
              $e = Je._closed ? "polygon" : "polyline";
              for (var Nt = [], Yt = 0; Yt < ae; Yt++)
                Nt.push(l.point(nt[Yt]._point));
              Et.points = Nt.join(" ");
            } else {
              $e = "line";
              var Ft = nt[0]._point, ai = nt[1]._point;
              Et.set({
                x1: Ft.x,
                y1: Ft.y,
                x2: ai.x,
                y2: ai.y
              });
            }
          else
            $e = "path", Et.d = Je.getPathData(null, Xe.precision);
          return Ie.create($e, Et, l);
        }
        function ue(Je) {
          var Xe = Je._type, z = Je._radius, He = _(Je._matrix, !0, Xe !== "rectangle");
          if (Xe === "rectangle") {
            Xe = "rect";
            var nt = Je._size, ae = nt.width, $e = nt.height;
            He.x -= ae / 2, He.y -= $e / 2, He.width = ae, He.height = $e, z.isZero() && (z = null);
          }
          return z && (Xe === "circle" ? He.r = z : (He.rx = z.width, He.ry = z.height)), Ie.create(Xe, He, l);
        }
        function Te(Je, Xe) {
          var z = _(Je._matrix), He = Je.getPathData(null, Xe.precision);
          return He && (z.d = He), Ie.create("path", z, l);
        }
        function ye(Je, Xe) {
          var z = _(Je._matrix, !0), He = Je._definition, nt = Pe(He, "symbol"), ae = He._item, $e = ae.getStrokeBounds();
          return nt || (nt = Ie.create("symbol", {
            viewBox: l.rectangle($e)
          }), nt.appendChild(Ze(ae, Xe)), at(He, nt, "symbol")), z.href = "#" + nt.id, z.x += $e.x, z.y += $e.y, z.width = $e.width, z.height = $e.height, z.overflow = "visible", Ie.create("use", z, l);
        }
        function Me(Je) {
          var Xe = Pe(Je, "color");
          if (!Xe) {
            var z = Je.getGradient(), He = z._radial, nt = Je.getOrigin(), ae = Je.getDestination(), $e;
            if (He) {
              $e = {
                cx: nt.x,
                cy: nt.y,
                r: nt.getDistance(ae)
              };
              var Et = Je.getHighlight();
              Et && ($e.fx = Et.x, $e.fy = Et.y);
            } else
              $e = {
                x1: nt.x,
                y1: nt.y,
                x2: ae.x,
                y2: ae.y
              };
            $e.gradientUnits = "userSpaceOnUse", Xe = Ie.create((He ? "radial" : "linear") + "Gradient", $e, l);
            for (var Nt = z._stops, Yt = 0, Ft = Nt.length; Yt < Ft; Yt++) {
              var ai = Nt[Yt], Mt = ai._color, Ae = Mt.getAlpha(), Fe = ai._offset;
              $e = {
                offset: Fe ?? Yt / (Ft - 1)
              }, Mt && ($e["stop-color"] = Mt.toCSS(!0)), Ae < 1 && ($e["stop-opacity"] = Ae), Xe.appendChild(
                Ie.create("stop", $e, l)
              );
            }
            at(Je, Xe, "color");
          }
          return "url(#" + Xe.id + ")";
        }
        function Ge(Je) {
          var Xe = Ie.create(
            "text",
            _(Je._matrix, !0),
            l
          );
          return Xe.textContent = Je._content, Xe;
        }
        var Qe = {
          Group: I,
          Layer: I,
          Raster: X,
          Path: ne,
          Shape: ue,
          CompoundPath: Te,
          SymbolItem: ye,
          PointText: Ge
        };
        function re(Je, Xe, z, He) {
          var nt = {}, ae = !He && Je.getParent(), $e = [];
          return Je._name != null && (nt.id = Je._name), q.each(pe, function(Et) {
            var Nt = Et.get, Yt = Et.type, Ft = Je[Nt]();
            if (Et.exportFilter ? Et.exportFilter(Je, Ft) : z.reduceAttributes == !1 || !ae || !q.equals(ae[Nt](), Ft)) {
              if (Yt === "color" && Ft != null) {
                var ai = Ft.getAlpha();
                ai < 1 && (nt[Et.attribute + "-opacity"] = ai);
              }
              Yt === "style" ? $e.push(Et.attribute + ": " + Ft) : nt[Et.attribute] = Ft == null ? "none" : Yt === "color" ? Ft.gradient ? Me(Ft) : Ft.toCSS(!0) : Yt === "array" ? Ft.join(",") : Yt === "lookup" ? Et.toSVG[Ft] : Ft;
            }
          }), $e.length && (nt.style = $e.join(";")), nt.opacity === 1 && delete nt.opacity, Je._visible || (nt.visibility = "hidden"), Ie.set(Xe, nt, l);
        }
        var Se;
        function Pe(Je, Xe) {
          return Se || (Se = { ids: {}, svgs: {} }), Je && Se.svgs[Xe + "-" + (Je._id || Je.__id || (Je.__id = M.get("svg")))];
        }
        function at(Je, Xe, z) {
          Se || Pe();
          var He = Se.ids[z] = (Se.ids[z] || 0) + 1;
          Xe.id = z + "-" + He, Se.svgs[z + "-" + (Je._id || Je.__id)] = Xe;
        }
        function Be(Je, Xe) {
          var z = Je, He = null;
          if (Se) {
            z = Je.nodeName.toLowerCase() === "svg" && Je;
            for (var nt in Se.svgs)
              He || (z || (z = Ie.create("svg"), z.appendChild(Je)), He = z.insertBefore(
                Ie.create("defs"),
                z.firstChild
              )), He.appendChild(Se.svgs[nt]);
            Se = null;
          }
          return Xe.asString ? new Tt.XMLSerializer().serializeToString(z) : z;
        }
        function Ze(Je, Xe, z) {
          var He = Qe[Je._class], nt = He && He(Je, Xe);
          if (nt) {
            var ae = Xe.onExport;
            ae && (nt = ae(Je, nt, Xe) || nt);
            var $e = JSON.stringify(Je._data);
            $e && $e !== "{}" && $e !== "null" && nt.setAttribute("data-paper-data", $e);
          }
          return nt && re(Je, nt, Xe, z);
        }
        function fe(Je) {
          return Je || (Je = {}), l = new R(Je.precision), Je;
        }
        T.inject({
          exportSVG: function(Je) {
            return Je = fe(Je), Be(Ze(this, Je, !0), Je);
          }
        }), j.inject({
          exportSVG: function(Je) {
            Je = fe(Je);
            var Xe = this._children, z = this.getView(), He = q.pick(Je.bounds, "view"), nt = Je.matrix || He === "view" && z._matrix, ae = nt && S.read([nt]), $e = He === "view" ? new E([0, 0], z.getViewSize()) : He === "content" ? T._getBounds(Xe, ae, { stroke: !0 }).rect : E.read([He], 0, { readNull: !0 }), Et = {
              version: "1.1",
              xmlns: Ie.svg,
              "xmlns:xlink": Ie.xlink
            };
            $e && (Et.width = $e.width, Et.height = $e.height, ($e.x || $e.x === 0 || $e.y || $e.y === 0) && (Et.viewBox = l.rectangle($e)));
            var Nt = Ie.create("svg", Et, l), Yt = Nt;
            ae && !ae.isIdentity() && (Yt = Nt.appendChild(Ie.create(
              "g",
              _(ae),
              l
            )));
            for (var Ft = 0, ai = Xe.length; Ft < ai; Ft++)
              Yt.appendChild(Ze(Xe[Ft], Je, !0));
            return Be(Nt, Je);
          }
        });
      }(), new function() {
        var l = {}, _;
        function I(Xe, z, He, nt, ae, $e) {
          var Et = Ie.get(Xe, z) || $e, Nt = Et == null ? nt ? null : He ? "" : 0 : He ? Et : parseFloat(Et);
          return /%\s*$/.test(Et) ? Nt / 100 * (ae ? 1 : _[/x|^width/.test(z) ? "width" : "height"]) : Nt;
        }
        function X(Xe, z, He, nt, ae, $e, Et) {
          return z = I(Xe, z || "x", !1, nt, ae, $e), He = I(Xe, He || "y", !1, nt, ae, Et), nt && (z == null || He == null) ? null : new x(z, He);
        }
        function ne(Xe, z, He, nt, ae) {
          return z = I(Xe, z || "width", !1, nt, ae), He = I(Xe, He || "height", !1, nt, ae), nt && (z == null || He == null) ? null : new w(z, He);
        }
        function ue(Xe, z, He) {
          return Xe === "none" ? null : z === "number" ? parseFloat(Xe) : z === "array" ? Xe ? Xe.split(/[\s,]+/g).map(parseFloat) : [] : z === "color" ? Ze(Xe) || Xe : z === "lookup" ? He[Xe] : Xe;
        }
        function Te(Xe, z, He, nt) {
          var ae = Xe.childNodes, $e = z === "clippath", Et = z === "defs", Nt = new W(), Yt = Nt._project, Ft = Yt._currentStyle, ai = [];
          if (!$e && !Et && (Nt = Be(Nt, Xe, nt), Yt._currentStyle = Nt._style.clone()), nt)
            for (var Mt = Xe.querySelectorAll("defs"), Ae = 0, Fe = Mt.length; Ae < Fe; Ae++)
              fe(Mt[Ae], He, !1);
          for (var Ae = 0, Fe = ae.length; Ae < Fe; Ae++) {
            var tt = ae[Ae], Ct;
            tt.nodeType === 1 && !/^defs$/i.test(tt.nodeName) && (Ct = fe(tt, He, !1)) && !(Ct instanceof me) && ai.push(Ct);
          }
          return Nt.addChildren(ai), $e && (Nt = Be(Nt.reduce(), Xe, nt)), Yt._currentStyle = Ft, ($e || Et) && (Nt.remove(), Nt = null), Nt;
        }
        function ye(Xe, z) {
          for (var He = Xe.getAttribute("points").match(
            /[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g
          ), nt = [], ae = 0, $e = He.length; ae < $e; ae += 2)
            nt.push(new x(
              parseFloat(He[ae]),
              parseFloat(He[ae + 1])
            ));
          var Et = new Ce(nt);
          return z === "polygon" && Et.closePath(), Et;
        }
        function Me(Xe) {
          return we.create(Xe.getAttribute("d"));
        }
        function Ge(Xe, z) {
          var He = (I(Xe, "href", !0) || "").substring(1), nt = z === "radialgradient", ae;
          if (He)
            ae = l[He].getGradient(), ae._radial ^ nt && (ae = ae.clone(), ae._radial = nt);
          else {
            for (var $e = Xe.childNodes, Et = [], Nt = 0, Yt = $e.length; Nt < Yt; Nt++) {
              var Ft = $e[Nt];
              Ft.nodeType === 1 && Et.push(Be(new wt(), Ft));
            }
            ae = new ct(Et, nt);
          }
          var ai, Mt, Ae, Fe = I(Xe, "gradientUnits", !0) !== "userSpaceOnUse";
          nt ? (ai = X(
            Xe,
            "cx",
            "cy",
            !1,
            Fe,
            "50%",
            "50%"
          ), Mt = ai.add(
            I(Xe, "r", !1, !1, Fe, "50%"),
            0
          ), Ae = X(Xe, "fx", "fy", !0, Fe)) : (ai = X(
            Xe,
            "x1",
            "y1",
            !1,
            Fe,
            "0%",
            "0%"
          ), Mt = X(
            Xe,
            "x2",
            "y2",
            !1,
            Fe,
            "100%",
            "0%"
          ));
          var tt = Be(
            new dt(ae, ai, Mt, Ae),
            Xe
          );
          return tt._scaleToBounds = Fe, null;
        }
        var Qe = {
          "#document": function(Xe, z, He, nt) {
            for (var ae = Xe.childNodes, $e = 0, Et = ae.length; $e < Et; $e++) {
              var Nt = ae[$e];
              if (Nt.nodeType === 1)
                return fe(Nt, He, nt);
            }
          },
          g: Te,
          svg: Te,
          clippath: Te,
          polygon: ye,
          polyline: ye,
          path: Me,
          lineargradient: Ge,
          radialgradient: Ge,
          image: function(Xe) {
            var z = new te(I(Xe, "href", !0));
            return z.on("load", function() {
              var He = ne(Xe);
              this.setSize(He);
              var nt = X(Xe).add(He.divide(2));
              this._matrix.append(new S().translate(nt));
            }), z;
          },
          symbol: function(Xe, z, He, nt) {
            return new me(
              Te(Xe, z, He, nt),
              !0
            );
          },
          defs: Te,
          use: function(Xe) {
            var z = (I(Xe, "href", !0) || "").substring(1), He = l[z], nt = X(Xe);
            return He ? He instanceof me ? He.place(nt) : He.clone().translate(nt) : null;
          },
          circle: function(Xe) {
            return new ee.Circle(
              X(Xe, "cx", "cy"),
              I(Xe, "r")
            );
          },
          ellipse: function(Xe) {
            return new ee.Ellipse({
              center: X(Xe, "cx", "cy"),
              radius: ne(Xe, "rx", "ry")
            });
          },
          rect: function(Xe) {
            return new ee.Rectangle(new E(
              X(Xe),
              ne(Xe)
            ), ne(Xe, "rx", "ry"));
          },
          line: function(Xe) {
            return new Ce.Line(
              X(Xe, "x1", "y1"),
              X(Xe, "x2", "y2")
            );
          },
          text: function(Xe) {
            var z = new Ke(X(Xe).add(
              X(Xe, "dx", "dy")
            ));
            return z.setContent(Xe.textContent.trim() || ""), z;
          },
          switch: Te
        };
        function re(Xe, z, He, nt) {
          if (Xe.transform) {
            for (var ae = (nt.getAttribute(He) || "").split(/\)\s*/g), $e = new S(), Et = 0, Nt = ae.length; Et < Nt; Et++) {
              var Yt = ae[Et];
              if (!Yt)
                break;
              for (var Ft = Yt.split(/\(\s*/), ai = Ft[0].trim(), Mt = Ft[1].split(/[\s,]+/g), Ae = 0, Fe = Mt.length; Ae < Fe; Ae++)
                Mt[Ae] = parseFloat(Mt[Ae]);
              switch (ai) {
                case "matrix":
                  $e.append(
                    new S(Mt[0], Mt[1], Mt[2], Mt[3], Mt[4], Mt[5])
                  );
                  break;
                case "rotate":
                  $e.rotate(Mt[0], Mt[1] || 0, Mt[2] || 0);
                  break;
                case "translate":
                  $e.translate(Mt[0], Mt[1] || 0);
                  break;
                case "scale":
                  $e.scale(Mt);
                  break;
                case "skewX":
                  $e.skew(Mt[0], 0);
                  break;
                case "skewY":
                  $e.skew(0, Mt[0]);
                  break;
              }
            }
            Xe.transform($e);
          }
        }
        function Se(Xe, z, He) {
          var nt = He === "fill-opacity" ? "getFillColor" : "getStrokeColor", ae = Xe[nt] && Xe[nt]();
          ae && ae.setAlpha(parseFloat(z));
        }
        var Pe = q.set(q.each(pe, function(Xe) {
          this[Xe.attribute] = function(z, He) {
            if (z[Xe.set] && (z[Xe.set](ue(He, Xe.type, Xe.fromSVG)), Xe.type === "color")) {
              var nt = z[Xe.get]();
              if (nt && nt._scaleToBounds) {
                var ae = z.getBounds();
                nt.transform(new S().translate(ae.getPoint()).scale(ae.getSize()));
              }
            }
          };
        }, {}), {
          id: function(Xe, z) {
            l[z] = Xe, Xe.setName && Xe.setName(z);
          },
          "clip-path": function(Xe, z) {
            var He = Ze(z);
            if (He)
              if (He = He.clone(), He.setClipMask(!0), Xe instanceof W)
                Xe.insertChild(0, He);
              else
                return new W(He, Xe);
          },
          gradientTransform: re,
          transform: re,
          "fill-opacity": Se,
          "stroke-opacity": Se,
          visibility: function(Xe, z) {
            Xe.setVisible && Xe.setVisible(z === "visible");
          },
          display: function(Xe, z) {
            Xe.setVisible && Xe.setVisible(z !== null);
          },
          "stop-color": function(Xe, z) {
            Xe.setColor && Xe.setColor(z);
          },
          "stop-opacity": function(Xe, z) {
            Xe._color && Xe._color.setAlpha(parseFloat(z));
          },
          offset: function(Xe, z) {
            if (Xe.setOffset) {
              var He = z.match(/(.*)%$/);
              Xe.setOffset(He ? He[1] / 100 : parseFloat(z));
            }
          },
          viewBox: function(Xe, z, He, nt, ae) {
            var $e = new E(ue(z, "array")), Et = ne(nt, null, null, !0), Nt, Yt;
            if (Xe instanceof W) {
              var Ft = Et ? Et.divide($e.getSize()) : 1, Yt = new S().scale(Ft).translate($e.getPoint().negate());
              Nt = Xe;
            } else Xe instanceof me && (Et && $e.setSize(Et), Nt = Xe._item);
            if (Nt) {
              if (at(nt, "overflow", ae) !== "visible") {
                var ai = new ee.Rectangle($e);
                ai.setClipMask(!0), Nt.addChild(ai);
              }
              Yt && Nt.transform(Yt);
            }
          }
        });
        function at(Xe, z, He) {
          var nt = Xe.attributes[z], ae = nt && nt.value;
          if (!ae && Xe.style) {
            var $e = q.camelize(z);
            ae = Xe.style[$e], !ae && He.node[$e] !== He.parent[$e] && (ae = He.node[$e]);
          }
          return ae ? ae === "none" ? null : ae : qe;
        }
        function Be(Xe, z, He) {
          var nt = z.parentNode, ae = {
            node: $t.getStyles(z) || {},
            parent: !He && !/^defs$/i.test(nt.tagName) && $t.getStyles(nt) || {}
          };
          return q.each(Pe, function($e, Et) {
            var Nt = at(z, Et, ae);
            Xe = Nt !== qe && $e(Xe, Nt, Et, z, ae) || Xe;
          }), Xe;
        }
        function Ze(Xe) {
          var z = Xe && Xe.match(/\((?:["'#]*)([^"')]+)/), He = z && z[1], nt = He && l[Q ? He.replace(Q.location.href.split("#")[0] + "#", "") : He];
          return nt && nt._scaleToBounds && (nt = nt.clone(), nt._scaleToBounds = !0), nt;
        }
        function fe(Xe, z, He) {
          var nt = Xe.nodeName.toLowerCase(), ae = nt !== "#document", $e = de.body, Et, Nt, Yt;
          He && ae && (_ = xt.getView().getSize(), _ = ne(Xe, null, null, !0) || _, Et = Ie.create("svg", {
            style: "stroke-width: 1px; stroke-miterlimit: 10"
          }), Nt = Xe.parentNode, Yt = Xe.nextSibling, Et.appendChild(Xe), $e.appendChild(Et));
          var Ft = xt.settings, ai = Ft.applyMatrix, Mt = Ft.insertItems;
          Ft.applyMatrix = !1, Ft.insertItems = !1;
          var Ae = Qe[nt], Fe = Ae && Ae(Xe, nt, z, He) || null;
          if (Ft.insertItems = Mt, Ft.applyMatrix = ai, Fe) {
            ae && !(Fe instanceof W) && (Fe = Be(Fe, Xe, He));
            var tt = z.onImport, Ct = ae && Xe.getAttribute("data-paper-data");
            tt && (Fe = tt(Xe, Fe, z) || Fe), z.expandShapes && Fe instanceof ee && (Fe.remove(), Fe = Fe.toPath()), Ct && (Fe._data = JSON.parse(Ct));
          }
          return Et && ($e.removeChild(Et), Nt && (Yt ? Nt.insertBefore(Xe, Yt) : Nt.appendChild(Xe))), He && (l = {}, Fe && q.pick(z.applyMatrix, ai) && Fe.matrix.apply(!0, !0)), Fe;
        }
        function Je(Xe, z, He) {
          if (!Xe)
            return null;
          z = typeof z == "function" ? { onLoad: z } : z || {};
          var nt = xt, ae = null;
          function $e(Ft) {
            try {
              var ai = typeof Ft == "object" ? Ft : new Tt.DOMParser().parseFromString(
                Ft.trim(),
                "image/svg+xml"
              );
              if (!ai.nodeName)
                throw ai = null, new Error("Unsupported SVG source: " + Xe);
              xt = nt, ae = fe(ai, z, !0), (!z || z.insert !== !1) && He._insertItem(qe, ae);
              var Mt = z.onLoad;
              Mt && Mt(ae, Ft);
            } catch (Ae) {
              Et(Ae);
            }
          }
          function Et(Ft, ai) {
            var Mt = z.onError;
            if (Mt)
              Mt(Ft, ai);
            else
              throw new Error(Ft);
          }
          if (typeof Xe == "string" && !/^[\s\S]*</.test(Xe)) {
            var Nt = de.getElementById(Xe);
            Nt ? $e(Nt) : Re.request({
              url: Xe,
              async: !0,
              onLoad: $e,
              onError: Et
            });
          } else if (typeof File < "u" && Xe instanceof File) {
            var Yt = new FileReader();
            return Yt.onload = function() {
              $e(Yt.result);
            }, Yt.onerror = function() {
              Et(Yt.error);
            }, Yt.readAsText(Xe);
          } else
            $e(Xe);
          return ae;
        }
        T.inject({
          importSVG: function(Xe, z) {
            return Je(Xe, z, this);
          }
        }), j.inject({
          importSVG: function(Xe, z) {
            return this.activate(), Je(Xe, z, this);
          }
        });
      }(), q.exports.PaperScript = (function() {
        var l = this, _ = l.acorn;
        if (!_ && typeof rp < "u")
          try {
            _ = y2();
          } catch {
          }
        if (!_) {
          var I, X;
          _ = I = X = {}, function(Be, Ze) {
            if (typeof I == "object" && typeof X == "object") return Ze(I);
            if (typeof qe == "function" && qe.amd) return qe(["exports"], Ze);
            Ze(Be.acorn || (Be.acorn = {}));
          }(this, function(Be) {
            Be.version = "0.5.0";
            var Ze, fe, Je, Xe;
            Be.parse = function(vi, Ci) {
              return fe = String(vi), Je = fe.length, He(Ci), Gs(), uu(Ze.program);
            };
            var z = Be.defaultOptions = {
              ecmaVersion: 5,
              strictSemicolons: !1,
              allowTrailingCommas: !0,
              forbidReserved: !1,
              allowReturnOutsideFunction: !1,
              locations: !1,
              onComment: null,
              ranges: !1,
              program: null,
              sourceFile: null,
              directSourceFile: null
            };
            function He(vi) {
              Ze = vi || {};
              for (var Ci in z) Object.prototype.hasOwnProperty.call(Ze, Ci) || (Ze[Ci] = z[Ci]);
              Xe = Ze.sourceFile || null;
            }
            var nt = Be.getLineInfo = function(vi, Ci) {
              for (var Xi = 1, sr = 0; ; ) {
                qn.lastIndex = sr;
                var rn = qn.exec(vi);
                if (rn && rn.index < Ci)
                  ++Xi, sr = rn.index + rn[0].length;
                else break;
              }
              return { line: Xi, column: Ci - sr };
            };
            Be.tokenize = function(vi, Ci) {
              fe = String(vi), Je = fe.length, He(Ci), Gs();
              var Xi = {};
              function sr(rn) {
                return Ct = Et, ul(rn), Xi.start = $e, Xi.end = Et, Xi.startLoc = Nt, Xi.endLoc = Yt, Xi.type = Ft, Xi.value = ai, Xi;
              }
              return sr.jumpTo = function(rn, Hr) {
                if (ae = rn, Ze.locations) {
                  Ae = 1, Fe = qn.lastIndex = 0;
                  for (var on; (on = qn.exec(fe)) && on.index < rn; )
                    ++Ae, Fe = on.index + on[0].length;
                }
                Mt = Hr, to();
              }, sr;
            };
            var ae, $e, Et, Nt, Yt, Ft, ai, Mt, Ae, Fe, tt, Ct, It, Ut, ti, Pt;
            function Wt(vi, Ci) {
              var Xi = nt(fe, vi);
              Ci += " (" + Xi.line + ":" + Xi.column + ")";
              var sr = new SyntaxError(Ci);
              throw sr.pos = vi, sr.loc = Xi, sr.raisedAt = ae, sr;
            }
            var ei = [], oi = { type: "num" }, _i = { type: "regexp" }, Di = { type: "string" }, Bi = { type: "name" }, Hi = { type: "eof" }, nr = { keyword: "break" }, rr = { keyword: "case", beforeExpr: !0 }, dr = { keyword: "catch" }, Rr = { keyword: "continue" }, Br = { keyword: "debugger" }, Ki = { keyword: "default" }, Ir = { keyword: "do", isLoop: !0 }, Mr = { keyword: "else", beforeExpr: !0 }, wn = { keyword: "finally" }, xn = { keyword: "for", isLoop: !0 }, En = { keyword: "function" }, Vn = { keyword: "if" }, Yn = { keyword: "return", beforeExpr: !0 }, ka = { keyword: "switch" }, ea = { keyword: "throw", beforeExpr: !0 }, ga = { keyword: "try" }, Ta = { keyword: "var" }, ha = { keyword: "while", isLoop: !0 }, Bo = { keyword: "with" }, Ao = { keyword: "new", beforeExpr: !0 }, za = { keyword: "this" }, ss = { keyword: "null", atomValue: null }, os = { keyword: "true", atomValue: !0 }, Ms = { keyword: "false", atomValue: !1 }, La = { keyword: "in", binop: 7, beforeExpr: !0 }, mn = {
              break: nr,
              case: rr,
              catch: dr,
              continue: Rr,
              debugger: Br,
              default: Ki,
              do: Ir,
              else: Mr,
              finally: wn,
              for: xn,
              function: En,
              if: Vn,
              return: Yn,
              switch: ka,
              throw: ea,
              try: ga,
              var: Ta,
              while: ha,
              with: Bo,
              null: ss,
              true: os,
              false: Ms,
              new: Ao,
              in: La,
              instanceof: { keyword: "instanceof", binop: 7, beforeExpr: !0 },
              this: za,
              typeof: { keyword: "typeof", prefix: !0, beforeExpr: !0 },
              void: { keyword: "void", prefix: !0, beforeExpr: !0 },
              delete: { keyword: "delete", prefix: !0, beforeExpr: !0 }
            }, eo = { type: "[", beforeExpr: !0 }, mo = { type: "]" }, Ba = { type: "{", beforeExpr: !0 }, tn = { type: "}" }, ys = { type: "(", beforeExpr: !0 }, Qa = { type: ")" }, fa = { type: ",", beforeExpr: !0 }, Wr = { type: ";", beforeExpr: !0 }, es = { type: ":", beforeExpr: !0 }, Tr = { type: "." }, Is = { type: "?", beforeExpr: !0 }, D = { binop: 10, beforeExpr: !0 }, be = { isAssign: !0, beforeExpr: !0 }, ht = { isAssign: !0, beforeExpr: !0 }, Ot = { postfix: !0, prefix: !0, isUpdate: !0 }, hi = { prefix: !0, beforeExpr: !0 }, di = { binop: 1, beforeExpr: !0 }, ki = { binop: 2, beforeExpr: !0 }, er = { binop: 3, beforeExpr: !0 }, _r = { binop: 4, beforeExpr: !0 }, en = { binop: 5, beforeExpr: !0 }, br = { binop: 6, beforeExpr: !0 }, Gn = { binop: 7, beforeExpr: !0 }, Ia = { binop: 8, beforeExpr: !0 }, ls = { binop: 9, prefix: !0, beforeExpr: !0 }, Hn = { binop: 10, beforeExpr: !0 };
            Be.tokTypes = {
              bracketL: eo,
              bracketR: mo,
              braceL: Ba,
              braceR: tn,
              parenL: ys,
              parenR: Qa,
              comma: fa,
              semi: Wr,
              colon: es,
              dot: Tr,
              question: Is,
              slash: D,
              eq: be,
              name: Bi,
              eof: Hi,
              num: oi,
              regexp: _i,
              string: Di
            };
            for (var Dn in mn) Be.tokTypes["_" + Dn] = mn[Dn];
            function xs(vi) {
              vi = vi.split(" ");
              var Ci = "", Xi = [];
              e: for (var sr = 0; sr < vi.length; ++sr) {
                for (var rn = 0; rn < Xi.length; ++rn)
                  if (Xi[rn][0].length == vi[sr].length) {
                    Xi[rn].push(vi[sr]);
                    continue e;
                  }
                Xi.push([vi[sr]]);
              }
              function Hr(Mn) {
                if (Mn.length == 1) return Ci += "return str === " + JSON.stringify(Mn[0]) + ";";
                Ci += "switch(str){";
                for (var Va = 0; Va < Mn.length; ++Va) Ci += "case " + JSON.stringify(Mn[Va]) + ":";
                Ci += "return true}return false;";
              }
              if (Xi.length > 3) {
                Xi.sort(function(Mn, Va) {
                  return Va.length - Mn.length;
                }), Ci += "switch(str.length){";
                for (var sr = 0; sr < Xi.length; ++sr) {
                  var on = Xi[sr];
                  Ci += "case " + on[0].length + ":", Hr(on);
                }
                Ci += "}";
              } else
                Hr(vi);
              return new Function("str", Ci);
            }
            var va = xs("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"), sl = xs("class enum extends super const export import"), Fo = xs("implements interface let package private protected public static yield"), No = xs("eval arguments"), Vs = xs("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"), Na = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/, bs = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", Ua = "------------------------------------------------------------------------------------------------------------------------------------------", ol = new RegExp("[" + bs + "]"), js = new RegExp("[" + bs + Ua + "]"), Nn = /[\n\r\u2028\u2029]/, qn = /\r\n|[\n\r\u2028\u2029]/g, ta = Be.isIdentifierStart = function(vi) {
              return vi < 65 ? vi === 36 : vi < 91 ? !0 : vi < 97 ? vi === 95 : vi < 123 ? !0 : vi >= 170 && ol.test(String.fromCharCode(vi));
            }, ia = Be.isIdentifierChar = function(vi) {
              return vi < 48 ? vi === 36 : vi < 58 ? !0 : vi < 65 ? !1 : vi < 91 ? !0 : vi < 97 ? vi === 95 : vi < 123 ? !0 : vi >= 170 && js.test(String.fromCharCode(vi));
            };
            function ps() {
              this.line = Ae, this.column = ae - Fe;
            }
            function Gs() {
              Ae = 1, ae = Fe = 0, Mt = !0, to();
            }
            function aa(vi, Ci) {
              Et = ae, Ze.locations && (Yt = new ps()), Ft = vi, to(), ai = Ci, Mt = vi.beforeExpr;
            }
            function ll() {
              var vi = Ze.onComment && Ze.locations && new ps(), Ci = ae, Xi = fe.indexOf("*/", ae += 2);
              if (Xi === -1 && Wt(ae - 2, "Unterminated comment"), ae = Xi + 2, Ze.locations) {
                qn.lastIndex = Ci;
                for (var sr; (sr = qn.exec(fe)) && sr.index < ae; )
                  ++Ae, Fe = sr.index + sr[0].length;
              }
              Ze.onComment && Ze.onComment(
                !0,
                fe.slice(Ci + 2, Xi),
                Ci,
                ae,
                vi,
                Ze.locations && new ps()
              );
            }
            function ts() {
              for (var vi = ae, Ci = Ze.onComment && Ze.locations && new ps(), Xi = fe.charCodeAt(ae += 2); ae < Je && Xi !== 10 && Xi !== 13 && Xi !== 8232 && Xi !== 8233; )
                ++ae, Xi = fe.charCodeAt(ae);
              Ze.onComment && Ze.onComment(
                !1,
                fe.slice(vi + 2, ae),
                vi,
                ae,
                Ci,
                Ze.locations && new ps()
              );
            }
            function to() {
              for (; ae < Je; ) {
                var vi = fe.charCodeAt(ae);
                if (vi === 32)
                  ++ae;
                else if (vi === 13) {
                  ++ae;
                  var Ci = fe.charCodeAt(ae);
                  Ci === 10 && ++ae, Ze.locations && (++Ae, Fe = ae);
                } else if (vi === 10 || vi === 8232 || vi === 8233)
                  ++ae, Ze.locations && (++Ae, Fe = ae);
                else if (vi > 8 && vi < 14)
                  ++ae;
                else if (vi === 47) {
                  var Ci = fe.charCodeAt(ae + 1);
                  if (Ci === 42)
                    ll();
                  else if (Ci === 47)
                    ts();
                  else break;
                } else if (vi === 160)
                  ++ae;
                else if (vi >= 5760 && Na.test(String.fromCharCode(vi)))
                  ++ae;
                else
                  break;
              }
            }
            function _o() {
              var vi = fe.charCodeAt(ae + 1);
              return vi >= 48 && vi <= 57 ? $u(!0) : (++ae, aa(Tr));
            }
            function Yh() {
              var vi = fe.charCodeAt(ae + 1);
              return Mt ? (++ae, kl()) : vi === 61 ? Ca(ht, 2) : Ca(D, 1);
            }
            function Mc() {
              var vi = fe.charCodeAt(ae + 1);
              return vi === 61 ? Ca(ht, 2) : Ca(Hn, 1);
            }
            function ms(vi) {
              var Ci = fe.charCodeAt(ae + 1);
              return Ci === vi ? Ca(vi === 124 ? di : ki, 2) : Ci === 61 ? Ca(ht, 2) : Ca(vi === 124 ? er : en, 1);
            }
            function au() {
              var vi = fe.charCodeAt(ae + 1);
              return vi === 61 ? Ca(ht, 2) : Ca(_r, 1);
            }
            function Zu(vi) {
              var Ci = fe.charCodeAt(ae + 1);
              return Ci === vi ? Ci == 45 && fe.charCodeAt(ae + 2) == 62 && Nn.test(fe.slice(Ct, ae)) ? (ae += 3, ts(), to(), ul()) : Ca(Ot, 2) : Ci === 61 ? Ca(ht, 2) : Ca(ls, 1);
            }
            function su(vi) {
              var Ci = fe.charCodeAt(ae + 1), Xi = 1;
              return Ci === vi ? (Xi = vi === 62 && fe.charCodeAt(ae + 2) === 62 ? 3 : 2, fe.charCodeAt(ae + Xi) === 61 ? Ca(ht, Xi + 1) : Ca(Ia, Xi)) : Ci == 33 && vi == 60 && fe.charCodeAt(ae + 2) == 45 && fe.charCodeAt(ae + 3) == 45 ? (ae += 4, ts(), to(), ul()) : (Ci === 61 && (Xi = fe.charCodeAt(ae + 2) === 61 ? 3 : 2), Ca(Gn, Xi));
            }
            function ou(vi) {
              var Ci = fe.charCodeAt(ae + 1);
              return Ci === 61 ? Ca(br, fe.charCodeAt(ae + 2) === 61 ? 3 : 2) : Ca(vi === 61 ? be : hi, 1);
            }
            function Kh(vi) {
              switch (vi) {
                case 46:
                  return _o();
                case 40:
                  return ++ae, aa(ys);
                case 41:
                  return ++ae, aa(Qa);
                case 59:
                  return ++ae, aa(Wr);
                case 44:
                  return ++ae, aa(fa);
                case 91:
                  return ++ae, aa(eo);
                case 93:
                  return ++ae, aa(mo);
                case 123:
                  return ++ae, aa(Ba);
                case 125:
                  return ++ae, aa(tn);
                case 58:
                  return ++ae, aa(es);
                case 63:
                  return ++ae, aa(Is);
                case 48:
                  var Ci = fe.charCodeAt(ae + 1);
                  if (Ci === 120 || Ci === 88) return Ll();
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  return $u(!1);
                case 34:
                case 39:
                  return io(vi);
                case 47:
                  return Yh();
                case 37:
                case 42:
                  return Mc();
                case 124:
                case 38:
                  return ms(vi);
                case 94:
                  return au();
                case 43:
                case 45:
                  return Zu(vi);
                case 60:
                case 62:
                  return su(vi);
                case 61:
                case 33:
                  return ou(vi);
                case 126:
                  return Ca(hi, 1);
              }
              return !1;
            }
            function ul(vi) {
              if (vi ? ae = $e + 1 : $e = ae, Ze.locations && (Nt = new ps()), vi) return kl();
              if (ae >= Je) return aa(Hi);
              var Ci = fe.charCodeAt(ae);
              if (ta(Ci) || Ci === 92) return Ic();
              var Xi = Kh(Ci);
              if (Xi === !1) {
                var sr = String.fromCharCode(Ci);
                if (sr === "\\" || ol.test(sr)) return Ic();
                Wt(ae, "Unexpected character '" + sr + "'");
              }
              return Xi;
            }
            function Ca(vi, Ci) {
              var Xi = fe.slice(ae, ae + Ci);
              ae += Ci, aa(vi, Xi);
            }
            function kl() {
              for (var rn = "", vi, Ci, Xi = ae; ; ) {
                ae >= Je && Wt(Xi, "Unterminated regular expression");
                var sr = fe.charAt(ae);
                if (Nn.test(sr) && Wt(Xi, "Unterminated regular expression"), vi)
                  vi = !1;
                else {
                  if (sr === "[") Ci = !0;
                  else if (sr === "]" && Ci) Ci = !1;
                  else if (sr === "/" && !Ci) break;
                  vi = sr === "\\";
                }
                ++ae;
              }
              var rn = fe.slice(Xi, ae);
              ++ae;
              var Hr = Xu();
              Hr && !/^[gmsiy]*$/.test(Hr) && Wt(Xi, "Invalid regexp flag");
              try {
                var on = new RegExp(rn, Hr);
              } catch (Mn) {
                Mn instanceof SyntaxError && Wt(Xi, Mn.message), Wt(Mn);
              }
              return aa(_i, on);
            }
            function lu(vi, Ci) {
              for (var Xi = ae, sr = 0, rn = 0, Hr = Ci ?? 1 / 0; rn < Hr; ++rn) {
                var on = fe.charCodeAt(ae), Mn;
                if (on >= 97 ? Mn = on - 97 + 10 : on >= 65 ? Mn = on - 65 + 10 : on >= 48 && on <= 57 ? Mn = on - 48 : Mn = 1 / 0, Mn >= vi) break;
                ++ae, sr = sr * vi + Mn;
              }
              return ae === Xi || Ci != null && ae - Xi !== Ci ? null : sr;
            }
            function Ll() {
              ae += 2;
              var vi = lu(16);
              return vi == null && Wt($e + 2, "Expected hexadecimal number"), ta(fe.charCodeAt(ae)) && Wt(ae, "Identifier directly after number"), aa(oi, vi);
            }
            function $u(vi) {
              var Ci = ae, Xi = !1, sr = fe.charCodeAt(ae) === 48;
              !vi && lu(10) === null && Wt(Ci, "Invalid number"), fe.charCodeAt(ae) === 46 && (++ae, lu(10), Xi = !0);
              var rn = fe.charCodeAt(ae);
              (rn === 69 || rn === 101) && (rn = fe.charCodeAt(++ae), (rn === 43 || rn === 45) && ++ae, lu(10) === null && Wt(Ci, "Invalid number"), Xi = !0), ta(fe.charCodeAt(ae)) && Wt(ae, "Identifier directly after number");
              var Hr = fe.slice(Ci, ae), on;
              return Xi ? on = parseFloat(Hr) : !sr || Hr.length === 1 ? on = parseInt(Hr, 10) : /[89]/.test(Hr) || Pt ? Wt(Ci, "Invalid number") : on = parseInt(Hr, 8), aa(oi, on);
            }
            function io(vi) {
              ae++;
              for (var Ci = ""; ; ) {
                ae >= Je && Wt($e, "Unterminated string constant");
                var Xi = fe.charCodeAt(ae);
                if (Xi === vi)
                  return ++ae, aa(Di, Ci);
                if (Xi === 92) {
                  Xi = fe.charCodeAt(++ae);
                  var sr = /^[0-7]+/.exec(fe.slice(ae, ae + 3));
                  for (sr && (sr = sr[0]); sr && parseInt(sr, 8) > 255; ) sr = sr.slice(0, -1);
                  if (sr === "0" && (sr = null), ++ae, sr)
                    Pt && Wt(ae - 2, "Octal literal in strict mode"), Ci += String.fromCharCode(parseInt(sr, 8)), ae += sr.length - 1;
                  else
                    switch (Xi) {
                      case 110:
                        Ci += `
`;
                        break;
                      case 114:
                        Ci += "\r";
                        break;
                      case 120:
                        Ci += String.fromCharCode(ro(2));
                        break;
                      case 117:
                        Ci += String.fromCharCode(ro(4));
                        break;
                      case 85:
                        Ci += String.fromCharCode(ro(8));
                        break;
                      case 116:
                        Ci += "	";
                        break;
                      case 98:
                        Ci += "\b";
                        break;
                      case 118:
                        Ci += "\v";
                        break;
                      case 102:
                        Ci += "\f";
                        break;
                      case 48:
                        Ci += "\0";
                        break;
                      case 13:
                        fe.charCodeAt(ae) === 10 && ++ae;
                      case 10:
                        Ze.locations && (Fe = ae, ++Ae);
                        break;
                      default:
                        Ci += String.fromCharCode(Xi);
                        break;
                    }
                } else
                  (Xi === 13 || Xi === 10 || Xi === 8232 || Xi === 8233) && Wt($e, "Unterminated string constant"), Ci += String.fromCharCode(Xi), ++ae;
              }
            }
            function ro(vi) {
              var Ci = lu(16, vi);
              return Ci === null && Wt($e, "Bad character escape sequence"), Ci;
            }
            var Ol;
            function Xu() {
              Ol = !1;
              for (var vi, Ci = !0, Xi = ae; ; ) {
                var sr = fe.charCodeAt(ae);
                if (ia(sr))
                  Ol && (vi += fe.charAt(ae)), ++ae;
                else if (sr === 92) {
                  Ol || (vi = fe.slice(Xi, ae)), Ol = !0, fe.charCodeAt(++ae) != 117 && Wt(ae, "Expecting Unicode escape sequence \\uXXXX"), ++ae;
                  var rn = ro(4), Hr = String.fromCharCode(rn);
                  Hr || Wt(ae - 1, "Invalid Unicode escape"), (Ci ? ta(rn) : ia(rn)) || Wt(ae - 4, "Invalid Unicode escape"), vi += Hr;
                } else
                  break;
                Ci = !1;
              }
              return Ol ? vi : fe.slice(Xi, ae);
            }
            function Ic() {
              var vi = Xu(), Ci = Bi;
              return !Ol && Vs(vi) && (Ci = mn[vi]), aa(Ci, vi);
            }
            function Pn() {
              tt = $e, Ct = Et, It = Yt, ul();
            }
            function Pc(vi) {
              if (Pt = vi, ae = $e, Ze.locations)
                for (; ae < Fe; )
                  Fe = fe.lastIndexOf(`
`, Fe - 2) + 1, --Ae;
              to(), ul();
            }
            function Yu() {
              this.type = null, this.start = $e, this.end = null;
            }
            function Uo() {
              this.start = Nt, this.end = null, Xe !== null && (this.source = Xe);
            }
            function zr() {
              var vi = new Yu();
              return Ze.locations && (vi.loc = new Uo()), Ze.directSourceFile && (vi.sourceFile = Ze.directSourceFile), Ze.ranges && (vi.range = [$e, 0]), vi;
            }
            function Sr(vi) {
              var Ci = new Yu();
              return Ci.start = vi.start, Ze.locations && (Ci.loc = new Uo(), Ci.loc.start = vi.loc.start), Ze.ranges && (Ci.range = [vi.range[0], 0]), Ci;
            }
            function _n(vi, Ci) {
              return vi.type = Ci, vi.end = Ct, Ze.locations && (vi.loc.end = It), Ze.ranges && (vi.range[1] = Ct), vi;
            }
            function Lr(vi) {
              return Ze.ecmaVersion >= 5 && vi.type === "ExpressionStatement" && vi.expression.type === "Literal" && vi.expression.value === "use strict";
            }
            function zn(vi) {
              if (Ft === vi)
                return Pn(), !0;
            }
            function cl() {
              return !Ze.strictSemicolons && (Ft === Hi || Ft === tn || Nn.test(fe.slice(Ct, $e)));
            }
            function kr() {
              !zn(Wr) && !cl() && us();
            }
            function sa(vi) {
              Ft === vi ? Pn() : us();
            }
            function us() {
              Wt($e, "Unexpected token");
            }
            function hl(vi) {
              vi.type !== "Identifier" && vi.type !== "MemberExpression" && Wt(vi.start, "Assigning to rvalue"), Pt && vi.type === "Identifier" && No(vi.name) && Wt(vi.start, "Assigning to " + vi.name + " in strict mode");
            }
            function uu(vi) {
              tt = Ct = ae, Ze.locations && (It = new ps()), Ut = Pt = null, ti = [], ul();
              var Ci = vi || zr(), Xi = !0;
              for (vi || (Ci.body = []); Ft !== Hi; ) {
                var sr = tr();
                Ci.body.push(sr), Xi && Lr(sr) && Pc(!0), Xi = !1;
              }
              return _n(Ci, "Program");
            }
            var Pa = { kind: "loop" }, $a = { kind: "switch" };
            function tr() {
              (Ft === D || Ft === ht && ai == "/=") && ul(!0);
              var vi = Ft, Ci = zr();
              switch (vi) {
                case nr:
                case Rr:
                  Pn();
                  var Xi = vi === nr;
                  zn(Wr) || cl() ? Ci.label = null : Ft !== Bi ? us() : (Ci.label = ba(), kr());
                  for (var sr = 0; sr < ti.length; ++sr) {
                    var rn = ti[sr];
                    if ((Ci.label == null || rn.name === Ci.label.name) && (rn.kind != null && (Xi || rn.kind === "loop") || Ci.label && Xi))
                      break;
                  }
                  return sr === ti.length && Wt(Ci.start, "Unsyntactic " + vi.keyword), _n(Ci, Xi ? "BreakStatement" : "ContinueStatement");
                case Br:
                  return Pn(), kr(), _n(Ci, "DebuggerStatement");
                case Ir:
                  return Pn(), ti.push(Pa), Ci.body = tr(), ti.pop(), sa(ha), Ci.test = fl(), kr(), _n(Ci, "DoWhileStatement");
                case xn:
                  if (Pn(), ti.push(Pa), sa(ys), Ft === Wr) return Vo(Ci, null);
                  if (Ft === Ta) {
                    var Hr = zr();
                    return Pn(), ya(Hr, !0), _n(Hr, "VariableDeclaration"), Hr.declarations.length === 1 && zn(La) ? Ps(Ci, Hr) : Vo(Ci, Hr);
                  }
                  var Hr = xa(!1, !0);
                  return zn(La) ? (hl(Hr), Ps(Ci, Hr)) : Vo(Ci, Hr);
                case En:
                  return Pn(), kc(Ci, !0);
                case Vn:
                  return Pn(), Ci.test = fl(), Ci.consequent = tr(), Ci.alternate = zn(Mr) ? tr() : null, _n(Ci, "IfStatement");
                case Yn:
                  return !Ut && !Ze.allowReturnOutsideFunction && Wt($e, "'return' outside of function"), Pn(), zn(Wr) || cl() ? Ci.argument = null : (Ci.argument = xa(), kr()), _n(Ci, "ReturnStatement");
                case ka:
                  Pn(), Ci.discriminant = fl(), Ci.cases = [], sa(Ba), ti.push($a);
                  for (var on, Mn; Ft != tn; )
                    if (Ft === rr || Ft === Ki) {
                      var Va = Ft === rr;
                      on && _n(on, "SwitchCase"), Ci.cases.push(on = zr()), on.consequent = [], Pn(), Va ? on.test = xa() : (Mn && Wt(tt, "Multiple default clauses"), Mn = !0, on.test = null), sa(es);
                    } else
                      on || us(), on.consequent.push(tr());
                  return on && _n(on, "SwitchCase"), Pn(), ti.pop(), _n(Ci, "SwitchStatement");
                case ea:
                  return Pn(), Nn.test(fe.slice(Ct, $e)) && Wt(Ct, "Illegal newline after throw"), Ci.argument = xa(), kr(), _n(Ci, "ThrowStatement");
                case ga:
                  if (Pn(), Ci.block = Mo(), Ci.handler = null, Ft === dr) {
                    var cs = zr();
                    Pn(), sa(ys), cs.param = ba(), Pt && No(cs.param.name) && Wt(cs.param.start, "Binding " + cs.param.name + " in strict mode"), sa(Qa), cs.guard = null, cs.body = Mo(), Ci.handler = _n(cs, "CatchClause");
                  }
                  return Ci.guardedHandlers = ei, Ci.finalizer = zn(wn) ? Mo() : null, !Ci.handler && !Ci.finalizer && Wt(Ci.start, "Missing catch or finally clause"), _n(Ci, "TryStatement");
                case Ta:
                  return Pn(), ya(Ci), kr(), _n(Ci, "VariableDeclaration");
                case ha:
                  return Pn(), Ci.test = fl(), ti.push(Pa), Ci.body = tr(), ti.pop(), _n(Ci, "WhileStatement");
                case Bo:
                  return Pt && Wt($e, "'with' in strict mode"), Pn(), Ci.object = fl(), Ci.body = tr(), _n(Ci, "WithStatement");
                case Ba:
                  return Mo();
                case Wr:
                  return Pn(), _n(Ci, "EmptyStatement");
                default:
                  var go = ai, qo = xa();
                  if (vi === Bi && qo.type === "Identifier" && zn(es)) {
                    for (var sr = 0; sr < ti.length; ++sr)
                      ti[sr].name === go && Wt(qo.start, "Label '" + go + "' is already declared");
                    var Wo = Ft.isLoop ? "loop" : Ft === ka ? "switch" : null;
                    return ti.push({ name: go, kind: Wo }), Ci.body = tr(), ti.pop(), Ci.label = qo, _n(Ci, "LabeledStatement");
                  } else
                    return Ci.expression = qo, kr(), _n(Ci, "ExpressionStatement");
              }
            }
            function fl() {
              sa(ys);
              var vi = xa();
              return sa(Qa), vi;
            }
            function Mo(vi) {
              var Ci = zr(), Xi = !0, sr = !1, rn;
              for (Ci.body = [], sa(Ba); !zn(tn); ) {
                var Hr = tr();
                Ci.body.push(Hr), Xi && vi && Lr(Hr) && (rn = sr, Pc(sr = !0)), Xi = !1;
              }
              return sr && !rn && Pc(!1), _n(Ci, "BlockStatement");
            }
            function Vo(vi, Ci) {
              return vi.init = Ci, sa(Wr), vi.test = Ft === Wr ? null : xa(), sa(Wr), vi.update = Ft === Qa ? null : xa(), sa(Qa), vi.body = tr(), ti.pop(), _n(vi, "ForStatement");
            }
            function Ps(vi, Ci) {
              return vi.left = Ci, vi.right = xa(), sa(Qa), vi.body = tr(), ti.pop(), _n(vi, "ForInStatement");
            }
            function ya(vi, Ci) {
              for (vi.declarations = [], vi.kind = "var"; ; ) {
                var Xi = zr();
                if (Xi.id = ba(), Pt && No(Xi.id.name) && Wt(Xi.id.start, "Binding " + Xi.id.name + " in strict mode"), Xi.init = zn(be) ? xa(!0, Ci) : null, vi.declarations.push(_n(Xi, "VariableDeclarator")), !zn(fa)) break;
              }
              return vi;
            }
            function xa(vi, Ci) {
              var Xi = jo(Ci);
              if (!vi && Ft === fa) {
                var sr = Sr(Xi);
                for (sr.expressions = [Xi]; zn(fa); ) sr.expressions.push(jo(Ci));
                return _n(sr, "SequenceExpression");
              }
              return Xi;
            }
            function jo(vi) {
              var Ci = dl(vi);
              if (Ft.isAssign) {
                var Xi = Sr(Ci);
                return Xi.operator = ai, Xi.left = Ci, Pn(), Xi.right = jo(vi), hl(Ci), _n(Xi, "AssignmentExpression");
              }
              return Ci;
            }
            function dl(vi) {
              var Ci = Go(vi);
              if (zn(Is)) {
                var Xi = Sr(Ci);
                return Xi.test = Ci, Xi.consequent = xa(!0), sa(es), Xi.alternate = xa(!0, vi), _n(Xi, "ConditionalExpression");
              }
              return Ci;
            }
            function Go(vi) {
              return no(pl(), -1, vi);
            }
            function no(vi, Ci, Xi) {
              var sr = Ft.binop;
              if (sr != null && (!Xi || Ft !== La) && sr > Ci) {
                var rn = Sr(vi);
                rn.left = vi, rn.operator = ai;
                var Hr = Ft;
                Pn(), rn.right = no(pl(), sr, Xi);
                var on = _n(rn, Hr === di || Hr === ki ? "LogicalExpression" : "BinaryExpression");
                return no(on, Ci, Xi);
              }
              return vi;
            }
            function pl() {
              if (Ft.prefix) {
                var vi = zr(), Ci = Ft.isUpdate;
                return vi.operator = ai, vi.prefix = !0, Mt = !0, Pn(), vi.argument = pl(), Ci ? hl(vi.argument) : Pt && vi.operator === "delete" && vi.argument.type === "Identifier" && Wt(vi.start, "Deleting local variable in strict mode"), _n(vi, Ci ? "UpdateExpression" : "UnaryExpression");
              }
              for (var Xi = oh(); Ft.postfix && !cl(); ) {
                var vi = Sr(Xi);
                vi.operator = ai, vi.prefix = !1, vi.argument = Xi, hl(Xi), Pn(), Xi = _n(vi, "UpdateExpression");
              }
              return Xi;
            }
            function oh() {
              return Ho(Ku());
            }
            function Ho(vi, Ci) {
              if (zn(Tr)) {
                var Xi = Sr(vi);
                return Xi.object = vi, Xi.property = ba(!0), Xi.computed = !1, Ho(_n(Xi, "MemberExpression"), Ci);
              } else if (zn(eo)) {
                var Xi = Sr(vi);
                return Xi.object = vi, Xi.property = xa(), Xi.computed = !0, sa(mo), Ho(_n(Xi, "MemberExpression"), Ci);
              } else if (!Ci && zn(ys)) {
                var Xi = Sr(vi);
                return Xi.callee = vi, Xi.arguments = Qu(Qa, !1), Ho(_n(Xi, "CallExpression"), Ci);
              } else return vi;
            }
            function Ku() {
              switch (Ft) {
                case za:
                  var sr = zr();
                  return Pn(), _n(sr, "ThisExpression");
                case Bi:
                  return ba();
                case oi:
                case Di:
                case _i:
                  var sr = zr();
                  return sr.value = ai, sr.raw = fe.slice($e, Et), Pn(), _n(sr, "Literal");
                case ss:
                case os:
                case Ms:
                  var sr = zr();
                  return sr.value = Ft.atomValue, sr.raw = Ft.keyword, Pn(), _n(sr, "Literal");
                case ys:
                  var vi = Nt, Ci = $e;
                  Pn();
                  var Xi = xa();
                  return Xi.start = Ci, Xi.end = Et, Ze.locations && (Xi.loc.start = vi, Xi.loc.end = Yt), Ze.ranges && (Xi.range = [Ci, Et]), sa(Qa), Xi;
                case eo:
                  var sr = zr();
                  return Pn(), sr.elements = Qu(mo, !0, !0), _n(sr, "ArrayExpression");
                case Ba:
                  return Rc();
                case En:
                  var sr = zr();
                  return Pn(), kc(sr, !1);
                case Ao:
                  return lh();
                default:
                  us();
              }
            }
            function lh() {
              var vi = zr();
              return Pn(), vi.callee = Ho(Ku(), !0), zn(ys) ? vi.arguments = Qu(Qa, !1) : vi.arguments = ei, _n(vi, "NewExpression");
            }
            function Rc() {
              var vi = zr(), Ci = !0, Xi = !1;
              for (vi.properties = [], Pn(); !zn(tn); ) {
                if (Ci)
                  Ci = !1;
                else if (sa(fa), Ze.allowTrailingCommas && zn(tn)) break;
                var sr = { key: Ju() }, rn = !1, Hr;
                if (zn(es) ? (sr.value = xa(!0), Hr = sr.kind = "init") : Ze.ecmaVersion >= 5 && sr.key.type === "Identifier" && (sr.key.name === "get" || sr.key.name === "set") ? (rn = Xi = !0, Hr = sr.kind = sr.key.name, sr.key = Ju(), Ft !== ys && us(), sr.value = kc(zr(), !1)) : us(), sr.key.type === "Identifier" && (Pt || Xi))
                  for (var on = 0; on < vi.properties.length; ++on) {
                    var Mn = vi.properties[on];
                    if (Mn.key.name === sr.key.name) {
                      var Va = Hr == Mn.kind || rn && Mn.kind === "init" || Hr === "init" && (Mn.kind === "get" || Mn.kind === "set");
                      Va && !Pt && Hr === "init" && Mn.kind === "init" && (Va = !1), Va && Wt(sr.key.start, "Redefinition of property");
                    }
                  }
                vi.properties.push(sr);
              }
              return _n(vi, "ObjectExpression");
            }
            function Ju() {
              return Ft === oi || Ft === Di ? Ku() : ba(!0);
            }
            function kc(vi, Ci) {
              Ft === Bi ? vi.id = ba() : Ci ? us() : vi.id = null, vi.params = [];
              var Xi = !0;
              for (sa(ys); !zn(Qa); )
                Xi ? Xi = !1 : sa(fa), vi.params.push(ba());
              var sr = Ut, rn = ti;
              if (Ut = !0, ti = [], vi.body = Mo(!0), Ut = sr, ti = rn, Pt || vi.body.body.length && Lr(vi.body.body[0]))
                for (var Hr = vi.id ? -1 : 0; Hr < vi.params.length; ++Hr) {
                  var on = Hr < 0 ? vi.id : vi.params[Hr];
                  if ((Fo(on.name) || No(on.name)) && Wt(on.start, "Defining '" + on.name + "' in strict mode"), Hr >= 0) for (var Mn = 0; Mn < Hr; ++Mn) on.name === vi.params[Mn].name && Wt(on.start, "Argument name clash in strict mode");
                }
              return _n(vi, Ci ? "FunctionDeclaration" : "FunctionExpression");
            }
            function Qu(vi, Ci, Xi) {
              for (var sr = [], rn = !0; !zn(vi); ) {
                if (rn)
                  rn = !1;
                else if (sa(fa), Ci && Ze.allowTrailingCommas && zn(vi)) break;
                Xi && Ft === fa ? sr.push(null) : sr.push(xa(!0));
              }
              return sr;
            }
            function ba(vi) {
              var Ci = zr();
              return vi && Ze.forbidReserved == "everywhere" && (vi = !1), Ft === Bi ? (!vi && (Ze.forbidReserved && (Ze.ecmaVersion === 3 ? va : sl)(ai) || Pt && Fo(ai)) && fe.slice($e, Et).indexOf("\\") == -1 && Wt($e, "The keyword '" + ai + "' is reserved"), Ci.name = ai) : vi && Ft.keyword ? Ci.name = Ft.keyword : us(), Mt = !1, Pn(), _n(Ci, "Identifier");
            }
          }), _.version || (_ = null);
        }
        function ne(Be, Ze) {
          return (l.acorn || _).parse(Be, Ze);
        }
        var ue = {
          "+": "__add",
          "-": "__subtract",
          "*": "__multiply",
          "/": "__divide",
          "%": "__modulo",
          "==": "__equals",
          "!=": "__equals"
        }, Te = {
          "-": "__negate",
          "+": "__self"
        }, ye = q.each(
          ["add", "subtract", "multiply", "divide", "modulo", "equals", "negate"],
          function(Be) {
            this["__" + Be] = "#" + Be;
          },
          {
            __self: function() {
              return this;
            }
          }
        );
        x.inject(ye), w.inject(ye), dt.inject(ye);
        function Me(Be, Ze, fe) {
          var Je = ue[Ze];
          if (Be && Be[Je]) {
            var Xe = Be[Je](fe);
            return Ze === "!=" ? !Xe : Xe;
          }
          switch (Ze) {
            case "+":
              return Be + fe;
            case "-":
              return Be - fe;
            case "*":
              return Be * fe;
            case "/":
              return Be / fe;
            case "%":
              return Be % fe;
            case "==":
              return Be == fe;
            case "!=":
              return Be != fe;
          }
        }
        function Ge(Be, Ze) {
          var fe = Te[Be];
          if (Ze && Ze[fe])
            return Ze[fe]();
          switch (Be) {
            case "+":
              return +Ze;
            case "-":
              return -Ze;
          }
        }
        function Qe(Be, Ze) {
          if (!Be)
            return "";
          Ze = Ze || {};
          var fe = [];
          function Je(Pt) {
            for (var Wt = 0, ei = fe.length; Wt < ei; Wt++) {
              var oi = fe[Wt];
              if (oi[0] >= Pt)
                break;
              Pt += oi[1];
            }
            return Pt;
          }
          function Xe(Pt) {
            return Be.substring(
              Je(Pt.range[0]),
              Je(Pt.range[1])
            );
          }
          function z(Pt, Wt) {
            return Be.substring(
              Je(Pt.range[1]),
              Je(Wt.range[0])
            );
          }
          function He(Pt, Wt) {
            for (var ei = Je(Pt.range[0]), oi = Je(Pt.range[1]), _i = 0, Di = fe.length - 1; Di >= 0; Di--)
              if (ei > fe[Di][0]) {
                _i = Di + 1;
                break;
              }
            fe.splice(_i, 0, [ei, Wt.length - oi + ei]), Be = Be.substring(0, ei) + Wt + Be.substring(oi);
          }
          function nt(Pt, Wt) {
            switch (Pt.type) {
              case "UnaryExpression":
                if (Pt.operator in Te && Pt.argument.type !== "Literal") {
                  var ei = Xe(Pt.argument);
                  He(Pt, '$__("' + Pt.operator + '", ' + ei + ")");
                }
                break;
              case "BinaryExpression":
                if (Pt.operator in ue && Pt.left.type !== "Literal") {
                  var oi = Xe(Pt.left), _i = Xe(Pt.right), Di = z(Pt.left, Pt.right), Bi = Pt.operator;
                  He(Pt, "__$__(" + oi + "," + Di.replace(
                    new RegExp("\\" + Bi),
                    '"' + Bi + '"'
                  ) + ", " + _i + ")");
                }
                break;
              case "UpdateExpression":
              case "AssignmentExpression":
                var Hi = Wt && Wt.type;
                if (!(Hi === "ForStatement" || Hi === "BinaryExpression" && /^[=!<>]/.test(Wt.operator) || Hi === "MemberExpression" && Wt.computed)) {
                  if (Pt.type === "UpdateExpression") {
                    var ei = Xe(Pt.argument), nr = "__$__(" + ei + ', "' + Pt.operator[0] + '", 1)', rr = ei + " = " + nr;
                    Pt.prefix ? rr = "(" + rr + ")" : (Hi === "AssignmentExpression" || Hi === "VariableDeclarator" || Hi === "BinaryExpression") && (Xe(Wt.left || Wt.id) === ei && (rr = nr), rr = ei + "; " + rr), He(Pt, rr);
                  } else if (/^.=$/.test(Pt.operator) && Pt.left.type !== "Literal") {
                    var oi = Xe(Pt.left), _i = Xe(Pt.right), nr = oi + " = __$__(" + oi + ', "' + Pt.operator[0] + '", ' + _i + ")";
                    He(Pt, /^\(.*\)$/.test(Xe(Pt)) ? "(" + nr + ")" : nr);
                  }
                }
                break;
            }
          }
          function ae(Pt) {
            switch (Pt.type) {
              case "ExportDefaultDeclaration":
                He({
                  range: [Pt.start, Pt.declaration.start]
                }, "module.exports = ");
                break;
              case "ExportNamedDeclaration":
                var Wt = Pt.declaration, ei = Pt.specifiers;
                if (Wt) {
                  var oi = Wt.declarations;
                  oi && (oi.forEach(function(Di) {
                    He(Di, "module.exports." + Xe(Di));
                  }), He({
                    range: [
                      Pt.start,
                      Wt.start + Wt.kind.length
                    ]
                  }, ""));
                } else if (ei) {
                  var _i = ei.map(function(Di) {
                    var Bi = Xe(Di);
                    return "module.exports." + Bi + " = " + Bi + "; ";
                  }).join("");
                  _i && He(Pt, _i);
                }
                break;
            }
          }
          function $e(Pt, Wt, ei) {
            if (Pt) {
              for (var oi in Pt)
                if (oi !== "range" && oi !== "loc") {
                  var _i = Pt[oi];
                  if (Array.isArray(_i))
                    for (var Di = 0, Bi = _i.length; Di < Bi; Di++)
                      $e(_i[Di], Pt, ei);
                  else _i && typeof _i == "object" && $e(_i, Pt, ei);
                }
              ei.operatorOverloading !== !1 && nt(Pt, Wt), ei.moduleExports !== !1 && ae(Pt);
            }
          }
          function Et(Pt) {
            var Wt = "", ei = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (Pt = (Math.abs(Pt) << 1) + (Pt < 0 ? 1 : 0); Pt || !Wt; ) {
              var oi = Pt & 31;
              Pt >>= 5, Pt && (oi |= 32), Wt += ei[oi];
            }
            return Wt;
          }
          var Nt = Ze.url || "", Yt = Ze.sourceMaps, Ft = Ze.paperFeatures || {}, ai = Ze.source || Be, Mt = Ze.offset || 0, Ae = xt.agent, Fe = Ae.versionNumber, tt = !1, Ct = /\r\n|\n|\r/mg, It;
          if (Yt && (Ae.chrome && Fe >= 30 || Ae.webkit && Fe >= 537.76 || Ae.firefox && Fe >= 23 || Ae.node)) {
            if (Ae.node)
              Mt -= 2;
            else if (Q && Nt && !Q.location.href.indexOf(Nt)) {
              var Ut = de.getElementsByTagName("html")[0].innerHTML;
              Mt = Ut.substr(0, Ut.indexOf(Be) + 1).match(
                Ct
              ).length + 1;
            }
            tt = Mt > 0 && !(Ae.chrome && Fe >= 36 || Ae.safari && Fe >= 600 || Ae.firefox && Fe >= 40 || Ae.node);
            var ti = ["AA" + Et(tt ? 0 : Mt) + "A"];
            ti.length = (Be.match(Ct) || []).length + 1 + (tt ? Mt : 0), It = {
              version: 3,
              file: Nt,
              names: [],
              mappings: ti.join(";AACA"),
              sourceRoot: "",
              sources: [Nt],
              sourcesContent: [ai]
            };
          }
          return (Ft.operatorOverloading !== !1 || Ft.moduleExports !== !1) && $e(ne(Be, {
            ranges: !0,
            preserveParens: !0,
            sourceType: "module"
          }), null, Ft), It && (tt && (Be = new Array(Mt + 1).join(`
`) + Be), /^(inline|both)$/.test(Yt) && (Be += `
//# sourceMappingURL=data:application/json;base64,` + Tt.btoa(unescape(encodeURIComponent(
            JSON.stringify(It)
          )))), Be += `
//# sourceURL=` + (Nt || "paperscript")), {
            url: Nt,
            source: ai,
            code: Be,
            map: It
          };
        }
        function re(Be, Ze, fe) {
          xt = Ze;
          var Je = Ze.getView(), Xe = /\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(Be) && !/\bnew\s+Tool\b/.test(Be) ? new Ye() : null, z = Xe ? Xe._events : [], He = ["onFrame", "onResize"].concat(z), nt = [], ae = [], $e, Et = typeof Be == "object" ? Be : Qe(Be, fe);
          Be = Et.code;
          function Nt(Fe, tt) {
            for (var Ct in Fe)
              (tt || !/^_/.test(Ct)) && new RegExp("([\\b\\s\\W]|^)" + Ct.replace(/\$/g, "\\$") + "\\b").test(Be) && (nt.push(Ct), ae.push(Fe[Ct]));
          }
          Nt(
            { __$__: Me, $__: Ge, paper: Ze, tool: Xe },
            !0
          ), Nt(Ze), Be = "var module = { exports: {} }; " + Be;
          var Mt = q.each(He, function(Fe) {
            new RegExp("\\s+" + Fe + "\\b").test(Be) && (nt.push(Fe), this.push("module.exports." + Fe + " = " + Fe + ";"));
          }, []).join(`
`);
          Mt && (Be += `
` + Mt), Be += `
return module.exports;`;
          var Yt = xt.agent;
          if (de && (Yt.chrome || Yt.firefox && Yt.versionNumber < 40)) {
            var Ft = de.createElement("script"), ai = de.head || de.getElementsByTagName("head")[0];
            Yt.firefox && (Be = `
` + Be), Ft.appendChild(de.createTextNode(
              "document.__paperscript__ = function(" + nt + ") {" + Be + `
}`
            )), ai.appendChild(Ft), $e = de.__paperscript__, delete de.__paperscript__, ai.removeChild(Ft);
          } else
            $e = Function(nt, Be);
          var Mt = $e && $e.apply(Ze, ae), Ae = Mt || {};
          return q.each(z, function(Fe) {
            var tt = Ae[Fe];
            tt && (Xe[Fe] = tt);
          }), Je && (Ae.onResize && Je.setOnResize(Ae.onResize), Je.emit("resize", {
            size: Je.size,
            delta: new x()
          }), Ae.onFrame && Je.setOnFrame(Ae.onFrame), Je.requestUpdate()), Mt;
        }
        function Se(Be) {
          if (/^text\/(?:x-|)paperscript$/.test(Be.type) && i.getAttribute(Be, "ignore") !== "true") {
            var Ze = i.getAttribute(Be, "canvas"), fe = de.getElementById(Ze), Je = Be.src || Be.getAttribute("data-src"), Xe = i.hasAttribute(Be, "async"), z = "data-paper-scope";
            if (!fe)
              throw new Error('Unable to find canvas with id "' + Ze + '"');
            var He = i.get(fe.getAttribute(z)) || new i().setup(fe);
            return fe.setAttribute(z, He._id), Je ? Re.request({
              url: Je,
              async: Xe,
              mimeType: "text/plain",
              onLoad: function(nt) {
                re(nt, He, Je);
              }
            }) : re(Be.innerHTML, He, Be.baseURI), Be.setAttribute("data-paper-ignore", "true"), He;
          }
        }
        function Pe() {
          q.each(
            de && de.getElementsByTagName("script"),
            Se
          );
        }
        function at(Be) {
          return Be ? Se(Be) : Pe();
        }
        return Q && (de.readyState === "complete" ? setTimeout(Pe) : rt.add(Q, { load: Pe })), {
          compile: Qe,
          execute: re,
          load: at,
          parse: ne,
          calculateBinary: Me,
          calculateUnary: Ge
        };
      }).call(this);
      var xt = new (i.inject(q.exports, {
        Base: q,
        Numerical: A,
        Key: St,
        DomEvent: rt,
        DomElement: $t,
        document: de,
        window: Q,
        Symbol: me,
        PlacedSymbol: le
      }))();
      return xt.agent.node && ry(xt), typeof qe == "function" && qe.amd ? qe("paper", xt) : mt.exports = xt, xt;
    }).call(x2, typeof self == "object" ? self : null);
  }(Yp)), Yp.exports;
}
var w2 = b2();
const tp = /* @__PURE__ */ dd(w2), $h = {
  heart: {
    name: "Heart",
    width: 150,
    height: 150,
    svg: "<svg version='1.0' xmlns='http://www.w3.org/2000/svg' width='150' height='150' viewBox='0 0 150 150'><path d='M54.0982,131.36312c-37.55979,-34.26132 -50.98892,-55.93441 -51.09775,-82.4662c-0.09925,-24.18698 16.47831,-47.53097 33.65802,-47.39635c8.57878,0.06736 26.98082,8.96949 33.49705,16.20469c3.28326,3.64551 4.83837,3.28603 12.14819,-2.80822c19.89425,-16.58593 39.32119,-16.93407 51.90293,-0.93003c20.10829,25.57781 16.44736,56.12239 -10.52395,87.80537c-14.3395,16.84451 -45.65381,46.72762 -48.96555,46.72762c-1.00772,0 -10.28624,-7.71161 -20.61895,-17.13688l0,0.00001z' fill='black'/></svg>",
    svg_d: "M54.0982,131.36312c-37.55979,-34.26132 -50.98892,-55.93441 -51.09775,-82.4662c-0.09925,-24.18698 16.47831,-47.53097 33.65802,-47.39635c8.57878,0.06736 26.98082,8.96949 33.49705,16.20469c3.28326,3.64551 4.83837,3.28603 12.14819,-2.80822c19.89425,-16.58593 39.32119,-16.93407 51.90293,-0.93003c20.10829,25.57781 16.44736,56.12239 -10.52395,87.80537c-14.3395,16.84451 -45.65381,46.72762 -48.96555,46.72762c-1.00772,0 -10.28624,-7.71161 -20.61895,-17.13688l0,0.00001z",
    svg_border: "M119.3 2.15c13.2 4.35 24.25 19.95 27.2 38.5.85 5.2.35 17.2-.95 22.85-3.55 15.6-11.65 29.05-28.45 47.3-9.6 10.4-32.75 31.7-39.75 36.55l-1.9 1.35-1.8-.95c-6.5-3.5-36.95-33.35-50.25-49.3-9.7-11.6-17.5-27.5-19.7-40.15-1.15-6.65-.75-16.45 1-22.95 3.1-11.55 11.8-24.65 19.35-29.1 13.05-7.65 27.5-4.7 44.55 9.15 3.8 3.1 6.3 4.6 7.65 4.6.4 0 2.05-1.2 3.65-2.65 6.2-5.7 14.6-10.6 23.85-13.85 5.3-1.9 12.1-2.45 15.55-1.35zm-12.6 2.65c-8.6 2.45-18.65 7.95-24.85 13.6-1.85 1.65-3.9 3.15-4.65 3.3-2.15.55-4.5-.6-9.6-4.6-6.85-5.35-12.4-8.75-17.5-10.6-3.65-1.4-5.25-1.7-10-1.9-6.9-.3-10.65.6-15.1 3.45-7.7 4.95-15.15 16.25-18.35 27.7-1.25 4.55-1.4 5.75-1.4 13.25.05 6.85.2 9 1.15 12.75 3.25 13 9.95 25.2 21.05 38.45 13 15.5 44.5 45.8 47.6 45.8 2.1 0 17.75-13.75 33-29 18.95-18.95 27.8-31.15 33.1-45.5 2.95-8.05 3.6-12.05 3.6-22.5-.05-8.2-.15-9.75-1.2-13.5-2.85-10.1-6.85-17.35-13-23.5-8.05-8-14.4-9.95-23.85-7.2z",
    svg_border_width: 4,
    maskClass: "mask-heart",
    fillColor: "rgba(255,255,255,0.7)",
    mapDimensions: {
      zoom: 12,
      targetSize: 300
    }
  },
  dogtag: {
    name: "Dog Tag",
    width: 84,
    height: 150,
    svg: `<svg version='1.0' xmlns='http://www.w3.org/2000/svg' width='84' height='150' viewBox='0 0 84 150'><path transform="translate(0, 0)" d='M42 150c-15.4 0-27.9-2.8-37.5-8.4C1.7 140 0 137.7 0 135V15C0 12.3 1.7 10 4.5 8.4 14.1 2.8 26.6 0 42 0s27.9 2.8 37.5 8.4C82.3 10 84 12.3 84 15v120c0 2.7-1.7 5-4.5 6.6C69.9 147.2 57.4 150 42 150z' fill='#000000'/></svg>`,
    svg_d: "M42 150c-15.4 0-27.9-2.8-37.5-8.4C1.7 140 0 137.7 0 135V15C0 12.3 1.7 10 4.5 8.4 14.1 2.8 26.6 0 42 0s27.9 2.8 37.5 8.4C82.3 10 84 12.3 84 15v120c0 2.7-1.7 5-4.5 6.6C69.9 147.2 57.4 150 42 150z",
    svg_border: "M42 150c-15.4 0-27.9-2.8-37.5-8.4C1.7 140 0 137.7 0 135V15C0 12.3 1.7 10 4.5 8.4 14.1 2.8 26.6 0 42 0s27.9 2.8 37.5 8.4C82.3 10 84 12.3 84 15v120c0 2.7-1.7 5-4.5 6.6C69.9 147.2 57.4 150 42 150z",
    svg_border_width: 4,
    maskClass: "mask-dogtag",
    fillColor: "rgba(255,255,255,0.7)",
    mapDimensions: {
      zoom: 13,
      targetSize: 400
    }
  }
}, S2 = ({
  map: mt,
  metalType: Tt,
  setPreviewContent: qe,
  setPreviewType: Q,
  cf: de,
  setCustomFields: q,
  shape: ie,
  selectedMarker: i
}) => {
  const N = () => {
    const Z = $h[ie], R = mt.current.getCenter(), A = mt.current.project(R), M = document.createElement("canvas");
    M.width = Z.width, M.height = Z.height, tp.setup(M);
    const x = new tp.Path(Z.svg_d);
    x.position = new tp.Point(Z.width / 2, Z.height / 2);
    const m = mt.current.queryRenderedFeatures({
      layers: ["road-network", "parks", "water", "background"],
      geometry: {
        type: "Circle",
        coordinates: R.toArray()
      }
    });
    let w = [];
    const k = document.createElement("canvas");
    k.width = Z.width, k.height = Z.height;
    const E = k.getContext("2d");
    m.forEach((W) => {
      if (W.layer.id === "parks" && W.geometry.coordinates.forEach((J) => {
        const ee = J[0].map((me) => {
          if (me[0] && me[1]) {
            const ke = mt.current.project([me[0], me[1]]);
            return {
              x: ke.x - (A.x - Z.width / 2),
              y: ke.y - (A.y - Z.height / 2)
            };
          }
        }).filter(Boolean), te = new tp.Path();
        ee.forEach((me) => {
          te.add(new tp.Point(me.x, me.y));
        }), te.closed = !0;
        const le = te.intersect(x);
        le && le.segments && (E.fillStyle = "#91d891", E.beginPath(), le.segments.forEach((me, ke) => {
          const ge = me.point;
          ke === 0 ? E.moveTo(ge.x, ge.y) : E.lineTo(ge.x, ge.y);
        }), E.closePath(), E.fill());
      }), W.geometry.type === "LineString") {
        const J = W.geometry.coordinates.map((ee) => {
          const te = mt.current.project([ee[0], ee[1]]);
          return {
            x: te.x - (A.x - Z.width / 2),
            y: te.y - (A.y - Z.height / 2)
          };
        });
        w.push(J);
      }
      W.geometry.type === "MultiLineString" && W.geometry.coordinates.forEach((J) => {
        const ee = J.map((te) => {
          const le = mt.current.project([te[0], te[1]]);
          return {
            x: le.x - (A.x - Z.width / 2),
            y: le.y - (A.y - Z.height / 2)
          };
        });
        w.push(ee);
      });
    });
    const P = document.createElement("canvas");
    P.width = Z.width, P.height = Z.height;
    const S = P.getContext("2d");
    S.beginPath();
    const U = new Path2D(Z.svg_d);
    S.clip(U), S.strokeStyle = `var(--metal-${Tt}-color)`, S.beginPath(), w.forEach((W) => {
      W.forEach((J, ee) => {
        ee === 0 ? S.moveTo(J.x, J.y) : S.lineTo(J.x, J.y);
      });
    }), S.stroke();
    const j = new iy.Potrace(), T = new iy.Potrace();
    T.loadImage(k.toDataURL(), () => {
      const W = T.getPathTag().replace("<path", '<path class="park-area"');
      j.loadImage(P.toDataURL(), () => {
        var ke;
        const J = j.getPathTag(), le = i && ((ke = Jp[i]) != null && ke.props.d) ? `<g transform="translate(${Z.width / 2 - 24 / 2}, ${Z.height / 2 - 24 / 2})">
                            <path d="${Jp[i].props.d}" />
                        </g>` : "", me = `<svg width="${Z.width}" height="${Z.height}" viewBox="0 0 ${Z.width} ${Z.height}" xmlns="http://www.w3.org/2000/svg">
                        ${J}${W}
                        ${le}
                    </svg>`;
        qe(me), Q("svg"), q(de);
      });
    });
  };
  return /* @__PURE__ */ Dr.jsx("div", { className: "design-confirmation", children: /* @__PURE__ */ Dr.jsx("div", { className: "confirm-button", onClick: N, children: de.name }) });
};
function E2(mt, Tt) {
  if (mt.match(/^[a-z]+:\/\//i))
    return mt;
  if (mt.match(/^\/\//))
    return window.location.protocol + mt;
  if (mt.match(/^[a-z]+:/i))
    return mt;
  const qe = document.implementation.createHTMLDocument(), Q = qe.createElement("base"), de = qe.createElement("a");
  return qe.head.appendChild(Q), qe.body.appendChild(de), Tt && (Q.href = Tt), de.href = mt, de.href;
}
const T2 = /* @__PURE__ */ (() => {
  let mt = 0;
  const Tt = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => (mt += 1, `u${Tt()}${mt}`);
})();
function Xh(mt) {
  const Tt = [];
  for (let qe = 0, Q = mt.length; qe < Q; qe++)
    Tt.push(mt[qe]);
  return Tt;
}
let hd = null;
function ex(mt = {}) {
  return hd || (mt.includeStyleProperties ? (hd = mt.includeStyleProperties, hd) : (hd = Xh(window.getComputedStyle(document.documentElement)), hd));
}
function Qp(mt, Tt) {
  const Q = (mt.ownerDocument.defaultView || window).getComputedStyle(mt).getPropertyValue(Tt);
  return Q ? parseFloat(Q.replace("px", "")) : 0;
}
function C2(mt) {
  const Tt = Qp(mt, "border-left-width"), qe = Qp(mt, "border-right-width");
  return mt.clientWidth + Tt + qe;
}
function A2(mt) {
  const Tt = Qp(mt, "border-top-width"), qe = Qp(mt, "border-bottom-width");
  return mt.clientHeight + Tt + qe;
}
function tx(mt, Tt = {}) {
  const qe = Tt.width || C2(mt), Q = Tt.height || A2(mt);
  return { width: qe, height: Q };
}
function M2() {
  let mt, Tt;
  try {
    Tt = process;
  } catch {
  }
  const qe = Tt && Tt.env ? Tt.env.devicePixelRatio : null;
  return qe && (mt = parseInt(qe, 10), Number.isNaN(mt) && (mt = 1)), mt || window.devicePixelRatio || 1;
}
const Rl = 16384;
function I2(mt) {
  (mt.width > Rl || mt.height > Rl) && (mt.width > Rl && mt.height > Rl ? mt.width > mt.height ? (mt.height *= Rl / mt.width, mt.width = Rl) : (mt.width *= Rl / mt.height, mt.height = Rl) : mt.width > Rl ? (mt.height *= Rl / mt.width, mt.width = Rl) : (mt.width *= Rl / mt.height, mt.height = Rl));
}
function em(mt) {
  return new Promise((Tt, qe) => {
    const Q = new Image();
    Q.onload = () => {
      Q.decode().then(() => {
        requestAnimationFrame(() => Tt(Q));
      });
    }, Q.onerror = qe, Q.crossOrigin = "anonymous", Q.decoding = "async", Q.src = mt;
  });
}
async function P2(mt) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(mt)).then(encodeURIComponent).then((Tt) => `data:image/svg+xml;charset=utf-8,${Tt}`);
}
async function R2(mt, Tt, qe) {
  const Q = "http://www.w3.org/2000/svg", de = document.createElementNS(Q, "svg"), q = document.createElementNS(Q, "foreignObject");
  return de.setAttribute("width", `${Tt}`), de.setAttribute("height", `${qe}`), de.setAttribute("viewBox", `0 0 ${Tt} ${qe}`), q.setAttribute("width", "100%"), q.setAttribute("height", "100%"), q.setAttribute("x", "0"), q.setAttribute("y", "0"), q.setAttribute("externalResourcesRequired", "true"), de.appendChild(q), q.appendChild(mt), P2(de);
}
const al = (mt, Tt) => {
  if (mt instanceof Tt)
    return !0;
  const qe = Object.getPrototypeOf(mt);
  return qe === null ? !1 : qe.constructor.name === Tt.name || al(qe, Tt);
};
function k2(mt) {
  const Tt = mt.getPropertyValue("content");
  return `${mt.cssText} content: '${Tt.replace(/'|"/g, "")}';`;
}
function L2(mt, Tt) {
  return ex(Tt).map((qe) => {
    const Q = mt.getPropertyValue(qe), de = mt.getPropertyPriority(qe);
    return `${qe}: ${Q}${de ? " !important" : ""};`;
  }).join(" ");
}
function O2(mt, Tt, qe, Q) {
  const de = `.${mt}:${Tt}`, q = qe.cssText ? k2(qe) : L2(qe, Q);
  return document.createTextNode(`${de}{${q}}`);
}
function sy(mt, Tt, qe, Q) {
  const de = window.getComputedStyle(mt, qe), q = de.getPropertyValue("content");
  if (q === "" || q === "none")
    return;
  const ie = T2();
  try {
    Tt.className = `${Tt.className} ${ie}`;
  } catch {
    return;
  }
  const i = document.createElement("style");
  i.appendChild(O2(ie, qe, de, Q)), Tt.appendChild(i);
}
function D2(mt, Tt, qe) {
  sy(mt, Tt, ":before", qe), sy(mt, Tt, ":after", qe);
}
const oy = "application/font-woff", ly = "image/jpeg", z2 = {
  woff: oy,
  woff2: oy,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: ly,
  jpeg: ly,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function B2(mt) {
  const Tt = /\.([^./]*?)$/g.exec(mt);
  return Tt ? Tt[1] : "";
}
function Sg(mt) {
  const Tt = B2(mt).toLowerCase();
  return z2[Tt] || "";
}
function F2(mt) {
  return mt.split(/,/)[1];
}
function xg(mt) {
  return mt.search(/^(data:)/) !== -1;
}
function N2(mt, Tt) {
  return `data:${Tt};base64,${mt}`;
}
async function ix(mt, Tt, qe) {
  const Q = await fetch(mt, Tt);
  if (Q.status === 404)
    throw new Error(`Resource "${Q.url}" not found`);
  const de = await Q.blob();
  return new Promise((q, ie) => {
    const i = new FileReader();
    i.onerror = ie, i.onloadend = () => {
      try {
        q(qe({ res: Q, result: i.result }));
      } catch (N) {
        ie(N);
      }
    }, i.readAsDataURL(de);
  });
}
const B_ = {};
function U2(mt, Tt, qe) {
  let Q = mt.replace(/\?.*/, "");
  return qe && (Q = mt), /ttf|otf|eot|woff2?/i.test(Q) && (Q = Q.replace(/.*\//, "")), Tt ? `[${Tt}]${Q}` : Q;
}
async function Eg(mt, Tt, qe) {
  const Q = U2(mt, Tt, qe.includeQueryParams);
  if (B_[Q] != null)
    return B_[Q];
  qe.cacheBust && (mt += (/\?/.test(mt) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime());
  let de;
  try {
    const q = await ix(mt, qe.fetchRequestInit, ({ res: ie, result: i }) => (Tt || (Tt = ie.headers.get("Content-Type") || ""), F2(i)));
    de = N2(q, Tt);
  } catch (q) {
    de = qe.imagePlaceholder || "";
    let ie = `Failed to fetch resource: ${mt}`;
    q && (ie = typeof q == "string" ? q : q.message), ie && console.warn(ie);
  }
  return B_[Q] = de, de;
}
async function V2(mt) {
  const Tt = mt.toDataURL();
  return Tt === "data:," ? mt.cloneNode(!1) : em(Tt);
}
async function j2(mt, Tt) {
  if (mt.currentSrc) {
    const q = document.createElement("canvas"), ie = q.getContext("2d");
    q.width = mt.clientWidth, q.height = mt.clientHeight, ie == null || ie.drawImage(mt, 0, 0, q.width, q.height);
    const i = q.toDataURL();
    return em(i);
  }
  const qe = mt.poster, Q = Sg(qe), de = await Eg(qe, Q, Tt);
  return em(de);
}
async function G2(mt, Tt) {
  var qe;
  try {
    if (!((qe = mt == null ? void 0 : mt.contentDocument) === null || qe === void 0) && qe.body)
      return await nm(mt.contentDocument.body, Tt, !0);
  } catch {
  }
  return mt.cloneNode(!1);
}
async function H2(mt, Tt) {
  return al(mt, HTMLCanvasElement) ? V2(mt) : al(mt, HTMLVideoElement) ? j2(mt, Tt) : al(mt, HTMLIFrameElement) ? G2(mt, Tt) : mt.cloneNode(rx(mt));
}
const q2 = (mt) => mt.tagName != null && mt.tagName.toUpperCase() === "SLOT", rx = (mt) => mt.tagName != null && mt.tagName.toUpperCase() === "SVG";
async function W2(mt, Tt, qe) {
  var Q, de;
  if (rx(Tt))
    return Tt;
  let q = [];
  return q2(mt) && mt.assignedNodes ? q = Xh(mt.assignedNodes()) : al(mt, HTMLIFrameElement) && (!((Q = mt.contentDocument) === null || Q === void 0) && Q.body) ? q = Xh(mt.contentDocument.body.childNodes) : q = Xh(((de = mt.shadowRoot) !== null && de !== void 0 ? de : mt).childNodes), q.length === 0 || al(mt, HTMLVideoElement) || await q.reduce((ie, i) => ie.then(() => nm(i, qe)).then((N) => {
    N && Tt.appendChild(N);
  }), Promise.resolve()), Tt;
}
function Z2(mt, Tt, qe) {
  const Q = Tt.style;
  if (!Q)
    return;
  const de = window.getComputedStyle(mt);
  de.cssText ? (Q.cssText = de.cssText, Q.transformOrigin = de.transformOrigin) : ex(qe).forEach((q) => {
    let ie = de.getPropertyValue(q);
    q === "font-size" && ie.endsWith("px") && (ie = `${Math.floor(parseFloat(ie.substring(0, ie.length - 2))) - 0.1}px`), al(mt, HTMLIFrameElement) && q === "display" && ie === "inline" && (ie = "block"), q === "d" && Tt.getAttribute("d") && (ie = `path(${Tt.getAttribute("d")})`), Q.setProperty(q, ie, de.getPropertyPriority(q));
  });
}
function $2(mt, Tt) {
  al(mt, HTMLTextAreaElement) && (Tt.innerHTML = mt.value), al(mt, HTMLInputElement) && Tt.setAttribute("value", mt.value);
}
function X2(mt, Tt) {
  if (al(mt, HTMLSelectElement)) {
    const qe = Tt, Q = Array.from(qe.children).find((de) => mt.value === de.getAttribute("value"));
    Q && Q.setAttribute("selected", "");
  }
}
function Y2(mt, Tt, qe) {
  return al(Tt, Element) && (Z2(mt, Tt, qe), D2(mt, Tt, qe), $2(mt, Tt), X2(mt, Tt)), Tt;
}
async function K2(mt, Tt) {
  const qe = mt.querySelectorAll ? mt.querySelectorAll("use") : [];
  if (qe.length === 0)
    return mt;
  const Q = {};
  for (let q = 0; q < qe.length; q++) {
    const i = qe[q].getAttribute("xlink:href");
    if (i) {
      const N = mt.querySelector(i), Z = document.querySelector(i);
      !N && Z && !Q[i] && (Q[i] = await nm(Z, Tt, !0));
    }
  }
  const de = Object.values(Q);
  if (de.length) {
    const q = "http://www.w3.org/1999/xhtml", ie = document.createElementNS(q, "svg");
    ie.setAttribute("xmlns", q), ie.style.position = "absolute", ie.style.width = "0", ie.style.height = "0", ie.style.overflow = "hidden", ie.style.display = "none";
    const i = document.createElementNS(q, "defs");
    ie.appendChild(i);
    for (let N = 0; N < de.length; N++)
      i.appendChild(de[N]);
    mt.appendChild(ie);
  }
  return mt;
}
async function nm(mt, Tt, qe) {
  return !qe && Tt.filter && !Tt.filter(mt) ? null : Promise.resolve(mt).then((Q) => H2(Q, Tt)).then((Q) => W2(mt, Q, Tt)).then((Q) => Y2(mt, Q, Tt)).then((Q) => K2(Q, Tt));
}
const nx = /url\((['"]?)([^'"]+?)\1\)/g, J2 = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g, Q2 = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function eS(mt) {
  const Tt = mt.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${Tt})(['"]?\\))`, "g");
}
function tS(mt) {
  const Tt = [];
  return mt.replace(nx, (qe, Q, de) => (Tt.push(de), qe)), Tt.filter((qe) => !xg(qe));
}
async function iS(mt, Tt, qe, Q, de) {
  try {
    const q = qe ? E2(Tt, qe) : Tt, ie = Sg(Tt);
    let i;
    return de || (i = await Eg(q, ie, Q)), mt.replace(eS(Tt), `$1${i}$3`);
  } catch {
  }
  return mt;
}
function rS(mt, { preferredFontFormat: Tt }) {
  return Tt ? mt.replace(Q2, (qe) => {
    for (; ; ) {
      const [Q, , de] = J2.exec(qe) || [];
      if (!de)
        return "";
      if (de === Tt)
        return `src: ${Q};`;
    }
  }) : mt;
}
function ax(mt) {
  return mt.search(nx) !== -1;
}
async function sx(mt, Tt, qe) {
  if (!ax(mt))
    return mt;
  const Q = rS(mt, qe);
  return tS(Q).reduce((q, ie) => q.then((i) => iS(i, ie, Tt, qe)), Promise.resolve(Q));
}
async function fd(mt, Tt, qe) {
  var Q;
  const de = (Q = Tt.style) === null || Q === void 0 ? void 0 : Q.getPropertyValue(mt);
  if (de) {
    const q = await sx(de, null, qe);
    return Tt.style.setProperty(mt, q, Tt.style.getPropertyPriority(mt)), !0;
  }
  return !1;
}
async function nS(mt, Tt) {
  await fd("background", mt, Tt) || await fd("background-image", mt, Tt), await fd("mask", mt, Tt) || await fd("-webkit-mask", mt, Tt) || await fd("mask-image", mt, Tt) || await fd("-webkit-mask-image", mt, Tt);
}
async function aS(mt, Tt) {
  const qe = al(mt, HTMLImageElement);
  if (!(qe && !xg(mt.src)) && !(al(mt, SVGImageElement) && !xg(mt.href.baseVal)))
    return;
  const Q = qe ? mt.src : mt.href.baseVal, de = await Eg(Q, Sg(Q), Tt);
  await new Promise((q, ie) => {
    mt.onload = q, mt.onerror = Tt.onImageErrorHandler ? (...N) => {
      try {
        q(Tt.onImageErrorHandler(...N));
      } catch (Z) {
        ie(Z);
      }
    } : ie;
    const i = mt;
    i.decode && (i.decode = q), i.loading === "lazy" && (i.loading = "eager"), qe ? (mt.srcset = "", mt.src = de) : mt.href.baseVal = de;
  });
}
async function sS(mt, Tt) {
  const Q = Xh(mt.childNodes).map((de) => ox(de, Tt));
  await Promise.all(Q).then(() => mt);
}
async function ox(mt, Tt) {
  al(mt, Element) && (await nS(mt, Tt), await aS(mt, Tt), await sS(mt, Tt));
}
function oS(mt, Tt) {
  const { style: qe } = mt;
  Tt.backgroundColor && (qe.backgroundColor = Tt.backgroundColor), Tt.width && (qe.width = `${Tt.width}px`), Tt.height && (qe.height = `${Tt.height}px`);
  const Q = Tt.style;
  return Q != null && Object.keys(Q).forEach((de) => {
    qe[de] = Q[de];
  }), mt;
}
const uy = {};
async function cy(mt) {
  let Tt = uy[mt];
  if (Tt != null)
    return Tt;
  const Q = await (await fetch(mt)).text();
  return Tt = { url: mt, cssText: Q }, uy[mt] = Tt, Tt;
}
async function hy(mt, Tt) {
  let qe = mt.cssText;
  const Q = /url\(["']?([^"')]+)["']?\)/g, q = (qe.match(/url\([^)]+\)/g) || []).map(async (ie) => {
    let i = ie.replace(Q, "$1");
    return i.startsWith("https://") || (i = new URL(i, mt.url).href), ix(i, Tt.fetchRequestInit, ({ result: N }) => (qe = qe.replace(ie, `url(${N})`), [ie, N]));
  });
  return Promise.all(q).then(() => qe);
}
function fy(mt) {
  if (mt == null)
    return [];
  const Tt = [], qe = /(\/\*[\s\S]*?\*\/)/gi;
  let Q = mt.replace(qe, "");
  const de = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  for (; ; ) {
    const N = de.exec(Q);
    if (N === null)
      break;
    Tt.push(N[0]);
  }
  Q = Q.replace(de, "");
  const q = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi, ie = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})", i = new RegExp(ie, "gi");
  for (; ; ) {
    let N = q.exec(Q);
    if (N === null) {
      if (N = i.exec(Q), N === null)
        break;
      q.lastIndex = i.lastIndex;
    } else
      i.lastIndex = q.lastIndex;
    Tt.push(N[0]);
  }
  return Tt;
}
async function lS(mt, Tt) {
  const qe = [], Q = [];
  return mt.forEach((de) => {
    if ("cssRules" in de)
      try {
        Xh(de.cssRules || []).forEach((q, ie) => {
          if (q.type === CSSRule.IMPORT_RULE) {
            let i = ie + 1;
            const N = q.href, Z = cy(N).then((R) => hy(R, Tt)).then((R) => fy(R).forEach((A) => {
              try {
                de.insertRule(A, A.startsWith("@import") ? i += 1 : de.cssRules.length);
              } catch (M) {
                console.error("Error inserting rule from remote css", {
                  rule: A,
                  error: M
                });
              }
            })).catch((R) => {
              console.error("Error loading remote css", R.toString());
            });
            Q.push(Z);
          }
        });
      } catch (q) {
        const ie = mt.find((i) => i.href == null) || document.styleSheets[0];
        de.href != null && Q.push(cy(de.href).then((i) => hy(i, Tt)).then((i) => fy(i).forEach((N) => {
          ie.insertRule(N, ie.cssRules.length);
        })).catch((i) => {
          console.error("Error loading remote stylesheet", i);
        })), console.error("Error inlining remote css file", q);
      }
  }), Promise.all(Q).then(() => (mt.forEach((de) => {
    if ("cssRules" in de)
      try {
        Xh(de.cssRules || []).forEach((q) => {
          qe.push(q);
        });
      } catch (q) {
        console.error(`Error while reading CSS rules from ${de.href}`, q);
      }
  }), qe));
}
function uS(mt) {
  return mt.filter((Tt) => Tt.type === CSSRule.FONT_FACE_RULE).filter((Tt) => ax(Tt.style.getPropertyValue("src")));
}
async function cS(mt, Tt) {
  if (mt.ownerDocument == null)
    throw new Error("Provided element is not within a Document");
  const qe = Xh(mt.ownerDocument.styleSheets), Q = await lS(qe, Tt);
  return uS(Q);
}
function lx(mt) {
  return mt.trim().replace(/["']/g, "");
}
function hS(mt) {
  const Tt = /* @__PURE__ */ new Set();
  function qe(Q) {
    (Q.style.fontFamily || getComputedStyle(Q).fontFamily).split(",").forEach((q) => {
      Tt.add(lx(q));
    }), Array.from(Q.children).forEach((q) => {
      q instanceof HTMLElement && qe(q);
    });
  }
  return qe(mt), Tt;
}
async function fS(mt, Tt) {
  const qe = await cS(mt, Tt), Q = hS(mt);
  return (await Promise.all(qe.filter((q) => Q.has(lx(q.style.fontFamily))).map((q) => {
    const ie = q.parentStyleSheet ? q.parentStyleSheet.href : null;
    return sx(q.cssText, ie, Tt);
  }))).join(`
`);
}
async function dS(mt, Tt) {
  const qe = Tt.fontEmbedCSS != null ? Tt.fontEmbedCSS : Tt.skipFonts ? null : await fS(mt, Tt);
  if (qe) {
    const Q = document.createElement("style"), de = document.createTextNode(qe);
    Q.appendChild(de), mt.firstChild ? mt.insertBefore(Q, mt.firstChild) : mt.appendChild(Q);
  }
}
async function pS(mt, Tt = {}) {
  const { width: qe, height: Q } = tx(mt, Tt), de = await nm(mt, Tt, !0);
  return await dS(de, Tt), await ox(de, Tt), oS(de, Tt), await R2(de, qe, Q);
}
async function mS(mt, Tt = {}) {
  const { width: qe, height: Q } = tx(mt, Tt), de = await pS(mt, Tt), q = await em(de), ie = document.createElement("canvas"), i = ie.getContext("2d"), N = Tt.pixelRatio || M2(), Z = Tt.canvasWidth || qe, R = Tt.canvasHeight || Q;
  return ie.width = Z * N, ie.height = R * N, Tt.skipAutoScale || I2(ie), ie.style.width = `${Z}`, ie.style.height = `${R}`, Tt.backgroundColor && (i.fillStyle = Tt.backgroundColor, i.fillRect(0, 0, ie.width, ie.height)), i.drawImage(q, 0, 0, ie.width, ie.height), ie;
}
async function _S(mt, Tt = {}) {
  return (await mS(mt, Tt)).toDataURL();
}
const gS = ({ previewContent: mt, previewType: Tt, width: qe, height: Q, currentVariant: de, customFields: q }) => {
  pd();
  const [ie, i] = _a.useState(null), [N, Z] = _a.useState("transparent"), R = {
    image: {
      type: "image/jpeg",
      extension: "jpg",
      accept: ".jpg,.jpeg,.png,.tiff,.bmp,.webp,.bpg",
      getBlob: (A) => fetch(A).then((M) => M.blob())
    },
    svg: {
      type: "image/svg+xml",
      extension: "svg",
      accept: ".svg",
      getBlob: (A) => {
        const M = A.startsWith("<?xml") ? A : `<?xml version="1.0" encoding="UTF-8"?>${A}`;
        return new Blob([M], { type: "image/svg+xml" });
      }
    }
  };
  return Pf.useEffect(() => {
    mt && (async () => {
      const M = document.querySelector(".preview-block");
      let x;
      if (Tt === "image") {
        const w = await _S(M, {
          quality: 1,
          pixelRatio: 2,
          skipAutoScale: !0
        });
        x = await fetch(w).then((k) => k.blob());
      } else {
        const k = M.querySelector("svg").outerHTML;
        x = k.startsWith("<?xml") ? k : `<?xml version="1.0" encoding="UTF-8"?>${k}`;
      }
      document.querySelectorAll('form[action="/cart/add"]').forEach((w) => {
        let k = w.querySelector(`input[name="properties[${q.options["input-name"]}]"]`);
        k || (k = document.createElement("input"), k.type = "file", k.name = `properties[${q.options["input-name"]}]`, k.accept = R[Tt].accept, k.style.display = "none", w.appendChild(k)), w.querySelectorAll('button[type="submit"]').forEach((U) => {
          U.disabled = !1;
        });
        const P = R[Tt], S = new DataTransfer();
        if (S.items.add(
          new File([x], `map-snapshot.${P.extension}`, { type: P.type })
        ), k.files = S.files, !ie) {
          const U = new Promise((j, T) => {
            w.addEventListener(
              "submit",
              async (W) => {
                W.preventDefault();
                const J = new FormData(w), te = await (await fetch("/cart/add.js", {
                  method: "POST",
                  body: J
                })).json(), ke = (await (await fetch("/cart.js")).json()).items.filter(
                  (ge) => ge.variant_id === de.id && !ge.properties[q.options["input-name"]]
                );
                for (const ge of ke)
                  await fetch("/cart/change.js", {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                      id: ge.key,
                      quantity: 0
                    })
                  });
                j(te);
              },
              { once: !0 }
            );
          });
          i(U);
        }
        w.dispatchEvent(
          new CustomEvent("shineon/add_submit_deferred", {
            detail: { promise: ie }
          })
        );
      });
    })();
  }, [mt]), /* @__PURE__ */ Dr.jsx("div", { className: "preview-wrapper", children: /* @__PURE__ */ Dr.jsx("div", { className: "preview-grid", children: /* @__PURE__ */ Dr.jsx(
    "div",
    {
      className: `preview-block bg-${N}`,
      style: {
        width: qe + "px",
        height: Q + "px"
      },
      children: Tt === "image" ? /* @__PURE__ */ Dr.jsx("img", { src: mt, alt: "Map preview" }) : /* @__PURE__ */ Dr.jsx("div", { dangerouslySetInnerHTML: { __html: mt } })
    }
  ) }) });
};
var F_, dy;
function md() {
  if (dy) return F_;
  dy = 1, F_ = Tt;
  var mt = Object.prototype.hasOwnProperty;
  function Tt() {
    for (var qe = {}, Q = 0; Q < arguments.length; Q++) {
      var de = arguments[Q];
      for (var q in de)
        mt.call(de, q) && (qe[q] = de[q]);
    }
    return qe;
  }
  return F_;
}
var N_ = { exports: {} }, py;
function vS() {
  return py || (py = 1, function(mt, Tt) {
    (function() {
      var qe = {};
      mt.exports = qe, qe.simpleFilter = function(Q, de) {
        return de.filter(function(q) {
          return qe.test(Q, q);
        });
      }, qe.test = function(Q, de) {
        return qe.match(Q, de) !== null;
      }, qe.match = function(Q, de, q) {
        q = q || {};
        var ie = 0, i = [], N = de.length, Z = 0, R = 0, A = q.pre || "", M = q.post || "", x = q.caseSensitive && de || de.toLowerCase(), m;
        Q = q.caseSensitive && Q || Q.toLowerCase();
        for (var w = 0; w < N; w++)
          m = de[w], x[w] === Q[ie] ? (m = A + m + M, ie += 1, R += 1 + R) : R = 0, Z += R, i[i.length] = m;
        return ie === Q.length ? (Z = x === Q ? 1 / 0 : Z, { rendered: i.join(""), score: Z }) : null;
      }, qe.filter = function(Q, de, q) {
        return !de || de.length === 0 ? [] : typeof Q != "string" ? de : (q = q || {}, de.reduce(function(ie, i, N, Z) {
          var R = i;
          q.extract && (R = q.extract(i));
          var A = qe.match(Q, R, q);
          return A != null && (ie[ie.length] = {
            string: A.rendered,
            score: A.score,
            index: N,
            original: i
          }), ie;
        }, []).sort(function(ie, i) {
          var N = i.score - ie.score;
          return N || ie.index - i.index;
        }));
      };
    })();
  }(N_)), N_.exports;
}
var U_, my;
function yS() {
  if (my) return U_;
  my = 1;
  var mt = function(Tt) {
    return this.component = Tt, this.items = [], this.active = 0, this.wrapper = document.createElement("div"), this.wrapper.className = "suggestions-wrapper", this.element = document.createElement("ul"), this.element.className = "suggestions", this.wrapper.appendChild(this.element), this.selectingListItem = !1, Tt.el.parentNode.insertBefore(this.wrapper, Tt.el.nextSibling), this;
  };
  return mt.prototype.show = function() {
    this.element.style.display = "block";
  }, mt.prototype.hide = function() {
    this.element.style.display = "none";
  }, mt.prototype.add = function(Tt) {
    this.items.push(Tt);
  }, mt.prototype.clear = function() {
    this.items = [], this.active = 0;
  }, mt.prototype.isEmpty = function() {
    return !this.items.length;
  }, mt.prototype.isVisible = function() {
    return this.element.style.display === "block";
  }, mt.prototype.draw = function() {
    if (this.element.innerHTML = "", this.items.length === 0) {
      this.hide();
      return;
    }
    for (var Tt = 0; Tt < this.items.length; Tt++)
      this.drawItem(this.items[Tt], this.active === Tt);
    this.show();
  }, mt.prototype.drawItem = function(Tt, qe) {
    var Q = document.createElement("li"), de = document.createElement("a");
    qe && (Q.className += " active"), de.innerHTML = Tt.string, Q.appendChild(de), this.element.appendChild(Q), Q.addEventListener("mousedown", (function() {
      this.selectingListItem = !0;
    }).bind(this)), Q.addEventListener("mouseup", (function() {
      this.handleMouseUp.call(this, Tt);
    }).bind(this));
  }, mt.prototype.handleMouseUp = function(Tt) {
    this.selectingListItem = !1, this.component.value(Tt.original), this.clear(), this.draw();
  }, mt.prototype.move = function(Tt) {
    this.active = Tt, this.draw();
  }, mt.prototype.previous = function() {
    this.move(this.active === 0 ? this.items.length - 1 : this.active - 1);
  }, mt.prototype.next = function() {
    this.move(this.active === this.items.length - 1 ? 0 : this.active + 1);
  }, mt.prototype.drawError = function(Tt) {
    var qe = document.createElement("li");
    qe.innerHTML = Tt, this.element.appendChild(qe), this.show();
  }, U_ = mt, U_;
}
var V_, _y;
function xS() {
  if (_y) return V_;
  _y = 1;
  var mt = md(), Tt = vS(), qe = yS(), Q = function(de, q, ie) {
    return ie = ie || {}, this.options = mt({
      minLength: 2,
      limit: 5,
      filter: !0,
      hideOnBlur: !0
    }, ie), this.el = de, this.data = q || [], this.list = new qe(this), this.query = "", this.selected = null, this.list.draw(), this.el.addEventListener("keyup", (function(i) {
      this.handleKeyUp(i.keyCode);
    }).bind(this), !1), this.el.addEventListener("keydown", (function(i) {
      this.handleKeyDown(i);
    }).bind(this)), this.el.addEventListener("focus", (function() {
      this.handleFocus();
    }).bind(this)), this.el.addEventListener("blur", (function() {
      this.handleBlur();
    }).bind(this)), this.el.addEventListener("paste", (function(i) {
      this.handlePaste(i);
    }).bind(this)), this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this), this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this), this;
  };
  return Q.prototype.handleKeyUp = function(de) {
    de === 40 || de === 38 || de === 27 || de === 13 || de === 9 || this.handleInputChange(this.el.value);
  }, Q.prototype.handleKeyDown = function(de) {
    switch (de.keyCode) {
      case 13:
      // ENTER
      case 9:
        this.list.isEmpty() || (this.list.isVisible() && de.preventDefault(), this.value(this.list.items[this.list.active].original), this.list.hide());
        break;
      case 27:
        this.list.isEmpty() || this.list.hide();
        break;
      case 38:
        this.list.previous();
        break;
      case 40:
        this.list.next();
        break;
    }
  }, Q.prototype.handleBlur = function() {
    !this.list.selectingListItem && this.options.hideOnBlur && this.list.hide();
  }, Q.prototype.handlePaste = function(de) {
    if (de.clipboardData)
      this.handleInputChange(de.clipboardData.getData("Text"));
    else {
      var q = this;
      setTimeout(function() {
        q.handleInputChange(de.target.value);
      }, 100);
    }
  }, Q.prototype.handleInputChange = function(de) {
    if (this.query = this.normalize(de), this.list.clear(), this.query.length < this.options.minLength) {
      this.list.draw();
      return;
    }
    this.getCandidates((function(q) {
      for (var ie = 0; ie < q.length && (this.list.add(q[ie]), ie !== this.options.limit - 1); ie++)
        ;
      this.list.draw();
    }).bind(this));
  }, Q.prototype.handleFocus = function() {
    this.list.isEmpty() || this.list.show(), this.list.selectingListItem = !1;
  }, Q.prototype.update = function(de) {
    this.data = de, this.handleKeyUp();
  }, Q.prototype.clear = function() {
    this.data = [], this.list.clear();
  }, Q.prototype.normalize = function(de) {
    return de = de.toLowerCase(), de;
  }, Q.prototype.match = function(de, q) {
    return de.indexOf(q) > -1;
  }, Q.prototype.value = function(de) {
    if (this.selected = de, this.el.value = this.getItemValue(de), document.createEvent) {
      var q = document.createEvent("HTMLEvents");
      q.initEvent("change", !0, !1), this.el.dispatchEvent(q);
    } else
      this.el.fireEvent("onchange");
  }, Q.prototype.getCandidates = function(de) {
    var q = {
      pre: "<strong>",
      post: "</strong>",
      extract: (function(i) {
        return this.getItemValue(i);
      }).bind(this)
    }, ie;
    this.options.filter ? (ie = Tt.filter(this.query, this.data, q), ie = ie.map((function(i) {
      return {
        original: i.original,
        string: this.render(i.original, i.string)
      };
    }).bind(this))) : ie = this.data.map((function(i) {
      var N = this.render(i);
      return {
        original: i,
        string: N
      };
    }).bind(this)), de(ie);
  }, Q.prototype.getItemValue = function(de) {
    return de;
  }, Q.prototype.render = function(de, q) {
    if (q)
      return q;
    for (var ie = de.original ? this.getItemValue(de.original) : this.getItemValue(de), i = this.normalize(ie), N = i.lastIndexOf(this.query); N > -1; ) {
      var Z = N + this.query.length;
      ie = ie.slice(0, N) + "<strong>" + ie.slice(N, Z) + "</strong>" + ie.slice(Z), N = i.slice(0, N).lastIndexOf(this.query);
    }
    return ie;
  }, Q.prototype.renderError = function(de) {
    this.list.drawError(de);
  }, V_ = Q, V_;
}
var j_, gy;
function bS() {
  if (gy) return j_;
  gy = 1;
  var mt = xS();
  return j_ = mt, typeof window < "u" && (window.Suggestions = mt), j_;
}
var G_, vy;
function wS() {
  if (vy) return G_;
  vy = 1;
  var mt = "Expected a function", Tt = NaN, qe = "[object Symbol]", Q = /^\s+|\s+$/g, de = /^[-+]0x[0-9a-f]+$/i, q = /^0b[01]+$/i, ie = /^0o[0-7]+$/i, i = parseInt, N = typeof Qn == "object" && Qn && Qn.Object === Object && Qn, Z = typeof self == "object" && self && self.Object === Object && self, R = N || Z || Function("return this")(), A = Object.prototype, M = A.toString, x = Math.max, m = Math.min, w = function() {
    return R.Date.now();
  };
  function k(j, T, W) {
    var J, ee, te, le, me, ke, ge = 0, Ve = !1, Oe = !1, Ue = !0;
    if (typeof j != "function")
      throw new TypeError(mt);
    T = U(T) || 0, E(W) && (Ve = !!W.leading, Oe = "maxWait" in W, te = Oe ? x(U(W.maxWait) || 0, T) : te, Ue = "trailing" in W ? !!W.trailing : Ue);
    function we(wt) {
      var Ht = J, $t = ee;
      return J = ee = void 0, ge = wt, le = j.apply($t, Ht), le;
    }
    function Ce(wt) {
      return ge = wt, me = setTimeout(bt, T), Ve ? we(wt) : le;
    }
    function it(wt) {
      var Ht = wt - ke, $t = wt - ge, rt = T - Ht;
      return Oe ? m(rt, te - $t) : rt;
    }
    function ut(wt) {
      var Ht = wt - ke, $t = wt - ge;
      return ke === void 0 || Ht >= T || Ht < 0 || Oe && $t >= te;
    }
    function bt() {
      var wt = w();
      if (ut(wt))
        return pt(wt);
      me = setTimeout(bt, it(wt));
    }
    function pt(wt) {
      return me = void 0, Ue && J ? we(wt) : (J = ee = void 0, le);
    }
    function Ke() {
      me !== void 0 && clearTimeout(me), ge = 0, J = ke = ee = me = void 0;
    }
    function dt() {
      return me === void 0 ? le : pt(w());
    }
    function ct() {
      var wt = w(), Ht = ut(wt);
      if (J = arguments, ee = this, ke = wt, Ht) {
        if (me === void 0)
          return Ce(ke);
        if (Oe)
          return me = setTimeout(bt, T), we(ke);
      }
      return me === void 0 && (me = setTimeout(bt, T)), le;
    }
    return ct.cancel = Ke, ct.flush = dt, ct;
  }
  function E(j) {
    var T = typeof j;
    return !!j && (T == "object" || T == "function");
  }
  function P(j) {
    return !!j && typeof j == "object";
  }
  function S(j) {
    return typeof j == "symbol" || P(j) && M.call(j) == qe;
  }
  function U(j) {
    if (typeof j == "number")
      return j;
    if (S(j))
      return Tt;
    if (E(j)) {
      var T = typeof j.valueOf == "function" ? j.valueOf() : j;
      j = E(T) ? T + "" : T;
    }
    if (typeof j != "string")
      return j === 0 ? j : +j;
    j = j.replace(Q, "");
    var W = q.test(j);
    return W || ie.test(j) ? i(j.slice(2), W ? 2 : 8) : de.test(j) ? Tt : +j;
  }
  return G_ = k, G_;
}
var $p = { exports: {} }, yy;
function SS() {
  if (yy) return $p.exports;
  yy = 1;
  var mt = typeof Reflect == "object" ? Reflect : null, Tt = mt && typeof mt.apply == "function" ? mt.apply : function(j, T, W) {
    return Function.prototype.apply.call(j, T, W);
  }, qe;
  mt && typeof mt.ownKeys == "function" ? qe = mt.ownKeys : Object.getOwnPropertySymbols ? qe = function(j) {
    return Object.getOwnPropertyNames(j).concat(Object.getOwnPropertySymbols(j));
  } : qe = function(j) {
    return Object.getOwnPropertyNames(j);
  };
  function Q(U) {
    console && console.warn && console.warn(U);
  }
  var de = Number.isNaN || function(j) {
    return j !== j;
  };
  function q() {
    q.init.call(this);
  }
  $p.exports = q, $p.exports.once = E, q.EventEmitter = q, q.prototype._events = void 0, q.prototype._eventsCount = 0, q.prototype._maxListeners = void 0;
  var ie = 10;
  function i(U) {
    if (typeof U != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof U);
  }
  Object.defineProperty(q, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return ie;
    },
    set: function(U) {
      if (typeof U != "number" || U < 0 || de(U))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + U + ".");
      ie = U;
    }
  }), q.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, q.prototype.setMaxListeners = function(j) {
    if (typeof j != "number" || j < 0 || de(j))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + j + ".");
    return this._maxListeners = j, this;
  };
  function N(U) {
    return U._maxListeners === void 0 ? q.defaultMaxListeners : U._maxListeners;
  }
  q.prototype.getMaxListeners = function() {
    return N(this);
  }, q.prototype.emit = function(j) {
    for (var T = [], W = 1; W < arguments.length; W++) T.push(arguments[W]);
    var J = j === "error", ee = this._events;
    if (ee !== void 0)
      J = J && ee.error === void 0;
    else if (!J)
      return !1;
    if (J) {
      var te;
      if (T.length > 0 && (te = T[0]), te instanceof Error)
        throw te;
      var le = new Error("Unhandled error." + (te ? " (" + te.message + ")" : ""));
      throw le.context = te, le;
    }
    var me = ee[j];
    if (me === void 0)
      return !1;
    if (typeof me == "function")
      Tt(me, this, T);
    else
      for (var ke = me.length, ge = m(me, ke), W = 0; W < ke; ++W)
        Tt(ge[W], this, T);
    return !0;
  };
  function Z(U, j, T, W) {
    var J, ee, te;
    if (i(T), ee = U._events, ee === void 0 ? (ee = U._events = /* @__PURE__ */ Object.create(null), U._eventsCount = 0) : (ee.newListener !== void 0 && (U.emit(
      "newListener",
      j,
      T.listener ? T.listener : T
    ), ee = U._events), te = ee[j]), te === void 0)
      te = ee[j] = T, ++U._eventsCount;
    else if (typeof te == "function" ? te = ee[j] = W ? [T, te] : [te, T] : W ? te.unshift(T) : te.push(T), J = N(U), J > 0 && te.length > J && !te.warned) {
      te.warned = !0;
      var le = new Error("Possible EventEmitter memory leak detected. " + te.length + " " + String(j) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      le.name = "MaxListenersExceededWarning", le.emitter = U, le.type = j, le.count = te.length, Q(le);
    }
    return U;
  }
  q.prototype.addListener = function(j, T) {
    return Z(this, j, T, !1);
  }, q.prototype.on = q.prototype.addListener, q.prototype.prependListener = function(j, T) {
    return Z(this, j, T, !0);
  };
  function R() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function A(U, j, T) {
    var W = { fired: !1, wrapFn: void 0, target: U, type: j, listener: T }, J = R.bind(W);
    return J.listener = T, W.wrapFn = J, J;
  }
  q.prototype.once = function(j, T) {
    return i(T), this.on(j, A(this, j, T)), this;
  }, q.prototype.prependOnceListener = function(j, T) {
    return i(T), this.prependListener(j, A(this, j, T)), this;
  }, q.prototype.removeListener = function(j, T) {
    var W, J, ee, te, le;
    if (i(T), J = this._events, J === void 0)
      return this;
    if (W = J[j], W === void 0)
      return this;
    if (W === T || W.listener === T)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete J[j], J.removeListener && this.emit("removeListener", j, W.listener || T));
    else if (typeof W != "function") {
      for (ee = -1, te = W.length - 1; te >= 0; te--)
        if (W[te] === T || W[te].listener === T) {
          le = W[te].listener, ee = te;
          break;
        }
      if (ee < 0)
        return this;
      ee === 0 ? W.shift() : w(W, ee), W.length === 1 && (J[j] = W[0]), J.removeListener !== void 0 && this.emit("removeListener", j, le || T);
    }
    return this;
  }, q.prototype.off = q.prototype.removeListener, q.prototype.removeAllListeners = function(j) {
    var T, W, J;
    if (W = this._events, W === void 0)
      return this;
    if (W.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : W[j] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete W[j]), this;
    if (arguments.length === 0) {
      var ee = Object.keys(W), te;
      for (J = 0; J < ee.length; ++J)
        te = ee[J], te !== "removeListener" && this.removeAllListeners(te);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (T = W[j], typeof T == "function")
      this.removeListener(j, T);
    else if (T !== void 0)
      for (J = T.length - 1; J >= 0; J--)
        this.removeListener(j, T[J]);
    return this;
  };
  function M(U, j, T) {
    var W = U._events;
    if (W === void 0)
      return [];
    var J = W[j];
    return J === void 0 ? [] : typeof J == "function" ? T ? [J.listener || J] : [J] : T ? k(J) : m(J, J.length);
  }
  q.prototype.listeners = function(j) {
    return M(this, j, !0);
  }, q.prototype.rawListeners = function(j) {
    return M(this, j, !1);
  }, q.listenerCount = function(U, j) {
    return typeof U.listenerCount == "function" ? U.listenerCount(j) : x.call(U, j);
  }, q.prototype.listenerCount = x;
  function x(U) {
    var j = this._events;
    if (j !== void 0) {
      var T = j[U];
      if (typeof T == "function")
        return 1;
      if (T !== void 0)
        return T.length;
    }
    return 0;
  }
  q.prototype.eventNames = function() {
    return this._eventsCount > 0 ? qe(this._events) : [];
  };
  function m(U, j) {
    for (var T = new Array(j), W = 0; W < j; ++W)
      T[W] = U[W];
    return T;
  }
  function w(U, j) {
    for (; j + 1 < U.length; j++)
      U[j] = U[j + 1];
    U.pop();
  }
  function k(U) {
    for (var j = new Array(U.length), T = 0; T < j.length; ++T)
      j[T] = U[T].listener || U[T];
    return j;
  }
  function E(U, j) {
    return new Promise(function(T, W) {
      function J(te) {
        U.removeListener(j, ee), W(te);
      }
      function ee() {
        typeof U.removeListener == "function" && U.removeListener("error", J), T([].slice.call(arguments));
      }
      S(U, j, ee, { once: !0 }), j !== "error" && P(U, J, { once: !0 });
    });
  }
  function P(U, j, T) {
    typeof U.on == "function" && S(U, "error", j, T);
  }
  function S(U, j, T, W) {
    if (typeof U.on == "function")
      W.once ? U.once(j, T) : U.on(j, T);
    else if (typeof U.addEventListener == "function")
      U.addEventListener(j, function J(ee) {
        W.once && U.removeEventListener(j, J), T(ee);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof U);
  }
  return $p.exports;
}
var H_, xy;
function ES() {
  return xy || (xy = 1, H_ = {
    fr: {
      name: "France",
      bbox: [[-4.59235, 41.380007], [9.560016, 51.148506]]
    },
    us: {
      name: "United States",
      bbox: [[-171.791111, 18.91619], [-66.96466, 71.357764]]
    },
    ru: {
      name: "Russia",
      bbox: [[19.66064, 41.151416], [190.10042, 81.2504]]
    },
    ca: {
      name: "Canada",
      bbox: [[-140.99778, 41.675105], [-52.648099, 83.23324]]
    }
  }), H_;
}
var q_, by;
function TS() {
  if (by) return q_;
  by = 1;
  function mt(Q) {
    var de = Q.match(/\s*(.+)\s*=\s*"?([^"]+)"?/);
    return de ? {
      key: de[1],
      value: de[2]
    } : null;
  }
  function Tt(Q) {
    var de = Q.match(/<?([^>]*)>(.*)/);
    if (!de) return null;
    var q = de[1], ie = de[2].split(";"), i = null, N = ie.reduce(function(Z, R) {
      var A = mt(R);
      return A ? A.key === "rel" ? (i || (i = A.value), Z) : (Z[A.key] = A.value, Z) : Z;
    }, {});
    return i ? {
      url: q,
      rel: i,
      params: N
    } : null;
  }
  function qe(Q) {
    return Q ? Q.split(/,\s*</).reduce(function(de, q) {
      var ie = Tt(q);
      if (!ie) return de;
      var i = ie.rel.split(/\s+/);
      return i.forEach(function(N) {
        de[N] || (de[N] = {
          url: ie.url,
          params: ie.params
        });
      }), de;
    }, {}) : {};
  }
  return q_ = qe, q_;
}
var W_, wy;
function CS() {
  if (wy) return W_;
  wy = 1;
  var mt = TS();
  function Tt(qe, Q) {
    this.request = qe, this.headers = Q.headers, this.rawBody = Q.body, this.statusCode = Q.statusCode;
    try {
      this.body = JSON.parse(Q.body || "{}");
    } catch {
      this.body = Q.body;
    }
    this.links = mt(this.headers.link);
  }
  return Tt.prototype.hasNextPage = function() {
    return !!this.links.next;
  }, Tt.prototype.nextPage = function() {
    return this.hasNextPage() ? this.request._extend({
      path: this.links.next.url
    }) : null;
  }, W_ = Tt, W_;
}
var Z_, Sy;
function am() {
  return Sy || (Sy = 1, Z_ = {
    API_ORIGIN: "https://api.mapbox.com",
    EVENT_PROGRESS_DOWNLOAD: "downloadProgress",
    EVENT_PROGRESS_UPLOAD: "uploadProgress",
    EVENT_ERROR: "error",
    EVENT_RESPONSE: "response",
    ERROR_HTTP: "HttpError",
    ERROR_REQUEST_ABORTED: "RequestAbortedError"
  }), Z_;
}
var $_, Ey;
function AS() {
  if (Ey) return $_;
  Ey = 1;
  var mt = am();
  function Tt(qe) {
    var Q = qe.type || mt.ERROR_HTTP, de;
    if (qe.body)
      try {
        de = JSON.parse(qe.body);
      } catch {
        de = qe.body;
      }
    else
      de = null;
    var q = qe.message || null;
    q || (typeof de == "string" ? q = de : de && typeof de.message == "string" ? q = de.message : Q === mt.ERROR_REQUEST_ABORTED && (q = "Request aborted")), this.message = q, this.type = Q, this.statusCode = qe.statusCode || null, this.request = qe.request, this.body = de;
  }
  return $_ = Tt, $_;
}
var X_, Ty;
function MS() {
  if (Ty) return X_;
  Ty = 1;
  function mt(qe) {
    var Q = qe.indexOf(":"), de = qe.substring(0, Q).trim().toLowerCase(), q = qe.substring(Q + 1).trim();
    return {
      name: de,
      value: q
    };
  }
  function Tt(qe) {
    var Q = {};
    return qe && qe.trim().split(/[\r|\n]+/).forEach(function(de) {
      var q = mt(de);
      Q[q.name] = q.value;
    }), Q;
  }
  return X_ = Tt, X_;
}
var Y_, Cy;
function IS() {
  if (Cy) return Y_;
  Cy = 1;
  var mt = CS(), Tt = AS(), qe = am(), Q = MS(), de = {};
  function q(A) {
    var M = de[A.id];
    M && (M.abort(), delete de[A.id]);
  }
  function ie(A, M) {
    return new mt(A, {
      body: M.response,
      headers: Q(M.getAllResponseHeaders()),
      statusCode: M.status
    });
  }
  function i(A) {
    var M = A.total, x = A.loaded, m = 100 * x / M;
    return {
      total: M,
      transferred: x,
      percent: m
    };
  }
  function N(A, M) {
    return new Promise(function(x, m) {
      M.onprogress = function(E) {
        A.emitter.emit(
          qe.EVENT_PROGRESS_DOWNLOAD,
          i(E)
        );
      };
      var w = A.file;
      w && (M.upload.onprogress = function(E) {
        A.emitter.emit(
          qe.EVENT_PROGRESS_UPLOAD,
          i(E)
        );
      }), M.onerror = function(E) {
        m(E);
      }, M.onabort = function() {
        var E = new Tt({
          request: A,
          type: qe.ERROR_REQUEST_ABORTED
        });
        m(E);
      }, M.onload = function() {
        if (delete de[A.id], M.status < 200 || M.status >= 400) {
          var E = new Tt({
            request: A,
            body: M.response,
            statusCode: M.status
          });
          m(E);
          return;
        }
        x(M);
      };
      var k = A.body;
      typeof k == "string" ? M.send(k) : k ? M.send(JSON.stringify(k)) : w ? M.send(w) : M.send(), de[A.id] = M;
    }).then(function(x) {
      return ie(A, x);
    });
  }
  function Z(A, M) {
    var x = A.url(M), m = new window.XMLHttpRequest();
    return m.open(A.method, x), Object.keys(A.headers).forEach(function(w) {
      m.setRequestHeader(w, A.headers[w]);
    }), m;
  }
  function R(A) {
    return Promise.resolve().then(function() {
      var M = Z(A, A.client.accessToken);
      return N(A, M);
    });
  }
  return Y_ = {
    browserAbort: q,
    sendRequestXhr: N,
    browserSend: R,
    createRequestXhr: Z
  }, Y_;
}
var ap = { exports: {} };
/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */
var PS = ap.exports, Ay;
function RS() {
  return Ay || (Ay = 1, function(mt, Tt) {
    (function(qe) {
      var Q = Tt, de = mt.exports == Q && mt, q = typeof Qn == "object" && Qn;
      (q.global === q || q.window === q) && (qe = q);
      var ie = function(m) {
        this.message = m;
      };
      ie.prototype = new Error(), ie.prototype.name = "InvalidCharacterError";
      var i = function(m) {
        throw new ie(m);
      }, N = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Z = /[\t\n\f\r ]/g, R = function(m) {
        m = String(m).replace(Z, "");
        var w = m.length;
        w % 4 == 0 && (m = m.replace(/==?$/, ""), w = m.length), (w % 4 == 1 || // http://whatwg.org/C#alphanumeric-ascii-characters
        /[^+a-zA-Z0-9/]/.test(m)) && i(
          "Invalid character: the string to be decoded is not correctly encoded."
        );
        for (var k = 0, E, P, S = "", U = -1; ++U < w; )
          P = N.indexOf(m.charAt(U)), E = k % 4 ? E * 64 + P : P, k++ % 4 && (S += String.fromCharCode(
            255 & E >> (-2 * k & 6)
          ));
        return S;
      }, A = function(m) {
        m = String(m), /[^\0-\xFF]/.test(m) && i(
          "The string to be encoded contains characters outside of the Latin1 range."
        );
        for (var w = m.length % 3, k = "", E = -1, P, S, U, j, T = m.length - w; ++E < T; )
          P = m.charCodeAt(E) << 16, S = m.charCodeAt(++E) << 8, U = m.charCodeAt(++E), j = P + S + U, k += N.charAt(j >> 18 & 63) + N.charAt(j >> 12 & 63) + N.charAt(j >> 6 & 63) + N.charAt(j & 63);
        return w == 2 ? (P = m.charCodeAt(E) << 8, S = m.charCodeAt(++E), j = P + S, k += N.charAt(j >> 10) + N.charAt(j >> 4 & 63) + N.charAt(j << 2 & 63) + "=") : w == 1 && (j = m.charCodeAt(E), k += N.charAt(j >> 2) + N.charAt(j << 4 & 63) + "=="), k;
      }, M = {
        encode: A,
        decode: R,
        version: "0.1.0"
      };
      if (Q && !Q.nodeType)
        if (de)
          de.exports = M;
        else
          for (var x in M)
            M.hasOwnProperty(x) && (Q[x] = M[x]);
      else
        qe.base64 = M;
    })(PS);
  }(ap, ap.exports)), ap.exports;
}
var K_, My;
function ux() {
  if (My) return K_;
  My = 1;
  var mt = RS(), Tt = {};
  function qe(q) {
    if (Tt[q])
      return Tt[q];
    var ie = q.split("."), i = ie[0], N = ie[1];
    if (!N)
      throw new Error("Invalid token");
    var Z = Q(N), R = {
      usage: i,
      user: Z.u
    };
    return de(Z, "a") && (R.authorization = Z.a), de(Z, "exp") && (R.expires = Z.exp * 1e3), de(Z, "iat") && (R.created = Z.iat * 1e3), de(Z, "scopes") && (R.scopes = Z.scopes), de(Z, "client") && (R.client = Z.client), de(Z, "ll") && (R.lastLogin = Z.ll), de(Z, "iu") && (R.impersonator = Z.iu), Tt[q] = R, R;
  }
  function Q(q) {
    try {
      return JSON.parse(mt.decode(q));
    } catch {
      throw new Error("Invalid token");
    }
  }
  function de(q, ie) {
    return Object.prototype.hasOwnProperty.call(q, ie);
  }
  return K_ = qe, K_;
}
var J_ = { exports: {} }, Iy;
function kS() {
  return Iy || (Iy = 1, function(mt) {
    var Tt = Object.prototype.hasOwnProperty, qe = "~";
    function Q() {
    }
    Object.create && (Q.prototype = /* @__PURE__ */ Object.create(null), new Q().__proto__ || (qe = !1));
    function de(N, Z, R) {
      this.fn = N, this.context = Z, this.once = R || !1;
    }
    function q(N, Z, R, A, M) {
      if (typeof R != "function")
        throw new TypeError("The listener must be a function");
      var x = new de(R, A || N, M), m = qe ? qe + Z : Z;
      return N._events[m] ? N._events[m].fn ? N._events[m] = [N._events[m], x] : N._events[m].push(x) : (N._events[m] = x, N._eventsCount++), N;
    }
    function ie(N, Z) {
      --N._eventsCount === 0 ? N._events = new Q() : delete N._events[Z];
    }
    function i() {
      this._events = new Q(), this._eventsCount = 0;
    }
    i.prototype.eventNames = function() {
      var Z = [], R, A;
      if (this._eventsCount === 0) return Z;
      for (A in R = this._events)
        Tt.call(R, A) && Z.push(qe ? A.slice(1) : A);
      return Object.getOwnPropertySymbols ? Z.concat(Object.getOwnPropertySymbols(R)) : Z;
    }, i.prototype.listeners = function(Z) {
      var R = qe ? qe + Z : Z, A = this._events[R];
      if (!A) return [];
      if (A.fn) return [A.fn];
      for (var M = 0, x = A.length, m = new Array(x); M < x; M++)
        m[M] = A[M].fn;
      return m;
    }, i.prototype.listenerCount = function(Z) {
      var R = qe ? qe + Z : Z, A = this._events[R];
      return A ? A.fn ? 1 : A.length : 0;
    }, i.prototype.emit = function(Z, R, A, M, x, m) {
      var w = qe ? qe + Z : Z;
      if (!this._events[w]) return !1;
      var k = this._events[w], E = arguments.length, P, S;
      if (k.fn) {
        switch (k.once && this.removeListener(Z, k.fn, void 0, !0), E) {
          case 1:
            return k.fn.call(k.context), !0;
          case 2:
            return k.fn.call(k.context, R), !0;
          case 3:
            return k.fn.call(k.context, R, A), !0;
          case 4:
            return k.fn.call(k.context, R, A, M), !0;
          case 5:
            return k.fn.call(k.context, R, A, M, x), !0;
          case 6:
            return k.fn.call(k.context, R, A, M, x, m), !0;
        }
        for (S = 1, P = new Array(E - 1); S < E; S++)
          P[S - 1] = arguments[S];
        k.fn.apply(k.context, P);
      } else {
        var U = k.length, j;
        for (S = 0; S < U; S++)
          switch (k[S].once && this.removeListener(Z, k[S].fn, void 0, !0), E) {
            case 1:
              k[S].fn.call(k[S].context);
              break;
            case 2:
              k[S].fn.call(k[S].context, R);
              break;
            case 3:
              k[S].fn.call(k[S].context, R, A);
              break;
            case 4:
              k[S].fn.call(k[S].context, R, A, M);
              break;
            default:
              if (!P) for (j = 1, P = new Array(E - 1); j < E; j++)
                P[j - 1] = arguments[j];
              k[S].fn.apply(k[S].context, P);
          }
      }
      return !0;
    }, i.prototype.on = function(Z, R, A) {
      return q(this, Z, R, A, !1);
    }, i.prototype.once = function(Z, R, A) {
      return q(this, Z, R, A, !0);
    }, i.prototype.removeListener = function(Z, R, A, M) {
      var x = qe ? qe + Z : Z;
      if (!this._events[x]) return this;
      if (!R)
        return ie(this, x), this;
      var m = this._events[x];
      if (m.fn)
        m.fn === R && (!M || m.once) && (!A || m.context === A) && ie(this, x);
      else {
        for (var w = 0, k = [], E = m.length; w < E; w++)
          (m[w].fn !== R || M && !m[w].once || A && m[w].context !== A) && k.push(m[w]);
        k.length ? this._events[x] = k.length === 1 ? k[0] : k : ie(this, x);
      }
      return this;
    }, i.prototype.removeAllListeners = function(Z) {
      var R;
      return Z ? (R = qe ? qe + Z : Z, this._events[R] && ie(this, R)) : (this._events = new Q(), this._eventsCount = 0), this;
    }, i.prototype.off = i.prototype.removeListener, i.prototype.addListener = i.prototype.on, i.prefixed = qe, i.EventEmitter = i, mt.exports = i;
  }(J_)), J_.exports;
}
var Q_, Py;
function LS() {
  if (Py) return Q_;
  Py = 1;
  function mt(ie) {
    return ie.map(encodeURIComponent).join(",");
  }
  function Tt(ie) {
    return Array.isArray(ie) ? mt(ie) : encodeURIComponent(String(ie));
  }
  function qe(ie, i, N) {
    if (N === !1 || N === null)
      return ie;
    var Z = /\?/.test(ie) ? "&" : "?", R = encodeURIComponent(i);
    return N !== void 0 && N !== "" && N !== !0 && (R += "=" + Tt(N)), "" + ie + Z + R;
  }
  function Q(ie, i) {
    if (!i)
      return ie;
    var N = ie;
    return Object.keys(i).forEach(function(Z) {
      var R = i[Z];
      R !== void 0 && (Array.isArray(R) && (R = R.filter(function(A) {
        return A != null;
      }).join(",")), N = qe(N, Z, R));
    }), N;
  }
  function de(ie, i) {
    if (!i || ie.slice(0, 4) === "http")
      return ie;
    var N = ie[0] === "/" ? "" : "/";
    return "" + i.replace(/\/$/, "") + N + ie;
  }
  function q(ie, i) {
    return i ? ie.replace(/\/:([a-zA-Z0-9]+)/g, function(N, Z) {
      var R = i[Z];
      if (R === void 0)
        throw new Error("Unspecified route parameter " + Z);
      var A = Tt(R);
      return "/" + A;
    }) : ie;
  }
  return Q_ = {
    appendQueryObject: Q,
    appendQueryParam: qe,
    prependOrigin: de,
    interpolateRouteParams: q
  }, Q_;
}
var eg, Ry;
function OS() {
  if (Ry) return eg;
  Ry = 1;
  var mt = ux(), Tt = md(), qe = kS(), Q = LS(), de = am(), q = 1;
  function ie(i, N) {
    if (!i)
      throw new Error("MapiRequest requires a client");
    if (!N || !N.path || !N.method)
      throw new Error(
        "MapiRequest requires an options object with path and method properties"
      );
    var Z = {};
    N.body && (Z["content-type"] = "application/json");
    var R = Tt(Z, N.headers), A = Object.keys(R).reduce(function(M, x) {
      return M[x.toLowerCase()] = R[x], M;
    }, {});
    this.id = q++, this._options = N, this.emitter = new qe(), this.client = i, this.response = null, this.error = null, this.sent = !1, this.aborted = !1, this.path = N.path, this.method = N.method, this.origin = N.origin || i.origin, this.query = N.query || {}, this.params = N.params || {}, this.body = N.body || null, this.file = N.file || null, this.encoding = N.encoding || "utf8", this.sendFileAs = N.sendFileAs || null, this.headers = A;
  }
  return ie.prototype.url = function(N) {
    var Z = Q.prependOrigin(this.path, this.origin);
    Z = Q.appendQueryObject(Z, this.query);
    var R = this.params, A = N ?? this.client.accessToken;
    if (A) {
      Z = Q.appendQueryParam(Z, "access_token", A);
      var M = mt(A).user;
      R = Tt({ ownerId: M }, R);
    }
    return Z = Q.interpolateRouteParams(Z, R), Z;
  }, ie.prototype.send = function() {
    var N = this;
    if (N.sent)
      throw new Error(
        "This request has already been sent. Check the response and error properties. Create a new request with clone()."
      );
    return N.sent = !0, N.client.sendRequest(N).then(
      function(Z) {
        return N.response = Z, N.emitter.emit(de.EVENT_RESPONSE, Z), Z;
      },
      function(Z) {
        throw N.error = Z, N.emitter.emit(de.EVENT_ERROR, Z), Z;
      }
    );
  }, ie.prototype.abort = function() {
    this._nextPageRequest && (this._nextPageRequest.abort(), delete this._nextPageRequest), !(this.response || this.error || this.aborted) && (this.aborted = !0, this.client.abortRequest(this));
  }, ie.prototype.eachPage = function(N) {
    var Z = this;
    function R(x) {
      function m() {
        delete Z._nextPageRequest;
        var w = x.nextPage();
        w && (Z._nextPageRequest = w, M(w));
      }
      N(null, x, m);
    }
    function A(x) {
      N(x, null, function() {
      });
    }
    function M(x) {
      x.send().then(R, A);
    }
    M(this);
  }, ie.prototype.clone = function() {
    return this._extend();
  }, ie.prototype._extend = function(N) {
    var Z = Tt(this._options, N);
    return new ie(this.client, Z);
  }, eg = ie, eg;
}
var tg, ky;
function cx() {
  if (ky) return tg;
  ky = 1;
  var mt = ux(), Tt = OS(), qe = am();
  function Q(de) {
    if (!de || !de.accessToken)
      throw new Error("Cannot create a client without an access token");
    mt(de.accessToken), this.accessToken = de.accessToken, this.origin = de.origin || qe.API_ORIGIN;
  }
  return Q.prototype.createRequest = function(q) {
    return new Tt(this, q);
  }, tg = Q, tg;
}
var ig, Ly;
function hx() {
  if (Ly) return ig;
  Ly = 1;
  var mt = IS(), Tt = cx();
  function qe(de) {
    Tt.call(this, de);
  }
  qe.prototype = Object.create(Tt.prototype), qe.prototype.constructor = qe, qe.prototype.sendRequest = mt.browserSend, qe.prototype.abortRequest = mt.browserAbort;
  function Q(de) {
    return new qe(de);
  }
  return ig = Q, ig;
}
var rg, Oy;
function DS() {
  if (Oy) return rg;
  Oy = 1;
  var mt = hx();
  return rg = mt, rg;
}
var ng, Dy;
function zS() {
  if (Dy) return ng;
  Dy = 1;
  var mt = Object.prototype.toString;
  return ng = function(Tt) {
    var qe;
    return mt.call(Tt) === "[object Object]" && (qe = Object.getPrototypeOf(Tt), qe === null || qe === Object.getPrototypeOf({}));
  }, ng;
}
var ag, zy;
function BS() {
  if (zy) return ag;
  zy = 1;
  var mt = zS(), Tt = md(), qe = "value", Q = `
  `, de = {};
  de.assert = function(m, w) {
    return w = w || {}, function(k) {
      var E = ie(m, k);
      if (E) {
        var P = i(E, w);
        throw w.apiName && (P = w.apiName + ": " + P), new Error(P);
      }
    };
  }, de.shape = function(w) {
    var k = x(w);
    return function(P) {
      var S = ie(de.plainObject, P);
      if (S)
        return S;
      for (var U, j, T = [], W = 0; W < k.length; W++)
        U = k[W].key, j = k[W].value, S = ie(j, P[U]), S && T.push([U].concat(S));
      return T.length < 2 ? T[0] : function(J) {
        T = T.map(function(le) {
          var me = le[0], ke = i(le, J).split(`
`).join(Q);
          return "- " + me + ": " + ke;
        });
        var ee = J.path.join("."), te = ee === qe ? "" : " of " + ee;
        return "The following properties" + te + " have invalid values:" + Q + T.join(Q);
      };
    };
  }, de.strictShape = function(w) {
    var k = de.shape(w);
    return function(P) {
      var S = k(P);
      if (S)
        return S;
      var U = Object.keys(P).reduce(function(j, T) {
        return w[T] === void 0 && j.push(T), j;
      }, []);
      if (U.length !== 0)
        return function() {
          return "The following keys are invalid: " + U.join(", ");
        };
    };
  }, de.arrayOf = function(w) {
    return q(w);
  }, de.tuple = function() {
    var w = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
    return q(w);
  };
  function q(m) {
    var w = Array.isArray(m), k = function(E) {
      return w ? m[E] : m;
    };
    return function(P) {
      var S = ie(de.plainArray, P);
      if (S)
        return S;
      if (w && P.length !== m.length)
        return "an array with " + m.length + " items";
      for (var U = 0; U < P.length; U++)
        if (S = ie(k(U), P[U]), S)
          return [U].concat(S);
    };
  }
  de.required = function(w) {
    function k(E) {
      return E == null ? function(P) {
        return A(
          P,
          M(P.path) ? "cannot be undefined/null." : "is required."
        );
      } : w.apply(this, arguments);
    }
    return k.__required = !0, k;
  }, de.oneOfType = function() {
    var w = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
    return function(E) {
      var P = w.map(function(S) {
        return ie(S, E);
      }).filter(Boolean);
      if (P.length === w.length)
        return P.every(function(S) {
          return S.length === 1 && typeof S[0] == "string";
        }) ? N(
          P.map(function(S) {
            return S[0];
          })
        ) : P.reduce(function(S, U) {
          return U.length > S.length ? U : S;
        });
    };
  }, de.equal = function(w) {
    return function(E) {
      if (E !== w)
        return JSON.stringify(w);
    };
  }, de.oneOf = function() {
    var w = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments), k = w.map(function(E) {
      return de.equal(E);
    });
    return de.oneOfType.apply(this, k);
  }, de.range = function(w) {
    var k = w[0], E = w[1];
    return function(S) {
      var U = ie(de.number, S);
      if (U || S < k || S > E)
        return "number between " + k + " & " + E + " (inclusive)";
    };
  }, de.any = function() {
  }, de.boolean = function(w) {
    if (typeof w != "boolean")
      return "boolean";
  }, de.number = function(w) {
    if (typeof w != "number")
      return "number";
  }, de.plainArray = function(w) {
    if (!Array.isArray(w))
      return "array";
  }, de.plainObject = function(w) {
    if (!mt(w))
      return "object";
  }, de.string = function(w) {
    if (typeof w != "string")
      return "string";
  }, de.func = function(w) {
    if (typeof w != "function")
      return "function";
  };
  function ie(m, w) {
    if (!(w == null && !m.hasOwnProperty("__required"))) {
      var k = m(w);
      if (k)
        return Array.isArray(k) ? k : [k];
    }
  }
  function i(m, w) {
    var k = m.length, E = m[k - 1], P = m.slice(0, k - 1);
    return P.length === 0 && (P = [qe]), w = Tt(w, { path: P }), typeof E == "function" ? E(w) : A(w, Z(E));
  }
  function N(m) {
    return m.length < 2 ? m[0] : m.length === 2 ? m.join(" or ") : m.slice(0, -1).join(", ") + ", or " + m.slice(-1);
  }
  function Z(m) {
    return "must be " + R(m) + ".";
  }
  function R(m) {
    return /^an? /.test(m) ? m : /^[aeiou]/i.test(m) ? "an " + m : /^[a-z]/i.test(m) ? "a " + m : m;
  }
  function A(m, w) {
    var k = M(m.path), E = m.path.join(".") + " " + w, P = k ? "Item at position " : "";
    return P + E;
  }
  function M(m) {
    return typeof m[m.length - 1] == "number" || typeof m[0] == "number";
  }
  function x(m) {
    return Object.keys(m || {}).map(function(w) {
      return { key: w, value: m[w] };
    });
  }
  return de.validate = ie, de.processMessage = i, ag = de, ag;
}
var sg, By;
function FS() {
  if (By) return sg;
  By = 1;
  var mt = md(), Tt = BS();
  function qe(ie) {
    if (typeof window < "u")
      return ie instanceof Qn.Blob || ie instanceof Qn.ArrayBuffer ? void 0 : "Blob or ArrayBuffer";
    if (!(typeof ie == "string" || ie.pipe !== void 0))
      return "Filename or Readable stream";
  }
  function Q(ie, i) {
    return Tt.assert(Tt.strictShape(ie), i);
  }
  function de(ie) {
    var i = "date";
    if (typeof ie == "boolean")
      return i;
    try {
      var N = new Date(ie);
      if (N.getTime && isNaN(N.getTime()))
        return i;
    } catch {
      return i;
    }
  }
  function q(ie) {
    return Tt.tuple(Tt.number, Tt.number)(ie);
  }
  return sg = mt(Tt, {
    file: qe,
    date: de,
    coordinates: q,
    assertShape: Q
  }), sg;
}
var og, Fy;
function NS() {
  if (Fy) return og;
  Fy = 1;
  function mt(Tt, qe) {
    var Q = function(de, q) {
      return qe.indexOf(de) !== -1 && q !== void 0;
    };
    return typeof qe == "function" && (Q = qe), Object.keys(Tt).filter(function(de) {
      return Q(de, Tt[de]);
    }).reduce(function(de, q) {
      return de[q] = Tt[q], de;
    }, {});
  }
  return og = mt, og;
}
var lg, Ny;
function US() {
  if (Ny) return lg;
  Ny = 1;
  function mt(Tt, qe) {
    return Object.keys(Tt).reduce(function(Q, de) {
      return Q[de] = qe(de, Tt[de]), Q;
    }, {});
  }
  return lg = mt, lg;
}
var ug, Uy;
function VS() {
  if (Uy) return ug;
  Uy = 1;
  var mt = US();
  function Tt(qe) {
    return mt(qe, function(Q, de) {
      return typeof de == "boolean" ? JSON.stringify(de) : de;
    });
  }
  return ug = Tt, ug;
}
var cg, Vy;
function jS() {
  if (Vy) return cg;
  Vy = 1;
  var mt = cx(), Tt = hx();
  function qe(Q) {
    return function(de) {
      var q;
      mt.prototype.isPrototypeOf(de) ? q = de : q = Tt(de);
      var ie = Object.create(Q);
      return ie.client = q, ie;
    };
  }
  return cg = qe, cg;
}
var hg, jy;
function GS() {
  if (jy) return hg;
  jy = 1;
  var mt = md(), Tt = FS(), qe = NS(), Q = VS(), de = jS(), q = {}, ie = [
    "country",
    "region",
    "postcode",
    "district",
    "place",
    "locality",
    "neighborhood",
    "address",
    "poi",
    "poi.landmark"
  ];
  return q.forwardGeocode = function(i) {
    Tt.assertShape({
      query: Tt.required(Tt.string),
      mode: Tt.oneOf("mapbox.places", "mapbox.places-permanent"),
      countries: Tt.arrayOf(Tt.string),
      proximity: Tt.oneOf(Tt.coordinates, "ip"),
      types: Tt.arrayOf(Tt.oneOf(ie)),
      autocomplete: Tt.boolean,
      bbox: Tt.arrayOf(Tt.number),
      limit: Tt.number,
      language: Tt.arrayOf(Tt.string),
      routing: Tt.boolean,
      fuzzyMatch: Tt.boolean,
      worldview: Tt.string,
      session_token: Tt.string
    })(i), i.mode = i.mode || "mapbox.places";
    var N = Q(
      mt(
        { country: i.countries },
        qe(i, [
          "proximity",
          "types",
          "autocomplete",
          "bbox",
          "limit",
          "language",
          "routing",
          "fuzzyMatch",
          "worldview",
          "session_token"
        ])
      )
    );
    return this.client.createRequest({
      method: "GET",
      path: "/geocoding/v5/:mode/:query.json",
      params: qe(i, ["mode", "query"]),
      query: N
    });
  }, q.reverseGeocode = function(i) {
    Tt.assertShape({
      query: Tt.required(Tt.coordinates),
      mode: Tt.oneOf("mapbox.places", "mapbox.places-permanent"),
      countries: Tt.arrayOf(Tt.string),
      types: Tt.arrayOf(Tt.oneOf(ie)),
      bbox: Tt.arrayOf(Tt.number),
      limit: Tt.number,
      language: Tt.arrayOf(Tt.string),
      reverseMode: Tt.oneOf("distance", "score"),
      routing: Tt.boolean,
      worldview: Tt.string,
      session_token: Tt.string
    })(i), i.mode = i.mode || "mapbox.places";
    var N = Q(
      mt(
        { country: i.countries },
        qe(i, [
          "country",
          "types",
          "bbox",
          "limit",
          "language",
          "reverseMode",
          "routing",
          "worldview",
          "session_token"
        ])
      )
    );
    return this.client.createRequest({
      method: "GET",
      path: "/geocoding/v5/:mode/:query.json",
      params: qe(i, ["mode", "query"]),
      query: N
    });
  }, hg = de(q), hg;
}
let HS = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", fx = (mt) => crypto.getRandomValues(new Uint8Array(mt)), dx = (mt, Tt, qe) => {
  let Q = (2 << Math.log(mt.length - 1) / Math.LN2) - 1, de = -~(1.6 * Q * Tt / mt.length);
  return (q = Tt) => {
    let ie = "";
    for (; ; ) {
      let i = qe(de), N = de;
      for (; N--; )
        if (ie += mt[i[N] & Q] || "", ie.length === q) return ie;
    }
  };
}, qS = (mt, Tt = 21) => dx(mt, Tt, fx), WS = (mt = 21) => crypto.getRandomValues(new Uint8Array(mt)).reduce((Tt, qe) => (qe &= 63, qe < 36 ? Tt += qe.toString(36) : qe < 62 ? Tt += (qe - 26).toString(36).toUpperCase() : qe > 62 ? Tt += "-" : Tt += "_", Tt), "");
const ZS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  customAlphabet: qS,
  customRandom: dx,
  nanoid: WS,
  random: fx,
  urlAlphabet: HS
}, Symbol.toStringTag, { value: "Module" })), $S = /* @__PURE__ */ Xy(ZS);
var fg, Gy;
function XS() {
  if (Gy) return fg;
  Gy = 1;
  var mt = $S.nanoid;
  function Tt(qe) {
    this.origin = qe.origin || "https://api.mapbox.com", this.endpoint = "events/v2", this.access_token = qe.accessToken, this.version = "0.3.0", this.pluginSessionID = this.generateSessionID(), this.sessionIncrementer = 0, this.userAgent = this.getUserAgent(), this.options = qe, this.send = this.send.bind(this), this.countries = qe.countries ? qe.countries.split(",") : null, this.types = qe.types ? qe.types.split(",") : null, this.bbox = qe.bbox ? qe.bbox : null, this.language = qe.language ? qe.language.split(",") : null, this.limit = qe.limit ? +qe.limit : null, this.locale = navigator.language || null, this.enableEventLogging = this.shouldEnableLogging(qe), this.eventQueue = new Array(), this.flushInterval = qe.flushInterval || 1e3, this.maxQueueSize = qe.maxQueueSize || 100, this.timer = this.flushInterval ? setTimeout(this.flush.bind(this), this.flushInterval) : null, this.lastSentInput = "", this.lastSentIndex = 0;
  }
  return Tt.prototype = {
    /**
       * Send a search.select event to the mapbox events service
       * This event marks the array index of the item selected by the user out of the array of possible options
       * @private
       * @param {Object} selected the geojson feature selected by the user
       * @param {Object} geocoder a mapbox-gl-geocoder instance
       * @returns {Promise}
       */
    select: function(qe, Q) {
      var de = this.getEventPayload("search.select", Q, { selectedFeature: qe });
      if (de && !(de.resultIndex === this.lastSentIndex && de.queryString === this.lastSentInput || de.resultIndex == -1))
        return this.lastSentIndex = de.resultIndex, this.lastSentInput = de.queryString, this.push(de);
    },
    /**
       * Send a search-start event to the mapbox events service
       * This turnstile event marks when a user starts a new search
       * @private
       * @param {Object} geocoder a mapbox-gl-geocoder instance
       * @returns {Promise}
       */
    start: function(qe) {
      var Q = this.getEventPayload("search.start", qe);
      if (Q)
        return this.push(Q);
    },
    /**
     * Send a search-keyevent event to the mapbox events service
     * This event records each keypress in sequence
     * @private
     * @param {Object} keyEvent the keydown event to log
     * @param {Object} geocoder a mapbox-gl-geocoder instance
     * 
     */
    keyevent: function(qe, Q) {
      if (qe.key && !(qe.metaKey || [9, 27, 37, 39, 13, 38, 40].indexOf(qe.keyCode) !== -1)) {
        var de = this.getEventPayload("search.keystroke", Q, { key: qe.key });
        if (de)
          return this.push(de);
      }
    },
    /**
     * Send an event to the events service
     *
     * The event is skipped if the instance is not enabled to send logging events
     *
     * @private
     * @param {Object} payload the http POST body of the event
     * @param {Function} [callback] a callback function to invoke when the send has completed
     * @returns {Promise}
     */
    send: function(qe, Q) {
      if (!this.enableEventLogging)
        return Q ? Q() : void 0;
      var de = this.getRequestOptions(qe);
      this.request(de, (function(q) {
        if (q) return this.handleError(q, Q);
        if (Q)
          return Q();
      }).bind(this));
    },
    /**
     * Get http request options
     * @private
     * @param {*} payload
     */
    getRequestOptions: function(qe) {
      Array.isArray(qe) || (qe = [qe]);
      var Q = {
        // events must be sent with POST
        method: "POST",
        host: this.origin,
        path: this.endpoint + "?access_token=" + this.access_token,
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(qe)
        //events are arrays
      };
      return Q;
    },
    /**
     * Get the event payload to send to the events service
     * Most payload properties are shared across all events
     * @private
     * @param {String} event the name of the event to send to the events service. Valid options are 'search.start', 'search.select', 'search.feedback'.
     * @param {Object} geocoder a mapbox-gl-geocoder instance
     * @param {Object} eventArgs Additional arguments needed for certain event types
     * @param {Object} eventArgs.key The key pressed by the user
     * @param {Object} eventArgs.selectedFeature GeoJSON Feature selected by the user
     * @returns {Object} an event payload
     */
    getEventPayload: function(qe, Q, de = {}) {
      if (qe === "search.select" && !de.selectedFeature || qe === "search.keystroke" && !de.key)
        return null;
      var q;
      if (!Q.options.proximity)
        q = null;
      else if (typeof Q.options.proximity == "object")
        q = [Q.options.proximity.longitude, Q.options.proximity.latitude];
      else if (Q.options.proximity === "ip") {
        var ie = Q._headers ? Q._headers["ip-proximity"] : null;
        ie && typeof ie == "string" ? q = ie.split(",").map(parseFloat) : q = [999, 999];
      } else
        q = Q.options.proximity;
      var i = Q._map ? Q._map.getZoom() : void 0, N = {
        event: qe,
        version: this.getEventSchemaVersion(qe),
        created: +/* @__PURE__ */ new Date(),
        sessionIdentifier: this.getSessionId(),
        country: this.countries,
        userAgent: this.userAgent,
        language: this.language,
        bbox: this.bbox,
        types: this.types,
        endpoint: "mapbox.places",
        autocomplete: Q.options.autocomplete,
        fuzzyMatch: Q.options.fuzzyMatch,
        proximity: q,
        limit: Q.options.limit,
        routing: Q.options.routing,
        worldview: Q.options.worldview,
        mapZoom: i,
        keyboardLocale: this.locale
      };
      if (qe === "search.select" ? N.queryString = Q.inputString : qe != "search.select" && Q._inputEl ? N.queryString = Q._inputEl.value : N.queryString = Q.inputString, ["search.keystroke", "search.select"].includes(qe) && (N.path = "geocoding/v5/mapbox.places"), qe === "search.keystroke" && de.key)
        N.lastAction = de.key;
      else if (qe === "search.select" && de.selectedFeature) {
        var Z = de.selectedFeature, R = this.getSelectedIndex(Z, Q);
        if (N.resultIndex = R, N.resultPlaceName = Z.place_name, N.resultId = Z.id, Z.properties && (N.resultMapboxId = Z.properties.mapbox_id), Q._typeahead) {
          var A = Q._typeahead.data;
          A && A.length > 0 && (N.suggestionIds = this.getSuggestionIds(A), N.suggestionNames = this.getSuggestionNames(A), N.suggestionTypes = this.getSuggestionTypes(A), N.suggestionSources = this.getSuggestionSources(A));
        }
      }
      return this.validatePayload(N) ? N : null;
    },
    /**
     * Wraps the request function for easier testing
     * Make an http request and invoke a callback
     * @private
     * @param {Object} opts options describing the http request to be made
     * @param {Function} callback the callback to invoke when the http request is completed
     */
    request: function(qe, Q) {
      var de = new XMLHttpRequest();
      de.onreadystatechange = function() {
        if (this.readyState == 4)
          return this.status == 204 ? Q(null) : Q(this.statusText);
      }, de.open(qe.method, qe.host + "/" + qe.path, !0);
      for (var q in qe.headers) {
        var ie = qe.headers[q];
        de.setRequestHeader(q, ie);
      }
      de.send(qe.body);
    },
    /**
     * Handle an error that occurred while making a request
     * @param {Object} err an error instance to log
     * @private
     */
    handleError: function(qe, Q) {
      if (Q) return Q(qe);
    },
    /**
     * Generate a session ID to be returned with all of the searches made by this geocoder instance
     * ID is random and cannot be tracked across sessions
     * @private
     */
    generateSessionID: function() {
      return mt();
    },
    /**
     * Get the a unique session ID for the current plugin session and increment the session counter.
     *
     * @returns {String} The session ID
     */
    getSessionId: function() {
      return this.pluginSessionID + "." + this.sessionIncrementer;
    },
    /**
     * Get a user agent string to send with the request to the events service
     * @private
     */
    getUserAgent: function() {
      return "mapbox-gl-geocoder." + this.version + "." + navigator.userAgent;
    },
    /**
       * Get the 0-based numeric index of the item that the user selected out of the list of options
       * @private
       * @param {Object} selected the geojson feature selected by the user
       * @param {Object} geocoder a Mapbox-GL-Geocoder instance
       * @returns {Number} the index of the selected result
       */
    getSelectedIndex: function(qe, Q) {
      if (Q._typeahead) {
        var de = Q._typeahead.data, q = qe.id, ie = de.map(function(N) {
          return N.id;
        }), i = ie.indexOf(q);
        return i;
      }
    },
    getSuggestionIds: function(qe) {
      return qe.map(function(Q) {
        return Q.properties ? Q.properties.mapbox_id || "" : Q.id || "";
      });
    },
    getSuggestionNames: function(qe) {
      return qe.map(function(Q) {
        return Q.place_name || "";
      });
    },
    getSuggestionTypes: function(qe) {
      return qe.map(function(Q) {
        return Q.place_type && Array.isArray(Q.place_type) && Q.place_type[0] || "";
      });
    },
    getSuggestionSources: function(qe) {
      return qe.map(function(Q) {
        return Q._source || "";
      });
    },
    /**
     * Get the correct schema version for the event
     * @private
     * @param {String} event Name of the event
     * @returns 
     */
    getEventSchemaVersion: function(qe) {
      return ["search.keystroke", "search.select"].includes(qe) ? "2.2" : "2.0";
    },
    /**
     * Checks if a payload has all the required properties for the event type
     * @private
     * @param {Object} payload 
     * @returns 
     */
    validatePayload: function(qe) {
      if (!qe || !qe.event) return !1;
      var Q = ["event", "created", "sessionIdentifier", "queryString"], de = ["event", "created", "sessionIdentifier", "queryString", "lastAction"], q = ["event", "created", "sessionIdentifier", "queryString", "resultIndex", "path", "suggestionIds"], ie = qe.event;
      return ie === "search.start" ? this.objectHasRequiredProps(qe, Q) : ie === "search.keystroke" ? this.objectHasRequiredProps(qe, de) : ie === "search.select" ? this.objectHasRequiredProps(qe, q) : !0;
    },
    /**
     * Checks of an object has all the required properties
     * @private
     * @param {Object} obj 
     * @param {Array<String>} requiredProps 
     * @returns 
     */
    objectHasRequiredProps: function(qe, Q) {
      return Q.every(function(de) {
        return de === "queryString" ? typeof qe[de] == "string" && qe[de].length > 0 : qe[de] !== void 0;
      });
    },
    /**
       * Check whether events should be logged
       * Clients using a localGeocoder or an origin other than mapbox should not have events logged
       * @private
       */
    shouldEnableLogging: function(qe) {
      return !(qe.enableEventLogging === !1 || qe.origin && qe.origin !== "https://api.mapbox.com");
    },
    /**
     * Flush out the event queue by sending events to the events service
     * @private
     */
    flush: function() {
      this.eventQueue.length > 0 && (this.send(this.eventQueue), this.eventQueue = new Array()), this.timer && clearTimeout(this.timer), this.flushInterval && (this.timer = setTimeout(this.flush.bind(this), this.flushInterval));
    },
    /**
     * Push event into the pending queue
     * @param {Object} evt the event to send to the events service
     * @param {Boolean} forceFlush indicates that the event queue should be flushed after adding this event regardless of size of the queue
     * @private
     */
    push: function(qe, Q) {
      this.eventQueue.push(qe), (this.eventQueue.length >= this.maxQueueSize || Q) && this.flush();
    },
    /**
     * Flush any remaining events from the queue before it is removed
     * @private
     */
    remove: function() {
      this.flush();
    }
  }, fg = Tt, fg;
}
var dg, Hy;
function YS() {
  if (Hy) return dg;
  Hy = 1;
  var mt = {
    // list drawn from https://docs.mapbox.com/api/search/#language-coverage
    de: "Suche",
    // german
    it: "Ricerca",
    //italian
    en: "Search",
    // english
    nl: "Zoeken",
    //dutch
    fr: "Chercher",
    //french
    ca: "Cerca",
    //catalan
    he: "",
    //hebrew
    ja: "",
    //japanese
    lv: "Meklt",
    //latvian
    pt: "Procurar",
    //portuguese 
    sr: "",
    //serbian
    zh: "",
    //chinese-simplified
    cs: "Vyhledvn",
    //czech
    hu: "Keress",
    //hungarian
    ka: "",
    // georgian
    nb: "Ske",
    //norwegian
    sk: "Vyhadvanie",
    //slovak
    th: "",
    //thai
    fi: "Hae",
    //finnish
    is: "Leita",
    //icelandic
    ko: "",
    //korean
    pl: "Szukaj",
    //polish
    sl: "Iskanje",
    //slovenian
    fa: "",
    //persian(aka farsi)
    ru: ""
    //russian
  };
  return dg = { placeholder: mt }, dg;
}
var Kp = { exports: {} }, KS = Kp.exports, qy;
function JS() {
  return qy || (qy = 1, function(mt) {
    (function(Tt, qe, Q) {
      mt.exports ? mt.exports = Q() : Tt[qe] = Q();
    })(KS, "subtag", function() {
      var Tt = "", qe = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
      function Q(N) {
        return N.match(qe) || [];
      }
      function de(N) {
        return Q(N).filter(function(Z, R) {
          return Z && R;
        });
      }
      function q(N) {
        return N = Q(N), {
          language: N[1] || Tt,
          extlang: N[2] || Tt,
          script: N[3] || Tt,
          region: N[4] || Tt
        };
      }
      function ie(N, Z, R) {
        Object.defineProperty(N, Z, {
          value: R,
          enumerable: !0
        });
      }
      function i(N, Z, R) {
        function A(M) {
          return Q(M)[N] || Tt;
        }
        ie(A, "pattern", Z), ie(q, R, A);
      }
      return i(1, /^[a-zA-Z]{2,3}$/, "language"), i(2, /^[a-zA-Z]{3}$/, "extlang"), i(3, /^[a-zA-Z]{4}$/, "script"), i(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region"), ie(q, "split", de), q;
    });
  }(Kp)), Kp.exports;
}
var pg, Wy;
function QS() {
  if (Wy) return pg;
  Wy = 1;
  function mt() {
  }
  return mt.prototype = {
    isSupport: function() {
      return !!window.navigator.geolocation;
    },
    getCurrentPosition: function() {
      const Tt = {
        enableHighAccuracy: !0
      };
      return new Promise(function(qe, Q) {
        window.navigator.geolocation.getCurrentPosition(qe, Q, Tt);
      });
    }
  }, pg = mt, pg;
}
var mg, Zy;
function eE() {
  if (Zy) return mg;
  Zy = 1;
  function mt(Q, de) {
    const q = Tt(Q), ie = ["address", "street", "place", "country"];
    var i;
    if (typeof de == "function")
      return de(q);
    const N = ie.indexOf(de);
    return N === -1 ? i = ie : i = ie.slice(N), i.reduce(function(Z, R) {
      return q[R] ? (Z !== "" && (Z = Z + ", "), Z + q[R]) : Z;
    }, "");
  }
  function Tt(Q) {
    const de = Q.address || "", q = Q.text || "", ie = Q.place_name || "", N = {
      address: ie.split(",")[0],
      houseNumber: de,
      street: q,
      placeName: ie
    };
    return Q.context.forEach(function(Z) {
      const R = Z.id.split(".")[0];
      N[R] = Z.text;
    }), N;
  }
  return mg = {
    transformFeatureToGeolocationText: mt,
    getAddressInfo: Tt,
    REVERSE_GEOCODE_COORD_RGX: /^[ ]*(-?\d{1,3}(\.\d{0,256})?)[, ]+(-?\d{1,3}(\.\d{0,256})?)[ ]*$/
  }, mg;
}
var _g, $y;
function tE() {
  if ($y) return _g;
  $y = 1;
  var mt = bS(), Tt = wS(), qe = md(), Q = SS().EventEmitter, de = ES(), q = DS(), ie = GS(), i = XS(), N = YS(), Z = JS(), R = QS(), A = eE();
  const M = {
    FORWARD: 0,
    LOCAL: 1,
    REVERSE: 2
  };
  function x() {
    var w = document.createElement("div");
    return w.className = "mapboxgl-ctrl-geocoder--powered-by", w.innerHTML = '<a href="https://www.mapbox.com/search-service" target="_blank">Powered by Mapbox</a>', w;
  }
  function m(w) {
    this._eventEmitter = new Q(), this.options = qe({}, this.options, w), this.inputString = "", this.fresh = !0, this.lastSelected = null, this.geolocation = new R();
  }
  return m.prototype = {
    options: {
      zoom: 16,
      flyTo: !0,
      trackProximity: !0,
      minLength: 2,
      reverseGeocode: !1,
      flipCoordinates: !1,
      limit: 5,
      origin: "https://api.mapbox.com",
      enableEventLogging: !0,
      marker: !0,
      mapboxgl: null,
      collapsed: !1,
      clearAndBlurOnEsc: !1,
      clearOnBlur: !1,
      enableGeolocation: !1,
      addressAccuracy: "street",
      getItemValue: function(w) {
        return w.place_name;
      },
      render: function(w) {
        var k = w.place_name.split(",");
        return '<div class="mapboxgl-ctrl-geocoder--suggestion"><div class="mapboxgl-ctrl-geocoder--suggestion-title">' + k[0] + '</div><div class="mapboxgl-ctrl-geocoder--suggestion-address">' + k.splice(1, k.length).join(",") + "</div></div>";
      }
    },
    _headers: {},
    /**
     * Add the geocoder to a container. The container can be either a `mapboxgl.Map`, an `HTMLElement` or a CSS selector string.
     *
     * If the container is a [`mapboxgl.Map`](https://docs.mapbox.com/mapbox-gl-js/api/map/), this function will behave identically to [`Map.addControl(geocoder)`](https://docs.mapbox.com/mapbox-gl-js/api/map/#map#addcontrol).
     * If the container is an instance of [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), then the geocoder will be appended as a child of that [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
     * If the container is a [CSS selector string](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors), the geocoder will be appended to the element returned from the query.
     *
     * This function will throw an error if the container is none of the above.
     * It will also throw an error if the referenced HTML element cannot be found in the `document.body`.
     *
     * For example, if the HTML body contains the element `<div id='geocoder-container'></div>`, the following script will append the geocoder to `#geocoder-container`:
     *
     * ```javascript
     * var geocoder = new MapboxGeocoder({ accessToken: mapboxgl.accessToken });
     * geocoder.addTo('#geocoder-container');
     * ```
     * @param {String|HTMLElement|mapboxgl.Map} container A reference to the container to which to add the geocoder
     */
    addTo: function(w) {
      function k(E, P) {
        if (!document.body.contains(P))
          throw new Error("Element provided to #addTo() exists, but is not in the DOM");
        const S = E.onAdd();
        P.appendChild(S);
      }
      if (w._controlContainer)
        w.addControl(this);
      else if (w instanceof HTMLElement)
        k(this, w);
      else if (typeof w == "string") {
        const E = document.querySelectorAll(w);
        if (E.length === 0)
          throw new Error("Element ", w, "not found.");
        if (E.length > 1)
          throw new Error("Geocoder can only be added to a single html element");
        k(this, E[0]);
      } else
        throw new Error("Error: addTo must be a mapbox-gl-js map, an html element, or a CSS selector query for a single html element");
    },
    onAdd: function(w) {
      if (w && typeof w != "string" && (this._map = w), this.setLanguage(), this.options.localGeocoderOnly || (this.geocoderService = ie(
        q({
          accessToken: this.options.accessToken,
          origin: this.options.origin
        })
      )), this.options.localGeocoderOnly && !this.options.localGeocoder)
        throw new Error("A localGeocoder function must be specified to use localGeocoderOnly mode");
      this.eventManager = new i(this.options), this._onChange = this._onChange.bind(this), this._onKeyDown = this._onKeyDown.bind(this), this._onPaste = this._onPaste.bind(this), this._onBlur = this._onBlur.bind(this), this._showButton = this._showButton.bind(this), this._hideButton = this._hideButton.bind(this), this._onQueryResult = this._onQueryResult.bind(this), this.clear = this.clear.bind(this), this._updateProximity = this._updateProximity.bind(this), this._collapse = this._collapse.bind(this), this._unCollapse = this._unCollapse.bind(this), this._clear = this._clear.bind(this), this._clearOnBlur = this._clearOnBlur.bind(this), this._geolocateUser = this._geolocateUser.bind(this);
      var k = this.container = document.createElement("div");
      k.className = "mapboxgl-ctrl-geocoder mapboxgl-ctrl";
      var E = this.createIcon("search", '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>');
      this._inputEl = document.createElement("input"), this._inputEl.type = "text", this._inputEl.className = "mapboxgl-ctrl-geocoder--input", this.setPlaceholder(), this.options.collapsed && (this._collapse(), this.container.addEventListener("mouseenter", this._unCollapse), this.container.addEventListener("mouseleave", this._collapse), this._inputEl.addEventListener("focus", this._unCollapse)), (this.options.collapsed || this.options.clearOnBlur) && this._inputEl.addEventListener("blur", this._onBlur), this._inputEl.addEventListener("keydown", Tt(this._onKeyDown, 200)), this._inputEl.addEventListener("paste", this._onPaste), this._inputEl.addEventListener("change", this._onChange), this.container.addEventListener("mouseenter", this._showButton), this.container.addEventListener("mouseleave", this._hideButton), this._inputEl.addEventListener("keyup", (function(J) {
        this.eventManager.keyevent(J, this);
      }).bind(this));
      var P = document.createElement("div");
      P.classList.add("mapboxgl-ctrl-geocoder--pin-right"), this._clearEl = document.createElement("button"), this._clearEl.setAttribute("aria-label", "Clear"), this._clearEl.addEventListener("click", this.clear), this._clearEl.className = "mapboxgl-ctrl-geocoder--button";
      var S = this.createIcon("close", '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>');
      if (this._clearEl.appendChild(S), this._loadingEl = this.createIcon("loading", '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>'), P.appendChild(this._clearEl), P.appendChild(this._loadingEl), k.appendChild(E), k.appendChild(this._inputEl), k.appendChild(P), this.options.enableGeolocation && this.geolocation.isSupport()) {
        this._geolocateEl = document.createElement("button"), this._geolocateEl.setAttribute("aria-label", "Geolocate"), this._geolocateEl.addEventListener("click", this._geolocateUser), this._geolocateEl.className = "mapboxgl-ctrl-geocoder--button";
        var U = this.createIcon("geolocate", '<path d="M12.999 3.677L2.042 8.269c-.962.403-.747 1.823.29 1.912l5.032.431.431 5.033c.089 1.037 1.509 1.252 1.912.29l4.592-10.957c.345-.822-.477-1.644-1.299-1.299z" fill="#4264fb"/>');
        this._geolocateEl.appendChild(U), P.appendChild(this._geolocateEl), this._showGeolocateButton();
      }
      var j = this._typeahead = new mt(this._inputEl, [], {
        filter: !1,
        minLength: this.options.minLength,
        limit: this.options.limit
      });
      this.setRenderFunction(this.options.render), j.getItemValue = this.options.getItemValue;
      var T = j.list.draw, W = this._footerNode = x();
      return j.list.draw = function() {
        T.call(this), W.addEventListener("mousedown", (function() {
          this.selectingListItem = !0;
        }).bind(this)), W.addEventListener("mouseup", (function() {
          this.selectingListItem = !1;
        }).bind(this)), this.element.appendChild(W);
      }, this.mapMarker = null, this._handleMarker = this._handleMarker.bind(this), this._map && (this.options.trackProximity && (this._updateProximity(), this._map.on("moveend", this._updateProximity)), this._mapboxgl = this.options.mapboxgl, !this._mapboxgl && this.options.marker && (console.error("No mapboxgl detected in options. Map markers are disabled. Please set options.mapboxgl."), this.options.marker = !1)), k;
    },
    _geolocateUser: function() {
      this._hideGeolocateButton(), this._showLoadingIcon(), this.geolocation.getCurrentPosition().then((function(w) {
        this._hideLoadingIcon();
        const k = {
          geometry: {
            type: "Point",
            coordinates: [w.coords.longitude, w.coords.latitude]
          }
        };
        this._handleMarker(k), this._fly(k), this._typeahead.clear(), this._typeahead.selected = !0, this.lastSelected = JSON.stringify(k), this._showClearButton(), this.fresh = !1;
        const E = {
          limit: 1,
          language: [this.options.language],
          query: k.geometry.coordinates,
          types: ["address"]
        };
        if (this.options.localGeocoderOnly) {
          const P = k.geometry.coordinates[0] + "," + k.geometry.coordinates[1];
          this._setInputValue(P), this._eventEmitter.emit("result", { result: k });
        } else
          this.geocoderService.reverseGeocode(E).send().then((function(P) {
            const S = P.body.features[0];
            if (S) {
              const U = A.transformFeatureToGeolocationText(S, this.options.addressAccuracy);
              this._setInputValue(U), S.user_coordinates = k.geometry.coordinates, this._eventEmitter.emit("result", { result: S });
            } else
              this._eventEmitter.emit("result", { result: { user_coordinates: k.geometry.coordinates } });
          }).bind(this));
      }).bind(this)).catch((function(w) {
        w.code === 1 ? this._renderUserDeniedGeolocationError() : this._renderLocationError(), this._hideLoadingIcon(), this._showGeolocateButton(), this._hideAttribution();
      }).bind(this));
    },
    createIcon: function(w, k) {
      var E = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      return E.setAttribute("class", "mapboxgl-ctrl-geocoder--icon mapboxgl-ctrl-geocoder--icon-" + w), E.setAttribute("viewBox", "0 0 18 18"), E.setAttribute("xml:space", "preserve"), E.setAttribute("width", 18), E.setAttribute("height", 18), E.innerHTML = k, E;
    },
    onRemove: function() {
      return this.container.parentNode.removeChild(this.container), this.options.trackProximity && this._map && this._map.off("moveend", this._updateProximity), this._removeMarker(), this._map = null, this;
    },
    _setInputValue: function(w) {
      this._inputEl.value = w, setTimeout((function() {
        this._inputEl.focus(), this._inputEl.scrollLeft = 0, this._inputEl.setSelectionRange(0, 0);
      }).bind(this), 1);
    },
    _onPaste: function(w) {
      var k = (w.clipboardData || window.clipboardData).getData("text");
      k.length >= this.options.minLength && this._geocode(k);
    },
    _onKeyDown: function(w) {
      var k = 27, E = 9;
      if (w.keyCode === k && this.options.clearAndBlurOnEsc)
        return this._clear(w), this._inputEl.blur();
      var P = w.target && w.target.shadowRoot ? w.target.shadowRoot.activeElement : w.target, S = P ? P.value : "";
      if (!S)
        return this.fresh = !0, w.keyCode !== E && this.clear(w), this._showGeolocateButton(), this._hideClearButton();
      this._hideGeolocateButton(), !(w.metaKey || [E, k, 37, 39, 13, 38, 40].indexOf(w.keyCode) !== -1) && P.value.length >= this.options.minLength && this._geocode(P.value);
    },
    _showButton: function() {
      this._typeahead.selected && this._showClearButton();
    },
    _hideButton: function() {
      this._typeahead.selected && this._hideClearButton();
    },
    _showClearButton: function() {
      this._clearEl.style.display = "block";
    },
    _hideClearButton: function() {
      this._clearEl.style.display = "none";
    },
    _showGeolocateButton: function() {
      this._geolocateEl && this.geolocation.isSupport() && (this._geolocateEl.style.display = "block");
    },
    _hideGeolocateButton: function() {
      this._geolocateEl && (this._geolocateEl.style.display = "none");
    },
    _showLoadingIcon: function() {
      this._loadingEl.style.display = "block";
    },
    _hideLoadingIcon: function() {
      this._loadingEl.style.display = "none";
    },
    _showAttribution: function() {
      this._footerNode.style.display = "block";
    },
    _hideAttribution: function() {
      this._footerNode.style.display = "none";
    },
    _onBlur: function(w) {
      this.options.clearOnBlur && this._clearOnBlur(w), this.options.collapsed && this._collapse();
    },
    _onChange: function() {
      var w = this._typeahead.selected;
      w && JSON.stringify(w) !== this.lastSelected && (this._hideClearButton(), this.options.flyTo && this._fly(w), this.options.marker && this._mapboxgl && this._handleMarker(w), this._inputEl.focus(), this._inputEl.scrollLeft = 0, this._inputEl.setSelectionRange(0, 0), this.lastSelected = JSON.stringify(w), this._eventEmitter.emit("result", { result: w }), this.eventManager.select(w, this));
    },
    _fly: function(w) {
      var k;
      if (w.properties && de[w.properties.short_code])
        k = qe({}, this.options.flyTo), this._map && this._map.fitBounds(de[w.properties.short_code].bbox, k);
      else if (w.bbox) {
        var E = w.bbox;
        k = qe({}, this.options.flyTo), this._map && this._map.fitBounds([[E[0], E[1]], [E[2], E[3]]], k);
      } else {
        var P = {
          zoom: this.options.zoom
        };
        k = qe({}, P, this.options.flyTo), w.center ? k.center = w.center : w.geometry && w.geometry.type && w.geometry.type === "Point" && w.geometry.coordinates && (k.center = w.geometry.coordinates), this._map && this._map.flyTo(k);
      }
    },
    _requestType: function(w, k) {
      var E;
      return w.localGeocoderOnly ? E = M.LOCAL : w.reverseGeocode && A.REVERSE_GEOCODE_COORD_RGX.test(k) ? E = M.REVERSE : E = M.FORWARD, E;
    },
    _setupConfig: function(w, k) {
      const E = [
        "bbox",
        "limit",
        "proximity",
        "countries",
        "types",
        "language",
        "reverseMode",
        "mode",
        "autocomplete",
        "fuzzyMatch",
        "routing",
        "worldview"
      ], P = /[\s,]+/;
      var S = this, U = E.reduce(function(T, W) {
        if (S.options[W] === void 0 || S.options[W] === null)
          return T;
        ["countries", "types", "language"].indexOf(W) > -1 ? T[W] = S.options[W].split(P) : T[W] = S.options[W];
        const J = typeof S.options[W].longitude == "number" && typeof S.options[W].latitude == "number";
        if (W === "proximity" && J) {
          const ee = S.options[W].longitude, te = S.options[W].latitude;
          T[W] = [ee, te];
        }
        return T;
      }, {});
      switch (w) {
        case M.REVERSE:
          {
            var j = k.split(P).map(function(T) {
              return parseFloat(T, 10);
            });
            S.options.flipCoordinates || j.reverse(), U.types && U.types[0], U = qe(U, { query: j, limit: 1 }), ["proximity", "autocomplete", "fuzzyMatch", "bbox"].forEach(function(T) {
              T in U && delete U[T];
            });
          }
          break;
        case M.FORWARD:
          {
            const T = k.trim();
            /^(-?\d{1,3}(\.\d{0,256})?)[, ]+(-?\d{1,3}(\.\d{0,256})?)?$/.test(T) && (k = k.replace(/,/g, " ")), U = qe(U, { query: k });
          }
          break;
      }
      return U.session_token = this.eventManager.getSessionId(), U;
    },
    _geocode: function(w) {
      this.inputString = w, this._showLoadingIcon(), this._eventEmitter.emit("loading", { query: w });
      const k = this._requestType(this.options, w), E = this._setupConfig(k, w);
      var P;
      switch (k) {
        case M.LOCAL:
          P = Promise.resolve();
          break;
        case M.FORWARD:
          P = this.geocoderService.forwardGeocode(E).send();
          break;
        case M.REVERSE:
          P = this.geocoderService.reverseGeocode(E).send();
          break;
      }
      var S = this.options.localGeocoder ? this.options.localGeocoder(w) || [] : [], U = [], j = null;
      return P.catch((function(T) {
        j = T;
      }).bind(this)).then(
        (function(T) {
          this._hideLoadingIcon();
          var W = {};
          return T ? T.statusCode == "200" && (W = T.body, W.request = T.request, W.headers = T.headers, this._headers = T.headers) : W = {
            type: "FeatureCollection",
            features: []
          }, W.config = E, this.fresh && (this.eventManager.start(this), this.fresh = !1), W.features && W.features.length && W.features.map(function(J) {
            J._source = "mapbox";
          }), W.features = W.features ? S.concat(W.features) : S, this.options.externalGeocoder ? (U = this.options.externalGeocoder(w, W.features) || Promise.resolve([]), U.then(function(J) {
            return W.features = W.features ? J.concat(W.features) : J, W;
          }, function() {
            return W;
          })) : W;
        }).bind(this)
      ).then(
        (function(T) {
          if (j)
            throw j;
          this.options.filter && T.features.length && (T.features = T.features.filter(this.options.filter)), T.features.length ? (this._showClearButton(), this._hideGeolocateButton(), this._showAttribution(), this._eventEmitter.emit("results", T), this._typeahead.update(T.features)) : (this._hideClearButton(), this._hideAttribution(), this._typeahead.selected = null, this._renderNoResults(), this._eventEmitter.emit("results", T));
        }).bind(this)
      ).catch(
        (function(T) {
          this._hideLoadingIcon(), this._hideAttribution(), S.length && this.options.localGeocoder || U.length && this.options.externalGeocoder ? (this._showClearButton(), this._hideGeolocateButton(), this._typeahead.update(S)) : (this._hideClearButton(), this._typeahead.selected = null, this._renderError()), this._eventEmitter.emit("results", { features: S }), this._eventEmitter.emit("error", { error: T });
        }).bind(this)
      ), P;
    },
    /**
     * Shared logic for clearing input
     * @param {Event} [ev] the event that triggered the clear, if available
     * @private
     *
     */
    _clear: function(w) {
      w && w.preventDefault(), this._inputEl.value = "", this._typeahead.selected = null, this._typeahead.clear(), this.eventManager.sessionIncrementer++, this._onChange(), this._hideClearButton(), this._showGeolocateButton(), this._removeMarker(), this.lastSelected = null, this._eventEmitter.emit("clear"), this.fresh = !0;
    },
    /**
     * Clear and then focus the input.
     * @param {Event} [ev] the event that triggered the clear, if available
     *
     */
    clear: function(w) {
      this._clear(w), this._inputEl.focus();
    },
    /**
     * Clear the input, without refocusing it. Used to implement clearOnBlur
     * constructor option.
     * @param {Event} [ev] the blur event
     * @private
     */
    _clearOnBlur: function(w) {
      var k = this;
      w.relatedTarget && k._clear(w);
    },
    _onQueryResult: function(w) {
      var k = w.body;
      if (k.features.length) {
        var E = k.features[0];
        this._typeahead.selected = E, this._inputEl.value = E.place_name, this._onChange();
      }
    },
    _updateProximity: function() {
      if (!(!this._map || !this.options.trackProximity))
        if (this._map.getZoom() > 9) {
          var w = this._map.getCenter().wrap();
          this.setProximity({ longitude: w.lng, latitude: w.lat }, !1);
        } else
          this.setProximity(null, !1);
    },
    _collapse: function() {
      !this._inputEl.value && this._inputEl !== document.activeElement && this.container.classList.add("mapboxgl-ctrl-geocoder--collapsed");
    },
    _unCollapse: function() {
      this.container.classList.remove("mapboxgl-ctrl-geocoder--collapsed");
    },
    /**
     * Set & query the input
     * @param {string} searchInput location name or other search input
     * @returns {MapboxGeocoder} this
     */
    query: function(w) {
      return this._geocode(w).then(this._onQueryResult), this;
    },
    _renderError: function() {
      var w = "<div class='mapbox-gl-geocoder--error'>There was an error reaching the server</div>";
      this._renderMessage(w);
    },
    _renderLocationError: function() {
      var w = "<div class='mapbox-gl-geocoder--error'>A location error has occurred</div>";
      this._renderMessage(w);
    },
    _renderNoResults: function() {
      var w = "<div class='mapbox-gl-geocoder--error mapbox-gl-geocoder--no-results'>No results found</div>";
      this._renderMessage(w);
    },
    _renderUserDeniedGeolocationError: function() {
      var w = "<div class='mapbox-gl-geocoder--error'>Geolocation permission denied</div>";
      this._renderMessage(w);
    },
    _renderMessage: function(w) {
      this._typeahead.update([]), this._typeahead.selected = null, this._typeahead.clear(), this._typeahead.renderError(w);
    },
    /**
     * Get the text to use as the search bar placeholder
     *
     * If placeholder is provided in options, then use options.placeholder
     * Otherwise, if language is provided in options, then use the localized string of the first language if available
     * Otherwise use the default
     *
     * @returns {String} the value to use as the search bar placeholder
     * @private
     */
    _getPlaceholderText: function() {
      if (this.options.placeholder) return this.options.placeholder;
      if (this.options.language) {
        var w = this.options.language.split(",")[0], k = Z.language(w), E = N.placeholder[k];
        if (E) return E;
      }
      return "Search";
    },
    /**
     * Set input
     * @param {string} searchInput location name or other search input
     * @param {boolean} [showSuggestions=false] display suggestion on setInput call
     * @returns {MapboxGeocoder} this
     */
    setInput: function(w, k) {
      return k === void 0 && (k = !1), this._inputEl.value = w, this._typeahead.selected = null, this._typeahead.clear(), w.length >= this.options.minLength && (k ? this._geocode(w) : this._onChange()), this;
    },
    /**
     * Set proximity
     * @param {Object|'ip'} proximity The new `options.proximity` value. This is a geographical point given as an object with `latitude` and `longitude` properties or the string 'ip'.
     * @param {Boolean} disableTrackProximity If true, sets `trackProximity` to false. True by default to prevent `trackProximity` from unintentionally overriding an explicitly set proximity value.
     * @returns {MapboxGeocoder} this
     */
    setProximity: function(w, k = !0) {
      return this.options.proximity = w, k && (this.options.trackProximity = !1), this;
    },
    /**
     * Get proximity
     * @returns {Object} The geocoder proximity
     */
    getProximity: function() {
      return this.options.proximity;
    },
    /**
     * Set the render function used in the results dropdown
     * @param {Function} fn The function to use as a render function. This function accepts a single [extended GeoJSON](https://docs.mapbox.com/api/search/geocoding-v5/#geocoding-response-object) object as input and returns a string.
     * @returns {MapboxGeocoder} this
     */
    setRenderFunction: function(w) {
      return w && typeof w == "function" && (this._typeahead.render = w), this;
    },
    /**
     * Get the function used to render the results dropdown
     *
     * @returns {Function} the render function
     */
    getRenderFunction: function() {
      return this._typeahead.render;
    },
    /**
     * Get the language to use in UI elements and when making search requests
     *
     * Look first at the explicitly set options otherwise use the browser's language settings
     * @param {String} language Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas.
     * @returns {MapboxGeocoder} this
     */
    setLanguage: function(w) {
      var k = navigator.language || navigator.userLanguage || navigator.browserLanguage;
      return this.options.language = w || this.options.language || k, this;
    },
    /**
     * Get the language to use in UI elements and when making search requests
     * @returns {String} The language(s) used by the plugin, if any
     */
    getLanguage: function() {
      return this.options.language;
    },
    /**
     * Get the zoom level the map will move to when there is no bounding box on the selected result
     * @returns {Number} the map zoom
     */
    getZoom: function() {
      return this.options.zoom;
    },
    /**
     * Set the zoom level
     * @param {Number} zoom The zoom level that the map should animate to when a `bbox` isn't found in the response. If a `bbox` is found the map will fit to the `bbox`.
     * @returns {MapboxGeocoder} this
     */
    setZoom: function(w) {
      return this.options.zoom = w, this;
    },
    /**
     * Get the parameters used to fly to the selected response, if any
     * @returns {Boolean|Object} The `flyTo` option
     */
    getFlyTo: function() {
      return this.options.flyTo;
    },
    /**
     * Set the flyTo options
     * @param {Boolean|Object} flyTo If false, animating the map to a selected result is disabled. If true, animating the map will use the default animation parameters. If an object, it will be passed as `options` to the map [`flyTo`](https://docs.mapbox.com/mapbox-gl-js/api/#map#flyto) or [`fitBounds`](https://docs.mapbox.com/mapbox-gl-js/api/#map#fitbounds) method providing control over the animation of the transition.
     */
    setFlyTo: function(w) {
      return this.options.flyTo = w, this;
    },
    /**
     * Get the value of the placeholder string
     * @returns {String} The input element's placeholder value
     */
    getPlaceholder: function() {
      return this.options.placeholder;
    },
    /**
     * Set the value of the input element's placeholder
     * @param {String} placeholder the text to use as the input element's placeholder
     * @returns {MapboxGeocoder} this
     */
    setPlaceholder: function(w) {
      return this.options.placeholder = w || this._getPlaceholderText(), this._inputEl.placeholder = this.options.placeholder, this._inputEl.setAttribute("aria-label", this.options.placeholder), this;
    },
    /**
     * Get the bounding box used by the plugin
     * @returns {Array<Number>} the bounding box, if any
     */
    getBbox: function() {
      return this.options.bbox;
    },
    /**
     * Set the bounding box to limit search results to
     * @param {Array<Number>} bbox a bounding box given as an array in the format [minX, minY, maxX, maxY].
     * @returns {MapboxGeocoder} this
     */
    setBbox: function(w) {
      return this.options.bbox = w, this;
    },
    /**
     * Get a list of the countries to limit search results to
     * @returns {String} a comma separated list of countries to limit to, if any
     */
    getCountries: function() {
      return this.options.countries;
    },
    /**
     * Set the countries to limit search results to
     * @param {String} countries a comma separated list of countries to limit to
     * @returns {MapboxGeocoder} this
     */
    setCountries: function(w) {
      return this.options.countries = w, this;
    },
    /**
     * Get a list of the types to limit search results to
     * @returns {String} a comma separated list of types to limit to
     */
    getTypes: function() {
      return this.options.types;
    },
    /**
     * Set the types to limit search results to
     * @param {String} countries a comma separated list of types to limit to
     * @returns {MapboxGeocoder} this
     */
    setTypes: function(w) {
      return this.options.types = w, this;
    },
    /**
     * Get the minimum number of characters typed to trigger results used in the plugin
     * @returns {Number} The minimum length in characters before a search is triggered
     */
    getMinLength: function() {
      return this.options.minLength;
    },
    /**
     * Set the minimum number of characters typed to trigger results used by the plugin
     * @param {Number} minLength the minimum length in characters
     * @returns {MapboxGeocoder} this
     */
    setMinLength: function(w) {
      return this.options.minLength = w, this._typeahead && (this._typeahead.options.minLength = w), this;
    },
    /**
     * Get the limit value for the number of results to display used by the plugin
     * @returns {Number} The limit value for the number of results to display used by the plugin
     */
    getLimit: function() {
      return this.options.limit;
    },
    /**
     * Set the limit value for the number of results to display used by the plugin
     * @param {Number} limit the number of search results to return
     * @returns {MapboxGeocoder}
     */
    setLimit: function(w) {
      return this.options.limit = w, this._typeahead && (this._typeahead.options.limit = w), this;
    },
    /**
     * Get the filter function used by the plugin
     * @returns {Function} the filter function
     */
    getFilter: function() {
      return this.options.filter;
    },
    /**
     * Set the filter function used by the plugin.
     * @param {Function} filter A function which accepts a Feature in the [extended GeoJSON](https://docs.mapbox.com/api/search/geocoding-v5/#geocoding-response-object) format to filter out results from the Geocoding API response before they are included in the suggestions list. Return `true` to keep the item, `false` otherwise.
     * @returns {MapboxGeocoder} this
     */
    setFilter: function(w) {
      return this.options.filter = w, this;
    },
    /**
     * Set the geocoding endpoint used by the plugin.
     * @param {Function} origin A function which accepts an HTTPS URL to specify the endpoint to query results from.
     * @returns {MapboxGeocoder} this
     */
    setOrigin: function(w) {
      return this.options.origin = w, this.geocoderService = ie(
        q({
          accessToken: this.options.accessToken,
          origin: this.options.origin
        })
      ), this;
    },
    /**
     * Get the geocoding endpoint the plugin is currently set to
     * @returns {Function} the endpoint URL
     */
    getOrigin: function() {
      return this.options.origin;
    },
    /**
     * Set the accessToken option used for the geocoding request endpoint.
     * @param {String} accessToken value
     * @returns {MapboxGeocoder} this
     */
    setAccessToken: function(w) {
      return this.options.accessToken = w, this.geocoderService = ie(
        q({
          accessToken: this.options.accessToken,
          origin: this.options.origin
        })
      ), this;
    },
    /**
     * Set the autocomplete option used for geocoding requests
     * @param {Boolean} value The boolean value to set autocomplete to
     * @returns
     */
    setAutocomplete: function(w) {
      return this.options.autocomplete = w, this;
    },
    /**
     * Get the current autocomplete parameter value used for requests
     * @returns {Boolean} The autocomplete parameter value
     */
    getAutocomplete: function() {
      return this.options.autocomplete;
    },
    /**
     * Set the fuzzyMatch option used for approximate matching in geocoding requests
     * @param {Boolean} value The boolean value to set fuzzyMatch to
     * @returns
     */
    setFuzzyMatch: function(w) {
      return this.options.fuzzyMatch = w, this;
    },
    /**
     * Get the current fuzzyMatch parameter value used for requests
     * @returns {Boolean} The fuzzyMatch parameter value
     */
    getFuzzyMatch: function() {
      return this.options.fuzzyMatch;
    },
    /**
     * Set the routing parameter used to ask for routable point metadata in geocoding requests
     * @param {Boolean} value The boolean value to set routing to
     * @returns
     */
    setRouting: function(w) {
      return this.options.routing = w, this;
    },
    /**
     * Get the current routing parameter value used for requests
     * @returns {Boolean} The routing parameter value
     */
    getRouting: function() {
      return this.options.routing;
    },
    /**
     * Set the worldview parameter
     * @param {String} code The country code representing the worldview (e.g. "us" | "cn" | "jp", "in")
     * @returns
     */
    setWorldview: function(w) {
      return this.options.worldview = w, this;
    },
    /**
     * Get the current worldview parameter value used for requests
     * @returns {String} The worldview parameter value
     */
    getWorldview: function() {
      return this.options.worldview;
    },
    /**
     * Handle the placement of a result marking the selected result
     * @private
     * @param {Object} selected the selected geojson feature
     * @returns {MapboxGeocoder} this
     */
    _handleMarker: function(w) {
      if (this._map) {
        this._removeMarker();
        var k = {
          color: "#4668F2"
        }, E = qe({}, k, this.options.marker);
        return this.mapMarker = new this._mapboxgl.Marker(E), w.center ? this.mapMarker.setLngLat(w.center).addTo(this._map) : w.geometry && w.geometry.type && w.geometry.type === "Point" && w.geometry.coordinates && this.mapMarker.setLngLat(w.geometry.coordinates).addTo(this._map), this;
      }
    },
    /**
     * Handle the removal of a result marker
     * @private
     */
    _removeMarker: function() {
      this.mapMarker && (this.mapMarker.remove(), this.mapMarker = null);
    },
    /**
     * Subscribe to events that happen within the plugin.
     * @param {String} type name of event. Available events and the data passed into their respective event objects are:
     *
     * - __clear__ `Emitted when the input is cleared`
     * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
     * - __results__ `{ results } Fired when the geocoder returns a response`
     * - __result__ `{ result } Fired when input is set`
     * - __error__ `{ error } Error as string`
     * @param {Function} fn function that's called when the event is emitted.
     * @returns {MapboxGeocoder} this;
     */
    on: function(w, k) {
      return this._eventEmitter.on(w, k), this;
    },
    /**
     * Remove an event
     * @returns {MapboxGeocoder} this
     * @param {String} type Event name.
     * @param {Function} fn Function that should unsubscribe to the event emitted.
     */
    off: function(w, k) {
      return this._eventEmitter.removeListener(w, k), this.eventManager.remove(), this;
    }
  }, _g = m, _g;
}
var iE = tE();
const rE = /* @__PURE__ */ dd(iE), nE = ({ currentVariant: mt }) => {
  var j, T, W, J;
  const [Tt, qe] = _a.useState("none"), Q = Pf.useRef(null), de = Pf.useRef(null), q = pd(), i = tm().filter((ee) => {
    var te;
    return ee.field_type === "custom" && ((te = ee.slug) == null ? void 0 : te.includes("capture-"));
  }), N = ((j = q.variant_metafields[mt.id]) == null ? void 0 : j.metal) || "", [Z, R] = _a.useState(N), [A, M] = _a.useState(null), [x, m] = _a.useState(null), [w, k] = _a.useState(null), E = (T = q.variant_metafields[mt.id]) == null ? void 0 : T.shape;
  _a.useEffect(() => {
    var te;
    const ee = ((te = q.variant_metafields[mt.id]) == null ? void 0 : te.metal) || "";
    R(ee);
  }, [mt, q]), _a.useEffect(() => {
    document.querySelectorAll('form[action="/cart/add"]').forEach((te) => {
      te.querySelectorAll('button[type="submit"]').forEach((me) => {
        me.disabled = !0;
      });
    });
  }, []);
  const P = Pf.useRef(null), [S, U] = Pf.useState({ x: 0, y: 0 });
  return Pf.useEffect(() => {
    var le, me;
    const ee = ((le = P.current) == null ? void 0 : le.offsetWidth) / 2 - $h[E].width / 2, te = ((me = P.current) == null ? void 0 : me.offsetHeight) / 2 - $h[E].height / 2;
    U({ x: ee, y: te });
  }, []), Pf.useEffect(() => {
    ip.accessToken = "pk.eyJ1IjoiYWxla3NoaW5lb24iLCJhIjoiY202ejZiYjZxMDFnZjJrcXM3b2F4OTI1ZiJ9.OuSSAJIvxBUncZsIa4f9dg", document.querySelector(".map-overlay svg").getBoundingClientRect(), de.current = new ip.Map({
      container: Q.current,
      preserveDrawingBuffer: !0,
      style: {
        version: 8,
        sources: {
          "mapbox-streets": {
            type: "vector",
            url: "mapbox://mapbox.mapbox-streets-v8"
          }
        },
        layers: [
          {
            id: "background",
            type: "background",
            paint: {
              "background-color": "#ffffff"
            }
          },
          {
            id: "water",
            type: "fill",
            source: "mapbox-streets",
            "source-layer": "water",
            paint: {
              "fill-color": "#82b8ff"
            }
          },
          {
            id: "parks",
            type: "fill",
            source: "mapbox-streets",
            "source-layer": "landuse",
            filter: ["==", "class", "park"],
            paint: {
              "fill-color": "#91d891"
            }
          },
          {
            id: "road-network",
            type: "line",
            source: "mapbox-streets",
            "source-layer": "road",
            filter: [
              "in",
              "class",
              "motorway",
              "trunk",
              "primary",
              "secondary",
              "tertiary",
              "street",
              "street_limited",
              "residential"
            ],
            paint: {
              "line-color": "#222222",
              "line-width": [
                "match",
                ["get", "class"],
                "motorway",
                2,
                "trunk",
                1.5,
                "primary",
                1,
                "secondary",
                0.8,
                "tertiary",
                0.6,
                "street",
                0.5,
                "street_limited",
                0.4,
                "residential",
                0.3,
                0.3
              ]
            }
          }
        ]
      },
      center: [-74.006, 40.7128],
      zoom: 12
    });
    const te = new rE({
      accessToken: ip.accessToken,
      mapboxgl: ip,
      marker: !1,
      placeholder: "Enter address to search"
    });
    return de.current.addControl(te, "top-left"), () => de.current.remove();
  }, []), /* @__PURE__ */ Dr.jsx(Dr.Fragment, { children: /* @__PURE__ */ Dr.jsxs("div", { className: "so-tw", children: [
    /* @__PURE__ */ Dr.jsxs("div", { className: "map-container", children: [
      /* @__PURE__ */ Dr.jsx("div", { ref: Q, className: "map" }),
      /* @__PURE__ */ Dr.jsx("div", { className: "map-overlay", ref: P, children: /* @__PURE__ */ Dr.jsxs("svg", { width: "100%", height: "100%", children: [
        /* @__PURE__ */ Dr.jsx("defs", { children: /* @__PURE__ */ Dr.jsxs("mask", { id: "shape-mask", children: [
          /* @__PURE__ */ Dr.jsx("rect", { width: "100%", height: "100%", fill: $h[E].fillColor }),
          /* @__PURE__ */ Dr.jsx("g", { transform: `translate(${S.x}, ${S.y})`, children: /* @__PURE__ */ Dr.jsx("path", { d: $h[E].svg_d, fill: "black" }) })
        ] }) }),
        /* @__PURE__ */ Dr.jsx(
          "rect",
          {
            width: "100%",
            height: "100%",
            fill: $h[E].fillColor,
            mask: "url(#shape-mask)"
          }
        ),
        /* @__PURE__ */ Dr.jsx(
          "g",
          {
            className: `metal-${Z}-border`,
            transform: `translate(${S.x}, ${S.y})`,
            children: /* @__PURE__ */ Dr.jsx(
              "path",
              {
                d: $h[E].svg_border,
                strokeWidth: $h[E].svg_border_width
              }
            )
          }
        )
      ] }) }),
      /* @__PURE__ */ Dr.jsx(V1, { renderInMap: !0, selectedType: Tt, metalType: Z })
    ] }),
    /* @__PURE__ */ Dr.jsx(
      V1,
      {
        renderInMap: !1,
        selectedType: Tt,
        onMarkerChange: qe,
        metalType: Z
      }
    ),
    A && /* @__PURE__ */ Dr.jsx(
      gS,
      {
        previewContent: A,
        previewType: w,
        width: ((W = P.current) == null ? void 0 : W.offsetWidth) + "px",
        height: ((J = P.current) == null ? void 0 : J.offsetHeight) + "px",
        currentVariant: mt,
        customFields: x
      }
    ),
    /* @__PURE__ */ Dr.jsx("div", { className: "button-row", children: i.map(
      (ee) => ee.slug === "capture-image" ? /* @__PURE__ */ Dr.jsx(
        o2,
        {
          map: de,
          setPreviewContent: M,
          setPreviewType: k,
          setCustomFields: m,
          cf: ee
        }
      ) : ee.slug === "capture-vector" ? /* @__PURE__ */ Dr.jsx(
        S2,
        {
          map: de,
          metalType: Z,
          currentVariant: mt,
          setPreviewContent: M,
          setPreviewType: k,
          setCustomFields: m,
          selectedMarker: Tt,
          cf: ee,
          shape: E
        }
      ) : null
    ) })
  ] }) });
}, gg = [
  {
    type: "birthstone"
  },
  {
    type: "heart"
  }
], aE = ({
  formId: mt,
  availableAccessories: Tt,
  currentVariant: qe,
  InputField: Q,
  selectedAccessories: de,
  setSelectedAccessories: q,
  accessoriesCF: ie
}) => {
  const { state: i, dispatch: N } = _a.useContext(Tg), Z = pd(), R = tm(), [A, M] = _a.useState([]), x = _a.useMemo(
    () => {
      var S;
      return ((S = Z.variant_metafields[qe.id]) == null ? void 0 : S.engravings) || 0;
    },
    [qe.id, Z.variant_metafields]
  ), m = _a.useMemo(
    () => R.filter(
      (S) => S.field_type === "engraving" && de.some((U) => {
        var j;
        return (j = S.class) == null ? void 0 : j.includes(U.type);
      })
    ),
    [R, de]
  ), w = (S, U) => {
    if (de.length >= x) return;
    const j = { type: S, option: U };
    q([...de, j]), P(!1);
    const T = de.length;
    document.querySelectorAll('form[action="/cart/add"]').forEach((J) => {
      const ee = document.createElement("input");
      ee.type = "hidden", ee.name = `properties[${ie[T].name}]`, ee.value = U, J.appendChild(ee);
    });
  }, k = (S, U) => {
    document.querySelectorAll('form[action="/cart/add"]').forEach((W) => {
      const J = W.querySelector(`input[name="properties[${U}]"]`);
      J && J.type === "hidden" && J.remove();
      const ee = W.querySelector(`input[name="properties[${ie[S].name}]"]`);
      ee && ee.remove(), Array.from(W.querySelectorAll('input[name^="properties[Birthstone"]')).forEach((le, me) => {
        me >= S && (le.name = `properties[${ie[me].name}]`);
      });
    });
    const T = [];
    m.slice(0, de.length).map((W, J) => {
      const ee = W.name, te = document.querySelector(`input[name="properties[${ee}]"]`);
      U !== ee && T.push({
        name: ee,
        value: te.value
      });
    }), M(T), q((W) => W.filter((J, ee) => ee !== S));
  };
  _a.useEffect(() => i2(() => {
    var T;
    const j = ((T = Z.variant_metafields[qe.id]) == null ? void 0 : T.engravings) || 0;
    de.length > j && q((W) => W.slice(0, j));
  }), []), _a.useEffect(() => {
    var U;
    const S = ((U = Z.variant_metafields[qe.id]) == null ? void 0 : U.engravings) || 0;
    q((j) => j.slice(0, S));
  }, [qe]);
  const [E, P] = _a.useState(!1);
  return _a.useEffect(() => {
    const S = document.querySelectorAll('form[action="/cart/add"]');
    m.slice(0, de.length).map((j, T) => {
      const W = j.name, J = document.querySelector(`input[name="properties[${W}]"]`);
      A[T] && (J && (J.value = A[T].value), S.forEach((ee) => {
        const te = ee.querySelector(`input[name="properties[${W}]"]`), le = ee.querySelector(
          `input[name="properties[${A[T].name}]"]`
        );
        le && (te == null ? void 0 : te.type) === "hidden" && (le.name = `properties[${W}]`);
      }), M([]));
    });
    const U = (j) => {
      de.length < x && (j.preventDefault(), P(!0));
    };
    return S.forEach((j) => {
      const T = j.querySelector('button[type="submit"]');
      T && T.addEventListener("click", U);
    }), () => {
      S.forEach((j) => {
        const T = j.querySelector('button[type="submit"]');
        T && T.removeEventListener("click", U);
      });
    };
  }, [de, x]), /* @__PURE__ */ Dr.jsxs("div", { className: "so-accessories", children: [
    Tt.map((S) => /* @__PURE__ */ Dr.jsxs(
      "div",
      {
        className: `so-${S.field_type}-container ${E && de.length < x ? "so-validation-error" : ""}`,
        children: [
          /* @__PURE__ */ Dr.jsx("div", { className: "so-counter-wrap", children: /* @__PURE__ */ Dr.jsxs("span", { children: [
            "Selected: ",
            de.length,
            " of ",
            x
          ] }) }),
          /* @__PURE__ */ Dr.jsx("div", { className: "so-options-grid", children: /* @__PURE__ */ Dr.jsx("ul", { className: "so-accessories-list", children: S.options.map((U) => {
            var j;
            return /* @__PURE__ */ Dr.jsxs("li", { children: [
              /* @__PURE__ */ Dr.jsx(
                "input",
                {
                  type: "radio",
                  name: S.name,
                  value: U,
                  required: de.length < x,
                  style: { position: "absolute", opacity: 0 },
                  checked: de.some((T) => T.option === U),
                  onChange: () => w(S.field_type, U)
                }
              ),
              /* @__PURE__ */ Dr.jsxs(
                "label",
                {
                  className: "so-accessory-option",
                  onClick: () => w(S.field_type, U),
                  "aria-disabled": de.length >= x,
                  children: [
                    S.field_type === "birthstone" && /* @__PURE__ */ Dr.jsx(
                      "div",
                      {
                        className: `so-custom-field-birthstone-circle ${U} no-loop ${(j = S.class) != null && j.includes("engraving") ? "no-loop" : ""}`,
                        children: /* @__PURE__ */ Dr.jsx("span", { class: "visually-hidden", children: U })
                      }
                    ),
                    /* @__PURE__ */ Dr.jsx("span", { children: U })
                  ]
                }
              )
            ] }, U);
          }) }) })
        ]
      },
      S.field_type
    )),
    de.length > 0 && /* @__PURE__ */ Dr.jsx("div", { className: "so-engraving-fields-container", children: m.slice(0, de.length).map((S, U) => {
      const j = de[U], T = S.name;
      return /* @__PURE__ */ Dr.jsxs("div", { className: "so-input-with-remove", children: [
        /* @__PURE__ */ Dr.jsx(
          "button",
          {
            type: "button",
            className: "so-remove-acc",
            onClick: () => k(U, T),
            children: /* @__PURE__ */ Dr.jsx(
              "svg",
              {
                width: "14",
                height: "14",
                viewBox: "0 0 14 14",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                children: /* @__PURE__ */ Dr.jsx(
                  "path",
                  {
                    d: "M13 1L1 13M1 1L13 13",
                    stroke: "currentColor",
                    strokeWidth: "2",
                    strokeLinecap: "round"
                  }
                )
              }
            )
          }
        ),
        /* @__PURE__ */ Dr.jsx(
          Q,
          {
            product_cf: {
              ...S,
              name: T,
              placeholder: `${S.label} ${j.option}`
            },
            required: S.required,
            formId: mt,
            dispatch: N,
            index: U,
            productInfo: Z,
            currentVariant: qe,
            selectedAccessories: de,
            setSelectedAccessories: q
          }
        )
      ] });
    }) })
  ] });
}, Tg = _a.createContext(), sE = (mt, Tt) => {
  switch (Tt.type) {
    case "UPDATE_SYMBOL_COUNT":
      return {
        ...mt,
        symbolCounts: {
          ...mt.symbolCounts,
          [Tt.payload.id]: Tt.payload.count
        }
      };
    case "SET_ERROR":
      return {
        ...mt,
        showNotification: Tt.payload.show,
        errorSymbol: Tt.payload.symbol
      };
    case "RESET_SYMBOL_COUNTS":
      return {
        ...mt,
        symbolCounts: {}
      };
    default:
      return mt;
  }
}, vg = _a.memo(
  ({ product_cf: mt, required: Tt, formId: qe, dispatch: Q, fontPreviewConfig: de, currentVariant: q, productInfo: ie }) => {
    var T;
    const { state: i } = _a.useContext(Tg), [N, Z] = _a.useState(""), R = window.Shopify.locale, A = ((T = ie.variant_metafields[q.id]) == null ? void 0 : T.metal) || "silver", M = (W) => {
      const J = mt.pattern;
      J && (new RegExp(J).test(W.data) ? Q({
        type: "SET_ERROR",
        payload: { show: !1, symbol: "" }
      }) : (W.preventDefault(), Q({
        type: "SET_ERROR",
        payload: { show: !0, symbol: W.data }
      })));
    }, x = (W) => {
      document.querySelectorAll('form[action="/cart/add"]').forEach((ee) => {
        let te = ee.querySelector(`input[name="${W.name}"]`);
        te || (te = document.createElement("input"), te.type = "hidden", te.name = W.name, ee.appendChild(te)), te.value = W.value;
      });
    }, [m, w] = _a.useState({}), k = async (W) => {
      const J = document.querySelectorAll('.so-hyper input[type="text"]'), ee = {};
      J.forEach((te) => {
        te.required && !te.value.length && (ee[te.name] = !0, W.preventDefault());
      }), w(ee);
    }, E = (W) => {
      w((le) => ({
        ...le,
        [W.target.name]: !1
      }));
      const J = W.target.value.charAt(0).toUpperCase() + W.target.value.slice(1);
      W.target.value = J, Z(J);
      const ee = document.querySelectorAll('.so-hyper input[type="text"]');
      let te = !1;
      ee.forEach((le) => {
        le.required && !le.value.length && (te = !0);
      }), te && P(), Q({
        type: "UPDATE_SYMBOL_COUNT",
        payload: { id: mt.id.key, count: W.target.value.length }
      }), t2(() => {
        x(W.target);
      });
    };
    _a.useEffect(() => {
      const W = document.querySelectorAll('form[action="/cart/add"]');
      return W.forEach((J) => {
        const ee = J.querySelector('button[type="submit"]');
        ee && ee.addEventListener("click", k);
      }), () => {
        W.forEach((J) => {
          const ee = J.querySelector('button[type="submit"]');
          ee && ee.removeEventListener("click", k);
        });
      };
    }, []);
    const P = () => {
      document.querySelectorAll('form[action="/cart/add"]').forEach((J) => {
        const ee = J.querySelector('button[type="submit"]');
        if (ee) {
          const te = ee.parentElement;
          te.classList.add("shopify-payment-button");
          const le = document.createElement("div");
          le.className = "so-validation-mask", te.appendChild(le), le.addEventListener("click", (me) => {
            const ke = document.querySelectorAll('.so-hyper input[type="text"]');
            let ge = !0;
            ke.forEach((Ve) => {
              Ve.required && !Ve.value.length && (ge = !1);
            }), ge ? (le.remove(), ee.click()) : k(me);
          });
        }
      });
    };
    _a.useEffect(() => (P(), () => {
      document.querySelectorAll(".so-validation-mask").forEach((W) => W.remove());
    }), []);
    const S = (W) => (document.querySelectorAll('.so-hyper input[type="text"][required]').forEach((ee) => {
      Object.keys(W).some((te) => te === ee.name) || (W[ee.name] = ee.value);
    }), W), U = "/cart/add.js", j = () => {
      const W = window.XMLHttpRequest;
      window.XMLHttpRequest = function() {
        const ee = new W(), te = ee.send;
        ee.send = function(me) {
          if (this._url && this._url.includes(U)) {
            const ke = new URLSearchParams(me), ge = {};
            ke.forEach((Oe, Ue) => {
              ge[Ue] = Oe;
            });
            const Ve = S(ge);
            return me = new URLSearchParams(Ve).toString(), te.apply(this, [me]);
          }
          return te.apply(this, [me]);
        };
        const le = ee.open;
        return ee.open = function(me, ke) {
          return this._url = ke, le.apply(this, arguments);
        }, ee;
      };
      const J = window.fetch;
      if (window.fetch = function(ee, te) {
        if (ee.includes(U)) {
          const le = new URLSearchParams(te.body), me = {};
          le.forEach((ge, Ve) => {
            me[Ve] = ge;
          });
          const ke = S(me);
          return te.body = new URLSearchParams(ke).toString(), J.apply(this, [ee, te]);
        }
        return J.apply(this, arguments);
      }, window.jQuery) {
        const ee = window.jQuery.ajax;
        window.jQuery.ajax = function(te, le) {
          if (typeof te == "string" && te.includes(U)) {
            const me = new URLSearchParams(le.data), ke = {};
            me.forEach((Ve, Oe) => {
              ke[Oe] = Ve;
            });
            const ge = S(ke);
            return window.jQuery.ajax({
              ...le,
              url: te,
              data: new URLSearchParams(ge).toString()
            });
          }
          return ee.apply(this, arguments);
        };
      }
    };
    return _a.useEffect(() => {
      j();
    }, []), /* @__PURE__ */ Dr.jsxs("div", { className: `so-field-wrapper ${m[`properties[${mt.name}]`] ? "error" : ""}`, children: [
      /* @__PURE__ */ Dr.jsx("label", { className: "so-form__label", children: mt.name }),
      /* @__PURE__ */ Dr.jsxs("div", { className: "so-field", children: [
        /* @__PURE__ */ Dr.jsxs("div", { className: "so-input-counter-w", children: [
          /* @__PURE__ */ Dr.jsx(
            r2,
            {
              product_cf: mt,
              required: Tt,
              formId: qe,
              onBeforeInput: M,
              onChange: E
            }
          ),
          i.showNotification && /* @__PURE__ */ Dr.jsx("span", { className: "so-wrong-input-notification", children: `"${i.errorSymbol}"${Jw[R].errors.invalid_character}` }),
          !i.showNotification && /* @__PURE__ */ Dr.jsxs(
            "span",
            {
              className: `so-counter ${i.symbolCounts[mt.id.key] ? "so-input-filled" : ""}`,
              children: [
                i.symbolCounts[mt.id.key] || 0,
                "/",
                mt.maxlength || 20
              ]
            }
          )
        ] }),
        (de == null ? void 0 : de.fields.length) > 0 && /* @__PURE__ */ Dr.jsx("div", { className: "font-preview-w", "data-metal": A, children: /* @__PURE__ */ Dr.jsx("div", { className: `preview ${de.fields[0].class}`, children: /* @__PURE__ */ Dr.jsx("span", { className: "colored-with-gradient", children: (N || mt.name) + (de.symbolAtEnd.length > 0 ? de.symbolAtEnd[0].options[0].code : "") }) }) })
      ] })
    ] });
  }
), oE = () => {
  var w;
  const mt = pd(), Tt = tm(), qe = mt.shop_info.sectionID ? "product-form-" + mt.shop_info.sectionID : Qw(), [Q, de] = _a.useState(e2()), [q, ie] = _a.useState([]), [i, N] = _a.useReducer(sE, {
    symbolCounts: {},
    showNotification: !1,
    errorSymbol: ""
  });
  _a.useEffect(() => {
    const k = (S) => {
      de(
        mt.product.variants.filter(
          (U) => U.id === parseInt(document.querySelector('[name="id"]').value)
        )[0]
      );
    }, E = mt.trigger_selector ? mt.trigger_selector : mt.variant_id_input, P = document.querySelectorAll(E);
    return P.forEach((S) => S.addEventListener("change", k)), () => {
      P.forEach((S) => S.removeEventListener("change", k));
    };
  }, []);
  const Z = Tt.filter(
    (k) => k.field_type === "engraving" && k.required && !gg.some((E) => {
      var P;
      return (P = k.class) == null ? void 0 : P.includes(E.type);
    })
  ), R = Tt.filter(
    (k) => k.field_type === "engraving" && !k.required && !gg.some((E) => {
      var P;
      return (P = k.class) == null ? void 0 : P.includes(E.type);
    })
  ).slice(0, ((w = mt.variant_metafields[Q.id]) == null ? void 0 : w.engravings) || 0), A = Tt.filter((k) => gg.some((E) => k.field_type === E.type)), M = Tt.filter((k) => k.field_type === "custom" && k.type != "none"), x = {
    fields: Tt.filter(
      (k) => {
        var E;
        return k.field_type === "custom" && ((E = k.slug) == null ? void 0 : E.includes("font-family-preview"));
      }
    ),
    symbolAtEnd: Tt.filter(
      (k) => {
        var E;
        return k.field_type === "custom" && ((E = k.class) == null ? void 0 : E.includes("symbol-at-the-end"));
      }
    )
  }, m = Tt.filter((k) => {
    var E;
    return k.field_type === "custom" && ((E = k.slug) == null ? void 0 : E.includes("capture-"));
  });
  return /* @__PURE__ */ Dr.jsxs(Tg.Provider, { value: { state: i, dispatch: N }, children: [
    /* @__PURE__ */ Dr.jsxs("div", { className: "so-hyper so-tw", children: [
      Z.map((k, E) => /* @__PURE__ */ Dr.jsx(
        vg,
        {
          product_cf: k,
          required: !0,
          formId: qe,
          dispatch: N,
          fontPreviewConfig: x,
          currentVariant: Q,
          productInfo: mt
        },
        `required-${E}`
      )),
      R.map((k, E) => /* @__PURE__ */ Dr.jsx(
        vg,
        {
          product_cf: k,
          required: !0,
          formId: qe,
          dispatch: N,
          currentVariant: Q,
          productInfo: mt
        },
        `optional-${E}`
      )),
      A.length > 0 && /* @__PURE__ */ Dr.jsx(
        aE,
        {
          formId: qe,
          availableAccessories: A,
          currentVariant: Q,
          InputField: vg,
          selectedAccessories: q,
          setSelectedAccessories: ie,
          accessoriesCF: M,
          productInfo: mt
        }
      )
    ] }),
    (m == null ? void 0 : m.length) > 0 && /* @__PURE__ */ Dr.jsx(nE, { currentVariant: Q })
  ] });
};
document.addEventListener("DOMContentLoaded", () => {
  const mt = document.getElementById("so-hyper");
  mt && Yw.createRoot(mt).render(
    /* @__PURE__ */ Dr.jsx(_a.StrictMode, { children: /* @__PURE__ */ Dr.jsx(oE, {}) })
  );
});
